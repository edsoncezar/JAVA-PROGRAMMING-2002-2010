<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 12</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000></FONT><FONT SIZE=5 COLOR=#FF0000>Portable Software and the </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.lang</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Package</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheObjectandClassClasses" >The Object and Class Classes</A>
<UL>
<LI><A HREF="#Object" >Object</A>
<LI><A HREF="#Class" >Class</A>
<LI><A HREF="#ATouchofClass" >A Touch of Class</A>
</UL>
<LI><A HREF="#TheClassLoaderSecurityManagerandRu" >The ClassLoader, SecurityManager, and Runtime Classes</A>
<UL>
<LI><A HREF="#ClassLoader" >ClassLoader</A>
<LI><A HREF="#SecurityManager" >SecurityManager</A>
<LI><A HREF="#Runtime" >Runtime</A>
</UL>
<LI><A HREF="#TheSystemClass" >The System Class</A>
<UL>
<LI><A HREF="#PropertyRelatedMethods" >Property-Related Methods</A>
<LI><A HREF="#SecurityManagerRelatedMethods" >Security Manager-Related Methods</A>
<LI><A HREF="#RuntimeRelatedMethods" >Runtime-Related Methods</A>
<LI><A HREF="#OddsandEnds" >Odds and Ends</A>
<LI><A HREF="#TimeandProperties" >Time and Properties</A>
</UL>
<LI><A HREF="#WrappedClasses" >Wrapped Classes</A>
<UL>
<LI><A HREF="#TheBooleanClass" >The Boolean Class</A>
<LI><A HREF="#TheCharacterClass" >The Character Class</A>
<LI><A HREF="#TheIntegerandLongClasses" >The Integer and Long Classes</A>
<LI><A HREF="#TheDoubleandFloatClasses" >The Double and Float Classes</A>
<LI><A HREF="#TheNumberClass" >The Number Class</A>
<LI><A HREF="#AllWrappedUp" >All Wrapped Up</A>
</UL>
<LI><A HREF="#TheMathClass" >The Math Class</A>
<LI><A HREF="#TheStringandStringBufferClasses" >The String and StringBuffer Classes</A>
<UL>
<LI><A HREF="#StringLiterals" >String Literals</A>
<LI><A HREF="#TheOperatorandStringBuffer" >The + Operator and StringBuffer</A>
<LI><A HREF="#StringConstructors" >String Constructors</A>
<LI><A HREF="#StringAccessMethods" >String Access Methods</A>
<LI><A HREF="#TheStringBufferClass" >The StringBuffer Class</A>
</UL>
<LI><A HREF="#ThreadsandProcesses" >Threads and Processes</A>
<UL>
<LI><A HREF="#Runnable" >Runnable</A>
<LI><A HREF="#Thread" >Thread</A>
<LI><A HREF="#ThreadGroup" >ThreadGroup</A>
<LI><A HREF="#Process" >Process</A>
<LI><A HREF="#HelloAgain" >Hello Again</A>
</UL>
<LI><A HREF="#TheCompilerClass" >The Compiler Class</A>
<LI><A HREF="#ExceptionsandErrors" >Exceptions and Errors</A>
<UL>
<LI><A HREF="#TheThrowableClass" >The Throwable Class</A>
<LI><A HREF="#TheErrorClass" >The Error Class</A>
<LI><A HREF="#TheExceptionClass" >The Exception Class</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>In this  you'll learn how to use the </FONT><TT>java.lang</TT>
package. This package contains the core API classes of the JDK.
It includes the <TT>Object</TT> class, which is the top class
in the Java class hierarchy, and the <TT>Class</TT> class, which
provides runtime class information for all Java objects. You'll
learn about classes that control the operation of the Java runtime
system and about the all-important <TT>System</TT> class. You'll
also learn how &quot;wrapped&quot; classes are used to convert
primitive data types into usable objects. By the time you have
completed this , you will have been introduced to all the classes
contained in the <TT>java.lang</TT> package.<BR>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=578>
<BLOCKQUOTE>
The objective of this part of the book is to familiarize you with each of the packages of the Java API. In order to make the best use of these s, you should browse through the pages of the API User's Guide that discuss each of the classes as they are covered here.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheObjectandClassClasses"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Object</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Class</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
<TT>Object</TT> and <TT>Class</TT> are two of the most important
classes in the Java API. The <TT>Object</TT> class is at the top
of the Java class hierarchy. All classes are subclasses of <TT>Object</TT>
and therefore inherit its methods. The <TT>Class</TT> class is
used to provide class descriptors for all objects created during
Java program execution.
<H3><A NAME="Object"><TT><B><FONT SIZE=4 FACE="Courier New">Object</FONT></B></TT></A>
</H3>
<P>
The <TT>Object</TT> class does not have any variables and has
only one constructor. However, it provides 11 methods that are
inherited by all Java classes and that support general operations
that are used with all objects. For example, the <TT>equals()</TT>
and <TT>hashCode()</TT> methods are used to construct hash tables
of Java objects. <I>Hash tables</I> are like arrays, but they
are indexed by key values and dynamically grow in size. They make
use of <I>hash functions</I> to quickly access the data that they
contain. The <TT>hashCode()</TT> method creates a <I>hash code</I>
for an object. Hash codes are used to quickly determine whether
two objects are different. You learn more about hash tables in
<A HREF="ch14.htm" >Chapter 14</A>, &quot;Useful Tools in the
<TT>java.util</TT> Package.&quot;
<P>
The <TT>clone()</TT> method creates an identical copy of an object.
The object must implement the <TT>Cloneable</TT> interface. This
interface is defined within the <TT>java.lang</TT> package. It
contains no methods and is used only to differentiate cloneable
from noncloneable classes.
<P>
The <TT>getClass()</TT> method identifies the class of an object
by returning an object of <TT>Class</TT>. You'll learn how to
use this method in the next programming example. (See the &quot;A
Touch of Class&quot; section.)
<P>
The <TT>toString()</TT> method creates a <TT>String</TT> representation
of the value of an object. This method is handy for quickly displaying
the contents of an object. When an object is displayed, using
<TT>print()</TT> or <TT>println()</TT>, the <TT>toString()</TT>
method of its class is automatically called to convert the object
into a string before printing. Classes that override the <TT>toString()</TT>
method can easily provide a custom display for their objects.
<P>
The <TT>finalize()</TT> method of an object is executed when an
object is garbage-collected. The method performs no action, by
default, and needs to be overridden by any class that requires
specialized finalization processing.
<P>
The <TT>Object</TT> class provides three <TT>wait()</TT> and two
<TT>notify()</TT> methods that support thread control. These methods
are implemented by the <TT>Object</TT> class so that they can
be made available to threads that are not created from subclasses
of class <TT>Thread</TT>. The <TT>wait()</TT> methods cause a
thread to wait until it is notified or until a specified amount
of time has elapsed. The <TT>notify()</TT> methods are used to
notify waiting threads that their wait is over.
<H3><A NAME="Class"><TT><B><FONT SIZE=4 FACE="Courier New">Class</FONT></B></TT></A>
</H3>
<P>
The <TT>Class</TT> class provides eight methods that support the
runtime processing of an object's class and interface information.
This class does not have a constructor. Objects of this class,
referred to as <I>class descriptors</I>, are automatically created
and associated with the objects to which they refer. Despite their
name, class descriptors are used for interfaces as well as classes.
<P>
The <TT>getName()</TT> and <TT>toString()</TT> methods return
the <TT>String</TT> containing the name of a class or interface.
The <TT>toString()</TT> method differs in that it prepends the
string <TT>class</TT> or <TT>interface</TT>, depending on whether
the class descriptor is a class or an interface. The static <TT>forName()</TT>
method is used to obtain a class descriptor for the class specified
by a <TT>String</TT> object.
<P>
The <TT>getSuperclass()</TT> method returns the class descriptor
of the superclass of a class. The <TT>isInterface()</TT> method
identifies whether a class descriptor applies to a class or an
interface. The <TT>getInterface()</TT> method returns an array
of <TT>Class</TT> objects that specify the interfaces of a class,
if any.
<P>
The <TT>newInstance()</TT> method creates an object that is a
new instance of the specified class. It can be used in lieu of
a class's constructor, although it is generally safer and clearer
to use a constructor rather than <TT>newInstance()</TT>.
<P>
The <TT>getClassLoader()</TT> method returns the class loader
of a class, if one exists. Classes are not usually loaded by a
class loader. However, when a class is loaded from outside the
<TT>CLASSPATH</TT>, such as over a network, a class loader is
used to convert the class byte stream into a class descriptor.
The <TT>ClassLoader</TT> class is covered later in this .
<H3><A NAME="ATouchofClass"><B>A Touch of Class</B></A></H3>
<P>
In order to give you a feel for how the <TT>Object</TT> and <TT>Class</TT>
methods can be used, let's create and run a small program called
<TT>ClassApp</TT>. If you have not already done so, create a <TT>ch12</TT>
directory to be used for this lesson. The program's source code
is shown in Listing 12.1.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.1. The source code of the </B><TT><B><FONT FACE="Courier New">ClassApp</FONT></B></TT><B>
program.</B><P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Class;<BR>
import jdg.ch05.Point;<BR>
import jdg.ch06.CGTextPoint;<BR>
<BR>
public class ClassApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;CGTextPoint p = new CGTextPoint(new Point(7,11));
<BR>
&nbsp;&nbsp;Object obj = new Object();<BR>
&nbsp;&nbsp;Class cl = p.getClass();<BR>
&nbsp;&nbsp;Class objcl = obj.getClass();<BR>
&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;describeClass(cl);<BR>
&nbsp;&nbsp;&nbsp;cl = cl.getSuperclass();<BR>
&nbsp;&nbsp;} while(cl!=objcl);<BR>
&nbsp;}<BR>
&nbsp;public static void describeClass(Class classDesc){<BR>
&nbsp;&nbsp;System.out.println(&quot;Class: &quot;+classDesc.getName());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Superclass: &quot;+classDesc.getSuperclass().getName());
<BR>
&nbsp;&nbsp;Class interfaces[] = classDesc.getInterfaces();<BR>
&nbsp;&nbsp;for(int i=0;i&lt;interfaces.length;++i)<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;has interface: &quot;+interfaces[i].getName());
<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program shows how the <TT>Object</TT> and <TT>Class</TT> methods
can be used to generate runtime class and interface information
about an arbitrary object. It creates an instance of class <TT>CGTextPoint</TT>
by importing the classes developed in <A HREF="ch5.htm" >Chapters 5</A>,
&quot;Classes and Objects,&quot; and <A HREF="ch6.htm" >6</A>,
&quot;Interfaces.&quot; It also creates a generic instance of
class <TT>Object</TT> in order to obtain the class descriptor
of that class. The following lines of code use the <TT>Object</TT>
<TT>getClass()</TT> method to obtain the class descriptors of
the <TT>CGTextPoint</TT> and <TT>Object</TT> classes:
<BLOCKQUOTE>
<TT>Class cl = p.getClass();<BR>
<FONT FACE="Courier New">Class objcl = obj.getClass();</FONT></TT>
</BLOCKQUOTE>
<P>
These class descriptors are instances of <TT>Class</TT>. They
are used in a simple <TT>do</TT> loop. The loop invokes the <TT>describeClass()</TT>
method for the class identified by <TT>cl</TT> and then assigns
<TT>cl</TT> to its superclass. The loop repeats until <TT>cl</TT>
becomes the class descriptor for <TT>Object</TT>.
<P>
The <TT>describeClass()</TT> method uses the <TT>getName()</TT>
method to get the name of the class and its superclass. The <TT>describeClass()</TT>
method displays this information to the console. It uses the <TT>getInterfaces()</TT>
method to get all interfaces implemented by a class and the <TT>getName()</TT>
method to get and display the name of each interface.
<P>
The program's output is as follows:
<BLOCKQUOTE>
<TT>Class: jdg.ch06.CGTextPoint<BR>
<FONT FACE="Courier New">Superclass: jdg.ch05.CGPoint<BR>
has interface: jdg.ch06.CGTextEdit<BR>
<BR>
Class: jdg.ch05.CGPoint<BR>
Superclass: jdg.ch05.CGObject<BR>
<BR>
Class: jdg.ch05.CGObject<BR>
Superclass: java.lang.Object</FONT></TT>
</BLOCKQUOTE>
<P>
It steps up the class hierarchy from <TT>CGTextPoint</TT> to <TT>CGObject</TT>
to display information about each class. See if you can modify
the program to work with objects of other classes. You can do
this by assigning the class of these objects to the <TT>cl</TT>
variable in the <TT>main()</TT> method.
<H2><A NAME="TheClassLoaderSecurityManagerandRu"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">ClassLoader</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>,
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">SecurityManager</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>,
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Runtime</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
The <TT>ClassLoader</TT>, <TT>SecurityManager</TT>, and <TT>Runtime</TT>
classes provide a fine level of control over the operation of
the Java runtime system. However, most of the time you will not
need or want to exercise this control because Java is set up to
perform optimally for a variety of applications. The <TT>ClassLoader</TT>
class allows you to define custom loaders for classes that you
load outside of your <TT>CLASSPATH</TT>-for example, over a network.
The <TT>SecurityManager</TT> class allows you to define a variety
of security policies that govern the accesses that classes may
make to threads, executable programs, your network, and your file
system. The <TT>Runtime</TT> class provides you with the capability
to control and monitor the Java runtime system. It also allows
you to execute external programs.
<H3><A NAME="ClassLoader"><TT><B><FONT SIZE=4 FACE="Courier New">ClassLoader</FONT></B></TT></A>
</H3>
<P>
Classes that are loaded from outside <TT>CLASSPATH</TT> require
a class loader to convert the class byte stream into a class descriptor.
<TT>ClassLoader</TT> is an abstract class that is used to define
class loaders. It uses the <TT>defineClass()</TT> method to convert
an array of bytes into a class descriptor. The <TT>loadClass()</TT>
method is used to load a class from its source, usually a network.
The <TT>resolveClass()</TT> method resolves all the classes referenced
by a particular class by loading and defining those classes. The
<TT>findSystemClass()</TT> method is used to load classes that
are located within <TT>CLASSPATH</TT> and, therefore, do not require
a class loader.
<H3><A NAME="SecurityManager"><TT><B><FONT SIZE=4 FACE="Courier New">SecurityManager</FONT></B></TT></A>
</H3>
<P>
The <TT>SecurityManager</TT> class is an abstract class that works
with class loaders to implement a security policy. It contains
several methods that can be overridden to implement customized
security policies. This class is covered in <A HREF="ch39.htm" >Chapter 39</A>,
&quot;Java Security,&quot; which gets into the details of Java
security. For right now, just be aware that it is in <TT>java.lang</TT>.
<H3><A NAME="Runtime"><TT><B><FONT SIZE=4 FACE="Courier New">Runtime</FONT></B></TT></A>
</H3>
<P>
The <TT>Runtime</TT> class provides access to the Java runtime
system. It consists of a number of methods that implement system-level
services.
<P>
The <TT>getRuntime()</TT> method is a static method that is used
to obtain access to an object of class <TT>Runtime</TT>. The <TT>exec()</TT>
methods are used to execute external programs from the Java runtime
system. The <TT>exec()</TT> methods provide a number of alternatives
for passing parameters to the executed program. These alternatives
are similar to the standard C methods for passing command-line
and environment information. The <TT>exec()</TT> methods are subject
to security checking to ensure that they are executed by trusted
code. <A HREF="ch39.htm" >See Chapter 39</A> for more information
about runtime security checking.
<P>
The <TT>exit()</TT> method is used to exit the Java runtime system
with an error code. It is similar to the <TT>exit</TT> function
found in standard C libraries.
<P>
The <TT>totalMemory()</TT>, <TT>freeMemory()</TT>, and <TT>gc()</TT>
methods are used to obtain information about and control the memory
used by the runtime system. The <TT>totalMemory()</TT> method
identifies the total memory available to the runtime system. The
<TT>freeMemory()</TT> method identifies the amount of free (unused)
memory. The <TT>gc()</TT> method is used to run the garbage collector
to free up memory allocated to objects that are no longer being
used. In general, you should not use the <TT>gc()</TT> method,
but rather let Java perform its own automated garbage collection.
<P>
The <TT>getLocalizedInputStream()</TT> and <TT>getLocalizedOutputStream()</TT>
methods are used to convert local (usually ASCII) input and output
streams to Unicode-based streams.
<P>
The <TT>load()</TT> and <TT>loadLibrary()</TT> methods are used
to load dynamic link libraries. This is usually performed in conjunction
with native methods, which are described in <A HREF="ch38.htm" >Chapter 38</A>,
&quot;Creating Native Methods.&quot;
<P>
The <TT>runFinalization()</TT> method causes the <TT>finalize()</TT>
method of each object awaiting finalization to be invoked. The
<TT>traceInstructions()</TT> and <TT>traceMethodCalls()</TT> methods
are used to enable or disable instruction and method tracing.
You will most likely never need to use any of these methods in
your programs. They are used in programs such as the debugger
to trace through the execution of Java methods and instructions.
<H4><B>Using </B><TT><B><FONT FACE="Courier New">Runtime</FONT></B></TT>
</H4>
<P>
Most of the methods provided by <TT>Runtime</TT> are not typically
used in application programs. However, some methods are pretty
useful. The program in Listing 12.2 shows how the <TT>Runtime</TT>
methods can be used to display memory status information.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.2. The source code of the </B><TT><B><FONT FACE="Courier New">RuntimeMemApp</FONT></B></TT><B>
program.</B><P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Runtime;<BR>
import java.io.IOException;<BR>
<BR>
public class RuntimeMemApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;Runtime r = Runtime.getRuntime();<BR>
&nbsp;&nbsp;System.out.println(r.totalMemory());<BR>
&nbsp;&nbsp;System.out.println(r.freeMemory());<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This program uses the static <TT>getRuntime()</TT> method to get
an instance of <TT>Runtime</TT> that represents the current Java
runtime system. The <TT>totalMemory()</TT> method is used to display
the total number of bytes of runtime system memory. The <TT>freeMemory()</TT>
method is used to display the number of bytes of memory that are
unallocated and currently available.
<P>
When you run the program, you should get results that are similar
to the following:
<BLOCKQUOTE>
<TT>3145720<BR>
<FONT FACE="Courier New">3135888</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 12.3 demonstrates how to use the <TT>Runtime</TT> <TT>exec()</TT>
method to execute external programs. This example assumes that
you are using Windows 95. It will not work with any other Java
implementation. However, it can be easily tailored to launch application
programs on other operating-system platforms.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.3. The source code of the </B><TT><B><FONT FACE="Courier New">RuntimeExecApp</FONT></B></TT><B>
program.</B><P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Runtime;<BR>
import java.io.IOException;<BR>
<BR>
public class RuntimeExecApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;Runtime r = Runtime.getRuntime();<BR>
&nbsp;&nbsp;r.exec(&quot;C:\\Windows\\Explorer.exe&quot;);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This program uses <TT>getRuntime()</TT> to get the current instance
of the runtime system and then uses <TT>exec()</TT> to execute
the Windows Explorer. The double backslashes (<TT>\\</TT>) are
Java escape codes for a single backslash (<TT>\</TT>). When you
run this program, it should launch a copy of the Windows Explorer.
Under Windows 95, the <TT>exec()</TT> function works with true
Win32 programs. It cannot be used to execute built-in DOS commands.
<H2><A NAME="TheSystemClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">System</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
You are no stranger to the <TT>System</TT> class because you have
used it in several previous programming examples. It is one of
the most important and useful classes provided by <TT>java.lang</TT>.
It provides a standard interface to common system resources and
functions. It implements the standard input, output, and error
streams, and supplies a set of methods that provide control over
the Java runtime system. Some of these methods duplicate those
provided by the <TT>Runtime</TT> class.
<H3><A NAME="PropertyRelatedMethods"><B>Property-Related Methods</B></A>
</H3>
<P>
The <TT>System</TT> class provides three property-related methods.
<I>Properties</I> are extensions of the <TT>Dictionary</TT> and
<TT>Hashtable</TT> classes and are defined in the <TT>java.util</TT>
package. A set of system properties is available through the <TT>System</TT>
class that describes the general characteristics of the operating
system and runtime system that you are using. The <TT>getProperties()</TT>
method gets all of the system properties and stores them in an
object of class <TT>Properties</TT>. The <TT>getProperty(String)</TT>
method gets a single property, as specified by a key. The <TT>setProperties()</TT>
method sets the system properties to the values of a <TT>Properties</TT>
object. The sample program presented in Listing 12.4 introduces
you to these system properties.
<H3><A NAME="SecurityManagerRelatedMethods"><B>Security Manager-Related
Methods</B></A></H3>
<P>
The <TT>getSecurityManager()</TT> and <TT>setSecurityManager()</TT>
methods provide access to the security manager that is currently
in effect. These methods are covered in <A HREF="ch39.htm" >Chapter 39</A>.
<H3><A NAME="RuntimeRelatedMethods"><B>Runtime-Related Methods</B></A>
</H3>
<P>
Several of the methods defined for the <TT>Runtime</TT> class
are made available through the <TT>System</TT> class. These methods
are <TT>exit()</TT>, <TT>gc()</TT>, <TT>load()</TT>, <TT>loadLibrary()</TT>,
and <TT>runFinalization()</TT>.
<H3><A NAME="OddsandEnds"><B>Odds and Ends</B></A></H3>
<P>
The <TT>arraycopy()</TT> method is used to copy data from one
array to another. This function provides the opportunity for system-specific
memory-copy operations to optimize memory-to-memory copies.
<P>
The <TT>currentTimeMillis()</TT> method returns the current time
in milliseconds since January 1, 1970. If you want more capable
date and time methods, check out the <TT>Date</TT> class in <TT>java.util</TT>.
<P>
The <TT>getenv()</TT> method is used to obtain the value of an
environment variable. However, this method is identified as obsolete
in the Java API documentation and can no longer be used.
<H3><A NAME="TimeandProperties"><B>Time and Properties</B></A>
</H3>
<P>
The short program in Listing 12.4 illustrates a few of the methods
provided by the <TT>System</TT> class. If your heyday was in the
1960s, it will allow you to keep track of the number of milliseconds
that have elapsed since the good old days. It also gets and displays
the <TT>System</TT> properties. Take a look through these properties
to get a feel for the type of information that is provided. Finally,
the <TT>exit()</TT> method is used to terminate the program, returning
a status code of <TT>13</TT>.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.4. The source code of the </B><TT><B><FONT FACE="Courier New">SystemApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Properties;<BR>
<BR>
public class SystemApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;long time = System.currentTimeMillis();<BR>
&nbsp;&nbsp;System.out.print(&quot;Milliseconds elapsed since
January 1, 1970: &quot;);<BR>
&nbsp;&nbsp;System.out.println(time);<BR>
&nbsp;&nbsp;Properties p=System.getProperties();<BR>
&nbsp;&nbsp;p.list(System.out);<BR>
&nbsp;&nbsp;System.exit(13);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program generated the following output on my computer:
<BLOCKQUOTE>
<TT>Milliseconds elapsed since January 1, 1970: 825298554460<BR>
<FONT FACE="Courier New">-- listing properties --<BR>
java.home=C:\JAVA\BIN\..<BR>
awt.toolkit=sun.awt.win32.MToolkit<BR>
java.version=1.0<BR>
file.separator=\<BR>
line.separator=<BR>
<BR>
java.vendor=Sun Microsystems Inc.<BR>
user.name=jamie<BR>
os.arch=x86<BR>
os.name=Windows 95<BR>
java.vendor.url=<A TARGET="resource window" HREF="http://www.sun.com/">http://www.sun.com/</A><BR>
user.dir=c:\java\jdg\ch12<BR>
java.class.path=.;c:\java;c:\java\lib\classes.zip;C:\...<BR>
java.class.version=45.3<BR>
os.version=4.0<BR>
path.separator=;<BR>
user.home=\home\jamie</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="WrappedClasses"><B><FONT SIZE=5 COLOR=#FF0000>Wrapped
Classes</FONT></B></A></H2>
<P>
Variables that are declared using the primitive Java types are
not objects and cannot be created and accessed using methods.
Primitive types also cannot be subclassed. To get around the limitations
of primitive types, the <TT>java.lang</TT> package defines class
<I>wrappers</I> for these types. These class wrappers furnish
methods that provide basic capabilities such as class conversion,
value testing, hash codes, and equality checks. The constructors
for the wrapped classes allow objects to be created and converted
from primitive values and strings. Be sure to browse the API pages
for each of these classes to familiarize yourself with the methods
they provide.
<H3><A NAME="TheBooleanClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Boolean</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Boolean</TT> class is a wrapper for the <TT>boolean</TT>
primitive type. It provides the <TT>getBoolean()</TT>, <TT>toString()</TT>,
and <TT>booleanValue()</TT> methods to support type and class
conversion. The <TT>toString()</TT>, <TT>equals()</TT>, and <TT>hashCode()</TT>
methods override those of class <TT>Object</TT>.
<H3><A NAME="TheCharacterClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Character</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Character</TT> class is a wrapper for the <TT>char</TT>
primitive type. It provides several methods that support case,
type, and class testing, and conversion. Check out the API pages
on these methods. We'll use some of them in the upcoming example.
<H3><A NAME="TheIntegerandLongClasses"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Integer</FONT></B></TT><B><FONT SIZE=4>
and </FONT></B><TT><B><FONT SIZE=4 FACE="Courier New">Long</FONT></B></TT><B><FONT SIZE=4>
Classes</FONT></B></A></H3>
<P>
The <TT>Integer</TT> and <TT>Long</TT> classes wrap the <TT>int</TT>
and <TT>long</TT> primitive types. They provide the <TT>MIN_VALUE</TT>
and <TT>MAX_VALUE</TT> constants, as well as a number of type
and class testing and conversion methods. The <TT>parseInt()</TT>
and <TT>parseLong()</TT> methods are used to parse <TT>String</TT>
objects and convert them to <TT>Integer</TT> and <TT>Long</TT>
objects.
<H3><A NAME="TheDoubleandFloatClasses"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Double</FONT></B></TT><B><FONT SIZE=4>
and </FONT></B><TT><B><FONT SIZE=4 FACE="Courier New">Float</FONT></B></TT><B><FONT SIZE=4>
Classes</FONT></B></A></H3>
<P>
The <TT>Double</TT> and <TT>Float</TT> classes wrap the <TT>double</TT>
and <TT>float</TT> primitive types. They provide the <TT>MIN_VALUE</TT>,
<TT>MAX_VALUE</TT>, <TT>POSITIVE_INFINITY</TT>, and <TT>NEGATIVE_INFINITY</TT>
constants, as well as the <TT>NaN</TT> (not-a-number) constant.
<TT>NaN</TT> is used as a value that is not equal to any value,
including itself. These classes provide a number of type and class
testing and conversion methods, including methods that support
conversion to and from integer bit representations.
<H3><A NAME="TheNumberClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Number</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Number</TT> class is an abstract numeric class that is
subclassed by <TT>Integer</TT>, <TT>Long</TT>, <TT>Float</TT>,
and <TT>Double</TT>. It provides four methods that support conversion
of objects from one class to another.
<H3><A NAME="AllWrappedUp"><B>All Wrapped Up</B></A></H3>
<P>
The program in Listing 12.5 shows some of the methods that can
be used with the primitive types when they are wrapped as objects.
Look up these methods in the API pages for each class and try
to figure out how they work before moving on to their explanations.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.5. The source code of the </B><TT><B><FONT FACE="Courier New">WrappedClassApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Boolean;<BR>
import java.lang.Character;<BR>
import java.lang.Integer;<BR>
import java.lang.Long;<BR>
import java.lang.Float;<BR>
import java.lang.Double;<BR>
<BR>
public class WrappedClassApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;Boolean b1 = new Boolean(&quot;TRUE&quot;);<BR>
&nbsp;&nbsp;Boolean b2 = new Boolean(&quot;FALSE&quot;);<BR>
&nbsp;&nbsp;System.out.println(b1.toString()+&quot; or &quot;+b2.toString());
<BR>
&nbsp;&nbsp;for(int j=0;j&lt;16;++j)<BR>
&nbsp;&nbsp;&nbsp;System.out.print(Character.forDigit(j,16));
<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;Integer i = new Integer(Integer.parseInt(&quot;ef&quot;,16));
<BR>
&nbsp;&nbsp;Long l = new Long(Long.parseLong(&quot;abcd&quot;,16));
<BR>
&nbsp;&nbsp;long m=l.longValue()*i.longValue();<BR>
&nbsp;&nbsp;System.out.println(Long.toString(m,8));<BR>
&nbsp;&nbsp;System.out.println(Float.MIN_VALUE);<BR>
&nbsp;&nbsp;System.out.println(Double.MAX_VALUE);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program examines some of the more useful methods provided
by each of the wrapped classes. It creates two objects of class
<TT>Boolean</TT> from string arguments passed to their constructors.
It assigns these objects to <TT>b1</TT> and <TT>b2</TT> and then
converts them back to <TT>String</TT> objects when it displays
them. They are displayed in lowercase, as <TT>boolean</TT> values
are traditionally represented.
<P>
The program then executes a <TT>for</TT> loop that prints out
the character corresponding to each of the hexadecimal digits.
The static <TT>forDigit()</TT> method of the <TT>Character</TT>
class is used to generate the character values of digits in a
number system of a different radix.
<P>
The static <TT>parseInt()</TT> and <TT>parseLong()</TT> methods
are used to parse strings according to different radices. In the
example, they are used to convert strings representing hexadecimal
numbers into <TT>Integer</TT> and <TT>Long</TT> values. These
values are then multiplied together and converted to a string
that represents the resulting value in base 8. This is accomplished
using an overloaded version of the <TT>toString()</TT> method.
<P>
The sample program concludes by displaying the minimum <TT>float</TT>
value and the maximum <TT>double</TT> value using the predefined
class constants of the <TT>Float</TT> and <TT>Double</TT> classes.
<P>
The program's output is as follows:
<BLOCKQUOTE>
<TT>true or false<BR>
<FONT FACE="Courier New">0123456789abcdef<BR>
50062143<BR>
1.4013e-045<BR>
1.79769e+308</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheMathClass"><B><FONT SIZE=5 COLOR=#FF0000>The </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Math</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>Math</TT> class provides an extensive set of mathematical
methods in the form of a static class library. It also defines
the mathematical constants <TT>E</TT> and <TT>PI</TT>. The supported
methods include arithmetic, trigonometric, exponential, logarithmic,
random number, and conversion routines. You should browse the
API page of this class to get a feel for the methods it provides.
The example in Listing 12.6 only touches on a few of these methods.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.6. The source code of the </B><TT><B><FONT FACE="Courier New">MathApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Math;<BR>
<BR>
public class MathApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;System.out.println(Math.E);<BR>
&nbsp;&nbsp;System.out.println(Math.PI);<BR>
&nbsp;&nbsp;System.out.println(Math.abs(-1234));<BR>
&nbsp;&nbsp;System.out.println(Math.cos(Math.PI/4));<BR>
&nbsp;&nbsp;System.out.println(Math.sin(Math.PI/2));<BR>
&nbsp;&nbsp;System.out.println(Math.tan(Math.PI/4));<BR>
&nbsp;&nbsp;System.out.println(Math.log(1));<BR>
&nbsp;&nbsp;System.out.println(Math.exp(Math.PI));<BR>
&nbsp;&nbsp;for(int i=0;i&lt;5;++i)<BR>
&nbsp;&nbsp;&nbsp;System.out.print(Math.random()+&quot; &quot;);
<BR>
&nbsp;&nbsp;System.out.println();</FONT></TT>
<P>
<TT> }</TT>
<P>
<TT>}</TT>
</BLOCKQUOTE>
<HR>
<P>
This program prints the constants e and <FONT FACE="Symbol">p</FONT>,
|-1234|, cos(<FONT FACE="Symbol">p</FONT>/4), sin(<FONT FACE="Symbol">p</FONT>/2),
tan(<FONT FACE="Symbol">p</FONT>/4), ln(1), e<FONT FACE="Symbol">p</FONT>,
and then five random double numbers between 0.0 and 1.1. Its output
is as follows:
<BLOCKQUOTE>

<TT>2.71828<BR>
<FONT FACE="Courier New">3.14159<BR>
1234<BR>
0.707107<BR>
1<BR>
1<BR>
0<BR>
23.1407<BR>
0.831965 0.573099 0.0268818 0.378625 0.164485</FONT></TT>
</BLOCKQUOTE>

<P>
The random numbers you generate will almost certainly differ from
the ones shown here.
<H2><A NAME="TheStringandStringBufferClasses"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">String</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">StringBuffer</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
The <TT>String</TT> and <TT>StringBuffer</TT> classes are used
to support operations on strings of characters. The <TT>String</TT>
class supports constant (unchanging) strings, whereas the <TT>StringBuffer</TT>
class supports growable, modifiable strings. <TT>String</TT> objects
are more compact than <TT>StringBuffer</TT> objects, but <TT>StringBuffer</TT>
objects are more flexible.
<H3><A NAME="StringLiterals"><TT><B><FONT SIZE=4 FACE="Courier New">String</FONT></B></TT><B><FONT SIZE=4>
Literals</FONT></B></A></H3>
<P>
<TT><I><FONT FACE="Courier New">String</FONT></I></TT><I> literals</I>
are strings that are specified using double quotes. <TT>&quot;This
is a string&quot;</TT> and <TT>&quot;xyz&quot;</TT> are examples
of string literals. <TT>String</TT> literals are different than
the literal values used with primitive types. When the <TT>javac</TT>
compiler encounters a <TT>String</TT> literal, it converts it
to a <TT>String</TT> constructor. For example, the following:
<BLOCKQUOTE>
<TT>String str = &quot;text&quot;;</TT>
</BLOCKQUOTE>
<P>
is equivalent to this:
<BLOCKQUOTE>
<TT>String str = new String(&quot;text&quot;);</TT>
</BLOCKQUOTE>
<P>
The fact that the compiler automatically supplies <TT>String</TT>
constructors allows you to use <TT>String</TT> literals everywhere
that you could use objects of the <TT>String</TT> class.
<H3><A NAME="TheOperatorandStringBuffer"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">+</FONT></B></TT><B><FONT SIZE=4>
Operator and </FONT></B><TT><B><FONT SIZE=4 FACE="Courier New">StringBuffer</FONT></B></TT></A>
</H3>
<P>
If <TT>String</TT> objects are constant, how can they be concatenated
with the <TT>+</TT> operator and be assigned to existing <TT>String</TT>
objects? In the following example, the code will result in the
string <TT>&quot;ab&quot;</TT> being assigned to the <TT>s</TT>
object:
<BLOCKQUOTE>
<TT>String s = &quot;&quot;;<BR>
<FONT FACE="Courier New">s = s + &quot;a&quot; + &quot;b&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
How can this be possible if <TT>String</TT>s are constant? The
answer lies in the fact that the Java compiler uses <TT>StringBuffer</TT>
objects to accomplish the string manipulations. This code would
be rendered as something similar to the following by the Java
compiler:
<BLOCKQUOTE>
<TT>String s = &quot;&quot;;<BR>
<FONT FACE="Courier New">s = new StringBuffer(&quot;&quot;).append(&quot;a&quot;).append(&quot;b&quot;).toString();</FONT></TT>
</BLOCKQUOTE>
<P>
A new object of class <TT>StringBuffer</TT> is created with the
<TT>&quot;&quot;</TT> argument. The <TT>StringBuffer</TT> <TT>append()</TT>
method is used to append the strings <TT>&quot;a&quot;</TT> and
<TT>&quot;b&quot;</TT> to the new object, and then the object
is converted to an object of class <TT>String</TT> via the <TT>toString()</TT>
method. The <TT>toString()</TT> method creates a new object of
class <TT>String</TT> before it is assigned to the <TT>s</TT>
variable. In this way, the <TT>s</TT> variable always refers to
a constant (although new) <TT>String</TT> object.
<H3><A NAME="StringConstructors"><TT><B><FONT SIZE=4 FACE="Courier New">String</FONT></B></TT><B><FONT SIZE=4>
Constructors</FONT></B></A></H3>
<P>
The <TT>String</TT> class provides seven constructors for the
creation and initialization of <TT>String</TT> objects. These
constructors allow strings to be created from other strings, string
literals, arrays of characters, arrays of bytes, and <TT>StringBuffer</TT>
objects. Browse through the API page for the <TT>String</TT> class
to become familiar with these constructors.
<H3><A NAME="StringAccessMethods"><TT><B><FONT SIZE=4 FACE="Courier New">String</FONT></B></TT><B><FONT SIZE=4>
Access Methods</FONT></B></A></H3>
<P>
The <TT>String</TT> class provides a very powerful set of methods
for working with <TT>String</TT> objects. These methods allow
you to access individual characters and substrings; test and compare
strings; copy, concatenate, and replace parts of strings; convert
and create strings; and perform other useful string operations.
<P>
The most important <TT>String</TT> methods are the <TT>length()</TT>
method, which returns an integer value identifying the length
of a string; the <TT>charAt()</TT> method, which allows the individual
characters of a string to be accessed; the <TT>substring()</TT>
method, which allows substrings of a string to be accessed; and
the <TT>valueOf()</TT> method, which allows primitive data types
to be converted into strings.
<P>
In addition to these methods, the <TT>Object</TT> class provides
a <TT>toString()</TT> method for converting other objects to <TT>String</TT>
objects. This method is often overridden by subclasses to provide
a more appropriate object-to-<TT>String</TT> conversion.
<H4><B>Character and Substring Methods</B></H4>
<P>
Several <TT>String</TT> methods allow you to access individual
characters and substrings of a string. These include <TT>charAt()</TT>,
<TT>getBytes()</TT>, <TT>getChars()</TT>, <TT>indexOf()</TT>,
<TT>lastIndexOf()</TT>, and <TT>substring()</TT>. Whenever you
need to perform string manipulations, be sure to check the API
documentation to make sure that you don't overlook an easy-to-use,
predefined <TT>String</TT> method.
<H4><B>String Comparison and Test Methods</B></H4>
<P>
Several <TT>String</TT> methods allow you to compare strings,
substrings, byte arrays, and other objects with a given string.
Some of these methods are <TT>compareTo()</TT>, <TT>endsWith()</TT>,
<TT>equals()</TT>, <TT>equalsIgnoreCase()</TT>, <TT>regionMatches()</TT>,
and <TT>startsWith()</TT>.
<H4><B>Copy, Concatenation, and Replace Methods</B></H4>
<P>
The following methods are useful for copying, concatenating, and
manipulating strings: <TT>concat()</TT>, <TT>copyValueOf()</TT>,
<TT>replace()</TT>, and <TT>trim()</TT>.
<H4><B>String Conversion and Generation</B></H4>
<P>
There are a number of string methods that support <TT>String</TT>
conversion. These are <TT>intern()</TT>, <TT>toCharArray()</TT>,
<TT>toLowerCase()</TT>, <TT>toString()</TT>, <TT>toUpperCase()</TT>,
and <TT>valueOf()</TT>. You explore the use of some of these methods
in the following example.
<H4><B>Stringing Along</B></H4>
<P>
The program in Listing 12.7 provides a glimpse at the operation
of some of the methods identified in the previous subsections.
Because strings are frequently used in application programs, learning
to use the available methods is essential to being able to use
the <TT>String</TT> class most effectively.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.7. The source code of the </B><TT><B><FONT FACE="Courier New">StringApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.String;<BR>
<BR>
public class StringApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;String s = &quot;  Java Developer's Guide  &quot;;
<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;System.out.println(s.toUpperCase());<BR>
&nbsp;&nbsp;System.out.println(s.toLowerCase());<BR>
&nbsp;&nbsp;System.out.println(&quot;[&quot;+s+&quot;]&quot;);
<BR>
&nbsp;&nbsp;s=s.trim();<BR>
&nbsp;&nbsp;System.out.println(&quot;[&quot;+s+&quot;]&quot;);
<BR>
&nbsp;&nbsp;s=s.replace('J','X');<BR>
&nbsp;&nbsp;s=s.replace('D','Y');<BR>
&nbsp;&nbsp;s=s.replace('G','Z');<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;int i1 = s.indexOf('X');<BR>
&nbsp;&nbsp;int i2 = s.indexOf('Y');<BR>
&nbsp;&nbsp;int i3 = s.indexOf('Z');<BR>
&nbsp;&nbsp;char ch[] = s.toCharArray();<BR>
&nbsp;&nbsp;ch[i1]='J';<BR>
&nbsp;&nbsp;ch[i2]='D';<BR>
&nbsp;&nbsp;ch[i3]='G';<BR>
&nbsp;&nbsp;s = new String(ch);<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This program performs several manipulations of a string <TT>s</TT>
that is initially set to <TT>&quot;  Java Developer's Guide  &quot;</TT>.
It prints the original string and then prints upper- and lowercase
versions of it, illustrating the use of the <TT>toUpperCase()</TT>
and <TT>toLowerCase()</TT> methods. It prints the string enclosed
between two braces to show that it contains leading and trailing
spaces. It then trims away these spaces using the <TT>trim()</TT>
method and reprints the string to show that these spaces were
removed.
<P>
The program uses the <TT>replace()</TT> method to replace the
letters <TT>'J'</TT>, <TT>'D'</TT>, and <TT>'G'</TT> with <TT>'X'</TT>,
<TT>'Y'</TT>, and <TT>'Z'</TT> and prints out the string to show
the changes. The <TT>replace()</TT> method is case sensitive.
It uses the <TT>indexOf()</TT> method to get the indices of <TT>'X'</TT>,
<TT>'Y'</TT>, and <TT>'Z'</TT> within <TT>s</TT>. It uses  <TT>toCharArray()</TT>
to convert the string to a <TT>char</TT> array. It then uses the
indices to put <TT>'J'</TT>, <TT>'D'</TT>, and <TT>'G'</TT> back
in their proper locations within the character array. The <TT>String()</TT>
constructor is used to construct a new string from the character
array. The new string is assigned to <TT>s</TT> and is printed.
<P>
The program's output is as follows:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;Java Developer's Guide<BR>
<FONT FACE="Courier New">&nbsp;&nbsp;JAVA DEVELOPER'S GUIDE<BR>
&nbsp;&nbsp;java developer's guide<BR>
[&nbsp;&nbsp;Java Developer's Guide&nbsp;&nbsp;]<BR>
[Java Developer's Guide]<BR>
Xava Yeveloper's Zuide<BR>
Java Developer's Guide</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="TheStringBufferClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">StringBuffer</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>StringBuffer</TT> class is the force behind the scene
for most complex string manipulations. The compiler automatically
declares and manipulates objects of this class to implement common
string operations.
<P>
The <TT>StringBuffer</TT> class provides three constructors: an
empty constructor, an empty constructor with a specified initial
buffer length, and a constructor that creates a <TT>StringBuffer</TT>
object from a <TT>String</TT> object. In general, you will find
yourself constructing <TT>StringBuffer</TT> objects from <TT>String</TT>
objects, and the last constructor will be the one you use most
often.
<P>
The <TT>StringBuffer</TT> class provides several versions of the
<TT>append()</TT> method to convert and append other objects and
primitive data types to <TT>StringBuffer</TT> objects. It provides
a similar set of <TT>insert()</TT> methods for inserting objects
and primitive data types into <TT>StringBuffer</TT> objects. It
also provides methods to access the character-buffering capacity
of <TT>StringBuffer</TT> and methods for accessing the characters
contained in a string. It is well worth a visit to the <TT>StringBuffer</TT>
API pages to take a look at the methods that it has to offer.
<H4><B>Strung Out</B></H4>
<P>
The program in Listing 12.8 shows how <TT>StringBuffer</TT> objects
can be manipulated using the <TT>append()</TT>, <TT>insert()</TT>,
and <TT>setCharAt()</TT> methods.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.8. The source code of the </B><TT><B><FONT FACE="Courier New">StringBufferApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.String;<BR>
import java.lang.StringBuffer;<BR>
<BR>
public class StringBufferApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;StringBuffer sb = new StringBuffer(&quot; is &quot;);
<BR>
&nbsp;&nbsp;sb.append(&quot;Hot&quot;);<BR>
&nbsp;&nbsp;sb.append('!');<BR>
&nbsp;&nbsp;sb.insert(0,&quot;Java&quot;);<BR>
&nbsp;&nbsp;sb.append('\n');<BR>
&nbsp;&nbsp;sb.append(&quot;This is &quot;);<BR>
&nbsp;&nbsp;sb.append(true);<BR>
&nbsp;&nbsp;sb.setCharAt(21,'T');<BR>
&nbsp;&nbsp;sb.append('\n');<BR>
&nbsp;&nbsp;sb.append(&quot;Java is #&quot;);<BR>
&nbsp;&nbsp;sb.append(1);<BR>
&nbsp;&nbsp;String s = sb.toString();<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates a <TT>StringBuffer</TT> object using the string
<TT>&quot; is &quot;</TT>. It appends the string <TT>&quot;Hot&quot;</TT>
using the <TT>append()</TT> method and the character <TT>'!'</TT>
using an overloaded version of the same method. The <TT>insert()</TT>
method is used to insert the string <TT>&quot;Java&quot;</TT>
at the beginning of the string buffer.
<P>
Three <TT>append</TT>s are used to tack on a newline character
(<TT>\n</TT>), the string <TT>&quot;This is &quot;</TT>, and the
<TT>boolean</TT> value <TT>true</TT>. The <TT>append()</TT> method
is overloaded to support the appending of the primitive data types
as well as arbitrary Java objects.
<P>
The <TT>setCharAt()</TT> method is used to replace the letter
<TT>'t'</TT> at index 21 with the letter <TT>'T'</TT>. The <TT>charAt()</TT>
and <TT>setCharAt()</TT> methods allow <TT>StringBuffer</TT> objects
to be treated as arrays of characters.
<P>
Finally, another newline character is appended to <TT>sb</TT>,
followed by the string <TT>&quot;Java is #&quot;</TT> and the
<TT>int</TT> value 1. The <TT>StringBuffer</TT> object is then
converted to a string and displayed to the console window.
<P>
The output of the program is as follows:
<BLOCKQUOTE>
<TT>Java is Hot!<BR>
<FONT FACE="Courier New">This is True<BR>
Java is #1</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ThreadsandProcesses"><B><FONT SIZE=5 COLOR=#FF0000>Threads
and Processes</FONT></B></A></H2>
<P>
<A HREF="ch8.htm" >Chapter 8</A>, &quot;Multithreading,&quot;
provides a detailed description of multithreading in Java. This
section briefly describes the classes of <TT>java.lang</TT> that
support multithreading. It also covers the <TT>Process</TT> class,
which is used to manipulate processes that are executed using
the <TT>System.exec()</TT> methods.
<H3><A NAME="Runnable"><TT><B><FONT SIZE=4 FACE="Courier New">Runnable</FONT></B></TT></A>
</H3>
<P>
The <TT>Runnable</TT> interface provides a common approach to
identifying the code to be executed as part of an active thread.
It consists of a single method, <TT>run()</TT>, which is executed
when a thread is activated. The <TT>Runnable</TT> interface is
implemented by the <TT>Thread</TT> class and by other classes
that support threaded execution.
<H3><A NAME="Thread"><TT><B><FONT SIZE=4 FACE="Courier New">Thread</FONT></B></TT></A>
</H3>
<P>
The <TT>Thread</TT> class is used to construct and access individual
threads of execution that are executed as part of a multithreaded
program. It defines the priority constants, <TT>MIN_PRIORITY</TT>,
<TT>MAX_PRIORITY</TT>, and <TT>NORM_PRIORITY</TT>, that are used
to control task scheduling. It provides seven constructors for
creating instances of class <TT>Thread</TT>. The four constructors
with the <TT>Runnable</TT> parameters are used to construct threads
for classes that do not subclass the <TT>Thread</TT> class. The
other constructors are used for the construction of <TT>Thread</TT>
objects from <TT>Thread</TT> subclasses.
<P>
<TT>Thread</TT> supports many methods for accessing <TT>Thread</TT>
objects. These methods provide the capabilities to work with a
thread's group; obtain detailed information about a thread's activities;
set and test a thread's properties; and cause a thread to wait,
be interrupted, or be destroyed.
<H3><A NAME="ThreadGroup"><TT><B><FONT SIZE=4 FACE="Courier New">ThreadGroup</FONT></B></TT></A>
</H3>
<P>
The <TT>ThreadGroup</TT> class is used to encapsulate a group
of threads as a single object so that they can be accessed as
a single unit. A number of access methods are provided for manipulating
<TT>ThreadGroup</TT> objects. These methods keep track of the
threads and thread groups contained in a thread group and perform
global operations on all threads in the group. The global operations
are group versions of the operations that are provided by the
<TT>Thread</TT> class.
<H3><A NAME="Process"><TT><B><FONT SIZE=4 FACE="Courier New">Process</FONT></B></TT></A>
</H3>
<P>
The <TT>Process</TT> class is used to encapsulate processes that
are executed with the <TT>System.exec()</TT> methods. An instance
of class <TT>Process</TT> is returned by the <TT>Runtime</TT>
class <TT>exec()</TT> method when it executes a process that is
external to the Java runtime system. This <TT>Process</TT> object
can be destroyed using the <TT>destroy()</TT> method and waited
on using the <TT>waitFor()</TT> method. The <TT>exitValue()</TT>
method returns the system exit value of the process. The <TT>getInputStream()</TT>,
<TT>getOutputStream()</TT>, and <TT>getErrorStream()</TT> methods
are used to access the standard input, output, and error streams
of the process.
<H3><A NAME="HelloAgain"><B>Hello Again</B></A></H3>
<P>
The simple program in Listing 12.9 actually performs some pretty
complex processing. It is provided as an example of some of the
powerful things that can be accomplished using the <TT>Process</TT>
class.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 12.9. The source code of the </B><TT><B><FONT FACE="Courier New">ProcessApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.lang.Runtime;<BR>
import java.lang.Process;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class ProcessApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;Runtime r = Runtime.getRuntime();<BR>
&nbsp;&nbsp;Process p = r.exec(&quot;java jdg.ch04.HelloWorldApp&quot;);
<BR>
&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(p.getInputStream());
<BR>
&nbsp;&nbsp;String line = inStream.readLine();<BR>
&nbsp;&nbsp;System.out.println(line);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program uses the static <TT>getRuntime()</TT> method to get
the current instance of the Java runtime system. It then uses
the <TT>exec()</TT> method to execute another separate copy of
the Java interpreter with the <TT>HelloWorldApp</TT> program that
was developed in <A HREF="ch4.htm" >Chapter 4</A>, &quot;First
Programs: Hello World! to BlackJack.&quot; It creates a <TT>DataInputStream</TT>
object, <TT>inStream</TT>, that is connected to the output stream
of the <TT>HelloWorldApp</TT> program. It then uses <TT>inStream</TT>
to read the output of the <TT>HelloWorldApp</TT> program and display
it on the console window as follows:
<P>
<TT>Hello World!</TT>
<P>
The <TT>exec()</TT> methods combined with the <TT>Process</TT>
class provide a powerful set of tools by which Java programs can
be used to launch and control the execution of other programs.
<H2><A NAME="TheCompilerClass"><B><FONT SIZE=5 COLOR=#FF0000>The
Compiler Class</FONT></B></A></H2>
<P>
The <TT>Compiler</TT> class consists of five <TT>static</TT> methods
that are used to compile Java classes in the rare event that you
want to compile classes directly from a program or applet. These
methods allow you to build your own customized Java development
environment.
<H2><A NAME="ExceptionsandErrors"><B><FONT SIZE=5 COLOR=#FF0000>Exceptions
and Errors</FONT></B></A></H2>
<P>
The <TT>java.lang</TT> package establishes the Java exception
hierarchy and declares numerous exceptions and errors. Errors
are used to indicate the occurrence of abnormal and fatal events
that should not be handled within application programs. (<A HREF="ch7.htm" >See Chapter 7</A>,
&quot;Exceptions.&quot;)
<H3><A NAME="TheThrowableClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Throwable</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Throwable</TT> class is at the top of the Java error-and-exception
hierarchy. It is extended by the <TT>Error</TT> and <TT>Exception</TT>
classes and provides methods that are common to both classes.
These methods consist of stack tracing methods, the <TT>getMessage()</TT>
method, and the <TT>toString()</TT> method, which is an override
of the method inherited from the <TT>Object</TT> class. The <TT>getMessage()</TT>
method is used to retrieve any messages that are supplied in the
creation of <TT>Throwable</TT> objects.
<P>
The <TT>fillInStackTrace()</TT> and <TT>printStackTrace()</TT>
methods are used to add information to supply and print information
that is used to trace the propagation of exceptions and errors
throughout a program's execution.
<H3><A NAME="TheErrorClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Error</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Error</TT> class is used to provide a common superclass
to define abnormal and fatal events that should not occur. It
provides two constructors and no other methods. Four major classes
of errors extend the <TT>Error</TT> class: <TT>AWTError</TT>,
<TT>LinkageError</TT>, <TT>ThreadDeath</TT>, and <TT>VirtualMachineError</TT>.
<P>
The <TT>AWTError</TT> class identifies fatal errors that occur
in the Abstract Window Toolkit packages. It is a single identifier
for all AWT errors and is not subclassed.
<P>
The <TT>LinkageError</TT> class is used to define errors that
occur as the result of incompatibilities between dependent classes.
These incompatibilities result when a class X that another class
Y depends on is changed before class Y can be recompiled. The
<TT>LinkageError</TT> class is extensively subclassed to identify
specific manifestations of this type of error.
<P>
The <TT>ThreadDeath</TT> error class is used to indicate that
a thread has been stopped. Instances of this class can be caught
and then rethrown to ensure that a thread is gracefully terminated,
although this is not recommended. The <TT>ThreadDeath</TT> class
is not subclassed.
<P>
The <TT>VirtualMachineError</TT> class is used to identify fatal
errors occurring in the operation of the Java virtual machine.
It has four subclasses: <TT>InternalError</TT>, <TT>OutOfMemoryError</TT>,
<TT>StackOverflowError</TT>, and <TT>UnknownError</TT>.
<H3><A NAME="TheExceptionClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Exception</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Exception</TT> class provides a common superclass for
the exceptions that can be defined for Java programs and applets.
There are nine subclasses of exceptions that extend the <TT>Exception</TT>
class. These exception subclasses are further extended by lower-level
subclasses.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this  you have learned how to use the <TT>java.lang</TT> package.
You have taken a tour of its classes and their methods and have
written some sample programs that illustrate their use. In the
next  you'll learn to use the <TT>java.io</TT> package to perform
stream-based I/O to files, memory buffers, and the console window.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



