<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 17</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Network Programming with the
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.net</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Package</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheInternetProtocolSuite" >The Internet Protocol Suite</A>
<UL>
<LI><A HREF="#WhatIstheInternetandHowDoesItWor" >What Is the Internet and How Does It Work?</A>
<LI><A HREF="#ConnectionOrientedVersusConnectionles" >Connection-Oriented Versus Connectionless Communication</A>
</UL>
<LI><A HREF="#ClientServerComputingandtheInternet" >Client/Server Computing and the Internet</A>
<UL>
<LI><A HREF="#SocketsandClientServerCommunication" >Sockets and Client/Server Communication</A>
</UL>
<LI><A HREF="#Overviewofjavanet" >Overview of java.net</A>
<LI><A HREF="#TheInetAddressClass" >The InetAddress Class</A>
<LI><A HREF="#TheSocketClass" >The Socket Class</A>
<LI><A HREF="#TheServerSocketClass" >The ServerSocket Class</A>
<LI><A HREF="#TheDatagramSocketClass" >The DatagramSocket Class</A>
<LI><A HREF="#TheDatagramPacketClass" >The DatagramPacket Class</A>
<UL>
<LI><A HREF="#TimeServerApp" >TimeServerApp</A>
<LI><A HREF="#GetTimeApp" >GetTimeApp</A>
</UL>
<LI><A HREF="#TheSocketImplClassandtheSocketImplF" >The SocketImpl Class and the SocketImplFactory Interface</A>
<LI><A HREF="#WebRelatedClasses" >Web-Related Classes</A>
<UL>
<LI><A HREF="#URL" >URL</A>
<LI><A HREF="#URLConnection" >URLConnection</A>
<LI><A HREF="#URLEncoder" >URLEncoder</A>
</UL>
<LI><A HREF="#TheContentHandlerandContentHandlerFac" >The ContentHandler and ContentHandlerFactory Classes</A>
<LI><A HREF="#TheURLStreamHandlerClassandtheURLSt" >The URLStreamHandler Class and the URLStreamHandlerFactory Interface</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
In this chapter you'll learn about Java's support of network programming.
You'll learn the basics of client/server computing and TCP/IP
socket programming. You'll then examine the classes of the <TT>java.net</TT>
package and learn how to use them to develop client/server applications.
This chapter provides an introduction to the <TT>java.net</TT>
package. Part V, &quot;Network Programming,&quot; explores the
information presented here in greater detail.
<P>
<A NAME="TheInternetProtocolSuite"><B><FONT SIZE=5 COLOR=#FF0000>The
Internet Protocol Suite</FONT></B></A>
<P>
The <TT>java.net</TT> package provides a set of classes that support
network programming using the communication protocols employed
by the Internet. These protocols are known as the <I>Internet
protocol suite</I> and include the <I>Internet Protocol</I> (IP),
the <I>Transport Control Protocol</I> (TCP), and the <I>User Datagram
Protocol</I> (UDP) as well as other, less-prominent supporting
protocols. Although this section cannot provide a full description
of the Internet protocols, it gives you the basic information
that you need to get started with Java network programming. In
order to take full advantage of this chapter, you need an Internet
connection.
<H3><A NAME="WhatIstheInternetandHowDoesItWor"><B>What Is the
Internet and How Does It Work?</B></A></H3>
<P>
Asking the question What is the Internet? may bring about a heated
discussion in some circles. In this book, the <I>Internet</I>
is defined as the collection of all computers that are able to
communicate, using the Internet protocol suite, with the computers
and networks registered with the <I>Internet Network Information
Center</I> (InterNIC). This definition includes all computers
to which you can directly (or indirectly through a firewall) send
Internet Protocol packets.
<P>
Computers on the Internet communicate by exchanging packets of
data, known as Internet Protocol, or IP, packets. IP is the network
protocol used to send information from one computer to another
over the Internet. All computers on the Internet (by our definition
in this book) communicate using IP. IP moves information contained
in IP packets. The IP packets are routed via special routing algorithms
from a source computer that sends the packets to a destination
computer that receives them. The routing algorithms figure out
the best way to send the packets from source to destination.
<P>
In order for IP to send packets from a source computer to a destination
computer, it must have some way of identifying these computers.
All computers on the Internet are identified using one or more
IP addresses. A computer may have more than one IP address if
it has more than one interface to computers that are connected
to the Internet.
<P>
IP addresses are 32-bit numbers. They may be written in decimal,
hexadecimal, or other formats, but the most common format is dotted
decimal notation. This format breaks the 32-bit address up into
four bytes and writes each byte of the address as unsigned decimal
integers separated by dots. For example, one of my IP addresses
is <TT>0xCCD499C1</TT>. Because <TT>0xCC</TT> = 204, <TT>0xD4</TT>
= 212, <TT>0x99</TT> = 153, and <TT>0xC1</TT> = 193, my address
in dotted decimal form is <TT>204.212.153.193</TT>.
<P>
IP addresses are not easy to remember, even using dotted decimal
notation. The Internet has adopted a mechanism, referred to as
the <I>Domain Name System</I> (DNS), whereby computer names can
be associated with IP addresses. These computer names are referred
to as <I>domain names</I>. The DNS has several rules that determine
how domain names are constructed and how they relate to one another.
For the purposes of this chapter, it is sufficient to know that
domain names are computer names and that they are mapped to IP
addresses.
<P>
The mapping of domain names to IP addresses is maintained by a
system of <I>domain name servers</I>. These servers are able to
look up the IP address corresponding to a domain name. They also
provide the capability to look up the domain name associated with
a particular IP address, if one exists.
<P>
As I mentioned, IP enables communication between computers on
the Internet by routing data from a source computer to a destination
computer. However, computer-to-computer communication only solves
half of the network communication problem. In order for an application
program, such as a mail program, to communicate with another application,
such as a mail server, there needs to be a way to send data to
specific programs within a computer.
<P>
Ports are used to enable communication between programs. A <I>port</I>
is an address within a computer. Port addresses are 16-bit addresses
that are usually associated with a particular application protocol.
An application server, such as a Web server or an FTP server,
listens on a particular port for service requests, performs whatever
service is requested of it, and returns information to the port
used by the application program requesting the service.
<P>
Popular Internet application protocols are associated with <I>well-known
ports</I>. The server programs implementing these protocols listen
on these ports for service requests. The well-known ports for
some common Internet application protocols are
<BLOCKQUOTE>
Port Protocol<BR>
21 File Transfer Protocol<BR>
23 Telnet Protocol<BR>
25 Simple Mail Transfer Protocol<BR>
80 Hypertext Transfer Protocol
</BLOCKQUOTE>
<P>
The well-known ports are used to standardize the location of Internet
services.
<H3><A NAME="ConnectionOrientedVersusConnectionles"><B>Connection-Oriented
Versus Connectionless Communication</B></A></H3>
<P>
Transport protocols are used to deliver information from one port
to another and thereby enable communication between application
programs. They use either a connection-oriented or connectionless
method of communication. TCP is a connection-oriented protocol
and UDP is a connectionless transport protocol.
<P>
The TCP connection-oriented protocol establishes a communication
link between a source port/IP address and a destination port/IP
address. The ports are bound together via this link until the
connection is terminated and the link is broken. An example of
a connection-oriented protocol is a telephone conversation. A
telephone connection is established, communication takes place,
and then the connection is terminated.
<P>
The reliability of the communication between the source and destination
programs is ensured through error-detection and error-correction
mechanisms that are implemented within TCP. TCP implements the
connection as a stream of bytes from source to destination. This
feature allows the use of the stream I/O classes provided by <TT>java.io</TT>.
<P>
The UDP connectionless protocol differs from the TCP connection-oriented
protocol in that it does not establish a link for the duration
of the connection. An example of a connectionless protocol is
postal mail. To mail something, you just write down a destination
address (and an optional return address) on the envelope of the
item you're sending and drop it in a mailbox. When using UDP,
an application program writes the destination port and IP address
on a datagram and then sends the datagram to its destination.
UDP is less reliable than TCP because there are no delivery-assurance
or error-detection and -correction mechanisms built into the protocol.
<P>
Application protocols such as FTP, SMTP, and HTTP use TCP to provide
reliable, stream-based communication between client and server
programs. Other protocols, such as the Time Protocol, use UDP
because speed of delivery is more important than end-to-end reliability.
<H2><A NAME="ClientServerComputingandtheInternet"><B><FONT SIZE=5 COLOR=#FF0000>Client/Server
Computing and the Internet</FONT></B></A></H2>
<P>
The Internet provides a variety of services that contribute to
its appeal. These services include e-mail, newsgroups, file transfer,
remote login, and the Web. Internet services are organized according
to a client/server architecture. Client programs, such as Web
browsers and file transfer programs, create connections to servers,
such as Web and FTP servers. The clients make requests of the
server, and the server responds to the requests by providing the
service requested by the client.
<P>
The Web provides a good example of client/server computing. Web
browsers are the clients and Web servers are the servers. Browsers
request HTML files from Web servers on your behalf by establishing
a connection with a Web server and submitting file requests to
the server. The server receives the file requests, retrieves the
files, and sends them to the browser over the established connection.
The browser receives the files and displays them to your browser
window.
<H3><A NAME="SocketsandClientServerCommunication"><B>Sockets and
Client/Server Communication</B></A></H3>
<P>
Clients and servers establish connections and communicate via
<I>sockets</I>. Connections are communication links that are created
over the Internet using TCP. Some client/server applications are
also built around the connectionless UDP. These applications also
use sockets to communicate.
<P>
Sockets are the endpoints of Internet communication. Clients create
client sockets and connect them to server sockets. Sockets are
associated with a host address and a port address. The host address
is the IP address of the host where the client or server program
is located. The port address is the communication port used by
the client or server program. Server programs use the well-known
port number associated with their application protocol.
<P>
A client communicates with a server by establishing a connection
to the socket of the server. The client and server then exchange
data over the connection. Connection-oriented communication is
more reliable than connectionless communication because the underlying
TCP provides message-acknowledgment, error-detection, and error-recovery
services.
<P>
When a connectionless protocol is used, the client and server
communicate by sending datagrams to each other's socket. The UDP
is used for connectionless protocols. It does not support reliable
communication like TCP.
<H2><A NAME="Overviewofjavanet"><B><FONT SIZE=5 COLOR=#FF0000>Overview
of </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.net</FONT></B></TT></A>
</H2>
<P>
The <TT>java.net</TT> package provides several classes that support
socket-based client/server communication.
<P>
The <TT>InetAddress</TT> class encapsulates Internet IP addresses
and supports conversion between dotted decimal addresses and hostnames.
<P>
The <TT>Socket</TT>, <TT>ServerSocket</TT>, and <TT>DatagramSocket</TT>
classes implement client and server sockets for connection-oriented
and connectionless communication. The <TT>SocketImpl</TT> class
and the <TT>SocketImplFactory</TT> interface provide hooks for
implementing custom sockets.
<P>
The <TT>URL</TT>, <TT>URLConnection</TT>, and <TT>URLEncoder</TT>
classes implement high-level browser-server Web connections. The
<TT>ContentHandler</TT> and <TT>URLStreamHandler</TT> classes
are <TT>abstract</TT> classes that provide the basis for the implementation
of Web content and stream handlers. They are supported by the
<TT>ContentHandlerFactory</TT> and <TT>URLStreamHandlerFactory</TT>
interfaces.
<H2><A NAME="TheInetAddressClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">InetAddress</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>InetAddress</TT> class encapsulates Internet addresses.
It supports both numeric IP addresses and hostnames.
<P>
The <TT>InetAddress</TT> class has no <TT>public</TT> variables
or constructors. It provides eight access methods that support
common operations on Internet addresses. Three of these methods
are <TT>static</TT>.
<P>
The <TT>getLocalHost()</TT> method is a <TT>static</TT> method
that returns an <TT>InetAddress</TT> object representing the Internet
address of the local host computer. The <TT>static</TT> <TT>getByName()</TT>
method returns an <TT>InetAddress</TT> object for a specified
host. The <TT>static</TT> <TT>getAllByName()</TT> method returns
an array of all Internet addresses associated with a particular
host.
<P>
The <TT>getAddress()</TT> method gets the numeric IP address of
the host identified by the <TT>InetAddress</TT> object, and the
<TT>getHostName()</TT> method gets its domain name.
<P>
The <TT>equals()</TT>, <TT>hashCode()</TT>, and <TT>toString()</TT>
methods override those of the <TT>Object</TT> class.
<P>
The <TT>NSLookupApp</TT> program illustrates the use of the <TT>InetAddress</TT>
class. It takes a hostname as a parameter and identifies the primary
IP address associated with that host. (See Listing 17.1.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.1. The source code of the </B><TT><B><FONT FACE="Courier New">NSLookupApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.net.InetAddress;<BR>
<FONT FACE="Courier New">import java.net.UnknownHostException;
<BR>
import java.lang.System;<BR>
<BR>
public class NSLookupApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;if(args.length!=1){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Usage: java NSLookupApp
hostName&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;InetAddress host = InetAddress.getByName(args[0]);
<BR>
&nbsp;&nbsp;&nbsp;String hostName = host.getHostName();<BR>
&nbsp;&nbsp;&nbsp;byte ipAddress[] = host.getAddress();<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Host name: &quot;+hostName);
<BR>
&nbsp;&nbsp;&nbsp;System.out.print(&quot;IP address: &quot;);
<BR>
&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;ipAddress.length;++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.print((ipAddress[i]+256)%256+&quot;.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;}catch(UnknownHostException ex) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown host&quot;);
<BR>
&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Compile <TT>NSLookupApp</TT> and run it as follows:
<BLOCKQUOTE>
<TT>C:\java\jdg\ch17&gt;java NSLookupApp sun.com<BR>
<FONT FACE="Courier New">Host name: sun.com<BR>
IP address: 192.9.9.1.</FONT></TT>
</BLOCKQUOTE>
<P>
This code example uses <TT>NSLookupApp</TT> to look up the primary
IP address associated with the <TT>sun.com</TT> host. Try it with
other Internet hostnames to look up their IP addresses.
<P>
<TT>NSLookupApp</TT> consists of a single <TT>main()</TT> method.
A <TT>try</TT> statement surrounds most of the program's statements.
It is used to catch the <TT>UnknownHostException</TT>, which is
generated when an invalid hostname is entered by the user or when
a hostname cannot be looked up from a DNS server.
<P>
<TT>NSLookupApp</TT> first checks the number of arguments supplied
in the program invocation to make sure that a hostname argument
is provided by the user. It then uses the hostname string of the
first user argument with the <TT>static</TT> <TT>getByName()</TT>
method of the <TT>InetAddress</TT> class to create an <TT>InetAddress</TT>
object based on the user-supplied hostname. This <TT>InetAddress</TT>
object is assigned to the <TT>host</TT> variable. The <TT>getHostName()</TT>
method gets the host's name from the host variable and assigns
it to the <TT>hostName</TT> variable. The <TT>getAddress()</TT>
method returns the four bytes of the host's IP address. The byte
array is assigned to the <TT>ipAddress[]</TT> array. The hostname
and IP address are then printed to the console window. The bytes
of the <TT>ipAddress[]</TT> array are converted to positive 8-bit
integers before they are printed.
<H2><A NAME="TheSocketClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Socket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>Socket</TT> class implements client connection-based sockets.
These sockets are used to develop applications that utilize services
provided by connection-oriented server applications.
<P>
The <TT>Socket</TT> class provides four constructors that create
sockets and connect them to a destination host and port. The access
methods are used to access the I/O streams and connection parameters
associated with a connected socket.
<P>
The <TT>getInetAddress()</TT> and <TT>getPort()</TT> methods get
the IP address of the destination host and the destination host
port number to which the socket is connected. The <TT>getLocalPort()</TT>
method returns the source host local port number associated with
the socket. The <TT>getInputStream()</TT> and <TT>getOutputStream()</TT>
methods are used to access the input and output streams associated
with a socket. The <TT>close()</TT> method is used to close a
socket.
<P>
The <TT>setSocketImplFactory()</TT> class method is used to switch
from the default Java socket implementation to a custom socket
implementation.
<P>
The <TT>PortTalkApp</TT> program is used to talk to a particular
port on a given host on a line-by-line basis. It provides the
option of sending a line to the specified port, receiving a line
from the other host, or terminating the connection. Its source
code is shown in Listing 17.2.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.2. The source code of the </B><TT><B><FONT FACE="Courier New">PortTalkApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.Socket;<BR>
import java.net.InetAddress;<BR>
import java.net.UnknownHostException;<BR>
import java.io.DataInputStream;<BR>
import java.io.DataOutputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class PortTalkApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;PortTalk portTalk = new PortTalk(args);<BR>
&nbsp;&nbsp;portTalk.displayDestinationParameters();<BR>
&nbsp;&nbsp;portTalk.displayLocalParameters();<BR>
&nbsp;&nbsp;portTalk.chat();<BR>
&nbsp;&nbsp;portTalk.shutdown();<BR>
&nbsp;}<BR>
}<BR>
<BR>
class PortTalk {<BR>
&nbsp;Socket connection;<BR>
&nbsp;DataOutputStream outStream;<BR>
&nbsp;DataInputStream inStream;<BR>
&nbsp;public PortTalk(String args[]){<BR>
&nbsp;&nbsp;if(args.length!=2) error(&quot;Usage: java PortTalkApp
host port&quot;);<BR>
&nbsp;&nbsp;String destination = args[0];<BR>
&nbsp;&nbsp;int port = 0;<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;port = Integer.valueOf(args[1]).intValue();
<BR>
&nbsp;&nbsp;}catch (NumberFormatException ex) error(&quot;Invalid
port number&quot;);<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;connection = new Socket(destination,port);<BR>
&nbsp;&nbsp;}catch (UnknownHostException ex) error(&quot;Unknown
host&quot;);<BR>
&nbsp;&nbsp;catch (IOException ex) error(&quot;IO error creating
socket&quot;);<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;inStream = new DataInputStream(connection.getInputStream());
<BR>
&nbsp;&nbsp;&nbsp;outStream = new DataOutputStream(connection.getOutputStream());
<BR>
&nbsp;&nbsp;}catch (IOException ex) error(&quot;IO error getting
streams&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;Connected to &quot;+destination+&quot;
at port &quot;+port+&quot;.&quot;);<BR>
&nbsp;}<BR>
&nbsp;public void displayDestinationParameters(){<BR>
&nbsp;&nbsp;InetAddress destAddress = connection.getInetAddress();
<BR>
&nbsp;&nbsp;String name = destAddress.getHostName();<BR>
&nbsp;&nbsp;byte ipAddress[] = destAddress.getAddress();<BR>
&nbsp;&nbsp;int port = connection.getPort();<BR>
&nbsp;&nbsp;displayParameters(&quot;Destination &quot;,name,ipAddress,port);
<BR>
&nbsp;}<BR>
&nbsp;public void displayLocalParameters(){<BR>
&nbsp;&nbsp;InetAddress localAddress = null;<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;localAddress = InetAddress.getLocalHost();<BR>
&nbsp;&nbsp;}catch (UnknownHostException ex) error(&quot;Error
getting local host information&quot;);<BR>
&nbsp;&nbsp;String name = localAddress.getHostName();<BR>
&nbsp;&nbsp;byte ipAddress[] = localAddress.getAddress();<BR>
&nbsp;&nbsp;int port = connection.getLocalPort();<BR>
&nbsp;&nbsp;displayParameters(&quot;Local &quot;,name,ipAddress,port);
<BR>
&nbsp;}<BR>
&nbsp;public void displayParameters(String s,String name,byte
ipAddress[],int port){<BR>
&nbsp;&nbsp;System.out.println(s+&quot;host is &quot;+name+&quot;.&quot;);
<BR>
&nbsp;&nbsp;System.out.print(s+&quot;IP address is &quot;);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;ipAddress.length;++i)<BR>
&nbsp;&nbsp;&nbsp;System.out.print((ipAddress[i]+256)%256+&quot;.&quot;);
<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;System.out.println(s+&quot;port number is &quot;+port+&quot;.&quot;);
<BR>
&nbsp;}<BR>
&nbsp;public void chat(){<BR>
&nbsp;&nbsp;DataInputStream keyboardInput = new DataInputStream(System.in);
<BR>
&nbsp;&nbsp;boolean finished = false;<BR>
&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;Send, receive,
or quit (S/R/Q): &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String line = keyboardInput.readLine();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(line.length()&gt;0){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line=line.toUpperCase();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (line.charAt(0)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'S':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String sendLine = keyboardInput.readLine();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeBytes(sendLine);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(13);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'R':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inByte;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;***&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((inByte = inStream.read())
!= '\n')<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.write(inByte);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 'Q':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finished=true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}catch (IOException ex) error(&quot;Error reading
from keyboard or socket&quot;);<BR>
&nbsp;&nbsp;} while(!finished);<BR>
&nbsp;}<BR>
&nbsp;public void shutdown(){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;connection.close();<BR>
&nbsp;&nbsp;}catch (IOException ex) error(&quot;IO error closing
socket&quot;);<BR>
&nbsp;}<BR>
&nbsp;public void error(String s){<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;System.exit(1);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
To see how <TT>PortTalkApp</TT> works, run it using the following
command line:
<BLOCKQUOTE>
<TT>C:\java\jdg\ch17&gt;java PortTalkApp jaworski.com 7<BR>
<FONT FACE="Courier New">Connected to jaworski.com at port 7.
<BR>
Destination host is jaworski.com.<BR>
Destination IP address is 204.212.153.193.<BR>
Destination port number is 7.<BR>
Local host is athome.jaworski.com.<BR>
Local IP address is 204.212.153.194.<BR>
Local port number is 1298.<BR>
Send, receive, or quit (S/R/Q):</FONT></TT>
</BLOCKQUOTE>

<P>
<TT>PortTalkApp</TT> connects to my server at port 7. This is
the port number for the <TT>echo</TT> server application. It is
used to test Internet communication between hosts. It identifies
my host's name, IP address, and destination port number. In this
example, I am connecting from another computer on my local area
network. Its name is <TT>athome.jaworski.com</TT> and has the
<TT>204.212.153.194</TT> IP address. When you run the program,
your hostname and IP address will be displayed. The local port
number that I am connecting from is port 1298.
<P>
<TT>PortTalkApp</TT> asks you whether you want to send a line,
receive a line, or quit the program. Whether you elect to send
or receive is important. If you decide to receive a line and the
host is not sending any data, your program will block while it
waits to receive information from a socket-based stream.
<P>
Enter an <TT>S</TT> to send a line and then enter <TT>This is
a test!</TT> on the following line, like this:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): s</TT>
</BLOCKQUOTE>
<P>
This is a test!
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q):</TT>
</BLOCKQUOTE>
<P>
<TT>PortTalkApp</TT> will send your line to port 7 on my host
and then prompt you for your next command. Enter <TT>R</TT> to
receive a line of text from my server:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): r<BR>
<FONT FACE="Courier New">***This is a test!<BR>
Send, receive, or quit (S/R/Q):</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>PortTalkApp</TT> reads a line of text from the socket stream
and displays it prefixed with three asterisks. Now enter <TT>Q</TT>
to close the connection and terminate the program. You can also
use <TT>PortTalkApp</TT> to talk to other ports. For example,
you can use it to talk to port 25 of hosts that support the Simple
Mail Transport Protocol to send e-mail to someone who is served
by that host.
<P>
<TT>PortTalkApp</TT> consists of a simple <TT>main()</TT> function
that creates an object of class <TT>PortTalk</TT>,  passing it
the user-supplied host and port arguments. It invokes the <TT>displayDestinationParameters()</TT>
and <TT>displayLocalParameters()</TT> methods of the <TT>PortTalk</TT>
class to provide the initial connection-status information. The
<TT>chat()</TT> method is used to send and receive lines of text
over an established connection. The <TT>shutdown()</TT> method
terminates the connection.
<P>
The <TT>PortTalk</TT> class implements the bulk of the processing
performed by the program. It declares three field variables. The
<TT>connection</TT> variable keeps track of the socket used with
the connection. The <TT>inStream</TT> and <TT>outStream</TT> variables
maintain the input and output streams derived from the socket.
<P>
The <TT>PortTalk</TT> constructor checks the arguments supplied
by the user to make sure that a host and port number were supplied
and converts the user-supplied port number to an integer. The
<TT>error()</TT> method is used to display any errors to the console
window. A new <TT>Socket</TT> object is created using the specified
destination hostname and port number and is assigned to the <TT>connection</TT>
variable. The <TT>getInputStream()</TT> and <TT>getOutputStream()</TT>
methods of the <TT>Socket</TT> class are used to attach input
and output streams to the socket identified by the <TT>connection</TT>
variable. These streams are then filtered as <TT>DataInputStream</TT>
and <TT>DataOutputStream</TT> objects and assigned to the <TT>inStream</TT>
and <TT>outStream</TT> variables. The constructor ends by displaying
a connection status message to the console window.
<P>
The <TT>displayDestinationParameters()</TT> method uses the <TT>getInetAdress()</TT>
method of the <TT>Socket</TT> class to get the <TT>InetAddress</TT>
object associated with the destination host of the connection.
It uses the <TT>getHostName()</TT> and <TT>getAddress()</TT> methods
of the <TT>InetAddress</TT> class to obtain the name and IP address
of the destination host. The <TT>getPort()</TT> method of the
<TT>Socket</TT> class is used to get the destination port number.
These parameters are displayed using the <TT>displayParameters()</TT>
method.
<P>
The <TT>displayLocalParameters()</TT> method uses the <TT>getLocalHost()</TT>,
<TT>getHostName()</TT>, and <TT>getAddress()</TT> methods of the
<TT>InetAddress</TT> class to obtain the <TT>InetAddress</TT>
object, name, and IP address of the local host. The <TT>getLocalPort()</TT>
method of the <TT>Socket</TT> class is used to get the local port
number. These parameters are displayed using the <TT>displayParameters()</TT>
method.
<P>
The <TT>displayParameters()</TT> method displays the hostname,
IP address, and port number of an end of a socket connection.
The <TT>s</TT> string parameter is used to differentiate between
a local and destination host.
<P>
The <TT>chat()</TT> method implements the heart of the <TT>PortTalkApp</TT>
program. It displays the <TT>Send, receive, or quit (S/R/Q):</TT>
prompt to the user and then reads an input line from the user's
keyboard.
<P>
If the user enters <TT>S</TT> for send, another line is read from
the user's keyboard. This line is then written to the output stream
associated with the socket connection. A carriage return and a
line-feed character are then written to the output stream to signal
an end of line. The carriage return-linefeed combination is the
standard end-of-line identifier used with Internet application
protocols.
<P>
If the user enters <TT>R</TT> for receive, three asterisks (<TT>***</TT>)
are written to the console window to indicate input from the destination
host. One byte at a time is then read from the input stream associated
with the socket and displayed to the console window until a newline
(<TT>\n</TT>) character is encountered.
<P>
If the user enters <TT>Q</TT> for quit, the <TT>do</TT> loop of
the <TT>chat()</TT> method is terminated.
<P>
The <TT>shutdown()</TT> method closes the <TT>Socket</TT> object
referenced by the connection variable.
<P>
The <TT>error()</TT> method prints an error message to the console
window and then terminates the program using the <TT>exit()</TT>
method of the <TT>System</TT> class.
<H2><A NAME="TheServerSocketClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">ServerSocket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>ServerSocket</TT> class implements a TCP server socket.
It provides two constructors that specify the port to which the
server socket is to listen for incoming connection requests. An
optional <TT>count</TT> parameter may be supplied to specify the
amount of time that the socket should listen for an incoming connection.
<P>
The <TT>accept()</TT> method is used to cause the server socket
to listen and wait until an incoming connection is established.
It returns an object of class <TT>Socket</TT> once a connection
is made. This <TT>Socket</TT> object is then used to carry out
a service for a single client. The <TT>getInetAddress()</TT> method
returns the address of the host to which the socket is connected.
The <TT>getLocalPort()</TT> method returns the port on which the
server socket listens for an incoming connection. The <TT>toString()</TT>
method returns the socket's address and port number as a string
in preparation for printing.
<P>
The <TT>close()</TT> method closes the server socket.
<P>
The static <TT>setSocketFactory()</TT> method is used to change
the default <TT>ServerSocket</TT> implementation to a custom implementation.
<P>
The <TT>ReverServerApp</TT> program is a simple server that listens
on port 1234 for incoming connections from client programs. When
<TT>ReverServerApp</TT> connects to a client, it reads one line
of text at a time from the client, reverses the characters in
the text line, and sends them back to the client. The source code
of <TT>ReverServerApp</TT> is shown in Listing 17.3.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.3. The source code of the </B><TT><B><FONT FACE="Courier New">ReverServerApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.ServerSocket;<BR>
import java.net.Socket;<BR>
import java.io.IOException;<BR>
import java.io.DataInputStream;<BR>
import java.io.DataOutputStream;<BR>
<BR>
public class ReverServerApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;ServerSocket server = new ServerSocket(1234);
<BR>
&nbsp;&nbsp;&nbsp;int localPort = server.getLocalPort();<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Reverse Server is listening
on port &quot;+localPort+&quot;.&quot;);<BR>
&nbsp;&nbsp;&nbsp;Socket client = server.accept();<BR>
&nbsp;&nbsp;&nbsp;String destName = client.getInetAddress().getHostName();
<BR>
&nbsp;&nbsp;&nbsp;int destPort = client.getPort();<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Accepted connection
to &quot;+destName+&quot; on port &quot;+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;destPort+&quot;.&quot;);<BR>
&nbsp;&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(client.getInputStream());
<BR>
&nbsp;&nbsp;&nbsp;DataOutputStream outStream = new DataOutputStream(client.getOutputStream());
<BR>
&nbsp;&nbsp;&nbsp;boolean finished = false;<BR>
&nbsp;&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String inLine = inStream.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Received: &quot;+inLine);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(inLine.equalsIgnoreCase(&quot;quit&quot;))
finished=true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String outLine=new ReverseString(inLine.trim()).getString();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;outLine.length();++i)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write((byte)outLine.charAt(i));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(13);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Sent: &quot;+outLine);
<BR>
&nbsp;&nbsp;&nbsp;} while(!finished);<BR>
&nbsp;&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;&nbsp;client.close();<BR>
&nbsp;&nbsp;&nbsp;server.close();<BR>
&nbsp;&nbsp;}catch (IOException ex){<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException occurred.&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}<BR>
class ReverseString {<BR>
&nbsp;String s;<BR>
&nbsp;public ReverseString(String in){<BR>
&nbsp;&nbsp;int len = in.length();<BR>
&nbsp;&nbsp;char outChars[] = new char[len];<BR>
&nbsp;&nbsp;for(int i=0;i&lt;len;++i)<BR>
&nbsp;&nbsp;&nbsp;outChars[len-1-i]=in.charAt(i);<BR>
&nbsp;&nbsp;s = String.valueOf(outChars);<BR>
&nbsp;}<BR>
&nbsp;public String getString(){<BR>
&nbsp;&nbsp;return s;<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
To see how <TT>ReverServerApp</TT> works, you need to run it in
a separate window and then use <TT>PortTalkApp</TT> to feed it
lines of text. First, run <TT>ReverServerApp</TT> using the following
command line:
<P>
<TT>C:\java\jdg\ch17&gt;java ReverServerApp</TT>
<P>
<TT>Reverse Server is listening on port 1234.</TT>
<P>
<TT>ReverServerApp</TT> notifies you that it is up and running.
Now, in a separate window run <TT>PortTalkApp</TT> as follows,
supplying your hostname instead of <TT>athome.jaworski.com</TT>:
<BLOCKQUOTE>
<TT>C:\java\jdg\ch17&gt;java PortTalkApp athome.jaworski.com 1234
<BR>
<FONT FACE="Courier New">Connected to athome.jaworski.com at port
1234.<BR>
Destination host is athome.jaworski.com.<BR>
Destination IP address is 204.212.153.194.<BR>
Destination port number is 1234.<BR>
Local host is athome.jaworski.com.<BR>
Local IP address is 204.212.153.194.<BR>
Local port number is 1302.<BR>
Send, receive, or quit (S/R/Q):</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>PortTalkApp</TT> displays all of the parameters of both endpoints
of the connection. If you look in the window where <TT>ReverServerApp</TT>
is running, you will see a message similar to the following:
<P>
<TT>Accepted connection to athome.jaworski.com on port 1302.</TT>
<P>
The port number reported by <TT>ReverServer</TT> is consistent
with that reported by <TT>PortTalkApp</TT>. Now switch back to
the <TT>PortTalkApp</TT> window and enter <TT>S</TT> to send a
line of text, followed by the line of text <TT>This is a test!</TT>,
as shown in the following output:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): s<BR>
<FONT FACE="Courier New">This is a test!</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT>ReverServerApp</TT> window reports the following:
<BLOCKQUOTE>
<TT>Received: This is a test!<BR>
<FONT FACE="Courier New">Sent: !tset a si sihT</FONT></TT>
</BLOCKQUOTE>
<P>
Enter an <TT>R</TT> in the <TT>PortTalkApp</TT> window, as shown
in the following output:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): r<BR>
<FONT FACE="Courier New">***!tset a si sihT<BR>
Send, receive, or quit (S/R/Q):</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>PortTalkApp</TT> displays the text that it received from <TT>ReverServerApp</TT>.
Enter the <TT>S</TT> command followed by a <TT>quit</TT> text
line:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): s<BR>
<FONT FACE="Courier New">quit</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT>quit</TT> line is read by <TT>ReverServerApp</TT>, causing
it to terminate the connection and exit. It displays the following:
<BLOCKQUOTE>
<TT>Received: quit<BR>
<FONT FACE="Courier New">Sent: tiuq<BR>
<BR>
C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
In the <TT>PortTalkApp</TT> window, type <TT>Q</TT> to terminate
<TT>PortTalkApp</TT>, as shown in the following output:
<BLOCKQUOTE>
<TT>Send, receive, or quit (S/R/Q): q<BR>
<BR>
<FONT FACE="Courier New">C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT>ReverServerApp</TT> program is smaller in size than <TT>PortTalkApp</TT>.
It consists of a single <TT>main()</TT> method. The <TT>ReverseString</TT>
class is also declared.
<P>
The <TT>main()</TT> method begins by creating a <TT>ServerSocket</TT>
object on port 1234. It then uses the <TT>getLocalPort()</TT>
method to get the local port number associated with the socket.
This is to verify that it is indeed using port 1234. It then displays
the fact that it is up and running and the number of the port
on which it is listening for connections.
<P>
The <TT>accept()</TT> method is used to accept an incoming client
connection and return the <TT>Socket</TT> object associated with
the connection. The <TT>getHostName()</TT> and <TT>getPort()</TT>
methods are used to get the hostname and port number associated
with the client program. These parameters are displayed to the
console window. Input and output streams are then associated with
the socket.
<P>
The <TT>main()</TT> method enters a loop where it reads a line
of text from the input stream and then checks to see if it is
the <TT>quit</TT> termination signal. The <TT>ReverseString()</TT>
constructor and <TT>getString()</TT> method are used to reverse
the line read from the input stream. The reversed line is then
written to the output stream. If the <TT>quit</TT> line is received
from the client, the loop is terminated and the input stream,
output stream, client socket, and server socket are closed.
<P>
The <TT>ReverseString</TT> class provides a constructor that reverses
a string and a <TT>getString()</TT> method for retrieving the
reversed string.
<H2><A NAME="TheDatagramSocketClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">DatagramSocket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>DatagramSocket</TT> class is used to implement client
and server sockets using the UDP protocol. UDP is a connectionless
protocol that allows application programs (both clients and servers)
to exchange information using chunks of data known as <I>datagrams</I>.
<P>
<TT>DatagramSocket</TT> provides two constructors. The default
constructor creates a datagram socket for use by client applications.
No port number is specified. The second constructor allows a datagram
socket to be created using a specified port. This constructor
is typically used with server applications.
<P>
The <TT>send()</TT> and <TT>receive()</TT> methods are used to
send and receive datagrams using the socket. The datagrams are
objects of class <TT>DatagramPacket</TT>. The <TT>getLocalPort()</TT>
method returns the local port used in the socket. The <TT>close()</TT>
method closes this socket, and the <TT>finalize()</TT> method
performs additional socket-termination processing when the socket
is deallocated during garbage collection.
<H2><A NAME="TheDatagramPacketClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">DatagramPacket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>DatagramPacket</TT> class encapsulates the actual datagrams
that are sent and received using objects of class <TT>DatagramSocket</TT>.
Two different constructors are provided: one for datagrams that
are received from a datagram socket and one for creating datagrams
that are sent over a datagram socket. The arguments to the received
datagram constructor are a byte array used as a buffer for the
received data and an integer that identifies the number of bytes
received and stored in the buffer. The sending datagram constructor
adds two additional parameters: the IP address and port where
the datagram is to be sent.
<P>
Four access methods are provided. The <TT>getAddress()</TT> and
<TT>getPort()</TT> methods are used to read the destination IP
address and port of the datagram. The <TT>getLength()</TT> and
<TT>getData()</TT> methods are used to get the number of bytes
of data contained in the datagram and to read the data into a
byte array buffer.
<P>
The <TT>TimeServerApp</TT> and <TT>GetTimeApp</TT> programs illustrate
the use of client/server computing using datagrams. <TT>TimeServerApp</TT>
listens on a UDP socket on port 2345 for incoming datagrams. When
a datagram is received, it displays the data contained in the
datagram to the console window and returns a datagram with the
current date and time to the sending client program. It terminates
its operation when it receives a datagram with the text <TT>quit</TT>
as its data.
<P>
The <TT>GetTimeApp</TT> program sends five datagrams with the
text <TT>time</TT> in each datagram to local port 2345. After
sending each datagram, it waits for a return datagram from <TT>TimeServerApp</TT>.
It displays the datagrams that it sends and receives to the console
window. It then sends a <TT>quit</TT> datagram to <TT>TimeServerApp</TT>
and terminates its operation.
<P>
The <TT>TimeServerApp</TT> program listing is shown in Listing
17.4. The code for <TT>GetTimeApp</TT> is in Listing 17.5.
<P>

<HR>
<BLOCKQUOTE>
<B>Listing 17.4. The source code of the </B><TT><B><FONT FACE="Courier New">TimeServerApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.DatagramSocket;<BR>
import java.net.DatagramPacket;<BR>
import java.net.InetAddress;<BR>
import java.io.IOException;<BR>
import java.util.Date;<BR>
<BR>
public class TimeServerApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;DatagramSocket socket = new DatagramSocket(2345);
<BR>
&nbsp;&nbsp;&nbsp;String localAddress = InetAddress.getLocalHost().getHostName().trim();
<BR>
&nbsp;&nbsp;&nbsp;int localPort = socket.getLocalPort();<BR>
&nbsp;&nbsp;&nbsp;System.out.print(localAddress+&quot;: &quot;);
<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Time Server is listening
on port &quot;+localPort+&quot;.&quot;);<BR>
&nbsp;&nbsp;&nbsp;int bufferLength = 256;<BR>
&nbsp;&nbsp;&nbsp;byte packetBuffer[] = new byte[bufferLength];
<BR>
&nbsp;&nbsp;&nbsp;DatagramPacket datagram = new DatagramPacket(packetBuffer,bufferLength);
<BR>
&nbsp;&nbsp;&nbsp;boolean finished = false;<BR>
&nbsp;&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(datagram);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;InetAddress destAddress = datagram.getAddress();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String destHost = destAddress.getHostName().trim();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int destPort = datagram.getPort();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;\nReceived a
datagram from &quot;+destHost+&quot; at port &quot;+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort+&quot;.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String data = new String(datagram.getData(),0).trim();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It contained
the data: &quot;+data);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(data.equalsIgnoreCase(&quot;quit&quot;))
finished=true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String time = new Date().toString();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;time.getBytes(0,time.length(),packetBuffer,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;datagram = new DatagramPacket(packetBuffer,bufferLength,destAddress,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;socket.send(datagram);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Sent &quot;+time+&quot;
to &quot;+destHost+&quot; at port &quot;+destPort+&quot;.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;} while(!finished);<BR>
&nbsp;&nbsp;}catch (IOException ex){<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException occurred.&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.5.</B> <B>The source code of the </B><TT><B><FONT FACE="Courier New">GetTimeApp</FONT></B></TT><B>
program</B><I>.</I>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.DatagramSocket;<BR>
import java.net.DatagramPacket;<BR>
import java.net.InetAddress;<BR>
import java.io.IOException;<BR>
<BR>
public class GetTimeApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;DatagramSocket socket = new DatagramSocket();
<BR>
&nbsp;&nbsp;&nbsp;InetAddress localAddress = InetAddress.getLocalHost();
<BR>
&nbsp;&nbsp;&nbsp;String localHost = localAddress.getHostName();
<BR>
&nbsp;&nbsp;&nbsp;int bufferLength = 256;<BR>
&nbsp;&nbsp;&nbsp;byte packetBuffer[];<BR>
&nbsp;&nbsp;&nbsp;DatagramPacket datagram;<BR>
&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;5;++i){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;packetBuffer = new byte[bufferLength];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;time&quot;.getBytes(0,4,packetBuffer,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;datagram = new DatagramPacket(packetBuffer,256,localAddress,2345);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;socket.send(datagram);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;\nSent time request
to &quot;+localHost+&quot; at port 2345.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(datagram);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;InetAddress destAddress = datagram.getAddress();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String destHost = destAddress.getHostName().trim();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int destPort = datagram.getPort();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Received a datagram
from &quot;+destHost+&quot; at port &quot;+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort+&quot;.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String data = new String(datagram.getData(),0).trim();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It contained
the following data: &quot;+data);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;packetBuffer = new byte[bufferLength];<BR>
&nbsp;&nbsp;&nbsp;&quot;quit&quot;.getBytes(0,4,packetBuffer,0);
<BR>
&nbsp;&nbsp;&nbsp;datagram = new DatagramPacket(packetBuffer,256,localAddress,2345);
<BR>
&nbsp;&nbsp;&nbsp;socket.send(datagram);<BR>
&nbsp;&nbsp;}catch (IOException ex){<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException occurred.&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT>TimeServerApp</TT> and <TT>GetTimeApp</TT> should be run in
separate windows. First, start <TT>TimeServerApp</TT> using the
following command line:

<TT>C:\java\jdg\ch17&gt;java TimeServerApp<BR>

<FONT FACE="Courier New">athome.jaworski.com: Time Server is listening
on port 2345.</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>TimeServerApp</TT> will respond by letting you know that it
is up and running and listening on port 2345.
<P>
Next start <TT>GetTimeApp</TT> in a different window, as follows:
<BLOCKQUOTE>
<TT>C:\java\jdg\ch17&gt;java GetTimeApp<BR>
</BLOCKQUOTE>
<BR>
<FONT FACE="Courier New">Sent time request to athome.jaworski.com
at port 2345.<BR>
Received a datagram from athome.jaworski.com at port 2345.<BR>
It contained the following data: Tue Mar 19 15:12:23  1996<BR>
<BR>
Sent time request to athome.jaworski.com at port 2345.<BR>
Received a datagram from athome.jaworski.com at port 2345.<BR>
It contained the following data: Tue Mar 19 15:12:23  1996<BR>
<BR>
Sent time request to athome.jaworski.com at port 2345.<BR>
Received a datagram from athome.jaworski.com at port 2345.<BR>
It contained the following data: Tue Mar 19 15:12:23  1996<BR>
<BR>
Sent time request to athome.jaworski.com at port 2345.<BR>
Received a datagram from athome.jaworski.com at port 2345.<BR>
It contained the following data: Tue Mar 19 15:12:24  1996<BR>
<BR>
Sent time request to athome.jaworski.com at port 2345.<BR>
Received a datagram from athome.jaworski.com at port 2345.<BR>
It contained the following data: Tue Mar 19 15:12:24  1996<BR>
<BR>
<BLOCKQUOTE>
C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>GetTimeApp</TT><FONT SIZE=2> reports the packets it sends
to and receives from </FONT><TT>TimeServerApp</TT><FONT SIZE=2>
and then terminates. </FONT><TT>TimeServerApp</TT><FONT SIZE=2>
provides a similar display in its window, as shown in the following:</FONT>
<TT>Received a datagram from athome.jaworski.com at port 1306.
<FONT FACE="Courier New">It contained the data: time<P>
Sent Tue Mar 19 15:12:23  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
Received a datagram from athome.jaworski.com at port 1306.<BR>
It contained the data: time<BR>
Sent Tue Mar 19 15:12:23  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
Received a datagram from athome.jaworski.com at port 1306.<BR>
It contained the data: time<BR>
Sent Tue Mar 19 15:12:23  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
Received a datagram from athome.jaworski.com at port 1306.<BR>
It contained the data: time<BR>
Sent Tue Mar 19 15:12:24  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
Received a datagram from athome.jaworski.com at port 1306.<BR>
It contained the data: time<BR>
Sent Tue Mar 19 15:12:24  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
Received a datagram from athome.jaworski.com at port 1306.<BR>
It contained the data: quit<BR>
Sent Tue Mar 19 15:12:24  1996 to athome.jaworski.com at port
1306.<BR>
<BR>
<BLOCKQUOTE>
C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>

<P>
These two simple programs illustrate the basic mechanisms of datagram-based
client/server applications. A UDP client sends a datagram to a
UDP server at the server's port address. The UDP server listens
on its port for a datagram, processes the datagram, and sends
back information to the UDP client.
<H3><A NAME="TimeServerApp"><TT><B><FONT SIZE=4 FACE="Courier New">TimeServerApp</FONT></B></TT></A>
</H3>
<P>
<TT>TimeServerApp</TT> begins by creating a <TT>DatagramSocket</TT>
object on port 2345 and assigning it to the socket variable. It
then obtains the hostname and local port number using the <TT>getHostName()</TT>
and <TT>getLocalPort()</TT> methods and displays this information
to the console window.
<P>
<TT>TimeServerApp</TT> creates a 256-byte buffer and assigns it
to the <TT>packetBuffer[]</TT> array. It then creates a <TT>DatagramPacket</TT>
object using the <TT>packetBuffer[]</TT> array and assigns it
to the <TT>datagram</TT> variable.
<P>
<TT>TimeServerApp</TT> executes a loop where it receives and processes
datagrams received from client programs. It receives datagrams
using the <TT>receive()</TT> method of the <TT>DatagramSocket</TT>
class. It uses the <TT>getAddress()</TT> and <TT>getPort()</TT>
methods of the <TT>DatagramPacket</TT> class to get the host address
and port of the client program that sent the socket. It displays
this information to the console window. It uses the <TT>getData()</TT>
method of the <TT>DatagramPacket</TT> class to retrieve the data
sent by the client program. It converts this data to a string
and displays it on the console window. If the received data contains
the <TT>quit</TT> string, it sets the finished flag to <TT>true</TT>.
<TT>TimeServerApp</TT> processes the client time request by using
the <TT>Date()</TT> constructor of the <TT>java.util</TT> package
to construct a new <TT>Date</TT> object, converting the <TT>Date</TT>
object to a byte array, and storing the data in <TT>packetBuffer[]</TT>.
It then creates a new <TT>DatagramPacket</TT> object, using <TT>packetBuffer[]</TT>,
with the destination address and port number of the sending client
program. It then sends the datagram to the client using the <TT>send()</TT>
method of the <TT>DatagramSocket</TT> class. The console display
is then updated with the data that was sent to the client program.
<H3><A NAME="GetTimeApp"><TT><B><FONT SIZE=4 FACE="Courier New">GetTimeApp</FONT></B></TT></A>
</H3>
<P>
The <TT>GetTimeApp</TT> client program creates a <TT>DatagramSocket</TT>
object and assigns it to the <TT>socket</TT> variable. It then
creates a <TT>DatagramPacket</TT> object in the same manner as
the <TT>TimeServerApp</TT> program. <TT>GetTimeApp</TT> uses a
<TT>for</TT> statement to loop five times, sending five datagrams
to port 2345 of the local host. After each datagram is sent, it
waits to receive a return datagram from <TT>TimeServerApp</TT>.
It uses the <TT>getAddress()</TT>, <TT>getPort()</TT>, and <TT>getData()</TT>
methods of the <TT>DatagramPacket</TT> class to report this information
to the console window.
<P>
After sending and receiving five datagrams, <TT>GetTimeApp</TT>
sends a datagram with the <TT>quit</TT> text to tell <TT>TimeServerApp</TT>
that it should terminate its processing.
<H2><A NAME="TheSocketImplClassandtheSocketImplF"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">SocketImpl</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class and the </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">SocketImplFactory</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Interface</FONT></B></A></H2>
<P>
The <TT>SocketImpl</TT> class is an <TT>abstract</TT> class that
is used to define custom socket implementations. It is used with
the <TT>SocketImplFactory</TT> interface that must be implemented
by new socket implementations.<BR>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=572>
<BLOCKQUOTE>
The <TT>setSocketImplFactory()</TT> method of the <TT>Socket</TT> class can be used to set the system <TT>SocketImplFactory</TT>. Once it is set, it cannot be changed.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>SocketImpl</TT> class provides four variables that are
used to define a socket: the destination IP address and port,
the local port, and a file descriptor used to create streams.
The local IP address of the host is assumed.
<P>
Some of the access methods defined by <TT>SocketImpl</TT> are
used to perform lower-level socket operations. These include listening
for connections, accepting connections, binding a socket to a
port, and implementing the actual connection. Datagram sockets
are also supported. Other access methods are used to support stream-based
I/O and to provide access to the IP address and port parameters
of a socket.
<H2><A NAME="WebRelatedClasses"><B><FONT SIZE=5 COLOR=#FF0000>Web-Related
Classes</FONT></B></A></H2>
<P>
In addition to providing the basic TCP- and UDP-based sockets
used by almost all Internet client/server applications, the <TT>java.net</TT>
package provides a very useful set of classes that support higher-level,
Web-specific applications. These classes are centered around the
<TT>URL</TT> class, which encapsulates an object on the Web, typically
a Web page, by its URL address.
<P>
<I>URL</I> stands for <I>uniform resource locator</I> and, as
its name states, provides a uniform way to locate resources on
the Web. Different types of URLs are used with different application
protocols, the most common of which are the <I>Hypertext Transfer
Protocol</I> (HTTP) and the <I>File Transfer Protocol</I> (FTP).
URLs for these types of protocols are mainly used to identify
the location of files, such as Web pages, supporting images, multimedia
files, text files, and downloadable programs. HTTP URLs also refer
to executable programs, such as CGI scripts, which perform Web-related
services. <I>CGI scripts</I> are programs, usually written in
a scripting language, that receive input and generate output in
accordance with the <I>common gateway interface</I> (CGI) specification.
<H3><A NAME="URL"><TT><B><FONT SIZE=4 FACE="Courier New">URL</FONT></B></TT></A>
</H3>
<P>
The <TT>URL</TT> class encapsulates Web objects by their URL address.
It provides a set of constructors that allow <TT>URL</TT> objects
to be easily constructed and a set of access methods that allow
high-level read and write operations to be performed using URLs.
<P>
Most, but not all, URLs typically consist of a protocol, hostname,
and the path and name of a file on the host. For example, the
URL <TT><A TARGET="resource window" HREF="http://www.jaworski.com/jdg/index.htm">http://www.jaworski.com/jdg/index.htm</A></TT> refers to a
Web page on my Web server. It specifies the HTTP protocol as the
protocol used to access the Web page. It identifies my hostname
as <TT>www.jaworski.com</TT>, and it names the file as <TT>/jdg/index.htm</TT>
where <TT>/jdg/</TT> is the directory path to the file (relative
to my Web server's directory root) and <TT>index.htm</TT> is the
file's name. In HTTP URLs, the pathname/filename is optional.
For example, the URL <TT><A TARGET="resource window" HREF="http://www.jaworski.com/jdg/">http://www.jaworski.com/jdg/</A></TT> is
equivalent to the previous URL. My Web server uses the filename
<TT>index.htm</TT> as the default name for a file. The pathname
can also be omitted. The URL <TT><A TARGET="resource window" HREF="http://www.jaworski.com">http://www.jaworski.com</A></TT>
would use the <TT>index.htm</TT> file in the Web server's root
directory.
<P>
The four <TT>URL</TT> constructors allow <TT>URL</TT> objects
to be created using a variety of URL parameters such as protocol
type, hostname, port, and file path. These parameters may be supplied
separately or in text form as part of an URL string. The <TT>URL</TT>
class treats a file's path and name as a single entity to provide
a more convenient way of working with URL components.
<P>
You can construct an URL using its absolute address or using an
address that is relative to another URL. Up to now we have been
working with the full, complete, or <I>absolute</I> address of
an URL. A <I>relative address</I> is a path/filename or file offset
that is specified relative to an absolute URL. For example, the
absolute URL <TT><A TARGET="resource window" HREF="http://www.jaworski.com">http://www.jaworski.com</A></TT> can be combined
with the relative URL <TT>/jdg/index.htm</TT> to produce the URL
to <TT><A TARGET="resource window" HREF="http://www.jaworski.com/jdg/index.htm">http://www.jaworski.com/jdg/index.htm</A></TT>.
<P>
The <TT>URL</TT> access methods provide a full set of URL processing
capabilities. The <TT>getProtocol()</TT>, <TT>getHost()</TT>,
<TT>getPort()</TT>, <TT>getFile()</TT>, and <TT>getRef()</TT>
methods allow the individual address components of the URL to
be determined. The <TT>getContent()</TT> and <TT>openStream()</TT>
methods allow reading of the Web object pointed to by the URL.
The <TT>toExternalForm()</TT> and <TT>toString()</TT> methods
enable URLs to be converted into strings to support display and
printing. The <TT>equals()</TT> method compares URLs, and the
<TT>sameFile()</TT> method compares the Web objects pointed to
by the URLs. The <TT>openConnection()</TT> method creates an object
of class <TT>URLConnection</TT> to the Web object pointed to by
the URL. This class is discussed after the &quot;<TT>URLConnection</TT>&quot;
section of this chapter.
<P>
The <TT>GetURLApp</TT> program illustrates the power provided
by the <TT>URL</TT> class. This small program implements a primitive
Web browser. Just run the program with the name of an URL and
it makes a connection to the destination Web server and downloads
the referenced document. The program's source code is shown in
Listing 17.6.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.6. The source code of the </B><TT><B><FONT FACE="Courier New">GetURLApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.URL;<BR>
import java.net.MalformedURLException;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class GetURLApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;if(args.length!=1) error(&quot;Usage: java GetURLApp
URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Fetching URL: &quot;+args[0]);
<BR>
&nbsp;&nbsp;&nbsp;URL url = new URL(args[0]);<BR>
&nbsp;&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(url.openStream());
<BR>
&nbsp;&nbsp;&nbsp;String line;<BR>
&nbsp;&nbsp;&nbsp;while ((line = inStream.readLine())!= null){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(line);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;}catch (MalformedURLException ex){<BR>
&nbsp;&nbsp;&nbsp;error(&quot;Bad URL&quot;);<BR>
&nbsp;&nbsp;}catch (IOException ex){<BR>
&nbsp;&nbsp;&nbsp;error(&quot;IOException occurred.&quot;);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
&nbsp;public static void error(String s){<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;System.exit(1);<BR>
&nbsp;}<BR>
}<BR>
</BLOCKQUOTE>
<HR>
<P>
After compiling the program, try running it with the URL <A TARGET="resource window" HREF="http://www.jaworski.com/java/GetURLApp.htm">http://www.jaworski.com/java/GetURLApp.htm</A>
as follows. Make sure that you use the correct upper- and lowercase
characters:<BR>
C:\java\jdg\ch17&gt;java GetURLApp <A TARGET="resource window" HREF="http://www.jaworski.com/java/GetURLApp.htm">http://www.jaworski.com/java/GetURLApp.htm</A>
<BR>
The program will respond by displaying the following Web document
from my Web server:<BR>
C:\java\jdg\ch17&gt;java GetURLApp <A TARGET="resource window" HREF="http://www.jaworski.com/java/GetURLApp.htm">http://www.jaworski.com/java/GetURLApp.htm</A>
<BR>
Fetching URL: <A TARGET="resource window" HREF="http://www.jaworski.com/java/GetURLApp.htm">http://www.jaworski.com/java/GetURLApp.htm</A><BR>
&lt;!DOCTYPE HTML PUBLIC &quot;-//SQ//DTD HTML 2.0 HoTMetaL +
extensions//EN&quot;&gt;<BR>
&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;GetURLApp Test Results&lt;/TITLE&gt;&lt;/HEAD&gt;
<BR>
&lt;BODY&gt;&lt;H1&gt;GetURLApp Test Results&lt;/H1&gt;<BR>
&lt;P&gt;Congratulations! You were able to successfully compile
and run GetURLApp.<BR>
&lt;/P&gt;<BR>
&lt;/BODY&gt;&lt;/HTML&gt;<BR>
<BR>
<BLOCKQUOTE>
C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>

<P>
Try running the program with other URLs to see how they are displayed.
<P>
<TT>GetURLApp</TT> consists of a short <TT>main()</TT> method
and the <TT>error()</TT> method, used to display error messages
to the console window.
<P>
The <TT>main()</TT> method checks the arguments supplied by the
user to make sure that the correct number of arguments are present.
It then displays a message to the console window identifying the
URL that it is trying to fetch. It creates an <TT>URL</TT> object
using the URL name supplied by the user and assigns it to the
<TT>url</TT> variable. It then uses the <TT>openStream()</TT>
method of the <TT>URL</TT> class to create an input stream from
the URL. The input stream is filtered as a <TT>DataInputStream</TT>
object and is assigned to the <TT>inStream</TT> variable. The
<TT>inStream</TT> variable is used to read and display the input
stream one line at a time.
<H3><A NAME="URLConnection"><TT><B><FONT SIZE=4 FACE="Courier New">URLConnection</FONT></B></TT></A>
</H3>
<P>
The <TT>URLConnnection</TT> class is an <TT>abstract</TT> class
that encapsulates an active HTTP connection to a Web object represented
by an URL. It provides a number of methods for getting information
about the Web object, about the connection to the Web object,
and for interacting with the Web object.
<P>
<TT>URLConnection</TT> defines several class variables that specify
the connection state and associated parameters. It also supplies
numerous methods that provide access to the HTTP-specific fields
of the connection. This class is studied, in detail, in Part V
of this book. The next programming example covers a few aspects
of its use.
<H3><A NAME="URLEncoder"><TT><B><FONT SIZE=4 FACE="Courier New">URLEncoder</FONT></B></TT></A>
</H3>
<P>
The <TT>URLEncoder</TT> class is a very simple class that provides
a single <TT>static</TT> method, <TT>encode()</TT>, for converting
text strings to a form that is suitable for use as part of an
URL. This format is known as <TT>x&#173;www&#173;form&#173;urlencoded</TT>
and is typically used to encode form data that is sent to a CGI
script.
<P>
The <TT>encode()</TT> method converts spaces to plus signs (<TT>+</TT>)
and uses the percent character (<TT>%</TT>) as an escape code
to encode special characters. The two characters that immediately
follow a percent sign are interpreted as hexadecimal digits that
are combined to produce an eight-bit value.
<P>
Listing 17.7 illustrates the use of the <TT>encode()</TT> method
and the <TT>URLConnection</TT> class. It accesses the echo-query
CGI program on my Web server, passing it the <TT>&quot;/this/is/extra/path/
information&quot;</TT> query string and the <TT>&quot;Query string
with some special characters: @#$%?&amp;+&quot;</TT> query string.
The query string is encoded using the <TT>encode()</TT> method
of the <TT>URLEncoder</TT> class. The echo-query CGI program creates
an HTML file that describes the parameters passed to it by my
Web server and returns this file to the <TT>QueryURLApp</TT> program.
This file shows how the query string was encoded by the <TT>encode()</TT>
method.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.7. The source code of the </B><TT><B><FONT FACE="Courier New">QueryURLApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.net.URL;<BR>
import java.net.URLConnection;<BR>
import java.net.URLEncoder;<BR>
import java.net.MalformedURLException;<BR>
import java.net.UnknownServiceException;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class QueryURLApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;try{<BR>
&nbsp;&nbsp;&nbsp;String urlString = &quot;http://www.jaworski.com/cgi-bin/echo-query&quot;;
<BR>
&nbsp;&nbsp;&nbsp;String extraPathInfo = &quot;/this/is/extra/path/information&quot;;
<BR>
&nbsp;&nbsp;&nbsp;String queryString = <BR>
&nbsp;&nbsp;&nbsp;&nbsp;URLEncoder.encode(&quot;Query string with
some special characters: @#$%?&amp;+&quot;);<BR>
&nbsp;&nbsp;&nbsp;URL url = new URL(urlString+extraPathInfo+&quot;?&quot;+queryString);
<BR>
&nbsp;&nbsp;&nbsp;URLConnection connection = url.openConnection();
<BR>
&nbsp;&nbsp;&nbsp;DataInputStream fromURL = new DataInputStream(url.openStream());
<BR>
&nbsp;&nbsp;&nbsp;String line;<BR>
&nbsp;&nbsp;&nbsp;while ((line = fromURL.readLine())!= null){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(line);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;fromURL.close();<BR>
&nbsp;&nbsp;}catch (MalformedURLException ex){<BR>
&nbsp;&nbsp;&nbsp;error(&quot;Bad URL&quot;);<BR>
&nbsp;&nbsp;}catch (UnknownServiceException ex){<BR>
&nbsp;&nbsp;&nbsp;error(&quot;UnknownServiceException occurred.&quot;);
<BR>
&nbsp;&nbsp;}catch (IOException ex){<BR>
&nbsp;&nbsp;&nbsp;error(&quot;IOException occurred.&quot;);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
&nbsp;public static void error(String s){<BR>
&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;System.exit(1);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
To run <TT>QueryURLApp</TT>, just type the following command line:
<P>
<BLOCKQUOTE>
<TT>C:\java\jdg\ch17&gt;java QueryURLApp</TT>
</BLOCKQUOTE>
<P>
<TT>QueryURLApp</TT> queries the echo-query program on my Web
server and displays the HTML file generated by the echo-query
program. Notice how the query string was encoded:
<BLOCKQUOTE>
<TT>&lt;HTML&gt;<BR>
<FONT FACE="Courier New">&lt;HEAD&gt;<BR>
&lt;TITLE&gt;Echo CGI Request&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;H1&gt;CGI Request&lt;/H1&gt;<BR>
&lt;H2&gt;Command Line Arguments&lt;/H2&gt;<BR>
&lt;P&gt;Number of command line arguments: 7&lt;/P&gt;<BR>
&lt;P&gt;Command line arguments: Query string with some special
characters: <BR>
&Acirc; @#\$%\?\&amp;+<BR>
&lt;/P&gt;<BR>
&lt;H2&gt;Environment Variables&lt;/H2&gt;<BR>
&lt;PRE&gt;<BR>
AUTH_TYPE =<BR>
CONTENT_LENGTH =<BR>
CONTENT_TYPE =<BR>
GATEWAY_INTERFACE = CGI/1.1<BR>
HTTP_ACCEPT = text/html, image/gif, image/jpeg, *; q=.2, */*;
q=.2<BR>
HTTP_USER_AGENT = Javainternal_build<BR>
PATH_INFO = /this/is/extra/path/information<BR>
PATH_TRANSLATED = /usr/local/etc/httpd/htdocs/this/is/extra/path/information
<BR>
QUERY_STRING = <BR>
&Acirc;  Query+string+with+some+special+characters%3a+%40%23%24%25%3f%26%2b
<BR>
REMOTE_ADDR = 204.212.153.194<BR>
REMOTE_HOST = athome.jaworski.com<BR>
REMOTE_IDENT =<BR>
REMOTE_USER =<BR>
REQUEST_METHOD = GET<BR>
SCRIPT_NAME = /cgi-bin/echo-query<BR>
SERVER_NAME = www.jaworski.com<BR>
SERVER_PORT = 80<BR>
SERVER_PROTOCOL = HTTP/1.0<BR>
SERVER_SOFTWARE = NCSA/1.4.2<BR>
&lt;/PRE&gt;<BR>
&lt;H2&gt;Standard Input&lt;/H2&gt;<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;<BR>
<BR>
C:\java\jdg\ch17&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
<TT>QueryURLApp</TT> creates an URL by concatenating the URL for
the echo-query program, the extra path information, and the encoded
query string. It then uses the <TT>openConnection()</TT> method
of the URL class to create an <TT>URLConnection</TT> object, which
it assigns to the <TT>connection</TT> variable. The connection
is then read and displayed in the same manner as the <TT>GetURLApp</TT>
program.
<H2><A NAME="TheContentHandlerandContentHandlerFac"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">ContentHandler</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">ContentHandlerFactory</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
The <TT>ContentHandler</TT> class is an <TT>abstract</TT> class
that is used to develop specialized objects that are able to extract
and process data associated with new MIME types.
<P>
<I>MIME,</I> or <I>multipurpose Internet mail extension,</I> is
a general method by which the content of different types of Internet
objects can be identified. MIME was originally developed to include
different types of objects, such as sounds, images, and videos,
in Internet e-mail messages. It was also adopted and popularized
by the Web and is used to identify multimedia and other types
of Web objects so that appropriate external viewers or plug-in
modules can be used to process and display these objects.
<P>
The <TT>ContentHandler</TT> class provides the basis for developing
new viewers for processing MIME types that are not currently supported
by Java. It consists of a single method, <TT>getContent()</TT>,
that extracts an object of a particular MIME type from an URL
connection. The <TT>ContentHandlerFactory</TT> interface provides
a standard method of associating a content handler with a MIME
type.
<P>
<A HREF="ch28.htm" >Chapter 28</A>, &quot;Content Handlers,&quot;
provides a detailed description of how content handlers are developed.
<H2><A NAME="TheURLStreamHandlerClassandtheURLSt"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">URLStreamHandler</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class and the </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">URLStreamHandlerFactory</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Interface</FONT></B></A></H2>
<P>
The <TT>URLStreamHandler</TT> class is an <TT>abstract</TT> class
that is used to develop specialized objects that are able to communicate
with Web resources using protocols that are currently not supported
by Java. For example, suppose you develop a new protocol for a
custom client/server application and you want that protocol to
be accessible to Web browsers. You would develop an <TT>URLStreamHandler</TT>
for that protocol. The <TT>URLStreamHandlerFactory</TT> interface
is used to associate a stream handler with a particular protocol.
<A HREF="ch28.htm" >Chapter 28</A> provides a detailed description
of how protocol stream handlers are developed.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter you have learned about Java's support of network
programming and covered the basics of client/server computing
and TCP/IP socket programming. You have toured the classes of
the <TT>java.net</TT> package and learned how to use them to develop
client/server applications. You have also covered the URL-centric
classes that support Web-based applications. You have now completed
your introduction to the Java API. The next three parts of this
book will show you how to use the Java API to develop Java application
programs and applets.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



