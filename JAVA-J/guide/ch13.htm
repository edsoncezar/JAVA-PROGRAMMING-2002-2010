<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

the java.io
   <META>
<H1><FONT COLOR=#FF0000>Chapter 13</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Stream-Based Input/Output and
the </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.io</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Package</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Streams" >Streams</A>
<LI><A HREF="#ThejavaioClassHierarchy" >The java.io Class Hierarchy</A>
<LI><A HREF="#TheInputStreamClass" >The InputStream Class</A>
<UL>
<LI><A HREF="#ThereadMethod" >The read() Method</A>
<LI><A HREF="#TheavailableMethod" >The available() Method</A>
<LI><A HREF="#ThecloseMethod1" >The close() Method</A>
<LI><A HREF="#MarkableStreams" >Markable Streams</A>
<LI><A HREF="#TheskipMethod" >The skip() Method</A>
</UL>
<LI><A HREF="#TheOutputStreamClass" >The OutputStream Class</A>
<UL>
<LI><A HREF="#ThewriteMethod" >The write() Method</A>
<LI><A HREF="#TheflushMethod" >The flush() Method</A>
<LI><A HREF="#ThecloseMethod2" >The close() Method</A>
</UL>
<LI><A HREF="#ByteArrayIO" >Byte Array I/O</A>
<UL>
<LI><A HREF="#TheByteArrayInputStreamClass" >The ByteArrayInputStream Class</A>
<LI><A HREF="#TheByteArrayOutputStreamClass" >The ByteArrayOutputStream Class</A>
<LI><A HREF="#TheByteArrayIOAppProgram" >The ByteArrayIOApp Program</A>
<LI><A HREF="#TheStringBufferInputStreamClass" >The StringBufferInputStream Class</A>
</UL>
<LI><A HREF="#FileIO" >File I/O</A>
<UL>
<LI><A HREF="#TheFileClass" >The File Class</A>
<LI><A HREF="#TheFileDescriptorClass" >The FileDescriptor Class</A>
<LI><A HREF="#TheFileInputStreamClass" >The FileInputStream Class</A>
<LI><A HREF="#TheFileOutputStreamClass" >The FileOutputStream Class</A>
<LI><A HREF="#TheFileIOAppProgram" >The FileIOApp Program</A>
</UL>
<LI><A HREF="#TheSequenceInputStreamClass" >The SequenceInputStream Class</A>
<UL>
<LI><A HREF="#TheSequenceIOAppProgram" >The SequenceIOApp Program</A>
</UL>
<LI><A HREF="#FilteredIO" >Filtered I/O</A>
<UL>
<LI><A HREF="#TheFilterInputStreamClass" >The FilterInputStream Class</A>
<LI><A HREF="#TheFilterOutputStreamClass" >The FilterOutputStream Class</A>
<LI><A HREF="#BufferedIO" >Buffered I/O</A>
<LI><A HREF="#PushbackInputStream" >PushbackInputStream</A>
<LI><A HREF="#TheLineNumberInputStreamClass" >The LineNumberInputStream Class</A>
<LI><A HREF="#DataIO" >Data I/O</A>
<LI><A HREF="#ThePrintStreamClass" >The PrintStream Class</A>
<LI><A HREF="#PipedIO" >Piped I/O</A>
</UL>
<LI><A HREF="#TheRandomAccessFileClass" >The RandomAccessFile Class</A>
<UL>
<LI><A HREF="#TheRandomIOAppProgram" >The RandomIOApp Program</A>
</UL>
<LI><A HREF="#TheStreamTokenizerClass" >The StreamTokenizer Class</A>
<UL>
<LI><A HREF="#TheStreamTokenAppProgram" >The StreamTokenApp Program</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>In this chapter you'll learn to use Java streams
to perform sophisticated input and output using standard I/O,
memory buffers, and files. You'll be introduced to all classes
of the </FONT><TT>java.io</TT> package. You'll explore the input
and output stream class hierarchy and learn to use stream filters
to simplify I/O processing. You'll also learn how to perform random-access
I/O and how to use the <TT>StreamTokenizer</TT> class to construct
input parsers. When you finish this chapter, you'll be able to
add sophisticated I/O processing to your Java programs.
<H2><A NAME="Streams"><B><FONT SIZE=5 COLOR=#FF0000>Streams</FONT></B></A>
</H2>
<P>
Java input and output is based on the use of streams. <I>Streams</I>
are sequences of bytes that travel from a source to a destination
over a communication path. If your program is writing to a stream,
it is the stream's <I>source</I>. If it is reading from a stream,
it is the stream's <I>destination</I>. The communication path
is dependent on the type of I/O being performed. It can consist
of memory-to-memory transfers, file system, network, and other
forms of I/O.
<P>
Streams are not complicated. They are powerful because they abstract
away the details of the communication path from input and output
operations. This allows all I/O to be performed using a common
set of methods. These methods can be tailored and extended to
provide higher-level custom I/O capabilities.
<P>
Java defines two major classes of streams: <TT>InputStream</TT>
and <TT>OutputStream</TT>. These streams are subclassed to provide
a variety of I/O capabilities.
<H2><A NAME="ThejavaioClassHierarchy"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.io</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class Hierarchy</FONT></B></A>
</H2>
<P>
<A HREF="f13-1.gif" >Figure 13.1</A> identifies the <TT>java.io</TT>
class hierarchy. As described in the previous section, the <TT>InputStream</TT>
and <TT>OutputStream</TT> classes are the major components of
this hierarchy. Other high-level classes include the <TT>File</TT>,
<TT>FileDescriptor</TT>, <TT>RandomAccessFile</TT>, and <TT>StreamTokenizer</TT>
classes.
<P>
<A HREF="f13-1.gif"><B>Figure 13.1 :</B><I>The classes of the <FONT FACE="Courier New"> java.io</FONT> hierarchy.</I></A>
<P>
The <TT>InputStream</TT> and <TT>OutputStream</TT> classes have
complementary subclasses. For example, both have subclasses for
performing I/O via memory buffers, files, and pipes. The <TT>InputStream</TT>
subclasses perform the input and the <TT>OutputStream</TT> classes
perform the output.
<P>
The <TT>InputStream</TT> class has six subclasses. The <TT>ByteArrayInputStream</TT>
class is used to convert an array into an input stream. The <TT>StreamBufferInputStream</TT>
class uses a <TT>StreamBuffer</TT> as an input stream. The <TT>FileInputStream</TT>
allows files to be used as input streams. The <TT>PipedInputStream</TT>
class allows a pipe to be constructed between two threads and
supports input through the pipe. The <TT>SequenceInputStream</TT>
class allows two or more streams to be concatenated into a single
stream. The <TT>FilterInputStream</TT> class is an abstract class
from which other input-filtering classes are constructed.
<P>
<I>Filters</I> are objects that read from one stream and write
to another, usually altering the data in some way as they pass
it from one stream to another. Filters can be used to buffer data,
read and write objects, keep track of line numbers, and perform
other operations on the data they move. Filters can be combined,
with one filter using the output of another as its input. You
can create custom filters by combining existing filters.
<P>
<TT>FilterInputStream</TT> has four filtering subclasses. The
<TT>BufferedInputStream</TT> class maintains a buffer of the input
data that it receives. This eliminates the need to read from the
stream's source every time an input byte is needed. The <TT>DataInputStream</TT>
class implements the <TT>DataInput</TT> interface, a set of methods
that allow objects and primitive data types to be read from a
stream. The <TT>LineNumberInputStream</TT> class is used to keep
track of input line numbers. The <TT>PushbackInputStream</TT>
class provides the capability to push data back onto the stream
that it is read from so that it can be read again.
<P>
The <TT>OutputStream</TT> class hierarchy consists of four major
subclasses. The <TT>ByteArrayOutputStream</TT>, <TT>FileOutputStream</TT>,
and <TT>PipedOutputStream</TT> classes are the output complements
to the <TT>ByteArrayInputStream</TT>, <TT>FileInputStream</TT>,
and <TT>PipedInputStream</TT> classes. The <TT>FilterOutputStream</TT>
class provides subclasses that complement the <TT>FilterInputStream</TT>
classes.
<P>
The <TT>BufferedOutputStream</TT> class is the output analog to
the <TT>BufferedInputStream</TT> class. It buffers output so that
output bytes can be written to devices in larger groups. The <TT>DataOutputStream</TT>
class implements the <TT>DataOutput</TT> interface. This interface
complements the <TT>DataInput</TT> interface. It provides methods
that write objects and primitive data types to streams so that
they can be read by the <TT>DataInput</TT> interface methods.
The <TT>PrintStream</TT> class provides the familiar <TT>print()</TT>
and <TT>println()</TT> methods used in most of the sample programs
that you've developed so far in this book. It provides a number
of overloaded methods that simplify data output.
<P>
The <TT>File</TT> class is used to access the files and directories
of the local file system. The <TT>FileDescriptor</TT> class is
an encapsulation of the information used by the host system to
track files that are being accessed. The <TT>RandomAccessFile</TT>
class provides the capabilities needed to directly access data
contained in a file. The <TT>StreamTokenizer</TT> class is used
to create parsers that operate on stream data.
<H2><A NAME="TheInputStreamClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">InputStream</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>InputStream</TT> class is an abstract class that lays
the foundation for the Java <TT>Input</TT> class hierarchy. As
such, it provides methods that are inherited by all <TT>InputStream</TT>
classes.
<H3><A NAME="ThereadMethod"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">read()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
The <TT>read()</TT> method is the most important method of the
<TT>InputStream</TT> class hierarchy. It reads a byte of data
from an input stream and blocks if no data is available. When
a method <I>blocks</I>, it causes the thread in which it is executing
to wait until data becomes available. This is not a problem in
multithreaded programs. The <TT>read()</TT> method takes on several
overloaded forms. It can read a single byte or an array of bytes,
depending upon what form is used. It returns the number of bytes
read or <TT>-1</TT> if an end of file is encountered with no bytes
read.
<P>
The <TT>read()</TT> method is overridden and overloaded by subclasses
to provide custom read capabilities.
<H3><A NAME="TheavailableMethod"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">available()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
The <TT>available()</TT> method returns the number of bytes that
are available to be read without blocking. It is used to peek
into the input stream to see how much data is available. However,
depending on the input stream, it might not be accurate or useful.
Some input streams on some operating systems may always report
0 available bytes. In general, it is not a good idea to blindly
rely on this method to perform input processing.
<H3><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">close()</FONT></B></TT><B><FONT SIZE=4>
<A NAME="ThecloseMethod1">Method</FONT></B></H3>
<P>
The <TT>close()</TT> method closes an input stream and releases
resources associated with the stream. It is always a good idea
to close a stream to ensure that the stream processing is correctly
terminated.
<H3><A NAME="MarkableStreams"><B>Markable Streams</B></A></H3>
<P>
Java supports <I>markable streams</I>. These are streams that
provide the capability to mark a position in the stream and then
later reset the stream so that it can be reread from the marked
position. If a stream can be marked, it must contain some memory
associated with it to keep track of the data between the mark
and the current position of the stream. When this buffering capability
is exceeded, the mark becomes invalid.
<P>
The <TT>markSupported()</TT> method returns a <TT>boolean</TT>
value that identifies whether a stream supports mark and reset
capabilities. The <TT>mark()</TT> method marks a position in the
stream. It takes an integer parameter that identifies the number
of bytes that can be read before the mark becomes invalid. This
is used to set the buffering capacity of the stream. The <TT>reset()</TT>
method simply repositions the stream to its last marked position.
<H3><A NAME="TheskipMethod"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">skip()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
The <TT>skip()</TT> method skips over a specified number of input
bytes. It takes a <TT>long</TT> value as a parameter.
<H2><A NAME="TheOutputStreamClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">OutputStream</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>OutputStream</TT> class is an abstract class that lays
the foundation for the output stream hierarchy. It provides a
set of methods that are the output analog to the <TT>InputStream</TT>
methods.
<H3><A NAME="ThewriteMethod"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">write()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
The <TT>write()</TT> method allows bytes to be written to the
output stream. It provides three overloaded forms to write a single
byte, an array of bytes, or a segment of an array. The <TT>write()</TT>
method, like the <TT>read()</TT> method, may block when it tries
to write to a stream. The blocking causes the thread executing
the <TT>write()</TT> method to wait until the write operation
has been completed.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
The <TT>OutputStream</TT> class defines three overloaded forms for the <TT>write()</TT> method. These forms allow you to write an integer, an array of bytes, or a subarray of bytes to an <TT>OutputStream</TT> object. You will often see several overloaded forms for methods that perform the same operation using different types of data.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheflushMethod"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">flush()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
The <TT>flush()</TT> method causes any buffered data to be immediately
written to the output stream. Some subclasses of <TT>OutputStream</TT>
support buffering and override this method to &quot;clean out&quot;
their buffers and write all buffered data to the output stream.
They must override the <TT>OutputStream</TT> <TT>flush()</TT>
method because, by default, it does not perform any operations
and is used as a placeholder.
<H3><A NAME="ThecloseMethod2"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">close()</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></A></H3>
<P>
It is generally more important to close output streams than input
streams, so that any data written to the stream is stored before
the stream is deallocated and lost. The <TT>close()</TT> method
of <TT>OutputStream</TT> is used in the same manner as that of
<TT>InputStream</TT>.
<H2><A NAME="ByteArrayIO"><B><FONT SIZE=5 COLOR=#FF0000>Byte Array
I/O</FONT></B></A></H2>
<P>
Java supports byte array input and output via the <TT>ByteArrayInputStream</TT>
and <TT>ByteArrayOutputStream</TT> classes. These classes use
memory buffers as the source and destination of the input and
output streams. These streams do not have to be used together.
They are covered in the same section here because they provide
similar and complementary methods. The <TT>StringBufferInputStream</TT>
class is similar to the <TT>ByteArrayInput</TT> class and is also
covered in this section.
<H3><A NAME="TheByteArrayInputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">ByteArrayInputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>ByteArrayInputStream</TT> class creates an input stream
from a memory buffer. The buffer is an array of bytes. It provides
two constructors that use a byte array argument to create the
input stream. The class does not support any new methods, but
overrides the <TT>read()</TT>, <TT>skip()</TT>, <TT>available()</TT>,
and <TT>reset()</TT> methods of <TT>InputStream</TT>.
<P>
The <TT>read()</TT> and <TT>skip()</TT> methods are implemented
as specified for <TT>InputStream</TT>. The method <TT>available()</TT>
is reliable and can be used to check on the number of available
bytes in the buffer. The <TT>reset()</TT> method does not work
with a <TT>mark()</TT> method; it simply resets to the beginning
of the buffer.
<H3><A NAME="TheByteArrayOutputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">ByteArrayOutputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>ByteArrayOutputStream</TT> class is a little more sophisticated
than its input complement. It creates an output stream on a byte
array, but provides additional capabilities to allow the output
array to grow to accommodate new data that is written to it. It
also provides the <TT>toByteArray()</TT> and <TT>toString()</TT>
methods for converting the stream to a byte array or <TT>String</TT>
object.
<P>
<TT>ByteArrayOutputStream</TT> provides two constructors. One
takes an integer argument that is used to set the output byte
array to an initial size. The other constructor does not take
an argument and sets the output buffer to a default size.
<P>
<TT>ByteArrayOutputStream</TT> provides some additional methods
not declared for <TT>OutputStream</TT>. The <TT>reset()</TT> method
resets the output buffer to allow writing to restart at the beginning
of the buffer. The <TT>size()</TT> method returns the current
number of bytes that have been written to the buffer. The <TT>writeTo()</TT>
method is new. It takes an object of class <TT>OutputStream</TT>
as an argument and writes the contents of the output buffer to
the specified output stream. The <TT>write()</TT> methods override
those of <TT>OutputStream</TT> to support array output.
<H3><A NAME="TheByteArrayIOAppProgram"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">ByteArrayIOApp</FONT></B></TT><B><FONT SIZE=4>
Program</FONT></B></A></H3>
<P>
Having learned about both sides of the byte array I/O classes,
you now have a base from which to create a sample program. Remember
to create a <TT>ch13</TT> directory under <TT>\java\jdg</TT> in
which to store the files created in this chapter. The source code
of the <TT>ByteArrayIOApp</TT> program is provided in Listing
13.1.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. The source code of the </B><TT><B><FONT FACE="Courier New">ByteArrayIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.ByteArrayInputStream;
<BR>
import java.io.ByteArrayOutputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class ByteArrayIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;ByteArrayOutputStream outStream = new ByteArrayOutputStream();
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;System.out.println(&quot;outstream: &quot;+outStream);
<BR>
&nbsp;&nbsp;System.out.println(&quot;size: &quot;+outStream.size());
<BR>
&nbsp;&nbsp;ByteArrayInputStream inStream;<BR>
&nbsp;&nbsp;inStream = new ByteArrayInputStream(outStream.toByteArray());
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates a <TT>ByteArrayOutputStream</TT> object, <TT>outStream</TT>,
and an array, <TT>s</TT>, that contains the text <TT>&quot;This
is a test.&quot;</TT> to be written to the stream. Each character
of <TT>s</TT> is written, one at a time, to <TT>outStream</TT>.
The contents of <TT>outstream</TT> are then printed, along with
the number of bytes written.
<P>
A <TT>ByteArrayInputStream</TT> object, <TT>inStream</TT>, is
created by invoking the <TT>toByteArray()</TT> method of <TT>outStream</TT>
to create a byte array that is used as an argument to the <TT>ByteArrayInputStream</TT>
constructor. The <TT>available()</TT> method is used to determine
the number of available input bytes stored in the buffer. This
number is stored as <TT>inBytes</TT> and is used to allocate a
byte array to store the data that is read. The <TT>read()</TT>
method is invoked for <TT>inStream</TT> to read <TT>inBytes</TT>
worth of data. The actual number of bytes read is stored in <TT>bytesRead</TT>.
This number is displayed, followed on the next line by the bytes
that were read from <TT>inStream</TT>, as follows:
<BLOCKQUOTE>
<TT>outstream: This is a test.<BR>
<FONT FACE="Courier New">size: 15<BR>
inStream has 15 available bytes<BR>
15 bytes were read<BR>
They are: This is a test.</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="TheStringBufferInputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">StringBufferInputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
<TT>StringBufferInputStream</TT> is similar to <TT>ByteArrayInputStream</TT>
except that it uses a <TT>StringBuffer</TT> to store input data.
The input stream is constructed using a <TT>String</TT> argument.
Its methods are identical to those provided by <TT>ByteArrayInputStream</TT>.
<H2><A NAME="FileIO"><B><FONT SIZE=5 COLOR=#FF0000>File I/O</FONT></B></A>
</H2>
<P>
Java supports stream-based file input and output through the <TT>File</TT>,
<TT>FileDescriptor</TT>, <TT>FileInputStream</TT>, and <TT>FileOutputStream</TT>
classes. It supports direct- or random-access I/O using the <TT>File</TT>,
<TT>FileDescriptor</TT>, and <TT>RandomAccessFile</TT> classes.
Random-access I/O is covered later in this chapter.
<P>
The <TT>File</TT> class provides access to file and directory
objects and supports a number of operations on files and directories.
The <TT>FileDescriptor</TT> class encapsulates the information
used by the host system to track files that are being accessed.
The <TT>FileInputStream</TT> and <TT>FileOutputStream</TT> classes
provide the capability to read and write to file streams.
<H3><A NAME="TheFileClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">File</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>File</TT> class is used to access file and directory objects.
It uses the file-naming conventions of the host operating system.
The <TT>File</TT> class encapsulates these conventions using the
<TT>File</TT> class constants.
<P>
<TT>File</TT> provides constructors for creating files and directories.
These constructors take absolute and relative file paths and file
and directory names.
<P>
The <TT>File</TT> class provides numerous access methods that
can be used to perform all common file and directory operations.
It is important for you to review the API page for this class
because file I/O and file and directory operations are common
to most programs.
<P>
<TT>File</TT> methods allow files to be created, deleted, and
renamed. They provide access to a file's path and name and determine
whether a <TT>File</TT> object is a file or directory. These methods
also check read and write access permissions.
<P>
<TT>Directory</TT> methods allow directories to be created, deleted,
renamed, and listed. <TT>Directory</TT> methods also allow directory
trees to be traversed by providing access to the parent and sibling
directories.
<H3><A NAME="TheFileDescriptorClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FileDescriptor</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>FileDescriptor</TT> class provides access to the file
descriptors maintained by operating systems when files and directories
are being accessed. This class is <I>opaque</I> in that it does
not provide visibility into the specific information maintained
by the operating system. It provides only one method, the <TT>valid()</TT>
method, which is used to determine whether a file descriptor object
is currently valid.
<H3><A NAME="TheFileInputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FileInputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>FileInputStream</TT> class allows input to be read from
a file in the form of a stream. Objects of class <TT>FileInputStream</TT>
are created using a filename string or a <TT>File</TT> or <TT>FileDescriptor</TT>
object as an argument. <TT>FileInputStream</TT> overrides the
methods of the <TT>InputStream</TT> class and provides two new
methods, <TT>finalize()</TT> and <TT>getFD()</TT>. The <TT>finalize()</TT>
method is used to close a stream when it is processed by the Java
garbage collector. The <TT>getFD()</TT> method is used to obtain
access to the <TT>FileDescriptor</TT> associated with the input
stream.
<H3><A NAME="TheFileOutputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FileOutputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>FileOutputStream</TT> class allows output to be written
to a file stream. Objects of class <TT>FileOutputStream</TT> are
created in the same way as those of class <TT>FileInputStream</TT>,
using a file- name string, <TT>File</TT> object, or <TT>FileDescriptor</TT>
object as an argument. <TT>FileOutputStream</TT> overrides the
methods of the <TT>OutputStream</TT> class and supports the <TT>finalize()</TT>
and <TT>getFD()</TT> methods described for the <TT>FileInputStream</TT>
class.
<H3><A NAME="TheFileIOAppProgram"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FileIOApp</FONT></B></TT><B><FONT SIZE=4>
Program</FONT></B></A></H3>
<P>
The program in Listing 13.2 illustrates the use of the <TT>FileInputStream</TT>,
<TT>FileOutputStream</TT>, and <TT>File</TT> classes. It writes
a string to an output file and then reads the file to verify that
the output was written correctly. The file used for the I/O is
then deleted.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. The source code of the </B><TT><B><FONT FACE="Courier New">FileIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.FileInputStream;<BR>
import java.io.FileOutputStream;<BR>
import java.io.File;<BR>
import java.io.IOException;<BR>
<BR>
public class FileIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;FileOutputStream outStream = new FileOutputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;FileInputStream inStream = new FileInputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;File f = new File(&quot;test.txt&quot;);<BR>
&nbsp;&nbsp;f.delete();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>FileOutputStream</TT> constructor creates an output stream
on the file <TT>test.txt</TT>. The file is automatically created
in the current working directory. It then writes the string <TT>&quot;This
is a test.&quot;</TT> to the output file stream. Note the similarity
between this program and the previous one. The power of streams
is that the same methods can be used no matter what type of stream
is being used.
<P>
The output stream is closed to make sure that all the data is
written to the file. The file is then reopened as an input file
by creating an object of class <TT>FileInputStream</TT>. The same
methods used in the <TT>ByteArrayIOApp</TT> program are used to
determine the number of available bytes in the file and read these
bytes into a byte array. The number of bytes read is displayed
along with the characters corresponding to those bytes.
<P>
The input stream is closed and then a <TT>File</TT> object is
created to provide access to the file. The <TT>File</TT> object
is used to delete the file using the <TT>delete()</TT> method.
The program's output follows:
<BLOCKQUOTE>
<TT>inStream has 15 available bytes<BR>
<FONT FACE="Courier New">15 bytes were read<BR>
They are: This is a test.</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheSequenceInputStreamClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">SequenceInputStream</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>SequenceInputStream</TT> class is used to combine two
or more input streams into a single input stream. The input streams
are concatenated, which allows the individual streams to be treated
as a single, logical stream. The <TT>SequenceInputStream</TT>
class does not introduce any new access methods. Its power is
derived from the two constructors that it provides. One constructor
takes two <TT>InputStream</TT> objects as arguments. The other
takes an <TT>Enumeration</TT> of <TT>InputStream</TT> objects.
The <TT>Enumeration</TT> interface is described in <A HREF="ch14.htm" >Chapter 14</A>,
&quot;Useful Tools in the <TT>java.util</TT> Package.&quot; It
provides methods for dealing with a sequence of related objects.
<H3><A NAME="TheSequenceIOAppProgram"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">SequenceIOApp</FONT></B></TT><B><FONT SIZE=4>
Program</FONT></B></A></H3>
<P>
The program in Listing 13.3 reads the two Java source files, <TT>ByteArrayIOApp.java</TT>
and <TT>FileIOApp.java</TT>, as a single file courtesy of the
<TT>SequenceInputStream</TT> class.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. The source code of the </B><TT><B><FONT FACE="Courier New">SequenceIOApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.FileInputStream;<BR>
import java.io.SequenceInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class SequenceIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;SequenceInputStream inStream;<BR>
&nbsp;&nbsp;FileInputStream f1 = new FileInputStream(&quot;ByteArrayIOApp.java&quot;);
<BR>
&nbsp;&nbsp;FileInputStream f2 = new FileInputStream(&quot;FileIOApp.java&quot;);
<BR>
&nbsp;&nbsp;inStream = new SequenceInputStream(f1,f2);<BR>
&nbsp;&nbsp;boolean eof = false;<BR>
&nbsp;&nbsp;int byteCount = 0;<BR>
&nbsp;&nbsp;while (!eof) {<BR>
&nbsp;&nbsp;&nbsp;int c = inStream.read();<BR>
&nbsp;&nbsp;&nbsp;if(c == -1) eof = true;<BR>
&nbsp;&nbsp;&nbsp;else{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.print((char) c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;++byteCount;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;System.out.println(byteCount+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;f1.close();<BR>
&nbsp;&nbsp;f2.close();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates two objects of class <TT>FileInputStream</TT>
for the files <TT>ByteArrayIOApp.java</TT> and <TT>FileIOApp.java</TT>.
The <TT>SequenceInputClass</TT> constructor is used to construct
a single input stream from the two <TT>FileInputStream</TT> objects.
The program then uses a <TT>while</TT> loop to read all bytes
in the combined file and display them to the console window. The
loop stops when the end of the combined file is encountered. This
is signaled when the <TT>read()</TT> method returns <TT>-1</TT>.
The streams are closed after the combined files have been read.
The program's output is as follows:
<BLOCKQUOTE>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.ByteArrayInputStream;
<BR>
import java.io.ByteArrayOutputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class ByteArrayIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;ByteArrayOutputStream outStream = new ByteArrayOutputStream();
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;System.out.println(&quot;outstream: &quot;+outStream);
<BR>
&nbsp;&nbsp;System.out.println(&quot;size: &quot;+outStream.size());
<BR>
&nbsp;&nbsp;ByteArrayInputStream inStream;<BR>
&nbsp;&nbsp;inStream = new ByteArrayInputStream(outStream.toByteArray());
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;}<BR>
}<BR>
<BR>
import java.lang.System;<BR>
import java.io.FileInputStream;<BR>
import java.io.FileOutputStream;<BR>
import java.io.File;<BR>
import java.io.IOException;<BR>
<BR>
public class FileIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;FileOutputStream outStream = new FileOutputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;FileInputStream inStream = new FileInputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;File f = new File(&quot;test.txt&quot;);<BR>
&nbsp;&nbsp;f.delete();<BR>
&nbsp;}<BR>
}<BR>
1771 bytes were read</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT>SequenceIOApp</TT> program displays the combined contents
of the two source files followed by a line identifying the number
of bytes that were read.
<H2><A NAME="FilteredIO"><B><FONT SIZE=5 COLOR=#FF0000>Filtered
I/O</FONT></B></A></H2>
<P>
The filtered input and output stream classes provide the capability
to filter I/O in a number of useful ways. I/O filters are used
to adapt streams to specific program needs. These filters sit
between an input stream and an output stream and perform special
processing on the bytes they transfer from input to output. You
can combine filters to perform a sequence of filtering operations
where one filter acts on the output of another, as shown in <A HREF="f13-2.gif" >Figure 13.2</A>.
<P>
<A HREF="f13-2.gif"><B>Figure 13.2 :</B><I>Combining filters.</I></A>
<P>
<H3><A NAME="TheFilterInputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FilterInputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>FilterInputStream</TT> class is an abstract class that
is the parent of all filtered input stream classes. The <TT>FilterInputStream</TT>
class provides the basic capability to create one stream from
another. It allows one stream to be read and provided as output
as another stream. This is accomplished through the use of the
<TT>in</TT> variable, which is used to maintain a separate object
of class <TT>InputStream</TT>. The design of the <TT>FilterInputStream</TT>
class allows multiple chained filters to be created using several
layers of nesting. Each subsequent class accesses the output of
the previous class through the <TT>in</TT> variable. Because the
<TT>in</TT> variable is an object of class <TT>InputStream</TT>,
arbitrary <TT>InputStream</TT> objects can be filtered.
<H3><A NAME="TheFilterOutputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">FilterOutputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>FilterOutputStream</TT> class is the complement of the
<TT>FilterInputStream</TT> class. It is an abstract class that
is the parent of all filtered output stream classes. It is similar
to the <TT>FilterInputStream</TT> class in that it maintains an
object of class <TT>OutputStream</TT> as an <TT>out</TT> variable.
Data written to an object of <TT>FilterOutputStream</TT> can be
modified as needed to perform filtering operations and then forwarded
to the <TT>out</TT> <TT>OutputStream</TT> object. Because <TT>out</TT>
is declared to be of class <TT>OutputStream</TT>, arbitrary output
streams can be filtered. Multiple <TT>FilterOutputStream</TT>
objects can be combined in a manner that is analogous to <TT>FilterInputStream</TT>
objects. The input of subsequent <TT>FilterOutputStream</TT> objects
is linked to the output of preceding objects.
<H3><A NAME="BufferedIO"><B>Buffered I/O</B></A></H3>
<P>
Buffered input and output is used to temporarily cache data that
is read from or written to a stream. This allows programs to read
and write small amounts of data without adversely affecting system
performance. When buffered input is performed, a large number
of bytes are read at a single time and stored in an input buffer.
When a program reads from the input stream, the input bytes are
read from the input buffer. Several reads may be performed before
the buffer needs to refilled. Input buffering is used to speed
up overall stream input processing.
<P>
Output buffering is performed in a manner similar to input buffering.
When a program writes to a stream, the output data is stored in
an output buffer until the buffer becomes full or the output stream
is flushed. Only then is the buffered output actually forwarded
to the output stream's destination.
<P>
Java implements buffered I/O as filters. The filters maintain
and operate the buffer that sits between the program and the source
or destination of a buffered stream.
<H4><B>The </B><TT><B><FONT FACE="Courier New">BufferedInputStream</FONT></B></TT><B>
Class</B></H4>
<P>
The <TT>BufferedInputStream</TT> class supports input buffering
by automatically creating and maintaining a buffer for a designated
input stream. This allows programs to read data from the stream
one byte at a time without degrading system performance. Because
the <TT>BufferedInputStream</TT> class is a filter, it can be
applied to arbitrary objects of class <TT>InputStream</TT> and
combined with other input filters.
<P>
The <TT>BufferedInputStream</TT> class uses several variables
to implement input buffering. These variables are described in
the Java API page for this class. However, because these variables
are declared as <TT>protected</TT>, they cannot be directly accessed
by your program.
<P>
<TT>BufferedInputStream</TT> defines two constructors. One allows
the size of an input buffer to be specified and the other does
not. Both constructors take an object of class <TT>InputStream</TT>
as an argument. It is usually better to let <TT>BufferedInputStream</TT>
select the best size for the input buffer than to specify one
yourself unless you have specific knowledge that one buffer size
is better than another.
<P>
<TT>BufferedInputStream</TT> overrides the access methods provided
by <TT>InputStream</TT> and does not introduce any new methods
of its own.
<H4><B>The </B><TT><B><FONT FACE="Courier New">BufferedOutputStream</FONT></B></TT><B>
Class</B></H4>
<P>
The <TT>BufferedOutputStream</TT> class performs output buffering
in a manner that is analogous to <TT>BufferedInputStream</TT>.
It allows the size of the output buffer to be specified in a constructor
as well as providing for a default buffer size. It overrides the
methods of the <TT>OutputStream</TT> class and does not introduce
any new methods of its own.
<H4><B>The </B><TT><B><FONT FACE="Courier New">BufferedIOApp</FONT></B></TT><B>
Program</B></H4>
<P>
The <TT>BufferedIOApp</TT> program (see Listing 13.4) builds on
the <TT>SequenceIOApp</TT> example that was presented previously.
It performs buffering on the <TT>SequenceInputStream</TT> object
used to combine the input from two separate files. It also performs
buffering on program output so that characters do not need to
be displayed to the console window a single character at a time.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.4. The source code of the </B><TT><B><FONT FACE="Courier New">BufferedIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.BufferedInputStream;<BR>
import java.io.BufferedOutputStream;<BR>
import java.io.PrintStream;<BR>
import java.io.FileInputStream;<BR>
import java.io.SequenceInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class BufferedIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;SequenceInputStream f3;<BR>
&nbsp;&nbsp;FileInputStream f1 = new FileInputStream(&quot;ByteArrayIOApp.java&quot;);
<BR>
&nbsp;&nbsp;FileInputStream f2 = new FileInputStream(&quot;FileIOApp.java&quot;);
<BR>
&nbsp;&nbsp;f3 = new SequenceInputStream(f1,f2);<BR>
&nbsp;&nbsp;BufferedInputStream inStream = new BufferedInputStream(f3);
<BR>
&nbsp;&nbsp;BufferedOutputStream bufStream = new BufferedOutputStream(System.out);
<BR>
&nbsp;&nbsp;PrintStream outStream = new PrintStream(bufStream);
<BR>
&nbsp;&nbsp;inStream.skip(500);<BR>
&nbsp;&nbsp;boolean eof = false;<BR>
&nbsp;&nbsp;int byteCount = 0;<BR>
&nbsp;&nbsp;while (!eof) {<BR>
&nbsp;&nbsp;&nbsp;int c = inStream.read();<BR>
&nbsp;&nbsp;&nbsp;if(c == -1) eof = true;<BR>
&nbsp;&nbsp;&nbsp;else{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outStream.print((char) c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;++byteCount;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;outStream.println(byteCount+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;f1.close();<BR>
&nbsp;&nbsp;f2.close();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program begins by creating two objects of <TT>FileInputStream</TT>
and combining them into a single input stream using the <TT>SequenceInputStream</TT>
constructor. It then uses this stream to  create an object of
<TT>BufferedInputStream</TT> using the default buffer size.
<P>
A <TT>BufferedOutputStream</TT> object is created using the <TT>System.out</TT>
output stream and a default buffer size. Another filter is applied
using the <TT>PrintStream</TT> class. <TT>PrintStream</TT> is
an output-filtering subclass of <TT>FilterOutputStream</TT>. It
provides several overloaded versions of the <TT>print()</TT> and
<TT>println()</TT> methods for facilitating program output.
<P>
The <TT>skip()</TT> method is used to skip over 500 bytes of the
input stream. This is done for two reasons: to illustrate the
use of the <TT>skip()</TT> method and to cut down on the size
of the program output. The rest of the input is read and printed
as in the previous example.
<P>
The program output is similar to that of the preceding example.
The <TT>skip()</TT> method was used to skip over 500 bytes of
input. These bytes are also absent from the program's output.
The program's output is as follows:
<BLOCKQUOTE>
<TT>rrayInputStream inStream;<BR>
<FONT FACE="Courier New">&nbsp;&nbsp;inStream = new ByteArrayInputStream(outStream.toByteArray());
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;}<BR>
}<BR>
<BR>
import java.lang.System;<BR>
import java.io.FileInputStream;<BR>
import java.io.FileOutputStream;<BR>
import java.io.File;<BR>
import java.io.IOException;<BR>
<BR>
public class FileIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;FileOutputStream outStream = new FileOutputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;FileInputStream inStream = new FileInputStream(&quot;test.txt&quot;);
<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;int bytesRead = inStream.read(inBuf,0,inBytes);<BR>
&nbsp;&nbsp;System.out.println(bytesRead+&quot; bytes were read&quot;);
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;File f = new File(&quot;test.txt&quot;);<BR>
&nbsp;&nbsp;f.delete();<BR>
&nbsp;}<BR>
}<BR>
1271 bytes were read</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="PushbackInputStream"><TT><B><FONT SIZE=4 FACE="Courier New">PushbackInputStream</FONT></B></TT></A>
</H3>
<P>
<TT>PushbackInputStream</TT> is a filter that lets you push a
byte that was previously read back onto the input stream so that
it can be reread. This type of filter is commonly used with parsers.
When a character indicating a new input token is read, it is pushed
back onto the input stream until the current input token is processed.
It is then reread when processing of the next input token is initiated.
<TT>PushbackInputStream</TT> allows only a single byte to be pushed
back. This is generally enough for most applications.
<P>
The pushback character is stored in a variable named <TT>pushBack</TT>.
<P>
The <TT>unread()</TT> method is the only new method introduced
by this class. It is used to push a specified character back onto
the input stream.
<H4><B>The </B><TT><B><FONT FACE="Courier New">PushbackIOApp</FONT></B></TT><B>
Program</B></H4>
<P>
The <TT>PushbackIOApp</TT> program illustrates the use of the
<TT>PushbackInputStream</TT> class. (See Listing 13.5.) It adds
a pushback filter to the <TT>ByteArrayIOApp</TT> program studied
earlier in this chapter.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.5. The source code of the </B><TT><B><FONT FACE="Courier New">PushbackIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.PushbackInputStream;<BR>
import java.io.ByteArrayInputStream;<BR>
import java.io.ByteArrayOutputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class PushbackIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;ByteArrayOutputStream outStream = new ByteArrayOutputStream();
<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i)<BR>
&nbsp;&nbsp;&nbsp;outStream.write(s.charAt(i));<BR>
&nbsp;&nbsp;System.out.println(&quot;outstream: &quot;+outStream);
<BR>
&nbsp;&nbsp;System.out.println(&quot;size: &quot;+outStream.size());
<BR>
&nbsp;&nbsp;ByteArrayInputStream inByteArray;<BR>
&nbsp;&nbsp;inByteArray = new ByteArrayInputStream(outStream.toByteArray());
<BR>
&nbsp;&nbsp;PushbackInputStream inStream;<BR>
&nbsp;&nbsp;inStream = new PushbackInputStream(inByteArray);<BR>
&nbsp;&nbsp;char ch = (char) inStream.read();<BR>
&nbsp;&nbsp;System.out.println(&quot;First character of inStream
is &quot;+ch);<BR>
&nbsp;&nbsp;inStream.unread((int) 't');<BR>
&nbsp;&nbsp;int inBytes = inStream.available();<BR>
&nbsp;&nbsp;System.out.println(&quot;inStream has &quot;+inBytes+&quot;
available bytes&quot;);<BR>
&nbsp;&nbsp;byte inBuf[] = new byte[inBytes];<BR>
&nbsp;&nbsp;for(int i=0;i&lt;inBytes;++i) inBuf[i]=(byte) inStream.read();
<BR>
&nbsp;&nbsp;System.out.println(&quot;They are: &quot;+new String(inBuf,0));
<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT>PushbackIOApp</TT> creates a stream to be used for byte array
input using the code of the <TT>ByteArrayIOApp</TT> program. It
applies a pushback filter to this stream by using the <TT>PushbackInputStream</TT>
filter to create an object of class <TT>PushbackInputStream</TT>.
It reads the first character of the input stream and displays
it. It then pushes back a <TT>t</TT> onto the input stream. Note
that any character could have been pushed back upon the input
stream. The new input stream is then read and displayed.
<P>
The program output shows how the pushback filter was used to change
the first character of the input stream from an uppercase <TT>T</TT>
to a lowercase <TT>t</TT>. The program output consists of the
following:
<BLOCKQUOTE>
<TT>outstream: This is a test.<BR>
<FONT FACE="Courier New">size: 15<BR>
First character of inStream is T<BR>
inStream has 15 available bytes<BR>
They are: this is a test.</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="TheLineNumberInputStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">LineNumberInputStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>LineNumberInputStream</TT> class provides a handy capability
for keeping track of input line numbers. It is also a subclass
of <TT>FilterInputStream</TT>. This class provides two new methods
to support line-number processing. The <TT>setLineNumber()</TT>
method is used to set the current line number to a particular
value. The <TT>getLineNumber()</TT> method is used to obtain the
value of the current line number.
<H4><B>The </B><TT><B><FONT FACE="Courier New">LineNumIOApp</FONT></B></TT><B>
Program</B></H4>
<P>
The <TT>LineNumIOApp</TT> program illustrates the use of this
filter class. (See Listing 13.6.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.6. The source code of the </B><TT><B><FONT FACE="Courier New">LineNumIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.LineNumberInputStream;
<BR>
import java.io.FileInputStream;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class LineNumIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;FileInputStream inFile = new FileInputStream(&quot;LineNumIOApp.java&quot;);
<BR>
&nbsp;&nbsp;LineNumberInputStream inLines = new LineNumberInputStream(inFile);
<BR>
&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(inLines);
<BR>
&nbsp;&nbsp;String inputLine;<BR>
&nbsp;&nbsp;while ((inputLine=inStream.readLine()) != null) {
<BR>
&nbsp;&nbsp;&nbsp;System.out.println(inLines.getLineNumber()+&quot;.
&quot;+inputLine);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT>LineNumIOApp</TT> reads the <TT>LineNumIOApp.java</TT> source
file and displays it using line numbers. It uses three nested
input stream objects. First it creates a <TT>FileInputStream</TT>
object and assigns it to the <TT>inFile</TT> variable. It then
uses this object to create a <TT>LineNumberInputStream</TT> object,
which it assigns to <TT>inLines</TT>. Finally, it creates a <TT>DataInputStream</TT>
object using <TT>inLines</TT> and assigns it to <TT>inStream</TT>.
The <TT>DataInputStream</TT> class is described in the &quot;Data
I/O&quot; section of this chapter.
<P>
A <TT>while</TT> loop is used to read every line of the program's
source file and display it along with its line number. The <TT>readline()</TT>
method indicates an end-of-file condition by returning a null
value. Otherwise, it returns a string with the value of the last
line that was read. Notice that the <TT>getLineNumber()</TT> method
was applied to <TT>inLines</TT> and not to <TT>inStream</TT>.
This is because <TT>inStream</TT> is an object of <TT>DataInputStream</TT>
and does not support this method.
<BLOCKQUOTE>
The program's output provides a nice example of the capabilities
of the <TT>LineNumberInputStream</TT>:<BR>
<TT>1.<BR>
<FONT FACE="Courier New">2.&nbsp;import java.lang.System;<BR>
3.&nbsp;import java.io.LineNumberInputStream;<BR>
4.&nbsp;import java.io.FileInputStream;<BR>
5.&nbsp;import java.io.DataInputStream;<BR>
6.&nbsp;import java.io.IOException;<BR>
7.<BR>
8.&nbsp;public class LineNumIOApp {<BR>
9.&nbsp;&nbsp;public static void main(String args[]) throws IOException
{<BR>
10.&nbsp;&nbsp;&nbsp;FileInputStream inFile = new FileInputStream(&quot;LineNumIOApp.java&quot;);
<BR>
11.&nbsp;&nbsp;&nbsp;LineNumberInputStream inLines = new LineNumberInputStream(inFile);
<BR>
12.&nbsp;&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(inLines);
<BR>
13.&nbsp;&nbsp;&nbsp;String inputLine;<BR>
14.&nbsp;&nbsp;&nbsp;while ((inputLine=inStream.readLine()) !=
null) {<BR>
15.&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(inLines.getLineNumber()+&quot;.
&quot;+inputLine);<BR>
16.&nbsp;&nbsp;&nbsp;}<BR>
17.&nbsp;&nbsp;}<BR>
18.&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="DataIO"><B>Data I/O</B></A></H3>
<P>
The <TT>DataInputStream</TT> and <TT>DataOutputStream</TT> classes
implement the <TT>DataInput</TT> and <TT>DataOutput</TT> interfaces.
These interfaces identify methods that provide the capability
to allow arbitrary objects and primitive data types to be read
and written from a stream. By implementing these interfaces, the
<TT>DataInputStream</TT> and <TT>DataOutputStream</TT> classes
provide the basis for the implementation of portable input and
output streams.
<H4><B>The </B><TT><B><FONT FACE="Courier New">DataInputStream</FONT></B></TT><B>
Class</B></H4>
<P>
The <TT>DataInputStream</TT> class provides the capability to
read arbitrary objects and primitive types from an input stream.
As you saw in the previous programming example, the filter provided
by this class can be nested with other input filters.
<P>
This class implements the methods of the <TT>DataInput</TT> interface.
These methods provide a full range of input capabilities. You
should check out the Java API pages for the <TT>DataInputStream</TT>
class to familiarize yourself with these methods.
<P>
Note that most, but not all, of these methods raise the <TT>EOFException</TT>
when an end of file is encountered. The <TT>readLine()</TT> method
returns a null value to signify a read past the end of a file.
<H4><B>The </B><TT><B><FONT FACE="Courier New">DataOutputStream</FONT></B></TT><B>
Class</B></H4>
<P>
The <TT>DataOutputStream</TT> class provides an output complement
to <TT>DataInputStream</TT>. It allows arbitrary objects and primitive
data types to be written to an output stream. It also keeps track
of the number of bytes written to the output stream. It is an
output filter and can be combined with any output-filtering streams.
<H4><B>The </B><TT><B><FONT FACE="Courier New">DataIOApp</FONT></B></TT><B>
Program</B></H4>
<P>
The program in Listing 13.7 shows how <TT>DataInputStream</TT>
and <TT>DataOutputStream</TT> can be used to easily read and write
a variety of values using streams.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.7. The source code of the </B><TT><B><FONT FACE="Courier New">DataIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.DataInputStream;<BR>
import java.io.DataOutputStream;<BR>
import java.io.FileInputStream;<BR>
import java.io.FileOutputStream;<BR>
import java.io.File;<BR>
import java.io.IOException;<BR>
<BR>
public class DataIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;File file = new File(&quot;test.txt&quot;);<BR>
&nbsp;&nbsp;FileOutputStream outFile = new FileOutputStream(file);
<BR>
&nbsp;&nbsp;DataOutputStream outStream = new DataOutputStream(outFile);
<BR>
&nbsp;&nbsp;outStream.writeBoolean(true);<BR>
&nbsp;&nbsp;outStream.writeInt(123456);<BR>
&nbsp;&nbsp;outStream.writeChar('j');<BR>
&nbsp;&nbsp;outStream.writeDouble(1234.56);<BR>
&nbsp;&nbsp;System.out.println(outStream.size()+&quot; bytes were
written&quot;);<BR>
&nbsp;&nbsp;outStream.close();<BR>
&nbsp;&nbsp;outFile.close();<BR>
&nbsp;&nbsp;FileInputStream inFile = new FileInputStream(file);
<BR>
&nbsp;&nbsp;DataInputStream inStream = new DataInputStream(inFile);
<BR>
&nbsp;&nbsp;System.out.println(inStream.readBoolean());<BR>
&nbsp;&nbsp;System.out.println(inStream.readInt());<BR>
&nbsp;&nbsp;System.out.println(inStream.readChar());<BR>
&nbsp;&nbsp;System.out.println(inStream.readDouble());<BR>
&nbsp;&nbsp;inStream.close();<BR>
&nbsp;&nbsp;inFile.close();<BR>
&nbsp;&nbsp;file.delete();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates an object of class <TT>File</TT> that is used
to access the <TT>test.txt</TT> file. This object is used to create
an instance of class <TT>FileOutputStream</TT> that is assigned
to the <TT>outFile</TT> variable. An object of class <TT>DataOutputStream</TT>
is then constructed as a filter for the <TT>FileOutputStream</TT>
object.
<P>
The <TT>writeBoolean()</TT>, <TT>writeChar()</TT>, <TT>writeInt()</TT>,
and <TT>writeDouble()</TT> methods of <TT>DataOutputStream</TT>
are used to write examples of primitive data types to the filtered
output stream. The number of bytes written to the output stream
is determined from the <TT>size()</TT> method and displayed to
the console window. The output streams are then closed.
<P>
The <TT>File</TT> object, created at the beginning of the program,
is then used to create an object of class <TT>FileInputStream</TT>.
The output stream is then filtered by creating an object of <TT>DataInputStream</TT>.
<P>
The primitive data types that were written to the output file
in the beginning of the program are now read from the filtered
input stream and displayed to the console window.
<P>
The program's output shows that the data values were successfully
written and read using the data I/O filters:
<BLOCKQUOTE>
<TT>15 bytes were written<BR>
<FONT FACE="Courier New">true<BR>
123456<BR>
j<BR>
1234.56</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="ThePrintStreamClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">PrintStream</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>PrintStream</TT> class should be no stranger to you. The
<TT>System.out</TT> object that you have been using for most of
the example programs is an instance of the <TT>PrintStream</TT>
class. It is used to write output to the Java console window.
<P>
<TT>PrintStream</TT>'s power lies in the fact that it provides
two methods, <TT>print()</TT> and <TT>println()</TT>, that are
overloaded to print any primitive data type or object. Objects
are printed by first converting them to strings using their <TT>toString()</TT>
method inherited from the <TT>Object</TT> class. To provide custom
printing for any class, all you have to do is override the <TT>toString()</TT>
method for that class.
<P>
<TT>PrintStream</TT> provides the capability to automatically
flush all output bytes in the stream when a newline character
is written to the stream. This feature can be enabled or disabled
when the stream is created.
<P>
Because <TT>PrintStream</TT> is a filter, it takes an instance
of <TT>OutputStream</TT> as an argument to its constructor. A
second constructor adds the capability to use the autoflushing
feature.
<P>
<TT>PrintStream</TT> introduces only one new method besides the
extensively overloaded <TT>print()</TT> and <TT>println()</TT>
methods. The <TT>checkError()</TT> method is used to flush stream
output and determine whether an error occurred on the output stream.
This capability is useful for printing output to devices, such
as printers, where error status is needed to notify the user of
any changes to the device state.
<H3><A NAME="PipedIO"><B>Piped I/O</B></A></H3>
<P>
Piped I/O provides the capability for threads to communicate via
streams. A thread sends data to another thread by creating an
object of <TT>PipedOutputStream</TT> that it connects to an object
of <TT>PipedInputStream</TT>. The output data written by one thread
is read by another thread using the <TT>PipedInputStream</TT>
object.
<P>
The process of connecting piped input and output threads is symmetric.
An object of class <TT>PipedInputThread</TT> can also be connected
to an existing object of class <TT>PipedOutputThread</TT>.
<P>
Java automatically performs synchronization with respect to piped
input and output streams. The thread that reads from an input
pipe does not have to worry about any conflicts with tasks that
are writing to the corresponding output stream thread.
<P>
Both <TT>PipedInputStream</TT> and <TT>PipedOutputStream</TT>
override the standard I/O methods of <TT>InputStream</TT> and
<TT>OutputStream</TT>. The only new method provided by these classes
is the <TT>connect()</TT> method. Both classes provide the capability
to connect a piped stream when it is constructed by passing the
argument of the piped stream to which it is to be connected as
an argument to the constructor.
<H4><B>The </B><TT><B><FONT FACE="Courier New">PipedIOApp</FONT></B></TT><B>
Program</B></H4>
<P>
The <TT>PipedIOApp</TT> program creates two threads of execution,
named <TT>Producer</TT> and <TT>Consumer</TT>, that communicate
using connected objects of classes <TT>PipedOutputStream</TT>
and <TT>PipedInputStream</TT>. <TT>Producer</TT> sends the message
<TT>This is a test.</TT> to <TT>Consumer</TT> one character at
a time, and <TT>Consumer</TT> reads the message in the same manner.
<TT>Producer</TT> displays its name and any characters that it
writes to the console window. <TT>Consumer</TT> reads the message
and displays its name and the characters it reads to the console
window. The source code for the <TT>PipedIOApp</TT> program is
shown in Listing 13.8.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.8. The source code of the </B><TT><B><FONT FACE="Courier New">PipedIOApp</FONT></B></TT><B>
program.</B><P>
<TT>import java.lang.Thread;<BR>
<FONT FACE="Courier New">import java.lang.System;<BR>
import java.lang.InterruptedException;<BR>
import java.lang.Runnable;<BR>
import java.io.PipedInputStream;<BR>
import java.io.PipedOutputStream;<BR>
import java.io.IOException;<BR>
<BR>
class PipedIOApp {<BR>
&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;Thread thread1 = new Thread(new PipeOutput(&quot;Producer&quot;));
<BR>
&nbsp;&nbsp;Thread thread2 = new Thread(new PipeInput(&quot;Consumer&quot;));
<BR>
&nbsp;&nbsp;thread1.start();<BR>
&nbsp;&nbsp;thread2.start();<BR>
&nbsp;&nbsp;boolean thread1IsAlive = true;<BR>
&nbsp;&nbsp;boolean thread2IsAlive = true;<BR>
&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;if(thread1IsAlive &amp;&amp; !thread1.isAlive()){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread1IsAlive = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread 1 is dead.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;if(thread2IsAlive &amp;&amp; !thread2.isAlive()){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread2IsAlive = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread 2 is dead.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}while(thread1IsAlive || thread2IsAlive);<BR>
&nbsp;}<BR>
}<BR>
class PipeIO {<BR>
&nbsp;static PipedOutputStream outputPipe = new PipedOutputStream();
<BR>
&nbsp;static PipedInputStream inputPipe = new PipedInputStream();
<BR>
&nbsp;static {<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;outputPipe.connect(inputPipe);<BR>
&nbsp;&nbsp;}catch (IOException ex) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException in static
initializer&quot;);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
&nbsp;String name;<BR>
&nbsp;public PipeIO(String id) {<BR>
&nbsp;&nbsp;name = id;<BR>
&nbsp;}<BR>
}<BR>
class PipeOutput extends PipeIO implements Runnable {<BR>
&nbsp;public PipeOutput(String id) {<BR>
&nbsp;&nbsp;super(id);<BR>
&nbsp;}<BR>
&nbsp;public void run() {<BR>
&nbsp;&nbsp;String s = &quot;This is a test.&quot;;<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;s.length();++i){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outputPipe.write(s.charAt(i));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name+&quot; wrote &quot;+s.charAt(i));
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;outputPipe.write('!');<BR>
&nbsp;&nbsp;} catch(IOException ex) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException in PipeOutput&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}<BR>
class PipeInput extends PipeIO implements Runnable {<BR>
&nbsp;public PipeInput(String id) {<BR>
&nbsp;&nbsp;super(id);<BR>
&nbsp;}<BR>
&nbsp;public void run() {<BR>
&nbsp;&nbsp;boolean eof = false;<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;while (!eof) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int inChar = inputPipe.read();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(inChar != -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char ch = (char) inChar;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ch=='!'){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eof=true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else System.out.println(name+&quot;
read &quot;+ch);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;} catch(IOException ex) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException in PipeOutput&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This program is somewhat longer than the other examples in this
chapter due to the overhead needed to set up the threading. The
<TT>main()</TT> method creates the two <TT>Producer</TT> and <TT>Consumer</TT>
threads as objects of classes <TT>PipeOutput</TT> and <TT>PipeInput</TT>.
These classes are subclasses of <TT>PipeIO</TT> that implement
the <TT>Runnable</TT> interface. The <TT>main()</TT> method starts
both threads and then loops, checking for their death.
<P>
The <TT>PipeIO</TT> class is the superclass of the <TT>PipeOutput</TT>
and <TT>PipeInput</TT> classes. It contains the <TT>static</TT>
variables, <TT>outputPipe</TT> and <TT>inputPipe</TT>, that are
used for interthread communication. These variables are assigned
objects of classes <TT>PipedOutputStream</TT> and <TT>PipeInputStream</TT>.
The <TT>static</TT> initializer is used to connect <TT>outputPipe</TT>
with <TT>inputPipe</TT> using the <TT>connect()</TT> method. The
<TT>PipeIO</TT> constructor provides the capability to maintain
the name of its instances. This is used by the <TT>PipeInput</TT>
and <TT>PipeOutput</TT> classes to store thread names.
<P>
The <TT>PipeOutput</TT> class extends <TT>PipeIO</TT> and implements
the <TT>Runnable</TT> interface, making it eligible to be executed
as a separate thread. The required <TT>run()</TT> method performs
all thread processing. It loops to write the test message one
character at a time to the <TT>outputPipe</TT>. It also displays
its name and the characters that it writes to the console window.
The <TT>!</TT> character is used to signal the end of the message
transmission. Notice that <TT>IOException</TT> is handled within
the thread rather than being identified in the <TT>throws</TT>
clause of the <TT>run()</TT> method. In order for <TT>run()</TT>
to properly implement the <TT>Runnable</TT> interface, it cannot
throw any exceptions.
<P>
The <TT>PipeInput</TT> class also extends <TT>PipeIO</TT> and
implements the <TT>Runnable</TT> interface. It simply loops and
reads one character at a time from <TT>inputPipe</TT>, displaying
its name and the characters that it reads to the console window.
It also handles <TT>IOException</TT> in order to avoid having
to identify the exception in its <TT>throws</TT> clause.
<P>
The output of <TT>PipeIOApp</TT> shows the time sequencing of
the thread input and output taking place using the connected pipe
I/O streams. The output generated by running the program on your
computer will probably differ because of differences in your computer's
execution speed and I/O performance. The output generated when
I ran the program is as follows:
<BLOCKQUOTE>
<TT>Producer wrote T<BR>
<FONT FACE="Courier New">Producer wrote h<BR>
Producer wrote i<BR>
Producer wrote s<BR>
Producer wrote<BR>
Consumer read T<BR>
Consumer read h<BR>
Consumer read i<BR>
Producer wrote i<BR>
Producer wrote s<BR>
Producer wrote<BR>
Consumer read s<BR>
Consumer read<BR>
Producer wrote a<BR>
Producer wrote<BR>
Producer wrote t<BR>
Consumer read i<BR>
Consumer read s<BR>
Consumer read<BR>
Producer wrote e<BR>
Producer wrote s<BR>
Consumer read a<BR>
Consumer read<BR>
Consumer read t<BR>
Producer wrote t<BR>
Producer wrote .<BR>
Thread 1 is dead.<BR>
Consumer read e<BR>
Consumer read s<BR>
Consumer read t<BR>
Consumer read .<BR>
Thread 2 is dead.</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheRandomAccessFileClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">RandomAccessFile</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>RandomAccessFile</TT> class provides the capability to
perform I/O directly to specific locations within a file. The
name &quot;random access&quot; comes from the fact that data can
be read from or written to random locations within a file rather
than as a continuous stream of information. Random access is supported
through the <TT>seek()</TT> method, which allows the pointer corresponding
to the current file position to be set to arbitrary locations
within the file.
<P>
<TT>RandomAccessFile</TT> implements both the <TT>DataInput</TT>
and <TT>DataOutput</TT> interfaces. This provides the capability
to perform I/O using all objects and primitive data types.
<P>
<TT>RandomAccessFile</TT> also supports basic file read/write
permissions, allowing files to be accessed in read-only or read-write
mode. A mode stream argument is passed to the <TT>RandomAccessFile</TT>
constructor as <TT>r</TT> or <TT>rw</TT>, indicating read-only
and read-write file access. The read-only access attribute may
be used to prevent a file from being inadvertently modified.
<P>
<TT>RandomAccessFile</TT> introduces several new methods besides
those inherited from <TT>Object</TT> and implemented from <TT>DataInput</TT>
and <TT>DataOutput</TT>. These methods include <TT>seek()</TT>,
<TT>getFilePointer()</TT>, and <TT>length()</TT>. The <TT>seek()</TT>
method sets the file pointer to a particular location within the
file. The <TT>getFilePointer()</TT> method returns the current
location of the file pointer. The <TT>length()</TT> method returns
the length of the file in bytes.
<H3><A NAME="TheRandomIOAppProgram"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">RandomIOApp</FONT></B></TT><B><FONT SIZE=4>
Program</FONT></B></A></H3>
<P>
The <TT>RandomIOApp</TT> program provides a simple demonstration
of the capabilities of random-access I/O. It writes a <TT>boolean</TT>,
<TT>int</TT>, <TT>char</TT>, and <TT>double</TT> value to a file
and then uses the <TT>seek()</TT> method to seek to offset location
1 within the file. This is the position after the first byte in
the file. It then reads the <TT>int</TT>, <TT>char</TT>, and <TT>double</TT>
values from the file and displays them to the console window.
Next, it moves the file pointer to the beginning of the file and
reads the <TT>boolean</TT> value that was first written to the
file. This value is also written to the console window. The source
code of the <TT>RandomIOApp</TT> program is shown in Listing 13.9.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.9. The source code of the </B><TT><B><FONT FACE="Courier New">RandomIOApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.RandomAccessFile;<BR>
import java.io.IOException;<BR>
<BR>
public class RandomIOApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;RandomAccessFile file = new RandomAccessFile(&quot;test.txt&quot;,&quot;rw&quot;);
<BR>
&nbsp;&nbsp;file.writeBoolean(true);<BR>
&nbsp;&nbsp;file.writeInt(123456);<BR>
&nbsp;&nbsp;file.writeChar('j');<BR>
&nbsp;&nbsp;file.writeDouble(1234.56);<BR>
&nbsp;&nbsp;file.seek(1);<BR>
&nbsp;&nbsp;System.out.println(file.readInt());<BR>
&nbsp;&nbsp;System.out.println(file.readChar());<BR>
&nbsp;&nbsp;System.out.println(file.readDouble());<BR>
&nbsp;&nbsp;file.seek(0);<BR>
&nbsp;&nbsp;System.out.println(file.readBoolean());<BR>
&nbsp;&nbsp;file.close();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Although the processing performed by <TT>RandomIOApp</TT> is quite
simple, it illustrates how random I/O allows you to move the file
pointer to various locations within a file to directly access
values and objects contained within the file.
<P>
The program's output is as follows:
<BLOCKQUOTE>
<TT>123456<BR>
<FONT FACE="Courier New">j<BR>
1234.56<BR>
true</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheStreamTokenizerClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">StreamTokenizer</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>StreamTokenizer</TT> class is used by parsers to convert
an input stream into a stream of lexical tokens. It uses special
methods to identify parser parameters such as ordinary, whitespace,
quote, and comment characters. These methods also enable and disable
number and end-of-line parsing.
<P>
Seven variables are defined for the <TT>StreamTokenizer</TT> class,
four of which are constant class variables. The <TT>TT_EOF</TT>,
<TT>TT_EOL</TT>, <TT>TT_NUMBER</TT>, and <TT>TT_WORD</TT> constants
are used to identify the type of input token encountered when
parsing the input stream. The <TT>ttype</TT> variable is set either
to one of these constants or to a single character based on the
kind of token that is read from the input stream. The <TT>TT_</TT>
constants are used to indicate a number, word, end of line, or
end of file. When a word token is read, the actual word is stored
in the <TT>sval</TT> variable and <TT>ttype</TT> is set to <TT>TT_WORD</TT>.
When a number token is read, its value is stored in the <TT>nval</TT>
variable and <TT>ttype</TT> is set to <TT>TT_NUMBER</TT>. When
other special characters, such as <TT>@</TT> or <TT>*</TT>, are
read from the input stream, they are assigned directly to the
<TT>ttype</TT> variable.
<P>
The <TT>StreamTokenizer</TT> constructor takes an <TT>InputStream</TT>
object as an argument and generates a <TT>StreamTokenizer</TT>
object. The <TT>StreamTokenizer</TT> access methods can be divided
into two groups: parser parameter-definition methods and stream-processing
methods.
<P>
The parser parameter-definition methods are used to control the
operation of the parser. The <TT>commentChar()</TT>, <TT>slashSlashComments(</TT>),
and <TT>slashStarComments()</TT> methods are used to define comments.
Comments are ignored by the parser. The <TT>whitespaceChars()</TT>,
<TT>wordChars()</TT>, <TT>quoteChar()</TT>, <TT>ordinaryChar()</TT>,
and <TT>ordinaryChars()</TT> methods are used to set the parser's
token-generation parameters. The <TT>parseNumbers()</TT> and <TT>eolIsSignificant()</TT>
methods toggle number and end-of-line parsing. The <TT>lowerCaseMode()</TT>
method controls whether input words are converted to lowercase,
and the <TT>resetSyntax()</TT> method is used to reset the syntax
table, causing all characters to be treated as special characters.
<P>
The stream-processing methods are used to read tokens from the
input stream, push tokens back out onto the input stream, and
return the current line number associated with the input stream.
The <TT>nextToken()</TT> method is used to get the next token
from the input stream. The <TT>pushBack()</TT> method pushes the
current token back out onto the input stream. The <TT>lineno()</TT>
method returns the current line number associated with the input
stream.
<P>
The <TT>toString()</TT> method of class <TT>Object</TT> is overwritten
to allow printing of the current token.
<H3><A NAME="TheStreamTokenAppProgram"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">StreamTokenApp</FONT></B></TT><B><FONT SIZE=4>
Program</FONT></B></A></H3>
<P>
The <TT>StreamTokenApp</TT> program demonstrates the ease with
which <TT>StreamTokenizer</TT> can be used to create a parser.
This program reads input from the standard input stream, parses
input tokens, and displays the token type and value to the console
window. (See Listing 13.10.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 13.10. The source code of the </B><TT><B><FONT FACE="Courier New">StreamTokenApp</FONT></B></TT><B>
program.</B><P>

<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.io.StreamTokenizer;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class StreamTokenApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;DataInputStream inData = new DataInputStream(System.in);
<BR>
&nbsp;&nbsp;StreamTokenizer inStream = new StreamTokenizer(inData);
<BR>
&nbsp;&nbsp;inStream.commentChar('#');<BR>
&nbsp;&nbsp;inStream.eolIsSignificant(true);<BR>
&nbsp;&nbsp;inStream.whitespaceChars(0,32);<BR>
&nbsp;&nbsp;boolean eof = false;<BR>
&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;int token=inStream.nextToken();<BR>
&nbsp;&nbsp;&nbsp;switch(token){<BR>
&nbsp;&nbsp;&nbsp;case inStream.TT_EOF:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;EOF encountered.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;eof = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;case inStream.TT_EOL:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;EOL encountered.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;case inStream.TT_WORD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Word: &quot;+inStream.sval);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;case inStream.TT_NUMBER:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Number: &quot;+inStream.nval);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((char) token+&quot;
encountered.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(token=='!') eof=true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;} while(!eof);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates a new object of class <TT>DataInputStream</TT>
using <TT>System.in</TT> as an argument. It then converts the
<TT>DataInputStream</TT> object into a <TT>StreamTokenizer</TT>
object and assigns it to the <TT>inStream</TT> variable. It sets
the comment-line character to <TT>#</TT>, makes the end-of-line
character a significant token, and identifies all ASCII characters
with values between 0 and 32 as whitespace characters.
<P>
Having set up the parser, <TT>StreamTokenApp</TT> reads tokens
from <TT>inStream</TT> until the end of file is encountered. It
uses a <TT>switch</TT> statement to identify the type and value
of each token read.
<P>
The following is an example of the output produced by <TT>StreamTokenizer</TT>.
Try running it with different input lines:
<BLOCKQUOTE>
<TT>This is a test.<BR>
<FONT FACE="Courier New">Word: This<BR>
Word: is<BR>
Word: a<BR>
Word: test.<BR>
EOL encountered.<BR>
123 456<BR>
Number: 123<BR>
Number: 456<BR>
EOL encountered.<BR>
12.34 56.78<BR>
Number: 12.34<BR>
Number: 56.78<BR>
EOL encountered.<BR>
@ $ % ^<BR>
@ encountered.<BR>
$ encountered.<BR>
% encountered.<BR>
^ encountered.<BR>
EOL encountered.<BR>
#This is a comment.<BR>
EOL encountered.<BR>
This is #a comment.<BR>
Word: This<BR>
Word: is<BR>
EOL encountered.<BR>
!<BR>
! encountered.</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter you have learned to work with Java input and output
streams to perform input and output using standard I/O, memory
buffers, and files. You have explored the input and output stream
class hierarchy and learned to use stream filters to simplify
I/O processing. You have also learned how to perform random-access
I/O and how to use the <TT>StreamTokenizer</TT> class to construct
an input parser. In <A HREF="ch14.htm" >Chapter 14</A> you will
learn how to use the utility classes provided in the <TT>java.util</TT>
package.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



