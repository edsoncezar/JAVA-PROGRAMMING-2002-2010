<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 14</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Useful Tools in the </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">java.util</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Package</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheDateClass" >The Date Class</A>
<UL>
<LI><A HREF="#DateApp" >DateApp</A>
</UL>
<LI><A HREF="#TheRandomClass" >The Random Class</A>
<UL>
<LI><A HREF="#RandomApp" >RandomApp</A>
</UL>
<LI><A HREF="#TheEnumerationInterface" >The Enumeration Interface</A>
<LI><A HREF="#TheVectorClass" >The Vector Class</A>
<UL>
<LI><A HREF="#VectorApp" >VectorApp</A>
</UL>
<LI><A HREF="#TheStackClass" >The Stack Class</A>
<UL>
<LI><A HREF="#StackApp" >StackApp</A>
</UL>
<LI><A HREF="#TheBitSetClass" >The BitSet Class</A>
<UL>
<LI><A HREF="#BitSetApp" >BitSetApp</A>
</UL>
<LI><A HREF="#TheDictionaryHashtableandPropertie" >The Dictionary, Hashtable, and Properties Classes</A>
<UL>
<LI><A HREF="#Dictionary" >Dictionary</A>
<LI><A HREF="#Hashtable" >Hashtable</A>
<LI><A HREF="#ThePropertiesClass" >The Properties Class</A>
</UL>
<LI><A HREF="#TheStringTokenizerClass" >The StringTokenizer Class</A>
<UL>
<LI><A HREF="#TokenApp" >TokenApp</A>
</UL>
<LI><A HREF="#ObserverandObservable" >Observer and Observable</A>
<UL>
<LI><A HREF="#Observable" >Observable</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
In this chapter you'll learn how to work with all the useful utility
classes contained in the <TT>java.util</TT> package. You'll learn
to use the <TT>Date</TT> class to manipulate <TT>Date</TT> objects,
to generate random numbers using the <TT>Random</TT> class, and
to work with data structures such as dictionaries, stacks, hash
tables, vectors, and bit sets. When you finish this chapter you'll
be able to make productive use of these utility classes in your
own programs.
<H2><A NAME="TheDateClass"><B><FONT SIZE=5 COLOR=#FF0000>The </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Date</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>Date</TT> class encapsulates date and time information
and allows <TT>Date</TT> objects to be accessed in a system-independent
manner. <TT>Date</TT> provides methods for accessing specific
date and time measurements, such as year, month, day, date, hours,
minutes, and seconds, and for displaying dates in a variety of
standard formats.
<P>
The <TT>Date</TT> class provides six constructors for creating
<TT>Date</TT> objects. The default constructor creates a <TT>Date</TT>
object with the current system date and time. Other constructors
allow <TT>Date</TT> objects to be set to other dates and times.
The access methods defined by the <TT>Date</TT> class support
comparisons between dates and provide access to specific date
information, including the time zone offset.
<P>
If you intend to process date-related information in a program,
you should consult the API page for the <TT>Date</TT> class to
obtain a full list of the available <TT>Date</TT> methods.
<H3><A NAME="DateApp"><TT><B><FONT SIZE=4 FACE="Courier New">DateApp</FONT></B></TT></A>
</H3>
<P>
The <TT>DateApp</TT> program illustrates the use of the <TT>Date</TT>
class. It shows how <TT>Date</TT> objects are created and manipulated
using the methods provided by the class. (See Listing 14.1.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.1. The source code of the </B><TT><B><FONT FACE="Courier New">DateApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Date;<BR>
<BR>
public class DateApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;Date today = new Date();<BR>
&nbsp;&nbsp;String days[] = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
<BR>
&nbsp;&nbsp;System.out.println(&quot;Today's date (locale conventions):
&quot;+<BR>
&nbsp;&nbsp;&nbsp;today.toLocaleString());<BR>
&nbsp;&nbsp;System.out.println(&quot;Today's date (Unix conventions):
&quot;+today.toString());<BR>
&nbsp;&nbsp;System.out.println(&quot;Today's date (GMT conventions):
&quot;+today.toGMTString());<BR>
&nbsp;&nbsp;System.out.println(&quot;Year: &quot;+today.getYear());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Month: &quot;+today.getMonth());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Date: &quot;+today.getDate());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Day: &quot;+days[today.getDay()]);
<BR>
&nbsp;&nbsp;System.out.println(&quot;Hour: &quot;+today.getHours());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Minute: &quot;+today.getMinutes());
<BR>
&nbsp;&nbsp;System.out.println(&quot;Second: &quot;+today.getSeconds());
<BR>
&nbsp;&nbsp;Date newYears2000 = new Date(100,0,1);<BR>
&nbsp;&nbsp;System.out.println(&quot;New Years Day 2000: &quot;+newYears2000.toString());
<BR>
&nbsp;&nbsp;System.out.println(&quot;New Years Day 2000 is &quot;+days[newYears2000.getDay()]);
<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates a <TT>Date</TT> object using the default constructor
and assigns it to the <TT>today</TT> variable. It then declares
an array named <TT>days</TT> and initializes it to the three-letter
abbreviations of the days of the week. The <TT>toLocaleString()</TT>,
<TT>toString()</TT>, and <TT>toGMTString()</TT> methods are used
to convert and print the date using the local operating system
and standard UNIX and GMT conventions.
<P>
The various <TT>get</TT> methods supported by the <TT>Date</TT>
class are used to print out the year, month, date, day, hours,
minutes, and seconds corresponding to the current date.
<P>
A new <TT>Date</TT> object is constructed and assigned to the
<TT>newYears2000</TT> variable. The <TT>Date</TT> constructor
takes the arguments <TT>100</TT>, <TT>0</TT>, and <TT>1</TT>.
They specify the 100th year after the year 1900, the 0th month
(that is, January), and the first day of the month. The date specified
is New Year's Day in the year 2000, as you probably guessed from
the name of the variable in which it is stored.
<P>
The <TT>newYears2000</TT> date is printed followed by the actual
day of the week corresponding to the date.
<P>
The output of the <TT>DateApp</TT> program is as follows. When
you run the program, you will obviously get a different date for
the first part of the program's processing. The following are
the results that were displayed when I ran the program:
<BLOCKQUOTE>
<TT>Today's date (locale conventions): 03/01/96 09:53:46<BR>
<FONT FACE="Courier New">Today's date (Unix conventions): Fri
Mar 01 09:53:46  1996<BR>
Today's date (GMT conventions): 1 Mar 1996 17:53:46 GMT<BR>
Year: 96<BR>
Month: 2<BR>
Date: 1<BR>
Day: Fri<BR>
Hour: 9<BR>
Minute: 53<BR>
Second: 46<BR>
New Years Day 2000: Sat Jan 01 00:00:00  2000<BR>
New Years Day 2000 is Sat</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheRandomClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Random</FONT></B></TT><B><FONT SIZE=2 COLOR=#FF0000>
</FONT><FONT SIZE=5 COLOR=#FF0000>Class</FONT></B></A></H2>
<P>
The <TT>Random</TT> class provides a template for the creation
of random number generators. It differs from the <TT>random()</TT>
method of the <TT>java.lang.Math</TT> class in that it allows
any number of random number generators to be created as separate
objects. The <TT>Math.random()</TT> method provides a <TT>static</TT>
function for the generation of random <TT>double</TT> values.
This <TT>static</TT> method is shared by all program code.
<P>
Objects of the <TT>Random</TT> class generate random numbers using
a linear congruential formula. Two constructors are provided for
creating <TT>Random</TT> objects. The default constructor initializes
the seed of the random number generator using the current system
time. The other constructor allows the seed to be set to an initial
<TT>long</TT> value.
<P>
The Java API page says the random number generator uses a 48-bit
seed, but the constructor allows only a 32-bit value to be passed
as a seed. In any case, the random number generators that are
created as objects of this class should be sufficient for most
random number generation needs.
<P>
The <TT>Random</TT> class provides six access methods, five of
which are used to generate random values. The <TT>nextInt()</TT>,
<TT>nextLong()</TT>, <TT>nextFloat()</TT>, and <TT>nextDouble()</TT>
methods generate values for the numeric data types. The values
generated by <TT>nextFloat()</TT> and <TT>nextDouble()</TT> are
between 0.0 and 1.0. The <TT>nextGaussian()</TT> method generates
a Gaussian distribution of <TT>double</TT> values with mean 0.0
and standard deviation 1.0.
<P>
The <TT>setSeed()</TT> method is used to reset the seed of the
random number generator.
<H3><A NAME="RandomApp"><TT><B><FONT SIZE=4 FACE="Courier New">RandomApp</FONT></B></TT></A>
</H3>
<P>
The <TT>RandomApp</TT> program demonstrates the use of the <TT>Random</TT>
class. (See Listing 14.2.) It creates an object of class <TT>Random</TT>
using the default constructor and assigns it to <TT>r</TT>. This
causes the random number generator to be seeded using the current
system time. Three <TT>for</TT> loops are used to print random
<TT>int</TT>, <TT>double</TT>, and Gaussian distributed <TT>double</TT>
values. Each loop prints four values.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.2. The source code of the </B><TT><B><FONT FACE="Courier New">RandomApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Random;<BR>
<BR>
public class RandomApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;Random r = new Random();<BR>
&nbsp;&nbsp;for(int i=0;i&lt;4;++i) System.out.print(r.nextInt()+&quot;
&quot;);<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;r = new Random(123456789);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;4;++i) System.out.print(r.nextDouble()+&quot;
&quot;);<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;r.setSeed(234567890);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;4;++i) System.out.print(r.nextGaussian()+&quot;
&quot;);<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output generated by the program when it was run on my computer
produced the following results:
<BLOCKQUOTE>
<TT>1799702397 -2014911382 618703884 -1181330064<BR>
<FONT FACE="Courier New">0.664038 0.456952 0.390506 0.893341<BR>
0.113781 0.412296 -1.57262 0.0756829</FONT></TT>
</BLOCKQUOTE>
<P>
It will produce different results when it is run on your computer
because the first line that is printed uses the <TT>Random()</TT>
constructor to generate the output data.
<H2><A NAME="TheEnumerationInterface"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Enumeration</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Interface</FONT></B></A></H2>
<P>
The <TT>Enumeration</TT> interface specifies two methods to be
used to index through a set of objects or values: <TT>hasMoreElements()</TT>
and <TT>nextElement()</TT>. The <TT>hasMoreElements()</TT> method
enables you to determine whether more elements are contained in
an <TT>Enumeration</TT> object. The <TT>nextElement()</TT> method
returns the next element contained by an object.
<P>
Enumeration-implementing objects are said to be <I>consumed</I>
by their use. This means that the <TT>Enumeration</TT> objects
cannot be restarted to reindex through the elements they contain.
Their elements may be accessed only once.
<P>
The <TT>Enumeration</TT> interface is implemented by the <TT>StringTokenizer</TT>
class as discussed later in this chapter in the section &quot;The
<TT>StringTokenizer</TT> Class.&quot; It is also used to obtain
a list of elements contained in a vector, as shown in the programming
example in the next section.
<H2><A NAME="TheVectorClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Vector</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>Vector</TT> class provides the capability to implement
a growable array. The array grows larger as more elements are
added to it. The array may also be reduced in size, after some
of its elements have been deleted. This is accomplished using
the <TT>trimToSize()</TT> method.
<P>
<TT>Vector</TT> operates by creating an initial storage capacity
and then adding to this capacity as needed. It grows by an increment
defined by the <TT>capacityIncrement</TT> variable. The initial
storage capacity and <TT>capacityIncrement</TT> can be specified
in <TT>Vector</TT>'s constructor. A second constructor is used
when you want to specify only the initial storage capacity. A
third, default constructor specifies neither the initial capacity
nor the <TT>capacityIncrement</TT>. This constructor lets Java
figure out the best parameters to use for <TT>Vector</TT> objects.
<P>
The access methods provided by the <TT>Vector</TT> class support
array-like operations and operations related to the size of <TT>Vector</TT>
objects. The array-like operations allow elements to be added,
deleted, and inserted into vectors. They also allow tests to be
performed on the contents of vectors and specific elements to
be retrieved. The size-related operations allow the byte size
and number of elements of the vector to be determined and the
vector size to be increased to a certain capacity or trimmed to
the minimum capacity needed. Consult the <TT>Vector</TT> API page
for a complete description of these methods.
<H3><A NAME="VectorApp"><TT><B><FONT SIZE=4 FACE="Courier New">VectorApp</FONT></B></TT></A>
</H3>
<P>
The <TT>VectorApp</TT> program illustrates the use of vectors
and the <TT>Enumeration</TT> interface. (See Listing 14.3.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.3. The source code of the </B><TT><B><FONT FACE="Courier New">VectorApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Vector;<BR>
import java.util.Enumeration;<BR>
<BR>
public class VectorApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;Vector v = new Vector();<BR>
&nbsp;&nbsp;v.addElement(&quot;one&quot;);<BR>
&nbsp;&nbsp;v.addElement(&quot;two&quot;);<BR>
&nbsp;&nbsp;v.addElement(&quot;three&quot;);<BR>
&nbsp;&nbsp;v.insertElementAt(&quot;zero&quot;,0);<BR>
&nbsp;&nbsp;v.insertElementAt(&quot;oops&quot;,3);<BR>
&nbsp;&nbsp;v.insertElementAt(&quot;four&quot;,5);<BR>
&nbsp;&nbsp;System.out.println(&quot;Size: &quot;+v.size());<BR>
&nbsp;&nbsp;Enumeration enum = v.elements();<BR>
&nbsp;&nbsp;while (enum.hasMoreElements())<BR>
&nbsp;&nbsp;&nbsp;System.out.print(enum.nextElement()+&quot; &quot;);
<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;v.removeElement(&quot;oops&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;Size: &quot;+v.size());<BR>
&nbsp;&nbsp;for(int i=0;i&lt;v.size();++i)<BR>
&nbsp;&nbsp;&nbsp;System.out.print(v.elementAt(i)+&quot; &quot;);
<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program creates a <TT>Vector</TT> object using the default
constructor and uses the <TT>addElement()</TT> method to add the
strings, <TT>&quot;one&quot;</TT>, <TT>&quot;two&quot;</TT>, and
<TT>&quot;three&quot;</TT> to the vector. It then uses the <TT>insertElementAt()</TT>
method to insert the strings <TT>&quot;zero&quot;</TT>, <TT>&quot;oops&quot;</TT>,
and <TT>&quot;four&quot;</TT> at locations 0, 3, and 5 within
the vector. The <TT>size()</TT> method is used to retrieve the
vector size for display to the console window.
<P>
The <TT>elements()</TT> method of the <TT>Vector</TT> class is
used to retrieve an enumeration of the elements that were added
to the vector. A <TT>while</TT> loop is then used to cycle through
and print the elements contained in the enumeration. The <TT>hasMoreElements()</TT>
method is used to determine whether the enumeration contains more
elements. If it does, the <TT>nextElement()</TT> method is used
to retrieve the object for printing.
<P>
The <TT>removeElement()</TT> of the <TT>Vector</TT> class is used
to remove the vector element containing the string <TT>&quot;oops&quot;</TT>.
The new size of the vector is displayed and the elements of the
vector are redisplayed. The <TT>for</TT> loop indexes each element
in the vector using the <TT>elementAt()</TT> method.
<P>
The output of the <TT>VectorApp</TT> program is as follows:
<BLOCKQUOTE>
<TT>Size: 6<BR>
<FONT FACE="Courier New">zero one two oops three four<BR>
Size: 5<BR>
zero one two three four</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheStackClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Stack</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>Stack</TT> class provides the capability to create and
use stacks within your Java programs. <I>Stacks</I> are storage
objects that store information by pushing it onto a stack and
remove and retrieve information by popping it off the stack. Stacks
implement a last-in-first-out storage capability: The last object
pushed on a stack is the first object that can be retrieved from
the stack. The <TT>Stack</TT> class extends the <TT>Vector</TT>
class.
<P>
The <TT>Stack</TT> class provides a single default constructor,
<TT>Stack()</TT>, that is used to create an empty stack.
<P>
Objects are placed on the stack using the <TT>push()</TT> method
and retrieved from the stack using the <TT>pop()</TT> method.
The <TT>search()</TT> method allows you to search through a stack
to see if a particular object is contained on the stack. The <TT>peek()</TT>
method returns the top element of the stack without popping it
off. The <TT>empty()</TT> method is used to determine whether
a stack is empty. The <TT>pop()</TT> and <TT>peek()</TT> methods
both throw the <TT>EmptyStackException</TT> if the stack is empty.
Use of the <TT>empty()</TT> method can help to avoid the generation
of this exception.
<H3><A NAME="StackApp"><TT><B><FONT SIZE=4 FACE="Courier New">StackApp</FONT></B></TT></A>
</H3>
<P>
The <TT>StackApp</TT> program demonstrates the operation of a
stack. (See Listing 14.4.) It creates a <TT>Stack</TT> object
and then uses the <TT>push()</TT> method to push the strings <TT>&quot;one&quot;</TT>,
<TT>&quot;two&quot;</TT>, and <TT>&quot;three&quot;</TT> onto
the stack. Because the stack operates in last-in-first-out fashion,
the top of the stack is the string <TT>&quot;three&quot;</TT>.
This is verified by using the <TT>peek()</TT> method. The contents
of the stack are then popped off and printed using a <TT>while</TT>
loop. The <TT>empty()</TT> method is used to determine when the
loop should terminate. The <TT>pop()</TT> method is used to pop
objects off the top of the stack.
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.4. The source code of the </B><TT><B><FONT FACE="Courier New">StackApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Stack;<BR>
<BR>
public class StackApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;Stack s = new Stack();<BR>
&nbsp;&nbsp;s.push(&quot;one&quot;);<BR>
&nbsp;&nbsp;s.push(&quot;two&quot;);<BR>
&nbsp;&nbsp;s.push(&quot;three&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;Top of stack: &quot;+s.peek());
<BR>
&nbsp;&nbsp;while (!s.empty())<BR>
&nbsp;&nbsp;&nbsp;System.out.println(s.pop());<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output of the <TT>StackApp</TT> program is as follows:
<BLOCKQUOTE>
<TT>Size: 6<BR>
<FONT FACE="Courier New">zero one two oops three four<BR>
Size: 5<BR>
zero one two three four</FONT></TT>
</BLOCKQUOTE>

<H2><A NAME="TheBitSetClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">BitSet</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>BitSet</TT> class is used to create objects that maintain
a set of bits. The bits are maintained as a growable set. The
capacity of the bit set is increased as needed. Bit sets are used
to maintain a list of <I>flags</I> that indicate the state of
each element of a set of conditions. Flags are boolean values
that are used to represent the state of an object.
<P>
Two <TT>BitSet</TT> constructors are provided. One allows the
initial capacity of a <TT>BitSet</TT> object to be specified.
The other is a default constructor that initializes a <TT>BitSet</TT>
to a default size.
<P>
The <TT>BitSet</TT> access methods provide and, or, and exclusive
or logical operations on bit sets; enable specific bits to be
set and cleared; and override general methods declared for the
<TT>Object</TT> class.
<H3><A NAME="BitSetApp"><TT><B><FONT SIZE=4 FACE="Courier New">BitSetApp</FONT></B></TT></A>
</H3>
<P>
The <TT>BitSetApp</TT> program demonstrates the operation of bit
sets. (See Listing 14.5.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.5. The source code of the BitSetApp program.</B></FONT><BR><P>
<TT><FONT FACE="Courier New">import java.lang.System;<BR>
import java.util.BitSet;<BR>
<BR>
public class BitSetApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;int size = 8;<BR>
&nbsp;&nbsp;BitSet b1 = new BitSet(size);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;size;++i) b1.set(i);<BR>
&nbsp;&nbsp;BitSet b2 = (BitSet) b1.clone();<BR>
&nbsp;&nbsp;for(int i=0;i&lt;size;i=i+2) b2.clear(i);<BR>
&nbsp;&nbsp;System.out.print(&quot;b1: &quot;);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;size;++i) System.out.print(b1.get(i)+&quot;
&quot;);<BR>
&nbsp;&nbsp;System.out.print(&quot;\nb2: &quot;);<BR>
&nbsp;&nbsp;for(int i=0;i&lt;size;++i) System.out.print(b2.get(i)+&quot;
&quot;);<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;System.out.println(&quot;b1: &quot;+b1);<BR>
&nbsp;&nbsp;System.out.println(&quot;b2: &quot;+b2);<BR>
&nbsp;&nbsp;b1.xor(b2);<BR>
&nbsp;&nbsp;System.out.println(&quot;b1 xor b2 = &quot;+b1);<BR>
&nbsp;&nbsp;b1.and(b2);<BR>
&nbsp;&nbsp;System.out.println(&quot;b1 and b2 = &quot;+b1);<BR>
&nbsp;&nbsp;b1.or(b2);<BR>
&nbsp;&nbsp;System.out.println(&quot;b1 or b2 = &quot;+b1);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program begins by creating a <TT>BitSet</TT> object, <TT>b1</TT>,
of size 8. It executes a <TT>for</TT> statement to index through
<TT>b1</TT> and set each bit in the bit set. It then uses the
<TT>clone()</TT> method to create an identical copy of <TT>b1</TT>
and assign it to <TT>b2</TT>. Another <TT>for</TT> statement is
executed to clear every even-numbered bit in <TT>b2</TT>. The
values of the <TT>b1</TT> and <TT>b2</TT> bit sets are then printed.
This results in the display of two lists of <TT>boolean</TT> values.
The bit sets are printed as objects, resulting in a set- oriented
display. Only the bits with <TT>true</TT> <TT>boolean</TT> values
are identified as members of the displayed bit sets.
<P>
The <TT>xor()</TT> method is used to compute the exclusive or
of <TT>b1</TT> and <TT>b2</TT>, updating <TT>b1</TT> with the
result. The new value of <TT>b1</TT> is then displayed.
<P>
The <TT>and()</TT> method is used to calculate the logical and
of <TT>b1</TT> and <TT>b2</TT>, again, updating <TT>b1</TT> with
the result and displaying <TT>b1</TT>'s new value.
<P>
Finally, the logical or of <TT>b1</TT> and <TT>b2</TT> is computed,
using the <TT>or()</TT> method. The result is used to update <TT>b1</TT>,
and <TT>b1</TT>'s value is displayed.
<P>
The output of <TT>BitSetApp</TT> is as follows:
<BLOCKQUOTE>
<TT>b1: true true true true true true true true<BR>
<FONT FACE="Courier New">b2: false true false true false true
false true<BR>
b1: {0, 1, 2, 3, 4, 5, 6, 7}<BR>
b2: {1, 3, 5, 7}<BR>
b1 xor b2 = {0, 2, 4, 6}<BR>
b1 and b2 = {}<BR>
b1 or b2 = {1, 3, 5, 7}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheDictionaryHashtableandPropertie"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Dictionary</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>,
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Hashtable</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>,
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Properties</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
The <TT>Dictionary</TT>, <TT>Hashtable</TT>, and <TT>Properties</TT>
classes are three generations of classes that implement the capability
to provide key-based data storage and retrieval. The <TT>Dictionary</TT>
class is the abstract superclass of <TT>Hashtable</TT>, which
is, in turn, the superclass of <TT>Properties</TT>.
<H3><A NAME="Dictionary"><TT><B><FONT SIZE=4 FACE="Courier New">Dictionary</FONT></B></TT></A>
</H3>
<P>
<TT>Dictionary</TT> provides the abstract functions used to store
and retrieve objects by key-value associations. The class allows
any object to be used as a key or value. This provides great flexibility
in the design of key-based storage and retrieval classes. <TT>Hashtable</TT>
and <TT>Properties</TT> are two examples of these classes.
<P>
The <TT>Dictionary</TT> class can be understood using its namesake
abstraction. A real-world hardcopy dictionary maps words to their
definition. The words can be considered the keys of the dictionary
and the definitions as the values of the keys. Java dictionaries
operate in the same fashion. One object is used as the key to
access another object. This abstraction will become clearer as
you investigate the <TT>Hashtable</TT> and <TT>Properties</TT>
classes.
<P>
The <TT>Dictionary</TT> class defines several methods that are
inherited by its subclasses. The <TT>elements()</TT> method is
used to return an <TT>Enumeration</TT> object containing the values
of the key-value pairs stored within the dictionary. The <TT>keys()</TT>
method returns an enumeration of the dictionary keys. The <TT>get()</TT>
method is used to retrieve an object from the dictionary based
on its key. The <TT>put()</TT> method puts a <TT>Value</TT> object
in the dictionary and indexes it using a <TT>Key</TT> object.
The <TT>isEmpty()</TT> method determines whether a dictionary
contains any elements, and the <TT>size()</TT> method identifies
the dictionary's size in terms of the number of elements it contains.
The <TT>remove()</TT> method deletes a key-value pair from the
dictionary based on the object's key.
<H3><A NAME="Hashtable"><TT><B><FONT SIZE=4 FACE="Courier New">Hashtable</FONT></B></TT></A>
</H3>
<P>
The <TT>Hashtable</TT> class implements a hash table data structure.
A <I>hash table</I> indexes and stores objects in a dictionary
using hash codes as the objects' keys. <I>Hash codes</I> are integer
values that identify objects. They are computed in such a manner
that different objects are very likely to have different hash
values and therefore different dictionary keys.
<P>
The <TT>Object</TT> class implements the <TT>hashCode()</TT> method.
This method allows the hash code of an arbitrary Java object to
be calculated. All Java classes and objects inherit this method
from <TT>Object</TT>. The <TT>hashCode()</TT> method is used to
compute the hash code key for storing objects within a hash table.
<TT>Object</TT> also implements the <TT>equals()</TT> method.
This method is used to determine whether two objects with the
same hash code are, in fact, equal.
<P>
The Java <TT>Hashtable</TT> class is very similar to the <TT>Dictionary</TT>
class from which it is derived. Objects are added to a hash table
as key-value pairs. The object used as the key is hashed, using
its <TT>hashCode()</TT> method, and the hash code is used as the
actual key for the value object. When an object is to be retrieved
from a hash table, using a key, the key's hash code is computed
and used to find the object.
<P>
The <TT>Hashtable</TT> class provides three constructors. The
first constructor allows a hash table to be created with a specific
initial capacity and load factor. The <I>load factor</I> is a
float value between 0.0 and 1.0 that identifies the percentage
of hash table usage that causes the hash table to be rehashed
into a larger table. For example, suppose a hash table is created
with a capacity of 100 entries and a 0.70 load factor. When the
hash table is 70 percent full, a new, larger hash table will be
created, and the current hash table entries will have their hash
values recalculated for the larger table.
<P>
The second <TT>Hashtable</TT> constructor just specifies the table's
initial capacity and ignores the load factor. The default hash
table constructor does not specify either hash table parameter.
<P>
The access methods defined for the <TT>Hashtable</TT> class allow
key-value pairs to be added to and removed from a hash table,
search the hash table for a particular key or object value, create
an enumeration of the table's keys and values, determine the size
of the hash table, and recalculate the hash table, as needed.
Many of these methods are inherited or overridden from the <TT>Dictionary</TT>
class.
<H4><TT><B><FONT FACE="Courier New">HashApp</FONT></B></TT></H4>
<P>
The <TT>HashApp</TT> program illustrates the operation and use
of hash tables. (See Listing 14.6.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.6. The source code of the </B><TT><B><FONT FACE="Courier New">HashApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Hashtable;<BR>
import java.util.Enumeration;<BR>
<BR>
public class HashApp {<BR>
&nbsp;public static void main(String args[]){<BR>
&nbsp;&nbsp;Hashtable h = new Hashtable();<BR>
&nbsp;&nbsp;h.put(&quot;height&quot;,&quot;6 feet&quot;);<BR>
&nbsp;&nbsp;h.put(&quot;weight&quot;,&quot;200 pounds&quot;);
<BR>
&nbsp;&nbsp;h.put(&quot;eye color&quot;,&quot;blue&quot;);<BR>
&nbsp;&nbsp;h.put(&quot;hair color&quot;,&quot;brown&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;h: &quot;+h);<BR>
&nbsp;&nbsp;Enumeration enum = h.keys();<BR>
&nbsp;&nbsp;System.out.print(&quot;keys: &quot;);<BR>
&nbsp;&nbsp;while (enum.hasMoreElements()) System.out.print(enum.nextElement()+&quot;,
&quot;);<BR>
&nbsp;&nbsp;System.out.print(&quot;\nelements: &quot;);<BR>
&nbsp;&nbsp;enum = h.elements();<BR>
&nbsp;&nbsp;while (enum.hasMoreElements()) System.out.print(enum.nextElement()+&quot;,
&quot;);<BR>
&nbsp;&nbsp;System.out.println();<BR>
&nbsp;&nbsp;System.out.println(&quot;height: &quot;+h.get(&quot;height&quot;));
<BR>
&nbsp;&nbsp;System.out.println(&quot;weight: &quot;+h.get(&quot;weight&quot;));
<BR>
&nbsp;&nbsp;System.out.println(&quot;eyes: &quot;+h.get(&quot;eye
color&quot;));<BR>
&nbsp;&nbsp;System.out.println(&quot;hair: &quot;+h.get(&quot;hair
color&quot;));<BR>
&nbsp;&nbsp;h.remove(&quot;weight&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;h: &quot;+h);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program begins by creating a <TT>Hashtable</TT> object using
the default constructor. It then adds four key-value pairs to
the hash table using the <TT>put()</TT> method. The hash table
is then printed using the default print method for objects of
class <TT>Hashtable</TT>.
<P>
The <TT>keys()</TT> method is used to create an enumeration of
the hash table's keys. These keys are then printed one at a time
by indexing through the enumeration object.
<P>
The <TT>elements()</TT> method is used to create an enumeration
of the hash table's values. This enumeration is printed in the
same way as the key enumeration.
<P>
The values of the hash table are again displayed by using the
<TT>get()</TT> method to get the values corresponding to specific
key values.
<P>
Finally, the <TT>remove()</TT> method is used to remove the key-value
pair associated with the <TT>weight</TT> key and the hash table
is reprinted using the default print convention.
<P>
The program output is as follows:
<BLOCKQUOTE>
<TT>h: {height=6 feet, weight=200 pounds, eye color=blue, hair
color=brown}<BR>
<FONT FACE="Courier New">keys: height, weight, eye color, hair
color,<BR>
elements: 6 feet, 200 pounds, blue, brown,<BR>
height: 6 feet<BR>
weight: 200 pounds<BR>
eyes: blue<BR>
hair: brown<BR>
h: {height=6 feet, eye color=blue, hair color=brown}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="ThePropertiesClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier New">Properties</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT>Properties</TT> class is a subclass of <TT>Hashtable</TT>
that can be read from or written to a stream. It also provides
the capability to specify a set of default values to be used if
a specified key is not found in the table. The default values
themselves are specified as an object of class <TT>Properties</TT>.
This allows an object of class <TT>Properties</TT> to have a default
<TT>Properties</TT> object, which in turn has its own default
properties, and so on.
<P>
<TT>Properties</TT> supports two constructors: a default constructor
with no parameters and a constructor that accepts the default
properties to be associated with the <TT>Properties</TT> object
being constructed.
<P>
The <TT>Properties</TT> class declares several new access methods.
The <TT>getProperty()</TT> method allows a property to be retrieved
using a <TT>String</TT> object as a key. A second overloaded <TT>getProperty()</TT>
method allows a value string to be used as the default in case
the key is not contained in the <TT>Properties</TT> object.
<P>
The <TT>load()</TT> and <TT>save()</TT> methods are used to load
a <TT>Properties</TT> object from an input stream and save it
to an output stream. The <TT>save()</TT> method allows an optional
header comment to be saved at the beginning of the saved object's
position in the output stream.
<P>
The <TT>propertyNames()</TT> method provides an enumeration of
all the property keys, and the <TT>list()</TT> method provides
a convenient way to print a <TT>Properties</TT> object on a <TT>PrintStream</TT>
object.
<H4><TT><B><FONT FACE="Courier New">PropApp</FONT></B></TT></H4>
<P>
The <TT>PropApp</TT> program illustrates the use of the <TT>Properties</TT>
class by saving a subset of the system properties to a byte array
stream and then loading the properties back in from the byte array
stream. (See Listing 14.7.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.7. The source code of the </B><TT><B><FONT FACE="Courier New">PropApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.Properties;<BR>
import java.io.ByteArrayOutputStream;<BR>
import java.io.ByteArrayInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class PropApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;Properties sysProp = System.getProperties();<BR>
&nbsp;&nbsp;sysProp.list(System.out);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;java.home&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;file.separator&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;line.separator&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;java.vendor&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;user.name&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;java.vendor.url&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;user.dir&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;java.class.path&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;java.class.version&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;path.separator&quot;);<BR>
&nbsp;&nbsp;sysProp.remove(&quot;user.home&quot;);<BR>
&nbsp;&nbsp;ByteArrayOutputStream outStream = new ByteArrayOutputStream();
<BR>
&nbsp;&nbsp;sysProp.save(outStream,&quot;sysProp&quot;);<BR>
&nbsp;&nbsp;System.out.println(&quot;\noutputStream:\n&quot;+outStream);
<BR>
&nbsp;&nbsp;ByteArrayInputStream inStream;<BR>
&nbsp;&nbsp;inStream = new ByteArrayInputStream(outStream.toByteArray());
<BR>
&nbsp;&nbsp;sysProp.load(inStream);<BR>
&nbsp;&nbsp;sysProp.list(System.out);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program begins by using the <TT>getProperties()</TT> method
of the <TT>System</TT> class to retrieve the system properties
and assign them to the <TT>sysProp</TT> variable. The system properties
are then listed on the console window using the <TT>list()</TT>
method.
<P>
Eleven of the properties contained by <TT>sysProp</TT> are removed
using the <TT>remove()</TT> method. They were removed to cut down
on the amount of program output and to illustrate the use of the
<TT>remove()</TT> method.
<P>
An object of class <TT>ByteArrayOutputStream</TT> is created and
assigned to the <TT>outStream</TT> variable. The <TT>sysProp Properties</TT>
object is then saved to the output stream using the <TT>save()</TT>
method.
<P>
The <TT>outStream</TT> is converted to a byte array using the
<TT>toByteArray()</TT> method of the <TT>ByteArrayOutputStream</TT>
class. The byte array is provided as an argument to a <TT>ByteArrayInputStream</TT>
constructor, which uses it to create an object of its class and
assign it to the <TT>inStream</TT> variable. The saved properties
are reloaded from <TT>inStream</TT> and reassigned to the <TT>sysProp</TT>
variable. The contents of the <TT>sysProp</TT> variable are then
relisted to show that they were correctly loaded.
<P>
The program output is as follows:
<BLOCKQUOTE>
<TT>-- listing properties --<BR>
<FONT FACE="Courier New">java.home=C:\JAVA\BIN\..<BR>
awt.toolkit=sun.awt.win32.MToolkit<BR>
java.version=1.0<BR>
file.separator=\<BR>
line.separator=<BR>
<BR>
java.vendor=Sun Microsystems Inc.<BR>
user.name=jaworskij<BR>
os.arch=x86<BR>
os.name=Windows 95<BR>
java.vendor.url=<A TARGET="resource window" HREF="http://www.sun.com/">http://www.sun.com/</A><BR>
user.dir=c:\java\jdg\ch14<BR>
java.class.path=.;c:\java;c:\java\lib;;C:\JAVA\BIN\.....<BR>
java.class.version=45.3<BR>
os.version=4.0<BR>
path.separator=;<BR>
user.home=\home\jamie<BR>
<BR>
outputStream:<BR>
#sysProp<BR>
#Fri Mar 01 09:59:00  1996<BR>
awt.toolkit=sun.awt.win32.MToolkit<BR>
java.version=1.0<BR>
os.arch=x86<BR>
os.name=Windows 95<BR>
os.version=4.0<BR>
<BR>
-- listing properties --<BR>
awt.toolkit=sun.awt.win32.MToolkit<BR>
java.version=1.0<BR>
os.arch=x86<BR>
os.name=Windows 95<BR>
os.version=4.0</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheStringTokenizerClass"><B><FONT SIZE=5 COLOR=#FF0000>The
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">StringTokenizer</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></B></A></H2>
<P>
The <TT>StringTokenizer</TT> class is used to create a parser
for <TT>String</TT> objects. It parses strings according to a
set of delimiter characters. It implements the <TT>Enumeration</TT>
interface in order to provide access to the tokens contained within
a string. The <TT>StringTokenizer</TT> class is similar to the
<TT>StreamTokenizer</TT> class covered in <A HREF="ch13.htm" >Chapter 13</A>,
&quot;Stream-Based Input/Output and the <TT>java.io</TT> Package.&quot;
<P>
<TT>StringTokenizer</TT> provides three constructors. All three
have the input string as a parameter. The first constructor includes
two other parameters: a set of delimiters to be using in the string
parsing and a <TT>boolean</TT> value used to specify whether the
delimiter characters should be returned as tokens. The second
constructor accepts the delimiter string but not the return token's
toggle. The last constructor uses the default delimiter set consisting
of the space, tab, newline, and carriage-return characters.
<P>
The access methods provided by <TT>StringTokenizer</TT> include
the <TT>Enumeration</TT> methods, <TT>hasMoreElements()</TT> and
<TT>nextElement()</TT>, <TT>hasMoreTokens()</TT> and <TT>nextToken()</TT>,
and <TT>countTokens()</TT>. The <TT>countTokens()</TT> method
returns the number of tokens in the string being parsed.
<H3><A NAME="TokenApp"><TT><B><FONT SIZE=4 FACE="Courier New">TokenApp</FONT></B></TT></A>
</H3>
<P>
The <TT>TokenApp</TT> program prompts the user to enter a line
of keyboard input and then parses the line, identifying the number
and value of the tokens that it found. (See Listing 14.8.)
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.8. The source code of the </B><TT><B><FONT FACE="Courier New">TokenApp</FONT></B></TT><B>
program.</B>
<P>
<TT>import java.lang.System;<BR>
<FONT FACE="Courier New">import java.util.StringTokenizer;<BR>
import java.io.DataInputStream;<BR>
import java.io.IOException;<BR>
<BR>
public class TokenApp {<BR>
&nbsp;public static void main(String args[]) throws IOException
{<BR>
&nbsp;&nbsp;DataInputStream keyboardInput = new DataInputStream(System.in);
<BR>
&nbsp;&nbsp;int numTokens;<BR>
&nbsp;&nbsp;do {<BR>
&nbsp;&nbsp;&nbsp;System.out.print(&quot;=&gt; &quot;);<BR>
&nbsp;&nbsp;&nbsp;System.out.flush();<BR>
&nbsp;&nbsp;&nbsp;StringTokenizer st = new StringTokenizer(keyboardInput.readLine());
<BR>
&nbsp;&nbsp;&nbsp;numTokens = st.countTokens();<BR>
&nbsp;&nbsp;&nbsp;System.out.println(numTokens+&quot; tokens&quot;);
<BR>
&nbsp;&nbsp;&nbsp;while (st.hasMoreTokens())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot; &quot;+st.nextToken());
<BR>
&nbsp;&nbsp;} while(numTokens!=0);<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The program begins by creating a <TT>DataInputStream</TT> object
using the <TT>System.in</TT> stream as an argument to its constructor.
A <TT>do</TT> loop is used to read a line of input from the user,
construct a <TT>StringTokenizer</TT> object on the input line,
display the number of tokens in the line, and display each token
as parsed using the standard delimiter set. The loop continues
until a line with no tokens is entered.
<P>
The program's output is as follows:
<BLOCKQUOTE>
<TT>=&gt; this is a test<BR>
<FONT FACE="Courier New">4 tokens<BR>
&nbsp;this<BR>
&nbsp;is<BR>
&nbsp;a<BR>
&nbsp;test<BR>
=&gt; 1 2 3 4.5 6<BR>
5 tokens<BR>
&nbsp;1<BR>
&nbsp;2<BR>
&nbsp;3<BR>
&nbsp;4.5<BR>
&nbsp;6<BR>
=&gt; @ # $ % ^<BR>
5 tokens<BR>
&nbsp;@<BR>
&nbsp;#<BR>
&nbsp;$<BR>
&nbsp;%<BR>
&nbsp;^<BR>
=&gt;<BR>
0 tokens</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ObserverandObservable"><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Observer</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier New">Observable</FONT></B></TT></A>
</H2>
<P>
The <TT>Observer</TT> interface and <TT>Observable</TT> class
are used to implement an abstract system by which observable objects
can be observed by objects that implement the <TT>Observer</TT>
interface. <I>Observable</I> objects are objects that subclass
the <TT>abstract</TT> <TT>Observable</TT> class. These objects
maintain a list of observers. When an observable object is updated,
it invokes the <TT>update()</TT> method of its observers to notify
the observers that it has changed state.
<P>
The <TT>update()</TT> method is the only method that is specified
in the <TT>Observer</TT> interface. The<TT>update()</TT> method
is used to notify an observer that an observable has changed.
The method takes the observable object and a second notification
message <TT>Object</TT> as its parameters.
<H3><A NAME="Observable"><TT><B><FONT SIZE=4 FACE="Courier New">Observable</FONT></B></TT></A>
</H3>
<P>
The <TT>Observable</TT> class is an <TT>abstract</TT> class that
must be subclassed by observable objects. It provides several
methods for adding, deleting, and notifying observers and for
manipulating change status. These methods are described in the
class's API page.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter you have learned how to work with all the useful
utility classes contained in the <TT>java.util</TT> package. You
have learned to use the <TT>Date</TT> class to manipulate <TT>Date</TT>
objects and the <TT>Random</TT> number class to generate random
numbers, and how to work with a range of data structures, including
dictionaries, stacks, hash tables, vectors, and bit sets. In <A HREF="ch15.htm" >Chapter 15</A>,
&quot;Window Programming with the <TT>java.awt</TT> Package,&quot;
you'll preview the Java Abstract Windows Toolkit (AWT) and learn
what window components are available to develop window-based programs
using Java.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



