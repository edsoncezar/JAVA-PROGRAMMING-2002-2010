<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 5</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Adding Graphs and Scrollbars to
the Spreadsheet</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>



<UL>
<LI><A HREF="#Tutorial" >Tutorial</A>
<UL>
<LI><A HREF="#ClassOrganization" >Class Organization</A>
</UL>
<LI><A HREF="#AddingScrollbars" >Adding Scrollbars</A>
<UL>
<LI><A HREF="#AddingtheScrollbarClass" >Adding the Scrollbar Class</A>
<LI><A HREF="#HandlingScrollbarEvents" >Handling Scrollbar Events</A>
<LI><A HREF="#InsidetheSpreadsheetContainerPaintMe" >Inside the SpreadsheetContainer Paint Methods</A>
</UL>
<LI><A HREF="#MarkingCells" >Marking Cells</A>
<LI><A HREF="#DrawingGraphs" >Drawing Graphs</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
In the previous two chapters, you have developed a spreadsheet
applet that supports general spreadsheet functionality, dialog
boxes for setting fonts and colors, and saving and opening files.
Along the way, many aspects of the AWT package have been discussed,
from basic components to layouts to methods of the Graphics class
to the AWT Toolkit.
<P>
With all these tools at hand, a few last touches can now be added
to the applet. Scrollbars are added to the spreadsheet, as is
support for marking cells. The latter will be used to generate
the final feature of the spreadsheet applet, the runtime generation
of graphs.
<P>
Since this chapter builds on the AWT tools explored in the earlier
chapters, it will go straight into the tutorial. Any new AWT features
that aren't covered in this exposition will be explained as part
of the tutorial.
<H2><A NAME="Tutorial"><FONT SIZE=5 COLOR=#FF0000>Tutorial</FONT></A>
</H2>
<P>
In this tutorial, you'll enhance the spreadsheet applet from the
previous chapter to support scrollbars, cell marking, and dynamic
graphs. Some new classes have been written to create the graphs
and the supporting dialogs, and some classes from the previous
section have been modified to support new functions.
<H3><A NAME="ClassOrganization">Class Organization</A></H3>
<P>
Table 5.1 lists the classes used in this chapter's version of
the spreadsheet applet. Since many of these classes were created
in the previous chapter, the new classes have their names in boldface
type; the classes that were modified have their names italicized.
<BR>
<P>
<CENTER><B>Table 5.1. Spreadsheet classes.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=181><I>Class</I></TD><TD WIDTH=410><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>Cell</TD><TD WIDTH=410>Contains a String and evaluated value corresponding to a single cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>CellContainer</TD><TD WIDTH=410>Contains a matrix of Cells. The String in each Cell is evaluated according to whether it is a formula, a literal numeric value, or an empty cell. Can write or read its contents from a file.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>FormulaParser</TD><TD WIDTH=410>Used to parse out the individual string fragments that make up a single formula. Converts literal strings to their numeric values.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>FormulaParserException</TD><TD WIDTH=410>An Exception that is thrown if a formula is poorly constructed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>ArgValue</TD><TD WIDTH=410>A FormulaParser helper class used to store information about an argument in a formula.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>ChooseColorDialog</TD><TD WIDTH=410>Dialog box for selecting the color of a spreadsheet element.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>colorDisplay</TD><TD WIDTH=410>A canvas class that ChooseColorDialog uses to display what a spreadsheet cell would look like if certain colors were picked.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>ColoredCheckbox</TD><TD WIDTH=410>Draws a checkbox with its colors set to a different color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>ColoredCheckboxGroup</TD><TD WIDTH=410>Creates a group of colored checkboxes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>ChooseFontDialog</TD><TD WIDTH=410>Dialog box for selecting a font for the spreadsheet.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>fontDisplay</TD><TD WIDTH=410>A canvas class that ChooseFontDialog uses to display what a font looks like.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181><B>GraphCanvas</B></TD><TD WIDTH=410>A canvas class that actually paints a graph.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181><B>GraphData</B></TD><TD WIDTH=410>An accessor class for holding data needed for drawing graphs.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181><B>GraphDialog</B></TD><TD WIDTH=410>Dialog box that brings up the GraphCanvas that displays the requested graph.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>SpreadsheetCell</TD><TD WIDTH=410>Provides for the visual presentation of a single Cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>SpreadsheetContainer</TD><TD WIDTH=410>Manages the visual presentation of a matrix of SpreadsheetCells. Provides an interface for changing the value of a cell. Supports the display of a currently highlighted cell. Sets fonts and colors of SpreadsheetCells.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>SpreadsheetFrame</TD><TD WIDTH=410>Provides the main presentation of the spreadsheet by displaying the SpreadsheetContainer, managing mouse selections on that spreadsheet, reading a text field for changing cell values, and handling a menu for actions such as invoking dialog boxes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=181>SpreadsheetApplet</TD><TD WIDTH=410>Responsible for creating, showing, and hiding the SpreadsheetFrame that provides this applet's visual display.
</TD></TR>
</TABLE></CENTER>
<H2><A NAME="AddingScrollbars"><FONT SIZE=5 COLOR=#FF0000>Adding
Scrollbars</FONT></A></H2>
<P>
As the spreadsheet applet stood at the end of <A HREF="ch4.htm" >Chapter 4</A>,
&quot;Enhancing the Spreadsheet Applet,&quot; you couldn't look
at any of the cells in the spreadsheet that didn't fit onscreen.
This severely reduced the applet's usefulness, but this problem
can be fixed by adding scrollbars. With horizontal and vertical
scrollbars, you can scroll to the cell you want to view; therefore,
the spreadsheet's full contents can be used.
<H3><A NAME="AddingtheScrollbarClass">Adding the Scrollbar Class</A>
</H3>
<P>
The AWT Scrollbar class is used to create vertical or horizontal
scrollbars. A box at the center of the scrollbar represents the
scrollbar's current position; this box has been called the <I>thumbtack</I>,
the <I>thumb</I>, or <I>elevator</I>, but in this discussion &quot;thumbtack&quot;
will be used. The thumbtack can be moved in line increments (when
the scrollbar arrows are pressed) or in page increments (when
the scrollbar area between the arrows is clicked). The thumbtack
can also be dragged to a specific position.
<P>
A Scrollbar object can be created through a variety of constructors.
The most useful constructor is one that takes five integer parameters.
A good way to illustrate this constructor is to look at how the
vertical and horizontal scrollbars are declared and created in
the SpreadsheetFrame:
<BLOCKQUOTE>
<TT>Scrollbar vScroll; // The vertical scrollbar
<BR>
Scrollbar hScroll;&nbsp;&nbsp;// The horizontal scrollbar<BR>
vScroll = new Scrollbar(Scrollbar.VERTICAL,1,1,1,numRows);<BR>
hScroll = new Scrollbar(Scrollbar.HORIZONTAL,1,1,1,numCols);</TT>
</BLOCKQUOTE>
<P>
The first parameter refers to the scrollbar's orientation, which
can be defined by using either the <TT>Scrollbar.HORIZONTAL</TT>
or <TT>Scrollbar.VERTICAL</TT> constant.
The former is a scrollbar set horizontally across the native container;
the latter is displayed up the side. Figure 5.1 shows what the
spreadsheet applet looks like after the scrollbars are added.
The orientation of the scrollbar can be retrieved through the
<TT>getOrientation()</TT> method.
<P>
<A HREF="f5-1.gif" ><B>Figure 5.1 </B>:<I> The spreadsheet applet with scrollbars.</I></A>
<P>
The next parameter specifies the initial value of the scrollbar.
This must be between the minimum and maximum scrollbar values,
specified in the last two parameters, respectively. In the case
of the spreadsheet applet, the maximum value is the number of
rows or columns supported by the spreadsheet. These are set at
<TT>26</TT> and <TT>40</TT>
in the SpreadsheetApplet class. The scrollbar's initial value
of <TT>1</TT> indicates that the display
begins at the top row and leftmost column of the spreadsheet.
<P>
The fourth parameter indicates the range of values that should
be traversed when you click on the paging portion of the scrollbar.
This corresponds to the visible portion of the scrollbar area.
For example, if 10 rows are currently displayed on the screen,
then the range is <TT>10</TT>. This
range is also known as the <I>page increment</I> and can be set
by the <TT>setPageIncrement()</TT>
method. Since it is usually possible to resize a window that has
scrollbars, you will need to modify the page increment on-the-fly.
This can involve somewhat lengthy code, so it isn't used in the
spreadsheet applet. There also seems to be a problem with the
<TT>setPageIncrement()</TT> method
in the version of AWT available at this time. Consequently, only
the line increment and thumbtack drag aspects of scrollbars are
set up for the spreadsheet applet.
<P>
Recall that the SpreadsheetFrame class uses GridBagLayout as its
layout mechanism. How the scrollbars are added to the frame display
provides another interesting example of using the complex GridBagLayout
class. See this book's CD-ROM to find out how the scrollbars are
added to the frame's GridBagLayout instance; this is defined in
the file SpreadsheetApplet.java.
<H3><A NAME="HandlingScrollbarEvents">Handling Scrollbar Events</A>
</H3>
<P>
The next step in creating and using scrollbars is to catch events
initiated by scrollbar actions. Five constants in the Event class
are allocated for handling scrollbar events. These are listed
in Table 5.2. The following code shows how the SpreadsheetFrame
class traps these events:
<BLOCKQUOTE>
<TT>public boolean handleEvent(Event evt)
{<BR>
&nbsp;switch(evt.id) {<BR>
case Event.SCROLL_LINE_UP:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.SCROLL_ABSOLUTE:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.SCROLL_LINE_DOWN:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.SCROLL_PAGE_UP:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.SCROLL_PAGE_DOWN:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(evt.target instanceof Scrollbar) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scrollbarAction((Scrollbar)evt.target);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 5.2. Scrollbar events.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=233><I>Event</I></TD><TD WIDTH=194><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=233><TT>EVENT.SCROLL_LINE_UP</TT>
</TD><TD WIDTH=194>User hit the line-up arrow.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=233><TT>EVENT.SCROLL_LINE_DOWN</TT>
</TD><TD WIDTH=194>User hit the line-down arrow.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=233><TT>EVENT.SCROLL_PAGE_UP</TT>
</TD><TD WIDTH=194>User hit the page-up arrow.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=233><TT>EVENT.SCROLL_PAGE_DOWN</TT>
</TD><TD WIDTH=194>User hit the page-down arrow.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=233><TT>EVENT.SCROLL_ABSOLUTE</TT>
</TD><TD WIDTH=194>User moved the thumbtack.</TD></TR>
</TABLE></CENTER>
<P>
<P>
The event-handling code calls the <TT>scrollbarAction()</TT>
method, which goes as follows:
<BLOCKQUOTE>
<TT>// Handle scroll bar actions...<BR>
&nbsp;&nbsp;&nbsp;void scrollbarAction(Scrollbar sb) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sb.getOrientation() ==
Scrollbar.VERTICAL)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.setNewTop(sb.getValue());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.setNewLeft(sb.getValue());
<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
It checks to see whether a horizontal or vertical scrollbar has
been selected by using the <TT>getOrientation()</TT>
method of the target and comparing it to the Scrollbar constant
value. The code then gets the current location of the thumbtack
with the <TT>getValue()</TT> method.
This returns a value between the minimum and maximum. If it is
the minimum value, then the thumbtack is at the top or leftmost
position of the scrollbar. The maximum value represents the bottom
or rightmost position. This value is set to the appropriate method
of the SpreadsheetContainer class.
<P>
This class is modified to support scrollbars by introducing two
variables that indicate the top row and leftmost column to be
displayed. When the scrollbar scrolls upward or downward, the
display's top row is adjusted in the corresponding direction.
Likewise, moving the scrollbar left or right adjusts the column
of the spreadsheet drawn on the display's leftmost portion. The
introduction of the <TT>topCell</TT>
and <TT>leftCell</TT> integer variables
are used to track where the row and column display begins.
<P>
Listing 5.1 provides the two SpreadsheetContainer methods called
by the <TT>scrollbarAction()</TT>
method shown above. These set the top row or leftmost column to
be displayed. The SpreadsheetContainer then repaints itself, displaying
the new selections. The following code shows how this display
works.
<HR>
<BLOCKQUOTE>
<B>Listing 5.1. Setting the top row and leftmost column of the
SpreadsheetContainer object.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Handle scrolling by setting new top...
<BR>
&nbsp;&nbsp;&nbsp;public void setNewTop(int newTop) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set top, taking into account
headings and constraints...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newTop &lt; numRows)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topCell
= newTop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topCell
= numRows - 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resetMarking();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set new leftmost column...<BR>
&nbsp;&nbsp;&nbsp;public void&nbsp;&nbsp;setNewLeft(int newLeft)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set new left, taking into
account headings and constraints...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newLeft &lt; numColumns)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftCell
= newLeft;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftCell
= numColumns - 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resetMarking();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="InsidetheSpreadsheetContainerPaintMe">Inside the
SpreadsheetContainer Paint Methods</A></H3>
<P>
Listing 5.2 shows the code involved in painting the SpreadsheetContainer.
These routines paint the row and column headers on the sides,
then fill up the interior with the evaluated values of the SpreadsheetCell
objects that fit in the painted region. This painting has as its
origin the <TT>topCell</TT> variable
as the top row to display and the <TT>leftCell</TT>
variable as the first column of SpreadsheetCell objects to be
displayed.
<HR>
<BLOCKQUOTE>
<B>Listing 5.2. SpreadsheetContainer paint methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Update message sent when repainting
is needed...<BR>
&nbsp;&nbsp;&nbsp;// Prevent paint from getting cleared out...
<BR>
&nbsp;&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
// Draw the displayable spreadsheet contents...<BR>
public synchronized void paint (Graphics g) {<BR>
 // Go through the calculations of the paint while painting...
<BR>
 calculatePaint(g,true,0,0);<BR>
}<BR>
<BR>
// This goes through the motions of calculating what is on the
<BR>
// screen and either calculates coordinates or paints...<BR>
// If it is not paint, returns cell that fits in hit region...
<BR>
SpreadsheetCell calculatePaint(Graphics g,boolean bPaint,int xHit,int
yHit) {<BR>
 // Get the current size of the display area...<BR>
 Dimension dm = size();<BR>
 Rectangle r = null;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;The clipping
rectangle...<BR>
 Rectangle cellRect = null; // The cell clipping rectangle...
<BR>
 // Calculate the cell width and height<BR>
 // Cell should be wide enough to show 8 digits...<BR>
 if (bPaint == true) {<BR>
&nbsp;&nbsp;cellWidth = g.getFontMetrics().stringWidth(&quot;12345.67&quot;);
<BR>
&nbsp;&nbsp;cellHeight = g.getFontMetrics().getHeight();<BR>
&nbsp;&nbsp;r = g.getClipRect();<BR>
 } // end if<BR>
 // Figure out how many rows and cols can be displayed<BR>
 int nCol = Math.min(numColumns,dm.width / cellWidth);<BR>
 int nRow = Math.min((numRows + 1),dm.height / cellHeight);<BR>
<BR>
 // Draw the cells...<BR>
 int index,i,x,j,y,currentRow,currentCol;<BR>
 -nRow;<BR>
 // Go across the rows...<BR>
 // Show the headers and adjust for top and left cell...<BR>
 for (currentRow = i = 0; i &lt; nRow; ++i) {<BR>
&nbsp;&nbsp;y = cellHeight + (i * cellHeight);<BR>
&nbsp;&nbsp;// Go across the columns...<BR>
&nbsp;&nbsp;for (currentCol = j = 0; j &lt; nCol; ++j) {<BR>
&nbsp;&nbsp;&nbsp;index = (currentRow * numColumns) + currentCol;
<BR>
&nbsp;&nbsp;&nbsp;x = (j * cellWidth);<BR>
&nbsp;&nbsp;&nbsp;// Paint if told to...<BR>
&nbsp;&nbsp;&nbsp;if (bPaint == true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// See if it is in the intersection of the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// clipping rectangle<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cellRect = new Rectangle(x,y,cellWidth,cellHeight);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (r.intersects(cellRect)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Paint if you are at a valid row...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ((currentRow &lt; numRows) &amp;&amp; (currentCol &lt; numColumns))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[index].paint(g,x,y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cellWidth,cellHeight);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} // end inner if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else {&nbsp;&nbsp;// Otherwise, fill it in with grey...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emptyCell.paint(g,x,y,cellWidth,cellHeight);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} // end else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} // end if<BR>
&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;else { // Otherwise, see if cell fits for highlight
calculations&#133;<BR>
&nbsp;&nbsp;&nbsp;if ((currentRow &lt; numRows) &amp;&amp; (currentCol
&lt; numColumns)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // See if it fits in the column...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if ((xHit &gt;= x) &amp;&amp; (xHit &lt;
(x + cellWidth))) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
See if it fits in the row...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((yHit &gt;= y) &amp;&amp; (yHit &lt; (y + cellHeight))) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paintIndex
= index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paintX
= x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paintY
= y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
matrix[index];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
&nbsp;&nbsp;&nbsp;} // end inner if<BR>
&nbsp;&nbsp;} // end else<BR>
&nbsp;&nbsp;// Adjust column display of cells<BR>
&nbsp;&nbsp;if (j == 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentCol = leftCell;
<BR>
&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++currentCol;
<BR>
 }&nbsp;&nbsp;// end column for<BR>
 // Now start data cells at appropriate top...<BR>
 if (i == 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentRow = topCell;<BR>
 else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++currentRow;<BR>
 } // end row for<BR>
 return null;&nbsp;&nbsp;// Only used if paint is false...<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The painting begins with the <TT>update()</TT>
method. Recall that the earlier versions of the spreadsheet applet
have a brief flicker of white when the spreadsheet area is repainted.
This is because the <TT>update()</TT>
method, by default, clears out the area before the <TT>paint()</TT>
area is called; this clearing results in the flicker, which can
be solved by overriding the <TT>update()</TT>
method. In this case, it calls the <TT>paint()</TT>
method directly. This method, in turn, calls the <TT>calculatePaint()</TT>
method.
<P>
The <TT>calculatePaint()</TT> method
is at the heart of the SpreadsheetContainer class. It is not only
used for painting, but also is called by other routines to calculate
where a cell is located. The second parameter of <TT>calculatePaint()</TT>
indicates whether the method should repaint the region or simply
calculate a value. The first part of the method calculates how
many rows and columns of SpreadsheetCells can be displayed in
the current canvas area. The <TT>size()</TT>
method returns the area's size, and the <TT>getFontMetrics()</TT>
methods are used to calculate the cell dimensions. Note that the
dimensions will change when the font of the spreadsheet is resized,
as discussed in the previous chapter's section on fonts.
<P>
The next step is to loop through all the rows and columns to be
displayed. The <TT>currentRow</TT>
and <TT>currentCol</TT> variables
indicate which SpreadsheetCell is to be painted. These values
are initially set to <TT>0</TT> so
that the row and column headers are displayed. At the bottom of
the <TT>for</TT> loops, these are
adjusted to the top cell or leftmost column. In the ensuing iterations,
the variables are simply incremented to get the new row or column.
<P>
If the mode of the <TT>calculatePaint()</TT>
method is true, then the cells are to be painted. In this case,
the code checks to see whether the item falls in the clipping
rectangle, retrieved by the <TT>getClipRect()</TT>
method. This actually represents the area to be painted. The clipping
rectangle could be the whole screen or a single cell. The code
that sets a highlighted cell or marks an area (to be discussed)
only forces the area affected to be repainted. If it does fall
in the region, the individual SpreadsheetCell is painted at the
current coordinates. Recall that the cell has colors and a font
associated with it. Highlighting or marking a cell is really nothing
more than changing a SpreadsheetCell object's internal color variables
and forcing it to be repainted. See the <A HREF="ch3.htm" >Chapter 3</A>,
&quot;Building a Spreadsheet Applet,&quot; tutorial for how the
SpreadsheetCell class works.
<P>
Painting affects only those objects that fall in the clipping
rectangle. The <TT>intersects()</TT>
method is used to see whether two Rectangle objects overlap. By
painting only the cells that intersect the clipping region, the
code saves some unnecessary processing.
<P>
If the method is not in painting mode, then the processing is
used to check which cell an x-y coordinate belongs to. This is
useful when the user clicks on a cell to be highlighted and when
marking occurs.
<P>
By using a central routine for determining the locations of SpreadsheetCells,
such activities as painting, scrolling, marking, and highlighting
become relatively easy. If something goes wrong, it probably could
be traced back to the <TT>calculatePaint()</TT>
method.
<H2><A NAME="MarkingCells"><FONT SIZE=5 COLOR=#FF0000>Marking
Cells</FONT></A></H2>
<P>
It is useful to mark cells to indicate that they are subject to
some upcoming operation, such as cutting or copying, or, in this
case, producing a graph. Marking is performed in this applet by
clicking on a valid cell, holding the mouse key down, and dragging
in a southeasterly direction. When the mouse is released, marking
is complete. Figure 5.2 shows what a spreadsheet with some cells
marked looks like.
<P>
<A HREF="f5-2.gif" ><B>Figure 5.2 :</B><I> A spreadsheet with cells marked.</I></A>
<P>
Marking cells is actually a simple extension of the techniques
that have been developed through the last three chapters. There
are three key aspects to marking: tracking mouse movements, keeping
track of the cells selected, and changing the color of the marked
cells.
<P>
To track mouse movements, the SpreadsheetContainer <TT>handleEvent()</TT>
method is modified to manage the mouse actions. The modified code
is detailed in Listing 5.3.
<HR>
<BLOCKQUOTE>
<B>Listing 5.3. SpreadsheetContainer event handler.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public boolean handleEvent(Event evt)
{<BR>
&nbsp;switch(evt.id) {<BR>
&nbsp;&nbsp;// Mouse clicks. See whether you should highlight
<BR>
&nbsp;&nbsp;// cell on spreadsheet...<BR>
&nbsp;&nbsp;case Event.MOUSE_DOWN:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setMouseHighlight(evt.x,evt.y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle cell marking...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;toggleMarking(evt.x,evt.y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;case Event.MOUSE_DRAG:<BR>
&nbsp;&nbsp;// Select cells if marking...<BR>
&nbsp;&nbsp;dragMarking(evt.x,evt.y);<BR>
&nbsp;&nbsp;return false;<BR>
&nbsp;case Event.MOUSE_UP:<BR>
&nbsp;&nbsp;// If marking, then you are done!<BR>
&nbsp;&nbsp;stopMarking(evt.x,evt.y);<BR>
&nbsp;&nbsp;return false;<BR>
&nbsp;}<BR>
&nbsp;default:<BR>
&nbsp;&nbsp;return false;<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The marking code is too long and involved to list here; refer
to the CD-ROM for the complete code. However, the general approach
and highlights can be presented.
<P>
When you click the mouse over a valid cell (not a row or column
header), the cell becomes the current focus and is highlighted.
This is done through the <TT>setMouseHighlight()</TT>
method, which calls <TT>calculatePaint()</TT>
to find the reference of the selected SpreadsheetCell. After the
cell is highlighted, the <TT>toggleMarking()</TT>
method is called to either begin marking or to reset the marking
if there were cells selected at the time of the mouse click. The
<TT>startMarking()</TT> method begins
tracking the mouse, and <TT>resetMarking()</TT>
resets the marking state. SpreadsheetCell objects are set to their
default colors through the <TT>setNewColors()</TT>
method, which is used to set the normal and highlighted values
of the spreadsheet. This method is called by the color dialog
discussed in the previous chapter, and is called here with the
current normal and highlighted colors as a simple way of resetting
colors.
<P>
As the mouse is being dragged (which means the mouse key is still
down), <TT>MOUSE_DRAG</TT> events
are issued. If marking is on, the <TT>dragMarking()</TT>
method checks to see whether the mouse has left the current cell;
if it has, then new cells are marked. The <TT>paintMarked()</TT>
method looks at the first cell marked and the last cell marked
and figures out the rectangular area to be painted. It then sets
the colors of each of the cells that are marked. The method then
forces a limited repaint of the SpreadsheetContainer so that painting
occurs quickly. The following code from <TT>paintMarked()</TT>
takes the top-left and bottom-right areas that are marked and
forces them to be repainted:
<BLOCKQUOTE>
<TT>repaint(startX,startY,endX-startX,endY-startY);</TT>
</BLOCKQUOTE>
<P>
When the paint message is processed, the marked cells are drawn
in their new color. Cells outside the clipping rectangle issued
by the <TT>repaint()</TT> method are
not drawn.
<P>
When the mouse is released, the <TT>stopMarking()</TT>
method is called, and the marking is finished. The marked areas
can then be used for further operations.
<H2><A NAME="DrawingGraphs"><FONT SIZE=5 COLOR=#FF0000>Drawing
Graphs</FONT></A></H2>
<P>
The last feature of the spreadsheet applet to be developed is
drawing graphs from the marked cells. Most of the work is done
in the <TT>graphCanvas()</TT> class.
However, the graph is displayed inside a dialog object based on
the GraphDialog class.
<P>
Two spreadsheet applets can produce two types of graphs: a line
graph and a bar chart. The latter is shown in Figure 5.3. They
are invoked by new menu items off the SpreadsheetFrame object.
The menu items result in a call to the SpreadsheetFrame method
<TT>launchGraphicsDialog()</TT>, which
gets the currently marked data and then displays the graphics
dialog box (which was instantiated in the frame's constructor).
If nothing is marked, an error message in the status bar indicates
that nothing was drawn.
<P>
<A HREF="f5-3.gif" ><B>Figure 5.3 :</B> <I>Spreadsheet applet bar chart.</I></A>
<P>
The GraphData class is an accessor class used to store the data
to be displayed. It contains an array of double values representing
the data to be plotted and an array of Strings used as the column
labels. These arrays are prepared in the SpreadsheetContainer
method <TT>getGraphData()</TT>, which
is called by the frame's <TT>launchGraphicsDialog()</TT>
method just discussed. The <TT>getGraphData()</TT>
checks to see whether something is marked; if not, an IllegalArgumentException
object is thrown. Otherwise, it stores the marked data in the
GraphData object by moving across the columns. The bottom row
marked is used to generate the data to be plotted and is placed
in the double array. The top row is used to represent the column
String headers. If only one row is marked, the cell headers (A1,
A2, and so forth) are used as the column headers. The middle rows
that are marked are ignored. As a further exercise, you can modify
the graph-<BR>
plotting algorithms to support multiple rows of data.
<P>
Once the graph data is collected, the GraphDialog is displayed.
The dialog box is very simple, consisting of only two components:
the GraphCanvas object for drawing the graph and a button for
shutting down the dialog box. The only interesting code in the
dialog box involves resizing the dialog box to take up most of
the screen.
<BLOCKQUOTE>
<TT>// Get the screen dimensions...<BR>
Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
<BR>
// Get the font and use to calculate some margins...<BR>
FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(getFont());
<BR>
resize(screen.width,screen.height - (4 * fm.getHeight()) );</TT>
</BLOCKQUOTE>
<P>
This code uses the AWT Toolkit to get the screen size and the
current font. The dialog box then resizes itself to take up the
screen's full width and most of its height.
<P>
When the dialog box is shown, it first calls the GraphCanvas <TT>prepareNewGraph()</TT>
method, which takes the GraphData and prepares it for presentation.
When the dialog box appears and a paint event is issued, the GraphCanvas
object draws the graph.
<P>
Listing 5.4 gives the full code for the GraphCanvas class. It
uses two constants to indicate the two graph modes it supports:
line or bar graph. When the canvas is constructed, it creates
an array of six Color objects. This array is used to randomly
generate colors for each bar chart or line so that they are more
easily distinguished. When the <TT>prepareNewGraph()</TT>
method is called, which must happen before painting occurs, the
maximum value is calculated and stored in the <TT>maxValue</TT>
variable. This is an important figure since it represents the
range of values the data is plotted against. The maximum value
is not the highest value in the data area, but actually is the
highest value rounded up to the nearest power of 10. Therefore,
if the top value is <TT>66</TT>, the
maximum value will be set to <TT>100</TT>.
Doing this makes it easy to divide the range of data values into
intervals of one-tenth the maximum. The data in Figure 5.3 shows
the plotting of values when the highest data value is <TT>66</TT>
and the range is set from <TT>0</TT>
to <TT>100</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 5.4. The GraphCanvas class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Not a public class.&nbsp;&nbsp;Imports
are in GraphDialog class<BR>
// This paints a graph on a canvas...<BR>
class GraphCanvas extends Canvas {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Types of graphs...<BR>
&nbsp;&nbsp;&nbsp;static final int LINE_GRAPH = 0;<BR>
&nbsp;&nbsp;&nbsp;static final int BAR_GRAPH = 1;<BR>
&nbsp;&nbsp;&nbsp;int graphMode;<BR>
&nbsp;&nbsp;&nbsp;Color randomColors[];<BR>
&nbsp;&nbsp;&nbsp;// This is the data for the display..<BR>
&nbsp;&nbsp;&nbsp;GraphData gd;<BR>
&nbsp;&nbsp;&nbsp;// Maximum scale of graph...<BR>
&nbsp;&nbsp;&nbsp;int maxValue;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Constructor just inits data...<BR>
&nbsp;&nbsp;&nbsp;public GraphCanvas() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gd = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store the random colors...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors = new Color[6];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[0] = Color.yellow;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[1] = Color.red;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[2] = Color.green;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[3] = Color.magenta;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[4] = Color.cyan;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomColors[5] = Color.blue;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Set up graphics display...<BR>
&nbsp;&nbsp;&nbsp;void prepareNewGraph(GraphData gphData,int graphMode)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store the data and string
values...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gd = gphData;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.graphMode = graphMode;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First calculate maximum
value of graph...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxValue = calculateMaxValue();
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Calculate the maximum value of the graph...
<BR>
&nbsp;&nbsp;&nbsp;int calculateMaxValue() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double maximum = 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double data;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int temp,roundMax;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First get maximum figure...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length = gd.size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; length;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = gd.getData(i);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data
&gt; maximum)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maximum
= data;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now round it up to nearest
power of 10<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roundMax = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (temp = (int)maximum;temp
&gt; 0; temp /= 10)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roundMax
*= 10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return roundMax;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;Draw the graph...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void paint (Graphics g)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (gd == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension dm = size();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate margins...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int height = g.getFontMetrics().getHeight();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ymargin = 3 * height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int xmargin = g.getFontMetrics().stringWidth(&quot;1112345.67&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length = gd.size();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Select bottom-left origin
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point origin = new Point(xmargin,dm.height
- ymargin);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw X-Axis line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int endx = dm.width - xmargin;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(origin.x,origin.y,endx,origin.y);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw Y-Axis line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(origin.x,ymargin,origin.x,origin.y);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate how headers are
spread out...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int yIncrement = (origin.y
- ymargin)/10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int xIncrement = (endx - origin.x)
/ (length + 1);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw horizontal axis headers
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int yMarkStart = origin.y
+ height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int yTextStart = yMarkStart
+ height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 1; i &lt; (length
+ 1); ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw
marker...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = origin.x
+ (xIncrement * i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(x,yMarkStart,x,origin.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
value header...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(gd.getHeading(i
- 1),x,yTextStart);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw vertical axis headers...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inset = g.getFontMetrics().charWidth('W');
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int xMarkStart = origin.x
- inset;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int xTextStart = inset;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dataIncrement = maxValue
/ 10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String yHeader;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt;= 10; ++i)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw
marker...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = origin.y
- (i * yIncrement);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(xMarkStart,y,origin.x,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
increment header...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yHeader
= String.valueOf(dataIncrement * i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(yHeader,xTextStart,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Call Graphic specific drawing..
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int vertLength = origin.y
- ymargin;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double dbLen = (double)randomColors.length;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rectOffset = xIncrement
/ 2; // For bar graphs...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point lastPt = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 1; i &lt; (length
+ 1); ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Plot
points, connecting points with lines...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = origin.x
+ (xIncrement * i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = origin.y
- (int)((gd.getData(i - 1)/maxValue) * vertLength);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Randomize
colors...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index =
(int)(dbLen * Math.random());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(randomColors[index]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If line
graph, draw connecting lines...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (graphMode
== LINE_GRAPH) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(lastPt != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(lastPt.x,lastPt.y,x,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPt
= new Point(x,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise,
bar graph draw rectangle...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(x
- rectOffset,y,xIncrement,origin.y - y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
After the maximum value is determined, the graph is ready to be
painted. This is surprisingly easy. The first step is to get the
dimensions of the canvas area and to figure where the bottom-left
origin of the graph should be; this is where the vertical line
that marks the range of values and the horizontal line that provides
the column headers will meet. The margins allow room at the sides
and the bottom for displaying the range and column headers. These
are calculated through the use of the FontMetrics class's <TT>getHeight()</TT>
and <TT>stringWidth()</TT> methods.
These margins make it easy to calculate the operations that follow.
The next step is drawing the vertical and horizontal lines from
the origin to the appropriate margin.
<P>
The column headers are next drawn underneath the horizontal line.
The location of the headers is based on the length of the line
divided by the number of columns. The horizontal range of values
is calculated similarly, except that the locations are based on
dividing the maximum value by ten and incrementing accordingly.
The range values and headers are drawn through the <TT>drawString()</TT>
method. The nearby <TT>drawLine()</TT>
methods are used to make a small line marker indicating the range
or header position.
<P>
The last step is to plot the graph. This is done in a <TT>for</TT>
loop that moves across each column of data. For each column, a
random color is chosen for the ensuing graph figure. This is done
by using the <TT>Math.random()</TT>
method, which returns a number between 0.0 and 1.0. The color
is then set by calling the Graphics object's <TT>setColor()</TT>
method. The data is then plotted based on its position in relation
to the origin and the maximum value. If it is a line graph, a
line is drawn from the endpoint of the last line drawn to the
new value; the <TT>drawLine()</TT>
method is used to do this. If it is a bar graph, a rectangle is
drawn from the horizontal baseline to the plotted value with the
<TT>fillRect()</TT> method of the
Graphics class. Both the line and the interior of the bar rectangle
will be the color just set by the random procedure.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This concludes the development of the spreadsheet applet. By going
through this part of the book, you have learned most of the fundamental
techniques needed to use the AWT package. You have also been exposed
to exception handling, as well as the underlying principles of
using input/output streams.
<P>
The next step is to tie these techniques in with some of Java's
more advanced features, such as multithreading and sockets programming.
With a good understanding of these new techniques, you can produce
a network-enabled applet ready for prime-time use on the Internet!
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



