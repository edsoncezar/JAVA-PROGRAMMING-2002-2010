<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Appendix A </FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Inside the Java Virtual Machine</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheClassFile" >The Class File</A>
<UL>
<LI><A HREF="#Layout" >Layout</A>
</UL>
<LI><A HREF="#TheVirtualMachine" >The Virtual Machine</A>
<UL>
<LI><A HREF="#Registers" >Registers</A>
<LI><A HREF="#OperandStack" >Operand Stack</A>
</UL>
<LI><A HREF="#PrimitiveTypes" >Primitive Types</A>
<LI><A HREF="#LocalVariables" >Local Variables</A>
<UL>
<LI><A HREF="#TheVerifier" >The Verifier</A>
<LI><A HREF="#ExceptionHandling" >Exception Handling</A>
<LI><A HREF="#Bytecodes" >Bytecodes</A>
<LI><A HREF="#TestClassBytecodes" >Test Class Bytecodes</A>
</UL>
<LI><A HREF="#GarbageCollection" >Garbage Collection</A>
</UL>
<HR>
<P>
Looking at a virtual machine from the outside in is probably the
best way to understand its workings. Incremental learning results
when you move from the known to the unknown, so this section starts
with the item you are most familiar with: the class file.
<H2><A NAME="TheClassFile"><FONT SIZE=5 COLOR=#FF0000>The Class
File</FONT></A></H2>
<P>
The class file is similar to standard language object modules.
When a C language file is compiled, the output is an object module.
Multiple object modules are linked together to form an executable
program. In Java, the class file replaces the object module and
the Java virtual machine replaces the executable program.
<P>
You'll find all the information needed to execute a class contained
within the class file, as well as extra information that aids
debugging and source file tracking. Remember that Java has no
&quot;header&quot; include files, so the class file format also
has to fully convey class layout and members. Parsing a class
file yields a wealth of class information, not just its runtime
architecture.
<H3><A NAME="Layout">Layout</A></H3>
<P>
The overall layout uses an outer structure and a series of substructures
that contain an ever-increasing amount of detail. The outer layer
is described by the following structure:
<BLOCKQUOTE>
<TT>ClassFile<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 magic;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 minor_version;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 major_version;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 constant_pool_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;cp_info constant_pool[constant_pool_count
- 1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 access_flags;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 this_class;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 super_class;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 interfaces_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 interfaces[interfaces_count];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 fields_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;field_info fields[fields_count];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 methods_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;method_info methods[methods_count];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attributes_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;attribute_info attributes[attribute_count];
<BR>
}</TT>
</BLOCKQUOTE>
<P>
In addition to the generic class information (this_class, super_class,
version, and so forth), there are three major substructures: constant_pool,
fields, and methods. Attributes are considered minor substructures
because they recur throughout the class file at various levels.
Fields and methods contain their own attributes. Some individual
attributes also contain their own private attribute arrays.
<P>
The u2 and u4 types represent unsigned 2-byte and 4-byte quantities.
<P>
This simple class will be used throughout this appendix as the
basis for class file exploration.
<BLOCKQUOTE>
<TT>public class test<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static int st_one;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public test()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st_one = 100;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public test(int v)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st_one = v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native boolean getData(int data[]
);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int do_countdown()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = st_one;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Performing
countdown:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( x- !=
0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return st_one;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int do_countdown(int x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int save = x;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Performing
countdown:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( x- !=
0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return save;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This class doesn't actually do very much, but it does provide
a basis for class file exploration. Once compiled, the outer layer
of the resulting class file is as follows:
<BLOCKQUOTE>
<TT>file name: test.class<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;magic: cafebabe<BR>
&nbsp;&nbsp;&nbsp;&nbsp;version: 45.3<BR>
&nbsp;&nbsp;constants: Valid indexes: 1 - 39<BR>
&nbsp;&nbsp;&nbsp;&nbsp; access: PUBLIC<BR>
 this class: Class: test<BR>
super class: Class: java/lang/Object<BR>
 interfaces: none<BR>
&nbsp;&nbsp;&nbsp;&nbsp; fields: [1] st_one<BR>
&nbsp;&nbsp;&nbsp;&nbsp;methods: [4] &lt;init&gt; &lt;init&gt;
do_countdown do_countdown<BR>
&nbsp;attributes: SourceFile(test.java)<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The above output was generated with a Java tool I wrote called ClassView. The full source code is available on this book's CD-ROM. ClassView parses and outputs the various features and levels of a given class file. It also provides a good basis for other class file parsers, such as disassemblers.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The magic number of a class is 0xcafebabe. This number must appear
in a class file, or the file is assumed to be invalid. The current
major version is 45; the current minor version is 3.
<H4>Access Flags</H4>
<P>
Access flags are used throughout the class file to convey the
access characteristics of various items. The flag itself is a
collection of 11 individual bits. Table A.1 lays out the masks.
<BR>
<P>
<CENTER><B>Table A.1. Access flag bit values.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=193><I>Flag Value</I></TD><TD WIDTH=265><I>Indication</I>
</TD></TR>
<TR><TD WIDTH=193><TT>ACC_PUBLIC = 0x0001</TT>
</TD><TD WIDTH=265>Global visibility</TD></TR>
<TR><TD WIDTH=193><TT>ACC_PRIVATE = 0x0002</TT>
</TD><TD WIDTH=265>Local class visibility</TD></TR>
<TR><TD WIDTH=193><TT>ACC_PROTECTED = 0x0004</TT>
</TD><TD WIDTH=265>Subclass visibility</TD></TR>
<TR><TD WIDTH=193><TT>ACC_STATIC = 0x0008</TT>
</TD><TD WIDTH=265>One occurrence in system (not per class)</TD>
</TR>
<TR><TD WIDTH=193><TT>ACC_FINAL = 0x0010</TT>
</TD><TD WIDTH=265>No changes allowed</TD></TR>
<TR><TD WIDTH=193><TT>ACC_SYNCHRONIZED = 0x0020</TT>
</TD><TD WIDTH=265>Access with a monitor</TD></TR>
<TR><TD WIDTH=193><TT>ACC_VOLATILE = 0x0040</TT>
</TD><TD WIDTH=265>No local caching</TD></TR>
<TR><TD WIDTH=193><TT>ACC_TRANSIENT = 0x0080</TT>
</TD><TD WIDTH=265>Not a persistent value</TD></TR>
<TR><TD WIDTH=193><TT>ACC_NATIVE = 0x0100</TT>
</TD><TD WIDTH=265>Native method implementation</TD></TR>
<TR><TD WIDTH=193><TT>ACC_INTERFACE = 0x0200</TT>
</TD><TD WIDTH=265>Class is an interface</TD></TR>
<TR><TD WIDTH=193><TT>ACC_ABSTRACT = 0x0400</TT>
</TD><TD WIDTH=265>Class or method is abstract</TD></TR>
</TABLE></CENTER>
<P>
<P>
Access flags are present for a class and its fields and methods.
Only a subset of values appears in any given item. Some bits apply
only to fields (VOLATILE and TRANSIENT); others apply only to
methods (SYNCHRONIZED and NATIVE).
<H4>Attributes</H4>
<P>
Attributes, like access flags, appear throughout a class file.
They have the following form:
<BLOCKQUOTE>
<TT>GenericAttribute_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attribute_name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 attribute_length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 info[attribute_length];<BR>
}</TT>
</BLOCKQUOTE>
<P>
A generic structure exists to enable loaders to skip over attributes
they don't understand. The actual attribute has a unique structure
that can be read if the loader understands the format. As an example,
the following structure specifies the format of a source file
attribute:
<BLOCKQUOTE>
<TT>SourceFile_attribute<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attribute_name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 attribute_length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 sourcefile_index;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The name of an attribute is an index into the constant pool. You'll
learn about constant pools momentarily. If a loader did not understand
the source file attribute structure, it could skip the data by
reading the number of bytes specified in the length parameter.
For the source file attribute, the length is 2.
<H4>Constant Pool</H4>
<P>
The constant pool forms the basis for all numbers and strings
within a class file. Nowhere else do you ever find strings or
numbers in a class file. Any time there is a need to reference
a string or number, an index into the constant pool is substituted.
Consequently, the constant pool is the dominant feature of a class.
The pool is even used directly within the virtual machine itself.
<P>
There are twelve different types of constants:
<UL>
<LI><TT>CONSTANT_Utf8</TT> = 1
<LI><TT>CONSTANT_Unicode</TT> = 2
<LI><TT>CONSTANT_Integer</TT> = 3
<LI><TT>CONSTANT_Float</TT> = 4
<LI><TT>CONSTANT_Long</TT> = 5
<LI><TT>CONSTANT_Double</TT> = 6
<LI><TT>CONSTANT_Class</TT> = 7
<LI><TT>CONSTANT_String</TT> = 8
<LI><TT>CONSTANT_Fieldref</TT> = 9
<LI><TT>CONSTANT_Methodref</TT> =
10
<LI><TT>CONSTANT_InterfaceMethodref</TT>
= 11
<LI><TT>CONSTANT_NameAndType</TT>
= 12
</UL>
<P>
Each constant structure leads off with a tag identifying the structure
type. Following the type is data specific to each individual structure.
The layout of each constant structure follows:
<BLOCKQUOTE>
<TT>CONSTANT_Utf8_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 bytes[length];<BR>
}<BR>
<BR>
CONSTANT_Unicode_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 words[length];<BR>
}<BR>
<BR>
CONSTANT_Integer_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 bytes;<BR>
}<BR>
<BR>
CONSTANT_Float_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 bytes;<BR>
}<BR>
<BR>
CONSTANT_Long_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 high_bytes;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 low_bytes;<BR>
}<BR>
<BR>
CONSTANT_Double_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 high_bytes;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 low_bytes;<BR>
}<BR>
<BR>
CONSTANT_Class_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_index;<BR>
}<BR>
<BR>
CONSTANT_String_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 string_index;<BR>
}<BR>
<BR>
CONSTANT_Fieldref_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 class_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_and_type_index;<BR>
}<BR>
<BR>
CONSTANT_Methodref_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 class_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_and_type_index;<BR>
}<BR>
<BR>
CONSTANT_InterfaceMethodref_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 class_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_and_type_index;<BR>
}<BR>
<BR>
CONSTANT_NameAndType_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 signature_index;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The <TT>CONSTANT_Utf8</TT> contains
standard ASCII text strings. These are not null-terminated because
they use an explicit length parameter. Notice that most of the
constants reference other constants for information. Methods,
for instance, specify a class and type by providing indexes to
other constant pool members. Constant pool cross-references eliminate
repetition of data.
<P>
The constant pool for the test class appears as follows:
<BLOCKQUOTE>
<TT>String #28 -&gt; Performing countdown:
<BR>
Class: java/lang/System<BR>
Class: java/lang/Object<BR>
Class: test<BR>
Class: java/io/PrintStream<BR>
Field: java/lang/System.out Ljava/io/PrintStream;<BR>
Field: test.st_one I<BR>
Method: java/io/PrintStream.println(I)V<BR>
Method: java/lang/Object.&lt;init&gt;()V<BR>
Method: java/io/PrintStream.println(Ljava/lang/String;)V<BR>
NameAndType: println (I)V<BR>
NameAndType: println (Ljava/lang/String;)V<BR>
NameAndType: out Ljava/io/PrintStream;<BR>
NameAndType: &lt;init&gt; ()V<BR>
NameAndType: st_one I<BR>
Utf8: [7] println<BR>
Utf8: [4] (I)V<BR>
Utf8: [3] ()I<BR>
Utf8: [13] ConstantValue<BR>
Utf8: [4] (I)I<BR>
Utf8: [19] java/io/PrintStream<BR>
Utf8: [10] Exceptions<BR>
Utf8: [15] LineNumberTable<BR>
Utf8: [1] I<BR>
Utf8: [10] SourceFile<BR>
Utf8: [14] LocalVariables<BR>
Utf8: [4] Code<BR>
Utf8: [21] Performing countdown:<BR>
Utf8: [3] out<BR>
Utf8: [21] (Ljava/lang/String;)V<BR>
Utf8: [16] java/lang/Object<BR>
Utf8: [6] &lt;init&gt;<BR>
Utf8: [21] Ljava/io/PrintStream;<BR>
Utf8: [16] java/lang/System<BR>
Utf8: [12] do_countdown<BR>
Utf8: [5] ([I)Z<BR>
Utf8: [6] st_one<BR>
Utf8: [7] getData<BR>
Utf8: [9] test.java<BR>
Utf8: [3] ()V<BR>
Utf8: [4] test<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The ClassView tool substitutes pool indexes with actual pool data whenever possible.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Fields</H4>
<P>
Field structures contain the individual data members of a class.
Any class item that is not a method is placed into the fields
section. The field structure looks like the following:
<BLOCKQUOTE>
<TT>field_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 access_flags;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 signature_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attribute_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;attribute_info attributes[attribute_count];
<BR>
}</TT>
</BLOCKQUOTE>
<P>
The test class contains the following field:
<BLOCKQUOTE>
<TT>st_one I<BR>
&nbsp;&nbsp;PUBLIC STATIC<BR>
&nbsp;&nbsp;No attributes</TT>
</BLOCKQUOTE>
<H4>Methods</H4>
<P>
The method section contains all of the executable content of a
class. In addition to the method name and signature, the structure
contains a set of attributes. One of these attributes has the
actual byte codes that the virtual machine will execute. The method
structure follows:
<BLOCKQUOTE>
<TT>method_info<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 access_flags;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 name_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 signature_index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attributes_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;attribute_info attributes[attribute_count];
<BR>
}</TT>
</BLOCKQUOTE>
<P>
The test class produces the following method section:
<BLOCKQUOTE>
<TT>&lt;init&gt;()V<BR>
&nbsp;&nbsp;PUBLIC<BR>
&nbsp;&nbsp;Code(stack=1 locals=1 code=10 exceptions=none)<BR>
&lt;init&gt;(I)V<BR>
&nbsp;&nbsp;PUBLIC<BR>
&nbsp;&nbsp;Code(stack=1 locals=2 code=9 exceptions=none)<BR>
getData([I)Z<BR>
&nbsp;&nbsp;PUBLIC NATIVE<BR>
&nbsp;&nbsp;No attributes<BR>
do_countdown()I<BR>
&nbsp;&nbsp;PUBLIC<BR>
&nbsp;&nbsp;Code(stack=2 locals=2 code=33 exceptions=none)<BR>
do_countdown(I)I<BR>
&nbsp;&nbsp;PUBLIC<BR>
&nbsp;&nbsp;Code(stack=2 locals=3 code=29 exceptions=none)</TT>
</BLOCKQUOTE>
<P>
Each method has a name and signature. You learned about signatures
in <A HREF="ch10.htm" >Chapter 10</A>, &quot;Native Methods and
Java.&quot; Each non-native method contains a code attribute that
has the following format:
<BLOCKQUOTE>
<TT>Code_attribute<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attribute_name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 attribute_length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 max_stack;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 max_locals;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u4 code_length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u1 code[code_length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 exception_table_length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ExceptionItem exceptions[exception_table_length];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 attributes_count;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;attribute_info attributes[attribute_count];
<BR>
}</TT>
</BLOCKQUOTE>
<P>
Code attributes contain a private list of other attributes. Typically,
these are debugging lists, such as line number information. Now
that you've hit the code attribute, it's time to jump into the
virtual machine.
<H2><A NAME="TheVirtualMachine"><FONT SIZE=5 COLOR=#FF0000>The
Virtual Machine</FONT></A></H2>
<P>
The Java virtual machine interprets Java byte codes that are contained
in code attributes. The virtual machine is stack based. Most computer
architectures perform their operations on a mixture of memory
locations and registers. The Java virtual machine performs its
operations exclusively on a stack. This is done primarily to support
portability. No assumptions could be made about the size or number
of registers in a given CPU. Intel microprocessors are especially
limited in their register composition.
<H3><A NAME="Registers">Registers</A></H3>
<P>
The virtual machine does contain some registers, but these are
used for tracking the current state of the machine:
<UL>
<LI><TT>pc</TT> register points to
the next bytecode to execute
<LI><TT>vars</TT> register points
to the local variables for a method
<LI><TT>optop</TT> register points
to the operand stack
<LI><TT>frame</TT> register points
to the execution environment
</UL>
<P>
All these registers are 32 bits wide and point into separate storage
blocks. The blocks, however, can be allocated all at once because
the code attribute specifies the size of the operand stack, the
number of local variables, and the length of the bytecodes.
<H3><A NAME="OperandStack">Operand Stack</A></H3>
<P>
Most Java byte codes work on the operand stack. For instance,
to add two integers together, each integer is pushed onto the
operand stack. The addition operator removes the top two integers,
adds them, and places the result in its place back on the stack:
<BLOCKQUOTE>
<TT>..., 4, 5 -&gt; ..., 9<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The operand stack notation is used throughout the remainder of this appendix. The stack reads from left to right, with the stack top on the extreme right. Ellipses indicate indeterminate data buried on the stack. The arrow indicates an operation; the data to the right of the arrow represents the stack after the operation is performed.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Each stack location is 32 bits wide. Long and doubles are 64 bits
wide, so they take up two stack locations.
<H2><A NAME="PrimitiveTypes"><FONT SIZE=5 COLOR=#FF0000>Primitive
Types</FONT></A></H2>
<P>
The virtual machine provides support for nine primitive types:
<UL>
<LI><TT>byte</TT>-single byte signed
2's complement
<LI><TT>short</TT>-2-byte signed 2's
complement
<LI><TT>int</TT>-4-byte signed 2's
complement
<LI><TT>long</TT>-8-byte signed 2's
complement
<LI><TT>float</TT>-4-byte IEEE 754
single precision
<LI><TT>double</TT>-8-byte IEEE 754
double precision
<LI><TT>char</TT>-2-byte unsigned
Unicode character
<LI><TT>object</TT>-4-byte reference
to a Java object
<LI><TT>returnAddress</TT>-4-byte
reference
</UL>
<P>
The virtual machine specification does not mandate the internal
format of object references. In Sun's implementation, object references
point to a Java handle consisting of two pointers. One points
to the method table for the class and the other points to the
object's instance data.
<H2><A NAME="LocalVariables"><FONT SIZE=5 COLOR=#FF0000>Local
Variables</FONT></A></H2>
<P>
Each code attribute specifies the size of the local variables.
A local variable is 32 bits wide, so long and double primitives
take up two variable slots. Unlike C, all method arguments appear
as local variables. The operand stack is reserved exclusively
for operations.
<H3><A NAME="TheVerifier">The Verifier</A></H3>
<P>
When a class is loaded, it is passed through a bytecode verifier
before it is executed. The verifier checks the internal consistency
of the class and the validity of the code. Java uses a late binding
scheme that puts the code at risk. In traditional languages, the
object linker binds all of the method calls and variable accesses
to specific addresses. In Java, the virtual machine doesn't perform
this service until the last possible moment. As a result, it is
possible for a called class to have changed since the original
class was compiled. Method names or their arguments may have been
altered, or the access levels may have been changed. One of the
verifier's jobs is to make sure that all external object references
are correct and allowed.
<P>
No assumptions can be made about the origin of bytecodes. A hostile
compiler could be used to create executable bytecodes that conform
to the class file format, but specify illegal codes.
<P>
The verifier uses a conservative four-pass verification algorithm
to check bytecodes.
<H4>Pass 1</H4>
<BLOCKQUOTE>
This pass reads in the class file and ensures that it is valid.
The magic number must be present and all the class data must be
present with no truncation or extra data after the end of the
class. Any recognized attributes must have the correct length
and the constant pool must not have any unrecognized entries.
</BLOCKQUOTE>
<H4>Pass 2</H4>
<BLOCKQUOTE>
The second pass involves validating class features other than
the bytecodes. All methods and fields must have a valid name and
signature and every class must have a super class. Signatures
are not actually checked, but they must appear valid. The next
pass is more specific.
</BLOCKQUOTE>
<H4>Pass 3</H4>
<BLOCKQUOTE>
This is the most complex pass because the bytecodes are validated.
The bytecodes are analyzed to make sure that they have the correct
type and number of arguments. In addition, a data-flow analysis
is performed to determine each path through the method. Each path
must arrive at a given point with the same stack size and types.
Each path must call methods with the proper arguments, and fields
must be modified with values of the appropriate type. Class accesses
are not checked in this pass. Only the return type of external
functions is verified.
</BLOCKQUOTE>
<BLOCKQUOTE>
Forcing all paths to arrive with the same stack and registers
can lead the verifier to fail some otherwise legitimate bytecodes.
This is a small price to pay for this high level of security.
</BLOCKQUOTE>
<H4>Pass 4</H4>
<BLOCKQUOTE>
This pass loads externally referenced classes and checks that
the method name and signatures match. It also validates that the
current class has access rights to the external class. After complete
validation, each instruction is replaced with a <TT>_quick</TT>
alternative. These <TT>_quick</TT>
bytecodes indicate that the class has been verified and need not
be checked again.
</BLOCKQUOTE>
<H3><A NAME="ExceptionHandling">Exception Handling</A></H3>
<P>
The <TT>pc</TT> register points to
the next bytecode to execute. Whenever an exception is thrown,
the method's exception table is searched for a handler. Each exception
table entry has this format:
<BLOCKQUOTE>
<TT>ExceptionItem<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 start_pc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 end_pc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 handler_pc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u2 catch_type;<BR>
}</TT>
</BLOCKQUOTE>
<P>
If the <TT>pc</TT> register is within
the proper range and the thrown exception is the proper type,
the entry's handler code block is executed. If no handler is found,
the exception propagates up to the calling method. The procedure
repeats itself until either a valid handler is found or the program
exits.
<H3><A NAME="Bytecodes">Bytecodes</A></H3>
<P>
The bytecodes can be divided into 11 major categories:
<UL>
<LI>Pushing constants onto the stack
<LI><FONT COLOR=#000000>Moving local variable contents to and
from the stack</FONT>
<LI><FONT COLOR=#000000>Managing arrays</FONT>
<LI><FONT COLOR=#000000>Generic stack instructions (dup, swap,
pop &amp; nop)</FONT>
<LI><FONT COLOR=#000000>Arithmetic and logical instructions</FONT>
<LI><FONT COLOR=#000000>Conversion instructions</FONT>
<LI><FONT COLOR=#000000>Control transfer and function return</FONT>
<LI><FONT COLOR=#000000>Manipulating object fields</FONT>
<LI><FONT COLOR=#000000>Method invocation</FONT>
<LI><FONT COLOR=#000000>Miscellaneous operations</FONT>
<LI><FONT COLOR=#000000>Monitors</FONT>
</UL>
<P>
Each bytecode has a unique tag and is followed by a fixed number
of additional arguments. Notice that there is no way to work directly
with class fields or local variables. They must be moved to the
operand stack before any operations can be performed on the contents.
<P>
Generally, there are multiple formats for each individual operation.
The addition operation provides a good example. There are actually
four forms of addition: <TT>iadd</TT>,
<TT>ladd</TT>, <TT>fadd</TT>,
and <TT>dadd</TT>. Each type assumes
the top two stack items are of the correct format: integers, longs,
floats, or doubles.
<H4>Pushing Constants Onto the Stack</H4>
<P>
Java uses the following instructions for moving object data and
local variables to the operand stack:
<H5>Push One-Byte Signed Integer</H5>
<BLOCKQUOTE>
<TT>bipush=16 byte1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., byte1</TT>
</BLOCKQUOTE>
<H5>Push Two-Byte Signed Integer</H5>
<BLOCKQUOTE>
<TT>sipush=17 byte1 byte2&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., word1</TT>
</BLOCKQUOTE>
<H5>Push Item From the Constant Pool (8-bit index)</H5>
<BLOCKQUOTE>
<TT>ldc1=18 indexbyte1&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., item</TT>
</BLOCKQUOTE>
<H5>Push Item from the Constant Pool (16-bit index)</H5>
<BLOCKQUOTE>
<TT>ldc2=19 indexbyte1 indexbyte2&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., item</TT>
</BLOCKQUOTE>
<H5>Push Long or Double from Constant Pool (16-bit index)</H5>
<BLOCKQUOTE>
<TT>ldc2w=20 indexbyte1 indexbyte2&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., word1, word2</TT>
</BLOCKQUOTE>
<H5>Push Null Object</H5>
<BLOCKQUOTE>
<TT>aconst_null=1&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., null</TT>
</BLOCKQUOTE>
<H5>Push Integer Constant -1</H5>
<BLOCKQUOTE>
<TT>iconst_m1=2&nbsp;&nbsp;&nbsp;Stack: ...
-&gt; ..., -1</TT>
</BLOCKQUOTE>
<H5>Push Integer Constants</H5>
<BLOCKQUOTE>
<TT>iconst_0=3&nbsp;&nbsp;&nbsp;Stack: ...
-&gt; ..., 0<BR>
iconst_1=4&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 1<BR>
iconst_2=5&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 2<BR>
iconst_3=6&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 3<BR>
iconst_4=7&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 4<BR>
iconst_5=8&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 5</TT>
</BLOCKQUOTE>
<H5>Push Long Constant</H5>
<BLOCKQUOTE>
<TT>lconst_0=9&nbsp;&nbsp;&nbsp;Stack: ...
-&gt; ..., 0, 0<BR>
lconst_1=10&nbsp;&nbsp;Stack: ... -&gt; ..., 0, 1</TT>
</BLOCKQUOTE>
<H5>Push Float Constants</H5>
<BLOCKQUOTE>
<TT>fconst_0=11&nbsp;&nbsp;&nbsp;Stack: ...
-&gt; ..., 0<BR>
fconst_1=12&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 1<BR>
fconst_2=13&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 2</TT>
</BLOCKQUOTE>
<H5>Push Double Constants</H5>
<BLOCKQUOTE>
<TT>dconst_0=14&nbsp;&nbsp;&nbsp;Stack: ...
-&gt; ..., 0, 0<BR>
dconst_1=15&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ..., 0, 1</TT>
</BLOCKQUOTE>
<H4>Accessing Local Variables</H4>
<P>
The most commonly referenced local variables are at the first
four offsets from the <TT>vars</TT>
register. Because of this, Java provides single byte instructions
to access these variables for both reading and writing. A two-byte
instruction is needed to reference variables greater than 4 deep.
The variable at location zero is the class pointer itself (the
<TT>this</TT> pointer).
<H5>Load Integer from Local Variable</H5>
<BLOCKQUOTE>
<TT>iload=21 vindex&nbsp;&nbsp;Stack: ...
-&gt; ..., contents of varaible at vars[vindex]<BR>
iload_o=26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents of variable at vars[0]<BR>
iload_1=27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents of variable at vars[1]<BR>
iload_2=28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents of variable at vars[2]<BR>
iload_3=29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents of variable at vars[3]</TT>
</BLOCKQUOTE>
<H5>Load Long Integer from Local Variable</H5>
<BLOCKQUOTE>
<TT>lload=22 vindex&nbsp;&nbsp;Stack: ..
-&gt; ..., word1, word2&nbsp;&nbsp;from vars[vindex] &amp; vars[vindex+1]
<BR>
lload_0=30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .. -&gt;
..., word1, word2&nbsp;&nbsp;from vars[0] &amp; vars[1]<BR>
lload_1=31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .. -&gt;
..., word1, word2&nbsp;&nbsp;from vars[1] &amp; vars[2]<BR>
lload_2=32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .. -&gt;
..., word1, word2&nbsp;&nbsp;from vars[2] &amp; vars[3]<BR>
lload_3=33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .. -&gt;
..., word1, word2&nbsp;&nbsp;from vars[3] &amp; vars[4]</TT>
</BLOCKQUOTE>
<H5>Load Float from Local Variable</H5>
<BLOCKQUOTE>
<TT>fload=23 vindex&nbsp;&nbsp;Stack: ...
-&gt; ..., contents from vars[vindex]<BR>
fload_0=34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents from vars[0]<BR>
fload_1=35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents from vars[1]<BR>
fload_2=36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents from vars[2]<BR>
fload_3=37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., contents from vars[3]</TT>
</BLOCKQUOTE>
<H5>Load Double from Local Variable</H5>
<BLOCKQUOTE>
<TT>dload=24 vindex&nbsp;&nbsp;Stack: ...
-&gt; ..., word1, word2&nbsp;&nbsp;from vars[vindex] &amp; vars[vindex+1]
<BR>
dload_0=38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., word1, word2&nbsp;&nbsp;from vars[0] &amp; vars[1]<BR>
dload_1=39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., word1, word2&nbsp;&nbsp;from vars[1] &amp; vars[2]<BR>
dload_2=40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., word1, word2&nbsp;&nbsp;from vars[2] &amp; vars[3]<BR>
dload_3=41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., word1, word2&nbsp;&nbsp;from vars[3] &amp; vars[4]</TT>
</BLOCKQUOTE>
<H5>Load Object from Local Variable</H5>
<BLOCKQUOTE>
<TT>aload=25 vindex&nbsp;&nbsp;Stack: ...
-&gt; ..., object&nbsp;&nbsp;from vars[vindex]<BR>
aload_0=42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., object&nbsp;&nbsp;from vars[0]<BR>
aload_1=43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., object&nbsp;&nbsp;from vars[1]<BR>
aload_2=44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., object&nbsp;&nbsp;from vars[2]<BR>
aload_3=45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: ... -&gt;
..., object&nbsp;&nbsp;from vars[3]</TT>
</BLOCKQUOTE>
<H5>Store Integer into Local Variable</H5>
<BLOCKQUOTE>
<TT>istore=54 vindex Stack: ..., INT -&gt;
...&nbsp;&nbsp;into vars[vindex]<BR>
istore_0=59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., INT
-&gt; ...&nbsp;&nbsp;into vars[0]<BR>
istore_1=60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., INT
-&gt; ...&nbsp;&nbsp;into vars[1]<BR>
istore_2=61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., INT
-&gt; ...&nbsp;&nbsp;into vars[2]<BR>
istore_3=62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., INT
-&gt; ...&nbsp;&nbsp;into vars[3]</TT>
</BLOCKQUOTE>
<H5>Store Long Integer into Local Variable</H5>
<BLOCKQUOTE>
<TT>lstore=55 vindex Stack: ..., word1, word2
-&gt; ...&nbsp;&nbsp;into vars[vindex] &amp; vars[vindex+1]<BR>
lstore_0=63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[0] &amp; vars[1]<BR>
lstore_1=64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[1] &amp; vars[2]<BR>
lstore_2=65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[2] &amp; vars[3]<BR>
lstore_3=66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[3] &amp; vars[4]</TT>
</BLOCKQUOTE>
<H5>Store Float into Local Variable</H5>
<BLOCKQUOTE>
<TT>fstore=56 vindex Stack: ..., FLOAT -&gt;
...&nbsp;&nbsp;into vars[vindex]<BR>
fstore_0=67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., FLOAT
-&gt; ...&nbsp;&nbsp;into vars[0]<BR>
fstore_1=68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., FLOAT
-&gt; ...&nbsp;&nbsp;into vars[1]<BR>
fstore_2=69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., FLOAT
-&gt; ...&nbsp;&nbsp;into vars[2]<BR>
fstore_3=70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., FLOAT
-&gt; ...&nbsp;&nbsp;into vars[3]</TT>
</BLOCKQUOTE>
<H5>Store Double into Local Variable</H5>
<BLOCKQUOTE>
<TT>dstore=57 vindex Stack: ..., word1, word2
-&gt; ...&nbsp;&nbsp;into vars[vindex] &amp; vars[vindex+1]<BR>
dstore_0=71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[0] &amp; vars[1]<BR>
dstore_1=72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[1] &amp; vars[2]<BR>
dstore_2=73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[2] &amp; vars[3]<BR>
dstore_3=74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., word1,
word2 -&gt; ...&nbsp;&nbsp;into vars[3] &amp; vars[4]</TT>
</BLOCKQUOTE>
<H5>Store Object into Local Variable</H5>
<BLOCKQUOTE>
<TT>istore=58 vindex Stack: ..., OBJ -&gt;
...&nbsp;&nbsp;into vars[vindex]<BR>
istore_0=75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., OBJ
-&gt; ...&nbsp;&nbsp;into vars[0]<BR>
istore_1=76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., OBJ
-&gt; ...&nbsp;&nbsp;into vars[1]<BR>
istore_2=77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., OBJ
-&gt; ...&nbsp;&nbsp;into vars[2]<BR>
istore_3=78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., OBJ
-&gt; ...&nbsp;&nbsp;into vars[3]</TT>
</BLOCKQUOTE>
<H5>Increment Local Variable </H5>
<P>
This applies only to integers.
<BLOCKQUOTE>
<TT>iinc=132 vindex constant&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ...&nbsp;&nbsp;vars[vindex] += constant</TT>
</BLOCKQUOTE>
<H4>Managing Arrays</H4>
<UL>
<LI>Arrays are treated as objects, but as you learned in <A HREF="Ch10.htm" >Chapter 10</A>,
they don't use a method table pointer. Because of this uniqueness,
arrays have special bytecodes to create and access them.
</UL>
<H5>Allocate a New Array</H5>
<BLOCKQUOTE>
<TT>newarray=188 type Stack: ..., size -&gt;
..., OBJ</TT>
</BLOCKQUOTE>
<H5>Allocate a New Array of Objects</H5>
<BLOCKQUOTE>
<TT>anewarray=189 classindex1 classindex2
Stack: ..., size -&gt; ..., OBJ</TT>
</BLOCKQUOTE>
<H5>Allocate a New Multi-Dimensional Array</H5>
<BLOCKQUOTE>
<TT>newarray=197 indexbyte1 indexbyte1 indexbyte2&nbsp;&nbsp;Stack:
..., size1, size2, etc -&gt; ..., OBJ</TT>
</BLOCKQUOTE>
<H5>Get the Array Length</H5>
<BLOCKQUOTE>
<TT>arraylength=190 Stack: ..., OBJ -&gt;
..., length</TT>
</BLOCKQUOTE>
<H5>Load Primitives from the Array</H5>
<BLOCKQUOTE>
<TT>iaload=46 Stack: ..., OBJ, index -&gt;
..., INT<BR>
laload=47 Stack: ..., OBJ, index -&gt; ..., LONG1, LONG2<BR>
faload=48 Stack: ..., OBJ, index -&gt; ..., FLOAT<BR>
daload=49 Stack: ..., OBJ, index -&gt; ..., DOUBLE1, DOUBLE2<BR>
aaload=50 Stack: ..., OBJ, index -&gt; ..., OBJ<BR>
baload=51 Stack: ..., OBJ, index -&gt; ..., BYTE<BR>
caload=52 Stack: ..., OBJ, index -&gt; ..., CHAR<BR>
saload=53 Stack: ..., OBJ, index -&gt; ..., SHORT</TT>
</BLOCKQUOTE>
<H5>Store Primitives into the Array</H5>
<BLOCKQUOTE>
<TT>iastore-79 Stack: ..., OBJ, index, INT
-&gt; ...<BR>
lastore=80 Stack: ..., OBJ, index, LONG1, LONG2 -&gt; ...<BR>
fastore=81 Stack: ..., OBJ, index, FLOAT -&gt; ...<BR>
dastore=82 Stack: ..., OBJ, index, DOUBLE1, DOUBLE2 -&gt; ...
<BR>
aastore=83 Stack: ..., OBJ, index, OBJ -&gt; ...<BR>
bastore=84 Stack: ..., OBJ, index, BYTE -&gt; ...<BR>
castore=85 Stack: ..., OBJ, index, CHAR -&gt; ...<BR>
sastore=86 Stack: ..., OBJ, index, SHORT -&gt; ...</TT>
</BLOCKQUOTE>
<H4>Generic Stack Instructions</H4>
<P>
These are basic operations that alter the stack:
<H5>Do Nothing</H5>
<BLOCKQUOTE>
<TT>nop=0&nbsp;&nbsp;&nbsp;Stack: ... -&gt;
...</TT>
</BLOCKQUOTE>
<H5>Pop Stack Values</H5>
<BLOCKQUOTE>
<TT>pop=87&nbsp;&nbsp;Stack: ..., VAL -&gt;
...<BR>
pop2=88&nbsp;&nbsp;Stack: ..., VAL1, VAL2 -&gt; ...</TT>
</BLOCKQUOTE>
<H5>Duplicate Stack Values and Possibly Insert Below Stack Top
</H5>
<BLOCKQUOTE>
<TT>dup=89&nbsp;&nbsp;&nbsp;&nbsp; Stack:
..., V -&gt; ..., V, V<BR>
dup2=92&nbsp;&nbsp;&nbsp;&nbsp;Stack: ..., V1, V2 -&gt; ..., V1,
V2, V1, V2<BR>
dup_x1=90&nbsp;&nbsp;Stack: ..., V1, V2 -&gt; ..., V2, V1, V2
<BR>
dup2_x1=93 Stack: ..., V1, V2, V3 -&gt; ..., V2, V3, V1, V2, V3
<BR>
dup_x2=91&nbsp;&nbsp;Stack: ..., V1, V2, V3 -&gt; ..., V3, V1,
V2, V3<BR>
dup2_x2=94 Stack: ..., V1, V2, V3, V4 -&gt; ..., V3, V4, V1, V2,
V3, V4</TT>
</BLOCKQUOTE>
<H5>Swap Two-Stack Items</H5>
<BLOCKQUOTE>
<TT>swap=95&nbsp;&nbsp;&nbsp;&nbsp;Stack:
..., V1, V2 -&gt; ..., V2, V1</TT>
</BLOCKQUOTE>
<H4>Arithmetic and Logical Instructions</H4>
<P>
All the arithmetic operations operate on four possible types:
integer, long, float, or double. Logical instructions operate
only on integer and long types.
<H5>Addition</H5>
<BLOCKQUOTE>
<TT>iadd=96&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; ..., INT1+INT2<BR>
ladd=97&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ...,
L1+L2 (high), L1+L2 (low)<BR>
fadd=98&nbsp;&nbsp;Stack: ..., FLOAT1, FLOAT2 -&gt; ..., FLOAT1+FLOAT2
<BR>
dadd=99&nbsp;&nbsp;Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt; ...,
D1+D2 (high), D1+D2 (low)</TT>
</BLOCKQUOTE>
<H5>Subtraction</H5>
<BLOCKQUOTE>
<TT>isub=100 Stack: ..., INT1, INT2 -&gt;
..., INT1-INT2<BR>
lsub=101 Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ..., L1-L2 (high),
L1-L2 (low)<BR>
fsub=102 Stack: ..., FLOAT1, FLOAT2 -&gt; ..., FLOAT1-FLOAT2<BR>
dsub=103 Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt; ..., D1-D2 (high),
D1-D2 (low)</TT>
</BLOCKQUOTE>
<H5>Multiplication</H5>
<BLOCKQUOTE>
<TT>imul=104&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; ..., INT1*INT2<BR>
lmul=105&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ...,
L1*L2 (high), L1*L2 (low)<BR>
fmul=106&nbsp;&nbsp;Stack: ..., FLOAT1, FLOAT2 -&gt; ..., FLOAT1*FLOAT2
<BR>
dmul=107&nbsp;&nbsp;Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt; ...,
D1*D2 (high), D1*D2 (low)</TT>
</BLOCKQUOTE>
<H5>Division</H5>
<BLOCKQUOTE>
<TT>idiv=108&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; ..., INT1/INT2<BR>
ldiv=109&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ...,
L1/L2 (high), L1/L2 (low)<BR>
fdiv=110&nbsp;&nbsp;Stack: ..., FLOAT1, FLOAT2 -&gt; ..., FLOAT1/FLOAT2
<BR>
ddiv=111&nbsp;&nbsp;Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt; ...,
D1/D2 (high), D1/D2 (low)</TT>
</BLOCKQUOTE>
<H5>Remainder</H5>
<BLOCKQUOTE>
<TT>irem=112&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; ..., INT1%INT2<BR>
lrem=113&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ...,
L1%L2 (high), L1%L2 (low)<BR>
frem=114&nbsp;&nbsp;Stack: ..., FLOAT1, FLOAT2 -&gt; ..., FLOAT1%FLOAT2
<BR>
drem=115&nbsp;&nbsp;Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt; ...,
D1%D2 (high), D1%D2 (low)</TT>
</BLOCKQUOTE>
<H5>Negation</H5>
<BLOCKQUOTE>
<TT>ineg=116&nbsp;&nbsp;Stack: ..., INT -&gt;
..., -INT<BR>
lneg=117&nbsp;&nbsp;Stack: ..., LONG1, LONG2 -&gt; ..., -LONG1,
-LONG2<BR>
fneg=118&nbsp;&nbsp;Stack: ..., FLOAT -&gt; ..., -FLOAT<BR>
dneg=119&nbsp;&nbsp;Stack: ..., DOUBLE1, DOUBLE2 -&gt; ..., -DOUBLE1,
-DOUBLE2</TT>
</BLOCKQUOTE>
<H5>Integer Logical Instructions </H5>
<P>
<TT>&gt;&gt;&gt;</TT> denotes an unsigned
right shift.
<BLOCKQUOTE>
<TT>ishl=120&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; INT1&lt;&lt;(INT2 &amp; 0x1f)<BR>
ishr=122&nbsp;&nbsp;Stack: ..., INT1, INT2 -&gt; INT1&gt;&gt;(INT2
&amp; 0x1f)<BR>
iushr=124 Stack: ..., INT1, INT2 -&gt; INT1&gt;&gt;&gt;(INT2 &amp;
0x1f)</TT>
</BLOCKQUOTE>
<H5>Long Integer Logical Instructions</H5>
<P>
<TT>&gt;&gt;&gt;</TT> denotes an unsigned
right shift.
<BLOCKQUOTE>
<TT>lshl=121&nbsp;&nbsp;Stack: ..., L1, L2,
INT -&gt; L1&lt;&lt;(INT &amp; 0x3f), L2&lt;&lt;(INT &amp; 0x3f)
<BR>
lshr=123&nbsp;&nbsp;Stack: ..., L1, L2, INT -&gt; INT1&gt;&gt;(INT
&amp; 0x3f), L2&gt;&gt;(INT &amp; 0x03)<BR>
lushr=125 Stack: ..., L1, L2, INT -&gt; INT1&gt;&gt;&gt;(INT &amp;
0x3f), L2&gt;&gt;&gt;(INT &amp; 0x3f)</TT>
</BLOCKQUOTE>
<H5>Integer Boolean Operations</H5>
<BLOCKQUOTE>
<TT>iand=126&nbsp;&nbsp;Stack: ..., INT1,
INT2 -&gt; ..., INT1&amp;INT2<BR>
ior=128&nbsp;&nbsp;&nbsp;Stack: ..., INT1, INT2 -&gt; ..., INT1|INT2
<BR>
ixor=130&nbsp;&nbsp;Stack: ..., INT1, INT2 -&gt; ..., INT1^INT2</TT>
</BLOCKQUOTE>
<H5>Long Integer Boolean Operations</H5>
<BLOCKQUOTE>
<TT>land=127&nbsp;&nbsp;Stack: ..., L1_1,
L1_2, L2_1, L2_2 -&gt; ..., L1_1&amp;L2_1, L1_2&amp;L2_2<BR>
lor=129&nbsp;&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt;
..., L1_1|L2_1, L1_2|L2_2<BR>
lxor=131&nbsp;&nbsp;Stack: ..., L1_1, L1_2, L2_1, L2_2 -&gt; ...,
L1_1^L2_1. L1_2^L2_2</TT>
</BLOCKQUOTE>
<H4>Conversion Instructions</H4>
<P>
Because most of the previous bytecodes expect the stack to contain
a homogenous set of operands, Java uses conversion functions.
In code, you can add a float and an integer, but Java will first
convert the integer to a float type before performing the addition.
<H5>Integer Conversions</H5>
<BLOCKQUOTE>
<TT>i2l=133&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Stack: .., INT -&gt; ..., LONG1, LONG2<BR>
i2f=134&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., INT -&gt;
..., FLOAT<BR>
i2d=135&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., INT -&gt;
..., DOUBLE1, DOUBLE2<BR>
int2byte=145&nbsp;&nbsp;Stack: .., INT -&gt; ..., BYTE<BR>
int2char=146&nbsp;&nbsp;Stack: .., INT -&gt; ..., CHAR<BR>
int2short=147 Stack: .., INT -&gt; ..., SHORT</TT>
</BLOCKQUOTE>
<H5>Long Integer Conversions</H5>
<BLOCKQUOTE>
<TT>l2i=136&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Stack: .., LONG1, LONG2 -&gt; ..., INT<BR>
l2f=137&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., LONG1,
LONG2 -&gt; ..., FLOAT<BR>
l2d=138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., LONG1,
LONG2 -&gt; ..., DOUBLE1, DOUBLE2</TT>
</BLOCKQUOTE>
<H5>Float Conversions</H5>
<BLOCKQUOTE>
<TT>f2i=139&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Stack: .., FLOAT -&gt; ..., INT<BR>
f2l=140&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., FLOAT -&gt;
..., LONG1, LONG2<BR>
f2d=141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., FLOAT -&gt;
..., DOUBLE1, DOUBLE2</TT>
</BLOCKQUOTE>
<H5>Double Conversions</H5>
<BLOCKQUOTE>
<TT>d2i=142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Stack: .., DOUBLE1, DOUBLE2 -&gt; ..., INT<BR>
d2l=143&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., DOUBLE1,
DOUBLE2 -&gt; ..., LONG1, LONG2<BR>
d2f=144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stack: .., DOUBLE1,
DOUBLE2 -&gt; ..., FLOAT</TT>
</BLOCKQUOTE>
<H4>Control Transfer and Function Return</H4>
<P>
All branch indexes are signed 16-bit offsets from the current
<TT>pc</TT> register.
<H5>Comparisons with Zero</H5>
<BLOCKQUOTE>
<TT>ifeq=153 branch1 branch2&nbsp;&nbsp;&nbsp;Stack:
..., INT -&gt; ...<BR>
ifne=154 branch1 branch2&nbsp;&nbsp;&nbsp;Stack: ..., INT -&gt;
...<BR>
iflt=155 branch1 branch2&nbsp;&nbsp;&nbsp;Stack: ..., INT -&gt;
...<BR>
ifge=156 branch1 branch2&nbsp;&nbsp;&nbsp;Stack: ..., INT -&gt;
...<BR>
ifgt=157 branch1 branch2&nbsp;&nbsp;&nbsp;Stack: ..., INT -&gt;
...<BR>
ifle=158 branch1 branch2&nbsp;&nbsp;&nbsp;Stack: ..., INT -&gt;
...</TT>
</BLOCKQUOTE>
<H5>Comparison with Null</H5>
<BLOCKQUOTE>
<TT>ifnull=198 branch1 branch2&nbsp;&nbsp;&nbsp;&nbsp;Stack:
..., OBJ -&gt; ...<BR>
ifnonnull=199 branch1 branch2 Stack: ..., OBJ -&gt; ...</TT>
</BLOCKQUOTE>
<H5>Compare Two Integers</H5>
<BLOCKQUOTE>
<TT>if_icmpeq=159 branch1 branch2&nbsp;&nbsp;Stack:
..., INT1, INT2 -&gt; ...<BR>
if_icmpne=160 branch1 branch2&nbsp;&nbsp;Stack: ..., INT1, INT2
-&gt; ...<BR>
if_icmplt=161 branch1 branch2&nbsp;&nbsp;Stack: ..., INT1, INT2
-&gt; ...<BR>
if_icmpge=162 branch1 branch2&nbsp;&nbsp;Stack: ..., INT1, INT2
-&gt; ...<BR>
if_icmpgt=163 branch1 branch2&nbsp;&nbsp;Stack: ..., INT1, INT2
-&gt; ...<BR>
if_icmple=164 branch1 branch2&nbsp;&nbsp;Stack: ..., INT1, INT2
-&gt; ...</TT>
</BLOCKQUOTE>
<H5>Compare Two Long Integers</H5>
<BLOCKQUOTE>
<TT>lcmp=148  Stack: ..., L1_1, L1_2, L2_1,
L2_2 -&gt; ..., INT (One of [-1, 0, 1])</TT>
</BLOCKQUOTE>
<H5>Compare Two Floats </H5>
<P>
l-&gt;-1 on NaN, g-&gt;1 on NaN.
<BLOCKQUOTE>
<TT>fcmpl=149&nbsp;&nbsp;Stack: ..., FLOAT1,
FLOAT2 -&gt; ..., INT (One of [-1, 0, 1])<BR>
fcmpg=150&nbsp;&nbsp;Stack: ..., FLOAT1, FLOAT2 -&gt; ..., INT
(One of [-1, 0, 1])</TT>
</BLOCKQUOTE>
<H5>Compare Two Doubles </H5>
<P>
l-&gt;-1 on NaN, g-&gt;1 on NaN.
<BLOCKQUOTE>
<TT>dcmpl=151&nbsp;&nbsp;Stack: ..., D1_1,
D1_2, D2_1, D2_2 -&gt; ..., INT (One of [-1, 0, 1])<BR>
dcmpg=152&nbsp;&nbsp;Stack: ..., D1_1, D1_2, D2_1, D2_2 -&gt;
..., INT (One of [-1, 0, 1])</TT>
</BLOCKQUOTE>
<H5>Compare Two Objects</H5>
<BLOCKQUOTE>
<TT>if_acmpeq=165 branch1 branch2&nbsp;&nbsp;Stack:
..., OBJ1, OBJ2 -&gt; ...<BR>
if_acmpne=166 branch1 branch2&nbsp;&nbsp;Stack: ..., OBJ1, OBJ2
-&gt; ...</TT>
</BLOCKQUOTE>
<H5>Unconditional Branching</H5>
<P>
16-bit and 32-bit branching
<BLOCKQUOTE>
<TT>goto=167 branch1 branch2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ...<BR>
goto_w=200 branch1 branch2 branch3 branch4&nbsp;&nbsp;Stack: ...
-&gt; ...</TT>
</BLOCKQUOTE>
<H5>Jump Subroutine </H5>
<P>
16-bit and 32-bit jumps
<BLOCKQUOTE>
<TT>jsr=168 branch1 branch2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., returnAddress<BR>
jsr_w=201 branch1 branch2 branch3 branch4&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ..., returnAddress</TT>
</BLOCKQUOTE>
<H5>Return from Subroutine </H5>
<P>
The return address is retrieved from a local variable, not the
stack.
<BLOCKQUOTE>
<TT>ret=169 vindex&nbsp;&nbsp;&nbsp;Stack:
... -&gt; ...&nbsp;&nbsp;&nbsp;(returnAddress &lt;- vars[vindex])
<BR>
ret_w=209 vindex1 vindex2&nbsp;&nbsp;&nbsp;Stack: ... -&gt; ...&nbsp;&nbsp;&nbsp;(returnAddress
&lt;- vars[vindex])</TT>
</BLOCKQUOTE>
<H5>Returning Primitives </H5>
<P>
The current stack frame is destroyed. The top primitive is pushed
onto the caller's operand stack.
<BLOCKQUOTE>
<TT>ireturn=172&nbsp;&nbsp;Stack: ..., INT
-&gt; [destroyed]<BR>
lreturn=173&nbsp;&nbsp;Stack: ..., LONG1, LONG2 -&gt; [destroyed]
<BR>
freturn=174&nbsp;&nbsp;Stack: ..., FLOAT -&gt; [destroyed]<BR>
dreturn=175&nbsp;&nbsp;Stack: ..., DOUBLE1, DOUBLE2 -&gt; [destroyed]
<BR>
areturn=176&nbsp;&nbsp;Stack: ..., OBJ -&gt; [destroyed]<BR>
return=177&nbsp;&nbsp;Stack: ... -&gt; [destroyed]</TT>
</BLOCKQUOTE>
<H5>Calling the Breakpoint Handler</H5>
<BLOCKQUOTE>
<TT>breakpoint=202&nbsp;&nbsp;Stack: ...,
-&gt; ...</TT>
</BLOCKQUOTE>
<H4>Manipulating Object Fields</H4>
<P>
Construct a 16-bit index into the constant pool to retrieve the
class and field name, then resolve these names to determine the
field offset and width. Use the object reference on the stack
as the target. The value will be 32 or 64 bits, depending on the
field information in the constant pool.
<BLOCKQUOTE>
<TT>Getstatic=178&nbsp;&nbsp;index1 index2&nbsp;&nbsp;&nbsp;Stack:
..., -&gt; ..., VAL<BR>
Putstatic=179&nbsp;&nbsp;index1 index2&nbsp;&nbsp;&nbsp;Stack:
..., VAL -&gt; ...<BR>
Getfield=180&nbsp;&nbsp;&nbsp;index1 index2&nbsp;&nbsp;&nbsp;Stack:
..., OBJ -&gt; ..., VAL<BR>
Putfield=181&nbsp;&nbsp;&nbsp;index1 index2&nbsp;&nbsp;&nbsp;Stack:
..., OBJ, VAL -&gt; ...</TT>
</BLOCKQUOTE>
<H4>Method Invocation</H4>
<P>
There are four types of method invocation:
<UL>
<LI><TT>invokevirtual=182</TT>-Normal
method dispatch in Java. Use the index bytes to create a 16-bit
index into the constant table of the current class. Extract the
method name and signature. Search the method table of the stack
object to determine the method address. Use the method signature
to remove the method arguments from the operand stack and transfer
them to the new method's local variables.
<LI><TT>invokenonvirtual=183</TT>-Used
when a method is called with the super keyword. Use the index
bytes to create a 16-bit index into the constant pool of the current
class. Extract the method name and signature. Search the named
class's method table to determine the method address. Extract
the object and arguments and place them in the new method's local
variables.
<LI><TT>invokestatic=184</TT>-Used
to call static methods. Create a 16-bit index into the current
class's constant pool. Extract the method and search the named
class's method table for the address. Transfer the arguments as
before. There is no object to pass.
<LI><TT>invokeinterface=185</TT>-Invoke
an interface function. Again, a 16-bit index is created to find
the method name and signature. This time, however, the number
of arguments is determined from the bytecodes, not the signature.
<BR>
<BR>
<TT>virtual index1 index2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack:
..., OBJ, [arg1, [arg2, ...]] -&gt; ...<BR>
nonvirtual index1 index2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Stack: ..., OBJ, [arg1, [arg2, ...]] -&gt; ...<BR>
static index1 index2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack:
..., [arg1, [arg2, ...]] -&gt; ...<BR>
interface index1 index2 nargs resv Stack: ..., OBJ, [arg1, [arg2,
...]] -&gt; ...</TT>
</UL>
<H4>Miscellaneous Operations</H4>
<P>
These instructions don't fall under any other heading; they deal
with generic object operations, such as creation and casting.
<H5>Throw Exception</H5>
<BLOCKQUOTE>
<TT>athrow=191&nbsp;&nbsp;Stack: ..., OBJ
-&gt; [undefined]</TT>
</BLOCKQUOTE>
<H5>Create a New Object</H5>
<BLOCKQUOTE>
<TT>new=187 index1 index2&nbsp;&nbsp;Stack:
... -&gt; ..., OBJ</TT>
</BLOCKQUOTE>
<H5>Check a Cast Operation</H5>
<BLOCKQUOTE>
<TT>checkcast=192 index1 index2&nbsp;&nbsp;Stack:
..., OBJ -&gt; ..., OBJ</TT>
</BLOCKQUOTE>
<H5>Instanceof</H5>
<BLOCKQUOTE>
<TT>instanceof=193 index1 index2&nbsp;&nbsp;Stack:
..., OBJ -&gt; ... INT (1 or 0)</TT>
</BLOCKQUOTE>
<H4>Monitors</H4>
<P>
Monitor instructions are used for synchronization.
<H5>Enter a Monitored Region of Code</H5>
<BLOCKQUOTE>
<TT>monitorenter=194&nbsp;&nbsp;Stack: ...,
OBJ -&gt; ...</TT>
</BLOCKQUOTE>
<H5>Exit a Monitored Region of Code</H5>
<BLOCKQUOTE>
<TT>monitorexit=195&nbsp;&nbsp;Stack: ...,
OBJ -&gt; ...</TT>
</BLOCKQUOTE>
<H3><A NAME="TestClassBytecodes">Test Class Bytecodes</A></H3>
<P>
Sun supplies a tool, <TT>javap</TT>,
that enables you to disassemble and view the bytecodes of a class.
If the -c option is passed to <TT>javap</TT>,
a listing of bytecodes is produced. These are the test class's
bytecodes:
<BLOCKQUOTE>
<TT>Compiled from test.java<BR>
public class test extends java.lang.Object {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static int st_one;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public test();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public test(int);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native boolean getData(int []);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int do_countdown();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int do_countdown(int);<BR>
<BR>
Method test()<BR>
&nbsp;&nbsp;&nbsp;0 aload_0<BR>
&nbsp;&nbsp;&nbsp;1 invokenonvirtual #9 &lt;Method java.lang.Object.&lt;init&gt;()V&gt;
<BR>
&nbsp;&nbsp;&nbsp;4 bipush 100<BR>
&nbsp;&nbsp;&nbsp;6 putstatic #7 &lt;Field test.st_one I&gt;<BR>
&nbsp;&nbsp;&nbsp;9 return<BR>
<BR>
Method test(int)<BR>
&nbsp;&nbsp;&nbsp;0 aload_0<BR>
&nbsp;&nbsp;&nbsp;1 invokenonvirtual #9 &lt;Method java.lang.Object.&lt;init&gt;()V&gt;
<BR>
&nbsp;&nbsp;&nbsp;4 iload_1<BR>
&nbsp;&nbsp;&nbsp;5 putstatic #7 &lt;Field test.st_one I&gt;<BR>
&nbsp;&nbsp;&nbsp;8 return<BR>
<BR>
Method int do_countdown()<BR>
&nbsp;&nbsp;&nbsp;0 getstatic #7 &lt;Field test.st_one I&gt;<BR>
&nbsp;&nbsp;&nbsp;3 istore_1<BR>
&nbsp;&nbsp;&nbsp;4 getstatic #6 &lt;Field java.lang.System.out
Ljava/io/PrintStream;&gt;<BR>
&nbsp;&nbsp;&nbsp;7 ldc #1 &lt;String &quot;Performing countdown:&quot;&gt;
<BR>
&nbsp;&nbsp;&nbsp;9 invokevirtual #10 &lt;Method java.io.PrintStream.println(Ljava/lang/String;)V&gt;
<BR>
&nbsp;&nbsp;12 goto 22<BR>
&nbsp;&nbsp;15 getstatic #6 &lt;Field java.lang.System.out Ljava/io/PrintStream;&gt;
<BR>
&nbsp;&nbsp;18 iload_1<BR>
&nbsp;&nbsp;19 invokevirtual #8 &lt;Method java.io.PrintStream.println(I)V&gt;
<BR>
&nbsp;&nbsp;22 iload_1<BR>
&nbsp;&nbsp;23 iinc 1 -1<BR>
&nbsp;&nbsp;26 ifne 15<BR>
&nbsp;&nbsp;29 getstatic #7 &lt;Field test.st_one I&gt;<BR>
&nbsp;&nbsp;32 ireturn<BR>
<BR>
Method int do_countdown(int)<BR>
&nbsp;&nbsp;&nbsp;0 iload_1<BR>
&nbsp;&nbsp;&nbsp;1 istore_2<BR>
&nbsp;&nbsp;&nbsp;2 getstatic #6 &lt;Field java.lang.System.out
Ljava/io/PrintStream;&gt;<BR>
&nbsp;&nbsp;&nbsp;5 ldc #1 &lt;String &quot;Performing countdown:&quot;&gt;
<BR>
&nbsp;&nbsp;&nbsp;7 invokevirtual #10 &lt;Method java.io.PrintStream.println(Ljava/lang/String;)V&gt;
<BR>
&nbsp;&nbsp;10 goto 20<BR>
&nbsp;&nbsp;13 getstatic #6 &lt;Field java.lang.System.out Ljava/io/PrintStream;&gt;
<BR>
&nbsp;&nbsp;16 iload_1<BR>
&nbsp;&nbsp;17 invokevirtual #8 &lt;Method java.io.PrintStream.println(I)V&gt;
<BR>
&nbsp;&nbsp;20 iload_1<BR>
&nbsp;&nbsp;21 iinc 1 -1<BR>
&nbsp;&nbsp;24 ifne 13<BR>
&nbsp;&nbsp;27 iload_2<BR>
&nbsp;&nbsp;28 ireturn<BR>
}</TT>
</BLOCKQUOTE>
<P>
The left-hand column displays the offset of the instruction. <TT>Javap</TT>
automatically converts jump displacements to actual offsets. In
addition, it looks up constant pool references in order to output
the corresponding strings.
<H2><A NAME="GarbageCollection"><FONT SIZE=5 COLOR=#FF0000>Garbage
Collection</FONT></A></H2>
<P>
Java uses a multitiered security mechanism. The bytecode verifier
provides the lowest layer of  security. Above the verifier, the
security manager is the next sentry. In addition to these two
explicit checks, there are a number of language features that
provide security as well. Chief among these is the garbage collector.
<P>
Failing to free memory blocks or file handles is a common bug
in most modern programs. The problem quickly escalates until the
system crashes in some unforeseen manner. Java, like Smalltalk
before it, uses implicit garbage collection to solve the problem.
The virtual machine spec does not mandate a particular type of
garbage collection; it requires only that some type be used.
<P>
In Sun's runtime, a mark and sweep algorithm is used. This enables
the garbage collector to run incrementally in the background.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



