<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 14</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Advanced Image Processing</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ChapterProject" >Chapter Project</A>
<LI><A HREF="#ClassOrganization" >Class Organization</A>
<LI><A HREF="#HowItWorks" >How It Works</A>
<LI><A HREF="#FractalsandtheMandelbrotSet" >Fractals and the Mandelbrot Set</A>
<LI><A HREF="#UsingtheApplets" >Using the Applets</A>
<LI><A HREF="#TheMandelbrotClass" >The Mandelbrot Class</A>
<LI><A HREF="#CalculateFilterNotifyInterface" >CalculateFilterNotify Interface</A>
<LI><A HREF="#CalculatorProducerInterface" >CalculatorProducer Interface</A>
<LI><A HREF="#TheCalculatorFilterClass" >The CalculatorFilter Class</A>
<LI><A HREF="#TheCalculatorImageClass" >The CalculatorImage Class</A>
<LI><A HREF="#TheMandelAppClass" >The MandelApp Class</A>
<LI><A HREF="#TheMandelZoomAppClass" >The MandelZoomApp Class</A>
<LI><A HREF="#TheBmpImageClass" >The BmpImage Class</A>
<UL>
<LI><A HREF="#AutomaticDocumentationwithjavadoc" >Automatic Documentation with javadoc</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter's project, one that views the Mandelbrot set, gives
you examples of some of the more advanced concepts you have been
introduced to. The Mandelbrot set is the most spectacular example
of fractals, which represents one of the hot scientific topics
of recent years. With the applets in this chapter, you can view
or generate an original Mandelbrot image and zoom in and out of
it to produce new portions of the set.
<P>
Since the Mandelbrot set can take a while to generate-requiring
millions of calculations-it gives you a chance to combine threads
and image filters so you can view the set as it's being generated.
You might also want to save the Mandelbrot images. The BmpClass,
introduced in Part III, that converts a BMP formatted file into
a Java image, is enhanced so you can save the Mandelbrot data
as a BMP file. You can then view or modify it with any tool that
can handle the BMP format. Finally, the chapter concludes by showing
how you can auto-document the source of a Java class into a HTML
file. This can be viewed by a browser and has links to other classes.
<P>
Since you have already been introduced to most aspects of Java,
this chapter will jump straight into the project. Topics will
be introduced as appropriate.
<H2><A NAME="ChapterProject"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project</FONT></A></H2>
<P>
There are actually two applets in this chapter. The first applet,
MandelApp, is used to generate a full Mandelbrot set. The tools
and BMP file produced by this applet are input into the second
applet, called MandelZoomApp. This applet displays a Mandelbrot
set, then allows you to zoom (magnify) portions of the set so
you can inspect its fractal qualities. You can also return to
previous images and zoom into another area.
<P>
If you want to use the file-saving capabilities of this program,
you need to run it from something that does not prevent file saving,
such as the appletviewer program. You can run the program in a
browser like Netscape, though; it will be able to do everything
except save the images as files.
<H2><A NAME="ClassOrganization"><FONT SIZE=5 COLOR=#FF0000>Class
Organization</FONT></A></H2>
<P>
Table 14.1 lists the classes used in this chapter's applets. Most
of the classes are new, so their names are set in boldface type.
Existing classes that were modified have their names italicized.
<BR>
<P>
<CENTER><B>Table 14.1. Mandelbrot project classes and interfaces.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=169><I>Class/Interface</I></TD><TD WIDTH=421><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169>BmpImage</TD><TD WIDTH=421>For BMP-Image conversion.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>CalculatorFilter</B></TD><TD WIDTH=421>ImageFilter that produces updates of images as they are generated.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>CalculatorFilterNotify</B></TD><TD WIDTH=421>Interface that defines ways an ImageFilter can receive data updates.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>CalculatorImage</B></TD><TD WIDTH=421>Used to tie a calculation object, an image, and a CalculatorFilter together.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>CalculatorProducer</B></TD><TD WIDTH=421>Interface that defines a mechanism for establishing how an ImageFilter can update a calculation class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>MandelApp</B></TD><TD WIDTH=421>An Applet that produces a full Mandelbrot image and lets you save it to a file.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>MandelEntry</B></TD><TD WIDTH=421>Accessor class for keeping information about a Mandelbrot image.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>Mandelbrot</B></TD><TD WIDTH=421>A Thread that produces Mandelbrot data for the specified parameters. It implements CalculatorProducer to get started by a filter. It uses CalculatorFilterNotify to update a filter with new data.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=169><B>MandelZoomApp</B></TD><TD WIDTH=421>An Applet that displays the full Mandelbrot set and allows you to zoom in and out of the set.
</TD></TR>
</TABLE></CENTER>
<H2><A NAME="HowItWorks"><FONT SIZE=5 COLOR=#FF0000>How It Works</FONT></A>
</H2>
<P>
Because the Mandelbrot set can take quite a while to generate,
it was designed by combining a calculation thread with an image
filter so you can see the results as they are generated. However,
understanding how the classes interrelate is a little tricky.
Figure 14.1 shows the workflow involved in producing a Mandelbrot
image. Understanding this flow is the key to understanding this
project.
<P>
<A HREF="f14-1.gif" ><B>Figure 14.1 : </B><I>Workflow of producing a Mandelbrot image.</I></A>
<P>
The process begins when an applet displaying Mandelbrot sets constructs
a Mandelbrot object. (In this project, the two Applet classes
are MandelApp and MandelZoomApp.) The Mandelbrot object, in turn,
creates an instance of the CalculatorImage class. The Mandelbrot
set passes itself as a part of the CalculatorImage constructor.
It is referenced as a CalculatorProducer object, an interface
that the Mandelbrot class implements. This interface implementation
will be used to communicate with the image filter.
<P>
In the next step, the applet requests a Mandelbrot image. This
is initiated by calling the <TT>getImage()</TT>
method of the Mandelbrot object, which in turn leads to a call
to a like-named method of the CalculatorImage object. At this
point, the CalculatorImage object first creates a color palette
by using an instance of the ImageColorModel class, then creates
a MemoryImageSource object. This object, which implements ImageProducer,
produces an image initialized to all zeros (black); it's combined
with an instance of the CalculatorFilter class to produce a FilteredImageSource.
<P>
When the MemoryImageSource object produces its empty image, it
is passed to the CalculatorFilter, which takes the opportunity
to produce the calculated image. It does this by kicking off the
thread of the image to be calculated. The CalculatorFilter doesn't
know that it is the Mandelbrot set that's calculated-it just knows
that some calculation needs to occur in the CalculatorProducer
object in which it has a reference.
<P>
Once the Mandelbrot thread is started, it begins the long calculations
to produce a Mandelbrot set. Whenever it finishes a section of
the set, it notifies the filter with new data through the CalculatorFilterNotify
interface. The filter, in turn, lets the viewing applet know that
it has new data to display by updating the corresponding ImageConsumer,
which causes the applet's <TT>imageUpdate()</TT>
method to be called. This causes a repaint, and the new image
data to be displayed. This process repeats until the full image
is created.
<P>
As you have probably observed, this is a complicated process.
Although the mechanics of image processing were introduced in
Part III, it doesn't hurt to have another example. The Calculator
classes here are meant to provide a generic approach toward manipulating
images that need long calculations. You can replace the Mandelbrot
class with some other calculation thread that implements CalculatorProducer,
and everything should work. A good exercise would be to replace
Mandelbrot with another fractal calculation or some other scientific
imaging calculation (I found that replacing Mandelbrot with a
Julia fractal class calculation was very easy).
<H2><A NAME="FractalsandtheMandelbrotSet"><FONT SIZE=5 COLOR=#FF0000>Fractals
and the Mandelbrot Set</FONT></A></H2>
<P>
Before going into the internals of the classes that make up this
project, it's worth spending a couple of moments to understand
what's behind the images produced by the Mandelbrot class.
<P>
In the 1970s, Benoit Mandelbrot at IBM was using computers to
study curves generated by iterations of complex formulas. He found
that these curves had unusual characteristics, one of which is
called <I>self-similarity</I>. The curves have a series of patterns
that repeat themselves when inspected more closely.
<P>
One of the characteristics of the curves Mandelbrot studied was
that they could be described as having a certain dimensional quality
that Mandelbrot termed &quot;fractal.&quot; One of the fractals
that Mandelbrot was investigating is called a <I>Julia set</I>.
By mapping the set in a certain way, Mandelbrot came across a
set that turned out to include all the Julia sets-a kind of a
master set that was deemed the <I>Mandelbrot set</I>. This set
has several spectacular features, all of them beautiful. The most
striking of these is its self-similarity and a extraordinary sensitivity
to initial conditions. As you explore the Mandelbrot set, you
will be amazed by both its seeming chaos and exquisite order.
<P>
Figure 14.2 shows the famous Mandelbrot set, produced by this
chapter's MandelApp applet. The figures in this chapter show the
kind of images that appear when you zoom into various places in
this set. The Mandelbrot set is based on a seemingly simple iterated
function, shown in Formula 14.1.
<P>
<A HREF="f14-2.gif" ><B>Figure 14.2 : </B><I>The full Mandelbrot set image.</I></A>
<HR>
<BLOCKQUOTE>
<B>Formula 14.1. Formula for calculating the Mandelbrot set.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>z</FONT><FONT SIZE=1 FACE="Courier">n+1</FONT>=z</FONT><FONT SIZE=1 FACE="Courier">n2</FONT>
+ c</TT>
</BLOCKQUOTE>
<HR>
<P>
In Formula 14.1, <TT>z</TT> and <TT>c</TT>
are complex numbers. The Mandelbrot set is concerned with what
happens when <TT>z0</TT> is zero and
<TT>c</TT> is set over a range of
values. The real part of <TT>c</TT>
is set to the x-axis, and the complex portion corresponds to the
y-axis. A color is mapped to each point based on how quickly the
corresponding value of <TT>c</TT>
causes the iteration to reach infinity. The process of &quot;zooming&quot;
in and out of the Mandelbrot set is equivalent to defining what
ranges of <TT>c</TT> are going to
be explored. It is amazing that something so simple can yield
patterns so sophisticated!<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you are more interested in chaos and fractals, there are a lot of places to turn. <I>Chaos</I> by James Gleick (Penguin, 1987) is a layman's introduction to the ideas and discoveries that gave rise to chaos theory and the study of fractals. Mandelbrot's<I> The Fractal Geometry of Nature</I> (W.H. Freeman, 1983) lays out his ideas on fractals and nature. For a rigorous mathematical treatment of fractals, see the beautiful book <I>Fractals Everywhere</I> (Academic Press, 1988), written by one of the foremost figures in fractals, Michael Barnsley. Among other things, Barnsley is a major innovator on how to use fractal geometrics to achieve high rates of data compression. For a no-nonsense approach to writing programs that display fractals, see <I>Fractal Programming in C</I> by Roger T. Stevens (M&amp;T Books, 1989). The algorithms for the Mandelbrot set were developed from this book. The C programs in this book map very easily to Java-except for the underlying graphics tools, which were developed for MS-DOS. However, the image calculation classes created in this chapter aim to fill this gap. With Stevens's book and these classes, you should be able to move his C code right over to Java and begin exploring the amazing world of fractals!
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="UsingtheApplets"><FONT SIZE=5 COLOR=#FF0000>Using
the Applets</FONT></A></H2>
<P>
There are two applets in this chapter. The first applet, MandelApp,
generates the full Mandelbrot set. This will take a little while,
depending on your computer; for example, on a 486DX2-50 PC, it
takes a couple of minutes. When the image is complete, indicated
by a message on the browser's status bar, you can save the image
to a BMP formatted file by clicking anywhere on the applet's display
area. The file will be called mandel.bmp. Remember to run this
applet from a program, such as appletviewer, that lets applets
write to disk.
<P>
The other applet, MandelAppZoom, is more full-featured. It begins
by loading the Mandelbrot bitmap specified by an HTML applet parameter
tag. The default <TT>mandel1</TT>
corresponds to a BMP file and a data file that specifies x-y parameter
values-included on this book's CD-ROM.
<P>
Once the image is up, you can pick regions to zoom in on by clicking
on a point in the image, then dragging the mouse to the endpoint
of the region you want to display. Enter <TT>z</TT>
or <TT>Z</TT> on the keyboard, and
the applet creates the image representing the new region of the
Mandelbrot set. The key to this applet is patience! The calculations
can take a little while to set up and run. The applet tries to
help your patience by updating the status bar to indicate what
is going on. Furthermore, the image filter displays each column
of the set as the calculations advance.
<P>
You might select a region that doesn't appear to have anything
interesting to show when you zoom in on it. You can stop a calculation
in the middle by entering <TT>a</TT>
or <TT>A</TT> on the keyboard. The
applet will take a moment to wrap up, but then you can proceed.
When you are having problems finding an interesting region to
look at, try increasing the size of the highlighted area. This
will yield a bigger area that is generated, giving you a better
feel for what should be inspected. You get the best results by
working with medium-sized highlighted regions, rather than large
or small ones.
<P>
Figures 14.3 to 14.6 show what some of the zoomed-in regions of
the Mandelbrot set look like. Figure 14.3 is a large area picked
above the black &quot;circles&quot; of the full Mandelbrot set;
Figure 14.5 explores an area between two of the black areas. The
richest displays seem to occur at the boundaries of the black
areas. The black color indicates that the particular value takes
a long time to reach infinity. Consequently, these are also the
regions that take the longest to calculate. You get what you pay
for!
<P>
<A HREF="f14-3.gif" ><B>Figure 14.3 : </B><I>Zoom in over block regions of Figure 14.2.</I></A>
<P>
<A HREF="f14-4.gif" ><B>Figure 14.4 : </B><I>Zoom in of Figure 14.3.</I></A>
<P>
The zoom applet maintains a cache of processed images so you can
move back and forth among the processed images. Table 14.2 lists
the text codes for using the zoom applet.
<P>
<A HREF="f14-5.gif" ><B>Figure 14.5 : </B><I>Zoom in between black regions of Figure 14.2</I></A><I>.</I>
<P>
<A HREF="f14-6.gif" ><B>Figure 14.6 : </B><I>Zoom in of Figure 14.5.</I></A>
<BR>
<P>
<CENTER><B>Table 14.2. Codes for controlling the Mandelbrot applet.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><I>Characters</I></CENTER></TD><TD WIDTH=355><I>Action</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>A or a</TT></CENTER>
</TD><TD WIDTH=355>Abort current Mandelbrot calculation.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>B or b</TT></CENTER>
</TD><TD WIDTH=355>Go to previous image.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>F or f</TT></CENTER>
</TD><TD WIDTH=355>Go to next image.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>C or c</TT></CENTER>
</TD><TD WIDTH=355>Remove all but full image from memory.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>N or n</TT></CENTER>
</TD><TD WIDTH=355>Go to next image.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>P or p</TT></CENTER>
</TD><TD WIDTH=355>Go to previous image.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><CENTER><TT>S or s</TT></CENTER>
</TD><TD WIDTH=355>Save the current image to a BMP file prefixed by <TT>tempMandel</TT>.
</TD></TR>
<TR VALIGN=TOP>`<TD WIDTH=97><CENTER><TT>Z or z</TT></CENTER>
</TD><TD WIDTH=355>Zoom in on currently highlighted region.</TD>
</TR>
</TABLE></CENTER>
<H2><A NAME="TheMandelbrotClass"><FONT SIZE=5 COLOR=#FF0000>The
Mandelbrot Class</FONT></A></H2>
<P>
The Mandelbrot class, shown in Listing 14.1, calculates the Mandelbrot
set. It implements the Runnable interface, so it can run as a
thread, and also implements the CalculatorProducer interface,
so it can update an image filter of progress made in its calculations.
<P>
There are two constructors for the Mandelbrot class. The default
constructor produces the full Mandelbrot set and takes the dimensions
of the image to calculate. The Real and Imagine variables in the
constructors and the <TT>run()</TT>
method are used to map the x-y axis to the real and imaginary
portions of <TT>c</TT> in Formula
14.1. The other constructor is used to zoom in on a user-defined
mapping.
<P>
A couple of the other variables are worth noting. The variable
<TT>maxIterations</TT> represents
when to stop calculating a number. If this number, set to <TT>512</TT>,
is reached, then the starting value of <TT>c</TT>
takes a long time to head toward infinity. The variable <TT>maxSize</TT>
is a simpler indicator of how quickly the current value grows.
How the current calculation is related to these variables is mapped
to a specific color; the higher the number, the slower the growth.
If you have a fast computer, you can adjust these variables to
get a richer or duller expression of the Mandelbrot set.
<P>
Once the thread is started (by the CalculatorFilter object through
the <TT>start()</TT> method), the
<TT>run()</TT> method calculates the
Mandelbrot values and stores a color corresponding to the growth
rate of the current complex number into a pixel array. When a
column is complete, it uses the CalculateFilterNotify to let the
related filter know that new data has been produced. It also checks
to see whether you want to abort the calculation. Note how it
synchronizes the <TT>stopCalc</TT>
boolean object in the <TT>run()</TT>
and <TT>stop()</TT> methods.
<P>
The calculation can take a while to complete. Still, it takes
only a couple of minutes on a 486-based PC. This performance is
quite a testament to Java! With other interpreted, portable languages
you would probably be tempted to use the reset button because
the calculations would take so long. With Java you get fast visual
feedback on how the set unfolds.
<P>
A good exercise is to save any partially developed Mandelbrot
set; you can use the <TT>saveBMP()</TT>
method here. You also need some kind of data file to indicate
where the calculation was stopped.
<HR>
<BLOCKQUOTE>
<B>Listing 14.1. The Mandelbrot class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.image.*;<BR>
import java.awt.Image;<BR>
import java.lang.*;<BR>
<BR>
// Class for producing a Mandelbrot set image...<BR>
public class Mandelbrot implements Runnable, CalculatorProducer
{<BR>
&nbsp;&nbsp;&nbsp;int width;&nbsp;&nbsp;// The dimensions of the
image...<BR>
&nbsp;&nbsp;&nbsp;int height;<BR>
&nbsp;&nbsp;&nbsp;CalculateFilterNotify filter; // Keeps track
of image production...<BR>
&nbsp;&nbsp;&nbsp;int pix[]; // Pixels used to construct image...
<BR>
&nbsp;&nbsp;&nbsp;CalculatorImage img;<BR>
&nbsp;&nbsp;&nbsp;// General Mandelbrot parameters...<BR>
&nbsp;&nbsp;&nbsp;int numColors = 256;<BR>
&nbsp;&nbsp;&nbsp;int maxIterations = 512;<BR>
&nbsp;&nbsp;&nbsp;int maxSize = 4;<BR>
&nbsp;&nbsp;&nbsp;double RealMax,ImagineMax,RealMin,ImagineMin;&nbsp;&nbsp;//
Define sizes to build...<BR>
&nbsp;&nbsp;&nbsp;private Boolean stopCalc = new Boolean(false);&nbsp;&nbsp;//
Stop calculations...<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create standard Mandelbrot set<BR>
&nbsp;&nbsp;&nbsp;public Mandelbrot(int width,int height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.height = height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RealMax = 1.20;&nbsp;&nbsp;//
Default starting sizes...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RealMin = -2.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImagineMax = 1.20;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImagineMin = -1.20;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create zoom of Mandelbrot set<BR>
&nbsp;&nbsp;&nbsp;public Mandelbrot(int width,int height,double
RealMax,double RealMin,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;double ImagineMax,double ImagineMin) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.height = height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.RealMax = RealMax;&nbsp;&nbsp;//
Default starting sizes...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.RealMin = RealMin;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ImagineMax = ImagineMax;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ImagineMin = ImagineMin;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Start producing the Mandelbrot set...<BR>
&nbsp;&nbsp;&nbsp;public Image getImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = new CalculatorImage(width,height,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img.getImage();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Start thread to produce data...<BR>
&nbsp;&nbsp;&nbsp;public void start(int pix[],CalculateFilterNotify
filter) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pix = pix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.filter = filter;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Thread(this).start();
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// See if user wants to stop before completion...
<BR>
&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (stopCalc) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopCalc
= Boolean.TRUE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;GOT
STOP!&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create data here...<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Establish Mandelbrot parameters...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double Q[] = new double[height];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pixdata is for image filter
updates...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int pixdata[] = new int[height];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double P,diffP,diffQ, x, y,
x2, y2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int color, row, column,index;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;RealMax
= &quot; + RealMax + &quot; RealMin = &quot; + RealMin +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
ImagineMax = &quot; + ImagineMax + &quot; ImagineMin = &quot;
+ ImagineMin);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Setup calculation parameters...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffP = (RealMax - RealMin)/(width);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffQ = (ImagineMax - ImagineMin)/(height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q[0] = ImagineMax;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Setup delta parameters...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (row = 1; row &lt; height;
row++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q[row] =
Q[row-1] - diffQ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = RealMin;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start calculating!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (column = 0; column &lt;
width; column++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (row
= 0; row &lt; height; row++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
= y = x2 = y2 = 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((color &lt; maxIterations) &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x2
+ y2) &lt; maxSize)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2
= x * x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y2
= y * y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
= (2*x*y) + Q[row];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
= x2 - y2 + P;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++color;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
plot...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index
= (row * width) + column;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index]
= (int)(color % numColors);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixdata[row]
= pix[index];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update
column after each iteration...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter.dataUpdateColumn(column,pixdata);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P += diffP;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if
we were told to stop...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized
(stopCalc) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(stopCalc == Boolean.TRUE) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column
= width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;RUN:
Got stop calc!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end sync<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end col<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Tell filter that we're
done producing data...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;FILTER:
Data Complete!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter.setComplete();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Save the Mandelbrot set as a BMP file...
<BR>
&nbsp;&nbsp;&nbsp;public void saveBMP(String filename) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img.saveBMP(filename,pix);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="CalculateFilterNotifyInterface"><FONT SIZE=5 COLOR=#FF0000>CalculateFilterNotify
Interface</FONT></A></H2>
<P>
The CalculateFilterNotify interface defines the methods needed
to update an image filter that works with a calculation thread.
As shown in Listing 14.2, the &quot;data&quot; methods are used
for conveying a new batch of data to the filter. The <TT>setComplete()</TT>
method indicates that the calculations are complete.
<HR>
<BLOCKQUOTE>
<B>Listing 14.2. The CalculateFilterNotify interface.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/* Interface for defining methods for
updating a<BR>
&nbsp;&nbsp;&nbsp;Calculator Filter... */<BR>
public interface CalculateFilterNotify {<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdate();&nbsp;&nbsp;&nbsp;//
Update everything...<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdateRow(int row); // Update
one row...<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdateColumn(int col,int pixdata[]);&nbsp;&nbsp;//
Update one column...<BR>
&nbsp;&nbsp;&nbsp;public void setComplete();<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="CalculatorProducerInterface"><FONT SIZE=5 COLOR=#FF0000>CalculatorProducer
Interface</FONT></A></H2>
<P>
The CalculatorProducer interface, as shown in Listing 14.3, defines
the method called when a calculation filter is ready to kick off
a thread that produces the data used to generate an image. The
CalculateFilterNotify object passed to the <TT>start()</TT>
method is called by the producer whenever new data is yielded.
<HR>
<BLOCKQUOTE>
<B>Listing 14.3. The CalculatorProducer interface.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Interface for a large calculation
to produce image...<BR>
interface CalculatorProducer {<BR>
&nbsp;&nbsp;&nbsp;public void start(int pix[],CalculateFilterNotify
cf);<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheCalculatorFilterClass"><FONT SIZE=5 COLOR=#FF0000>The
CalculatorFilter Class</FONT></A></H2>
<P>
The CalculatorFilter class in Listing 14.4 is a subclass of ImageFilter.
Its purpose is to receive image data produced by some long calculation
(like the Mandelbrot set) and update any consumer of the the new
data's image. The CalculatorProducer, indicated by variable <TT>cp</TT>,
is what produces the data.
<P>
Since the ImageFilter class was explained in detail in Part III,
issues related to this class are not repeated here. However, a
couple of things should be pointed out. When the image is first
requested, the filter gets the dimensions the consumer wants by
a call of the <TT>setDimensions()</TT>
method. At this point, the CalculatorFilter will allocate a large
array holding the color values for each pixel.
<P>
When the original ImageProducer is finished creating the original
image, the filter's <TT>imageComplete()</TT>
method will be called, but the filter needs to override this method.
In this case, the CalculatorFilter will start the CalculatorProducer
thread, passing it the pixel array to put in its updates. Whenever
the CalculatorProducer has new data, it will call one of the four
methods specified by the CalculateFilterNotify interface: <TT>dataUpdate()</TT>,
<TT>dataUpdateRow()</TT>, <TT>dataUpdateColumn()</TT>,
or <TT>setComplete()</TT>. (The <TT>dataUpdateColumn()</TT>
method is called by the Mandelbrot calculation since it operates
on a column basis.) In each of these cases, the filter updates
the appropriate consumer pixels by using the <TT>setPixels()</TT>
method, then calls the consumer's <TT>imageComplete()</TT>
method to indicate the nature of the change. For the three &quot;data&quot;
methods, the updates are only partial, so a SINGLEFRAMEDONE flag
is sent. The <TT>setComplete()</TT>
method, on the other hand, indicates that everything is complete,
so it sets a STATICIMAGEDONE flag.
<HR>
<BLOCKQUOTE>
<B>Listing 14.4. The CalculatorFilter class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.image.*;<BR>
import java.awt.Image;<BR>
import java.awt.Toolkit;<BR>
import java.lang.*;<BR>
<BR>
public class CalculatorFilter extends ImageFilter<BR>
 implements CalculateFilterNotify {<BR>
&nbsp;&nbsp;&nbsp;private ColorModel defaultRGBModel;<BR>
&nbsp;&nbsp;&nbsp;private int width, height;<BR>
&nbsp;&nbsp;&nbsp;private int pix[];<BR>
&nbsp;&nbsp;&nbsp;private boolean complete = false;<BR>
&nbsp;&nbsp;&nbsp;private CalculatorProducer cp;<BR>
&nbsp;&nbsp;&nbsp;private boolean cpStart = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;public CalculatorFilter(ColorModel cm,CalculatorProducer
cp) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultRGBModel = cm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cp = cp;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void setDimensions(int width, int height)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.height = height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix = new int[width * height];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.setDimensions(width,height);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void setColorModel(ColorModel model)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.setColorModel(defaultRGBModel);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void setHints(int hints) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.setHints(ImageConsumer.RANDOMPIXELORDER);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void resendTopDownLeftRight(ImageProducer
p) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void setPixels(int x, int y, int w, int
h,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ColorModel model, int pixels[],int
off,int scansize) {<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void imageComplete(int status) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (!cpStart) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpStart = true;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataUpdate();&nbsp;&nbsp;//
Show empty pixels...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cp.start(pix,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (complete)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.imageComplete(ImageConsumer.STATICIMAGEDONE);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called externally to notify that more data
has been created<BR>
&nbsp;&nbsp;&nbsp;// Notify consumer so they can repaint...<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdate() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.setPixels(0,0,width,height,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultRGBModel,pix,0,width);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.imageComplete(ImageConsumer.SINGLEFRAMEDONE);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// External call to update a specific pixel
row...<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdateRow(int row) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // The key thing here is the second to
last parameter (offset)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // which states where to start getting
data from the pix array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.setPixels(0,row,width,1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultRGBModel,pix,(width
* row),width);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.imageComplete(ImageConsumer.SINGLEFRAMEDONE);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// External call to update a specific pixel
column...<BR>
&nbsp;&nbsp;&nbsp;public void dataUpdateColumn(int col,int pixdata[])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // The key thing here is the second to
last parameter (offset)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // which states where to start getting
data from the pix array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.setPixels(col,0,1,height,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultRGBModel,pixdata,0,1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; consumer.imageComplete(ImageConsumer.SINGLEFRAMEDONE);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called from external calculating program
when data has<BR>
&nbsp;&nbsp;&nbsp;// finished being calculated...<BR>
&nbsp;&nbsp;&nbsp;public void setComplete() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.setPixels(0,0,width,height,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultRGBModel,pix,0,width);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer.imageComplete(ImageConsumer.STATICIMAGEDONE);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheCalculatorImageClass"><FONT SIZE=5 COLOR=#FF0000>The
CalculatorImage Class</FONT></A></H2>
<P>
The CalculatorImage class, shown in Listing 14.5, is the glue
between the CalculatorProducer class that produces the image data
and the CalculatorFilter that manages it. When an image is requested
with the <TT>getImage()</TT> method,
the CalculatorImage creates a color palette through an instance
of the ImageColorModel class, then creates a MemoryImageSource
object. This ImageProducer object produces an image initialized
to all zeros (black). It is combined with an instance of the CalculatorFilter
class to produce a FilteredImageSource. When the <TT>createImage()</TT>
method of the Toolkit is called, production of the calculated
image begins.
<P>
The color palette is a randomly generated series of pixel values.
Depending on your luck, these colors can be attractive or uninspiring.
The <TT>createPalette()</TT> method
is a good place to create a custom set of colors for this applet,
if you want to have some control over its appearance. You should
replace the random colors with hard-coded RGB values, and you
might want to download a URL file that specifies a special color
mapping.
<HR>
<BLOCKQUOTE>
<B>Listing 14.5. The CalculatorImage class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This class takes a CalculatorProducer
and sets up the<BR>
// environment for creating a calculated image.&nbsp;&nbsp;Ties
the<BR>
// producer to the CalculatorFilter so incremental updates can
<BR>
// be made...<BR>
public class CalculatorImage {<BR>
&nbsp;&nbsp;&nbsp;int width;&nbsp;&nbsp;// The dimensions of the
image...<BR>
&nbsp;&nbsp;&nbsp;int height;<BR>
&nbsp;&nbsp;&nbsp;CalculatorProducer cp;&nbsp;&nbsp;// What produces
the image data...<BR>
&nbsp;&nbsp;&nbsp;IndexColorModel palette;&nbsp;&nbsp;// The colors
of the image...<BR>
&nbsp;&nbsp;&nbsp;// Create Palette only once per session...<BR>
&nbsp;&nbsp;&nbsp;static IndexColorModel prvPalette = null;<BR>
&nbsp;&nbsp;&nbsp;int numColors = 256;&nbsp;&nbsp;// Number of
colors in palette...<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Use defines how big of an image they want...
<BR>
&nbsp;&nbsp;&nbsp;public CalculatorImage(int width,int height,CalculatorProducer
cp) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.height = height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cp = cp;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Start producing the Calculator image...<BR>
&nbsp;&nbsp;&nbsp;public synchronized Image getImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Hook into the filter...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createPalette();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer p = new FilteredImageSource(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new MemoryImageSource(width,height,palette,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new
int[width * height]),0,width),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
CalculatorFilter(palette,cp));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Return the image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Toolkit.getDefaultToolkit().createImage(p);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create a 256 color palette...<BR>
&nbsp;&nbsp;&nbsp;// Use Default color model...<BR>
&nbsp;&nbsp;&nbsp;void createPalette() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Create palette only once per session...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (prvPalette != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;palette
= prvPalette;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Create a palette out of random RGB
combinations...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; byte blues[], reds[], greens[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp; reds = new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp; blues = new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp; greens = new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // First and last entries are black and
white...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; blues[0] = reds[0] = greens[0] = (byte)0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; blues[255] = reds[255] = greens[255]
= (byte)255;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Fill in other entries...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; for ( int x = 1; x &lt; 254; x++ ){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reds[x] = (byte)(255 * Math.random());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blues[x] = (byte)(255 * Math.random());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greens[x] = (byte)(255 * Math.random());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Create Index Color Model...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; palette = new IndexColorModel(8,256,reds,greens,blues);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; prvPalette = palette;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Save the image set as a BMP file...<BR>
&nbsp;&nbsp;&nbsp;public void saveBMP(String filename,int pix[])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage.saveBitmap(filename,palette,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException ioe) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
saving file!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheMandelAppClass"><FONT SIZE=5 COLOR=#FF0000>The
MandelApp Class</FONT></A></H2>
<P>
The MandelApp class, shown in Listing 14.6, creates and displays
the full Mandelbrot set; the end result is shown in Figure 14.2.
An instance of the Mandelbrot class is created in the <TT>init()</TT>
method. Whenever the Mandelbrot calculation has produced some
new data, it calls the ImageObserver-based method, <TT>imageUpdate()</TT>.
This will probably result in the applet being repainted to show
the new data. If the image is complete, an internal flag is set.
After this, if you click the mouse, the image will be saved to
a BMP formatted file called mandel.bmp.
<HR>
<BLOCKQUOTE>
<B>Listing 14.6. The MandelApp class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
<BR>
// This applet displays the Mandlebrot set through<BR>
// use of the Mandelbrot class...<BR>
public class MandelApp extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Image im;&nbsp;&nbsp;&nbsp;// Image that displays
Mandelbrot set...<BR>
&nbsp;&nbsp;&nbsp;Mandelbrot m; // Creates the Mandelbrot image...
<BR>
&nbsp;&nbsp;&nbsp;int NUMCOLS = 640;&nbsp;&nbsp;&nbsp;// Dimensions
image display...<BR>
&nbsp;&nbsp;&nbsp;int NUMROWS = 350;<BR>
&nbsp;&nbsp;&nbsp;boolean complete = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set up the Mandelbrot set...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = new Mandelbrot(NUMCOLS,NUMROWS);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;im = m.getImage();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Will get updates as set is being created.
<BR>
&nbsp;&nbsp;&nbsp;// Repaint when they occur...<BR>
&nbsp;&nbsp;&nbsp;public boolean imageUpdate(Image im,int flags,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x, int y, int w, int h)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; FRAMEBITS)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Calculating...&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; ALLBITS)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Image
Complete!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Paint on update...<BR>
&nbsp;&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public synchronized void paint(Graphics g) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawImage(im,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Save Bitmap on mouse down when image complete...
<BR>
&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event evt,int x, int
y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (complete)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Save
Bitmap...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.saveBMP(&quot;mandel.bmp&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Bitmap
saved!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheMandelZoomAppClass"><FONT SIZE=5 COLOR=#FF0000>The
MandelZoomApp Class</FONT></A></H2>
<P>
Listing 14.7 shows the MandelZoomApp class, which represents this
chapter's main applet; its function was described earlier, in
the section &quot;Using the Applets.&quot; See this section and
Table 14.1 for how to use the applet.
<P>
The most interesting features in the code are the routines for
marking the region to be highlighted. Each pixel on the displayed
Mandelbrot image maps an x-y value to a real-imaginary value of
the <TT>c</TT> value of the Mandelbrot
formula shown in Formula 14.1. Whenever you move the cursor, the
current real-imaginary values are shown in the browser's status
bar. When you highlight an area to zoom in on, you are really
picking a range of <TT>c</TT> values
to be explored. All the double variables are used for tracking
this range of values. These values are read in at initialization
by the <TT>loadParameters()</TT> method
to match the bitmap that's displayed. You can specify other Mandelbrot
BMP files and corresponding data files by changing the <TT>filename</TT>
parameter of the applet's <TT>&lt;APPLET&gt;</TT>
tag.
<P>
The <TT>Zoom()</TT> method takes the
currently highlighted range and brings up a new Mandelbrot image
that corresponds to this range. It uses the same calculation-image
filtering techniques that the MandelApp class does.
<HR>
<BLOCKQUOTE>
<B>Listing 14.7. The MandelZoomApp class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This applet displays the Mandelbrot
set bitmap specified<BR>
// in the APPLET tag parameters.&nbsp;&nbsp;You can then zoom
and in<BR>
// and out of the bitmap by dragging a region to paint.<BR>
// And then clicking on the appropriate option...<BR>
// Z or z - Zoom<BR>
// S or s - Save.<BR>
public class MandelZoomApp extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Image img;<BR>
&nbsp;&nbsp;&nbsp;boolean zoomOn = false;<BR>
&nbsp;&nbsp;&nbsp;double XLeft,XRight,YTop,YBottom,XDelta,YDelta;
<BR>
&nbsp;&nbsp;&nbsp;double currentX,currentY;<BR>
&nbsp;&nbsp;&nbsp;double startX,startY,endX,endY;&nbsp;&nbsp;//
Zooming coordinates...<BR>
&nbsp;&nbsp;&nbsp;Rectangle markingRectangle;&nbsp;&nbsp;// Zooming
rectangle...<BR>
&nbsp;&nbsp;&nbsp;Mandelbrot m; // Creates the Mandelbrot image...
<BR>
&nbsp;&nbsp;&nbsp;int NUMCOLS = 640;&nbsp;&nbsp;&nbsp;// Dimensions
image display...<BR>
&nbsp;&nbsp;&nbsp;int NUMROWS = 350;<BR>
&nbsp;&nbsp;&nbsp;boolean complete = false;<BR>
&nbsp;&nbsp;&nbsp;// Array for keeping track of Mandelbrot entries...
<BR>
&nbsp;&nbsp;&nbsp;MandelEntry me[];<BR>
&nbsp;&nbsp;&nbsp;int lastIndex;&nbsp;&nbsp;// Top of array...
<BR>
&nbsp;&nbsp;&nbsp;int currentIndex;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set up the Mandelbrot set specified in the
parameters...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get parameter of bitmap
to display...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String filename;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((filename = getParameter(&quot;filename&quot;))
== null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename
= &quot;mandel1&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load the bitmap...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadBitmap(filename);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Initialize Mandelbrot array...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me = new MandelEntry[40];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me[0] = new MandelEntry(null,img,XLeft,XRight,YTop,YBottom);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastIndex = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentIndex = 0;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// ZOOM onto Mandelbrot set if all is good...
<BR>
&nbsp;&nbsp;&nbsp;void Zoom() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// No Zooming if off or no
rectangle...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!zoomOn) || (markingRectangle
== null)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Nothing
marked or Zooming disable...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if Mandelbrot table
is full...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((lastIndex + 1) &gt;=
me.length) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Mandelbrot
table full. Clear with C before zooming&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;ZOOM: SX=&quot;
+ startX + &quot; SY=&quot; + startY + &quot; EX=&quot; + endX
+ &quot; EY=&quot; + endY);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load new Mandelbrot...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoomOn = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle = null; //
Reset marking rectangle...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = new Mandelbrot(NUMCOLS,NUMROWS,endX,startX,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endY,startY);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = m.getImage();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store in Mandelbrot table...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XLeft = startX;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XRight = endX;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YTop = startY;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YBottom = endY;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDelta = Math.abs(XRight -
XLeft);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YDelta = Math.abs(YBottom
- YTop);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++lastIndex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me[lastIndex] = new MandelEntry(m,img,startX,endX,startY,endY);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentIndex = lastIndex;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Calculating...&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Paint on update...<BR>
&nbsp;&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public synchronized void paint(Graphics g) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (img == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Show image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(img,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Show marking rectangle
if exists...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (markingRectangle != null)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawRect(markingRectangle.x,markingRectangle.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle.width,markingRectangle.height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Will get updates as set is being created.
<BR>
&nbsp;&nbsp;&nbsp;// Repaint when they occur...<BR>
&nbsp;&nbsp;&nbsp;public boolean imageUpdate(Image im,int flags,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x, int y, int w, int h)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; FRAMEBITS)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; ALLBITS)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Image
Complete!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoomOn =
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Load a bitmap and accompanying data file...
<BR>
&nbsp;&nbsp;&nbsp;void loadBitmap(String filename) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Zoom is false unless both
succeed...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoomOn = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle = null; //
Reset marking rectangle...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load the bitmap...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Load
image...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
producer = BmpImage.getImageProducer(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDocumentBase(),
filename + &quot;.bmp&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = createImage(producer);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Image
loaded...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (AWTException e){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Cannot
open file &quot; + filename);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Load the zoom parameters.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Turn Zoom on if all works...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadParameters(filename);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoomOn =
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Cannot
load parameter data. &quot; + e.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Load the parameters.&nbsp;&nbsp;Throw IO
Exception...<BR>
&nbsp;&nbsp;&nbsp;public void loadParameters(String filename)
throws IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create URL for data...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URL u;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = new URL(getDocumentBase(),filename
+ &quot;.dat&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Bad Data URL&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IOException(&quot;Bad
URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Now load the data by opening up a stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// to the URL...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream dis = new DataInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new BufferedInputStream(u.openStream()
) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Read only the first line...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; String param = dis.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Tokenize out the boundary values....
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; StringTokenizer s = new StringTokenizer(param,&quot;,&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XLeft = Double.valueOf(s.nextToken()).doubleValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XRight = Double.valueOf(s.nextToken()).doubleValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; YTop = Double.valueOf(s.nextToken()).doubleValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; YBottom = Double.valueOf(s.nextToken()).doubleValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDelta = Math.abs(XRight
- XLeft);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; YDelta = Math.abs(YBottom
- YTop);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; catch (NumberFormatException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IOException(&quot;Improperly
formatted data...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; catch (NoSuchElementException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IOException(&quot;Improperly
formatted data...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Track mouse to show fractal values and to
<BR>
&nbsp;&nbsp;&nbsp;// mark area to zoom<BR>
&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event evt) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; switch(evt.id) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.KEY_PRESS:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Z or z means Zoom<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'z') || (evt.key == 'Z'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zoom();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
S or s means Save<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 's') || (evt.key == 'S'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveFile();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
A or a means Abort Zoom calculation...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'a') || (evt.key == 'A')) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(m != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Aborting
calculation...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
P or p means previous image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'p') || (evt.key == 'P'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previousImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
B or b means previous image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'B') || (evt.key == 'b'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previousImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
N or n means next image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'N') || (evt.key == 'n'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
F or f means next image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'F') || (evt.key == 'f'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
C or c means clear images<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((evt.key == 'C') || (evt.key == 'c'))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Mouse
clicks. Start marking...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.MOUSE_DOWN:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startMarking(evt.x,evt.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.MOUSE_DRAG:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dragMarking(evt.x,evt.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.MOUSE_UP:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopMarking(evt.x,evt.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Event.MOUSE_MOVE:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showPosition(evt.x,evt.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Save the image as a file...<BR>
&nbsp;&nbsp;&nbsp;void saveFile() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Don't save if we are loading...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!complete)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get Mandelbrot reference,
if exists...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mandelbrot mb = me[currentIndex].getMandelbrot();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mb == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Cannot
save. Not generated in this session&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Generate the filename...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String filename = &quot;tempMandel&quot;
+ (currentIndex + 1) + &quot;.bmp&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Security test...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.getSecurityManager().checkWrite(filename);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (SecurityException e)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Write
not permitted!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Save the image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Saving image
as &quot; + filename + &quot;...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mb.saveBMP(filename);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Image saved
as &quot; + filename);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Routines for moving through Mandelbrot table...
<BR>
&nbsp;&nbsp;&nbsp;// Load previous image...<BR>
&nbsp;&nbsp;&nbsp;void previousImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nothing if we are loading...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!complete)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do nothing if at top index...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (currentIndex == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;At
Top index&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go to previous image...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reloadImage(currentIndex -
1);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Load next image...<BR>
&nbsp;&nbsp;&nbsp;void nextImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nothing if we are loading...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!complete)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do nothing if at last index...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (currentIndex == lastIndex)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;At
Last index&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go to next image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reloadImage(currentIndex +
1);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Reload index from Mandelbrot array...<BR>
&nbsp;&nbsp;&nbsp;void reloadImage(int index) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showMsg(&quot;Reloading image...&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentIndex = index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zoomOn = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle = null; //
Reset marking rectangle...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get data from Mandelbrot
table...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img = me[currentIndex].getImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XLeft = me[currentIndex].getXLeft();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XRight = me[currentIndex].getXRight();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YTop = me[currentIndex].getYTop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YBottom = me[currentIndex].getYBottom();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDelta = Math.abs(XRight -
XLeft);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YDelta = Math.abs(YBottom
- YTop);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Remove everything but first image from stack...
<BR>
&nbsp;&nbsp;&nbsp;void clearImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= lastIndex;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me[i] =
null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go back to first image...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastIndex = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reloadImage(0);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// ************************************<BR>
&nbsp;&nbsp;&nbsp;// Routines for mouse tracking...<BR>
&nbsp;&nbsp;&nbsp;// ************************************<BR>
&nbsp;&nbsp;&nbsp;boolean TrackingOn = false;<BR>
&nbsp;&nbsp;&nbsp;int leftX,topY;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Start marking a zoom rectangle, erase existing
one...<BR>
&nbsp;&nbsp;&nbsp;void startMarking(int x,int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get current positions...
Clear marking if invalid...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!showPosition(x,y)) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrackingOn
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Else, start marking...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrackingOn = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startX = currentX;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startY = currentY;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endX = currentX;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endY = currentY;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftX = x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topY = y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set marking rectangle and
repaint...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle = new Rectangle(x,y,1,1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Expand square of dragging unless invalid...
<BR>
&nbsp;&nbsp;&nbsp;void dragMarking(int x,int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get current positions...
Clear marking if invalid...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean good = showPosition(x,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if other marking conditions
hold.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Such as going in a bad
direction...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (good) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!TrackingOn)
|| (x &lt; leftX) || (y &lt; topY))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Clear out if marking is
bad...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!good) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrackingOn
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set new marking rectangle
and repaint...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endX = currentX;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endY = currentY;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle = new Rectangle(leftX,topY,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
- leftX,y - topY);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint(leftX,topY,markingRectangle.width
+ 1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle.height
+ 1);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Stop marking...<BR>
&nbsp;&nbsp;&nbsp;void stopMarking(int x,int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showPosition(x,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrackingOn = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Kill if too small...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (markingRectangle != null)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((markingRectangle.width
&lt; 3) ||<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(markingRectangle.height
&lt; 3)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;markingRectangle
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Show current position to status if an image
has<BR>
&nbsp;&nbsp;&nbsp;// been prepared...<BR>
&nbsp;&nbsp;&nbsp;// Returns true if good position, else bad...
<BR>
&nbsp;&nbsp;&nbsp;boolean showPosition(int x,int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Return if not ready to
zoom...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((img == null) || (!zoomOn))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if we are in the display
area...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int width = img.getWidth(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int height = img.getHeight(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((x &gt; width) || y &gt;
height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentX = XLeft + (XDelta
* (((double)x)/((double)width)));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentY = YTop + (YDelta
* (((double)y)/((double)height)));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(currentX + &quot;
: &quot; + currentY);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Print a message to standard out and the status
bar...<BR>
&nbsp;&nbsp;&nbsp;public void showMsg(String s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(s);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
A cache is maintained so that you can move back and forth between
images. The cache is an array of MandelEntry accessor objects;
the MandelEntry class is shown in Listing 14.8. The cache is set
to store up to 40 images. If you fill up the cache, press <TT>C</TT>
or <TT>c</TT> to clear the cache of
everything but the full Mandelbrot set image. As an exercise,
you might want to make the caching mechanism more sophisticated
so that it can bring in existing files, delete individual images,
and so forth.
<P>
Note that there is a little trick in the <TT>saveFile()</TT>
method. It uses the SecurityManager to see whether file writes
are allowed. This is a way of checking the browser's security
before a write is attempted. If file writing is prohibited, a
SecurityException is thrown. How this works will differ from browser
to browser.
<HR>
<BLOCKQUOTE>
<B>Listing 14.8. The MandelEntry class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Store Mandelbrot images and corresponding
coordinates...<BR>
class MandelEntry {<BR>
&nbsp;&nbsp;&nbsp;Mandelbrot m;<BR>
&nbsp;&nbsp;&nbsp;Image img;<BR>
&nbsp;&nbsp;&nbsp;double XLeft,XRight,YTop,YBottom;<BR>
&nbsp;&nbsp;&nbsp;// Constructor: Store data...<BR>
&nbsp;&nbsp;&nbsp;public MandelEntry(Mandelbrot m,Image img,double
XLeft,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double XRight,double YTop,double
YBottom) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.m =
m;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.img
= img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.XLeft
= XLeft;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.XRight
= XRight;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.YTop
= YTop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.YBottom
= YBottom;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Accessor methods...<BR>
&nbsp;&nbsp;&nbsp;public Mandelbrot getMandelbrot() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return m;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public Image getImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public double getXLeft() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return XLeft;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public double getXRight() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return XRight;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public double getYTop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return YTop;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public double getYBottom() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return YBottom;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheBmpImageClass"><FONT SIZE=5 COLOR=#FF0000>The
BmpImage Class</FONT></A></H2>
<P>
The BmpImage class, introduced in Part III of this book, reads
images stored in the BMP format and converts them into a form
Java can use. In this chapter, more functions were added to the
class so that it could write the BMP back out to a file (shown
in Listing 14.9). It's basically the opposite of the reading process
discussed in Part III.
<HR>
<BLOCKQUOTE>
<B>Listing 14.9. Adding BMP saving to the BmpImage class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.String;<BR>
import java.io.*;<BR>
import java.net.*;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
/**<BR>
 * This is a class that reads and writes a<BR>
 * BMP formatted file<BR>
*/<BR>
public class BmpImage<BR>
{<BR>
// ... EXISTING CODE GOES HERE!!!<BR>
/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write out a bitmap...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Current only supporting 8 bits per
pixel...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @String filename - The file to save
it as...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @IndexColorModel ICM - Palette to use
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int pix[] - Pixels to save<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int width - Width of data<BR>
* @int height - Height of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void saveBitmap(String filename,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; IndexColorModel ICM, int pix[],<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int width, int height) throws IOException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
output stream...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage
b = new BmpImage(filename);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
os = new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new FileOutputStream(filename) ) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.writeFileHeader(os,ICM,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.write8bitWindowsHeader(os,ICM,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.write8bitColorIndex(os,ICM);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.write8bitData(os,pix,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write out the file header<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @DataOutputStream os - The output stream
to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @IndexColorModel ICM - Palette to use
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int width - Width of data<BR>
* @int height - Height of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void writeFileHeader(DataOutputStream
os,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; IndexColorModel ICM,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int width, int height) throws IOException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte b[] = new byte[4];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write out magic code...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[0] = 'B';<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[1] = 'M';<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.write(b,0,2);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate size and offset..
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int paletteSize = (ICM.getMapSize()
* 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int offset = 54 + paletteSize;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int fileSize = offset + (width
* height);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write out size &amp; offset...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,fileSize,4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,0,4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,offset,4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write the bitmap header out to Windows...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @DataOutputStream os - The output stream
to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @IndexColorModel ICM - Palette to use
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int width - Width of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int height - Height of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void write8bitWindowsHeader(DataOutputStream
os,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; IndexColorModel ICM,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int width, int height) throws IOException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,40,4);&nbsp;&nbsp;//
Bytes in header<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,width,4);&nbsp;&nbsp;//
Size in pixels...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,height,4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,1,2);&nbsp;&nbsp;&nbsp;//
# Color Planes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,8,2);&nbsp;&nbsp;//
Bits per pixel...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,0,4);&nbsp;&nbsp;//
NO Compression...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,width * height,4);&nbsp;&nbsp;//
Size of image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// LATER PUT IN REAL DATA
pixels/meter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,3790,4);&nbsp;&nbsp;//
TBD: Horizontal Res pixels/meter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,3790,4);&nbsp;&nbsp;//
TBD: Vertical Res pixels/meter<BR>
pushVal(os,ICM.getMapSize(),4);&nbsp;&nbsp;// Indexes in bitmap...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushVal(os,ICM.getMapSize(),4);&nbsp;&nbsp;//
Indexes in bitmap...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write the bitmap header out to Windows...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @DataOutputStream os - The output stream
to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @IndexColorModel ICM - Palette to use
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void write8bitColorIndex(DataOutputStream
os,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexColorModel ICM) throws
IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
RGB array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int paletteSize
= ICM.getMapSize();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte blues[]
= new byte[paletteSize];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte greens[]
= new byte[paletteSize];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte reds[]
= new byte[paletteSize];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte b[]
= new byte[4];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy
RGB arrays...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ICM.getBlues(blues);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ICM.getGreens(reds);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ICM.getReds(reds);
<BR>
// Write out palette...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int
i = 0; i &lt; paletteSize; ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[0]
= (byte)blues[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[1]
= (byte)greens[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[2]
= (byte)reds[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[3]
= (byte)0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.write(b,0,4);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write out data of bitmap...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @DataOutputStream os - The output stream
to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @IndexColorModel ICM - Palette to use
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int pix[] - Pixels to save<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int width - Width of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int height - Height of data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void write8bitData(DataOutputStream
os,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int pix[],int width, int height) throws
IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Bytes b...<BR>
byte b[] = new byte[width];<BR>
&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 4; ++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[i] = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Calculate padding<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int padding = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int overage = width % 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (overage != 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding = 4 - overage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Write out starting from bottom of
height<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int index,x,y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; for (y = (height - 1); y &gt;= 0; -y)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write
out each row, send to big buffer...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index =
(y * width);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x =
0; x &lt; width; ++x,++index)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[x]
= (byte)pix[index];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write
out a big block...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.write(b,0,width);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send
out padding...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (padding
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(int i = 0; i &lt; 4; ++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[i]
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.write(b,0,padding);
<BR>
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;.&quot;);
System.out.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end y for<BR>
&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Write done!&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Write out integer to little endian
stream...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @DataOutputStream os - The output stream
to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int data - Data to convert<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @int len - Length of array to convert
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void pushVal(DataOutputStream
os,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int data,int len) throws IOException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte b[] = new byte[len];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; len;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[i] = (byte)(data
&gt;&gt; (i * 8));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.write(b,0,len);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="AutomaticDocumentationwithjavadoc">Automatic Documentation
with <TT><FONT SIZE=4 FACE="Courier">javadoc</TT></FONT></A></H3>
<P>
The last thing covered in this chapter is how to auto-document
your code. The tool <TT>javadoc</TT>,
provided with the JDK, can take a properly formatted file and
convert it into an HTML file, complete with links to the classes
it references (assuming those classes are also run through <TT>javadoc</TT>).
The BmpImage.java is such a file; its HTML output from <TT>javadoc</TT>
is shown in Figure 14.7 and is included on this book's CD-ROM.
<P>
<A HREF="f14-7.gif" ><B>Figure 14.7 : </B><I>BmpImage HTML after being run through </I>javadoc.</A>
<P>
Comments that should appear in the HTML are marked by appearing
between <TT>/**</TT> and <TT>*/</TT>,
as shown at the beginning of the source code in Listing 14.9.
The <TT>javadoc</TT> tool figures
out a lot of things on its own, such the superclass, what external
classes are used, and the individual parts of a method or variable
declaration. You can specify additional information for each method
by preceding certain keywords with an <TT>@</TT>.
These keywords include <TT>param</TT>,
<TT>returns</TT>, and <TT>exception</TT>
for documenting parameters, return values, and exceptions thrown,
respectively. For example, here is the declaration for <TT>getImageProducer()</TT>:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A method to retreive an ImageProducer
given just a BMP URL.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param context contains the base URL
(from getCodeBase() or such)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns an ImageProducer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception AWTException on stream or
bitmap data errors<BR>
*/</TT>
</BLOCKQUOTE>
<P>
Look at the HTML to see what this looks like.
<P>
You will need to place the HTML output in the right directory
for everything to work properly. You can also document an entire
package by passing the package name to <TT>javadoc</TT>.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
The major work of this book began in Part II with a series of
discussions on how to use the AWT package. The spreadsheet applet
was used to show how to incrementally build an applet using AWT.
Since AWT is the basis for constructing the user interface of
your Java applets, you need to know the package well. While constructing
the spreadsheet, you also learned the subtleties of the java.io
package and how to create exception handlers. By the end of Part
II, you had seen most of the basics of Java applet programming.
<P>
Part III took everything a step further. You discovered the underlying
classes behind applets and images and saw how threads can be used
to enhance your application. Part III concluded with showing you
how AWT, the applet classes, images, and threads could be brought
together to create a Catalog applet, whose key element was a background
image loader running as a thread. Although this applet was not
a final product, it could-combined with the client/server mechanisms
of Part IV-be the basis for producing a serious catalog application
for use on the World Wide Web.
<P>
In Part IV, you incorporated the lessons of the previous chapters
to create the most complex application of the book. You saw how
to use the Java network classes to create a client-server application,
and how to use native methods to take full advantage of a particular
platform's features. The client applet demonstrated how Java could
be used to represent data as it changes in real time. The election
applet in Part IV was just the beginning of what you can create
with Java client-server technology.
<P>
Part V allowed you to focus on some of the more advanced features
of Java. You saw how HotJava, although still in its infancy, has
features that indicate the future of browsers and Java programming.
You also saw how to use Java's image classes to create advanced
animation and image-processing applets. With a knowledge of these
advanced imaging techniques, you can now use Java to produce images
more sophisticated than just a banner moving across the screen.
<P>
You have been given the tools to write great Java applets for
the Internet, the intranet, or anywhere else Java calls. Go for
it!
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



