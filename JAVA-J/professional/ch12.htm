<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 12</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Handling Dynamic Content</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>





<UL>
<LI><A HREF="#IntroducingtheHotJavaBrowser" >Introducing the HotJava Browser</A>
<UL>
<LI><A HREF="#DynamicContent" >Dynamic Content</A>
<LI><A HREF="#SecurityModel" >Security Model</A>
<LI><A HREF="#Alpha3DistributionDifferences" >Alpha3 Distribution Differences</A>
</UL>
<LI><A HREF="#AlteringtheHotJavaSource" >Altering the HotJava Source</A>
<UL>
<LI><A HREF="#BufferedStreamsPrimer" >Buffered Streams Primer</A>
<LI><A HREF="#MakingtheChanges" >Making the Changes</A>
<LI><A HREF="#CompilingUnderHotJava" >Compiling Under HotJava</A>
</UL>
<LI><A HREF="#TowardaMorePerfectServer" >Toward a More Perfect Server</A>
<UL>
<LI><A HREF="#AddingaConfigurationFile" >Adding a Configuration File</A>
<LI><A HREF="#AddingStandardLogging" >Adding Standard Logging</A>
<LI><A HREF="#BuildingLogInformation" >Building Log Information</A>
<LI><A HREF="#AlteringtheSendRoutines" >Altering the Send Routines</A>
</UL>
<LI><A HREF="#CreatingNewContentTypes" >Creating New Content Types</A>
<UL>
<LI><A HREF="#WritingContentHandlers" >Writing Content Handlers</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter introduces the HotJava browser and explains why it
is so groundbreaking, then introduces the HotJava source release,
used to modify HotJava itself. The HTTP server from previous chapters
gets a needed face-lift before being used to serve dynamic content
to HotJava. At the end of the chapter, you will actually write
and test two HotJava content handlers.
<H2><A NAME="IntroducingtheHotJavaBrowser"><FONT SIZE=5 COLOR=#FF0000>Introducing
the HotJava Browser</FONT></A></H2>
<P>
The developers at Sun had a problem; they had a new language,
Java, envisioned as dominating the World Wide Web (WWW), but they
didn't have a way to reach the public. People need to see demonstrations
before they can fully appreciate a new technology, and they need
to work with things before they will adopt them. How could Sun
convince people to use their distributed language without a demonstration
vehicle? The answer is: They couldn't. A Web browser that could
execute Java was needed, so the HotJava browser was developed.
<P>
HotJava is completely implemented in the Java language itself!
It was started to demonstrate interactive content (Java applets)
and to prove that Java was a viable language for advanced applications
(the browser).
<H3><A NAME="DynamicContent">Dynamic Content</A></H3>
<P>
Traditional Web browsers are a monolithic collection of protocol
handlers and display routines. Typically, the manufacturer equips
them to respond to a certain subset of the huge number of protocols
and data formats that make up the Internet. HotJava essentially
understands none of the protocols or data formats on the Internet.
This distinction is important. HotJava was not conceived to speak
any specific protocol; it was developed to speak them all.
<P>
HotJava implements a concept called <I>dynamic content</I>. When
you point HotJava at a URL, the browser searches for the code
to converse in whatever protocol is being used. If you entered
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.javasoft.com/">http://www.javasoft.com/</A></TT>
</BLOCKQUOTE>
<P>
HotJava would load its HTTP protocol handler. If you entered
<BLOCKQUOTE>
<TT>ftp://ftp.some.host/</TT>
</BLOCKQUOTE>
<P>
HotJava would load its FTP protocol handler. What if it didn't
have an FTP handler? Well, it would ask the host whether it had
an FTP handler. If the host had one, HotJava would download it,
then use the new handler to fetch the original URL. HotJava upgrades
itself on the fly!
<H4>Protocol Handlers</H4>
<P>
HotJava actually does come with a great many protocol handlers
already installed-that is, already present on the local computer.
When a new protocol is needed, HotJava searches locally first;
only then does it resort to asking the remote host.
<P>
The distinction is that it makes no difference to HotJava whether
the handler is locally available or gotten from halfway around
the world. This dynamic behavior extends to display content as
well.
<H4>Content Handlers</H4>
<P>
Traditional Web browsers understand a small subset of display
formats. Most common are GIF, JPEG, and X11 bitmap. The content
type comes encoded in a Multipurpose Internet Mail Extension (MIME)
header. You experienced MIME content types when you worked with
the HTTP server. Remember how the server sent everything as <TT>Content-type:
text/html</TT>? This was a MIME content type. Servers are
configured to send each file format with a specific MIME type.
Typically, this is done by tying the suffix of a file to a specific
content type. Table 12.1 lists some common file extensions and
their MIME content types.
<P>
When HotJava sees a MIME content type, it tries to load the appropriate
handler. Again, if it can't find a local handler, it will ask
the remote server for one.<BR>
<P>
<CENTER><B>Table 12.1. Common file extensions and their MIME content
types.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=133><I>File Extension</I></TD><TD WIDTH=198><I>MIME Content Type</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>html</TT></TD>
<TD WIDTH=198>text/html</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>htm</TT></TD>
<TD WIDTH=198>text/html</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>txt</TT></TD>
<TD WIDTH=198>text/plain</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>rtf</TT></TD>
<TD WIDTH=198>text/rtf</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>ps</TT></TD>
<TD WIDTH=198>text/postscript</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>doc</TT></TD>
<TD WIDTH=198>text/msword</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>gif</TT></TD>
<TD WIDTH=198>image/gif</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>jpg</TT></TD>
<TD WIDTH=198>image/jpeg</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>mpg</TT></TD>
<TD WIDTH=198>video/mpeg</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>wav</TT></TD>
<TD WIDTH=198>audio/wav</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>au</TT></TD>
<TD WIDTH=198>audio/ulaw</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>tar</TT></TD>
<TD WIDTH=198>file/tar</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>arc</TT></TD>
<TD WIDTH=198>file/arc</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>lha</TT></TD>
<TD WIDTH=198>file/lharc</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133><TT>zip</TT></TD>
<TD WIDTH=198>file/zip</TD></TR>
</TABLE></CENTER>
<P>
<P>
Netscape attempts to mimic this behavior with &quot;plug-ins.&quot;
You can configure Netscape Navigator to run plug-in programs when
it encounters certain MIME content types. The one thing that Netscape
can't do is use the server to load one on the fly. Even if it
could, there are so many different platforms available, who knows
if it would load the correct executable for your specific architecture.
Java is portable, so you can compile it once and execute it everywhere
there's an interpreter present. If you're using the HotJava browser,
then you have a running Java interpreter already in action.
<H3><A NAME="SecurityModel">Security Model</A></H3>
<P>
HotJava has a much more flexible security model than Netscape
Navigator. Instead of banning all file access and limiting socket
access, HotJava allows the severity of restrictions to be configured.
<P>
Network security has four modes:
<UL>
<LI><B>No access</B>-Applets cannot open any external URLs or
socket connections.
<LI><B>Applet host</B>-Applets can open sockets only to the host
they were loaded from.
<LI><B>Firewall</B>-Applets can open sockets to the host they
were loaded from and to hosts within a configurable list or domain.
<LI><B>Unrestricted</B>-Applets can open sockets to anywhere.
</UL>
<P>
In addition, you can also apply these modes to applet loading:
<UL>
<LI><B>No access</B>-No Java applets can be loaded.
<LI><B>Applet host</B>-Only applets from the local file system
can be loaded.
<LI><B>Firewall</B>-Applets from hosts within a firewall can be
loaded.
<LI><B>Unrestricted</B>-Applets can be loaded from any host.
</UL>
<P>
Accessing local file storage is also a configurable option. HotJava
uses two environment variables to control file access by applets:
<UL>
<LI><TT>HOTJAVA_READ_PATH</TT>
<LI><TT>HOTJAVA_WRITE_PATH</TT>
</UL>
<P>
Both these variables consist of a semicolon-separated list of
directories. Applets can access any files in these directories
or their subdirectories.
<H4>Firewall Security Model</H4>
<P>
The <I>firewall security model</I> is a powerful option. The corporate
world is only now becoming aware of the vast power inherent in
HTML. Corporate intranets are sprouting up everywhere; these corporate
nets offer full access for machines behind their firewall, but
limited or no access to the Internet at large. Allowing a browser
to have full access rights within a firewall offers the necessary
flexibility that corporations demand. The current Netscape security
model is too restrictive for business use. Real-world applications
need local storage and flexible connectivity options to be of
any use. Browsers will probably adopt this firewall model as business
demands for Java grow.
<H3><A NAME="Alpha3DistributionDifferences">Alpha3 Distribution
Differences</A></H3>
<P>
Unfortunately, HotJava is mired in the world of Java Alpha3. It
can't run applets written for version 1.0, but it still has instructive
use. The Java language is quite stable, so you'll find no differences
in the language syntax or semantics, but there are some major
differences in the class packages and libraries.
<P>
To begin with, there is no classes.zip file. All the Java classes
are contained in a directory tree that reflects the package name
of each class. Actually, if you peered inside the zipped class
file from version 1.0, you would find that this same tree has
been maintained in the compressed image. Figure 12.1 shows the
major packages within the directory hierarchy.
<P>
<A HREF="f12-1.gif" ><B>Figure 12.1 : </B><I>Directory structory and major packages.</I></A>
<P>
This layout should look familiar to you, with the exception of
the browser package. This package contains classes and interfaces
to HotJava's general functionality. In particular, the Applet
class is located within the browser package.
<P>
The protocol and content handler classes are under the following
directories:
<BLOCKQUOTE>
<TT>classes/net/www/protocol<BR>
classes/net/www/content</TT>
</BLOCKQUOTE>
<P>
When HotJava makes a request to a server for a specific handler,
it uses the same path as the local directories. For example, if
you encounter MIME type <TT>text/plain</TT>
and there's no plain.class within the local text subdirectory,
HotJava issues the following request:
<BLOCKQUOTE>
<TT>GET /classes/net/www/content/text/plain.class
HTTP/1.0</TT>
</BLOCKQUOTE>
<P>
Unfortunately, this request issued to the previous chapter's HTTP
server would go unanswered because HotJava is waiting for a socket
close notification that will never arrive due to a bug in the
JDK. It seems as though <TT>socket.close()</TT>
doesn't work under either Windows 95 or Windows NT. You need to
change HotJava's source code to use the <TT>Content-length</TT>
MIME parameter that the HTTP server dutifully places into the
outbound stream.
<H2><A NAME="AlteringtheHotJavaSource"><FONT SIZE=5 COLOR=#FF0000>Altering
the HotJava Source</FONT></A></H2>
<P>
To alter the HotJava source, you must first have a thorough understanding
of the inner workings of the HotJava protocol handler; its principle
function is to provide the input stream:
<BLOCKQUOTE>
<TT>public InputStream openStream(URL u);</TT>
</BLOCKQUOTE>
<P>
The handler for HTTP constructs an instance of the HttpClient
class to perform its low-level work; this class extends NetworkClient.
Then the socket connection is opened and the request is sent.
The input stream is acquired and wrapped in a BufferedInputStream.
The HttpClient parses the response header and stores the results.
<P>
At this point, the constructor for HttpClient returns. The HTTP
protocol handler now processes the response. If the MIME header
contains a valid <TT>Content-length:</TT>
field, the input stream is further encapsulated in a MeteredStream.
The Stream class MeteredStream is the perfect place to make the
alterations.
<H3><A NAME="BufferedStreamsPrimer">Buffered Streams Primer</A>
</H3>
<P>
The standard input stream hierarchy looks like this:
<BLOCKQUOTE>
<TT>InputStream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FilterInputStream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream</TT>
</BLOCKQUOTE>
<P>
The following list shows the public methods of the FilterInputStream
class:<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=373><I>FilterInputStream Members</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=373>
<BLOCKQUOTE>
<TT>available()<BR>
close()<BR>
mark(int)<BR>
markSupported()<BR>
read()<BR>
read(byte[])<BR>
read(byte[], int, int)<BR>
reset()<BR>
skip(int)</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
This class is extended by BufferedInputStream. Buffered streams
offer a look-ahead buffer that enables a stream to be read in
large chunks, but processed a character at a time. They also provide
mark/reset capability. Frequently, applications will need to parse
a stream, looking for a specific string. If this string is not
found, then the application should reset the stream so other processes
can try to parse the same data. Marking a stream tells the BufferedInputStream
object to remember the current location within the buffer. If
a subsequent reset is called, the object will march backward in
its buffer to the previously stored location. New read requests
will be satisfied from the old location. The following list shows
the public methods of the BufferedInputStream class; all these
methods override the equivalent named method in the FilterInputStream
class:<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=404><I>Public Methods of BufferedInputStream</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=404>
<BLOCKQUOTE>
<TT>available()<BR>
mark(int)<BR>
markSupported()<BR>
read()<BR>
read(byte[], int, int)<BR>
reset()<BR>
skip(int)</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Start with the following InputStream:
<BLOCKQUOTE>
<TT>&quot;BufferedInputStreams are handy!&quot;</TT>
</BLOCKQUOTE>
<P>
Next, execute the following code snippet on the stream:
<BLOCKQUOTE>
<TT>byte data[] = new byte[13];<BR>
is.read(data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read 13
characters [BufferedInput]<BR>
mark(200);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save this position for up to 200 characters<BR>
is.read(data, 0, 7);&nbsp;&nbsp;// read 7 more characters [Streams]
<BR>
reset();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
go back<BR>
byte rest[] = new byte[18];<BR>
is.read(rest);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read 18
more characters [Streams are handy!]</TT>
</BLOCKQUOTE>
<P>
A MeteredStream extends FilterInputStream; you can find its source
code in the HotJava directory:
<BLOCKQUOTE>
<TT>classsrc\net\www\html\MeteredStream.java</TT>
</BLOCKQUOTE>
<H4>Metered Stream and HTTP</H4>
<P>
HotJava has a progress display, performed by the MeteredStream
class, that can show how a transfer is progressing. Whenever the
HTTP protocol handler detects a length parameter in the response
header, it will encapsulate the current input stream within a
MeteredStream:
<BLOCKQUOTE>
<TT>String ct = http.getHeaderField(&quot;content-length&quot;);
<BR>
int len = 0;<BR>
if (ct != null &amp;&amp; (len = Integer.parseInt(ct)) != 0) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;is = new MeteredStream(is, len, url);</TT>
</BLOCKQUOTE>
<P>
Since all subsequent reads will be done through the MeteredStream
class, this is the ideal location for the changes.
<H3><A NAME="MakingtheChanges">Making the Changes</A></H3>
<P>
Now you simply need to make stream reads return end-of-stream
once the length parameter has been read. The following list shows
the overriding methods in the MeteredStream class:<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=427><I>MeteredStream Public Methods</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=427>
<BLOCKQUOTE>
<TT>read()<BR>
read(byte[], int, int)<BR>
skip(int)<BR>
close()</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Both read routines must be changed so that there are no further
read attempts once the entire length of bytes has been returned:
<BLOCKQUOTE>
<TT>public int read() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>if ( count &gt;= expected ) return
-1;&nbsp;&nbsp;&nbsp;&nbsp;// add this line<BR>
</B>&nbsp;&nbsp;&nbsp;&nbsp;int c = super.read();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (c != -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;justRead(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return c;<BR>
}<BR>
public int read(byte b[], int off, int len) {<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;if ( count &gt;= expected ) return
-1;<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;if ( count + len &gt; expected ) len
= expected - count;&nbsp;&nbsp;&nbsp;&nbsp;// add both of these
</B></B></TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT><B>lines
<BR>
</FONT></B>&nbsp;&nbsp;&nbsp;&nbsp;int n
= super.read(b, off, len);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (n != -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;justRead(n);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return n;<BR>
}</TT>
</BLOCKQUOTE>
<P>
In addition, mark and reset operations must be intercepted so
the counts can be updated. As you can see from the previous list
of public methods, these routines are absent, so add the following
two routines:
<BLOCKQUOTE>
<TT>public synchronized void mark(int readlimit)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meterMark = count;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.mark(readlimit);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void reset() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( meterMark
!= -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= meterMark;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.reset();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The class variable <TT>meterMark</TT>
also needs to be added to the class:
<BLOCKQUOTE>
<TT>public<BR>
class MeteredStream extends FilterInputStream<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Class variables.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Instance variables.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>int meterMark = -1;</B>&nbsp;&nbsp;&nbsp;&nbsp;//
add this line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>
}</TT>
</BLOCKQUOTE>
<P>
That's it! Recompile MeteredStream and move the class file into
the classes/net/www/html subdirectory.
<H3><A NAME="CompilingUnderHotJava">Compiling Under HotJava</A>
</H3>
<P>
Compiling under HotJava is the same as compiling under the JDK;
the only difference is which version of javac you use. I prefer
not to alter my path and environment for HotJava. Simply issue
the command specifying the full path to HotJava's version of javac:
<BLOCKQUOTE>
<TT>c:\hotjava\bin\javac MeteredStream.java</TT>
</BLOCKQUOTE>
<P>
Assuming you made the alterations correctly, this will create
a MeteredStream.class file in the current directory. Rename the
original MeteredStream.class to MeteredStream.orig, then copy
your altered MeteredStream.class into its place. You have just
changed the source for HotJava! Now give it a try-run the server
from <A HREF="ch9.htm" >Chapters 9</A>, &quot;Java Socket Programming,&quot;
10, &quot;Native Methods and Java,&quot; or 11, &quot;Building
a Live Data Applet,&quot; and point your new HotJava at the server.
The files transfer perfectly.
<P>
Before addressing content handlers, you need to add some enhancements
to the server.
<H2><A NAME="TowardaMorePerfectServer"><FONT SIZE=5 COLOR=#FF0000>Toward
a More Perfect Server</FONT></A></H2>
<P>
The server used in Part IV, &quot;Managing Live Data,&quot; was
useful, but it lacked many features of an actual HTTP server.
Specifically, there is no configuration file to map file extensions
to MIME content strings. In addition, some log information would
be helpful.
<P>
The first change is to the class name. Up to this point, the main
class has been called BasicWebServer. Change this to HTTPServer,
then perform a global search and replace to make the change. Now
the configuration and logging methods can be added.
<H3><A NAME="AddingaConfigurationFile">Adding a Configuration
File</A></H3>
<P>
Since the server is an application, it is free to read and even
write the disk. The format of the configuration file is very straightforward:
<UL>
<LI><FONT COLOR=#000000>port = #</FONT>
<LI><FONT COLOR=#000000>suffix = file_extension Content-type</FONT>
<LI><FONT COLOR=#000000>log = filename</FONT>
</UL>
<P>
New methods are added to handle reading the configuration data.
Listing 12.1 shows the new routines.
<HR>
<BLOCKQUOTE>
<B>Listing 12.1. New routines for reading configuration files.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Read the config file.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void initialize()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String line =
null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String configFile
= &quot;server.cfg&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setup defaults
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP_PORT = 80;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix = new Hashtable();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream
inFile = new FileInputStream(configFile);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
is = new DataInputStream(inFile);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((line = is.readLine()) != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
icmd = new StringTokenizer(line, &quot; \t=&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addConfigEntry(icmd);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
fnf)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix.put(&quot;html&quot;,
&quot;text/html&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix.put(&quot;htm&quot;,
&quot;text/html&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix.put(&quot;class&quot;,
&quot;text/plain&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix.put(&quot;gif&quot;,
&quot;image/gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
reading config file: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a config entry.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param icmd contains the tokenized
line.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void addConfigEntry(StringTokenizer
icmd)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( icmd.hasMoreTokens()
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
param = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
command = icmd.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( icmd.hasMoreTokens() )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param
= icmd.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( command.equalsIgnoreCase(&quot;PORT&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP_PORT
= Integer.valueOf(param).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Monitoring
port &quot; + HTTP_PORT);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( command.equalsIgnoreCase(&quot;SUFFIX&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( icmd.hasMoreTokens() )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
param2 = icmd.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix.put(param,
param2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Adding
suffix: '&quot; + param + &quot;'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;&nbsp;&nbsp;'&quot;
+ param2 + &quot;'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( command.equalsIgnoreCase(&quot;LOG&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openLog(param);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;Error:
Unknown cfg entry: &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(command);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Open a log file<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param logfile contains the filename
to open<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void openLog(String logfile)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logFile
= new PrintStream( new FileOutputStream(logfile) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logging
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
opening log file: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The StringTokenizer is instructed to parse equal sign characters
out of the stream. This allows the configuration file to omit
the equal sign and still function as expected. Only one config
entry per line is allowed because <TT>readLine()</TT>
is used to retrieve the entries.
<P>
File extension to MIME type mapping is contained in a hash table
called <TT>suffix</TT>. The file extension
is used as the key. If a configuration file contains multiple
entries for an extension, only the last one will be stored. Hash
table <TT>put</TT> operations overwrite
duplicate entries.
<H3><A NAME="AddingStandardLogging">Adding Standard Logging</A>
</H3>
<P>
There are many third-party tools available to analyze server log
files, provided they are in a &quot;common log format&quot;:
<BLOCKQUOTE>
<TT>hostname identd authuser [date] &quot;request&quot;
status length</TT>
</BLOCKQUOTE>
<P>
The first entry, <TT>hostname</TT>,
is the name of the host this connection was received from. If
the name cannot be established, this field will display the numeric
IP address of the caller. The next two fields contain information
for &quot;login&quot; and authorized user names. The HTTP server
does not support remote identification dialogs, so these fields
will appear as a single dash (<TT>-</TT>).
The date field has this format:
<BLOCKQUOTE>
<TT>DD/MMM/YYY:HH:MM:SS GGGG</TT>
</BLOCKQUOTE>
<P>
All these fields are evident except GGGG, which represents the
number of time zones away from GMT.
<P>
The request field is the first line from the request header. <TT>status</TT>
is the HTTP response code that was sent, typically 200, and <TT>length</TT>
is the total number of file bytes sent in the response. Here is
a sample log entry:
<BLOCKQUOTE>
<TT>some.name.com - - [25/Mar/1996:08:48:23
-0400] &quot;GET / HTTP/1.0&quot; 200 342</TT>
</BLOCKQUOTE>
<P>
The 200 indicates that a response containing 342 bytes was sent.
<H3><A NAME="BuildingLogInformation">Building Log Information</A>
</H3>
<P>
HTTP requests are already stored in the HTTPrequest class, so
it's reasonable to also store the log information in this class.
If the server is ever made to work concurrently, the log information
will have to travel with each request, so just add it there now:
<BLOCKQUOTE>
<TT>/**<BR>
 * This class maintains all of the information from a HTTP request
<BR>
 */<BR>
public class HTTPrequest<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public StringBuffer log;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Create an instance of this class<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public HTTPrequest()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</TT>
</BLOCKQUOTE>
<P>
A StringBuffer is used because the string will grow and be altered.
Java String objects are immutable-they can never be altered after
they are created. If you use the plus operator to grow a String,
you are actually creating a new String:
<BLOCKQUOTE>
<TT>String first = new String(&quot;This
is the first string.&quot;);<BR>
first += &quot;  This is the second string&quot;;</TT>
</BLOCKQUOTE>
<P>
The <TT>first</TT> variable now contains
a completely different string, constructed from the first string
and the addition of the second string. The original contents of
the variable are lost.
<P>
The log string will need some tweaking to bring it in line with
the common log format. That is why a StringBuffer class is used.
<P>
After a request is parsed, a new routine is added to HTTPrequest
to format the initial portions of the log entry:
<BLOCKQUOTE>
<TT>/**<BR>
 * Log a complete request.<BR>
 */<BR>
public void logRequest()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Date current = new Date();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;log = new StringBuffer(&quot;&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( clientSocket == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.append(&quot;-&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.append(clientSocket.getInetAddress().getHostName());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;log.append(&quot; - - &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;log.append(formatDate(current));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;log.append(&quot; \&quot;&quot; + firstLine
+ &quot;\&quot; &quot;);<BR>
}</TT>
</BLOCKQUOTE>
<H4>The Date Class</H4>
<P>
The Date class is part of the java.util package. It provides full
support for both date and time. Six different constructors for
the class, shown in the following list, offer a great deal of
flexibility in how a date is specified.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=505><I>Date Class Constructors</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=505>
<BLOCKQUOTE>
<TT>Date()<BR>
Date(long totalSecs)<BR>
Date(int yr, int mth, int day)<BR>
Date(int yr, int mth, int day, int hrs, int min)<BR>
Date(int yr, int mth, int day, int hrs, int min, int sec)<BR>
Date(String s)</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The first constructor, the most commonly used, constructs a Date
class reflecting the current date and time. The other constructors
are used mainly to construct Date objects that are either forward
or backward in time. This could be done for comparison purposes:
<BLOCKQUOTE>
<TT>Date c = new Date();<BR>
Date p = new Date( c.getYear() - 1, c.getMonth(), c.getDate()
);<BR>
Date n = new Date( c.getYear() + 1, c.getMonth(), c.getDate()
);<BR>
if ( p.before( c ) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Date &quot; +
p + &quot; is before Date &quot; + c);<BR>
if ( n.after( c ) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Date &quot; +
n + &quot; is after Date &quot; + c);</TT>
</BLOCKQUOTE>
<P>
The Date class provides three useful comparison functions:
<UL>
<LI><TT>boolean before(Date d)</TT>
<LI><TT>boolean after(Date d)</TT>
<LI><TT>boolean equals(Date d)</TT>
</UL>
<P>
Several public methods get and manipulate Date class variables.
Table 12.2 lists the remaining public methods of the Date class.
<BR>
<P>
<CENTER><B>Table 12.2. Public methods of the Date class.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=291><I>Method</I></TD><TD WIDTH=227><I>Synopsis</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getYear()</TT>
</TD><TD WIDTH=227>Year since 1900</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setYear(int y)</TT>
</TD><TD WIDTH=227>Year since 1900</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getMonth()</TT>
</TD><TD WIDTH=227>Month (0-11)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setMonth(int m)</TT>
</TD><TD WIDTH=227>Month (0-11)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getDate()</TT>
</TD><TD WIDTH=227>Day of month (1-31)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setDate(int d)</TT>
</TD><TD WIDTH=227>Day of month (1-31)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getDay()</TT>
</TD><TD WIDTH=227>Day of week (0-6)[0=Sunday]</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getHours()</TT>
</TD><TD WIDTH=227>(0-23)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setHours(int h)</TT>
</TD><TD WIDTH=227>(0-23)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getMinutes()</TT>
</TD><TD WIDTH=227>(0-59)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setMinutes(int m)</TT>
</TD><TD WIDTH=227>(0-59)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getSeconds()</TT>
</TD><TD WIDTH=227>(0-59)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setSeconds(int s)</TT>
</TD><TD WIDTH=227>(0-59)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>long getTime()</TT>
</TD><TD WIDTH=227>Milliseconds since 1970</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>void setTime(long totalSecs)</TT>
</TD><TD WIDTH=227>Milliseconds since 1970</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int hashCode()</TT>
</TD><TD WIDTH=227>Return the object's hash code</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>String toString()</TT>
</TD><TD WIDTH=227>Uses UNIX ctime conventions</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>String toLocaleString()</TT>
</TD><TD WIDTH=227>Uses locale conventions</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>String toGMTString()</TT>
</TD><TD WIDTH=227>Uses Internet GMT conventions</TD></TR>
<TR VALIGN=TOP><TD WIDTH=291><TT>int getTimezoneOffset()</TT>
</TD><TD WIDTH=227>Minutes from GMT</TD></TR>
</TABLE></CENTER>
<P>
<H4>Creating Common Log Date Format</H4>
<P>
None of the <TT>toString()</TT> variants
in the Date class match common log format. The following routines
use a Date class to create the correct common log date format:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the passed date as a common
log format String.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param d contains the date to convert
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String formatDate(Date d)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &quot;[&quot;
+ formatFor2(d.getDate()) + &quot;/&quot; + getMonthName(d) +
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;/&quot;
+ (d.getYear() + 1900) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:&quot;
+ formatFor2(d.getHours()) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:&quot;
+ formatFor2(d.getMinutes()) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:&quot;
+ formatFor2(d.getSeconds()) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
&quot; + getTimezone(d) + &quot;]&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * return a String of the passed int.&nbsp;&nbsp;The
String will<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * be formatted to take up at least two
places.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String formatFor2(int n)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String ret;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( n &lt; 10
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= new String(&quot;0&quot; + n);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= new String(&quot;&quot; + n);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the timezone formatted for common
log format.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param d contains the date to convert
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getTimezone(Date d)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String ret;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int tz = d.getTimezoneOffset();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lf = tz %
60;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
check for remainders<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tz /= 60;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
change to hours<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The polarity
of getTimezoneOffset is backwards.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Positive values
mean you are behind GMT.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Negative values
mean GMT is behind you.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( tz &gt; 0
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= &quot;-&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( tz &lt;
0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= &quot;+&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret += formatFor2(tz)
+ formatFor2(lf);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return a String representing the month
name in<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * common log format.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param d contains the date to convert
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getMonthName(Date d)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( d.getMonth()
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: return
&quot;Jan&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: return
&quot;Feb&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: return
&quot;Mar&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: return
&quot;Apr&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: return
&quot;May&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 5: return
&quot;Jun&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 6: return
&quot;Jul&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 7: return
&quot;Aug&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 8: return
&quot;Sep&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 9: return
&quot;Oct&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 10: return
&quot;Nov&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 11: return
&quot;Dec&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &quot;-&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Integers will print in their current precision. Common log format
calls for two-digit numbers. The method <TT>formatFor2()</TT>
will add a zero at the beginning if the passed integer is less
than 10.
<P>
Notice the polarity switch of <TT>getTimezoneOffset()</TT>.
Common log format as well as most other time-zone representations
use hours away from GMT (locale - GMT).<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>getTimezoneOffset()</TT> method returns the number of minutes GMT is away from your locale (GMT - locale). Normal convention is to use the number of minutes your locale is away from GMT (locale - GMT). Be careful when displaying time-zone information.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now the HTTPrequest contains the request and the initial parts
of the log string. The remaining two pieces of log information,
<TT>status</TT> and <TT>length</TT>,
are filled in by the send routines.
<H3><A NAME="AlteringtheSendRoutines">Altering the Send Routines</A>
</H3>
<P>
A nice feature of many servers is that they send a standard HTML
file for error states. For instance, file error404.html is returned
when a request is not found, which enables you to configure what
is sent for various error conditions. Previously, the status of
a transmission was always <TT>200 OK</TT>.
Now, negative responses also need to use the services of <TT>sendFile()</TT>.
Status and the description string need to be passed in by the
caller. This has another advantage because log information is
written in the <TT>sendFile()</TT>
routine, which means that negative responses are also recorded.
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send a negative (404 NOT FOUND) response
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request to
respond to.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void sendNegativeResponse(HTTPrequest
request)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
fileToGet = &quot;error404.html&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream
inFile = new FileInputStream(fileToGet);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug &amp; level &lt; 4)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;DEBUG:
Sending -rsp &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(fileToGet
+ &quot; &quot; + inFile.available());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;
Bytes&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendFile(request,
inFile, 404, &quot;Not Found&quot;, fileToGet);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inFile.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
fnf)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error:
No error404.html file for -rsp&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (ProtocolException
pe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
file length: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send the passed file<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request instance
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param inFile the opened input file
stream to send<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void sendFile(HTTPrequest request,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream
inFile,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
status, String describe,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
fileToGet)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outbound = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String type =
null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire an output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound
= new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.clientSocket.getOutputStream());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send the response header<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
period = fileToGet.lastIndexOf('.');<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( period != -1 &amp;&amp; period != fileToGet.length() )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type
= (String)suffix.get(fileToGet.substring(period + 1));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(type == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type
= &quot;text/plain&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug &amp; level &lt; 4)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;DEBUG:
Type &quot; + type);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;HTTP/1.0
&quot; + status + &quot; &quot; + describe + &quot;\r\n&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;Content-type:
&quot; + type + &quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;Content-Length:
&quot; + inFile.available() + &quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;\r\n&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.log.append(status
+ &quot; &quot; + inFile.available());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(request.log.toString());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( logging )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logFile.print(request.log.toString()
+ &quot;\r\n&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Added to allow Netscape to process header properly<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
This is needed because the close is not recognized<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(5000);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If not a HEAD request, send the file body.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
HEAD requests only solicit a header response.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(!request.method.equals(&quot;HEAD&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte
dataBody[] = new byte[1024];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
cnt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((cnt = inFile.read(dataBody)) != -1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.write(dataBody,
0, cnt);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Cleanup<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.flush();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException
while sending file: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
Notice how the MIME content type is derived from the file's extension.
Using a hash table for this information allows a rapid lookup.
If the extension is not found, or if the file has no extension,
the file is sent as type <TT>text/plain</TT>.
<H2><A NAME="CreatingNewContentTypes"><FONT SIZE=5 COLOR=#FF0000>Creating
New Content Types</FONT></A></H2>
<P>
Now that the server can send various MIME content types, it's
time to investigate how to use HotJava content handlers. This
exercise is small in scope, but large in know-how.
<P>
HotJava comes equipped with four content handlers, in addition
to its standard HTML handler:
<UL>
<LI><TT>text/plain</TT>
<LI>image/gif
<LI>image/x_xbitmap
<LI><TT>image/x_xpixmap</TT>
</UL>
<P>
This exercise adds two new types, <TT>text/fee</TT>
and <TT>text/foo</TT>. Since these
types aren't within the local system, HotJava will try to load
them from the server:
<BLOCKQUOTE>
<TT>GET /classes/net/www/content/text/fee.class
HTTP/1.0<BR>
GET /classes/net/www/content/text/foo.class HTTP/1.0</TT>
</BLOCKQUOTE>
<H3><A NAME="WritingContentHandlers">Writing Content Handlers</A>
</H3>
<P>
A HotJava content handler consists of a single class that extends
the ContentHandler class. Its class name must be the same as the
MIME sub-type that it handles. In addition, it must have the same
path it would have if it were local to HotJava.
<P>
The code below implements the <TT>text/fee</TT>
content handler:
<BLOCKQUOTE>
<TT>package net.www.content.text;<BR>
<BR>
import net.www.html.ContentHandler;<BR>
import net.www.html.URL;<BR>
import java.io.InputStream;<BR>
<BR>
/**<BR>
 * A content handler for text/fee objects<BR>
 */<BR>
public class fee extends ContentHandler<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Read in an ASCII text file and append
an<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * ID string to the end.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is holds the input stream for
the content<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param u holds the URL for the object
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Object getContent(InputStream is,
URL u)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sb
= new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((c = is.read())
&gt;= 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.appendChar((char)c);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(&quot;\n\n\nThis
is a fee ASCII text file.\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(&quot;Rendered
by the fee content handler!\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.close();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sb.toString();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return a string object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This handler expects an ASCII text file to be its input. It will
continue reading until the end of the stream. When the stream
is finished, this handler adds an identification string to the
end of the text.
<P>
All content handlers return some type of object to the browser.
The browser uses <TT>instanceof</TT>
calls to figure out how to display the object. Obviously, HotJava
can handle string data. More complex types, such as images, would
return an instance of the Observable class. Inspecting the GIF
content handler shows that it returns a GIFImage, which descends
from DIBitmap, which itself descends from class Observable.
<P>
Compile the code by invoking HotJava's version of javac:
<BLOCKQUOTE>
<TT>c:\hotjava\bin\javac fee.java</TT>
</BLOCKQUOTE>
<P>
Now add the new content type to the server config file: server.cfg.
<BLOCKQUOTE>
<TT>suffix= fee text/fee</TT>
</BLOCKQUOTE>
<P>
Finally, run the server and then HotJava. Remember to use the
server's new name: HTTPServer. Point the browser at the server
test file: test.fee.
<BLOCKQUOTE>
<TT>http://your_host/test.fee</TT>
</BLOCKQUOTE>
<P>
You should see the display shown in Figure 12.2.
<P>
<A HREF="f12-2.gif" ><B>Figure 12.2 : </B><I>Rendition of test fee using the fee content handler</I></A><I>.</I>
<P>
HotJava downloaded the new handler, installed it, and used it
to render the new type! You can check this by looking at the output
of the server:
<BLOCKQUOTE>
<TT>merlin - - [25/Mar/1996:16:07:56 -0400]
&quot;GET /test.fee HTTP/1.0&quot; 200 120<BR>
merlin - - [25/Mar/1996:16:08:09 -0400]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;GET
/classes/net/www/content/text/fee.class HTTP/1.0&quot; 200 834</TT>
</BLOCKQUOTE>
<P>
Did you notice the strange boxes at the end of each text line
in the HotJava display? Those are carriage returns. HotJava doesn't
know how to display these, so it uses a box.
<P>
Copy the fee.java file to foo.java. Edit the new foo handler so
that it removes carriage returns whenever it sees them.
<BLOCKQUOTE>
<TT>package net.www.content.text;<BR>
<BR>
import net.www.html.ContentHandler;<BR>
import net.www.html.URL;<BR>
import java.io.InputStream;<BR>
<BR>
/**<BR>
 * A content handler for text/foo objects<BR>
 */<BR>
public class foo extends ContentHandler<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Read in an ASCII text file and append
an<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * ID string to the end.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is holds the input stream for
the content<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param u holds the URL for the object
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Object getContent(InputStream is,
URL u)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sb
= new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((c = is.read())
&gt;= 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( c == '\r' ) continue;&nbsp;&nbsp;&nbsp;&nbsp;// remove carriage
returns<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.appendChar((char)c);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(&quot;\n\n\nThis
is a foo ASCII text file.\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(&quot;Rendered
by the foo content handler!\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.close();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sb.toString();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return a string object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
First, compile the new foo handler:
<BLOCKQUOTE>
<TT>c:\hotjava\bin\javac foo.java</TT>
</BLOCKQUOTE>
<P>
Add the new &quot;foo&quot; suffix to the server configuration
file:
<BLOCKQUOTE>
<TT>suffix= foo text/foo</TT>
</BLOCKQUOTE>
<P>
Next, restart the server and HotJava. Point the browser to the
following statement:
<BLOCKQUOTE>
<TT>http://your_host/test.foo</TT>
</BLOCKQUOTE>
<P>
The boxes have disappeared! You should see the display shown in
Figure 12.3.
<P>
<A HREF="f12-3.gif" ><B>Figure 12.3 : </B><I>Rendition of test foo using the foo content handler.</I></A>
<P>
The server log shows the following:
<BLOCKQUOTE>
<TT>merlin - - [25/Mar/1996:16:10:17 -0400]
&quot;GET /test.foo HTTP/1.0&quot; 200 120<BR>
merlin - - [25/Mar/1996:16:10:24 -0400]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;GET
/classes/net/www/content/text/foo.class HTTP/1.0&quot; 200 845</TT>
</BLOCKQUOTE>
<P>
Again, the handler was dynamically loaded by HotJava.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covers the dynamic Web browser HotJava. After some
initial background, the HotJava class hierarchy is reviewed and
the HotJava concept of dynamic content handlers is introduced.
To demonstrate dynamic content, HotJava's source is patched to
enable it to operate with the HTTP server from previous chapters.
<P>
The server itself receives a face-lift that brings it more in
line with a standard HTTP server. In light of the changes, its
name is changed to HTTPServer. You add a configuration file and
logging.
<P>
You learn about the MIME content types as well as how servers
use file extensions to decide what content type to send for a
specific file.
<P>
The Date class is reviewed, and the common log format is introduced.
Finally, you learn the basics of writing a HotJava content handler.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



