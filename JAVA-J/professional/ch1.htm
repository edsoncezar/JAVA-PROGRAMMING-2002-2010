<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 1</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>The Java Development Environment</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>



<UL>
<LI><A HREF="#ToughProblemsinSearchofOneSolution" >Tough Problems in Search of One Solution</A>
<UL>
<LI><A HREF="#WhyJavaIsaComprehensiveSolution" >Why Java Is a Comprehensive Solution</A>
<LI><A HREF="#WhyObjectOrientedIsImportant" >Why Object-Oriented Is Important</A>
<LI><A HREF="#JavaasanObjectOrientedLanguage" >Java as an Object-Oriented Language</A>
<LI><A HREF="#JavaasaPortableEnvironment" >Java as a Portable Environment</A>
<LI><A HREF="#JavaasHighPerformance" >Java as High Performance</A>
<LI><A HREF="#JavaintheWorldofDistributedComputin" >Java in the World of Distributed Computing</A>
<LI><A HREF="#JavaasaSecureEnvironment" >Java as a Secure Environment</A>
</UL>
<LI><A HREF="#GeneralFeaturesoftheJavaProgramming" >General Features of the Java Programming Language</A>
<UL>
<LI><A HREF="#DataTypes" >Data Types</A>
<LI><A HREF="#Literals" >Literals</A>
<LI><A HREF="#Variables" >Variables</A>
<LI><A HREF="#Comments" >Comments</A>
<LI><A HREF="#Operators" >Operators</A>
<LI><A HREF="#KeywordsandConditionals" >Keywords and Conditionals</A>
<LI><A HREF="#Loops" >Loops</A>
<LI><A HREF="#Arrays" >Arrays</A>
</UL>
<LI><A HREF="#AppletsandStandaloneApplications" >Applets and Standalone Applications</A>
<UL>
<LI><A HREF="#CreatinganApplet" >Creating an Applet</A>
<LI><A HREF="#CreatingaStandaloneApplication" >Creating a Standalone Application</A>
</UL>
<LI><A HREF="#AppletsVersusStandaloneApplications" >Applets Versus Standalone Applications</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Java is a programming language that provides a foundation for
developing Internet applications. Java does this through <I>applets</I>,
which are programs executed as part of a Web page and displayed
with a Java-enabled browser, such as HotJava or Netscape Navigator
2.0. However, Java's features need to be understood in a context
much broader than just running Internet applications. Java is
a language designed to solve a variety of problems that have plagued
the computing community for years; running well on the Internet
is almost a by-product of solving these problems.
<P>
What are these problems? And how does Java solve them? This chapter
will attempt to answer those questions. Through the course of
this chapter, you will be given the background needed for understanding
why Java, applets, and the Internet are such a natural match.
This background will not only help you better understand the techniques
used to program the Java applets developed throughout this book,
but the extra knowledge of the &quot;big picture&quot; may also
help you come up with novel ways to apply this new technology.
Java and the Internet are very much like the old Western frontier-pathfinders
who break new ground may find the gold that lies underneath.
<H2><A NAME="ToughProblemsinSearchofOneSolution"><FONT SIZE=5 COLOR=#FF0000>Tough
Problems in Search of One Solution</FONT></A></H2>
<P>
A key word often used when discussing the &quot;information superhighway&quot;
is <I>convergence</I>. People talk about the convergence of telecommunications
and computing, television and computers, consumer appliances and
telecommunications, and so forth. Each of these converging factors
comes from areas of technology that, until recently, have not
had much in common. For example, the technology of fiber optics
does not have much to do directly with the problems of computing.
At the same time that these <I>disparate</I> technologies have
converged, there have also been pressures from <I>within</I> computing
to bring together disciplines historically considered unrelated.
This convergence within computing has been brought about by various
pressures that have arisen:
<UL>
<LI><FONT COLOR=#000000>An overwhelming need to deal with the
</FONT><I>software crisis </I>has developed. This term has been
coined to describe problems that have plagued the software community.
Software development has been marred by high cost, low quality,
and ever-increasing demand; these problems have been both caused
and exacerbated by increasing software complexity. Because of
these trends, there is tremendous interest in any technique that
can increase the productivity of software developers, improve
reliability, and make it easier to design software that tackles
complex problems. Over the last decade the technology that has
been viewed as having the best chance of successfully dealing
with these problems is <I>object-oriented programming</I>. Object-oriented
features of abstraction, encapsulation, and modularity are particularly
well suited for making complex real-world problems easier to model
and, hence, design. A true object-oriented language's support
for inheritance and dynamic binding improves software reuse and
also, as a consequence, programmer productivity. The garbage collection
facility in some object-oriented languages improves <I>reliability</I>
by freeing the programmer from the intricate concerns of memory
management.
<LI><FONT COLOR=#000000>The predominance of a variety of operating
systems and platforms has created a heavy demand for </FONT><I>portable</I>
software. Programs need to be written that will not only run on
several different platforms, but do so in a way that fits into
the native &quot;look and feel&quot; of the environment. Furthermore,
portable software needs to have the <I>high performance</I> that
is typical of the software written for the target platform. Interest
in soft-ware that is portable but slow is waning rapidly.
<LI><FONT COLOR=#000000>The rapid growth of computer networks
has been matched by a corresponding rise of interest in </FONT><I>distributed
computing</I>. This discipline is concerned with the problems
of software distributed across multiple computers. Distributed
computing issues include interprocess communication, concurrent
processing, data sharing and replication, and security. Although
the Internet is the most well-known distributed environment, it
is in just the early stages of using the full potential of distributed
computing. Until recently, for example, there has been no solution
to the problem of dynamically downloading an application both
efficiently and securely. <I>Efficiency</I> is important since
you want to download only the code you need when you need it;
you don't want to wait thirty minutes to download a 3MB application.
Even more important, you need to be concerned with the <I>security</I>
of the code. You won't run applications from the Internet if it
means giving the green light to hackers around the world to attack
your hard disk. You also do not want a poorly written Internet
application to crash your system-the software has to be <I>reliable</I>.
</UL>
<P>
Each of these problems has been seriously addressed from many
fronts, but no approach has simultaneously addressed all these
problems. For example, there might be a programming language that's
good for rapid development but isn't portable, or a development
environment might be portable, but could not work in a distributed
environment without opening you up to serious breaches of security.
A single solution to all these problems has been lacking&#133;until
Java!
<H3><A NAME="WhyJavaIsaComprehensiveSolution">Why Java Is a Comprehensive
Solution</A></H3>
<P>
The designers of Java created a programming environment to attack
each and every one of these problems. As a comprehensive solution
to these pressing issues, Java needs to be understood as not just
a programming language, but as a general-purpose environment.
Its unique combination of a programming language, compiler, and
runtime environment provides a general architecture well suited
for addressing many of the concerns that have been plaguing the
computing community for years. This general development environment
is often referred to with the solitary term <I>Java</I>.
<P>
In part, Java's evolution into a comprehensive solution stems
from its twisted history of being a language for general consumer
electronics to being one for PDAs and set-top boxes for interactive
television. Features common to each of these potential platforms
include severe memory constraints and the need to support multiple
operating systems. These problems forced the language to address
the problems of distributed computing, efficiency, security, portability,
and reliability. For Java to be a successful language, furthermore,
it would also have to address the problems associated with the
software crisis-it would need to be object-oriented.
<P>
Being object-oriented carried another bonus for Java. The object-oriented
message-passing model of invoking class methods makes it a natural
for network-based application development. Consequently, being
object-oriented is one of the cornerstones of Java, so it's a
good place to begin a tour of its general architectural features.
<H3><A NAME="WhyObjectOrientedIsImportant">Why Object-Oriented
Is Important</A></H3>
<P>
Why is it important for Java to be an object-oriented language?
As stated before, modern programming languages need to address
the problems of the software crisis. Perhaps the most serious
difficulty a software engineer encounters is the inherent complexity
involved in modeling a real-world problem. Through the past decades
of computing, analysis techniques have come in and out of fashion
that aim to make modeling the world a more comprehensible and
stable practice. When you were taking your first classes in programming,
you might have seen flowcharts used as a modeling tool. The Structured
Analysis school of thought uses data flow diagrams to model the
world. These approaches have some contributions to make, but they
have one serious problem: they are heavily oriented toward the
<I>procedural</I> side of the activities being modeled. The problem
with a procedural approach is that it does not translate well
to software that is compact, easy to maintain, and reusable. In
its worst implementations, a system based on the procedural model
has a different function for every different type of procedure
that could occur. You have probably seen such systems-they are
so incomprehensible and hard to follow that the only goal of the
poor soul who has to maintain the system is to &quot;just make
it work.&quot;
<P>
Object-oriented analysis, design, and programming is a radical
departure from the procedural model. Its focus is not on the procedures
of the modeled world, but on the <I>objects</I> appearing in it.
Objects are a natural thing to model because that's what the world
is made of. Planes, dogs, and computers are all objects. Even
abstract concepts, such as a priority queue, can be thought of
as an object. What all objects have in common is that they have
<I>state</I> and <I>behavior</I>. For example, the state of a
plane can be partially indicated by its speed and location, but
its behavior might be represented by its ability to change altitude.
<P>
Another feature of objects is that they are self-contained; in
other words, they are <I>modular</I>. When modeling a car engine,
for example, you can focus on the characteristics of each object
in the engine as opposed to the flow of gas and energy through
it. The object model breaks the engine down into a series of components
that can be described on their own terms, as opposed to what they
are in a complex global view of things. Instead of writing a single
huge procedure describing what's going on in the car, you can
focus on how each of the individual elements behaves.
<P>
Finally, objects have the quality of being hierarchical. A large
complex object, a house, for example, consists of other objects,
such as its physical structure, the electrical system, the plumbing,
and so forth. These are in turn made up of yet other objects,
such as a chimney, the light switches, and a sink. These can be
broken down into yet smaller components such as wood, wires, and
pipes. By modeling a system based on <I>hierarchy</I>, you can
use the model of smaller, more easily understood objects, such
as a wire, to construct more complex objects, such as a light
switch. Since the switch is now seen as an object that consists
of yet simpler objects, its complexity is easier to understand
and manage.
<P>
In object-oriented systems, objects communicate through a <I>message-passing</I>
mechanism. When an object receives a message, it may change its
state and behavior as part of the response. For example, sending
a message of &quot;play&quot; to a CD player object might result
in the CD playing a music track. This message-passing aspect of
objects translates very nicely into the needs of network programming,
where transactions are carried out by the mechanism of messages.
It is particularly well suited to distributed systems because
objects communicate by a standard message-passing mechanism, in
which the actual location of the objects becomes less important.
If your object needs to talk to an object, it isn't particularly
important if it is on your computer or a remote host. All that
really counts is that the object gets your message.
<H3><A NAME="JavaasanObjectOrientedLanguage">Java as an Object-Oriented
Language</A></H3>
<P>
Java is unusual for an object-oriented programming language in
that it is &quot;objects all the way down.&quot; Unlike C++, which
is a confusing combination of objects and functions, everything
in Java is an object. Strings are objects, numbers are objects,
threads are objects, even applets are objects. Because of this,
Java has all the helpful features of object-oriented systems just
described. Its core constructs of classes, objects, methods, and
instance variables are, by their very nature, managed in a modular
fashion. Java's support for inheritance allows you to build new
classes from other classes. Each class you construct becomes a
tool that can be used to create yet more complex classes.
<P>
Java's particular object-oriented implementation allows it to
have yet even more desirable features than those already discussed.
It has a runtime <I>garbage collector</I> that removes objects
from memory that you no longer need. No longer will your program
run out of memory because you forgot to explicitly delete an object.
The garbage collector, which your program doesn't even have to
be aware of, does this for you. Furthermore, Java's total orientation
toward objects removes another construct that has been a blight
of programmers-the pointer. Java hides almost all aspects of memory
management from the programmer. C or C++ programmers who have
had to deal with complex bugs caused by the misuse of pointers
or bad pointer arithmetic will no longer have to deal with this
entire class of problems. In Java, you will never deal with pointers,
only objects. Because of this combination of garbage collection
and removal of the pointer construct, Java has generally taken
the problem of memory management away from you. Consequently,
programs written in Java are more <I>reliable</I>.
<P>
Java's unique object-oriented implementation gives it another
set of desirable characteristics-<I>simplicity</I> and <I>familiarity</I>.
In many ways, its syntax is similar to C and C++, thus making
it familiar. On the other hand, it strips out all the programming
constructs of this language that are historical artifacts contributing
little to writing object-oriented programs. For example, the structure
construct is removed because everything in Java is an object.
Unions are removed because they make you think too much about
how memory is laid out, a low-level memory consideration that
Java's garbage collection and removal of pointers tries to abolish.
Other procedural features of C and C++ that are removed include
functions, which are replaced by class methods; preprocessor constructs,
such as <TT>typedef</TT> and <TT>ifdef</TT>;
the hated <TT>goto</TT> statement;
and, of course, pointers. Java also replaces the complex and troublesome
multiple inheritance of C++ by a simpler combination of single
inheritance and interfaces. With all these features in mind, Java
becomes a simpler and easier language to use.
<P>
Java has all the object-oriented features discussed in the previous
section. It uses message passing to let objects communicate, and
it supports <I>dynamic binding</I>, allowing a message to be sent
to an object even though its specific type may not be known until
runtime. Abstract classes and interfaces enable you to specify
a design without having to worry about a specific implementation.
With Java's access control constructs, you can define different
levels of access to your class's methods and variables that are
available to external classes.
<H3><A NAME="JavaasaPortableEnvironment">Java as a Portable Environment</A>
</H3>
<P>
<I>Portability</I> is critical to success in the emerging world
of networked applications and commerce. On the Internet, you cannot
make assumptions about what kind of platform your applet will
run on. Not only do you have to write software that will run on
the client's underlying architecture-such as 80x86, PowerPC, or
68000 series-but you must also ensure it will have the correct
look and feel of the native interface. To make things even tougher,
this software needs to be fast and compact.
<P>
Java takes a multipronged approach to this challenge. At the heart
of this approach is the fact that the Java compiler generates
<I>bytecodes</I> that are <I>interpreted</I> at runtime. The fact
that bytecodes are generated is important because it avoids the
problem of basing the binary code on a basic set of primitive
types-such as integers and floating point-that would be tied to
a specific platform. For example, even something as simple as
an integer data type is implemented in a different manner on different
platforms (16-bit on some, 32-bit on others). Java defines its
own set of primitive data types and reconstructs large 16-bit
or 32-bit values at runtime by composing them out of individual
bytecodes. Java consistently uses the big-endian format to do
this, thus avoiding another portability conflict about how platforms
store primitive data types. You can also quickly and efficiently
convert the bytecodes at runtime to the underlying native formats
if necessary. In short, Java's underlying encoding scheme is <I>architecture-neutral</I>.
<P>
The bytecode-based system is important to writing a portable interpreter.
The bytecodes generated by the compiler are based on the specification
of a <I>Java Virtual Machine,</I> which, as its name suggests,
is not a specific hardware platform but a machine implemented
in software. The virtual machine is very similar to a real CPU
with its own instruction set, storage formats, and registers.
Since it is written in software, however, it is portable. All
that's needed to take Java code compiled on one platform and run
it on another is to provide a Java interpreter and runtime environment.
The runtime system is written in an easily portable fashion. Once
you have this system, everything becomes easy. You don't even
have to port the Java compiler-it is written in Java!
<P>
Another advantage of the Java interpreter is that it improves
software development by eliminating the link phase of the development
process. You can go straight from compiling your code to executing
it. Linking actually occurs at runtime through mechanisms discussed
in the section &quot;Java as a Secure Environment.&quot;
<P>
A couple of higher-level features also improve Java's portability.
The Abstract Window Toolkit (or AWT) is constructed to be a visual
interface that is portable across platforms. This way your applets
will look good regardless of the underlying interface. They will
have the proper &quot;look and feel&quot; on Microsoft Windows,
the Macintosh, or X-Windows. Although not a portability issue
in the strict sense, Java stores characters by using the 16-bit
Unicode format as opposed to the 8-bit ASCII standard. Unicode
is used if you need to support international character sets. Since
the Internet is an international network, this consideration is
important.
<H3><A NAME="JavaasHighPerformance">Java as High Performance</A>
</H3>
<P>
One of the reasons why Java's portable solution is such a coup
is that interpreted platforms have generally been very slow. Often
their performance is so poor that systems based on these interpreters
have been unusable. Java's bytecode system, however, provides
a &quot;lean and mean&quot; interpreted solution. It isn't based
on multimegabyte executable &quot;image&quot; files. Rather, the
runtime system works with small binary <I>class files</I> compiled
to Java virtual machine code. These files typically have a size
of only a few kilobytes.
<P>
However, Java offers more than just the byte-code system to get
high performance. Since the byte-code system is at a low level,
it can be easily converted at runtime to the native platform.
Just-in-time Java compilers will be out in the near future to
allow this. Another performance enhancement is a by-product of
another Java feature. When a class is brought into memory at runtime,
it runs through a verification process as part of the Java security
mechanism (discussed in the section &quot;Java as a Secure Environment&quot;).
This process not only guarantees that the code you are loading
is secure, but the end result is code that requires less runtime
checks. These checks, which otherwise would hurt performance,
now don't need to be executed. For example, the runtime system
does not have to check for stack overflows on verified code.
<P>
One of the key features that Java offers to improve performance
is <I>multithreading.</I> Most interactive applications are characterized
by large periods of time during which the user pauses between
actions to decide what to do next. In traditional single-threaded
environments, the application may sit idle during such periods.
In multithreaded environments, however, the application can perform
other tasks during these types of delays or at any other time.
This is critical for network applications, which can take long
periods of time to load files. Wouldn't it be more efficient if
you could read the current page of text while the next page is
being downloaded? Multithreading also greatly improves the usability
of multimedia applications. For example, you need to be able to
interact with your system while a sound or a movie is playing.
Multithreading is useful for even more down-to-earth things, such
as running a background thread that spell checks your document
as you are typing in words.
<P>
You can use Java's easy-to-use multithreading environment to perform
all kinds of optimizations to your program. In fact, the designers
of Java have taken great pains to make sure it's easy to write
multithreaded programs. Historically, writing multithreaded applications
has been quite difficult-a key reason they have appeared infrequently.
Furthermore, Java uses threads to improve its own performance.
The garbage collector that takes care of your memory management
concerns runs in the background as a low-priority thread. So even
when your program is doing nothing, the garbage collector could
be busy optimizing memory!
<P>
There are some other interesting things Java does to guarantee
good performance. As stated earlier, Java is &quot;objects all
the way down.&quot; In some object-oriented systems, primitives
such as integers and floating point numbers are implemented only
as objects. So to perform an operation such as adding two numbers,
you actually have to call an object method. If you are doing some
serious number crunching, this will absolutely kill your performance.
Java has an intermediate solution to resolve the dilemma between
having good performance and being a pure object-oriented system.
It implements &quot;type wrappers&quot; to take primitives, such
as numbers, and make them appear as objects. This way, methods-such
as converting numbers to strings-can be performed by using the
object-oriented method style. However, if you need to work with
raw data types, you can use the primitive formats to produce such
things as CPU-intensive images like fractals. Java can even be
used to create the computation-hungry Mandelbrot set. It's rather
remarkable that Java can do this; if you don't believe it can,
then see <A HREF="ch14.htm" >Chapter 14</A>, &quot;Advanced Image
Processing.&quot;
<P>
If you really need that final push to your performance, Java can
link to executable code written in a low-level native language
such as C. Java code that does this is said to use <I>native methods</I>.
This technique can also be used to implement platform-specific
features. However, using native methods is not without its drawbacks;
it will probably compromise the portability of your code. Fortunately,
Java performance is generally good enough that you don't need
to bring in native methods very often.
<P>
Finally, it is important to remember that the Java community is
constantly working on techniques to improve performance but not
compromise all the other features of Java, such as portability.
The just-in-time compilers that will be out later this year are
among the most impressive of such optimizations.
<H3><A NAME="JavaintheWorldofDistributedComputin">Java in the World
of Distributed Computing</A></H3>
<P>
Much of what has been discussed so far makes Java well suited
for network computing. In particular, the lightweight nature of
the binary class files makes it possible to download Java code
without serious performance hits. Multithreading is also critical
for latency-laden network operations; your applet can download
code and resources in the background while the end user is deciding
the next action to take. Portability frees you from knowing how
your applet will run and what it will look like on your potential
client's unknown platform.
<P>
Another feature of Java that makes it excellent for distributed
computing is that it's <I>dynamic</I>. Since there is no linking
phase after compilation, the resolution of references is put off
until runtime. Java also does not calculate the layout of objects
in memory until they are used at runtime. Consequently, if you
add a new method to one class, you don't have to recompile another
class that uses the class but not the method. In C++, you are
constantly having to recompile multiple classes because one is
&quot;dependent&quot; on the other-this is known as the &quot;fragile
superclass problem.&quot; In its typical efficient manner, Java
solves the superclass problem while taking care of other issues.
Since the Java dynamic system removes difficulties caused by unnecessary
dependencies, it's easy to download a special subclass to handle
a specific situation without worrying about &quot;linking&quot;
problems.
<P>
The Java development package also gives you a variety of good
communication constructs. The message-passing mechanism of its
objects can be used to let two different applets communicate;
this is known as &quot;inter-applet communication.&quot; Sockets,
pipes, and thread synchronization constructs also provide other
easy-to-use communication mechanisms. In short, Java provides
all the basics for creating distributed systems.
<H3><A NAME="JavaasaSecureEnvironment">Java as a Secure Environment</A>
</H3>
<P>
Although distributed systems are extremely powerful, they open
the door to a range of security problems, which are particularly
serious on a vast open network like the Internet. For normal data
transmission, you have to be concerned with someone eavesdropping
on your information as it passes through the network. If you have
a server on the Internet, you have to worry about someone breaking
in and wreaking havoc on your internal network. And if you're
downloading applications from the net, you have to worry about
it causing damage to your host system.
<P>
The kind of damage a poorly written application could inflict
on your host spans a range of extremes. On one hand, a poorly
written application can misuse the resources of your system, taking
resources you might need elsewhere. For example, a C program that
mismanages memory can simply take memory that another one of your
applications needs. If the program is really bad, it can cause
your system to lock up. Fortunately, it's usually easy to recover
from such problems. However, the other end of the extreme is not
quite so innocent. A malicious program can attack some of the
most critical resources of your computer, such as your hard disk,
causing damage less easily fixed. If the program is a virus, it
can be even more pernicious. It can lie in wait for weeks or even
months, then one day pounce on your computer and connecting network,
causing hours or even days of lost work time. If this attack came
from an application that you ran from the World Wide Web, you
would probably be reluctant to use the Web again. Consequently,
bad Web programs not only threaten your system, but the viability
of the Web as a whole.
<P>
The designers of Java know just how important security is. For
this reason, they built a multi-layered security system whose
presence is felt throughout Java. This security model consists
of four main layers:
<UL>
<LI><FONT COLOR=#000000>The </FONT><B>language</B> itself is designed
to be safe. A strict <B>compiler</B> prevents generating bytecodes
that don't completely follow extensive safety rules.
<LI><FONT COLOR=#000000>A runtime </FONT><B>bytecode verifier</B>
that inspects class bytecodes as they are loaded into the system.
Since code loaded at runtime has already passed through the compilation
stage, Java cannot know that it hasn't been produced by a malicious
or weak compiler that does not follow all the language's safety
rules.
<LI><FONT COLOR=#000000>Once code has been verified, it needs
to be loaded into a runtime namespace. This is performed by a
module called the </FONT><B>Class</B> <B>Loader</B>, represented
by a like-named class. Java has a different namespace depending
on whether the loaded class came from a local file system or across
a network. These separate namespaces prevent a class from passing
itself off as a new low-level class. Therefore, it can't do such
things as replacing the existing Security Manager (discussed briefly
in the next bulleted item).
<LI><FONT COLOR=#000000>The final layer performs checks on the
code as it's being executed. This layer makes sure the code does
not violate any security restrictions defined for the current
environment; it's generally represented by a module called the
</FONT><B>Security Manager</B>, which corresponds to a Java class
of a similar name. An applet that can delete a file on your computer
is an example of something that falls under the auspices of the
Security Manager. The workings of Security Managers can vary on
different environments. Extremely conservative Java-enabled browsers,
such as Netscape Navigator, actually prevent applets from reading
or writing to your local file system altogether. The HotJava browser,
on the other hand, can be configured to authorize file operations
more flexibly.
</UL>
<P>
Figure 1.1 gives an overview of the lifetime of Java code as it
travels through the layers of security. Those modules related
to security are set off in boldface.
<P>
Since security is such a critical part of Java, it is worth taking
a moment to look at it in greater detail. In doing so, you will
get some greater insight into the inner workings of Java.
<P>
<A HREF="f1-1.gif" >Figure 1.1 : <I>The Java life</I>-cycle in relationship to its security layers.</A>
<H4>First Security Layer: The Language and Compiler</H4>
<P>
You have already seen a couple of reasons why Java is a secure
language. A key ingredient here is removing pointers from Java.
Without pointers, a bad or malicious program cannot invade the
memory space of other applications. This removes a major source
of attack for viruses. For example, a threatening program cannot
use Java as a launching pad to directly attack your operating
system kernel. Furthermore, the absence of pointers makes the
Java applet itself more secure and reliable. An applet won't crash
because of a &quot;dangling pointer,&quot; as is often the case
in C and C++.
<P>
Another security feature of the language is its class access mechanism.
Classes can control the kinds of access other classes have to
their methods and variables. There are four access modifiers,
ranging from <TT>public</TT>, which
indicates availability to all classes, to <TT>private</TT>,
which makes a method or variable accessible only from within the
class where it's defined. These modifiers can make your class
more secure by denying other classes access to critical behavior.
For example, if you have a class that manages critical data in
a private method, another class cannot invoke that method to change
the data. Access modifiers will be discussed in more detail in
the next section.
<P>
The compiler uses very strict checking to ensure adherence to
these and other Java language constructs. Java is a strongly typed
language, so runtime bugs aren't introduced because of freely
casting one type of object to another. A language like C is notorious
for its loose casting mechanism. A pointer to a structure can
be fairly easily cast into a long integer, and vice versa. When
such casting is done incorrectly, pernicious and difficult-to-find
bugs can be introduced, but this kind of casting is eliminated
in Java. All casts must be explicit, and those that don't follow
the semantics of the language are disallowed. Because the compiler
is so strict, many errors that would otherwise appear at runtime
are caught at compilation. Since runtime bugs are potentially
dangerous and can be time-consuming and difficult to track down,
it's good to catch as many mistakes as possible during compilation.
Java's strict compiler is one reason the environment is said to
be <I>robust</I>.
<H4>Second Security Layer: The ByteCode Verifier</H4>
<P>
The bytecode verifier is the most critical line of defense in
the Java security system. If a rogue class can get through this
layer, you could be in real trouble! However, this is unlikely.
The verifier uses various techniques, including a theorem prover,
to ensure that the bytecodes of the class being loaded do not
violate any of the structural constraints Java places on incoming
code. The verifier is, therefore, positioned to catch any potential
malicious actions caused by bytecodes produced by a hostile compiler
or subject to post-compilation tampering.
<P>
Verification goes through a couple of steps. The first step is
to verify the format of the incoming file to make sure it is indeed
a Java class and has been properly constructed. The next step
is much more complex. The verifier basically sets out to prove
that the code has a variety of properties. If the bytecodes make
it through this phase of the verifier, then you'll know the following
things:
<UL>
<LI><FONT COLOR=#000000>The code does not cause stack overflows
or underflows.</FONT>
<LI><FONT COLOR=#000000>The operand types of the bytecode opcodes
are proper. For example, an opcode that works with an integer
operand cannot have an operand that is an object reference.</FONT>
<LI><FONT COLOR=#000000>No illegal casting is attempted.</FONT>
<LI><FONT COLOR=#000000>Object access rules are followed.</FONT>
</UL>
<P>
As a result of these properties being proved, the runtime system
will know a couple of other important things, the most important
being no forged pointers in the code.
<P>
A beneficial side effect of the verification process is that the
interpreter is free from performing many of these checks as the
code is being executed. For example, it does not need to conduct
expensive checks to see if a stack overflow is about to occur.
Because such checks are not necessary, the interpreter will run
much faster.
<P>
Another security-related step occurs when the interpreter loads
the verified bytecodes. When the interpreter brings in a class,
it defines the <I>memory layout</I> of the class. Recall that
this is a feature of Java's dynamic linking used to solve the
&quot;fragile superclass&quot; problem. Dynamic linking also has
a security advantage. In traditional languages, memory is laid
out at compile time. A malicious programmer, knowing the layout
of memory in the executable code, could then tamper with the pointers
to get around security problems. Since Java performs memory layout
at runtime, however, this potential security bypass is thwarted.
<H4>Third Security Layer: The Class Loader</H4>
<P>
After a class is verified, it's ready for runtime use. The Class
Loader brings each class into a unique <I>namespace</I> that corresponds
to its origin. The default namespace is for classes that come
from the local file system. Such classes are called <I>built-ins</I>;
they can never be replaced by a class that comes from an external
source because there is a separate namespace for each network
source of classes. When a class is referenced, Java looks first
for a built-in class. If it isn't found, then Java inspects the
namespace of the referencing class. This approach prevents network
classes from replacing a built-in, or a class from one network
source overriding one from another source. The security implications
of this approach are subtle but important. Java tries to implement
as much as possible through Java classes; for example, the Security
Manager module is represented by a SecurityManager class, you
get access to system resources through the System class, and,
as will be seen shortly, class loader policies are implemented
by ClassLoader classes. By preventing built-ins from being overridden,
Java protects critical modules, such as the SecurityManager or
System. It's easy to imagine what could happen if a network class
was allowed to replace the SecurityManager class.
<P>
Subclasses of the ClassLoader class are used to enforce namespace
policies. The Class Loader system can consist of multiple instances
of ClassLoader subclasses. For example, one Class Loader can be
used for classes brought from inside a firewall, but another Class
Loader class can be used for those brought in from the Internet.
The local file system, by default, does not use a ClassLoader
class. Instead, it searches for classes in directories listed
in the <TT>CLASSPATH</TT> environment
variable; you can modify this path to include the directories
that have your classes. Keep in mind that there's a subtle difference
between the Class Loader mechanism, which applies to the entire
Java runtime environment, and instances of the ClassLoader class,
which implement specific policies.
<H4>Fourth Security Layer: The Security Manager</H4>
<P>
Even after a chunk of bytecode has gotten past the verifier and
the class loader, it is still technically in a position to cause
some damage. Suppose that a class downloaded from the Internet
has some code to delete files from your hard disk. This can be
done legitimately by calling the <TT>delete()</TT>
method of the File class and so will pass the verifier and class
loader. Fortunately, the final security layer, represented by
the SecurityManager class (also known as the Security Manager),
will prevent this from occurring. The Security Manager is responsible
for enforcing a set of policies for protecting the runtime environment
from unauthorized transactions. Whenever a potentially &quot;dangerous&quot;
action is about to happen, the Security Manager is asked for authorization
to perform the action. Based on how the manager is implemented,
the action may be denied or granted.
<P>
Different browsers and applet viewers can use the Security Manager
in an appropriate way. Once installed into the runtime system,
the Security Manager cannot be replaced. These browsers may grant
levels of authorization for different actions. For example, the
Netscape Navigator has a very conservative Security Manager. The
most dangerous class of actions, those of reading and writing
from the hard disk, are prohibited altogether. On the other hand,
the HotJava browser has a more flexible configuration. It can
be set up to grant full disk access from applets loaded locally,
some access to applets loaded from within the firewall, and no
access for those brought in over the Internet.
<P>
A wide variety of actions are subject to authorization by the
Security Manager. When a class is asked to perform a potentially
dangerous action, such as a file delete, it will ask the SecurityManager
class for authorization. If it isn't permitted, a security exception
will occur. Besides all file-related activities, the actions of
the most importance to security are network accesses. Once more,
restrictions are usually based on how the SecurityManager is set
up, but there are a few generalities. An applet loaded over the
Internet can connect only to the host from which it originated;
it will not be allowed to connect to anywhere from inside the
client's firewall, nor will it be permitted to use the client
to act as a launching pad into some other Internet site. An applet
is also prevented from running as a network server (this has some
implications that are explored later). Restrictions enforced by
the SecurityManager will be discussed throughout the book as the
appropriate topics dictate.
<H2><A NAME="GeneralFeaturesoftheJavaProgramming"><FONT SIZE=5 COLOR=#FF0000>General
Features of the Java Programming Language</FONT></A></H2>
<P>
You will now be guided through a very quick tour of the basics
of the Java language. If you have experience with C or C++, then
much will be familiar-you might want to skip over parts of this
section. If you don't know these languages, don't worry. The basic
mechanics of the language are easy, and you will see many examples
throughout the book. Discussion of classes, methods, and objects
will be postponed until the next chapter.
<H3><A NAME="DataTypes">Data Types</A></H3>
<P>
As stated earlier, everything in Java is an object. The <I>partial</I>
exception to this is the primitive data types. These data types
have a standard size across all platforms; this standardization
is a key aspect of Java's portability. Table 1.1 lists the primitive
data types.<BR>
<P>
<CENTER><B>Table 1.1. Primitive Java data types.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=88><I>Data Type</I></TD><TD WIDTH=150><I>Size</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>byte</TT></TD>
<TD WIDTH=150>8-bit</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>short</TT></TD>
<TD WIDTH=150>16-bit</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>int</TT></TD>
<TD WIDTH=150>32-bit</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>long</TT></TD>
<TD WIDTH=150>64-bit</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>float</TT></TD>
<TD WIDTH=150>32-bit floating point</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>double</TT></TD>
<TD WIDTH=150>64-bit floating point</TD></TR>
<TR VALIGN=TOP><TD WIDTH=88><TT>char</TT></TD>
<TD WIDTH=150>16-bit Unicode</TD></TR>
</TABLE></CENTER>
<P>
<P>
If you are a C or C++ programmer, you might have noticed a couple
of things. First of all, there is no <TT>unsigned</TT>
type specifier. The <TT>char</TT>
data type has been replaced by the <TT>byte</TT>
primitive. The <TT>char</TT> type
is now 16 bits, instead of the old 8 bits, because Java bases
character data on the Unicode character set. Unicode is a standard
that supports international characters, thus broadening the potential
base in which your application can run. Although Unicode is a
much broader standard than ASCII, you will probably have many
opportunities to program in the 8-bit standard. Some default class
behavior and localization methods will be available for doing
this. This book will focus on ASCII output.
<P>
The only primitive data type not in Table 1.1 is <TT>boolean</TT>.
A <TT>boolean</TT> variable cannot
be converted to a number and has only two values: <TT>true</TT>
or <TT>false</TT>.
<P>
You might have noticed that these primitive data types present
a <I>partial</I> exception to Java's pure object-oriented nature.
It is &quot;partial&quot; because Java has a suite of classes
used to encapsulate these data types as objects. These classes
are called <I>type wrappers</I> and are discussed in <A HREF="ch2.htm" >Chapter 2</A>,
&quot;Object-Oriented Development in Java.&quot;
<H3><A NAME="Literals">Literals</A></H3>
<P>
<I>Literals</I> are used to represent the primitive types. Integers
are defined in a manner similar to C. They can be literally set
to a decimal value, such as 10. A hexadecimal value is indicated
with a leading 0x; 15 is represented by 0xF. Octal values (base
8) are prefaced by 0.
<P>
Floating point numbers are represented by the standard decimal
point notation, such as 3.1415. These can be stored as a 32-bit
<TT>float</TT> or a 64-bit <TT>double</TT>;
the latter is the default. The notation style of 6.1D or 6.1F
can also be used to designate the number as a <TT>double</TT>
or <TT>float</TT>, respectively.
<P>
Characters can be represented by a single character in quotes
such as <TT>'a'</TT>. Escape sequences
are used to represent special characters and are preceded by a
backslash (<TT>\</TT>). For example,
tab is <TT>\t</TT>, newline is <TT>\n</TT>,
and so forth. See your Java references for a listing of all the
escape characters.
<P>
The last literal is not based on a primitive data type. Strings
are represented by zero or more characters in double quotes. An
example is <TT>&quot;This is a Java book!&quot;</TT>.
The literal string can also use escape characters. For example,
to add a new line to the previous example you would write: <TT>&quot;This
is a Java book!\n&quot;</TT>.
<P>
String literals are implemented as objects of the String class.
Operations on strings do not occur on character arrays (as in
C), but through class methods; these operations are discussed
in more detail in the next chapter.
<H3><A NAME="Variables">Variables</A></H3>
<P>
Java has three types of variables: <I>instance</I>, <I>class</I>,
and <I>local</I>. The first two types are talked about in the
next chapter in the context of the discussion on classes. Local
variables can be declared inside methods or blocks. <I>Blocks</I>
are statements appearing in braces { }. Any local variable declared
inside a left brace is valid until the right brace, at which point
the variable goes out of scope.
<P>
Individual variables are declared in the general format:
<BLOCKQUOTE>
<TT>&lt;type&gt; &lt;variable name&gt;</TT>
</BLOCKQUOTE>
<P>
For example, to declare a <TT>double</TT>
called pi:
<BLOCKQUOTE>
<TT>double pi;</TT>
</BLOCKQUOTE>
<P>
You can also asign a value to it:
<BLOCKQUOTE>
<TT>double pi = 3.1415;</TT>
</BLOCKQUOTE>
<P>
Variable names are prefaced by letters, an underscore, or a dollar
sign. They can use most characters, including numbers. However
some symbols, such as those used in operators, should not be used.
For example, you should not call a variable <TT>pi+3.</TT>
<H3><A NAME="Comments">Comments</A></H3>
<P>
Java has three comment styles. Two are similar to those used in
C and C++. A double slash (<TT>//</TT>)
means that everything to the end of the line should be ignored:
<BLOCKQUOTE>
<TT>// Ignore this</TT>
</BLOCKQUOTE>
<P>
Everything between the characters <TT>/*</TT>
and <TT>*/</TT> is also ignored. This
can be spread over several lines. If the first part of the comment
starts with <TT>/**</TT>, then a special
documenting feature is indicated. How this works is discussed
in <A HREF="ch14.htm" >Chapter 14</A>.
<H3><A NAME="Operators">Operators</A></H3>
<P>
Table 1.2 lists a quick summary of operators in Java, which are
fairly simple to use. The following code declares two integers,
assigns values to them, and adds them to a third variable:
<BLOCKQUOTE>
<TT>int x,y;<BR>
x = 3;<BR>
y = 4;<BR>
int z = x + y;</TT>
</BLOCKQUOTE>
<P>
The final value is <TT>7</TT>.
<P>
The following code applies the bitwise <TT>AND</TT>
operator to the end of the previous example to get the value <TT>4</TT>.
<BLOCKQUOTE>
<TT>int q = z &amp; 4;</TT>
</BLOCKQUOTE>
<P>
You'll see examples of other categories of operators in the upcoming
sections.<BR>
<P>
<CENTER><B>Table 1.2. Classification of operators.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=300><I>Classification</I></TD><TD WIDTH=203><I>Operators</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Arithmetic</TD><TD WIDTH=203>+ - * / %</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=300>Relational Operators</TD><TD WIDTH=203>&lt; &gt; &gt;= &lt;= == != &amp;&amp; || !
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Bitwise Operators</TD><TD WIDTH=203>&amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt; ~ &amp;= |= ^=
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Assignments</TD><TD WIDTH=203>= += -= /= %=
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Bitwise Assignments</TD><TD WIDTH=203>&amp;= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= ^=
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Ternary Operator (<TT>if...else</TT> shorthand)
</TD><TD WIDTH=203>?:</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Increment</TD><TD WIDTH=203>++</TD></TR>
<TR VALIGN=TOP><TD WIDTH=300>Decrement</TD><TD WIDTH=203>--</TD></TR>
</TABLE></CENTER>
<P>
<P>
Expressions that have multiple operators are resolved according
to where they are in a hierarchy of precedences, shown in Table
1.3. Operators higher up in the precedence table are evaluated
first. If multiple operators on the same line have the same precedence,
then they are resolved by left-right order. If you are confused
or cannot remember precedence, then a nice rule is &quot;When
in doubt, use parentheses.&quot;<BR>
<P>
<CENTER><B>Table 1.3. Operator precedence.</B></CENTER><P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=40%>
<TR VALIGN=TOP><TD WIDTH=176>. [] ()</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>++ - ! ~</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>* / %</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>+ -</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>&lt; &gt; &lt;= &gt;=</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>== !=</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>&amp;<BR>
^</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>|</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>&amp;&amp;</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>||</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>?:</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>= and other assignments</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>Bitwise Assignments</TD></TR>
</TABLE></CENTER>
<H3><A NAME="KeywordsandConditionals">Keywords and Conditionals</A>
</H3>
<P>
Table 1.4 lists Java keywords; they are reserved for Java statements,
so you can't use them for things like variable names. They are
identifiers for such things as data types, conditionals, control
flow constructs, class definitions, and object implementations.
Most of these keywords will be described in this and the next
chapter. Those that are reserved but currently not implemented
are italicized.<BR>
<P>
<CENTER><B>Table 1.4. Java keywords</B>.</CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=80>Abstract</TD><TD WIDTH=106>boolean</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>break</TD><TD WIDTH=106>byte</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80><I>byvalue</I></TD><TD WIDTH=106>case</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>catch</TD><TD WIDTH=106>char</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>class</TD><TD WIDTH=106><I>const</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>continue</TD><TD WIDTH=106>default</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>do</TD><TD WIDTH=106>double</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>else</TD><TD WIDTH=106>extends</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>false</TD><TD WIDTH=106>final</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>finally</TD><TD WIDTH=106>float</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>for</TD><TD WIDTH=106><I>goto</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>if</TD><TD WIDTH=106>implements</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>import</TD><TD WIDTH=106>instanceof</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>int</TD><TD WIDTH=106>interface</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>long</TD><TD WIDTH=106>native</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>new</TD><TD WIDTH=106>null</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>package</TD><TD WIDTH=106>private</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>protected</TD><TD WIDTH=106>public</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>return</TD><TD WIDTH=106>short</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>static</TD><TD WIDTH=106>super</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>switch</TD><TD WIDTH=106>synchronized</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>this</TD><TD WIDTH=106>threadsafe</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>throw</TD><TD WIDTH=106>transient</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>true</TD><TD WIDTH=106>try</TD></TR>
<TR VALIGN=TOP><TD WIDTH=80>void</TD><TD WIDTH=106>while</TD></TR>
</TABLE></CENTER>
<P>
<P>
An <TT>if...else</TT> conditional
is used to execute code based on whether a <TT>boolean</TT>
test is <TT>true</TT>. Single statements
can follow, or multiple statements can be declared in braces:
<BLOCKQUOTE>
<TT>if (test == true)<BR>
&nbsp;&nbsp;// ... A single statement to execute if test if true
<BR>
else {<BR>
&nbsp;&nbsp;// ... multiple statements to execute if test if false
<BR>
}</TT>
</BLOCKQUOTE>
<P>
The test must return a <TT>boolean</TT>
value. This means an expression such as
<BLOCKQUOTE>
<TT>if (1)</TT>
</BLOCKQUOTE>
<P>
is not valid because it returns a <TT>numeric</TT>,
but not a <TT>boolean</TT>. It's acceptable
to nest <TT>if...else</TT> statements
or call them in a nested series, such as<B> </B><TT>if...else...if...else...if...else</TT>.
<P>
The latter can also be simulated with the <TT>switch</TT>
conditional. Not being restricted to just boolean comparisons,
the <TT>switch</TT> conditional uses
a comparison with a general primitive to conduct its test. The
following code uses an integer to perform its test:
<BLOCKQUOTE>
<TT>switch ( Count ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
... test 1<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
... do some operation...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 24: break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
-1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The <TT>case</TT> statements can appear
in braces.
<H3><A NAME="Loops">Loops</A></H3>
<P>
Java has three looping operations. The <TT>for</TT>
construct loop is structured as follows:
<BLOCKQUOTE>
<TT>for (init; test; post-test)</TT>
</BLOCKQUOTE>
<P>
The first part of the expression is any initialization at the
start of the loop. The test is a simple or complex expression.
The last part is an expression such as an increment or decrement
of a variable. The <TT>for</TT> loop
is followed by a single statement or a block of code. For example,
<BLOCKQUOTE>
<TT> for (k = 0; k &lt; 10; ++k) {<BR>
&nbsp;&nbsp;&nbsp;// ... do something<BR>
}</TT>
</BLOCKQUOTE>
<P>
loops ten times.
<P>
A <TT>while</TT> loop is just the
test portion of the <TT>for</TT> loop:
<BLOCKQUOTE>
<TT>while (test)</TT>
</BLOCKQUOTE>
<P>
The <TT>do...while</TT> construct
performs the test and the end of the loop:
<BLOCKQUOTE>
<TT>do {<BR>
&nbsp;&nbsp;&nbsp;// ... do something<BR>
} while (test);</TT>
</BLOCKQUOTE>
<P>
The <TT>break</TT> construct is used
to exit from a loop, and the <TT>continue</TT>
statement skips to the next iteration of the loop. Labeled loops
can also be used to control where to go in complex loops. If a
label follows a <TT>break</TT> statement,
then the code breaks out of the nearest loop that has the matching
label. The following example effectively quits both loops when
the variable <TT>j</TT> is greater
than 100:
<BLOCKQUOTE>
<TT>int i,j;<BR>
&nbsp;&nbsp;quit: for (i = j = 0; i &lt; 100; ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(int k = 0; k &lt; 10; ++k) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
... Do something<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(j &gt; 100)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
quit;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }</TT>
</BLOCKQUOTE>
<P>
If the <TT>break</TT> statement in
this example was replaced by the following,
<BLOCKQUOTE>
<TT>if (j &gt; 100)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;continue quit;</TT>
</BLOCKQUOTE>
<P>
then the code would jump to the next iteration of the outer <TT>for</TT>
loop.
<H3><A NAME="Arrays">Arrays</A></H3>
<P>
Arrays are first-class objects in Java; they are not just a pointer
to memory as in C. Consequently, Java arrays are a lot safer.
You cannot indiscriminately assign an element to just any index
in an array. Java makes sure the index is valid-this prevents
the difficult-to-track memory access violations that occur so
easily in C. If you try to access a bad array index in Java, an
exception will be thrown and no action will be taken.
<P>
Because Java arrays are objects, their semantics are a little
different from their counterparts in C or C++. The thing that
confuses most new Java programmers is how to allocate a new array.
First, you cannot declare an array with a prefixed size; it must
be declared as an uninitialized variable:
<BLOCKQUOTE>
<TT>int numbers[];&nbsp;&nbsp;&nbsp;// For
integer arrays<BR>
String myStrings[];&nbsp;&nbsp;// For arrays of String objects</TT>
</BLOCKQUOTE>
<P>
Another way to declare array variables is to put the braces after
the type. Some programmers consider this method more readable.
<BLOCKQUOTE>
<TT>String[] myStrings;</TT>
</BLOCKQUOTE>
<P>
As you might have noticed from these examples, arrays can be used
for both primitive data types and classes.
<P>
The next step is to create the array by using the <TT>new</TT>
operator to construct an object instance; this will be discussed
in more detail in the next chapter.
<BLOCKQUOTE>
<TT>int numbers[] = new int[5];&nbsp;&nbsp;&nbsp;//
For integer arrays of length 5<BR>
String myStrings[] = new String[20];&nbsp;&nbsp;// For arrays
of <BR>
length 20 of String objects</TT>
</BLOCKQUOTE>
<P>
These examples create an <TT>integer</TT>
array of 5 elements and a String array of 20 elements. However,
the arrays still don't actually contain anything. Each slot is
initialized to a default value. Integers are all set to <TT>0</TT>,
and String elements are all set to <TT>null</TT>
(indicating no object).
<P>
It's easy to add elements to the array after it's created, much
as you do in C++. It is a zero-based system with integer indexes.
Therefore, to assign the first element you would call the following:
<BLOCKQUOTE>
<TT>myStrings[0] = &quot;My First String&quot;
<BR>
numbers[0] = 10;</TT>
</BLOCKQUOTE>
<P>
If you try to make an invalid assignment to an invalid index,
an ArrayIndexOutOfBoundsException will be thrown:
<BLOCKQUOTE>
<TT>numbers[10] = 10;</TT>
</BLOCKQUOTE>
<P>
<A HREF="ch2.htm" >Chapter 2</A> covers how exceptions are handled;
for now, you just need to know that such exceptions occur at runtime.
The preceding error will not be caught by the compiler.
<P>
A <TT>public</TT> instance variable
called <I>length</I> is used to get the size of an array:
<BLOCKQUOTE>
<TT>int q = numbers.length;&nbsp;&nbsp;//
This is 5</TT>
</BLOCKQUOTE>
<P>
Array sizes are final; any attempts to change the length variable
will lead to problems.
<P>
Java doesn't support multidimensional arrays. However, they can
be effectively simulated by using arrays of arrays, which can
be initialized in several different ways. The simplest way is
to define the array with preset sizes:
<BLOCKQUOTE>
<TT>int k[][] = new int[5][4];<BR>
k[1][3] = 999;&nbsp;&nbsp;// Assign a value to it</TT>
</BLOCKQUOTE>
<P>
This example creates a 5 <FONT FACE="Symbol">&#165;</FONT> 4 array
of arrays assigned to the variable <TT>k</TT>.
The second line shows that assigning an element to the array is
straightforward, much like C or C++.
<P>
Another way to create a multidimensional array is to declare and
then later assign its sizes:
<BLOCKQUOTE>
<TT>int z[][];<BR>
int outerSize = 5;<BR>
int innerSize = 4;<BR>
z = new int[outerSize][innerSize];</TT>
</BLOCKQUOTE>
<P>
Not all the dimensions need to be known at the time of allocation-only
one dimension is required:
<BLOCKQUOTE>
<TT>int j[][] = new int[5][];<BR>
j[0] = new int[4];<BR>
j[1] = new int[4];</TT>
</BLOCKQUOTE>
<P>
In this example, the outer array is set to size 5, then two of
its elements are set to arrays of size 4. It is interesting to
note that the statement
<BLOCKQUOTE>
<TT>j.length</TT>
</BLOCKQUOTE>
<P>
will return size 5, but
<BLOCKQUOTE>
<TT>j[0].length</TT>
</BLOCKQUOTE>
<P>
will return size 4.
<H2><A NAME="AppletsandStandaloneApplications"><FONT SIZE=5 COLOR=#FF0000>Applets
and Standalone Applications</FONT></A></H2>
<P>
Java can work with two kinds of applications: <I>Applets</I>,
as stated at the beginning of this chapter, are programs executed
as part of a Web page and displayed with a Java-enabled browser;
<I>standalone applications</I>, on the other hand, are general-purpose
Java applications that don't need a browser to run. Although applets
and standalone applications are compiled in a similar fashion,
they are created differently.
<H3><A NAME="CreatinganApplet">Creating an Applet</A></H3>
<P>
Listing 1.1 shows the code of a minimum applet, which is stored
in a file called FirstApplet.java on this book's CD-ROM. It is
compiled with the following command line call to the Java compiler:
<BLOCKQUOTE>
<TT>javac FirstApplet.java</TT>
</BLOCKQUOTE>
<P>
The output from the compiler consists of Java bytecodes in a file
called FirstApplet.class. This class code is ready to be directly
run from the interpreter-no further steps are necessary.
<P>
The code consists of one class called FirstApplet, a subclass
of the Applet class. The Applet class is used to tie the applet
into the browser environment; it will be described in more detail
in <A HREF="ch6.htm" >Chapter 6</A>, &quot;Building a Catalog
Applet.&quot;
<HR>
<BLOCKQUOTE>
<B>Listing 1.1. An applet that compiles but does nothing.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.applet.Applet;<BR>
public class FirstApplet extends Applet&nbsp;&nbsp;{<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
To run the applet in the browser, you need to create an HTML file.
Listing 1.2 shows the HTML text needed to run the applet. Note
the second line of the listing: The &lt;APPLET&gt; tag is a special
HTML extension used to launch Java applets; notice especially
the <TT>CODE</TT> attribute. The value
assigned to it indicates the class that will be run. In this case,
it is the FirstApplet class that was just compiled. The &lt;WIDTH&gt;
and &lt;HEIGHT&gt; tags are used to specify the bounding area
of the applet, so you can control what the applet looks like on
your Web page. How Applet tags are used in HTML files is discussed
in more detail later in <A HREF="ch6.htm" >Chapter 6</A>.<BR>
<HR>
<BLOCKQUOTE>
<B>Listing 1.2. The HTML text to run the applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;TITLE&gt;First Applet&lt;/TITLE&gt;
<BR>
&lt;APPLET CODE=&quot;FirstApplet&quot; WIDTH=300 HEIGHT=200&gt;
<BR>
&lt;/APPLET&gt;</TT>
</BLOCKQUOTE>
<HR>
<P>
The program called appletviewer is used to run a Java applet from
outside a browser. It's limited in capability-it lacks all the
features that a browser has-but it's good for rapid development.
You can launch an applet from appletviewer by passing it the name
of the HTML file that starts the applet on the command line:
<BLOCKQUOTE>
<TT>appletviewer FirstApplet.html<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Most of the projects and examples in the book can be run by loading the HTML in the example directory of the CD-ROM into the appletviewer program or a browser such as Netscape. When there are additional steps required, such as in the Part IV server programs, you should look at the README file in the working directory of the CD-ROM.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H3><A NAME="CreatingaStandaloneApplication">Creating a Standalone
Application</A></H3>
<P>
Listing 1.3 shows the code of a simple standalone application,
which is stored in a file called Standalone.java on this book's
CD-ROM. Like the preceding sample applet, and class files in general,
it's compiled with the program javac.
<P>
The code in a standalone application differs from an applet's
code in two ways: first, standalone applications do not need an
instance of the Applet class; second,they are started by a call
to the <TT>main()</TT> method, as
in C programs. The <TT>main()</TT>
method is the first routine executed in the program, which you
start by invoking the Java interpreter:
<BLOCKQUOTE>
<TT>java Standalone</TT>
</BLOCKQUOTE>
<P>
The .class extension should not be specified as part of the main
parameter. Additional parameters can be specified after this;
they are passed to the <TT>main()</TT>
method as an array of String objects, as the example shows.
<P>
The example just prints text to the standard output console by
using a call to the <TT>println()</TT>
method of the System class: <TT>System.out.println</TT>.
You will see this method invoked regularly throughout the book-it
provides the same role for Java programmers as <TT>printf()</TT>
does for C programmers. It will be used for both debugging and
conveying program information.
<HR>
<BLOCKQUOTE>
<B>Listing 1.3. A simple standalone application.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.System;<BR>
public class Standalone {<BR>
&nbsp;&nbsp;public static void main(String args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Running standalone
applet!&quot;);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="AppletsVersusStandaloneApplications" ><FONT SIZE=5 COLOR=#FF0000>Applets Versus Standalone Applications</FONT></A>
</H2>
<P>
Most classes and methods can be used in both applets (which are
tied to browsers) and standalone applications (which are not).
Using a browser gives your applet access to a range of services,
such as linking your applet to another Web page or using browser
resources like the status bar. On the other hand, much of what
you can do in an applet is restricted by a browser's security
constraints. You don't have as much freedom to perform file and
network operations as you do in a standalone application.
<P>
Sometimes the security restrictions of a browser force you to
write a standalone application, as illustrated in the chapter
on network servers in Part IV of this book. Such servers generally
need to be written as standalone applications. Of course, security
is both a blessing and a curse. It's a curse because it limits
what you can do, but of course, if someone used that lax security
to break into your system, you could end up with quite another
view.
<P>
Consequently, there may come a time when people begin to write
their own Security Man-agers into standalone programs to fit special
needs. For example, a corporate &quot;intranet&quot; is a possibility.
<P>
This book, as its title indicates, will focus on applets. However,
some features, such as network servers, are best created as standalone
applications, so these will be used when appropriate.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Java is more than just an Internet programming language. It is
a full-featured, object-oriented language in its own right. As
the language matures, Java may be considered the language of choice
for <I>all</I> object-oriented programming. In this way, Java
might compete with major object-oriented languages, such as C++
or Smalltalk. It is entirely possible that corporations and other
institutions will use Java for in-house applications, such as
timesheets and client/server projects. Java will probably prove
to be especially popular on intranets. So despite its billing
as primarily an Internet language, Java's wide variety of features
could establish it as the next major language in general, for
uses ranging from in-house projects to commercial uses to the
Internet and intranets to being the first language taught in universities.
For this reason, Java is worth knowing, regardless of how you
use the Internet.
<P>
<A HREF="ch2.htm" >Chapter 2</A> moves from this overview of Java's
foundations to a deeper exploration of its object-oriented features.
You will also be introduced to the Java Development Kit (JDK),
which offers a large suite of classes for creating your applets.
Techniques for writing more readable, efficient, and extendible
code will also be discussed.

<P>
<HR WIDTH="100%"></P>

<CENTER><P></P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



