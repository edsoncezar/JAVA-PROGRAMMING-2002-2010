<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>


   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 2</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Object-Oriented Development in
Java</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#IntroductiontoJavaClassesandObjects" >Introduction to Java Classes and Objects</A>
<UL>
<LI><A HREF="#BasicStructureofaClass" >Basic Structure of a Class</A>
<LI><A HREF="#CreatinganObjectInstance" >Creating an Object Instance</A>
<LI><A HREF="#UsingMethods" >Using Methods</A>
<LI><A HREF="#OverloadingMethods" >Overloading Methods</A>
<LI><A HREF="#Constructors" >Constructors</A>
</UL>
<LI><A HREF="#InheritanceinJava" >Inheritance in Java</A>
<UL>
<LI><A HREF="#Subclassing" >Subclassing</A>
<LI><A HREF="#MethodOverriding" >Method Overriding</A>
<LI><A HREF="#CallingSuperclassMethods" >Calling Superclass Methods</A>
<LI><A HREF="#CallingSuperclassConstructors" >Calling Superclass Constructors</A>
</UL>
<LI><A HREF="#ImportantCoreClasses" >Important Core Classes</A>
<UL>
<LI><A HREF="#TheObjectBaseClass" >The Object Base Class</A>
<LI><A HREF="#StringClasses" >String Classes</A>
<LI><A HREF="#TypeWrappers" >Type Wrappers</A>
</UL>
<LI><A HREF="#MoreaboutClasses" >More about Classes</A>
<UL>
<LI><A HREF="#AccessModifiers" >Access Modifiers</A>
<LI><A HREF="#ClassMethodsandClassVariables" >Class Methods and Class Variables</A>
<LI><A HREF="#ThefinalModifier" >The final Modifier</A>
<LI><A HREF="#ThenullKeywordandMoreaboutGarbage" >The null Keyword and More about Garbage Collection</A>
<LI><A HREF="#ScopingRules" >Scoping Rules</A>
<LI><A HREF="#CastingRules" >Casting Rules</A>
<LI><A HREF="#OtherKeywords" >Other Keywords</A>
</UL>
<LI><A HREF="#IntroductiontoExceptionHandling" >Introduction to Exception Handling</A>
<UL>
<LI><A HREF="#StructureofanExceptionHandler" >Structure of an Exception Handler</A>
<LI><A HREF="#WhentoCatchExceptions" >When to Catch Exceptions</A>
<LI><A HREF="#ExceptionHandlersandExceptionClasses" >Exception Handlers and Exception Classes</A>
<LI><A HREF="#NestedExceptions" >Nested Exceptions</A>
</UL>
<LI><A HREF="#OrganizingProjectsinJava" >Organizing Projects in Java</A>
<UL>
<LI><A HREF="#AbstractMethods" >Abstract Methods</A>
<LI><A HREF="#Interfaces" >Interfaces</A>
<LI><A HREF="#Packages" >Packages</A>
</UL>
<LI><A HREF="#TheJavaDevelopersKit" >The Java Developer's Kit</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Now that you're familiar with the general architecture of Java
and its basic programming constructs, you're ready to look at
Java's tools for object-oriented development. This chapter first
looks at the simple, yet powerful, object-oriented features of
the Java programming language. You then see how you can organize
Java classes into libraries by using the <I>package</I> <I>mechanism</I>.
Finally, you're introduced to the suite of class libraries provided
with Java, known as the <I>Java Developer's Kit</I> <I>(JDK)</I>
or the <I>Java API</I>.
<H2><A NAME="IntroductiontoJavaClassesandObjects"><FONT SIZE=5 COLOR=#FF0000>Introduction
to Java Classes and Objects</FONT></A></H2>
<P>
The starting place of object-oriented programming in Java is <I>classes</I>,
which provide templates for specifying the state and behavior
of an object at runtime. An <I>object</I> is said to be an <I>instance</I>
of a class. For a given class and runtime session, there can be
multiple object instances.
<H3><A NAME="BasicStructureofaClass">Basic Structure of a Class</A>
</H3>
<P>
A class generally consists of <I>variables</I> and <I>methods</I>.
The following is a rudimentary example of a class called FirstClass:
<BLOCKQUOTE>
<TT>class FirstClass {<BR>
&nbsp;&nbsp;&nbsp;int firstVariable = 0; // Initially set to 0
<BR>
&nbsp;&nbsp;&nbsp;// Set the value of the variable...<BR>
&nbsp;&nbsp;&nbsp;public void setValue(int newValue) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstVariable = newValue;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Get the variable value...<BR>
&nbsp;&nbsp;&nbsp;public int getValue() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return firstVariable;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This class consists of a single variable, called <TT>firstVariable</TT>,
which is initially set to <TT>0</TT>.
The class has two methods. The <TT>setValue()</TT>
method is used to set <TT>firstVariable</TT>
to the specified value. The <TT>getValue()</TT>
method returns the current value of <TT>firstVariable</TT>.
<P>
The variable <TT>firstVariable</TT>
is called an <I>instance variable</I>. This type of variable is
defined for an instance of an object. It differs from a <I>local
variable</I>, which is defined inside a block of code or a method.
Suppose that a new method is defined to get half the value of
<TT>firstVariable</TT>:
<BLOCKQUOTE>
<TT>public int getHalf() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int half;&nbsp;&nbsp;// A
local variable<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;half = firstVariable / 2;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return half;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The variable <TT>half</TT> is a local
variable; it will not exist after the <TT>getHalf()</TT>
method is finished. However, the <TT>firstVariable</TT>
instance variable hangs around until the object instance is destroyed.
<P>
Note that the <TT>getHalf()</TT> local
variable isn't really needed. This method could have gotten the
same results in a single <TT>return</TT>
statement:
<BLOCKQUOTE>
<TT>public int getHalf() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return firstVariable / 2;
<BR>
}</TT>
</BLOCKQUOTE>
<H3><A NAME="CreatinganObjectInstance">Creating an Object Instance</A>
</H3>
<P>
After defining a class, you can use it as a runtime object. Use
the <TT>new</TT> operator to create
an instance of a class. You can use the following code to create
an object instance of the FirstClass class:
<BLOCKQUOTE>
<TT>FirstClass firstObject = new FirstClass();</TT>
</BLOCKQUOTE>
<P>
The <TT>new</TT> operator does a couple
of things. First, it allocates memory for the object. Recall that
Java has automatic memory management; consequently, you don't
have to explicitly allocate memory. The <TT>new</TT>
operator also initializes instance variables. In this sample class,
<TT>firstVariable</TT> is set to an
initial value of zero. However, the explicit initialization to
zero is not necessary; Java automatically sets instance variables
to initial values such as zero or null.
<P>
The <TT>new</TT> operator also calls
a <I>constructor</I><B>.</B> A constructor is a method called
when an object is instantiated. You can use a constructor to provide
additional initialization. Constructors are discussed in greater
detail in the &quot;Constructors&quot; section of this chapter.
<H3><A NAME="UsingMethods">Using Methods</A></H3>
<P>
A <I>method</I> has two parts: a <I>definition</I> and a <I>body</I>.
The definition must have at least three components: a <I>return
value</I>, a <I>name</I>, and a <I>parameter list</I>. These three
components define the <I>signature</I> of a method. As you will
see in the next section, signatures are important because you
can use a method name multiple times in a class.
<P>
The return value of a method can be a primitive data type (such
as <TT>int</TT>), a class name (such
as String), or <TT>void</TT> if there
is no return value. A method has zero or more parameters. If there
are no parameters, the method consists of empty parentheses; otherwise,
the parameters can be primitive data types or classes, separated
by commas.
<P>
It's easy to call object methods. The following code instantiates
a FirstClass object and manipulates its internal variable values:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirstClass
firstObject;&nbsp;&nbsp;// Object not <BR>
instantiated yet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstObject = new FirstClass();
// Object <BR>
instantiated!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See what the default value
of the object is...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int val = firstObject.getValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Value
of firstObject = &quot; + <BR>
val);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set it to a new value...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstObject.setValue(1000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Value
of firstObject = &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstObject.getValue());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Half
Value of firstObject = &quot; <BR>
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstObject.getHalf());</TT>
</BLOCKQUOTE>
<P>
Recall that <TT>System.out.println</TT>
prints a string to standard output. In this example, the first
<TT>Print</TT> statement outputs a
value of <TT>0</TT>, which was the
initialized value of <TT>firstVariable</TT>.
The code then sets that variable to a value of <TT>1000</TT>
by using the <TT>setValue()</TT> method.
When its value prints again, a value of <TT>1000</TT>
is output. Finally, the code calls the <TT>getHalf()</TT>
method to print half the instance variable's value, namely <TT>500</TT>.
<H3><A NAME="OverloadingMethods">Overloading Methods</A></H3>
<P>
As mentioned earlier, a method has a signature. This is important
because Java provides a mechanism for repeatedly using the same
method name; this mechanism is called <I>overloading</I>. An overloaded
method has the same name but different parameters. To illustrate
overloading, a class is created that defines two instance variables.
This class, called SecondClass, illustrates overloading by providing
two methods of the same name to set the instance variables:
<BLOCKQUOTE>
<TT>class SecondClass {<BR>
&nbsp;&nbsp;&nbsp;int var1 = 1;<BR>
&nbsp;&nbsp;&nbsp;int var2 = 2;<BR>
&nbsp;&nbsp;&nbsp;// Set only the first variable<BR>
&nbsp;&nbsp;&nbsp;public void setVar(int newVal1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var1 = newVal1;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Overloaded! Set both variables...<BR>
&nbsp;&nbsp;&nbsp;public void setVar(int newVal1,int newVal2)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var1 = newVal1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var2 = newVal2;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Get variable values...<BR>
&nbsp;&nbsp;&nbsp;public int getVar1() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return var1;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public int getVar2() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return var2;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
The version of <TT>setVar()</TT> with
one parameter sets the value of variable <TT>1</TT>;
the <TT>setVar()</TT> version with
two parameters sets both variable values. The following code shows
how you can use this class:
<BLOCKQUOTE>
<TT>SecondClass secondObject = new SecondClass();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Var1=&quot;
+ <BR>
secondObject.getVar1()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;
Var2= &quot; + secondObject.getVar2());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondObject.setVar(1000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Var1=&quot;
+ <BR>
secondObject.getVar1()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;
Var2= &quot; + secondObject.getVar2());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondObject.setVar(secondObject.getVar1()/2,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondObject.getVar1());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Var1=&quot;
+ <BR>
secondObject.getVar1()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;
Var2= &quot; + secondObject.getVar2());</TT>
</BLOCKQUOTE>
<P>
After you call the first <TT>print</TT>
method, the output is <TT>1</TT> and
<TT>2</TT>, the initialized values
of the two variables. The code then uses the first version of
<TT>setVar()</TT> to set the first
variable to a value of <TT>1000</TT>.
The second <TT>print</TT> call prints
the values <TT>1000</TT> and <TT>2</TT>.
Finally, the other <TT>setVar()</TT>
method is called to set both variables. The first variable is
set to half its existing value, and the second variable is set
to half the existing value. Parameters resolve fully before passing
to the called method. This means that half of the existing first
variable value of <TT>500</TT> passes
to the first parameter, but the full value of <TT>1000</TT>
passes to the second parameter. The consequent printing displays
<TT>500</TT> and <TT>1000</TT>
for SecondClass object variables <TT>var1</TT>
and <TT>var2</TT>, respectively.
<P>
Periodically, you might hear method invocation called &quot;message
passing&quot; or &quot;sending a message.&quot; This is object-oriented
&quot;lingo&quot; for talking about how two objects communicate.
The reason that message passing is more than a buzzword is because
of what goes on behind the scenes when a method is invoked. Because
a method can be overloaded (and overridden, as you'll see in the
section on &quot;Method Overriding&quot;), an invocation of an
object actually results in the receiving object performing a lookup
to see which method should be called. Consequently, it is more
correct to call the procedure a &quot;message passing&quot; because
the method invocation is not a direct call (such as calling a
function in C) but a request for action.
<H3><A NAME="Constructors">Constructors</A></H3>
<P>
As stated earlier, <I>constructors</I> are a special type of method
called when an object is initialized; their syntax is similar
to that of methods, except they don't return values. The name
of a constructor is the same as its class. A constructor is automatically
called when an object is instantiated.
<P>
Now, rework the SecondClass class to illustrate constructors.
First, add a default constructor:
<BLOCKQUOTE>
<TT>class SecondClass {<BR>
&nbsp;&nbsp;&nbsp;int var1;<BR>
&nbsp;&nbsp;&nbsp;int var2;<BR>
&nbsp;&nbsp;&nbsp;// Main constructor...<BR>
&nbsp;&nbsp;&nbsp;public SecondClass() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var1 = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var2 = 2;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// ... OTHER METHODS GO HERE...<BR>
}</TT>
</BLOCKQUOTE>
<P>
Rather than setting the values of the instance variables in their
declaration, set them in the constructor. This constructor is
called if you create an instance of SecondClass, as follows:
<BLOCKQUOTE>
<TT>SecondClass secondObject = new SecondClass();</TT>
</BLOCKQUOTE>
<P>
As with methods, you can overload constructors. Here is a constructor
that defines the variable <TT>var1</TT>
at creation:
<BLOCKQUOTE>
<TT>// Another constructor...<BR>
&nbsp;&nbsp;&nbsp;public SecondClass(int var1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.var1 = var1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var2 = 2;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
To instantiate an object with this constructor, use the following:
<BLOCKQUOTE>
<TT>SecondClass secondObject = new SecondClass(100);</TT>
</BLOCKQUOTE>
<P>
This call creates an object with <TT>var1</TT>
set to <TT>100</TT>; <TT>var2</TT>
is set to <TT>2</TT>.
<P>
You may have noticed the curious way <TT>var1</TT>
is set in the new constructor.
<BLOCKQUOTE>
<TT>this.var1 = var1;</TT>
</BLOCKQUOTE>
<P>
In this code, <TT>this</TT> refers
to the current instance of the object, so use <TT>this</TT>
to differentiate the <TT>var1</TT>
of the object from that of the parameter. Because local variables
and parameter variables are first in scope, they will be used
unless the <TT>this</TT> keyword is
used. Effectively, <TT>this</TT> appears
in front of every call to an object's variable, so this is the
<TT>var2</TT> initialization of the
constructor:
<BLOCKQUOTE>
<TT>this.var2 = 2;</TT>
</BLOCKQUOTE>
<P>
To round out this example, you can use a third constructor to
set both the variable's initial values:
<BLOCKQUOTE>
<TT>// Define both values at initialization
<BR>
&nbsp;&nbsp;&nbsp;public SecondClass(int var1,int var2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.var1 = var1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.var2 = var2;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
You can call this constructor with the following:
<BLOCKQUOTE>
<TT>SecondClass secondObject = new SecondClass(100,200);</TT>
</BLOCKQUOTE>
<P>
This call creates an object with <TT>var1</TT>
set to <TT>100</TT>; <TT>var2</TT>
is set to <TT>200</TT>.
<P>
What happens if there is no constructor, as in the earlier examples?
In this case, the constructor of the class's <I>superclass</I>
is called. This brings up the subject of <I>inheritance</I> in
Java.
<H2><A NAME="InheritanceinJava"><FONT SIZE=5 COLOR=#FF0000>Inheritance
in Java</FONT></A></H2>
<P>
One of the distinguishing features of object-oriented languages
is <I>inheritance, </I>a mechanism you can use to create a new
class by extending the definition of another class. It gives you
a powerful way to increase the reusability of your code. You can
take an old class and use it to create a new class by defining
the differences between your new class and the old one. The old
extended class is the <I>superclass</I>; the new extended class
is the <I>subclass</I>. In Java, the process of extending one
class to create a new class is called <I>subclassing</I>.
<H3><A NAME="Subclassing">Subclassing</A></H3>
<P>
Java uses the <TT>extends</TT> keyword
to indicate the creation of a new class as a subclass of an existing
class. To illustrate subclassing, the following code creates a
simple class that keeps a record of people's first and last names.
It has a default constructor that simply initializes the two names,
a constructor for storing String parameters, and a <TT>list()</TT>
method that dumps the current values to standard output.
<BLOCKQUOTE>
<TT>class SimpleRecord {<BR>
&nbsp;&nbsp;&nbsp;String firstName;<BR>
&nbsp;&nbsp;&nbsp;String lastName;<BR>
&nbsp;&nbsp;&nbsp;// Default constructor<BR>
&nbsp;&nbsp;&nbsp;public SimpleRecord() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = &quot;&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;// Constructor...<BR>
&nbsp;&nbsp;&nbsp;public SimpleRecord(String firstName, String
<BR>
lastName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstName = firstName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastName = lastName;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// List the elements of the record...<BR>
&nbsp;&nbsp;&nbsp;public void list() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;First
Name: &quot; + firstName);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Last
Name: &quot; + lastName);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
To instantiate the class with a name and dump its contents, use
the following:
<BLOCKQUOTE>
<TT>SimpleRecord simple = new <BR>
SimpleRecord(&quot;Thomas&quot;,&quot;Jefferson&quot;);<BR>
simple.list();</TT>
</BLOCKQUOTE>
<P>
You can use the <TT>extends</TT> operator
to <I>derive</I> from the SimpleRecord class a new class with
additional address information:
<BLOCKQUOTE>
<TT>class AddressRecord extends SimpleRecord
{<BR>
&nbsp;&nbsp;&nbsp;String address;<BR>
&nbsp;&nbsp;&nbsp;// Default constructor<BR>
&nbsp;&nbsp;&nbsp;public AddressRecord() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = &quot;&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address = &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Constructor...<BR>
&nbsp;&nbsp;&nbsp;public AddressRecord(String firstName, String
<BR>
lastName,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String address) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstName = firstName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastName = lastName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.address = address;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Notice how this new AddressRecord class inherits the <TT>firstName</TT>
and <TT>lastName</TT> variables from
the SimpleRecord class. It also inherits the <TT>list()</TT>
method. Therefore, if you call
<BLOCKQUOTE>
<TT>record = new AddressRecord(&quot;Thomas&quot;,&quot;Jefferson&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Monticello&quot;);
<BR>
record.list();</TT>
</BLOCKQUOTE>
<P>
you create a fully initialized AddressRecord object. However,
the <TT>list()</TT> method prints
only the name variables because this call ultimately results in
calling the SimpleRecord <TT>list()</TT>
method. The reason for this is because you haven't explicitly
defined a <TT>list()</TT> method in
the AddressRecord. However, you can address this limitation through
method overriding.
<H3><A NAME="MethodOverriding">Method Overriding</A></H3>
<P>
Use <I>method overriding </I>when you need a subclass to replace
a method of its superclass. Recall that each method has a signature.
When you override a method, you are defining a new method that
replaces the method in the superclass that has the same signature.
Whenever you call a method, Java looks for a method of that signature
in the class definition of the object. If Java doesn't find the
method, it looks for a matching signature in the definition of
the superclass. Java continues to look for the matching method
until it reaches the topmost superclass.
<P>
To add a <TT>list()</TT> method to
the AddressRecord class that displays the address, all you need
to do is add this code to the class definition:
<BLOCKQUOTE>
<TT>// List the elements of the record...
<BR>
&nbsp;&nbsp;&nbsp;public void list() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;First
Name: &quot; + firstName);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Last
Name: &quot; + lastName);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Address:
&quot; + address);<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The <TT>list()</TT> method call from
the previous example will now print the following results:
<BLOCKQUOTE>
<TT>First Name: Thomas<BR>
Last Name: Jefferson<BR>
Address: Monticello</TT>
</BLOCKQUOTE>
<H3><A NAME="CallingSuperclassMethods">Calling Superclass Methods</A>
</H3>
<P>
You may have noticed that the AddressRecord <TT>list()</TT>
method duplicates some code of the SimpleRecord <TT>list()</TT>
method. Namely, it duplicates the following:
<BLOCKQUOTE>
<TT>System.out.println(&quot;Last Name: &quot;
+ lastName);<BR>
System.out.println(&quot;Address: &quot; + address);</TT>
</BLOCKQUOTE>
<P>
You can eliminate this redundancy. Recall that one of the points
of inheritance is that a subclass takes an existing class and
extends its definition. Because the <TT>list()</TT>
method of SimpleRecord already has some of the behavior of the
AddressRecord class, you should be able to use the SimpleRecord
<TT>list()</TT> method as part of
the base behavior of the AddressRecord class.
<P>
Use the <TT>super</TT> keyword to
refer to a superclass. The <TT>super</TT>
keyword is appropriate for the current problem being discussed
because calling the superclass of AddressRecord has some of the
behavior the <TT>list()</TT> method
needs. Consequently, the <TT>list()</TT>
method of AddressRecord is modified to call the SimpleRecord <TT>list()</TT>
method before specifying additional behavior:
<BLOCKQUOTE>
<TT>public void list() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.list();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Address:
&quot; + address);<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This code now prints the full name and address, as mentioned in
the preceding section's definition of <TT>list()</TT>.
<H3><A NAME="CallingSuperclassConstructors">Calling Superclass
Constructors</A></H3>
<P>
You can use the <TT>super</TT> keyword
to call the constructor of the superclass. The only difference
from the previous use of <TT>super</TT>
is that you call it without any method definition. For example,
the two constructors of AddressRecord are modified to call the
SimpleRecord constructor before performing its own initialization:
<BLOCKQUOTE>
<TT>// Default constructor<BR>
&nbsp;&nbsp;&nbsp;public AddressRecord() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address = &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Constructor...<BR>
&nbsp;&nbsp;&nbsp;public AddressRecord(String firstName, String
<BR>
lastName,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String address) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(firstName,lastName);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.address = address;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
You can call the default constructor (no parameters) or another
constructor with <TT>super</TT> as
long as the constructor with the matching signature exists.
<P>
You can use the <TT>this</TT> keyword
in a similar manner to call methods within your class. For example,
suppose that you need a constructor that just adds an address
to the AddressRecord class, with the other fields set to empty
strings. You can do this by using the following code:
<BLOCKQUOTE>
<TT>public AddressRecord(String address)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.address = address;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This code calls the default constructor of the AddressRecord class,
which in turn calls the SimpleRecord default constructor. At this
point, all the fields are set to empty strings. The code then
assigns the specified String to the address field, and you're
ready to go.
<P>
You might wonder what the superclass of SimpleRecord is; the answer
is in the next section.
<H2><A NAME="ImportantCoreClasses"><FONT SIZE=5 COLOR=#FF0000>Important
Core Classes</FONT></A></H2>
<P>
Now that you have seen the fundamentals of classes in Java, it's
time to see how some of the basic classes in Java work. Because
these classes are used throughout Java, you should be familiar
with them.
<H3><A NAME="TheObjectBaseClass">The Object Base Class</A></H3>
<P>
The Object class is <I>the</I> base class of all classes in Java-the
ultimate superclass of all classes. Because of its primary nature,
the methods of the Object class are present in all other classes,
although custom methods often override them.
<P>
The Object class has a variety of interesting methods. Each Object
has its own String representation. This may be a system-generated
name or something generated by the class. For example, a String
object's representation is the string itself. You get an Object's
String representation in two ways:
<BLOCKQUOTE>
<TT>Object o = new Object();<BR>
System.out.println(&quot;Object = &quot; + o);<BR>
System.out.println(&quot;Object = &quot; + o.toString());</TT>
</BLOCKQUOTE>
<P>
In the second line of the preceding example, the Object itself
is provided as part of the printout. The Object's <TT>toString()</TT>
method is actually called when an Object is provided as part of
the <TT>print</TT> statement. Consequently,
the second and third lines are functionally equivalent. The <TT>toString()</TT>
method should be overridden if you want a custom String representation;
it is overriden throughout the Java class libraries.
<P>
The <TT>finalize()</TT> method is
the closest thing Java objects have to a destroy method. Recall
that Java has automatic memory management so you don't have to
explicitly delete objects. The <I>garbage collector</I> removes
unreferenced objects from memory. When an object is about to get
&quot;garbage collected,&quot; its <TT>finalize()</TT>
method is called. This can be overridden if you need to do some
custom cleanup, such as closing a file or terminating a connection.
However, because garbage collection doesn't happen at predictable
times, you need to use the <TT>finalize()</TT>
method carefully. You can also call the method manually, as in
right before removing a reference.
<P>
Each class in Java has a class <I>descriptor</I>. The Class class
represents this descriptor, which you access by using the <TT>getClass()</TT>
method of the Object class. You cannot modify the returned class
descriptor. However, you can use it to get all kinds of useful
information. For example, the <TT>getSuperclass()</TT>
method returns the class descriptor of a class's superclass. For
example, to get the superclass of a String, you can call the following:
<BLOCKQUOTE>
<TT>String s = &quot;A string&quot;;<BR>
System.out.println(&quot;String superclass = &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.getClass().getSuperclass());</TT>
</BLOCKQUOTE>
<P>
The <TT>getName()</TT> method of Class
returns the name of the class.
<P>
You may notice the <TT>wait()</TT>
and <TT>notify()</TT> methods of the
Object class. These are complex methods related to threaded processing,
which is discussed in detail in <A HREF="ch8.htm" >Chapter 8</A>,
&quot;Adding Threads to Applets.&quot;
<H3><A NAME="StringClasses">String Classes</A></H3>
<P>
As stated in <A HREF="ch1.htm" >Chapter 1</A>, <I>string literals</I>
are implemented as objects of the String class. You can create
strings in a variety of ways. First, you can assign a String to
a literal, as has been shown. You can also use String arithmetic
to concatenate one String to another. For example, the second
string in
<BLOCKQUOTE>
<TT>String s1 = &quot;A string&quot;;<BR>
String s2 = s1 + &quot; with some additional text&quot;;</TT>
</BLOCKQUOTE>
<P>
is set to <TT>&quot;A string with some additional
text&quot;</TT>. You can also use other operators, such
as <TT>+=</TT>, in String arithmetic.
String concatenation also works with primitive data types. For
example, this is a valid operation:
<BLOCKQUOTE>
<TT>String s = &quot;This is number &quot;
+ 6;</TT>
</BLOCKQUOTE>
<P>
Although you cannot change String objects after creating them,
you can apply methods to them to yield new String objects. For
example, you can use the <TT>substring()</TT>
method to return a String starting at a specific index. You can
also apply other operations. The <TT>length()</TT>
method returns the length of the String. For example, the following
methods applied on the above String objects print <TT>with
some additional text</TT>:
<BLOCKQUOTE>
<TT>System.out.println(s2.substring(s1.length()));</TT>
</BLOCKQUOTE>
<P>
A series of overloaded <TT>valueOf()</TT>
methods is particularly useful. These methods take a primitive
data type and return a String representation. The following code
sets the String variable <TT>s</TT>
to <TT>100</TT>.
<BLOCKQUOTE>
<TT>int i = 100;<BR>
String s = String.valueOf(i);</TT>
</BLOCKQUOTE>
<P>
Notice that the preceding example didn't use any instance of the
String class to invoke the <TT>valueOf()</TT>
method. This is because <TT>valueOf()</TT>
is a <I>class</I> <I>method</I>, which means that the method is
global to the class, not to a specific instance of the class.
Class methods (sometimes called <I>static methods</I>) are discussed
in the section &quot;Class Methods and Class Variables&quot; later,
but keep this syntax in mind when you see it.
<P>
The <TT>equals()</TT> method returns
a boolean indicating whether two String objects have identical
internal strings. The call
<BLOCKQUOTE>
<TT>s2.equals(s);</TT>
</BLOCKQUOTE>
<P>
using the String variables from the previous example returns <TT>false</TT>.
The String class has many methods; you'll see many of these used
in the examples and chapter projects of this book.
<P>
Another type of string class is StringBuffer. Unlike the String
class, you can modify a StringBuffer object after you've created
it. You typically construct a StringBuffer object with a String
as the lone parameter, although other variations are possible.
After construction, you can use operations like <TT>append()</TT>
to modify its state. Using the two String variables again in an
example, the following code creates the same String value as variable
<TT>s2</TT>, except with a period
concatenated to the end:
<BLOCKQUOTE>
<TT>StringBuffer sb = new StringBuffer(s2);
<BR>
sb.append('.');<BR>
System.out.println(sb);</TT>
</BLOCKQUOTE>
<P>
The StringBuffer class has some of the same methods as String,
and you usually use it in close conjunction with String objects.
<H3><A NAME="TypeWrappers">Type Wrappers</A></H3>
<P>
As pointed out in <A HREF="ch1.htm" >Chapter 1</A>, &quot;The
Java Development Environment,&quot; Java had some important design
decisions to make regarding primitive data types like integers
and floating point numbers. On one hand, designers of Java wanted
it to be &quot;objects all the way down,&quot; while on the other
hand, it needed good performance. In other object-oriented languages,
such as Smalltalk, everything is an object, including a number.
To perform a mathematical operation would then actually be an
application of a method. However, this purity comes at the expense
of performance; methods calls are relatively expensive compared
to, say, an addition of two integers.
<P>
Java uses a middle-ground approach. You can work with the primitive
data types directly so that
<BLOCKQUOTE>
<TT>int x = 2 + x2;</TT>
</BLOCKQUOTE>
<P>
does not result in an object method call. However, if you want
to use numbers or other data types of objects, you can use instances
of a special set of classes called <I>type wrappers</I>. Each
of the primitive data types has a type wrapper class, as shown
in Table 2.1.<BR>
<P>
<CENTER><B>Table 2.1. Type wrapper classes.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=124><I>Class</I></TD><TD WIDTH=376><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Boolean</TT>
</TD><TD WIDTH=376>Object wrapper for the <TT>boolean</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Character</TT>
</TD><TD WIDTH=376>Object wrapper for the <TT>char</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Double</TT>
</TD><TD WIDTH=376>Object wrapper for <TT>double</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Float</TT></TD>
<TD WIDTH=376>Wrapper for <TT>float</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Integer</TT>
</TD><TD WIDTH=376>Wraps <TT>integer</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Long</TT></TD>
<TD WIDTH=376>Type wrapper for <TT>long</TT> data type
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Number</TT>
</TD><TD WIDTH=376>A superclass that defines methods of numeric type wrappers
</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can create wrappers in a variety of ways depending on the
data type. You can create instances of the Integer class in two
ways:
<BLOCKQUOTE>
<TT>Integer I1 = new Integer(6);<BR>
Integer I2 = new Integer(&quot;6&quot;);</TT>
</BLOCKQUOTE>
<P>
Once created, you can apply a suite of methods. You can use some
of these to convert the internal value to a new data type. For
example, the preceding code returns a double value for the integer
<TT>6</TT>:
<BLOCKQUOTE>
<TT>double dbl = I1.doubleValue();</TT>
</BLOCKQUOTE>
<P>
As with the String class, you can employ class methods to perform
operations on primitive data types without creating an instance
of a class. For example, the following code converts a string
to an integer:
<BLOCKQUOTE>
<TT>int i = Integer.parseInt(&quot;6&quot;);</TT>
</BLOCKQUOTE>
<P>
If the String cannot be converted to a number, a NumberFormatException
object is thrown. Exceptions are discussed later in the section
&quot;Introduction to Exception Handling.&quot;
<P>
Finally, the type wrappers provide public variables that give
information about such things as the upper and lower bounds of
a data type. To get the maximum value a <TT>double</TT>
primitive type can have, you may call the following:
<BLOCKQUOTE>
<TT>System.out.println(&quot;Max double value:
&quot; + Double.MAX_VALUE);</TT>
</BLOCKQUOTE>
<P>
The <TT>MAX_VALUE</TT> public variable
is a class variable of the Double class and is declared as static
as in class methods. You learn more about these types of variables
in the section &quot;Class Methods and Class Variables.&quot;
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Now that you have seen some of Java's core classes, you can gain some further insight into Java arrays; as stated earlier, arrays are first-class objects. Because Object is the base class, this implies that arrays are subclasses of the Object class. Actually there is a class called Array, which is a direct subclass of Object. For each primitive type and class, there is a subclass of Array. Thus, there is a String[] and int[] class. Inheritance relationships are also maintained in this Array hierarchy. Turning back to the first inheritance example, the AddressRecord[] class is a subclass of SimpleRecord[].</BLOCKQUOTE>
<BLOCKQUOTE>
Because arrays are subclasses of Object, this means that you can apply Object methods to it. For example, this is legal:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>String s[] = new String[4];<BR>
System.out.println(&quot;S Superclass: &quot; + s.getClass().getSuperclass());</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Therefore, you can assign arrays to Objects. These are all valid calls:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>String s[] = new String[4];<BR>
Object oArray[] = s;<BR>
int numbers[] = new int[4];<BR>
System.out.println(numbers);<BR>
Object o = numbers;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
However, you cannot explicitly subclass an array.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="MoreaboutClasses"><FONT SIZE=5 COLOR=#FF0000>More
about Classes</FONT></A></H2>
<P>
It is time to go back to the mechanics of using Java classes.
However, with the basics and a description of some core classes
behind you, you're ready for some more advanced class constructs.
<H3><A NAME="AccessModifiers">Access Modifiers</A></H3>
<P>
Java uses access control modifiers to specify the level of visibility
a method or variable has to other classes. Java has four levels
of access: <TT>public</TT>, <TT>private</TT>,
<TT>protected</TT>, and <TT>package</TT>.
The first three are straightforward and may be familiar; the <TT>package</TT>
access level is a little more involved.
<P>
The <TT>public</TT> modifier indicates
that you can access a variable by any class or method. Constructors
are usually <TT>public</TT>, as in
the AddressRecord example from earlier:
<BLOCKQUOTE>
<TT>class AddressRecord extends SimpleRecord
{<BR>
&nbsp;&nbsp;&nbsp;// Default constructor<BR>
&nbsp;&nbsp;&nbsp;public AddressRecord() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
You can also declare a variable as <TT>public</TT>.
For example, you can extend the AddressRecord class to have two
<TT>public</TT>/FONT></TT> variables to indicate
whether the address is for the Internet or is physical:
<BLOCKQUOTE>
<TT>class AddressRecord extends SimpleRecord
{<BR>
&nbsp;&nbsp;&nbsp;public int INTERNET_ADDRESS = 0;<BR>
&nbsp;&nbsp;&nbsp;public int PHYSICAL_ADDRESS = 1;<BR>
&nbsp;&nbsp;&nbsp;// ... Constructors and methods...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
You can use the following code to print its values:
<BLOCKQUOTE>
<TT>AddressRecord a = new AddressRecord();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Physical
Address = &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.PHYSICAL_ADDRESS);&nbsp;&nbsp;//
which is 1</TT>
</BLOCKQUOTE>
<P>
You use the <TT>protected</TT> accessor
to restrict access only to subclasses of the protected class.
This accessor allows you to design classes so that you can specify
methods only of use to subclasses. For example, you can make the
name variables of SimpleRecord <TT>protected</TT>.
This restricts their use to a subclass, such as AddressRecord.
This is how the variable portion of SimpleRecord is defined:
<BLOCKQUOTE>
<TT>class SimpleRecord {<BR>
&nbsp;&nbsp;&nbsp;protected String firstName;<BR>
&nbsp;&nbsp;&nbsp;protected String lastName;<BR>
&nbsp;&nbsp;&nbsp;// ... Constructors and methods...<BR>
}</TT>
</BLOCKQUOTE>
<P>
The AddressRecord class can continue to use these variables, but
outside classes cannot access them.
<P>
The <TT>private</TT> accessor indicates
that a variable or method is not available to any other class
except the one in which it appears. For example, recall that the
<TT>list()</TT> method of SimpleRecord
is called by the AddressRecord subclass. This can happen because
access to the method is allowed. However, if the method is declared
as <TT>private</TT>,
<BLOCKQUOTE>
<TT>private void list()</TT>
</BLOCKQUOTE>
<P>
then AddressRecord will not be able to access the method. A compilation
error will therefore arise when you try to compile the AddressRecord
class.
<P>
The last and default form of access, <TT>package</TT>,
does not directly correspond to an accessor keyword. <I>Packages</I>,
as discussed in the section of the same name, are a way of creating
libraries of classes. If you do not specify an access control
modifier, a method or variable is accessible to all classes in
the <TT>package</TT>. The <TT>package</TT>
level of access is a way of saying that the method or variable
is accessible to all classes that are &quot;friends&quot; with,
or the same <TT>package</TT> as, the
class they're contained in.
<H3><A NAME="ClassMethodsandClassVariables">Class Methods and
Class Variables</A></H3>
<P>
Sometimes you may need to have information that is global to a
class and shared by every instance of that class. One reason you
might want to do this is for values that do not change, as in
defining mathematical constants, like pi. Or you may want to define
a version number for a class. Finally, if your class is providing
a service that is used throughout an applet, you may want to make
its data global to the class so that objects can share the information.
<P>
<I>Class</I><B> </B><I>methods</I> and <I>class</I><B> </B><I>variables</I>
are employed to define data that is local to a class and not an
object. For this reason, class variables are different from instance
variables. Class methods and class variables are declared by using
the <TT>static</TT> keyword, which
sometimes results in them being referred to as <I>static</I><B>
</B><I>methods</I> and <I>static</I><B> </B><I>variables</I>.
<P>
From the ever present AddressRecord example, you can make the
two public address flags into class variables by adding the <TT>static</TT>
keyword:
<BLOCKQUOTE>
<TT>class AddressRecord extends SimpleRecord
{<BR>
&nbsp;&nbsp;&nbsp;public static int INTERNET_ADDRESS = 0;<BR>
&nbsp;&nbsp;&nbsp;public static int PHYSICAL_ADDRESS = 1;<BR>
&nbsp;&nbsp;&nbsp;// ... Constructors and methods...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This is more efficient than the previous use that just declared
the addresses as <TT>public</TT>.
By adding the <TT>static</TT> keyword,
you have indicated that these flags are global to the class and
not the particular instance.
<P>
Class methods are even more interesting. In Part III of this book,
you will create a class that keeps track of images that have been
loaded in memory. This class information is kept across invocations
of applets, so some of this class information doesn't need to
be tied to a particular instance. In fact, there is only one instance
of the class, and it is invoked by the class itself! The class
does this through a private constructor. Here are some of the
code highlights:
<BLOCKQUOTE>
<TT>public class MediaLoader {<BR>
&nbsp;&nbsp;&nbsp;// Cache is hashtable...<BR>
<BR>
&nbsp;&nbsp;&nbsp;static Hashtable cache = new Hashtable(cacheSize);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// The loader is static and so can be created
only once<BR>
&nbsp;&nbsp;&nbsp;private static MediaLoader loader = new <BR>
MediaLoader();<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Private internal constructor<BR>
&nbsp;&nbsp;&nbsp;private MediaLoader() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... various initilization
goes on here...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Return reference to this MediaLoader object
<BR>
&nbsp;&nbsp;&nbsp;public static MediaLoader getMediaLoader() {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return loader;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// ... internal methods..<BR>
}</TT>
</BLOCKQUOTE>
<P>
A lot of interesting things are going on here. A <TT>cache</TT>,
which is used to store images, is declared as a class variable.
One of the neat things about Java is the flexibility with which
you can structure your code. Note how this initialization is not
within a method but is part of the class definition; remember
that because the <TT>cache</TT> variable
is <TT>static</TT>, it is a class
variable and thus is not tied to an object instance.
<P>
The next step is even more unusual. The loader class initializes
itself! The constructor is <TT>private</TT>
and not <TT>public</TT>, so no other
object can create an instance of the loader. Instead, the class
calls the <TT>private</TT> constructor
and stores the instantiated loader object into a <I>private class
variable</I>. In effect, the class is saying, &quot;Make only
one instance of this class, and only I know it!&quot;
<P>
How do other objects use this MediaLoader object? They do so by
calling the last method listed, <TT>getMediaLoader()</TT>.
It is a class method and so is not tied to any instance. The job
of the method is to return a <I>reference</I> to the <TT>private</TT>
instance of the object. The other objects can then use this reference
to call the <TT>public</TT> methods
of the loader class. These methods will not be declared as <TT>static</TT>.
<P>
To keep things simple, suppose that the loader has a <TT>public</TT>
method called <TT>getImage()</TT>,
with no parameters. Another object calls the method as follows:
<BLOCKQUOTE>
<TT>MediaLoader ref = MediaLoader.getMediaLoader();
// Get the reference!<BR>
ref.getImage(); // Call the method!</TT>
</BLOCKQUOTE>
<P>
Note how you call the class method <TT>getMediaLoader()</TT>
by prefacing it with the name of the class. Because class methods
are global to the class, you do not need an instance of the class.
<P>
The preceding call also could have been accomplished in one line
of code:
<BLOCKQUOTE>
<TT>MediaLoader.getMediaLoader().getImage();</TT>
</BLOCKQUOTE>
<P>
This method-chaining technique prevents you from creating short-lived
variables; you can use the object returned from one method call
as the object to be used in the next method call.
<P>
While class methods are extremely powerful, they have some restrictions.
In particular, they can work only on class variables. If you think
about it, the reason for this is obvious: They cannot work on
instance variables because there may not be an instance for them
to work with!
<P>
The various techniques you have seen in the MediaLoader class
are used throughout the Java Developer's Kit (JDK). You sometimes
see classes that you cannot figure out how to use. In this situation,
look for methods named something like <TT>getReference</TT>
or <TT>getDefault</TT>; these may
return a reference to an object instance of that class. You would
then employ them in a fashion similar to the MediaLoader class.
<H3><A NAME="ThefinalModifier">The <TT><FONT SIZE=4 FACE="Courier">final</TT></FONT><FONT SIZE=4>
Modifier</FONT></A></H3>
<P>
You use the <TT>final</TT> modifier
to indicate that something cannot be changed or overridden. If
the <TT>final</TT> modifier is applied
to a variable, it is effectively made into a <I>constant</I>.
In the AddressRecord example, the address flags are set to their
best form by adding the <TT>final</TT>
modifier:
<BLOCKQUOTE>
<TT>class AddressRecord extends SimpleRecord
{<BR>
&nbsp;&nbsp;&nbsp;public static final int INTERNET_ADDRESS = 0;
<BR>
&nbsp;&nbsp;&nbsp;public static final int PHYSICAL_ADDRESS = 1;
<BR>
&nbsp;&nbsp;&nbsp;// ... Constructors and methods...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Without the <TT>final</TT> modifier,
other classes could change the value of the variable by calling
something like
<BLOCKQUOTE>
<TT>AddressRecord.INTERNET_ADDRESS = 6;</TT>
</BLOCKQUOTE>
<P>
With the <TT>final</TT> modifier attached
to <TT>INTERNET_ADDRESS</TT>, however,
this line of code would generate a compiler error. This is because
<TT>final</TT> variables cannot be
modified.
<P>
If a method is declared as <TT>final</TT>,
it cannot be subclassed. Because <TT>private</TT>
methods cannot be subclassed, they are effectively <TT>final</TT>.
Note, however, that the converse does not hold. It is useful to
declare methods as <TT>final</TT>
whenever it is appropriate. This allows the Java compiler to make
some optimizations, thus improving the performance of your code.
If the compiler knows that a method cannot be subclassed, it can
do such things as &quot;in-lining&quot; the method wherever it
is called. Because a <TT>final</TT>
method cannot be subclassed, runtime lookups for matching method
signatures as part of the subclassing mechanism are not necessary.
<P>
To declare a method as <TT>final</TT>,
place the modifier as follows:
<BLOCKQUOTE>
<TT>public final void list()</TT>
</BLOCKQUOTE>
<P>
You can also declare classes as <TT>final</TT>.
This means that the class cannot be subclassed. The main reason
you may want to declare a class as <TT>final</TT>
is related to security. In the JDK, many classes are <TT>final</TT>.
The reason for this is clear if you think about it. For example,
suppose that you could subclass the System class! It would then
be relatively easy to subvert the security of a client. Final
classes may also be subject to some compiler optimizations, thus
providing an additional reason for declaring a class as <TT>final</TT>.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The term <I>accessor methods</I> refers to methods used to set and retrieve a variable. This is the preferred way of constructing a class rather than declaring everything as <TT>public</TT>. In the SimpleRecord class, the preferred way to set or retrieve the <TT>firstName</TT> variable of an object is to create methods like
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public void setFirstName(String firstName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstName = firstName;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public String getFirstName() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return firstName;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
where the variable <TT>firstName</TT> is not declared as <TT>public</TT>. While writing a <TT>set</TT> or <TT>get</TT> method for every accessible variable may seem tedious, it is better than declaring everything <TT>public</TT>. If you make instance variables <TT>public</TT>, you're compromising the principle of encapsulation. By exposing <TT>public</TT> instance variables to objects that use your class, you're making the outside world aware of how your class works. You may then lose the freedom to modify the inner workings of your class. For example, if you want to rename or delete a <TT>public</TT> instance variable, you may not be able to do so because all kinds of classes are using this variable! This very bad practice departs from all the good principles of object-oriented programming. So while it may seem painful now to write large numbers of <TT>set</TT> or <TT>get</TT> methods, you're saving yourself time down the road. If you have a good editor, it won't take that much time anyway.
</BLOCKQUOTE>
<BLOCKQUOTE>
The term <I>accessor class</I> is sometimes used to refer to classes that do nothing more than hold data reachable through accessor methods; the classes have no behavior per se. For C programmers, you will often want to write an accessor class where you would normally create a structure.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H3><A NAME="ThenullKeywordandMoreaboutGarbage">The <TT><FONT SIZE=4 FACE="Courier">null</TT></FONT><FONT SIZE=4>
Keyword and More about Garbage Collection</FONT></A></H3>
<P>
The <TT>null</TT> keyword indicates
that something has no instance. By default, an uninitialized class
variable is set to <TT>null</TT>.
Sometimes you might want to do this explicitly-simply for code
readability-if your variable will not be initialized for a while.
<P>
The biggest use of <TT>null</TT> occurs
when you no longer need an object. For example, suppose that you
create a local variable in a long and involved method that refers
to an instance of the Integer class. You use the Integer object
for a while, and then you want to indicate that it is no longer
needed. You can do this with the <TT>null</TT>
keyword:
<BLOCKQUOTE>
<TT>Integer I = new Integer(6);<BR>
// ... do something with the object...<BR>
I = null;</TT>
</BLOCKQUOTE>
<P>
You can achieve the same result in other ways. You can enclose
the variable in a block statement; when the variable goes out
of scope, the object will no longer be referenced. If you reuse
the variable for another object reference, the old object will
no longer be referenced:
<BLOCKQUOTE>
<TT>Integer I = new Integer(6);<BR>
// ... do something with the object...<BR>
I = new Integer(9);&nbsp;&nbsp;// Old Integer reference is <BR>
gone...</TT>
</BLOCKQUOTE>
<P>
Why would you want to set something to <TT>null</TT>?
Recall that Java's memory management is through a garbage collector.
This garbage collector removes objects from memory that are no
longer referenced. If your variable was the only reference to
the object, then after the reference is removed, the object is
a candidate for garbage collection. Remember that the garbage
collector is a low-priority thread, so the object may not be cleaned
up immediately. If you are really tight on memory, you can call
the garbage collector explicitly via the System class:
<BLOCKQUOTE>
<TT>System.gc();</TT>
</BLOCKQUOTE>
<P>
Like all methods in the System class, <TT>gc()</TT>
is a class method, so you don't have to create any instance to
use it. The kind of situations in which you might want to call
the garbage collector explicitly is after involved operations
that consume a large number of objects and system resources. Do
not call the collector in a loop, however. The <TT>gc()</TT>
operation runs the full collector, so the collector's execution
will take a moment or so.
<H3><A NAME="ScopingRules">Scoping Rules</A></H3>
<P>
When a variable is referenced inside a method, Java first looks
in an enclosing block for a declaration. If a declaration is not
found, Java travels up the nested blocks until it reaches the
method definition. If the variable is found anywhere inside a
method, the variable has priority over a similarly named instance
or class variable. This is why you often see code like the following:
<BLOCKQUOTE>
<TT>public SimpleRecord(String firstName,
String lastName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstName = firstName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lastName = lastName;
<BR>
}</TT>
</BLOCKQUOTE>
<P>
The <TT>this</TT> keyword is used
here to differentiate the instance variable from the local variable.
<P>
If the referenced variable is not found inside the method, Java
searches the class. If the reference variable still is not found,
Java travels up the class hierarchy (until the Object class is
reached), inspecting the superclasses for the variable. You have
seen how this works in the &quot;Inheritance in Java&quot; section.
<H3><A NAME="CastingRules">Casting Rules</A></H3>
<P>
Use <I>casting</I> when you need to convert an object or primitive
of one type to another type. For example, you may want to convert
a <TT>double</TT> to an <TT>int</TT>,
or a subclass to its superclass. Casting allows you to do this,
although the rules of casting can be complicated. The key thing
to remember about casting is that it does <I>not</I> affect the
object or value being cast. However, the receiver of the cast
constitutes a new object or a new type.
<P>
Casting primitive data types occurs quite often, such as when
you are reading in a stream of data. How the cast occurs depends
on the precision of the types involved in the cast. Precision
relates to how much information the type can contain; for example,
a floating point type such as <TT>double</TT>
or <TT>float</TT> has more precision
than a simple number like <TT>int</TT>.
Likewise, <TT>double</TT> has more
precision than <TT>float</TT> because
it is 64-bit as opposed to 32-bit. Whenever you transfer data
from a less precise type to a more precise type, explicit casting
is <I>not</I> required:
<BLOCKQUOTE>
<TT>int i = 3;<BR>
double pi = i + .14159;</TT>
</BLOCKQUOTE>
<P>
On the other hand, transferring data from a more precise type
to a less precise type requires casting. This is because data
may be lost in the casting. Java forces you to explicitly cast
because it wants you to be aware of the possible danger of such
a conversion:
<BLOCKQUOTE>
<TT>double pi = 3.14159;<BR>
int i = (int)pi;  // This is set to 3 (you lost the <BR>
.14159!)</TT>
</BLOCKQUOTE>
<P>
Casting between objects is a little more complicated. To illustrate
casting, look at the Hashtable class of the JDK. This class takes
instances of the Object class and places them into a hash table
via a method called <TT>put()</TT>,
where a String is used as a key. To retrieve them from the table,
you invoke <TT>get()</TT>, which takes
a String key and returns the corresponding Object.
<P>
Recall that Object is a superclass of all classes; every class
is a subclass of Object. Suppose that you have a class called
MyClass and a String that will be used as a key, placed in a variable
<TT>key</TT>. You can place it in
a Hashtable object, indicated by the variable <TT>hash</TT>,
as follows:
<BLOCKQUOTE>
<TT>MyClass MyObject;<BR>
hash.put(key,MyObject);</TT>
</BLOCKQUOTE>
<P>
Because you want to keep your object, MyObject, as an instance
of MyClass, don't cast it when you call <TT>put()</TT>.
This is acceptable because MyClass is a subclass of Object.
<P>
Suppose that you want to actually store MyObject as a proper Object.
In other words, you want to cast a subclass to a superclass. You
would then cast it as follows:
<BLOCKQUOTE>
<TT>hash.put(key,(Object)MyObject);</TT>
</BLOCKQUOTE>
<P>
By doing this, however, you lose the functionality of MyObject.
<P>
Suppose that you store the MyObject in the original example, without
casting. When you retrieve the object, it is returned as an Object.
You can convert the Object returned by <TT>get()</TT>
to the original MyObject by casting:
<BLOCKQUOTE>
<TT>MyClass MyObject;<BR>
hash.put(key,MyObject);<BR>
// ... do something...<BR>
MyClass MyObject2 = (MyClass)hash.get(key);&nbsp;&nbsp;// Get
back original MyObject</TT>
</BLOCKQUOTE>
<P>
In this case, you're using casting to convert a superclass to
a subclass. You can then use <BR>
the variable <TT>MyObject2</TT> as
an instance of MyClass. It will be identical to the original <TT>MyObject</TT>
variable.
<P>
If you structure the code in the following way, you will have
problems:
<BLOCKQUOTE>
<TT>MyClass MyObject;<BR>
hash.put(key,(Object)MyObject);<BR>
// ... do something...<BR>
MyClass myObject2 = (MyClass)hash.get(key);&nbsp;&nbsp;// Don't
<BR>
do this!</TT>
</BLOCKQUOTE>
<P>
Problems will occur because MyObject was stored in this case as
an Object. When you retrieve it, even after casting, it is not
really an instance of MyObject any more because that data was
lost. If you try to use a <TT>MyObject</TT>
method or variable after this, you get a runtime exception.
<P>
You cannot cast indiscriminately. If you try to convert two sibling
classes (they are not derived from each other), you get a compilation
error:
<BLOCKQUOTE>
<TT>AddressRecord a = new AddressRecord(&quot;Thomas&quot;,&quot;Jefferson&quot;,&quot;Monticello&quot;);
<BR>
String s = (String)a;  // THIS WILL NOT COMPILE!</TT>
</BLOCKQUOTE>
<P>
You cannot cast primitive data types to objects or vice versa.
However, you can effectively perform these conversions by using
the type wrapper classes discussed earlier in this chapter.
<H3><A NAME="OtherKeywords">Other Keywords</A></H3>
<P>
You use the <TT>instanceof</TT> operator
to test if a class is an instance of another. A subclass will
be an instance of its superclass, but not vice versa. For example,
the first three of the following print statements will display
<TT>true</TT>. (Recall that AddressRecord
is a subclass of SimpleRecord.) Only the last test will be <TT>false</TT>.
<BLOCKQUOTE>
<TT>AddressRecord a = new AddressRecord();
<BR>
System.out.println((a instanceof SimpleRecord));&nbsp;&nbsp;//
true<BR>
System.out.println((a instanceof AddressRecord));&nbsp;&nbsp;//
true<BR>
SimpleRecord b = new SimpleRecord();<BR>
System.out.println((b instanceof SimpleRecord));&nbsp;&nbsp;//
true<BR>
System.out.println((b instanceof AddressRecord));&nbsp;&nbsp;//
false</TT>
</BLOCKQUOTE>
<P>
Another important modifier is <TT>synchronized</TT>.
You will see this modifier in code throughout this book and in
the JDK. The <TT>synchronized</TT>
modifier is related to coordinating thread processing; it is discussed
in depth in Part III of the book.
<H2><A NAME="IntroductiontoExceptionHandling"><FONT SIZE=5 COLOR=#FF0000>Introduction
to Exception Handling</FONT></A></H2>
<P>
One of the great challenges for programmers is how to handle runtime
errors in a graceful and efficient manner. In traditional programming,
developers manage problems by passing success or failure codes
in <TT>return</TT> statements. The
calling functions then check the return code in an <TT>if...else</TT>
statement. If the function succeeds, one chain of action is called;
otherwise, another course of action is taken.
<P>
There are a couple of problems with this approach. First, this
approach results in bloated code. To have to put an <TT>if...else</TT>
check around every function call increases the size of your code
by several factors. Even worse, this traditional approach does
not enforce strong error checking. Because of sloppiness or overconfidence,
programmers often ignore return codes. If there is a problem in
an unchecked function call, however, the program may end up reaching
a dangerous state that eventually culminates in an abnormal termination.
The ensuing search for the cause of the error would probably prove
to be quite painful because the source of the problem is not readily
apparent.
<P>
Fortunately, Java's strongly enforced implementation of exception
handling makes it easier to track down errors. In fact, many errors
are caught by the compiler instead of at runtime. If the problem
does happen at runtime, however, a stack trace makes the difficulty
easy to spot. Furthermore, Java's error-handling mechanism does
not result in the kind of code bloat typical of traditional programming.
Java's way of handling errors is through a programming construct
called an <I>exception handler</I>.
<H3><A NAME="StructureofanExceptionHandler">Structure of an Exception
Handler</A></H3>
<P>
An <I>exception handler</I> is often called a <I>try-catch block
</I>because of its structure. It is typified by a block of code
called a <I>try block</I>, which is where you attempt to execute
your normal course of action. The code marches right through the
block if there is no problem. If there is an error, however, Java
or the called method may generate an object that may indicate
the problem. This object is called an <I>exception object</I>
and is passed off to the runtime system in search of a way to
handle the error. The act of passing an exception object to the
runtime system is called <I>throwing an exception</I>.
<P>
The job of the catch block of an exception handler is to catch
any exception objects thrown from within the try block. It can
then perform any cleanup or message notification as a consequence
of the error.
<P>
A simple example can illustrate the basics of writing an exception
handler. Suppose that you need to divide two numbers. Division,
of course, can be the cause of a frequent problem: divide-by-zero
errors. However, the following code handles this problem in a
graceful manner:
<BLOCKQUOTE>
<TT>int z = 0;<BR>
try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;z = x/y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Z = &quot; +
z);<BR>
}<BR>
catch (Exception e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Divide by zero
error.&quot;);<BR>
}</TT>
</BLOCKQUOTE>
<P>
If the variable <TT>y</TT> in this
example is not <TT>0</TT>, the division
goes fine, and the result is printed. However, if the variable
is <TT>0</TT>, an exception is thrown.
The Java runtime system will then try to find an exception handler
to manage the error. Fortunately, Java will not have to look very
far. The catch clause in the exception handler catches the thrown
exception. This handler prints the fact that there is a divide-by-zero
error to standard output.
<P>
An exception handler has an optional block placed at the end of
the code called the <I>finally block</I>, which provides code
to be executed regardless of whether an exception occurs.
<BLOCKQUOTE>
<TT>int z = 0;<BR>
try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;z = x/y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Z = &quot; +
z);<BR>
}<BR>
catch (Exception e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Divide by zero
error.&quot;);<BR>
}<BR>
finally {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Finally: Z =
&quot; + z);<BR>
}</TT>
</BLOCKQUOTE>
<P>
Regardless of what happens in the division operation, the last
print statement is invoked.
<H3><A NAME="WhentoCatchExceptions">When to Catch Exceptions</A>
</H3>
<P>
When should you catch an exception? Sometimes exceptions are generated
as a result of a normal runtime violation, such as a division
error or an array out of bounds. However, methods can also explicitly
throw exceptions. A method can declare that it can throw an exception
via the <TT>throws</TT> clause.
<P>
For example, it was stated earlier that the Integer class has
a method, called <TT>parseInt()</TT>,
that takes a String and converts it to an <TT>int</TT>
data type. When the String cannot be converted to a number, however,
the <TT>parseInt()</TT> method throws
a NumberFormatException object.
<P>
The following code tries to convert some Strings to integers and
prints their values:
<BLOCKQUOTE>
<TT>String s = &quot;100&quot;;<BR>
String s2 = &quot;Not a number&quot;;<BR>
try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The
first number is: &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt(s));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The
second number is: &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt(s2));
<BR>
}<BR>
catch (NumberFormatException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Cannot
convert String to <BR>
number!&quot;);<BR>
}</TT>
</BLOCKQUOTE>
<P>
The first conversion succeeds, but the second fails. The NumberFormatException
generated is caught by the exception handler, and an error message
is printed. The calling code knows that <TT>parseInt()</TT>
throws this kind of exception because of how the method is declared:
<BLOCKQUOTE>
<TT>public static int parseInt(String s)
throws NumberFormatException</TT>
</BLOCKQUOTE>
<P>
The <TT>throws</TT> section of the
declaration indicates that the method may throw a certain type
of exception if an operation cannot be performed. Whenever you
use a method that has a <TT>throws</TT>
clause, you should probably catch the type of exception the method
throws. Depending on the type of exception thrown, an exception
handler may or may not be required for a successful compile. Categories
of exceptions are discussed in more detail in the next chapter.
<P>
To throw an exception, you use the <TT>throw</TT>
keyword. The <TT>throw</TT> statement
passes a throwable object that follows it to the runtime environment,
which then begins trying to find an exception handler to catch
the object. The method that throws the exception is no longer
executed after the <TT>throw</TT>
statement is invoked.
<P>
Exceptions, like everything else in Java, are objects. Consequently,
you can generate an exception object by instantiating it with
the <TT>new</TT> operator. You would
then use the <TT>throw</TT> keyword
to throw the object. Because the <TT>parseInt()</TT>
method throws a NumberFormatException, it's likely that there
is a line of code in the method similar to the following:
<BLOCKQUOTE>
<TT>throw new NumberFormatException();</TT>
</BLOCKQUOTE>
<H3><A NAME="ExceptionHandlersandExceptionClasses">Exception Handlers
and Exception Classes</A></H3>
<P>
As indicated in the previous section, exceptions have different
types, or more specifically, classes. For example, NumberFormatException
refers to a specific class. When an exception is generated, the
Java runtime system looks for an <I>appropriate</I> handler to
catch the exception. The details of this process are explained
in the next chapter, but remember that whether or not a handler
is appropriate has to do with the class of the exception.
<P>
To clarify this, consider a couple of exception classes. The ArithmeticException
class represents errors caused by illegal arithmetic operations,
usually divided by zero. Objects of class ArrayIndexOutOfBoundsException
are thrown when an invalid array index is accessed. The Exception
class is used to represent the general class of exceptions; the
other exception classes that have been discussed are actually
subclasses of Exception.
<P>
The following example shows how these exceptions are used:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = Integer.parseInt(s);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y =Integer.parseInt(s2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index =Integer.parseInt(s3);
<BR>
</TT>\<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
a[] = new int[5];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[index] = x/y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Everything
worked!&quot;);<BR>
}<BR>
catch (ArithmeticException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Arithmetic
exception&quot;);<BR>
}<BR>
catch (ArrayIndexOutOfBoundsException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Array
index out of bounds <BR>
exception&quot;);<BR>
}<BR>
catch (NumberFormatException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Cannot
convert String to <BR>
number!&quot;);<BR>
}<BR>
catch (Exception e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Generic
exception&quot;);<BR>
}</TT>
</BLOCKQUOTE>
<P>
The first part of the code takes three input Strings and tries
to convert them into integers; if the conversion fails, a NumberFormatException
object is thrown. However, the third <TT>catch</TT>
clause will catch the thrown object. If the clause were not there,
the last <TT>catch</TT> clause would
catch the problem because NumberFormatException is a subclass
of Exception. The general rule is this: Java searches the <TT>catch</TT>
clauses in the order they are declared, looking for a handler
that either matches the class of the exception thrown or is a
superclass of it. The runtime system will use the first handler
that matches. If no appropriate handler is found, Java will go
up the runtime stack and look at the next method. Java looks for
an appropriate handler in the same way. This process repeats until
the top of the stack is reached or until an appropriate handler
is found. If there is no appropriate handler, Java dumps the stack
trace to standard output. Depending on the nature of the class
being thrown, the program may terminate abnormally.
<P>
After the Strings are converted to numbers, the program tries
to divide the numbers. If the program divides by zero, an ArithmeticException
object is thrown. The object is caught by the ArithmeticException
<TT>catch</TT> clause, although the
<TT>Exception</TT> clause also would
have handled it.
<P>
Finally, the code assigns the divided number to an array index.
If the index is illegal, an ArrayIndexOutOfBoundsException is
thrown. However, there is also an appropriate handler for it,
so the code finishes gracefully.
<H3><A NAME="NestedExceptions">Nested Exceptions</A></H3>
<P>
You can also nest exceptions. To illustrate this, look at the
following rework of the preceding example:
<BLOCKQUOTE>
<TT>int y = 0;<BR>
int z = 0;<BR>
int z = 0;<BR>
int index = 0;<BR>
int a[] = new int[5];<BR>
try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = Integer.parseInt(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y =Integer.parseInt(s2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index =Integer.parseInt(s3);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[index] = x/y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Everything
worked!&quot;);<BR>
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (ArithmeticException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Arithmetic
exception. Try to assign Zero&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[index]
= x/z;&nbsp;&nbsp;// Try another division to <BR>
the index<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (ArithmeticException
e2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Another
Arithmetic exception&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
catch (ArrayIndexOutOfBoundsException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Array
index out of bounds <BR>
exception&quot;);<BR>
}<BR>
catch (NumberFormatException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Cannot
convert String to number!&quot;);<BR>
}<BR>
catch (Exception e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Generic
exception&quot;);<BR>
}</TT>
</BLOCKQUOTE>
<P>
If the <TT>int</TT> variable <TT>y</TT>
evaluates to <TT>0</TT>, an ArithmeticException
is thrown. When it is caught, the code attempts to perform yet
another division. Unfortunately, this is also a divide-by-zero
<BR>
error. Fortunately, this is caught in a nested ArithmeticException
catch block. If there were no divide-by-zero problem but the index
were illegal, the outer ArrayIndexOutOfBoundsException <TT>catch</TT>
clause would catch the exception.
<P>
You learn more about exception handling in the next chapter. You
see how Java organizes its exception classes, what methods to
use, and how to use them. The following chapter also discusses
how to write your own exception classes within the framework established
by Java.
<H2><A NAME="OrganizingProjectsinJava"><FONT SIZE=5 COLOR=#FF0000>Organizing
Projects in Java</FONT></A></H2>
<P>
You've seen a wide variety of constructs that Java uses to help
you develop classes. These are useful for quickly getting an applet
up and running. But what happens if you are working on a large-scale
project that requires a carefully designed and organized class
hierarchy? How will Java help you manage all of the classes required
in such an environment?
<P>
Fortunately, Java provides a variety of constructs that help you
develop large-scale software as well as small applets. These constructs
range from those that help you lay out your design to those that
help you pull the pieces together. With these techniques in hand,
you can use Java to design applets that can meet your current
requirements and can be used as a foundation for future development.
<H3><A NAME="AbstractMethods">Abstract Methods</A></H3>
<P>
Suppose that you're defining a class that manages files on your
hard disk. You can define most of the high-level methods, such
as how to list files and their attributes; however, you can't
define low-level behavior, such as how you actually get the file
attributes. Because this is platform dependent, you want to leave
this behavior as undefined so it can be implemented for practical
purposes.
<P>
In Java, you use <I>abstract methods</I> and <I>abstract classes</I>
to define a template for a class that is well defined except for
a few methods. A class is abstract if one or more methods are
defined by the <TT>abstract</TT> keyword.
The following case shows how you might structure the discussed
file manager as an abstract class:
<BLOCKQUOTE>
<TT>abstract class FileManager {<BR>
&nbsp;&nbsp;&nbsp;// Abstract class that enumerates files...<BR>
&nbsp;&nbsp;&nbsp;public abstract String enumerateFiles(String
file);<BR>
&nbsp;&nbsp;&nbsp;// Practical implementation. List all files
<BR>
&nbsp;&nbsp;&nbsp;// using abstract enumerateFiles...<BR>
&nbsp;&nbsp;&nbsp;public void dir() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // ... call enumerateFiles...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// ... other methods<BR>
}</TT>
</BLOCKQUOTE>
<P>
In this example, the only abstract method is <TT>enumerateFiles()</TT>,
which provides the low-level implementation of getting a file
attribute. However, this is enough to make the class abstract.
All the other methods are well defined, so if you create a class
that provides a practical implementation of <TT>enumerateFiles()</TT>,
the class will be ready to use. As long as a class is abstract,
though, it cannot be instantiated.
<P>
You need to subclass the FileManager class to create a class that
can be implemented. Here is one way to do it:
<BLOCKQUOTE>
<TT>class MyFileManager extends FileManager
{<BR>
&nbsp;&nbsp;&nbsp;// Enumerate all files...<BR>
&nbsp;&nbsp;&nbsp;public String enumerateFiles(String file) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... do the platform specific
operation...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This class uses all the methods of FileManager and is ready to
be instantiated.
<P>
There are a couple of restrictions in creating abstract methods.
Constructors and <TT>private</TT>
or <TT>static</TT> methods cannot
be declared as abstract. (If you think about the semantics of
these, it should be clear why they cannot be abstract.) You also
cannot replace a <TT>superclass</TT>
method with an <TT>abstract</TT> method.
<H3><A NAME="Interfaces">Interfaces</A></H3>
<P>
If you have a class that is nothing but abstract methods, it's
better not to use the <TT>abstract</TT>
keyword. Java provides a technique called <I>interfaces</I>, which
you can use to define a template of behavior. Like abstract methods,
interfaces cannot be instantiated. Interfaces differ from abstract
methods, however, in that no interface methods can have a body.
Interfaces are strictly templates.
<P>
By their nature, interfaces are a way of defining a <I>design</I>.
It specifies the kinds of behaviors that something needs to have.
Classes that <I>implement</I> the interface are said to provide
the <I>implementation</I> of the design.
<P>
Interfaces are also Java's way of dealing with the limitations
of single inheritance. Unlike C++, Java avoids multiple inheritance
because of all the problems related to it, such as name ambiguity.
Interfaces are a way of adding behavior to a class without compromising
its fundamental behavior. However, a class can implement multiple
interfaces and so simulate multiple inheritance.
<P>
The following example shows how interfaces are used. Suppose that
you're working for a printer company. You have a well-defined
and tested Printer class and a Document class that represents
what is to be printed. However, your company wants to move into
the fax and copier markets, so a multifunction printer will be
developed.
<P>
You define two interfaces for copiers and fax machines as follows:
<BLOCKQUOTE>
<TT>interface Copier {<BR>
&nbsp;&nbsp;public void copyDocument(Document d);<BR>
}<BR>
<BR>
interface Fax {<BR>
&nbsp;&nbsp;public void transmitDocument(Document d);<BR>
}</TT>
</BLOCKQUOTE>
<P>
These interfaces define the behavior that a copier and fax machine
should have, respectively. You can also add this behavior to the
Printer class to get the desired multifunction printer. You can
implement these interfaces in a class that is a subclass of Printer:
<BLOCKQUOTE>
<TT>class MultiFunctionPrinter extends Printer
<BR>
&nbsp;implements Copier, Fax {<BR>
&nbsp;&nbsp;public void copyDocument(Document d) {<BR>
&nbsp;&nbsp;&nbsp;// Practical implementation of Copier...<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public void transmitDocument(Document d) {<BR>
&nbsp;&nbsp;&nbsp;// Practical implementation of Fax...<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
You now have a multifunction Printer class!
<P>
It should be noted that interfaces can have variables but cannot
have modifiers.
<H3><A NAME="Packages">Packages</A></H3>
<P>
<I>Packages</I> are a mechanism for grouping classes and interfaces.
Every class or interface has a package. You can explicitly name
the package in which it appears by using the <TT>package</TT>
statement:
<BLOCKQUOTE>
<TT>package myPackage;</TT>
</BLOCKQUOTE>
<P>
If no package is specified, a default package is used (usually
represented by the current directory).
<P>
Java has a hierarchical naming convention for naming packages,
known as a <I>dot notation</I>. The top level of the notation
represents the producer of the source file, such as &quot;java.&quot;
After that, you would name subhierarchies. For example, the JDK
has a package called &quot;lang&quot; that is used to house classes
related to the basic mechanics of programming in Java. The String
class is in the &quot;lang&quot; package. You can therefore refer
to the class from anywhere in your source code as <TT>java.lang.String</TT>.
This dot structure is reflected in the directory organization
of the source code files that make up the package. Thus, the String.java
file will be located off a java/lang subdirectory.
<P>
Given this, the <TT>package</TT> declaration
for the String class would be
<BLOCKQUOTE>
<TT>package java.lang;</TT>
</BLOCKQUOTE>
<P>
The <TT>package</TT> declaration must
be the first non-comment, non-white space line in the file.
<P>
The <TT>import</TT> statement allows
you to use a class defined in another package or source file.
You can use the <TT>import</TT> statement
in several ways. You can define the full reference to the class,
as in the following:
<BLOCKQUOTE>
<TT>import java.lang.String;</TT>
</BLOCKQUOTE>
<P>
You can also bring in all classes in a package by specifying a
wildcard:
<BLOCKQUOTE>
<TT>import java.lang.*;</TT>
</BLOCKQUOTE>
<P>
Anything imported is thereafter treated as part of the current
package for the purposes of compilation.
<P>
You can also reference a class in the code by using the full package
reference:
<BLOCKQUOTE>
<TT>java.lang.String s = &quot;A string&quot;;
<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Java runtime system looks for classes by the path specified by the <TT>CLASSPATH</TT> environment variable. You can specify multiple directories in the path. For example:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>CLASSPATH=\java\classes;.</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This path looks first in a Java directory for the class files and then in the current directory.</BLOCKQUOTE>
<BLOCKQUOTE>
If the runtime system cannot find the class requested, it may look in the current directory, even if it was not specified in <TT>CLASSPATH</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
A final note about <I>compilation units</I>: A compilation unit
is a source code file that has <I>at most</I> one public class
or interface. The file must be the same name as the <TT>public</TT>
declaration, followed by the .java suffix. So if your source code
declares a public class SimpleRecord, the file it appears in must
be named SimpleRecord.java. While this convention may seem annoying
at first, it will prove to be helpful because your files will
give a quick listing of your public classes. The convention also
helps you write more modular and easier-to-maintain code.
<H2><A NAME="TheJavaDevelopersKit"><FONT SIZE=5 COLOR=#FF0000>The
Java Developer's Kit</FONT></A></H2>
<P>
You have now seen all of the fundamentals of Java programming.
However, one last thing needs to be discussed. The <I>Java Developer's
Kit (JDK)</I> is a series of class libraries organized as packages
that give you a set of tools for creating software based on Java.
The JDK consists of over 150 classes that provide functionality
ranging from manipulating Strings to working with network sockets.
A large number of these classes are used and explained throughout
this book. Many of them are subject to extended tutorials, while
others are explained in the course of describing a chapter project.
A quick overview of the JDK will get you ready for the in-depth
coverage that follows.
<P>
Eight packages make up the JDK. These packages are represented
by the &quot;java.&quot; notation mentioned earlier:
<UL>
<LI><B>java.lang:</B> This package contains classes related to
the basic workings of the Java environment. Such activities include
wrappers for basic data types and strings, classes for managing
threads, a class for mathematical operations, a wide variety of
classes for describing exceptions, the System class, and the Object
base class. The classes in this package appear throughout this
book.
<LI><B><FONT COLOR=#000000>java.io:</FONT></B> Classes for controlling
file and stream operations. The fundamentals of using this package
are introduced in <A HREF="ch4.htm" >Chapter 4</A>, &quot;Enhancing
the Spreadsheet Applet.&quot; The java.io classes for stream operations
are employed in many of the chapter projects.
<LI><B><FONT COLOR=#000000>java.util</FONT>:</B> This package
provides a series of utility classes: a class for manipulating
dates; basic data structure classes, such as hash tables and stacks;
a class and interface for writing classes that use the model-view
paradigm; and a tool for parsing Strings. Classes in the java.util
package are used throughout this book.
<LI><B><FONT COLOR=#000000>java.applet:</FONT></B> This package
contains the Applet class that ties your applet to its working
environment, such as a browser. It also has a class that allows
you to more directly exploit the native browser's capabilities.
Classes of the java.applet package are explored in detail in <A HREF="ch6.htm" >Chapter 6</A>,
&quot;Building a Catalog Applet,&quot; and are employed throughout
this book.
<LI><B><FONT COLOR=#000000>java.awt:</FONT></B> The <I>AWT (Abstract
Window Toolkit)</I> package provides simple and advanced tools
used to direct the visual interface of a Java applet. The most
important of the AWT tools is a set of standard controls that
allow you to interact with the applet, such as buttons and text
fields. Because AWT is one of the cornerstones of Java applet
programming, Part II of this book is dedicated to exploring the
package. Furthermore, various techniques for using AWT classes
appear throughout the remainder of this book.
<LI><B><FONT COLOR=#000000>java.awt.image:</FONT></B> This &quot;sub-package&quot;
of AWT provides the underpinnings for using images in Java. Although
it's a complex package, it is also very powerful. This package
is explored in depth in Part III of this book and in <A HREF="ch14.htm" >Chapter 14</A>,
&quot;Advanced Image Processing.&quot;
<LI><B><FONT COLOR=#000000>java.awt.peer:</FONT></B> This package
is used to tie AWT widgets to the underlying platform. Because
you will be more concerned with the AWT classes than with the
inner workings of these peers, this package is not discussed in
the following chapters.
<LI><B><FONT COLOR=#000000>java.awt.net:</FONT></B> The classes
in this package are used to write Java network programs. This
package includes sockets classes for both the client and the server
and classes for referencing URLs. Part IV of this book explores
this package in depth and uses its classes to build a Java-based
HTTP server.
</UL>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This first part of this book has introduced you to the fundamentals
of Java. You're now ready to dive head first into the world of
Java programming. Wear your safety belt! Each chapter that follows
will have an involved project that explores a feature of Java
in depth. Some of these projects are quite involved and touch
on many of the classes in the JDK. By the end of <A HREF="ch4.htm" >Chapter 4</A>,
you will have been presented with almost every major aspect of
writing an applet in Java (and more!). You're encouraged to explore
these projects on your computer. Modify the code to give extra
functionality or to add print statements to help you understand
what is going on. The emphasis of this book is learning by example,
so there will be no shortage of code to look at!
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



