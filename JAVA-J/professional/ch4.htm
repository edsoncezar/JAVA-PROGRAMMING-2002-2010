<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 4</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Enhancing the Spreadsheet Applet</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>




<UL>
<LI><A HREF="#OverviewofAWTPart2" >Overview of AWT: Part 2</A>
<UL>
<LI><A HREF="#WindowsandFrames" >Windows and Frames</A>
<LI><A HREF="#Menus" >Menus</A>
<LI><A HREF="#Dialogs" >Dialogs</A>
<LI><A HREF="#Colors" >Colors</A>
<LI><A HREF="#Fonts" >Fonts</A>
<LI><A HREF="#TheToolkitClass" >The Toolkit Class</A>
</UL>
<LI><A HREF="#IOandStreams" >I/O and Streams</A>
<UL>
<LI><A HREF="#StructureofthejavaioPackage" >Structure of the java.io Package</A>
</UL>
<LI><A HREF="#IOandSecurity" >I/O and Security</A>
<UL>
<LI><A HREF="#IOExceptions" >I/O Exceptions</A>
<LI><A HREF="#InputStreamClasses" >InputStream Classes</A>
<LI><A HREF="#OutputStreamClasses" >OutputStream Classes</A>
<LI><A HREF="#FilterOutputStreamClassesandFileOutpu" >FilterOutputStream Classes and FileOutputStream</A>
<LI><A HREF="#OtherOutputClasses" >Other Output Classes</A>
<LI><A HREF="#OtherIOClasses" >Other I/O Classes</A>
</UL>
<LI><A HREF="#Tutorial" >Tutorial</A>
<UL>
<LI><A HREF="#ClassOrganization" >Class Organization</A>
<LI><A HREF="#AddingtheColorDialog" >Adding the Color Dialog</A>
<LI><A HREF="#FontDialogBox" >Font Dialog Box</A>
<LI><A HREF="#TheFileDialogClass" >The FileDialog Class</A>
<LI><A HREF="#SavingaSpreadsheetFile" >Saving a Spreadsheet File</A>
<LI><A HREF="#OpeningaSpreadsheetFile" >Opening a Spreadsheet File</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>The previous chapter laid the foundations
for the spreadsheet applet to be developed throughout this part
of the book. In creating this first version of the spreadsheet,
<A HREF="ch3.htm" >Chapter 3</A>, &quot;Building a Spreadsheet
Applet,&quot; introduces many of the fundamental concepts of AWT
programming. It also discusses exception handling and practical
ways to handle errors in a Java application. However, this first
version of the spreadsheet applet also includes elements such
as menus and frames that were not discussed at the time they were
presented. These concepts are expanded on in this chapter.</FONT>
<P>
While exploring these aspects of Java programming, this chapter
will illustrate more features of the AWT package, and discussing
the Dialog classes will lead to the practical addition of dialog
boxes to the spreadsheet applet. Custom dialog boxes will be created
for the purposes of selecting the color and font of a spreadsheet
cell; they will be accessed through an expanded menu and their
selections will be made through upgraded classes. This chapter
also includes an introduction to streams programming, which is
used to add the capability of saving and reading a spreadsheet
file. Security issues related to file storage in Java will be
an important part of this discussion.
<H2><A NAME="OverviewofAWTPart2"><FONT SIZE=5 COLOR=#FF0000>Overview
of AWT: Part 2</FONT></A></H2>
<P>
The previous chapter's version of the spreadsheet applet did not
cover how to use the Frame and Menu classes. These features of
AWT are actually closely related. The Frame class also has a common
relationship with the Dialog class because they both are from
the same superclass, Window; therefore, dialog boxes will also
be covered in this section.
<P>
AWT applications can also be enhanced through the support of multiple
colors and fonts. Using them can not only make an applet more
visually pleasing, but can also give the user more freedom in
customizing the spreadsheet's display. The Color, Font, and FontMetrics
classes that make this possible are, therefore, also an appropriate
topic of discussion here.
<H3><A NAME="WindowsandFrames">Windows and Frames</A></H3>
<P>
The Window class is used in AWT to create &quot;popup&quot; windows
that appear outside the constraints of the normal browser area
allocated to an applet. The Window class is derived from the Container
class and so can contain other components. Unlike applet components
tied directly to a browser page, Window classes are not restricted
to a prespecified area of the screen. Window objects can be resized
as their immediate requirements dictate. AWT can perform this
automatically through the Window class's <TT>pack()</TT>
method; it works with the Window layout (by default, BorderLayout)
to arrive at the optimal presentation of the window, given its
contained components and screen resolution. Typically, <TT>pack()</TT>
is called before a window is displayed. Windows are not made visible
until the <TT>show()</TT> method is
called. They are removed from the screen, and their resources
freed, when the <TT>dispose()</TT>
method is invoked.
<P>
The Frame class extends Window by adding a title bar, a border
for resizing, support for menus, and the ability to modify the
system cursor to various states such as waiting or moving. For
most GUI platforms, the Frame's title bar will be tied to system
control boxes, such as minimize, maximize, or destroy. Consequently,
the Frame class has all the elements necessary to make an applet
look like a &quot;real&quot; application, complete with menus
and system controls.
<P>
Figure 4.1 and Listing 4.1 present a simple Frame applet that
changes the cursor to a state based on the button selected. The
applet class, FrameCursorApplet, does little more than launch
the main frame, FrameCursor. The constructor for this frame begins
by calling the frame super constructor. The sole parameter in
this case is the caption displayed on the title bar. The layout
for the Frame is then set. The default is BorderLayout, but in
this case, you want a three by two grid matrix, hence the use
of GridLayout. The buttons are added to the frame next, with names
representing the cursor state to be selected. After all the components
have been added, the <TT>pack()</TT>
method is invoked so that the button placement can be optimized.
Since this optimized placement will result in a small frame (six
buttons sized tightly around the label text doesn't take much
space), the <TT>resize()</TT> method
is called to make the frame a larger size. Finally, the frame
is displayed with the <TT>show()</TT>
method.
<P>
<A HREF="f4-1.gif" >Figure 4.1 : <I>Frame applets for changing the state of the cursor.</I></A>
<P>
When a button is selected, the custom method <TT>SetCursor()</TT>
is invoked. This method takes the button label and figures out
which cursor should be displayed. The Frame <TT>setCursor()</TT>
method is used to set the cursor state; its parameter is a static
integer defined as part of the Frame class.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You might see the message <TT><FONT SIZE=1 FACE="Courier">Untrusted Java Applet Window</TT></FONT> in your Netscape browser when applet frames are displayed. However, this is not cause for alarm-it is just a security message.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 4.1. Code for Frame applet that changes the cursor
state.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// This applet simply starts up the frame used to<BR>
// show different frame cursors...<BR>
public class FrameCursorApplet extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the frame with a
title...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new FrameCursor(&quot;Frame
Cursors&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// The frame for letting the user pick different<BR>
// cursors to display...<BR>
class FrameCursor extends Frame {<BR>
&nbsp;&nbsp;&nbsp;// Create the frame with a title...<BR>
&nbsp;&nbsp;&nbsp;public FrameCursor(String title) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Call the superclass constructor...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(title);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create a grid layout to
place the buttons...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new GridLayout(3,2));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the buttons for choosing
the cursor...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;Default&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;Wait&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;Hand&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;Move&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;Text&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Button(&quot;SE Resize&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pack and display...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(300,200); // Make it
a reasonable size...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Handle events...<BR>
&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(e.id) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case e.WINDOW_DESTROY:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();&nbsp;&nbsp;//
Erase frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.ACTION_EVENT:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(e.target instanceof Button)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetCursor((Button)e.target);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set the cursor based on the button chosen...
<BR>
&nbsp;&nbsp;&nbsp;void SetCursor(Button btn) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the label of the button...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String selection = btn.getLabel();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Set the cursor based on
that label...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (selection.equals(&quot;Wait&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.WAIT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (selection.equals(&quot;Hand&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.HAND_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (selection.equals(&quot;Move&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.MOVE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (selection.equals(&quot;Text&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.TEXT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (selection.equals(&quot;SE
Resize&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.SE_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else // Just use the default...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.DEFAULT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The current state of the cursor can be retrieved with the <TT>getCursorType()</TT>
method, and the <TT>getTitle()</TT>
and <TT>setTitle()</TT> Frame methods
can be used for getting and setting the title bar caption, respectively.
Similarly, the <TT>getIconImage()</TT>
and <TT>setIconImage()</TT> methods
can be used to set the image display of an iconized frame.
<H3><A NAME="Menus">Menus</A></H3>
<P>
Frames and menus are closely related since the Frame class is
the only AWT class with built-in support for menus. Frames implement
the MenuContainer interface, which is used to contain menu components.
These components are defined by the MenuComponent class, the superclass
of all menu components. It defines a set of methods pertinent
to individual menu items. For example, the <TT>getFont()</TT>
and <TT>setFont()</TT> MenuComponent
methods are used to control the font selection of the menu object.
<P>
Menus can be illustrated by modifying the previous example to
use menus, instead of buttons, to change the state of a cursor.
Listing 4.2 shows the code that performs this. The constructor
of the Frame class, called FrameMenuCursor, shows how to add menus
to a frame. The first step is creating a MenuBar object. The menu
bar is tied to the frame with the <TT>setMenuBar()</TT>
method of the Frame class. This makes the MenuBar object the default
menu for the frame.
<P>
The next step is to add the individual menus to the menubar. The
Menu class is used as a container of individual menu items or
other menus. In this applet, the two menus are File and Cursor.
The Menu constructor takes these strings as its sole parameter,
thus defining the text to be associated with the menu. The menus
are then added to the menu bar through the MenuBar <TT>add()</TT>
method. The <TT>remove()</TT> method
can be used to delete a Menu from a MenuBar.
<P>
The final step in menu creation is to add the individual menu
items, defined by the MenuItem class. This class is a subclass
of MenuComponent and provides additional operations to be performed
on a menu item. MenuItem methods can be used to set the menu label
and to disable or enable an item. The constructor for the MenuItem
has as its sole parameter the item label that will be initially
displayed. The <TT>add()</TT> method
is used to add an instance of MenuItem to a Menu.
<HR>
<BLOCKQUOTE>
<B>Listing 4.2. Code for applet that uses menus to change cursor
state.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// This applet simply starts up the frame<BR>
// which provides a menu for setting cursors...<BR>
public class FrameMenuCursorApplet extends Applet {<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the frame with a
title...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new FrameMenuCursor(&quot;Menu
Based Cursors&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// The frame for letting the user pick different<BR>
// cursors to display...<BR>
class FrameMenuCursor extends Frame {<BR>
&nbsp;&nbsp;&nbsp;// Create the frame with a title...<BR>
&nbsp;&nbsp;&nbsp;public FrameMenuCursor(String title) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Call the superclass constructor...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(title);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the menus...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First create the menu bar
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MenuBar mbar = new MenuBar();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setMenuBar(mbar); // Attach
to the frame...<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the File submenu...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Menu m = new Menu(&quot;File&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mbar.add(m);&nbsp;&nbsp;//
Add to menu bar<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add Quit to the submenu...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Quit&quot;));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the Cursor submenu...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = new Menu(&quot;Cursor&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mbar.add(m);&nbsp;&nbsp;//
Add to menu bar<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the cursor selections
to the submenu...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Default&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Wait&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Hand&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Move&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;Text&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.add(new MenuItem(&quot;SE
Resize&quot;));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Pack and display...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(300,200); // Make it
a reasonable size...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Handle events...<BR>
&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(e.id) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case e.WINDOW_DESTROY:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();&nbsp;&nbsp;//
Erase frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case e.ACTION_EVENT:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Process menu selection...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(e.target instanceof MenuItem) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Get the name of the menu selection..<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
menuName = e.arg.toString();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Dispose of frame if quit is chosen...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Quit&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Otherwise, set the cursor...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Default&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.DEFAULT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Wait&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.WAIT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Hand&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.HAND_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Move&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.MOVE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;Text&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.TEXT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(menuName.equals(&quot;SE Resize&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.SE_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
A MenuItem can be removed from a Menu with the <TT>remove()</TT>
method, much as it is in the MenuBar class. A separator, dividing
menu items, can be added with the <TT>addSeparator()</TT>
method of the Menu class. This is useful for menus that have different
categories of options.
<P>
The current example also illustrates how to process menu selections.
When a menu item is selected, an <TT>ACTION_EVENT</TT>
is issued. The <TT>instanceof</TT>
operator can be used in the handler to verify that the target
of the action is a menu. By taking the Event argument (the <TT>arg</TT>
variable) and converting it to a string, the program can get the
name of the menu item. Through the name, the appropriate course
of action can then be taken. In this example, the Quit menu item
forces the frame to shut down by using the <TT>dispose()</TT>
method. The other menu choices result in a new state for the cursor.
<P>
It should be mentioned that the CheckboxMenuItem class can be
implemented for menus that need to use checkmarks to indicate
whether the item has been selected. This is handy for menu items
that toggle.
<H3><A NAME="Dialogs">Dialogs</A></H3>
<P>
Like the Frame class, the Dialog class is a subclass of Window.
Dialogs differ from Frames in a couple of subtle ways, however.
The most important of these differences is that Dialogs can be
<I>modal</I>. When a modal Dialog is displayed, input to other
windows in the Applet is blocked until the Dialog is disposed.
This feature points to the general purpose of Dialogs, which is
to give the user a warning or a decision to be made before the
program can continue. Although non-modal, or <I>modeless,</I>
Dialogs are supported, most Dialogs are modal.
<P>
There are two constructors for the Dialog class. Both take a Frame
object as a parameter; they also take a boolean flag, which indicates
whether the dialog should be modal. If the flag is set to true,
the dialog is modal. The constructors differ only in a parameter
that specifies whether the dialog should have a title caption.
It is this constructor that is used in the example that follows.
<P>
Figure 4.2 shows a variation of the previous applet, except that
a Dialog is used to change the cursor state. Listing 4.3 shows
the code for the Dialog class, called ChangeCursorDialog. The
Frame class (still called FrameMenuCursor from the previous example)
declares the dialog and instantiates it as follows:
<P>
<A HREF="f4-2.gif" ><B>Figure 4.2 </B>: <I>Using Dialog to change the state of the cursor</I></A>
<BLOCKQUOTE>
<TT>ChangeCursorDialog dlg;<BR>
dlg = new ChangeCursorDialog(this,true,&quot;Change the cursor&quot;);</TT>
</BLOCKQUOTE>
<P>
The menu for this application is different from the previous example.
The frame constructs the menu as follows:
<BLOCKQUOTE>
<TT>// First create the menu bar<BR>
MenuBar mbar = new MenuBar();<BR>
setMenuBar(mbar); // Attach to the frame...<BR>
<BR>
// Add the File submenu...<BR>
Menu m = new Menu(&quot;File&quot;);<BR>
mbar.add(m);&nbsp;&nbsp;// Add to menu bar<BR>
// Add Dialog to the submenu...<BR>
m.add(new MenuItem(&quot;Cursor Dialog&quot;));<BR>
// Add a separator<BR>
m.addSeparator();<BR>
// Add Quit to the submenu...<BR>
m.add(new MenuItem(&quot;Quit&quot;));<BR>
</TT>Note that a separator is added to divide the two menu
items.<BR>
When the Cursor Dialog menu item is chosen, the dialog box is
presented with the following code:<BR>
<TT>if (menuName.equals(&quot;Cursor Dialog&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dlg.show(); // Make the dialog visible...
<BR>
</TT>Listing 4.3. Code for a Dialog to change the cursor
state.<BR>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// Dialog that presents a grid of buttons<BR>
// for choosing the Frame cursor. A Cancel<BR>
// button exits the dialog...<BR>
class ChangeCursorDialog extends Dialog {<BR>
FrameMenuCursor fr;<BR>
// Create the dialog and store the title string...<BR>
public ChangeCursorDialog(Frame parent,boolean modal,String title)
{<BR>
 // Create dialog with title<BR>
 super(parent,title,modal);<BR>
 fr = (FrameMenuCursor)parent;<BR>
 // The layout is Grid layout...<BR>
 setLayout(new GridLayout(3,2));<BR>
 // Add the button options<BR>
 add(new Button(&quot;Default&quot;));<BR>
 add(new Button(&quot;Wait&quot;));<BR>
 add(new Button(&quot;Hand&quot;));<BR>
 add(new Button(&quot;Move&quot;));<BR>
 add(new Button(&quot;Text&quot;));<BR>
 add(new Button(&quot;Cancel&quot;));<BR>
 // Pack and size for display...<BR>
 pack();<BR>
 resize(300,200);<BR>
}<BR>
// Look for button selections to<BR>
// change the cursor...<BR>
public boolean action(Event e,Object arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // If button was selected then exit dialog..
<BR>
if (e.target instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// And possibly
change the cursor...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg.equals(&quot;Default&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.setCursor(Frame.DEFAULT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg.equals(&quot;Wait&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.setCursor(Frame.WAIT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg.equals(&quot;Hand&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.setCursor(Frame.HAND_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg.equals(&quot;Move&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.setCursor(Frame.MOVE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg.equals(&quot;Text&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr.setCursor(Frame.TEXT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Another AWT class called FileDialog is a subclass of Dialog. It
is used for creating stock Load and Save dialog boxes. The upcoming
tutorial has examples of the FileDialog class.
<H3><A NAME="Colors">Colors</A></H3>
<P>
The Color class is used to set an object's colors. This class
represents a color as a combination of RGB values. RGB is a 24-bit
representation of a color composed of red, green, and blue byte
values. This 24-bit representation is virtual since many platforms
do not support 24-bit color. In these situations, Java maps the
color to the appropriate value; this will usually be an index
into a palette.
<P>
The Color class defines a set of stock color values, implemented
as static variables. For example, Color.red is available with
an RGB value of 255,0,0. Other colors supported are white, black,
gray, green, blue, yellow, magenta, and cyan. Various Color constructors
can also be used to define other colors. For example, the statement
<BLOCKQUOTE>
<TT>Color col = new Color(0,0,120);</TT>
</BLOCKQUOTE>
<P>
produces a dark blue color. Other methods, such as <TT>darker()</TT>
and <TT>brighter()</TT>, can also
be used to create a new Color object from an existing one.
<P>
There are generally two approaches to tying a color to an object.
The first approach is to use methods provided by the Component
class. The <TT>setBackground()</TT>
and <TT>setForeground()</TT> methods
are used to set the colors of an object in the two respective
positions. For example, the following code creates a Panel object
and sets its background to white:
<BLOCKQUOTE>
<TT>Panel p = new Panel();<BR>
p.setBackground(Color.white);</TT>
</BLOCKQUOTE>
<P>
You can use the respective methods prefixed by &quot;get&quot;
to return the background and foreground colors of a component.
<P>
The other approach to setting a color occurs in the <TT>paint()</TT>
method. Recall that a Graphics object is passed to this method.
The <TT>setColor()</TT> method can
then be used to set the color of the next items to be painted.
For example, the following code paints a blue framed rectangle:
<BLOCKQUOTE>
<TT>public synchronized void paint (Graphics
g)<BR>
g.setColor(Color.blue);<BR>
g.drawRect(0,0,100,40);</TT>
</BLOCKQUOTE>
<P>
The tutorial in this section gives more examples of using color.
A dialog box presents a choice of colors through the use of colored
components. The spreadsheet is modified to use these chosen colors
when it is painted.
<H3><A NAME="Fonts">Fonts</A></H3>
<P>
Fonts are a critical aspect of graphics-based programming. Not
only are they important for making an application attractive,
they are a seminal part of programming a visual interface. Often
how a component is sized or placed turns on what font is being
used. The spreadsheet tutorial in this chapter, for example, uses
the current dimensions of the font to determine how the spreadsheet
cell should be sized and located. Therefore, there are two aspects
of font programming: tying fonts to display components and getting
font information to program how graphical objects are positioned.
The former aspect generally falls in the domain of the Font class;
the latter is tied to the FontMetrics class, although Font is
involved here also.
<P>
To construct a Font object, you need a font name, style, and size.
The font name represents a family of fonts, such as Courier. The
font families available to an applet depend on where the program
is running, and so decisions about what font is to be used should
be made dynamically. The java.awt.Toolkit has a method called
<TT>getFontList()</TT> that returns
a string array of font names on the host system. An example of
how this method is used is found in the next section and in the
font dialog in the tutorial. The family of a Font can be retrieved
through the <TT>getFamily()</TT> method.
<P>
The size of a font is its point size, such as 8 for a small font
and 72 for a large one. There are three styles defined as constants
in the Font class: <TT>PLAIN</TT>,
<TT>BOLD</TT>, or <TT>ITALIC</TT>.
The latter two can be combined to produce a font with both features.
For example, you could create a Helvetica font that has a 36-point
size and is both bold and italicized as follows:
<BLOCKQUOTE>
<TT>Font f = new Font(&quot;Helvetica&quot;,
Font.BOLD + Font.ITALIC,36);</TT>
</BLOCKQUOTE>
<P>
Fonts can be tied to a component through the <TT>setFont()</TT>
method. To create the previous font and tie it to a label, the
following code could be invoked:
<BLOCKQUOTE>
<TT>Label l = new Label(&quot;My Label&quot;);
<BR>
l.setFont(new Font(&quot;Helvetica&quot;, Font.BOLD + Font.ITALIC,36));</TT>
</BLOCKQUOTE>
<P>
A reference to a component's Font can be retrieved through <TT>getFont()</TT>.
<P>
Another way to use fonts is in the <TT>paint()</TT>
method. The Graphics class used in <TT>paint()</TT>
can have the current font set through the <TT>setFont()</TT>
method. For example, Listing 4.4 provides the code for an applet
that paints a series of Strings containing a row number. Figure
4.3 shows the output. When the <TT>paint()</TT>
method begins, a new font is created and set to the graphics object;
this font is now the current font used for the following graphics
calls. The <TT>drawString()</TT> method
is then called repeatedly with the y coordinate being dynamically
calculated.
<P>
<A HREF="f4-3.gif" ><B>Figure 4.3 </B>: <I>A Font applet using hardcoded coordinates</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 4.4. Code for Font applet using hard-coded coordinates.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// This aspect throws a string into the applet<BR>
// display separated by a height difference of the<BR>
// current font<BR>
public class FontTest extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font f = new Font(&quot;Helvetica&quot;,Font.BOLD
+ Font.PLAIN,16);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(f);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 5;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 40 +
(i * 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Row
&quot; + i + &quot; of text output.&quot;,10,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
There are a couple of things about this applet that are not quite
optimal. First of all, it isn't good to create a new Font in the
paint routine. Painting occurs frequently and font creation is
an expensive operation. It is faster and more efficient to create
the font only once, as in the <TT>init()</TT>
method.
<P>
The other thing that might be avoided is using hard-coded values,
which is notorious for displays that do not appear uniformly across
different platforms. (After all, that is why AWT has layouts!)
Although this applet might look decent across platforms, it gives
an excuse for showing a better way of using coordinates. This
is where the FontMetrics class comes in.
<P>
FontMetrics is used to get a variety of information about a Font
object. Such information includes the font's dimensions, how big
a String or character using that font would be, and so forth.
Table 4.1 lists some of the methods of the FontMetrics class.
<BR>
<P>
<CENTER><B>Table 4.1. FontMetrics methods.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=129><I>Method</I></TD><TD WIDTH=461><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>charWidth</TT>
</TD><TD WIDTH=461>Returns width of character using this font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>GetAscent</TT>
</TD><TD WIDTH=461>Returns the ascent of the font (distance between the baseline and top of the character).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>GetDescent</TT>
</TD><TD WIDTH=461>Returns descent of font (distance from the baseline of the font and its bottom).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>getHeight</TT>
</TD><TD WIDTH=461>Returns total height of font (ascent + descent + leading).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>getLeading</TT>
</TD><TD WIDTH=461>Returns the line spacing of the font.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=129><TT>stringWidth</TT>
</TD><TD WIDTH=461>Returns the number of pixels a String using this font will take.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can retrieve a FontMetrics object for a specific font in a
couple of ways. First of all, the FontMetrics object can be created
from scratch by using its constructor; it takes the Font in question
as its only parameter. The reference to the FontMetrics can also
be taken directly from the Graphics class by using the <TT>getFontMetrics()</TT>
method. The first technique is used when the program is not painting,
but that is when the latter technique is applied. Finally, it
could retrieve from the default toolkit with a method also named
<TT>getFontMetrics()</TT>.The next
section explains how the Toolkit class works.
<P>
Figure 4.4 shows an improved version of the Font applet through
the use of FontMetrics; Listing 4.5 gives the new code. In this
version of the applet, each of the String displays are equally
incremented by the height of the font. The code calculates the
height increment from the <TT>getHeight()</TT>
method of the FontMetrics reference of the Graphics object. The
new code is also more efficient than the previous example since
it creates the font only once, at initialization.
<P>
<A HREF="f4-4.gif" ><B>Figure 4.4 </B>: <I>A Font applet using FontMetrics.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 4.5. Code for a Font applet that uses FontMetrics.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// This aspect throws a string into the applet<BR>
// display separated by a height difference of the<BR>
// current font<BR>
public class FontTest extends Applet {<BR>
&nbsp;&nbsp;&nbsp;Font f;<BR>
&nbsp;&nbsp;&nbsp;// Create the font...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; f&nbsp;&nbsp;= new Font(&quot;Helvetica&quot;,Font.BOLD
+ Font.PLAIN,16);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Paint using TextMetrics to set the height
in even<BR>
&nbsp;&nbsp;&nbsp;// increments...<BR>
&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the font<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(f);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Always increment by twice
the height of the font...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int heightIncrement =&nbsp;&nbsp;2
* g.getFontMetrics().getHeight();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 5;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += heightIncrement;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Row
&quot; + i + &quot; of text output.&quot;,10,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The tutorial that follows will have even more examples of fonts,
including a dialog box that can be used to select a font family,
size, and style.
<H3><A NAME="TheToolkitClass">The Toolkit Class</A></H3>
<P>
The AWT Toolkit class provides the link between the AWT system-independent
interface and the underlying platform-based toolkit (such as Windows).
The class is abstract, so the <TT>getDefaultToolkit()</TT>
method must be called to get a reference to the actual Toolkit
object. Once this is done, all kinds of information about the
underlying environment can be revealed. By working with the Toolkit,
this underlying information can be used in a way that does not
compromise portability.
<P>
For example, the following code gets a list of all the fonts available
on the native platform and prints them out:
<BLOCKQUOTE>
<TT>String fontList[] = Toolkit.getDefaultToolkit().getFontList();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; fontList.length;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(fontList[i]);</TT>
</BLOCKQUOTE>
<P>
If the fonts used in an applet are derived from this list, versus
using hard-coded font names, the portability of an applet will
be improved. The <TT>getFontMetrics()</TT>
method returns the screen metrics of a font.
<P>
Another useful Toolkit method is <TT>getScreenSize()</TT>.
This returns the full-screen dimensions of the native platform.
If you want to create a window that fills up the screen, these
dimensions will be useful. The <TT>getScreenResolution()</TT>
method returns the dots-per-inch resolution of the screen.
<P>
The Toolkit class also provides a variety of methods for using
images, including a method for synchronizing the screen's graphics
state. This <TT>sync()</TT> method
can be used in animation to avoid flicker.
<H2><A NAME="IOandStreams"><FONT SIZE=5 COLOR=#FF0000>I/O and
Streams</FONT></A></H2>
<P>
<I>Streams</I> are a traditional way of representing a connection
between two objects. The types of streams that programmers are
most familiar with are ones between I/O devices (such as files)
and processes or streams between two memory structures. Each endpoint
of a stream connection can have one or two channels: an input
channel and an output channel. When a process is reading from
a file, it reads from a stream that receives data from the file
device's output channel. From the point of view of the process,
it is managing an <I>input stream</I>. From the viewpoint of the
file device, it is sending an <I>output stream</I>. Figure 4.5
illustrates the relationship.
<P>
<A HREF="f4-5.gif" ><B>Figure 4.5 : </B><I>Stream relationships when a process reads from a file.</I></A>
<P>
The JDK package for managing input and output interactions, called
java.io, has the stream concept at its foundation. It is structured
on the notion of input and output streams just discussed. These
stream classes permeate the Java programming environment. Their
use ranges from file I/O to network programming to the widely
used <TT>System.out.println()</TT>
method. There are few things that will increase the capabilities
of a Java programmer more than a full understanding of Java streams.
<H3><A NAME="StructureofthejavaioPackage">Structure of the java.io
Package</A></H3>
<P>
As just stated, the java.io package is based heavily on the notion
of input and output streams. This is made clear by the diagram
of significant java.io classes, shown in Figure 4.6. The most
important of these are, not surprisingly, the InputStream and
OutputStream classes, which are generally used to read and write
from a stream, respectively. They form the basis of an elaborate
network of stream classes that make it easy to build high-level
streams, such as those that work on newline delimited ASCII data,
to low-level streams, such as one that manages data on a byte-by-byte
level. How this works will be explored in the upcoming discussion
of the two foundation classes and their subclasses.
<P>
<A HREF="f4-6.gif" ><B>Figure 4.6 :</B><I> Significant classes of the java to hierarchy.</I></A>
<P>
Before engaging in a discussion of the input and output stream
classes, it's useful to look at some of the other aspects of Java
I/O programming. The File class can be used to get information
about a file or directory on the host file system. For example,
the following code checks to see whether a file exists in the
current directory and lists what is in the grandparent directory.
<BLOCKQUOTE>
<TT>myFile = new File(&quot;File.txt&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The
file &quot; + myFile.getName()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+
&quot; existence is &quot; + myFile.exists());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File myDirectory = new File(&quot;..\\..&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s[] = myDirectory.list();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Directory
contents: &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; s.length;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s[i]);</TT>
</BLOCKQUOTE>
<P>
As you might have observed in the constructor for the directory
object, the naming conventions are based on the host file system.
Consequently, hard coding such conventions can result in nonportable
code. Fortunately, the class provides some constants that can
hide the platform-specific conventions. For example, the following
code makes the directory constructor portable:
<BLOCKQUOTE>
<TT>File myDirectory = new File(&quot;..&quot;
+ File.separator + &quot;..&quot;);</TT>
</BLOCKQUOTE>
<P>
The File class also offers a variety of other file operations.
This includes the ability to delete or rename a file, create a
new directory, and inspect a file's attributes. Note, however,
that these operations are subject to the native environment's
security constraints, discussed in the following section.
<H2><A NAME="IOandSecurity"><FONT SIZE=5 COLOR=#FF0000>I/O and
Security</FONT></A></H2>
<P>
The Java language and its native environment (such as a browser)
give you a sophisticated system of security layers. At the top
of this security hierarchy is protection for the local file system.
After all, the most prevalent methods for a virus to inflict pain
on its victim is to destroy his or her file system. Consequently,
protection of the file system where the applet is running is paramount.
<P>
A Java environment enforces a security policy through its security
manager. This is implemented as an object through the SecurityManager
class and is created once and only once by a browser at startup.
Once established, a SecurityManager cannot be changed or replaced.
The reasons for this are obvious. If a rogue applet can modify
the SecurityManager object, then it can simply remove all access
restrictions and wield unlimited power over your hard disk. However,
it is possible to get a reference to the SecurityManager through
the System object's <TT>getSecurityManager()</TT>
method. Once obtained, methods can be applied on the object to
see what security constraints are currently being applied.
<P>
The strictness of a security policy depends on the runtime Java
environment. Netscape Navigator, for example, cannot perform any
file operations. The simple File class example in the previous
section causes a security violation. This occurs when the File
<TT>exists()</TT> method is invoked,
which is the first file operation in the code (the File constructor
simply associates the String name with the object).
<P>
Sun's HotJava browser allows some file operations on the client
running an applet. Note that where the applet is loaded from is
important. The client is the site running the applet; the server
is where the applet was loaded from. The security that concerns
Java the most is that of the client site. In Hot Java, the operations
allowed on the client are based on the concept of <I>access control
lists</I>. By default, any file not covered in the list cannot
be accessed in any fashion, including the simple File <TT>exists()</TT>
operation. The access control list can be found in the properties
file of the .hotjava directory located under the parent.
<P>
File security is even weaker for the appletviewer program that
programmers can use to test an applet. In this environment, most
file operations are allowed for applets loaded from the client.
Some file operations performed by applets loaded from a server
over the network are also permitted. Standalone Java applications
have no file security. If a sophisticated Java application is
being developed, such as over an internal corporate network, it
probably would be best to create a subclass of SecurityManager
to set up a security policy appropriate for that environment.
<P>
When a file operation violates a security policy, a SecurityException
object is thrown. This can be caught by the program to prevent
abnormal termination.
<H3><A NAME="IOExceptions">I/O Exceptions</A></H3>
<P>
Besides thrown SecurityException objects, Java I/O programs need
to be concerned with handling other exceptions. In particular,
they need to catch IOException objects that are thrown. The IOException
class embraces the category of errors related to input/output
operations. Many of the methods in the java.io package throw IOException
objects that must be caught. The typical structure of code that
performs I/O operations is, therefore, as follows:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;// IO operations<BR>
}<BR>
catch (IOException e) {<BR>
&nbsp;&nbsp;// Handle the error<BR>
}</TT>
</BLOCKQUOTE>
<P>
Two subclasses of IOException are noteworthy. A FileNotFoundException
object is thrown when there is an attempt to open a file that
doesn't exist. For example, the constructor for the FileInputStream
class tries to open the file specified in its parameter. If it
cannot do so, an object of class FileNotFoundException is thrown.
<P>
Another notable subclass of IOException is EOFException, which
typically occurs in read operations when an end of file has been
reached. This indicates that there are no more bytes to be read.
<H3><A NAME="InputStreamClasses">InputStream Classes</A></H3>
<P>
Figure 4.7 illustrates the class hierarchy that descends from
the InputStream class. InputStream is an abstract class that defines
the basic operations that must be implemented by its subclasses.
The most noteworthy of these is the <TT>read()</TT>
method. This is used to read in bytes one at a time or into a
byte array. The System.in variable, which represents that standard
input stream, is based on the InputStream class and is now used
to illustrate the <TT>read()</TT>
method:
<P>
<A HREF="f4-7.gif" ><B>Figure 4.7 :</B><I> Input stream classes</I></A>
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = System.in.read();
<BR>
}<BR>
catch (IOException e) {<BR>
&nbsp;&nbsp;// Handle any exception&#133;<BR>
}</TT>
</BLOCKQUOTE>
<P>
This example reads in a byte that is, confusingly, converted to
an integer by the <TT>read()</TT>
method. The method returns <TT>-1</TT>
if there is no input to be read. For many subclasses of InputStream,
an EOFException object is thrown in these circumstances.
<P>
Table 4.2 lists other notable methods of the abstract InputStream
class.<BR>
<P>
<CENTER><B>Table 4.2. Notable InputStream methods.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=124><I>Method</I></TD><TD WIDTH=409><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>available</TT>
</TD><TD WIDTH=409>A non-blocking way to find out number of bytes available to read.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>Close</TT></TD>
<TD WIDTH=409>Closes the input stream.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>mark</TT></TD>
<TD WIDTH=409>Marks the current stream position.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>read</TT></TD>
<TD WIDTH=409>Reads a byte or array of bytes.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>reset</TT></TD>
<TD WIDTH=409>Resets stream to last marked position.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>skip</TT></TD>
<TD WIDTH=409>Skips over specified number of input bytes.</TD>
</TR>
</TABLE></CENTER>
<P>
<H4>FilterInputStream classes</H4>
<P>
The FilterInputStream class is at the top of a branch of the InputStream
hierarchy that can be used to implement some very powerful operations.
In particular, this class is used to chain a series of FilterInputStream
classes so that one stream can process data before passing it
&quot;up&quot; to the next stream. This chaining technique is
excellent to use when encapsulating classes that interact with
streams at a lower level (such as bytes) into streams that read
in data at a higher level, such as Strings. The following example
illustrates how this works.
<P>
As seen in the previous overview of the InputStream class, the
System.in object reads data in a byte at a time. This will prove
to be cumbersome for many standard input operations that typically
want to work on String objects. Fortunately, FilterInputStream
classes make it easy to abstract this byte-level functionality
into a higher and more usable interface. The code in Listing 4.6
takes the System.in object and creates a DataInputStream object
that can be used to read in a String of text delimited by a newline
or EOF. This is then sent to the System.out object, which prints
the string to the standard output stream.
<HR>
<BLOCKQUOTE>
<B>Listing 4.6. Chaining Input Stream classes.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
the data input stream...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
dis =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
DataInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedInputStream(System.in));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read
in a line of text...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s
= dis.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send
it to standard output...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle any exceptions caused
by the process...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Just
print out the error...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The first line inside the <TT>try</TT>
clause is full of material; the innermost part of the clause introduces
the BufferedInputStream class:
<BLOCKQUOTE>
<TT>new BufferedInputStream(System.in)</TT>
</BLOCKQUOTE>
<P>
This subclass of FilterInputStream simply allows the reading in
of data more efficiently. Reading a file so that every byte request
requires a new input read is very slow. The BufferedInputStream
class reads data into a buffer in a series of large chunks. This
prevents each request for a byte of data resulting in a read from
the underlying input stream, such as a file or network read. If
the BufferedInputStream already has the data in the buffer, it
can return the data directly from its memory cache. This is also
useful for operations that require movement back and forth in
a stream, such as a &quot;push back&quot; of an unneeded byte.
Since this class will improve the efficiency of input stream operations,
it should be used liberally.
<P>
Once the BufferedInputStream object is created, it is used as
the constructor for a DataInputStream object:
<BLOCKQUOTE>
<TT>DataInputStream dis =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new DataInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedInputStream(System.in));</TT>
</BLOCKQUOTE>
<P>
This code means that the DataInputStream object's request for
input is actually made to a BufferedInputStream object. This object
in turn makes its requests for input to the System.in object (which
is based on InputStream) when it needs more data.
<P>
The code can now use DataInputStream methods, such as <TT>readLine()</TT>,
to hide the underlying request of data at a byte-by-byte level.
The DataInputStream methods return the data formatted in a data
type that the user needs. In this case, <TT>readLine()</TT>
reads in a String of text delimited by a new Line (a carriage
return/line feed, or EOF). The delimiter is not included in the
stream.
<P>
The DataInputStream class supports over a dozen data type operations,
as listed in Table 4.3. These include most of the basic data types
supported from Java, ranging from a single byte to an integer
to a floating point number to a full-text String in Unicode format.
The DataInputStream class is an implementation of the DataInput
stream interface, which defines the data type methods that need
to be supported.<BR>
<P>
<CENTER><B>Table 4.3. Data-type reads supported by DataInputStream.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=186><I>Method</I></TD><TD WIDTH=306><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>read</TT></TD>
<TD WIDTH=306>Reads data into byte array.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readBoolean</TT>
</TD><TD WIDTH=306>Reads a boolean.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readByte</TT>
</TD><TD WIDTH=306>Reads an 8-bit byte.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readChar</TT>
</TD><TD WIDTH=306>Reads a 16-bit char.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readDouble</TT>
</TD><TD WIDTH=306>Reads a 64-bit double number.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readFloat</TT>
</TD><TD WIDTH=306>Reads a 32-bit floating point number.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readInt</TT>
</TD><TD WIDTH=306>Reads a 32-bit integer.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readLine</TT>
</TD><TD WIDTH=306>Reads String terminated by newline or EOF.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readLong</TT>
</TD><TD WIDTH=306>Reads a 64-bit long.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readShort</TT>
</TD><TD WIDTH=306>Reads a 16-bit short.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readUTF</TT>
</TD><TD WIDTH=306>Reads a Unicode formatted String.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readUnsignedByte</TT>
</TD><TD WIDTH=306>Reads an unsigned byte.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>readUnsignedShort</TT>
</TD><TD WIDTH=306>Reads an unsigned 16-bit short.</TD></TR>
</TABLE></CENTER>
<P>
<P>
From the powerful chaining operation supported by FilterInputStream,
it's easy to imagine interesting new possible classes. For example,
a WordProcessStream could be written to read paragraphs and images
into a word processing application.
<P>
Two other FilterInputStream classes are worth mentioning. The
LineNumberInputStream class associates the data streams with line
numbers. This means that the class supports such operations as
<TT>setLineNumber()</TT> and <TT>getLineNumber()</TT>.
The PushBackInputStream class is used for the kind of operations
that parsers typically perform. Parsers need methods such as <TT>unread()</TT>,
which pushes a character back into a stream. This kind of operation
is needed when a token has been identified by the parser.
<H4>Other InputStream classes</H4>
<P>
Although the FilterInputStream classes are the most powerful part
of the InputStream hierarchy, other classes are also useful. If
applets read from a file, an instance of the FileInputStream class
will probably be used. It includes the same operations as its
superclass, InputStream. Therefore, it can be used to pass data
to FilterInputStream classes, as in the previous section's example.
Listing 4.7 shows how to use chaining to read an ASCII file and
send its contents to standard output. Instead of creating the
FilterInputStream classes from the System.in InputStream object,
it is built from a FileInputStream object tied to the filename
provided in the method parameter; if the file cannot be opened
because it does not, an IOException object will be thrown.
<HR>
<BLOCKQUOTE>
<B>Listing 4.7. Reading a file to standard output.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>void readFileToStandardOut(String filename)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;*****
BEGIN &quot; + filename + &quot; *****&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Open
the file...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
dis = new DataInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
FileInputStream(filename)) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read
lines until EOF is reached...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((s
= dis.readLine()) != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Close
the file when done...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dis.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle any exceptions caused
by the process...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Just
print out the error...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;*****
END &quot; + filename + &quot; *****&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
As this example further illustrates, the powerful technique of
stream chaining makes it easy to abstract away from the low-level
implementation of reading from a file. In fact, except for the
innermost part of the constructor, with this code it really doesn't
matter if you're working on a file, the standard input stream,
or even from a network!
<P>
However, if it's necessary to work with streams at the level of
bytes, the ByteArrayInputStream class could be used. This takes
a large array of bytes and uses it as the basis for input stream
requests. Therefore, this is the constructor for the class:
<BLOCKQUOTE>
<TT>ByteArrayInputStream bis = new ByteArrayInputStream(byteArray)</TT>
</BLOCKQUOTE>
<P>
The <TT>reset()</TT> method sets the
current position back to the beginning of the stream buffer. The
StringBufferInputStream class functions in a manner similar to
ByteArrayInputStream, except it works on a StringBuffer. Like
ByteArrayInputStream, however, the <TT>read()</TT>
methods return a single byte or an array of bytes.
<P>
The PipedInputStream class works with the PipedOutputStream class
to send a stream of data from one channel to another. This is
well suited for thread processing, in which one thread is producing
data (the output) to another thread that's consuming it (the input).
Piped streams is a classic technique of interprocess communication.
<A HREF="ch8.htm" >Chapter 8</A>, &quot;Adding Threads to Applets,&quot;
will provide a concrete example of piped streams.
<P>
Finally, the SequenceInputStream class can be used to take a series
of InputStreams and treat them as if they were one stream. This
could be useful for operations such as concatenating files.
<H3><A NAME="OutputStreamClasses">OutputStream Classes</A></H3>
<P>
The OutputStream class is an abstract class that marks the top
of the hierarchy of classes used for streamed output. Its major
operations are represented by <TT>write()</TT>
methods, which can be used to write an integer, a byte, or an
array of bytes to a stream. The other methods of OutputStream
are the <TT>close()</TT> method, which
is used to close a stream, and the <TT>flush()</TT>
method, which writes the contents of a buffered cache to the stream-this
applies only to derivatives of OutputStream that implement buffering.
<P>
Figure 4.8 lists the output classes that descend from OutputStream.
In many cases, the classes mirror the input classes shown in Figure
4.7. The most noteworthy of these, not surprisingly, is the FilterOutputStream
class, which, like its FilterInputStream counterpart, is used
to chain streams together. This class will be used as the starting
point for a tour through the OutputStream classes.
<P>
<A HREF="f4-8.gif" ><B>Figure 4.8 : </B><I>Output Stream classes</I></A>
<H3><A NAME="FilterOutputStreamClassesandFileOutpu">FilterOutputStream
Classes and FileOutputStream</A></H3>
<P>
The FilterOutputStream class is used to chain streams together
so that one stream can process data before passing it to the next
stream in the chain. This is useful for cases in which the lowest
level stream reads in data at a primitive level (such as bytes)
and passes up to the interface layer, which manages streams in
terms of Strings and other data types. This is well suited for
operations such as writing to a file, as the following example
illustrates.
<P>
Listing 4.8 shows a method that takes a string array and writes
it to a file, which is formatted for ASCII text. As in the InputStream
example of Listing 4.7, the key part of this method is the constructor.
Its innermost statement consists of a constructor for a stream
that writes to a file:
<BLOCKQUOTE>
<TT>new FileOutputStream(filename)</TT>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 4.8. Writing a string array to an ASCII file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>void writeStringsToFile(String s[],String
filename) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
the output stream to a file...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
out = new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
FileOutputStream(filename)) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write
the strings out...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int
i = 0; i &lt; s.length; ++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.writeBytes(s[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Flush
and close...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.flush();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle any exceptions caused
by the process...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Just
print out the error...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The FileOutputStream opens a file with the designated filename.
If the file previously exists, its contents will be lost. The
FileOutputStream class has an alternate constructor that takes
a File object. The File class was described in the section &quot;Structure
of the java.io Package.&quot; The created file can then be written
to with the <TT>write()</TT> methods,
which can take a single integer or a byte array.
<P>
In the example, the FileOutputStream is fed as input into the
BufferedOutputStream. The use of this class is very useful for
file write operations since it prevents disk writes from occurring
every time the buffer is given some data. It only writes when
the buffer's cache is full or when the <TT>flush()</TT>
method is called.
<P>
Finally, the newly created BufferedOutputStream object becomes
the source for the DataOutputStream object. Like the DataInputStream
counterpart, the DataOutputStream works with general Java data
types, such as bytes, integers, doubles, and Strings. Table 4.4
summarizes the write operations supported by DataOutputStream.
These are fairly straightforward, except for the three methods
used for writing out Strings. Recall that Java treats characters
not as 8-bit ASCII bytes, but as 16-bit Unicode characters. This
is important for creating international software. However, programmers
often need to read and write data in its native form. The <TT>writeBytes()</TT>
method takes a String and writes out each character in the 8-bit
ASCII format. This is the method used in the example. The <TT>writeChars()</TT>
method, on the other hand, writes data out in 16-bit Unicode characters.
A file created this way will not look or behave like an ASCII
file, so this method wasn't used in the example. The <TT>writeUTF()</TT>
method writes a String out in a special Unicode format.<BR>
<P>
<CENTER><B>Table 4.4. Data-type writes supported by DataOutputStream.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=247><I>Method</I></TD><TD WIDTH=343><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>write(byte)</TT>
</TD><TD WIDTH=343>Writes a byte.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>Write(byte [],int, int)</TT>
</TD><TD WIDTH=343>Writes a subarray of bytes.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteBoolean(boolean)</TT>
</TD><TD WIDTH=343>Writes a boolean.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteByte(int)</TT>
</TD><TD WIDTH=343>Writes an 8-bit byte.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteBytes(String)</TT>
</TD><TD WIDTH=343>Writes a String out as 8-bit bytes. Use for writing out ASCII text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteChar(int)</TT>
</TD><TD WIDTH=343>Writes a 16-bit char.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteChars(String)</TT>
</TD><TD WIDTH=343>Writes a String out as 16-bit Unicode characters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteDouble(double)</TT>
</TD><TD WIDTH=343>Writes a 64-bit double number.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteFloat(float)</TT>
</TD><TD WIDTH=343>Writes a 32-bit floating point number.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteInt(int)</TT>
</TD><TD WIDTH=343>Writes a 32-bit integer.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteLong(long)</TT>
</TD><TD WIDTH=343>Writes a 64-bit long.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteShort(int)</TT>
</TD><TD WIDTH=343>Writes a 16-bit short.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=247><TT>WriteUTF(String)</TT>
</TD><TD WIDTH=343>Reads a Unicode formatted String.</TD></TR>
</TABLE></CENTER>
<P>
<P>
The DataOutputStream class implements the DataOutput class. This
defines the data-type write methods that need to be supported
by the classes that implement data output streams.
<P>
At the end of the example, there are calls to <TT>flush()</TT>
and <TT>close()</TT>. The <TT>flush()</TT>
method forces the BufferedOutputStream object to send its cached
contents to the FileOutputStream. This could also be called inside
the <TT>write</TT> loop at appropriate
intervals (such as when a prespecified number of bytes or Strings
have been written). The <TT>close()</TT>
method call closes in the FileOutputStream stream, and the file
is now complete.
<P>
The other FilterOutputStream class is PrintStream. This is the
class used to implement the standard output and error objects,
System.out and System.err. Of course, its most noteworthy method
is <TT>println()</TT>. This is actually
an overloaded method that takes any of a variety of data types
and writes it to the PrintStream (usually standard output) followed
by a new line. The <TT>println()</TT>
method is most widely used with String objects. This method is
also noteworthy in that the stream is flushed every time it is
called. The <TT>print()</TT> method
functions similarly but with no newline appended. A <TT>println()</TT>
or <TT>flush()</TT> method will cause
output from <TT>print()</TT> to be
written to the stream. Finally, a byte-based <TT>write()</TT>
is also supported by PrintStream.
<H3><A NAME="OtherOutputClasses">Other Output Classes</A></H3>
<P>
The PipedOutputStream class works with the PipedInputStream class
to send a stream of data from one channel to another. Pipes are
a classic technique of interprocess communication. You will find
a concrete example of piped streams in <A HREF="ch8.htm" >Chapter 8.</A>
<P>
The ByteArrayOutputStream is used for working with arrays of bytes.
Its most interesting feature is that its internal array will grow
as it receives data.
<H3><A NAME="OtherIOClasses">Other I/O Classes</A></H3>
<P>
Two other I/O classes need to be mentioned. The RandomAccessFile
class implements both the DataInput and DataOutput interfaces.
Consequently, it is the only stream class that supports both the
read and write operations. This is good for more traditional programming
in which files are read and updated interactively. The RandomAccessFile
also supports file-positioning operations, such as <TT>seek()</TT>.
<P>
The StreamTokenizer stream can be used for tokenizing a stream.
This is useful for the lexical analysis operations of a parser.
<H2><A NAME="Tutorial"><FONT SIZE=5 COLOR=#FF0000>Tutorial</FONT></A>
</H2>
<P>
The spreadsheet applet from the previous chapter is enhanced in
this tutorial to support dialog boxes and to introduce file storage
to the spreadsheet data. Some new classes were written to create
the dialog boxes, and classes from the previous section were modified
to support new functioning.
<P>
For ease of reading, Figure 4.9 shows the spreadsheet applet again
as it appears in a browser.
<P>
<A HREF="f4-9.gif" ><B>Figure 4.9 : </B><I>The spreadsheet applet</I></A><I>.</I>
<H3><A NAME="ClassOrganization">Class Organization</A></H3>
<P>
Table 4.5 enumerates the classes used in this chapter's version
of the spreadsheet applet. Since many of these classes were created
in the previous section, the new classes are delimited by having
their name in bold. The classes that were modified have their
names italicized.<BR>
<P>
<CENTER><B>Table 4.5. Spreadsheet classes.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=190><I>Class</I></TD><TD WIDTH=400><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>Cell</TD><TD WIDTH=400>Contains a String and evaluated value corresponding to a single cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>CellContainer</TD><TD WIDTH=400>Contains a matrix of Cells. The String in each Cell is evaluated according to whether it is a formula, a literal numeric value, or an empty cell. Can write or read its contents from a file.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>FormulaParser</TD><TD WIDTH=400>Used to parse out the individual string fragments that make up a single formula. Converts literal strings to their numeric values.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>FormulaParserException</TD><TD WIDTH=400>An Exception that is thrown if a formula is poorly constructed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>ArgValue</TD><TD WIDTH=400>A FormulaParser helper class used to store information about an argument in a formula.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>ChooseColorDialog</B></TD><TD WIDTH=400>Dialog for choosing the color of a spreadsheet element.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>ColorDisplay</B></TD><TD WIDTH=400>A canvas class that ChooseColorDialog uses to display how a spreadsheet cell would appear if certain colors were picked.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>ColoredCheckbox</B></TD><TD WIDTH=400>Draws a checkbox with its color set to a different color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>ColoredCheckboxGroup</B></TD><TD WIDTH=400>Creates a group of colored checkboxes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>ChooseFontDialog</B></TD><TD WIDTH=400>Dialog for choosing a font for the spreadsheet.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><B>FontDisplay</B></TD><TD WIDTH=400>A canvas class that ChooseFontDialog uses to display how a font looks.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>SpreadsheetCell</TD><TD WIDTH=400>Provides for the visual presentation of a single Cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>SpreadsheetContainer</TD><TD WIDTH=400>Manages the visual presentation of a matrix of SpreadsheetCells. Provides an interface for changing the value of a cell. Supports the display of a currently highlighted cell. Sets fonts and colors of SpreadsheetCells.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>SpreadsheetFrame</TD><TD WIDTH=400>Provides the main presentation of the spreadsheet by displaying the SpreadsheetContainer, managing mouse selections on that spreadsheet, reading a text field for changing cell values, and handling a menu for actions such as invoking dialog boxes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190>SpreadsheetApplet</TD><TD WIDTH=400>Responsible for creating, showing and hiding the SpreadsheetFrame that provides the visual display of this applet.
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="AddingtheColorDialog">Adding the Color Dialog</A>
</H3>
<P>
The color dialog box lets you associate a color with various elements
of a spreadsheet cell. You can set the foreground and background
color of a cell in its normal state and also change the colors
of the cell when it is highlighted. <B>Figure</B> 4.10 shows how
the dialog appears in a browser.
<P>
<A HREF="f4-10.gif" ><B>Figure 4.10 :</B><I> The color dialog box.</I></A>
<H4>How the Dialog Box Is Used</H4>
<P>
When the dialog box appears, the current settings of the spreadsheet
cell colors are displayed. A list control in the top left shows
which elements of the spreadsheet cell can be modified. These
colors are normal foreground, normal background, highlighted foreground,
and highlighted background. When you select a list item, the radio
button for the corresponding color is highlighted. A text display
underneath the list shows what the spreadsheet cell would look
like with the given colors. The text display shows either the
normal state (with both foreground and background colors) or the
background state. If you select a new color with the radio button,
the canvas object is updated to show what the new foreground and
background combination would look like. The spreadsheet is updated
with the color settings for the current list item when you select
the Update button.
<H4>The Construction of the Color Dialog Box</H4>
<P>
Four classes are used to construct the color dialog box. The ChooseColorDialog
class is a subclass of Dialog and controls the main display and
control of the dialog box. The colorDisplay class is a Canvas
class derivative that draws text with colors corresponding to
the selected foreground and background display. The ColoredCheckbox
class draws a checkbox associated with a certain Color object;
the background of the box is drawn according to that color. The
ColoredCheckboxGroup class groups ColoredCheckbox items together
so that they can function as part of a radio button group.
<P>
The discussion of the color dialog box begins with its underlying
components. Listing 4.9 shows the code for the ColoredCheckbox
class. Its most interesting feature is that it associates itself
with a given Color object. It paints its background according
to the Color and, through the <TT>setIfColorMatches()</TT>
method, turns its checkbox on if the Color sent to it matches
its internal color. The checkbox in this case is a radio button
because the class is associated with a CheckboxGroup. Checkbox
objects have radio buttons only if they are associated with a
CheckboxGroup object; only one radio button in a checkbox group
can be on at one time. If no checkbox group is specified for a
checkbox object, then there are no restrictions on which boxes
can be selected.
<HR>
<BLOCKQUOTE>
<B>Listing 4.9. The ColoredCheckbox class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Class for creating a checkbox associated
<BR>
// with a given color...<BR>
class ColoredCheckbox extends Checkbox {<BR>
&nbsp;&nbsp;&nbsp;Color color;&nbsp;&nbsp;// The color of this
checkbox...<BR>
&nbsp;&nbsp;&nbsp;// Constructor creates checkbox with specified
color...<BR>
&nbsp;&nbsp;&nbsp;public ColoredCheckbox(Color color, String label,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckboxGroup
grp, boolean set) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Call
the default constructor...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(label,grp,set);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color
= color;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(color);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Sets itself to true if it matches the color
<BR>
&nbsp;&nbsp;&nbsp;public void setIfColorMatches(Color match) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (color == match)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setState(true);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setState(false);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Return the color matching this box...<BR>
&nbsp;&nbsp;&nbsp;public Color getColor() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return color;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The ColoredCheckboxGroup is used to contain ColoredCheckbox objects.
Its constructor creates a preselected number of colored checkboxes
to be associated with a Panel object. Here are the first few lines
of the ColoredCheckboxGroup class declaration:
<BLOCKQUOTE>
<TT>class ColoredCheckboxGroup extends CheckboxGroup
{<BR>
&nbsp;&nbsp;&nbsp;// Array to hold checkboxes...<BR>
&nbsp;&nbsp;&nbsp;ColoredCheckbox c[] = new ColoredCheckbox[12];
<BR>
&nbsp;&nbsp;&nbsp;// Constructor. Create the checkboxes with<BR>
&nbsp;&nbsp;&nbsp;// no default color chosen...<BR>
&nbsp;&nbsp;&nbsp;public ColoredCheckboxGroup(Panel p) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Call the default constructor...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the checkboxes and
store in panel and reference array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[0] = new ColoredCheckbox(Color.black,&quot;Black&quot;,this,false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.add(c[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[1] = new ColoredCheckbox(Color.cyan,&quot;Cyan&quot;,this,false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.add(c[1]);</TT>
</BLOCKQUOTE>
<P>
Strangely enough, ColoredCheckboxGroup is not a Container object.
Consequently, the checkboxes need to be associated with a Panel
to meet the needs at hand. Note the use of the Color constants
in constructing the ColoredCheckbox objects. The reference array
(variable <TT>c</TT>) is used in the
other method of the class, <TT>setMatchingColor()</TT>,
which is used to set the radio button of the ColoredCheckbox that
matches a certain color:
<BLOCKQUOTE>
<TT>public void setMatchingColor(Color match)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; c.length;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i].setIfColorMatches(match);
<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
Since ColoredCheckbox objects are self-identifying by color, this
technique prevents a long and cumbersome walk through hard-coded
color names to see which radio button should be turned on.
<P>
The colorDisplay class is a Canvas derivative that draws text
(specified in the <TT>displayText</TT>
String variable) with a specified foreground and background color.
Listing 4.10 highlights some of the more interesting features
of the class. The <TT>paint()</TT>
method draws the canvas if a background and foreground color have
been selected. It first starts getting the size of its drawing
area through the <TT>size()</TT> method;
this method is a standard part of subclasses of Component. It
fills in the background color through the <TT>setColor()</TT>
and <TT>fillRect()</TT> methods of
the Graphics class. It then sets the color of the text to be displayed
(the foreground). By getting the current FontMetrics, the canvas
can figure out a good location for the text string; the <TT>getHeight()</TT>
method returns the total height of the font. The <TT>drawString()</TT>
method then draws the text at the specified location.
<HR>
<BLOCKQUOTE>
<B>Listing 4.10. Portions of the colorDisplay class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// The layout will call this to get the
minimum size<BR>
&nbsp;&nbsp;&nbsp;// of the object.&nbsp;&nbsp;In this case, you
want it to be at<BR>
&nbsp;&nbsp;&nbsp;// least big enough to fit the display test...
<BR>
&nbsp;&nbsp;&nbsp;public Dimension minimumSize() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the metrics of the
current font...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = getFontMetrics(getFont());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Dimension(fm.stringWidth(displayText),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 * fm.getHeight());
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Paint the colors and text...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void paint(Graphics g) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((foreground == null) ||
(background == null))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set background...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension dm = size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(background);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0,0,dm.width,dm.height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(foreground);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set dimensions. Move just
from left...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = getFontMetrics(getFont());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = fm.charWidth('W');
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// And center in height...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y = fm.getHeight();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(displayText,x,y);
<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>minimumSize()</TT> method
is used with layouts, which were discussed in the last chapter.
When AWT is constructing the display of a group of components,
it works with the layouts to decide what position and size a component
should have. Sometimes, you might want a component to exercise
some input into what its size will be. Two methods of the Component
class can be invoked to do this. The <TT>preferredSize()</TT>
method returns the Dimensions of the preferred size of the component.
The <TT>minimumSize()</TT> method
returns the smallest size in which the component should be made.
In the case of the <TT>colorDisplay()</TT>
class, it returns that the component should be wide enough to
display the text String and twice as high as its current font.
It does this by getting the FontMetrics of the current font and
calling the <TT>stringWidth()</TT>
and <TT>getHeight()</TT> methods respectively.
<P>
Finally, the dialog box is ready to be constructed. Figure 4.11
highlights the declarations and methods used to construct the
color dialog box. The <TT>createComponents()</TT>
method adds the components to the dialog box by using the complex
<TT>GridBagLayout()</TT> class. The
main thing that needs to be done here is to have most of the space
taken up by the list control set to half the dialog box and the
color checkboxes on the other half, as shown in Figure 4.10. The
key reason for doing this is to set the GridBagConstraints <TT>weighty</TT>
and <TT>gridheight</TT> variables
to the appropriate values. By setting the former to <TT>1.0</TT>,
this tells the layout that the associated components should be
given preeminence in terms of the layout's height. When <TT>weighty</TT>
is set to <TT>0.0</TT>, then the height
of the corresponding components is given lower priority.
<P>
<A HREF="f4-11.gif" ><B>Figure 4.11 :</B><I> The font dialog box.</I></A>
<P>
The <TT>preferredSize()</TT> method
in Listing 4.11 returns the desired dimensions of the dialog box.
It needs to be three times as wide as the longest string in the
list component, and 24 times as high as the current font. This
way everything should fit comfortably in the dialog box.
<HR>
<BLOCKQUOTE>
<B>Listing 4.11. The construction of ChooseColorDialog.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Dialog box for choosing display colors...
<BR>
public class ChooseColorDialog extends Dialog {<BR>
&nbsp;&nbsp;&nbsp;SpreadsheetFrame fr;&nbsp;&nbsp;&nbsp;// What
to update...<BR>
&nbsp;&nbsp;&nbsp;ColoredCheckboxGroup colorGrp;&nbsp;&nbsp;//
To hold radio buttons of colors...<BR>
&nbsp;&nbsp;&nbsp;SpreadsheetContainer s;<BR>
&nbsp;&nbsp;&nbsp;List choiceList;&nbsp;&nbsp;// List of color
choices...<BR>
&nbsp;&nbsp;&nbsp;colorDisplay d; // This is the text display...
<BR>
&nbsp;&nbsp;&nbsp;// Defines for listbox values...<BR>
&nbsp;&nbsp;&nbsp;static int NORMAL_FORE = 0;<BR>
&nbsp;&nbsp;&nbsp;static int NORMAL_BACK = 1;<BR>
&nbsp;&nbsp;&nbsp;static int HILITE_FORE = 2;<BR>
&nbsp;&nbsp;&nbsp;static int HILITE_BACK = 3;<BR>
&nbsp;&nbsp;&nbsp;// Construct dialog to allow color to be chosen...
<BR>
&nbsp;&nbsp;&nbsp;public ChooseColorDialog(Frame parent,boolean
modal) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create dialog with title
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(parent,&quot;Color Dialog&quot;,modal);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fr = (SpreadsheetFrame)parent;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the dialog components...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createComponents();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pack();&nbsp;&nbsp;// Compact...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Resize to fit everything...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(preferredSize());<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
// The layout will call this to get the preferred size<BR>
&nbsp;&nbsp;&nbsp;// of the dialog.&nbsp;&nbsp;Make it big enough
for the listbox text<BR>
&nbsp;&nbsp;&nbsp;// the checkboxes, canvas, and buttons...<BR>
&nbsp;&nbsp;&nbsp;public Dimension preferredSize() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the metrics of the
current font...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = getFontMetrics(getFont());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int width = 3 * fm.stringWidth(&quot;Highlighted
foreground&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int height = 24 * fm.getHeight();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Dimension(width,height);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create the main display panel...<BR>
&nbsp;&nbsp;&nbsp;void createComponents() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Use gridbag constraints...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout g = new GridBagLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLayout(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints gbc = new GridBagConstraints();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Set the constraints for the top objects...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.fill = GridBagConstraints.BOTH;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.weightx = 1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.weighty = 1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridheight = 10;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Add the listbox of choices...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList = new List();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList.addItem(&quot;Normal foreground&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList.addItem(&quot;Normal background&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList.addItem(&quot;Highlighted foreground&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList.addItem(&quot;Highlighted background&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(choiceList,gbc);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(choiceList);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the checkbox panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Panel checkboxPanel = new Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;checkboxPanel.setLayout(new GridLayout(12,1));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the checkbox group and add radio
buttons...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;colorGrp = new ColoredCheckboxGroup(checkboxPanel);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;colorGrp.setMatchingColor(Color.magenta);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create checkbox panel to right...<BR>
gbc.gridwidth = GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(checkboxPanel,gbc);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(checkboxPanel);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Display the color chosen...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;d = new colorDisplay(&quot;This is how
the text looks.&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Add to grid bag...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.weighty = 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.weightx = 1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth = GridBagConstraints.REMAINDER;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridheight = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(d,gbc);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(d);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Two buttons: &quot;Update&quot; and
&quot;Cancel&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Panel p = new Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;p.add(new Button(&quot;Update&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;p.add(new Button(&quot;Cancel&quot;));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Add to grid bag...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth = GridBagConstraints.REMAINDER;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(p,gbc);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(p);<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H4>Using the Dialog Box</H4>
<P>
Once the dialog box is displayed, its event loop is entered. Listing
4.12 details the <TT>handleEvent()</TT>
method of the dialog box. This code has several subtleties worth
noting. Most of the work is performed when an action occurs, as
indicated by the <TT>ACTION_EVENT</TT>
method. When a button is selected, the argument of the Event object
is set to the name of the button. The <TT>handleEvent()</TT>
method looks at this name to decide what to do. If the name is
&quot;Cancel,&quot; then the dialog box is removed from the screen
with the <TT>dispose()</TT> method,
and control returns to the calling frame. The Update button sets
the spreadsheet colors according to what is currently highlighted.
How this works will be discussed shortly.
<HR>
<BLOCKQUOTE>
<B>Listing 4.12. The </B><TT><B>handleEvent()</FONT></B></TT><B>
method of ChooseColorDialog.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Wait for Cancel or OK buttons to be
chosen...<BR>
public boolean handleEvent(Event e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch(e.id) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Event.ACTION_EVENT:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Kill
the dialog...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.arg.equals(&quot;Cancel&quot;))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();&nbsp;&nbsp;//
Remove Dialog...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update
colors on the spreadsheet...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.arg.equals(&quot;Update&quot;))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setSpreadsheetColors();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target
instanceof Checkbox) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selectedRadioItem();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // User selected a listbox
item...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Event.LIST_SELECT:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up
caption colors and color choice highlight...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target
instanceof List) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selectedChoiceListItem();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end list if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;} // end switch<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
If the target of the <TT>ACTION_EVENT</TT>
is a Checkbox, then it means a radio button is selected, which
calls the <TT>selectedRadioItems()</TT>
method. This method sets the colorDisplay object's foreground
or background color according to the radio button chosen and the
current selection in the list.
<P>
If you click on a list item, a <TT>LIST_SELECT</TT>
event is issued. In this case, this invokes the <TT>selectedChoiceListItems()</TT>
method. It sets the colorDisplay object's settings according to
the current list selection; this process needs to take into account
both the foreground and background colors. The ColoredCheckboxGroup's
<TT>setMatchingColor()</TT> method
is called to set the radio button of the ColoredCheckbox object
corresponding to the current list color.
<P>
See this book's accompanying CD-ROM for the full source code of
the <TT>selectedRadioItems()</TT>
and <TT>selectedChoiceListItems()</TT>
methods.
<H4>Calling the Dialog Box</H4>
<P>
The SpreadsheetFrame object is responsible for bringing up the
color dialog box. It declares a variable of the color dialog class
as follows:
<BLOCKQUOTE>
<TT>ChooseColorDialog colorDialog;&nbsp;&nbsp;//
Color Dialog...</TT>
</BLOCKQUOTE>
<P>
In its constructor, the frame instantiates the color dialog box
with the following:
<BLOCKQUOTE>
<TT>colorDialog = new ChooseColorDialog(this,
true);</TT>
</BLOCKQUOTE>
<P>
This states that the frame is the parent of the dialog box and
its appearance is modal. Recall that a modal dialog box does not
allow input to other windows while it is being displayed.
<P>
A dialog box does not automatically appear when it is constructed;
you do this with the <TT>show()</TT>
method. The SpreadsheetFrame object is modified in this chapter's
tutorial to add menu options for the new dialog boxes. Here is
some of the code from the frame's <TT>handleEvent()</TT>
method that results in the ChooseColorDialog object being displayed:
<BLOCKQUOTE>
<TT>public boolean handleEvent(Event evt)
{<BR>
 switch(evt.id) {<BR>
&nbsp;&nbsp;case Event.ACTION_EVENT: {<BR>
&nbsp;&nbsp;&nbsp;String menu_name = evt.arg.toString();<BR>
&nbsp;&nbsp;&nbsp;if (evt.target instanceof MenuItem) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Set colors...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(menu_name.equals(&quot;Colors...&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorDialog.show();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// &#133; other menu choices&#133;</TT>
</BLOCKQUOTE>
<P>
The color dialog box overrides the <TT>show()</TT>
method so it can do some setup before the dialog box appears:
<BLOCKQUOTE>
<TT>public synchronized void show() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.show(); // Call the
default show method...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the spreadsheet container...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = fr.getSpreadsheetContainer();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the listbox default...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceList.select(0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up caption colors and
color choice <BR>
highlight...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selectedChoiceListItem();
<BR>
}</TT>
</BLOCKQUOTE>
<P>
After calling the superclass show method, the dialog box gets
a reference to the frame's SpreadsheetContainer object. It will
need this to get and set the spreadsheet's colors. It then sets
the list box selection to the first item. The last method called,
<TT>selectedChoiceListItem()</TT>,
sets the radio buttons and display canvas to values corresponding
to the current list selection.
<H4>Setting the Spreadsheet Colors</H4>
<P>
The SpreadsheetContainer class needs to be modified slightly to
support dynamically selecting colors. Fortunately, these changes
are small since the SpreadsheetCell class, which represents the
individual cells in the spreadsheet, was written to support colors
in its first version presented in <A HREF="ch3.htm" >Chapter 3</A>,
&quot;Building a Spreadsheet Applet.&quot;
<P>
Four <TT>Color</TT> variables are
introduced to the SpreadsheetContainer class so that colors can
be set dynamically:
<BLOCKQUOTE>
<TT>Color normalForeColor = Color.black;
<BR>
Color normalBackColor = Color.white;<BR>
Color highlightedForeColor = Color.white;<BR>
Color highlightedBackColor = Color.red;</TT>
</BLOCKQUOTE>
<P>
Associated with the variable declarations are the default colors.
These SpreadsheetCell colors have the background and foreground
colors set, respectively, in code such as the following:
<BLOCKQUOTE>
<TT>matrix[index].setFillColor(normalBackColor);
<BR>
matrix[index].setTextColor(normalForeColor);</TT>
</BLOCKQUOTE>
<P>
This code is from the SpreadsheetContainer constructor. The two
<TT>setFillColor()</TT> and <TT>setTextColor()</TT>
methods are also called when a cell is given the current highlight
focus. In this case, the cell is given the highlight colors. Some
code is repeated here from the SpreadsheetCell object's <TT>paint()</TT>
method to illustrate how these colors are applied to the cell:
<BLOCKQUOTE>
<TT>// Set up drawing rectangle...<BR>
g.setColor(Color.blue);<BR>
g.drawRect(x,y,width,height);<BR>
g.setColor(fillColor);<BR>
g.fillRect(x + 1,y + 1,width - 2,height - 2);<BR>
// Draw the string<BR>
g.setColor(textColor);<BR>
g.drawString(textPaint,x + 4,y + (height - 2));</TT>
</BLOCKQUOTE>
<P>
The <TT>fillColor</TT> and <TT>textColor</TT>
variables are set by the <TT>setFillColor()</TT>
and <TT>setTextColor()</TT> methods,
respectively.
<P>
Four accessor methods are added to the SpreadsheetContainer class
for getting the normal and highlight Color variables. These are
called by the <TT>selectedChoiceListItem()</TT>
method of the ChooseColorDialog  class to retrieve the colors
to be displayed in the colorDisplay object.
<P>
When you click the Update button, the color dialog box's <TT>setSpreadsheetColors()</TT>
is invoked to update the spreadsheet colors. This in turn calls
the SpreadsheetContainer's <TT>setNewColors()</TT>
method, which applies the four normal and highlight colors to
each of the SpreadsheetCell objects that are not row or column
headers. The container is then repainted, displaying the cells
in their new colors.
<H3><A NAME="FontDialogBox">Font Dialog Box</A></H3>
<P>
The discussion of the spreadsheet applet's font dialog box will
not be as lengthy as the preceeding overview of the color dialog.
In many ways, it is very similar, so a detailed explanation doesn't
need to be repeated; refer to this book's CD-ROM for any details
not covered in this overview.
<P>
Figure 4.11 shows the font dialog box. It is based on the ChooseFontDialog
class, which displays its components in a two-column style similar
to the color dialog box. The current font family, style, and size
is shown in a Canvas display object of the fontDisplay class.
This class is very similar to the colorDisplay class.
<P>
The list component on the left side of the dialog box shows the
fonts available on the current platform. It uses the AWT Toolkit
class to get this information. Here is the code that creates the
control and adds the font families:
<BLOCKQUOTE>
<TT>// Add the listbox of choices...<BR>
&nbsp;&nbsp;&nbsp;// Get the selection from the toolkit...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;choiceList = new List();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String fontList[] = <BR>
Toolkit.getDefaultToolkit().getFontList();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; fontList.length;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; choiceList.addItem(fontList[i]);</TT>
</BLOCKQUOTE>
<P>
A choice box is added to the dialog box to enumerate font sizes
that can be used. Two checkboxes are used to set the bold and
italicized styles. If none of these are set, the font's style
is set to plain.
<P>
Every time one of these controls is changed, the font display
is updated with a new font. This happens in the <TT>paintSample()</TT>
method, whose text is found in Listing 4.13. The variable <TT>d</TT>
in the code represents the fontDisplay object.
<HR>
<BLOCKQUOTE>
<B>Listing 4.13. The </B><TT><B>paintSample()</FONT></B></TT><B>
method for displaying a font with selected attributes.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Set the display canvas to show itself
with<BR>
&nbsp;&nbsp;&nbsp;// the currently selected font<BR>
&nbsp;&nbsp;&nbsp;private synchronized void paintSample() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the family to display
<BR>
String fontName = choiceList.getSelectedItem();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get its point size<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String fontSize = choiceSize.getSelectedItem();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set its style<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int fontStyle = Font.PLAIN;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkItalics.getState())
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontStyle
+= Font.ITALIC;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (checkBold.getState())
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontStyle
+= Font.BOLD;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create a font with the
proper attributes...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentFont = new Font(fontName,fontStyle,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt(fontSize));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the new font on the
canvas...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.setFont(currentFont);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Repaint it so the new font
is displayed..<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.repaint();<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
When you select OK, the <TT>setFont()</TT>
method of the SpreadsheetContainer class is called; the font created
in the previous <TT>paintSample()</TT>
code is passed as the parameter. This <TT>setFont()</TT>
method overrides the default <TT>setFont()</TT>
method, as seen in Listing 4.14. The method goes through every
font in the container and sets it to the new font. The container
is then repainted to show the new font. Figure 4.12 shows what
the spreadsheet looks like when it is set with a Helvetica Bold
16-point font.
<P>
<A HREF="f4-12.gif" ><B>Figure 4.12 :</B><I> The spreadsheet applet set to Helvetica Bold 16-point font.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 4.14. The SpreadsheetContainer </B><TT><B>setFont()</FONT></B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Set the font for all the individual
<BR>
&nbsp;&nbsp;// spreadsheet cells...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void setFont(Font f) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; super.setFont(f);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Reload the font for each cell...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numRows; ++i)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; numColumns;
++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = (i * (numColumns))
+ j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the colors...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrix[index].setFont(f);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end inner
for...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end outer for<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Repaint to show new font...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; repaint();<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheFileDialogClass">The FileDialog Class</A></H3>
<P>
The FileDialog class is a subclass of Dialog used to provide a
platform-independent approach to letting the user select what
files are to be loaded or saved. Instances of the FileDialog class
will usually mirror the underlying GUI conventions. For example,
a FontDialog object for loading a file on the Windows 95 environment
is shown in Figure 4.13. As you can see from the example, the
dialog box follows the Windows 95 Open dialog box conventions.
<P>
<A HREF="f4-13.gif" ><B>Figure 4.13 : </B><I>The load file font Dialog.</I></A>
<P>
The FileDialog can be constructed to be in a mode to load a file
or save a file. These dialog boxes look similar but perform slightly
differently. For example, the Save version of the dialog box will
notify the user that a file exists if a filename is given for
a preexisting file. The SpreadsheetFrame class constructs a dialog
box for both the load and save cases:
<BLOCKQUOTE>
<TT>FileDialog openFileDialog;&nbsp;&nbsp;//
File Open Dialog...<BR>
FileDialog saveFileDialog;&nbsp;&nbsp;// File Save Dialog...<BR>
openFileDialog = new FileDialog(this,&quot;Open File&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDialog.LOAD);
<BR>
saveFileDialog = new FileDialog(this,&quot;Save File&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileDialog.SAVE);</TT>
</BLOCKQUOTE>
<P>
The integer flag in the last parameter of the constructors indicates
the mode in which the dialog box should function.
<P>
When the dialog box is displayed with the <TT>show()</TT>
method, it acts in a modal fashion so that input to the frame
is blocked while it is up. After a choice has been made, the chosen
file and directory can be retrieved with the <TT>getFile()</TT>
and <TT>getDirectory()</TT> methods.
The former will return a null value if the user had canceled out
of the dialog box. If the names are valid, the SpreadsheetFrame
class either saves or opens the specified spreadsheet file.
<P>
It is interesting to note that the FileDialog objects constructed
here do not appear when the applet is run in Netscape Navigator.
Recall that Netscape does not allow any file-based methods to
be invoked from an applet. Consequently, there is no reason to
even display FileDialog objects.
<H3><A NAME="SavingaSpreadsheetFile">Saving a Spreadsheet File</A>
</H3>
<P>
The process of saving a spreadsheet file is surprisingly simple.
What is saved is not the contents of the SpreadsheetContainer
object, but the CellContainer object. This is because the former
has some useless information like row/column headers, but the
real data is in the CellContainer.
<P>
Listing 4.15 shows the CellContainer method for saving a file.
This code was easy to generate because of the FilterOutputStream
classes discussed in the overview of streams. The DataOutputStream
variable <TT>fs</TT> is used to hide
the complexities of the underlying BufferedOutputStream and FileOutputStream
objects. The former is used as a cache so that every stream write
does not result in a disk write. In short, BufferedOutputStream
is used to improve performance. The inner part of the constructor,
FileOutputStream, actually opens the file for writing. If there
is a problem opening or writing the file at any point in the process,
an IOException will be thrown. The <TT>saveFile()</TT>
method simply rethrows the exception, forcing the calling method
to catch the problem.
<HR>
<BLOCKQUOTE>
<B>Listing 4.15. The CellContainer method for saving a file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Save the cell container to a file...
<BR>
&nbsp;&nbsp;&nbsp;public void saveFile(String filename) throws
IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Perform these file operations.&nbsp;&nbsp;If
anything goes wrong<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an exception will be thrown.&nbsp;&nbsp;This
must be caught<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by the calling method...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Open the file...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream fs = new
DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
BufferedOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
FileOutputStream(filename)));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write out magic number
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.writeInt(magicNumber);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write out row and column
sizes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.writeInt(numRows);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.writeInt(numColumns);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now go through each row
and column and save...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write out literal value
followed by delimited...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numCells = numRows * numColumns;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; numCells;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.writeBytes(matrix[i].getCellString());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.writeByte(delimiter);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Close the file. You're
done!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.close();<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The first thing written to the file is a magic integer number.
This is used to indicate that the file is a spreadsheet file.
The method for opening a spreadsheet file (discussed in the next
section) will check for the existence of the magic number at the
beginning of the file. If it isn't there, an exception will be
thrown.
<P>
The <TT>saveFile()</TT> method writes
out the magic number and the number of rows and columns out as
integers, using the DataOutputStream <TT>writeInt()</TT>
method. The method then loops through each element in the CellContainer
matrix, writing out each cell's String contents followed by a
delimiter (in this case, a tab). Recall that the CellContainer
needs only the Cell's String value; the evaluated value can be
generated on the fly by calling the CellContainer <TT>reevaluate()</TT>
method.
<P>
The Cell string is written out through the <TT>writeBytes()</TT>
method. Why not use a <TT>writeString()</TT>
method? This does not exist because Java is a Unicode-based system.
This means that 8-bit ASCII character strings need to be treated
differently than 16-bit Unicode values. The <TT>writeBytes()</TT>
method is used here so that ASCII data can be written out.
<H3><A NAME="OpeningaSpreadsheetFile">Opening a Spreadsheet File</A>
</H3>
<P>
Once a spreadsheet's contents have been saved to a file, it can
be reopened through the CellContainer's <TT>readFile()</TT>
method. This is detailed in Listing 4.16. Although it's similar
to the <TT>saveFile()</TT> method
in the previous section, it differs in some important ways. A
major difference is that the <TT>readFile()</TT>
method generates the Cell matrix of the CellContainer because
<TT>readFile()</TT> is called from
a new CellContainer constructor, which takes a filename as its
parameter. This constructor does little more than call <TT>readFile()</TT>,
which becomes responsible for setting up the Cell matrix.
<HR>
<BLOCKQUOTE>
<B>Listing 4.16. The CellContainer method for reading in a file.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Read in a file and create a new matrix
to<BR>
&nbsp;&nbsp;&nbsp;// accommodate the data...<BR>
&nbsp;&nbsp;&nbsp;public void readFile(String filename) throws
IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set everything to empty...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numRows = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numColumns = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int magic;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream fs;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Open
the file...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs = new
DataInputStream(new BufferedInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
FileInputStream(filename)) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Can't open file, quit out...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now try to load the data...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Check the magic number<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magic&nbsp;&nbsp;=
fs.readInt();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(magic != magicNumber)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
(new IOException(&quot;Invalid magic number&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Get the rows and columns...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numRows
= fs.readInt();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numColumns
= fs.readInt();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
((numRows &lt;= 0) || (numColumns &lt;=0) ||<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(numRows
&gt; maxRows) || (numColumns &gt; maxColumns) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
(new IOException(&quot;Invalid row/col settings&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
numCells = numRows * numColumns;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Allocate matrix...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrix
= new Cell[numCells];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Now load the individual cells...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; numCells; ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Load the string up until delimited...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer
s = new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((b = fs.readByte()) != delimiter)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.append((char)b);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Add it to new Cell...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i]
= new Cell();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i].setCellString(s);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
// end for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Success! Close the file and leave...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fs.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If exception, then close
file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and reset everything...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numRows
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numColumns
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Of course, the other difference between <TT>saveFile()</TT>
and <TT>readFile()</TT> is that the
latter works with an InputStream. The DataInputStream object <TT>fs</TT>
builds on BufferedInputStream and FileInputStream objects, the
latter of which actually opens the file for reading. The code
uses <TT>readInt()</TT> to check the
first few bytes of the file to make sure the magic number is present.
If it isn't, an exception is thrown. The <TT>readFile()</TT>
method throws an IOException if the magic number fails, the file
is not found, or there is a problem with the read. The constructor
does not catch thrown IOException objects, so it's up to the calling
object to catch IOException objects.
<P>
The individual Cell Strings are created through multiple calls
to <TT>readByte()</TT>. This is used
with the String <TT>append()</TT>
method to add byte characters to a new String until the delimiter
is found. When this happens, a new Cell is created with the String
and is assigned to the CellContainer matrix.
<P>
The SpreadsheetFrame object calls the CellContainer constructor
that loads a file when the load FileDialog object is used. It
takes the newly created CellContainer and sets it to the SpreadsheetContainer
with the <TT>newCellContainer()</TT>
method discussed in the previous chapter. This method uses the
loaded CellContainer object to generate new SpreadsheetCell objects.
It then repaints itself, displaying the new spreadsheet contents.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter's tutorial provides several examples of how to use
Dialogs. In doing so, it also illustrates more principles for
using the Graphics object to paint colors and fonts, working with
layouts to create more complex displays, and learning the subtleties
of event handling. It also gives you an overview of Java streams
with examples of how to read and write to files. This latter capability
will be restricted depending on the browser environment (or lack
thereof) in which a Java applet is being executed.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



