<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>


   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 10</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Native Methods and Java</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#DecidingtoUseNativeMethods" >Deciding to Use Native Methods</A>
<LI><A HREF="#NativeMethodsfromtheJavaSide" >Native Methods from the Java Side</A>
<LI><A HREF="#WritingNativeMethods" >Writing Native Methods</A>
<UL>
<LI><A HREF="#UsingJavah" >Using Javah</A>
<LI><A HREF="#JavaArrays" >Java Arrays</A>
<LI><A HREF="#TheStubsCode" >The Stubs Code</A>
</UL>
<LI><A HREF="#ChapterProjectADatabaseInterfaceLi" >Chapter Project: A Database Interface Library Using ODBC</A>
<UL>
<LI><A HREF="#CallingBackIntoJava" >Calling Back Into Java</A>
<LI><A HREF="#ConstructingJavaObjectsfromC" >Constructing Java Objects from C</A>
<LI><A HREF="#CreatingtheLibrary" >Creating the Library</A>
</UL>
<LI><A HREF="#DatabaseServer" >Database Server</A>
<LI><A HREF="#AddingPacketAssemblytoDGTP" >Adding Packet Assembly to DGTP</A>
<UL>
<LI><A HREF="#TheElectionServer" >The Election Server</A>
</UL>
<LI><A HREF="#ElectionClient" >Election Client</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter builds on the concepts of <A HREF="ch9.htm" >Chapter 9</A>,
&quot;Java Socket Programming,&quot; to construct a sophisticated
database server. The server reads from a back-end database in
real time. Since the standard Java classes do not, as yet, provide
a database interface, native methods must be used to read the
tables. A native interface library is developed and used to read
a sample database. Along the way, you will learn the following:
<UL>
<LI><FONT COLOR=#000000>Calling C methods from Java</FONT>
<LI><FONT COLOR=#000000>Creating C libraries that can be called
from Java</FONT>
<LI><FONT COLOR=#000000>Handling Java types as arguments to C
functions</FONT>
<LI><FONT COLOR=#000000>Accessing Java class members from C functions</FONT>
<LI><FONT COLOR=#000000>Calling Java methods from C functions</FONT>
<LI><FONT COLOR=#000000>Throwing Java exceptions from a C function</FONT>
</UL>
<H2><A NAME="DecidingtoUseNativeMethods"><FONT SIZE=5 COLOR=#FF0000>Deciding
to Use Native Methods</FONT></A></H2>
<P>
The decision to use native methods comes with a heavy cost. Any
classes that load native methods cannot be used in an applet!
There aren't any browsers available that allow applets to call
native methods. The reason for this restriction is security. The
Java security manager can't protect against malicious attacks
from within a native method. The only solution is to not allow
native methods to be called.
<P>
Another disadvantage is the lost portability of your applications.
One of the chief benefits of using Java is the portability of
the resulting code between disparate platforms. A small industry
has developed trying to provide truly portable application frameworks.
For all their refinement, you are still left recompiling a version
for each platform. Java steps into the fray with an intermediate
format that enables you to compile once and execute everywhere.
When you choose to use native methods, you lose this capability.
Once again, you will be relegated to coding a separate library
for each platform that runs Java.
<P>
Now that the downside to native methods is clear, why use them
at all? The single best reason to resort to native methods is
to add functions not present in the standard classes. Maybe you
want to interface with a specific piece of hardware or use a new
network driver. Whatever the reason, native methods supply the
capability. Because Java is portable, it cannot take advantage
of operating specific features. The Java developers endeavored
to supply the standard classes with all needed functionality,
but this is an impossible task. The ability to call native C methods
supplies a way to use features not available through the Java
classes. Most of the functions in the standard classes themselves
have to resort to native method calls to accomplish their tasks.
<H2><A NAME="NativeMethodsfromtheJavaSide"><FONT SIZE=5 COLOR=#FF0000>Native
Methods from the Java Side</FONT></A></H2>
<P>
Native methods within a Java class are very simple. Any Java method
can be transformed into a native method-simply delete the method
body, add a semicolon at the end, and prefix the <TT>native</TT>
keyword. The following Java method
<BLOCKQUOTE>
<TT>public int myMethod(byte[] data)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</TT>
</BLOCKQUOTE>
<P>
becomes
<BLOCKQUOTE>
<TT>public native int myMethod(byte[] data);</TT>
</BLOCKQUOTE>
<P>
Where does the method body get implemented? In a Java-called native
library that gets loaded into Java at runtime. The class of the
above method would have to cause the library to be loaded. The
best way to accomplish the load is to add a static initializer
to the class:
<BLOCKQUOTE>
<TT>static<BR>
{<BR>
&nbsp;&nbsp;&nbsp;System.loadLibrary(&quot;myMethodLibrary&quot;);
<BR>
}</TT>
</BLOCKQUOTE>
<P>
Static code blocks are executed once by the system when the class
is first introduced. Any operations may be specified, but library
loading is the most common use. If the static block fails, the
class will not be loaded. This ensures that no native methods
are executed without the underlying libraries.
<P>
That's all there is to Java-side native methods. All the complexity
is hidden within the native library. A native method appears to
Java like all other real Java methods. In fact, all the Java modifiers
(public, private, and so forth) apply to native methods as well.
<H2><A NAME="WritingNativeMethods"><FONT SIZE=5 COLOR=#FF0000>Writing
Native Methods</FONT></A></H2>
<P>
The Java runtime was implemented in the C programming language,
so currently the only native language supported is C. The entry
points into a C library that can be called from Java are called
<I>stubs</I>. When you execute a native method call, a stub is
entered. Java tries to ease the transition into native code by
supplying a tool to generate a C header file and stub module.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Any language that can link with and be called by C can be used to implement a native method. The C language is needed only to provide the actual interface with Java. Any additional, non-Java processing could be done in another language, such as Pascal.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="UsingJavah">Using <TT><FONT SIZE=4 FACE="Courier">Javah</TT></FONT></A>
</H3>
<P>
<TT>Javah</TT> is the tool used to
generate C files for Java classes; here's how you use it:
<BLOCKQUOTE>
<TT>javah [options] <I>class</I></TT>
</BLOCKQUOTE>
<P>
Table 10.1 briefly lists the options available. By default, <TT>javah</TT>
will create a C header (.h) file in the current directory for
each class listed on the command line. Class names are specified
without the trailing <TT>.class</TT>.
Therefore, to generate the header for SomeName.class, use the
following command:
<BLOCKQUOTE>
<TT>javah SomeName<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 10.1. </B><TT><B>Javah</FONT></B></TT><B>
options.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=185><I>Option</I></TD><TD WIDTH=308><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-verbose</TT>
</TD><TD WIDTH=308>Causes progress strings to be sent to stdout
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-version</TT>
</TD><TD WIDTH=308>Prints the version of javah</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-o <I>outputfile</I></TT>
</TD><TD WIDTH=308>Overrides default file creation;uses only this file
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-d <I>directory</I></TT>
</TD><TD WIDTH=308>Overrides placement of output in current directory
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-td <I>tempdirectory</I></TT>
</TD><TD WIDTH=308>Overrides default temp directory use</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-stubs</TT>
</TD><TD WIDTH=308>Creates C code module instead of header module
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=185><TT>-classpath <I>path</I></TT>
</TD><TD WIDTH=308>Overrides default classpath</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If the class you want is within a package, then the package name must be specified along with the class name: <TT>javah java.net.Socket</TT>. In addition, <TT>javah</TT> will prefix the package name to the output filename: <TT>java_net_Socket.h</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 10.1 is a simple class with native methods. The class
was chosen because it uses most of the Java types. Compile this
class and pass it to <TT>javah</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 10.1. A simple class using native methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Demonstration<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String publicName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private String privateName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static String publicStaticName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static String privateStatucName;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native void method1();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native int method2(boolean b, byte
by, char c, short s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native byte[] method3(byte data[],
boolean b[]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public native String[] method4(int num,
long l, float f, double d);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;static<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.loadLibrary(&quot;Demonstration&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>javah</TT> output of the above
class is in Listing 10.2.
<HR>
<BLOCKQUOTE>
<B>Listing 10.2. </B><TT><B>Javah</FONT></B></TT><B>
output header of Demonstration class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;native.h&gt;<BR>
/* Header for class Demonstration */<BR>
<BR>
#ifndef _Included_Demonstration<BR>
#define _Included_Demonstration<BR>
struct Hjava_lang_String;<BR>
<BR>
typedef struct ClassDemonstration {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct Hjava_lang_String *publicName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct Hjava_lang_String *privateName;
<BR>
/* Inaccessible static: publicStaticName */<BR>
/* Inaccessible static: privateStatucName */<BR>
} ClassDemonstration;<BR>
HandleTo(Demonstration);<BR>
<BR>
#ifdef __cplusplus<BR>
extern &quot;C&quot; {<BR>
#endif<BR>
__declspec(dllexport) void Demonstration_method1(struct HDemonstration
*);<BR>
__declspec(dllexport) long Demonstration_method2(struct HDemonstration
*,/*boolean*/ long,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char,unicode,short);<BR>
__declspec(dllexport) HArrayOfByte *Demonstration_method3(struct
HDemonstration *,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HArrayOfByte *,HArrayOfInt *);<BR>
__declspec(dllexport) HArrayOfString *Demonstration_method4(struct
HDemonstration *,long,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int64_t,float,double);<BR>
#ifdef __cplusplus<BR>
}<BR>
#endif<BR>
#endif</TT>
</BLOCKQUOTE>
<HR>
<P>
The class has been transformed into a C structure. Each class
member is represented, except for static fields. Representation
in a structure has an interesting side effect. Native methods
have access to all non-static fields, including private class
members. You are free to read and alter any member of the class.
<P>
Now focus your attention on the four native method prototypes.
Each method has been renamed by prefixing the class name to the
method name. Had this class been contained in a package, the package
name also would have been added. Each method has an additional
argument. All native methods have a <TT>this</TT>
pointer that allows the function to access the variables of its
associated class. This argument is often referred to as an &quot;automatic&quot;
parameter. Java will add this parameter to your methods automatically.
<P>
The final piece to the puzzle is the <TT>HandleTo()</TT>
macro. Every object in Java is represented in a structure called
a JHandle. The format of this structure for the Demonstration
class is as follows:
<BLOCKQUOTE>
<TT>struct HDemonstration<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ClassDemonstration *obj;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;methodtable *methods;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The <TT>HandleTo()</TT> macro names
the JHandle by adding an <I>H</I> to the passed name. To access
any member of a JHandle class, you must dereference it with the
<TT>unhand()</TT> macro. This macro
has the opposite effect of <TT>HandleTo()</TT>.
The following line retrieves a string member from the Demonstration
class:
<BLOCKQUOTE>
<TT>Hjava_lang_String str = unhand(demoPtr)-&gt;publicName;</TT>
</BLOCKQUOTE>
<P>
The code for the <TT>unhand()</TT>
macro shows the conversion:
<BLOCKQUOTE>
<TT>#define unhand(o)&nbsp;&nbsp;((o)-&gt;obj)</TT>
</BLOCKQUOTE>
<P>
Structure member <TT>obj</TT> is obviously
the class structure, but what of the other structure member?
<P>
Typically, structure member methods will contain a pointer to
an internal Java runtime structure that represents all the information
on a class. This includes the Java byte codes, the exception table,
any defined constants, and the parent class. There are times,
however, when the variable is not a pointer at all. Java has reserved
the lower 5 bits of the pointer for flags. If all 5 bits are zero,
then the value is a pointer. If the lower 5 bits are non-zero,
then the methods field becomes a typecode. You will encounter
typecodes whenever you handle arrays.
<H3><A NAME="JavaArrays">Java Arrays</A></H3>
<P>
Arrays are handled uniquely in Java. They are considered objects,
though they have no methods. Arrays occupy the realm somewhere
between basic runtime types, such as <TT>int</TT>
or <TT>long</TT>, and formal class
objects. In Java, basic types are represented in a compact form.
It would be inefficient to have all the class baggage carried
around with something simple like an integer. When you need to
represent an <TT>int</TT> as an object,
you use a wrapper class, such as class Integer. This is why the
&quot;wrapper&quot; classes are necessary. Arrays are much more
complicated than numbers because they have variable length and
multiple members. Like class objects, their storage is best represented
by a C structure. Unlike class objects, arrays don't have methods.
It was decided that the <TT>methodtable</TT>
pointer could be better used as a scalar quantity for arrays.
<P>
The upper 27 bits of the pointer represent the length of the array,
and the lower 5 bits represent the type of data the array contains.
All the runtime types are actually represented in the lower 4
bits. The fifth bit is reserved for compiler usage. Table 10.2
shows the encoding of the lower 4 flag bits and their meanings.
<BR>
<P>
<CENTER><B>Table 10.2. Type encoding.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=82><CENTER><I>Encoding</I></CENTER></TD><TD WIDTH=175><I>Type</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0000</CENTER></TD><TD WIDTH=175>T_NORMAL_OBJECT
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0001</CENTER></TD><TD WIDTH=175>Unused
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0010</CENTER></TD><TD WIDTH=175>T_CLASS
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0011</CENTER></TD><TD WIDTH=175>Unused
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0100</CENTER></TD><TD WIDTH=175>T_BOOLEAN
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0101</CENTER></TD><TD WIDTH=175>T_CHAR
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0110</CENTER></TD><TD WIDTH=175>T_FLOAT
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>0111</CENTER></TD><TD WIDTH=175>T_DOUBLE
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>1000</CENTER></TD><TD WIDTH=175>T_BYTE
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>1001</CENTER></TD><TD WIDTH=175>T_SHORT
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>1010</CENTER></TD><TD WIDTH=175>T_INTEGER
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=82><CENTER>1011</CENTER></TD><TD WIDTH=175>T_LONG
</TD></TR>
</TABLE></CENTER>
<P>
<P>
There are macros to help you read both the type bits and the length.
The <TT>obj_flags()</TT> macro will
return the flag bits, and <TT>obj_length()</TT>
will return the array length. Both must be passed a JHandle pointer:
<BLOCKQUOTE>
<TT>if ( obj_flags( demoPtr ) != T_NORMAL_OBJECT
)<BR>
&nbsp;&nbsp;&nbsp;length = obj_length( demoPtr );</TT>
</BLOCKQUOTE>
<P>
In practice, you will not need to check the type bits because
Java will create and pass one of the standard array structures.
You can see this in <TT>Demonstration_method3()</TT>.
The parameter <TT>byte[]</TT> has
been passed as an HArrayOfByte pointer. All the standard array
structures have a single member: <TT>body[1]</TT>.
Table 10.3 lists all the array structures and their contents.
To access an array member, dereference the JHandle and index into
the body array. The following line reads the fifth byte from a
Java byte array:
<BLOCKQUOTE>
<TT>char fifthByte = unhand(hByte)-&gt;body[4];</TT>
</BLOCKQUOTE>
<P>
As you can see, Java arrays are zero-based just like C arrays.
<BR>
<P>
<CENTER><B>Table 10.3. Standard array structures.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=122><I>Structure</I></TD><TD WIDTH=154><I>Contents</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfByte</TD><TD WIDTH=154>char body[1]</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayofChar</TD><TD WIDTH=154>unicode body[1]
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfShort</TD><TD WIDTH=154>signed short body[1]
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfInt</TD><TD WIDTH=154>long body[1]</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfLong</TD><TD WIDTH=154>int64_t body[1]
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfFloat</TD><TD WIDTH=154>float body[1]
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfDouble</TD><TD WIDTH=154>double body[1]
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfArray</TD><TD WIDTH=154>JHandle *(body[1])
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfObject</TD><TD WIDTH=154>HObject *(body[1])
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=122>ArrayOfString</TD><TD WIDTH=154>HString *(body[1])
</TD></TR>
</TABLE></CENTER>
<P>
<P>
In contrast to JHandle and array pointers, the Java basic types
are passed and referenced as direct C types. Table 10.4 displays
all the basic Java types and their corresponding C representation.
<BR>
<P>
<CENTER><B>Table 10.4. C representation of Java basic types in
Windows 95.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=90><I>Java Type</I></TD><TD WIDTH=131><I>C Representation</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>boolean</TT>
</TD><TD WIDTH=131>long</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>char</TT></TD>
<TD WIDTH=131>unicode</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>short</TT></TD>
<TD WIDTH=131>short</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>int</TT></TD>
<TD WIDTH=131>long</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>long</TT></TD>
<TD WIDTH=131>int64_t</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>float</TT></TD>
<TD WIDTH=131>float</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT>double</TT></TD>
<TD WIDTH=131>double</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
All the type information in this chapter is specific to Windows 95. The Java type representations may be different on another platform. It is best to run <TT>javah</TT> on the Demonstration class to verify the C representations when working on a different platform. In addition, all the macros and structures discussed can be found in the Java header files in the Java/include directory. These files are specific to a given platform and, as such, should be consulted when performing native method work.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now that you understand the C side of Java data, it's time to
generate the code that interfaces Java to C.
<H3><A NAME="TheStubsCode">The Stubs Code</A></H3>
<P>
Run the following command on the Demonstration class:
<BLOCKQUOTE>
<TT>javah -stubs Demonstration</TT>
</BLOCKQUOTE>
<P>
The output will be a C file in the current directory. Listing
10.3 shows the result.
<HR>
<P>
<B>Listing 10.3. The output of </B><TT><B>javah
-stubs Demonstration</FONT></B></TT><B>.<BR>
</B>
<BLOCKQUOTE>
<TT>/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;StubPreamble.h&gt;<BR>
<BR>
/* Stubs for class Demonstration */<BR>
/* SYMBOL: &quot;Demonstration/method1()V&quot;, Java_Demonstration_method1_stub
*/<BR>
declspec(dllexport) stack_item *<BR>
 Java_Demonstration_method1_stub(stack_item *_P_,struct execenv
*_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern
void Demonstration_method1(void *);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)
Demonstration_method1(_P_[0].p);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
_P_;<BR>
}<BR>
/* SYMBOL: &quot;Demonstration/method2(ZBCS)I&quot;, Java_Demonstration_method2_stub
*/<BR>
declspec(dllexport) stack_item *<BR>
 Java_Demonstration_method2_stub(stack_item *_P_,struct execenv
*_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern
long Demonstration_method2(void *,long,long,long,long);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_P_[0].i
= Demonstration_method2(_P_[0].p,((_P_[1].i)),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_P_[2].i)),((_P_[3].i)),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_P_[4].i)));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
_P_ + 1;<BR>
}<BR>
/* SYMBOL: &quot;Demonstration/method3([B[Z)[B&quot;, Java_Demonstration_method3_stub
*/<BR>
declspec(dllexport) stack_item *<BR>
 Java_Demonstration_method3_stub(stack_item *_P_,struct execenv
*_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern
long Demonstration_method3(void *,void *,void *);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_P_[0].i
= Demonstration_method3(_P_[0].p,((_P_[1].p)),((_P_[2].p)));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
_P_ + 1;<BR>
}<BR>
/* SYMBOL: &quot;Demonstration/method4(IJFD)[Ljava/lang/String;&quot;,
<BR>
Java_Demonstration_method4_stub */<BR>
declspec(dllexport) stack_item *<BR>
 Java_Demonstration_method4_stub(stack_item *_P_,struct execenv
*_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java8
_t2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java8
_t4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern
long Demonstration_method4(void *,long,int64_t,float,double);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_P_[0].i
= Demonstration_method4(_P_[0].p,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_P_[1].i)),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GET_INT64(_t2, _P_+2),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((_P_[4].f)),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GET_DOUBLE(_t5, _P_+5));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
_P_ + 1;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
This file contains the stub functions for each of the four native
methods. It is the stub's job to translate Java data structures
into a C format. Once this is done, the stub will then enter your
C function. Sometimes the stub will have to do a little extra
work to make the transition. For example, take a look at <TT>method4</TT>'s
stub. The Java stack is made up of 32-bit words. Java data types
<TT>long</TT> and <TT>double</TT>
each command 64 bits of storage. The stub code calls &quot;helper&quot;
functions to extract the data from the Java stack. The stubs will
perform all the work necessary, no matter how complex, to interface
the Java stack to C.
<P>
The other interesting feature of the stub module is the <TT>SYMBOL</TT>
comment at the top of each method. Java uses a system of method
&quot;signatures&quot; to identify functions. The signature contains
the method arguments and the return type; the symbols are explained
in Table 10.5.<BR>
<P>
<CENTER><B>Table 10.5. Method signature symbols.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=167><I>Type</I></TD><TD WIDTH=149><CENTER><I>Signature Character</I></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>byte</TT></TD>
<TD WIDTH=149><CENTER>B</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>char</TT></TD>
<TD WIDTH=149><CENTER>C</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>class</TT></TD>
<TD WIDTH=149><CENTER>L</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>end of class</TT>
</TD><TD WIDTH=149><CENTER>;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>float</TT></TD>
<TD WIDTH=149><CENTER>F</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>double</TT>
</TD><TD WIDTH=149><CENTER>D</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>function</TT>
</TD><TD WIDTH=149><CENTER>(</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>end of function</TT>
</TD><TD WIDTH=149><CENTER>)</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>int</TT></TD>
<TD WIDTH=149><CENTER>I</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>long</TT></TD>
<TD WIDTH=149><CENTER>J</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>short</TT></TD>
<TD WIDTH=149><CENTER>S</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>void</TT></TD>
<TD WIDTH=149><CENTER>V</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>boolean</TT>
</TD><TD WIDTH=149><CENTER>Z</CENTER></TD></TR>
</TABLE></CENTER>
<P>
<P>
Signatures are important because they enable you to make calls
back into the Java system. If you know the class, name, and signature
of a method, then these elements can be used to invoke the Java
method from within a C library. The format of a signature is as
follows:
<BLOCKQUOTE>
<TT>&quot;package_name/class_name/method_name(args*)return_type&quot;</TT>
</BLOCKQUOTE>
<P>
Arguments can be any combination of the characters in Table 10.5.
Class name arguments are written like this:
<BLOCKQUOTE>
<TT>Lclass_name;</TT>
</BLOCKQUOTE>
<P>
The semicolon signals the end of the class name, just as the right
(closing) parenthesis signals the end of an argument list. Arrays
are followed by the array type:
<BLOCKQUOTE>
<TT>[B for an array of bytes<BR>
[Ljava/langString; for an array of objects (in this case, Strings)</TT>
</BLOCKQUOTE>
<P>
The Demonstration class is not actually going to be used; it's
merely a convenient tool to demonstrate the C features of Java's
runtime environment. Now it's time to move on to the chapter project
and some actual native method code.
<H2><A NAME="ChapterProjectADatabaseInterfaceLi"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project: A Database Interface Library Using ODBC</FONT></A></H2>
<P>
The goal of this project is to be able to read from a database.
Although this project uses ODBC for its database access layer,
any embedded SQL routines could be used. The database query routine
has been separated from the Java return logic within the native
method. Any database access method could easily be substituted.
In fact, if you don't have ODBC installed, a synthetic query routine
is supplied on the CD-ROM in the file FakeDatabaseImpl.c.
<P>
The project will consist of two classes and an interface library.
A container class will be used to house the query statement and
resulting data, and a second class called Database will perform
all the native methods.
<P>
Listing 10.4 lays out the SQLStmt class. The native method library
reads and writes directly to the variables in this container class.
<HR>
<BLOCKQUOTE>
<B>Listing 10.4. The SQLStmt class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.lang.*;<BR>
import DBException;<BR>
<BR>
/**<BR>
 * Class to contain an SQL statement and resulting data<BR>
 */<BR>
public class SQLStmt<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// The query string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String sqlStmt = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// The actual data from the query<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private String result[][];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int nRows, nCols;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// True if the query is successful<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean query = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * The lone constructor, you must supply
a query<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * string to use this constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param stmt contains the query to execute
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SQLStmt(String stmt)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlStmt = stmt;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Statement:
&quot; + stmt);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the number of rows in a query
data set<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception DBException if no query
has been made<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int numRows()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !query )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;No active query&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nRows;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the number of cols in a query
data set<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception DBException if no query
has been made<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int numCols()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !query )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;No active query&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nCols;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Retreive the contents of a row.&nbsp;&nbsp;Each
column<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * is separated from the others by a pipe
'|' character.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param row is the row to retreive<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception DBException if invalid row
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getRow(int row)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !query )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;No active query&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( row
&gt;= nRows )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;Row out of bounds&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String buildResult
= new String(&quot;&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int x =
0; x &lt; nCols; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buildResult
+= (result[row])[x] + &quot; |&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return buildResult;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Retreive the contents of a column.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param row, col is the column to retreive
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception DBException if invalid row
or column<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getColumn(int row, int col)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !query )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;No active query&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( row
&gt;= nRows )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;Row out of bounds&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( col
&gt;= nCols )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new DBException(&quot;Column out of bounds&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result[row][col];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void allDone(String str)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Display the contents of the statement
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String toString()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s = new
String();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( query ==
false )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
+= sqlStmt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; nRows; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
+= getRow(x) + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(DBException de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(de);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The SQLStmt class has public methods to enable extracting query
data in an orderly manner: <TT>numRows()</TT>,
<TT>numCols()</TT>, <TT>getRow()</TT>,
and <TT>getColumn()</TT>. SQLStmts
are two-way objects-they hold both the input and the output data.
The output is contained in a two-dimensional array of Strings.
This scheme forces the database interface library to translate
all table columns into String format.
<P>
A new exception has been defined with this class. It can be found
on this book's CD-ROM in the file DBException.java. This exception
is thrown by the SQLStmt class when a request is made, but no
query has been attempted. The Database class, discussed in the
following paragraphs, also throws DBExceptions.
<P>
The method <TT>allDone()</TT> will
be called by the native library and gives the library a convenient
way to print. It serves no other purpose.
<P>
Although the SQLStmt class contains all the database information,
it does not actually interface with the native library. For this
task, the Database class is used. This class is much simpler than
the data container; its chief role is to interface with the native
methods. Listing 10.5 shows the Database class.
<HR>
<BLOCKQUOTE>
<B>Listing 10.5. The Database class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.*;<BR>
import java.io.*;<BR>
import SQLStmt;<BR>
import DBException;<BR>
<BR>
/**<BR>
 * Class to allow access to the database library<BR>
 */<BR>
public class Database<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Table name to use (ODBC data source)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String tableName;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Lone constructor.&nbsp;&nbsp;A data
source must be passed.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param s holds the name of the data
source to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Database(String s)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableName = s;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Native method query<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param stmt holds the SQLStmt class
to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception DBException is thrown on
any error<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized native void query(SQLStmt
stmt)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized native SQLStmt sql(String
stmt)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws DBException;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;static<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.loadLibrary(&quot;Database&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The first native method uses an SQLStmt object for both input
and output, and the second native method uses a String input and
returns an SQLStmt object as output. It is the native library's
task to create and fill the output object. Both native methods
are marked as synchronized because the library implementation
is single-threaded. Nothing in Java precludes making re-entrant
native libraries, but the database library uses global variables
for storage. This makes it necessary to protect the library from
being entered by more than one thread at a time.
<P>
As with the Demonstration class, the first step is to compile
the classes and pass them to the <TT>javah</TT>
tool:
<BLOCKQUOTE>
<TT>javac SQLStmt.java Database.java<BR>
javah SQLStmt Database</TT>
</BLOCKQUOTE>
<P>
Here is the output for the SQLStmt class:
<BLOCKQUOTE>
<TT>/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;native.h&gt;<BR>
/* Header for class SQLStmt */<BR>
<BR>
#ifndef _Included_SQLStmt<BR>
#define _Included_SQLStmt<BR>
struct Hjava_lang_String;<BR>
<BR>
typedef struct ClassSQLStmt {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct Hjava_lang_String *sqlStmt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct HArrayOfArray *result;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long nRows;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long nCols;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*boolean*/ long query;<BR>
} ClassSQLStmt;<BR>
HandleTo(SQLStmt);<BR>
<BR>
#ifdef __cplusplus<BR>
extern &quot;C&quot; {<BR>
#endif<BR>
#ifdef __cplusplus<BR>
}<BR>
#endif<BR>
#endif</TT>
</BLOCKQUOTE>
<P>
Notice how the two-dimensional array has been translated into
HArrayOfArray. SQLStmt doesn't have any native methods, though
the <TT>javah</TT> tool still places
the surrounding <TT>ifdef cplusplus</TT>
statements where native methods would normally appear.
<P>
Here is the output for the Database class:
<BLOCKQUOTE>
<TT>/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;native.h&gt;<BR>
/* Header for class Database */<BR>
<BR>
#ifndef _Included_Database<BR>
#define _Included_Database<BR>
struct Hjava_lang_String;<BR>
<BR>
typedef struct ClassDatabase {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct Hjava_lang_String *tableName;<BR>
} ClassDatabase;<BR>
HandleTo(Database);<BR>
<BR>
#ifdef __cplusplus<BR>
extern &quot;C&quot; {<BR>
#endif<BR>
struct HSQLStmt;<BR>
__declspec(dllexport) void Database_query(struct HDatabase *,struct
HSQLStmt *);<BR>
__declspec(dllexport) struct HSQLStmt *Database_sql(struct HDatabase
*,struct Hjava_lang_String *);<BR>
#ifdef __cplusplus<BR>
}<BR>
#endif<BR>
#endif</TT>
</BLOCKQUOTE>
<P>
The two native methods appear at the bottom of the header. Since
this file has native methods, it needs to have stub code generated
for it. The next step is to execute the <TT>javah</TT>
tool with the stubs option:
<BLOCKQUOTE>
<TT>javah -stubs Database<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There is no rule about what the stub module must be called. You can use the <TT>-ofilename</TT> option to override <TT>javah</TT>'s default naming convention. This option is also useful for forcing the output from multiple classes into a single stubs file: <TT>javah -stubs -ostubs.c class1 class2 class3</TT>. This can be done as long as all the native methods for classes 1, 2, and 3 will appear in the same native library.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Here is the stub module for the Database class:
<BLOCKQUOTE>
<TT>/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;StubPreamble.h&gt;<BR>
<BR>
/* Stubs for class Database */<BR>
/* SYMBOL: &quot;Database/query(LSQLStmt;)V&quot;, Java_Database_query_stub
*/<BR>
declspec(dllexport) stack_item *Java_Database_query_stub(stack_item
*_P_,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct execenv *_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;extern void Database_query(void *,void
*);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(void) Database_query(_P_[0].p,((_P_[1].p)));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return _P_;<BR>
}<BR>
/* SYMBOL: &quot;Database/sql(Ljava/lang/String;)LSQLStmt;&quot;,
Java_Database_sql_stub */<BR>
declspec(dllexport) stack_item *Java_Database_sql_stub(stack_item
*_P_,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct execenv *_EE_) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;extern long Database_sql(void *,void *);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;_P_[0].i = Database_sql(_P_[0].p,((_P_[1].p)));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return _P_ + 1;<BR>
}</TT>
</BLOCKQUOTE>
<P>
All that's left to do is to write the implementation module for
the Database stub. In the interest of having a comprehensible
project layout, the name of this module will be DatabaseImpl.c.
Listing 10.6 shows only the code that manipulates the Java structures.
The entire source code for DatabaseImpl, including the ODBC calls,
can be found on the CD-ROM.
<HR>
<BLOCKQUOTE>
<B>Listing 10.6. Java interface functions from DatabaseImpl.c.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#include &lt;StubPreamble.h&gt;<BR>
#include &lt;javaString.h&gt;<BR>
#include &quot;Database.h&quot;<BR>
#include &quot;SQLStmt.h&quot;<BR>
#include &lt;stdio.h&gt;<BR>
#include &lt;sql.h&gt;<BR>
<BR>
#define MAX_WIDTH&nbsp;&nbsp;&nbsp;&nbsp; 50<BR>
#define MAX_COLS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20<BR>
#define MAX_ROWS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200<BR>
<BR>
static SQLSMALLINT nRows, nCols;<BR>
static SQLINTEGER namelen[ MAX_COLS ];<BR>
static char *cols[ MAX_COLS ];<BR>
static char *rows[ MAX_ROWS ][ MAX_COLS ];<BR>
<BR>
bool_t throwDBError(char *description)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SignalError(0, &quot;DBException&quot;,
description);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return FALSE;<BR>
}<BR>
<BR>
/*<BR>
 * Extract from local storage into the passed String array.<BR>
 */<BR>
void getTableRow(struct HDatabase *db,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HArrayOfString
*result,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long
row)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int col;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;char *st;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( col = 0; col &lt; nCols; col++ )
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st = rows[row][col];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(result)-&gt;body[col]
= makeJavaString(st, strlen(st));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
/*<BR>
 * Perform a database lookup using the passed HSQLStmt.<BR>
 */<BR>
void Database_query(struct HDatabase *db,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HSQLStmt *stmt)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;HArrayOfArray *all;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;HString *s;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Read from the database into local storage
*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( doQuery(db, stmt) == FALSE )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeStorage();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* If we have data, store it in the class
*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( nRows != 0 &amp;&amp; nCols != 0
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Allocate the
row array (1st dimension) */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all = (HArrayOfArray
*)ArrayAlloc(T_CLASS, nRows);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !all )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeStorage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;query
= FALSE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throwDBError(&quot;Unable
to allocate result array&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set the array
into the HSQLStmt class object */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;result
= all;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* For each row,
store the result strings */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( x = 0; x
&lt; nRows; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
Allocate the columns (2nd dimension) */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all-&gt;obj-&gt;body[x]
= ArrayAlloc(T_CLASS, nCols);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
Extract the data from local storage into the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* HSQLStmt object.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getTableRow(db,
(HArrayOfString *)all-&gt;obj-&gt;body[x], x);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set final variables
in the object to reflect the query */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;query
= TRUE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;nRows
= nRows;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;nCols
= nCols;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Print the results
of the query by calling<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * allDone( HSQLStmt.toString()
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = (HString *)execute_java_dynamic_method(0,
(HObject *)stmt,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;toString&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;()Ljava/lang/String;&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute_java_dynamic_method(0,
(HObject *)stmt, &quot;allDone&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(Ljava/lang/String;)V&quot;,
s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(stmt)-&gt;query
= FALSE;<BR>
}<BR>
<BR>
/*<BR>
 * Create a HSQLStmt class object and pass it to the<BR>
 * query routine.<BR>
 */<BR>
struct HSQLStmt *Database_sql(struct HDatabase *db,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
Hjava_lang_String *s)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;HObject *ret;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Create the object by calling its constructor
*/<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ret = execute_java_constructor(0, &quot;SQLStmt&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FindClass(
0, &quot;SQLStmt&quot;, TRUE),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(Ljava/lang/String;)&quot;,
s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( !ret ) return NULL;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Database_query(db, (HSQLStmt *)ret);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (HSQLStmt *)ret;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>doQuery()</TT> function merely
uses ODBC to read a sample database into the local two-dimensional
array: rows. The storage for the array is allocated as needed,
though the total possible size is limited by the constants <TT>MAX_ROWS</TT>
and <TT>MAX_COLS</TT>. The <TT>doQuery()</TT>
function also fills in the variables <TT>nRows</TT>
and <TT>nCols</TT> to reflect the
storage allocated in the local array. Once the data has been extracted
from the database, it's time to move it into the SQLStmt container
object.
<P>
The native method <TT>Database_query()</TT>
performs most of the interesting work. After making sure that
<TT>doQuery()</TT> returns some data,
the function first allocates a Java array to store the rows:
<BLOCKQUOTE>
<TT>all = (HArrayOfArray *)ArrayAlloc(T_CLASS,
nRows);</TT>
</BLOCKQUOTE>
<P>
Unlike C, Java two-dimensional arrays are not allocated together.
In Java, a two-dimensional array is actually an array of an array.
The Java function <TT>ArrayAlloc()</TT>
is used to make an array. The first parameter is the type of data
that the array will contain; the second parameter is the array
length. A JHandle pointer is returned. Since this is the first
dimension of a two-dimensional array, it will contain arrays.
<TT>T_CLASS</TT> represents any object,
including arrays. It signals that the array contains Jhandles.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The rows of a two-dimensional Java array do not have to contain the same number of columns. Some rows could even be NULL. You should be aware of this when dealing with multidimensional arrays. The database library will make sure that the number of columns is consistent throughout the array.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Assuming everything allocated successfully, the JHandle is placed
into the SQLStmt class with the following line:
<BLOCKQUOTE>
<TT>unhand(stmt)-&gt;result = all;</TT>
</BLOCKQUOTE>
<P>
If there is an error, the native method will throw a DBException
by using the function <TT>throwDBError()</TT>.
A Java function called <TT>SignalError()</TT>
is used to throw the actual exception:
<BLOCKQUOTE>
<TT>SignalError(0, &quot;DBException&quot;,
description);</TT>
</BLOCKQUOTE>
<P>
The first parameter is a structure called <TT>execenv</TT>.
Zero is substituted to cause the current environment to be used.
The next parameter is the name of the exception, and the final
parameter is the exception description. The preceding code line
is equivalent to the Java line:
<BLOCKQUOTE>
<TT>throw new DBException(description);<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Whenever the <TT>execenv</TT> structure (or <TT>ExecEnv</TT>) is called for, you may substitute NULL or 0. This causes the Java runtime to use the current environment. The actual environment pointer is supplied to the stub methods as parameter <TT>_EE_</TT>, but it is not passed into the native implementations.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
An additional array is allocated for each row; this second dimension
array has <TT>nCols</TT> members.
The array will contain String objects, so <TT>T_CLASS</TT>
is again passed into <TT>ArrayAlloc()</TT>.
The created array is passed into <TT>getTableRow()</TT>
to be filled in with the table data.
<P>
The <TT>getTableRow()</TT> function
creates a Java String object for each column's data:
<BLOCKQUOTE>
<TT>unhand(result)-&gt;body[col] = makeJavaString(st,
strlen(st));</TT>
</BLOCKQUOTE>
<P>
The Java function <TT>makeJavaString()</TT>
takes a C <TT>char</TT> pointer and
the string length as parameters. It returns a JHandle to an equivalent
Java String, then the created String is stored. There is a corollary
function for <TT>makeJavaString()</TT>:
<BLOCKQUOTE>
<TT>char *makeCString(Hjava_lang_String *s);</TT>
</BLOCKQUOTE>
<P>
This function converts a Java String back into a C string. Storage
for the string is allocated from the Java heap. You should keep
the pointer in a Java class variable somewhere to prevent the
C string from being garbage-collected. The following is an alternative
method:
<BLOCKQUOTE>
<TT>char *allocCString(Hjava_lang_String
*s);</TT>
</BLOCKQUOTE>
<P>
This function allocates the C string from the local heap by using
<TT>malloc()</TT>. You are responsible
for freeing the resulting pointer when you are finished with it.
<P>
When all the rows have been created, the method tries to print
the result. Originally, I printed the results from within Java,
but I wanted to show you an example of C calling Java. The call
was moved into the native library for this purpose.
<H3><A NAME="CallingBackIntoJava">Calling Back Into Java</A></H3>
<P>
Remember the discussion of method signatures? This is where they
are used. Any Java method can be invoked from C:
<BLOCKQUOTE>
<TT>s = (HString *)execute_java_dynamic_method(0,
(HObject *)stmt,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;toString&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;()Ljava/lang/String;&quot;);</TT>
</BLOCKQUOTE>
<P>
The function <TT>execute_java_dynamic_method()</TT>
accomplishes the invocation. A JHandle to the object is passed,
along with the method name and its signature. Without the correct
signature, Java can't find the method to execute. The invoked
method can return any normal Java value. In this case, a String
was returned. Do you recognize the previous call? Its Java equivalent
would be the following:
<BLOCKQUOTE>
<TT>String s = stmt.toString();</TT>
</BLOCKQUOTE>
<P>
There are actually three functions for calling back into Java:
<BLOCKQUOTE>
<TT>Hobject *<B>execute_java_constructor</B>(ExecEnv
*,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*classname,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassClass
*cb,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*signature, ...);<BR>
<BR>
long <B>execute_java_statuc_method</B>(ExecEnv *, ClassClass *db,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*method_name,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*signature, ...);<BR>
<BR>
long <B>execute_java_dynamic_method</B>(ExecEnv *, Hobject *,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*method_name,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
*signature, ...);</TT>
</BLOCKQUOTE>
<P>
You must know whether the method is static or dynamic because
calling the wrong function will yield an exception. The ellipses
at the end of each parameter list indicate a variable number of
additional arguments, and the signature determines how many additional
parameters there are.
<P>
Structure ClassClass describes all the attributes of a Java class.
You can find the <TT>ClassClass</TT>
pointer from the JHandle structure. In addition, there is a Java
&quot;helper&quot; function to find the ClassClass structure of
a Java class:
<BLOCKQUOTE>
<TT>ClassClass *<B>FindClass</B>(struct execenv
*, char *name, bool_t resolve);</TT>
</BLOCKQUOTE>
<P>
The second native method <TT>Database_sql()</TT>
uses <TT>FindClass()</TT> to construct
an instance of the SQLStmt class.
<H3><A NAME="ConstructingJavaObjectsfromC">Constructing Java Objects
from C</A></H3>
<P>
<TT>Database_sql()</TT> is passed
a String object, but it needs to return an SQLStmt object. The
return object must be created. Calling <TT>execute_java_constructor()</TT>
will both create and initialize the desired object, but what is
the signature of a constructor? The following routine will dump
the contents of a class's method table:
<BLOCKQUOTE>
<TT>void dumpMethodTable(ClassClass *cb)
<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct methodblock *mptr;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, &quot;There are %d methods
in class %s\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cb-&gt;methods_count,
cb-&gt;name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mptr = cb-&gt;methods;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( x = 0; x &lt; cb-&gt;methods_count;
x++, mptr++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&quot;Method %02d: name: '%s'&nbsp;&nbsp;signature: '%s'\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,
mptr-&gt;fb.name, mptr-&gt;fb.signature);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
void dumpMethods(HObject *han)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dumpMethodTable(han-&gt;methods-&gt;classdescriptor);
<BR>
}</TT>
</BLOCKQUOTE>
<P>
Dumping SQLStmt's method table yields the following:
<BLOCKQUOTE>
<TT>There are 7 methods in class SQLStmt
<BR>
Method 0: name: '&lt;init&gt;'&nbsp;&nbsp;&nbsp;&nbsp;signature:
'(Ljava/lang/String;)V'<BR>
Method 1: name: 'numRows'&nbsp;&nbsp; signature: '()I'<BR>
Method 2: name: 'numCols'&nbsp;&nbsp; signature: '()I'<BR>
Method 3: name: 'getRow'&nbsp;&nbsp;&nbsp;&nbsp;signature: '(I)Ljava/lang/String;'
<BR>
Method 4: name: 'getColumn' signature: '(II)Ljava/lang/String;'
<BR>
Method 5: name: 'allDone'&nbsp;&nbsp; signature: '(Ljava/lang/String;)V'
<BR>
Method 6: name: 'toString'&nbsp;&nbsp;signature: '()Ljava/lang/String;'</TT>
</BLOCKQUOTE>
<P>
The signature of the constructor seems as though it should be
<TT>&quot;(Ljava/lang/String;)V&quot;</TT>.
This is not actually the case. Using this signature will yield
an exception:
<BLOCKQUOTE>
<TT>java.lang.NoSuchMethodError</TT>
</BLOCKQUOTE>
<P>
The correct signature leaves off the trailing <I>V</I>.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The signature of a constructor has NO return type at all. It should always be written as &quot;(...)&quot;, not as &quot;(...)V&quot;.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
After the constructor is run, the object is passed into the original
query routine before it is returned to the caller.
<H3><A NAME="CreatingtheLibrary">Creating the Library</A></H3>
<P>
The final step is to compile the library. You must have Microsoft
Visual C++ Version 2.<I>x</I> or above. The libraries on the CD-ROM
were compiled with Visual C++ 4.0. To compile the database library,
issue the following command:
<BLOCKQUOTE>
<TT>cl Database.c DatabaseImpl.c -FeDatabase.dll
-MD -LD odbc32.lib javai.lib</TT>
</BLOCKQUOTE>
<P>
If you don't have ODBC32 installed in your system, a synthetic
version can be made. Issue the following command to construct
the synthetic version:
<BLOCKQUOTE>
<TT>cl Database.c FakeDatabaseImpl.c -FeDatabase.dll
-MD -LD javai.lib</TT>
</BLOCKQUOTE>
<P>
Obviously, FakeDatabaseImpl.c makes no ODBC calls, but it does
supply a simulated version of the data. Both of the above commands
create the file Database.dll. The javai library provides access
to the Java runtime DLL of the same name. It should be listed
as the last library on the command line.
<P>
The Database class still needs to be integrated into the server
from <A HREF="ch9.htm" >Chapter 9</A>,  but the following Java
application is suitable for testing the library itself. It can
be found on the CD-ROM in the file TestDatabase.java.
<BLOCKQUOTE>
<TT>import Database;<BR>
<BR>
/**<BR>
 * A simple test application for exercising the Database class.
<BR>
 */<BR>
public class TestDatabase<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
database class and assign the data source<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Database db =
new Database(&quot;election.dbf&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make the a
SQL statement to execute<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLStmt stmt =
new SQLStmt(&quot;select * from election&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Execute the 1st native method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.query(stmt);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Execute the 2nd native method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.sql(&quot;select
* from election where State = 'Maryland'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (DBException
de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(de);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The database in this project has five columns: Candidate, State, Votes, % Precincts Reporting, and Electoral Votes. The database file, election.dbf, is in dBASE IV format. You will need to set up an ODBC data source called election.dbf to access this file.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now that the database access class is written, it's time to integrate
it with the client/server applet from the previous chapter.
<H2><A NAME="DatabaseServer"><FONT SIZE=5 COLOR=#FF0000>Database
Server</FONT></A></H2>
<P>
The project architecture consists of three threads. The main HTTP
server thread forms the basis of the application and provides
HTTP services. This main thread spawns a separate second thread,
called ElectionServer, whose purpose is to perform additional
server functions unrelated to HTTP. ElectionServer acts as a manager
of the DGTP transmission protocol thread and provides access to
the database. The DGTP thread is the third and final thread for
the project-it's spawned and used by the election server. The
main HTTP thread has no communication with either the election
server or its DGTP thread.
<P>
The client side mirrors the server. Instead of a HTTP server,
the client substitutes a Java-enabled browser. The browser spawns
the applet, and the applet spawns and manages the DGTPClient thread.
Figure 10.1 illustrates the overall architecture.
<P>
<A HREF="f10-1.gif" ><B>Figure 10.1 : </B><I>The project architecture.</I></A>
<P>
This project uses the DGTP protocol from <A HREF="ch9.htm" >Chapter 9</A>,
but the protocol has a major limitation that must be addressed
first. Currently, the amount of data being sent to a DGTP client
must fit within the block size of the protocol (1024 bytes). This
is not acceptable for a database server, so the protocol must
be amended to serve arbitrarily large amounts of data.
<H2><A NAME="AddingPacketAssemblytoDGTP"><FONT SIZE=5 COLOR=#FF0000>Adding
Packet Assembly to DGTP</FONT></A></H2>
<P>
Serving large data blocks isn't difficult, but it does require
some overhead costs. DGTP will use a technique called <I>chaining</I>
to send the data. Chaining simply means that large data will be
sent as a series of smaller sub-blocks; each sub-block is marked
to reflect both its position within a chain and the chain itself.
In addition, the sub-blocks are marked as first-in-chain, middle-in-chain,
or last-in-chain, depending on their chain position. Keep in mind
that datagrams are still being used to send the sub-blocks, so
it is quite possible for the sub-blocks to arrive at the receiver
in a different order than they were sent.
<P>
When a chained sub-block is received, it will have to be queued
to a packet assembler to reconstruct the original chain. Only
when all the sub-blocks are received can the data be forwarded.
A <I>packet assembler</I> acts as a middle man-assembling packet
fragments into a single continuous packet.
<P>
Each transmission request is checked for size before it is sent.
If the size will not fit into a single packet, the data block
is forwarded to a separate send routine for chaining. This new
routine will use a new DGTP command for its transmissions:
<UL>
<LI><TT>MDATA <I>chain sub-block first-middle-or-last
length</I></TT>
</UL>
<P>
The new format for DGTP send operations is shown in Listing 10.7.
<HR>
<BLOCKQUOTE>
<B>Listing 10.7. New DGTP send operations.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send the block of data to the specified
address.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param dest contains the address to
send to<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param data is the data to send<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param srcOffset is where to start
sending from<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param length is the amount of data
to send<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void sendData(ClientAddr dest,
byte[] data,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int srcOffset, int length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String hdr = new
String(&quot;DGTP/&quot; + DGTPver + &quot; &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr += &quot;DATA
&quot; + length + &quot;\r\n\r\n&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (hdr.length()
+ length) &gt; PSIZE )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;multiPartSend(dest,
data, srcOffset, length);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
sendbuf = new byte[hdr.length() + length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr.getBytes(0,
hdr.length(), sendbuf, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(data,
srcOffset, sendbuf, hdr.length(), length);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
sendPacket = new DatagramPacket(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendbuf,
sendbuf.length, dest.address, dest.port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(sendPacket);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException:
Unable to send. &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send the a large block of data to the
specified address.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Large means bigger than the largest
packet size (PSIZE).<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param dest contains the address to
send to<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param data is the data to send<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param srcOffset is where to start
sending from<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param length is the amount of data
to send<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void multiPartSend(ClientAddr dest,
byte[] data,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
srcOffset, int length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int multiNum =
chainNum++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blockNum =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int sentSoFar
= 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( sentSoFar
&lt; length )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
chain;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
hdr = new String(&quot;DGTP/&quot; + DGTPver + &quot; &quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr
+= &quot;MDATA &quot; + multiNum + &quot; &quot; + blockNum;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
max = current header + sizeof(&quot; xic &quot;) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sizeof(&quot;1024 &quot;) + sizeof(&quot;\r\n\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
maxHdrSize = hdr.length() + 5 + MAX_PSIZE_STRING + 4;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Determine the biggest block we can send<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
blockLength = PSIZE - maxHdrSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( blockLength &lt;= 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error:
PSIZE is too small&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Header
is &quot; + maxHdrSize + &quot; bytes long&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If block is more than we need, make it fit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( (blockLength + sentSoFar) &gt;= length )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockLength
= length - sentSoFar;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain
= &quot; lic &quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // last-in-chain
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( blockNum == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain
= &quot; fic &quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
first-in-chain<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain
= &quot; mic &quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
middle-in-chain<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
finish wrting the header<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr
+= chain + blockLength + &quot;\r\n\r\n&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
sendbuf = new byte[hdr.length() + blockLength];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hdr.getBytes(0,
hdr.length(), sendbuf, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(data,
srcOffset + sentSoFar,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sendbuf, hdr.length(), blockLength);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
sendPacket = new DatagramPacket(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendbuf,
sendbuf.length, dest.address, dest.port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(sendPacket);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException:
Unable to send. &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Update counters<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockNum++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sentSoFar
+= blockLength;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The DGTPClient class also has to be changed to work with the new
transmission scheme. Listing 10.8 shows only the changed methods.
<HR>
<BLOCKQUOTE>
<B>Listing 10.8. Changes to DGTPClient in support of chaining.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public DGTPClient(LiveDataNotify
handler)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buildThread
= new ClientPacketAssembler(this);<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
<BR>
</B></B>&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
packet = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regThread.start();
<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buildThread.start();
<BR>
</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<BR>
</B>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void parsePacketData(DatagramPacket
packet)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( cmd.equals(&quot;MDATA&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handleNewMultiData(cmds,
is);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void handleNewMultiData(StringTokenizer
cmds, DataInputStream is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws ProtocolException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int packetNum
= Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int subBlockNum
= Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean last =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( cmds.nextToken().equals(&quot;lic&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length = Integer.valueOf(cmds.nextToken()).intValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] data =
new byte[length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.readFully(data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buildThread.newSubBlock(packetNum,
subBlockNum, last, data);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (EOFException
eof)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Server
packet too short: &quot; + eof);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Error
while reading server data: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The actual tracking and assembly of chains is done in the ClientPacketAssembly
thread. The DGTPClient merely assembles the sub-block and its
information, then passes the data into the assembly thread, shown
in Listing 10.9.
<HR>
<BLOCKQUOTE>
<B>Listing 10.9. The ClientPacketAssembler class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.*;<BR>
import java.util.*;<BR>
import java.net.*;<BR>
import java.io.*;<BR>
import DGTPClient;<BR>
<BR>
/**<BR>
 * Packet assembler tracks and assembles multi part data blocks.
<BR>
 */<BR>
public class ClientPacketAssembler extends Thread<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static final int TIMEOUT = 30000;&nbsp;&nbsp;&nbsp;&nbsp;//
in milliseconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static final int SLEEP_TIME =
5000;&nbsp;&nbsp;// in milliseconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DGTPClient ct = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Hashtable partials = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ClientPacketAssembler(DGTPClient
cthread)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct = cthread;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partials = new
Hashtable();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Thread.currentThread().sleep(SLEEP_TIME);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(InterruptedException ie)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;InterruptedException:
in packet assembler thread: &quot; + ie);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkTimers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * For each partial packet being tracked,
decrement the timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * and kill the packet if it has expired.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void checkTimers()
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (Enumeration
e = partials.elements(); e.hasMoreElements();)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PartialPacket pp = (PartialPacket)e.nextElement();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( pp.timer &gt; 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pp.timer -= SLEEP_TIME;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( pp.timer &lt;= 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
partials.remove( new Integer(pp.packetNum) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ct.notifyCompleteBlock(null, true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new sub block.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param packetNum contains the pnum
being assembled<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param subBlockNum contains the bnum
within this pnum<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param last is true if this is the
last in a series<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param data contains the data for this
sub block.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void newSubBlock(int
packetNum, int subBlockNum,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean
last, byte data[])<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PartialPacket
pp;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp = (PartialPacket)partials.get(new
Integer(packetNum));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( pp == null
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp
= new PartialPacket(packetNum);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partials.put(new
Integer(packetNum), pp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp.addSubBlock(subBlockNum,
last, data);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( pp.complete()
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.notifyCompleteBlock(pp.getData(),
false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partials.remove(new
Integer(packetNum));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
getting data: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp.timer
= TIMEOUT;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
This class is structured to handle multiple chains simultaneously.
A hash table is used to store each chain's assembly. The key to
the hash table is the packet number, but it can't be passed directly
to the hash table because <TT>int</TT>
is a base type, not a class object. The <TT>int</TT>
must first be placed in an Integer class wrapper.
<P>
The ClientPacketAssembler class  is a thread so that it can detect
timeouts. The <TT>run()</TT> method
checks for timeouts on each packet under assembly. Every time
a sub-block is received, the sub-block's chain timer is reset.
If the timer expires before a new sub-block arrives, the chain
is killed. This protects the client if one of a chain's sub-blocks
is lost. When a chain is killed, the DGTPClient is notified through
the same function used to signal complete chains:
<BLOCKQUOTE>
<TT>ct.notifyCompleteBlock(null, true);</TT>
</BLOCKQUOTE>
<P>
The second parameter to the above function is a boolean error
flag. If it is true, the first parameter is undefined. This flag
is also added to the <TT>recvNewData()</TT>
method within the LiveDataNotify interface:
<BLOCKQUOTE>
<TT>public interface LiveDataNotify<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getDestHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int getDestPort();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void recvNewData(byte[] newDataBlock,
<B>boolean error</B>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void connectRefused();<BR>
}</TT>
</BLOCKQUOTE>
<P>
A new command has been added to the client to facilitate recovery
from lost chains. In each application, you must decide what action
to take if it loses a chain, but one option is to send a <TT>REFRESH</TT>
request to the server.
<P>
When a new sub-block arrives, the assembler checks to see whether
a chain has been started. If no previous instance of the chain
exists, a PartialPacket class, shown in Listing 10.10, is created
to track the new chain. The current sub-block is then added to
the chain.
<HR>
<BLOCKQUOTE>
<B>Listing 10.10. The PartialPacket tracking class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* A private class for assembling packets<BR>
&nbsp;*/<BR>
class PartialPacket<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int timer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int packetNum;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int totalBlocks;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int totalSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Hashtable blocks;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private BitSet recvd;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public PartialPacket(int pnum)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packetNum = pnum;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalBlocks =
-1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalSize = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocks = new Hashtable();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvd = new BitSet();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Handle a new sub block<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param subBlockNum is the strand being
added<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param last is true if this is the
last block<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param data contains the data for this
strand<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void addSubBlock(int subBlockNum,
boolean last, byte data[])<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Ignore duplicate
packets, shouldn't occur<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( recvd.get(subBlockNum)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if last block,
we can set the number of blocks<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for this packet
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( last )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalBlocks
= subBlockNum + 1;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalSize += data.length;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvd.set(subBlockNum);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocks.put(new
Integer(subBlockNum), data);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Function to test whether a packet is
completely<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * assembled.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean complete()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( totalBlocks
!= -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; totalBlocks; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( recvd.get(x) == false )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Assembles the strands into one big
byte array.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException if packet is
not complete.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public byte[] getData()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte ret[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( complete()
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
= new byte[ totalSize ];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
bytesSoFar = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; totalBlocks; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte
data[] = (byte[])blocks.remove(new Integer(x));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( data == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IOException(&quot;Internal packet assembler error&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( data.length + bytesSoFar &gt; totalSize )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IOException(&quot;Internal packet assembler error&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(data,
0, ret, bytesSoFar, data.length);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytesSoFar
+= data.length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IOException(&quot;getData() of incomplete packet&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
PartialPacket uses a hash table of its own to track each piece
of a chain. The sub-block number is the key, and the data block
is the value. A BitSet class is used to track each piece in relation
to the whole. BitSets take up very little storage and operate
like an array of booleans. When a sub-block comes in, its bit
is set before it's added to the hash table. Once the last-in-chain
sub-block appears, the object knows how many blocks are in the
chain. The method <TT>complete()</TT>
is called to test whether the chain has all its members. When
all sub-blocks have been received, the chain is assembled by using
method <TT>getData()</TT>.
<P>
Only the DGTPServer can initiate MDATA blocks. The client is still
limited to sending data that can travel within a single DGTP packet.
<H3><A NAME="TheElectionServer">The Election Server</A></H3>
<P>
The NumUsersServer class from <A HREF="ch9.htm" >Chapter 9</A>
will be used as the basis for the ElectionServer class. If you
recall, NumUsersServer sent text commands to applets that connected
to it. There was a single command:
<UL>
<LI><TT>CLIENTS num_of_connections</TT>
</UL>
<P>
The ElectionServer adds two new commands:
<UL>
<LI><TT>RESULTS #rows #cols database_rows</TT>
<LI><TT>QUERY_RSP qnum #rows #cols database_rows</TT>
</UL>
<P>
In addition, the ElectionServer will now have to handle incoming
data blocks. The election client uses the <TT>QUERY</TT>
command:
<UL>
<LI><TT>QUERY qnum query_string</TT>
</UL>
<P>
Listing 10.11 shows the ElectionServer class.
<HR>
<BLOCKQUOTE>
<B>Listing 10.11. The ElectionServer class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.Thread;<BR>
import java.net.DatagramPacket;<BR>
import java.util.*;<BR>
import DGTPServer;<BR>
import LiveDataServer;<BR>
import ClientAddr;<BR>
<BR>
public class ElectionServer extends Thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;implements LiveDataServer<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static final int ONE_SECOND =
1000;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private DGTPServer servThread = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Database election = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private SQLStmt results = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ElectionServer(int hostPort)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread = new
DGTPServer(this, hostPort);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;election = new
Database(&quot;election.dbf&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results
= election.sql(&quot;select * from election&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (DBException
de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
&quot; + de);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Server
exiting due to lack of data&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Run method for this thread.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Issue a new query every 30 seconds.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean toggle
= false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( results !=
null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(30);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLStmt
nn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(toggle)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nn
= election.sql(&quot;select * from election&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toggle
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nn
= election.sql(&quot;select * from election &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;where
State = 'Maryland'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toggle
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized
(results)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results
= nn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendToUsers(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatResults(&quot;RESULTS&quot;,
results));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(DBException de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error:
&quot; + de);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean ValidateRegistrant(ClientAddr
user)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private routine to concatenate the
number of rows &amp; cols<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * to a response string and then add the
SQLStmt data.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * If the query was invalid, send a NULL
response.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; *<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param sql contains the data to return
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param resultType contains the initial
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private String formatResults(String resultType,
SQLStmt sql)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String ret = new
String(resultType + &quot; &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(sql)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
+= sql.numRows() + &quot; &quot; + sql.numCols() + &quot; &quot;
+ sql;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (DBException
de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret
+= &quot;0 0&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A new connection was accepted, send
the latest data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param user contains the address to
send to<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void NewRegistrant(ClientAddr user)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // broadcast
the new user<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servThread.sendToUsers(&quot;CLIENTS
&quot; + servThread.Clients.size());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // send the latest
data to only the new user<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; servThread.sendData(user,
formatResults(&quot;RESULTS&quot;, results));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void refreshRequest(ClientAddr
user)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendData(user,
formatResults(&quot;RESULTS&quot;, results));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A connection was dropped.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param user contains the address that
was dropped<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void DropRegistrant(ClientAddr
user)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// broadcast the
new number of users<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendToUsers(&quot;CLIENTS
&quot; + servThread.Clients.size());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Recv data block routine<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param newDataBlock contains the data
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param who is the original recv packet
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void recvNewData(byte[] newDataBlock,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
who)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientAddr user
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLStmt stmt =
null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String query =
new String(newDataBlock, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
cmds = new StringTokenizer(query, &quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cmds.nextToken().equals(&quot;QUERY&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
qnum = cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
sql = cmds.nextToken(&quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Processing:
&quot; + sql);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Try the query<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stmt
= election.sql(sql);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(DBException de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error:
&quot; + sql + &quot;\n&quot; + de);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user
= new ClientAddr(who.getAddress(), who.getPort());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send the response (will be NULL rsp if DBException)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendData(user,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatResults(&quot;QUERY_RSP
&quot; + qnum, stmt));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A simple sleep routine<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param a the number of SECONDS to sleep
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void sleep(int a)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.currentThread().sleep(a
* ONE_SECOND);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The run method for this thread will query the database every 30
seconds. Since this is still a demonstration applet, a simple
toggle was added to cause the data to change with each read.
<P>
The <TT>formatResults()</TT> method
accepts a String and an SQLStmt class and creates a single return
string consisting of the request type String, followed by the
number of rows and columns in the data. This is followed by the
data itself. This routine is the only method in the class that
reads an SQLStmt object. Because the thread receives connection
requests asynchronously, access to SQLStmt objects must be protected:
<BLOCKQUOTE>
<TT>synchronized(sql)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ret += sql.numRows() + &quot; &quot; +
sql.numCols() + &quot; &quot; + sql;<BR>
}</TT>
</BLOCKQUOTE>
<P>
When the thread queries the database, it will update the class
variable: <TT>results</TT>. The update
must also be synchronized to protect the update from corrupting
a transmission.
<BLOCKQUOTE>
<TT>synchronized (results)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;results = nn;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The entire method could have been protected, but good technique
keeps protected ranges to the absolute minimum possible. Protecting
entire methods will tie up the object for the time that the method
executes. It isn't necessary to protect the database access, because
the result is stored in temporary variable <TT>nn</TT>.
The only critical piece of code is the assignment itself.
<P>
In <A HREF="ch9.htm" >Chapter 9</A>, the <TT>recvNewData()</TT>
method performed no actions, but now clients can send queries
to the server for evaluation. The method first checks to make
sure the request is a valid <TT>QUERY</TT>
command. If it is, the query string is extracted from the data
along with the query number. The query is sent to the database,
and a response is formulated for the caller. If the query fails,
a normal response is sent, with the number of rows and columns
set to zero.
<H2><A NAME="ElectionClient"><FONT SIZE=5 COLOR=#FF0000>Election
Client</FONT></A></H2>
<P>
The SimpleClientApplet class will serve as the basis for the Election
class. The server needed to implement checking only for the <TT>QUERY</TT>
command, but as the client, the applet will have to parse and
display both normal <TT>RESULTS</TT>
and specific <TT>QUERY_RSP</TT> packets.
In addition, logic is added to display the additional database
responses. The display showing the number of users is maintained,
with the new database fields being displayed under the active
connections string. Listing 10.12 shows the Election applet source
code.
<HR>
<BLOCKQUOTE>
<B>Listing 10.12. The Election applet class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.applet.*;<BR>
import java.awt.*;<BR>
import java.net.*;<BR>
import java.io.*;<BR>
import java.util.*;<BR>
import DGTPClient;<BR>
<BR>
public class Election extends Applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;implements LiveDataNotify<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static final int SPACING = 70;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean init = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DGTPClient ct = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int destPort;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String destHost = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String users = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String results[][];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int nRows = 0, nCols = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard initialization method for
an applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( init == false
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(500,500);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
strPort = getParameter(&quot;PORT&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( strPort == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
PORT parameter is missing&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPort
= &quot;4545&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort
= Integer.valueOf(strPort).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destHost
= getDocumentBase().getHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard paint routine for an applet.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param g contains the Graphics class
to use for painting<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Active
connections: &quot; + getUsers(), 0, 100);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint the headings
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Candidate&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPACING
* 0, 120);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;State&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPACING
* 1, 120);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Votes&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPACING
* 2, 120);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;%
Reporting&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPACING *
3, 120);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Electorial
Votes&quot;, SPACING * 4, 120);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Display the
contents of the database<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int x =
0; x &lt; nRows; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int y = 0; y &lt; nCols; y++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(results[x][y],
SPACING * y, 140 + (20 * x));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp; }<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the name of the server<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getDestHost()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destHost;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return the server port number<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int getDestPort()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destPort;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Recv a new block of data.&nbsp;&nbsp;Parse
it for display.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param newDataBlock contains the data
to parse<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void recvNewData(byte[]
newDataBlock)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String cmd =
new String(newDataBlock, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringTokenizer
cmds = new StringTokenizer(cmd, &quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String current
= cmds.nextToken();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number of
users update<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (current.equals(&quot;CLIENTS&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
users = cmds.nextToken();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Entire new
database image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (current.equals(&quot;RESULTS&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nRows = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nCols = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
results = new String[nRows][nCols];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( int x = 0; x &lt; nRows; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( int y = 0; y &lt; nCols; y++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
results[x][y] = cmds.nextToken(&quot;|\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // QUERY response
is unimplemented because<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this applet
currently sends no QUERY commands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (current.equals(&quot;QUERY_RSP&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Cause the
applet to receive a paint request<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Return either the users string if it
has been<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * filled in or return the unknown string.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized String getUsers()
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (users != null)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
users;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &quot;Unknown
at this time&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard applet start method.&nbsp;&nbsp;Launch
the<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * DGTP client thread.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct = new DGTPClient(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard applet stop method.&nbsp;&nbsp;Kill
the<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * DGTPClient thread.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.terminate();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Notification if a server connection
was refused<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * by the host.&nbsp;&nbsp;Needed to satisfy
the interface, but<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * otherwise unimplemented.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void connectRefused()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The paint routine uses a <TT>SPACING</TT>
constant to position all the data, relying on the sample table
having at most four rows. <A HREF="ch11.htm" >Chapter 11</A>,
&quot;Building a Live Data Applet,&quot; will dress up the applet
display and expand the table to a full 100 rows! The data is stored
in a two-dimensional String array within the applet. The <TT>recvNewData()</TT>
method parses the data block into this array. Because the data
is formatted into columns separated by a pipe character, a simple
StringTokenizer object can completely extract the individual columns.
Notice that the parsing criteria is altered after the number of
rows and columns is extracted. The method <TT>nextToken()</TT>
can accept an argument, which, if present, will become the separating
characters for successive tokens. In this case, the parser changed
from looking for tokens separated by spaces to looking for tokens
separated by pipe characters. The routine relies on the server
placing at least a single space into an otherwise null column.
If this isn't done, the StringTokenizer will completely skip the
column and a later <TT>nextToken()</TT>
call will fail.
<P>
Because the applet behaves in an essentially synchronous fashion,
only the asynchronous method <TT>recvNewData()</TT>
needs to be protected. This ensures that the applet will not paint
while its data is being refreshed. Figure 10.2 shows the display
of the Election applet.
<P>
<A HREF="f10-2.gif" ><B>Figure 10.2 : </B><I>Output of the Election applet.</I></A>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covers a lot of ground-you learn how to create native
methods in C and how to create and manipulate Java internal objects.
You should now be familiar with method signatures, as well as
the majority of standard Java helper functions. Both Java calling
C and C calling into Java have been covered, and using a static
initializer has been introduced for loading native libraries.
<P>
In addition to native methods, the data communications concept
of chaining has been introduced. The DGTP protocol is now relatively
mature and can form the basis for a wide array of client/server
applications.
<P>
<A HREF="ch11.htm" >Chapter 11</A> will complete this section
on managing live data, which has developed the internals of a
sophisticated client/server applet, and address the one area not
yet covered, the applet's user interface.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



