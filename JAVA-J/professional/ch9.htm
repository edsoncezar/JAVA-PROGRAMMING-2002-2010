<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 9</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Java Socket Programming</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>



<UL>
<LI><A HREF="#AnIntroductiontoSockets" >An Introduction to Sockets</A>
<UL>
<LI><A HREF="#SocketTransmissionModes" >Socket Transmission Modes</A>
<LI><A HREF="#JavaConnectionOrientedClasses" >Java Connection-Oriented Classes</A>
<LI><A HREF="#IterativeandConcurrentServers" >Iterative and Concurrent Servers</A>
<LI><A HREF="#JavaDatagramClasses" >Java Datagram Classes</A>
<LI><A HREF="#AppletSecurityandSockets" >Applet Security and Sockets</A>
</UL>
<LI><A HREF="#ChapterProjectHTTPServerApplication" >Chapter Project: HTTP Server Application and Client Applet</A>
<UL>
<LI><A HREF="#ChapterProjectHTTPServeApplication" >Chapter Project: HTTP Server Application and Client Applet</A>
<LI><A HREF="#BasicWebServer" >Basic Web Server</A>
<LI><A HREF="#ClientDatagramApplet" >Client Datagram Applet</A>
<LI><A HREF="#ClientApplet" >Client Applet</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>To demonstrate full Java client/server applet
connectivity, an applet server is necessary. This chapter initiates
the development of a Java HTTP server. Before beginning the server,
however, you need some background knowledge of socket programming.
This chapter begins with a socket overview and is followed by
an exploration of Java's socket classes. The remainder of the
chapter will delve into constructing a Java HTTP Web server and
a client/server applet.</FONT>
<P>
After reading this chapter, you should be able to do the following:
<UL>
<LI><FONT COLOR=#000000>Understand the socket abstraction</FONT>
<LI><FONT COLOR=#000000>Know the different modes of socket operation</FONT>
<LI><FONT COLOR=#000000>Have a working knowledge of the HTTP protocol</FONT>
<LI><FONT COLOR=#000000>Be able to apply the Java socket classes</FONT>
<LI><FONT COLOR=#000000>Understand applet socket use and limitations</FONT>
<LI><FONT COLOR=#000000>Comprehend the HTTP Java server</FONT>
</UL>
<H2><A NAME="AnIntroductiontoSockets"><FONT SIZE=5 COLOR=#FF0000>An
Introduction to Sockets</FONT></A></H2>
<P>
The computers on the Internet are connected by the TCP/IP protocol.
In the 1980s, the Advanced Research Projects Agency (ARPA) of
the U.S. government funded the University of California at Berkeley
to provide a UNIX implementation of the TCP/IP protocol suite.
What was developed was termed the <I>socket interface</I>, although
you might hear it called the Berkeley-socket interface or just
Berkeley sockets. Today, the socket interface is the most widely
used method for accessing a TCP/IP network.
<P>
A socket is nothing more than a convenient abstraction. It represents
a connection point into a TCP/IP network, much like the electrical
sockets in your home provide a connection point for your appliances.
When two computers want to converse, they each use a socket. One
computer is termed the server-it opens a socket and listens for
connections. The other computer is termed the client; it calls
the server socket to start the connection. To establish a connection,
all that's needed is a destination address and a port number.
<P>
Each computer in a TCP/IP network has a unique address. <I>Ports</I>
represent individual connections within that address. This is
analogous to corporate mail-each person within a company shares
the same address, but a letter is routed within the company by
the person's name. Each port within a computer shares the same
address, but data is routed within each computer by the port number.
When a socket is created, it must be associated with a specific
port-this is known as binding to a port.
<H3><A NAME="SocketTransmissionModes">Socket Transmission Modes</A>
</H3>
<P>
Sockets have two major modes of operation: <I>connection-oriented</I>
and <I>connectionless</I>. Connection-oriented sockets operate
like a telephone; they must establish a connection and a hang
up. Everything that flows between these two events arrives in
the same order it was sent. Connectionless sockets operate like
the mail-delivery is not guaranteed, and multiple pieces of mail
may arrive in a different order than they were sent.
<P>
Which mode to use is determined by an application's needs. If
reliability is important, then connection-oriented operation is
better. File servers need to have all their data arrive correctly
and in sequence. If some data was lost, the server's usefulness
would be invalidated. Some applications-a time server, for example-send
discrete chunks of data at regular intervals. If the data became
lost, the server would not want the network to retry until the
data was sent. By the time the data arrived, it would be too old
to have any accuracy. When you need reliability, be aware that
it does come with a price. Ensuring data sequence and correctness
requires extra processing and memory usage; this extra overhead
can slow down the response times of a server.
<P>
Connectionless operation uses the User Datagram Protocol (UDP).
A datagram is a self- contained unit that has all the information
needed to attempt its delivery. Think of it as an envelope-it
has a destination and return address on the outside and contains
the data to be sent on the inside. A socket in this mode does
not need to connect to a destination socket; it simply sends the
datagram. The UDP protocol promises only to make a best-effort
delivery attempt. Connectionless operation is fast and efficient,
but not guaranteed.
<P>
Connection-oriented operation uses the Transport Control Protocol
(TCP). A socket in this mode needs to connect to the destination
before sending data. Once connected, the sockets are accessed
using a streams interface: open-read-write-close. Everything sent
by one socket is received by the other end of the connection in
exactly the same order it was sent. Connection-oriented operation
is less efficient than connectionless, but it's guaranteed.
<P>
Sun Microsystems has always been a proponent of internetworking,
so it isn't surprising to find rich support for sockets in the
Java class hierarchy. In fact, the Java classes have significantly
reduced the skill needed to create a sockets program. Each transmission
mode is implemented in a separate set of Java classes. The connection-oriented
classes will be discussed first.
<H3><A NAME="JavaConnectionOrientedClasses">Java Connection-Oriented
Classes</A></H3>
<P>
The connection-oriented classes within Java have both a client
and a server representative. The client half tends to be the simplest
to set up, so it will be covered first.
<P>
Listing 9.1 shows a simple client application. It requests an
HTML document from a server and displays the response to the console.
<HR>
<BLOCKQUOTE>
<B>Listing 9.1. A simple socket client.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.net.*;<BR>
<BR>
/**<BR>
 * An application that opens a connection to a Web server and
reads<BR>
 * a single Web page from the connection.<BR>
 * NOTE: &quot;merlin&quot; is the name of my local machine.<BR>
 */<BR>
public class SimpleWebClient {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Open a client socket connection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket
clientSocket1 = new Socket(&quot;merlin&quot;, 80);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Client1:
&quot; + clientSocket1);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Get a Web page<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getPage(clientSocket1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (UnknownHostException
uhe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;UnknownHostException:
&quot; + uhe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;IOException:
&quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Request a Web page using the passed
client socket.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Display the reply and close the client
socket.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void getPage(Socket clientSocket)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire the input and output streams<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outbound = new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientSocket.getOutputStream()
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
inbound = new DataInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientSocket.getInputStream()
);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Write the HTTP request to the server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;GET
/ HTTP/1.0\r\n\r\n&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Read the response<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
responseLine;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((responseLine = inbound.readLine()) != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Display each line to the console<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(responseLine);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
This code checks for EOF.&nbsp;&nbsp;There is a bug in the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
socket close code under Win 95.&nbsp;&nbsp;readLine() will<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
not return null when the client socket is closed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
by the server.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( responseLine.indexOf(&quot;&lt;/HTML&gt;&quot;) != -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Clean up<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientSocket.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException:
&quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The examples in this chapter are coded as applications so as to avoid security restrictions. Run the code from the command line <TT>java ClassName</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
Recall that a client socket issues a connect to a listening server
socket. Client sockets are created and connected by using a constructor
from the Socket class. The following line creates a client socket
and connects it to a host:
<BLOCKQUOTE>
<TT>Socket clientSocket = new Socket(&quot;merlin&quot;,
80);</TT>
</BLOCKQUOTE>
<P>
The first parameter is the name of the host you want to connect
to; the second parameter is the port number. A host name specifies
only the destination computer. The port number is required to
complete the transaction and allow an individual application to
receive the call. In this case, 80 was specified, the well-known
port number for the HTTP protocol. Other well-known port numbers
are shown in Table 9.1. Port numbers are not mandated by any governing
body, but are assigned by convention-this is why they are said
to be &quot;well known.&quot;<BR>
<P>
<CENTER><B>Table 9.1. Well-known port numbers.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=73><I>Service</I></TD><TD WIDTH=48><CENTER><I>Port</I></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=73>echo</TD><TD WIDTH=48><CENTER>7</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>daytime</TD><TD WIDTH=48><CENTER>13</CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=73>ftp</TD><TD WIDTH=48><CENTER>21</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>telnet</TD><TD WIDTH=48><CENTER>23</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>smtp</TD><TD WIDTH=48><CENTER>25</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>finger</TD><TD WIDTH=48><CENTER>79</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>http</TD><TD WIDTH=48><CENTER>80</CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=73>pop3</TD><TD WIDTH=48><CENTER>110</CENTER></TD>
</TR>
</TABLE></CENTER>
<P>
<P>
Because the Socket class is connection oriented, it provides a
streams interface for reads and writes. Classes from the java.io
package should be used to access a connected socket:
<BLOCKQUOTE>
<TT>DataOutputStream outbound = new DataOutputStream(
clientSocket.getOutputStream() );<BR>
DataInputStream inbound = new DataInputStream( clientSocket.getInputStream()
);</TT>
</BLOCKQUOTE>
<P>
Once the streams are created, normal stream operations can be
performed:
<BLOCKQUOTE>
<TT>outbound.writeBytes(&quot;GET / HTTP/1.0\r\n\r\n);
<BR>
String responseLine;<BR>
while ( (responseLine = inbound.readLine()) != null)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(responseLine);<BR>
}</TT>
</BLOCKQUOTE>
<P>
The above code snippet requests a Web page and echoes the response
to the screen. When the program is done using the socket, the
connection needs to be closed:
<BLOCKQUOTE>
<TT>outbound.close();<BR>
inbound.close();<BR>
clientSocket.close();</TT>
</BLOCKQUOTE>
<P>
Notice that the socket streams are closed first. All socket streams
should be closed before the socket is closed. This application
is relatively simple, but all client programs follow the same
basic script:
<OL>
<LI>Create the client socket connection.
<LI>Acquire read and write streams to the socket.
<LI>Use the streams according to the server's protocol.
<LI>Close the streams.
<LI>Close the socket.
</OL>
<P>
Using a server socket is only slightly more complicated, as explained
in the following section.
<H4>Server Sockets</H4>
<P>
Listing 9.2 is a partial listing of a simple server application.
The complete server example can be found on the CD-ROM in SimpleWebServer.java.
<HR>
<BLOCKQUOTE>
<B>Listing 9.2. A simple server application.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
 * An application that listens for connections and serves a simple
<BR>
 * HTML document.<BR>
 */<BR>
class SimpleWebServer {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket serverSocket
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket clientSocket
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int connects =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Create the server socket<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverSocket
= new ServerSocket(80, 5);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
(connects &lt; 5)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Wait for a connection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientSocket
= serverSocket.accept();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Service
the connection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServiceClient(clientSocket);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connects++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverSocket.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
in SimpleWebServer: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void ServiceClient(Socket
client)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
inbound = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outbound = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire the streams for IO<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound
= new DataInputStream( client.getInputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound
= new DataOutputStream( client.getOutputStream());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Format the output (response header and tiny HTML document)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer
buffer = PrepareOutput();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
inputLine;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((inputLine = inbound.readLine()) != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If end of HTTP request, send the response<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( inputLine.equals(&quot;&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(buffer.toString());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Clean up<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Cleaning
up connection: &quot; + client);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Servers do not actively create connections. Instead, they passively
listen for a client connect request and then provide their services.
Servers are created with a constructor from the ServerSocket class.
The following line creates a server socket and binds it to port
80:
<BLOCKQUOTE>
<TT>ServerSocket serverSocket = new ServerSocket(80,
5);</TT>
</BLOCKQUOTE>
<P>
The first parameter is the port number on which the server should
listen. The second parameter is optional. The API documentation
indicates that this parameter is a listen time, but in traditional
sockets programming the listen function's second parameter is
the listen stack depth. As it turns out, this is also true for
the second constructor parameter. A server can receive connect
requests from many clients at the same time, but each call must
be processed one at a time. The <I>listen stack</I> is a queue
of unanswered connect requests. The above code instructs the socket
driver to maintain the last five connect requests. If the constructor
omits the listen stack depth, a default value of <TT>50</TT>
is used.
<P>
Once the socket is created and listening for connections, incoming
connections are created and placed on the listen stack. The <TT>accept()</TT>
method is called to lift individual connections off the stack:
<BLOCKQUOTE>
<TT>Socket clientSocket = serverSocket.accept();</TT>
</BLOCKQUOTE>
<P>
This method returns a connected client socket used to converse
with the caller. No conversations are ever conducted over the
server socket itself. Instead, the server socket will spawn a
new socket in the <TT>accept()</TT>
method. The server socket is still open and queuing new connection
requests.
<P>
Like the client socket, the next step is to create an input and
output stream:
<BLOCKQUOTE>
<TT>DataInputStream inbound = new DataInputStream(
clientSocket.getInputStream() );<BR>
DataOutputStream outbound = new DataOutputStream( clientSocket.getOutputStream()
);</TT>
</BLOCKQUOTE>
<P>
Normal I/O operations can now be performed by using the newly
created streams. This server waits for the client to send a blank
line before sending its response. When the conversation is finished,
the server closes the streams and the client socket. At this point,
the server tries to accept more calls. What happens when there
are no calls waiting in the queue? The method will wait for one
to arrive. This behavior is known as <I>blocking</I>. The <TT>accept()</TT>
method will block the server thread from performing any other
tasks until a new call arrives. When five connects have been serviced,
the server exits by closing its server socket. Any queued calls
will be canceled.
<P>
All servers follow the same basic script:
<OL>
<LI>Create the server socket and begin listening.
<LI>Call the <TT>accept()</TT> method
to get new connections.
<LI>Create input and output streams for the returned socket.
<LI>Conduct the conversation based on the agreed protocol.
<LI>Close the client streams and socket.
<LI>Go back to step 2, or continue to step 7.
<LI>Close the server socket.
</OL>
<P>
Figure 9.1<B> </B>summarizes the steps needed for client/server
connection-oriented applications.
<P>
<A HREF="f9-1.gif" ><B>Figure 9.1:</B> <I>Client and server connection-oriented applications.</I></A>
<H3><A NAME="IterativeandConcurrentServers">Iterative and Concurrent
Servers</A></H3>
<P>
The application just presented is known as an <I>iterative server</I>
because the code accepts a client connection and completely processes
it before it will accept another connection. More complex servers
are concurrent. Instead of accepting connections and immediately
processing them, a <I>concurrent server</I> spawns a new thread
to process each new request, so it seems as though the server
is processing many requests simultaneously. All commercial Web
servers are concurrent servers.
<H3><A NAME="JavaDatagramClasses">Java Datagram Classes</A></H3>
<P>
Unlike connection-oriented classes, the datagram versions of the
client and server behave in nearly identical manners-the only
difference occurs in implementation. The same class is used for
both client and server halves. The following lines create client
and server datagram sockets:
<BLOCKQUOTE>
<TT>DatagramSocket serverSocket = new DatagramSocket(
4545 );<BR>
DatagramSocket clientSocket = new DatagramSocket();</TT>
</BLOCKQUOTE>
<P>
The server specifies its port using the lone constructor parameter
<TT>4545</TT>. Since the client will
call the server, the client can use any available port. The omitted
constructor parameter in the second call instructs the operating
system to assign the next available port number. The client could
have requested a specific port, but the call would fail if some
other socket had already bound itself to that port. It's better
not to specify a port unless the intent is to be a server.
<P>
Since streams can't be acquired for communication, how do you
talk to a DatagramSocket? The answer lies in the DatagramPacket
class.
<H4>Receiving Datagrams</H4>
<P>
The DatagramPacket class is used to receive and send data over
DatagramSocket classes. The packet class contains connection information
as well as the data. As was explained earlier, datagrams are self-contained
transmission units. The DatagramPacket class encapsulates these
units. The following lines receive data from a datagram socket:
<BLOCKQUOTE>
<TT>DatagramPacket packet = new DatagramPacket(new
byte[512], 512);<BR>
clientSocket.receive(packet);</TT>
</BLOCKQUOTE>
<P>
The constructor for the packet needs to know where to place the
received data. A 512-byte buffer was created and passed to the
constructor as the first parameter. The second constructor parameter
was the size of the buffer. Like the <TT>accept()</TT>
method in the ServerSocket class, the <TT>receive()</TT>
method will block until data is available.
<H4>Sending Datagrams</H4>
<P>
Sending datagrams is really very simple; all that's needed is
a complete address. Addresses are created and tracked by using
the InetAddress class. This class has no public constructors,
but it does contain several static methods that can be used to
create an instance of the class. The following list shows the
public methods that create InetAddress class instances:<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=541><I>Public InetAddress Creation Methods</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=541>
<BLOCKQUOTE>
<TT>InetAddress getByName(String host);<BR>
InetAddress[] getAllByName(String host);<BR>
InetAddress getLocalHost();</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Getting the local host is useful for informational purposes, but
only the first two methods are actually used for sending packets.
Both <TT>getByName()</TT> and <TT>getAllByName()</TT>
require the name of the destination host. The first method merely
returns the first match it finds. The second method is needed
because a computer can have more than one address. When this occurs,
the computer is said to be <I>multi-homed</I>. The computer has
one name, but multiple ways to reach it.
<P>
All the creation methods are marked as static. They must be called
as follows:
<BLOCKQUOTE>
<TT>InetAddress addr1 = InetAddress.getByName(&quot;merlin&quot;);
<BR>
InetAddress addr2[] = InetAddress.getAllByName(&quot;merlin&quot;);
<BR>
InetAddress addr3 = InetAddress.getLocalHost();</TT>
</BLOCKQUOTE>
<P>
Any of these calls can throw an UnknownHostException. If a computer
is not connected to a Domain Name Server (DNS) or if the host
is really not found, an exception will be thrown. If a computer
does not have an active TCP/IP configuration, then <TT>getLocalHost()</TT>
is likely to fail with this exception as well.
<P>
Once an address is determined, datagrams can be sent. The following
lines transmit a String to a destination socket:
<BLOCKQUOTE>
<TT>String toSend = &quot;This is the data
to send!&quot;);<BR>
byte[] sendbuf = new byte[ toSend.length() ];<BR>
toSend.getBytes( 0, toSend.length(), sendbuf, 0 );<BR>
DatagramPacket sendPacket = new DatagramPacket( sendbuf, sendbuf.length,
addr, port);<BR>
clientSocket.send( sendPacket );</TT>
</BLOCKQUOTE>
<P>
First, the string must be converted to a byte array. The <TT>getBytes()</TT>
method takes care of the conversion. Next, a new DatagramPacket
instance must be created. Notice the two extra parameters at the
end of the constructor. Since this will be a send packet, the
address and port of the destination must also be placed into the
packet. An applet may know the address of its server, but how
does a server know the address of its client? Remember that a
datagram is like an envelope-it has a return address. When any
packet is received, the return address can be extracted from the
packet by using <TT>getAddress()</TT>
and <TT>getPort()</TT>. This is how
a server would respond to a client packet:
<BLOCKQUOTE>
<TT>DatagramPacket sendPacket = new DatagramPacket(
sendbuf, sendbuf.length,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;recvPacket.getAddress(), recvPacket.getPort()
);<BR>
serverSocket.send( sendPacket );</TT>
</BLOCKQUOTE>
<P>
Unlike connection-oriented operation, datagram servers are actually
less complicated than the datagram client.
<H4>Datagram Servers</H4>
<P>
The basic script for datagram servers is as follows:
<OL>
<LI>Create the datagram socket on a specific port.
<LI>Call receive to wait for incoming packets.
<LI>Respond to received packets according to the agreed protocol.
<LI>Go back to step 2, or continue to step 5.
<LI>Close the datagram socket.
</OL>
<P>
Listing 9.3 shows a simple datagram echo server. It will echo
back any packets it receives.
<HR>
<BLOCKQUOTE>
<B>Listing 9.3. A simple datagram echo server.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.net.*;<BR>
<BR>
public class SimpleDatagramServer<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramSocket
socket = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
recvPacket, sendPacket;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= new DatagramSocket(4545);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
(socket != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvPacket=
new DatagramPacket(new byte[512], 512);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(recvPacket);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendPacket
= new DatagramPacket(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvPacket.getData(),
recvPacket.getLength(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvPacket.getAddress(),
recvPacket.getPort() );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(
sendPacket );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (SocketException
se)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
in SimpleDatagramServer: &quot; + se);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
in SimpleDatagramServer: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>Datagram Clients</H4>
<P>
The corresponding client uses the same process with one exception:
A client must initiate the conversation. The basic recipe for
datagram clients is as follows:
<OL>
<LI>Create the datagram socket on any available port.
<LI>Create the address to send to.
<LI>Send the data according to the server's protocol.
<LI>Wait for receive data.
<LI>Go to step 3 (send more data), 4 (wait for receive), or 6
(exit).
<LI>Close the datagram socket.
</OL>
<P>
Figure 9.2 summarizes the steps needed for client/server datagram
applications. The symmetry between client and server is evident
from this picture; compare Figure 9.2 with Figure 9.1.
<P>
<A HREF="f9-2.gif" ><B>Figure 9.2 </B>: <I>Client and server datagram applications.</I></A>
<P>
Listing 9.4 shows a simple datagram client. It reads user input
strings and sends them to the echo server from Listing 9.3. The
echo server will send the data right back, and the client will
print the response to the console.
<HR>
<BLOCKQUOTE>
<B>Listing 9.4. A simple datagram client.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.net.*;<BR>
<BR>
public class SimpleDatagramClient<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private DatagramSocket socket = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private DatagramPacket recvPacket, sendPacket;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int hostPort;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramSocket
socket = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
recvPacket, sendPacket;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= new DatagramSocket();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetAddress
hostAddress = InetAddress.getByName(&quot;merlin&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
userData = new DataInputStream( System.in );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
(socket != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
userString = userData.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(userString == null || userString.equals(&quot;&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte
sendbuf[] = new byte[ userString.length() ];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userString.getBytes(0,
userString.length(), sendbuf, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendPacket
= new DatagramPacket(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendbuf,
sendbuf.length, hostAddress, 4545 );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(
sendPacket );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvPacket=
new DatagramPacket(new byte[512], 512);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(recvPacket);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.write(recvPacket.getData(),
0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recvPacket.getLength());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;\n&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (SocketException
se)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
in SimpleDatagramClient: &quot; + se);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error
in SimpleDatagramClient: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
All the examples so far have been Java applications. Running these
in an applet presents an extra complication: security.
<H3><A NAME="AppletSecurityandSockets">Applet Security and Sockets</A>
</H3>
<P>
When writing applications, you don't need to be concerned with
security exceptions. This changes when the code under development
is executed from an applet. Netscape Navigator 2.0 uses very stringent
security measures where sockets are concerned. An applet may open
a socket only back to the host name from which it was loaded.
If any other connection is attempted, a SecurityException will
be thrown.
<P>
Datagram sockets don't open connections, so how is security ensured
for these sockets? When an inbound packet is received, the host
name is checked. If the packet did not originate from the server,
a SecurityException is immediately thrown. Obviously, sending
comes under the same scrutiny. If a datagram socket tries to send
to any destination except the server, a SecurityException is thrown.
These restrictions apply only to the address, not the port number.
Any port number on the host may be used.
<P>
All the socket techniques demonstrated so far will be developed
further in this chapter's project.
<H2><A NAME="ChapterProjectHTTPServerApplication"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project: HTTP Server Application and Client Applet</FONT></A>
</H2>
<P>
This project at first glance seems a bit ambitious, but writing
a rudimentary Web server is not as hard as it sounds. Client applets
need an HTTP Web server so they can open sockets. If an applet
is loaded into Netscape from a hard drive, then no socket activity
is allowed to take place. A simple solution is to write an HTTP
server application. Once written, additional server threads can
be added to provide all types of back-end connectivity. This project
will add a multipurpose datagram protocol that will be used for
live data in both <A HREF="ch10.htm" >Chapter 10</A>, &quot;Native
Methods and Java,&quot; and 11, &quot;Building a Live Data Applet.&quot;
<H3><A NAME="ChapterProjectHTTPServeApplication">Chapter Project:
HTTP Server Application and Client Applet</A></H3>
<P>
Before diving into the project, you need some background information
on the HTTP protocol. The Hypertext Transfer Protocol (HTTP) has
been in use on the World Wide Web since 1990. All applet-bearing
Web pages are sent over the net with HTTP. The server will support
a subset of version 1.0 in that only file requests will be handled.
As long as Netscape page requests can be fulfilled, the server
will have accomplished its goal.
<P>
HTTP uses a stream-oriented (TCP) socket connection. Typically,
port 80 is used, but other port numbers can be substituted. All
the protocol is sent in plain-text format. An example of a conversation
was demonstrated in Listings 9.1 and 9.2. The server listens on
port 80 for a client request, which takes this format:
<BLOCKQUOTE>
<TT>GET FILE HTTP/1.0</TT>
</BLOCKQUOTE>
<P>
The first word is referred to as the &quot;method&quot; of the
request. Table 9.2 lists all the request methods for HTTP/1.0.
<BR>
<P>
<CENTER><B>Table 9.2. HTTP/1.0 request methods.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=77><I>Method</I></TD><TD WIDTH=314><I>Use</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=77>GET</TD><TD WIDTH=314>Retrieve a file</TD></TR>
<TR VALIGN=TOP><TD WIDTH=77>HEAD</TD><TD WIDTH=314>Retrieve only file information
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=77>POST</TD><TD WIDTH=314>Send data to the server
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=77>PUT</TD><TD WIDTH=314>Send data to the server
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=77>DELETE</TD><TD WIDTH=314>Delete a resource</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=77>LINK</TD><TD WIDTH=314>Link two resources</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=77>UNLINK</TD><TD WIDTH=314>Unlink two resources
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The second parameter of a request is a file path. Each of the
following URLs is followed by the request that will be formulated
and sent:
<BLOCKQUOTE>
<TT>HTTP://www.qnet.com/<BR>
GET / HTTP/1.0<BR>
<BR>
HTTP://www.qnet.com/index.html<BR>
GET /index.html HTTP/1.0<BR>
<BR>
HTTP://www.qnet.com/classes/applet.html<BR>
GET /classes/applet.html HTTP/1.0</TT>
</BLOCKQUOTE>
<P>
The request does not end until a blank line containing only a
carriage return (\r) and a line feed (\n) is received. After the
method line, a number of optional lines can be sent. Netscape
Navigator 2.0 will produce the following request:
<BLOCKQUOTE>
<TT>GET / HTTP/1.0<BR>
Connection: Keep-Alive<BR>
User-Agent: Mozilla/2.0 (Win95; I)<BR>
Host: merlin<BR>
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*</TT>
</BLOCKQUOTE>
<P>
Responses use a header similar to the request:
<BLOCKQUOTE>
<TT>HTTP/1.0 200 OK<BR>
Content-type: text/html<BR>
Content-Length: 128</TT>
</BLOCKQUOTE>
<P>
Like the request, the response header is not complete until a
blank line is sent containing only a carriage return and a line
feed. The first line contains a version identification string,
followed by a status code indicating the results of the request.
Table 9.3 lists all the defined status codes. The server will
send only two of these: 200 and 404. The text that follows the
status code is optional. It may be omitted, or, if present, it
might not match the definitions given in the table.<BR>
<P>
<CENTER><B>Table 9.3. HTTP response status codes.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=151><CENTER><I>Status Code</I></CENTER></TD><TD WIDTH=240><I>Optional Text Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>200</CENTER></TD><TD WIDTH=240>OK</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>201</CENTER></TD><TD WIDTH=240>Created
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>202</CENTER></TD><TD WIDTH=240>Accepted
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>204</CENTER></TD><TD WIDTH=240>No Content
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>300</CENTER></TD><TD WIDTH=240>Multiple Choices
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>301</CENTER></TD><TD WIDTH=240>Moved Permanently
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>302</CENTER></TD><TD WIDTH=240>Moved Temporarily
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>304</CENTER></TD><TD WIDTH=240>Not Modified
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>400</CENTER></TD><TD WIDTH=240>Bad Request
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>401</CENTER></TD><TD WIDTH=240>Unauthorized
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>403</CENTER></TD><TD WIDTH=240>Forbidden
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>404</CENTER></TD><TD WIDTH=240>Not Found
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>500</CENTER></TD><TD WIDTH=240>Internal Server Error
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>501</CENTER></TD><TD WIDTH=240>Not Implemented
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>502</CENTER></TD><TD WIDTH=240>Bad Gateway
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=151><CENTER>503</CENTER></TD><TD WIDTH=240>Service Unavailable
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Immediately after the response header, the requested file is sent.
When the file is completely transmitted, the socket connection
is closed. Each request-response pair consumes a new socket connection.
<P>
That's enough information to construct a basic Web server. Full
information on the HTTP protocol can be retrieved from <TT>HTTP://www.w3.org/</TT>.
<H3><A NAME="BasicWebServer">Basic Web Server</A></H3>
<P>
The basic Web server will follow the construction of the SimpleWebServer
from Listing 9.2. Many improvements will have to be made to method
and response handling. The simple server does not parse or store
the request header as it arrives. The new Web server will have
to parse and store the requests for later processing. To do this,
you need a class to contain an HTTP request.
<H4>HTTPrequest Class</H4>
<P>
Listing 9.5 shows the complete HTTPrequest class. The class must
contain all the information that could be conveyed in a request
header.
<HR>
<BLOCKQUOTE>
<B>Listing 9.5. The HTTPrequest class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.util.*;<BR>
import java.net.*;<BR>
import NameValue;<BR>
<BR>
/**<BR>
 * This class maintains all the information from an HTTP request
<BR>
 */<BR>
public class HTTPrequest<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String version;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String method;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String file;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Socket clientSocket;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public DataInputStream inbound;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public NameValue headerpairs[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Create an instance of this class<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public HTTPrequest()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientSocket =
null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headerpairs =
new NameValue[0];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a name/value pair to the internal
array<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void addNameValue(String name,
String value)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NameValue
temp[] = new NameValue[ headerpairs.length + 1 ];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(headerpairs,
0, temp, 0, headerpairs.length);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[
headerpairs.length ] = new NameValue(name, value);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headerpairs
= temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (NullPointerException
npe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;NullPointerException
while adding name-value: &quot; + </TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>npe);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Renders the contents of the class in
String format<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String toString()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s = method
+ &quot; &quot; + file + &quot; &quot; + version + &quot;\n&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int x = 0;
x &lt; headerpairs.length; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s += headerpairs[x] + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The NameValue class simply stores two strings: name and value.
You can find the source code for it on the CD-ROM in NameValue.java.
When a new pair needs to be added, a new array is allocated. The
new array receives a copy of the old array as well as the new
member. The old array is then replaced with the newly created
entity.
<P>
Two data fields in the class are not directly part of an HTTP
request. The <TT>clientSocket</TT>
member allows response routines to get an output stream, and the
<TT>inbound</TT> member allows easy
closure after a request has been processed. The remaining members
are all part of an HTTP request. The method <TT>toString()</TT>
allows class objects to be printed using &quot;plus notation.&quot;
The following line will display the contents of a request by invoking
the <TT>toString()</TT> method:
<BLOCKQUOTE>
<TT>System.out.println(&quot;Request: &quot;
+ request);</TT>
</BLOCKQUOTE>
<P>
Now that the request container is finished, it's time to populate
it.
<H4>BasicWebServer Class</H4>
<P>
This is the main class for the server. It can be broken down into
request and response routines. Since this is a server, the request
routines will be activated first. After some validation, the response
routines will be called. Listing 9.6 provides the routines to
parse an HTTP request.
<HR>
<BLOCKQUOTE>
<B>Listing 9.6. HTTP request routines.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Read an HTTP request into a continuous
String.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param client a connected client stream
socket.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @return a populated HTTPrequest instance
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException If not
a valid HTTP header<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public HTTPrequest GetRequest(Socket client)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
inbound = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPrequest request
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire an input stream for the socket<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound
= new DataInputStream(client.getInputStream());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Read the header into a String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
reqhdr = readHeader(inbound);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Parse the string into an HTTPrequest instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request
= ParseReqHdr(reqhdr);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Add the client socket and inbound stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.clientSocket
= client;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.inbound
= inbound;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (ProtocolException
pe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( inbound != null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
pe;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( inbound != null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
ioe;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return request;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Assemble an HTTP request header String
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * from the passed DataInputStream.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is the input stream to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @return a continuous String representing
the header<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException If a pre
HTTP/1.0 request<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private String readHeader(DataInputStream
is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String command;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String line;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the first
request line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (command
= is.readLine()) == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command
= &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command += &quot;\n&quot;;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check for HTTP/1.0
signature<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (command.indexOf(&quot;HTTP/&quot;)
!= -1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Retrieve any additional lines<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((line = is.readLine()) != null&nbsp;&nbsp;&amp;&amp;&nbsp;&nbsp;!line.equals(&quot;&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command
+= line + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(&quot;Pre HTTP/1.0 request&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return command;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Parsed the passed request String and
populate an HTTPrequest.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param reqhdr the HTTP request as a
continous String<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @return a populated HTTPrequest instance
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException If name,value
pairs have no ':'<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private HTTPrequest ParseReqHdr(String
reqhdr)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPrequest req
= new HTTPrequest();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Break the request
into lines<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
lines = new StringTokenizer(reqhdr, &quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String currentLine
= lines.nextToken();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Process the
initial request line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// into method,
file, version Strings<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
members = new StringTokenizer(currentLine, &quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.method = members.nextToken();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.file = members.nextToken();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (req.file.equals(&quot;/&quot;))
req.file = &quot;/index.html&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.version =
members.nextToken();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Process additional
lines into name/value pairs<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ( lines.hasMoreTokens()
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
line = lines.nextToken();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Search for separating character<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
slice = line.indexOf(':');<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Error if no separating character<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( slice == -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Invalid
HTTP header: &quot; + line);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Separate at the slice character into name, value<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
name = line.substring(0,slice).trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
value = line.substring(slice + 1).trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.addNameValue(name,
value);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return req;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The method <TT>readHeader()</TT> interrogates
the inbound socket stream searching for the blank line. If the
request is not in HTTP/1.0 format, this method will throw an exception.
Otherwise, the resulting String is passed to <TT>parseReqHdr()</TT>
for processing.
<P>
These routines will reject any improperly formatted requests,
including requests made in the older HTTP/0.9 format. Parsing
makes heavy use of the StringTokenizer class found in the java.util
package.
<P>
Normally, it would be preferable to close the inbound stream as
soon as the request has been completely read. If this is done,
then subsequent output attempts will fail with an IOException.
This is why the inbound stream is placed into the HTTPrequest
instance. When the output has been completely sent, both the output
and the input streams will be closed.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=578><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=578>
<BLOCKQUOTE>
Do not be tempted to close an inbound stream after all input has been read. Closing the input stream will cause subsequent output attempts to fail with an IOException. Close both streams only after all socket operations are finished.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Currently, the server makes no use of the additional lines in
an HTTP request header. The HTTPrequest class does save them in
an array, however, so they can be used in future enhancements.
Wherever possible, the server has been written with future enhancements
in mind.
<P>
Once you've built the request, you need to form a response. Listing
9.7 presents the response routines used by the server.
<HR>
<BLOCKQUOTE>
<B>Listing 9.7. HTTP response routines.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Respond to an HTTP request<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request to
respond to.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException If unimplemented
request method<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void implementMethod(HTTPrequest
request)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws ProtocolException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug &amp;&amp; level &lt; 4)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;DEBUG:
Servicing:\n&quot; + request);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( (request.method.equals(&quot;GET&quot;) ) ||<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(request.method.equals(&quot;HEAD&quot;)) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServicegetRequest(request);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(&quot;Unimplemented method: &quot; + </TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>request.method);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (ProtocolException
pe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendNegativeResponse(request);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
pe;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send a response header for the file
and the file itself.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Handles GET and HEAD request methods.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request to
respond to<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void ServicegetRequest(HTTPrequest
request)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws ProtocolException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(request.file.indexOf(&quot;..&quot;) != -1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(&quot;Relative paths not supported&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
fileToGet = &quot;htdocs&quot; + request.file;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream
inFile = new FileInputStream(fileToGet);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug &amp; level &lt; 4)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(&quot;DEBUG:
Sending file &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(fileToGet
+ &quot; &quot; + inFile.available());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;
Bytes&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendFile(request,
inFile);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inFile.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
fnf)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendNegativeResponse(request);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (ProtocolException
pe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
pe;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException:
Unknown file length: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendNegativeResponse(request);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send a negative (404 NOT FOUND) response
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request to
respond to.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void sendNegativeResponse(HTTPrequest
request)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outbound = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire the output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound
= new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.clientSocket.getOutputStream());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Write the negative response header<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;HTTP/1.0
&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;404
NOT_FOUND\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;\r\n&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Clean up<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException
while sending -rsp: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Send the passed file<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param request the HTTP request instance
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param inFile the opened input file
stream to send\<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void sendFile(HTTPrequest request,
FileInputStream inFile)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outbound = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Acquire an output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound
= new DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.clientSocket.getOutputStream());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send the response header<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;HTTP/1.0
200 OK\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;Content-type:
text/html\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;Content-Length:
&quot; + inFile.available() + &quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.writeBytes(&quot;\r\n&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Added to allow Netscape to process header properly<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
This is needed because the close is not recognized<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(500);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If not a HEAD request, send the file body.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
HEAD requests solicit only a header response.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(!request.method.equals(&quot;HEAD&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte
dataBody[] = new byte[1024];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
cnt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
((cnt = inFile.read(dataBody)) != -1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.write(dataBody,
0, cnt);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Clean up<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.flush();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.inbound.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException
while sending file: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Only <TT>GET</TT> and <TT>HEAD</TT>
requests are honored. The primary goal is to provide an applet
server, not a full-featured Web server. File requests are all
that's needed for applet loading, though additional handlers can
certainly be added for other request methods. The <TT>serviceGetRequest()</TT>
function handles all responses. When the input stream for a file
is acquired, the file is opened. At this point, the routine knows
whether the file exists and its size. Once a valid file is found,
the <TT>sendFile()</TT> function can
be called. The file is read and sent in 1K blocks. This keeps
memory usage down while seeking to balance the number of disk
accesses attempted. Negative responses are sent only for errors
occurring after the request has been built. As a consequence,
improperly formatted requests will generate no response.
<P>
The response routines rely on ProtocolExceptions to signal error
conditions. When one of these exceptions reaches the <TT>implementMethod()</TT>
function, a negative response is sent. Notice the catch clause
in <TT>serviceGetRequest()</TT>. The
ProtocolException must be caught and thrown again, or the following
IOException will catch the event. This is because ProtocolException
is a child class of IOException. If it had been placed after the
IOException, the compiler would have generated an error:
<BLOCKQUOTE>
<TT>BasicWebServer.java:303: catch not reached.</TT>
</BLOCKQUOTE>
<P>
The remainder of the BasicWebServer application can be found on
the CD-ROM. The <BR>
remaining code calls the input routine <TT>getRequest()</TT>
and then the output routine <TT>implementMethod()</TT>
for each client connection.
<P>
The next section develops a client applet that will be loaded
with the server just constructed. Another service thread will
be added to the server to conduct a datagram socket protocol with
the client.
<H3><A NAME="ClientDatagramApplet">Client Datagram Applet</A>
</H3>
<P>
Applets need to communicate with a server for a variety of applications.
What is needed is a generic protocol that any applet can use to
communicate with its server. This protocol should not be connection
oriented because of the additional load that would be placed on
a server. Datagrams present a lighter load and allow the same
socket to be used no matter how many actual connections are being
serviced. What is envisioned is a broadcast capability for data.
It isn't reasonable for applets to query a server every five seconds
to see whether data has changed. The server should be able to
send to all of its connections whenever the data changes. With
this in mind, the Datagram Transfer Protocol (DGTP) was developed.
The primary requirements of this protocol were as follows:
<UL>
<LI><FONT COLOR=#000000>Use datagrams to lessen server socket
use.</FONT>
<LI><FONT COLOR=#000000>Implement a hook-in and an unhook mechanism.</FONT>
<LI><FONT COLOR=#000000>Allow generic data of any type to be transferred.</FONT>
<LI><FONT COLOR=#000000>Allow any object type to use DGTP services.</FONT>
<LI><FONT COLOR=#000000>Provide a broadcast capability.</FONT>
</UL>
<P>
Figure 9.3 shows a client applet using DGTP to communicate with
a server. Notice how the HTTP data connection does not extend
to the applet. The browser spawns the applet from the data received
from the server.
<P>
<A HREF="f9-3.gif" ><B>Figure 9.3 :</B><I> DGTP communication in the client/server model</I></A>
<P>
The DGTP protocol uses a header much like HTTP; its basic methods
are <TT>REGISTER</TT>, <TT>UNREGISTER</TT>,
<TT>DATA</TT>, <TT>PING</TT>,
and <TT>PONG</TT>. The two register
methods accomplish hooking and unhooking. <TT>PING</TT>
and <TT>PONG</TT> are currently unused,
but could provide a mechanism to periodically check the connection
list. The <TT>DATA</TT> method facilitates
the transfer capability. To allow any object to use DGTP services,
a standard interface was developed. These interfaces specify the
set of functions that an object must use to communicate with DGTP
service threads. Listing 9.8 shows the client and server interfaces.
<HR>
<BLOCKQUOTE>
<B>Listing 9.8. DGTP client and server interfaces.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public interface LiveDataNotify<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getDestHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int getDestPort();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void recvNewData(byte[] newDataBlock);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void connectRefused();<BR>
}<BR>
<BR>
public interface LiveDataServer<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean ValidateRegistrant(ClientAddr
user);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void NewRegistrant(ClientAddr user);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void DropRegistrant(ClientAddr
user);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void recvNewData(byte[] newDataBlock,
DatagramPacket fromWho);<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Notice that both the client and the server have a method to receive
blocks of data. The client has methods to specify the destination
host and port, and the server has methods to validate and register
new connections. The DGTP client is covered first.
<H4>DGTP Client</H4>
<P>
Since listening for receive will block until there is data, the
registration requests will have to be sent using a different thread.
The first thing the client's <TT>run()</TT>
method does is to start the registration thread. At that point,
it can begin receiving data. Listing 9.9 displays a partial listing
of the DGTP client. The complete source code for the client and
the registration threads is on the CD-ROM in DGTPClient.java.
<HR>
<BLOCKQUOTE>
<B>Listing 9.9. The DGTPClient class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * The runmethod for the client.&nbsp;&nbsp;Start
the register thread and<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * begin listening for incoming packets.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
packet = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regThread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
(socket != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet
= new DatagramPacket(new byte[512], 512);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(packet);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsePacketData(packet);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(ProtocolException pe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ProtocolException:
&quot; + pe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;IOException:
in DGTPClient: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Handle a DGTP incoming header<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param packet the incoming packet to
parse<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void parsePacketData(DatagramPacket
packet)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String command
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteArrayInputStream
barray = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
is = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barray = new ByteArrayInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet.getData(),
0, packet.getLength() );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is = new DataInputStream(
barray );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command = readHeader(is);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
lines, cmds;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines = new StringTokenizer(command,
&quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmds = new StringTokenizer(lines.nextToken(),
&quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String ver = cmds.nextToken();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String cmd = cmds.nextToken();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( cmd.equals(&quot;PING&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(&quot;PONG&quot;
+ cmds.nextToken());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( cmd.equals(&quot;REGISTER&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastResponse
= cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registered
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( !lastResponse.equals(&quot;CONFIRM&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataClient.connectRefused();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( cmd.equals(&quot;UNREGISTER&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastResponse
= cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( lastResponse.equals(&quot;CONFIRM&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registered
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( cmd.equals(&quot;DATA&quot;)
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
length = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
data = new byte[length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.readFully(data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataClient.recvNewData(data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(EOFException eof)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Server
packet too short: &quot; + eof);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;While
reading server data: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown
DGTP command: &quot; + cmd);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.close();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Unregister the DGTPClient<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void terminate()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unregThread =
new ClientUnregistration(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unregThread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The read routines are largely the same as the HTTP server's. What
is significant is the translation of the packet data to stream
format. Once that is done, the header can be parsed in the same
manner as an HTTP request. To perform the translation, ByteArrayInputStream
is used; this class is extremely useful when working with byte
arrays. Once the array is in a stream format, it can be turned
into a DataInputStream-the same format the BasicWebServer used
to read its requests.
<P>
The <TT>terminate()</TT> function
spawns a new thread to send the <TT>UNREGISTER</TT>
command because the main client thread is blocked in a receive
call.
<H4>DGTP Server Class</H4>
<P>
Since DGTP is a datagram protocol, the server will be very similar
to the client. There are two main changes, the largest of which
occurs in the <TT>parsePacketData()</TT>
handler function. Listing 9.10 shows the data parse function for
the DGTPServer class. The complete source code can be found on
the CD-ROM in DGTPServer.java.
<HR>
<BLOCKQUOTE>
<B>Listing 9.10. DGTPServer data parsing routine.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Process all incoming packets<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param packet contains the DGTP request
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception IOException<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void ParsePacketData(DatagramPacket
packet)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
ProtocolException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String command
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ByteArrayInputStream
barray = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
is = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String cmd = null;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barray = new ByteArrayInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet.getData(),
0, packet.getLength() );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is = new DataInputStream(
barray );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command = readHeader(is);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
lines = new StringTokenizer(command, &quot;\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
cmds = new StringTokenizer(lines.nextToken(), &quot; \t&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
ver = cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd
= cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( cmd.equals(&quot;PING&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientAddr
addr = new ClientAddr(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet.getAddress(),
packet.getPort());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(addr,
&quot;PONG&quot; + cmds.nextToken());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( cmd.equals(&quot;REGISTER&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClientAddr
addr = new ClientAddr(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet.getAddress(),
packet.getPort());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(!Clients.containsKey(addr))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( dataServer.ValidateRegistrant(addr) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clients.put(addr,
addr);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(addr,
&quot;REGISTER CONFIRM&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataServer.NewRegistrant(addr);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(addr,
&quot;REGISTER DENIED&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(addr,
&quot;REGISTER CONFIRM&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( cmd.equals(&quot;UNREGISTER&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
port = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dumpUser(
new ClientAddr(packet.getAddress(), port) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if ( cmd.equals(&quot;DATA&quot;) )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
length = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
data = new byte[length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.readFully(data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataServer.recvNewData(data,
packet);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(EOFException eof)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Client
packet too short: &quot; + eof);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;While
reading client data: &quot; + ioe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown
DGTP command: &quot; + cmd);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (NoSuchElementException
ne)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new ProtocolException(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Command
arg mismatch: &quot; + cmd);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.close();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The changes occur when adding new users. The server thread will
receive a <TT>REGISTER</TT> request,
which it will pass to the interface object for validation. If
the interface object accepts the new user, a <TT>REGISTER
CONFIRM</TT> response is sent, and the interface object
is alerted to the addition. If the user is rejected, a <TT>REGISTER
DENIED</TT> response is sent. The second change is one
of omission. The <TT>run()</TT> method
for the server will not spawn a registration thread. Otherwise,
it is identical to the client's <TT>run()</TT>
method.
<P>
The server keeps track of user connections in a Hashtable. The
ClientAddr class object encapsulates the address and port as well
as providing a hash key. This allows the server to add a new user
quickly. The code for the <TT>REGISTER</TT>
method creates the address and checks to see whether it's already
present. Multiple <TT>REGISTER</TT>
requests may have been sent before the <TT>REGISTER
CONFIRM</TT> packet could travel back to the sender. If
the server doesn't have this connection yet, it adds the address
to the Clients list. Listing 9.11 shows the ClientAddr class.
Pay particular attention to the <TT>hashCode()</TT>
and <TT>equals()</TT> functions; they
allow the object to act as a hash key.
<HR>
<BLOCKQUOTE>
<B>Listing 9.11. The ClientAddr class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.net.InetAddress;<BR>
<BR>
public class ClientAddr<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public InetAddress address;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int port;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ClientAddr(InetAddress addr, int hostPort)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address = addr;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = hostPort;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int hashCode()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int result = address.hashCode();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += port;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object obj)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (obj !=
null) &amp;&amp; (obj instanceof ClientAddr) &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (address.equals(((ClientAddr)obj).address))
&amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (port
== ((ClientAddr)obj).port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Since this is a broadcast server, there is a varied array of send
methods embedded in the class. The DGTP server has two main send
routines:
<BLOCKQUOTE>
<TT>sendData(ClientAddr dest, byte[] data,
int srcOffset, int length);<BR>
send(ClientAddr dest, String toSend);</TT>
</BLOCKQUOTE>
<P>
The first routine sends the byte array as a DGTP DATA block. The
second routine sends the passed String as a DGTP command header.
All the remaining send routines call <TT>sendData()</TT>
to do the actual transmission. This is the code for one version
of <TT>sendToUsers()</TT>:
<BLOCKQUOTE>
<TT>public void sendToUsers(byte[] data,
int srcOffset, int length)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; for (Enumeration e = Clients.elements();
e.hasMoreElements();)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendData((ClientAddr)e.nextElement(),
data, srcOffset, length);<BR>
}</TT>
</BLOCKQUOTE>
<P>
This routine uses an Enumeration object to loop through the client
hashtable and send to each member. All the remaining send methods
are variations on this theme. Some send to all users; some send
to a specific subset of users. These are all the public send methods:
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=565><BLOCKQUOTE>
<I>Public Send Methods in DGTPServer</I>
</BLOCKQUOTE>

</TD></TR>
<TR VALIGN=TOP><TD WIDTH=565><BLOCKQUOTE>
<TT>sendToUsers(String toSend);<BR>
</TT>sendToUsers(byte[] data, int Offset, int length);<BR>
sendToUsers(ClientAddr[] users, String toSend);<BR>
sendToUsers(ClientAddr[] users, byte[] data, int Offset, int length);<BR>
sendData(ClientAddr addr, String block);<BR>
sendData(ClientAddr dest, byte[] data, int srcOffset, int length);<BR>
<TT>send(ClientAddr dest, String toSend);</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now that the threads are in place, it's time to apply them in
the actual client/server applet.
<H3><A NAME="ClientApplet">Client Applet</A></H3>
<P>
The client applet will be simple in appearance. The emphasis here
will be on using the DGTP protocol. Figure 9.4 shows the applet
in action.
<P>
<A HREF="f9-4.gif" ><B>Figure 9.4 :</B> <I>A simple client applet display.</I></A>
<P>
The purpose of this applet is to display the number of active
connections to this page. Whenever a new user connects, the display
will automatically update to reflect the new count. Likewise,
when a user disconnects, the count will update. Listing 9.12 shows
the client applet class.
<HR>
<BLOCKQUOTE>
<B>Listing 9.12. A client applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.applet.*;<BR>
import java.awt.*;<BR>
import java.net.*;<BR>
import java.io.*;<BR>
import java.util.*;<BR>
import DGTPClient;<BR>
<BR>
public class SimpleClientApplet extends Applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;implements LiveDataNotify<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean init = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DGTPClient ct = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int destPort;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String destHost = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String numUsers = &quot;Unknown at this
time&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String users = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( init == false
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(500,500);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
strPort = getParameter(&quot;PORT&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( strPort == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
PORT parameter is missing&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPort
= &quot;4545&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort
= Integer.valueOf(strPort).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destHost
= getDocumentBase().getHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Registered
Users: &quot; + getUsers(), 0, 100);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getDestHost()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destHost;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int getDestPort()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destPort;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void recvNewData(byte[]
newDataBlock)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;users =
new String(newDataBlock, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized String getUsers()
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (users != null)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
cmds = new StringTokenizer(users, &quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(cmds.nextToken().equals(&quot;CLIENTS&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numUsers
= cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return numUsers;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct = new DGTPClient(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;SimpleClientApplet.stop()&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.terminate();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void connectRefused()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The applet layers a simple protocol on top of DGTP. Whenever the
server detects a change in the number of users, it sends a DATA
block with the following text:
<BLOCKQUOTE>
<TT>CLIENTS number CRLF</TT>
</BLOCKQUOTE>
<P>
The applet receives the new DATA block and converts it to a String
in <TT>recvNewData()</TT>. Note that
this routine as well as <TT>getUsers()</TT>
is marked as synchronized. This prevents the applet from attempting
to read the String while DGTP is updating it.
<P>
The applet uses an applet parameter to know which port the server
is monitoring. The following line reads the PORT parameter:
<BLOCKQUOTE>
<TT>String strPort = getParameter(&quot;PORT&quot;);</TT>
</BLOCKQUOTE>
<P>
The server host name is retrieved from the document itself:
<BLOCKQUOTE>
<TT>destHost = getDocumentBase().getHost();</TT>
</BLOCKQUOTE>
<P>
This is all the information needed to establish a server connection.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=550><B>Using <TT><B>gethost()</FONT></B></TT> over a dial-up connection</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=550>
<BLOCKQUOTE>
If you connect to the Internet through a dial-up account, then you might have trouble with this application because of a host name issue. Specifically, when a dial-in PPP connection is made, your computer is assigned an IP address by the provider. This address is displayed by the server when it is started. Users on the Internet can now reach your server by typing in your IP address:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>HTTP://xxx.xxx.xxx.xxx/</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This will access your server, and pages can be sent. The trouble arises when your applet attempts to receive data from your server. The call to <TT>getDocumentBase().getHost()</TT> will return the IP address that the user typed in to reach your server:
</BLOCKQUOTE>
<BLOCKQUOTE>
<P>
<TT>&quot;xxx.xxx.xxx.xxx&quot;</TT>
<P>
<FONT SIZE=2>In reality, your service provider has already assigned your connection a name:</FONT>
<P>
<TT>&quot;dialup_xx.internet.service.provide.com&quot;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
When the server sends data to the applet, the host name on the data will be that of the service provider. Netscape will flag this as a security violation and raise the dreaded SecurityException. The solution is to enter the actual connection name into the initial URL, but determining this name is a problem. The easiest method I've found is to go ahead and use the IP address initially. When the exception is raised, open the Java console to discover the actual connection name. Use this name instead, and your applet will work wonderfully.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>PORT</TT> parameter needs
to be coded into the HTML applet file so the applet knows on which
port the server is listening. The HTML tag for this applet looks
like this:
<BLOCKQUOTE>
<TT>&lt;applet<BR>
&nbsp;&nbsp;codebase=&quot;/classes&quot;<BR>
&nbsp;&nbsp;code=&quot;SimpleClientApplet.class&quot;<BR>
&nbsp;&nbsp;width=500<BR>
&nbsp;&nbsp;height=500<BR>
&gt;<BR>
&lt;param name=&quot;PORT&quot; value=&quot;4545&quot;&gt;<BR>
&lt;/applet&gt;</TT>
</BLOCKQUOTE>
<H4>Adding the DGTP Server Thread</H4>
<P>
Because the BasicWebServer project was written in Java, it's trivial
to add an instance of the DGTPServer. The problem is that some
object needs to implement the LiveDataServer interface. The base
server class could be changed to add this behavior, but then it
would have to be rewritten any time you wanted a new service thread.
A better solution is to create a separate thread whose only purpose
is to spawn and communicate with the DGTPServer. To this end,
the NumUsersServer class was created. It really doesn't do much,
but it does create the needed interface and enable simple integration
with the Web server. Listing 9.13 shows the NumUsersServer.
<HR>
<BLOCKQUOTE>
<B>Listing 9.13. The NumUsersServer class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.Thread;<BR>
import java.net.DatagramPacket;<BR>
import DGTPServer;<BR>
import LiveDataServer;<BR>
import ClientAddr;<BR>
<BR>
public class NumUsersServer extends Thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;implements LiveDataServer<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private DGTPServer servThread = null;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public NumUsersServer(int hostPort)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread = new
DGTPServer(this, hostPort);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true) yield();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean ValidateRegistrant(ClientAddr
user)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void NewRegistrant(ClientAddr user)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendToUsers(&quot;CLIENTS
&quot; + servThread.Clients.size());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void DropRegistrant(ClientAddr
user)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendToUsers(&quot;CLIENTS
&quot; + servThread.Clients.size());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void recvNewData(byte[] newDataBlock,
DatagramPacket fromWho)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Receive
data block...discarding&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>run()</TT> method starts the
DGTP server and then enters into an infinite <TT>while</TT>
loop. It calls the <TT>yield()</TT>
function to avoid interfering with other active threads.
<P>
The thread is now added to the BasicWebServer class in the <TT>start()</TT>
method:
<BLOCKQUOTE>
<TT>// Create the server socket<BR>
serverSocket = new ServerSocket(HTTP_PORT, 5);<BR>
<BR>
// Create and start any additional<BR>
// server thread services here<BR>
st = new NumUsersServer(4545);<BR>
st.start();<BR>
</TT>
</BLOCKQUOTE>
<P>
The project is now finished, so compile all the source code and
start the server. If you maintained the directory structure of
the CD-ROM, you should be able to start the server and connect
to it. The client applet classes are under htdocs/classes. The
default HTML document is in htdocs/index.html.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you have learned about socket abstraction as
well as the Java implementation of sockets. After some basic client/server
applications, a full HTTP server is undertaken. You should have
a working knowledge of HTTP and an appreciation for socket applet
security. The last part of the chapter introduces the DGTP protocol
for applet/server interaction. This protocol will be reused in
<A HREF="ch11.htm" >Chapter 11</A>, &quot;Building a Live Data
Applet,&quot; as the basis for a live data server, but first,
you must learn to work with native methods for database access.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



