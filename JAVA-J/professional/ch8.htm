<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 8</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Adding Threads to Applets</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#WhatIsaThread" >What Is a Thread?</A>
<LI><A HREF="#CreatingaThreadwiththeThreadClass" >Creating a Thread with the Thread Class</A>
<UL>
<LI><A HREF="#EnhancingYourFirstMultithreadedApple" >Enhancing Your First Multithreaded Applet</A>
</UL>
<LI><A HREF="#TheRunnableInterface" >The Runnable Interface</A>
<LI><A HREF="#Synchronization" >Synchronization</A>
<UL>
<LI><A HREF="#ATestStackClassThatIsNotThreadSaf" >A TestStack Class That Is Not Thread-Safe</A>
<LI><A HREF="#IntroducingtheSynchronizedModifier" >Introducing the Synchronized Modifier</A>
<LI><A HREF="#NotifyandWait" >Notify and Wait</A>
</UL>
<LI><A HREF="#MoreAboutThreads" >More About Threads</A>
<LI><A HREF="#ThreadGroups" >ThreadGroups</A>
<UL>
<LI><A HREF="#ThreadDeath" >ThreadDeath</A>
</UL>
<LI><A HREF="#TalkingThreadsPipesandThreads" >Talking Threads: Pipes and Threads</A>
<LI><A HREF="#ChapterProject" >Chapter Project</A>
<UL>
<LI><A HREF="#ClassOrganization" >Class Organization</A>
<LI><A HREF="#CatalogHTMLandPreloadFile" >Catalog HTML and Preload File</A>
</UL>
<LI><A HREF="#TheMediaLoaderThreadandMediaObserver" >The MediaLoaderThread and MediaObserver Classes</A>
<UL>
<LI><A HREF="#TheMediaLoaderClass" >The MediaLoader Class</A>
<LI><A HREF="#TheMediaSweeperClass" >The MediaSweeper Class</A>
<LI><A HREF="#TheQueueClass" >The Queue Class</A>
<LI><A HREF="#TheBMPImageClass" >The BMPImage Class</A>
<LI><A HREF="#TheCatalogClass" >The Catalog Class</A>
<LI><A HREF="#TheCatalogButtonClass" >The CatalogButton Class</A>
<LI><A HREF="#TheSelectionCanvasClass" >The SelectionCanvas Class</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Using images might make your applet look nicer, but it also slows
the performance of your applet quite a bit. The biggest reason
for this delay is that images are large compared to normal text
documents, such as HTML files; consequently, images take longer
to load from the network. Another reason for this delay is the
time it takes to render some images. Most images are based on
a graphics format that uses some type of compression algorithm.
Although this compression can result in faster delivery, rendering
the image will take additional time, even though this time delay
may be minor.
<P>
In traditional programming, you would have no options for speeding
up the image display. You would simply have to wait for each image
to be downloaded, then wait for it to be rendered. However, this
chapter ends Part III of this book by introducing <I>multithreading</I>
as a way to make your applet run faster and more efficiently.
No longer will you have to wait for each image to be downloaded
and rendered. With multithreading, you can download images while
other images are being displayed. The prospective user of your
applet won't have to wait for all the images to be downloaded
to make a decision. With multithreading, you can use a single
image when it's ready instead of waiting for all images to be
made available.
<H2><A NAME="WhatIsaThread"><FONT SIZE=5 COLOR=#FF0000>What Is
a Thread?</FONT></A></H2>
<P>
A <I>thread</I> has many features of a standalone process. It
has a beginning, a middle, and an ending. Technically speaking,
a thread is a single sequential stream of execution. A thread
can perform a task until it has run to its conclusion (such as
a long calculation), or it can run indefinitely, waiting for requests
to perform a service (such as a database server). In practical
terms, a thread can do just about everything a process can.
<P>
So what is special about threads? The key thing to note is that
a thread runs inside a process; to put it another way, a process
can contain one or more threads (in an operating environment that
supports multithreading). This means that one process can have
a thread that performs a calculation, another thread that performs
a service, and so forth. Furthermore, threads can create new threads.
In Java, threads are everywhere. There are even threads you haven't
explicitly created. The object garbage collector runs in the virtual
machine as a thread. Even the Applet class that starts your applet
is itself running as part of a thread.
<P>
There are other subtle differences between processes and threads.
Multitasking operating systems, which have been around for a long
time, allow multiple processes to run simultaneously. However,
these processes are generally completely independent of each other;
the only thing they share is the operating environment. Consequently,
activities like getting processes to communicate with each other
can be a little tricky. In a multithreading environment, however,
programs that would traditionally be run as separate processes
can be structured to run as separate threads within a common process.
This allows the threads to share resources common to that process,
such as objects and variables. Consequently, the threads of a
process, though running separately, also work together to form
a greater whole. Each thread can be seen as existing as part of
a single, greater unit. For example, when the process dies, so
do all its threads.
<H2><A NAME="CreatingaThreadwiththeThreadClass"><FONT SIZE=5 COLOR=#FF0000>Creating
a Thread with the Thread Class</FONT></A></H2>
<P>
Java offers a variety of tools for writing multithreaded programs.
The most useful is the Thread class, which, as its name suggests,
is used for creating a class that runs as a thread. You need to
declare a subclass of Thread if you want to create a functional
thread. After the subclass is created, you need to override Thread's
<TT>run()</TT> method. This method
is the key to making the Thread class perform as a thread; it
defines your class's thread of execution. After the <TT>run()</TT>
method is established and your class is instantiated, you can
begin the thread with the <TT>start()</TT>
method.
<P>
A simple example shows how easy it is to create a thread in Java.
Figure 8.1 shows an applet with lines drawn randomly throughout
its workspace. These lines are drawn by a thread using the code
in Listing 8.1. The class LineThread is a subclass of Thread that
loops indefinitely, randomly drawing lines on an applet. The applet
is provided to LineThread through its constructor. Although the
LineThread class has a custom constructor, Thread classes often
do not have special constructors.
<P>
<A HREF="f8-1.gif" ><B>Figure 8.1 : </B><I>An applet with lines drawn by a thread </I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 8.1. The source code for applet with lines drawn by
a thread.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
<BR>
// This is an applet that creates a Thread that<BR>
// randomly draws lines on its workspace...<BR>
public class LineApplet extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Thread t;<BR>
&nbsp;&nbsp;&nbsp;// Set the size of the applet, create the thread,
<BR>
&nbsp;&nbsp;&nbsp;// and start it...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(300,300);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new LineThread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Click the mouse to kill the thread...<BR>
&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event ev, int x1, int
x2) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;};<BR>
}<BR>
<BR>
// Thread that randomly draws lines all over a component...<BR>
class LineThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;Applet a;&nbsp;&nbsp;// Thread needs to know
the applet...<BR>
&nbsp;&nbsp;&nbsp;// Constructor simply stores the applet to paint...
<BR>
&nbsp;&nbsp;&nbsp;public LineThread(Applet a) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;this.a = a;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Run the thread. Lines everywhere!<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get dimension data about
the applet...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double width = (double) a.size().width;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double height = (double)a.size().height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop and draw lines forever...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics
g = a.getGraphics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine((int)(width
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(width
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height
* Math.random()) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>run()</TT> method of LineThread
provides the applet's threaded activity. After getting the applet's
dimensions, the thread enters an indefinite <TT>while</TT>
loop, randomly drawing lines on each iteration. (The Component
class's <TT>getGraphics()</TT> method
is a way of getting a Graphics object to draw on a component outside
the <TT>paint()</TT> method.) The
thread will run until the applet is terminated or until the thread
is explicitly stopped.
<P>
After setting its own size and constructing a LineThread object,
the Applet class, LineApplet, begins the line drawing by calling
the <TT>start()</TT> method. This
<TT>start()</TT> method call begins
the thread and invokes the <TT>run()</TT>
method of the LineThread class. The thread will not run until
the <TT>start()</TT> method is applied.
<P>
The <TT>stop()</TT> method terminates
a thread. In a general sense, <TT>stop()</TT>
causes a thread to abruptly leave its <TT>run()</TT>
method and, therefore, end its threaded activity. In this example,
a mouse click on the applet causes the thread (and hence the line
drawing) to stop.
<H3><A NAME="EnhancingYourFirstMultithreadedApple">Enhancing Your
First Multithreaded Applet</A></H3>
<P>
A couple of things can be done to this applet to further illustrate
the Thread class. Listing 8.2 gives the source code for the enhanced
version of the applet. The threaded class, LineThread, was modified
to delay a little between the line drawings by using the <TT>sleep()</TT>
method, which causes the thread to &quot;sleep&quot; for a specific
number of milliseconds; in this case, the delay is for a tenth
of a second. Note how the <TT>sleep()</TT>
method requires catching InterruptedException objects. This is
meant for situations in which a thread has been interrupted by
another thread. However, this capability doesn't seem to be active
in the current version of the JDK. Consequently, you will see
null handlers for InterruptedException objects throughout this
book. Because it is annoying to have to have an exception handler
every time you call <TT>sleep()</TT>,
you might want to encapsulate <TT>sleep()</TT>
and the exception handling in your own method. This technique
appears in the code used elsewhere in this book.
<HR>
<BLOCKQUOTE>
<B>Listing 8.2. Enhanced version of the line-drawing applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
<BR>
// This is an applet that creates a Thread that<BR>
// randomly draws lines on its workspace...<BR>
public class LineApplet extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;Thread t;<BR>
&nbsp;&nbsp;&nbsp;boolean running = false;<BR>
&nbsp;&nbsp;&nbsp;// Set the size of the applet, create the thread
<BR>
&nbsp;&nbsp;&nbsp;// and start it...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;resize(300,300);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;t = new LineThread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;t.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;running = true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Click the mouse down to kill the thread...
<BR>
&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event ev, int x1, int
x2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// If the thread is active, suspend the
thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// and remove the lines...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (running) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; running = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; t.suspend();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; repaint();&nbsp;&nbsp;// Removes the
lines...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// If thread is suspended, then reactivate
it...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; running = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; t.resume();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;};<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Destroy the thread when the applet shuts
down...<BR>
&nbsp;&nbsp;&nbsp;public void destroy() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Stop the thread and wait for it to
die...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;t.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.join();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) { }<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// Thread that randomly draws lines all over a component...<BR>
class LineThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;Applet a;&nbsp;&nbsp;// Thread needs to know
the applet...<BR>
&nbsp;&nbsp;&nbsp;// Constructor simply stores the applet to paint...
<BR>
&nbsp;&nbsp;&nbsp;public LineThread(Applet a) {<BR>
&nbsp;&nbsp;this.a = a;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Run the thread. Lines everywhere!<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Get dimension data about the applet...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;double width = (double) a.size().width;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;double height = (double)a.size().height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Loop and draw lines forever...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; Graphics g = a.getGraphics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Randomly select a color...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; Color c = new Color((int)(255.0 * Math.random()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(255.0 * Math.random()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(255.0 * Math.random())
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; g.drawLine((int)(width * Math.random()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height * Math.random()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(width * Math.random()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height * Math.random())
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sleep some...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(100);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) {
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
A visual enhancement also was made to LineThread. It randomly
creates a new Color object and uses it (with the Graphics class
<TT>setColor()</TT> method) in each
iteration. Figure 8.2 shows the enhancement.
<P>
<A HREF="f8-2.gif" ><B>Figure 8.2 : </B><I>Second version of the linedrawing applet </I></A>
<P>
Most of the changes occur in the Applet class LineApplet. The
method that traps the mouse clicks, <TT>mouseDown()</TT>,
is changed so it no longer stops the thread. It now toggles between
pausing and resuming the thread's execution. The <TT>suspend()</TT>
method suspends a thread's execution; when a thread is suspended,
it will not continue its stream of execution until the complementary
<TT>resume()</TT> method is invoked.
In this example, suspending a thread is accompanied by clearing
out the applet's drawing area through the <TT>repaint()</TT>
method. (This clearing occurs because the applet does not override
the <TT>paint()</TT> method.) The
<TT>running</TT> variable is used
to keep track of whether the thread is suspended; unfortunately,
there is no method in the Thread class for determining this.
<P>
The last bit of code occurs in the newly added <TT>destroy()</TT>
method, which is called when the applet shuts down. In this call,
the <TT>stop()</TT> method terminates
the thread. It is accompanied by a <TT>join()</TT>
call, which forces the calling thread to wait until the victim
thread is really &quot;dead.&quot; This is important because stopping
a thread does not cause an immediate (in the strict sense of the
word) termination of the thread. There may be some delay due to
time-slicing or some other reason. It is often dangerous not to
wait for a thread to die. In some cases, the thread may run even
after some of the objects it uses (like the applet) are no longer
valid. This will cause an exception. Furthermore, an applet that
has been stopped without waiting for its constituent threads to
terminate could cause the applet to unexpectedly &quot;hang.&quot;
Consequently, it's good practice to follow <TT>stop()</TT>
calls by a complementary call to <TT>join()</TT>
to prevent this from happening. It should be noted that the Thread
class has two additional versions of <TT>join()</TT>
that take time-out flags. Use these if your applet has some severe
time constraints and you cannot afford to wait indefinitely for
a thread to end. The time-out values (like most time-outs in Java)
are in milliseconds with an optional nanosecond precision value.
<P>
It is easy to modify the example to have multiple line-drawing
threads. If you add the following code, there will be two threads
drawing lines on the applet:
<BLOCKQUOTE>
<TT>Thread t2 = new LineThread(this);<BR>
t2.start();</TT>
</BLOCKQUOTE>
<P>
You should add corresponding <TT>stop()</TT>
and <TT>join()</TT> methods to terminate
the threads in the applet <TT>destroy()</TT>
method.
<H2><A NAME="TheRunnableInterface"><FONT SIZE=5 COLOR=#FF0000>The
Runnable Interface</FONT></A></H2>
<P>
One thing may strike you as troubling in this discussion about
how threads work. If you have to use the Thread class every time
you need to run something as a thread, don't you lose the capability
to inherit other classes? Because Java is a single-inheritance
system, forcing a class to inherit the Thread class would seem
to be overly restrictive because you couldn't, for example, run
the Applet class as a thread. Fortunately, Java actually implements
threads through an interface, thus allowing any class to use a
thread's functions. The interface is called <I>Runnable</I> and
has only one method, <TT>run()</TT>.
The <TT>run()</TT> method of the Thread
class is itself an implementation of Runnable.
<P>
The typical way of starting a class that implements Runnable as
a thread is to call an alternate Thread constructor. This constructor
takes a Runnable class as its target parameter. For example, if
you have a Runnable object assigned to the variable <TT>r</TT>,
you would pass it to the Thread constructor as follows:
<BLOCKQUOTE>
<TT>t = new Thread(r);</TT>
</BLOCKQUOTE>
<P>
When the thread's <TT>start()</TT>
method is called after this, the <TT>run()</TT>
method of the Runnable target is invoked. If you don't want to
explicitly declare a <TT>Thread</TT>
variable, you can start the Runnable target in a more concise
manner:
<BLOCKQUOTE>
<TT>new Thread(r).start();</TT>
</BLOCKQUOTE>
<P>
A Thread object created with a Runnable target behaves similarly
to the thread behavior discussed in the previous sections. The
<TT>stop()</TT> method terminates
the thread, <TT>suspend()</TT> and
<TT>resume()</TT> are used to pause
and restart the thread, and so on.
<P>
The line-drawing applet can be reworked to use the Runnable interface.
In the example shown in Listing 8.3, the LineThread class is removed,
and the Applet class (called LineRun, in this case) implements
the Runnable interface. Therefore, there is only one class in
the applet that both draws the lines and runs as a thread.
<HR>
<BLOCKQUOTE>
<B>Listing 8.3. The line-drawing applet using the Runnable interface.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
<BR>
// Runs the Applet as a Thread so that it can paint<BR>
// lines indefinitely...<BR>
public class LineRun extends Applet implements Runnable {<BR>
&nbsp;&nbsp;&nbsp;Thread t;&nbsp;&nbsp;// This is the thread!
<BR>
&nbsp;&nbsp;&nbsp;// Set the size of the applet...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(300,300);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Entering the Applet. Start the thread...
<BR>
&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (t == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Leaving the Applet. Stop the thread...<BR>
&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (t != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp; t = null;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Run the thread. Lines everywhere!<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get dimension data about
the applet...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double width = (double)size().width;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double height = (double)size().height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop and draw lines forever...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics
g = getGraphics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Randomly
select a color...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color c
= new Color((int)(255.0 * Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(255.0
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(255.0
* Math.random()) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(c);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine((int)(width
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(width
* Math.random()),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(height
* Math.random()) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sleep
some...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.sleep(100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
There are a couple of interesting things to note about this applet.
It looks almost exactly like the example in the previous section.
In fact, the <TT>run()</TT> method
of Listing 8.3 is only slightly modified from that of the second
version of the LineThread class; the only changes are the removal
of the references to the Applet class and how the <TT>sleep()</TT>
method is invoked.
<P>
The thread that runs the Runnable target is constructed in the
<TT>start()</TT> method of the LineRun
class. (Keep in mind that the <TT>start()</TT>
method here is that of the Applet class and not the Thread class.)
You must check whether the thread already exists because you might
move back and forth from the line-drawing Web page to another
page. If you leave the drawing page, the Applet <TT>stop()</TT>
method kills the thread and waits for it to die. It will be restarted
if you return to the page.
<P>
An interesting thing to note about classes that implement Runnable
is that they are not &quot;dead&quot; if their <TT>run()</TT>
method has been stopped. Even if the thread is dead, the other
methods in a class using Runnable still can be invoked. For example,
add the following code to the LineRun class:
<BLOCKQUOTE>
<TT>// Toggle the running of the line-drawing
thread...<BR>
public boolean mouseDown(Event ev, int x, int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Stop the thread if it is running...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (t != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = null;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If it is dead, then start a new
thread...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new
Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
};</TT>
</BLOCKQUOTE>
<P>
This code stops the thread if it is running and restarts it if
the thread is stopped. Therefore, the LineRun object is alive
regardless of whether the <TT>run()</TT>
method is active. This example points out an advantage of using
the Runnable interface over creating a subclass of Thread. When
a Thread object's <TT>run()</TT> method
is stopped, it cannot be restarted; you have to create a new Thread
to have its <TT>run()</TT> method
run again. On the other hand, an object using Runnable can have
its <TT>run()</TT> method repeatedly
started and stopped.
<P>
Another advantage of using the Runnable interface for your custom
thread is that it does carry all the baggage of the Thread class,
which supports over two dozen methods. It seems wasteful to subclass
threads so that you can override only the <TT>run()</TT>
method. On the other hand, the Thread class might be useful if
your threaded class doesn't need to be a subclass of a complex
class like Applet. In general, it's best to follow the design
versus implementation rule: If your class is designed to be a
special kind of thread, then use the Thread class; if it's designed
to be something else (like an AWT component) but needs to implement
threads, then use Runnable.
<H2><A NAME="Synchronization"><FONT SIZE=5 COLOR=#FF0000>Synchronization</FONT></A>
</H2>
<P>
As you can see from the previous examples, writing threaded classes
in Java is generally pretty easy, so you might wonder why, until
recently, relatively few languages and programs have supported
multithreading. The reason for this is that multithreading is
not without risks. In particular, a class meant to run in a concurrent
environment must be designed so that multiple threads can access
an instance of the class without causing undesired behavior. An
instance of the class must be as reliable in an environment with
multiple threads of execution as it is within a single-threaded
environment. In other words, the class must be <I>thread-safe</I>.
You will now see an example of a class that's not thread-safe.
<H3><A NAME="ATestStackClassThatIsNotThreadSaf">A TestStack Class
That Is Not Thread-Safe</A></H3>
<P>
Listing 8.4 shows the code for a class that is a stack of Integer
objects. It is a generally well-constructed class, showing good
Java programming practices, such as handling errors (like an empty
stack) by throwing exceptions. However, it is not thread-safe.
Why is this? Look at the <TT>push()</TT>
and <TT>pop()</TT> methods. They both
use the <TT>top</TT> integer variable
to indicate the current top of the stack. But what happens if
one thread is calling <TT>push()</TT>
at the same time another thread is calling <TT>pop()</TT>?
In this situation, <TT>push()</TT>
and <TT>pop()</TT> might behave in
an undesired fashion.
<HR>
<BLOCKQUOTE>
<B>Listing 8.4. A TestStack class that isn't thread-safe.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Classes of stack exceptions...<BR>
class StackException extends Exception { }<BR>
class StackFullException extends StackException { }<BR>
class StackEmptyException extends StackException { }<BR>
<BR>
// This class implements a simple stack as<BR>
// an array of integers...<BR>
class TestStack {<BR>
&nbsp;&nbsp;&nbsp;Integer s[];&nbsp;&nbsp;// The stack array of
integer objects...<BR>
&nbsp;&nbsp;&nbsp;int top; // The current top of the stack. Next
item to place.<BR>
&nbsp;&nbsp;&nbsp;// Construct a stack of the specified size...
<BR>
&nbsp;&nbsp;&nbsp;public TestStack(int size) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new Integer[size];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top = -1;&nbsp;&nbsp;&nbsp;//
Empty stack...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Push an item onto the stack...<BR>
&nbsp;&nbsp;&nbsp;public void push(Integer item) throws StackFullException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if stack
is full...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (top == s.length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new StackFullException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise increment the
top and add the item...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = item;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Pop the top item off the stack...<BR>
&nbsp;&nbsp;&nbsp;public Integer pop() throws StackEmptyException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if stack
is empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (top &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new StackEmptyException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise, return the top
item and decrement the top...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer I = s[top];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return I;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// List the contents of the stack...<BR>
&nbsp;&nbsp;&nbsp;public void list() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt;= top;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i
+ &quot;: &quot; + s[i]);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
It is important to note that threads generally function by <I>time-slicing</I>.
What occurs in an environment that supports time-slicing is that
threads share CPU time while executing their respective code.
In effect, although the threads are said to be running simultaneously,
there is really only one thread executing at a given moment in
time. It just <I>seems</I> like the threads are running simultaneously.
The speed of the computer and the small increments of time make
it possible for the threads to look like they're performing simultaneously.
<P>
Suppose there are two threads, A and B. If thread A is executing
a method, thread B could get a slice of time before A is finished
with its method. If the method is thread-safe, it won't matter
to thread A that one or more threads interrupts its processing.
Regardless of the time-slicing sequence, a thread-safe thread
A will get the desired results.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java works best in environments designed to support <I>preemptive</I> time scheduling. A preemptive scheduler gives running tasks (processes or threads) small portions of time to execute by using time-slicing, discussed in this section. UNIX and Windows 95 are two operating systems that support some form of preemptive scheduling. However, some platforms, such as Windows 3.1, support a more primitive form of scheduling, called <I>nonpreemptive</I>. In this form of scheduling, one task doesn't give another task a chance to run until it's finished or has manually yielded its time. This makes writing cooperative programs fairly difficult-especially those with long CPU-intensive operations. You basically have to code your application around the system being nonpreemptive; in certain portions of the code, you need to call some kind of yield method to let other threads execute. In preemptive scheduling environments, this kind of manual coding is not necessary.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
With time-slicing in mind, it isn't difficult to expose the problem
with the TestStack class. Think about what would happen if the
<TT>push()</TT> and <TT>pop()</TT>
code shared time slices in the following manner:
<BLOCKQUOTE>
<TT>PUSH: ++top;<BR>
POP: Integer I = s[top];<BR>
POP: s[top] = null;<BR>
POP; -top;<BR>
PUSH: s[top] = item;</TT>
</BLOCKQUOTE>
<P>
In this case, the <TT>pop()</TT> call
would be in error because it would return a stack top that hasn't
been assigned a value yet. In short, if the <TT>push()</TT>
and <TT>pop()</TT> operations share
slices of time, they will probably not work properly. The operations
with the <TT>top</TT> variable need
to be <I>atomic</I>, which effectively means that another thread
cannot interrupt the execution of the operation until it's finished.
<P>
This issue of operations causing undesired behavior because of
concurrency is often referred to as the <I>producer/consumer</I>
<I>problem</I>. This problem is characterized by one thread producing
data (in this case, pushing an item onto the stack), while a concurrent
thread is consuming the data (popping the stack). The problem
is one of <I>synchronization</I>: Consuming and producing operations
cannot be interleaved indiscriminately; rather, the operations
need to be synchronized to guarantee thread-safe behavior.<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1  WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although a stack class was used in this example, note that there is a stack class available in the java.util package. The stack class written in this chapter is used strictly to illustrate problems with multithreading. Also note that the Exception classes associated with the stack code of this section give you a good example of how to create a subhierarchy of Exception classes. In this case, a new hierarchy of stack exceptions was created, with StackException as the root.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
Listing 8.5 provides Applet and Thread classes that use the TestStack
class appearing throughout this discussion on synchronization.
The Applet class, StackApplet, pushes an element onto the stack
whenever you click the mouse. It follows this push with a listing
of the current stack contents. The Thread class, called StackThread,
loops indefinitely, looking for items on the stack. If one is
found, its integer value is displayed to standard output. If not
(indicated by a StackEmptyException object being thrown), the
thread sleeps a little and tries again. The synchronization problem
can be seen by clicking the mouse rapidly. The <TT>push()</TT>,
<TT>pop()</TT>, and <TT>list()</TT>
methods can then be interleaved. It is likely you'll see the listing
appearing incorrectly if you click fast enough. In fact, the problem
will be blatant: The output from the <TT>pop()</TT>
method-which changes the <TT>top</TT>
variable also used in <TT>list()</TT>-will
occur in the middle of the <TT>list()</TT>
method, thus undermining its results.
<HR>
<BLOCKQUOTE>
<B>Listing 8.5. Applet and Thread classes that use the TestStack
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
<BR>
public class StackApplet extends Applet&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;TestStack s;<BR>
&nbsp;&nbsp;&nbsp;int counter = 0;&nbsp;&nbsp;// For stack test
data...<BR>
&nbsp;&nbsp;&nbsp;Thread t; // The stack thread...<BR>
&nbsp;&nbsp;&nbsp;// Create the stack at initialization...<BR>
&nbsp;&nbsp;&nbsp;// Make a thread to read the stack...<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new TestStack(20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new StackThread(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Add an item to the stack whenever you click
<BR>
&nbsp;&nbsp;&nbsp;// on the mouse...<BR>
&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event ev, int x, int
y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(++counter));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.list();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (StackFullException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Stack
full!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;};<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Kill the stack thread when leaving...<BR>
&nbsp;&nbsp;&nbsp;public void destroy() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// Thread that constantly reads the stack and prints out<BR>
// the current top...<BR>
class StackThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;TestStack s;<BR>
&nbsp;&nbsp;&nbsp;public StackThread(TestStack s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.s = s;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Loop forever, looking at the top of the stack...
<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer Top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
out top of stack, if stack isn't empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Top
= s.pop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread:
Read &quot; + Top);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Sleep
some if stack is empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (StackEmptyException
se) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(250);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(InterruptedException e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="IntroducingtheSynchronizedModifier">Introducing the
Synchronized Modifier</A></H3>
<P>
The developers of Java are aware of the synchronization problem
described in the preceding section. They also know that synchronization
is often dealt with by issuing many lines of code. Fortunately
for Java developers, the Java architects took advantage of programming
constructs introduced over 20 years ago that make creating thread-safe
classes relatively easy. Java synchronization is based on the
concept of <I>monitors</I>. The idea is that each class and object
has its own monitor that functions as a lock on the item. For
example, if one thread locks an object's monitor, then another
thread cannot access that object until the monitor is released.
A monitor can make a code fragment behave like a <I>critical section</I>,
with a piece of code that should only have one thread in it at
a given time.
<P>
The Java language's <I>synchronized</I> modifier is used to implement
a monitor. The modifier can be applied on a method or a block
of code. If a method is declared as synchronized, then a thread
that invokes the method owns the monitor of the object or class
until it leaves the method. If another thread tries to invoke
the method while the other thread owns the monitor, then that
calling thread will have to wait until the first thread is finished.
When this occurs, the monitor is released, and the next thread
can execute the method.
<P>
Placing the synchronized modifier in just three areas of the TestStack
class is all that's needed to  make that class thread-safe. To
do this, the three method declarations of the class need to be
redeclared, as follows:
<BLOCKQUOTE>
<TT>public synchronized void push(Integer
item) throws StackFullException<BR>
public synchronized Integer pop() throws StackEmptyException<BR>
public synchronized void list()</TT>
</BLOCKQUOTE>
<P>
With that simple change, the TestStack class is now thread-safe!
<P>
Another way of using the synchronized modifier is to apply it
to blocks of code. Specifically, the critical sections of code
should be synchronized. The TestStack class can be modified to
do this, as shown in Listing 8.6. The same methods from the previous
declaration are modified to have blocks of the structure
<BLOCKQUOTE>
<TT>synchronized(this) {<BR>
}</TT>
</BLOCKQUOTE>
<P>
around their critical sections of code. The <TT>this</TT>
of the synchronized statement refers to the instance of the TestStack
class. The effect in this case is similar to that of synchronizing
methods; no thread can enter synchronized code while another thread
holds the monitor of the object. As in synchronizing methods,
this version of the TestStack class is thread-safe. Note, however,
that the code is a little more cumbersome and harder to read.
In general, synchronizing methods is preferred over synchronizing
code blocks for both readability and ease of use. Furthermore,
method-based synchronization is considered more object-oriented
because it more <BR>
effectively &quot;hides&quot; the fact that the code is executing
as a thread, thus allowing you to focus on the object's behavior
and not on how it works in a concurrent atmosphere. On the other
hand, synchronizing blocks is more efficient because the monitors
are held for shorter periods of time. If your code has only a
small section of code that is critical, then it might be best
to synchronize that block of code. However, classes such as TestStack
are probably best implemented with synchronized methods.
<HR>
<BLOCKQUOTE>
<B>Listing 8.6. The TestStack class with synchronized code blocks.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This class implements a simple stack
as<BR>
// an array of integers...<BR>
class TestStack {<BR>
&nbsp;&nbsp;&nbsp;Integer s[];&nbsp;&nbsp;// The stack array of
integer objects...<BR>
&nbsp;&nbsp;&nbsp;int top; // The current top of the stack. Next
item to place.<BR>
&nbsp;&nbsp;&nbsp;// Construct a stack of the specified size...
<BR>
&nbsp;&nbsp;&nbsp;public TestStack(int size) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new Integer[size];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top = -1;&nbsp;&nbsp;&nbsp;//
Empty stack...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Push an item onto the stack...<BR>
&nbsp;&nbsp;&nbsp;public void push(Integer item) throws StackFullException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if stack
is full...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (top == s.length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new StackFullException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise increment the
top and add the item...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = item;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Pop the top item off the stack...<BR>
&nbsp;&nbsp;&nbsp;public Integer pop() throws StackEmptyException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Integer I;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if stack
is empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (top &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new StackEmptyException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise, return the top
item and decrement the top...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I = s[top];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return I;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// List the contents of the stack...<BR>
&nbsp;&nbsp;&nbsp;public void list() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt;= top;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i
+ &quot;: &quot; + s[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The code blocks in Listing 8.6 could just have easily been synchronized
with the stack Integer array <TT>s</TT>.
The results would be the same. However, you cannot synchronize
with the integer variable <TT>top</TT>.
The synchronized modifier works only with objects and classes;
variables, such as integers, are not proper synchronization types.
<H3><A NAME="NotifyandWait">Notify and Wait</A></H3>
<P>
Suppose that you wanted to change the TestStack class to be blocking.
That is, if you are invoking the <TT>pop()</TT>
method and there is nothing on the stack, then you should wait
until some other thread adds an element to the stack. However,
because the <TT>pop()</TT> method
is synchronized, you cannot wait inside that method without locking
out the thread that is going to add the element you need! What
you would like to do is wait inside the <TT>pop()</TT>
method but relinquish the TestStack object monitor so that other
threads can use the stack.
<P>
Fortunately, the designers of Java come to your rescue again!
The base Object class has several methods built into it for this
situation. Because these methods are part of the base class, they
are available for every class you create. The <TT>wait()</TT>
method provides the behavior you need for the <TT>pop()</TT>
problem just discussed. When it is called, the <TT>wait()</TT>
method releases the Object's monitor and simply waits until it
is notified. Notification occurs when another thread calls the
same Object's <TT>notify()</TT> method.
This causes the waiting thread to wake up and reacquire the monitor.
If the thread finds what it needs, it can leave the method and
release the lock; otherwise, it can call <TT>wait()</TT>
again.
<P>
Listing 8.7 shows modified methods of the TestStack class that
implement the blocking behavior just discussed. The <TT>pop()</TT>
method no longer throws an exception if the stack is empty. It
now waits until the <TT>push()</TT>
method calls <TT>notify()</TT> to
indicate that an item has been added to the stack. In this example,
the <TT>wait()</TT> method will wait
indefinitely for an item to be added to the stack. In the Queue
class developed in this chapter's project, you will see the use
of alternate <TT>wait()</TT> methods
that have time-outs associated with them.
<HR>
<BLOCKQUOTE>
<B>Listing 8.7. The TestStack class with a blocking </B><TT><B><FONT SIZE=1 FACE="Courier">pop()</FONT></B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Push an item onto the stack...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void push(Integer item)
throws StackFullException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if stack
is full...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (top == s.length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new StackFullException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise increment the
top and add the item...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = item;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>notify</B>();&nbsp;&nbsp;&nbsp;//
Let pop know you got something...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Pop the top item off the stack...<BR>
&nbsp;&nbsp;&nbsp;public synchronized Integer pop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wait indefinitely if stack
is empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (top &lt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>wait</B>();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end while<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Otherwise, return the top
item and decrement the top...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer I = s[top];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[top] = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return I;<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 8.8 shows the StackThread class that is modified to use
the blocking <TT>pop()</TT> method.
The <TT>run()</TT> method is a lot
simpler than before because it no longer has to sleep between
invocations of <TT>pop()</TT>. This
is done implicitly when it is waiting for the TestStack to change.
<HR>
<BLOCKQUOTE>
<B>Listing 8.8. The StackThread class modified to use the blocking
</B><TT><B><FONT SIZE=1 FACE="Courier">pop()</FONT></B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Thread that constantly reads the stack
and prints out<BR>
// the current top...<BR>
class StackThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;TestStack s;<BR>
&nbsp;&nbsp;&nbsp;public StackThread(TestStack s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.s = s;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Loop forever, looking at the top of the stack...
<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer Top;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
out top of stack, if stack isn't empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wait
indefinitely if the stack is empty...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Top = s.pop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread:
Read &quot; + Top);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
If more than one thread is waiting on an object, the <TT>notifyAll()</TT>
method can be used to tell all waiting threads of the change in
the object's state. On the other hand, the <TT>notify()</TT>
method will send a signal only to a single waiting thread. It
should also be noted that the <TT>notify()</TT>
and <TT>wait()</TT> methods can be
called only from within a synchronized method and from the thread
that currently owns the object's monitor. For example, if the
StackApplet object tried to call the TestStack object's <TT>notify()</TT>
method, an IllegalMonitorStateException would be thrown.
<H2><A NAME="MoreAboutThreads"><FONT SIZE=5 COLOR=#FF0000>More
About Threads</FONT></A></H2>
<P>
Suppose you need one of your objects to sleep for a while, but
the object is not an instance of the Thread class. How can this
be done? The Thread class has a static method, called <TT>currentThread()</TT>,
that returns a reference to the Thread object currently being
executed. If the code is structured as in the following example,
you can get the Thread reference you need:
<BLOCKQUOTE>
<TT>public class MyClass {&nbsp;&nbsp;&nbsp;//
Note it does not extend Thread<BR>
&nbsp;&nbsp;&nbsp;public MyMethod() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...work for a while...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now sleep for 2 seconds
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.currentThread().sleep(2000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...back to work...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
With the reference returned from <TT>currentThread()</TT>,
you can execute the Thread methods that your class needs to perform.
If you engage in serious Java programming, you will find the method
to be useful in a wide variety of situations.
<P>
Another feature of the Thread class is that threads can run at
different priority levels. Recall that threads generally operate
by using time-slicing. Setting the priority of a thread lets you
establish how large a time-slice your thread will get in relation
to other threads. For example, a high-priority thread will get
larger slices of time to process than a low-priority thread will.
The Thread class supplies three public variables that can be used
to define a thread's priority:
<UL>
<LI><TT>MIN_PRIORITY</TT> indicates
the minimum priority value in which a thread can run. A thread
set to this priority will receive little processing time. It is
best used for low-priority activities whose rate of completion
isn't important. In this context, it is worth noting that the
Java garbage collector runs at low priority (although it may not
be <TT>MIN_PRIORITY</TT>).
<LI><TT>NORMAL_PRIORITY</TT> indicates
the default value in which a thread runs. Most threads you create
will run at this priority.
<LI><TT>MAX_PRIORITY</TT> indicates
the maximum priority value in which a thread can run. A thread
running at this priority will take most of the available CPU time.
This should be used only for short CPU-intensive tasks that need
to finish quickly.
</UL>
<P>
In general, these priorities are set at the values of <TT>1</TT>,
<TT>5</TT>, and <TT>10</TT>,
respectively. However, it is best not to code with this knowledge
because these variable definitions exist to hide their underlying
values.
<P>
A thread's priority can be set with the <TT>setPriority()</TT>
method. This method takes an integer priority value as its sole
parameter. It throws an IllegalArgumentException if the priority
does not fall within the bounds of <TT>MIN_PRIORITY</TT>
and <TT>MAX_PRIORITY</TT>, inclusively.
For example, this code sets the priority of a thread to the minimum
value:
<BLOCKQUOTE>
<TT>// Create the thread...<BR>
myThread t;<BR>
t = new MyThread().<BR>
// Set the priority to minimum<BR>
try {<BR>
&nbsp;&nbsp;t.setPriority(Thread.MIN_PRIORITY);<BR>
}<BR>
// This exception will not occur!<BR>
catch (IllegalArgumentException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}<BR>
// Start the thread at the low priority...<BR>
t.start();</TT>
</BLOCKQUOTE>
<P>
The priority of a thread can be retrieved with the <TT>getPriority()</TT>
method. Table 8.1 provides a summary of Thread class methods that
you may find useful. Note that ThreadGroups and daemons will be
discussed next.<BR>
<P>
<B>Table 8.1. Summary of important methods of the Thread class.</B>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1  WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=175><TT><I>Method</FONT></I></TT>
</TD><TD WIDTH=415><I>Description</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>currentThread()</TT>
</TD><TD WIDTH=415>Returns a reference to the currently executing Thread.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>getName()</TT>
</TD><TD WIDTH=415>Gets the name of the Thread. Assigned manually or automatically in the constructor.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>getPriority()</TT>
</TD><TD WIDTH=415>Returns the priority of a Thread.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>GetThreadGroup()</TT>
</TD><TD WIDTH=415>Returns the ThreadGroup of a thread.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>isAlive()</TT>
</TD><TD WIDTH=415>Returns whether the Thread is alive; that is, it has been started but not stopped.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>join()</TT>
</TD><TD WIDTH=415>Waits for a Thread to die.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>resume()</TT>
</TD><TD WIDTH=415>Resumes the running of a suspended Thread.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>run()</TT></TD>
<TD WIDTH=415>Establishes where the threaded activity occurs.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>setDaemon()</TT>
</TD><TD WIDTH=415>Establishes the Thread as a daemon or user thread.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>setPriority()</TT>
</TD><TD WIDTH=415>Sets the priority of a Thread.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>sleep()</TT>
</TD><TD WIDTH=415>Causes a Thread to sleep for a specified amount of time.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>stop()</TT>
</TD><TD WIDTH=415>Terminates the <TT>run()</TT> method of a Thread.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>suspend()</TT>
</TD><TD WIDTH=415>Suspends the execution of a Thread.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT>yield()</TT>
</TD><TD WIDTH=415>Yields the currently scheduled time slice to another Thread.
</TD></TR>
</TABLE></CENTER>
<H2><A NAME="ThreadGroups"><FONT SIZE=5 COLOR=#FF0000>ThreadGroups</FONT></A>
</H2>
<P>
The ThreadGroup class contains Threads and other ThreadGroups.
This hierarchical structure allows a ThreadGroup method, such
as <TT>stop()</TT>, to be applied
recursively over the Threads and ThreadGroups it contains. In
this case, the <TT>stop()</TT> method
terminates all currently executing threads in the ThreadGroup
hierarchy. This recursive nature of ThreadGroups also makes it
easy to coordinate the activities of running threads in the group
with a single method call. For example, a call to a ThreadGroup's
<TT>suspend()</TT> method will recursively
suspend all threads in the group; its <TT>resume()</TT>
method will just as easily resume the execution of the group's
threads.
<P>
The Java runtime environment organizes all Threads according to
a hierarchical structure of ThreadGroups. Every Thread belongs
to a ThreadGroup. In an applet, the Thread of the Applet class
belongs to the top-level ThreadGroup. Other Threads can be placed
into that top-level group or placed into a new ThreadGroup.
<P>
The ThreadGroup class has two constructors, both of which require
a string name. The second constructor allows you to specify the
ThreadGroup in which the group should belong. If the default is
used, the new ThreadGroup will be placed in the ThreadGroup of
the currently executing thread. The following code creates an
owner ThreadGroup that belongs in the currently executing thread's
ThreadGroup and an owned group that belongs in the owner group:
<BLOCKQUOTE>
<TT>// This goes into the currently executing
thread's ThreadGroup<BR>
ThreadGroup ownerGrp = new ThreadGroup(&quot;Owner Group&quot;);
// The naem<BR>
// Create the child group...<BR>
ThreadGroup ownedGrp = new ThreadGroup(ownerGrp,&quot;Owned Group&quot;);</TT>
</BLOCKQUOTE>
<P>
To add a Thread to a ThreadGroup, you need to create it as part
of the specified ThreadGroup. If the default Thread constructor
is used, the Thread is placed into the ThreadGroup of the currently
executing thread. The following code creates a Thread that belongs
to the owner ThreadGroup of the previous example:
<BLOCKQUOTE>
<TT>Thread t = new Thread(ownerGrp, &quot;My
Thread&quot;);</TT>
</BLOCKQUOTE>
<P>
Note that names are important to ThreadGroups. You can get the
name of a Thread or ThreadGroup through the corresponding <TT>getName()</TT>
method. A Thread's name can be set at any time with <TT>setName()</TT>.
A thread can find out which ThreadGroup it belongs to by calling
the Thread method <TT>getThreadGroup()</TT>.
For example, the following code can be used at any time to see
what group a non-thread object is running in:
<BLOCKQUOTE>
<TT>ThreadGroup grp = Thread.currentThread().getThreadGroup();</TT>
</BLOCKQUOTE>
<P>
The various <TT>enumerate()</TT> methods
of the Thread and ThreadGroup classes can be used to list the
active threads or groups in an instance of the class. For example,
the following code lists active threads in the owner ThreadGroup
of the previous examples:
<BLOCKQUOTE>
<TT>Thread outArray[] = new Thread[ownerGrp.activeCount()];
<BR>
int count = ownerGrp.enumerate(outArray);<BR>
for (int i = 0; i &lt; count; ++i)<BR>
&nbsp;&nbsp;System.out.println(outArray[i]);</TT>
</BLOCKQUOTE>
<P>
The size of the output array is determined by the <TT>activeCount()</TT>
method of the ThreadGroup class. This returns the number of active
Threads in the group. Note that inactive threads will not appear
in these <TT>activeCount()</TT> or
<TT>enumerate()</TT> methods. This
might be a problem in some situations, so you may need to keep
a manual list of threads. The ThreadGroup method <TT>activeGroupCount()</TT>
returns the number of active ThreadGroups in the group. It corresponds
to an <TT>enumerate()</TT> method
similar to the one shown earlier.
<P>
One of the primary roles ThreadGroups plays is related to Java
security. In theory, the access of a Thread or ThreadGroup to
another ThreadGroup is restricted according to their relationship
to each other. For example, a ThreadGroup can change its child
ThreadGroups, but not the other way around. The <TT>checkAccess()</TT>
method of the Thread and ThreadGroup classes is used to see whether
access to a ThreadGroup is allowed; if not, then a <TT>SecurityException</TT>
object is thrown. Unfortunately, the security feature of ThreadGroups
does not seem to have been fully implemented in the JDK at the
time of this writing. However, the methods and structure are in
place, so it may be worthwhile to test these mechanisms to see
whether your version of the JDK supports the ThreadGroup security
function.
<P>
Another role of ThreadGroups is to control the priority of the
threads running in it. The <TT>setMaxPriority()</TT>
method is used to set the maximum priority of all the threads
(recursively) in a ThreadGroup. This method will not affect currently
running threads until their priorities are changed manually; however,
the new maximum will apply to any threads started after this call.
For example, if the priority is set to a value below <TT>NORMAL_PRIORITY</TT>
(the default priority), all new threads will have their priorities
set to this new lower value. Any time a currently executing thread
changes its priority to a value higher than that established by
<TT>setMaxPriority()</TT>, the priority
applied will be that set by the ThreadGroup.
<P>
A Thread or ThreadGroup can be set as a <I>daemon</I> thread or
group, respectively, by using the corresponding <TT>setDaemon()</TT>
method. A daemon differs from the default state (a <I>user</I>
thread) by being independent of the group that created the daemon;
it is typically used to run in the background as some kind of
service provider, such as a file loader or a print spooler (when
printing is supported in AWT). A daemon thread will run until
it is manually terminated or until all user threads have stopped
running. A daemon ThreadGroup will be destroyed when it no longer
has any active threads or ThreadGroup objects. The <TT>isDaemon()</TT>
method can be used to check whether a thread or group is a daemon
or user.
<P>
Now that you have seen ThreadGroups and the Runnable interface,
you are now ready to look at the list of the various constructors
for the Thread class, as shown in Table 8.2. They use various
combinations of ThreadGroups, Runnable targets, and string names.
If a ThreadGroup is not specified, the Thread is assigned to the
ThreadGroup of the currently executing thread. If a string name
is not provided, one is automatically assigned.<BR>
<P>
<CENTER><B>Table 8.2. Thread constructors.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1  WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=256><I>Constructor</I></TD><TD WIDTH=334><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread()</TT>
</TD><TD WIDTH=334>Default constructor.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(Runnable)</TT>
</TD><TD WIDTH=334>Constructs a thread with the provided Runnable object as the target of the <TT>run()</TT> method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(ThreadGroup, Runnable)</TT>
</TD><TD WIDTH=334>Same as the previous, except it is assigned to the specified ThreadGroup.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(String)</TT>
</TD><TD WIDTH=334>Constructs a Thread with the specified name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(ThreadGroup, String)</TT>
</TD><TD WIDTH=334>Constructs a Thread with the specified name, assigned to the specified ThreadGroup.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(Runnable, String)</TT>
</TD><TD WIDTH=334>Constructs a Thread with the specified name and Runnable target.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=256><TT>Thread(ThreadGroup, Runnable, String)</TT>
</TD><TD WIDTH=334>Constructs a Thread with the specified name and Runnable target, assigned to the specified ThreadGroup.
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="ThreadDeath">ThreadDeath</A></H3>
<P>
One of the interesting things about threads is how the <TT>run()</TT>
method is terminated. From an external user standpoint, a thread
is stopped by calling the <TT>stop()</TT>
method. Internal to the Thread class, however, something more
interesting is going on. The <TT>stop()</TT>
method results in an instance of an Error subclass, called ThreadDeath,
being thrown at the victim thread. Note that ThreadDeath is not
an Exception because these are usually caught as part of good
programming practice. However, because errors are generally not
caught, the thrown ThreadDeath object will result in the termination
of the <TT>run()</TT> method.
<P>
You can catch ThreadDeath as part of your <TT>run()</TT>
method if some extraordinary cleanup needs to occur when the thread
is terminated. However, if you do this, you will need to rethrow
the ThreadDeath object to ensure that the thread is actually terminated.
Although this practice of catching ThreadDeath is discouraged
for its potential risk, an example is shown here to illustrate
how it works:
<BLOCKQUOTE>
<TT>public void run() {<BR>
&nbsp;while (true) {<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;// Do normal threaded loop processing here...
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;catch (Exception e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Normal exceptions are caught here...
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;// Catch thread death!<BR>
&nbsp;&nbsp;catch (ThreadDeath e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Clean up here...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Then rethrow the object to guarantee
thread termination<BR>
&nbsp;&nbsp;&nbsp;&nbsp; throw e;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
An alternative stop() method can be used to throw your own customized
thread &quot;death.&quot; The syntax of the method is as follows:
<BLOCKQUOTE>
<TT>public final synchronized stop(Throwable
o)</TT>
</BLOCKQUOTE>
<P>
The parameter can be any Throwable object, including Exceptions.
Suppose you create your own Exception subclass called MyThreadDeath.
You can then stop your custom thread by calling the following:
<BLOCKQUOTE>
<TT>t.stop(new MyThreadDeath());</TT>
</BLOCKQUOTE>
<P>
Your <TT>run()</TT> method should
then catch the Exception:
<BLOCKQUOTE>
<TT>catch(MyThreadDeath e) {<BR>
&nbsp;&nbsp;// Do some special cleanup here...<BR>
&nbsp;&nbsp;// Then throw ThreadDeath to really kill the thread...
<BR>
&nbsp;&nbsp;throw new ThreadDeath();<BR>
}</TT>
</BLOCKQUOTE>
<P>
Make sure to throw ThreadDeath to kill the thread or to set a
flag to exit the <TT>run()</TT> method
gracefully.
<P>
Given these two <TT>stop()</TT> methods,
it is easy to see that the standard <TT>stop()</TT>
does little more than call the other version of <TT>stop()</TT>,
with ThreadDeath as the Throwable object.
<H2><A NAME="TalkingThreadsPipesandThreads"><FONT SIZE=5 COLOR=#FF0000>Talking
Threads: Pipes and Threads</FONT></A></H2>
<P>
One of the interesting problems of multithreaded programming is
how to get two threads to exchange information. A common method
is to specify a shared communication object. In this chapter's
project, the main thread and the MediaLoader thread talk by using
a shared queue object. When the main thread needs an image to
be loaded, it places the request into the queue. When the loader
thread has retrieved the image, it places the image reference
into a shared cache object.
<P>
Another way to exchange information between two threads is to
create a series of methods for sharing data. One thread can &quot;put&quot;
data while another does a &quot;get&quot; on the data. This technique
is problematic, however, because the calling thread needs to know
when the &quot;get&quot; is complete. By writing a shared object
such as a queue or an instance of the TestStack class discussed
earlier, you can solve the problem through a blocking mechanism
that implements the <TT>wait()</TT>
and <TT>notify()</TT> methods.
<P>
Another classical technique of interthread communication is the
use of pipes. A <I>pipe</I> is a First-In First-Out (FIFO) mechanism
best used by multiple threads. One thread exclusively writes to
the pipe, but another exclusively reads from it. Blocking is easily
implemented in pipes because the output (reader) thread can simply
wait until an item is written to the pipe by the input thread.
<P>
This pipe model can be extended to work with the consumer-producer
model. A consumer thread requests a service by writing to a pipe
that the other thread constantly reads to see if it needs to produce
something. Another pipe, with its input-output reversed, can be
used to let the producer thread notify the consumer thread that
the service request has been fulfilled. Figure 8.3 illustrates
how this would work in a duplex pipe setup.
<P>
<A HREF="f8-3.gif" ><B>Figure 8.3 : </B><I>Using pipes to implement a consumer-producer model </I></A>
<P>
The java.io package provides an easy-to-use mechanism for implementing
pipes. An instance of the PipedOutputStream is used to write data
to a pipe with the <TT>write()</TT>
method. A PipedInputStream instance is connected to the same pipe
by using the <TT>read()</TT> method.
An example, shown in Figure 8.4, uses pipes to take a string specified
in a TextField object and reverse its contents. The applet, appearing
in Listing 8.9, creates two pipes and two threads. Whenever you
enter a string into a TextField and press Enter, it sends the
string to an output pipe. Another class, the ReverseThread, is
a threaded object that waits on the applet's output pipe-which
is an input to it-and reads in a string; the ReverseThread class
is found in Listing 8.10. The thread reverses the string and sends
it to its own output pipe. The applet has its own thread, which
waits for input from the ReverseThread class. When the applet
thread gets the reversed string, it sets it to the display Label
at the bottom of the string. Figure 8.5 shows the data flow of
this pipe example; note how it is similar to Figure 8.3.
<P>
<A HREF="f8-4.gif" ><B>Figure 8.4 : </B><I>An applet that uses pipes to reverse a string </I></A>
<P>
<A HREF="f8-5.gif" ><B>Figure 8.5 : </B><I>The data flow of the pipes's example </I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 8.9. The applet code of the pipe program.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
import java.io.*;<BR>
<BR>
// Applet that uses simple string reversal program<BR>
// to illustrate pipes...<BR>
public class PipeApplet extends Applet implements Runnable {<BR>
&nbsp;&nbsp;&nbsp;TextField tf;&nbsp;&nbsp;// You input the String
to reverse here...<BR>
&nbsp;&nbsp;&nbsp;Label reversed;&nbsp;&nbsp;// Shows the reversed
String...<BR>
&nbsp;&nbsp;&nbsp;DataInputStream inPipe; // String request pipe...
<BR>
&nbsp;&nbsp;&nbsp;DataOutputStream outPipe; // String format...
<BR>
&nbsp;&nbsp;&nbsp;Thread t; // This thread<BR>
&nbsp;&nbsp;&nbsp;ReverseThread r; // Thread to reverse Strings...
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Create TextField to read text to reverse
<BR>
&nbsp;&nbsp;&nbsp;// and label to reverse it.<BR>
&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up the components...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new BorderLayout());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;,(tf
= new TextField()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,(reversed
= new Label(&quot;Reversed String: &quot;)) );<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Catch a text entry and write to a pipe...
<BR>
&nbsp;&nbsp;&nbsp;public boolean action(Event e,Object o) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Take text field entry and stick in
output pipe...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (e.target instanceof TextField) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outPipe.writeBytes(tf.getText()+&quot;\n&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
eio) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Applet
Pipe Write Error: &quot; + eio.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tf.setText(&quot;&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Main thread. Look for output from String
Reverse pipe<BR>
&nbsp;&nbsp;&nbsp;// and write to label...<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Print out reversed string to label...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s = inPipe.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
reversed.setText(&quot;Reversed String: &quot; + s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException eio) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Applet:
Read error &quot; + eio.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Entering Applet. Start the threads...<BR>
&nbsp;&nbsp;&nbsp;// Create communication pipes between the threads...
<BR>
&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if (t == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the pipes...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream out;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outPipe = new DataOutputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(out
= new PipedOutputStream()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream in;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inPipe = new DataInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(in
= new PipedInputStream()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the thread objects...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = new ReverseThread(in,out);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start the threads...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Leaving the Applet. Stop the threads...<BR>
&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = null;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 8.10. The thread code of the pipe program.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Thread that looks into pipe for strings
to reverse...<BR>
class ReverseThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;DataInputStream inPipe;&nbsp;&nbsp;// Request
stream...<BR>
&nbsp;&nbsp;&nbsp;DataOutputStream outPipe;&nbsp;&nbsp;// Send
out reversed string here...<BR>
&nbsp;&nbsp;&nbsp;// Construct with the pipes to use...<BR>
&nbsp;&nbsp;&nbsp;public ReverseThread(PipedInputStream in, PipedOutputStream
out) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inPipe = new DataInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
PipedInputStream(out));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outPipe = new
DataOutputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
PipedOutputStream(in));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (IOException eio) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread:
&quot; + eio.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Loop looking for threads to reverse...<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;&nbsp;&nbsp;// Input
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer rev; // The reverse
string...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Get a string to reverse...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
s = inPipe.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Create the reversal of the string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rev = new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = (s.length() - 1); i &gt;= 0; -i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rev.append(s.charAt(i));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Send the reversed string to the caller!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
outPipe.writeBytes(rev + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException eio) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Thread:
Read error &quot; + eio.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="ChapterProject"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project</FONT></A></H2>
<P>
Part III of this book concludes by adding a background media loader
to the catalog applet developed in <A HREF="ch6.htm" >Chapter 6</A>,
&quot;Building a Catalog Applet.&quot; This loader runs as a thread
and retrieves images that are either to be used as soon as possible
or are &quot;preloaded&quot; in anticipation of your going to
another page in the catalog. This preloading feature improves
the speed of your applet by loading images into memory <I>before</I>
they are needed. Running the loader as a thread also improves
performance because you can display a page of the catalog while
the background thread is loading and preparing the images it needs.
<P>
Another thread that runs in the applet is a <I>sweeper</I> thread.
This thread checks to see whether any items in the image cache
have not been used for a while and so have aged beyond a useful
time, therefore needing to be discarded. In the original version
of this project in <A HREF="ch6.htm" >Chapter 6</A>, the sweeper
ran synchronously with the applet; when the sweeper was running,
the applet would have to wait. In this version, the sweeper thread
runs nonintrusively in the background. It is a low-priority thread,
so its existence will probably go unnoticed.
<P>
The last enhancement to the catalog applet is linking in the BMP
image producer discussed in the chapter project of <A HREF="ch7.htm" >Chapter 7</A>,
&quot;Java and Images.&quot; The media loader thread checks to
see the format of the image coming down; if it is a BMP file,
it will use the BMP image producer. This makes the media loader
act as a kind of &quot;content handler,&quot; handling multiple
kinds of content; at the very least, it is a first step toward
having a real dynamic content handler as in HotJava.
<P>
The main menu of the catalog application is shown in Figure 8.6.
<P>
<A HREF="f8-6.gif" ><B>Figure 8.6 : </B><I>Main menu of the online catalog </I></A>
<H3><A NAME="ClassOrganization">Class Organization</A></H3>
<P>
Table 8.3 lists the classes used in this chapter's version of
the catalog applet. Because many of these classes were created
in the previous chapters, the new classes are delimited by having
their names appear in boldface type. The classes that were modified
have their names italicized.<BR>
<P>
<CENTER><B>Table 8.3. Catalog project classes.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1  WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=187><I>Class</I></TD><TD WIDTH=403><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>BMPImage</TT>
</TD><TD WIDTH=403>Used to produce Images based on the BMP format.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>CacheEntry</TT>
</TD><TD WIDTH=403>Represents a single entry in the image cache maintained by the MediaLoader class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>Catalog</TT>
</TD><TD WIDTH=403>The Applet class that takes HTML parameters and constructs the components representing the current choices. Adds images to be preloaded from the MediaLoader.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>CatalogButton</TT>
</TD><TD WIDTH=403>An image-based button that shows text representing a choice and links to another Catalog applet when selected.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>MediaLoader</TT>
</TD><TD WIDTH=403>A class used to maintain a cache of images. It starts and sends requests to an instance of MediaLoaderThread to actually get the images and starts a MediaSweeper thread to remove any old images from the cache.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>MediaLoaderException</TT>
</TD><TD WIDTH=403>An exception thrown by the MediaLoader when there is a problem.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>MediaLoaderThread</TT>
</TD><TD WIDTH=403>A background thread that loads normal or BMP images as they are requested. It gets requests for images from a Queue object and adds loaded images to the image cache.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>MediaObserver</TT>
</TD><TD WIDTH=403>Used to track whether the loading of an image is complete.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>MediaSweeper</TT>
</TD><TD WIDTH=403>A background thread that removes any old images from the image cache.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>Queue</TT></TD>
<TD WIDTH=403>A generic class for reading or writing objects to a queue.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=187><TT>SelectionCanvas</TT>
</TD><TD WIDTH=403>Displays a large image representing a possible choice of the user. Appears to the right of its companion CatalogButton.
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="CatalogHTMLandPreloadFile">Catalog HTML and Preload
File</A></H3>
<P>
A new parameter is added to the catalog HTML file. The <TT>&lt;PARAM&gt;</TT>
tag with the name <TT>preload</TT>
specifies the file that contains images that should be loaded
by the background MediaLoader thread after all of the images needed
by the current catalog page have been loaded. Listing 8.11 shows
the HTML of the main catalog page, with the preload parameter
set in bold. Notice that the data associated with the parameter
is now a bitmap file. Reading in this format is automatically
handled by the BMPImage class.
<HR>
<BLOCKQUOTE>
<B>Listing 8.11. HTML of main catalog page (index.html).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;title&gt;Catalog Applet&lt;/title&gt;
<BR>
&lt;hr&gt;<BR>
&lt;applet code=&quot;Catalog&quot; width=400 height=300&gt;<BR>
&lt;param name=field1 value=&quot;Computers,catalog/field1.gif,MEDIUM,computer/main.html&quot;&gt;
<BR>
&lt;param name=image1 value=&quot;catalog/selection1.gif&quot;&gt;
<BR>
&lt;param name=field2 value=&quot;Software,catalog/field1.gif,MEDIUM,software/main.html&quot;&gt;
<BR>
&lt;param name=image2 value=&quot;catalog/selection2.gif&quot;&gt;
<BR>
&lt;param name=field3 value=&quot;Accessories,catalog/field1.gif,MEDIUM,accessory/</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>main.html&quot;&gt;
<BR>
&lt;param name=image3 value=&quot;catalog/selection3.<B>bmp</B>&quot;&gt;
<BR>
&lt;param name=data value=&quot;catalog/data.txt&quot;&gt;<BR>
&lt;param name=<B>preload</B> value=&quot;preload&quot;&gt;<BR>
&lt;/applet&gt;<BR>
&lt;hr&gt;</TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 8.12 displays the contents of the preload file that is
tied to the HTML just listed. The entries of the preload file
consist of a series of lines that list the following: the relative
path and filename of the image to be preloaded, the style (for
example, dimensions) of the file, and whether it goes on a CatalogButton
object or a SelectionCanvas.
<HR>
<BLOCKQUOTE>
<B>Listing 8.12. Preload file of the main catalog page.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>computer/selection1.gif, MEDIUM, CANVAS
<BR>
computer/field1.gif, MEDIUM, BUTTON<BR>
computer/selection3.gif, MEDIUM, CANVAS<BR>
software/softsel1.gif, MEDIUM, CANVAS<BR>
software/softsel3.gif, MEDIUM, CANVAS</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheMediaLoaderThreadandMediaObserver"><FONT SIZE=5 COLOR=#FF0000>The
MediaLoaderThread and MediaObserver Classes</FONT></A></H2>
<P>
The MediaLoaderThread class, shown in Listing 8.13, is a background
thread responsible for loading images that are requested in a
shared instance of the Queue class. The heart of the class is
its <TT>run()</TT> method. The thread
waits indefinitely for input to appear in the input queue; as
described later, the queue <TT>get()</TT>
method is blocking, so the thread will do nothing until something
is placed in the queue. When the appropriate data is found, the
thread checks to see if the image is a BMP format or a standard
image handled by Java. If it is the former, the BMPImage class
is to produce an image based on the BMP format. If it is not a
BMP file, then the Toolkit class is used to get an instance of
the Image class. In either case, a MediaObserver object is created
that is passed to the Toolkit's <TT>prepareImage</TT>()
method. This forces the image to start being loaded. The MediaObserver
will then track the progress of the image as it is being brought
in. When the whole image is retrieved, the observer's complete
flag is set. The MediaObserver class is shown in Listing 8.14.
The ImageObserver interface on which it is based was described
in the two previous chapters.
<HR>
<BLOCKQUOTE>
<B>Listing 8.13. The MediaLoaderThread class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// The MediaLoaderThread loads all images
that appear in its<BR>
// input queue.&nbsp;&nbsp;It works with the MediaObserver to
track whether<BR>
// or not a standard image has been fully loaded.<BR>
public class MediaLoaderThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;Queue inQueue;<BR>
&nbsp;&nbsp;&nbsp;Hashtable cache;<BR>
&nbsp;&nbsp;&nbsp;public static final int WAIT = 1;<BR>
&nbsp;&nbsp;&nbsp;public static final int NO_WAIT = 2;<BR>
&nbsp;&nbsp;&nbsp;public static final int LOAD_AND_WAIT = 3;<BR>
&nbsp;&nbsp;&nbsp;static boolean debug = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Construct thread by giving it the cache hashtable
<BR>
&nbsp;&nbsp;&nbsp;// and the input queue<BR>
&nbsp;&nbsp;&nbsp;public MediaLoaderThread(Hashtable cache,Queue
q) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Store the input queue...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inQueue = q;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.cache = cache;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Run the thread until it gets an orderly shutdown...
<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL u;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s; // URL string from
queue...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int width,height,wait;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean status;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaObserver mo;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer producer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer I;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if
there is something in the queue....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= (String) inQueue.get();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Queue
input: &quot; + s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I
= (Integer)inQueue.get();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width
= I.intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Queue
input:&nbsp;&nbsp;W = &quot; + width);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I
= (Integer)inQueue.get();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height
= I.intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Queue
input: H = &quot; + height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I
= (Integer)inQueue.get();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait
= I.intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Queue
input: Wait = &quot; + wait);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start
loading the image....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
a URL for the image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u
= new URL(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
See what type the image is.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
BMPs are a special case...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(s.toUpperCase().endsWith(&quot;.BMP&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Thread:
Load Bitmap...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer
= BmpImage.getImageProducer(u);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= Toolkit.getDefaultToolkit().createImage(producer);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Handle normal images (JPEG or GIF)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
debugString(&quot;Thread: Load and prepare image...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
img = Toolkit.getDefaultToolkit().getImage(u);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
img.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Create MediaObserver and prepare image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mo
= new MediaObserver(img,width,height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toolkit.getDefaultToolkit().prepareImage(img,width,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
height,mo);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If load and wait, stick in cache right away...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(wait == LOAD_AND_WAIT)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.put(u,new
CacheEntry(img,Integer.MAX_VALUE));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Loop until complete. BMPs won't go through here...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((wait != NO_WAIT) &amp;&amp; (mo != null)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Thread:
Start waiting...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
(true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(mo.isComplete())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If not complete, sleep a little...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(InterruptedException e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end while<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end wait if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debugString(&quot;Thread:
Done loading&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Finished! Write to cache. High age prevents<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
premature garbage collection...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(wait != LOAD_AND_WAIT)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.put(u,new
CacheEntry(img,Integer.MAX_VALUE));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Malformed
URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (AWTException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;AWTException:
&quot; + e);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end while<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// See if we should print out debug strings...
<BR>
&nbsp;&nbsp;&nbsp;private void debugString(String s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (debug)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 8.14. The MediaObserver class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Observes an image as it's being loaded
and tracks<BR>
// whether its loading is complete...<BR>
class MediaObserver implements ImageObserver {<BR>
&nbsp;&nbsp;&nbsp;Image img;<BR>
&nbsp;&nbsp;&nbsp;Boolean complete;<BR>
&nbsp;&nbsp;&nbsp;static boolean debug = false;<BR>
&nbsp;&nbsp;&nbsp;// Get image and dimensions...<BR>
&nbsp;&nbsp;&nbsp;public MediaObserver(Image img,int width,int
height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.img = img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete = new Boolean(false);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// The complete flag needs to be synchronized...
<BR>
&nbsp;&nbsp;&nbsp;public boolean isComplete() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean status;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(complete) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status
= complete.booleanValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return status;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Automatically called when an image is updated...
<BR>
&nbsp;&nbsp;&nbsp;public boolean imageUpdate(Image imgIn, int
info,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x, int y, int width, int
height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((info &amp; (ALLBITS |
FRAMEBITS)) != 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(complete)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete
= new Boolean(true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(debug)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;COMPLETE!!!&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The MediaLoaderThread class indicates that an image is prepared
by adding it to the image Hashtable cache shared by the parent
class (MediaLoader). When the image is added to the cache depends
on the class's wait mode, of which it has three variations. If
the mode is <TT>WAIT</TT>, the image
is not entered into the cache until it has been fully loaded,
indicated by the complete flag of the MediaObserver. (Recall that
the <TT>getImage()</TT> method returns
immediately and only creates an instance of the Image class; the
image data is not loaded until a request is made for it by a method
such as <TT>prepareImage()</TT>.)
If the mode is <TT>NO_WAIT</TT>, the
image reference is placed immediately into the cache. For the
<TT>LOAD_AND_WAIT</TT> mode, the image
is placed immediately into the cache, but the next image request
is not read until the image is fully loaded. This latter mode
will be used for prefetching images. This mode of operation will
work well in cases where the thread is in the middle of preloading
an image that becomes immediately needed because you have moved
to the page of the catalog in which the image appears.
<P>
Many enhancements can be made to these two classes. In particular,
the MediaObserver can use the ImageObserver interface's <TT>ABORT</TT>
flag to stop the loading of an image; the MediaLoaderThread class
would also have to be adjusted. You might want to abort a load
if you are moving to a new page of the catalog and you need its
images loaded immediately. However, it is questionable whether
this is actually worth while. Suppose that the image is 90 percent
loaded, and you abort it. If the image is needed again shortly,
network resources will have been wasted. Because this is a tough
decision to make, the default procedure of letting the current
load go through to completion was chosen.
<H3><A NAME="TheMediaLoaderClass">The MediaLoader Class</A></H3>
<P>
The MediaLoader class was changed drastically from its original
incarnation in Chapter 6. Consequently, its new design appears
in Listing 8.15. The major change is that the actual loading of
the images was moved into the MediaLoaderThread class, and the
cleanup routines were placed into the MediaSweeper class. Both
of these classes run as threads, which are created and started
in the <TT>start()</TT> method. This
is called once and only once by the private constructor. The <TT>start()</TT>
method is also responsible for creating the Queue object that
is used to place requests to the MediaLoaderThread object.
<HR>
<BLOCKQUOTE>
<B>Listing 8.15. The MediaLoader class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This class loads image media via URL
commands and<BR>
// keeps a local cache of images. Each image has an<BR>
// address that is used for aging. When the image is too<BR>
// old then it is removed from that cache.<BR>
public class MediaLoader {<BR>
&nbsp;&nbsp;&nbsp;public static final int WAIT = MediaLoaderThread.WAIT;
<BR>
&nbsp;&nbsp;&nbsp;public static final int NO_WAIT =MediaLoaderThread.NO_WAIT;
<BR>
&nbsp;&nbsp;&nbsp;public static final int LOAD_AND_WAIT =MediaLoaderThread.LOAD_AND_WAIT;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Cache size is used for tracking age of URL
<BR>
&nbsp;&nbsp;&nbsp;static int cacheSize = 40;<BR>
&nbsp;&nbsp;&nbsp;static int currentAge = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Cache is hashtable...<BR>
&nbsp;&nbsp;&nbsp;static Hashtable cache = new Hashtable(cacheSize);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// The loader is static and so can be created
only once<BR>
&nbsp;&nbsp;&nbsp;private static MediaLoader loader = new MediaLoader();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Private internal constructor: Create the
cache<BR>
&nbsp;&nbsp;&nbsp;// abdstart the loaded thread...<BR>
&nbsp;&nbsp;&nbsp;private MediaLoader() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Media
Loader: CONSTRUCTOR!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Return reference to this MediaLoader object
<BR>
&nbsp;&nbsp;&nbsp;public static synchronized MediaLoader getMediaLoader()
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return loader;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Keeps track of whether or not it has started
or<BR>
&nbsp;&nbsp;&nbsp;// stopped the MediaLoaderThread object<BR>
&nbsp;&nbsp;&nbsp;static boolean running = false;<BR>
&nbsp;&nbsp;&nbsp;static MediaLoaderThread t;<BR>
&nbsp;&nbsp;&nbsp;static MediaSweeper sweeper;<BR>
&nbsp;&nbsp;&nbsp;static Queue reqQueue;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// If not started yet, create output queue and
<BR>
&nbsp;&nbsp;&nbsp;// then start the media loader thread...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!running) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
request queue...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue
= new Queue(cacheSize * 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start
the media loader stream...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new
MediaLoaderThread(cache,reqQueue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start
the sweeper. Try to keep cacheSize around<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initial
values...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sweeper
= new MediaSweeper(cache,cacheSize,cacheSize + 10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sweeper.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// If running, shutdown the thread and wait
for it to die...<BR>
&nbsp;&nbsp;&nbsp;public synchronized void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Kill the thread if running...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (running) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Orderly
shutdown...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sweeper.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wait
for thread to die...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sweeper.join();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It's
dead, Jim!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Get image via URL set for specified coordinates....
<BR>
&nbsp;&nbsp;&nbsp;// Will send this into the output queue that
the media<BR>
&nbsp;&nbsp;&nbsp;// thread reads...<BR>
&nbsp;&nbsp;&nbsp;public synchronized Image getImage(URL base,String
name,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int width,int height,int wait) throws
MediaLoaderException&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create a URL for the image...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL u;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u
= new URL(base,name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw
new MediaLoaderException(&quot;Malformed URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if it is in the cache...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Get image
&quot; + u + &quot;...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++currentAge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheEntry ce = (CacheEntry)
cache.get(u);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If its in the cache, update
the age and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ce != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce.setAge(currentAge);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Image
found in cache...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ce.getImage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now write the URL and dimensions
to the request array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue.put(u.toString());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue.put(new Integer(width));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue.put(new Integer(height));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue.put(new Integer(wait));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// The running thread determines
the wait flag...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// It either sets the Image
object right away<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// or it waits for it...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce = (CacheEntry)
cache.get(u);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ce !=
null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.currentThread().sleep(100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end while
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;Image &quot;
+ name + &quot; retrieved...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce.setAge(currentAge);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ce.getImage();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Applet is used for updating status bar...
<BR>
&nbsp;&nbsp;&nbsp;Applet a = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called when a new applet has been loaded...
<BR>
&nbsp;&nbsp;&nbsp;public synchronized void enter(Applet a) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.a = a;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called when the current applet is leaving...
<BR>
&nbsp;&nbsp;&nbsp;public synchronized void leave(Applet a) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.a = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Clear the queue...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reqQueue.reset();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Show status of load...<BR>
&nbsp;&nbsp;&nbsp;public void showStatus(String msg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;MediaLoader:
&quot; + msg);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.showStatus(msg);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// The identifying String of the loader<BR>
&nbsp;&nbsp;&nbsp;public String toString() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (&quot;MediaLoader
ID: &quot; + hashCode());<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>getImage()</TT> method has
the same parameters as before, except for one that indicates how
to wait. The wait flags correspond to the discussion in the previous
section. Internally, the <TT>getImage()</TT>
method is greatly simplified. It checks to see if the image requested
appears in the cache; if so, then it updates its age and returns
it immediately. Otherwise, it places a request for the image to
the loader thread via the shared Queue object. The MediaLoader
does not release control until the image is placed into the cache;
when this occurs implicitly depends on the wait flag.
<P>
The other thing worth noting in the MediaLoader class is the <TT>enter()</TT>
and <TT>leave()</TT> methods. These
are used for tracking the current applet; a reference to the applet
allows the loader to update the browser's status bar with the
current state of a request. When you leave a page of the catalog,
the <TT>leave()</TT> method clears
out the request queue of any pending image preloads. The loader
thread will therefore finish only the current preload it is working
on; it will then be free for any immediate requests needed for
the new page.
<H3><A NAME="TheMediaSweeperClass">The MediaSweeper Class</A>
</H3>
<P>
The MediaSweeper class is a low-priority thread that removes images
from the MediaLoader cache whose age has grown beyond a certain
acceptable value. This value is set by a desired cache size (the
<TT>desiredSize</TT> variable). Whenever
the size of the cache has grown bigger than a predetermined size
(the <TT>cleanSize</TT> variable),
the cache removes as many of the oldest cache entries as is necessary
to get down to the desired size.
<P>
When the sweeper is constructed, it sets its priority to a low
value by using the Thread class <TT>setPriority()</TT>
method. When the sweeper thread is running, the <TT>run()</TT>
method repeatedly checks to see whether the cache is bigger than
the clean size, cleans if necessary, and then has a long sleep.
If the cache is too big, the <TT>sweeper()</TT>
method is called. This method, developed in <A HREF="ch6.htm" >Chapter 6</A>,
is only slightly changed to run inside the sweeper thread.
<P>
The contents of the MediaSweeper class appear in Listing 8.16.
<HR>
<BLOCKQUOTE>
<B>Listing 8.16. The MediaSweeper class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Removes any item from cache that has
an<BR>
// age that is too old...<BR>
&nbsp;&nbsp;&nbsp;private void sweeper() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheEntry ce;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Array for placing hashtable
elements...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ages[] = new int[cache.size()];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First step is to go through
get all the ages...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumeration em = cache.elements();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; em.hasMoreElements();
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce = (CacheEntry)em.nextElement();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ages[i]
= ce.getAge();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Next step is to get minimum
age...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is gross since we
have to perform<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a sort...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(ages);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now get nTh element<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index = ages.length -
desiredSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minAge = ages[index];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currentAge = ages[ages.length
- 1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do nothing if we have nothing
that's old...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (minAge &gt; (currentAge
- desiredSize)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Final step is to walk through
and remove<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// old elements...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em = cache.keys();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL u;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (em.hasMoreElements())
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = (URL)em.nextElement();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get cache
entry...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce = (CacheEntry)cache.get(u);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if
its too old...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ce.getAge()
&lt; minAge) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.remove(u);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Sort an integer array...<BR>
&nbsp;&nbsp;&nbsp;// I didn't have enough time to write quick
sort<BR>
&nbsp;&nbsp;&nbsp;// so here is a lame bubble sort...<BR>
&nbsp;&nbsp;&nbsp;void sort(int data[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int N = data.length - 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j,t;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = N; i &gt;= 0; -i)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j =
1; j &lt;= i; ++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(data[j - 1] &gt; data[j]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t
= data[j - 1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[j
- 1] = data[j];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[j]
= t;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end swap if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
j if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end i if<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheQueueClass">The Queue Class</A></H3>
<P>
The Queue class implements a standard circular queue that uses
objects as entries. The tail of the queue marks the index of the
next entry in queue; the head is the last item read from the queue.
Like a dog, the head chases the tail. If the head is equal to
the tail, the queue is empty.
<P>
The most notable thing about the queue, shown in Listing 8.17,
is that the <TT>put()</TT> and <TT>get()</TT>
methods are blocking. If you try to put an element in a queue
that is full, the method will wait until an element has been removed
from the queue; it does this through the object <TT>wait()</TT>
and <TT>notify()</TT> methods discussed
earlier in this chapter. Similarly, the <TT>get()</TT>
method blocks until there is an element in the queue to read.
The <TT>put()</TT> and <TT>get()</TT>
methods can be called with an indefinite time-out (value <TT>0</TT>)
or a millisecond timeout.
<HR>
<BLOCKQUOTE>
<B>Listing 8.17. The Queue class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Generic class for holding a Queue
of Objects...<BR>
// Uses synchronization and wait/notify methods to<BR>
// indicate when the Queue has something to read or<BR>
// is ready to accept a new entry...<BR>
public class Queue {<BR>
&nbsp;Object Q[];<BR>
</TT>&nbsp;<TT>int head,tail;<BR>
&nbsp;// Create Queue of specified size....<BR>
</TT>&nbsp;<TT>public Queue(int size)
{<BR>
&nbsp;&nbsp;&nbsp;Q = new Object[size];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;head =
tail = 0;<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Add an element to the Queue.&nbsp;&nbsp;If it is full
then wait<BR>
</TT>&nbsp;<TT>// until something
has been read or it times out.<BR>
&nbsp;// Timeout 0 means wait forever....<BR>
</TT>&nbsp;<TT>public synchronized
void put(Object o,long timeout)<BR>
&nbsp;&nbsp;throws QueueTimeoutException {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Add
the element to the queue...<BR>
&nbsp;&nbsp;&nbsp;Q[tail] = o;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;int newTail
= tail + 1;&nbsp;&nbsp;// Increment tail...<BR>
&nbsp;&nbsp;&nbsp;// Wrap around if the end is reached...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;if (newTail
&gt;= Q.length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newTail = 0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// See
if the queue is full and so we have to wait...<BR>
&nbsp;&nbsp;&nbsp;if (newTail == head) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Q
Full. Wait...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(timeout);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(InterruptedException e) { }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Throw exception if we timed
out...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(head == tail)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new QueueTimeoutException();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;} // end
if<BR>
&nbsp;&nbsp;&nbsp;tail = newTail;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;notify();
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Default put: Wait forever...<BR>
</TT>&nbsp;<TT>public void put(Object
o) {<BR>
&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put(o,0);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// This
shouldn't happen...<BR>
&nbsp;&nbsp;&nbsp;catch (QueueTimeoutException e) { }<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Get an element from
the queue... Wait if queue<BR>
&nbsp;// is empty. If empty, then wait until timeout,<BR>
</TT>&nbsp;<TT>// where 0 means wait
forever...<BR>
&nbsp;public synchronized Object get(long timeout)<BR>
</TT>&nbsp;<TT>&nbsp;throws QueueTimeoutException
{<BR>
&nbsp;&nbsp;&nbsp;// See if Queue is empty...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;if (head
== tail) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Nothing
in Q. Wait...&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(timeout);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) { }<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Throw exception if we timed out...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (head == tail)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new QueueTimeoutException();<BR>
&nbsp;&nbsp;&nbsp;} // end if<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Get
the Object at the head of the Queue...<BR>
&nbsp;&nbsp;&nbsp;Object o = Q[head];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Reset
the Q entry...<BR>
&nbsp;&nbsp;&nbsp;Q[head] = null;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Set
the new head...<BR>
&nbsp;&nbsp;&nbsp;++head;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;if (head
&gt;= Q.length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head = 0;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;notify();
<BR>
&nbsp;&nbsp;&nbsp;return o;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Default put: Wait
forever...<BR>
&nbsp;public Object get() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return get(0);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// This shouldn't happen...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;catch (QueueTimeoutException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Reset the queue to be empty....<BR>
</TT>&nbsp;<TT>public synchronized
void reset() {<BR>
&nbsp;&nbsp;&nbsp;head = tail = 0;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// List the Q elements....
<BR>
&nbsp;public synchronized void list() {<BR>
</TT>&nbsp;<TT>&nbsp;for (int i =
0; i &lt; Q.length; ++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i + &quot;:
&quot; + Q[i]);<BR>
</TT>&nbsp;<TT>}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheBMPImageClass">The BMPImage Class</A></H3>
<P>
The BMPImage class constructed in <A HREF="ch7.htm" >Chapter 7</A>
needed two new methods to handle the requirements of the catalog
applet. The <TT>extract4BitData()</TT>
method is used to handle additional bitmap formats (see the CD-ROM
for its code). Listing 8.18 includes an additional constructor
for the BMPImage class. Unlike the other constructor, it takes
only a full URL as its sole parameter.
<HR>
<BLOCKQUOTE>
<B>Listing 8.18. An additional constructor for the BMPImage class.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A method to retrieve an ImageProducer
given just a BMP URL.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param context contains the base URL
(from getCodeBase() or such)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns an ImageProducer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception AWTException on stream or
bitmap data errors<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static ImageProducer getImageProducer(
URL context)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws AWTException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream is
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
img = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name =
context.toString();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index; //
Make last part of URL&nbsp;&nbsp;the name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((index = name.lastIndexOf('/'))
&gt;= 0) <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= name.substring(index + 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage
im = new BmpImage(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is
= context.openStream();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
input = new DataInputStream( new<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream(is)
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= im.extractImage(input);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException
me)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(me.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(ioe.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheCatalogClass">The Catalog Class</A></H3>
<P>
The <TT>start()</TT> method of the
Catalog class is modified to notify the MediaLoader that a new
catalog page is loaded, via the <TT>enter()</TT>
method. It also starts the preload of images. This occurs in the
<TT>preload()</TT> method. It reads
in the file specified by the &quot;preload&quot; parameter and
sends each entry as an image request to the MediaLoader. The <TT>LOAD_AND_WAIT</TT>
flag tells the loader not to start loading any new requests until
the current request is completely satisfied. 
<P>
The <TT>stop()</TT> method tells the
MediaLoader that you are leaving the current Catalog page by invoking
its <TT>leave()</TT> method. This
results in the clearing of the preload request queue. The changes
to the Catalog class are shown in Listing 8.19.
<HR>
<BLOCKQUOTE>
<B>Listing 8.19. Changes to the Catalog class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Begin preloading data...<BR>
&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Let the loader know a new
page has been loaded...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.getMediaLoader().enter(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start the preload of images...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preload();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Stop preload when leaving page...<BR>
&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.getMediaLoader().leave(this);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
// Start preloading images if specified...<BR>
&nbsp;&nbsp;&nbsp;public void preload() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Get path to data from parameter...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String dataPath = getParameter(&quot;preload&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (dataPath == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;No
preload variable found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create URL for data...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URL u;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = new URL(getDocumentBase(),dataPath);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Bad
Data URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Now load the data by opening up a stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// to the URL...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; DataInputStream dis = new DataInputStream(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new BufferedInputStream(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.openStream()
) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Read each line and put in MediaLoader
queue...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; String fetchLine, fileDir, tempStyle,
tempType;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; while ((fetchLine = dis.readLine()) !=
null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Prefetch:
&quot; + fetchLine);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Parse
out the string...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
s = new StringTokenizer(fetchLine,&quot;,&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s.hasMoreTokens())
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileDir
= s.nextToken().trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(s.hasMoreTokens()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tempStyle = s.nextToken().trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// If we get past here, then all the fields are present<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// and we can start to preload the image...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (s.hasMoreTokens()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempType
= s.nextToken().trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Right now only the Medium style is supported...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (tempType.equalsIgnoreCase(&quot;button&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.getMediaLoader().getImage(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDocumentBase(),fileDir,150,100,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.LOAD_AND_WAIT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.getMediaLoader().getImage(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDocumentBase(),fileDir,250,100,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.LOAD_AND_WAIT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Just ignore errors....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(MediaLoaderException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end innermost if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end while<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;URL
read error&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheCatalogButtonClass">The CatalogButton Class</A>
</H3>
<P>
The constructor of the CatalogButton class was changed to use
the new MediaLoader <TT>getImage()</TT>
format, as shown in Listing 8.20. The wait flag is, oddly enough,
<TT>NO_WAIT</TT>. This causes the
MediaLoader to continue as soon as the Image object is created
and not to wait until the image is fully loaded. This allows painting
to occur as soon as possible, and the image to be rendered as
it is loaded. It is worth seeing what happens when the flag of
this class and SelectionCanvas is set to <TT>WAIT</TT>.
Nothing will appear until everything is loaded. However, the images
are shown in their full form, not partially rendered.
<HR>
<BLOCKQUOTE>
<B>Listing 8.20. Changes to the CatalogButton constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Create the catalog button...<BR>
&nbsp;&nbsp;&nbsp;public CatalogButton(Applet aIn,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; String backgroundImage,&nbsp;&nbsp;String
textIn, Font fIn,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL URLBaseIn, String linkIn,
String dataIn,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font dataFontIn) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store
parameters...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = aIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text = textIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = fIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URLBase
= URLBaseIn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link = linkIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastX =
lastY = -1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state =
NORMAL_STATE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = dataIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataFont
= dataFontIn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now start
loading the background image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// via the
Media Loader...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= MediaLoader.getMediaLoader().getImage(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URLBase,backgroundImage,150,100,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.NO_WAIT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MediaLoaderException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.showStatus(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheSelectionCanvasClass">The SelectionCanvas Class</A>
</H3>
<P>
The constructor of this class is modified in a manner similar
to the CatalogButton class. <BR>
The wait flag of the <TT>getImage()</TT>
call to the MediaLoader is also set to <TT>NO_WAIT</TT>,
as shown in Listing 8.21.<BR>
<HR>
<BLOCKQUOTE>
<B>Listing 8.21. Changes to the SelectionCanvas constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Create the canvas display...<BR>
&nbsp;&nbsp;&nbsp;public SelectionCanvas(Applet aIn,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; String displayImage,URL URLBaseIn) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Store
parameters...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = aIn;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URLBase
= URLBaseIn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now start
loading the background image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// via the
Media Loader...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= MediaLoader.getMediaLoader().getImage(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URLBase,displayImage,250,100,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaLoader.NO_WAIT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MediaLoaderException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.getAppletContext().showStatus(e.getMessage());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This part of the book has emphasized how to use images for tasks
like animation or smart image loading through a loader thread.
The catalog applet developed in this chapter forms just the foundation
for creating a serious online application. The media loader will
need to be optimized to fit your particular needs, such as when
to abort a load and how to use the wait flag to control how an
image is displayed. But most of all, the catalog will probably
need data from the server to show prices and other runtime information.
This dynamic data loading is the subject of Part IV, &quot;Managing
Live Data&quot;; in this part, you will develop an applet that
dynamically reads in election night returns as they are fed in
from a back-end server.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



