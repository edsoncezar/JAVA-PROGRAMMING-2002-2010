<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 7</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Java and Images</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#DisplayingImages" >Displaying Images</A>
<UL>
<LI><A HREF="#LoadingJavaImages" >Loading Java Images</A>
<LI><A HREF="#ImageDisplay" >Image Display</A>
<LI><A HREF="#ImageObservers" >Image Observers</A>
</UL>
<LI><A HREF="#TrackingImageLoading" >Tracking Image Loading</A>
<LI><A HREF="#TheConsumerProducerModel" >The Consumer/Producer Model</A>
<LI><A HREF="#JavaColorModels" >Java Color Models</A>
<UL>
<LI><A HREF="#DefaultRGB" >Default RGB</A>
<LI><A HREF="#DirectColor" >Direct Color</A>
<LI><A HREF="#IndexColor" >Index Color</A>
</UL>
<LI><A HREF="#ChapterProjectDisplayingaWindowsBM" >Chapter Project: Displaying a Windows BMP Image</A>
<UL>
<LI><A HREF="#UsingImageTypesNotSupportedbyJava" >Using Image Types Not Supported by Java</A>
<LI><A HREF="#MemoryImages" >Memory Images</A>
<LI><A HREF="#LoadingForeignImages" >Loading Foreign Images</A>
<LI><A HREF="#BMPFileFormat" >BMP File Format</A>
<LI><A HREF="#ReadingUnsignedBinaryinJava" >Reading Unsigned Binary in Java</A>
<LI><A HREF="#CreatingtheColorTable" >Creating the Color Table</A>
<LI><A HREF="#ConstructingtheImage" >Constructing the Image</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Images offer the best way to work with Java graphics; as a matter
of fact, everything in the AWT seems centered on the concept of
images. This chapter shows you how to use Java for generating
images. It leads off with rendering and tracking a simple image
and continues by explaining the fundamental model behind Java
images. The chapter ends by writing a class to display image formats
not directly supported by Java.
<H2><A NAME="DisplayingImages"><FONT SIZE=5 COLOR=#FF0000>Displaying
Images</FONT></A></H2>
<P>
Images are nothing more than a collection of colors and their
layout, but they are useful because, with an auxiliary paint program,
you can create sophisticated visual effects that can be captured
and displayed in your applets.
<P>
Java arrives with built-in support for two types of images: GIF
and JPEG. The GIF standard (Graphics Interchange Format) is maintained
by CompuServe. It uses an excellent compression scheme (LZW) to
represent a large image in a small file. JPEG (Joint Photographic
Experts Group) is an international standard mainly used for photographic
material. It uses a discrete cosine transform (DCT) to remove
extraneous material your eye doesn't really notice, so a very
efficient compression scheme can be used. The cosine transform
is &quot;lossy,&quot; meaning it loses some information when applied.
LZW, on the other hand, is &quot;lossless.&quot; It turns out
that the information removed by a cosine transform is precisely
the photographic detail that your eye does not see.
<H3><A NAME="LoadingJavaImages">Loading Java Images</A></H3>
<P>
Both these formats can be easily loaded by your applets:
<BLOCKQUOTE>
<TT>Image newImage = getImage(<I>URL</I>);
<BR>
Image newImage = Toolkit.getDefaultToolkit().getImage(<I>filename
or URL</I>);</TT>
</BLOCKQUOTE>
<P>
The first line may be used only from a subclass of Applet, but
line two can be called by either an applet or application. Each
<TT>getImage()</TT> method returns
immediately, without actually loading the image. To retrieve the
image, you must try to display it; this is done to keep memory
consumption down. For example, sometimes an applet might refer
to an image, but not actually make use of it. Therefore, until
the image is really needed, it will remain on the server.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>getImage()</TT> method does not cause your image to be loaded. The image remains on the server until you try to display it.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The Applet class provides two versions of <TT>getImage()</TT>:
<UL>
<LI><TT>public Image getImage(URL imgLocation);</TT>
<LI><TT>public Image getImage(URL baseLocation,
String filename);</TT>
</UL>
<P>
The second call is the one most commonly used because applets
can load only from the server they originated on. The methods
to get either the URL of the page or the applet code's URL can
then be combined with the filename of the image to construct a
complete path:
<BLOCKQUOTE>
<TT>Image newImage = getImage(getDocumentBase(),
&quot;image.gif&quot;);</TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT>Image newImage = getImage(getCodeBase(),
&quot;image.gif&quot;);</TT>
</BLOCKQUOTE>
<P>
The call you use depends on whether your image is grouped with
the class files or the HTML Web pages on your server.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You must be aware of the organization of your various data files on the server. If your images reside with your class files (/htdocs/classes/images), then use <TT>getCodeBase()</TT>; however, if your images reside with your html files (/htdocs/images), use <TT>getDocumentBase()</TT>. Many times, class files are grouped together with html files. In this case, both methods will return the same URL.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The Toolkit also provides two <TT>getImage()</TT>
methods:
<UL>
<LI><TT>public Image getImage(URL imgLocation);</TT>
<LI><TT>public Image getImage(String filename);</TT>
</UL>
<P>
Although the Toolkit can retrieve a filename, applets can't use
<TT>getImage()</TT> to read local
files because they would cause a security exception. Remember,
applets can read only from the server they originated on. Allowing
applets to read from a local drive is definitely a security no-no.
<H3><A NAME="ImageDisplay">Image Display</A></H3>
<P>
Once an Image object is instantiated, it can be displayed in an
applet's <TT>paint()</TT> method by
using the Graphics object passed to it:
<BLOCKQUOTE>
<TT>g.drawImage(newImage, x, y, this);</TT>
</BLOCKQUOTE>
<P>
Variables <TT>x</TT> and <TT>y</TT>
contain the coordinates of the image's upper-left corner, and
the final parameter is an ImageObserver object. This interface
is implemented in the Component class that the applet is derived
from, which is why you can pass the <TT>this</TT>
pointer. You'll learn more about the ImageObserver interface in
the next section.
<P>
There are four variations of <TT>drawImage()</TT>
in the Graphics class:
<UL>
<LI><TT>public abstract boolean drawImage(Image
img, int x, int y, ImageObserver observer);</TT>
<LI><TT>public abstract boolean drawImage(Image
img, int x, int y, int width, int height, ImageObserver observer);</TT>
<LI><TT>public abstract boolean drawImage(Image
img, int x, int y, Color bgcolor, ImageObserver observer);</TT>
<LI><TT>public abstract boolean drawImage(Image
img, int x, int y, int width, int height, Color bgcolor, ImageObserver
observer);</TT>
</UL>
<P>
The width and height parameters allow you to scale an image, which
can be enlarged or reduced in either the x or y direction. The
<TT>bgcolor</TT> parameter specifies
which color to use for any transparent pixels in the image. Each
<TT>drawImage()</TT> version returns
<TT>true</TT> if the image was painted,
<TT>false</TT> otherwise. The image
will not paint if it hasn't been loaded yet. It will eventually
display because the Component class will be notified of the load
and will call your paint method when the image arrives.
<H3><A NAME="ImageObservers">Image Observers</A></H3>
<P>
The Component class accomplishes this because it implements the
ImageObserver interface. Most of Java's image-manipulation routines
are <I>asynchronous</I>, meaning they return immediately and notify
you when they have completed their assignment. The notification,
which flows through the ImageObserver interface, contains the
following method:
<UL>
<LI><TT>public abstract boolean imageUpdate(Image
img, int infoflags, int x, int y, int width, int height);</TT>
</UL>
<P>
The Component class uses this method, but you can override it
to get information about your image. The <TT>infoflags</TT>
parameter is a bit flag; the settings for the bits are shown in
Table 7.1.<BR>
<P>
<CENTER><B>Table 7.1. <FONT SIZE=1>Infoflags</FONT> bit values
for the ImageObserver interface.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=124><I>Name</I></TD><TD WIDTH=466><I>Meaning</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>WIDTH=1</TT>
</TD><TD WIDTH=466>Width is available and can be read from the width parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>HEIGHT=2</TT>
</TD><TD WIDTH=466>Height is available and can be read from the height parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>PROPERTIES=4</TT>
</TD><TD WIDTH=466>Image properties are now available. The <TT>getProperty()</TT> method can be used.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>SOMEBITS=8</TT>
</TD><TD WIDTH=466>Additional pixels for drawing a scaled image are available. The bounding box of the pixels can be read from the x, y, width, and height parameters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>FRAMEBITS=16</TT>
</TD><TD WIDTH=466>A complete image frame has been built and can now be displayed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>ALLBITS=32</TT>
</TD><TD WIDTH=466>A complete static image has been built and can now be displayed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>ERROR=64</TT>
</TD><TD WIDTH=466>An error occurred. No further information will be available, and drawing will fail.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=124><TT>ABORT=128</TT>
</TD><TD WIDTH=466>Image processing has been aborted. Set at the same time as ERROR. If ERROR is not also set, then you may try to paint the object again.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The following routine is used to repaint the applet when a complete
image arrives:
<BLOCKQUOTE>
<TT>public boolean imageUpdate(Image whichOne,
int flags, int x, int y, int w, int h)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( (flags &amp; (ERROR | FRAMEBITS |
ALLBITS)) != 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The return value specifies whether you would like to continue
to get information on this image; returning <TT>false</TT>
will stop future notifications.
<H2><A NAME="TrackingImageLoading"><FONT SIZE=5 COLOR=#FF0000>Tracking
Image Loading</FONT></A></H2>
<P>
Image loading can also be tracked by using the MediaTracker class.
Unlike the ImageObserver interface, it will not call back when
something completes. The client of a MediaTracker object must
register images with the tracker, then ask for status. <I>Registration</I>
involves passing an image and assigning a tracking number to it,
which then is used to query for the image's status. The following
methods are available for image registration:
<UL>
<LI><TT>public void addImage(Image image,
int id);</TT>
<LI><TT>public void addImage(Image image,
int id, int w, int h);</TT>
</UL>
<P>
If a width and height are specified, the image will be scaled
to these values. You can assign the same ID to multiple images.
All the status-check routines can work on several images at once.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you assign the same ID to two or more images, then you can't check on the individual status of each image. Only group status as a whole can be checked.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can use the following routines to get status information:
<UL>
<LI><TT>public boolean checkAll();</TT>
<LI><TT>public boolean checkAll(boolean load);</TT>
<LI><TT>public void waitForAll();</TT>
<LI><TT>public boolean waitForAll(long timeout);</TT>
<LI><TT>public int statusAll(boolean load);</TT>
<LI><TT>public boolean checkID(int id);</TT>
<LI><TT>public boolean checkID(int id, boolean
load);</TT>
<LI><TT>public void waitForID(int id);</TT>
<LI><TT>public boolean waitForID(int id,
long timeout);</TT>
<LI><TT>public int statusID(int id, boolean
load);</TT>
</UL>
<P>
The MediaTracker class can be passed a load parameter. If this
parameter is <TT>true</TT>, then the
image (or images) will start to load. Remember, <TT>getImage()</TT>
does not actually load the image. MediaTracker can be used to
preload an image before it is displayed. The methods returning
a Boolean value will indicate <TT>false</TT>
unless all eligible images are complete. Images that encounter
an error are considered to be complete, so you have to check for
errors with these routines:
<UL>
<LI><TT>public boolean isErrorAny();</TT>
<LI><TT>public Object[] getErrorsAny();</TT>
<LI><TT>public boolean isErrorID(int id);</TT>
<LI><TT>public Object[] getErrorsID(int id);</TT>
</UL>
<P>
The integer returned by <TT>statusAll()</TT>
and <TT>statusID()</TT> uses a bit
flag much like <TT>imageUpdate()</TT>
does; the values for the bit flag are listed in Table 7.2. The
wait methods will block until all images are complete. You can
also specify a time-out in milliseconds that determines the maximum
time to wait.<BR>
<P>
<CENTER><B><FONT SIZE=2>Table 7.2. Status bit values for MediaTracker.</FONT></B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=112><I>Name</I></TD><TD WIDTH=293><I>Meaning</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=112><TT>LOADING=1</TT>
</TD><TD WIDTH=293>Some (or all) images are still loading.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=112><TT>ABORTED=2</TT>
</TD><TD WIDTH=293>Some (or all) images have aborted.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=112><TT>ERRORED=4</TT>
</TD><TD WIDTH=293>Some (or all) images have encountered an error.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=112><TT>COMPLETE=8</TT>
</TD><TD WIDTH=293>Some (or all) images have loaded.</TD></TR>
</TABLE></CENTER>
<H2><A NAME="TheConsumerProducerModel"><FONT SIZE=5 COLOR=#FF0000>The
Consumer/Producer Model</FONT></A></H2>
<P>
In Java, the Image class is just the tip of the iceberg; beneath
it stand the ImageConsumer and ImageProducer interfaces. Image
data is originated in an object that adheres to the ImageProducer
interface, which sends the data to an object using the ImageConsumer
interface. Figure 7.1 illustrates this relationship.
<P>
<A HREF="f7-1.gif" ><B>Figure 7.1 : </B><I>The relationship between ImageProducer and ImageConsumer </I></A>
<P>
This model allows any type of object to both originate and receive
image data. By creating the image subsystems as interfaces, Sun
has freed image production from any specific object type. This
is an important abstraction that you'll exploit in this chapter's
project.
<H2><A NAME="JavaColorModels"><FONT SIZE=5 COLOR=#FF0000>Java
Color Models</FONT></A></H2>
<P>
As stated earlier, an image is a collection of colors and their
layout. Much research has been done on how color is represented.
Humans perceive color when combinations of wavelengths of visible
light stimulate the retina. The number of wavelength combinations
is infinite, but humans can see only a fixed subset as separate
colors. Therefore, <I>color models</I> were invented to group
human-visible colors into a working set. There are two predominant
color models used to represent color information:
<UL>
<LI>The CMY (cyan-magenta-yellow) color model is used in subtractive
color systems, such as printing.
<LI>The RGB (red-green-blue) color model is used in additive color
systems, such as television and computer screens.
</UL>
<P>
Printing is a <I>subtractive system</I> because the perceived
color is contained in wavelengths of light reflected from the
paper. The absorbed colors are said to be &quot;subtracted&quot;
from the perceived color. Conversely, an <I>additive color system</I>
creates the light source containing the color. Therefore, you
can watch television in the dark, but you can't read a magazine.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you're really curious, cyan absorbs red light, magenta absorbs green light, and yellow absorbs blue light. CMY color systems subtract RGB light and thus control the appearance of RGB color on a printed page.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Java encapsulates color information for an image in the ColorModel
class. Using the model, pixel data is interpreted into a raw color
component (red, green, blue, and alpha) for display. The ColorModel
class has the following methods:
<UL>
<LI><TT>public static ColorModel getRGBdefault();</TT>
<LI><TT>public int getPixelSize();</TT>
<LI><TT>public int getRed(int pixel);</TT>
<LI><TT>public int getGreen(int pixel);</TT>
<LI><TT>public int getBlue(int pixel);</TT>
<LI><TT>public int getAlpha(int pixel);</TT>
<LI><TT>public int getRGB(int pixel);</TT>
</UL>
<P>
The lone static method returns the system default ColorModel.
<H3><A NAME="DefaultRGB">Default RGB</A></H3>
<P>
Java uses the RGB color model for all its painting; all other
models are eventually translated into this format. It has 8 bits
of red, 8 bits of green, 8 bits of blue, and 8 bits of alpha.
The alpha channel supplies transparency-255 is opaque (visible),
and 0 is transparent. These add up to 32 bits of color information,
which just happens to be the size of a Java integer. The format
of colors within an integer is <TT>0xAARRGGBB</TT>.
<P>
To support images, Java supplies two other ColorModels: DirectColorModel
and IndexColorModel.
<H3><A NAME="DirectColor">Direct Color</A></H3>
<P>
The DirectColorModel is used when the underlying pixels in an
image contain the RGB values directly. This is also known as &quot;true
color.&quot; There are two constructors-one with an alpha channel,
one without. To create the model, you need to specify only the
number of bits per pixel and which bits correspond to which color:
<UL>
<LI><TT>public DirectColorModel(int bits,
int rmask, int gmask, int bmask);</TT>
<LI><TT>public DirectColorModel(int bits,
int rmask, int gmask, int bmask, int amask);</TT>
</UL>
<P>
The mask values for Java's default RGB model are the following:
<UL>
<LI><TT>r</TT> = <TT>0x00ff0000</TT>
<LI><TT>g</TT> = <TT>0x0000ff00</TT>
<LI><TT>b</TT> = <TT>0x000000ff</TT>
<LI><TT>a</TT> = <TT>0xff000000</TT>
</UL>
<H3><A NAME="IndexColor">Index Color</A></H3>
<P>
The IndexColorModel is used when the underlying pixels in an image
represent an index into a color table. Most bitmaps fall into
this category because the actual colors are contained in a color
map somewhere in the file. The actual pixel data represent indexes
into the color map instead of complete RGB values. There are five
constructors for this model:
<UL>
<LI><TT>public IndexColorModel(int bits,
int size, byte r[], byte g[], byte b[]);</TT>
<LI><TT>public IndexColorModel(int bits,
int size, byte r[], byte g[], byte b[], int trans);</TT>
<LI><TT>public IndexColorModel(int bits,
int size, byte r[], byte g[], byte b[], byte a[]);</TT>
<LI><TT>public IndexColorModel(int bits,
int size, byte cmap[], int start, boolean hasalpha);</TT>
<LI><TT>public IndexColorModel(int bits,
int size, byte cmap[], int start, boolean hasalpha, int trans);</TT>
</UL>
<P>
The parameter <TT>bits</TT> represents
how many bits per pixel in the image, and <TT>size</TT>
specifies the length of each color array. The colors themselves
can be passed as individual arrays or packed into one large array
(all reds, then all greens, and so forth). The parameter <TT>hasalpha</TT>
signals the presence (or absence) of alpha information at the
end of the packed array, and the <TT>trans</TT>
parameter indicates which index is to be considered transparent,
regardless of its alpha channel setting.
<H2><A NAME="ChapterProjectDisplayingaWindowsBM"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project: Displaying a Windows BMP Image</FONT></A></H2>
<P>
Java has built-in support for GIF and JPEG format images, but
what if you want to display an image using a different format?
This chapter's project creates a class to display Windows BMP
images. The principles involved in the display can be applied
to almost any image format.
<H3><A NAME="UsingImageTypesNotSupportedbyJava">Using Image Types
Not Supported by Java</A></H3>
<P>
The goal of this project is to create a class that accepts a URL
and filename just as <TT>getImage()</TT>
does. Although <TT>getImage()</TT>
returns an image, the BmpImage class will return an ImageProducer.
The caller of the class will have to use the producer to create
an image:
<BLOCKQUOTE>
<TT>producer = BmpImage.getImageProducer(getCodeBase(),
&quot;Forest.bmp&quot;);<BR>
myImage = createImage(producer);<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
BmpImage could return an image, but the class would have had to be a component subclass to create an image. I didn't want to apply any restrictions to using BmpImage.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="MemoryImages">Memory Images</A></H3>
<P>
External image formats are most easily displayed by using the
Java class MemoryImageSource, which allows an arbitrary array
of pixels to be stored and used as the source for an ImageProducer.
Because MemoryImageSource uses the ImageProducer interface, it
can be used as the source for an image in the same way a GIF or
JPEG image is used. The class has six different constructors:
<UL>
<LI><TT>public MemoryImageSource(int w, int
h, ColorModel cm, byte pix[], int off, int scan);</TT>
<LI><TT>public MemoryImageSource(int w, int
h, ColorModel cm, byte pix[], int off, int scan, Hashtable props);</TT>
<LI><TT>public MemoryImageSource(int w, int
h, ColorModel cm, int pix[], int off, int scan);</TT>
<LI><TT>public MemoryImageSource(int w, int
h, ColorModel cm, int pix[], int off, int scan, Hashtable props);</TT>
<LI><TT>public MemoryImage(int w, int h,
int pix[], int off, int scan);</TT>
<LI><TT>public MemoryImage(int w, int h,
int pix[], int off, int scan, Hashtable props);</TT>
</UL>
<P>
The first four pass in a ColorModel, but the final two do not.
No ColorModel indicates that the passed pixel array uses the default
RGB model. Hashtable <TT>props</TT>
will be passed in the ImageConsumer call <TT>setProperties(Hashtable)</TT>.
Normally, the props constructors are not used unless your image
consumer uses the <TT>setProperties()</TT>
method.
<P>
Now that you know how to create a suitable ImageProducer, the
only remaining mystery is how to load and convert an arbitrary
BMP image into the correct constructor arguments for MemoryImageSource.
<H3><A NAME="LoadingForeignImages">Loading Foreign Images</A>
</H3>
<P>
Foreign images, such as BMP, are loaded by using the Java URL
class. The following code snippet creates an input stream for
a URL:
<BLOCKQUOTE>
<TT>InputStream is = new URL(getCodeBase(),
filename).openStream();</TT>
</BLOCKQUOTE>
<P>
Once created, the input stream is read until all the information
needed to create the image has been extracted.
<H3><A NAME="BMPFileFormat">BMP File Format</A></H3>
<P>
The Windows and OS/2 BMP formats are simple color map images;
Figure 7.2 lays out the formats. All quantities are in Intel little-endian
format. This means that all multibyte quantities, such as a 2-byte
short, are stored as low byte, then high byte. Java uses big endian
for all I/O reads (high byte, then low byte). You cannot use Java's
<TT>readShort()</TT> or <TT>readInt()</TT>
method to parse the file.
<P>
<A HREF="f7-2.gif" ><B>Figure 7.2 : </B><I>Layout of Windows and OS/2 BMP files </I></A>
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The 2-byte quantity <TT>0x1234</TT> appears in memory differently depending on the system's endian order. In a little-endian system, the number would be stored in memory as 34, 12 (low byte first). Big-endian systems would store the number in memory as 12, 34 (high byte first).
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Windows color maps are stored as 4 bytes per index. Each index
consists of blue, green, red, and reserved bytes, in that order.
The number of indexes is determined from either the number of
colors specified in the header or the number of bits per pixel.
If the number of colors in the header is zero, than bits per pixel
is converted into number of colors. Images having 1, 4, or 8 bits
per pixel use 2, 16, or 256 colors, respectively. OS/2 BMP images
store colors as 3 bytes per index. Each OS/2 index consists of
blue, green, and red bytes, in that order.
<H3><A NAME="ReadingUnsignedBinaryinJava">Reading Unsigned Binary
in Java</A></H3>
<P>
I created a single method to read in a multibyte little-endian
sequence:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* A private method for extracting little endian<BR>
</TT>&nbsp;<TT>* quantities from a
data input stream.<BR>
&nbsp;* @param is contains the input stream<BR>
</TT>&nbsp;<TT>* @param len is the
number of bytes in the quantity<BR>
&nbsp;* @returns the result as an integer<BR>
</TT>&nbsp;<TT>*/<BR>
private int pullVal(DataInputStream is, int len)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;throws
IOException<BR>
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
value = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int temp;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( int x = 0; x &lt; len; x++ )<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = is.readUnsignedByte();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value
+= (temp &lt;&lt; (x * 8));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
value;<BR>
}</TT>
</BLOCKQUOTE>
<P>
Each byte is read as an unsigned quantity and shifted into the
proper position before being added to the total. Little-endian
values are stored in completely reversed format, so the routine
shifts each byte in multiples of 8 bits.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Java method <TT>readUnsignedByte()</TT> returns an integer, not a byte. Java bytes are signed quantities, so a larger storage variable had to be used to contain the unsigned value.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="CreatingtheColorTable">Creating the Color Table</A>
</H3>
<P>
Since the colors are stored in RGB format, you will create separate
arrays for each color. One large array could have been used, but
managing it would have been more complex. Once the color arrays
have been stored, they are used to create a ColorModel:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* A private method for extracting the color table from<BR>
</TT>&nbsp;<TT>* a BMP type file.
<BR>
&nbsp;* @param is contains the input stream<BR>
</TT>&nbsp;<TT>* @param numColors
contains the biClrUsed (for Windows) or zero<BR>
&nbsp;*/<BR>
private void extractColorMap(DataInputStream is, int numColors)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throws IOException, AWTException<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;byte blues[], reds[], greens[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// if passed count is zero, then determine
the<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
number of entries from bits per pixel.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( numColors == 0 )<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; switch ( biBitCount )<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; case 1:&nbsp;&nbsp;numColors =&nbsp;&nbsp;&nbsp;2;
break;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
case 4:&nbsp;&nbsp;numColors =&nbsp;&nbsp;16; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; case 8:&nbsp;&nbsp;numColors = 256; break;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
case 24: numColors =&nbsp;&nbsp;&nbsp;0; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; default: numColors =&nbsp;&nbsp;-1; break;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
}<BR>
}<BR>
if ( numColors == -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw new AWTException(&quot;Invalid bits
per pixel: &quot; + biBitCount);<BR>
else if ( numColors == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;colorModel = new DirectColorModel(24,
255 * 3, 255 * 2, 255);<BR>
else<BR>
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;reds
= new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;blues = new byte[numColors];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;greens
= new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( int x = 0; x &lt; numColors; x++
)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; blues[x] = is.readByte();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
greens[x] = is.readByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; reds[x] = is.readByte();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
if ( windowsStyle )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.skipBytes(1);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;colorModel = new IndexColorModel( biBitCount,
numColors,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reds,
greens, blues );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
DirectColorModel is used for true color BMP images; IndexColorModel,
for all other representations.
<H3><A NAME="ConstructingtheImage">Constructing the Image</A>
</H3>
<P>
The image data itself is stored differently depending on the number
of bits per pixel and whether the data is compressed. BMPImage
will only support uncompressed 4 and 8 bits per pixel, though
it can easily be extended to support all other modes.
<P>
All modes store the image in rows from the bottom of the image
to the top. Yes, this means that the image is stored upside down.
For 8 bits per pixel, each row is stored as single bytes and padded
to a 4-byte boundary. The following code block extracts uncompressed,
8-bits-per-pixel images:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* A private method for extracting 8 bit per pixel<BR>
&nbsp;* image data.<BR>
&nbsp;* @param is contains the input stream<BR>
&nbsp;*/<BR>
private void extract8BitData( DataInputStream is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throws IOException<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int index;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( biCompression == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int padding = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int overage = biWidth % 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( overage != 0 )<BR>
&nbsp;&nbsp;&nbsp;padding = 4 - overage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix = new int[biHeight * biWidth];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int y = biHeight - 1; y &gt;=
0; y- )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;index = y * biWidth;<BR>
&nbsp;&nbsp;&nbsp;for ( int x = 0; x &lt; biWidth; x++ )<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pix[index++] = is.readUnsignedByte();
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;if ( padding != 0 ) is.skipBytes(padding);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Storage for 4 bits per pixel is similar to 8 bits per pixel, except
the data is stored two per byte. The next code block extracts
4 bits per pixel data:
<BLOCKQUOTE>
<TT>private void extract4BitData( DataInputStream
is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throws IOException<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int index, temp = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ( biCompression == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int padding =
0;<BR>
&nbsp;&nbsp;int overage = ((biWidth + 1)/ 2) % 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( overage !=
0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding = 4 - overage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix = new int[biHeight
* biWidth];<BR>
&nbsp;&nbsp;for ( int y = biHeight - 1; y &gt;= 0; y-- )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = y * biWidth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int x = 0; x &lt; biWidth;
x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
if on an even byte, read new 8 bit quantity<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// use low nibble of previous read for
odd bytes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( (x % 2) == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = is.readUnsignedByte();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index++] =
temp &gt;&gt; 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index++] =
temp &amp; 0x0f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( padding != 0 ) is.skipBytes(padding);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;throw new IOException(&quot;Compressed images not
supported&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
The real complication occurs when figuring the padding bytes.
If the rows have an odd number of columns, then the last pixel
will take up an entire byte. To accommodate this, the width is
bumped up by one before it is divided by two. This will force
odd-numbered columns to yield the correct number of bytes; even-numbered
columns are unaffected (see the following code lines for an example):
<BLOCKQUOTE>
<TT>11 columns: 11 / 2 = 5 [incorrect], (11
+ 1) / 2 = 6 [correct]<BR>
12 columns: 12 / 2 = 6 [correct],&nbsp;&nbsp;&nbsp;(12 + 1) /
2 = 6 [correct]</TT>
</BLOCKQUOTE>
<P>
Listing 7.1 displays the entire BmpImage class. At the bottom
of the listing, you will see a static main function; it was added
to allow testing of the class. This function allows the class
to be invoked from the command line as follows:
<BLOCKQUOTE>
<TT>java BmpImage Forest.bmp</TT>
</BLOCKQUOTE>
<P>
Although the image won't be rendered, the entire image will be
processed, and all the header contents will be displayed to the
screen. In addition, any exceptions thrown during image extraction
will be displayed.
<HR>
<BLOCKQUOTE>
<B>Listing 7.1. The BMP display class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.net.*;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
public class BmpImage<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String bfName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean imageProcessed;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean windowsStyle;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ColorModel colorModel = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int pix[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;byte bfType[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int bfSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int bfOffset;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biSize;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biWidth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biHeight;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biPlanes;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biBitCount;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biCompression;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biSizeImage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biXPelsPerMeter;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biYPelsPerMeter;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biClrUsed;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int biClrImportant;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public BmpImage(String name)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfName = name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfType = new byte[2];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageProcessed
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting little
endian<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * quantities from a input stream.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param len is the number of bytes in
the quantity<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns the result as an integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int pullVal(DataInputStream is,
int len)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int value = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int temp = 0;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ( int x =
0; x &lt; len; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= is.readUnsignedByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value
+= (temp &lt;&lt; (x * 8));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting the
file header<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * portion of a BMP file.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractFileHeader(DataInputStream
is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.read(bfType);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( bfType[0]
!= 'B' || bfType[1] != 'M' )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(&quot;Not BMP format&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfSize = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.skipBytes(4);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfOffset = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting the
color table from<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * a BMP type file.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param numColors contains the biClrUsed
(for Windows) or zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractColorMap(DataInputStream
is, int numColors)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte blues[],
reds[], greens[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if passed count
is zero, then determine the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// number of entries
from bits per pixel.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( numColors
== 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch
( biBitCount )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
1:&nbsp;&nbsp;numColors =&nbsp;&nbsp;&nbsp;2; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
4:&nbsp;&nbsp;numColors =&nbsp;&nbsp;16; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
8:&nbsp;&nbsp;numColors = 256; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
24: numColors =&nbsp;&nbsp;&nbsp;0; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
numColors =&nbsp;&nbsp;-1; break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( numColors
== -1 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(&quot;Invalid bits per pixel: &quot; + biBitCount);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( numColors
== 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorModel
= new DirectColorModel(24, 255 * 3, 255 * 2, 255);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reds
= new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blues
= new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greens
= new byte[numColors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; numColors; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blues[x]
= is.readByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greens[x]
= is.readByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reds[x]
= is.readByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( windowsStyle )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.skipBytes(1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colorModel
= new IndexColorModel( biBitCount, numColors,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
reds, greens, blues );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting an
OS/2 style<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * bitmap header.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractOS2Style(DataInputStream
is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowsStyle =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biWidth = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biHeight = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biPlanes = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biBitCount = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractColorMap(is,
0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting a Windows
style<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * bitmap header.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractWindowsStyle(DataInputStream
is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowsStyle =
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biWidth = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biHeight = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biPlanes = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biBitCount = pullVal(is,
2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biCompression
= pullVal(is, 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biSizeImage =
pullVal(is, 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biXPelsPerMeter
= pullVal(is, 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biYPelsPerMeter
= pullVal(is, 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biClrUsed = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biClrImportant
= pullVal(is, 4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractColorMap(is,
biClrUsed);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting the
bitmap header.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * This method determines the header type
(OS/2 or Windows)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * and calls the appropriate routine.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractBitmapHeader(DataInputStream
is)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biSize = pullVal(is,
4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( biSize ==
12 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractOS2Style(is);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractWindowsStyle(is);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting 4 bit
per pixel<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * image data.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extract4BitData( DataInputStream
is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index, temp
= 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( biCompression
== 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
padding = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
overage = ((biWidth + 1)/ 2) % 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( overage != 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding
= 4 - overage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix
= new int[biHeight * biWidth];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int y = biHeight - 1; y &gt;= 0; y-- )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index
= y * biWidth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; biWidth; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
if on an even byte, read new 8 bit quantity<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
use low nibble of previous read for odd bytes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( (x % 2) == 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= is.readUnsignedByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index++]
= temp &gt;&gt; 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index++]
= temp &amp; 0x0f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( padding != 0 ) is.skipBytes(padding);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IOException(&quot;Compressed images not supported&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting 8 bit
per pixel<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * image data.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extract8BitData( DataInputStream
is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( biCompression
== 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
padding = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
overage = biWidth % 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( overage != 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding
= 4 - overage;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix
= new int[biHeight * biWidth];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int y = biHeight - 1; y &gt;= 0; y-- )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index
= y * biWidth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
( int x = 0; x &lt; biWidth; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pix[index++]
= is.readUnsignedByte();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( padding != 0 ) is.skipBytes(padding);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new IOException(&quot;Compressed images not supported&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A private method for extracting the
image data from<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * a input stream.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private void extractImageData( DataInputStream
is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException,
AWTException<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( biBitCount
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(&quot;Unhandled bits/pixel: &quot; + biBitCount);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4:&nbsp;&nbsp;extract4BitData(is);
break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 8:&nbsp;&nbsp;extract8BitData(is);
break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 24:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(&quot;Unhandled bits/pixel: &quot; + biBitCount);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(&quot;Invalid bits per pixel: &quot; + biBitCount);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Given an input stream, create an ImageProducer
from<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * the BMP info contained in the stream.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param is contains the input stream
to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns the ImageProducer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ImageProducer extractImage( DataInputStream
is )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws AWTException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemoryImageSource
img = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractFileHeader(is);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractBitmapHeader(is);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractImageData(is);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= new MemoryImageSource( biWidth, biHeight, colorModel,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pix, 0, biWidth );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageProcessed
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(ioe.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Describe the image as a string<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String toString()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer buf
= new StringBuffer(&quot;&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( imageProcessed
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name: &quot; + bfName + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size: &quot; + bfSize + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;
img offset: &quot; + bfOffset + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;header
size: &quot; + biSize + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:
&quot; + biWidth + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;&nbsp;&nbsp;&nbsp;&nbsp;
height: &quot; + biHeight + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;
clr planes: &quot; + biPlanes + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;
bits/pixel: &quot; + biBitCount + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( windowsStyle )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;compression:
&quot; + biCompression + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;
image size: &quot; + biSizeImage + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;Xpels/meter:
&quot; + biXPelsPerMeter + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;Ypels/meter:
&quot; + biYPelsPerMeter + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;colors
used: &quot; + biClrUsed + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;primary
clr: &quot; + biClrImportant + &quot;\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(&quot;Image
not read yet.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return buf.toString();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A method to retrieve an ImageProducer
for a BMP URL.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param context contains the base URL
(from getCodeBase() or such)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param name contains the file name.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns an ImageProducer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception AWTException on stream or
bitmap data errors<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static ImageProducer getImageProducer(
URL context, String name )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws AWTException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream is
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
img = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage
im = new BmpImage(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is
= new URL(context, name).openStream();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
input = new DataInputStream( new<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream(is)
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= im.extractImage(input);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException
me)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(me.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(ioe.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A method to retrieve an ImageProducer
given just a BMP URL.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param context contains the base URL
(from getCodeBase() or such)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @returns an ImageProducer<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @exception AWTException on stream or
bitmap data errors<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static ImageProducer getImageProducer(
URL context)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws AWTException
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream is
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
img = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name =
context.toString();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index; //
Make last part of URL the name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((index = name.lastIndexOf('/'))
&gt;= 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= name.substring(index + 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage
im = new BmpImage(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is
= context.openStream();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
input = new DataInputStream( new<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream(is)
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img
= im.extractImage(input);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (MalformedURLException
me)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(me.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException
ioe)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new AWTException(ioe.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * A public test routine (you must pass
the filename as the 1st arg)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main( String args[]
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream
inFile = new FileInputStream(args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
is = new DataInputStream( new<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream(inFile)
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BmpImage
im = new BmpImage(args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
img = im.extractImage(is);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Output:\n&quot;
+ im);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch ( Exception
e )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>}
</BLOCKQUOTE>
<HR>
<P>
This class supports both Windows and OS/2 format bitmaps. OS/2
image data is identical to Windows image data, though OS/2 supports
only uncompressed formats.
<P>
The concepts used to create the BMP image can also be applied
to other image formats. The steps can be boiled down to the following
list:
<UL>
<LI><FONT COLOR=#000000>Acquire the input stream for the image
data.</FONT>
<LI><FONT COLOR=#000000>Parse the image data to extract and create
a ColorModel.</FONT>
<LI><FONT COLOR=#000000>Extract the image data into an array that
conforms to the ColorModel previously created.</FONT>
<LI><FONT COLOR=#000000>Use the model and data to create a MemoryImageSource
object that acts as the ImageProducer for the image.</FONT>
</UL>
<P>
Listing 7.2 shows a simple applet that uses BmpImage to display
a bitmap.
<HR>
<BLOCKQUOTE>
<B>Listing 7.2. The SimpleBmp applet used to exercise the BmpImage
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.applet.*;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
import BmpImage;<BR>
<BR>
public class SimpleBmp extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean init = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image myImage = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard initialization method for
an applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProducer
producer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( init == false
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer
= BmpImage.getImageProducer(getCodeBase(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;Forest.bmp&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myImage
= createImage(producer);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(AWTException ae)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(ae.toString());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Standard paint routine for an applet.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param g contains the Graphics class
to use for painting<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(myImage,
0, 0, this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covers Java image concepts, including loading and
display. Remember the image producer/consumer model; you'll see
it recur whenever you deal with images. The Java color models-direct
and indexed-are also important concepts. The producer/consumer
and color models combine to enable you to render an almost infinite
number of image types and formats. The chapter ends by demonstrating
a class for reading and displaying image formats that Java doesn't
directly support. <A HREF="ch8.htm" >Chapter 8</A>, &quot;Adding
Threads to Applets,&quot; will explore image loading and tracking
in more depth, so you can make use of the material covered in
this chapter.
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



