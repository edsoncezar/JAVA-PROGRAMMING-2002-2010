<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 11</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Building a Live Data Applet</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ObserversandtheModelViewParadigm" >Observers and the Model-View Paradigm</A>
<LI><A HREF="#ChapterProject" >Chapter Project</A>
<UL>
<LI><A HREF="#GeneralArchitectureoftheProject" >General Architecture of the Project</A>
<LI><A HREF="#ChangestotheServer" >Changes to the Server</A>
<LI><A HREF="#AppletClient" >Applet Client</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter concludes Part IV with an application that brings
together most of the JDK features you have seen throughout this
book. The application is an Election Night applet that shows election
returns as they arrive. It can do this because the applet gets
datagrams from a back-end Web server that broadcasts returns as
they are entered into a server database. This client-server application
is Internet-ready! You can run the server on the host and have
multiple clients connect to your site to see the live returns.
<P>
This application brings in many of the JDK's major components,
such as AWT, threads and synchronization, streams, exception handling,
native methods, and sockets. Because of the project's size, many
less critical but useful components are also applied-such as the
Hashtable class, static methods, and string parsing. Some new
concepts are also introduced; for example, the model-view paradigm
is covered briefly before you get into the heart of the chapter
project.
<H2><A NAME="ObserversandtheModelViewParadigm"><FONT SIZE=5 COLOR=#FF0000>Observers
and the Model-View Paradigm</FONT></A></H2>
<P>
One problem that programmers often face is showing different views
of data that may change over time. A classic example of this is
a spreadsheet with multiple graphs (this sounds familiar!). If
the spreadsheet were tied to a relational database, traditional
programmers would represent the graph by making SQL calls to the
same set of tables the spreadsheet uses. However, if the spreadsheet
changes (and, therefore, its underlying table structure), the
graph programs would need to be modified, also. In other words,
the spreadsheet structure is closely tied to both the spreadsheet
program and the graphs that use its data.
<P>
The problem can get even worse if the graphs must update themselves
as the spreadsheet data changes. How do the graphs monitor the
data? Should the graphs keep querying the data to see whether
it has changed? This would be inefficient from a performance standpoint
since such data will probably not change much from second to second,
although it can change dramatically over longer periods of time.
Furthermore, with multiple graphs and a spreadsheet constantly
accessing the data, the database host's performance will be strained.
<P>
The <I>model-view paradigm</I> offers a solution to these problems
with two fundamental tenets: Separate the underlying data model
from the programs that view (use) this data, and let the underlying
data model inform the views that something has changed, which
prevents the view from having to constantly query the data. To
illustrate the first tenet being applied, take a look again at
the spreadsheet applet developed in Part II. The data was maintained
in the CellContainer class, whose only function was the proper
upkeep of the spreadsheet data. The CellContainer class provided
a &quot;model&quot; for the spreadsheet data. There were three
&quot;views&quot; on the data-the two graphs and the spreadsheet
itself. The latter was represented by the SpreadsheetContainer
class, which simply uses the CellContainer model. For example,
the SpreadsheetContainer didn't have any responsibility for verifying
a formula or evaluating its results-that was the job of the model.
In a sense, the SpreadsheetContainer was little more than a &quot;dumb&quot;
view of the model.
<P>
The second tenet of the model-view paradigm is how to let a view
know when a model has changed. For this situation, the Observable
class and Observer interface in the java.util package offer an
effective solution. The Observable class represents the model.
To create an Observable model, you need to build a subclass of
Observable. Observer objects can then attach to your model; when
the model changes, you notify the observers.
<P>
In the applet portion of the chapter project, a class called ElectionTable
maintains a local cache of election results on a state-by-state
and grand-total basis; it is a direct subclass of Observable.
When its data is modified, it notifies the Observer objects of
the changes:
<BLOCKQUOTE>
<TT>setChanged();<BR>
notifyObservers();</TT>
</BLOCKQUOTE>
<P>
The first method, <TT>setChanged()</TT>,
tells the Observable class that the model has been modified. When
a notify method is next called (immediately afterward, in this
case), the Observable class checks to see whether the data has
changed and, if so, broadcasts a notification to the observers.
Table 11.1 lists a summary of the Observable class's methods.
<BR>
<P>
<CENTER><B>Table 11.1. The Observable class's methods.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=163><I>Method</I></TD><TD WIDTH=427><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>addObserver</TT>
</TD><TD WIDTH=427>Add an Observer object to the list of observers.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>deleteObserver</TT>
</TD><TD WIDTH=427>Remove an Observer from the observer list.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>deleteObservers</TT>
</TD><TD WIDTH=427>Clear the observer list.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>notifyObservers</TT>
</TD><TD WIDTH=427>Notify all the Observers that the data has changed. One version of this method has an optional parameter to send data about what was modified.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>setChanged</TT>
</TD><TD WIDTH=427>Signals internally that a change has occurred.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>hasChanged</TT>
</TD><TD WIDTH=427>Returns whether the data has changed.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>countObservers</TT>
</TD><TD WIDTH=427>Returns a count of all the Observers.</TD>
</TR>
</TABLE></CENTER>
<P>
<P>
The Observer interface has only one method, <TT>update()</TT>.
It takes as its parameters the Observable object and an object
that can be used to convey more information about what has changed.
The Observer object hooks to the Observable object through the
<TT>addObserver()</TT> method. In
this chapter's project, the two observers simply repaint when
they get an <TT>update()</TT> message.
<H2><A NAME="ChapterProject"><FONT SIZE=5 COLOR=#FF0000>Chapter
Project</FONT></A></H2>
<P>
This chapter project demonstrates an applet and corresponding
Java server used to show you election night returns as they come
in. When you select the Election home page, the applet connects
to the server and is added to a list of registrants to be notified
whenever election data changes. The server uses its local database
to check for any incoming election returns. When they occur, the
server broadcasts the results to the client applets. The applets,
in turn, update themselves to show the latest totals.
<P>
To add a little fun to the project, the system was designed for
the likely 1996 presidential election between the incumbent and
his challenger. (Note that it wouldn't be hard to change the project
if a third-party candidate throws a monkey wrench into this mix,
since the project is mostly driven by the database. However, a
few assumptions about there being two candidates were made.) Figure
11.1 shows the Election applet before the returns start rolling
in, Figure 11.2 illustrates what the applet might look like later
in the evening, and Figure 11.3 shows the applet as the election
reaches its possible conclusion. This last figure demonstrates
the applet with its graphical view turned on.
<P>
<A HREF="f11-1.gif" ><B>Figure 11.1 : </B><I>The Election applet before the election returns start rolling in.</I></A>
<P>
<A HREF="f11-2.gif" ><B>Figure 11.2 : </B><I>The Election applet as the evening progresses. It's a close one.</I></A>
<P>
<A HREF="f11-3.gif" ><B>Figure 11.3 : </B><I>The applet as the election reaches in climax-who is going to win?</I></A>
<P>
You are given a database consisting of filled-in states and corresponding
electoral votes. However, the totals are left blank. If you want,
you can rig the election in favor of the candidate of your choice!
<H3><A NAME="GeneralArchitectureoftheProject">General Architecture
of the Project</A></H3>
<P>
The general architecture of this project is based on the project
architecture from <A HREF="ch10.htm" >Chapter 10</A>, &quot;Native
Methods and Java.&quot; For the sake of clarity, a visual overview
of the architecture is repeated in Figure 11.4. Refer to <A HREF="ch10.htm" >Chapter 10</A>
for a description of the general architecture and detailed server
and database implementation, but a couple of additional points
about the structure of the project are covered here. Furthermore,
a full description of the client applet will follow in the section
&quot;Applet Client.&quot;
<P>
<A HREF="f11-4.gif" ><B>Figure 11.4 : </B><I>The project architecture.</I></A>
<P>
The hierarchy of the server environment is as follows: The server
classes should be placed in the parent directory (which could
be in a variety of places); the database (ELECT.DBF) can also
be in this directory, but if your ODBC data source is set up properly,
the database can be located elsewhere.
<P>
Underneath the parent is a directory called <I>htdocs</I>. The
only file it must have is index.html, which is the HTML for the
applet at hand. Located underneath htdocs is a <I>classes</I>
subdirectory. This will contain classes and any additional files
the client applet will need.
<P>
To start the server, go to the parent directory and type:
<BLOCKQUOTE>
<TT>java BasicWebServer</TT>
</BLOCKQUOTE>
<P>
An additional <TT>debug 1</TT> parameter
will display debug information about the server.
<H3><A NAME="ChangestotheServer">Changes to the Server</A></H3>
<P>
As in the previous chapter, the ElectionServer class is used to
send data to multiple client applets. It does this at the behest
of the BasicWebServer class because it implements the LiveDataServer
interface. The main part of this Thread class is its <TT>run()</TT>
method, which constantly looks for new data and broadcasts its
results to the client applets. This code was slightly modified
from <A HREF="ch10.htm" >Chapter 10</A> for a fuller implementation
of the election night project. Only the <TT>run()</TT>
method was modified, as illustrated in Listing 11.1.
<HR>
<BLOCKQUOTE>
<B>Listing 11.1. Changes to the </B><TT><B><FONT SIZE=1 FACE="Courier">run()</FONT></B></TT><B>
method of the ElectionServer Class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Run method for this thread.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Recheck the database every 30 seconds
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * and send changed data<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Resend all data every couple minutes.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int timestamp = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int iterationsBeforeFull = 60;&nbsp;&nbsp;//
Fifteen minutes<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int iteration = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( results !=
null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(30);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLStmt
nn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
After so many iterations, resend all data...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(iteration &gt;= iterationsBeforeFull) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nn = election.sql(&quot;select * from election order by </TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>state,candidate&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
synchronized (results)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results
= nn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
servThread.sendToUsers(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatResults(&quot;RESULTS&quot;,
results));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
iteration = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
// end full if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Otherwise just check timestamps...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
partialSQL =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;select
* from election where updated &gt; '&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestampToChar(timestamp)
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;'
order by state,candidate&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nn
= election.sql(partialSQL);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Make sure a valid number of rows is returned...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((nn.numRows() &gt; 0) &amp;&amp; ((nn.numRows()%2) == 0) ) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send data and update timestamp...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servThread.sendToUsers(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatResults(&quot;RESULTS&quot;,
nn));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++timestamp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++iteration;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(DBException de)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Error:
&quot; + de);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Note that the database used here does not have a &quot;triggering&quot; capability as many relational databases do. With triggers, the database would update the server, much like the model-view paradigm discussed earlier. This is much better than having the server query the database all the time.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
There were mainly two changes to the method. The first was the
introduction of partial updates. After broadcasting all the election
data (in the <TT>NewRegistrant()</TT>
method, which is not listed here), the server loops and waits
for partial updates. The server uses the timestamp mechanism discussed
in the next section, &quot;Database,&quot; to see whether data
has changed. Every 30 seconds, the server queries the database
to see whether any data has been added with a timestamp older
than the current timestamp. If not, the server sleeps again and
then retries. If new data is found, the changes are broadcast
to the client applets. The timestamp is then incremented and the
process repeats itself.
<P>
The other change in the server's <TT>run()</TT>
method is indicated by the <I>iteration</I> variable. Every 15
minutes, the server rebroadcasts <I>all</I> of the data to the
clients. This might seem unnecessary, but remember that the datagram
protocol used to transmit data is unreliable, and packets could
be lost. Given this, it's possible that the clients might not
have received some earlier updates. However, you could increase
the rebroadcast time to a higher value, such as 30 minutes, an
hour, or more. The right figure for this will depend on a variety
of factors, including the size and sensitivity of your data.
<H4>Database</H4>
<P>
The database used in this chapter is generally the same dBASE
IV table described in the previous chapter. An UPDATED field was
added so that changes can be timestamped, thus allowing the server
to download only the state information that has changed.
<P>
A couple of other things should be mentioned about the database.
First of all, a blank version of the database can be found in
the file NEWELECT.DBF located on the CD-ROM. It has all the states,
candidates, and electoral votes. Data that changes over time,
such as the popular vote, is initialized to zero. Since the runtime
server uses ELECT.DBF, you can simply replace NEWELECT.DBF to
generate a clean database after the ELECT.DBF data is modified
for testing.
<P>
Another peculiarity of the table is that the ELECTORAL field initially
has negative numbers. The absolute value of the negative numbers
symbolizes the number of electoral votes a state carries. If the
number is positive, it indicates that the corresponding candidate
has won the state. A normalized database would have been a better
solution here (separate tables for state information and declared
winners), but it didn't seem appropriate to focus on this aspect
of the project.
<P>
Yet another curiosity is the UPDATED field. Since the native method's
ODBC driver implements only character data types, all the fields
in the database need to be of a character type. Unfortunately,
this makes timestamping a little tricky, so timestamps in this
project have the following format: <TT>000XXX</TT>.
That is, all timestamps need to be prefixed by zeroes to produce
a timestamp six characters long. So the first stamp would be 000001,
the hundredth would be 000100, and so on. If your server updates
aren't working properly, be careful how you enter the timestamps
in the database.
<P>
After sending data down the first time, the server retrieves partial
updates based on a timestamp. Although internally it is a number,
it's in the format just described in the database. Any database
rows with a timestamp higher than the last timestamp are made
part of any new partial update broadcasts. Once the database timestamp
is surpassed by the external timestamp, the corresponding row
is no longer sent down as part of a partial update. The server
will always print out the current timestamp it is working on.
Suppose it is 000003, and you want to update the data. You can
do this by changing <I>both</I> entries of the candidates in a
state and setting the timestamp to 000004. The data will then
be sent down in the next partial update broadcast and should show
up in your applet.
<H3><A NAME="AppletClient">Applet Client</A></H3>
<P>
The Election applet continually gives you updated election results
as they arrive to the server. The applet consists of basically
two parts: back-end threads to manage the arrival of datagrams
with the latest election results from the server and a front-end
that displays the results in either a graphical or text-based
format. The network-processing classes were mostly developed in
the previous two chapters; the display classes are new for this
chapter.
<H4>Class Organization</H4>
<P>
Table 11.2 lists the classes used in this chapter's Election applet.
Since many of these classes were created in the previous section,
the new classes are specified by having their names in boldface
type; the classes that were modified have their names italicized.
<BR>
<P>
<CENTER><B>Table 11.2. The Election applet classes and interfaces.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=186><I>Class/Interface</I></TD><TD WIDTH=404><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>Candidate</B></TD><TD WIDTH=404>An accessor class that keeps vote totals for a specific candidate.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>ClientPacketAssembler</TD><TD WIDTH=404>Tracks and assembles blocks of data packets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>ClientRegistration</TD><TD WIDTH=404>For registering as a new client.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>ClientUnregistration</TD><TD WIDTH=404>For removing client registration with server.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>DGTPClient</TD><TD WIDTH=404>To receive dynamic data updates from server.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Election</TD><TD WIDTH=404>The class for the Election applet that implements the LiveDataNotify interface to manage dynamic data from the server and creates components for visual display.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>ElectionTable</B></TD><TD WIDTH=404>Keeps local copy of election results from the server. Uses synchronization so that incoming DGTP data does not collide with reads from visual components.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>ElectionUpdater</B></TD><TD WIDTH=404>Periodically causes update of Election's visual components.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>LiveDataNotify</TD><TD WIDTH=404>Interface that defines methods for handling dynamic delivery of data from the server.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>PartialPacket</TD><TD WIDTH=404>Private class used by ClientPacketAssembler for assembling packets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>StateBreakdownCanvas</B></TD><TD WIDTH=404>ElectionTable observer that displays results of individual states in text or graphics format.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>StateEntry</B></TD><TD WIDTH=404>Simple accessor class that keeps all election data related to a specific state.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><B>SummaryCanvas</B></TD><TD WIDTH=404>ElectionTable observer that displays national election totals.
</TD></TR>
</TABLE></CENTER>
<P>
<H4>How It Works</H4>
<P>
Figure 11.5 illustrates the workflow of the Election applet. The
DGTPClient object receives datagrams from the server indicating
the latest election results. This data may be a partial update
of just the states that have changed, or it may be a broadcast
of the full election results. In either case, the Election object
receives the new data since it implements the LiveDataNotify interface.
<P>
<A HREF="f11-5.gif" ><B>Figure 11.5 : </B><I>Data flow of the Election applet.</I></A>
<P>
The Election object parses the data and passes it to the ElectionTable
object. The ElectionTable class has only one instance since it
has a private constructor; objects that use the data must get
a reference to the table object from a public ElectionTable method.
The Election object is the only object that updates the table
and does so when it's notified by the DGTPClient with new data.
When you get the first full batch of election data, with all the
states identified, the ElectionTable object creates a private
table of the individual state and summary totals. This table is
updated by any calls that follow.
<P>
ElectionTable is an instance of the Observable class. It notifies
its two Observers, the StateBreakdownCanvas and SummaryCanvas,
whenever its data change. These two Canvas objects implement the
Observer interface and are mainly responsible for displaying the
election information. The ElectionUpdater thread runs in the background,
periodically forcing refreshes of the Canvas objects.
<P>
Since the underlying classes that implement the network interfaces
haven't changed since the previous chapter, the discussion that
follows will focus on the classes involved in the visual interface.
<H4>The Election Class</H4>
<P>
The Election class runs the Election applet. It implements the
LiveDataNotify interface so that it can be notified whenever the
DGTPClient gets new election data packets. The Election class
also creates the two components that display the election results-the
StateBreakdownCanvas and SummaryCanvas classes. Listing 11.2 shows
the Election class's code.
<P>
Several important things happen at initialization. In the <TT>init()</TT>
method, the first step is to get an applet parameter that specifies
the port the server is listening on, then initializes the display.
It creates a panel at the top of the screen so that you can toggle
between a text-based or graphical display. The Election class
then creates the components that display the election results
and starts a simple thread, ElectionThread, that periodically
causes the applet to repaint. This is needed because paint messages
could be lost if election returns come in rapid-fire fashion.
The last step in the <TT>init()</TT>
method is to resize the applet so that it's large enough to show
all of the state returns.
<P>
The other major thing that happens at initialization occurs when
the <TT>start()</TT> method is first
called. The Election class creates an instance of the DGTPClient
class, specifying itself as the LiveDataNotify parameter-this
ensures that the Election applet is notified of all incoming datagrams.
<P>
The DGTPClient calls the Election class's <TT>recvNewData()</TT>
method when data has arrived. The Election class then parses this
data into a large two-dimensional String array, which is then
passed to the ElectionTable class that provides the data's final
storage location.
<HR>
<BLOCKQUOTE>
<B>Listing 11.2. The Election class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This class starts the Election applet.
It implements<BR>
// the LiveDataNotify interface that sends the latest<BR>
// results to it.&nbsp;&nbsp;It creates objects to display the
<BR>
// returns as they arrive.<BR>
public class Election extends Applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;implements LiveDataNotify<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static final int SPACING = 70;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean init = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DGTPClient ct = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int destPort;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String destHost = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String numUsers = &quot;Unknown at this
time&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String users = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String results[][];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int nRows = 0, nCols = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Place canvas drawing objects...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SummaryCanvas sc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;StateBreakdownCanvas states;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Checkbox graphView,textView;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Panel p;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( init == false
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Initialize network connections...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
strPort = getParameter(&quot;PORT&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( strPort == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
PORT parameter is missing&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strPort
= &quot;4545&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destPort
= Integer.valueOf(strPort).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destHost
= getDocumentBase().getHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Initialize AWT components...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Do basic setup...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Add panel to set views...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p
= new Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckboxGroup
cg = new CheckboxGroup();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graphView
= new Checkbox(&quot;Graphical View&quot;,cg,false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textView
= new Checkbox(&quot;Text View&quot;,cg,true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.add(graphView);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.add(textView);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;,p);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Add summary information at top of applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc
= new SummaryCanvas(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Show state breakdowns...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states
= new StateBreakdownCanvas(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Create update thread...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread
t = new ElectionUpdater(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Resize to fit all the states...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension
d = size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics
fm = Toolkit.getDefaultToolkit().getFontMetrics(getFont());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
height = sc.getHeight() + states.getHeight()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+
(2 * fm.getHeight());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(d.width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Update message sent when repainting is needed...
<BR>
&nbsp;&nbsp;&nbsp;// Prevent paint from getting cleared out...
<BR>
&nbsp;&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;// If table is ready, paint all the canvases...
<BR>
&nbsp;&nbsp;&nbsp;public synchronized void paint(Graphics g) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(ElectionTable.getElectionTable().ready())
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dimension d = size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int height = g.getFontMetrics(getFont()).getHeight();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y = 2 * height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = sc.paint(g,0,y,d.width);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += states.paint(g,0,y,d.width,d.height
- y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;Registered
Users: &quot; + getUsers(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10,d.height
- height);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Toggle radio buttons...<BR>
&nbsp;&nbsp;&nbsp;public boolean action(Event ev,Object o) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ev.target instanceof Checkbox)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ev.target.equals(graphView))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states.setMode(StateBreakdownCanvas.GRAPHICS);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.setMode(SummaryCanvas.GRAPHICS);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states.setMode(StateBreakdownCanvas.TEXT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc.setMode(SummaryCanvas.TEXT);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getDestHost()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destHost;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int getDestPort()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return destPort;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void recvNewData(byte[]
newDataBlock, boolean error)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( error
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ct.send(&quot;REFRESH&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String cmd
= new String(newDataBlock, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
cmds = new StringTokenizer(cmd, &quot; \t&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String current
= cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (current.equals(&quot;CLIENTS&quot;))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
users = cmds.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if
(current.equals(&quot;RESULTS&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nRows = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nCols = Integer.valueOf(cmds.nextToken()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
results = new String[nRows][nCols];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( int x = 0; x &lt; nRows; x++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for ( int y = 0; y &lt; nCols; y++ )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;results[x][y]
= cmds.nextToken(&quot;|\r\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Update the election table with the new data...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ElectionTable.getElectionTable().tableUpdate(nRows,results);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// QUERY
response is unimplemented because<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this
applet currently sends no QUERY commands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if
(current.equals(&quot;QUERY_RSP&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized String getUsers()
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (users != null)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
users;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return numUsers;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct = new DGTPClient(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Election.stop()&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct.terminate();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void connectRefused()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>The ElectionTable Class</H4>
<P>
The ElectionTable class, shown in Listing 11.3, creates a private
table of the individual state and summary totals. Since ElectionTable
is responsible for keeping the local cache of the election data,
it isn't allowed to be instantiated by an external class. The
table has only one instance because it has a private constructor;
objects that use the data must get a reference to the table object
from a public ElectionTable method called <TT>getElectionTable()</TT>.
<P>
An internal array, called <TT>states</TT>,
maintains each state's election information. It is composed of
StateEntry objects that contain electoral information about the
state, as well as the state totals of the two candidates. The
<TT>states</TT> array is not created
in the constructor; rather, it's created when data is first received
in the <TT>tableUpdate()</TT> method,
the only entry point into the table for updating data. When the
<TT>states</TT> array is null, it
is set up in the <TT>initializeTable()</TT>
method. All subsequent updates (called through the <TT>partialUpdate()</TT>
method) are applied to the <TT>states</TT>
array created at initialization. These write methods are synchronized
to prevent any collisions by other threads reading data.
<P>
After each update, ElectionTable compiles the state totals to
get the summary figures by using the <TT>updateTotals()</TT>
method. Since ElectionTable is an instance of the Observable class,
it notifies its observers of the changes at the end of the <TT>tableUpdate()</TT>
method.
<P>
The observers use the <TT>getStates()</TT>
method to walk through the results of the individual states. This
method has an interesting solution to the synchronization problem,
such as when an update occurs while an observer is reading the
state information. The <TT>getStates()</TT>
method makes a shallow copy of the <TT>states</TT>
array; it's &quot;shallow&quot; because it copies only the array
references and not the actual state elements. If an update thread
modifies the original States table, it doesn't affect the copy
the reader has because the update makes new StateEntry objects
for each update. Therefore, the reader won't be adversely affected
by any updates.
<HR>
<BLOCKQUOTE>
<B>Listing 11.3. The ElectionTable class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.lang.*;<BR>
import java.util.Observable;<BR>
<BR>
// This class keeps a local cache of the election results<BR>
// The table can only be created once so constructor is private...
<BR>
// A producer thread keeps the table updated<BR>
public class ElectionTable extends Observable {<BR>
 // The table is static and so can be created only once<BR>
&nbsp;&nbsp;private static ElectionTable table = new ElectionTable();
<BR>
<BR>
&nbsp;&nbsp;// Data objects...<BR>
&nbsp;&nbsp;Candidate Incumbent;<BR>
&nbsp;&nbsp;Candidate Challenger;<BR>
&nbsp;&nbsp;int totalPopular;<BR>
&nbsp;&nbsp;static StateEntry states[];<BR>
<BR>
&nbsp;&nbsp;// Create the table information...<BR>
&nbsp;&nbsp;private ElectionTable() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up the candidates...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incumbent = new Candidate(&quot;Incumbent&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Challenger = new Candidate(&quot;Challenger&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not ready yet...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states = null;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Get reference to election table...<BR>
&nbsp;&nbsp;public static synchronized ElectionTable getElectionTable()
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return table;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// See if table is ready...<BR>
&nbsp;&nbsp;public static synchronized boolean ready() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ((states != null) ?
(true) : (false));<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Update the states table with new values...<BR>
&nbsp;&nbsp;public void tableUpdate(int rows,String results[][])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (states == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializeTable(rows,results);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partialUpdate(rows,results);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update totals...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateTotals();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Notify observers of changes...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Initialize the table with the first batch of data...
<BR>
&nbsp;&nbsp;// Code ASSUMES that the results are ordered by<BR>
&nbsp;&nbsp;// state and then candidate<BR>
&nbsp;&nbsp;private static synchronized void initializeTable(int
rows,String results[][]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateEntry newState;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the state array...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states = new StateEntry[rows/2];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go through each row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = j = 0; i &lt; rows;
i+=2,++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newState
= createStateEntry(i,results);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now add
to state array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states[j]
= newState;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Update just parts of the table...<BR>
&nbsp;&nbsp;private void partialUpdate(int rows,String results[][])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateEntry newState;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Kick out if rows is not
a multiple of 2<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((rows % 2) != 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Data
not formatted right. Rejected.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Go through each row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = j = 0; i &lt; rows;
i+=2,++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
new state table...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newState
= createStateEntry(i,results);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now update
state array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stateUpdate(newState);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Take index into results table and get a StateEntry
<BR>
&nbsp;&nbsp;// object from it...<BR>
private static StateEntry createStateEntry(int index,String results[][])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Candidate newChallenger;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Candidate newIncumbent;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String stateName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double precincts = 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int electoral = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int candElectoral = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int IncumbentVotes = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ChallengerVotes = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = index;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// First
row is Challenger. Get his and state info...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = results[i][1];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stateName
= s.trim();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get precinct,
electoral,votes...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= results[i][2];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChallengerVotes
= Integer.valueOf(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.trim()).intValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= results[i][3];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precincts
= Double.valueOf(s.trim()).doubleValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= results[i][4];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;electoral
= Math.abs(Integer.valueOf(s.trim()).intValue());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral
= Integer.valueOf(s.trim()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(candElectoral &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Format
error: &quot; + e.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = results[i][0];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newChallenger
= new Candidate(s.trim(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral,
ChallengerVotes);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now get
Incumbent info...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= results[i][2];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncumbentVotes
= Integer.valueOf(s.trim()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= results[i][4];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral
= Integer.valueOf(s.trim()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(candElectoral &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Format
error: &quot; + e.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = results[i][0];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIncumbent
= new Candidate(s.trim(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candElectoral,IncumbentVotes);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Return
state entry field...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new
StateEntry(stateName,precincts,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;electoral,(IncumbentVotes
+ ChallengerVotes),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIncumbent,
newChallenger);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Get table of state listings.&nbsp;&nbsp;This is
a copy of the<BR>
&nbsp;&nbsp;// state entry TABLE, but not the individual listings.&nbsp;&nbsp;This
<BR>
&nbsp;&nbsp;// solves synchronization problems.&nbsp;&nbsp;The
user of the table<BR>
&nbsp;&nbsp;// will get the references to the states but does
not actually<BR>
&nbsp;&nbsp;// have references to the actual keys used by the
ElectionTable<BR>
&nbsp;&nbsp;// class.<BR>
&nbsp;&nbsp;public synchronized StateEntry[] getStates() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (states == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
states;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateEntry tempStates[] =
new StateEntry[states.length];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; states.length;
++i)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempStates[i]
= states[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tempStates;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Get candidate total information...<BR>
&nbsp;&nbsp;public synchronized Candidate getIncumbent() {<BR>
&nbsp;&nbsp;&nbsp;return Incumbent;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public synchronized Candidate getChallenger() {<BR>
&nbsp;&nbsp;&nbsp;return Challenger;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Update the totals for each Candidate...<BR>
&nbsp;&nbsp;public synchronized void updateTotals() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ChallengerPopular = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ChallengerElectoral =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int IncumbentPopular = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int IncumbentElectoral = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalPopular = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate the totals...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; states.length;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChallengerPopular
+= states[i].getChallenger().getPopular();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChallengerElectoral
+= states[i].getChallenger().getElectoral();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncumbentPopular
+= states[i].getIncumbent().getPopular();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IncumbentElectoral
+= states[i].getIncumbent().getElectoral();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalPopular
+= states[i].getTotalVotes();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update the Candidates...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incumbent = new Candidate(&quot;Incumbent&quot;,IncumbentElectoral,IncumbentPopular);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Challenger = new Candidate(&quot;Challenger&quot;,ChallengerElectoral,
</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>ChallengerPopular);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Take a state field and find spot in state<BR>
&nbsp;&nbsp;// table to update...<BR>
&nbsp;&nbsp;public synchronized void stateUpdate(StateEntry newState)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name = newState.getName();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; states.length;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Replace
state that matches current entry...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (name.equals(states[i].getName()))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;states[i]
= newState;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
System.out.println(&quot;STATE UPDATE ERROR!&quot;);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Get total popular vote...<BR>
&nbsp;&nbsp;public synchronized int getTotalPopular() {<BR>
&nbsp;&nbsp;&nbsp;return totalPopular;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Get info for a specific state...<BR>
&nbsp;&nbsp;private synchronized StateEntry getState(String name)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; states.length;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Replace
state that matches current entry...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (name.equals(states[i].getName()))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
states[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
System.out.println(&quot;STATE GET ERROR!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>The Candidate Class</H4>
<P>
Listing 11.4 displays the Candidate class, which contains the
name and vote totals of a specific candidate. Although it's a
simple accessor class, it effectively functions as a row in a
virtual table of candidates.
<HR>
<BLOCKQUOTE>
<B>Listing 11.4. The Candidate class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This is a simple accessor class to
keep information<BR>
// about candidates...<BR>
public class Candidate {<BR>
&nbsp;&nbsp;&nbsp;String Name;&nbsp;&nbsp;// Name of candidate
<BR>
&nbsp;&nbsp;&nbsp;int totalElectoral;&nbsp;&nbsp;// Electoral
votes so far...<BR>
&nbsp;&nbsp;&nbsp;int votePopular;&nbsp;&nbsp;// Popular vote...
<BR>
&nbsp;&nbsp;&nbsp;// Create object with states long name and abbreviation
<BR>
&nbsp;&nbsp;&nbsp;public Candidate(String Name) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Name = Name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalElectoral = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;votePopular = 0;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Candidate with new totals...<BR>
&nbsp;&nbsp;&nbsp;public Candidate(String Name,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int totalElectoral,int votePopular) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Name = Name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.totalElectoral = totalElectoral;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.votePopular = votePopular;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Access the variables...<BR>
&nbsp;&nbsp;&nbsp;public String getName() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Name;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public int getElectoral() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return totalElectoral;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public int getPopular() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return votePopular;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>The StateEntry Class</H4>
<P>
Listing 11.5 displays the StateEntry class, which contains general
electoral votes of the state, the percent of precincts counted
so far, and the total number of votes cast. It also holds Candidate
objects for the two candidates. The StateEntry class, coupled
with the Candidate class, provides for normalized data, something
that was missing in the back-end database.
<HR>
<BLOCKQUOTE>
<B>Listing 11.5. The StateEntry class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This is a simple accessor class to
keep information<BR>
// about candidates and corresponding state totals...<BR>
public class StateEntry {<BR>
&nbsp;&nbsp;&nbsp;String Name;&nbsp;&nbsp;// Name of state<BR>
&nbsp;&nbsp;&nbsp;int electoral; // Number of electoral votes
<BR>
&nbsp;&nbsp;&nbsp;int totalVotes; // Total number of votes in
state<BR>
&nbsp;&nbsp;&nbsp;double precincts; // % of precincts counted
<BR>
&nbsp;&nbsp;&nbsp;Candidate Incumbent;&nbsp;&nbsp;// The two candidates
<BR>
&nbsp;&nbsp;&nbsp;Candidate Challenger;<BR>
&nbsp;&nbsp;&nbsp;// Create object with states long name and abbreviation
<BR>
&nbsp;&nbsp;&nbsp;public StateEntry(String Name) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Name = Name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precincts = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;electoral = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalVotes = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incumbent = new Candidate(&quot;Incumbent&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Challenger = new Candidate(&quot;Challenger&quot;);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Candidates with new totals...<BR>
&nbsp;&nbsp;&nbsp;public StateEntry(String Name,double precincts,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int electoral,int totalVotes,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Candidate Incumbent, Candidate Challenger)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Name = Name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.totalVotes = totalVotes;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.precincts = precincts;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.electoral = electoral;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Incumbent = Incumbent;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Challenger = Challenger;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;// Access the variables...<BR>
&nbsp;&nbsp;&nbsp;public String getName() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Name;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public int getElectoral() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return electoral;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public int getTotalVotes() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return totalVotes;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public double getPrecincts() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return precincts;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Get candidate-state information...<BR>
&nbsp;&nbsp;&nbsp;public Candidate getIncumbent() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return Incumbent;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public Candidate getChallenger() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return Challenger;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>The StateBreakdownCanvas Class</H4>
<P>
The StateBreakdownCanvas class displays the election results on
a state-by-state basis, as shown in Listing 11.6. The class can
show the data graphically or in a primarily text-based format,
indicated by its mode. If the canvas is in graphical mode, it
shows the popular vote as a bar graph representing the percentages
of each candidate in the state.
<P>
When the StateBreakdownCanvas is initialized, it sets up a variety
of variables used when painting the canvas. Its last step is to
declare itself an observer of the ElectionTable by calling its
<TT>addObserver()</TT> method. When
the table changes, the canvas's <TT>update()</TT>
method is called, which results in the canvas being repainted
to yield the new results.
<P>
The <TT>paint()</TT> method uses many
of the techniques discussed elsewhere in this book. The most interesting
thing about it, however, is that the canvas occurs over a large
area, bigger than most screens. However, most browsers-such as
Netscape Navigator-support large applets. If you scroll down the
applet, you will see the other state totals. Figure 11.6 shows
what the StateBreakdownCanvas looks like when the Election applet,
while set in graphical mode, is scrolled down toward the middle
of the state listings.
<P>
<A HREF="f11-6.gif" ><B>Figure 11.6 : </B><I>The Election applet set in graphical mode.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 11.6. The StateBreakdownCanvas class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.Applet;<BR>
import java.util.Observable;<BR>
import java.util.Observer;<BR>
<BR>
// This canvas shows the breakdown of each state<BR>
// by candidate. An Observer of the election table<BR>
// is added and is called when election<BR>
// data has changed which forces update<BR>
public class StateBreakdownCanvas extends Canvas implements Observer
{<BR>
&nbsp;&nbsp;&nbsp;Applet a; // The applet<BR>
&nbsp;&nbsp;&nbsp;Font fonts[];&nbsp;&nbsp;// Font to display...
<BR>
&nbsp;&nbsp;&nbsp;int fontHeight; // Quick reference of font height...
<BR>
&nbsp;&nbsp;&nbsp;int totalWidth;&nbsp;&nbsp;// Width coordinates...
<BR>
&nbsp;&nbsp;&nbsp;int colStart[];<BR>
&nbsp;&nbsp;&nbsp;Rectangle lastPaint; // Keep track of last paint...
<BR>
&nbsp;&nbsp;&nbsp;// Various display strings...<BR>
&nbsp;&nbsp;&nbsp;String titleBanner = &quot;1996 ELECTION RETURNS&quot;;
<BR>
&nbsp;&nbsp;&nbsp;String winner = &quot;WINNER!&quot;;<BR>
&nbsp;&nbsp;&nbsp;String headers[] = { &quot;State&quot;, &quot;Electoral&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Precincts %&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Candidate&quot;, &quot;Popular
Vote&quot; };<BR>
&nbsp;&nbsp;&nbsp;// Graphics or text mode.<BR>
&nbsp;&nbsp;&nbsp;public static final int TEXT = 0;<BR>
&nbsp;&nbsp;&nbsp;public static final int GRAPHICS = 1;<BR>
&nbsp;&nbsp;&nbsp;int mode = TEXT;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Calculate some dimension information...<BR>
&nbsp;&nbsp;&nbsp;public StateBreakdownCanvas(Applet app) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create display fonts...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts = new Font[2];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts[0] = new Font(&quot;Helvetica&quot;,Font.BOLD,12);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts[1] = new Font(&quot;Helvetica&quot;,Font.PLAIN,12);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get font height info...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fm = Toolkit.getDefaultToolkit().getFontMetrics(fonts[0]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontHeight = fm.getHeight();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Initialize column width
displays...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart = new int[5];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[0] = fm.stringWidth(&quot;
&quot; + winner + &quot;!! &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[1] = colStart[0]
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(1.25
*(double)fm.stringWidth(&quot;New Jersey!!!&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[2] = colStart[1]
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(1.25
*(double)fm.stringWidth(headers[1]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[3] = colStart[0];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[4] = colStart[1];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalWidth = colStart[2] +
fm.stringWidth(headers[2]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make Canvas an observer
of the ElectionTable...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = app;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElectionTable.getElectionTable().addObserver(this);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Get target height...<BR>
&nbsp;&nbsp;&nbsp;public int getHeight() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 3 * 53 * fontHeight;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set the mode to paint in...<BR>
&nbsp;&nbsp;&nbsp;public void setMode(int mode) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mode = mode;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called when Table changes....<BR>
&nbsp;&nbsp;&nbsp;public void update(Observable o, Object arg)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (lastPaint != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.repaint(lastPaint.x,lastPaint.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPaint.width,lastPaint.height);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Paint the summary totals...<BR>
&nbsp;&nbsp;&nbsp;public int paint(Graphics g,int xOrg,int yOrg,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int width, int totalHeight) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the background color
to white...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y = yOrg + fontHeight;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.white);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(xOrg,yOrg,width,totalHeight);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPaint = new Rectangle(xOrg,yOrg,width,totalHeight);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint the header...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 5;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(headers[i],colStart[i],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i ==
2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[1]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
+= fontHeight;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw line across bottom...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(colStart[0],y,totalWidth,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeight;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now get the listing of
states...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double graphicsWidth = (double)(totalWidth
- colStart[1]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double percent;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StateEntry[] stateData =ElectionTable.getElectionTable().getStates();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Walk through each state...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; stateData.length;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
the state information...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.black);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[0]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(stateData[i].getName(),colStart[0],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(Integer.toString(stateData[i].getElectoral()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[1],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(Double.toString(stateData[i].getPrecincts()),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[2],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Print
the candidates...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Incumbent...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[1]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeight;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Candidate
c = stateData[i].getIncumbent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if
he won the state...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c.getElectoral()
&gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(winner,2,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(c.getName(),colStart[0],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get election
percentage...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (stateData[i].getTotalVotes()
&gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= ((double)c.getPopular()) /<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)stateData[i].getTotalVotes());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw
text or graphics based on mode...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode
!= GRAPHICS) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= Integer.toString(c.getPopular()) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
(&quot; + ((float)(percent * 100.00) ) + &quot;%)&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(s,colStart[1],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(stateData[i].getTotalVotes() &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length
= (int)(percent * graphicsWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(colStart[1],y
- fontHeight + 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length,fontHeight
- 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// then
Challenger...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeight;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = stateData[i].getChallenger();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See if
he won the state...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c.getElectoral()
&gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(winner,2,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(c.getName(),colStart[0],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get election
percentage...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (stateData[i].getTotalVotes()
&gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= ((double)c.getPopular()) /<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)stateData[i].getTotalVotes());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw
text or graphics based on mode...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode
!= GRAPHICS) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= Integer.toString(c.getPopular()) +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
(&quot; + ((float)(percent * 100.00) ) + &quot;%)&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(s,colStart[1],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(stateData[i].getTotalVotes() &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length
= (int)(percent * graphicsWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(colStart[1],y
- fontHeight + 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length,fontHeight
- 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeight;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return totalHeight;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H4>The SummaryCanvas Class</H4>
<P>
The SummaryCanvas class, whose code is given in Listing 11.7,
displays the election results on a national basis. It, too, can
show the data graphically or in a primarily text-based format,
depending on its mode. If the canvas is in graphical mode, then
it shows the popular vote as a bar graph representing the percentages
of each candidate in the state.
<P>
When the SummaryCanvas is initialized, it sets up variables used
when painting the canvas. The canvas also declares itself an observer
of the ElectionTable by calling its <TT>addObserver()</TT>
method. When the table changes, then the canvas's <TT>update()</TT>
method is called. This repaints the canvas, yielding the new results.
<HR>
<BLOCKQUOTE>
<B>Listing 11.7. The SummaryCanvas class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.util.Observable;<BR>
import java.util.Observer;<BR>
import java.applet.Applet;<BR>
<BR>
// This canvas shows the top banner and the<BR>
// election totals...<BR>
// The Observer is called when election<BR>
// data has changed and, if so, forces update<BR>
public class SummaryCanvas extends Canvas implements Observer
{<BR>
&nbsp;&nbsp;&nbsp;Applet a; // The applet<BR>
&nbsp;&nbsp;&nbsp;int totalWidth;&nbsp;&nbsp;// Width coordinates...
<BR>
&nbsp;&nbsp;&nbsp;int colStart[];<BR>
&nbsp;&nbsp;&nbsp;Font fonts[];&nbsp;&nbsp;// Font to display...
<BR>
&nbsp;&nbsp;&nbsp;int fontHeights[]; // Quick reference of font
heights...<BR>
&nbsp;&nbsp;&nbsp;int topMargin; // Where to start painting...
<BR>
&nbsp;&nbsp;&nbsp;int totalHeight; // How much to paint...<BR>
&nbsp;&nbsp;&nbsp;Rectangle lastPaint; // Keep track of last paint...
<BR>
&nbsp;&nbsp;&nbsp;// Various display strings....<BR>
&nbsp;&nbsp;&nbsp;String titleBanner = &quot;1996 ELECTION RETURNS&quot;;
<BR>
&nbsp;&nbsp;&nbsp;String headers[] = { &quot;Candidate&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Electoral Total&quot;,
&quot;Popular Vote&quot; };<BR>
&nbsp;&nbsp;&nbsp;String winner = &quot;WINNER!&quot;;<BR>
&nbsp;&nbsp;&nbsp;// Graphics or text mode.<BR>
&nbsp;&nbsp;&nbsp;public static final int TEXT = 0;<BR>
&nbsp;&nbsp;&nbsp;public static final int GRAPHICS = 1;<BR>
&nbsp;&nbsp;&nbsp;int mode = TEXT;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Calculate some dimension information...<BR>
&nbsp;&nbsp;&nbsp;public SummaryCanvas(Applet app) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create display fonts...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts = new Font[3];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts[0] = new Font(&quot;Helvetica&quot;,Font.BOLD,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts[1] = new Font(&quot;Helvetica&quot;,Font.BOLD,12);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fonts[2] = new Font(&quot;Helvetica&quot;,Font.PLAIN,12);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Initialize column width
array...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart = new int[3];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the font and use to
calculate some margins...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontHeights = new int[3];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 3;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fm = Toolkit.getDefaultToolkit().getFontMetrics(fonts[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fontHeights[i]
= fm.getHeight();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topMargin = fontHeights[0];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fm = Toolkit.getDefaultToolkit().getFontMetrics(fonts[1]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[0] = fm.stringWidth(&quot;
&quot; + winner + &quot;!! &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[1] = colStart[0]
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(1.5
*(double)fm.stringWidth(headers[0]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[2] = colStart[1]
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(1.5
*(double)fm.stringWidth(headers[1]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalWidth = colStart[2] +
fm.stringWidth(headers[2]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalHeight = 8 * fontHeights[1];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Make Canvas an observer
of the ElectionTable...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = app;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElectionTable.getElectionTable().addObserver(this);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Get target height...<BR>
&nbsp;&nbsp;&nbsp;public int getHeight() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return totalHeight;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Set the mode to paint in...<BR>
&nbsp;&nbsp;&nbsp;public void setMode(int mode) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.mode = mode;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Called when Table changes....<BR>
&nbsp;&nbsp;&nbsp;public void update(Observable o, Object arg)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (lastPaint != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.repaint(lastPaint.x,lastPaint.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPaint.width,lastPaint.height);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// Paint the summary totals...<BR>
&nbsp;&nbsp;&nbsp;public int paint(Graphics g,int xOrg,int yOrg,int
width) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the background color
to white...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y = yOrg + topMargin;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.white);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(xOrg,yOrg,width,totalHeight);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPaint = new Rectangle(xOrg,yOrg,width,totalHeight);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint the title banner...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = g.getFontMetrics();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = (width - fm.stringWidth(titleBanner))/2;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(titleBanner,x,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeights[0];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint the header...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[1]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fm = g.getFontMetrics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 3;
++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(headers[i],colStart[i],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw line across bottom...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(colStart[0],y,totalWidth,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeights[1];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Display the candidate totals...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(fonts[2]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double graphicsWidth =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double)(totalWidth
- colStart[2] + fm.stringWidth(winner) );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElectionTable t = ElectionTable.getElectionTable();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int totalPopular = t.getTotalPopular();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Show Incumbent...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int electoral,length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Candidate c = t.getIncumbent();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;electoral = c.getElectoral();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (electoral &gt;= 270)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(winner,2,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(c.getName(),colStart[0],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(Integer.toString(electoral),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[1],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double percent;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get popular vote percentage...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (totalPopular &gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= ((double)c.getPopular()) /<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)totalPopular);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint Text or Graphics?
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode != GRAPHICS) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = Integer.toString(c.getPopular())
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
(&quot; + ((float)(percent * 100.00) ) + &quot;%)&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(s,colStart[2],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(totalPopular &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length
= (int)(percent * graphicsWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(colStart[2],y
- fontHeights[2] + 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length,fontHeights[2]
- 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += fontHeights[2];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Show Challenger...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// *********<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = t.getChallenger();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;electoral = c.getElectoral();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (electoral &gt;= 270)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(winner,2,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(c.getName(),colStart[0],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(Integer.toString(electoral),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colStart[1],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get popular vote percentage...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (totalPopular &gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= ((double)c.getPopular()) /<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)totalPopular);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percent
= 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Paint Text or Graphics?
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode != GRAPHICS) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = Integer.toString(c.getPopular())
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
(&quot; + ((float)(percent * 100.00) ) + &quot;%)&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(s,colStart[2],y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(totalPopular &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length
= (int)(percent * graphicsWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(colStart[2],y
- fontHeights[2] + 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length,fontHeights[2]
- 1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return yOrg + totalHeight;
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This part of the book has brought together many of Java's most
powerful elements. Sockets and streams are used to manage network
connections, features of AWT are used to display the election
results, and multithreading and synchronization constructs are
used to run the applet and server application efficiently. The
result is a large project that concludes the project-development
portion of this book. Part V, &quot;Advanced Applet Development,&quot;
will focus on smaller, standalone projects, giving you more exposure
to the subtleties of Java.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



