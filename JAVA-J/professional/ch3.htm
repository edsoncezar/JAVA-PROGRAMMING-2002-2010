<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 3</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Building a Spreadsheet Applet</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#OverviewofAWTPart1" >Overview of AWT: Part 1</A>
<UL>
<LI><A HREF="#AWTClasses" >AWT Classes</A>
<LI><A HREF="#ComponentsandContainers" >Components and Containers</A>
<LI><A HREF="#Layouts" >Layouts</A>
<LI><A HREF="#EventHandling" >Event Handling</A>
</UL>
<LI><A HREF="#ExceptionClasses" >Exception Classes</A>
<UL>
<LI><A HREF="#TheThrowableClass" >The Throwable Class</A>
<LI><A HREF="#ExceptionClassHierarchy" >Exception Class Hierarchy</A>
<LI><A HREF="#ExceptionHandlersandThrowableClasses" >Exception Handlers and Throwable Classes</A>
<LI><A HREF="#WritingCustomExceptionHandlers" >Writing Custom Exception Handlers</A>
<LI><A HREF="#ClassOrganization" >Class Organization</A>
<LI><A HREF="#TheCellClass" >The Cell Class</A>
<LI><A HREF="#TheCellContainerClass" >The Cell Container Class</A>
<LI><A HREF="#TheFormulaParserClass" >The FormulaParserClass</A>
<LI><A HREF="#TheFormulaParserExceptionClass" >The FormulaParserException Class</A>
<LI><A HREF="#TheArgValueClass" >The ArgValue Class</A>
<LI><A HREF="#TheSpreadsheetCellClass" >The SpreadsheetCell Class</A>
<LI><A HREF="#TheSpreadsheetContainerClass" >The SpreadsheetContainer Class</A>
<LI><A HREF="#TheSpreadsheetFrameClass" >The SpreadsheetFrame Class</A>
<LI><A HREF="#TheSpreadsheetAppletclass" >The SpreadsheetApplet class</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>This chapter starts with an overview of AWT
(the Abstract Window Toolkit) and its general features and then
details the basic structure of AWT and its most important classes.
A discussion of more advanced aspects of exception handling follows.
AWT and exception handling will be important in developing the
first version of the spreadsheet applet, discussed in detail in
the last section of this chapter. The visual and user-interface
features of the applet will rely on AWT. The underlying spreadsheet
engine will make active use of exception handling, particularly
when validating and calculating formulas.</FONT>
<H2><A NAME="OverviewofAWTPart1"><FONT SIZE=5 COLOR=#FF0000>Overview
of AWT: Part 1</FONT></A></H2>
<P>
AWT forms the basis for graphical user-interface programming in
Java. The AWT package offers a large variety of tools for creating
graphic widgets such as buttons, list boxes, and scrollbars. A
graphics class can be used for two-dimensional drawing operations,
such as displaying polygons, painting text, and setting fonts
and colors, and graphical operations, such as clipping and scaling.
Beyond all this, AWT provides an underlying foundation for interfacing
with the user. A series of methods handle events produced by the
user and the system, such as mouse clicks and keystrokes. In short,
AWT gives you a set of tools for writing simple applets and a
basis for developing classes that can be used to create more sophisticated
programs. <A HREF="ch4.htm" >Chapters 4</A>, &quot;Enhancing the
Spreadsheet Applet,&quot;and 5, &quot;Adding Graphs and Scrollbars
to the Spreadsheet,&quot; will have the other parts of the AWT
tutorial.
<H3><A NAME="AWTClasses">AWT Classes</A></H3>
<P>
Figure 3.1 illustrates the hierarchy of the most important classes
in the AWT package; they are used for a variety of services:
<P>
<A HREF="f3-1.gif" >Figure 3.1 : <I>Hierarchy of significant AWT classes.</I></A>
<UL>
<LI><B>Component</B> is the foundation of controls such as buttons
and labels. It is also the superclass of more sophisticated controls,
such as dialog boxes, and even the Applet class.
<LI><B>Container</B> is a class that contains Components or other
Containers.
<LI><B>Panel</B> is a visual Container that can be used to hold
other components, such as buttons, list boxes, and other Containers.
<LI><B>Applet</B> is the base class for creating an applet. It
starts the program and ties it to the native browser.
<LI><B>Window</B> is used for popup-style components, such as
dialog boxes.
<LI><B>Font</B> can be used to create fonts customized by such
features as point size and style.
<LI><B>Event</B> encapsulates user- and system-initiated events,
such as mouse clicks, keyboard strokes, and the shutdown of an
applet.
<LI><B>Graphics</B> is mainly used when a Component needs painting.
This class encapsulates a wide range of functions, including drawing
polygons, text, and images, plus setting the Fonts and Colors
to create what is drawn.
<LI><B>MenuComponent</B> provides the foundation for creating
drop-down, checkbox, and other menus.
</UL>
<P>
Most of these classes are discussed and illustrated in more detail
throughout this and subsequent chapters.
<H3><A NAME="ComponentsandContainers">Components and Containers</A>
</H3>
<P>
Component classes are used for coordinating all aspects of a visual
control. A variety of Component methods can be used to process
events, enable or disable a control, set fonts and colors, and
manage the control's visual display. The most widely used Components
will be those simple ones that are part and parcel of creating
a user interface. These include labels, buttons, list boxes, and
choice menus. However, more sophisticated Component subclasses
can be used to manage these primitive controls. The following
list shows the primitive Component classes; these simpler classes
are derived directly from Component.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=511><I>Primitive Component Classes</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=511>
<BLOCKQUOTE>
Button<BR>
Canvas<BR>
Checkbox<BR>
CheckboxGroup<BR>
Choice<BR>
Label<BR>
List<BR>
Scrollbar<BR>
TextComponent<BR>
TextArea (extends TextComponent)<BR>
TextField (extends TextComponent)</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The Component hierarchy complements these primitive controls with
classes based on the Container class. Containers are used to hold
Component classes and other Containers. Panels, Windows, Dialogs,
and Applets are all notable Container subclasses. The Container
classes are presented in more detail shortly.
<P>
You can use the primitive controls in Table 3.1 to quickly produce
a functional applet. Figure 3.2 shows such an applet; with five
components, it enables the user to choose what to display and
when to display it. A choice between painting nothing, a rectangle,
or text is offered. The class that does the drawing is a custom
subclass of the Canvas Component called DrawCanvas, located in
the middle of the applet. At the bottom of the screen is a Panel
with Button and Choice objects. The Choice menu object lets the
user decide what is to be painted when the Button object is clicked
(or when the applet repaints). A TextField object at the top of
the screen is used to specify which text will be displayed, if
text is used.
<P>
<A HREF="f3-2.gif" ><B>Figure 3.2 </B>: <I>Example with five companents</I></A>
<P>
Listing 3.1 provides the code for this example. Although the applet
is simple, it illustrates a lot of features. The <TT>init()</TT>
portion of the applet class (called <TT>Example1</TT>)
shows how easy it is to create and add classes to the applet display.
The <TT>handleEvent()</TT> method
overrides the default event handler and is used to trap button
clicks. The code checks to see whether the action came from its
button. If so, it forces the DrawCanvas object to repaint. The
user's selection in the Choice box will then be reflected.
<P>
The DrawCanvas class inherits the features of Canvas and adds
its own custom functions to it. When it is drawn with the <TT>paint()</TT>
method, the class queries the applet about the user's selections
and paints accordingly. This <TT>paint()</TT>
method can be issued either when the user clicks the button or
when a certain region of the canvas needs to be redrawn. The <TT>paint()</TT>
method is part of all Component classes. It must be overridden,
as in the DrawCanvas class, if any custom drawing needs to be
done.
<P>
The <TT>paint()</TT> method takes
as its sole parameter an instance of the Graphics class. This
class offers different methods that can be used to set the features
of the area being drawn. For example, the DrawCanvas class uses
the <TT>drawString()</TT> method to
put some text up on the drawing area. The <TT>drawRect()</TT>
and <TT>fillRect()</TT> methods paint
a rectangle that draws a border rectangle and its interior, respectively.
These rectangles are painted a color established by the <TT>setColor()</TT>
method. Since the <TT>paint()</TT>
method and the Graphics class are at the basis of drawing AWT
images, you will see more examples of these throughout the rest
of the book.<BR>
<HR>
<BLOCKQUOTE>
<B>Listing 3.1. An applet with five components.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.io.*;<BR>
import java.applet.*;<BR>
<BR>
// This program illustrates a simple applet with a <BR>
TextField,<BR>
<BR>
// Panel, Button, Choice menu, and Canvas.<BR>
public class Example1 extends Applet&nbsp;&nbsp;{<BR>
TextField tf;<BR>
DrawCanvas c;<BR>
Button drawBtn;<BR>
Choice ch;<BR>
// Add the Components to the screen...<BR>
public void init() {<BR>
<BR>
&nbsp;// Set up display area...<BR>
&nbsp;resize(300,200);<BR>
&nbsp;setLayout(new BorderLayout());<BR>
<BR>
&nbsp;// Add the components...<BR>
&nbsp;// Add the text at the top.<BR>
&nbsp;tf = new TextField();<BR>
&nbsp;add(&quot;North&quot;,tf);<BR>
<BR>
</TT>&nbsp;<TT>// Add the custom Canvas
to the center<BR>
&nbsp;c = new DrawCanvas(this);<BR>
&nbsp;add(&quot;Center&quot;,c);<BR>
<BR>
</TT>&nbsp;<TT>// Create the panel
with button and choices at the <BR>
bottom...<BR>
&nbsp;Panel p = new Panel();<BR>
&nbsp;drawBtn = new Button(&quot;Draw Choice Item&quot;);<BR>
&nbsp;p.add(drawBtn);<BR>
&nbsp;// Create the choice box and add the options...<BR>
&nbsp;ch = new Choice();<BR>
&nbsp;ch.addItem(&quot;Rectangle&quot;);<BR>
&nbsp;ch.addItem(&quot;Empty&quot;);<BR>
&nbsp;ch.addItem(&quot;Text&quot;);<BR>
&nbsp;p.add(ch);<BR>
&nbsp;add(&quot;South&quot;,p);<BR>
}<BR>
<BR>
// Handle events that have occurred<BR>
public boolean handleEvent(Event evt) {<BR>
switch(evt.id) {<BR>
</TT>&nbsp;<TT>// This can be handled
<BR>
&nbsp;case Event.ACTION_EVENT: {<BR>
&nbsp;&nbsp;if(evt.target instanceof Button)&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;// Repaint canvas to use new choices...<BR>
&nbsp;&nbsp;&nbsp;c.repaint();<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end if<BR>
&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>default:<BR>
&nbsp;&nbsp;return false;<BR>
&nbsp;}<BR>
}<BR>
<BR>
// Return the current choice to display...<BR>
public String getChoice() {<BR>
&nbsp;return ch.getSelectedItem();<BR>
}<BR>
<BR>
// Return the text in the list box...<BR>
public String getTextString() {<BR>
&nbsp;return tf.getText();<BR>
}<BR>
}<BR>
<BR>
// This is a custom canvas that is used for drawing<BR>
// text, a rectangle, or nothing...<BR>
class DrawCanvas extends Canvas {<BR>
Example1 e1app;<BR>
&nbsp;// Constructor - store the applet to get drawing <BR>
info...<BR>
&nbsp;public DrawCanvas(Example1 a) {<BR>
&nbsp;&nbsp;e1app = a;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// Draw the image per
the choices in the applet...<BR>
&nbsp;public synchronized void paint (Graphics g) {<BR>
&nbsp;&nbsp;// Get the current size of the display area...<BR>
&nbsp;&nbsp;Dimension dm = size();<BR>
&nbsp;&nbsp;// Draw based on choice...<BR>
&nbsp;&nbsp;String s = e1app.getChoice();<BR>
&nbsp;&nbsp;// Calculate center coordinates...<BR>
&nbsp;&nbsp;int x,y,width,height;<BR>
&nbsp;&nbsp;x = dm.width/4;<BR>
&nbsp;&nbsp;y = dm.height / 4;<BR>
&nbsp;&nbsp;width = dm.width / 2;<BR>
&nbsp;&nbsp;height = dm.height / 2;<BR>
&nbsp;&nbsp;// Paint a rectangle in the center...<BR>
&nbsp;&nbsp;if (s.compareTo(&quot;Rectangle&quot;) == 0) {<BR>
&nbsp;&nbsp;&nbsp;// Draw the rectangle in the center with colors!
<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;g.drawRect(x,y,width,height);<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;g.fillRect(x + 1,y + 1,width - 2,height - 2);
<BR>
&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;// Get the text in the applet and display in the 
<BR>
middle...<BR>
&nbsp;&nbsp;if (s.compareTo(&quot;Text&quot;) == 0) {<BR>
&nbsp;&nbsp;&nbsp;String displayText = e1app.getTextString();
<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;g.drawString(displayText,x,y + (height/2));
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The other Component in this example is a Panel, which is a subclass
of Container. In the example, the Panel contains the Button and
Choice objects. Containers are good for managing a group of Components
and have a special meaning in AWT regarding how an object is displayed.
Containers function as a broker for how a component within it
is presented. If a component's display coordinates are outside
the region of a container, it is clipped. More importantly, Containers
provide a mechanism for <I>how</I> an object is presented, especially
its size and position. This is closely tied to how Layouts work,
discussed briefly in the following section.
<P>
One interesting aspect of AWT is that the Applet class is derived
from Panel. This may seem unusual at first; however, an Applet
really functions as a Container. Objects that do not fit within
its area are clipped in display, and if the Applet is destroyed,
so are the objects within it. Given this, the Applet class can
be easily understood as simply a Panel with additional functions
that tie it to the workings of the native browser.
<P>
The Window, Frame, and Dialog classes are also Containers that
figure prominently. These are used to create objects that &quot;pop
up&quot; outside the space of the applet, giving a multidimensional
feel to an otherwise &quot;flat&quot; Web page. These classes
will be discussed in more detail in the next chapter.
<H3><A NAME="Layouts">Layouts</A></H3>
<P>
For someone who has not seen Java applet code before, one question
that might immediately come to mind from the previous example
is: How does the program know where to position the Component
objects on the screen? After all, there is no coordinate information
in the code. And what do code expressions like <TT>add(&quot;North&quot;,
tf)</TT> mean?
<P>
The key to understanding the previous code and how AWT displays
components in general is a knowledge of layouts. Containers rely
on layouts to give you a way to determine the size and position
of the components within it. Every container is tied to a single
instance of a layout. The layout that a container uses is either
set by default or through programming. In Listing 3.1, the layout
of the Applet object, Example1, is set to an instance of the BorderLayout
class by the line:
<BLOCKQUOTE>
<TT>setLayout(new BorderLayout());</TT>
</BLOCKQUOTE>
<P>
Since the Panel class is also a container, it too has a layout.
The default class, FlowLayout, is used in the example.
<P>
Layouts are an important part of AWT because they take care of
a major issue in Java: portability. Although the language portion
of Java takes care of software portability concerns, it cannot,
by nature, take care of visual portability issues. Namely, how
can Java guarantee that an applet developed on a specific GUI
(such as Windows 95) and on a specific monitor resolution (such
as VGA) have a proper look and feel on other platforms? The AWT
package was designed to solve this problem. By providing a level
of abstraction above the native GUI, it can hide the specifics
of the underlying environment from the developer. Layouts are
key elements of the visual part of the abstraction mechanism.
By taking control of the sizing and positioning of components,
layouts free the developer from having to worry about how to write
an applet that looks good on the variety of monitor resolutions
in the field. Layouts dynamically calculate how to present a component
by looking at the native display-coordinate system at runtime;
the sizing and positioning of the components is based on this
runtime information.
<P>
All layouts are derived from the LayoutManager interface, which
specifies how a layout needs to function. AWT provides five classes
(described in the following sections) that set up the LayoutManager
interface. This range of layouts allows the developer to choose
the appropriate layout manager for the requirements at hand; if
these choices aren't enough, a new class can be written. In fact,
Java developers have already created several custom layout classes.
Various incarnations of a RelativeLayout class have been created
that lets you state where components go in relation to each other.
By navigating the Java home pages on the Internet, you might find
a layout class that better fits your development needs. Some of
the entry points to Java on the Internet are mentioned in this
book's Introduction.
<H4>Border Layout</H4>
<P>
In Listing 3.1, the applet specifies adding new components through
an unusual scheme that uses such terms as &quot;North&quot; and
&quot;South&quot;. This scheme reflects how the BorderLayout class
works. In the example, BorderLayout is tied to the Example1 applet
class when the <TT>setLayout()</TT>
method is invoked. This method indicates that the Example1 object,
which is an instance of Container, is tied to the BorderLayout
object. When a Container uses BorderLayout, a Component is added
through a command of this form:
<BLOCKQUOTE>
<TT>add(String direction, Component);</TT>
</BLOCKQUOTE>
<P>
Direction is one of the following Strings: <TT>&quot;North&quot;</TT>,
<TT>&quot;South&quot;</TT>, <TT>&quot;East&quot;</TT>,
<TT>&quot;West&quot;</TT>, and <TT>&quot;Center&quot;</TT>.
In short, the BorderLayout class uses a directional scheme to
position a component based on one of the five direction strings.
A component set to the <TT>&quot;North&quot;</TT>
direction is set to the top of the container, one that is set
to <TT>&quot;South&quot;</TT> is positioned
at the bottom, and so forth. The size of the components is determined
by other runtime information, such as the size of the container
(usually set by the <TT>resize()</TT>
method) and the attributes of the displayed component. The default
behavior of BorderLayout gives the component set to the <TT>&quot;Center&quot;</TT>
direction any space not used by the other components. In Listing
3.1, the Example1 applet dimensions are set to 300<FONT FACE="Symbol">&#165;</FONT>200
pixels. The TextField and Panel objects are relatively small and
so are set comfortably at the top and bottom of the applet. The
remaining display is then used for the <TT>&quot;Center&quot;</TT>
component, the DrawCanvas object. This object takes up the bulk
of the applet display area.
<P>
That the BorderLayout class can display up to only five components
(corresponding to the five directions) might concern users; however,
this is not really a problem. Recall that since containers can
hold other containers, this limitation does not really exist.
Consequently, an applet can contain Panel objects, which in turn
can contain other containers, and so forth.
<P>
In the example, the Panel class is used to align the button and
choice box on the same row. The Panel class can be used as a kind
of &quot;toolbar,&quot; displaying components along the top or
bottom of the screen. It exemplifies this behavior because its
default layout is the FlowLayout class (see the following section).
<H4>Flow Layout</H4>
<P>
The FlowLayout class is good for displaying components horizontally
across the container. It is the default layout for Panels, which
can be set to function like a toolbar or to contain related Components,
such as OK and Cancel buttons. In most cases, the FlowLayout class
will present components across a single row. However, if the components
do not fit on one row, a new row is started.
<P>
Figure 3.3 illustrates a modification of Listing 3.1, which adds
another Choice menu to the left of the button (whose text has
been modified). The canvas uses this new Choice object to pick
the color used to paint the object chosen in the other Choice
menu. Since the order of when a component is added to a container
is important in determining the layout display, the color Choice
object is added before the button.
<P>
<A HREF="f3-3.gif" ><B>Figure 3.3 </B>: <I>Second version, illustrating FlawLayout</I></A><I>.</I>
<P>
The following code modifies the <TT>init()</TT>
method in Listing 3.1 to build the Panel object shown in Figure
3.4. It is inserted in the source code after the DrawCanvas object
is created, but before the Button is made.
<BLOCKQUOTE>
<TT>// Create the panel with button and choices
at <BR>
bottom...<BR>
Panel p = new Panel();<BR>
// Explicitly set to flow layout...<BR>
p.setLayout(new FlowLayout());<BR>
// Add color choice to left of button...<BR>
colorChoice = new Choice();<BR>
colorChoice.addItem(&quot;Yellow&quot;);<BR>
colorChoice.addItem(&quot;Red&quot;);<BR>
colorChoice.addItem(&quot;Blue&quot;);<BR>
p.add(colorChoice);<BR>
// Add button...</TT>
</BLOCKQUOTE>
<P>
The code explicitly creates a new FlowLayout object for the Panel
to use. This is unnecessary, but it illustrates how a FlowLayout
object could be set up for Container objects in general.
<P>
To use the color Choice menu in the DrawCanvas code, add a method
to the Example1 class to return the color selection:
<BLOCKQUOTE>
<TT>// Get the color to be displayed....
<BR>
// Convert the String to a Color object<BR>
Color getColor() {<BR>
 String s = colorChoice.getSelectedItem();<BR>
 if (s.compareTo(&quot;Yellow&quot;) == 0)<BR>
&nbsp;&nbsp;return Color.yellow;<BR>
 if (s.compareTo(&quot;Red&quot;) == 0)<BR>
&nbsp;&nbsp;return Color.red;<BR>
 return Color.blue;<BR>
}</TT>
</BLOCKQUOTE>
<P>
The DrawCanvas class modifies its color code to get the color
choice from the applet class:
<BLOCKQUOTE>
<TT>g.setColor(e1app.getColor());</TT>
</BLOCKQUOTE>
<P>
You can specify other features of FlowLayout to customize its
appearance. By default, components within a container using FlowLayout
are aligned along the center. However, alternative FlowLayout
constructors can be used to align the components to the left or
the right. Figure 3.4 shows how the Panel in the example would
look if it were right-aligned. The following code line is all
you need to add to modify how the layout is established:
<BLOCKQUOTE>
<TT>p.setLayout(new FlowLayout(FlowLayout.RIGHT));</TT>
</BLOCKQUOTE>
<P>
You can specify the number of pixels between the components in
a container using FlowLayout in an alternative constructor. This
difference in the spacing between the components is known as the
<I>gap value</I>. Both the horizontal and vertical gap values
can be set in FlowLayout. Most of the LayoutManager classes support
setting gaps. The discussion of the next layout, GridLayout, will
illustrate how to use gap values.
<P>
<A HREF="f3-4.gif" ><B>Figure 3.4 </B>: <I>The FlawLayout panel is right-justified.</I></A>
<H4>GridLayout</H4>
<P>
The GridLayout class is used to set a matrix of components along
a number of rows and columns. Since the size of each row and column
is the same, each component in the grid has the same size. Each
new component added to the container using GridLayout is positioned
to the next index in the grid. If the row is not full, it is added
to the next column; if it is, a new row is started and the component
is added to the new column.
<P>
Figure 3.5 illustrates an applet set to use GridLayout. It is
a 5<FONT FACE="Symbol">&#165;</FONT>5 matrix of Buttons. Listing
3.2 shows the code used to create this applet and illustrates
the use of gap values. In this case, a horizontal gap of 10 and
a vertical gap of 20 is specified in the constructor.
<HR>
<BLOCKQUOTE>
<B>Listing 3.2. Creating an example using GridLayout</B>.<BR>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// Class used for illustrating Grid Layouts...<BR>
public class GridLayoutExample extends Applet&nbsp;&nbsp;{<BR>
&nbsp;// Set up a matrix of numbers to be displayed in a <BR>
grid...<BR>
&nbsp;public void init() {<BR>
&nbsp;&nbsp;// Set up display area...<BR>
&nbsp;&nbsp;resize(300,200);<BR>
&nbsp;&nbsp;// Set the layout to a 5 by 5 grid with<BR>
&nbsp;&nbsp;// a horizontal gap of 10 and a vertical gap of 20
<BR>
&nbsp;&nbsp;int rowsAcross = 5;<BR>
&nbsp;&nbsp;int rowsDown = 5;<BR>
&nbsp;&nbsp;setLayout(new GridLayout(rowsAcross,rowsDown,10,20));
<BR>
&nbsp;&nbsp;// Fill the grid with buttons filled with numbers...
<BR>
&nbsp;&nbsp;int matrixSize = rowsAcross *rowsDown;<BR>
&nbsp;&nbsp;for (int i = 0; i &lt; matrixSize; ++i) {<BR>
&nbsp;&nbsp;&nbsp;// Make a label set to the current number...
<BR>
&nbsp;&nbsp;&nbsp;// Add it to the grid...<BR>
&nbsp;&nbsp;&nbsp;add(new Button(Integer.toString(i)) );<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="f3-5.gif" ><B>Figure 3.5 </B>: <I>An example using GridLayout.</I></A>
<P>
The code ends with a <TT>for</TT>
loop that adds Buttons to the grid. As the number increases, each
Button is added across and down the applet display area. The code
that creates the numeric name of the Button is interesting because
it illustrates a static method of the type wrapper class, Integer,
that can be used to convert an integer to a String without creating
a new object.
<P>
An alternative constructor enables you to create a GridLayout
without horizontal and vertical gaps.
<H4>GridBagLayout</H4>
<P>
The most complex layout class provided with the Java API is GridBagLayout.
While it is superficially similar to the GridLayout class, it
differs significantly by not requiring the components in the grid
to be the same size. GridBagLayout uses a helper class called
GridBagConstraints to specify how the component is displayed in
relation to the container's other components. GridBagLayout can
guarantee a logical display of components because it replaces
the use of hard-code coordinates with a relative structure of
how the components should visually interrelate.
<P>
Figure 3.6 and Listing 3.3 show an example of using GridBagLayout.
As the code illustrates, this class is much more complex than
the other layouts. The key to using GridBagLayout is understanding
its interaction with the GridBagConstraints helper. To describe
it in high-level terms, GridBagLayout and GridBagConstraints use
a system of weighting and relative flags to determine how things
will be positioned and sized. To see how this works, look at some
of the GridBagConstraints variables summarized in Table 3.1. The
variables starting with &quot;grid&quot; specify positioning in
relation to the other components in the row or column. The GridBagConstraints
constant <TT>REMAINDER</TT> means
that the object should be the last item in the row or column.
A value of <TT>1</TT>, on the other
hand, indicates that it should be positioned normally. The <TT>weightx</TT>
and <TT>weighty</TT> variables determine
space distribution of the components in relation to each other.
A weight of <TT>1</TT> indicates that
the item should be positioned evenly with other items of weight
<TT>1</TT>. On the other hand, a weight
of <TT>0</TT> will give a component
a lower priority in sizing. If the weight variables are not set
to a nonzero value, the default distribution will be moved toward
the center of the container.
<P>
<A HREF="f3-6.gif" ><B>Figure 3.6 </B>: <I>An example using GridBagLayout.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 3.3. Creating an example using GridBagLayout.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
// Class used for illustrating GridBagLayouts...<BR>
public class GridBagLayoutExample extends Applet&nbsp;&nbsp;{
<BR>
<BR>
</TT>&nbsp;<TT>// A complex set of
buttons<BR>
&nbsp;public void init() {<BR>
&nbsp;&nbsp;// Just reuse these over &amp; over...<BR>
&nbsp;&nbsp;Button b;<BR>
&nbsp;&nbsp;Label l;<BR>
&nbsp;&nbsp;// Set up display area...<BR>
&nbsp;&nbsp;resize(300,200);<BR>
&nbsp;&nbsp;// Create the GridBagLayout and its helper...<BR>
&nbsp;&nbsp;GridBagLayout g = new GridBagLayout();<BR>
&nbsp;&nbsp;setLayout(g);<BR>
&nbsp;&nbsp;GridBagConstraints gbc = new GridBagConstraints();
<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;// Put up a row of three equal size buttons...<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;// This tells the layout to use the full horizontal
<BR>
&nbsp;&nbsp;// and vertical height if the display area is not
<BR>
filled...<BR>
</TT>&nbsp;<TT>&nbsp;gbc.fill = GridBagConstraints.BOTH;
<BR>
&nbsp;&nbsp;// Distribute horizontal space evenly between buttons
<BR>
&nbsp;&nbsp;gbc.weightx = 1.0;<BR>
&nbsp;&nbsp;// Create and add the three buttons...<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 1&quot;);<BR>
&nbsp;&nbsp;g.setConstraints(b,gbc);<BR>
&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 2&quot;);<BR>
&nbsp;&nbsp;g.setConstraints(b,gbc);<BR>
&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 3&quot;);<BR>
&nbsp;&nbsp;gbc.gridwidth = GridBagConstraints.REMAINDER; // Fill
<BR>
up the row...<BR>
</TT>&nbsp;<TT>&nbsp;g.setConstraints(b,gbc);
<BR>
&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;// Put up a button, a label, and a button<BR>
&nbsp;&nbsp;// that uses the remaining height area...<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 4&quot;);<BR>
&nbsp;&nbsp;gbc.gridwidth = 1;&nbsp;&nbsp;// Reset to normal...
<BR>
&nbsp;&nbsp;gbc.weighty = 1.0;&nbsp;&nbsp;// Force it to use remaining
<BR>
height...<BR>
&nbsp;&nbsp;g.setConstraints(b,gbc);<BR>
&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;l = new Label(&quot;Number 5&quot;);<BR>
&nbsp;&nbsp;g.setConstraints(l,gbc);<BR>
&nbsp;&nbsp;add(l);<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 6&quot;);<BR>
&nbsp;&nbsp;gbc.gridwidth = GridBagConstraints.REMAINDER; // Fill
<BR>
up the row...<BR>
</TT>&nbsp;<TT>&nbsp;g.setConstraints(b,gbc);
<BR>
&nbsp;&nbsp;add(b);<BR>
</TT>&nbsp;<TT>&nbsp;// *************************************
<BR>
&nbsp;&nbsp;// Make a normal height button with insets...<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;gbc.weighty = 0.0; // Normal height;<BR>
&nbsp;&nbsp;gbc.gridheight = 1;<BR>
&nbsp;&nbsp;gbc.weightx = 0.0;&nbsp;&nbsp;// Use up the row...
<BR>
&nbsp;&nbsp;gbc.insets.left = 20;<BR>
&nbsp;&nbsp;gbc.insets.right = 20;<BR>
&nbsp;&nbsp;b = new Button(&quot;Number 7&quot;);<BR>
&nbsp;&nbsp;g.setConstraints(b,gbc);<BR>
&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;// Finally add a text field across the bottom...<BR>
&nbsp;&nbsp;// *************************************<BR>
&nbsp;&nbsp;gbc.insets.left = 0;&nbsp;&nbsp;&nbsp;// Reset these...
<BR>
&nbsp;&nbsp;gbc.insets.right = 0;<BR>
&nbsp;&nbsp;TextField t = new TextField(&quot;Number 8&quot;);
<BR>
&nbsp;&nbsp;g.setConstraints(t,gbc);<BR>
&nbsp;&nbsp;add(t);<BR>
&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
<CENTER><B>Table 3.1. The GridBagConstraints variables.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=163><I>Variables</I></TD><TD WIDTH=427><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>gridx</TT>, <TT>gridy</TT> 
</TD><TD WIDTH=427>Specifies the upper-left display of the grid cell. A value of <TT>GridBagConstraints.RELATIVE</TT> indicates that the component is to be placed just right of or below the component just added before.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>Gridwidth</TT>, 
</TD><TD WIDTH=427>Indicates the number of grid cells in its display area. The 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>gridheight</TT>
</TD><TD WIDTH=427><TT>GridBagConstraints.REMAINDER</TT> value specifies that it is the last cell it is the next to last cell in the row or column.in the row or column. <TT>GridBagConstraints.RELATIVE</TT> indicates that 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>Fill</TT></TD>
<TD WIDTH=427>Indicates what to do if the display area is not filled. If this value is set to <TT>GridBagConstraints.BOTH</TT>, then it will fill up the display area.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>ipadx</TT>, <TT>ipady</TT>
</TD><TD WIDTH=427>Used to specify internal padding to add to the component's minimum size.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>Insets</TT>
</TD><TD WIDTH=427>Sets the external padding around the component's display area.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>anchor</TT>
</TD><TD WIDTH=427>A directional scheme to indicate where a component should go if it does not fill up the display area. The <TT>GridBagConstraints.CENTER</TT> variable is the default value.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>weightx</TT>, 
</TD><TD WIDTH=427>Determines space distribution. The default value of zero results in 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=163><TT>weighty </TT> 
</TD><TD WIDTH=427>the components clumping together in the middle of the display. Otherwise, the value indicates a weighting in relation to the other row and column components.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Look at the Java API documentation for more information about
these variables.
<P>
The spreadsheet project throughout this part of the book uses
GridBagLayout. In particular, the frame initialization uses this
class to set how the text field, spreadsheet canvas, and scrollbars
are positioned in relation to each other. Look at these examples
to get more ideas about how GridBagLayout works.
<H4>CardLayout</H4>
<P>
The CardLayout class allows the developer to flip through a series
of displays. The flipping action of CardLayout is similar to HyperCard
or other card-based programs. This card style of presentation
differentiates CardLayout from the other layouts in that only
one card of information is displayed at a time.
<P>
The typical way to use CardLayout is to tie it to a container,
like a Panel. A series of cards can then be added to the container.
Every time a component is added to a container that uses CardLayout,
a new &quot;card&quot; is added. A variety of methods can be used
to flip through the cards. For example, the <TT>first()</TT>
method goes to the first card in the deck, <TT>next()</TT>
goes to the next card, <TT>show()</TT>
goes to a card with a certain name, and so on.
<P>
Listing 3.4 provides the source code for a program that can be
used to flip through a deck displaying different graphical images.
It is similar to the first example in this chapter.
<HR>
<BLOCKQUOTE>
<B>Listing 3.4. Creating an example using CardLayout.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
// This class illustrates card layouts by drawing a <BR>
different<BR>
// shape for a variety of cards...<BR>
public class CardLayoutExample extends <BR>
java.applet.Applet&nbsp;&nbsp;{<BR>
&nbsp;// Each card consists of a canvas that draws the name<BR>
&nbsp;// of the card...<BR>
&nbsp;Panel p;<BR>
&nbsp;CardLayout panelLayout;<BR>
&nbsp;int index = 0;<BR>
&nbsp;int lastIndex;<BR>
&nbsp;public void init() {<BR>
&nbsp;&nbsp;String name;<BR>
&nbsp;&nbsp;// Set up display area...<BR>
&nbsp;&nbsp;resize(300,200);<BR>
&nbsp;&nbsp;setLayout(new BorderLayout());<BR>
<BR>
&nbsp;&nbsp;// Create the panel that uses CardLayout<BR>
&nbsp;&nbsp;p = new Panel();<BR>
&nbsp;&nbsp;panelLayout = new CardLayout();<BR>
&nbsp;&nbsp;p.setLayout(panelLayout);<BR>
&nbsp;&nbsp;add(&quot;Center&quot;,p);<BR>
<BR>
&nbsp;&nbsp;// Add a canvas to each card<BR>
&nbsp;&nbsp;// The name variable is the shape to display...<BR>
CardLayoutDrawCanvas c; // Reuse these...<BR>
&nbsp;&nbsp;// Add the rectangle...<BR>
&nbsp;&nbsp;name = &quot;Rectangle&quot;;<BR>
&nbsp;&nbsp;c = new CardLayoutDrawCanvas(name);<BR>
&nbsp;&nbsp;p.add(name,c);<BR>
<BR>
<BR>
&nbsp;&nbsp;// Add the oval display...<BR>
&nbsp;&nbsp;name = &quot;Oval&quot;;<BR>
&nbsp;&nbsp;c = new CardLayoutDrawCanvas(name);<BR>
&nbsp;&nbsp;p.add(name,c);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Add the round
rectangle display...<BR>
&nbsp;&nbsp;name = &quot;RoundRect&quot;;<BR>
&nbsp;&nbsp;c = new CardLayoutDrawCanvas(name);<BR>
&nbsp;&nbsp;p.add(name,c);<BR>
<BR>
&nbsp;&nbsp;// Show the first card...<BR>
&nbsp;&nbsp;index = 0;<BR>
&nbsp;&nbsp;lastIndex = 2;<BR>
&nbsp;&nbsp;panelLayout.first(p);<BR>
&nbsp;}<BR>
<BR>
&nbsp;// A mouse click takes you to the next card...<BR>
&nbsp;public boolean mouseDown(Event ev, int x, int y) {<BR>
&nbsp;&nbsp;// Go to the next card or to beginning<BR>
&nbsp;&nbsp;if (index != lastIndex) {<BR>
&nbsp;&nbsp;&nbsp;panelLayout.next(p);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;++index;
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;else {&nbsp;&nbsp;//
Go to first card...<BR>
&nbsp;&nbsp;&nbsp;panelLayout.first(p);<BR>
&nbsp;&nbsp;&nbsp;index = 0;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;return true;<BR>
&nbsp;}<BR>
<BR>
}<BR>
<BR>
// This is a custom canvas that is used for drawing<BR>
// text, a rectangle, or nothing...<BR>
class CardLayoutDrawCanvas extends Canvas {<BR>
&nbsp;String name;<BR>
&nbsp;// Constructor - store the applet to get drawing <BR>
info...<BR>
</TT>&nbsp;<TT>public CardLayoutDrawCanvas(String
s) {<BR>
&nbsp;&nbsp;name = s;<BR>
&nbsp;}<BR>
&nbsp;// Draw the image per the choices in the applet...<BR>
&nbsp;public synchronized void paint (Graphics g) {<BR>
&nbsp;&nbsp;// Get the current size of the display area...<BR>
&nbsp;&nbsp;Dimension dm = size();<BR>
&nbsp;&nbsp;// Draw based on choice...<BR>
&nbsp;&nbsp;// Calculate center coordinates....<BR>
&nbsp;&nbsp;int x,y,width,height;<BR>
&nbsp;&nbsp;x = dm.width/4;<BR>
&nbsp;&nbsp;y = dm.height / 4;<BR>
&nbsp;&nbsp;width = dm.width / 2;<BR>
&nbsp;&nbsp;height = dm.height / 2;<BR>
&nbsp;&nbsp;// Paint a rectangle in the center...<BR>
&nbsp;&nbsp;if (name.compareTo(&quot;Rectangle&quot;) == 0) {
<BR>
&nbsp;&nbsp;&nbsp;// Draw the rectangle in the center with colors!
<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;g.drawRect(x,y,width,height);<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;g.fillRect(x + 1,y + 1,width - 2,height - 2);
<BR>
&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;// Paint an oval in the center...<BR>
&nbsp;&nbsp;if (name.compareTo(&quot;Oval&quot;) == 0) {<BR>
&nbsp;&nbsp;&nbsp;// Draw the rectangle in the center with colors!
<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;g.drawOval(x,y,width,height);<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;g.fillOval(x + 1,y + 1,width - 2,height - 2);
<BR>
&nbsp;&nbsp;} // end if<BR>
&nbsp;&nbsp;if (name.compareTo(&quot;RoundRect&quot;) == 0) {
<BR>
&nbsp;&nbsp;&nbsp;// Draw the rectangle in the center with colors!
<BR>
&nbsp;&nbsp;&nbsp;int rounding = dm.width / 8;<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;g.drawRoundRect(x,y,width,height,rounding,rounding);
<BR>
&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;g.fillRoundRect(x + 1,y + 1,width - 2,height
- 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp; rounding,rounding);<BR>
&nbsp;&nbsp;} // end if<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="EventHandling">Event Handling</A></H3>
<P>
Programs written for most GUI environments take actions based
on events initiated by the user or the system. If the user clicks
the mouse, a &quot;mouse click&quot; event is issued. If the program
wants to handle the mouse click, it needs to insert some code
to trap for any mouse click event. The program may pass the event
on to a default handler if it doesn't want to handle the event.
The default handler encapsulates an object's standard behavior.
For example, when you click a button, it should reflect the action
by showing a pressing motion. This default behavior should occur
regardless of whether the program processes the mouse click event.
<P>
As stated earlier, the visual controls the user interacts with
in the AWT environment are derived from the Component class. A
critical method of this class is <TT>handleEvent()</TT>,
which is used to process incoming events and relay them to the
appropriate handler methods. Any component that needs to manage
specific events will need to override this method with its own
handler.
<P>
In this chapter's initial example, the canvas object that draws
shapes and text was repainted every time the user clicked the
Draw button. (See Figure 3.3 and Listing 3.1.) The program made
this happen by adding the following code to the applet class,
Example1:
<BLOCKQUOTE>
<TT>// Handle events that have occurred<BR>
public boolean handleEvent(Event evt) {<BR>
switch(evt.id) {<BR>
&nbsp;// This can be handled<BR>
&nbsp;case Event.ACTION_EVENT: {<BR>
&nbsp;&nbsp;if(evt.target instanceof Button)&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;// Repaint canvas to use new choices...<BR>
&nbsp;&nbsp;&nbsp;c.repaint();<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end if<BR>
&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;}<BR>
&nbsp;default:<BR>
</TT>&nbsp;<TT>&nbsp;return false;
<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
This code overrides the default handler of the Applet class (which
is a subclass of Component). The sample applet would do very little
if this code had not been added. Even though the default handler
was overridden, the code can still allow default behavior to occur.
The return code from the method tells the parent of the component
what should happen next. If the method returns true, then the
event has been completely handled and should not be passed to
the parent. On the other hand, a false return value allows the
event to be passed on. The event handler of the component's superclass
can also be called through this expression:
<BLOCKQUOTE>
<TT>return super.handleEvent(evt);</TT>
</BLOCKQUOTE>
<P>
The <TT>handleEvent()</TT> method
takes as its sole parameter an instance of the Event class. This
class encapsulates information about the event that occurred.
The <TT>id</TT> integer variable of
the class represents the type of event that occurred. The most
widely captured event is the one with the <TT>id</TT>
<TT>ACTION_EVENT</TT>. Each class
of component has a specific action tied to it. For example, the
action for a Button object is its selection, such as a mouse click.
For TextField objects, the action is the entry of the Return key
in the text field.
<P>
Other types of frequently caught events are those prefixed by
<TT>KEY_</TT> and <TT>MOUSE_</TT>,
which represent keyboard and mouse events, respectively. Other
events include scrollbar actions and window events, such as Minimize
or Destroy.
<P>
In the preceding code, the <TT>handleEvent()</TT>
method traps for button selections. When the button is selected,
an event with an <TT>ACTION_EVENT</TT>
ID is generated. Recall, however, that this example also had a
TextField. To differentiate the button selection from a text field
Return keystroke, the code needs to tell what class of object
issued the event. It does this by looking at the Event target
variable. In the example's code, the program checks to see whether
the target is a button by using the <TT>instanceOf</TT>
operator.
<P>
Other information can be found in Event variables. An optional
argument, the <TT>arg</TT> variable,
provides information specific to the Event, such as the Object
of an action. For mouse events, the <TT>x</TT>
and <TT>y</TT> variables can be used
to get the mouse position. The key variable is used to determine
which keystroke corresponds to a <TT>KEY_</TT>
event.
<P>
The Component class also has helper methods that can be used if
the user wants to manage events in a simpler manner than <TT>handleEvent()</TT>
provides. These helper methods are actually called by <TT>handleEvent()</TT>.
However, the overriding of <TT>handleEvent()</TT>
is not required to use the helper methods.
<P>
In the CardLayout example, cards were flipped by overriding the
<TT>mouseDown()</TT> method, which
was declared as follows.
<BLOCKQUOTE>
<TT>public boolean mouseDown(Event ev, int
x, int y)</TT>
</BLOCKQUOTE>
<P>
This is used to trap mouse clicks, passing the current location
of the mouse in the x and y parameters. This call actually begins
in the <TT>handleEvent()</TT> method,
which traps for events of ID <TT>MOUSE_DOWN</TT>.
When such events are issued, <TT>handleEvent()</TT>
reacts by calling <TT>mouseDown()</TT>.
If this is overridden by the object in question, its version of
the method will be called. Like <TT>handleEvent()</TT>,
the return value of the helper methods indicate whether the event
has been completely handled.
<P>
Table 3.2 lists the available Event helper methods, which are
all part of the definition of the Component class.<BR>
<P>
<CENTER><B>Table 3.2. Event helper methods.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=134><I>Method</I></TD><TD WIDTH=325><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseEnter</TT>
</TD><TD WIDTH=325>Mouse enters the Component's area</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseExit</TT>
</TD><TD WIDTH=325>Mouse leaves the Component's area</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseMove</TT>
</TD><TD WIDTH=325>Mouse has moved</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseDown</TT>
</TD><TD WIDTH=325>Mouse has been pressed down</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseDrag</TT>
</TD><TD WIDTH=325>Mouse has moved while it is pressed down</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>mouseUp</TT>
</TD><TD WIDTH=325>Mouse click has been released</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>keyDown</TT>
</TD><TD WIDTH=325>Keyboard character has been pressed</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>keyUp</TT></TD>
<TD WIDTH=325>Keyboard character has been released</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>action</TT>
</TD><TD WIDTH=325>An action has occurred to the Component</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>gotFocus</TT>
</TD><TD WIDTH=325>The input focus has been placed on the Component
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=134><TT>lostFocus</TT>
</TD><TD WIDTH=325>The Component has lost input focus</TD></TR>
</TABLE></CENTER>
<H2><A NAME="ExceptionClasses"><FONT SIZE=5 COLOR=#FF0000>Exception
Classes</FONT></A></H2>
<P>
Although the basics of exception handling were discussed in the
first part of the book, there is a lot more to managing exceptions
in Java than just the &quot;try-catch&quot; clause. The class
of exceptions that is thrown and what information can be gleaned
from the thrown object are also important topics. This part of
exception handling is related to Java's exception class hierarchy,
the subject of this section.
<H3><A NAME="TheThrowableClass">The Throwable Class</A></H3>
<P>
All throwable objects in Java are an instance of, or are subclassed
from, the Throwable class, which encapsulates the behaviors found
in all the throwable classes that are part of the Java API. One
widely used method of Throwable is <TT>getMethod()</TT>.
This prints out a detail message attached to the thrown object.
The detail message will give extra information regarding the nature
of the error. If the default constructor of the thrown object
is used, a system-generated detail message will be provided. If
you want a custom message, on the other hand, an alternative constructor
can be used.
<P>
A couple of examples will illustrate using detail messages. Suppose
an operation is performed that results in an error. The following
code will catch the thrown object and print out the detail message:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;// &#133; do something that causes an exception, such
as <BR>
divide by zero<BR>
}<BR>
catch (Throwable t) {<BR>
&nbsp;&nbsp;// Print out the detail message of the error&#133;
<BR>
&nbsp;&nbsp;System.out.println(t.getMessage());<BR>
}</TT>
</BLOCKQUOTE>
<P>
In another case, suppose that the same code wants to rethrow the
message with its own custom detail message if there is an error.
The other constructor for Throwable can be used in this situation
to construct the custom message:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;// &#133; do something that causes an exception, such
as <BR>
divide by zero<BR>
}<BR>
catch (Throwable t) {<BR>
&nbsp;&nbsp;// Throw a new Throwable object with<BR>
&nbsp;&nbsp;// Custom detail message&#133;<BR>
&nbsp;&nbsp;throw new Throwable(&quot;This method threw an <BR>
exception&quot;);<BR>
}</TT>
</BLOCKQUOTE>
<P>
When the new Throwable is caught and <TT>getMessage()</TT>
is invoked, the program will get the String <TT>&quot;This
method threw an exception&quot;</TT> instead of a system-generated
message.
<P>
Other methods in Throwable can be used for getting the state of
the runtime stack when the error occurred. The <TT>printStackTrace()</TT>
method, for example, prints to standard error the kind of stack
output that you often see when a Java program terminates abnormally.
<H3><A NAME="ExceptionClassHierarchy">Exception Class Hierarchy</A>
</H3>
<P>
All the other exception classes in the Java API behave similarly
to the Throwable class. They differ only in how they are located
in the hierarchy of class exceptions. Java divides errors into
two general groupings, indicated by two parent classes derived
from Throwable. The Exception class represents the kind of errors
that occur in a normal programming environment, such as file not
found, array index out of bounds, null pointers, divide by zero,
and so forth. These are &quot;soft&quot; errors, the type of difficulty
that a program should be able to easily recover from. In general,
Exception classes represent errors that are meant to be caught
by the calling method whenever they occur. Classes derived from
the Error class, on the other hand, represent more serious errors
that can occur at unpredictable times and are often fatal in nature.
An extreme case of such an Error is a failure within the Java
virtual machine. If this occurs, often the best you can hope for
is an orderly shutdown of the program. Because of their unpredictable
and catastrophic nature, Error objects do not have to be caught
in exception handlers. In general, programs will be written to
catch only classes derived from the Exception class.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
From a terminological standpoint, &quot;exception&quot; (lowercase) is used to refer to all classes of thrown objects. The term &quot;error&quot; (lowercase also) refers to the circumstances that cause the object to be thrown.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
As mentioned in the first part of this book, a method establishes
that it throws an Exception that has to be caught in its declaration.
For example, this is the constructor for the class that opens
a file for output:
<BLOCKQUOTE>
<TT>public FileOutputStream(String name)
throws IOException</TT>
</BLOCKQUOTE>
<P>
This declaration means that an instance of IOException is thrown
whenever the file specified in the String cannot be opened. The
IOException class is derived from Exception, so any code that
uses this FileOutputStream constructor must catch this exception.
This means that code using this constructor must be generally
structured as follows:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;FileOutputStream fo = new FileOutputStream(&quot;MyFile&quot;);
<BR>
&nbsp;// &#133; write the file&#133;<BR>
{<BR>
catch (IOException e) {<BR>
&nbsp;&nbsp;// &#133;Handle the file open problem&#133;<BR>
}</TT>
</BLOCKQUOTE>
<P>
With one notable exception, all methods that throw objects of
type Exception must be called in an exception handler that catches
the Exception. However, Java provides a branch of Exceptions of
thrown objects that do not have to be caught. These are derived
from the RuntimeException class. Subclasses of the RuntimeException
class are those problems that would be too cumbersome to trap
every time they may occur. For example, all accesses to arrays
could result in an exception because the index into the array
could be bad. However, it would be unwieldy to put an exception
handler around all array calls. There would also be a performance
hit. Even worse are instances of the NullPointerException class
being thrown, which theoretically could occur anywhere in the
program.
<P>
Just because an exception is a subclass of RuntimeException, however,
doesn't mean that a good program should not trap for the thrown
object. For example, the ArithmeticException usually indicates
a divide by zero error. It is good programming to trap for this
error whenever it occurs. In most cases, division doesn't often
occur in a program. Consequently, a clause like the following
is appropriate for many division operations:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;result = divider / divisor;<BR>
}<BR>
catch (ArithmeticException e) {<BR>
&nbsp;System.out.println(&quot;Divide by zero error!&quot;);<BR>
&nbsp;result = 0;<BR>
}</TT>
</BLOCKQUOTE>
<P>
On the other hand, it is acceptable to have a divide operation
that is not part of an exception handler, since ArithmeticException
is a subclass of RuntimeException. Here is a list of the subclasses
of RuntimeException:<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=481><I>The Subclasses of RuntimeException</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=481>
<BLOCKQUOTE>
ArithmeticException<BR>
ArrayIndexOutOfBoundsException<BR>
ArrayStoreException<BR>
ClassCastException<BR>
IllegalArgumentException<BR>
IllegalMonitorStateException<BR>
IllegalThreadStateException<BR>
IndexOutOfBoundsException<BR>
NegativeArraySizeException</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="ExceptionHandlersandThrowableClasses">Exception Handlers
and Throwable Classes</A></H3>
<P>
The Exception class hierarchy serves a more fundamental purpose
in Java programming than just providing a way to order exception
classes; it plays an important role in determining how an exception
is handled. When an exception is thrown, Java looks for an exception
handler to catch the thrown object. It first looks in the method
where the error occurred, checking to see whether it has an appropriate
exception handler-one that is the class or a superclass of the
exception thrown. Recall that an exception handler can have multiple
catch statements. The catch statements should be ordered in such
a way that a subclass is listed before any of its superclasses.
Here is a possible exception handler for managing a variety of
problems:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;// &#133; some bad arithmetic operation<BR>
&nbsp;// &#133; or maybe a bad array access<BR>
&nbsp;// &#133; or a null errror</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>}<BR>
catch (ArithmeticException e) {<BR>
&nbsp;// Handle the exception&#133;<BR>
</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>}<BR>
catch (RuntimeException e) {<BR>
&nbsp;// Handle the runtime exception&#133;<BR>
}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>catch (Exception e) {<BR>
&nbsp;// Handle the Exception&#133;<BR>
}<BR>
catch (Throwable e) {<BR>
&nbsp;// Handle the thrown object&#133;<BR>
}</TT>
</BLOCKQUOTE>
<P>
Recall that ArithmeticException is a subclass of RuntimeException.
The latter is derived from Exception, which in turn is a subclass
of Throwable. In this example, a divide by zero error throws an
ArithmeticException, which is handled in the first catch statement.
On the other hand, a NullPointerException or a bad array access
will result in a RuntimeException object being thrown, which is
handled in the second catch statement. A serious problem of class
Error will not be handled until it reaches the last catch statement,
which will catch the thrown object since Error is a subclass of
Throwable. This example illustrates that the exception class hierarchy
is a critical part of Java's strategy for resolving exceptions.
<P>
If the method that caused an object to be thrown does not have
an appropriate exception handler, the object percolates up the
call stack, and this process of finding an appropriate handler
is repeated. If it reaches the top of the stack and no appropriate
handler is found, the program will terminate abnormally.
<H3><A NAME="WritingCustomExceptionHandlers">Writing Custom Exception
Handlers</A></H3>
<P>
It's easy to write your own exception handler. A class is simply
created that extends the class that should function as the superclass.
If a new IOException handler is needed, for example, it could
be written as the following:
<BLOCKQUOTE>
<TT>public class CustomIOException extends
IOException { }</TT>
</BLOCKQUOTE>
<P>
The hard part, however, is deciding what the superclass of the
handler should be. In general, it should not be a subclass of
Error since these are reserved for &quot;hard&quot; system problems.
Using RuntimeException should also be discouraged because of an
interesting controversy over whether there should even be such
a thing as a RuntimeException class. This is because, in some
ways, the use of RuntimeException classes defeats some of the
goals of exception handling. By definition, a RuntimeException
object does not have to be caught, but this would then increase
the likelihood of an exception not being caught at all, forcing
the program to terminate abnormally. This defeats a key goal of
exception handling, which is to have a graceful resolution of
problems. Thus, the use of RuntimeException is reserved for classes
of errors that would occur too frequently to have an exception
handler every time the pertinent methods are called.
<P>
This leaves the subclasses of Exception as the best candidate
for being the superclass of new exception classes. Some good examples
can be found in the organization of the exceptions in the Java
IO package. One of the constructors for the FileInputStream class
tries to open up the input file specified in its String parameter.
If the file cannot be opened, a FileNotFoundException is thrown.
This class is derived from the IOException class, which is based
on Exception. Other file error classes are also derived from IOException.
Therefore, the IOException class marks a hierarchy for problems
related to input/output operations.
<P>
Suppose a new set of classes is being created for database operations.
It might be helpful to create a new hierarchy of exceptions that
correspond to database problems. The class at the top of this
hierarchy might be called DatabaseException, which could be derived
from Exception since it marks a new branch of the Exception hierarchy.
For errors related to problems with the database key, you could
create a KeyException class derived from DatabaseException. If
the key could not be found, then you could add a KeyNotFoundException,
whose superclass is KeyException. These new Exceptions could be
declared as follows:
<BLOCKQUOTE>
<TT>public class DatabaseException extends
Exception { }<BR>
public class KeyException extends DatabaseException { }<BR>
public class KeyNotFoundException extends KeyException { }</TT>
</BLOCKQUOTE>
<P>
In the following example, a method that tries to find a record
could then be declared as throwing a KeyNotFoundException if the
record is not found:
<BLOCKQUOTE>
<TT>public findRecord(Key index) throws KeyNotFoundException</TT>
</BLOCKQUOTE>
<P>
The code that invokes this method then can be structured as follows:
<BLOCKQUOTE>
<TT>try {<BR>
&nbsp;&nbsp;db.findRecord(myKey);<BR>
}<BR>
catch (KeyNotFoundException e) {<BR>
&nbsp;// Handle the key not found exception&#133;<BR>
}<BR>
catch (KeyException e) {<BR>
&nbsp;// Handle the exception due to a bad key<BR>
}<BR>
catch (DatabaseException e) {<BR>
&nbsp;// Handle any database exception&#133;<BR>
}<BR>
catch (Exception e) {<BR>
&nbsp;// Handle the Exception&#133;<BR>
}<BR>
</TT> 
</BLOCKQUOTE>
<P>
The project in this chapter is a spreadsheet applet that supports
rudimentary formula operations and other basic behavior. This
version of the project has the following behaviors:
<UL>
<LI><FONT COLOR=#000000>The program produces a spreadsheet of
the size specified in the HTML parameter list. The rows are indicated
by alpha characters ranging from </FONT><I>A</I> to <I>Z</I>.
The columns are numbered from 0 to the number of columns minus
one. The individual cells in the spreadsheet are labeled accordingly.
Therefore, the upper-left cell is A0. The spreadsheet cells support
only numeric values of precision double.
<LI><FONT COLOR=#000000>The user can change the value of a cell
by clicking on a valid cell. A numeric value, a formula, or an
empty string can then be entered into the text field at the top
of the screen. When the user hits return, the new value is validated
and entered into the cell, and the spreadsheet cell values are
recalculated.</FONT>
<LI><FONT COLOR=#000000>The program supports several formulas.
Arithmetic formulas of MULT, ADD, SUB, and DIV operate on two
cells and return the double value resulting from it. For example,
MULT(C3,B3) returns the value in cell C3 times the value in cell
B3. The SUM(cell1,cell2) operation returns the values of all the
sums between cell1 and cell2 when these cells share a common row
or column. The spreadsheet supports cell recursion on formulas,
so a cell with a formula can be included in the formula operation
of another cell.</FONT>
<LI><FONT COLOR=#000000>The applet has a basic menu with Quit
and New spreadsheet commands.</FONT>
</UL>
<P>
Figure 3.7 shows how the spreadsheet applet appears in a browser.
More advanced features, such as scrollbars, dialog boxes, and
graphs, will be explored in the upcoming chapters. The version
of the spreadsheet currently presented aims to illustrate many
of the features of AWT and exception handling discussed in the
first section of this chapter.
<P>
<A HREF="f3-7.gif" ><B>Figure 3.7 </B>: <I>The first version of the spreadsheet applet.</I></A>
<H3><A NAME="ClassOrganization">Class Organization</A></H3>
<P>
Table 3.3 explains the classes used in this chapter's version
of the spreadsheet applet.<BR>
<BLOCKQUOTE>
<CENTER><B>Table 3.3. Spreadsheet classes.</B></CENTER>
</BLOCKQUOTE>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=176><I>Class</I></TD><TD WIDTH=414><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>Cell</TD><TD WIDTH=414>Contains a String and evaluated value corresponding to a single cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>CellContainer</TD><TD WIDTH=414>Contains a matrix of Cells. The String in each Cell is evaluated according to whether it is a formula, a literal numeric value, or an empty cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>FormulaParser</TD><TD WIDTH=414>Used to parse out the individual string fragments that make up a single formula. Converts literal strings to their numeric values.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>FormulaParserException</TD><TD WIDTH=414>An Exception that is thrown if a formula is ill constructed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>ArgValue</TD><TD WIDTH=414>A FormulaParser helper class used to store information about an argument in a formula.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>SpreadsheetCell</TD><TD WIDTH=414>Provides for the visual presentation of a single Cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>SpreadsheetContainer</TD><TD WIDTH=414>Manages the visual presentation of a matrix of SpreadsheetCells. Provides an interface for changing the value of a cell. Supports the display of a currently highlighted cell.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>SpreadsheetFrame</TD><TD WIDTH=414>Provides the main presentation of the spreadsheet by displaying the SpreadsheetContainer, managing mouse selections on that spreadsheet, reading a text field for changing cell values, and handling a simple menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176>SpreadsheetApplet</TD><TD WIDTH=414>Responsible for creating, showing, and hiding the SpreadsheetFrame that provides the visual display of this applet.
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="TheCellClass">The Cell Class</A></H3>
<P>
This class stores a String and its evaluated value for a single
cell. It performs no validation in terms of the validity of any
formulas or nonnumeric values contained in the String. A variable
is used to mark whether the cell has been evaluated, although
the setting of this variable is of interest only to the classes
that use Cell.
<HR>
<BLOCKQUOTE>
<B>Listing 3.5. The Cell class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// A cell contains the formula&nbsp;&nbsp;for
an individual cell<BR>
// However, it does not know what to do with it and <BR>
simply<BR>
// returns its contents...<BR>
public class Cell {<BR>
&nbsp;String s;<BR>
&nbsp;double evaluatedValue;<BR>
&nbsp;boolean evaluated;&nbsp;&nbsp;// True if the cell has been
<BR>
evaluated<BR>
&nbsp;// Constructor creates empty StringBuffer as <BR>
reference...<BR>
</TT>&nbsp;<TT>public Cell() {<BR>
&nbsp;&nbsp;s = &quot;&quot;;<BR>
&nbsp;&nbsp;evaluatedValue = 0.0;<BR>
&nbsp;&nbsp;evaluated = true;<BR>
&nbsp;}<BR>
&nbsp;// Takes a StringBuffer and makes it the cell's <BR>
data...<BR>
</TT>&nbsp;<TT>public void setCellString(StringBuffer
s) {<BR>
&nbsp;&nbsp;this.s = new String(s);<BR>
&nbsp;&nbsp;evaluated = false;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// Takes a StringBuffer
and makes it the cell's <BR>
data...<BR>
&nbsp;public void setCellString(String s) {<BR>
&nbsp;&nbsp;this.s = s;<BR>
&nbsp;&nbsp;evaluated = false;<BR>
&nbsp;}<BR>
&nbsp;// Return the current contents of the Cell<BR>
&nbsp;public String getCellString() {<BR>
&nbsp;&nbsp;return s;<BR>
</TT>&nbsp;<TT>}<BR>
&nbsp;// Set the evaluated value of a cell...<BR>
&nbsp;public void setEvalValue(double val) {<BR>
&nbsp;&nbsp;evaluated = true;<BR>
&nbsp;&nbsp;evaluatedValue = val;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// Set the evaluated
value of a cell...<BR>
&nbsp;public void setEvalValue(int val) {<BR>
&nbsp;&nbsp;setEvalValue((double)val);<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// See if a cell has
been evaluated...<BR>
&nbsp;public boolean getEvaluated() {<BR>
&nbsp;&nbsp;return evaluated;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// Get the evaluated
value of a cell...<BR>
&nbsp;public double getEvalValue() {<BR>
&nbsp;&nbsp;return evaluatedValue;<BR>
&nbsp;}<BR>
</TT>&nbsp;<TT>// Set a cell to unevaluated...
<BR>
&nbsp;public void setEvaluated(boolean eval) {<BR>
&nbsp;&nbsp;evaluated = eval;<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheCellContainerClass">The Cell Container Class</A>
</H3>
<P>
This class consists of a matrix of Cells. Its main constructor
creates the matrix based on the number of rows and columns provided
in its constructor. Public methods allow setting or retrieving
values of individual cells based on a row and column index. If
this index is bad, an IllegalArgumentException is thrown. The
most interesting feature of this class is its ability to evaluate
formulas. The <TT>recalculateAll()</TT>
method forces a reevaluation of all the Cell values in the matrix.
It works with the FormulaParser class to see how a formula will
be calculated. If the formula relies on a Cell that contains yet
another formula, the program recurses into finding out the evaluated
formula value of that cell. The recursion occurs in the <TT>calculateCell()</TT>
and <TT>parseFormula()</TT> methods,
which determine the numeric value of a specific Cell. The recursion
stops when a Cell with a literal (that is, a number) value is
found. When a Cell's formula or literal value has been fully evaluated,
the Cell is updated accordingly. The calculation process provides
a good illustration of exception handling because they are widely
used to handle formula parsing errors and illegal formula operations.
<HR>
<BLOCKQUOTE>
<B>Listing 3.6. The CellContainer class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// The CellContainer class contains a
matrix of Cell data.<BR>
// The class is responsible for making sure<BR>
// that the formulas in the cells are evaluated properly...<BR>
public class CellContainer {<BR>
</TT>&nbsp;<TT>int numRows;<BR>
&nbsp;int numColumns;<BR>
</TT>&nbsp;<TT>Cell matrix[];<BR>
&nbsp;// Constructs an empty container...<BR>
</TT>&nbsp;<TT>public CellContainer()
{<BR>
&nbsp;&nbsp;numRows = 0;<BR>
</TT>&nbsp;&nbsp;<TT>numColumns =
0;<BR>
&nbsp;&nbsp;matrix = null;<BR>
</TT>&nbsp;<TT>}<BR>
&nbsp;// Constructs a matrix of cells [rows X columns]<BR>
</TT>&nbsp;<TT>public CellContainer(int
rows,int columns) throws IllegalArgumentException {<BR>
&nbsp;&nbsp;numRows = rows;<BR>
</TT>&nbsp;&nbsp;<TT>numColumns =
columns;<BR>
&nbsp;&nbsp;// Throw an exception if the row/col values are no
good...<BR>
</TT>&nbsp;&nbsp;<TT>if ((numRows
&lt;= 0) || (numColumns &lt;=0)) {<BR>
&nbsp;&nbsp;&nbsp;numRows = 0;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>numColumns
= 0;<BR>
&nbsp;&nbsp;&nbsp;matrix = null;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw new
IllegalArgumentException();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Create the Cell matrix...<BR>
</TT>&nbsp;&nbsp;<TT>int numCells
= numRows * numColumns;<BR>
&nbsp;&nbsp;matrix = new Cell[numCells];<BR>
</TT>&nbsp;&nbsp;<TT>for (int i =
0; i &lt; numCells; ++i)<BR>
&nbsp;&nbsp;&nbsp;matrix[i] = new Cell();<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Sets the new value
of a cell...<BR>
&nbsp;public void setCellFormula(StringBuffer s,int row,int col)
{<BR>
</TT>&nbsp;&nbsp;<TT>setCellFormula(s.toString(),row,col);
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Sets the new value of a cell...<BR>
</TT>&nbsp;<TT>public void setCellFormula(String
s,int row,int col) {<BR>
&nbsp;&nbsp;// Get the index into the matrix...<BR>
</TT>&nbsp;&nbsp;<TT>int index;<BR>
&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>index =
getMatrixIndex(row,col);<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>catch (IllegalArgumentException
e) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Invalid CellContainer
index.&quot;);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>return;
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Set the value
of the cell...<BR>
&nbsp;&nbsp;matrix[index].setCellString(s);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Get the string contents
of a cell...<BR>
&nbsp;public String getCellFormula(int row,int col)&nbsp;&nbsp;throws
IllegalArgumentException {<BR>
</TT>&nbsp;&nbsp;<TT>// Get the index
into the matrix...<BR>
&nbsp;&nbsp;int index;<BR>
</TT>&nbsp;&nbsp;<TT>try {<BR>
&nbsp;&nbsp;&nbsp;index = getMatrixIndex(row,col);<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;catch (IllegalArgumentException e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw e;
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Good index.
Return string...<BR>
&nbsp;&nbsp;return matrix[index].getCellString();<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Get the cell at
certain index...<BR>
&nbsp;public Cell getCell(int row,int col)&nbsp;&nbsp;throws IllegalArgumentException
{<BR>
</TT>&nbsp;&nbsp;<TT>// Get the index
into the matrix...<BR>
&nbsp;&nbsp;int index;<BR>
</TT>&nbsp;&nbsp;<TT>try {<BR>
&nbsp;&nbsp;&nbsp;index = getMatrixIndex(row,col);<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;catch (IllegalArgumentException e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw e;
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Good index.
Return Cell...<BR>
&nbsp;&nbsp;&nbsp;return matrix[index];<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Calculate the matrix
index given a row and column...<BR>
&nbsp;// Throw an exception if it is bad...<BR>
</TT>&nbsp;<TT>int getMatrixIndex(int
row,int col) throws IllegalArgumentException {<BR>
&nbsp;&nbsp;// Kick out if there are negative indexes...<BR>
</TT>&nbsp;&nbsp;<TT>if ((row &lt;
0) || (col &lt;0))<BR>
&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException();<BR>
</TT>&nbsp;&nbsp;<TT>// Also reject
too large indexes...<BR>
&nbsp;&nbsp;if ((row &gt;= numRows) || (col &gt;= numColumns))
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw new
IllegalArgumentException();<BR>
&nbsp;&nbsp;// Everything is OK. Calculate index...<BR>
</TT>&nbsp;&nbsp;<TT>return ((numColumns
* row) + col);<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Validate a formula by seeing whether it matches the basic
syntax...<BR>
</TT>&nbsp;<TT>public String validateFormula(Cell
c,String newFormula) throws <BR>
</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>FormulaParserException
{<BR>
// Convert all alphas to Upper Case<BR>
&nbsp;&nbsp;String convertedFormula = newFormula.toUpperCase();
<BR>
</TT>&nbsp;&nbsp;<TT>// Get old formula
of cell and temporarily set cell value there...<BR>
&nbsp;&nbsp;String oldFormula = c.getCellString();<BR>
</TT>&nbsp;&nbsp;<TT>// Set up the
parser to validate the cell...<BR>
&nbsp;&nbsp;FormulaParser f = new FormulaParser(convertedFormula);
<BR>
</TT>&nbsp;&nbsp;<TT>// Validate the
cell...<BR>
&nbsp;&nbsp;try {&nbsp;&nbsp;// Set up the formula parser...<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Get
the type of formula it is...<BR>
&nbsp;&nbsp;&nbsp;int typeFormula = f.getType();<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// If it's
empty, return Success...<BR>
&nbsp;&nbsp;&nbsp;if (typeFormula == f.EMPTY)<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>return
convertedFormula;<BR>
&nbsp;&nbsp;&nbsp;// Check to see whether literal is valid...
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>if (typeFormula
== f.LITERAL) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f.getLiteral();&nbsp;&nbsp;// Ignore the
return value...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>return
convertedFormula;<BR>
&nbsp;&nbsp;&nbsp;} // end if<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// If it's
a formula, you need to parse it...<BR>
&nbsp;&nbsp;&nbsp;parseFormula(c,f);<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;catch (Exception e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw new
FormulaParserException();<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Return the
converted string...<BR>
&nbsp;&nbsp;return convertedFormula;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Recalculate the
values in all the cells...<BR>
&nbsp;public void recalculateAll() {<BR>
</TT>&nbsp;&nbsp;<TT>if (matrix ==
null)<BR>
&nbsp;&nbsp;&nbsp;return;<BR>
</TT>&nbsp;&nbsp;<TT>// Invalidate
the formulas...<BR>
&nbsp;&nbsp;invalidateFormulas();<BR>
</TT>&nbsp;&nbsp;<TT>// Go through
each cell and calculate its value...<BR>
&nbsp;&nbsp;// Go row-wise across, as this is how things are probably
set up<BR>
</TT>&nbsp;&nbsp;<TT>int i,j;<BR>
&nbsp;&nbsp;for (i = 0; i &lt; numRows; ++i) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>for (j
= 0; j &lt; numColumns; ++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (matrix[(i * numColumns) + j].getEvaluated()
== false) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
calculateCell(i,j);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>} // end
column for<BR>
&nbsp;&nbsp;} // end row for<BR>
}<BR>
<BR>
</TT>&nbsp;<TT>// Recalculate an individual
cell...<BR>
&nbsp;// Update its evaluation when complete...<BR>
</TT>&nbsp;<TT>double calculateCell(int
row,int col) {<BR>
&nbsp;&nbsp;// Get the index of the calculation...<BR>
</TT>&nbsp;&nbsp;<TT>int index;<BR>
&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>index =
getMatrixIndex(row,col);<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>catch (IllegalArgumentException
e) {<BR>
&nbsp;&nbsp;&nbsp;return 0.0;&nbsp;&nbsp;// Bad index...<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;&nbsp;<TT>// Set up the
parser to recalculate the cell...<BR>
&nbsp;&nbsp;FormulaParser f = new FormulaParser(matrix[index].getCellString());
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// First
get the type...<BR>
&nbsp;&nbsp;&nbsp;int typeFormula = f.getType();<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// If it's
empty, you're done...<BR>
&nbsp;&nbsp;&nbsp;if (typeFormula == f.EMPTY) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>matrix[index].setEvalValue(0.0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return 0.0;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;&nbsp;// If it's a literal, you can also finish quickly...
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>if (typeFormula
== f.LITERAL) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// It better be some kind of number...
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; double dbl = f.getLiteral(); // Get the
double value...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
matrix[index].setEvalValue(dbl);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return dbl;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Some kind of invalid string...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>catch(FormulaParserException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Invalid literal
at [&quot; + row + &quot;,&quot; + col + &quot;]&quot;);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
matrix[index].setEvalValue(0.0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return 0.0;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>}
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Formulas
got to be parsed and maybe recurse, however...<BR>
&nbsp;&nbsp;&nbsp;double dbl;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dbl = parseFormula(matrix[index],f);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;&nbsp;catch (Exception e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>System.out.println(&quot;Invalid
formula at [ &quot; + row + &quot;,&quot; + col + &quot;]&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dbl = 0.0;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;&nbsp;matrix[index].setEvalValue(dbl);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>return
dbl;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Parse out a formula...<BR>
</TT>&nbsp;&nbsp;<TT>// Assumes formula
parser is set to a certain formula...<BR>
&nbsp;&nbsp;double parseFormula(Cell c, FormulaParser f) throws
FormulaParserException {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Figure
out what type of formula it is...<BR>
&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>int
op = f.getOperation();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Get the arguments...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>ArgValue
arg1 = new ArgValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ArgValue arg2 = new ArgValue();<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>f.getOpArgs(arg1,arg2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Sum operation is different from rest...
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>if
(op != f.SUM) { // SUM is even worse...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; double val1,val2;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
// Get the values...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // See if you have to recurse...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
if (arg1.getType() == arg1.CELL)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val1 = calculateCell(arg1.getRow(),arg1.getColumn());
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val1 = arg1.getLiteral();
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
if (arg2.getType() == arg1.CELL)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val2 = calculateCell(arg2.getRow(),arg2.getColumn());
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val2 = arg2.getLiteral();
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
// Perform the operation...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; switch (op) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;case
f.ADD:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (val1 + val2);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;case
f.MULT:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (val1 * val2);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;case
f.DIV:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;&nbsp;&nbsp;//
Handle divide by zero errors...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;double
ret = val1 / val2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (ArithmeticException
e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;//
Divide by zero!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0.0;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case f.SUB:<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
return (val1 - val2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;// end switch...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {&nbsp;&nbsp;// Sum...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
double dbl = 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; int index;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
// Validate row-wise or column operation...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if ((arg1.getType() != arg1.CELL) ||
(arg2.getType() != arg2.CELL))<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;throw
new FormulaParserException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // Row-wise or column-wise...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
if (arg1.getRow() == arg2.getRow()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg2.getColumn() &lt;
arg1.getColumn())<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
throw new FormulaParserException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = arg1.getColumn();
i &lt;= arg2.getColumn(); ++i) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
// Skip cases where the cells are the same...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = getMatrixIndex(arg2.getRow(),i);
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
if (matrix[index] == c)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
// If OK, then recurse...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbl += calculateCell(arg2.getRow(),i);
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;}
// end for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dbl;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp; else if (arg1.getColumn() == arg2.getColumn())
{<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;if
(arg2.getRow() &lt; arg1.getRow())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new FormulaParserException();
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;for
(int i = arg1.getRow(); i &lt;= arg2.getRow(); ++i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip cases
where the cells are the same...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;index
= getMatrixIndex(i,arg2.getColumn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (matrix[index]
== c)<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If OK, then
recurse...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;dbl
+= calculateCell(i,arg2.getColumn());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } // end for<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;
return dbl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>throw
new FormulaParserException();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>return
0.0;<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>catch (FormulaParserException
e) {<BR>
&nbsp;&nbsp;&nbsp;throw e;<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;}<BR>
<BR>
// Invalidate all cells that are formulas to force recalculation...
<BR>
</TT>&nbsp;<TT>void invalidateFormulas()
{<BR>
&nbsp;&nbsp;// Set up the parser to get the cell type...<BR>
</TT>&nbsp;&nbsp;<TT>FormulaParser
f = new FormulaParser();<BR>
&nbsp;&nbsp;int numCells = numRows * numColumns;<BR>
</TT>&nbsp;&nbsp;<TT>for (int i =
0; i &lt; numCells; ++i) {<BR>
&nbsp;&nbsp;&nbsp;f.setFormula(matrix[i].getCellString());<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>if (f.getType()
== f.FORMULA)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;matrix[i].setEvaluated(false);<BR>
</TT>&nbsp;&nbsp;<TT>} // end for
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Get the number of rows in the container<BR>
</TT>&nbsp;<TT>int getNumRows() {
<BR>
&nbsp;&nbsp;return numRows;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Get the number of
columns in the container<BR>
&nbsp;int getNumColumns() {<BR>
</TT>&nbsp;&nbsp;<TT>return numColumns;
<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheFormulaParserClass">The FormulaParserClass</A>
</H3>
<P>
This class is used to parse the elements of a single formula.
Its public integer variables are used to indicate what kind of
operation (such as SUM) is being performed or whether the formula
is a literal or empty value. It uses internal hints to keep track
of the current parsing operation. It not only returns the type
of operation the formula performs, but also the contents of its
arguments. For example, the formula SUM(A0,A3) results in the
first argument being parsed into row 0 and column 0 (corresponding
to A0) and row 0 and column 3 (cell A3). These are stored in the
helper ArgValue class. A FormulaParserException object is thrown
if there is anything wrong with the formula or literal.
<P>
For the sake of saving space, you are referred to the accompanying
CD-ROM for the source code of this class.
<H3><A NAME="TheFormulaParserExceptionClass">The FormulaParserException
Class</A></H3>
<P>
This exception is thrown when a String does not contain a proper
formula, for any of a variety of reasons. It is a subclass of
IllegalArgumentException.<BR>
<HR>
<BLOCKQUOTE>
<B>Listing 3.7. The FormulaParserException class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This class is an Exception thrown
when a<BR>
// formula is an invalid format...<BR>
public class FormulaParserException extends IllegalArgumentException
{ }</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheArgValueClass">The ArgValue Class</A></H3>
<P>
This class does little more than hold information about an argument.
Public integer variables are used to indicate whether the argument
is a literal or cell value. If it is the former, the class stores
the converted double value. If it is a cell in a spreadsheet,
then its converted row and column values are stored.
<P>
In the interest of saving space, see the accompanying CD-ROM for
the source code of this class.
<H3><A NAME="TheSpreadsheetCellClass">The SpreadsheetCell Class</A>
</H3>
<P>
This class is used to draw the contents of an individual Cell.
It is an extension of the Canvas class and has a custom <TT>paint()</TT>
method that is used to draw the Cell at specific coordinates.
It gets the evaluated value of the Cell to determine what to display.
The text and background color of the Cell can be set through public
methods. It is also possible to indicate that the literal Cell
value should be painted and the evaluated value should be ignored.
<HR>
<BLOCKQUOTE>
<B>Listing 3.8. The SpreadsheetCell class</B>.<BR>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
<BR>
// This class ties the contents of an individual<BR>
// SpreadsheetCell to a single data Cell.<BR>
// The evaluated contents of<BR>
// that cell are returned to the SpreadsheetContainer...<BR>
public class SpreadsheetCell extends Canvas {<BR>
</TT>&nbsp;<TT>Cell c;&nbsp;&nbsp;//
The cell this is tied to...<BR>
&nbsp;boolean literal;&nbsp;&nbsp;// If set to true, automatically
paint what's in <BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// cell string...<BR>
&nbsp;Color fillColor;<BR>
</TT>&nbsp;<TT>Color textColor;<BR>
&nbsp;public SpreadsheetCell(Cell c,boolean literal) {<BR>
</TT>&nbsp;<TT>&nbsp;super();<BR>
&nbsp;&nbsp;this.c = c;<BR>
</TT>&nbsp;<TT>&nbsp;this.literal
= literal;<BR>
&nbsp;&nbsp;// Set the color defaults...<BR>
</TT>&nbsp;<TT>&nbsp;fillColor = Color.white;
<BR>
&nbsp;&nbsp;textColor = Color.black;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Set the fill color
<BR>
&nbsp;public void setFillColor(Color clr) {<BR>
</TT>&nbsp;<TT>&nbsp;fillColor = clr;
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Set the text color<BR>
</TT>&nbsp;<TT>public void setTextColor(Color
clr) {<BR>
&nbsp;&nbsp;textColor = clr;<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Return the reference
to the cell...<BR>
&nbsp;public Cell getCell() {<BR>
</TT>&nbsp;<TT>&nbsp;return c;<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Set the cell string...<BR>
</TT>&nbsp;<TT>public void setString(String
s) {<BR>
&nbsp;&nbsp;c.setCellString(s);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Get the current
string value in the cell...<BR>
&nbsp;public String getString() {<BR>
</TT>&nbsp;<TT>&nbsp;return c.getCellString();
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// This will return the text to the current evaluated contents
<BR>
</TT>&nbsp;<TT>// of the cell...<BR>
&nbsp;public synchronized void paint(Graphics g,int x,int y,int
width,int height) {<BR>
</TT>&nbsp;<TT>&nbsp;String s = c.getCellString();
<BR>
&nbsp;&nbsp;String textPaint;<BR>
</TT>&nbsp;<TT>&nbsp;// If this is
a literal value, then print what it has...<BR>
&nbsp;&nbsp;if (literal == true)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;textPaint
= s;<BR>
&nbsp;&nbsp;else {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Otherwise,
display formula only if cell is not empty...<BR>
&nbsp;&nbsp;&nbsp;if (s.compareTo(&quot;&quot;) == 0)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;textPaint
= s;<BR>
&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;// Otherwise, show evaluate
value...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;textPaint
= String.valueOf(c.getEvalValue()) ;<BR>
&nbsp;&nbsp;} // end else<BR>
</TT>&nbsp;<TT>&nbsp;// Set up drawing
rectangle...<BR>
&nbsp;&nbsp;g.setColor(Color.blue);<BR>
</TT>&nbsp;<TT>&nbsp;g.drawRect(x,y,width,height);
<BR>
&nbsp;&nbsp;g.setColor(fillColor);<BR>
</TT>&nbsp;<TT>&nbsp;g.fillRect(x
+ 1,y + 1,width - 2,height - 2);<BR>
&nbsp;&nbsp;// Clip the text if necessary...<BR>
</TT>&nbsp;<TT>&nbsp;int textWidth;
<BR>
&nbsp;&nbsp;int len = textPaint.length();<BR>
</TT>&nbsp;<TT>&nbsp;int effWidth
= width - 4;<BR>
&nbsp;&nbsp;// Loop until text is small enough to fit...<BR>
</TT>&nbsp;<TT>&nbsp;while (len &gt;
0) {<BR>
&nbsp;&nbsp;&nbsp;textWidth = g.getFontMetrics().stringWidth(textPaint);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;if (textWidth
&lt; effWidth)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;-len;<BR>
&nbsp;&nbsp;&nbsp;textPaint = textPaint.substring(0,len);<BR>
</TT>&nbsp;<TT>&nbsp;} // end while
<BR>
&nbsp;&nbsp;// Draw the string<BR>
</TT>&nbsp;<TT>&nbsp;g.setColor(textColor);
<BR>
&nbsp;&nbsp;g.drawString(textPaint,x + 4,y + (height - 2));<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Return the literal
value...<BR>
&nbsp;public boolean getLiteral() {<BR>
</TT>&nbsp;<TT>&nbsp;return literal;
<BR>
&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheSpreadsheetContainerClass">The SpreadsheetContainer
Class</A></H3>
<P>
This class constructs the spreadsheet to be displayed. It takes
as input an instance of CellContainer that contains the matrix
being operated on. It constructs a matrix of Spreadsheet cells,
each of which is tied to an individual Cell in the CellContainer,
except for the headers. These are represented by SpreadsheetCells
(set to a literal value) created on the boundaries of the spreadsheet
to display the row and column headers.
<P>
The SpreadsheetContainer class is derived from the Canvas class.
It overrides the <TT>paint()</TT>
method to draw the SpreadsheetCells. It goes across and down the
spreadsheet matrix repeatedly calling the SpreadsheetCell's <TT>paint()</TT>
method, providing the coordinates of where it should be drawn.
Note the <TT>update()</TT> method
that is called before <TT>paint()</TT>;
this was added to prevent flicker. The default behavior of <TT>update()</TT>
is to blank out the painting area with a white color; this causes
a &quot;flicker&quot; until the <TT>paint()</TT>
method is next called. By overriding <TT>update()</TT>
with a direct call to <TT>paint()</TT>,
however, you can avoid the flicker. Try removing the <TT>update()</TT>
method from the SpreadsheetContainer class, and you can see the
flicker that results.
<P>
The SpreadsheetContainer class also controls the currently highlighted
cell by setting the background and text color of the highlighted
SpreadsheetCell. It also overrides the <TT>handleEvent()</TT>
method so it can trap mouse clicks. It checks to see whether the
mouse is over a valid cell; if so, it is given the highlight.
<HR>
<BLOCKQUOTE>
<B>Listing 3.9. The SpreadsheetContainer class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.lang.*;<BR>
<BR>
// This class contains the cells that make up a spreadsheet...
<BR>
public class SpreadsheetContainer extends Canvas {<BR>
&nbsp;CellContainer c;&nbsp;&nbsp;// The actual spreadsheet data...
<BR>
</TT>&nbsp;<TT>int numRows;<BR>
&nbsp;int numColumns;<BR>
</TT>&nbsp;<TT>SpreadsheetCell matrix[];
<BR>
&nbsp;int cellWidth; // These are set in the paint routine...
<BR>
</TT>&nbsp;<TT>int cellHeight;<BR>
&nbsp;SpreadsheetCell newHighlight;<BR>
</TT>&nbsp;<TT>SpreadsheetCell oldHighlight;
<BR>
<BR>
</TT>&nbsp;<TT>// Construct container.&nbsp;&nbsp;Create
internal paint matrix tied to<BR>
&nbsp;// the data container...<BR>
</TT>&nbsp;<TT>public SpreadsheetContainer(CellContainer
ctnr) {<BR>
&nbsp;&nbsp;super();<BR>
</TT>&nbsp;&nbsp;<TT>// Load the container
and set up the display...<BR>
&nbsp;&nbsp;loadContainer(ctnr);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Take a cell container
and load set the spreadsheet<BR>
&nbsp;// to use it. Put the highlight in the first cell...<BR>
</TT>&nbsp;<TT>void loadContainer(CellContainer
ctnr) {<BR>
&nbsp;&nbsp;c = ctnr; // Store the CellContainer...<BR>
<BR>
&nbsp;&nbsp;// Get size of spreadsheet...<BR>
</TT>&nbsp;&nbsp;<TT>numRows = c.getNumRows()
+ 1;<BR>
&nbsp;&nbsp;numColumns = c.getNumColumns() + 1;<BR>
<BR>
&nbsp;&nbsp;// Create the SpreadsheetCell matrix...<BR>
</TT>&nbsp;&nbsp;<TT>matrix = new
SpreadsheetCell[numRows * numColumns];<BR>
<BR>
</TT>&nbsp;&nbsp;<TT>// Add the cells
to the grid...<BR>
&nbsp;&nbsp;int i,j,index;<BR>
</TT>&nbsp;&nbsp;<TT>char ch;<BR>
<BR>
</TT>&nbsp;&nbsp;<TT>// Add the column
labels across the top...<BR>
&nbsp;&nbsp;for (j = 0; j &lt; numColumns; ++j) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Create
a literal cell for each column...<BR>
&nbsp;&nbsp;&nbsp;matrix[j] = new SpreadsheetCell(new Cell(),true);
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Set
the cell contents and color...<BR>
&nbsp;&nbsp;&nbsp;if (j &gt; 0)<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>matrix[j].setString(String.valueOf((j
- 1)) );<BR>
&nbsp;&nbsp;&nbsp;matrix[j].setFillColor(Color.lightGray);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>matrix[j].setTextColor(Color.blue);
<BR>
&nbsp;&nbsp;} // end for<BR>
<BR>
&nbsp;&nbsp;// Create the individual rows...<BR>
</TT>&nbsp;&nbsp;<TT>for (i = 1; i
&lt; numRows; ++i) {<BR>
&nbsp;&nbsp;&nbsp;// Set up the row header...<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>index =
(i * (numColumns));<BR>
&nbsp;&nbsp;&nbsp;matrix[index] = new SpreadsheetCell(new Cell(),true);
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>ch = (char)('A'
+ (i - 1));<BR>
&nbsp;&nbsp;&nbsp;matrix[index].setString(String.valueOf(ch) );
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>matrix[index].setFillColor(Color.lightGray);
<BR>
&nbsp;&nbsp;&nbsp;matrix[index].setTextColor(Color.blue);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Now
set the container cells...<BR>
&nbsp;&nbsp;&nbsp;for (j = 1; j &lt; numColumns; ++j) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>index
= (i * (numColumns)) + j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;matrix[index] = new SpreadsheetCell(c.getCell(i
- 1,j - 1),false);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>//
Set the colors...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;matrix[index].setFillColor(Color.white);
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>matrix[index].setTextColor(Color.black);
<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end inner for...<BR>
</TT>&nbsp;&nbsp;<TT>} // end outer
for<BR>
<BR>
</TT>&nbsp;&nbsp;<TT>// Highlight
the upper-left cell...<BR>
&nbsp;&nbsp;index = getIndex(1,1);<BR>
</TT>&nbsp;&nbsp;<TT>newHighlight
= matrix[index];<BR>
&nbsp;&nbsp;oldHighlight = newHighlight;<BR>
</TT>&nbsp;&nbsp;<TT>setCellHighlight(newHighlight,true);
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Attach a new container to the spreadsheet...<BR>
</TT>&nbsp;<TT>public void newCellContainer(CellContainer
ctnr) {<BR>
&nbsp;&nbsp;// Load the container and set up the display...<BR>
</TT>&nbsp;&nbsp;<TT>loadContainer(ctnr);
<BR>
&nbsp;&nbsp;repaint();<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Return the currently
highlighted row...<BR>
&nbsp;public SpreadsheetCell getHighlight() {<BR>
</TT>&nbsp;&nbsp;<TT>return newHighlight;
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Get the index into the matrix for a row or column...
<BR>
</TT>&nbsp;<TT>int getIndex(int row,
int col) {<BR>
&nbsp;&nbsp;return ((row * numColumns) + col);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Handle mouse clicks...
<BR>
&nbsp;void setMouseHighlight(int x, int y) {<BR>
</TT>&nbsp;&nbsp;<TT>// First figure
out what cell is at those coordinates...<BR>
&nbsp;&nbsp;newHighlight = calculatePaint(null,false,x,y);<BR>
</TT>&nbsp;&nbsp;<TT>// Make it the
new highlight if it is not a border element...<BR>
&nbsp;&nbsp;if ((newHighlight != null) &amp;&amp; (newHighlight.getLiteral()
== false) ) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Turn
off old highlight...<BR>
&nbsp;&nbsp;&nbsp;if ((oldHighlight != null) &amp;&amp; (oldHighlight
!= newHighlight))<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>setCellHighlight(oldHighlight,false);
<BR>
&nbsp;&nbsp;&nbsp;// Set new highlight...<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>setCellHighlight(newHighlight,true);
<BR>
&nbsp;&nbsp;&nbsp;oldHighlight = newHighlight;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// Notify
parent of change...<BR>
&nbsp;&nbsp;&nbsp;notifyParentOfHighlight(newHighlight);<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;}<BR>
<BR>
// Highlight a cell<BR>
</TT>&nbsp;<TT>// If boolean is on
then highlight; else set to normal...<BR>
&nbsp;void setCellHighlight(SpreadsheetCell sc,boolean on) {<BR>
</TT>&nbsp;&nbsp;<TT>if (on == true)
{&nbsp;&nbsp;&nbsp;// Highlight it!<BR>
&nbsp;&nbsp;&nbsp;sc.setFillColor(Color.red);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>sc.setTextColor(Color.white);
<BR>
&nbsp;&nbsp;} // end if<BR>
</TT>&nbsp;&nbsp;<TT>else {&nbsp;&nbsp;&nbsp;//
Set to normal...<BR>
&nbsp;&nbsp;&nbsp;sc.setFillColor(Color.white);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>sc.setTextColor(Color.black);
<BR>
&nbsp;&nbsp;} // end else...<BR>
</TT>&nbsp;&nbsp;<TT>// Force the
cell to repaint...<BR>
&nbsp;&nbsp;repaint();<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Update message sent
when repainting is needed...<BR>
&nbsp;// Prevent paint from getting cleared out...<BR>
</TT>&nbsp;<TT>public void update(Graphics
g) {<BR>
&nbsp;&nbsp;paint(g);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Draw the displayable
spreadsheet contents...<BR>
&nbsp;public synchronized void paint (Graphics g) {<BR>
</TT>&nbsp;&nbsp;<TT>// Go through
the calculations of the paint while painting...<BR>
&nbsp;&nbsp;calculatePaint(g,true,0,0);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// This goes through
the motions of calculating what is on the<BR>
&nbsp;// screen and either calculates coordinates or paints...
<BR>
</TT>&nbsp;<TT>// If it is not paint,
returns cell that fits in hit region...<BR>
&nbsp;SpreadsheetCell calculatePaint(Graphics g,boolean bPaint,int
xHit,int yHit) {<BR>
</TT>&nbsp;&nbsp;<TT>// Get the current
size of the display area...<BR>
&nbsp;&nbsp;Dimension dm = size();<BR>
</TT>&nbsp;&nbsp;<TT>// Calculate
the cell width and height<BR>
&nbsp;&nbsp;// Cell should be wide enough to show 8 digits...
<BR>
</TT>&nbsp;&nbsp;<TT>if (bPaint ==
true) {<BR>
&nbsp;&nbsp;&nbsp;cellWidth = g.getFontMetrics().stringWidth(&quot;12345.67&quot;);
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>cellHeight
= g.getFontMetrics().getHeight();<BR>
&nbsp;&nbsp;} // end if<BR>
<BR>
&nbsp;&nbsp;// Figure out how many rows and cols can be displayed
<BR>
</TT>&nbsp;&nbsp;<TT>int nCol = Math.min(numColumns,dm.width
/ cellWidth);<BR>
&nbsp;&nbsp;int nRow = Math.min((numRows + 1),dm.height / cellHeight);
<BR>
<BR>
&nbsp;&nbsp;// Draw the cells...<BR>
</TT>&nbsp;&nbsp;<TT>int index,i,x,j,y;
<BR>
&nbsp;&nbsp;-nRow;<BR>
</TT>&nbsp;&nbsp;<TT>// Go across
the rows...<BR>
&nbsp;&nbsp;for (i = 0; i &lt; nRow; ++i) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>y = cellHeight
+ (i * cellHeight);<BR>
&nbsp;&nbsp;&nbsp;// Go across the colomns...<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>for (j
= 0; j &lt; nCol; ++j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;index = (i * numColumns) + j;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>//
Paint if told to...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (bPaint == true) {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
matrix[index].paint(g, (j * cellWidth),y,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cellWidth,cellHeight);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else { // Otherwise see whether cell fits...
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
x = (j * cellWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // See whether it fits in the column...
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>
if ((xHit &gt;= x) &amp;&amp; (xHit &lt; (x + cellWidth))) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// See whether it fits in
the row...<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;if
((yHit &gt;= y) &amp;&amp; (yHit &lt; (y + cellHeight))) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return matrix[index];<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;}
// end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp; } // end if<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>}
<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;// end column for<BR>
</TT>&nbsp;&nbsp;<TT>} // end row
for<BR>
&nbsp;&nbsp;return null;&nbsp;&nbsp;// Only used if paint is false...
<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Notify parent that
there is a new Highlight...<BR>
&nbsp;void notifyParentOfHighlight(SpreadsheetCell sc) {<BR>
</TT>&nbsp;&nbsp;<TT>// Create new
event with highlight cell as arg<BR>
&nbsp;&nbsp;Event ev = new Event(this,Event.ACTION_EVENT,sc);
<BR>
</TT>&nbsp;&nbsp;<TT>// Send it to
the parent...<BR>
&nbsp;&nbsp;getParent().deliverEvent(ev);<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Handle mouse clicks
to spreadsheet...<BR>
&nbsp;public boolean handleEvent(Event evt) {<BR>
</TT>&nbsp;&nbsp;<TT>switch(evt.id)
{<BR>
&nbsp;&nbsp;&nbsp;// Mouse clicks. See whether you should highlight
<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>// cell
on spreadsheet...<BR>
&nbsp;&nbsp;&nbsp;case Event.MOUSE_DOWN: {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>if
(evt.target instanceof SpreadsheetContainer)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; setMouseHighlight(evt.x,evt.y);<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>return
false;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>default:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Handle to change to a formula...<BR>
</TT>&nbsp;<TT>// Throws an exception
if the formula is invalid...<BR>
&nbsp;public void replaceFormula(SpreadsheetCell sc,String newFormula)
throws <BR>
</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>IllegalArgumentException
{<BR>
String convertedFormula;<BR>
</TT>&nbsp;&nbsp;<TT>// First validate
the formula...<BR>
&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>convertedFormula
= c.validateFormula(sc.getCell(),newFormula);<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// If formula
is invalid, rethrow an exception...<BR>
&nbsp;&nbsp;catch (FormulaParserException e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>throw new
IllegalArgumentException();<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Add converted
formula to cell...<BR>
&nbsp;&nbsp;sc.setString(convertedFormula);<BR>
</TT>&nbsp;&nbsp;<TT>// Recalc...
<BR>
&nbsp;&nbsp;c.recalculateAll();<BR>
</TT>&nbsp;&nbsp;<TT>// Repaint...
<BR>
&nbsp;&nbsp;repaint();<BR>
</TT>&nbsp;<TT>}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheSpreadsheetFrameClass">The SpreadsheetFrame Class</A>
</H3>
<P>
The SpreadsheetFrame class is responsible for presenting the spreadsheet
applet to the user. Its most important component is the SpreadsheetContainer
class, displayed in the middle of the applet. It creates the CellContainer
class that is passed to the SpreadsheetContainer. It also has
a TextField object used to edit the individual Cell values. The
components of SpreadsheetFrame are displayed using the GridBagLayout
manager.
<P>
When the user clicks on a cell in the SpreadsheetContainer, the
SpreadsheetFrame class gets a notification of the current cell
highlighted and sticks the text of the cell into the TextField.
When the user enters the text, the new formula is validated, and
the spreadsheet is redisplayed with the recalculated values.
<P>
The SpreadsheetFrame also has a menu attached to it. Currently,
the only menu options are Quit and New for a new spreadsheet.
Frames and menus will be discussed in more detail in the next
chapter.]
<HR>
<BLOCKQUOTE>
<B>Listing 3.10. The SpreadsheetFrame Class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// THIS CLASS IS NOT PUBLIC! Compile
in same file as SpreadsheetApplet class.<BR>
// This is the frame that controls that user interaction<BR>
// with the applet.&nbsp;&nbsp;It creates the initial spreadsheet
data<BR>
// and visual container, along with the input field for<BR>
// changing values of a cell, the scrollbars, and the menus<BR>
class SpreadsheetFrame extends Frame {<BR>
</TT>&nbsp;<TT>CellContainer c;&nbsp;&nbsp;&nbsp;//
The actual spreadsheet data...<BR>
&nbsp;SpreadsheetContainer s;&nbsp;&nbsp;// The spreadsheet view
<BR>
</TT>&nbsp;<TT>Scrollbar hScroll;&nbsp;&nbsp;//
The scrollbars...<BR>
&nbsp;Scrollbar vScroll;<BR>
</TT>&nbsp;<TT>GridBagLayout g;&nbsp;&nbsp;&nbsp;//
Layout for Frame<BR>
&nbsp;MenuBar mbar;&nbsp;&nbsp;// The frames menu...<BR>
</TT>&nbsp;<TT>TextField t;&nbsp;&nbsp;//
The text field for the spreadsheet...<BR>
&nbsp;SpreadsheetCell currHighlight;&nbsp;&nbsp;// The currently
highlighted cell...<BR>
</TT>&nbsp;<TT>Applet appl; // The
applet...<BR>
&nbsp;int numRows;&nbsp;&nbsp;// Keep the initial parameters...
<BR>
</TT>&nbsp;<TT>int numCols;<BR>
<BR>
</TT>&nbsp;<TT>// The constructor
for the spreadsheet frame takes the<BR>
&nbsp;// values of the size of the Spreadsheet...<BR>
</TT>&nbsp;<TT>public SpreadsheetFrame(Applet
a,int rows, int cols) {<BR>
&nbsp;&nbsp;super(&quot;Spreadsheet Applet&quot;);<BR>
<BR>
&nbsp;&nbsp;// Set the initial size and layouts...<BR>
</TT>&nbsp;<TT>&nbsp;resize(300,200);
<BR>
&nbsp;&nbsp;g = new GridBagLayout();<BR>
</TT>&nbsp;<TT>&nbsp;setLayout(g);
<BR>
&nbsp;&nbsp;appl = a;&nbsp;&nbsp;// Store the applet...<BR>
</TT>&nbsp;<TT>&nbsp;numRows = rows;
<BR>
&nbsp;&nbsp;numCols = cols;<BR>
<BR>
&nbsp;&nbsp;// Create the new container based on the applet parameters...
<BR>
</TT>&nbsp;<TT>&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;c = new CellContainer(rows,cols);<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
&nbsp;&nbsp;catch (IllegalArgumentException e) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;System.out.println(&quot;Invalid
Spreadsheet parameters&quot;);<BR>
&nbsp;&nbsp;&nbsp;dispose();<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Add some fake
data to see how it works...<BR>
&nbsp;&nbsp;addTestData();<BR>
<BR>
&nbsp;&nbsp;// Create display components...<BR>
</TT>&nbsp;<TT>&nbsp;addDisplayComponents();
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Add the menu
choices to the frames<BR>
&nbsp;&nbsp;addMenuItems();<BR>
<BR>
&nbsp;&nbsp;// Pack before display...<BR>
</TT>&nbsp;<TT>&nbsp;pack();<BR>
&nbsp;&nbsp;resize(300,200);&nbsp;&nbsp;// Then reset to default
value...<BR>
</TT>&nbsp;<TT>&nbsp;show();<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Handle system and user events...<BR>
</TT>&nbsp;<TT>public boolean handleEvent(Event
evt) {<BR>
&nbsp;&nbsp;switch(evt.id) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;case Event.WINDOW_DESTROY:
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dispose();&nbsp;&nbsp;&nbsp;// Kill the
frame...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
true;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// This
can be handled<BR>
&nbsp;&nbsp;&nbsp;case Event.ACTION_EVENT: {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;String
menu_name = evt.arg.toString();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (evt.target instanceof MenuItem)&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
// Exit...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; if(menu_name.equals(&quot;Quit&quot;))
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;dispose();&nbsp;&nbsp;//
Kill the frame...<BR>
&nbsp;&nbsp;&nbsp;&nbsp; // New Spreadsheet...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
if(menu_name.equals(&quot;New&quot;))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newSpreadsheet();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (evt.target instanceof TextField)&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
validateNewFormula();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;//
end if<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (evt.target instanceof SpreadsheetContainer)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
changeInputFormula((SpreadsheetCell)evt.arg);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;default:<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
// Add the menu choices to the frames<BR>
&nbsp;void addMenuItems() {<BR>
</TT>&nbsp;<TT>&nbsp;mbar = new MenuBar();
<BR>
&nbsp;&nbsp;Menu m = new Menu(&quot;File&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;m.add(new MenuItem(&quot;New&quot;));
<BR>
&nbsp;&nbsp;m.addSeparator();<BR>
</TT>&nbsp;<TT>&nbsp;m.add(new MenuItem(&quot;Quit&quot;));
<BR>
&nbsp;&nbsp;mbar.add(m);<BR>
</TT>&nbsp;<TT>&nbsp;setMenuBar(mbar);
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Add the spreadsheet and input field<BR>
</TT>&nbsp;<TT>// to display...<BR>
&nbsp;void addDisplayComponents() {<BR>
</TT>&nbsp;<TT>&nbsp;GridBagConstraints
gbc = new GridBagConstraints();<BR>
&nbsp;&nbsp;// Create an input field across the top...<BR>
</TT>&nbsp;<TT>&nbsp;gbc.fill = GridBagConstraints.BOTH;
<BR>
&nbsp;&nbsp;gbc.weightx = 1.0;<BR>
</TT>&nbsp;<TT>&nbsp;gbc.gridwidth
= GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;t = new TextField();<BR>
</TT>&nbsp;<TT>&nbsp;g.setConstraints(t,gbc);
<BR>
&nbsp;&nbsp;add(t);<BR>
<BR>
&nbsp;&nbsp;// Create the spreadsheet display...<BR>
</TT>&nbsp;<TT>&nbsp;gbc.fill = GridBagConstraints.BOTH;
<BR>
&nbsp;&nbsp;gbc.weightx = 1.0;<BR>
</TT>&nbsp;<TT>&nbsp;gbc.weighty =
1.0;<BR>
&nbsp;&nbsp;gbc.gridwidth = GridBagConstraints.RELATIVE;<BR>
</TT>&nbsp;<TT>&nbsp;gbc.gridheight
= 10;<BR>
&nbsp;&nbsp;s = new SpreadsheetContainer(c);<BR>
</TT>&nbsp;<TT>&nbsp;g.setConstraints(s,gbc);
<BR>
&nbsp;&nbsp;add(s);<BR>
<BR>
&nbsp;&nbsp;// Set initial formula for text field...<BR>
</TT>&nbsp;<TT>&nbsp;changeInputFormula(s.getHighlight());
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Change the formula of the input field to that of<BR>
</TT>&nbsp;<TT>// the Object argument,
which is a spreadsheet cell...<BR>
&nbsp;void changeInputFormula(SpreadsheetCell sc) {<BR>
</TT>&nbsp;<TT>&nbsp;// Set the text
box with the formula...<BR>
&nbsp;&nbsp;if (sc != null)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;t.setText(sc.getString());
<BR>
&nbsp;&nbsp;else<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;t.setText(&quot;&quot;);
<BR>
&nbsp;&nbsp;// Store the currently highlighted cell...<BR>
</TT>&nbsp;<TT>&nbsp;currHighlight
= sc;<BR>
&nbsp;}<BR>
<BR>
&nbsp;// A text field formula has been entered...<BR>
</TT>&nbsp;<TT>// Validate it and
update spreadsheet...<BR>
&nbsp;// Update text field where necessary...<BR>
</TT>&nbsp;<TT>void validateNewFormula()
{<BR>
&nbsp;&nbsp;// Put up wait icon for calculations...<BR>
</TT>&nbsp;<TT>&nbsp;int oldCursor
= getCursorType();<BR>
&nbsp;&nbsp;setCursor(WAIT_CURSOR);<BR>
</TT>&nbsp;<TT>&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;// Replace the formula.&nbsp;&nbsp;If no problem,
then<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// spreadsheet
will be recalculated...<BR>
&nbsp;&nbsp;&nbsp;s.replaceFormula(currHighlight, t.getText());
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;appl.getAppletContext().showStatus(&quot;Formula
accepted.&quot;);<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;catch (Exception
e) {&nbsp;&nbsp;// Handle illegal exception...<BR>
&nbsp;&nbsp;&nbsp;// Let browser status bar know about error...
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;// Get
the status bar from the AppletContext...<BR>
&nbsp;&nbsp;&nbsp;appl.getAppletContext().showStatus(&quot;Illegal
Formula syntax: <BR>
</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>Use
SUM,ADD,SUB,MULT,DIV&quot;);<BR>
}<BR>
</TT>&nbsp;<TT>&nbsp;// Always place
the converted formula in the text field...<BR>
&nbsp;&nbsp;changeInputFormula(s.getHighlight());<BR>
</TT>&nbsp;<TT>&nbsp;setCursor(oldCursor);
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Reload spreadsheet with blank data...<BR>
</TT>&nbsp;<TT>void newSpreadsheet()
{<BR>
&nbsp;&nbsp;// Create the new container based on the applet parameters...
<BR>
</TT>&nbsp;<TT>&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;c = new CellContainer(numRows,numCols);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;s.newCellContainer(c);
<BR>
&nbsp;&nbsp;&nbsp;// Set initial formula for text field...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;changeInputFormula(s.getHighlight());
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;catch (IllegalArgumentException
e) {<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;Invalid Spreadsheet
parameters&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;dispose();
<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>}<BR>
<BR>
</TT>&nbsp;<TT>// Just some test data...
<BR>
&nbsp;void addTestData() {<BR>
</TT>&nbsp;<TT>&nbsp;c.setCellFormula(&quot;1&quot;,0,0);
<BR>
&nbsp;&nbsp;c.setCellFormula(&quot;2&quot;,0,1);<BR>
</TT>&nbsp;<TT>&nbsp;c.setCellFormula(&quot;3&quot;,0,2);
<BR>
&nbsp;&nbsp;c.setCellFormula(&quot;4&quot;,0,3);<BR>
</TT>&nbsp;<TT>&nbsp;c.setCellFormula(&quot;SUM(A0,A3)&quot;,0,4);
// Should be 10<BR>
&nbsp;&nbsp;// c.setCellFormula(&quot;ADD(A0,A3)&quot;,0,4);&nbsp;&nbsp;//
Should be 5<BR>
</TT>&nbsp;<TT>&nbsp;// c.setCellFormula(&quot;ADD(A0,4)&quot;,0,4);&nbsp;&nbsp;//
Should be 5<BR>
&nbsp;&nbsp;// c.setCellFormula(&quot;ADD(1,4)&quot;,0,4);&nbsp;&nbsp;//
Should be 5<BR>
</TT>&nbsp;<TT>&nbsp;c.recalculateAll();
<BR>
&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheSpreadsheetAppletclass">The SpreadsheetApplet
class</A></H3>
<P>
This class takes the applet parameters and determines the size
of the spreadsheet to be constructed. If the parameters are bad,
default values are used. When row and column sizes of the spreadsheet
are determined, an instance of the SpreadsheetFrame class is created
and the visual portion of the program begins. When the user moves
away from the current Web page, the spreadsheet is hidden; it
is redisplayed if the user returns.
<HR>
<BLOCKQUOTE>
<B>Listing 3.11. The SpreadsheetApplet class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// This file describes the applet class
that manages the<BR>
// spreadsheet program.<BR>
<BR>
import java.awt.*;<BR>
import java.lang.*;<BR>
import java.applet.*;<BR>
<BR>
//&nbsp;&nbsp;This applet kicks off the SpreadsheetFrame<BR>
//&nbsp;&nbsp;that manages the spreadsheet program.<BR>
public class SpreadsheetApplet extends Applet&nbsp;&nbsp;{<BR>
</TT>&nbsp;<TT>SpreadsheetFrame fr;
<BR>
&nbsp;public void init() {<BR>
</TT>&nbsp;&nbsp;<TT>int rows = 10;&nbsp;&nbsp;//
Default if params are no good...<BR>
&nbsp;&nbsp;int cols = 10;<BR>
</TT>&nbsp;&nbsp;<TT>// Get the HTML
parameters<BR>
&nbsp;&nbsp;// and try to convert to a good value...<BR>
</TT>&nbsp;&nbsp;<TT>// Get the row...
<BR>
&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>String
param = getParameter(&quot;rows&quot;);<BR>
&nbsp;&nbsp;&nbsp;int temp = Integer.parseInt(param);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>if ((temp
&gt; 1) &amp;&amp; (temp &lt; 26))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;rows = temp;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException();
<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;catch (Exception e) {&nbsp;&nbsp;&nbsp;// Display
error to browser...<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>getAppletContext().showStatus(&quot;Invalid
row parameter. Using default...&quot;);<BR>
&nbsp;&nbsp;}<BR>
</TT>&nbsp;&nbsp;<TT>// Get the column...
<BR>
&nbsp;&nbsp;try {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>String
param = getParameter(&quot;columns&quot;);<BR>
&nbsp;&nbsp;&nbsp;int temp = Integer.parseInt(param);<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>if ((temp
&gt; 1) &amp;&amp; (temp &lt; 40))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;cols = temp;<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException();
<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;catch (Exception e) {<BR>
</TT>&nbsp;&nbsp;&nbsp;<TT>getAppletContext().showStatus(&quot;Invalid
column parameter. Using default...&quot;);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Create the spreadsheet frame<BR>
</TT>&nbsp;&nbsp;<TT>fr = new SpreadsheetFrame(this,rows,cols);
<BR>
&nbsp;}<BR>
<BR>
&nbsp;// If returning to screen, show frame...<BR>
</TT>&nbsp;<TT>public void start()
{<BR>
&nbsp;&nbsp;// Redisplay the applet...<BR>
</TT>&nbsp;&nbsp;<TT>try {<BR>
&nbsp;&nbsp;&nbsp;fr.show();<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;// Handle any problem...<BR>
</TT>&nbsp;&nbsp;<TT>catch(Exception
e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
<BR>
&nbsp;// Hide the frame upon leaving...<BR>
</TT>&nbsp;<TT>public void stop()
{<BR>
&nbsp;&nbsp;// Handle where it may have been disposed...<BR>
</TT>&nbsp;&nbsp;<TT>try {<BR>
&nbsp;&nbsp;&nbsp;fr.hide();<BR>
</TT>&nbsp;&nbsp;<TT>}<BR>
&nbsp;&nbsp;// Handle any problem...<BR>
</TT>&nbsp;&nbsp;<TT>catch(Exception
e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><FONT SIZE=5 COLOR=#FF0000><A NAME="Summary">Summary</A></FONT></H2>
<P>
In this chapter, you have read about many of the basics of AWT
and seen it applied to the creation of a non-trivial spreadsheet.
In <A HREF="ch4.htm" >Chapter 4</A>, &quot;Enhancing the Spreadsheet
Applet,&quot; you will see how dialog boxes, streams, colors,
and fonts can be applied to improve the spreadsheet applet. More
of the fundamentals of AWT will be discussed in the context of
these enhancements. You will also see a practical example of streams
as the ability to save and open a spreadsheet is added to the
applet.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



