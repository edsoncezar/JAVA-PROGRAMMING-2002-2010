<HTML>
<HEAD>
<TITLE>Day 16 -- Packages and Interfaces</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;16</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Packages and Interfaces</FONT>
</H1>
<P>
<I><B>by Laura Lemay and Charles L. Perkins</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ProgrammingintheLargeandProgrammingintheSmall">
Programming in the Large and Programming in the Small</A>
<LI><A HREF="#WhatArePackages">
What Are Packages?</A>
<LI><A HREF="#UsingPackages">
Using Packages</A>
<UL>
<LI><A HREF="#FullPackageandClassNames">
Full Package and Class Names</A>
<LI><A HREF="#TheTTFONTSIZEFACECourierimportFONTTTFONTSIZECommandFONT">
The <TT>import </TT>Command</FONT>
</A>
<LI><A HREF="#NameConflicts">
Name Conflicts</A>
<LI><A HREF="#ANoteAboutTTFONTSIZEFACECourierCLASSPATHFONTTTFONTSIZEandWhereClassesAreLocatedFONT">
A Note About <TT>CLASSPATH</TT>
and Where Classes Are Located</FONT></A>
</UL>
<LI><A HREF="#CreatingYourOwnPackages">
Creating Your Own Packages</A>
<UL>
<LI><A HREF="#PickaPackageName">
Pick a Package Name</A>
<LI><A HREF="#CreatetheDirectoryStructure">
Create the Directory Structure</A>
<LI><A HREF="#UseTTFONTSIZEFACECourierpackageFONTTTFONTSIZEtoAddYourClasstoaPackageFONT">
Use <TT>package</TT>
to Add Your Class to a Package</FONT></A>
<LI><A HREF="#PackagesandClassProtection">
Packages and Class Protection</A>
</UL>
<LI><A HREF="#WhatAreInterfaces">
What Are Interfaces?</A>
<UL>
<LI><A HREF="#TheProblemofSingleInheritance">
The Problem of Single Inheritance</A>
<LI><A HREF="#AbstractDesignandConcreteImplementation">
Abstract Design and Concrete Implementation</A>
<LI><A HREF="#InterfacesandClasses">
Interfaces and Classes</A>
</UL>
<LI><A HREF="#ImplementingandUsingInterfaces">
Implementing and Using Interfaces</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEFACECourierimplementsFONTTTFONTSIZEKeywordFONT">
The <TT>implements</TT>
Keyword</FONT></A>
<LI><A HREF="#ImplementingMultipleInterfaces">
Implementing Multiple Interfaces</A>
<LI><A HREF="#OtherUsesofInterfaces">
Other Uses of Interfaces</A>
</UL>
<LI><A HREF="#CreatingandExtendingInterfaces">
Creating and Extending Interfaces</A>
<UL>
<LI><A HREF="#NewInterfaces">
New Interfaces</A>
<LI><A HREF="#MethodsInsideInterfaces">
Methods Inside Interfaces</A>
<LI><A HREF="#ExtendingInterfaces">
Extending Interfaces</A>
<LI><A HREF="#AnExampleEnumeratingLinkedLists">
An Example: Enumerating Linked Lists</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Packages and interfaces are two capabilities that allow you greater
control and flexibility in designing sets of interrelated classes.
Packages allow you to combine groups of classes and control which
of those classes are available to the outside world; interfaces
provide a way of grouping abstract method definitions and sharing
them among classes that may not necessarily acquire those methods
through inheritance.
<P>
Today you'll learn how to design with, use, and create your own
packages and interfaces. Specific topics you'll learn about today
include
<UL>
<LI>A discussion of designing classes versus coding classes and
how to approach each
<LI>What packages are and why they are useful for class design
<LI>Using other people's packages in your own classes
<LI>Creating your own packages
<LI>What interfaces buy you in terms of code reuse and design
<LI>Designing and working with interfaces
</UL>
<H2><A NAME="ProgrammingintheLargeandProgrammingintheSmall"><FONT SIZE=5 COLOR=#FF0000>
Programming in the Large and Programming in the Small</FONT></A></H2>
<P>
When you examine a new language feature, you should ask yourself
two questions:
<UL>
<LI>How can I use it to better organize the methods and classes
of my Java program?
<LI>How can I use it while writing the actual Java code?
</UL>
<P>
The first is often called programming in the large, and the second,
programming in the small. Bill Joy, a founder of Sun Microsystems,
likes to say that Java feels like C when programming in the small
and like Smalltalk when programming in the large. What he means
by that is that Java is familiar and powerful like any C-like
language while you're coding individual lines, but has the extensibility
and expressive power of a pure object-oriented language like Smalltalk
while you're designing.
<P>
The separation of &quot;designing&quot; from &quot;coding&quot;
was one of the most fundamental advances in programming in the
past few decades, and object-oriented languages such as Java implement
a strong form of this separation. The first part of this separation
has already been described on previous days: When you develop
a Java program, first you design the classes and decide on the
relationships between these classes, and then you implement the
Java code needed for each of the methods in your design. If you
are careful enough with both these processes, you can change your
mind about aspects of the design without affecting anything but
small, local pieces of your Java code, and you can change the
implementation of any method without affecting the rest of the
design.
<P>
As you begin to explore more advanced Java programming, however,
you'll find that this simple model becomes too limiting. Today
you'll explore these limitations, for programming in the large
and in the small, to motivate the need for packages and interfaces.
Let's start with packages.
<H2><A NAME="WhatArePackages"><FONT SIZE=5 COLOR=#FF0000>
What Are Packages?</FONT></A></H2>
<P>
Packages, as mentioned a number of times in this book so far,
are a way of organizing groups of classes. A package contains
any number of classes that are related in purpose, in scope, or
by inheritance.
<P>
Why bother with packages? If your programs are small and use a
limited number of classes, you may find that you don't need to
explore packages at all. But the more Java programming you do,
the more classes you'll find you have. And although those classes
may be individually well designed, reusable, encapsulated, and
with specific interfaces to other classes, you may find the need
for a bigger organizational entity that allows you to group your
packages.
<P>
Packages are useful for several broad reasons:
<UL>
<LI>They allow you to organize your classes into units. Just as
you have folders or directories on your hard disk to organize
your files and applications, packages allow you to organize your
classes into groups so that you only use what you need for each
program.
<LI>They reduce problems with conflicts in names. As the number
of Java classes grows, so does the likelihood that you'll use
the same class name as someone else, opening up the possibility
of naming clashes and errors if you try to integrate groups of
classes into a single program. Packages allow you to &quot;hide&quot;
classes so that conflicts can be avoided.
<LI>They allow you to protect classes, variables, and methods
in larger ways than on a class-by-class basis, as you learned
yesterday. You'll learn more about protections with packages later
today.
<LI>They can be used to identify your classes. For example, if
you implemented a set of classes to perform some purpose, you
could name a package of those classes with a unique identifier
that identifies you or your organization.
</UL>
<P>
Although a package is most typically a collection of classes,
packages can also contain other packages, forming yet another
level of organization somewhat analogous to the inheritance hierarchy.
Each &quot;level&quot; usually represents a smaller, more specific
grouping of classes. The Java class library itself is organized
along these lines. The top level is called <TT>java</TT>;
the next level includes names such as <TT>io</TT>,
<TT>net</TT>, <TT>util</TT>,
and <TT>awt</TT>. The last of these
has an even lower level, which includes the package <TT>image</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
By convention, the first level of the hierarchy specifies the (globally unique) name to identify the author or owner of those packages. For example, Sun Microsystems's classes, which are not part of the standard Java environment, all begin with the prefix 
<TT>sun</TT>. Classes that Netscape includes with its implementation are contained in the <TT>netscape</TT> package. The standard package, <TT>java</TT>, is an exception to this rule because it is so fundamental and because it might someday be implemented 
by multiple companies.
</BLOCKQUOTE>
<BLOCKQUOTE>
I'll tell you more about package-naming conventions later when you create your own packages.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="UsingPackages"><FONT SIZE=5 COLOR=#FF0000>
Using Packages</FONT></A></H2>
<P>
You've been using packages all along in this book. Every time
you use the <TT>import</TT> command,
and every time you refer to a class by its full package name (<TT>java.awt.Color</TT>,
for example), you've used packages. Let's go over the specifics
of how to use classes from other packages in your own programs
to make sure you've got it and to go into greater depth than we
have in previous lessons.
<P>
To use a class contained in a package, you can use one of three
mechanisms:
<UL>
<LI>If the class you want to use is in the package <TT>java.lang</TT>
(for example, <TT>System</TT> or <TT>Date</TT>),
you can simply use the class name to refer to that class. The
<TT>java.lang</TT> classes are automatically
available to you in all your programs.
<LI>If the class you want to use is in some other package, you
can refer to that class by its full name, including any package
names (for example, <TT>java.awt.Font</TT>).
<LI>For classes that you use frequently from other packages, you
can import individual classes or a whole package of classes. After
a class or a package has been imported, you can refer to that
class by its class name.
</UL>
<P>
What about your own classes in your own programs that don't belong
to any package? The rule is that if you don't specifically define
your classes to belong to a package, they're put into an unnamed
default package. You can refer to those classes simply by class
name from anywhere in your code.
<H3><A NAME="FullPackageandClassNames">
Full Package and Class Names</A></H3>
<P>
To refer to a class in some other package, you can use its full
name: the class name preceded by any package names. You do not
have to import the class or the package to use it this way:
<BLOCKQUOTE>
<PRE>
java.awt.Font f = new java.awt.Font()
</PRE>
</BLOCKQUOTE>
<P>
For classes that you use only once or twice in your program, using
the full name makes the most sense. If, however, you use that
class multiple times, or if the package name is really long with
lots of subpackages, you'll want to import that class instead
to save yourself some typing.
<H3><A NAME="TheTTFONTSIZEFACECourierimportFONTTTFONTSIZECommandFONT">
The <TT>import </TT>Command</FONT>
</A></H3>
<P>
To import classes from a package, use the <TT>import</TT>
command, as you've used throughout the examples in this book.
You can either import an individual class, like this:
<BLOCKQUOTE>
<PRE>
import java.util.Vector;
</PRE>
</BLOCKQUOTE>
<P>
or you can import an entire package of classes, using an asterisk
(<TT>*</TT>) to replace the individual
class names:
<BLOCKQUOTE>
<PRE>
import java.awt.*<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Actually, to be technically correct, this command doesn't import all the classes in a package-it only imports the classes that have been declared <TT>public</TT>, and even then only imports those classes that the code itself refers to. You'll learn more on 
this in the section titled &quot;Packages and Class Protection.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Note that the<FONT FACE="AGaramond Bold"> </FONT>asterisk (<TT>*</TT>)
in this example is not like the one you might use at a command
prompt to specify the contents of a directory or to indicate multiple
files. For example, if you ask to list the contents of the directory
<TT>classes/java/awt/*</TT>, that
list includes all the <TT>.class</TT>
files and subdirectories, such as <TT>image</TT>
and <TT>peer</TT>. Writing <TT>import
java.awt.*</TT> imports all the public classes in that
package, but does <I>not</I> import subpackages such as <TT>image</TT>
and <TT>peer</TT>. To import all the
classes in a complex package hierarchy, you must explicitly import
each level of the hierarchy by hand. Also, you cannot indicate
partial class names (for example, <TT>L*</TT>
to import all the classes that begin with L). It's all the classes
in a package or a single class.
<P>
The <TT>import</TT> statements in
your class definition go at the top of the file, before any class
definitions (but after the package definition, as you'll see in
the next section).
<P>
So should you take the time to import classes individually or
just import them as a group? It depends on how specific you want
to be. Importing a group of classes does not slow down your program
or make it any larger; only the classes you actually use in your
code are loaded as they are needed. But importing a package does
make it a little more confusing for readers of your code to figure
out where your classes are coming from. Using individual <TT>import</TT>s
or importing packages is mostly a question of your own coding
style. <BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java's <TT>import</TT> command is not at all similar to the <TT>#include</TT> command in C-like languages, although they accomplish similar functions. The C preprocessor takes the contents of all the included files (and, in turn, the files they include, 
and so on) and stuffs them in at the spot where the <TT>#include</TT> was. The result is an enormous hunk of code that has far more lines than the original program did. Java's <TT>import</TT> behaves more like a linker; it tells the Java compiler and 
interpreter where (in which files) to find classes, variables, method names, and method definitions. It doesn't bring anything into the current Java program.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="NameConflicts">
Name Conflicts</A></H3>
<P>
After you have imported a class or a package of classes, you can
usually refer to a class name simply by its name, without the
package identifier. I say &quot;usually&quot; because there's
one case where you may have to be more explicit: when there are
multiple classes with the same name from different packages.
<P>
Here's an example. Let's say you import the classes from two packages
from two different programmers (Joe and Eleanor):
<BLOCKQUOTE>
<PRE>
import joesclasses.*;
import eleanorsclasses.*;
</PRE>
</BLOCKQUOTE>
<P>
Inside Joe's package is a class called <TT>Name</TT>.
Unfortunately, inside Eleanor's package there is also a class
called <TT>Name</TT> that has an entirely
different meaning and implementation. You would wonder whose version
of <TT>Name</TT> would end up getting
used if you referred to the <TT>Name</TT>
class in your own program like this:
<BLOCKQUOTE>
<PRE>
Name myName = new Name(&quot;Susan&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The answer is neither; the Java compiler will complain about a
naming conflict and refuse to compile your program. In this case,
despite the fact that you imported both classes, you still have
to refer to the appropriate <TT>Name</TT>
class by full package name:
<BLOCKQUOTE>
<PRE>
joesclasses.Name myName = new joesclasses.Name(&quot;Susan&quot;);
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ANoteAboutTTFONTSIZEFACECourierCLASSPATHFONTTTFONTSIZEandWhereClassesAreLocatedFONT">
A Note About <TT>CLASSPATH</TT>
and Where Classes Are Located</FONT></A></H3>
<P>
Before I go on to explain how to create your own packages of classes,
I'd like to make a note about how Java finds packages and classes
when it's compiling and running your classes.
<P>
For Java to be able to use a class, it has to be able to find
it on the file system. Otherwise, you'll get an error that the
class does not exist. Java uses two things to find classes: the
package name itself and the directories listed in your <TT>CLASSPATH</TT>
variable.
<P>
First, the package names. Package names map to directory names
on the file system, so the class <TT>java.applet.Applet</TT>
will actually be found in the <TT>applet</TT>
directory, which in turn will be inside the <TT>java</TT>
directory (<TT>java/applet/Applet.class</TT>,
in other words).
<P>
Java looks for those directories, in turn, inside the directories
listed in your <TT>CLASSPATH</TT>
variable. If you remember back to <A HREF="ch1.htm">Day 1</A>, &quot;An Introduction
to Java Programming,&quot; when you installed the JDK, you had
to set up a <TT>CLASSPATH</TT> variable
to point to the various places where your Java classes live. <TT>CLASSPATH</TT>
usually points to the <TT>java/lib</TT>
directory in your JDK release, a class directory in your development
environment if you have one, perhaps some browser-specific classes,
and to the current directory. When Java looks for a class you've
referenced in your source, it looks for the package and class
name in each of those directories and returns an error if it can't
find the class file. Most &quot;cannot load class&quot; errors
result because of missed <TT>CLASSPATH</TT>
variables.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you're using the Macintosh version of the JDK, you're probably wondering what I'm talking about. The Mac JDK doesn't use a <TT>CLASSPATH</TT> variable; it knows enough to be able to find the default classes and those contained in the current directory. 
However, if you do a lot of Java development, you may end up with classes and packages in other directories. The Java compiler contains a Preferences dialog box that lets you add directories to Java's search path.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="CreatingYourOwnPackages"><FONT SIZE=5 COLOR=#FF0000>
Creating Your Own Packages</FONT></A></H2>
<P>
Creating your own packages is a difficult, complex process, involving
many lines of code, long hours late at night with lots of coffee,
and the ritual sacrifice of many goats. Just kidding. To create
a package of classes, you have three basic steps to follow, which
I'll explain in the following sections.
<H3><A NAME="PickaPackageName">
Pick a Package Name</A></H3>
<P>
The first step is to decide what the name of your package is going
to be. The name you choose for your package depends on how you
are going to be using those classes. Perhaps your package will
be named after you, or perhaps after the part of the Java system
you're working on (like <TT>graphics</TT>
or <TT>hardware_interfaces</TT>).
If you're intending your package to be distributed to the Net
at large, or as part of a commercial product, you'll want to use
a package name (or set of package names) that uniquely identifies
you or your organization or both.
<P>
One convention for naming packages that has been recommended by
Sun is to use your Internet domain name with the elements reversed.
So, for example, if Sun were following its own recommendation,
its packages would be referred to using the name <TT>com.sun.java</TT>
rather than just <TT>java</TT>. If
your Internet domain name is <TT>fooblitzky.eng.nonsense.edu</TT>,
your package name might be <TT>edu.nonsense.eng.fooblitzky</TT>
(and you might add another package name onto the end of that to
refer to the product or to you, specifically).
<P>
The idea is to make sure your package name is unique. Although
packages can hide conflicting class names, the protection stops
there. There's no way to make sure your package won't conflict
with someone else's package if you both use the same package name.
<P>
By convention, package names tend to begin with a lowercase letter
to distinguish them from class names. Thus, for example, in the
full name of the built-in <TT>String</TT>
class, <TT>java.lang.String</TT>,
it's easier to separate the package name from the class name visually.
This convention helps reduce name conflicts.
<H3><A NAME="CreatetheDirectoryStructure">
Create the Directory Structure</A></H3>
<P>
Step two in creating packages is to create a directory structure
on your disk that matches the package name. If your package has
just one name (<TT>mypackage</TT>),
you'll only have to create a directory for that one name. If the
package name has several parts, however, you'll have to create
directories within directories. For the package name <TT>edu.nonsense.eng.fooblitzky</TT>,
you'll need to create an <TT>edu</TT>
directory and then create a <TT>nonsense</TT>
directory inside <TT>edu</TT>, an
<TT>eng</TT> directory inside <TT>nonsense</TT>,
and a <TT>fooblitzky</TT> directory
inside <TT>eng</TT>. Your classes
and source files can then go inside the <TT>fooblitzky</TT>
directory.
<H3><A NAME="UseTTFONTSIZEFACECourierpackageFONTTTFONTSIZEtoAddYourClasstoaPackageFONT">
Use <TT>package</TT>
to Add Your Class to a Package</FONT></A></H3>
<P>
The final step to putting your class inside packages is to add
the <TT>package</TT> command to your
source files. The <TT>package</TT>
command says &quot;this class goes inside this package,&quot;
and is used like this:
<BLOCKQUOTE>
<PRE>
package myclasses;
package edu.nonsense.eng.fooblitzky;
package java.awt;
</PRE>
</BLOCKQUOTE>
<P>
The single <TT>package</TT> command,
if any, must be the first line of code in your source file, after
any comments or blank lines and before any <TT>import</TT>
commands.
<P>
As mentioned before, if your class doesn't have a <TT>package</TT>
command in it, that class is contained in the default package
and can be used by any other class. But once you start using packages,
you should make sure all your classes belong to some package to
reduce the chance of confusion about where your classes belong.
<H3><A NAME="PackagesandClassProtection">
Packages and Class Protection</A></H3>
<P>
Yesterday you learned all about the four Ps of protection and
how they apply (primarily) to methods and variables and their
relationship to other classes. When referring to classes and their
relationship to other classes in other packages, you only have
two Ps to worry about: package and public.
<P>
By default, classes have package protection, which means that
the class is available to all the other classes in the same package
but is not visible or available outside that package-not even
to subpackages. It cannot be imported or referred to by name;
classes with package protection are hidden inside the package
in which they are contained.
<P>
Package protection comes about when you define a class as you
have throughout this book, like this:
<BLOCKQUOTE>
<PRE>
class TheHiddenClass extends AnotherHiddenClass {
...
}
</PRE>
</BLOCKQUOTE>
<P>
To allow a class to be visible and importable outside your package,
you'll want to give it public protection by adding the <TT>public</TT>
modifier to its definition:
<BLOCKQUOTE>
<PRE>
public class TheVisibleClass {
...
}
</PRE>
</BLOCKQUOTE>
<P>
Classes declared as <TT>public</TT>
can be imported by other classes outside the package.
<P>
Note that when you use an <TT>import</TT>
statement with an asterisk, you import only the public classes
inside that package. Hidden classes remain hidden and can be used
only by the other classes in that package.
<P>
Why would you want to hide a class inside a package? For the same
reason you want to hide variables and methods inside a class:
so you can have utility classes and behavior that are useful only
to your implementation, or so you can limit the interface of your
program to minimize the effect of larger changes. As you design
your classes, you'll want to take the whole package into consideration
and decide which classes will be declared <TT>public</TT>
and which will be hidden.
<P>
Listing 16.1 shows two classes that illustrate this point. The
first is a public class that implements a linked list; the second
is a private node of that list.
<HR>
<BLOCKQUOTE>
<B>Listing 16.1. The public class </B><TT><B>LinkedList</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: package  collections;
 2: 
 3: public class  LinkedList {
 4:     private Node  root;
 5: 
 6:     public  void  add(Object o) {
 7:         root = new Node(o, root);
 8:     }
 9:     . . .
10: }
11: 
12: class  Node {   // not public
13:     private Object  contents;
14:     private Node    next;
15: 
16:     Node(Object o, Node n) {
17:         contents = o;
18:         next     = n;
19:     }
20:     . . .
21: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Notice here that I'm including two class definitions in one file. I mentioned this briefly on <A HREF="ch13.htm">Day 13</A>, &quot;Creating User Interfaces with the awt,&quot; and it bears mentioning here as well: You can include as many class definitions 
per file as you want, but only one of them can be declared <TT>public</TT>, and that filename must have the same name as the one public class. When Java compiles the file, it'll create separate <TT>.class</TT> files for each class definition inside the 
file. In reality, I find the one-to-one correspondence of class definition to file much more easily maintained because I don't have to go searching around for the definition of a class.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The public <TT>LinkedList</TT> class
provides a set of useful public methods (such as <TT>add()</TT>)
to any other classes that might want to use them. These other
classes don't need to know about any support classes <TT>LinkedList</TT>
needs to get its job done. <TT>Node</TT>,
which is one of those support classes, is therefore declared without
a <TT>public</TT> modifier and will
not appear as part of the public interface to the <TT>collections</TT>
package.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Just because <TT>Node</TT> isn't public doesn't mean <TT>LinkedList</TT> won't have access to it once it's been imported into some other class. Think of protections not as hiding classes entirely, but more as checking the permissions of a given class to 
use other classes, variables, and methods. When you import and use <TT>LinkedList</TT>, the <TT>Node</TT> class will also be loaded into the system, but only instances of <TT>LinkedList</TT> will have permission to use it.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
One of the great powers of hidden classes is that even if you
use them to introduce a great deal of complexity into the implementation
of some public class, all the complexity is hidden when that class
is imported or used. Thus, creating a good package consists of
defining a small, clean set of public classes and methods for
other classes to use, and then implementing them by using any
number of hidden (package) support classes. You'll see another
use for hidden classes later today.
<H2><A NAME="WhatAreInterfaces"><FONT SIZE=5 COLOR=#FF0000>
What Are Interfaces?</FONT></A></H2>
<P>
Interfaces, like the abstract classes and methods you saw yesterday,
provide templates of behavior that other classes are expected
to implement. Interfaces, however, provide far more functionality
to Java and to class and object design than do simple abstract
classes and methods. The rest of this lesson explores interfaces:
what they are, why they're crucial to getting the most out of
the Java language for your own classes, and how to use and implement
them.
<H3><A NAME="TheProblemofSingleInheritance">
The Problem of Single Inheritance</A></H3>
<P>
When you first begin to design object-oriented programs, the concept
of the class hierarchy can seem almost miraculous. Within that
single tree you can express a hierarchy of different types of
objects, many simple to moderately complex relationships between
objects and processes in the world, and any number of points along
the axis from abstract/general to concrete/specific. The strict
hierarchy of classes appears, at first glance, to be simple, elegant,
and easy to use.
<P>
After some deeper thought or more complex design experience, however,
you may discover that the pure simplicity of the class hierarchy
is restrictive, particularly when you have some behavior that
needs to be used by classes in different branches of the same
tree.
<P>
Let's look at a few examples that will make the problems clearer.
Way back on <A HREF="ch2.htm">Day 2</A>, &quot;Object-Oriented Programming and Java,&quot;
when you first learned about class hierarchies, we discussed the
<TT>Vehicle</TT> hierarchy, as shown
in Figure 16.1.
<P>
<A HREF="f16-1.gif"><B>Figure 16.1 : </B><I>The Vechicle hierarchy</I>.</A>
<P>
Now let's add to that hierarchy and create the classes <TT>BritishCar</TT>
and <TT>BritishMotorcycle</TT> underneath
<TT>Car</TT> and <TT>Motorcycle</TT>,
respectively. The behavior that makes a car or motorcycle British
(which might include methods for <TT>leakOil()</TT>
or <TT>electricalSystemFailure()</TT>)
is common to both these classes, but because they are in very
different parts of the class hierarchy, you can't create a common
superclass for both of them. And you can't put the British behavior
further up in the hierarchy because that behavior isn't common
to all motorcycles and cars. Other than physically copying the
behavior between the two classes (which breaks the object-oriented
programming [OOP] rules of code reuse and shared behavior), how
can you create a hierarchy like this?
<P>
Let's look at an even thornier example. Say you have a biological
hierarchy with <TT>Animal</TT> at
the top, and the classes <TT>Mammal</TT>
and <TT>Bird</TT> underneath. Things
that define a mammal include bearing live young and having fur.
Behavior or features of birds include having a beak and laying
eggs. So far, so good, right? So how do you go about creating
a class for the platypus, which has fur, has a beak, and lays
eggs? You'd need to combine behavior from two classes to form
the <TT>Platypus</TT> class. And,
because classes can have only one immediate superclass in Java,
this sort of problem simply cannot be solved elegantly.
<P>
Other OOP languages include the concept of <I>multiple inheritance</I>,
which solves this problem. With multiple inheritance, a class
can inherit from more than one superclass and get behavior and
attributes from all its superclasses at once. Using multiple inheritance,
you could simply factor the common behavior of <TT>BritishCar</TT>
and <TT>BritishMotorcycle</TT> into
a single class (<TT>BritishThing</TT>)
and then create new classes that inherit from both their primary
superclass <I>and</I> the <TT>British</TT>
class.
<P>
The problem with multiple inheritance is that it makes a programming
language far more complex to learn, to use, and to implement.
Questions of method invocation and how the class hierarchy is
organized become far more complicated with multiple inheritance,
and more open to confusion and ambiguity. And because one of the
goals for Java was that it be simple, multiple inheritance was
rejected in favor of the simpler single inheritance.
<P>
So how do you solve the problem of needing common behavior that
doesn't fit into the strict class hierarchy? Java, borrowing from
Objective-C, has another hierarchy altogether separate from the
main class hierarchy, a hierarchy of mixable behavior classes.
Then, when you create a new class, that class has only one primary
superclass, but it can pick and choose different common behaviors
from the other hierarchy.
<P>
This other hierarchy is the <I>interface hierarchy</I>. A Java
<I>interface</I> is a collection of abstract behavior that can
be mixed into any class to add to that class behavior that is
not supplied by its superclasses. Specifically, a Java interface
contains nothing but abstract method definitions and constants-no
instance variables and no method implementations.
<P>
Interfaces are implemented and used throughout the Java class
library whenever a behavior is expected to be implemented by a
number of disparate classes. The Java class hierarchy, for example,
defines and uses the interfaces <TT>java.lang.Runnable</TT>,
<TT>java.util.Enumeration</TT>, <TT>java.util.Observable</TT>,
<TT>java.awt.image.ImageConsumer</TT>,
and <TT>java.awt.image.ImageProducer</TT>.
Some of these interfaces you've seen before; others you'll see
later in this book. Still others may be useful to you in your
own programs, so be sure to examine the API to see what's available
to you.
<H3><A NAME="AbstractDesignandConcreteImplementation">
Abstract Design and Concrete Implementation</A></H3>
<P>
Throughout this book you've gotten a taste of the difference between
design and implementation in object-oriented programming, where
the design of a thing is its abstract representation and its implementation
is the concrete counterpart of the design. You saw this with methods,
where a method's signature defines how it's used, but the method
implementation can occur anywhere in the class hierarchy. You
saw this with abstract classes, where the class's design provides
a template for behavior, but that behavior isn't implemented until
further down in the hierarchy.
<P>
This distinction between the design and the implementation of
a class or a method is a crucial part of object-oriented programming
theory. Thinking in terms of design when you organize your classes
allows you to get the big picture without being bogged down in
implementation details. And having the overall design already
defined when you actually start implementing allows you to concentrate
on those details solely for the class you're working on. This
programming version of &quot;think globally, act locally&quot;
provides a powerful way of thinking about how your classes and
your programs and your overall designs are organized and how they
interrelate.
<P>
An interface is made up of a set of method signatures with no
implementations, making it the embodiment of pure design. By mixing
an interface in with your class, you're encompassing that design
into your implementation. That design can then be safely included
anywhere in the class hierarchy because there are no class-specific
details of how an interface behaves-nothing to override, nothing
to keep track of, just the name and arguments for a method.
<P>
What about abstract classes? Don't abstract classes provide this
same behavior? Yes and no. Abstract classes and the abstract methods
inside them do provide a separation of design and implementation,
allowing you to factor common behavior into an abstract superclass.
But abstract classes can, and often do, contain some concrete
data (such as instance variables), and you can have an abstract
superclass with both abstract and regular methods, thereby confusing
the distinction.
<P>
Even a pure abstract class with only abstract methods isn't as
powerful as an interface. An abstract class is simply another
class; it inherits from some other class and has its place in
the hierarchy. Abstract classes cannot be shared across different
parts of the class hierarchy the way interfaces can, nor can they
be mixed into other classes that need their behavior. To attain
the sort of flexibility of shared behavior across the class hierarchy,
you need an interface.
<P>
You can think of the difference between the design and the implementation
of any Java class as the difference between the interface hierarchy
and the design hierarchy. The singly inherited class hierarchy
contains the implementations where the relationships between classes
and behavior are rigidly defined. The multiply inherited mixable
interface hierarchy, however, contains the design and can be freely
used anywhere it's needed in the implementation. This is a powerful
way of thinking about the organization of your program, and although
it takes a little getting used to, it's also a highly recommended
one.
<H3><A NAME="InterfacesandClasses">
Interfaces and Classes</A></H3>
<P>
Classes and interfaces, despite their different definitions, have
an awful lot in common. Interfaces, like classes, are declared
in source files, one interface to a file. Like classes, they also
are compiled using the Java compiler into <TT>.class</TT>
files. And, in most cases, anywhere you can use a class (as a
data type for a variable, as the result of a cast, and so on),
you can also use an interface.
<P>
Almost everywhere that this book has a class name in any of its
examples or discussions, you can substitute an interface name.
Java programmers often say &quot;class&quot; when they actually
mean &quot;class or interface.&quot; Interfaces complement and
extend the power of classes, and the two can be treated almost
exactly the same. One of the few differences between them is that
an interface cannot be instantiated: <TT>new</TT>
can only create an instance of a class.
<H2><A NAME="ImplementingandUsingInterfaces"><FONT SIZE=5 COLOR=#FF0000>
Implementing and Using Interfaces</FONT></A></H2>
<P>
Now that you've grasped what interfaces are and why they're powerful
(the &quot;programming in the large&quot; part), let's move on
to actual bits of code (&quot;programming in the small&quot;).
There are two things you can do with interfaces: use them in your
own classes and define your own. Let's start with the former.
<H3><A NAME="TheTTFONTSIZEFACECourierimplementsFONTTTFONTSIZEKeywordFONT">
The <TT>implements</TT>
Keyword</FONT></A></H3>
<P>
To use an interface, you include the <TT>implements</TT>
keyword as part of your class definition. You did this back on
<A HREF="ch11.htm">Day 11</A>, &quot;More Animation, Images, and Sound,&quot; when you
learned about threads and included the <TT>Runnable</TT>
interface in your applet definition:
<BLOCKQUOTE>
<PRE>
// java.applet.Applet is the superclass 
public class Neko extends java.applet.Applet
    implements Runnable {  // but it also has Runnable behavior
...
}
</PRE>
</BLOCKQUOTE>
<P>
Because interfaces provide nothing but abstract method definitions,
you then have to implement those methods in your own classes,
using the same method signatures from the interface. Note that
once you include an interface, you have to implement <I>all</I>
the methods in that interface-you can't pick and choose the methods
you need. By implementing an interface you're telling users of
your class that you support <I>all</I> of that interface. (Note
that this is another difference between interfaces and abstract
classes-subclasses of the latter can pick which methods to implement
or override and can ignore others.)
<P>
After your class implements an interface, subclasses of your class
will inherit those new methods (and can override or overload them)
just as if your superclass had actually defined them. If your
class inherits from a superclass that implements a given interface,
you don't have to include the <TT>implements</TT>
keyword in your own class definition.
<P>
Let's examine one simple example-creating the new class <TT>Orange</TT>.
Suppose you already have a good implementation of the class <TT>Fruit</TT>
and an interface, <TT>Fruitlike</TT>,
that represents what <TT>Fruit</TT>s
are expected to be able to do. You want an orange to be a fruit,
but you also want it to be a spherical object that can be tossed,
rotated, and so on. Here's how to express it all (don't worry
about the definitions of these interfaces for now; you'll learn
more about them later today):
<BLOCKQUOTE>
<PRE>
interface  Fruitlike {
    void  decay();
    void  squish();
    . . .
}

class  Fruit implements Fruitlike {
    private Color  myColor;
    private int    daysTilIRot;
    . . .
}

interface  Spherelike {
    void  toss();
    void  rotate();
    . . .
}

class  Orange extends Fruit implements Spherelike {
    . . .  // toss()ing may squish() me (unique to me)
}
</PRE>
</BLOCKQUOTE>
<P>
Note that the class <TT>Orange</TT>
doesn't have to say <TT>implements Fruitlike</TT>
because, by extending <TT>Fruit</TT>,
it already has! One of the nice things about this structure is
that you can change your mind about what class <TT>Orange</TT>
extends (if a really great <TT>Sphere</TT>
class is suddenly implemented, for example), yet class <TT>Orange</TT>
will still understand the same two interfaces:
<BLOCKQUOTE>
<PRE>
class  Sphere implements Spherelike {   // extends Object
    private float  radius;
    . . .
}

class  Orange extends Sphere implements Fruitlike {
    . . .     // users of Orange never need know about the change!
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ImplementingMultipleInterfaces">
Implementing Multiple Interfaces</A></H3>
<P>
Unlike the singly inherited class hierarchy, you can include as
many interfaces as you need in your own classes, and your class
will implement the combined behavior of all the included interfaces.
To include multiple interfaces in a class, just separate their
names with commas:
<BLOCKQUOTE>
<PRE>
public class Neko extends java.applet.Applet 
    implements Runnable, Eatable, Sortable, Observable {
...
}
</PRE>
</BLOCKQUOTE>
<P>
Note that complications may arise from implementing multiple interfaces-what
happens if two different interfaces both define the same method?
There are three ways to solve this:
<UL>
<LI>If the methods in each of the interfaces have identical signatures,
you implement one method in your class and that definition satisfies
both interfaces.
<LI>If the methods have different parameter lists, it is a simple
case of method overloading; you implement both method signatures,
and each definition satisfies its respective interface definition.
<LI>If the methods have the same parameter lists but differ in
return type, you cannot create a method that satisfies both (remember,
method overloading is triggered by parameter lists, not by return
type). In this case, trying to compile a class that implements
both interfaces will produce a compiler error. Running across
this problem suggests that your interfaces have some design flaws
that might need re-examining.
</UL>
<H3><A NAME="OtherUsesofInterfaces">
Other Uses of Interfaces</A></H3>
<P>
Remember that almost everywhere that you can use a class, you
can use an interface instead. So, for example, you can declare
a variable to be of an interface type:
<BLOCKQUOTE>
<PRE>
Runnable aRunnableObject = new MyAnimationClass()
</PRE>
</BLOCKQUOTE>
<P>
When a variable is declared to be of an interface type, it simply
means that any object the variable refers to is expected to have
implemented that interface-that is, it is expected to understand
all the methods that interface specifies. It assumes that a promise
made between the designer of the interface and its eventual implementors
has been kept. In this case, because <TT>aRunnableObject</TT>
contains an object of the type <TT>Runnable</TT>,
the assumption is that you can call <TT>aRunnableObject.run()</TT>.
<P>
The important thing to realize here is that although <TT>aRunnableObject</TT>
is expected to be able to have the <TT>run()</TT>
method, you could write this code long before any classes that
qualify are actually implemented (or even created!). In traditional
object-oriented programming, you are forced to create a class
with &quot;stub&quot; implementations (empty methods, or methods
that print silly messages) to get the same effect.
<P>
You can also cast objects to an interface, just as you can cast
objects to other classes. So, for example, let's go back to that
definition of the <TT>Orange</TT>
class, which implemented both the <TT>Fruitlike</TT>
interface (through its superclass, <TT>Fruit</TT>)
and the <TT>Spherelike</TT> interface.
Here we'll cast instances of <TT>Orange</TT>
to both classes and interfaces:
<BLOCKQUOTE>
<PRE>
Orange      anOrange    = new Orange();
Fruit       aFruit      = (Fruit)anOrange;
Fruitlike   aFruitlike  = (Fruitlike)anOrange;
Spherelike  aSpherelike = (Spherelike)anOrange;


aFruit.decay();          // fruits decay
aFruitlike.squish();     //  and squish

aFruitlike.toss();       // things that are fruitlike do not toss
aSpherelike.toss();      // but things that are spherelike do

anOrange.decay();        // oranges can do it all
anOrange.squish();
anOrange.toss();
anOrange.rotate();
</PRE>
</BLOCKQUOTE>
<P>
Declarations and casts are used in this example to restrict an
orange's behavior to acting more like a mere fruit or sphere.
<P>
Finally, note that although interfaces are usually used to mix
in behavior to other classes (method signatures), interfaces can
also be used to mix in generally useful constants. So, for example,
if an interface defined a set of constants, and then multiple
classes used those constants, the values of those constants could
be globally changed without having to modify multiple classes.
This is yet another example of where the use of interfaces to
separate design from implementation can make your code more general
and more easily maintainable.
<H2><A NAME="CreatingandExtendingInterfaces"><FONT SIZE=5 COLOR=#FF0000>
Creating and Extending Interfaces</FONT></A></H2>
<P>
After using interfaces for a while, the next step is to define
your own interfaces. Interfaces look a lot like classes; they
are declared in much the same way and can be arranged into a hierarchy,
but there are rules for declaring interfaces that must be followed.
<H3><A NAME="NewInterfaces">
New Interfaces</A></H3>
<P>
To create a new interface, you declare it like this:
<BLOCKQUOTE>
<PRE>
public interface Growable {
...
}
</PRE>
</BLOCKQUOTE>
<P>
This is, effectively, the same as a class definition, with the
word <TT>interface</TT> replacing
the word <TT>class</TT>. Inside the
interface definition you have methods and constants. The method
definitions inside the interface are <TT>public</TT>
and <TT>abstract</TT> methods; you
can either declare them explicitly as such, or they will be turned
into <TT>public</TT> and <TT>abstract</TT>
methods if you do not include those modifiers. You cannot declare
a method inside an interface to be either <TT>private</TT>
or <TT>protected</TT>. So, for example,
here's a <TT>Growable</TT> interface
with one method explicitly declared <TT>public</TT>
and <TT>abstract</TT> (<TT>growIt()</TT>)
and one implicitly declared as such (<TT>growItBigger()</TT>).
<BLOCKQUOTE>
<PRE>
public interface Growable {
    public abstract void growIt(); //explicity public and abstract
    void growItBigger();          // effectively public and abstract
}
</PRE>
</BLOCKQUOTE>
<P>
Note that, as with abstract methods in classes, methods inside
interfaces do not have bodies. Remember, an interface is pure
design; there is no implementation involved.
<P>
In addition to methods, interfaces can also have variables, but
those variables must be declared <TT>public</TT>,
<TT>static</TT>, and <TT>final</TT>
(making them constant). As with methods, you can explicitly define
a variable to be <TT>public</TT>,
<TT>static</TT>, and <TT>final</TT>,
or it will be implicitly defined as such if you don't use those
modifiers. Here's that same <TT>Growable</TT>
definition with two new variables:
<BLOCKQUOTE>
<PRE>
public interface Growable {
    public static final int increment = 10;
    long maxnum = 1000000;  // becomes public static and final

    public abstract void growIt(); //explicitly public and abstract
    void growItBigger();          // effectively public and abstract
}
</PRE>
</BLOCKQUOTE>
<P>
Interfaces must have either public or package protection, just
like classes. Note, however, that interfaces without the <TT>public</TT>
modifier do not automatically convert their methods to <TT>public</TT>
and <TT>abstract</TT> nor their constants
to <TT>public</TT>. A non-<TT>public</TT>
interface also has non-<TT>public</TT>
methods and constants that can be used only by classes and other
interfaces in the same package.
<P>
Interfaces, like classes, can belong to a package by adding a
<TT>package</TT> statement to the
first line of the class file. Interfaces can also import other
interfaces and classes from other packages, just as classes can.
<H3><A NAME="MethodsInsideInterfaces">
Methods Inside Interfaces</A></H3>
<P>
One trick to note about methods inside interfaces: Those methods
are supposed to be abstract and apply to any kind of class, but
how can you define parameters to those methods? You don't know
what class will be using them!
<P>
The answer lies in the fact that you use an interface name anywhere
a class name can be used, as you learned earlier. By defining
your method parameters to be interface types, you can create generic
parameters that apply to any class that might use this interface.
<P>
So, for example, take the interface <TT>Fruitlike</TT>,
which defines methods (with no arguments) for <TT>decay()</TT>
and <TT>squish()</TT>. There might
also be a method for <TT>germinateSeeds()</TT>,
which has one argument: the fruit itself. Of what type is that
argument going to be? It can't be simply <TT>Fruit</TT>,
because there may be a class that's <TT>Fruitlike</TT>
(that is, implements the <TT>Fruitlike</TT>
interface) without actually being a fruit. The solution is to
declare the argument as simply <TT>Fruitlike</TT>
in the interface:
<BLOCKQUOTE>
<PRE>
public interface Fruitlike {
    public abstract germinate(Fruitlike self) {
       ...
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Then, in an actual implementation for this method in a class,
you can take the generic <TT>Fruitlike</TT>
argument and cast it to the appropriate object:
<BLOCKQUOTE>
<PRE>
public class Orange extends Fruit {

    public germinate(Fruitlike self) {
       Orange theOrange = (Orange)self;
       ...
    }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ExtendingInterfaces">
Extending Interfaces</A></H3>
<P>
As with classes, interfaces can be organized into a hierarchy.
When one interface inherits from another interface, that &quot;subinterface&quot;
acquires all the method definitions and constants that its &quot;superinterface&quot;
defined. To extend an interface, you use the <TT>extends</TT>
keyword just as you do in a class definition:
<BLOCKQUOTE>
<PRE>
public interface Fruitlike extends Foodlike { 
...
}
</PRE>
</BLOCKQUOTE>
<P>
Note that, unlike classes, the interface hierarchy has no equivalent
of the <TT>Object</TT> class; this
hierarchy is not rooted at any one point. Interfaces can either
exist entirely on their own or inherit from another interface.
<P>
Note also that, unlike the class hierarchy, the inheritance hierarchy
is multiply inherited. So, for example, a single interface can
extend as many classes as it needs to (separated by commas in
the <TT>extends</TT> part of the definition),
and the new interface will contain a combination of all its parent's
methods and constants. Here's an interface definition for an interface
called <TT>BusyInterface</TT> that
inherits from a whole lot of other interfaces:
<BLOCKQUOTE>
<PRE>
public interface BusyInterface extends Runnable, Growable, Fruitlike, Observable {
...}
</PRE>
</BLOCKQUOTE>
<P>
In multiply inherited interfaces, the rules for managing method
name conflicts are the same as for classes that use multiple interfaces;
methods that differ only in return type will result in a compiler
error.
<H3><A NAME="AnExampleEnumeratingLinkedLists">
An Example: Enumerating Linked Lists</A></H3>
<P>
To finish up today's lesson, here's an example that uses packages,
package protection, and defines a class that implements the Enumeration
interface (part of the <TT>java.util</TT>
package). Listing 16.2 shows the code.
<HR>
<BLOCKQUOTE>
<B>Listing 16.2. Packages, classes, and interfaces.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: package  collections;
 2:
 3: public class  LinkedList {
 4:       private Node  root;
 5:
 6:       . . .
 7:       public Enumeration  enumerate() {
 8:           return new LinkedListEnumerator(root);
 9:     }
10: }
11: 
12: class  Node {
13:     private Object  contents;
14:     private Node    next;
15:
16:     . . .
17:     public  Object  contents() {
18:         return contents;
19:     }
20:
21:     public  Node    next() {
22:         return next;
23:     }
24: }
25: 
26: class  LinkedListEnumerator implements Enumeration {
27:     private Node  currentNode;
28: 
29:      LinkedListEnumerator(Node  root) {
30:         currentNode = root;
31:     }
32:  
33:     public boolean  hasMoreElements() {
34:         return currentNode != null;
35:     }
36:  
37:     public Object   nextElement() {
38:        Object  anObject = currentNode.contents();
39:  
40:         currentNode = currentNode.next();
41:        return  anObject;
42:    }
43: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Here is a typical use of the enumerator:
<BLOCKQUOTE>
<PRE>
collections.LinkedList aLinkedList = createLinkedList();
java.util.Enumeration e = aLinkedList.enumerate();

while (e.hasMoreElements()) {
    Object  anObject = e.nextElement();
    // do something useful with anObject
}
</PRE>
</BLOCKQUOTE>
<P>
Notice that, although you are using the <TT>Enumeration</TT>
<TT>e</TT> as though you know what
it is, you actually do not. In fact, it is an instance of a hidden
class (<TT>LinkedListEnumerator</TT>)
that you cannot see or use directly. By using a combination of
packages and interfaces, the <TT>LinkedList</TT>
class has managed to provide a transparent public interface to
some of its most important behavior (via the already defined interface
<TT>java.util.Enumeration</TT>) while
still encapsulating (hiding) its two implementation (support)
classes.
<P>
Handing out an object like this is sometimes called <I>vending</I>.
Often the &quot;vendor&quot; gives out an object that a receiver
can't create itself but that it knows how to use. By giving it
back to the vendor, the receiver can prove it has a certain capability,
authenticate itself, or do any number of useful tasks-all without
knowing much about the vended object. This is a powerful metaphor
that can be applied in a broad range of situations.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you have learned how packages can be used to collect and
categorize classes into meaningful groups. Packages are arranged
in a hierarchy, which not only better organizes your programs
but allows you and the millions of Java programmers out on the
Net to name and share their projects uniquely with one another.
<P>
You have also learned how to use packages, both your own and the
many preexisting ones in the Java class library.
<P>
You then discovered how to declare and use interfaces, a powerful
mechanism for extending the traditional single inheritance of
Java's classes and for separating design inheritance from implementation
inheritance in your programs. Interfaces are often used to call
common (shared) methods when the exact class involved is not known.
You'll see further uses of interfaces tomorrow and the day after.
<P>
Finally, you learned that packages and interfaces can be combined
to provide useful abstractions, such as <TT>LinkedList</TT>,
that appear simple yet are actually hiding almost all their (complex)
implementation from their users. This is a powerful technique.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Can you use <TT><B>import some.package.B*</B></TT> to import all the classes in that package that begin with B?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>No, the import asterisk (<TT>*</TT>) does not act like a command-line asterisk.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Then what exactly does <TT><B>import</B></TT>ing with an <TT><B>*</B></TT> mean?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Combining everything said previously, this precise definition emerges: It imports all the public classes you use in your Java code that are directly</FONT> inside the package named, and not 
inside one of its subpackages. (You can only import exactly this set of classes, or exactly one explicitly named class, from a given package.) By the way, Java only &quot;loads&quot; the information for a class when you actually refer to that class in your 
code, so the <TT>*</TT> form of <TT>import</TT> is no less efficient than naming each class individually.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Why is full multiple inheritance so complex that Java abandoned it?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>It's not so much that it is too complex, but that it makes the language overly complicated-and as you'll learn on <A HREF="ch21.htm">Day 21</A>, &quot;Under the Hood,&quot; this can cause 
larger systems to be less trustworthy and thus less secure. For example, if you were to inherit from two different parents, each having an instance variable with the same name, you would be forced to allow the conflict and explain how the exact same 
reference to that variable name in each of your superclasses, and in you (all three), are now different. Instead of being able to call &quot;super&quot; methods to get more abstract behavior accomplished, you would always need to worry about which of the 
(possibly many) identical methods you actually wished to call in which parent. Java's run-time method dispatching would have to be more complex as well. Finally, because so many people would be providing classes for reuse on the Net, the normally 
manageable conflicts that would arise in your own program would be confounded by millions of users mixing and matching these fully multiply inherited classes at will. In the future, if all these issues are resolved, more powerful inheritance may be added 
to Java, but its current capabilities are already sufficient for 99 percent of your programs.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><TT><B>abstract</B></TT><B> classes don't have to implement all the methods in an interface themselves, but don't all their subclasses have to?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Actually, no. Because of inheritance, the precise rule is that an implementation must be provided by some class for each method, but it doesn't have to be your class. This is analogous to when 
you are the subclass of a class that implements an interface for you. Whatever the <TT>abstract</TT> class doesn't implement, the first non-<TT>abstract</TT> class below it must implement. Then, any further subclasses need do nothing further.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>You didn't mention callbacks. Aren't they an important use of interfaces?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Yes, but I didn't mention them because a good example would be too bulky. Callbacks are often used in user interfaces (such as window systems) to specify what set of methods is going to be sent 
whenever the user does a certain set of things (such as clicking the mouse somewhere, typing, and so forth). Because the user interface classes should not &quot;know&quot; anything about the classes using them, an interface's ability to specify a set of 
methods separate from the class tree is crucial in this case. Callbacks using interfaces are not as general as using, for example, the <TT>perform:</TT> method of Smalltalk, however, because a given object can only request that a user interface object 
&quot;call it back&quot; using a single method name. Suppose that object wanted two user interface objects of the same class to call it back, using different names to tell them apart? It cannot do this in Java, and it is forced to use special state and 
tests to tell them apart. (I warned you that it was complicated!) So although interfaces are quite valuable in this case, they are not the ideal callback facility. 
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch15.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch17.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
