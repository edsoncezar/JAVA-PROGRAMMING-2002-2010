<HTML>
<HEAD>
<TITLE>appendix L -- java.util Package Reference</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>appendix&nbsp;L</FONT></H1>
<H1><FONT COLOR=#FF0000><TT>java.util</TT></FONT><FONT SIZE=6 COLOR=#FF0000>
Package Reference</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TTFONTSIZEFACECourierEnumerationFONTTT">
<TT>Enumeration</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierObserverFONTTT">
<TT>Observer</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierBitSetFONTTT">
<TT>BitSet</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierDateFONTTT">
<TT>Date</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierDictionaryFONTTTFONTSIZEFONT">
<TT>Dictionary</TT>
</FONT></A>
<LI><A HREF="#TTFONTSIZEFACECourierHashtableFONTTT">
<TT>Hashtable</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierObservableFONTTT">
<TT>Observable</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierPropertiesFONTTT">
<TT>Properties</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierRandomFONTTT">
<TT>Random</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierStackFONTTT">
<TT>Stack</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierStringTokenizerFONTTT">
<TT>StringTokenizer</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierVectorFONTTT">
<TT>Vector</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierEmptyStackExceptionFONTTT">
<TT>EmptyStackException</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierNoSuchElementExceptionFONTTT">
<TT>NoSuchElementException</TT>
</A>
</UL>

<HR>
<P>
The <TT>java.util</TT> package contains
a variety of classes representing data structures and other miscellaneous
features such as support for date and time.
<H2><A NAME="TTFONTSIZEFACECourierEnumerationFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Enumeration</TT></FONT></A></H2>
<P>
The <TT>Enumeration</TT> interface
defines methods that can be used to iterate through a set of objects.
<H4><TT>hasMoreElements</TT></H4>
<BLOCKQUOTE>
<TT>public abstract boolean hasMoreElements()
<BR>
</TT>Can be used to determine if the enumeration has more
elements.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if there are more elements, <TT>false</TT>
if not.
</BLOCKQUOTE>
<H4><TT>nextElement</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Object nextElement()
<BR>
</TT>This method returns the next element in the enumeration.
Calling it repeatedly will move through the enumeration.<BR>
<I><B>Returns: </B></I>The next element in the enumeration.<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if there are no more elements in the enumeration.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierObserverFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Observer</TT></FONT></A></H2>
<P>
The <TT>Observer</TT> interface defines
an <TT>update</TT> method that is
invoked by an <TT>Observable</TT>
object whenever the <TT>Observable</TT>
object has changed and wants to notify its observers.
<H4><TT>update</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void update(Observable
o, Object arg)<BR>
</TT>This method is called whenever an <TT>Observable</TT>
instance that is being observed invokes either of its <TT>notifyObservers</TT>
methods.<BR>
<I><B>Parameters: <BR>
</B></I><TT>o</TT>-the <TT>Observable</TT>
object that is generating this message.<BR>
<TT>arg</TT>-any additional information
passed by the <TT>Observable</TT>
object's <TT>notifyObservers</TT>
method.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierBitSetFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>BitSet</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT><I><B>Implements: </B></I>Cloneable<BR>
This class represents a dynamically sized set of bits. Two constructors
are provided, one that creates an empty set of unspecified size
and one that creates a set of a specified size. The set method
can be used to set an individual bit, or clear can be used to
clear an individual bit.
</BLOCKQUOTE>
<H4><TT>BitSet</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public BitSet()<BR>
</TT>This constructor creates an empty bit set.
</BLOCKQUOTE>
<H4><TT>BitSet</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public BitSet(int nbits)<BR>
</TT>This constructor creates an empty bit set with the
specified number of bits.<BR>
<I><B>Parameters: </B></I><TT>nbits</TT>-the
number of bits in the set.
</BLOCKQUOTE>
<H4><TT>and</TT></H4>
<BLOCKQUOTE>
<TT>public void and(BitSet set)<BR>
</TT>This method logically <TT>AND</TT>s
the bit set with another bit set.<BR>
<I><B>Parameters: </B></I><TT>set</TT>-the
bit set to <TT>AND</TT> with the current
set.
</BLOCKQUOTE>
<H4><TT>clear</TT></H4>
<BLOCKQUOTE>
<TT>public void clear(int bit)<BR>
</TT>Clears the specified bit.<BR>
<I><B>Parameters: </B></I><TT>bit</TT>-the
bit to clear.
</BLOCKQUOTE>
<H4><TT>clone</TT></H4>
<BLOCKQUOTE>
<TT>public Object clone()<BR>
</TT>This method overrides the <TT>clone</TT>
method in <TT>Object</TT>. It can
be used to clone the bit set.
</BLOCKQUOTE>
<H4><TT>equals</TT></H4>
<BLOCKQUOTE>
<TT>public boolean equals(Object obj)<BR>
</TT>This method can be used to compare the contents of
two bit sets. If the same bits are set in the two bit sets, they
are considered equal.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
bit set to compare against.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the set bits are the same, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>get</TT></H4>
<BLOCKQUOTE>
<TT>public boolean get(int bit)<BR>
</TT>Gets the value of a specified bit in the set.<BR>
<I><B>Parameters: </B></I><TT>bit</TT>-the
bit to get.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the bit is set; <TT>false</TT>
if it is clear.
</BLOCKQUOTE>
<H4><TT>hashCode</TT></H4>
<BLOCKQUOTE>
<TT>public int hashCode()<BR>
</TT>This method overrides the <TT>hashCode</TT>
method in <TT>Object</TT> and can
be used to get a hash code for the instance.<BR>
<I><B>Returns: </B></I>A hash code for the instance.
</BLOCKQUOTE>
<H4><TT>or</TT></H4>
<BLOCKQUOTE>
<TT>public void or(BitSet set)<BR>
</TT>This method logically <TT>OR</TT>s
the bit set with another.<BR>
<I><B>Parameters: </B></I><TT>set</TT>-the
bit set to <TT>OR</TT> with the current
set.
</BLOCKQUOTE>
<H4><TT>set</TT></H4>
<BLOCKQUOTE>
<TT>public void set(int bit)<BR>
</TT>Sets the specified bit.<BR>
<I><B>Parameters: </B></I><TT>bit</TT>-the
bit to set.
</BLOCKQUOTE>
<H4><TT>size</TT></H4>
<BLOCKQUOTE>
<TT>public int size()<BR>
</TT>This method returns the amount of space, in bits,
used to store the set. Space for a bit set is allocated in 64-bit
increments.<BR>
<I><B>Returns: </B></I>The amount of space, in bits, used to store
the bit set. 
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public String toString()<BR>
</TT>This method formats the bit set as a string. The string
will consist of an opening curly brace, comma-separated values
representing each set bit, and a closing curly brace.<BR>
<I><B>Returns: </B></I>A string representing the bits in the bit
set that are set. 
</BLOCKQUOTE>
<H4><TT>xor</TT></H4>
<BLOCKQUOTE>
<TT>public void xor(BitSet set)<BR>
</TT>This method logically <TT>XOR</TT>s
the bit set with another bit set.<BR>
<I><B>Parameters: </B></I><TT>set</TT>-the
bit set to <TT>XOR</TT> with the current
set.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierDateFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Date</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>The Date class stores a representation of a date and
time and provides methods for manipulating the date and time components.
Constructors are provided that will create a new Date instance
based on the current date and time, the UNIX-standard milliseconds
since midnight on January 1, 1970, a string, or from integers
representing the year, month, day, hours, minutes, and seconds.
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date()<BR>
</TT>This method creates a new <TT>Date</TT>
object using today's date.
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date(long date)<BR>
</TT>This method creates a date from a <TT>long</TT>
that represents the number of milliseconds since January 1, 1970.
<BR>
<I><B>Parameters: </B></I><TT>date</TT>-the
number of milliseconds since January 1, 1970.
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date(int year, int month, int
date)<BR>
</TT>This method creates a new <TT>Date</TT>
object that corresponds to the year, month, and day passed to
it. The first month of the year is month zero. The day of the
month is normalized so that impossible dates become real dates.
<BR>
<I><B>Parameters:</B></I> <BR>
<TT>year</TT>-the number of years
since 1900.<BR>
<TT>month</TT>-the zero-based month,
from 0 to 11.<BR>
<TT>date</TT>-the day of the month.
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date(int year, int month, int
date, int hrs, int min)<BR>
</TT>This method creates a new <TT>Date</TT>
object that corresponds to the year, month, day, hours, and minutes
passed to it. As with the prior constructor, the day of the month
is normalized so that impossible dates become real dates.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>year</TT>-the number of years
since 1900.<BR>
<TT>month</TT>-the zero-based month,
from 0 to 11.<BR>
<TT>date</TT>-the day of the month.
<BR>
<TT>hrs</TT>-the zero-based number
of hours (0-23).<BR>
<TT>min</TT>-the zero-based number
of minutes (0-59).
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date(int year, int month, int
date, int hrs, int min, <BR>
int sec)<BR>
</TT>This method creates a new <TT>Date</TT>
object that corresponds to the year, month, day, hour, minute,
and seconds passed to it. As with the other constructors, the
day of the month is normalized so that impossible dates become
real dates.<BR>
<I><B>Parameters: <BR>
</B></I><TT>year</TT>-the number of
years since 1900.<BR>
<TT>month</TT>-the zero-based month,
from 0 to 11.<BR>
<TT>date</TT>-the day of the month.
<BR>
<TT>hrs</TT>-the zero-based number
of hours (0-23).<BR>
<TT>min</TT>-the zero-based number
of minutes (0-59).<BR>
<TT>sec</TT>-the zero-based number
of seconds (0-59).
</BLOCKQUOTE>
<H4><TT>Date</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Date(String s)<BR>
</TT>This method creates a new date based on the date string
passed to it.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-a
time string in the format passed to <TT>java.util.Date.Parse</TT>,
as described later in this appendix.
</BLOCKQUOTE>
<H4><TT>UTC</TT></H4>
<BLOCKQUOTE>
<TT>public static long UTC(int year, int
month, int date, int <BR>
hrs, int min, int sec)<BR>
</TT>This method calculates the time in UTC (Coordinated
Universal Time) format based on the specified parameters. Parameters
are expected to be given in UTC values, not the time in the local
time zone.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>year</TT>-the number of years
since 1900.<BR>
<TT>month</TT>-the zero-based month,
from 0 to 11.<BR>
<TT>date</TT>-the day of the month.
<BR>
<TT>hrs</TT>-the zero-based number
of hours (0-23).<BR>
<TT>min</TT>-the zero-based number
of minutes (0-59).<BR>
<TT>sec</TT>-the zero-based number
of seconds (0-59).<BR>
<I><B>Returns: </B></I>A UTC time value.
</BLOCKQUOTE>
<H4><TT>parse</TT></H4>
<BLOCKQUOTE>
<TT>public static long parse(String s)<BR>
</TT>This method calculates the time in UTC format based
on the string passed to it.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-a
formatted time string such as <TT>Mon, 8
Apr 1996 21:32:PM PST</TT>.<BR>
<I><B>Returns: </B></I>A UTC time value.
</BLOCKQUOTE>
<H4><TT>after</TT></H4>
<BLOCKQUOTE>
<TT>public boolean after(Date when)<BR>
</TT>Determines whether the <TT>Date</TT>
occurs after the specified date.<BR>
<I><B>Parameters: </B></I><TT>when</TT>-the
date to compare against.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the object's date occurs after the specified date; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>before</TT></H4>
<BLOCKQUOTE>
<TT>public boolean before(Date when)<BR>
</TT>This method determines whether the <TT>Date</TT>
occurs before the specified date.<BR>
<I><B>Parameters: </B></I><TT>when</TT>-the
date to compare against.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the object's date occurs before the specified date; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>equals</TT></H4>
<BLOCKQUOTE>
<TT>public boolean equals(Object obj)<BR>
</TT>This method determines whether two <TT>Date</TT>
objects are the same by comparing the dates represented by each
object.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to compare against.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the dates are the same; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>getDate</TT></H4>
<BLOCKQUOTE>
<TT>public int getDate()<BR>
</TT>This method returns the day (or date) portion of a
<TT>Date</TT> object.<BR>
<I><B>Returns: </B></I>The day of the month, from 1 to 31.
</BLOCKQUOTE>
<H4><TT>getDay</TT></H4>
<BLOCKQUOTE>
<TT>public int getDay()<BR>
</TT>This method returns the day of the week. Sunday is
assigned a value of 0.<BR>
<I><B>Returns: </B></I>The day of the week from 0 (Sunday) to
6 (Saturday).
</BLOCKQUOTE>
<H4><TT>getHours</TT></H4>
<BLOCKQUOTE>
<TT>public int getHours()<BR>
</TT>This method returns the hour.<BR>
<I><B>Returns: </B></I>The hour from 0 to 23.
</BLOCKQUOTE>
<H4><TT>getMinutes</TT></H4>
<BLOCKQUOTE>
<TT>public int getMinutes()<BR>
</TT>This method returns the minutes.<BR>
<I><B>Returns: </B></I>The minutes from 0 to 59.
</BLOCKQUOTE>
<H4><TT>getMonth</TT></H4>
<BLOCKQUOTE>
<TT>public int getMonth()<BR>
</TT>This method returns the month.<BR>
<I><B>Returns: </B></I>The month from 0 (January) to 11 (December).
</BLOCKQUOTE>
<H4><TT>getSeconds</TT></H4>
<BLOCKQUOTE>
<TT>public int getSeconds()<BR>
</TT>This method returns the seconds.<BR>
<I><B>Returns: </B></I>The seconds from 0 to 59.
</BLOCKQUOTE>
<H4><TT>getTime</TT></H4>
<BLOCKQUOTE>
<TT>public long getTime()<BR>
</TT>This method returns the number of milliseconds since
midnight on January 1, 1970.<BR>
<I><B>Returns: </B></I>The time expressed in elapsed milliseconds.
</BLOCKQUOTE>
<H4><TT>getTimezoneOffset</TT></H4>
<BLOCKQUOTE>
<TT>public int get`TimezoneOffset()<BR>
</TT>This method returns the offset in minutes of the current
time zone from the UTC.<BR>
<I><B>Returns: </B></I>The number of minutes difference between
the time zone of the object and UTC.
</BLOCKQUOTE>
<H4><TT>getYear</TT></H4>
<BLOCKQUOTE>
<TT>public int getYear()<BR>
</TT>This method returns the year after 1900.<BR>
<I><B>Returns: </B></I>The year after 1900.
</BLOCKQUOTE>
<H4><TT>hashCode</TT></H4>
<BLOCKQUOTE>
<TT>public int hashCode()<BR>
</TT>This method overrides the <TT>hashCode</TT>
method in <TT>Object</TT> and can
be used to get a hash code for the instance.<BR>
<I><B>Returns: </B></I>A hash code for the instance.
</BLOCKQUOTE>
<H4><TT>setDate</TT></H4>
<BLOCKQUOTE>
<TT>public void setDate(int date)<BR>
</TT>This method sets the day of the month portion of a
<TT>Date</TT> object.<BR>
<I><B>Parameters: </B></I><TT>date</TT>-the
day value.
</BLOCKQUOTE>
<H4><TT>setHours</TT></H4>
<BLOCKQUOTE>
<TT>public void setHours(int hours)<BR>
</TT>This method sets the hours portion of a <TT>Date</TT>
object.<BR>
<I><B>Parameters: </B></I><TT>hours</TT>-the
hour from 0 (midnight) to 23.
</BLOCKQUOTE>
<H4><TT>setMinutes</TT></H4>
<BLOCKQUOTE>
<TT>public void setMinutes(int minutes)<BR>
</TT>This method sets the minutes portion of a <TT>Date</TT>
object.<BR>
<I><B>Parameters: </B></I><TT>minutes</TT>-the
minutes from 0 to 59.
</BLOCKQUOTE>
<H4><TT>setMonth</TT></H4>
<BLOCKQUOTE>
<TT>public void setMonth(int month)<BR>
</TT>This method sets the month portion of a <TT>Date</TT>
object.<BR>
<I><B>Parameters: </B></I><TT>month</TT>-the
zero-based month from 0 (January) to 11 (December).
</BLOCKQUOTE>
<H4><TT>setSeconds</TT></H4>
<BLOCKQUOTE>
<TT>public void setSeconds(int seconds)<BR>
</TT>This method sets the seconds portion of a <TT>Date</TT>
object.<BR>
<I><B>Parameters: </B></I><TT>seconds</TT>-the
seconds from 0 to 59.
</BLOCKQUOTE>
<H4><TT>setTime</TT></H4>
<BLOCKQUOTE>
<TT>public void setTime(long time)<BR>
</TT>This method sets the time to the time represented
by the number of milliseconds in the <TT>time</TT>
parameter. It is frequently used in conjunction with the <TT>getTime</TT>
method that returns a number of milliseconds.<BR>
<I><B>Parameters: </B></I><TT>time</TT>-the
new time in milliseconds since January 1, 1970.
</BLOCKQUOTE>
<H4><TT>setYear</TT></H4>
<BLOCKQUOTE>
<TT>public void setYear(int year)<BR>
</TT>This method sets the year portion of a <TT>Date</TT>
instance.<BR>
<I><B>Parameters: </B></I><TT>year</TT>-the
year after 1900 (for 1996, use 96).
</BLOCKQUOTE>
<H4><TT>toGMTString</TT></H4>
<BLOCKQUOTE>
<TT>public String toGMTString()<BR>
</TT>This method creates a string that contains the date
and time formatted according to GMT (Greenwich Mean Time) conventions.
<BR>
<I><B>Returns: </B></I>A string representing the date in GMT format,
such as <TT>14 Nov 1995 08:00:00 GMT</TT>.
</BLOCKQUOTE>
<H4><TT>toLocaleString</TT></H4>
<BLOCKQUOTE>
<TT>public String toLocaleString()<BR>
</TT>This method creates a string that contains the date
and time in the format of the current locale.<BR>
<I><B>Returns: </B></I>A string representing the date as formatted
for the locale of the instance, such as <BR>
<TT>11/14/95 00:00:00</TT>.
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public String toString()<BR>
</TT>This method creates a string that contains the day
of the week, the date, and the time.<BR>
<I><B>Returns: </B></I>A string representing the day of the week,
date and time of the instance, such as <BR>
<TT>Tue Nov 14 00:00:00 1995</TT>.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierDictionaryFONTTTFONTSIZEFONT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Dictionary</TT>
</FONT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>The Dictionary class is an abstract class. Each element
in a Dictionary consists of a key and value. Elements are added
to a Dictionary using put and are retrieved using get. Elements
may be deleted with remove. The methods elements and keys each
return an enumeration of the values and keys, respectively, stored
in the Dictionary.
</BLOCKQUOTE>
<H4><TT>Dictionary</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Dictionary()<BR>
</TT>This is a default constructor that will create an
empty dictionary.
</BLOCKQUOTE>
<H4><TT>elements</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Enumeration elements()
<BR>
</TT>This abstract method returns an enumeration of all
elements in a dictionary.<BR>
<I><B>Returns: </B></I>An enumeration of each of the elements
in the dictionary. The methods of <TT>Enumeration</TT>
can be used to iterate through the elements.
</BLOCKQUOTE>
<H4><TT>get</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Object get(Object key)
<BR>
</TT>This abstract method retrieves an object from a dictionary
based on its key.<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key of the object to be retrieved.<BR>
<I><B>Returns: </B></I>The value associated with the key, if found;
null if not.
</BLOCKQUOTE>
<H4><TT>isEmpty</TT></H4>
<BLOCKQUOTE>
<TT>public abstract boolean isEmpty()<BR>
</TT>This abstract method can be used to determine if the
dictionary is empty.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the dictionary is empty; <TT>false</TT>
if not.
</BLOCKQUOTE>
<H4><TT>keys</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Enumeration keys()<BR>
</TT>This abstract method returns an enumeration of all
keys in a dictionary.<BR>
<I><B>Returns: </B></I>An enumeration of each of the keys in the
dictionary. The methods of <TT>Enumeration</TT>
can be used to iterate through the keys.
</BLOCKQUOTE>
<H4><TT>put</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Object put(Object key,
Object value)<BR>
</TT>This abstract method inserts a new element into the
dictionary. To retrieve an element, use the <TT>get</TT>
method.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>key</TT>-the key to be added.
<BR>
<TT>value</TT>-the value associated
with the key.<BR>
<I><B>Returns: </B></I>If the key was already in the dictionary,
the old value associated with it is returned. If not, null is
returned.<BR>
<I><B>Throws: </B></I><TT>NullPointerException</TT>
if the value is null.
</BLOCKQUOTE>
<H4><TT>remove</TT></H4>
<BLOCKQUOTE>
<TT>public abstract Object remove(Object
key)<BR>
</TT>This abstract method removes an object from a dictionary.
<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key of the element to be removed.<BR>
<I><B>Returns: </B></I>If the key is found, the value associated
with it is returned; if not, null is returned.
</BLOCKQUOTE>
<H4><TT>size</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int size()<BR>
</TT>This abstract method returns the number of elements
in the dictionary.<BR>
<I><B>Returns: </B></I>The number of items stored in the dictionary.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierHashtableFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Hashtable</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Dictionary<BR>
</TT>The Hashtable class is used for mapping keys to values.
Each element in a hash table consists of a key and a value. Elements
are added to a hash table using the put method and are retrieved
using get. Elements may be deleted from a hash table with remove.
A hash table will expand in size as elements are added to it.
When creating a new hash table, you can specify an initial capacity
and a load factor. The hash table will increase in size whenever
adding a new element would move the hash table past its threshold.
A hash table's <I>threshold</I> is its capacity multiplied by
its load factor. For example, a hash table with a capacity of
100 and a load factor of 0.75 would have a threshold of 75 items.
</BLOCKQUOTE>
<H4><TT>Hashtable</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Hashtable(int initialCapacity,
float loadFactor)<BR>
</TT>This constructor creates a new instance of a hash
table with the specified initial capacity and load factor. Although
an initial capacity is specified, the hash table will grow as
needed when new items are added. The initial capacity specifies
how many elements could be stored in the hash table if the load
factor is 1.0. The load factor is a number between 0.0 and 1.0
and specifies the percentage of the hash table that must be full
before the size is automatically increased.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>initialCapacity</TT>-the initial
capacity of the hash table.<BR>
<TT>loadFactor</TT>-a value between
0.0 and 1.0 that specifies the percent of available hash slots
that can be filled before the table is automatically rehashed
into a large hash table.
</BLOCKQUOTE>
<H4><TT>Hashtable</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Hashtable(int initialCapacity)
<BR>
</TT>This constructor creates a new hash table with the
specified initial capacity and a default load factor of 0.75.
<BR>
<I><B>Parameters: </B></I><TT>initialCapacity</TT>-the
initial capacity of the hash table.
</BLOCKQUOTE>
<H4><TT>Hashtable</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Hashtable()<BR>
</TT>This constructor creates a new hash table using default
values for the initial capacity and the load factor. A default
of 101 is used for the initial capacity, and 0.75 is used for
the load factor.
</BLOCKQUOTE>
<H4><TT>clear</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void clear()<BR>
</TT>This method will remove all elements from a hash table.
</BLOCKQUOTE>
<H4><TT>clone</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Object clone()<BR>
</TT>This method clones the hash table into a new hash
table. The keys and values themselves are not cloned.<BR>
<I><B>Returns: </B></I>A cloned hash table.
</BLOCKQUOTE>
<H4><TT>contains</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized boolean contains(Object
value)<BR>
</TT>This method searches the hash table to determine if
a specific value is stored.<BR>
<I><B>Parameters: </B></I><TT>value</TT>-the
value to search for.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the value is found; <TT>false</TT>
if not.<BR>
<I><B>Throws: </B></I><TT>NullPointerException</TT>
if the value is null.
</BLOCKQUOTE>
<H4><TT>containsKey</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized boolean containsKey(Object
key)<BR>
</TT>This method searches the hash table to determine if
a specific key occurs.<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key to search for.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the key is found; <TT>false</TT>
if not.
</BLOCKQUOTE>
<H4><TT>elements</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Enumeration elements()
<BR>
</TT>This method returns an enumeration of all of the element
values in the instance.<BR>
<I><B>Returns: </B></I>An enumeration of each of the keys in the
hash table. The methods of <TT>Enumeration</TT>
can be used to iterate through the keys.
</BLOCKQUOTE>
<H4><TT>get</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Object get(Object
key)<BR>
</TT>This method retrieves the object associated with the
specified key.<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key of the object to be retrieved.<BR>
<I><B>Returns: </B></I>The value associated with the key, if found;
null if not.
</BLOCKQUOTE>
<H4><TT>isEmpty</TT></H4>
<BLOCKQUOTE>
<TT>public boolean isEmpty()<BR>
</TT>This method can be used to determine if the hash table
is empty.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the hash table is empty; <TT>false</TT>
if not.
</BLOCKQUOTE>
<H4><TT>keys</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Enumeration keys()
<BR>
</TT>This method returns an enumeration of all the keys
in the instance.<BR>
<I><B>Returns: </B></I>An enumeration of each of the keys in the
hash table. The methods of <TT>Enumeration</TT>
can be used to iterate through the keys.
</BLOCKQUOTE>
<H4><TT>put</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Object put(Object
key, Object value)<BR>
</TT>This method inserts a new element into the hash table.
To retrieve an element, use the <TT>get</TT>
method.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>key</TT>-the key to be added.
<BR>
<TT>value</TT>-the value associated
with the key.<BR>
<I><B>Returns: </B></I>If the key was already in the hash table,
the old value associated with it is returned. If not, null is
returned.<BR>
<I><B>Throws: </B></I><TT>NullPointerException</TT>
if the value is null.
</BLOCKQUOTE>
<H4><TT>rehash</TT></H4>
<BLOCKQUOTE>
<TT>protected void rehash()<BR>
</TT>This method rehashes the hash table into a larger
hash table. It is not normally necessary to call this method directly
because it is invoked automatically based on the capacity and
load factor of the hash table.
</BLOCKQUOTE>
<H4><TT>remove</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Object remove(Object
key)<BR>
</TT>This method removes an object from a hash table.<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key of the element to be removed.<BR>
<I><B>Returns: </B></I>If the key is found, the value associated
with it is returned; if not, null is returned.
</BLOCKQUOTE>
<H4><TT>size</TT></H4>
<BLOCKQUOTE>
<TT>public int size()<BR>
</TT>This method returns the number of elements in the
hash table.<BR>
<I><B>Returns: </B></I>The number of items stored in the hash
table.
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized String toString()
<BR>
</TT>This method overrides the <TT>toString</TT>
method in <TT>Object</TT> and formats
the contents of the hash table as a string.<BR>
<I><B>Returns: </B></I>A string representation of the hash table.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierObservableFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Observable</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>An Observable class is a class that can be watched
or monitored by another class that implements the Observer interface.
Associated with an Observable instance is a list of observers.
Whenever the Observable instance changes it can notify each of
its observers. By using Observable and Observer classes you can
achieve a better partitioning of your code by decreasing the reliance
of one class on another.
</BLOCKQUOTE>
<H4><TT>Observable</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Observable()<BR>
</TT>This is an empty, default constructor.
</BLOCKQUOTE>
<H4><TT>addObserver</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void addObserver(Observer
o)<BR>
</TT>This method will add an observer to the list of objects
that are observing this instance. The observer must implement
the <TT>Observer</TT> interface.<BR>
<I><B>Parameters: </B></I><TT>o</TT>-the
observer to add.
</BLOCKQUOTE>
<H4><TT>clearChanged</TT></H4>
<BLOCKQUOTE>
<TT>protected synchronized void clearChanged()
<BR>
</TT>This method clears the internal flag that indicates
an <TT>Observable</TT> instance has
changed.
</BLOCKQUOTE>
<H4><TT>countObservers</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized int countObservers()
<BR>
</TT>This method counts the numbers of observers who are
observing the instance.<BR>
<I><B>Returns: </B></I>The number of observers for the instance.
</BLOCKQUOTE>
<H4><TT>deleteObserver</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void deleteObserver(Observer
o)<BR>
</TT>This method will delete an observer from the list
of observers that are monitoring an <TT>Observable</TT>
object. The observer must have been previously added with <TT>addObserver</TT>.
<BR>
<I><B>Parameters: </B></I><TT>o</TT>-the
observer to delete.
</BLOCKQUOTE>
<H4><TT>deleteObservers</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void deleteObservers()
<BR>
</TT>This method will delete all observers of the <TT>Observable</TT>
instance.
</BLOCKQUOTE>
<H4><TT>hasChanged</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized boolean hasChanged()
<BR>
</TT>This method can be used to query if an <TT>Observable</TT>
has changed.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if an observable change has occurred; <TT>false</TT>
otherwise. 
</BLOCKQUOTE>
<H4><TT>notifyObservers</TT></H4>
<BLOCKQUOTE>
<TT>public void notifyObservers()<BR>
</TT>This method will notify all observers that a change
has occurred in the <TT>Observable</TT>
object. This will result in a call to the <TT>update</TT>
method in each observer.
</BLOCKQUOTE>
<H4><TT>notifyObservers</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void notifyObservers(Object
arg)<BR>
</TT>This method will notify all observers that a change
has occurred in the <TT>Observable</TT>
object. This will result in a call to the <TT>update</TT>
method in each observer to which <TT>arg</TT>
will be passed.<BR>
<I><B>Parameters: </B></I><TT>arg</TT>-any
object that can be used to convey information to the observers.
</BLOCKQUOTE>
<H4><TT>setChanged</TT></H4>
<BLOCKQUOTE>
<TT>protected synchronized void setChanged()
<BR>
</TT>This method sets an internal flag to indicate that
an observable change has occurred within the instance.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierPropertiesFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Properties</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Hashtable<BR>
</TT>The Properties class can be used to store keys and
associated values. Through its save and load methods, Properties
can be written to disk. This makes this class an excellent mechanism
for storing configuration information between runs of a program.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected Properties defaults<BR>
</TT>This member stores the default property values.
</BLOCKQUOTE>
<H4><TT>Properties</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Properties()<BR>
</TT>This constructor is used to create an empty, new instance
of <TT>Properties</TT>.
</BLOCKQUOTE>
<H4><TT>Properties</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public Properties(Properties defaults)
<BR>
</TT>This constructor will create a new instance of <TT>Properties</TT>
and will establish a set of default properties.
</BLOCKQUOTE>
<H4><TT>getProperty</TT></H4>
<BLOCKQUOTE>
<TT>public String getProperty(String key)
<BR>
</TT>This method is used to retrieve a property based on
its key. If no matching key is found, the defaults are searched.
If no match is found there either, null is returned.<BR>
<I><B>Parameters: </B></I><TT>key</TT>-the
key of the property to retrieve.<BR>
<I><B>Returns: </B></I>The property associated with the key or
null if there is no matching key.
</BLOCKQUOTE>
<H4><TT>getProperty</TT></H4>
<BLOCKQUOTE>
<TT>public String getProperty(String key,
String defaultValue)<BR>
</TT>This method is used to retrieve a property based on
its key. If no match is found, <TT>defaultValue</TT>
is returned.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>key</TT>-the key of the property
to retrieve.<BR>
<TT>defaultValue</TT>-the value to
use if no matching key is found.<BR>
<I><B>Returns: </B></I>The property associated with the key or
the <TT>defaultValue</TT> if there
is no matching key.
</BLOCKQUOTE>
<H4><TT>list</TT></H4>
<BLOCKQUOTE>
<TT>public void list(PrintStream out)<BR>
</TT>This method will list all of the properties to the
specified <TT>PrintStream</TT>. It
is useful mainly while debugging.<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
<TT>PrintStream</TT> where the properties
are to be printed.
</BLOCKQUOTE>
<H4><TT>load</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void load(InputStream
in) throws IOException <BR>
</TT>This method reads a set of properties from the specified
<TT>InputStream</TT>. Used in conjunction
with the <TT>save</TT> method, <TT>Properties</TT>
can be written to disk at the end of a program run and then reloaded
at the start of the next run.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream from which the properties are to be read.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if the specified file is not found or cannot be read.
</BLOCKQUOTE>
<H4><TT>propertyNames</TT></H4>
<BLOCKQUOTE>
<TT>public Enumeration propertyNames()<BR>
</TT>This method returns an enumeration of all of the property
names in the instance.<BR>
<I><B>Returns: </B></I>An enumeration of each of the property
names. The methods of <TT>Enumeration</TT>
can be used to iterate through the property names.
</BLOCKQUOTE>
<H4><TT>save</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void save(OutputStream
out, String header)<BR>
</TT>This method saves the properties to an output stream.
Since <TT>FileOutputStream</TT> is
a subclass of <TT>OutputStream</TT>,
this method can be used to write to a file.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>out</TT>-the output stream to
which the properties are to be written.<BR>
<TT>header</TT>-a header that will
be sent to the output stream before the properties.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierRandomFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Random</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>The Random class represents a pseudo-random number
generator. Two constructors are provided, one taking a seed value
as a parameter and the other taking no parameters and using the
current time as a seed.
</BLOCKQUOTE>
<H4><TT>random</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public random()<BR>
</TT>This constructor creates a new random number generator
that is seeded based on the current time.
</BLOCKQUOTE>
<H4><TT>random</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public random(long seed) <BR>
</TT>This constructor creates a new random number generator
based on the specified seed value. A program can reset the seed
of an already created instance by using the <TT>setSeed</TT>
method.<BR>
<I><B>Parameters: </B></I><TT>seed</TT>-the
seed value.
</BLOCKQUOTE>
<H4><TT>nextDouble</TT></H4>
<BLOCKQUOTE>
<TT>public double nextDouble()<BR>
</TT>This method retrieves the next number from the random
number generator. The number will be a pseudo-random, uniformly
distributed <TT>double</TT> between
0.0D and 1.0D.<BR>
<I><B>Returns: </B></I>A randomly distributed <TT>double</TT>
between 0.0D and 1.0D.
</BLOCKQUOTE>
<H4><TT>nextFloat</TT></H4>
<BLOCKQUOTE>
<TT>public float nextFloat()<BR>
</TT>This method retrieves the next number from the random
number generator. The number will be a pseudo-random, uniformly
distributed <TT>float</TT> between
0.0F and 1.0F.<BR>
<I><B>Returns: </B></I>A randomly distributed <TT>float</TT>
between 0.0F and 1.0F.
</BLOCKQUOTE>
<H4><TT>nextGaussian</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized double nextGaussian()
<BR>
</TT>This method retrieves the next value from the pseudo-random
number generator. The value will be returned as a Gaussian-distributed
<TT>double</TT> that has a mean of
0 and a standard deviation of 1.<BR>
<I><B>Returns: </B></I>A Gaussian-distributed <TT>double</TT>.
</BLOCKQUOTE>
<H4><TT>nextInt</TT></H4>
<BLOCKQUOTE>
<TT>public int nextInt() <BR>
</TT>This method retrieves the next number from the random
number generator. The number will be a pseudo-random <TT>int</TT>
with a value that is uniformly distributed among all possible
<TT>int</TT> values.<BR>
<I><B>Returns: </B></I>A randomly distributed <TT>int</TT>.
</BLOCKQUOTE>
<H4><TT>nextLong</TT></H4>
<BLOCKQUOTE>
<TT>public long nextLong()<BR>
</TT>This method retrieves the next number from the random
number generator. The number will be a pseudo-random <TT>long</TT>
with a value that is uniformly distributed among all possible
<TT>long</TT> values.<BR>
<I><B>Returns: </B></I>A randomly distributed <TT>long</TT>.
</BLOCKQUOTE>
<H4><TT>setSeed</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized void setSeed(long
seed)<BR>
</TT>This method sets a seed value for the pseudo-random
number generator. The seed value is used to determine the values
that are generated. By setting a specific seed value, the random
number generator can be coerced into generating a specific sequence
of values.<BR>
<I><B>Parameters: </B></I><TT>seed</TT>-the
seed value.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierStackFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Stack</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Vector<BR>
</TT>The Stack class implements a simple last-in-first-out
stack. An item is stored on a stack by &quot;pushing&quot; it
onto the stack. An item may subsequently be &quot;popped&quot;
off the stack and used. The item popped off a stack will always
be the most recently pushed item. 
</BLOCKQUOTE>
<H4><TT>Stack</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Stack()<BR>
</TT>This is the default constructor.
</BLOCKQUOTE>
<H4><TT>empty</TT></H4>
<BLOCKQUOTE>
<TT>public boolean empty()<BR>
</TT>This method can be used to determine if the stack
contains items.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the stack is empty; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>peek</TT></H4>
<BLOCKQUOTE>
<TT>public Object peek()<BR>
</TT>This method can be used to peek at the top item on
the stack. It is similar to <TT>pop</TT>
but does not remove the item from the stack.<BR>
<I><B>Returns: </B></I>The item at the top of the stack.<BR>
<I><B>Throws: </B></I><TT>EmptyStackException</TT>
if the stack is empty.
</BLOCKQUOTE>
<H4><TT>pop</TT></H4>
<BLOCKQUOTE>
<TT>public Object pop()<BR>
</TT>This method retrieves the last item added to the stack.
To examine, but not remove, the top item in the stack use the
<TT>peek</TT> method.<BR>
<I><B>Returns: </B></I>The item at the top of the stack.<BR>
<I><B>Throws: </B></I><TT>EmptyStackException</TT>
if the stack is empty.
</BLOCKQUOTE>
<H4><TT>push</TT></H4>
<BLOCKQUOTE>
<TT>public Object push(Object item)<BR>
</TT>This method adds a new item to the stack.<BR>
<I><B>Parameters: </B></I><TT>item</TT>-the
item to push onto the stack.<BR>
<I><B>Returns: </B></I>The item that was pushed onto the stack.
</BLOCKQUOTE>
<H4><TT>search</TT></H4>
<BLOCKQUOTE>
<TT>public int search(Object o)<BR>
</TT>This method examines the stack to see if the specified
object is in the stack.<BR>
<I><B>Parameters: </B></I><TT>o</TT>-the
object to search for.<BR>
<I><B>Returns: </B></I>The distance from the top of the stack,
or <TT>-1</TT> if the item is not
in the stack.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierStringTokenizerFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>StringTokenizer</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT><I><B>Implements: </B></I>Enumeration<BR>
A StringTokenizer can be used to parse a string into its constituent
tokens. For example, each word in a sentence could be considered
a token. However, the StringTokenizer class goes beyond the parsing
of sentences. You can create a fully customized tokenizer by specifying
the set of token delimiters when the string tokenizer is created.
</BLOCKQUOTE>
<H4><TT>StringTokenizer</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public StringTokenizer(String str, String
delim, boolean returnTokens)<BR>
</TT>This constructor creates a new instance based on the
string to be tokenized, the set of delimiters, and a flag indicating
if delimiters should be returned as tokens.<BR>
<I><B>Parameters:<BR>
</B></I><TT>str</TT>-the string to
be tokenized.<BR>
<TT>delim</TT>-a string containing
the delimiters to use when tokenizing the string.<BR>
<TT>returnTokens</TT>-<TT>true</TT>
if the string tokenizer should return delimiters as tokens; <TT>false</TT>
if not.
</BLOCKQUOTE>
<H4><TT>StringTokenizer</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public StringTokenizer(String str, String
delim)<BR>
</TT>This constructor creates a new instance based on the
string to be tokenized and a set of delimiters.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>str</TT>-the string to be tokenized.
<BR>
<TT>delim</TT>-a string containing
the delimiters to use when tokenizing the string.
</BLOCKQUOTE>
<H4><TT>StringTokenizer</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public StringTokenizer(String str)<BR>
</TT>This constructor creates a new instance based on the
string to be tokenized and the default set of delimiters. The
default delimiters are the space, tab, newline, and carriage-return
characters.
</BLOCKQUOTE>
<H4><TT>countTokens</TT></H4>
<BLOCKQUOTE>
<TT>public int countTokens()<BR>
</TT>This method returns the number of remaining tokens.
<BR>
<I><B>Returns: </B></I>The quantity of tokens remaining in the
string being tokenized.
</BLOCKQUOTE>
<H4><TT>hasMoreElements</TT></H4>
<BLOCKQUOTE>
<TT>public boolean hasMoreElements()<BR>
</TT>This method can be used to determine if the string
tokenizer contains more elements (tokens). This method is identical
to <TT>hasMoreTokens</TT> and is a
member of <TT>StringTokenizer</TT>
because <TT>StringTokenizer</TT> implements
the <TT>Enumeration</TT> interface.
<BR>
<I><B>Returns: </B></I><TT>true</TT>
if there are more elements; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>hasMoreTokens</TT></H4>
<BLOCKQUOTE>
<TT>public boolean hasMoreTokens()<BR>
</TT>This method can be used to determine if the string
tokenizer contains more tokens. It is identical to <TT>hasMoreElements</TT>.
<BR>
<I><B>Returns: </B></I><TT>true</TT>
if there are more tokens; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>nextElement</TT></H4>
<BLOCKQUOTE>
<TT>public Object nextElement()<BR>
</TT>This method overrides <TT>nextElement</TT>
in the <TT>Enumeration</TT> interface
and exists because <TT>StringTokenizer</TT>
implements that interface. It is identical to <TT>nextToken</TT>
and returns the next token in the enumeration.<BR>
<I><B>Returns: </B></I>The next token in the enumeration.<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if there are no more elements.
</BLOCKQUOTE>
<H4><TT>nextToken</TT></H4>
<BLOCKQUOTE>
<TT>public String nextToken()<BR>
</TT>This method returns the next token in the string that
is being tokenized. It is typically used inside a loop that processes
each token.<BR>
<I><B>Returns: </B></I>The next token in the string being tokenized.
<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if there are no more tokens.
</BLOCKQUOTE>
<H4><TT>nextToken</TT></H4>
<BLOCKQUOTE>
<TT>public String nextToken(String delim)
<BR>
</TT>This method changes the set of delimiter characters
and then returns the next token. The new delimiter set will remain
in effect after this method completes.<BR>
<I><B>Parameters: </B></I><TT>delim</TT>-a
string containing the new set of delimiters.<BR>
<I><B>Returns: </B></I>The next token in the string being tokenized.
<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if there are no more tokens.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierVectorFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>Vector</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT><I><B>Implements: </B></I>Cloneable <BR>
A vector is analogous to a linked list in other languages or class
libraries. A vector stores items of type Object so it can be used
to store instances of any Java class. A single vector may store
different elements that are instances of different classes. 
</BLOCKQUOTE>
<H4><TT>Vector</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Vector(int initialCapacity, int
capacityIncrement)<BR>
</TT>This constructor will create a new instance of a vector
with space for <TT>initialCapacity</TT>
elements initially. Memory for additional elements will be allocated
in blocks that will each hold <TT>capacityIncrement</TT>
elements.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>initialCapacity</TT>-the number
of elements to allocate space for when the object is created.
<BR>
<TT>capacityIncrement</TT>-the number
of additional elements to allocate space for whenever additional
space is needed.
</BLOCKQUOTE>
<H4><TT>Vector</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public Vector(int initialCapacity)<BR>
</TT>This constructor will create a new instance of a vector
with space for <TT>initialCapacity</TT>
elements initially. Whenever a new element is added that would
have exceeded this capacity, the size of the vector is doubled.
<BR>
<I><B>Parameters: </B></I><TT>initialCapacity</TT>-the
number of elements to allocate space for when the object is created.
</BLOCKQUOTE>
<H4><TT>Vector</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public constructorVector()<BR>
</TT>This constructor will create a new instance of a vector.
Initially, the vector will have room for storing 10 elements,
but this will increase automatically to accommodate new elements.
Whenever a new element is added that would have exceeded this
capacity, the size of the vector is doubled.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected int capacityIncrement<BR>
</TT>This member stores the amount by which the vector
will be incremented each time it needs to grow. If <TT>capacityIncrement</TT>
is <TT>0</TT>, the buffer does not
grow by a fixed amount but instead doubles whenever it needs to
grow.<BR>
<TT>protected int elementCount<BR>
</TT>This member stores the number of elements in the vector.
<BR>
<TT>protected Object elementData[]<BR>
</TT>This member is the array where the <TT>Vector</TT>
elements are stored.
</BLOCKQUOTE>
<H4><TT>addElement</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void addElement(Object
obj)<BR>
</TT>This method is used to insert new elements into the
vector; a vector can store objects of different types.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to add to the vector.
</BLOCKQUOTE>
<H4><TT>capacity</TT></H4>
<BLOCKQUOTE>
<TT>public final int capacity()<BR>
</TT>This method returns the number of elements that will
fit in the vector before more space is allocated.<BR>
<I><B>Returns: </B></I>The number of elements that will fit in
the currently allocated portion of the vector.
</BLOCKQUOTE>
<H4><TT>clone</TT></H4>
<BLOCKQUOTE>
<TT>public synchronized Object clone()<BR>
</TT>This method overrides <TT>clone</TT>
in <TT>Object</TT> and will clone
the vector. Only the vector itself is cloned; the elements of
the vector are not cloned.<BR>
<I><B>Returns: </B></I>A cloned copy of the vector. 
</BLOCKQUOTE>
<H4><TT>contains</TT></H4>
<BLOCKQUOTE>
<TT>public final boolean contains(Object
elem)<BR>
</TT>This method determines if an object is stored in a
vector.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the object is stored in the vector; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>copyInto</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void copyInto(Object
anArray[])<BR>
</TT>This method copies the elements of the vector into
an array.<BR>
<I><B>Parameters: </B></I><TT>anArray</TT>-the
array into which the vector elements will be copied.
</BLOCKQUOTE>
<H4><TT>elementAt</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized Object elementAt(int
index)<BR>
</TT>This method retrieves the element located at the specified
index within the vector.<BR>
<I><B>Parameters: </B></I><TT>index</TT>-the
zero-based index number of the element to retrieve.<BR>
<I><B>Returns: </B></I>The element at the specified zero-based
index.<BR>
<I><B>Throws: </B></I><TT>ArrayIndexOutOfBoundsException</TT>
if an invalid index is specified.
</BLOCKQUOTE>
<H4><TT>elements</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized Enumeration
elements()<BR>
</TT>This method returns an <TT>Enumeration</TT>
of the elements in the vector, making it easy to iterate through
the elements.<BR>
<I><B>Returns: </B></I>An <TT>Enumeration</TT>
consisting of all the elements in the vector. 
</BLOCKQUOTE>
<H4><TT>ensureCapacity</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void ensureCapacity(int
minCapacity)<BR>
</TT>This method ensures that the vector has at least the
specified minimum capacity. If the current capacity of the vector
is less than <TT>minCapacity</TT>,
the size of the vector is increased to hold at least <TT>minCapacity</TT>.
<BR>
<I><B>Parameters: </B></I><TT>minCapacity</TT>-the
minimum capacity of the vector.
</BLOCKQUOTE>
<H4><TT>firstElement</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized Object firstElement()
<BR>
</TT>This method retrieves the first element in the vector.
If the vector is empty, an exception is thrown. It performs the
same function as <TT>elementAt(0)</TT>.
<BR>
<I><B>Returns: </B></I>The element at the specified zero-based
index.<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if the vector is empty.
</BLOCKQUOTE>
<H4><TT>indexOf</TT></H4>
<BLOCKQUOTE>
<TT>public final int indexOf(Object elem)
<BR>
</TT>This method searches the vector and returns the zero-based
index number of the first matching object.<BR>
<I><B>Parameters: </B></I><TT>elem</TT>-the
element to find the index of.<BR>
<I><B>Returns: </B></I>The element number of the first element
that matches <TT>elem</TT>, or <TT>-1</TT>
if no match is found.
</BLOCKQUOTE>
<H4><TT>indexOf</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized int indexOf(Object
elem, int index) <BR>
</TT>This method finds the first element in the vector
that matches <TT>elem</TT> starting
at the element given by <TT>index</TT>.
It is very useful for traversing a vector searching for all elements
matching a specific object.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>elem</TT>-the element to find
the index of.<BR>
<TT>index</TT>-the index number at
which to start the search.<BR>
<I><B>Returns: </B></I>The element number of the first element
that matches <TT>elem</TT>, or <TT>-1</TT>
if no match is found.
</BLOCKQUOTE>
<H4><TT>insertElementAt</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void insertElementAt(Object
obj, <BR>
int index)<BR>
</TT>This method, like <TT>addElement</TT>,
is used to add a new element to a vector. However, this method
can be used to specify where in the vector the new element should
be added. All <TT>Vector</TT> elements
with index numbers greater than or equal to <TT>index</TT>
are moved to make room for the new element.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>obj</TT>-the object to add to
the vector.<BR>
<TT>index</TT>-the zero-based index
at which the object is to be inserted.<BR>
<I><B>Throws: </B></I><TT>ArrayIndexOutOfBoundsException</TT>
if the specified index is invalid.
</BLOCKQUOTE>
<H4><TT>isEmpty</TT></H4>
<BLOCKQUOTE>
<TT>public final boolean isEmpty()<BR>
</TT>This method is used to determine if the vector contains
any elements.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the vector has no elements; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>lastElement</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized Object lastElement()
<BR>
</TT>This method retrieves the last element in the vector.
If the vector is empty an exception is thrown.<BR>
<I><B>Returns: </B></I>The element at the specified zero-based
index.<BR>
<I><B>Throws: </B></I><TT>NoSuchElementException</TT>
if the vector is empty.
</BLOCKQUOTE>
<H4><TT>lastIndexOf</TT></H4>
<BLOCKQUOTE>
<TT>public final int lastIndexOf(Object elem)
<BR>
</TT>This method searches the vector and returns the zero-based
index number of the last matching object.<BR>
<I><B>Parameters: </B></I><TT>elem</TT>-the
element to find the index of.<BR>
<I><B>Returns: </B></I>The element number of the last element
that matches <TT>elem</TT>, or <TT>-1</TT>
if no match is found.
</BLOCKQUOTE>
<H4><TT>lastIndexOf</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized int lastIndexOf(Object
elem, int index)<BR>
</TT>This method finds the last element in the vector that
matches <TT>elem</TT> starting at
the element given by <TT>index</TT>.
It is very useful for traversing a vector backward searching for
all elements matching a specific object. <BR>
<I><B>Parameters:</B></I> <BR>
<TT>elem</TT>-the element to find
the last index of.<BR>
<TT>index</TT>-the index number at
which to start the search.<BR>
<I><B>Returns: </B></I>The element number of the last element
that matches <TT>elem</TT>, or <TT>-1</TT>
if no match is found.
</BLOCKQUOTE>
<H4><TT>removeAllElements</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void removeAllElements()
<BR>
</TT>This method can be used to remove all elements from
the vector.
</BLOCKQUOTE>
<H4><TT>removeElement</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized boolean removeElement(Object
obj)<BR>
</TT>This method can be used to remove a specific element
from the vector. Only the first element that matches <TT>obj</TT>
is removed.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to remove.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the element was found and deleted; <TT>false</TT>
otherwise. 
</BLOCKQUOTE>
<H4><TT>removeElementAt</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void removeElementAt(int
index)<BR>
</TT>This method removes the element at the specified zero-based
index.<BR>
<I><B>Parameters: </B></I><TT>index</TT>-the
index number of the element to remove from the vector.<BR>
<I><B>Throws: </B></I><TT>ArrayIndexOutOfBoundsException</TT>
if the specified index is invalid.
</BLOCKQUOTE>
<H4><TT>setElementAt</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void setElementAt(Object
obj, int index)<BR>
</TT>This method replaces an element in the vector with
another element.<BR>
<I><B>Parameters:</B></I> <BR>
<TT>obj</TT>-the object to be placed
in the vector.<BR>
<TT>index</TT>-the index number of
the element to be replaced.<BR>
<I><B>Throws: </B></I><TT>ArrayIndexOutOfBoundsException</TT>
if the specified index is invalid.
</BLOCKQUOTE>
<H4><TT>setSize</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void setSize(int
newSize)<BR>
</TT>This method sets the size of the vector. If the specified
size makes the vector too small to hold its current elements,
elements from the end of the vector are removed. If the new size
is larger than the current size, empty elements are added at the
end of the vector.<BR>
<I><B>Parameters: </B></I><TT>newSize</TT>-the
desired size of the vector.
</BLOCKQUOTE>
<H4><TT>size</TT></H4>
<BLOCKQUOTE>
<TT>public final int size()<BR>
</TT>The method returns the number of elements currently
in the vector.<BR>
<I><B>Returns: </B></I>The number of elements in the vector.
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized String toString()
<BR>
</TT>This method overrides the <TT>toString</TT>
method in <TT>Object</TT> and formats
the contents of the vector as a string.<BR>
<I><B>Returns: </B></I>A string representation of the vector.
</BLOCKQUOTE>
<H4><TT>trimToSize</TT></H4>
<BLOCKQUOTE>
<TT>public final synchronized void trimToSize()
<BR>
</TT>This method will remove any excess capacity from the
vector by resizing it to hold only the quantity of elements it
currently holds. If new items are added, the size of the vector
will be increased.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierEmptyStackExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>EmptyStackException</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>RuntimeException
<BR>
</TT>This exception signals when the stack is empty.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierNoSuchElementExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>NoSuchElementException</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>RuntimeException
<BR>
</TT>This exception signals when an enumeration is empty.
</BLOCKQUOTE>
<HR>

<CENTER><P><A HREF="ch39.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
