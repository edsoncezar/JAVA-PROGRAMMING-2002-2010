<HTML>
<HEAD>
<TITLE>Day 27 -- The Standard Extension APIs</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;27</FONT>
</H1>
<H1><FONT SIZE=6 COLOR=#FF0000>The Standard Extension APIs</FONT>
</H1>
<P>
<I><B>by Michael Morrison</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#JavaAPIOverview">
Java API Overview</A>
<LI><A HREF="#TheEnterpriseAPI">
The Enterprise API</A>
<UL>
<LI><A HREF="#JavaDatabaseConnectivity">
Java Database Connectivity</A>
<LI><A HREF="#InterfaceDefinitionLanguage">
Interface Definition Language</A>
<LI><A HREF="#RemoteMethodInvocation">
Remote Method Invocation</A>
</UL>
<LI><A HREF="#TheCommerceAPI">
The Commerce API</A>
<LI><A HREF="#TheManagementAPI">
The Management API</A>
<LI><A HREF="#TheServerAPI">
The Server API</A>
<LI><A HREF="#TheMediaAPI">
The Media API</A>
<LI><A HREF="#TheSecurityAPI">
The Security API</A>
<LI><A HREF="#TheJavaBeansAPI">
The Java Beans API</A>
<LI><A HREF="#TheEmbeddedAPI">
The Embedded API</A>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Throughout this book you've learned a lot about the Java programming
environment and how it can be used to create interactive Web-based
programs. Your knowledge of Java thus far has been entirely based
on what is known as the core Java API, or Java Base API. Until
recently, this core API comprised the entirety of the Java programming
landscape. However, JavaSoft recently announced a broad plan for
integrating various new software technologies into the Java API.
These new technologies come in the form of extension APIs that
integrate with the core Java API, and they are referred to as
the <I>standard extension APIs</I>. At some point, many of these
APIs will merge and become part of the core API, but for now they
are all being presented as extensions.
<P>
Today's lesson takes a look at these new APIs and discusses what
they have to offer, along with exactly how they will integrate
with the existing core API. The main topics you cover today are
<UL>
<LI>Java software platform overview
<LI>Enterprise and commerce API extensions
<LI>Management and server API extensions
<LI>Media API extensions
<LI>Security API extensions
<LI>Component API extensions
<LI>Embedded systems API extensions
</UL>
<P>
Most of these API extensions are very new and haven't even reached
the specification stage. For this reason, today's lesson is only
meant to give you an idea of where Java is headed with the standard
extension APIs. In other words, you may want to check JavaSoft's
Web site (<TT>www.javasoft.com</TT>)
to get the latest scoop on the status of these APIs since they
are in a constant state of flux.
<H2><A NAME="JavaAPIOverview"><FONT SIZE=5 COLOR=#FF0000>
Java API Overview</FONT></A></H2>
<P>
Java release 1.02, which is the latest Java release as of this
writing, is now being referred to by JavaSoft as the <I>core Java
API</I>. The core Java API defines the minimal set of functionality
a Java implementation must support to be considered Java compliant.
For example, when someone undertakes the job of supporting Java
on a particular platform, he must fully implement the core Java
API. This guaranteed support for the core API is what allows Java
developers the luxury of being able to write Java programs once
and have them run on any Java-compliant platform.
<P>
In the near future, JavaSoft plans to expand on the core API by
introducing new APIs addressing more applied development needs.
The new APIs cover a wide range of areas and will ultimately save
developers a great deal of time by establishing a consistent approach
to certain development issues, thereby reducing the need for custom
coding. Some of these new APIs will merge with the core API; others
will remain extensions. Regardless of their ultimate relationship
to the core API, the new extension APIs are referred to as the
standard extension APIs since they extend the current core API
as we know it.
<P>
The standard extension API is broken up into a set of individual
APIs targeting different development needs. Following are the
major components of the standard extension APIs:
<UL>
<LI>Enterprise API
<LI>Commerce API
<LI>Management API
<LI>Server API
<LI>Media API
<LI>Security API
<LI>Java Beans API
<LI>Embedded API
</UL>
<P>
The rest of today's lesson focuses on each of these APIs and how
they affect the Java software platform.
<H2><A NAME="TheEnterpriseAPI"><FONT SIZE=5 COLOR=#FF0000>
The Enterprise API</FONT></A></H2>
<P>
Enterprise computing has become increasingly important in recent
years as more and more companies realize the importance of integrating
their operations electronically. The unique possibilities afforded
by the increased usage of the Internet have served to magnify
the popularity of enterprise computing. JavaSoft took note of
Java's lack of support for enterprise systems and announced plans
for an Enterprise API.
<P>
The Java Enterprise API is designed to give Java programs a formal
mechanism for connecting to enterprise information systems. This
is a much-needed feature in Java since so many corporate computer
systems rely heavily on enterprise information sources. In answering
this need, the Enterprise API tackles the problem on three fronts.
These fronts come in the form of three API subsets:
<UL>
<LI>Java Database Connectivity (JDBC)
<LI>Interface Definition Language (IDL)
<LI>Remote Method Invocation (RMI)
</UL>
<P>
JavaSoft has recognized the importance of these three API subsets
and plans to directly incorporate them into the core Java API
at some point in the future.
<H3><A NAME="JavaDatabaseConnectivity">
Java Database Connectivity</A></H3>
<P>
The first of these subset APIs, JDBC, defines a structured interface
to SQL (Structured Query Language) databases, which is the industry
standard approach to accessing relational databases. By supporting
SQL, JDBC allows developers to interact and support a wide range
of databases. This means that the specifics of the underlying
database platform are pretty much irrelevant when it comes to
JDBC, which is very good news to Java developers.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>SQL databases</I> are databases built on the SQL standard, which is a widely accepted standard that defines a strict protocol for accessing and manipulating data.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The JDBC API provides Java developers with a consistent approach
to accessing SQL databases that is comparable to existing database
development techniques, so interacting with a SQL database using
JDBC isn't all that much different than interacting with a SQL
database using traditional database tools. This should give Java
programmers who already have some database experience confidence
that they can hit the ground running with JDBC. The JDBC API has
already been widely endorsed by industry leaders, including some
development-tool vendors who have announced future support for
JDBC in their development products.
<P>
The JDBC API includes classes for common SQL database constructs
such as database connections, SQL statements, and result sets.
JDBC Java programs will be able to use the familiar SQL programming
model of issuing SQL statements and processing the resulting data.
The JDBC API is largely dependent on a driver manager that supports
multiple drivers connecting to different databases. JDBC database
drivers can be either written entirely in Java or implemented
using native methods to bridge Java applications to existing database
access libraries.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>result set</I> is a group data retrieved from a database after a user request.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="InterfaceDefinitionLanguage">
Interface Definition Language</A></H3>
<P>
The IDL subset of the Enterprise API is aimed at providing a way
to connect Java client programs to network servers running on
other platforms. IDL is an industry standard protocol for client/server
communications across different platforms. The primary use of
the IDL API is to transparently connect Java client programs to
legacy systems.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=565><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=565>
<BLOCKQUOTE>
A <I>legacy system</I> is an outdated system that has yet to be reimplemented using current technologies.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The Java IDL API includes the following components:
<UL>
<LI>A client framework that allows Java IDL clients to be designed
as either applets or standalone applications
<LI>A server framework that allows Java applications to act as
network servers for IDL clients
<LI>A development tool that automatically generates stub code
for specific remote interfaces
</UL>
<H3><A NAME="RemoteMethodInvocation">
Remote Method Invocation</A></H3>
<P>
The RMI component of the Enterprise API defines an interface for
invoking object methods in a distributed environment. The RMI
API serves a crucial purpose in the Enterprise API by adding full
support for remote object communications. The RMI API makes it
straightforward for Java developers to add remote computing support
to their classes.
<H2><A NAME="TheCommerceAPI"><FONT SIZE=5 COLOR=#FF0000>
The Commerce API</FONT></A></H2>
<P>
As the role of the Internet continues to evolve from being just
an information source to also being a retail marketplace, the
need for a secure commercial transaction protocol is growing to
new heights. Both Internet vendors and shoppers alike are eagerly
awaiting the inevitable migration of shopping to the Web. JavaSoft
has provided an answer to the secure purchasing problem with the
Commerce API, which is a Java API extension that provides the
overhead for Java programs to support secure purchasing and financial
management.
<P>
The Java Commerce API aims to provide developers with an elegant
solution to the problem of commercial transactions on the Web.
The goal is to make purchasing goods a seamless, yet secure, 
part of the Web experience. To this end, the Commerce API is being
pushed by JavaSoft as an open, extensible environment for financial
management on the Web. The long-term plan for the Commerce API
is for integration into the Java software platform partially with
the core API and partially as a standard extension. It isn't clear
yet which components will make it into the core API and which
will remain separate.
<P>
The Commerce API consists of the following primary components:
<UL>
<LI>An infrastructure 
<LI>A database 
<LI>Payment cassettes 
<LI>Service cassettes 
<LI>Administrative interfaces 
</UL>
<P>
The infrastructure of the Commerce API is basically the architectural
framework that defines the interactions between the other components
of the API. This infrastructure is also what gives the API its
extensibility to support future commerce extensions.
<P>
The database component serves as a repository for user information,
such as payment methods and the user's shipping address. The database
component contains encryption features so that user information
can be kept completely private. Alternately, commerce service
providers have the option of sharing user information with one
another.
<P>
The Commerce API makes use of <I>cassettes</I>, which are software
modules that implement specific financial protocols. The two different
types of cassettes supported are payment cassettes and service
cassettes. A <I>payment cassette</I> defines the protocol for
making electronic payments. Examples of payment cassettes are
credit cards, debit cards, and eventually digital cash. A user
could have multiple payment cassettes that represent different
payment instruments, much like we carry different payment instruments
in our wallets or purses. In fact, one of the classes in the Commerce
API specifically models an electronic wallet.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>cassette</I> is a software module that implements a specific payment protocol.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<I>Service cassettes</I> are more general, and they model any
type of value-added financial service such as financial analysis
or tax preparation modules. For example, you could feasibly purchase
a service cassette to help balance your electronic checkbook or
assess the value of your stock portfolio.
<P>
The last component of the Commerce API includes administrative
interfaces, which are dialog boxes and other graphical interfaces
used to retrieve information from the user and to configure commerce
options.
<H2><A NAME="TheManagementAPI"><FONT SIZE=5 COLOR=#FF0000>
The Management API</FONT></A></H2>
<P>
The Management API is designed to answer the needs of integrated
network management systems. It includes a wide range of interfaces,
classes, and applets to facilitate the development of integrated
management solutions. The primary goal of the Management API is
to provide a unified approach to handling the complexities involved
in developing and maintaining resources and services on a heterogeneous
network. Using the Management API, Java developers will be able
to rapidly develop network management applications supporting
a wide range of systems on large and often complex networks. JavaSoft
plans to keep the Management API as a separate extension from
the core API.
<P>
The Management API includes the following core components:
<UL>
<LI>The Admin View Module (AVM)
<LI>Base object interfaces
<LI>Managed container interfaces
<LI>Managed notification interfaces
<LI>Managed data interfaces
<LI>Managed protocol interfaces
<LI>SNMP interfaces
<LI>Applet integration interfaces
</UL>
<P>
The Admin View Module is an extension of the Java Abstract Windowing
Toolkit (awt) that is enhanced to provide specific support for
creating integrated management applications. The classes implemented
in the AVM serve as a basis for developing sophisticated graphical
user interfaces. For example, the AVM includes support for graphical
tables, charts, graphs, and meters.
<P>
The base object interfaces define the core object types that are
used for distributed resources and services in a management system.
Using the base object interfaces, developers can define abstractions
for a variety of attributes associated with a managed enterprise
environment.
<P>
The managed container interfaces define a means for grouping together
managed objects for better organization. This organization facilitates
a more group-oriented approach to keeping up with managed resources,
which can be a great benefit in complex systems.
<P>
The managed notification interfaces define a core foundation of
managed-event notification services. Developers are free to develop
more advanced application-specific notification services by extending
these services.
<P>
The managed data interfaces provide a means of linking managed
object attributes to relational databases via JDBC. In doing so,
the managed data interfaces establish a transparent link between
management resources and external databases.
<P>
The managed protocol interfaces use the Java Security APIs and
Java RMI to add secure distributed object support to the core
functionality provided by the base object interfaces. In turn,
the SNMP interfaces extend the managed protocol interfaces to
provide support for SNMP agents. Since SNMP is the most popular
management protocol in use, its support via the SNMP interfaces
is an important part of the Management API.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>SNMP</I> stands for Simple Network Management Protocol, which is a relatively simple protocol originally developed to solve communication problems between different types of networks and gather network statistics.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Finally, the applet integration interfaces component of the Management
API specifies how Java applets can be integrated with the Management
API to provide management solutions. Applet developers use the
applet integration interfaces to build management support into
their applets.
<H2><A NAME="TheServerAPI"><FONT SIZE=5 COLOR=#FF0000>
The Server API</FONT></A></H2>
<P>
After the success of Java and its immediate use for developing
client-side applets, JavaSoft decided to take steps to make Java
a more viable alternative for server-side applications. The Server
API is JavaSoft's answer to the need for more complete server-oriented
support in Java. The Server API provides a wide range of server
functionality including support for administration, accessibility
control, and dynamic resource handling. Also included in the Server
API is the Servlet API, which provides a framework for extending
servers with servlets. JavaSoft plans to keep the Server API an
extension separate from the core API.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>servlet</I> is a Java object that extends the functionality of an information server, such as an HTTP server. You can think of servlets as the server equivalents of client-side Java applets.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The Servlet API provides the overhead necessary for creating servlets
and interfacing them with information servers. The Servlet API
is equipped to handle the entire servlet/server relationship,
with an emphasis on keeping things stable and simple. All that
is required to run servlets is a server that supports the Servlet
API.
<H2><A NAME="TheMediaAPI"><FONT SIZE=5 COLOR=#FF0000>
The Media API</FONT></A></H2>
<P>
Possibly the weakest area of the core Java API as we know it is
its support for media. Currently, the Java API supports only static
GIF and JPEG images and wave sounds in the AU sound format. This
limited media support won't cut it in the long run. Sure, developers
can hack their own media implementations to some extent, but they
could do that already in a variety of other languages and platforms.
Java was supposed to make things easier, right?
<P>
JavaSoft realized this weakness and is remedying things with the
Media API, which is slated to include support for a dizzying array
of media types that will no doubt put Java on the map as a serious
multimedia platform. The Media API includes classes that model
media types such as full-motion video, audio, 2D and 3D graphics,
and telephony. Furthermore, the structure of the API is such that
many of these media types will rely on the same underlying facilities.
For example, all time-based media like video and audio will use
the same underlying timing mechanism, meaning that synchronization
won't be a problem.
<P>
The Media API is designed to be very open and extensible, which
is important considering the fact that the world of multimedia
is ever changing. JavaSoft plans to integrate the Media API into
the Java platform both as core API additions and as standard extension
APIs.
<P>
The following API subsets comprise the Media API:
<UL>
<LI>The Media Framework API
<LI>The 2D Graphics API
<LI>The Animation API
<LI>The 3D Graphics API
<LI>The Video API
<LI>The Audio API
<LI>The MIDI API
<LI>The Share API
<LI>The Telephony API
</UL>
<P>
The Media Framework API handles the low-level timing functionality
required by many of the other media APIs. This API includes support
for timing and synchronization, both of which are critical to
media types that must function together in harmony. Also included
in the Media Framework API is support for streaming, compression,
and live data sources.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Synchronization</I> refers to how different time-based media elements agree with each other in time. For example, it is important for the sound track of a movie to remain synchronized with the picture.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Streaming</I> is the process of interacting with data while it is still being transferred. For example, a streaming audio player would begin playing audio as soon as a certain minimal amount of data has been transferred.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The 2D Graphics API extends the functionality of the awt classes
to provide wider support for 2D graphics primitives and a variety
of different graphical output devices, such as printers. Another
important addition to the 2D Graphics API is the definition of
a uniform graphical model that brings many graphics functions
into one structure. The Animation API uses the 2D Graphics API
as a basis for its implementation of animated 2D graphics objects,
or sprites. It also relies on the Media Framework API for maintaining
timing and synchronization.
<P>
The 3D Graphics API provides the overhead necessary to generate
high-performance 3D graphics. This API implements 3D graphics
by supporting a model of 3D graphical objects that can be rendered
at high speeds. The 3D Graphics API also includes support for
VRML, which is a popular 3D modeling language. To pull off all
this functionality, the 3D Graphics API relies heavily on the
functions provided by many of the other media APIs.
<P>
The Video API brings full-motion video to Java. The API provides
the framework for managing and processing video in either a streaming
or stored scenario. Similar to the Video API in some ways, the
Audio API also provides support for both streaming and stored
media. However, the media supported by the Audio API consists
of either sampled or synthesized audio. The Audio API even contains
classes for implementing 3D spatial audio.
<P>
The MIDI API brings timed musical events to Java by way of the
popular MIDI standard. MIDI is an efficient way to represent both
musical pieces as well as more general timing resources. Expect
to hear the Web much differently once this API catches on!<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>MIDI</I> stands for Musical Instrument Digital Interface. It defines a protocol for communicating and storing time-based events, such as those generated by playing a musical instrument.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The Share API is probably the most interesting of the media APIs,
simply because it's the least obvious. It defines a means by which
live, multiparty communication can take place over a network.
The Share API provides support for both synchronization and session
management. I wouldn't be surprised to see multiplayer games and
&quot;chat&quot; applets take on a new feel once this API is out.
<P>
The last of the media APIs is the Telephony API, which gives Java
the ability to interact with telephones. Most important telephone
functions, including teleconferencing and caller ID, are supported
in this API.
<H2><A NAME="TheSecurityAPI"><FONT SIZE=5 COLOR=#FF0000>
The Security API</FONT></A></H2>
<P>
The eagerly awaited Security API will hopefully remedy one of
the biggest limitations of Java applets: the inability to read
or write files locally. With full support for cryptography, digital
signatures, and authentication, Java developers should be able
to leverage security issues to some extent and move away from
the seemingly overprotective solution currently in place. The
Security API will eventually be incorporated directly into the
core Java API.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Cryptography</I> encompasses the algorithms and techniques used to render data unrecognizable in the hands of unauthorized parties, thereby enforcing information privacy.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>digital signature</I> is an electronic identification technique that serves much the same purpose as a handwritten signature.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Authentication</I> is the process of verifying an action based on a security check.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The cryptographic functions built into the Security API are isolated
from the programmatic interface used by applets wanting to make
security decisions. This layering allows the cryptographic functions
to be replaced by third-party alternatives without impacting any-thing
at the applet level, thereby giving Java developers more options
when it comes to their security needs.
<H2><A NAME="TheJavaBeansAPI"><FONT SIZE=5 COLOR=#FF0000>
The Java Beans API</FONT></A></H2>
<P>
The Java Beans API defines an open standard for implementing dynamic
Java software components, which are tightly packaged classes designed
for reusability. Because the Java Beans API is given prominent
coverage in tomorrow's lesson, I'll spare you the juicy details
for now. However, I will tell you now that the Java Beans API
is planned to merge with the core Java API at some point.
<H2><A NAME="TheEmbeddedAPI"><FONT SIZE=5 COLOR=#FF0000>
The Embedded API</FONT></A></H2>
<P>
The last of the standard extension APIs is the Embedded API, which
defines a minimal set of Java functionality specifically targeted
for embedded systems applications, such as consumer electronics
devices. The Embedded API is the only API that doesn't really
add anything to the Java core API. In fact, the Embedded API will
likely be a subset of the core API since only part of the core
functionality is needed in embedded applications. For example,
since most embedded systems have no graphical output to speak
of, the entire awt is really unnecessary. Likewise, a network
connection is unlikely in an embedded system, so there is no need
to include the Java networking package.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An <I>embedded system</I> is a scaled-down computer system programmed to perform a particular function within an electronic device.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
It is likely that the Embedded API will consist of the following
packages from the core API: language, utilities, and I/O. Beyond
those, it's possible that Embedded API extensions could be developed
to support specialized networking and output requirements. Since
the Embedded API is itself a subset of the core API, it will probably
be treated as an extension API.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you have learned about the standard extension APIs that
are planned to expand Java in a variety of different directions.
These APIs will no doubt boost the appeal of Java to new levels,
since developers will have much more reusable code to leverage
when building custom applications and applets. Although this will
ultimately mean more learning on the part of developers, it will
also result in less time spent writing code that is best suited
to a standard extension. Knowing this, many developers will be
forced to rethink their current plans based on the availability
of the standard extension APIs, as there's no need to reinvent
the wheel if it's already in the works.
<P>
Tomorrow you'll continue to learn about Java extensions by looking
at some other technologies that are going to affect Java in the
near future.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>What exactly is the core Java API and how will it change?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The core Java API as of Java version 1.02 consists of the eight packages that are shipped with version 1.02 of the Java Developer's Kit. This API will change in future releases to incorporate 
some of the technologies that are emerging as part of the standard extension APIs. However, not all of the standard extension APIs will make it into the core API; some will remain as extensions.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Will the Commerce API help standardize financial transactions on the Web?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>I sure hope so. Considering the large amount of Java development already taking place, combined with JavaSoft's desire to make the Commerce API extensible to a variety of technologies, it 
stands to reason that the Commerce API will be a major force in shaping the future of financial transactions on the Web.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How are servlets developed?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Servlets are developed in much the same way as applets, except you use the Servlet API instead of the Applet API. Most servlets probably won't have graphical interfaces, but the approach of 
developing servlets based on an API is still very similar to the current approach to developing applets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How will digital signatures affect Java security?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>It's still not clear what the total impact of digital signatures will be on Java security, but the most likely change will be the removal of the local file access restriction on applets. Using 
digital signatures, it will be possible to validate the origination of an applet so that users can feel safe allowing the applet more freedom on their system.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch26.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch28.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
