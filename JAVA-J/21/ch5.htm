<HTML>
<HEAD>
<TITLE>Day 5 -- Arrays, Conditionals, and Loops</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;5</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Arrays, Conditionals, and Loops</FONT>
</H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#Arrays">
Arrays</A>
<UL>
<LI><A HREF="#DeclaringArrayVariables">
Declaring Array Variables</A>
<LI><A HREF="#CreatingArrayObjects">
Creating Array Objects</A>
<LI><A HREF="#AccessingArrayElements">
Accessing Array Elements</A>
<LI><A HREF="#ChangingArrayElements">
Changing Array Elements</A>
<LI><A HREF="#MultidimensionalArrays">
Multidimensional Arrays</A>
</UL>
<LI><A HREF="#BlockStatements">
Block Statements</A>
<LI><A HREF="#TTFONTSIZEFACECourierifFONTTTFONTSIZEConditionalsFONT">
<TT>if</TT>
Conditionals</FONT></A>
<UL>
<LI><A HREF="#TheConditionalOperator">
The Conditional Operator</A>
</UL>
<LI><A HREF="#TTFONTSIZEFACECourierswitchFONTTTFONTSIZEConditionalsFONT">
<TT>switch</TT>
Conditionals</FONT></A>
<LI><A HREF="#TTFONTSIZEFACECourierforFONTTTFONTSIZELoopsFONT">
<TT>for</TT>
Loops</FONT></A>
<LI><A HREF="#TTFONTSIZEFACECourierwhileFONTTTFONTSIZEandFONTTTFONTSIZEFACECourierdoFONTTTFONTSIZELoopsFONT">
<TT>while</TT>
and </FONT><TT>do</TT>
Loops</FONT></A>
<UL>
<LI><A HREF="#TTFONTSIZEFACECourierwhileFONTTTFONTSIZELoopsFONT">
<TT>while</TT>
Loops</FONT></A>
<LI><A HREF="#TTFONTSIZEFACECourierdowhileFONTTTFONTSIZELoopsFONT">
<TT>do...while</TT>
Loops</FONT></A>
</UL>
<LI><A HREF="#BreakingOutofLoops">
Breaking Out of Loops</A>
<UL>
<LI><A HREF="#LabeledLoops">
Labeled Loops</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Although you could write Java programs using what you've learned
so far, those programs would be pretty dull. Much of the good
stuff in Java or in any programming language results when you
have arrays to store values in and control-flow constructs (loops
and conditionals) to execute different bits of a program based
on tests. Today, you'll find out about the following:
<UL>
<LI>Arrays, one of the most useful objects in Java, which enable
you to collect objects or primitive types into an easy-to-manage
list
<LI>Block statements, for grouping together related statements
<LI><TT>if</TT> and <TT>switch</TT>,
for conditional tests
<LI><TT>for</TT> and <TT>while</TT>
loops, for iteration or repeating a statement or statements multiple
times
</UL>
<H2><A NAME="Arrays"><FONT SIZE=5 COLOR=#FF0000>
Arrays</FONT></A></H2>
<P>
Arrays in Java, as in other languages, are a way to store collections
of items into a single unit. The array has some number of slots</FONT>,
each of which holds an individual item. You can add and delete
items to those slots as needed. Unlike in other languages, however,
arrays in Java are actual objects that can be passed around and
treated just like other objects.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Time</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An array</FONT> is a collection of items. Each slot in the array can hold an object or a primitive value. Arrays in Java are objects that can be treated just like other objects in the language.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Arrays can contain any type of element value (primitive types
or objects), but you can't store different types in a single array.
You can have an array of integers or an array of strings or an
array of arrays, but you can't have an array that contains, for
example, both strings and integers.
<P>
To create an array in Java, you use three steps:
<OL>
<LI>Declare a variable to hold the array.
<LI>Create a new array object and assign it to the array variable.
<LI>Store things in that array.
</OL>
<H3><A NAME="DeclaringArrayVariables">
Declaring Array Variables</A></H3>
<P>
The first step in creating an array is creating a variable that
will hold the array, just as you would any other variable. Array
variables indicate the type of object the array will hold (just
as they do for any variable) and the name of the array, followed
by empty brackets (<TT>[]</TT>). The
following are all typical array variable declarations:
<BLOCKQUOTE>
<PRE>
String difficultWords[];

Point hits[];

int temps[];
</PRE>
</BLOCKQUOTE>
<P>
An alternate method of defining an array variable is to put the
brackets after the type instead of after the variable. They are
equivalent, but this latter form is often much more readable.
So, for example, these three declarations could be written like
this:
<BLOCKQUOTE>
<PRE>
String[] difficultWords;

Point[] hits;

int[] temps;
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CreatingArrayObjects">
Creating Array Objects</A></H3>
<P>
The second step is to create an array object and assign it to
that variable. There are two ways to do this:
<UL>
<LI>Using <TT>new</TT>
<LI>Directly initializing the contents of that array
</UL>
<P>
The first way is to use the <TT>new</TT>
operator to create a new instance of an array:
<BLOCKQUOTE>
<PRE>
String[] names = new String[10];
</PRE>
</BLOCKQUOTE>
<P>
That line creates a new array of <TT>String</TT>s
with 10 slots (sometimes called elements). When you create a new
array object using <TT>new</TT>, you
must indicate how many slots that array will hold. This line does
not put actual <TT>String</TT> objects
in the slots-you'll have to do that later.
<P>
Array objects can contain primitive types such as integers or
booleans, just as they can contain objects:
<BLOCKQUOTE>
<PRE>
int[] temps = new int[99];
</PRE>
</BLOCKQUOTE>
<P>
When you create an array object using <TT>new</TT>,
all its slots are initialized for you (<TT>0</TT>
for numeric arrays, <TT>false</TT>
for boolean, <TT>'\0'</TT> for character
arrays, and <TT>null</TT> for objects).
You can then assign actual values or objects to the slots in that
array. You can also create an array and initialize its contents
at the same time. Instead of using <TT>new</TT>
to create the new array object, enclose the elements of the array
inside braces, separated by commas:
<BLOCKQUOTE>
<PRE>
String[] chiles = { &quot;jalapeno&quot;, &quot;anaheim&quot;, &quot;serrano&quot;,
    &quot;habanero&quot;, &quot;thai&quot; };<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Note that the Java keyword <TT>null</TT> refers to a null object (and can be used for any object reference). It is not equivalent to zero or the <TT>'\0'</TT> character as the <TT>NULL</TT> constant is in C.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Each of the elements inside the braces must be of the same type
and must be the same type as the variable that holds that array
(the Java compiler will complain if they're not). An array the
size of the number of elements you've included will be automatically
created for you. This example creates an array of <TT>String</TT>
objects named <TT>chiles</TT> that
contains five elements.
<H3><A NAME="AccessingArrayElements">
Accessing Array Elements</A></H3>
<P>
Once you have an array with initial values, you can test and change
the values in each slot of that array. To get at a value stored
within an array, use the array subscript expression (<TT>[]</TT>):
<BLOCKQUOTE>
<PRE>
myArray[subscript];
</PRE>
</BLOCKQUOTE>
<P>
The <TT>myArray</TT> part of this
expression is a variable holding an array object, although it
can also be an expression that results in an array. The <TT>subscript</TT>
part of the expression, inside the brackets, specifies the number
of the slot within the array to access. Array subscripts start
with <TT>0</TT>, as they do in C and
C++. So, an array with 10 elements has 10 array slots accessed
using subscript <TT>0</TT> to <TT>9</TT>.
<P>
Note that all array subscripts are checked when your Java program
is run to make sure that they are inside the boundaries of the
array (greater than or equal to <TT>0</TT>
but less than the array's length). Unlike in C, it is impossible
in Java to access or assign a value to an array slot outside the
boundaries of the array (thereby avoiding a lot of the common
problems and bugs that result from overrunning the bounds of an
array in C-like languages). Note the following two statements,
for example:
<BLOCKQUOTE>
<PRE>
String[] arr = new String[10];
arr[10] = &quot;eggplant&quot;;
</PRE>
</BLOCKQUOTE>
<P>
A program with that last statement in it produces an error at
that line when you try to run it. (Actually, to be more technically
correct, it throws an exception. You'll learn more about exceptions
on <A HREF="ch18.htm">Day 18</A>, &quot;Multithreading.&quot;) The array stored in <TT>arr</TT>
has only 10 slots numbered from <TT>0</TT>,
the element at subscript <TT>10</TT>
doesn't exist.
<P>
If the array subscript is calculated at runtime (for example,
as part of a loop) and ends up outside the boundaries of the array,
the Java interpreter also produces an error.
<P>
How can you keep from accidentally overrunning the end of an array
in your own programs? You can test for the length of the array
in your programs using the <TT>length</TT>
instance variable-it's available for all array objects, regardless
of type:
<BLOCKQUOTE>
<PRE>
int len = arr.length // returns 10
</PRE>
</BLOCKQUOTE>
<P>
However, just to reiterate: The length of the array is <TT>10</TT>,
but its subscript can only go up to <TT>9</TT>.
Arrays start numbering from <TT>0</TT>.
Whenever you work with arrays, keep this in mind and subtract
1 from the length of the array to get its largest element.
<H3><A NAME="ChangingArrayElements">
Changing Array Elements</A></H3>
<P>
To assign an element value to a particular array slot, merely
put an assignment statement after the array access expression:
<BLOCKQUOTE>
<PRE>
myarray[1] = 15;
sentence[0] = &quot;The&quot;;
sentence[10] = sentence[0];
</PRE>
</BLOCKQUOTE>
<P>
An important thing to note is that an array of objects in Java
is an array of references to those objects (similar in some ways
to an array of pointers in C or C++). When you assign a value
to a slot in an array, you're creating a reference to that object,
just as you do for a plain variable. When you move values around
inside arrays (as in that last line), you just reassign the reference;
you don't copy the value from one slot to another. Arrays of primitive
types such as <TT>int</TT>s or <TT>float</TT>s
do copy the values from one slot to another.
<P>
Arrays of references to objects, as opposed to the objects themselves,
are particularly useful because you can have multiple references
to the same objects both inside and outside arrays. For example,
you can assign an object contained in an array to a variable and
refer to that same object by using either the variable or the
array position.
<P>
Got it? Arrays are pretty simple to create and modify, but they
provide an enormous amount of functionality for Java. You'll find
yourself running into arrays a lot the more you use Java.
<P>
To finish up the discussion on arrays, here's a simple program
that shows how to create, initialize, modify, and examine parts
of an array. Listing 5.1 has the code.
<HR>
<BLOCKQUOTE>
<B>Listing 5.1. Various simple array operations.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class ArrayTest {
 2:
 3:    String[] firstNames = { &quot;Dennis&quot;, &quot;Grace&quot;, &quot;Bjarne&quot;, &quot;James&quot; };
 4:    String[] lastNames = new String[firstNames.length];
 5: 
 6:    void printNames() {
 7:      int i = 0;
 8:       System.out.println(firstNames[i] 
 9:          + &quot; &quot; + lastNames[i]);   
10:      i++;
11:       System.out.println(firstNames[i] 
12:         + &quot; &quot; + lastNames[i]);
13:       i++;   
14:       System.out.println(firstNames[i] 
15:          + &quot; &quot; + lastNames[i]);
16:       i++;   
17:      System.out.println(firstNames[i] 
18:          + &quot; &quot; + lastNames[i]);
19:    }
20:   
21:    public static void main (String args[]) {
22:      ArrayTest a = new ArrayTest();
23:       a.printNames();
24:       System.out.println(&quot;----------&quot;);
25:       a.lastNames[0] = &quot;Ritchie&quot;;
26:       a.lastNames[1] = &quot;Hopper&quot;;
27:      a.lastNames[2] = &quot;Stroustrup&quot;;
28:       a.lastNames[3] = &quot;Gosling&quot;;
29:       a.printNames();    
30:   }
31:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Dennis null
Grace null
Bjarne null
James null
----------
Dennis Ritchie
Grace Hopper
Bjarne Stroustrup
James Gosling<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This somewhat verbose example shows you how to create and use arrays. The class we've created here, <TT>ArrayTest</TT>, has two instance variables that hold arrays of <TT>String </TT>objects. The first, called <TT>firstNames</TT>, is declared and 
initialized in the same line (line 3) to contain four strings. The second instance variable, <TT>lastNames</TT>, is declared and created in line 4, but no initial values are placed in the slots. Note also that we created the <TT>lastNames</TT> array to 
have exactly the same number of slots as the <TT>firstNames</TT> array by using the <TT>firstNames.length</TT> variable as the initial array index. The <TT>length</TT> instance variable on array objects returns the number of slots in the array.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>ArrayTest</TT> class also
has two methods: <TT>printNames()</TT>
and <TT>main()</TT>. <TT>printNames()</TT>,
defined in lines 6 through 19, is a utility method that does nothing
but go through the <TT>firstNames</TT>
and <TT>lastNames</TT> arrays sequentially,
printing the values of each slot, one name per line. Note that
the array index we've defined here (<TT>i</TT>)
is initially set to <TT>0</TT> because
Java array slots all start numbering from <TT>0</TT>.
<P>
Finally, there is <TT>main()</TT>,
which performs the actual actions of this example. The <TT>main()</TT>
method here does four things:
<UL>
<LI>Line 22 creates an initial instance of <TT>ArrayTest</TT>,
so we can set and modify its instance variables and call its methods.
<LI>Line 23 calls <TT>printNames()</TT>
to show what the object looks like initially. The result is the
first four lines of the output; note that the <TT>firstNames</TT>
array was initialized, but the values in <TT>lastNames</TT>
are all <TT>null</TT>. If you don't
initialize an array when you declare it, the values of the initial
slots will be empty (or, actually, <TT>null</TT>
for object arrays, <TT>0</TT> for
numbers, and <TT>false</TT> for booleans).
<LI>Lines 25 through 28 set the values of each of the slots in
the <TT>lastNames</TT> array to actual
strings.
<LI>Finally, line 29 calls <TT>printNames()</TT>
once again to show that the <TT>lastNames</TT>
array is now full of values, and each first and last name prints
as you would expect. The results are shown in the last four lines
of the output. 
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Who are the people in this example? They're inventors of computer programming languages. Dennis Ritchie is the inventor of C, Bjarne Stroustrup did C++, Grace Hopper is credited with COBOL, and, finally, James Gosling is the principal designer of 
Java.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
One other note I should make about Listing 5.1 is that it's a
terrible example of programming style. Usually when you deal with
arrays you do not hard code the number of elements into the code
as we have here; instead you use a loop to go through each element
of the array in turn. This makes the code a lot shorter and, in
many cases, easier to read. You'll learn about loops later in
this section, and we'll rewrite this example so that it works
more flexibly.
<H3><A NAME="MultidimensionalArrays">
Multidimensional Arrays</A></H3>
<P>
One last thing to note about arrays before we move on to the rest
of this lesson is about multidimensional arrays. Java does not
directly support multidimensional arrays. However, you can declare
and create an array of arrays (and those arrays can contain arrays,
and so on, for however many dimensions you need) and access the
arrays as you would C-style multidimensional arrays:
<BLOCKQUOTE>
<PRE>
int coords[][] = new int[12][12];
coords[0][0] = 1;
coords[0][1] = 2;
</PRE>
</BLOCKQUOTE>
<H2><A NAME="BlockStatements"><FONT SIZE=5 COLOR=#FF0000>
Block Statements</FONT></A></H2>
<P>
Before we launch into the last two-thirds of this lesson, let's
take a small detour into a topic I haven't mentioned a whole lot
up to this point (but that will be important later on): block
statements. 
<P>
A block statement is simply a group of Java statements surrounded
by braces (<TT>{}</TT>). You've seen
blocks a whole lot already; you've used a block statement to contain
the variables and methods in a class definition, and inside that
block you've also used blocks to hold the body of a method definition.
The opening brace opens the block, and the closing brace closes
the nearest closing block. Easy, right?
<P>
You can also use blocks even further, inside method definitions.
The rule is that you can use a block anywhere a single statement
would go. Each statement inside the block is then executed sequentially.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A block statement</FONT> is a group of individual Java statements enclosed in braces (<TT>{}</TT>). You can put a block statement anywhere a single statement can go.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
So what's the difference between using a group of individual statements
and using a block? The block creates a new local variable scope
for the statements inside it. This means that you can declare
and use local variables inside a block, and those variables will
cease to exist after the block is finished executing. For example,
here's a block inside a method definition that declares a new
variable <TT>y</TT>. You cannot use
<TT>y</TT> outside the block in which
it's declared:
<BLOCKQUOTE>
<PRE>
void testblock() {
    int x = 10;
    { // start of block
      int y = 50;
      System.out.println(&quot;inside the block:&quot;);
      System.out.println(&quot;x:&quot; + x);
      System.out.println(&quot;y:&quot; + y);
    } // end of block
}
</PRE>
</BLOCKQUOTE>
<P>
Blocks are not usually used in this way-alone in a method definition,
with random variable declarations inside them. You've mostly seen
blocks up to this point surrounding class and method definitions,
but another very common use of block statements is in the control
flow constructs you'll learn about in the remainder of today's
lesson.
<H2><A NAME="TTFONTSIZEFACECourierifFONTTTFONTSIZEConditionalsFONT"><FONT SIZE=5 COLOR=#FF0000>
<TT>if</TT>
Conditionals</FONT></FONT></A></H2>
<P>
The <TT>if</TT> conditional statement
is used when you want to execute different bits of code based
on a simple test. <TT>if</TT> conditions
are nearly identical to <TT>if</TT>
statements in C: They contain the keyword <TT>if</TT>,
followed by a boolean test, followed by either a single statement
or a block statement to execute if the test is <TT>true</TT>.
Here's a simple example that prints the message <TT>x
is smaller than y</TT> only if the value of <TT>x</TT>
is less than the value of <TT>y</TT>:
<BLOCKQUOTE>
<PRE>
if (x &lt; y)
    System.out.println(&quot;x is smaller than y&quot;);
</PRE>
</BLOCKQUOTE>
<P>
An optional <TT>else</TT> keyword
provides the alternative statement to execute if the test is <TT>false</TT>:
<BLOCKQUOTE>
<PRE>
if (x &lt; y)
    System.out.println(&quot;x is smaller than y&quot;);
else System.out.println(&quot;y is bigger&quot;);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>if</TT> conditional</FONT> executes different bits of code based on the result of a single boolean test.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The difference between <TT>if</TT> conditionals in Java and C or C++ is that the test must return a boolean value (<TT>true</TT> or <TT>false</TT>). Unlike in C, the test cannot return an integer.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Using <TT>if</TT>, you can only include
a single statement as the code to execute after the test (in this
case, the <TT>System.out.println()</TT>
method for each one). But because a block can appear anywhere
a single statement can, if you want to do more than just one thing
(as you usually will), you can enclose those statements inside
a block:
<BLOCKQUOTE>
<PRE>
if (engineState == true ) 
    System.out.println(&quot;Engine is already on.&quot;);
else {
    System.out.println(&quot;Now starting Engine.&quot;);
    if (gasLevel &gt;= 1)
        engineState = true;
    else System.out.println(&quot;Low on gas! Can't start engine.&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
This example uses the test <TT>(engineState
== true)</TT>. For boolean tests of this type, a common
shortcut is merely to include the first part of the expression
rather than explicitly test its value against <TT>true</TT>
or <TT>false</TT>. Because it's a
boolean variable, it automatically returns <TT>true</TT>
or <TT>false</TT> all by itself, so
you don't have to explicitly test it for that value. Here's a
shorter version of the previous code, with the test replaced with
the shorthand version:
<BLOCKQUOTE>
<PRE>
if (engineState)
    System.out.println(&quot;Engine is on.&quot;);
else System.out.println(&quot;Engine is off.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Listing 5.2 shows another simple example-this one in full application
form. The <TT>Peeper</TT> class contains
one utility method called <TT>peepMe()</TT>,
which tests a value to see if it's even. If it is, it prints <TT>Peep!</TT>
to the screen.
<HR>
<BLOCKQUOTE>
<B>Listing 5.2. The </B><TT><B>Peeper</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class Peeper {
 2:
 3:    void peepMe(int val) {
 4:       System.out.println(&quot;Value is &quot; 
 5:          + val + &quot;. &quot;);
 6:       if (val % 2 == 0) 
 7:         System.out.println(&quot;Peep!&quot;);
 8:    }
 9:    
10:   public static void main (String args[]) {
11:      Peeper p = new Peeper();
12:      
13:       p.peepMe(1);      
14:       p.peepMe(2);
15:        p.peepMe(54);
16:       p.peepMe(77);
17:      p.peepMe(1346);
18:    }
19: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Value is 1.
Value is 2.
Peep!
Value is 54.
Peep!
Value is 77.
Value is 1346.
Peep!<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The heart of the <TT>Peeper</TT> class is the <TT>peepMe()</TT> method (lines 3 through 8), where values are tested and an appropriate message is printed. Unlike the methods you've defined in previous examples, note that the definition of <TT>peepMe()</TT> 
includes a single integer argument (see line 3). The <TT>peepMe()</TT> method starts by printing out the value that was passed to it. Then that argument is tested, using an <TT>if</TT> conditional, to see if it's an even number. (The modulus test, as 
you'll remember from <A HREF="ch3.htm">Day 3</A>, &quot;Java Basics,&quot; returns the remainder of the division of its operands. So if the remainder of a number divided by 2 is 0, it's an even number.) If the number is even, <TT>Peep!</TT> is printed 
(you'll learn more about defining methods with arguments tomorrow).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
We'll use a<TT> main()</TT> method,
as always, in this application to create a new instance of <TT>Peeper</TT>
and test it, calling the <TT>peepMe()</TT>
method repeatedly with different values. In the output,  only
the values that are even get a <TT>Peep!</TT>
message.
<H3><A NAME="TheConditionalOperator">
The Conditional Operator</A></H3>
<P>
An alternative to using the <TT>if</TT>
and <TT>else</TT> keywords in a conditional
statement is to use the conditional
operator</FONT>, sometimes called the ternary
operator</FONT> (ternary</FONT>
means three; the conditional operator has three parts).
<P>
The conditional operator is an expression, meaning that it returns
a value (unlike the more general <TT>if</TT>,
which can only result in a statement or block being executed).
The conditional operator is most useful for very short or simple
conditionals and looks like this:
<BLOCKQUOTE>
<PRE>
<I>test</I> ? </FONT><I>trueresult</I> : </FONT><I>falseresult;</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
<TT><I>test</I></TT> is a boolean
expression that returns <TT>true</TT>
or <TT>false</TT>, just like the test
in the <TT>if</TT> statement. If the
test is <TT>true</TT>, the conditional
operator returns the value of <TT><I>trueresult</I></TT>;
if it's <TT>false</TT>, it returns
the value of <TT><I>falseresult</I></TT>.
For example, the following conditional tests the values of <TT>x</TT>
and <TT>y</TT>, returns the smaller
of the two, and assigns that value to the variable <TT>smaller</TT>:
<BLOCKQUOTE>
<PRE>
int smaller = x &lt; y ? x : y;
</PRE>
</BLOCKQUOTE>
<P>
The conditional operator has a very low precedence; that is, it's
usually evaluated only after all its subexpressions are evaluated.
The only operators lower in precedence are the assign-ment operators.
See the precedence chart in <A HREF="ch3.htm">Day 3</A>'s lesson for a refresher on
precedence of all the operators.
<H2><A NAME="TTFONTSIZEFACECourierswitchFONTTTFONTSIZEConditionalsFONT"><FONT SIZE=5 COLOR=#FF0000>
<TT>switch</TT>
Conditionals</FONT></FONT></A></H2>
<P>
A common programming practice in any language is to test a variable
against some value, and if it doesn't match that value, to test
it again against a different value, and if it doesn't match that
one to make yet another test, and so on until it matches with
the right result. Using only <TT>if</TT>
statements, this can become unwieldy, depending on how it's formatted
and how many different options you have to test. For example,
you might end up with a set of <TT>if</TT>
statements something like this or longer:
<BLOCKQUOTE>
<PRE>
if (oper == '+')
  addargs(arg1, arg2);
else if (oper == '-')
   subargs(arg1, arg2);
else if (oper == '*')
   multargs(arg1, arg2);
else if (oper == '/')
   divargs(arg1, arg2);
</PRE>
</BLOCKQUOTE>
<P>
This form of <TT>if</TT> statement
is called a nested</FONT> <TT>if</TT>
because each <TT>else</TT> statement
in turn contains yet another <TT>if</TT>,
and so on, until all possible tests have been made.
<P>
Many languages have a shorthand version of the nested <TT>if</TT>
that is (somewhat) easier to read and allows you to group the
tests and actions. Called a <TT>switch</TT>
or <TT>case</TT> statement, in Java
it's called <TT>switch</TT> and behaves
as it does in C:
<BLOCKQUOTE>
<PRE>
switch (test) {
    case valueOne:     
      resultOne;
      break;
    case valueTwo:     
      resultTwo;
      break;
    case valueThree:   
      resultThree;
      break;
    ...
    default: defaultresult;
}
</PRE>
</BLOCKQUOTE>
<P>
In the <TT>switch</TT> statement,
the test</FONT> (a variable or expression
that evaluates to a <TT>byte</TT>,
<TT>char</TT>, <TT>short</TT>,
or <TT>int</TT>) is compared with
each of the case values (<TT>valueOne</TT>,
<TT>valueTwo</TT>, and so on) in turn.
If a match is found, the statement (or statements) after the test
is executed. If no match is found, the <TT>default</TT>
statement is executed. The <TT>default</TT>
is optional, so if there isn't a match in any of the cases and
<TT>default</TT> doesn't exist, the
<TT>switch</TT> statement completes
without doing anything.
<P>
Note that the significant limitation of the <TT>switch</TT>
in Java is that the tests and values can be only simple primitive
types (and then only primitive types that are automatically castable
to <TT>int</TT>). You cannot use larger
primitive types (<TT>long</TT>, <TT>float</TT>),
strings, or other objects within a <TT>switch</TT>,
nor can you test for any relationship other than simple equality.
This limits the usefulness of <TT>switch</TT>;
nested <TT>if</TT>s can work for any
kind of test on any type.
<P>
Here's a simple example of a <TT>switch</TT>
statement similar to the nested <TT>if</TT>
shown earlier:
<BLOCKQUOTE>
<PRE>
switch (oper) {
    case '+':
        addargs(arg1, arg2);
        break;
    case '-':
        subargs(arg1, arg2);
        break;
    case '*':
        multargs(arg1, arg2);
        break;
    case '/':
        divargs(arg1, arg2);
        break;
 }
</PRE>
</BLOCKQUOTE>
<P>
There are two things to be aware of in this example: The first
is that after each case, you can include a single result statement
or as many as you need. Unlike with <TT>if</TT>,
you don't need to surround multiple statements with braces for
it to work. The second thing to note about this example is the
<TT>break</TT> statement included
at the end of every case. Without the explicit break, once a match
is made, the statements for that match (and
also</FONT> all the statements further down in the <TT>switch</TT>
for all the other cases) are executed until a <TT>break</TT>
or the end of the <TT>switch</TT>
is found. In some cases, this may be exactly what you want to
do, but in most cases, you'll want to make sure to include the
<TT>break</TT> so that only the statements
you want to be executed are actually executed (break, which you'll
learn about in the section &quot;Breaking Out of Loops,&quot;
stops execution at the current point and jumps to the code outside
of the next closing bracket (<TT>})</TT>).
<P>
One handy use of allowing a <TT>switch</TT>
to continue processing statements after a match is found occurs
when you want multiple values to match to the same statements.
In this instance, you can use multiple case lines with no result,
and the <TT>switch</TT> will execute
the first statement it finds. For example, in the following <TT>switch</TT>
statement, the string <TT>&quot;x is an even
number.&quot;</TT> is printed if <TT>x</TT>
has a value of <TT>2</TT>, <TT>4</TT>,
<TT>6</TT>, or <TT>8</TT>.
All other values of <TT>x</TT> print
the string <TT>&quot;x is an odd number.&quot;</TT>:
<BLOCKQUOTE>
<PRE>
switch (x) {
    case 2:
    case 4:
    case 6:
    case 8: 
       System.out.println(&quot;x is an even number.&quot;);
       break;
    default: System.out.println(&quot;x is an odd number.&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
Listing 5.3 shows yet another example of a <TT>switch</TT>.
This class, called <TT>NumberReader</TT>,
converts integer values to their actual English word equivalents
using a method called <TT>convertIt()</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 5.3. The </B><TT><B>NumberReader</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class NumberReader {
 2:
 3:    String convertNum(int val) {
 4:       switch (val) {
 5:          case 0: return &quot;zero &quot;;
 6:          case 1: return &quot;one &quot;;
 7:         case 2: return &quot;two &quot;;
 8:          case 3: return &quot;three &quot;;
 9:          case 4: return &quot;four &quot;;
10:         case 5: return &quot;five &quot;;
11:         case 6: return &quot;six &quot;;
12:         case 7: return &quot;seven &quot;;
13:          case 8: return &quot;eight &quot;;
14:          case 9: return &quot;nine &quot;;
15:          default: return &quot; &quot;;
16:       }
17:   }
18:    
19:    public static void main (String args[]) {
20:      NumberReader n = new NumberReader();
21:      String num = n.convertNum(4) + n.convertNum(1)  + n.convertNum(5);
22:      System.out.println(&quot;415 converts to &quot; + num);
23:   }
24:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
415 converts to four one five<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The heart of this example is, of course, the main switch statement in the middle  of the convert Num ( ) method in lines 4 through 16. This switch statement takes the integer argument that was passed into convert Nm ( ) and, when it finds a match, returns 
the appropriate string value. (Note that this method is defined to return a string as opposed to the other methods you've defined up to this point, which didn't return anything. You'll learn more about this tomorrow.)</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
So where are the <TT>break</TT> statements?
You don't need them here because you're using <TT>return</TT>
instead. <TT>return</TT> is similar
to <TT>break</TT> except that it breaks
out of the entire method definition and returns a single value.
Again, you'll learn more about this tomorrow when you learn all
about how to define methods. 
<P>
At this point you've probably seen enough <TT>main()</TT>
methods to know what's going on, but let's run through this one
quickly.
<P>
Line 20 creates a new instance of the <TT>NumberReader</TT>
class.
<P>
Line 21 defines a string called <TT>num</TT>
that will be the concatenation of the string values of three numbers.
Each number is converted using a call to the <TT>convertNum()</TT>
method.
<P>
Finally, line 22 prints out the result.
<H2><A NAME="TTFONTSIZEFACECourierforFONTTTFONTSIZELoopsFONT"><FONT SIZE=5 COLOR=#FF0000>
<TT>for</TT>
Loops</FONT></FONT></A></H2>
<P>
The <TT>for</TT> loop, as in C, repeats
a statement or block of statements until a condition is matched.
<TT>for</TT> loops are frequently
used for simple iterations in which you repeat a block of statements
a certain number of times and then stop, but you can use <TT>for</TT>
loops for just about any kind of loop.
<P>
The <TT>for</TT> loop in Java looks
roughly like this:
<BLOCKQUOTE>
<PRE>
for (initialization; test; increment) {
    statements;
}
</PRE>
</BLOCKQUOTE>
<P>
The start of the <TT>for</TT> loop
has three parts:
<UL>
<LI><TT>initialization</TT> is an
expression that initializes the start of the loop. If you have
a loop index variable to keep track of how many times the loop
has occurred, this expression might declare and initialize it-for
example, <TT>int i = 0</TT>. Variables
that you declare in this part of the <TT>for</TT>
loop are local to the loop itself; they cease existing after the
loop is finished executing.
<LI><TT>test</TT> is the test that
occurs before each pass of the loop. The test must be a boolean
expression or function that returns a boolean value-for example,
<TT>i &lt; 10</TT>. If the test is
<TT>true</TT>, the loop executes.
Once the test is <TT>false</TT>, the
loop stops executing.
<LI><TT>increment</TT> is any expression
or function call. Commonly, the increment is used to change the
value of the loop index to bring the state of the loop closer
to returning <TT>false</TT> and completing.
</UL>
<P>
The statement part of the <TT>for</TT>
loop is the statements that are executed each time the loop iterates.
Just as with <TT>if</TT>, you can
only include one statement, although a block will work just fine
as well. 
<P>
Remember the example in the section on arrays where I said that
iterating over the contents of an array is usually done with a
loop? Here's an example of a <TT>for</TT>
loop that does just that-it initializes all the values of a <TT>String</TT>
array to null strings:
<BLOCKQUOTE>
<PRE>
String strArray[] = new String[10]; \\ the array
int i; // loop index

for (i = 0; i &lt; strArray.length; i++)
    strArray[i] = &quot;&quot;;
</PRE>
</BLOCKQUOTE>
<P>
In this example, the variable <TT>I</TT>
keeps track of the number of times the loop has occurred; it also
makes a convenient index for the array itself. Here, we start
the <TT>for</TT> loop with an index
of <TT>I</TT>. The test for when the
<TT>for</TT> loop will end is whether
the current index is less than the length of the array (once the
index is bigger than the array, you should stop), and the increment
is simply to add 1 to the index each time. Then, for every loop
you can put a null string (<TT>&quot;&quot;</TT>)
into the array at the given slot.
<P>
Any of the parts of the <TT>for</TT>
loop can be empty statements; that is, you can simply include
a semicolon with no expression or statement, and that part of
the <TT>for</TT> loop will be ignored.
Note that if you do use a null statement in your <TT>for</TT>
loop, you may have to initialize or increment any loop variables
or loop indices yourself elsewhere in the program.
<P>
You can also have an empty statement for the body of your <TT>for</TT>
loop, if everything you want to do is in the first line of that
loop. For example, here's one that finds the first prime number
higher than 4000 (it calls a method called <TT>notPrime()</TT>,
which will theoretically have a way of figuring that out):
<BLOCKQUOTE>
<PRE>
for (i = 4001; notPrime(i); i += 2)
    ;
</PRE>
</BLOCKQUOTE>
<P>
Note that a common mistake in C that also occurs in Java is to
accidentally put a semicolon after the first line of the <TT>for</TT>
loop:
<BLOCKQUOTE>
<PRE>
for (i = 0; i &lt; 10; i++);
    System.out.println(&quot;Loop!&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Because the first semicolon ends the loop with an empty statement,
the loop doesn't actually do anything. The <TT>println()</TT>
function will be printed only once because it's actually outside
the <TT>for</TT> loop entirely. Be
careful not to make this mistake in your own Java programs.
<P>
To finish up <TT>for</TT> loops, let's
rewrite that example with the names from the array section. The
original example is long and repetitive and only works with an
array four elements long. This version, shown in Listing 5.4,
is shorter and more flexible (but it returns the same output).
<HR>
<BLOCKQUOTE>
<B>Listing 5.4. A modified array test with loops.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class NamesLoop {
 2:
 3:    String[] firstNames = { &quot;Dennis&quot;, &quot;Grace&quot;, &quot;Bjarne&quot;, &quot;James&quot; };
 4:    String[] lastNames = new String[firstNames.length];
 5: 
 6:    void printNames() {
 7:      for (int i = 0; i &lt; firstNames.length; i++) 
 8:          System.out.println(firstNames[i] + &quot; &quot; + lastNames[i]);   
 9:    }
10:   
11:   public static void main (String args[]) {
12:      ArrayTest a = new ArrayTest();
13:       a.printNames();
14:       System.out.println(&quot;----------&quot;);
15:       a.lastNames[0] = &quot;Ritchie&quot;;
16:       a.lastNames[1] = &quot;Hopper&quot;;
17:      a.lastNames[2] = &quot;Stroustrup&quot;;
18:       a.lastNames[3] = &quot;Gosling&quot;;
19:       
20:      a.printNames();    
21:}
22:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Dennis null
Grace null
Bjarne null
James null
----------
Dennis Ritchie
Grace Hopper
Bjarne Stroustrup
James Gosling<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The only difference between this example and Listing 5.1 is in the <TT>printNames()</TT> method. Instead of going through the array slots one by one, this example uses a <TT>for</TT> loop to iterate through the array one slot at a time, stopping at the 
last element in the array. Using a more general-purpose loop to iterate over an array allows you to use <TT>printNames()</TT> for any array of any size and still have it print all the elements.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TTFONTSIZEFACECourierwhileFONTTTFONTSIZEandFONTTTFONTSIZEFACECourierdoFONTTTFONTSIZELoopsFONT"><FONT SIZE=5 COLOR=#FF0000>
<TT>while</TT>
and </FONT><TT>do</TT>
Loops</FONT></FONT></A></H2>
<P>
Finally, there are <TT>while</TT>
and <TT>do</TT> loops. <TT>while</TT>
and <TT>do</TT> loops, like <TT>for</TT>
loops, repeat the execution of a block of Java code until a specific
condition is met. Whether you use a <TT>for</TT>
loop, a <TT>while</TT>, or a <TT>do</TT>
is mostly a matter of your programming style.
<P>
<TT>while</TT> and <TT>do</TT>
loops are exactly the same as in C and C++ except that their test
conditions must be booleans.
<H3><A NAME="TTFONTSIZEFACECourierwhileFONTTTFONTSIZELoopsFONT">
<TT>while</TT>
Loops</FONT></A></H3>
<P>
The <TT>while</TT> loop is used to
repeat a statement or block of statements as long as a particular
condition is <TT>true</TT>. <TT>while</TT>
loops look like this:
<BLOCKQUOTE>
<PRE>
while (<I>condition</I>) {
    bodyOfLoop;
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>condition</I></TT> is a
boolean<FONT SIZE=2> test because it is in the </FONT><TT>if</TT><FONT SIZE=2>
and </FONT><TT>for</TT><FONT SIZE=2>
constructions. If the test returns </FONT><TT>true</TT>,
the <TT>while</TT> loop executes the
statements in <TT>bodyOfLoop</TT>
and then tests the condition again, repeating until the condition
is <TT>false</TT>. I've shown the
<TT>while</TT> loop here with a block
statement because it's most commonly used, although you can use
a single statement in place of the block.
<P>
Listing 5.5 shows an example of a <TT>while</TT>
loop that copies the elements of an array of integers (in <TT>array1</TT>)
to an array of <TT>float</TT>s (in
<TT>array2</TT>), casting each element
to a <TT>float</TT> as it goes. The
one catch is that if any of the elements in the first array is
<TT>0</TT>, the loop will immediately
exit at that point.
<HR>
<BLOCKQUOTE>
<B>Listing 5.5. </B><TT><B>while</B></TT><B>
loops to copy array elements.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class CopyArrayWhile {
 2:   public static void main (String args[]) {
 3:       int[] array1 = { 5, 7, 3, 6, 0, 3, 2, 1 };
 4:       float[] array2 = new float[array1.length];
 5:       
 6:        System.out.print(&quot;array1: [ &quot;);
 7:       for (int i = 0; i &lt; array1.length; i++) {
 8:          System.out.print(array1[i] + &quot; &quot;);
 9:        }
10:       System.out.println(&quot;]&quot;);
11:   
12:       System.out.print(&quot;array2: [ &quot;);
13:       int count = 0;
14:       while ( count &lt; array1.length &amp;&amp; array1[count] != 0) {   
15:              array2[count] = (float) array1[count];
16:              System.out.print(array2[count++] + &quot; &quot;);
17:      }
18:        System.out.println(&quot;]&quot;);
19:    }
20:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
array1: [ 5 7 3 6 0 3 2 1 ]
array2: [ 5 7 3 6 ]
</PRE>
</BLOCKQUOTE>
<P>
I've done all the work here in <TT>main()</TT>
to make things shorter. Here's what's going on here:
<P>
Lines 3 and 4, declare the arrays; <TT>array1</TT>
is an array of <TT>int</TT>s, which
I've initialized to some suitable numbers. <TT>array2</TT>,
or <TT>float</TT>s, is the same length
as <TT>array1</TT>, but doesn't have
any initial values.
<P>
Lines 6 through 10 are for output purposes; they simply iterate
through <TT>array1</TT> using a <TT>for</TT>
loop to print out its values.
<P>
Lines 13 through 17 are where the interesting stuff happens. This
bunch of statements both assigns the values of <TT>array2</TT>
(converting the numbers to floats along the array) and prints
it out at the same time. We start with a <TT>count</TT>
variable, which keeps track of the array index elements. The test
in the <TT>while</TT> loop keeps track
of the two conditions for existing the loop, where those two conditions
are running out of elements in <TT>array1</TT>
or encountering a <TT>0</TT> in <TT>array1</TT>
(remember, that was part of the original description of what this
program does). We can use the logical conditional <TT>&amp;&amp;</TT>
to keep track of the test; remember that <TT>&amp;&amp;</TT>
makes sure both conditions are <TT>true</TT>
before the entire expression is <TT>true</TT>.
If either one is <TT>false</TT>, the
expression returns <TT>false</TT>
and the loop exits.
<P>
So what goes on in this particular example? The output shows that
the first four elements in <TT>array1</TT>
were copied to <TT>array2</TT>, but
there was a <TT>0</TT> in the middle
that stopped the loop from going any further. Without the <TT>0</TT>,
<TT>array2</TT> should end up with
all the same elements as <TT>array1</TT>.
<P>
Note that if the <TT>while</TT> loop's
test is initially <TT>false</TT> the
first time it is tested (for example, if the first element in
that first array is <TT>0</TT>), the
body of the <TT>while</TT> loop will
never be executed. If you need to execute the loop at least once,
you can do one of two things:
<UL>
<LI>Duplicate the body of the loop outside the <TT>while</TT>
loop.
<LI>Use a <TT>do</TT> loop (which
is described in the following section).
<LI>The <TT>do</TT> loop is considered
the better solution of the two.
</UL>
<H3><A NAME="TTFONTSIZEFACECourierdowhileFONTTTFONTSIZELoopsFONT">
<TT>do...while</TT>
Loops</FONT></A></H3>
<P>
The <TT>do</TT> loop is just like
a <TT>while</TT> loop, except that
<TT>do</TT> executes a given statement
or block until the condition is <TT>false</TT>.
The main difference is that <TT>while</TT>
loops test the condition before looping, making it possible that
the body of the loop will never execute if the condition is <TT>false</TT>
the first time it's tested. <TT>do</TT>
loops run the body of the loop at least once before testing the
condition. <TT>do</TT> loops look
like this:
<BLOCKQUOTE>
<PRE>
do {
    bodyOfLoop;
} while (<I>condition</I>);
</PRE>
</BLOCKQUOTE>
<P>
Here, the <TT>bodyOfLoop</TT> part
is the statements that are executed with each iteration. It's
shown here with a block statement because it's most commonly used
that way, but you can substitute the braces for a single statement
as you can with the other control-flow constructs. The condition
is a boolean test. If it returns <TT>true</TT>,
the loop is run again. If it returns <TT>false</TT>,
the loop exits. Keep in mind that with <TT>do</TT>
loops, the body of the loop executes at least once.
<P>
Listing 5.6 shows a simple example of a <TT>do</TT>
loop that prints a message each time the loop iterates (10 times,
for this example):
<HR>
<BLOCKQUOTE>
<B>Listing 5.6. A simple </B><TT><B>do</B></TT><B>
loop.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class DoTest {
 2:    public static void main (String args[]) {
 3:      int x = 1;
 4:  
 5:      do {
 6:        System.out.println(&quot;Looping, round &quot; + x);
 7:        x++;
 8:      } while (x &lt;= 10);
 9:    }
10: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Looping, round 1
Looping, round 2
Looping, round 3
Looping, round 4
Looping, round 5
Looping, round 6
Looping, round 7
Looping, round 8
Looping, round 9
Looping, round 10
</PRE>
</BLOCKQUOTE>
<H2><A NAME="BreakingOutofLoops"><FONT SIZE=5 COLOR=#FF0000>
Breaking Out of Loops</FONT></A></H2>
<P>
In all the loops (<TT>for</TT>, <TT>while</TT>,
and <TT>do</TT>), the loop ends when
the condition you're testing for is met. What happens if something
odd occurs within the body of the loop and you want to exit the
loop early? For that, you can use the <TT>break</TT>
and <TT>continue</TT> keywords.
<P>
You've already seen <TT>break</TT>
as part of the <TT>switch</TT> statement;
it stops execution of the <TT>switch</TT>,
and the program continues. The <TT>break</TT>
keyword, when used with a loop, does the same thing-it immediately
halts execution of the current loop. If you've nested loops within
loops, execution picks up in the next outer loop; otherwise, the
program merely continues executing the next statement after the
loop.
<P>
For example, take that <TT>while</TT>
loop that copied elements from an integer array into an array
of floats until the end of the array or until a <TT>0</TT>
is reached. You can instead test for that latter case inside the
body of the <TT>while</TT> and then
use a <TT>break</TT> to exit the loop:
<BLOCKQUOTE>
<PRE>
int count = 0;
while (count &lt; array1.length) {
    if (array1[count] == 0) {
        break;
    }
    array2[count] = (float) array1[count++];
}
</PRE>
</BLOCKQUOTE>
<P>
<TT>continue</TT> is similar to <TT>break</TT>
except that instead of halting execution of the loop entirely,
the loop starts over at the next iteration. For <TT>do</TT>
and <TT>while</TT> loops, this means
that the execution of the block starts over again; for <TT>for</TT>
loops, the increment and test expressions are evaluated and then
the block is executed. <TT>continue</TT>
is useful when you want to special-case elements within a loop.
With the previous example of copying one array to another, you
can test for whether the current element is <TT>0</TT>
and restart the loop if you find it so that the resulting array
will never contain zero. Note that because you're skipping elements
in the first array, you now have to keep track of two different
array counters:
<BLOCKQUOTE>
<PRE>
int count1 = 0;
int count2 = 0;
while (count &lt; array1.length) {
    if (array1[count1] == 0)  {
       continue;
        count1++
    }
    array2[count2++] = (float)array1[count1++];
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="LabeledLoops">
Labeled Loops</A></H3>
<P>
Both <TT>break</TT> and <TT>continue</TT>
can have an optional label that tells Java where to break to.
Without a label, <TT>break</TT> jumps
outside the nearest loop (to an enclosing loop or to the next
statement outside the loop), and <TT>continue</TT>
restarts the enclosing loop. Using labeled <TT>break</TT>s
and <TT>continue</TT>s, you can break
to specific points outside nested loops or continue a loop outside
the current loop.
<P>
To use a labeled loop, add the label before the initial part of
the loop, with a colon between them. Then, when you use <TT>break</TT>
or <TT>continue</TT>, add the name
of the label after the keyword itself:
<BLOCKQUOTE>
<PRE>
out:
    for (int i = 0; i &lt;10; i++) {
        while (x &lt; 50) {
            if (i * x == 400)
                break out;
            ...
        }
        ...
    }
</PRE>
</BLOCKQUOTE>
<P>
In this snippet of code, the label <TT>out</TT>
labels the outer loop. Then, inside both the <TT>for</TT>
and the <TT>while</TT> loops, when
a particular condition is met, a <TT>break</TT>
causes the execution to break out of both loops and continue executing
any code after both loops.
<P>
Here's another example: The program shown in Listing 5.7 contains
a nested <TT>for</TT> loop. Inside
the innermost loop, if the summed values of the two counters is
greater than 4, both loops exit at once.
<HR>
<BLOCKQUOTE>
<B>Listing 5.7. A labeled loop example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class LabelTest {
 2:    public static void main (String arg[]) {
 3:  
 4:      foo: 
 5:      for (int i = 1; i &lt;= 5; i++)
 6:        for (int j = 1; j &lt;= 3; j++) {
 7:           System.out.println(&quot;i is &quot; + i + &quot;, j is &quot; + j);
 8:           if (( i + j) &gt; 4) 
 9:           break foo;
10:        }
11:      System.out.println(&quot;end of loops&quot;);
12:    }
13:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
i is 1, j is 1
i is 1, j is 2
i is 1, j is 3
i is 2, j is 1
i is 2, j is 2
i is 2, j is 3
end of loops
</PRE>
</BLOCKQUOTE>
<P>
As you can see, the loop iterated until the sum of <TT>i</TT>
and <TT>j</TT> was greater than <TT>4</TT>,
and then both loops exited back to the outer block and the final
message was printed.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you have learned about three main topics that you'll most
likely use quite often in your own Java programs: arrays, conditionals,
and loops.
<P>
You have learned how to declare an array variable, create and
assign an array object to that variable, and access and change
elements within that array.
<P>
Conditionals include the <TT>if</TT>
and <TT>switch</TT> statements, with
which you can branch to different parts of your program based
on a boolean test.
<P>
Finally, you have learned about the <TT>for</TT>,
<TT>while</TT>, and <TT>do</TT>
loops, each of which enable you to execute a portion of your program
repeatedly until a given condition is met.
<P>
Now that you've learned the small stuff, all that's left is to
go over the bigger issues of declaring classes and creating methods
within which instances of those classes can communicate with each
other by calling methods. Get to bed early tonight, because tomorrow
is going to be a wild ride.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>If arrays are objects, and you use <TT><B>new</B></TT> to create them, and they have an instance variable length, where is the <TT><B>Array</B></TT> class? I didn't see it in the Java class 
libraries.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Arrays are implemented kind of weirdly in Java. The <TT>Array</TT> class is constructed automatically when your Java program runs; <TT>Array</TT> provides the basic framework for arrays, 
including the <TT>length</TT> variable. Additionally, each primitive type and object has an implicit subclass of <TT>Array</TT> that represents an array of that class or object. When you create a new array object, it may not have an actual class, but it 
behaves as if it does.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>When you create an array, you have to give it the number of slots that the array has. What happens if you get halfway through your program and you've run out of slots in the array? Does the 
array get bigger automatically?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>No, arrays stay the same size throughout their existence. And, as I noted in the part of this lesson on arrays, you cannot access slots outside the bounds of the array, so adding extra elements 
to a full array will cause an error.
<P>
So what do you do if an array is full? You have to do it the hard way: Create a new array that's bigger than the initial one and copy all the elements from the old array to the new.<P>
Optionally, you can use a data structure other than an array if you expect to have widely varying numbers of elements in the array. The <TT>Vector</TT> class, part of the <TT>java.util</TT> package, is a growable collection you can use in place of an 
array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Does Java have <TT><B>goto</B></TT>s?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The Java language defines the keyword <TT>goto</TT>, but it is not currently used for anything. In other words, no-Java does not have <TT>goto</TT>s.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I declared a variable inside a block statement for an <TT><B>if</B></TT>. When the <TT><B>if</B></TT> was done, the definition of that variable vanished. Where did it go?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>In technical terms, block statements form a new lexical scope. What this means is that if you declare a variable inside a block, it's only visible and usable inside that block. When the block 
finishes executing, all the variables you declared go away.
<P>
It's a good idea to declare most of your variables in the outermost block in which they'll be needed-usually at the top of a block statement. The exception might be very simple variables, such as index counters in <TT>for</TT> loops, where declaring them 
in the first line of the <TT>for</TT> loop is an easy shortcut. 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Why can't you use <TT><B>switch</B></TT> with strings?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Strings are objects, and <TT>switch</TT> in Java works only for the primitive types <TT>byte</TT>, <TT>char</TT>, <TT>short</TT>, and <TT>int</TT>. To compare strings, you have to use nested 
<TT>if</TT>s, which enable more general expression tests, including string comparison.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>It seems to me that a lot of <TT><B>for</B></TT> loops could be written as <TT><B>while</B></TT> loops, and vice versa.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>True. The <TT>for</TT> loop is actually a special case of <TT>while</TT> that enables you to iterate a loop a specific number of times. You could just as easily do this with a <TT>while</TT> 
and then increment a counter inside the loop. Either works equally well. This is mostly just a question of programming style and personal choice.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch4.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch6.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
