<HTML>
<HEAD>
<TITLE>Day 6 --Creating Classes and Applications in Java
</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;6</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Creating Classes and Applications
in Java</FONT></H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#DefiningClasses">
Defining Classes</A>
<LI><A HREF="#CreatingInstanceandClassVariables">
Creating Instance and Class Variables</A>
<UL>
<LI><A HREF="#DefiningInstanceVariables">
Defining Instance Variables</A>
<LI><A HREF="#Constants">
Constants</A>
<LI><A HREF="#ClassVariables">
Class Variables</A>
</UL>
<LI><A HREF="#CreatingMethods">
Creating Methods</A>
<UL>
<LI><A HREF="#DefiningMethods">
Defining Methods</A>
<LI><A HREF="#TheTTFONTSIZEFACECourierthisFONTTTFONTSIZEKeywordFONT">
The <TT>this</TT>
Keyword</FONT></A>
<LI><A HREF="#VariableScopeandMethodDefinitions">
Variable Scope and Method Definitions</A>
<LI><A HREF="#PassingArgumentstoMethods">
Passing Arguments to Methods</A>
<LI><A HREF="#ClassMethods">
Class Methods</A>
</UL>
<LI><A HREF="#CreatingJavaApplications">
Creating Java Applications</A>
<UL>
<LI><A HREF="#HelperClasses">
Helper Classes</A>
</UL>
<LI><A HREF="#JavaApplicationsandCommandLineArguments">
Java Applications and Command-Line Arguments</A>
<UL>
<LI><A HREF="#PassingArgumentstoJavaPrograms">
Passing Arguments to Java Programs</A>
<LI><A HREF="#HandlingArgumentsinYourJavaProgram">
Handling Arguments in Your Java Program</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
In just about every lesson up to this point you've been creating
Java applications-writing classes, creating instance variables
and methods, and running those applications to perform simple
tasks. Also up to this point, you've focused either on the very
broad (general object-oriented theory) or the very minute (arithmetic
and other expressions). Today you'll pull it all together and
learn how and why to create classes by using the following basics:
<UL>
<LI>The parts of a class definition
<LI>Declaring and using instance variables
<LI>Defining and using methods
<LI>Creating Java applications, including the <TT>main()</TT>
method and how to pass arguments to a Java program from a command
line
</UL>
<H2><A NAME="DefiningClasses"><FONT SIZE=5 COLOR=#FF0000>
Defining Classes</FONT></A></H2>
<P>
Defining classes is pretty easy; you've seen how to do it a bunch
of times in previous lessons. To define a class, use the <TT>class</TT>
keyword and the name of the class:
<BLOCKQUOTE>
<PRE>
class MyClassName {
...
}
</PRE>
</BLOCKQUOTE>
<P>
By default, classes inherit from the <TT>Object</TT>
class. If this class is a subclass of another specific class (that
is, inherits from another class), use <TT>extends</TT>
to indicate the superclass of this class:
<BLOCKQUOTE>
<PRE>
class myClassName extends mySuperClassName {
...
}<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java 1.1 will give you the ability to nest a class definition inside other classes-a useful construction when you're defining &quot;adapter classes&quot; that implement an interface. The flow of control from the inner class then moves automatically to the 
outer class. For more details (beyond this sketchy description), see the information at the 1.1 Preview Page at <TT><A HREF="http://java.sun.com/products/JDK/1.1/designspecs">http://java.sun.com/products/JDK/1.1/designspecs</A></TT>/.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="CreatingInstanceandClassVariables"><FONT SIZE=5 COLOR=#FF0000>
Creating Instance and Class Variables</FONT></A></H2>
<P>
A class definition with nothing in it is pretty dull; usually,
when you create a class, you have something you want to add to
make that class different from its superclasses. Inside each class
definition are declarations and definitions for variables or methods
or both-for the class <I>and</I> for each instance. In this section,
you'll learn all about instance and class variables; the next
section talks about methods.
<H3><A NAME="DefiningInstanceVariables">
Defining Instance Variables</A></H3>
<P>
On <A HREF="ch3.htm">Day 3</A>, &quot;Java Basics,&quot; you learned how to declare
and initialize local variables-that is, variables inside method
definitions. Instance variables, fortunately, are declared and
defined in almost exactly the same way as local variables; the
main difference is their location in the class definition. Variables
are considered instance variables if they are declared outside
a method definition. Customarily, however, most instance variables
are defined just after the first line of the class definition.
For example, Listing 6.1 shows a simple class definition for the
class <TT>Bicycle</TT>, which inherits
from the class <TT>PersonPoweredVehicle</TT>.
This class definition contains five instance variables:
<UL>
<LI><TT>bikeType</TT>-The kind of
bicycle this bicycle is-for example, <TT>Mountain</TT>
or <TT>Street</TT>
<LI><TT>chainGear</TT>-The number
of gears in the front
<LI><TT>rearCogs</TT>-The number of
minor gears on the rear axle
<LI><TT>currentGearFront</TT> and
<TT>currentGearRear</TT>-The gear
the bike is currently in, both front and rear
</UL>
<HR>
<BLOCKQUOTE>
<B>Listing 6.1. The </B><TT><B>Bicycle</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
1: class Bicycle extends PersonPoweredVehicle {
2:     String bikeType;
</FONT>3:     int chainGear;
4:     int rearCogs;
</FONT>5:     int currentGearFront;
6:     int currentGearRear;
</FONT>7: }
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Constants">
Constants</A></H3>
<P>
A <I>constant variable</I> or <I>constant </I>is a variable whose
value never changes (which may seem strange given the meaning
of the word <I>variable</I>). Constants are useful for defining
shared values for all the methods of an object-for giving meaningful
names to objectwide values that will never change. In Java, you
can create constants only for instance or class variables, not
for local variables.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>constant</I> is a variable whose value never changes.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
To declare a constant, use the <TT>final</TT>
keyword before the variable declaration and include an initial
value for that variable:
<BLOCKQUOTE>
<PRE>
final float pi = 3.141592;
final boolean debug = false;
</FONT>final int maxsize = 40000;<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The only way to define constants in Java is by using the <TT>final</TT> keyword. Neither the C and C++ constructs for <TT>#define</TT> nor <TT>const</TT> are available in Java, although the <TT>const</TT> keyword is reserved to prevent you from 
accidentally using it.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Constants can be useful for naming various states of an object
and then testing for those states. For example, suppose you have
a test label that can be aligned left, right, or center. You can
define those values as constant integers:
<BLOCKQUOTE>
<PRE>
final int LEFT = 0;
final int RIGHT = 1;
</FONT>final int CENTER = 2;
</PRE>
</BLOCKQUOTE>
<P>
The variable alignment is then also declared as an <TT>int</TT>:
<BLOCKQUOTE>
<PRE>
int alignment;
</PRE>
</BLOCKQUOTE>
<P>
Then, later in the body of a method definition, you can either
set the alignment:
<BLOCKQUOTE>
<PRE>
this.alignment = CENTER;
</PRE>
</BLOCKQUOTE>
<P>
or test for a given alignment:
<BLOCKQUOTE>
<PRE>
switch (this.alignment) {
    case LEFT: // deal with left alignment
</FONT>               ...
               break;
</FONT>    case RIGHT: // deal with right alignment
                ...
</FONT>                break;
    case CENTER: // deal with center alignment
</FONT>                 ...
                 break;
</FONT>}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ClassVariables">
Class Variables</A></H3>
<P>
As you have learned in previous lessons, class variables are global
to a class and to all that class's instances. You can think of
class variables as being even more global than instance variables.
Class variables are good for communicating between different objects
with the same class, or for keeping track of global states among
a set of objects.
<P>
To declare a class variable, use the <TT>static</TT>
keyword in the class declaration:
<BLOCKQUOTE>
<PRE>
static int sum;
static final int maxObjects = 10;
</PRE>
</BLOCKQUOTE>
<H2><A NAME="CreatingMethods"><FONT SIZE=5 COLOR=#FF0000>
Creating Methods</FONT></A></H2>
<P>
Methods, as you learned on <A HREF="ch2.htm">Day 2</A>, &quot;Object-Oriented Programming
and Java,&quot; define an object's behavior-what happens when
that object is created and the various operations that object
can perform during its lifetime. In this section, you'll get a
basic introduction to method definition and how methods work;
tomorrow, you'll go into more detail about advanced things you
can do with methods.
<H3><A NAME="DefiningMethods">
Defining Methods</A></H3>
<P>
Method definitions have four basic parts:
<UL>
<LI>The name of the method
<LI>The type of object or primitive type the method returns
<LI>A list of parameters
<LI>The body of the method
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To keep things simple today, I've left off two optional parts of the method definition: a modifier such as <TT>public</TT> or <TT>private</TT>, and the <TT>throws</TT> keyword, which indicates the exceptions a method can throw. You'll learn about these 
parts of a method definition in Week 3.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The first three parts of the method definition form what's called
the method's <I>signature</I> and indicate the most important
information about the method itself. 
<P>
In other languages, the name of the method (or function, subroutine,
or procedure) is enough to distinguish it from other methods in
the program. In Java, you can have different methods that have
the same name but a different return type or argument list, so
all these parts of the method definition are important. This is
called <I>method overloading</I>, and you'll learn more about
it tomorrow.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A method's <I>signature</I> is a combination of the name of the method, the type of object or primitive data type this method returns, and a list of parameters. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Here's what a basic method definition looks like:
<BLOCKQUOTE>
<PRE>
<I>returntype</FONT></I> <I>methodname</I>(type1 arg1, type2 arg2, type3 arg3..) {
    ...
</FONT>}
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>returntype</I></TT> is
the type of value this method returns. It can be one of the primitive
types, a class name, or <TT>void</TT>
if the method does not return a value at all.
<P>
Note that if this method returns an array object, the array brackets
can go either after the return type or after the parameter list;
because the former way is considerably easier to read, it is used
in the examples today (and throughout this book):
<BLOCKQUOTE>
<PRE>
int[] makeRange(int lower, int upper) {...}
</PRE>
</BLOCKQUOTE>
<P>
The method's parameter list is a set of variable declarations,
separated by commas, inside parentheses. These parameters become
local variables in the body of the method, whose values are the
objects or values of primitives passed in when the method is called.
<P>
Inside the body of the method you can have statements, expressions,
method calls to other objects, conditionals, loops, and so on-everything
you've learned about in the previous lessons.
<P>
If your method has a real return type (that is, it has not been
declared to return <TT>void</TT>),
somewhere inside the body of the method you need to explicitly
return a value. Use the <TT>return</TT>
keyword to do this. Listing 6.2 shows an example of a class that
defines a <TT>makeRange()</TT> method.
<TT>makeRange()</TT> takes two integers-a
lower bound and an upper bound-and creates an array that contains
all the integers between those two boundaries (inclusive).
<HR>
<BLOCKQUOTE>
<B>Listing 6.2. The </B><TT><B>RangeClass</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class RangeClass {
 2:     int[] makeRange(int lower, int upper) {
</FONT> 3:         int arr[] = new int[ (upper - lower) + 1 ];
 4: 
</FONT> 5:         for (int i = 0; i &lt; arr.length; i++) {
 6:             arr[i] = lower++;
</FONT> 7:         }
 8:         return arr;
</FONT> 9:     }
10:         
</FONT>11:     public static void main(String arg[]) {
12:         int theArray[];
</FONT>13:         RangeClass theRange = new RangeClass();
14: 
</FONT>15:         theArray = theRange.makeRange(1, 10);
16:         System.out.print(&quot;The array: [ &quot;);
</FONT>17:         for (int i = 0; i &lt; theArray.length; i++) {
18:             System.out.print(theArray[i] + &quot; &quot;);
</FONT>19:         }
20:         System.out.println(&quot;]&quot;);
</FONT>21:     }
22: 
</FONT>23: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
The array: [ 1 2 3 4 5 6 7 8 9 10 ]<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>main()</TT> method in this class tests the <TT>makeRange()</TT> method by creating a range where the lower and upper boundaries of the range are <TT>1</TT> and <TT>10</TT>, respectively (see line 6), and then uses a <TT>for</TT> loop to print the 
values of the new array.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheTTFONTSIZEFACECourierthisFONTTTFONTSIZEKeywordFONT">
The <TT>this</TT>
Keyword</FONT></A></H3>
<P>
In the body of a method definition, you may want to refer to the
current object-the object in which the method is contained in
the first place-to refer to that object's instance variables or
to pass the current object as an argument to another method. To
refer to the current object in these cases, you can use the <TT>this</TT>
keyword. <TT>this</TT> can be used
anywhere the current object might appear-in dot notation to refer
to the object's instance variables, as an argument to a method,
as the return value for the current method, and so on. Here's
an example:
<BLOCKQUOTE>
<PRE>
t = this.x;          // the x instance variable for this object
this.myMethod(this); // call the myMethod method, defined in
</FONT>                     // this class, and pass it the current
                     // object
</FONT>return this;         // return the current object
</PRE>
</BLOCKQUOTE>
<P>
In many cases you may be able to omit the <TT>this</TT>
keyword entirely. You can refer to both instance variables and
method calls defined in the current class simply by name; the
<TT>this</TT> is implicit in those
references. So the first two examples could be written like this:
<BLOCKQUOTE>
<PRE>
t = x          // the x instance variable for this object
myMethod(this) // call the myMethod method, defined in this
</FONT>               // class<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Omitting the <TT>this</TT> keyword for instance variables depends on whether there are no variables of the same name declared in the local scope. See the next section for more details on variable scope.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Keep in mind that because <TT>this</TT>
is a reference to the current <I>instance</I> of a class, you
should only use it inside the body of an instance method definition.
Class methods-that is, methods declared with the static keyword-cannot
use <TT>this</TT>.
<H3><A NAME="VariableScopeandMethodDefinitions">
Variable Scope and Method Definitions</A></H3>
<P>
When you declare a variable, that variable always has a limited
scope. Variable scope determines where that variable can be used.
Variables with a local scope, for example, can only be used inside
the block in which they were defined. Instance variables have
a scope that extends to the entire class so they can be used by
any of the methods within that class.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Variable</I> <I>scope</I> determines where a variable can be used.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
When you refer to a variable within your method definitions, Java
checks for a definition of that variable first in the current
scope (which may be a block, for example, inside a loop), then
in the outer scopes up to the current method definition. If that
variable is not a local variable, Java then checks for a definition
of that variable as an instance or class variable in the current
class, and then, finally, in each superclass in turn.
<P>
Because of the way Java checks for the scope of a given variable,
it is possible for you to create a variable in a lower scope such
that a definition of that same variable &quot;hides&quot; the
original value of that variable. This can introduce subtle and
confusing bugs into your code.
<P>
For example, note the small Java program in Listing 6.3.
<HR>
<BLOCKQUOTE>
<B>Listing 6.3. A variable scope example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class ScopeTest {
 2:     int test = 10;
</FONT> 3: 
 4:     void printTest () {
</FONT> 5:         int test = 20;
 6:         System.out.println(&quot;test = &quot; + test);
</FONT> 7:     }
 8:     
</FONT> 9:     public static void main (String args[]) {
10:        ScopeTest st = new ScopeTest();
</FONT>11:        st.printTest();
12:     }
</FONT>13: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In this class, you have two variables with the same name and definition: The first, an instance variable, has the name <TT>test</TT> and is initialized to the value <TT>10</TT>. The second is a local variable with the same name, but with the value 
<TT>20</TT>. Because the local variable hides the instance variable, the <TT>println()</TT> method will print that <TT>test</TT> is <TT>20</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The easiest way to get around this problem is to make sure you
don't use the same names for local variables as you do for instance
variables. Another way to get around this particular problem,
however, is to use <TT>this.test</TT>
to refer to the instance variable, and just <TT>test</TT>
to refer to the local variable. By referring explicitly to the
instance variable by its object scope you avoid the conflict.
<P>
A more insidious example of this variable naming problem occurs
when you redefine a variable in a subclass that already occurs
in a superclass. This can create very subtle bugs in your code-for
example, you may call methods that are intended to change the
value of an instance variable, but that change the wrong one.
Another bug might occur when you cast an object from one class
to another-the value of your instance variable may mysteriously
change (because it was getting that value from the superclass
instead of from your class). The best way to avoid this behavior
is to make sure that when you define variables in a subclass you're
aware of the variables in each of that class's superclasses and
you don't duplicate what is already there.
<H3><A NAME="PassingArgumentstoMethods">
Passing Arguments to Methods</A></H3>
<P>
When you call a method with object parameters, the variables you
pass into the body of the method are passed by reference, which
means that whatever you do to those objects inside the method
affects the original objects as well. This includes arrays and
all the objects that arrays contain; when you pass an array into
a method and modify its contents, the original array is affected.
(Note that primitive types are passed by value.)
<P>
Listing 6.4 is an example to demonstrate how this works.
<HR>
<BLOCKQUOTE>
<B>Listing 6.4. The </B><TT><B>PassByReference</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class PassByReference {
 2:     int onetoZero(int arg[]) {
</FONT> 3:         int count = 0;
 4: 
</FONT> 5:         for (int i = 0; i &lt; arg.length; i++) {
 6:             if (arg[i] == 1) {
</FONT> 7:                 count++;
 8:                 arg[i] = 0;
</FONT> 9:             }
10:         }
</FONT>11:         return count;
12:     }
</FONT>13:     public static void main (String arg[]) {
14        int arr[] = { 1, 3, 4, 5, 1, 1, 7 };
</FONT>15:        PassByReference test = new PassByReference();
16:        int numOnes;
</FONT>17:        
18:        System.out.print(&quot;Values of the array: [ &quot;);
</FONT>19:        for (int i = 0; i &lt; arr.length; i++) {
20:           System.out.print(arr[i] + &quot; &quot;);
</FONT>21:        }
22:        System.out.println(&quot;]&quot;);
</FONT>23:     
24        numOnes = test.onetoZero(arr);
</FONT>25:        System.out.println(&quot;Number of Ones = &quot; + numOnes);
26:        System.out.print(&quot;New values of the array: [ &quot;);
</FONT>27:        for (int i = 0; i &lt; arr.length; i++) {
28:            System.out.print(arr[i] + &quot; &quot;);
</FONT>29:        }
30:        System.out.println(&quot;]&quot;);
</FONT>31:     }
32:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Values of the array: [ 1 3 4 5 1 1 7 ]
Number of Ones = 3
</FONT>New values of the array: [ 0 3 4 5 0 0 7 ]
<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Note the method definition for the <TT>onetoZero()</TT> method in lines 2 to 12, which takes a single array as an argument. The <TT>onetoZero()</TT> method does two things:
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<UL>
<LI>It counts the number of <TT>1</TT>s
in the array and returns that value.
<LI>If it finds a <TT>1</TT>, it substitutes
a <TT>0</TT> in its place in the array.
</UL>
<P>
The <TT>main()</TT> method in the
<TT>PassByReference</TT> class tests
the use of the<TT> onetoZero()</TT>
method. Let's go over the <TT>main()</TT>
method line by line so that you can see what is going on and why
the output shows what it does.
<P>
Lines 14 through 16 set up the initial variables for this example.
The first one is an array of integers; the second one is an instance
of the class <TT>PassByReference</TT>,
which is stored in the variable test. The third is a simple integer
to hold the number of ones in the array.
<P>
Lines 18 through 22 print out the initial values of the array;
you can see the output of these lines in the first line of the
output.
<P>
Line 24 is where the real work takes place; this is where you
call the <TT>onetoZero()</TT> method,
defined in the object test, and pass it the array stored in <TT>arr</TT>.
This method returns the number of ones in the array, which you'll
then assign to the variable <TT>numOnes</TT>.
<P>
Got it so far? Line 25 prints out the number of <TT>1</TT>s
(that is, the value you got back from the <TT>onetoZero()</TT>
method). It returns <TT>3</TT>, as
you would expect.
<P>
The last bunch of lines print out the array values. Because a
reference to the array object is passed to the method, changing
the array inside that method changes that original copy of the
array. Printing out the values in lines 27 through 30 proves this-that
last line of output shows that all the <TT>1</TT>s
in the array have been changed to <TT>0</TT>s.
<H3><A NAME="ClassMethods">
Class Methods</A></H3>
<P>
Just as you have class and instance variables, you also have class
and instance methods, and the differences between the two types
of methods are analogous. Class methods are available to any instance
of the class itself and can be made available to other classes.
Therefore, some class methods can be used anywhere, regardless
of whether an instance of the class exists.
<P>
For example, the Java class libraries include a class called <TT>Math</TT>.
The <TT>Math</TT> class defines a
whole set of math operations that can be used in any program or
the various number types:
<BLOCKQUOTE>
<PRE>
float root = Math.sqrt(453.0);
System.out.print(&quot;The larger of x and y is &quot; + Math.max(x, y));
</PRE>
</BLOCKQUOTE>
<P>
To define class methods, use the <TT>static</TT>
keyword in front of the method definition, just as you would create
a class variable. For example, that <TT>max</TT>
class method might have a signature like this:
<BLOCKQUOTE>
<PRE>
static int max(int arg1, int arg2) { ... }
</PRE>
</BLOCKQUOTE>
<P>
Java supplies &quot;wrapper&quot; classes for each of the primitive
data types-for example, classes for <TT>Integer</TT>,
<TT>Float</TT>, and <TT>boolean</TT>.
Using class methods defined in those classes, you can convert
to and from objects and primitive types. For example, the <TT>parseInt()</TT>
class method in the <TT>Integer</TT>
class takes a string and a radix (base) and returns the value
of that string as an integer:
<BLOCKQUOTE>
<PRE>
int count = Integer.parseInt(&quot;42&quot;, 10) // returns 42
</PRE>
</BLOCKQUOTE>
<P>
Most methods that operate on a particular object, or that affect
that object, should be defined as instance methods. Methods that
provide some general utility but do not directly affect an instance
of that class are better declared as class methods.
<H2><A NAME="CreatingJavaApplications"><FONT SIZE=5 COLOR=#FF0000>
Creating Java Applications</FONT></A></H2>
<P>
Now that you know how to create classes, objects, and class and
instance variables and methods, all that's left is to put it together
into something that can actually run-in other words, to create
a Java application.
<P>
Applications, to refresh your memory, are Java programs that run
on their own. Applications are different from applets, which require
a Java-enabled browser to view them. Much of what you've been
creating up to this point have been Java applications; next week
you'll dive into how to create applets. (Applets require a bit
more background in order to get them to interact with the browser
and draw and update with the graphics system. You'll learn all
of this next week.)
<P>
A Java application consists of one or more classes and can be
as large or as small as you want it to be. While all the Java
applications you've created up to this point do nothing but output
some characters to the screen or to a window, you can also create
Java applications that use windows, graphics, and user interface
elements, just as applets do (you'll learn how to do this next
week). The only thing you need to make a Java application run,
however, is one class that serves as the &quot;jumping-off&quot;
point for the rest of your Java program. If your program is small
enough, it may need only the one class.
<P>
The jumping-off class for your application needs only one thing:
a <TT>main()</TT> method. When you
run your compiled Java class (using the Java interpreter), the
<TT>main()</TT> method is the first
thing that gets called. None of this should be much of a surprise
to you at this point; you've been creating Java applications with
<TT>main()</TT> methods all along.
<P>
The signature for the <TT>main()</TT>
method always looks like this:
<BLOCKQUOTE>
<PRE>
public static void main(String args[]) {...}
</PRE>
</BLOCKQUOTE>
<P>
Here's a run-down of the parts of the <TT>main()</TT>
method:
<UL>
<LI><TT>public</TT> means that this
method is available to other classes and objects. The <TT>main()</TT>
method must be declared <TT>public</TT>.
You'll learn more about <TT>public</TT>
and <TT>private</TT> methods in Week
3.
<LI><TT>static</TT> means that this
is a class method.
<LI><TT>void</TT> means that the <TT>main()</TT>
method doesn't return anything.
<LI><TT>main()</TT> takes one parameter:
an array of strings. This argument is used for command-line arguments,
which you'll learn about in the next section.
</UL>
<P>
The body of the <TT>main()</TT> method
contains any code you need to get your application started: initializing
variables or creating instances of any classes you may have declared.
<P>
When Java executes the <TT>main()</TT>
method, keep in mind that <TT>main()</TT>
is a class method-the class that holds it is not automatically
instantiated when your program runs. If you want to treat that
class as an object, you have to instantiate it in the <TT>main()</TT>
method yourself (all the examples up to this point have done this).
<H3><A NAME="HelperClasses">
Helper Classes</A></H3>
<P>
Your Java application can have only one class, or, in the case
of most larger programs, it may be made up of several classes,
where different instances of each class are created and used while
the application is running. You can create as many classes as
you want for your program, and as long as they are in the same
directory or listed in your <TT>CLASSPATH</TT>,
Java will be able to find them when your program runs. Note, however,
that only the one jumping-off class, only the class you use with
the Java bytecode interpreter needs a<TT>
main()</TT> method. Remember, <TT>main()</TT>
is used only so that Java can start up the program and create
an initial object; after that, the methods inside the various
classes and objects take over. While you can include <TT>main()</TT>
methods in helper classes, they will be ignored when the program
actually runs.
<H2><A NAME="JavaApplicationsandCommandLineArguments"><FONT SIZE=5 COLOR=#FF0000>
Java Applications and Command-Line Arguments</FONT></A></H2>
<P>
Because Java applications are standalone programs, it's useful
to be able to pass arguments or options to a program to determine
how the program is going to run, or to enable a generic program
to operate on many different kinds of input. Command-line arguments
can be used for many different purposes-for example, to turn on
debugging input, to indicate a filename to read or write from,
or for any other information that you might want your Java program
to know.
<H3><A NAME="PassingArgumentstoJavaPrograms">
Passing Arguments to Java Programs</A></H3>
<P>
How you pass arguments to a Java application varies based on the
platform you're running Java on. On Windows and UNIX, you can
pass arguments to the Java program via the command line; in the
Macintosh, the Java Runner gives you a special window to type
those arguments in.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Windows or Solaris</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To pass arguments to a Java program on Windows or Solaris, append them to the command line when you run your Java program:</BLOCKQUOTE>
<BLOCKQUOTE>
java Myprogram argumentOne 2 three</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Macintosh</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To pass arguments to a Java program on the Macintosh, double-click the compiled Java class file. The Java Runner will start up, and you'll get the dialog box shown in Figure 6.1.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<A HREF="f6-1.gif"><B>Figure 6.1:</B> <I>Java Runner arguments.</I></A>
<P>
<P>
Enter your arguments, separated by spaces, into this box.
<P>
In these examples, you've passed three arguments to your program:
<TT>argumentOne</TT>, the number <TT>2</TT>,
and <TT>three</TT>. Note that a space
separates arguments, so if you use the phrase <TT>Java
is cool</TT> as your arguments, you'll get three of them.
<P>
To group arguments, surround them with double-quotes. So, for
example, the argument <TT>&quot;Java is cool&quot;</TT>
produces one argument for your program to deal with. The double-quotes
are stripped off before the argument gets to your Java program.
<H3><A NAME="HandlingArgumentsinYourJavaProgram">
Handling Arguments in Your Java Program</A></H3>
<P>
How does Java handle arguments? It stores them in an array of
strings, which is passed to the <TT>main()</TT>
method in your Java program. Remember the signature for <TT>main()</TT>:
<BLOCKQUOTE>
<PRE>
public static void main (String args[]) {...}
</PRE>
</BLOCKQUOTE>
<P>
Here, <TT>args</TT> is the name of
the array of strings that contains the list of arguments. You
can actually call it anything you want.
<P>
Inside your <TT>main()</TT> method,
you can then handle the arguments your program was given by iterating
over the array of arguments and handling those arguments any way
you want. For example, Listing 6.5 is a really simple class that
prints out the arguments it gets, one per line.
<HR>
<BLOCKQUOTE>
<B>Listing 6.5. The </B><TT><B>EchoArgs</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
1: class EchoArgs {
2:     public static void main(String args[]) {
</FONT>3:         for (int i = 0; i &lt; args.length; i++) {
4:             System.out.println(&quot;Argument &quot; + i + &quot;: &quot; + args[i]);
</FONT>5:         }
6:     }
</FONT>7: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The following is some sample input and output from this program:
<P>
<IMG SRC="input.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
java EchoArgs 1 2 3 jump
</PRE>
</BLOCKQUOTE>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Argument 0: 1
Argument 1: 2
</FONT>Argument 2: 3
Argument 3: jump
</PRE>
</BLOCKQUOTE>
<P>
<IMG SRC="input.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
java EchoArgs &quot;foo bar&quot; zap twaddle 5
</PRE>
</BLOCKQUOTE>
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Argument 0: foo bar
Argument 1: zap
</FONT>Argument 2: twaddle
Argument 3: 5
</PRE>
</BLOCKQUOTE>
<P>
Note how the arguments are grouped in the second input example;
putting quotes around <TT>foo bar</TT>
causes that argument to be treated as one unit inside the argument
array.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The array of arguments in Java is not analogous to <TT>argv</TT> in C and UNIX. In particular, <TT>arg[0]</TT>, the first element in the array of arguments, is the first command-line argument after the name of the class-<I>not</I> the name of the program 
as it would be in C. Be careful of this as you write your Java programs.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
An important thing to note about the arguments you pass into a
Java program is that those arguments will be stored in an array
of strings. This means that any arguments you pass to your Java
program are strings stored in the argument array. To treat them
as non-strings, you'll have to convert them to whatever type you
want them to be.
<P>
For example, suppose you have a very simple Java program called
<TT>SumAverage</TT> that takes any
number of numeric arguments and returns the sum and the average
of those arguments. Listing 6.6 shows a first pass at this program.
Don't try compiling this one; just look at the code and see if
you can figure out what it does.
<HR>
<BLOCKQUOTE>
<B>Listing 6.6. A first try at the </B><TT><B>SumAverage</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class SumAverage {
 2:     public static void main (String args[]) {
</FONT> 3:         int sum = 0;
 4: 
</FONT> 5:         for (int i = 0; i &lt; args.length; i++) {
 6:             sum += args[i];
</FONT> 7:         }
 8: 
</FONT> 9:         System.out.println(&quot;Sum is: &quot; + sum);
10:         System.out.println(&quot;Average is: &quot; +
</FONT>11:             (float)sum / args.length);
12:     }
</FONT>13: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
At first glance, this program seems rather straightforward-a <TT>for</TT>
loop iterates over the array of arguments, summing them, and then
the sum and the average are printed out as the last step.
<P>
What happens when you try and compile this? You get an error similar
to this one:
<BLOCKQUOTE>
<PRE>
SumAverage.java:6: Incompatible type for +=. 
Can't convert java.lang.String to int.
</FONT>    sum += args[i];
</PRE>
</BLOCKQUOTE>
<P>
You get this error because the argument array is an array of strings.
Even though you passed integers into the program from the command
line, those integers were converted to strings before they were
stored in the array. To be able to sum those integers, you have
to convert them back from strings to integers. There's a class
method for the <TT>Integer</TT> class,
called <TT>parseInt</TT>, that does
just this. If you change line 6 to use that method, everything
works just fine:
<BLOCKQUOTE>
<PRE>
sum += Integer.parseInt(args[i]);
</PRE>
</BLOCKQUOTE>
<P>
Now, compiling the program produces no errors and running it with
various arguments returns the expected results. For example, <TT>java
SumAverage 1 2 3</TT> returns the following output:
<P>
<IMG SRC="output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Sum is: 6
Average is: 2
</PRE>
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you put together everything you've come across in the preceding
days of this week about how to create Java classes and use them
in Java applications. This includes the following:
<UL>
<LI>Instance and class variables, which hold the attributes of
the class and its instances. You have learned how to declare them,
how they are different from regular local variables, and how to
declare constants.
<LI>Instance and class methods, which define a class's behavior.
You have learned how to define methods, including the parts of
a method's signature, how to return values from a method, how
arguments are passed in and out of methods, and how to use the
<TT>this</TT> keyword to refer to
the current object.
<LI>Java applications-all about the <TT>main()</TT>
method and how it works, as well as how to pass arguments into
a Java application from a command line.
</UL>
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I tried creating a constant variable inside a method, and I got a compiler error when I tried it. What was I doing wrong?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>You can create only constant (<TT>final</TT>) class or instance variables; local variables cannot be constant.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><TT><B>static</B></TT><B> and <TT><B>final</B></TT> are not exactly the most descriptive words for creating class variables, class methods, and constants. Why not use <TT><B>class</B></TT> and 
<TT><B>const</B></TT>?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD><TT>static</TT> comes from Java's C++ heritage; C++ uses the <TT>static</TT> keyword to retain memory for class variables and methods (and, in fact, they aren't called class methods and 
variables in C++: <TT>static</TT> member functions and variables are more common terms).
<P>
<TT>final</TT>, however, is new. <TT>final</TT> is used in a more general way for classes and methods to indicate that those things cannot be subclassed or overridden. Using the <TT>final</TT> keyword for variables is consistent with that behavior. 
<TT>final</TT> variables are not quite the same as constant variables in C++, which is why the <TT>const</TT> keyword is not used.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>In my class, I have an instance variable called <TT><B>origin</B></TT>. I also have a local variable called <TT><B>origin</B></TT> in a method, which, because of variable scope, gets hidden 
by the local variable. Is there any way to get hold of the instance variable's value?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The easiest way is not to name your local variables the same names as your instance variables. If you feel you must, you can use <TT>this.origin</TT> to refer to the instance variable and 
<TT>origin</TT> to refer to the local variable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I want to pass command-line arguments to an applet. How do I do this?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>You're writing applets already? Been skipping ahead, have you? The answer is that you use HTML attributes to pass arguments to an applet, not the command line (you don't have a command line for 
applets). You'll learn how to do this next week.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I wrote a program to take four arguments, but if I give it too few arguments, it crashes with a runtime error.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Testing for the number and type of arguments your program expects is up to you in your Java program; Java won't do it for you. If your program requires four arguments, test that you have indeed 
been given four arguments, and return an error message if you haven't.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch5.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch7.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
