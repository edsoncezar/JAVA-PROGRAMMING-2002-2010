<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 24</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using the Provided Data Structures</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#OverviewoftheDataStructures" >Overview of the Data Structures</A>
<LI><A HREF="#Enumeration" >Enumeration</A>
<LI><A HREF="#BitSet" >BitSet</A>
<LI><A HREF="#Vector" >Vector</A>
<LI><A HREF="#Stack" >Stack</A>
<LI><A HREF="#Dictionary" >Dictionary</A>
<LI><A HREF="#Hashtable" >Hashtable</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<FONT COLOR=#000000>At the heart of even the most basic Java programs
are data structures</FONT>, which are responsible for modeling
information within the context of a program. There are many varieties
of data structures, ranging from primitive data types to arrays
to more complex structures like hash tables. In this chapter,
you learn about the data structures provided by the Java API.
More specifically, you learn how to use the data structures in
the Java utility package, also known as <TT><FONT FACE="Courier">java.util</FONT></TT>.
This package contains a wide range of data structures applicable
to many different programming scenarios. The goal of this chapter
is to familiarize you with these data structures and show you
the basics of how to use them. If you want more complete details
regarding the data structure classes, refer to <A HREF="ch34.htm" >Chapter 34</A>,
&quot;Package <TT><FONT FACE="Courier">java.util</FONT></TT>,&quot;
which is a complete reference for the <TT><FONT FACE="Courier">java.util</FONT></TT>
package.
<H2><A NAME="OverviewoftheDataStructures"><FONT SIZE=5 COLOR=#FF0000>Overview
of the Data Structures</FONT></A></H2>
<P>
The data structures provided by the Java utility package are very
powerful and perform a wide range of functions. These data structures
consist of an interface and five classes, which follow:
<UL>
<LI><TT><FONT FACE="Courier">Enumeration</FONT></TT>
<LI><TT><FONT FACE="Courier">BitSet</FONT></TT>
<LI><TT><FONT FACE="Courier">Vector</FONT></TT>
<LI><TT><FONT FACE="Courier">Stack</FONT></TT>
<LI><TT><FONT FACE="Courier">Dictionary</FONT></TT>
<LI><TT><FONT FACE="Courier">Hashtable</FONT></TT>
</UL>
<P>
The <TT><FONT FACE="Courier">Enumeration</FONT></TT> interface
isn't itself a data structure, but it is very important within
the context of other data structures. The <TT><FONT FACE="Courier">Enumeration</FONT></TT>
interface defines a means to retrieve successive elements from
a data structure. For example, <TT><FONT FACE="Courier">Enumeration</FONT></TT>
defines a method called <TT><FONT FACE="Courier">nextElement</FONT></TT>
that is used to get the next element in a data structure that
contains multiple elements.
<P>
The <TT><FONT FACE="Courier">BitSet</FONT></TT> class implements
a group of bits, or flags, that can be set and cleared individually.
This class is very useful in cases where you need to keep up with
a set of Boolean values; you just assign a bit to each value and
set it or clear it appropriately.
<P>
The <TT><FONT FACE="Courier">Vector</FONT></TT> class is very
similar to a traditional Java array, except that it can grow as
necessary to accommodate new elements. Like an array, elements
of a <TT><FONT FACE="Courier">Vector</FONT></TT> object can be
accessed through an index into the vector. The nice thing about
using the <TT><FONT FACE="Courier">Vector</FONT></TT> class is
that you don't have to worry about setting it to a specific size
upon creation.
<P>
The <TT><FONT FACE="Courier">Stack</FONT></TT> class implements
a last-in-first-out (LIFO) stack of elements. You can think of
a stack as a vertical stack of objects; when you add a new element,
it gets stacked on top of the others. When you pull an element
off the stack, it comes off the top. In other words, the last
element you added to the stack is the first one to come back off.
<P>
The <TT><FONT FACE="Courier">Dictionary</FONT></TT> class is an
abstract class that defines a data structure for mapping keys
to values. This is useful in cases where you want to be able to
access data through a particular key rather than on the value
of the data itself. Because the <TT><FONT FACE="Courier">Dictionary</FONT></TT>
class is abstract, it only provides the framework for a key-mapped
data structure, rather than a specific implementation.
<P>
An actual implementation of a key-mapped data structure is provided
by the <TT><FONT FACE="Courier">Hashtable</FONT></TT> class. The
<TT><FONT FACE="Courier">Hashtable</FONT></TT> class provides
a means of organizing data based on some user-defined key structure.
For example, in an address list hash table, you could store and
sort data based on a key such as ZIP code rather than on a person's
name. The specific meaning of keys in regard to hash tables is
totally dependent on the usage of the hash table and the data
it contains.
<P>
That sums up the data structures provided by the Java utility
package. Now that you have a cursory understanding of them, let's
dig into each in a little more detail and see how they work.
<H2><A NAME="Enumeration"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Enumeration</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Enumeration</FONT></TT> interface
provides a standard means of iterating through a list of sequentially
stored elements, which is a common task of many data structures.
Since <TT><FONT FACE="Courier">Enumeration</FONT></TT> is an interface,
its role is limited to providing the method protocol for data
structures that can be enumerated in a sequential manner. Even
though you can't use the interface outside the context of a particular
data structure, understanding how it works will put you well on
your way to understanding other Java data structures. With that
in mind, take a look at the only two methods defined by the <TT><FONT FACE="Courier">Enumeration</FONT></TT>
interface:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public abstract boolean hasMoreElements();
<BR>
public abstract Object nextElement();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">hasMoreElements</FONT></TT> method
is used to determine whether the enumeration contains any more
elements. You will typically call this method to see if you can
continue iterating through an enumeration. An example of this
is calling <TT><FONT FACE="Courier">hasMoreElements</FONT></TT>
in the conditional clause of a <TT><FONT FACE="Courier">while</FONT></TT>
loop that is iterating through an enumeration.
<P>
The <TT><FONT FACE="Courier">nextElement</FONT></TT> method is
responsible for actually retrieving the next element in an enumeration.
If no more elements are in the enumeration, <TT><FONT FACE="Courier">nextElement</FONT></TT>
will throw a <TT><FONT FACE="Courier">NoSuchElementException</FONT></TT>
exception. Because you want to avoid generating exceptions whenever
possible, you should always use <TT><FONT FACE="Courier">hasMoreElements</FONT></TT>
in conjunction with <TT><FONT FACE="Courier">nextElement</FONT></TT>
to make sure there is another element to retrieve. Following is
an example of a <TT><FONT FACE="Courier">while</FONT></TT> loop
that uses these two methods to iterate through a data structure
object that implements the <TT><FONT FACE="Courier">Enumeration</FONT></TT>
 interface:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">// e is an object that implements the
Enumeration interface<BR>
while (e.hasMoreElements()) {<BR>
&nbsp;&nbsp;Object o = e.nextElement();<BR>
&nbsp;&nbsp;System.out.println(o);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This example code prints out the contents of an enumeration using
the <TT><FONT FACE="Courier">hasMoreElements</FONT></TT> and <TT><FONT FACE="Courier">nextElement</FONT></TT>
methods. Pretty simple!
<H2><A NAME="BitSet"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">BitSet</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">BitSet</FONT></TT> class is useful
whenever you need to represent a group of Boolean flags. The nice
thing about the <TT><FONT FACE="Courier">BitSet</FONT></TT> class
is that it alleviates the need for masking out the value of each
bit; you simply refer to each bit using an index. Another nice
feature about the <TT><FONT FACE="Courier">BitSet</FONT></TT>
class is that it automatically grows to represent the number of
bits required by a program.
<P>
A good example of using a <TT><FONT FACE="Courier">BitSet</FONT></TT>
is an object that has a number of attributes that can easily be
modeled by Boolean values. Because the individual bits in a bit
set are accessed through an index, you can define each attribute
as a constant index value:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class someBits {<BR>
&nbsp;&nbsp;public static final int readable = 0;<BR>
&nbsp;&nbsp;public static final int writeable = 1;<BR>
&nbsp;&nbsp;public static final int streamable = 2;<BR>
&nbsp;&nbsp;public static final int flexible = 3;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that the attributes are assigned increasing values beginning
with zero. You can use these values to get and set the appropriate
bits in a bit set. But first, you need to create a <TT><FONT FACE="Courier">BitSet</FONT></TT>
 object:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">BitSet bits = new BitSet();</FONT></TT>
</BLOCKQUOTE>
<P>
This constructor creates a bit set with no specified size. You
can also create a bit set with a specific size:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">BitSet bits = new BitSet(4);</FONT></TT>
</BLOCKQUOTE>
<P>
This creates a bit set containing four Boolean bit fields. Regardless
of the constructor used, all bits in new bit sets are initially
set to <TT><FONT FACE="Courier">false</FONT></TT>. Once you have
a bit set created, you can easily set and clear the bits using
the <TT><FONT FACE="Courier">set</FONT></TT> and <TT><FONT FACE="Courier">clear</FONT></TT>
methods along with the bit constants you defined:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">bits.set(someBits.writeable);<BR>
bits.set(someBits.streamable);<BR>
bits.set(someBits.flexible);<BR>
bits.clear(someBits.writeable);</FONT></TT>
</BLOCKQUOTE>
<P>
In this code, the <TT><FONT FACE="Courier">writeable</FONT></TT>,
<TT><FONT FACE="Courier">streamable</FONT></TT>, and <TT><FONT FACE="Courier">flexible</FONT></TT>
attributes are set, and then the <TT><FONT FACE="Courier">writeable</FONT></TT>
bit is cleared. Notice that the fully qualified name is used for
each attribute because they are declared as static in the <TT><FONT FACE="Courier">someBits</FONT></TT>
class.
<P>
You can get the value of individual bits in a bit set using the
<TT><FONT FACE="Courier">get</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean canIWrite = bits.get(someBits.writeable);</FONT></TT>
</BLOCKQUOTE>
<P>
You can find out how many bits are being modeled by a bit set
using the <TT><FONT FACE="Courier">size</FONT></TT> method. An
example of this follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int numBits = bits.size();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">BitSet</FONT></TT> class also provides
other methods for performing comparisons and bitwise operations
on bit sets such as <TT><FONT FACE="Courier">AND</FONT></TT>,
<TT><FONT FACE="Courier">OR</FONT></TT>, and <TT><FONT FACE="Courier">XOR</FONT></TT>.
All of these methods take a <TT><FONT FACE="Courier">BitSet</FONT></TT>
object as their only parameter.
<H2><A NAME="Vector"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Vector</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Vector</FONT></TT> class implements
a growable array of objects. Because the <TT><FONT FACE="Courier">Vector</FONT></TT>
class is responsible for growing itself as necessary to support
more elements, it has to decide when and by how much to grow as
new elements are added. You can easily control this aspect of
vectors upon creation. Before getting into that, however, take
a look at how to create a basic vector:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Vector v = new Vector();</FONT></TT>
</BLOCKQUOTE>
<P>
That's about as simple as it gets! This constructor creates a
default vector containing no elements. Actually, all vectors are
empty upon creation. One of the attributes important to how a
vector sizes itself is the initial capacity of a vector. The following
code shows how to create a vector with a specified capacity:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Vector v = new Vector(25);</FONT></TT>
</BLOCKQUOTE>
<P>
This vector is created to immediately support up to 25 elements.
In other words, the vector will go ahead and allocate enough memory
to support 25 elements. Once 25 elements have been added, however,
the vector must decide how to grow itself to accept more elements.
You can specify the value by which a vector grows using yet another
<TT><FONT FACE="Courier">Vector</FONT></TT> constructor:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Vector v = new Vector(25, 5);</FONT></TT>
</BLOCKQUOTE>
<P>
This vector has an initial size of 25 elements, and it will grow
in increments of 5 elements whenever its size grows to more than
25 elements. This means that the vector will first jump to 30
elements in size, then 35, and so on. A smaller grow value for
a vector results in more efficient memory management, but at a
cost of more execution overhead because more memory allocations
are taking place. On the other hand, a larger grow value results
in fewer memory allocations, but sometimes memory may be wasted
if you don't use all the extra space created.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The default grow value for a vector is 0, which actually results in the vector doubling its size whenever it needs to grow. In other words, a default grow value essentially acts like a grow value equal to the size of the vector.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Unlike arrays, you can't just use square brackets (<TT><FONT FACE="Courier">[]</FONT></TT>)
to access the elements in a vector; you have to use methods defined
in the <TT><FONT FACE="Courier">Vector</FONT></TT> class. To add
an element to a vector, you use the <TT><FONT FACE="Courier">addElement</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.addElement(&quot;carrots&quot;);<BR>
v.addElement(&quot;broccoli&quot;);<BR>
v.addElement(&quot;cauliflower&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
This code shows how to add some vegetable strings to a vector.
To get the last string added to the vector, you can use the <TT><FONT FACE="Courier">lastElement</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String s = (String)v.lastElement();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">lastElement</FONT></TT> method retrieves
the last element added to the vector. Notice that you have to
cast the return value of <TT><FONT FACE="Courier">lastElement</FONT></TT>
because the <TT><FONT FACE="Courier">Vector</FONT></TT> class
is designed to work with <TT><FONT FACE="Courier"> Object</FONT></TT>s.
Although <TT><FONT FACE="Courier">lastElement</FONT></TT> certainly
has its usefulness, you will probably find more use with the <TT><FONT FACE="Courier">elementAt</FONT></TT>
method, which allows you to index into a vector to retrieve an
element. Following is an example of using the <TT><FONT FACE="Courier">elementAt</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String s1 = (String)v.elementAt(0);<BR>
String s2 = (String)v.elementAt(2);</FONT></TT>
</BLOCKQUOTE>
<P>
Because vectors are zero-based, the first call to <TT><FONT FACE="Courier">elementAt</FONT></TT>
retrieves the <TT><FONT FACE="Courier">&quot;carrots&quot;</FONT></TT>
string, and the second call retrieves the <TT><FONT FACE="Courier">&quot;cauliflower&quot;</FONT></TT>
string. Just as you can retrieve an element at a particular index,
you can also add and remove elements at an index using the <TT><FONT FACE="Courier">insertElementAt</FONT></TT>
and <TT><FONT FACE="Courier">removeElementAt</FONT></TT> methods:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.insertElementAt(&quot;squash&quot;,
1);<BR>
v.insertElementAt(&quot;corn&quot;, 0);<BR>
v.removeElementAt(3);</FONT></TT>
</BLOCKQUOTE>
<P>
The first call to <TT><FONT FACE="Courier">insertElementAt</FONT></TT>
inserts an element at index 1, in between the <TT><FONT FACE="Courier">&quot;carrots&quot;</FONT></TT>
and <TT><FONT FACE="Courier">&quot;broccoli&quot;</FONT></TT>
strings. The <TT><FONT FACE="Courier">&quot;broccoli&quot;</FONT></TT>
and <TT><FONT FACE="Courier">&quot;cauliflower&quot;</FONT></TT>
strings are moved up a space in the vector to accommodate the
inserted <TT><FONT FACE="Courier">&quot;squash&quot;</FONT></TT>
string. The second call to <TT><FONT FACE="Courier">insertElementAt</FONT></TT>
inserts an element at index 0, which is the beginning of the vector.
In this case, all existing elements are moved up a space in the
vector to accommodate the inserted <TT><FONT FACE="Courier">&quot;corn&quot;</FONT></TT>
string. At this point, the contents of the vector look like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&quot;corn&quot;<BR>
&quot;carrots&quot;<BR>
&quot;squash&quot;<BR>
&quot;broccoli&quot;<BR>
&quot;cauliflower&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
The call to <TT><FONT FACE="Courier">removeElementAt</FONT></TT>
removes the element at index 3, which is the <TT><FONT FACE="Courier">&quot;broccoli&quot;</FONT></TT>
string. The resulting contents of the vector consist of the following
strings:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&quot;corn&quot;<BR>
&quot;carrots&quot;<BR>
&quot;squash&quot;<BR>
&quot;cauliflower&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
You can use the <TT><FONT FACE="Courier">setElementAt</FONT></TT>
method to change a specific element:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.setElementAt(&quot;peas&quot;, 1);</FONT></TT>
</BLOCKQUOTE>
<P>
This method replaces the <TT><FONT FACE="Courier">&quot;carrots&quot;</FONT></TT>
string with the <TT><FONT FACE="Courier">&quot;peas&quot;</FONT></TT>
string, resulting in the following vector contents:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&quot;corn&quot;<BR>
&quot;peas&quot;<BR>
&quot;squash&quot;<BR>
&quot;cauliflower&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
If you want to clear out the vector completely, you can remove
all the elements with the <TT><FONT FACE="Courier">removeAllElements</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.removeAllElements();</FONT></TT>
</BLOCKQUOTE>
<P>
The Vector class also provides some methods for working with elements
without using indexes. These methods actually search through the
vector for a particular element. The first of these methods is
the <TT><FONT FACE="Courier">contains</FONT></TT> method, which
simply checks to see if an element is in the vector:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isThere = v.contains(&quot;celery&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Another method that works in this manner is the <TT><FONT FACE="Courier">indexOf</FONT></TT>
method, which finds the index of an element based on the element
itself:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int i = v.indexOf(&quot;squash&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">indexOf</FONT></TT> method returns
the index of the element in question if it is in the vector, or
-1 if not. The <TT><FONT FACE="Courier">removeElement</FONT></TT>
method works similarly in that it removes an element based on
the element itself, rather than an index:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.removeElement(&quot;cauliflower&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
If you're interested in working with all the elements in a vector
sequentially, you can use the <TT><FONT FACE="Courier">elements</FONT></TT>
method, which returns an enumeration of the elements:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Enumeration e = v.elements();</FONT></TT>
</BLOCKQUOTE>
<P>
If you recall from earlier in this chapter, you can use an enumeration
to step through elements sequentially.
<P>
You may find yourself wanting to work with the size of a vector.
Fortunately, the <TT><FONT FACE="Courier">Vector</FONT></TT> class
provides a few methods for determining and manipulating the size
of a vector. First, the <TT><FONT FACE="Courier">size</FONT></TT>
method determines the number of elements in the vector:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int size = v.size();</FONT></TT>
</BLOCKQUOTE>
<P>
If you want to explicitly set the size of a vector, you can use
the <TT><FONT FACE="Courier">setSize</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.setSize(10);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">setSize</FONT></TT> method expands
or truncates the vector to accommodate the new size specified.
If the vector is expanded because of a larger size, null elements
are inserted as the newly added elements. If the vector is truncated,
any elements at indexes beyond the specified size are discarded.
<P>
If you recall, vectors have two different attributes relating
to size: size and capacity. The size is the number of elements
in the vector, and the capacity is the amount of memory allocated
to hold new elements. The capacity is always greater than or equal
to the size. You can force the capacity to exactly match the size
using the <TT><FONT FACE="Courier">trimToSize</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">v.trimToSize();</FONT></TT>
</BLOCKQUOTE>
<P>
You can also check to see what the capacity is using the <TT><FONT FACE="Courier">capacity</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int capacity = v.capacity();</FONT></TT>
</BLOCKQUOTE>
<P>
You'll find that the <TT><FONT FACE="Courier">Vector</FONT></TT>
class is one of the most useful data structures provided in the
Java API. This tour of the class should give you an idea of how
powerful and easy it is to use vectors.
<H2><A NAME="Stack"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Stack</FONT></TT></A>
</H2>
<P>
Stacks are a classic data structure used to model information
that is accessed in a specific order. The <TT><FONT FACE="Courier">Stack</FONT></TT>
class in Java is implemented as a last-in-first-out (LIFO) stack,
which means that the last item added to the stack is the first
one to come back off. The <TT><FONT FACE="Courier">Stack</FONT></TT>
class defines only one constructor, which is a default constructor
that creates an empty stack. You use this constructor to create
a stack like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Stack s = new Stack();</FONT></TT>
</BLOCKQUOTE>
<P>
You add new elements to a stack using the <TT><FONT FACE="Courier">push</FONT></TT>
method, which pushes an element onto the top of the stack:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s.push(&quot;One&quot;);<BR>
s.push(&quot;Two&quot;);<BR>
s.push(&quot;Three&quot;);<BR>
s.push(&quot;Four&quot;);<BR>
s.push(&quot;Five&quot;);<BR>
s.push(&quot;Six&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
This code pushes six strings onto the stack, with the last string
(<TT><FONT FACE="Courier">&quot;Six&quot;</FONT></TT>) remaining
on top. You pop elements back off the stack using the <TT><FONT FACE="Courier">pop</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String s1 = (String)s.pop();<BR>
String s2 = (String)s.pop();</FONT></TT>
</BLOCKQUOTE>
<P>
This code pops the last two strings off the stack, leaving the
first four strings remaining. This code results in the <TT><FONT FACE="Courier">s1</FONT></TT>
variable containing the <TT><FONT FACE="Courier">&quot;Six&quot;</FONT></TT>
string and the <TT><FONT FACE="Courier">s2</FONT></TT> variable
containing the <TT><FONT FACE="Courier">&quot;Five&quot;</FONT></TT>
string.
<P>
If you want to get the top element on the stack without actually
popping it off the stack, you can use the <TT><FONT FACE="Courier">peek</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String s3 = (String)s.peek();</FONT></TT>
</BLOCKQUOTE>
<P>
This call to <TT><FONT FACE="Courier">peek</FONT></TT> returns
the <TT><FONT FACE="Courier">&quot;Four&quot;</FONT></TT> string,
but it leaves the string on the stack. You can search for an element
on the stack using the <TT><FONT FACE="Courier">search</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int i = s.search(&quot;Two&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">search</FONT></TT> method returns
the distance from the top of the stack of the element if it is
found, or -1 if not. In this case, the <TT><FONT FACE="Courier">&quot;Two&quot;</FONT></TT>
string is the third element from the top, so the <TT><FONT FACE="Courier">search</FONT></TT>
method returns 2 (zero-based).
<P>
The only other method defined in the <TT><FONT FACE="Courier">Stack</FONT></TT>
class is <TT><FONT FACE="Courier">empty</FONT></TT>, which determines
if a stack is empty:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isEmpty = s.empty();</FONT></TT>
</BLOCKQUOTE>
<P>
Although the <TT><FONT FACE="Courier">Stack</FONT></TT> class
may not be quite as useful as the <TT><FONT FACE="Courier">Vector</FONT></TT>
class, it provides the functionality for a very common and established
data structure.
<H2><A NAME="Dictionary"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Dictionary</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Dictionary</FONT></TT> class defines
a framework for implementing a basic key-mapped data structure.
Although you can't actually create <TT><FONT FACE="Courier">Dictionary</FONT></TT>
objects because the <TT><FONT FACE="Courier">Dictionary</FONT></TT>
class is abstract, you can still learn a lot about key-mapped
data modeling by learning how the  <TT><FONT FACE="Courier">Dictionary</FONT></TT>
class works. You can put the key-mapped approach to work using
the <TT><FONT FACE="Courier">Hashtable</FONT></TT> class, which
is derived from <TT><FONT FACE="Courier">Dictionary</FONT></TT>,
or by deriving your own class from <TT><FONT FACE="Courier">Dictionary</FONT></TT>.
You learn about the <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class in the next section of this chapter.
<P>
The <TT><FONT FACE="Courier">Dictionary</FONT></TT> class defines
a means of storing information based on a key. This is similar
in some ways to how the <TT><FONT FACE="Courier">Vector</FONT></TT>
class works, in that elements in a vector are accessed through
an index, which is a type of key. However, keys in the <TT><FONT FACE="Courier">Dictionary</FONT></TT>
class can be just about anything. You can create your own class
to use as the keys for accessing and manipulating data in a dictionary.
<P>
The <TT><FONT FACE="Courier">Dictionary</FONT></TT> class defines
a variety of methods for working with the data stored in a dictionary.
All of these methods are defined as abstract, meaning that derived
classes will have to implement all of them to actually be useful.
The <TT><FONT FACE="Courier">put</FONT></TT> and <TT><FONT FACE="Courier">get</FONT></TT>
methods are used to put objects in the dictionary and get them
back. Assuming that <TT><FONT FACE="Courier">dict</FONT></TT>
is a <TT><FONT FACE="Courier">Dictionary</FONT></TT>-derived class
that implements these methods, the following code shows how to
use the <TT><FONT FACE="Courier">put</FONT></TT> method to add
elements to a dictionary:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">dict.put(&quot;small&quot;, new Rectangle(0,
0, 5, 5));<BR>
dict.put(&quot;medium&quot;, new Rectangle(0, 0, 15, 15));<BR>
dict.put(&quot;large&quot;, new Rectangle(0, 0, 25, 25));</FONT></TT>
</BLOCKQUOTE>
<P>
This code adds three rectangles to the dictionary using strings
as the keys. To get an element from the dictionary, you use the
<TT><FONT FACE="Courier">get</FONT></TT> method and specify the
appropriate key:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Rectangle r = (Rectangle)dict.get(&quot;medium&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
You can also remove an element from the dictionary with a key
using the <TT><FONT FACE="Courier">remove</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">dict.remove(&quot;large&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
You can find out how many elements are in the dictionary using
the <TT><FONT FACE="Courier">size</FONT></TT> method, much as
you did with the <TT><FONT FACE="Courier">Vector</FONT></TT> class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int size = dict.size();</FONT></TT>
</BLOCKQUOTE>
<P>
You can also check to see if the dictionary is empty using the
<TT><FONT FACE="Courier">isEmpty</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isEmpty = dict.isEmpty();</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the <TT><FONT FACE="Courier">Dictionary</FONT></TT> class
includes two methods for enumerating the keys and values contained
within: <TT><FONT FACE="Courier">keys</FONT></TT> and <TT><FONT FACE="Courier">elements</FONT></TT>.
The <TT><FONT FACE="Courier">keys</FONT></TT> method returns an
enumeration containing all the keys contained in a dictionary,
and the <TT><FONT FACE="Courier">elements</FONT></TT> method returns
an enumeration of all the key-mapped values contained. Following
is an example of retrieving both enumerations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Enumeration keys = dict.keys();<BR>
Enumeration elements = dict.elements();</FONT></TT>
</BLOCKQUOTE>
<P>
Note that because keys are mapped to elements on a one-to-one
basis, these enumerations are of equal length.
<H2><A NAME="Hashtable"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Hashtable</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Hashtable</FONT></TT> class is derived
from <TT><FONT FACE="Courier">Dictionary</FONT></TT> and provides
a complete implementation of a key-mapped data structure. Like
dictionaries, hash tables allow you to store data based on some
type of key. Unlike dictionaries, hash tables have an efficiency
associated with them defined by the load factor of the table.
The <I>load factor</I> of a hash table is a number between 0.0
and 1.0 that determines how and when the hash table allocates
space for more elements. Like vectors, hash tables have a capacity,
which is the amount of memory allocated for the table. Hash tables
 allocate more memory by comparing the current size of the table
with the product of the capacity and load factor. If the size
of the hash table exceeds this product, the table increases its
capacity by rehashing itself.
<P>
Load factors closer to 1.0 result in a more efficient usage of
memory at the expense of a longer look-up time for each element.
Similarly, load factors closer to 0.0 result in more efficient
look-ups but also tend to be more wasteful with memory. Determining
the load factor for your own hash tables is really dependent on
the usage of the hash table and whether your priority is on performance
or memory efficiency.
<P>
You create hash tables using one of three methods. The first method
creates a default hash table:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Hashtable hash = new Hashtable();</FONT></TT>
</BLOCKQUOTE>
<P>
The second constructor creates a hash table with the specified
initial capacity:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Hashtable hash = new Hashtable(20);</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the third constructor creates a hash table with the specified
initial capacity and load factor:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Hashtable hash = new Hashtable(20, 0.75);</FONT></TT>
</BLOCKQUOTE>
<P>
All of the abstract methods defined in <TT><FONT FACE="Courier">Dictionary</FONT></TT>
are implemented in the <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class. Because these methods perform the exact same function in
<TT><FONT FACE="Courier">Hashtable</FONT></TT>, there's no need
to cover them again. However, they are listed here just so you'll
have an idea of what support <TT><FONT FACE="Courier">Hashtable</FONT></TT>
 provides:
<UL>
<LI><TT><FONT FACE="Courier">elements</FONT></TT>
<LI><TT><FONT FACE="Courier">get</FONT></TT>
<LI><TT><FONT FACE="Courier">isEmpty</FONT></TT>
<LI><TT><FONT FACE="Courier">keys</FONT></TT>
<LI><TT><FONT FACE="Courier">put</FONT></TT>
<LI><TT><FONT FACE="Courier">remove</FONT></TT>
<LI><TT><FONT FACE="Courier">size</FONT></TT>
</UL>
<P>
In addition to these methods, the <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class implements a few others that perform functions specific
to supporting hash tables. One of these is the <TT><FONT FACE="Courier">clear</FONT></TT>
method, which clears a hash table of all its keys and elements:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">hash.clear();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">contains</FONT></TT> method is used
to see if an object is stored in the hash table. This method searches
for an object value in the hash table rather than a key. The following
code shows how to use the <TT><FONT FACE="Courier">contains</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isThere = hash.contains(new Rectangle(0,
0, 5, 5));</FONT></TT>
</BLOCKQUOTE>
<P>
Similar to <TT><FONT FACE="Courier">contains</FONT></TT>, the
<TT><FONT FACE="Courier">containsKey</FONT></TT> method searches
a hash table, but it searches based on a key rather than a value:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isThere = hash.containsKey(&quot;Small&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
As mentioned earlier, a hash table will rehash itself when it
determines that it must increase its capacity. You can force a
rehash yourself by calling the <TT><FONT FACE="Courier">rehash</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">hash.rehash();</FONT></TT>
</BLOCKQUOTE>
<P>
That sums up the important methods implemented by the <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class. Even though you've seen all the methods, you still may
be wondering exactly how the <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class is useful. The practical usage of a hash table is actually
in representing data that is too time-consuming to search or reference
by value. In other words, it's much more efficient to access complex
elements in a data structure using a key rather than by comparing
the objects themselves. Furthermore, hash tables typically compute
a key for elements, which is called a hash code. For example,
an object such as a string can have an integer hash code computed
for it that uniquely represents the string. When a bunch of strings
are stored in a hash table, the table can access the strings by
integer hash codes as opposed to the contents of the strings themselves.
<P>
This technique of computing and using hash codes for object storage
and reference is exploited very heavily throughout the Java system.
This is apparent in the fact that the parent of all classes, <TT><FONT FACE="Courier">Object</FONT></TT>,
defines a <TT><FONT FACE="Courier">hashCode</FONT></TT> method
that is overridden in most standard Java classes. Any class that
defines a <TT><FONT FACE="Courier">hashCode</FONT></TT> method
can be efficiently stored and accessed in a hash table. A class
that is to be hashed must also implement the <TT><FONT FACE="Courier">equals</FONT></TT>
method, which defines a way of telling whether two objects are
equal. The <TT><FONT FACE="Courier">equals</FONT></TT> method
usually just performs a straight comparison of all the member
variables defined in a class.
<P>
Hash tables are an extremely powerful data structure that you
will probably want to integrate into some of your programs that
manipulate large amounts of data. The fact that they are so widely
supported in the Java API through the <TT><FONT FACE="Courier">Object</FONT></TT>
class should give you a clue as to their importance in Java programming.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned all about the data structures provided
by the Java utility package (<TT><FONT FACE="Courier">java.util</FONT></TT>).
You learned exactly what each data structure provides in terms
of modeling data in different ways. You then moved on to the details
of each data structure and how to use it to actually model data.
Although this chapter didn't go into great detail regarding practical
scenarios that use the data structures in your own programs, it
did cover the basics of how to use each of the data structures.
The reality is that there are limitless uses of the data structures
in your own programs, so the best approach is to learn how to
use them in general terms and then apply them to your own code
as you see fit.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



