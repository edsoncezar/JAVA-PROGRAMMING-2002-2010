<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 20</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Working with Threads</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#ThreadBasics" >Thread Basics</A>
<LI><A HREF="#TheThreadClasses" >The Thread Classes</A>
<UL>
<LI><A HREF="#Thread" >Thread</A>
<LI><A HREF="#Runnable1" >Runnable</A>
<LI><A HREF="#ThreadDeath" >ThreadDeath</A>
<LI><A HREF="#ThreadGroup" >ThreadGroup</A>
<LI><A HREF="#Object" >Object</A>
</UL>
<LI><A HREF="#CreatingThreads" >Creating Threads</A>
<UL>
<LI><A HREF="#DerivingfromtheThreadClass" >Deriving from the Thread Class</A>
<LI><A HREF="#ImplementingtheRunnableInterface" >Implementing the Runnable Interface</A>
</UL>
<LI><A HREF="#SchedulingandThreadPriority" >Scheduling and Thread Priority</A>
<UL>
<LI><A HREF="#HowItWorks" >How It Works</A>
<LI><A HREF="#EstablishingThreadPriority" >Establishing Thread Priority</A>
</UL>
<LI><A HREF="#Daemons" >Daemons</A>
<LI><A HREF="#GroupingThreads" >Grouping Threads</A>
<LI><A HREF="#ThreadStates" >Thread States</A>
<LI><A HREF="#New" >New</A>
<LI><A HREF="#Runnable" >Runnable</A>
<LI><A HREF="#NotRunning" >Not Running</A>
<LI><A HREF="#Dead" >Dead</A>
<LI><A HREF="#Synchronization" >Synchronization</A>
<UL>
<LI><A HREF="#AHypotheticalExample" >A Hypothetical Example</A>
<LI><A HREF="#SynchronizingThreads" >Synchronizing Threads</A>
<LI><A HREF="#VolatileVariables" >Volatile Variables</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
A key feature of the Java programming environment and runtime
system is the multithreaded architecture shared by both. Multithreading,
which is a fairly recent construct in the programming community,
is a very powerful means of enhancing and controlling program
execution. This chapter takes a look at how the Java language
supports multithreading through the use of threads. You learn
all about the different classes that enable Java to be a threaded
language, along with many of the issues surrounding the effective
use of threads.
<H2><A NAME="ThreadBasics"><FONT SIZE=5 COLOR=#FF0000>Thread Basics</FONT></A>
</H2>
<P>
The multithreading support in Java revolves around the concept
of a thread. The question is, what is a thread? Put simply, a
<I>thread</I> is a single stream of execution within a process.
OK, maybe that wasn't so simple. It might be better to start off
by exploring exactly what a process is.
<P>
A <I>process</I> is a program executing within its own address
space. Java is a multiprocessing system, meaning that it supports
many processes running concurrently in their own address spaces.
You may be more familiar with the term multitasking, which describes
a scenario very similar to multiprocessing. As an example, consider
the variety of applications typically running at once in a graphical
environment. As I write this, I am running Microsoft Word along
with Internet Explorer, Windows Explorer, Inbox, CD Player, and
Volume Control. These applications are all processes executing
within the Windows 95 environment. In this way, you can think
of processes as being analogous to applications, or stand-alone
programs; each process in a system is given its own room to execute.
<P>
A thread is a sequence of code executing within the context of
a process. As a matter of fact, threads cannot execute on their
own; they require the overhead of a parent process to run. Within
each of the processes I mentioned running on my machine, there
are no doubt a variety of threads executing. For example, Word
may have a thread in the background automatically checking the
spelling of what I'm writing, while another thread may be automatically
saving changes to the document I'm working on. Like Word, each
application (process) can be running many threads that are performing
any number of tasks. The significance here is that threads are
always associated with a particular process. Figure 20.1 shows
the relationship between threads and processes.
<P>
<A HREF="f20-1.gif" ><B>Figure 20.1: </B><I>The relationship between threads and processes.</I></A>
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Threads are sometimes referred to as <I>lightweight processes</I>, implying that they are a limited form of a process. A thread is in fact very similar to a full-blown process, with the major difference being that a thread always runs within the context of another program. Unlike processes, which maintain their own address space and operating environment, threads rely on a parent program for execution resources.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
I've described threads and processes using Windows 95 as an example,
so you've probably guessed that Java isn't the first system to
employ the use of threads. That's true, but Java is the first
major programming language to incorporate threads at the heart
of the language itself. Typically, threads are implemented at
the system level, requiring a platform-specific programming interface
separate from the core programming language. This is the case
with C/C++ Windows programming, because you have to use the Win32
programming interface to develop multithreaded Windows applications.
<P>
Java is presented as both a language and a runtime system, so
the Sun architects were able to integrate threads into both. The
end result is that you are able to make use of Java threads in
a standard, cross-platform fashion. Trust me, this is no small
feat, especially considering the fact that some systems, like
Windows 3.1, don't have any native support for threads!
<H2><A NAME="TheThreadClasses"><FONT SIZE=5 COLOR=#FF0000>The
Thread Classes</FONT></A></H2>
<P>
The Java programming language provides support for threads through
a single interface and a handful of classes. The Java interface
and classes that include thread functionality follow:
<UL>
<LI><TT><FONT FACE="Courier">Thread</FONT></TT>
<LI><TT><FONT FACE="Courier">Runnable</FONT></TT>
<LI><TT><FONT FACE="Courier">ThreadDeath</FONT></TT>
<LI><TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
<LI><TT><FONT FACE="Courier">Object</FONT></TT>
</UL>
<P>
All of these classes are part of the <TT><FONT FACE="Courier">java.lang</FONT></TT>
package, and they are covered in great detail in <A HREF="ch32.htm" >Chapter 32</A>,
&quot;Package <TT><FONT FACE="Courier">java.lang</FONT></TT>.&quot;
For now, take a brief look at what each offers in the way of thread
support.
<H3><A NAME="Thread"><TT><FONT SIZE=4 FACE="Courier">Thread</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">Thread</FONT></TT> class is the primary
class responsible for providing thread functionality to other
classes. To add thread functionality to a class, you simply derive
the class from <TT><FONT FACE="Courier">Thread</FONT></TT> and
override the <TT><FONT FACE="Courier">run</FONT></TT> method.
The <TT><FONT FACE="Courier">run</FONT></TT> method is where the
processing for a thread takes place, and it is often referred
to as the <I>thread body</I>. The <TT><FONT FACE="Courier">Thread</FONT></TT>
class also defines <TT><FONT FACE="Courier">start</FONT></TT>
and <TT><FONT FACE="Courier">stop</FONT></TT> methods that allow
you to start and stop the execution of the thread, along with
a host of other useful methods.
<H3><TT><FONT SIZE=4 FACE="Courier"><A NAME="Runnable1">Runnable</A></FONT></TT></H3>
<P>
Java does not directly support multiple inheritance, which involves
deriving a class from <BR>
multiple parent classes. This brings up a pretty big question
in regard to adding thread functionality to a class: how can you
derive from the <TT><FONT FACE="Courier">Thread</FONT></TT> class
if you are already deriving from another class? The answer is:
you can't! This is where the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface comes into play.
<P>
The <TT><FONT FACE="Courier">Runnable</FONT></TT> interface provides
the overhead for adding thread functionality to a class simply
by implementing the interface, rather than deriving from <TT><FONT FACE="Courier">Thread</FONT></TT>.
Classes that implement the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface simply provide a <TT><FONT FACE="Courier">run</FONT></TT>
method that is executed by an associated thread object that is
created separately. This is a very useful feature and is often
the only outlet you have to incorporating multithreading into
existing classes.
<H3><A NAME="ThreadDeath"><TT><FONT SIZE=4 FACE="Courier">ThreadDeath</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">ThreadDeath</FONT></TT> error class
provides a mechanism for allowing you to clean up after a thread
is asynchronously terminated. I'm calling the <TT><FONT FACE="Courier">ThreadDeath</FONT></TT>
an error class because it is derived from the <TT><FONT FACE="Courier">Error</FONT></TT>
class, which provides a means of handling and reporting errors.
When the <TT><FONT FACE="Courier">stop</FONT></TT> method is called
on a thread, an instance of <TT><FONT FACE="Courier">ThreadDeath</FONT></TT>
is thrown by the dying thread as an error. You should only catch
the <TT><FONT FACE="Courier">ThreadDeath</FONT></TT> object if
you need to perform cleanup specific to the asynchronous termination,
which is a pretty rare situation. If you do catch the object,
you must rethrow it so the thread will actually die.
<H3><A NAME="ThreadGroup"><TT><FONT SIZE=4 FACE="Courier">ThreadGroup</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">ThreadGroup</FONT></TT> class is
used to manage a group of threads as a single unit. This provides
you with a means to finely control thread execution for a series
of threads. For example, the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
class provides <TT><FONT FACE="Courier">stop</FONT></TT>, <TT><FONT FACE="Courier">suspend</FONT></TT>,
and <TT><FONT FACE="Courier">resume</FONT></TT> methods for controlling
the execution of all the threads in the group. Thread groups can
also contain other thread groups, allowing for a nested hierarchy
of threads. Individual threads have access to their immediate
thread group, but not to the parent of the thread group.
<H3><A NAME="Object"><TT><FONT SIZE=4 FACE="Courier">Object</FONT></TT></A>
</H3>
<P>
Although not strictly a thread support class, the <TT><FONT FACE="Courier">Object</FONT></TT>
class does provide a few methods that are crucial to the Java
thread architecture. These methods are <TT><FONT FACE="Courier">wait</FONT></TT>,
<TT><FONT FACE="Courier">notify</FONT></TT>, and <TT><FONT FACE="Courier">notifyAll</FONT></TT>.
The <TT><FONT FACE="Courier">wait</FONT></TT> method causes a
thread to wait in a sleep state until it is notified to continue.
Likewise, the <TT><FONT FACE="Courier">notify</FONT></TT> method
informs a waiting thread to continue along with its processing.
The <TT><FONT FACE="Courier">notifyAll</FONT></TT> method is similar
to <TT><FONT FACE="Courier">notify</FONT></TT> except it applies
to all waiting threads. These three methods can only be called
from a synchronized method; don't worry, you'll learn more about
synchronized methods a little later in this chapter.
<P>
Typically, these methods are used with multiple threads, where
one method waits for another to finish some processing before
it can continue. The first thread waits for the other thread to
notify it so it can continue. Just in case you're in the dark
here, the <TT><FONT FACE="Courier">Object</FONT></TT> class rests
at the top of the Java class hierarchy, meaning that it is the
parent of all classes. In other words, every Java class inherits
the functionality provided by <TT><FONT FACE="Courier">Object</FONT></TT>,
including the <TT><FONT FACE="Courier">wait</FONT></TT>, <TT><FONT FACE="Courier">notify</FONT></TT>,
and <TT><FONT FACE="Courier">notifyAll</FONT></TT> methods. For
more information on the <TT><FONT FACE="Courier">Object</FONT></TT>
class, check out <A HREF="ch32.htm" >Chapter 32</A>.
<H2><A NAME="CreatingThreads"><FONT SIZE=5 COLOR=#FF0000>Creating
Threads</FONT></A></H2>
<P>
Threads aren't much use if you don't know how to create them.
Fortunately, you have two options for creating and using threads
in your own programs, which have already been alluded to when
discussing the thread classes:
<UL>
<LI><FONT COLOR=#000000>Derive your class from the </FONT><TT><FONT FACE="Courier">Thread</FONT></TT>
class and override its <TT><FONT FACE="Courier">run</FONT></TT>
method.
<LI><FONT COLOR=#000000>Implement the </FONT><TT><FONT FACE="Courier">Runnable</FONT></TT>
interface in your class and provide an implementation for the
<TT><FONT FACE="Courier">run</FONT></TT> method.
</UL>
<P>
Both of these approaches revolve around providing a <TT><FONT FACE="Courier">run</FONT></TT>
method, which is where all the actual processing takes place.
After a thread has been created and initialized, its <TT><FONT FACE="Courier">run</FONT></TT>
method is called and given the opportunity to perform whatever
processing the thread is designed to provide. Because it provides
all the processing power, the <TT><FONT FACE="Courier">run</FONT></TT>
method is the heart of a thread. It's not uncommon for the <TT><FONT FACE="Courier">run</FONT></TT>
method to consist of an infinite loop that performs some repetitive
action like updating the frames of an animation. But enough about
<TT><FONT FACE="Courier">run</FONT></TT> for now; go ahead and
create some threads!
<H3><A NAME="DerivingfromtheThreadClass">Deriving from the <TT><FONT SIZE=4 FACE="Courier">Thread</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
If your class isn't derived from a specific class, you can easily
make it threaded by deriving it from the <TT><FONT FACE="Courier">Thread</FONT></TT>
class. The following source code shows how to add thread functionality
to a class by deriving from the <TT><FONT FACE="Courier">Thread</FONT></TT>
class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ThreadMe extends Thread
{<BR>
&nbsp;&nbsp;public run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do some busy work<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
It's as easy as that! To use this class in a real program and
set the thread in motion, you simply create a <TT><FONT FACE="Courier">ThreadMe</FONT></TT>
object and call the <TT><FONT FACE="Courier">start</FONT></TT>
method inherited from <TT><FONT FACE="Courier">Thread</FONT></TT>,
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadMe me = new ThreadMe();<BR>
me.start();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">start</FONT></TT> method automatically
calls <TT><FONT FACE="Courier">run</FONT></TT> and gets the thread
busy performing its processing. The thread will then run until
the <TT><FONT FACE="Courier">run</FONT></TT> method exits or the
thread is stopped, suspended, or killed. If for some reason you
want to stop the thread's execution, just call the <TT><FONT FACE="Courier">stop</FONT></TT>
method, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">me.stop();</FONT></TT>
</BLOCKQUOTE>
<P>
If stopping the thread entirely is a little too abrupt, you can
also temporarily pause it by calling the <TT><FONT FACE="Courier">suspend</FONT></TT>
method, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">me.suspend();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">suspend</FONT></TT> method puts the
thread in a wait state, very similar to the state a thread enters
when you call the <TT><FONT FACE="Courier">wait</FONT></TT> method.
When you decide the thread has waited long enough, just call <TT><FONT FACE="Courier">resume</FONT></TT>
to get things rolling again, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">me.resume();</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="ImplementingtheRunnableInterface">Implementing the
<TT><FONT SIZE=4 FACE="Courier">Runnable</FONT></TT><FONT SIZE=4>
Interface</FONT></A></H3>
<P>
If your class needs to derive from a class other than <TT><FONT FACE="Courier">Thread</FONT></TT>,
you are forced to implement the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface to make it threaded. A very common situation where you
have to do this is when an applet class needs to be threaded.
Because applet classes must be derived from the <TT><FONT FACE="Courier">Applet</FONT></TT>
class, and Java doesn't provide a mechanism for multiple inheritance,
you have no other option but to implement the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface to add threading support. You implement the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface in a class like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ThreadYou implements Runnable
{<BR>
&nbsp;&nbsp;&nbsp;public run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do some busy work<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see, the only syntactic difference in this approach
is that you use the <TT><FONT FACE="Courier">implements</FONT></TT>
keyword instead of <TT><FONT FACE="Courier">extends</FONT></TT>.
However, notice that you can still use the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword to derive from another class, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ThreadedApp extends Applet
implements Runnable {<BR>
&nbsp;&nbsp;&nbsp;public run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do some busy work<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
This is a very practical scenario involving an applet class with
a <TT><FONT FACE="Courier">run</FONT></TT> method that performs
some type of threaded processing. Even though the definition of
a class implementing the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface is little different than directly deriving from <TT><FONT FACE="Courier">Thread</FONT></TT>,
there is a big difference when it comes to creating the thread
and getting it running. Creating and running a threaded class
implementing the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface is a three-part process, as the following code shows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadYou you = new ThreadYou();<BR>
Thread t = new Thread(you);<BR>
t.start();</FONT></TT>
</BLOCKQUOTE>
<P>
Unlike the previous approach involving creating a thread object
and calling its <TT><FONT FACE="Courier">start</FONT></TT> method,
this approach requires you to create both an instance of your
class and a separate instance of the <TT><FONT FACE="Courier">Thread</FONT></TT>
class. You pass your object into the <TT><FONT FACE="Courier">Thread</FONT></TT>
class's constructor, which gives it access to your <TT><FONT FACE="Courier">run</FONT></TT>
method. You then set the thread running by calling the thread
object's <TT><FONT FACE="Courier">start</FONT></TT> method. The
thread in turn executes your object's <TT><FONT FACE="Courier">run</FONT></TT>
method. The thread knows your class has a <TT><FONT FACE="Courier">run</FONT></TT>
method because it implements the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface.
<P>
If you have no need to access the thread after you get it started,
the creation and starting of the thread can be combined into one
statement, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadYou you = new ThreadYou();<BR>
new Thread(you).start();</FONT></TT>
</BLOCKQUOTE>
<P>
This approach eliminates the creation of the local variable <TT><FONT FACE="Courier">t</FONT></TT>,
which makes the code a little more efficient. Of course, you may
think the original code is easier to understand, in which case
you should by all means stick with the clearer technique.
<H2><A NAME="SchedulingandThreadPriority"><FONT SIZE=5 COLOR=#FF0000>Scheduling
and Thread Priority</FONT></A></H2>
<P>
You may be wondering how any software system can be truly threaded
when running on a machine with a single CPU. If there is only
one physical CPU in a computer system, it's impossible for more
than one machine code instruction to be executed at a time. This
means that no matter how hard you try to rationalize the behavior
of a multithreaded system, only one thread is really being executed
at a particular time. The reality is that multithreading on a
single CPU system, like the systems most of us use, is at best
a good illusion. The good news is that the illusion works so well
most of the time that we feel pretty comfortable in the thought
that multiple threads are really running in parallel.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Incidentally, this same rule applies to multiprocessing systems involving a single CPU. Even though it may look as though you're downloading a file and playing a game in parallel, under the hood the CPU is busy juggling the execution of each process.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="HowItWorks">How It Works</A></H3>
<P>
The illusion of parallel thread execution on a system with a single
CPU is often managed by giving each thread an opportunity to execute
a little bit of code at regular intervals. This approach is known
as <I>timeslicing</I>, which refers to the way each thread gets
a little of the CPU's time to execute code. When you speed up
this whole scenario to millions of instructions per second, the
whole effect of parallel execution comes across pretty well. The
general task of managing and executing multiple threads in an
environment such as this is known as <I>scheduling</I>. So far,
I've described the most basic form of timesliced scheduling, where
every thread is given equal access to the processor in small increments.
In reality, this turns out not to be the best approach to managing
thread execution.
<P>
Undoubtedly, there are going to be situations where you would
like some threads to get more of the CPU's attention than others.
To accommodate this reality, most threaded systems employ some
type of prioritization to allow threads to execute at different
priority levels. Java employs a type of scheduling known as <I>fixed
priority scheduling</I>, which schedules thread execution based
on the relative priorities between threads. It works like this:
each thread is assigned a relative priority level, which determines
the order in which it receives access to the CPU. High-priority
threads are given first rights to the CPU, while low-priority
threads are left to execute when the CPU is idle.
<P>
One interesting thing about Java's approach to scheduling is that
it doesn't employ timeslicing. In other words, the currently executing
thread gets to enjoy the complete control of the CPU until it
yields control to other threads. Lower-priority threads must simply
wait until high-priority threads give them a chance to execute.
Threads with the same priority level are given access to the CPU
one after the next. Figure 20.2 shows how priority impacts the
order in which threads are executed.
<P>
<A HREF="f20-2.gif" ><B>Figure 20.2:</B> <I>The relationship between thread priority and execution.</I></A><P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Java runtime system itself could be merely a single process within a timesliced multiprocessing system on a particular platform. In this way, the fixed priority scheduling employed in Java applies only to Java programs executing within the Java runtime environment.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
A good example of a low-priority thread is the garbage collection
thread in the Java runtime system. Even though garbage collection
is a very important function, it is not something you want hogging
the CPU. Because the garbage collection thread is a low-priority
thread, it chugs along in the background freeing up memory as
the processor allows it. This may result in memory being freed
a little more slowly, but it allows more time-critical threads,
such as the user input handling thread, full access to the CPU.
You may be wondering what happens if the CPU stays busy and the
garbage collector never gets to clean up memory. Does the runtime
system run out of memory and crash? No-this brings up one of the
neat aspects of threads and how they work. If a high-priority
thread can't access a resource it needs, such as memory, it enters
a wait state until memory becomes available. When all memory is
gone, all the threads running will eventually go into a wait state,
thereby freeing up the CPU to execute the garbage collection thread,
which in turn frees up memory. And the circle of threaded life
continues!
<H3><A NAME="EstablishingThreadPriority">Establishing Thread Priority</A>
</H3>
<P>
When a new thread is created, it inherits its priority from the
thread that created it. The <TT><FONT FACE="Courier">Thread</FONT></TT>
class defines three constants representing the relative priority
levels for threads, which follow:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">MIN_PRIORITY<BR>
NORM_PRIORITY<BR>
MAX_PRIORITY</FONT></TT>
</BLOCKQUOTE>
<P>
The Java garbage collection thread has a priority of <TT><FONT FACE="Courier">MIN_PRIORITY</FONT></TT>,
whereas the system thread that manages user input events has a
priority of <TT><FONT FACE="Courier">MAX_PRIORITY</FONT></TT>.
Knowing this, it's a good idea to take the middle road for most
of your own threads and declare them as <TT><FONT FACE="Courier">NORM_PRIORITY</FONT></TT>.
Generally speaking, this should happen without your having to
do anything special because the parent thread you are creating
threads from will likely be set to <TT><FONT FACE="Courier">NORM_PRIORITY</FONT></TT>.
If, however, you want to explicitly set a thread's priority, it's
pretty easy-the <TT><FONT FACE="Courier">Thread</FONT></TT> class
provides a method called <TT><FONT FACE="Courier">setPriority</FONT></TT>
that allows you to directly set a thread's priority.
<P>
Incidentally, the thread priority constants are actually integers
that define a range of priorities. <TT><FONT FACE="Courier">MIN_PRIORITY</FONT></TT>
and <TT><FONT FACE="Courier">MAX_PRIORITY</FONT></TT> are the
lower and upper limits of the range of acceptable priority values,
while <TT><FONT FACE="Courier">NORM_PRIORITY</FONT></TT> rests
squarely in the middle of the range. This means that you can offset
these values to get varying priority levels. If you pass a priority
value outside the legal range (<TT><FONT FACE="Courier">MIN_PRIORITY</FONT></TT>
to <TT><FONT FACE="Courier">MAX_PRIORITY</FONT></TT>), the thread
will throw an exception of type <TT><FONT FACE="Courier">IllegalArgumentException</FONT></TT>.
<P>
Getting back to the <TT><FONT FACE="Courier">setPriority</FONT></TT>
method, you can use it to set a thread's priority like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">t.setPriority(Thread.MAX_PRIORITY);</FONT></TT>
</BLOCKQUOTE>
<P>
Likewise, you can use the <TT><FONT FACE="Courier">getPriority</FONT></TT>
method to retrieve a thread's priority like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int priority = t.getPriority();</FONT></TT>
</BLOCKQUOTE>
<P>
Knowing that thread priority is a relative integer value, you
can fine-tune a thread's priority by incrementing or decrementing
its priority value, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">t.setPriority(t.getPriority() + 1);</FONT></TT>
</BLOCKQUOTE>
<P>
This statement moves the thread up a little in the priority list.
Of course, the extents of the priority range determine the effectiveness
of this statement; in the current release of Java, <TT><FONT FACE="Courier">MIN_PRIORITY</FONT></TT>
is set to 1 and <TT><FONT FACE="Courier">MAX_PRIORITY</FONT></TT>
is set to 10.
<H2><A NAME="Daemons"><FONT SIZE=5 COLOR=#FF0000>Daemons</FONT></A>
</H2>
<P>
So far, you've been learning about threads that operate within
the context of a parent program. Java provides support for another
type of thread, called a <I>daemon thread</I>, that acts in many
ways like an independent process. Unlike traditional threads,
daemon threads belong to the runtime system itself, rather than
a particular program. Daemon threads are typically used to manage
some type of background service available to all programs. The
garbage collection thread is a perfect example of a daemon thread;
it chugs along without regard to any particular program performing
a very useful service that benefits all programs.
<P>
You can set a thread as a daemon thread simply by calling the
<TT><FONT FACE="Courier">setDaemon</FONT></TT> method, which is
defined in the <TT><FONT FACE="Courier">Thread</FONT></TT> class,
and passing <TT><FONT FACE="Courier">true</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">thread.setDaemon(true);</FONT></TT>
</BLOCKQUOTE>
<P>
You can query a thread to see if it is a daemon thread simply
by calling the <TT><FONT FACE="Courier">isDaemon</FONT></TT> method,
which is also defined in the <TT><FONT FACE="Courier">Thread</FONT></TT>
class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean b = thread.isDaemon();</FONT></TT>
</BLOCKQUOTE>
<P>
The Java runtime interpreter typically stays around until all
threads in the system have finished executing. However, it makes
an exception when it comes to daemon threads. Because daemon threads
are specifically designed to provide some type of service for
full-blown programs, it makes no sense to continue to run them
when there are no programs running. So, when all the remaining
threads in the system are daemon threads, the interpreter exits.
This is still the same familiar situation of the interpreter exiting
when your program finishes executing; you just may not have realized
there were daemon threads out there as well.
<H2><A NAME="GroupingThreads"><FONT SIZE=5 COLOR=#FF0000>Grouping
Threads</FONT></A></H2>
<P>
Earlier you learned a little about the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
class, which is used to group threads together. Grouping threads
is sometimes useful because it allows you to control multiple
threads as a single entity. For example, the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
class has <TT><FONT FACE="Courier">suspend</FONT></TT> and <TT><FONT FACE="Courier">resume</FONT></TT>
methods, which can be used to suspend and resume the entire group
of threads. What you haven't learned is how to actually manage
thread groups, which is the focus of this section.
<P>
Every thread in the Java runtime system belongs to a thread group.
You may be wondering how this is possible, considering the fact
that you saw earlier how to create threads with no mention of
a thread group. If you create a thread without specifying a thread
group, the thread is added to the group that the current thread
belongs to. The current thread is the thread where the new thread
is created from. In some cases, there may not be a current thread,
in which case the Java runtime system adds the thread to a default
thread group called <TT><FONT FACE="Courier">main</FONT></TT>.
<P>
You associate threads with a particular group upon thread creation.
There is no way to alter the group membership of a thread once
it has been created; in other words, you get one opportunity to
specify the permanent group for a thread when you create the thread.
The Thread class includes constructors for specifying the thread
group for the thread:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Thread(ThreadGroup, String)<BR>
Thread(ThreadGroup, Runnable)<BR>
Thread(ThreadGroup, Runnable, String)</FONT></TT>
</BLOCKQUOTE>
<P>
Each constructor takes a <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
object as the first parameter. The first constructor also takes
a string parameter, allowing you to give the thread a name. The
last two constructors take a <TT><FONT FACE="Courier">Runnable</FONT></TT>
object as the second parameter, which is typically an object of
your own concoction that implements the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface. Finally, the last constructor also takes a string parameter,
allowing you to name the thread.
<P>
Before you can create any threads, you need to create a <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
object. The <TT><FONT FACE="Courier">ThreadGroup</FONT></TT> class
defines two constructors, which follow:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadGroup(String name)<BR>
ThreadGroup(ThreadGroup parent, String name)</FONT></TT>
</BLOCKQUOTE>
<P>
The first constructor simply creates an empty thread group with
the specified name. The second constructor does the same thing,
but places the new thread group within the thread group specified
in the <TT><FONT FACE="Courier">parent</FONT></TT> parameter.
This constructor allows you to nest thread groups.
<P>
Take a look at a quick example of creating a thread group and
adding a few threads to it. The following code shows how to create
and manage a thread group and a couple of member threads:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadGroup group = new ThreadGroup(&quot;Queen
bee&quot;);<BR>
Thread t1 = new Thread(group, &quot;Worker bee 1&quot;);<BR>
Thread t2 = new Thread(group, &quot;Worker bee 2&quot;);<BR>
t1.start();<BR>
t2.start();<BR>
...<BR>
group.suspend();<BR>
...<BR>
group.resume();</FONT></TT>
</BLOCKQUOTE>
<P>
After the thread group is created, each thread is created and
passed the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT> object.
This makes them members of the thread group. Each thread is then
started by calling the <TT><FONT FACE="Courier">start</FONT></TT>
method of each; the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
class doesn't provide a means to start all the thread members
at once. Sometime later the thread group suspends both threads
with a call to the <TT><FONT FACE="Courier">suspend</FONT></TT>
method. It then gets them running again by calling <TT><FONT FACE="Courier">resume</FONT></TT>.
<P>
You can find out what group a thread belongs to by calling the
<TT><FONT FACE="Courier">getThreadGroup</FONT></TT> method. This
method returns the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
object that the thread belongs to. You can then find out the name
of the thread group by calling the <TT><FONT FACE="Courier">getName</FONT></TT>
method defined in the <TT><FONT FACE="Courier">ThreadGroup</FONT></TT>
class. The following code shows how to print the name of the thread
group for a particular thread.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ThreadGroup group = t.getThreadGroup();
<BR>
System.out.println(group.getName());</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ThreadStates"><FONT SIZE=5 COLOR=#FF0000>Thread States</FONT></A>
</H2>
<P>
Thread behavior is completely dependent on the state a thread
is in. The <I>state</I> of a thread defines its current mode of
operation, such as whether it is running or not. Following is
a list of the Java thread states:
<UL>
<LI><FONT COLOR=#000000>New</FONT>
<LI><FONT COLOR=#000000>Runnable</FONT>
<LI><FONT COLOR=#000000>Not running</FONT>
<LI><FONT COLOR=#000000>Dead</FONT>
</UL>
<H3><A NAME="New">New</A></H3>
<P>
A thread is in the &quot;new&quot; state when it is first created
until its <TT><FONT FACE="Courier">start</FONT></TT> method is
called. New threads are already initialized and ready to get to
work, but they haven't been given the cue to take off and get
busy.
<H3><A NAME="Runnable">Runnable</A></H3>
<P>
When the <TT><FONT FACE="Courier">start</FONT></TT> method is
called on a new thread, the <TT><FONT FACE="Courier">run</FONT></TT>
method is in turn called and the thread enters the &quot;runnable&quot;
state. You may be thinking this state should just be called &quot;running,&quot;
because the execution of the <TT><FONT FACE="Courier">run</FONT></TT>
method means a thread is running. However, you have to take into
consideration the whole priority issue of threads having to potentially
share a single CPU. Even though every thread may be running from
an end-user perspective, in actuality all but the one currently
accessing the CPU are in a &quot;runnable&quot; wait state at
any particular instant. You can still conceptually think of the
&quot;runnable&quot; state as the &quot;running&quot; state; just
remember that all threads have to share system resources.
<H3><A NAME="NotRunning">Not Running</A></H3>
<P>
The &quot;not running&quot; state applies to all threads that
are temporarily halted for some reason. When a thread is in this
state, it is still available for use and is capable of re-entering
the &quot;runnable&quot; state at some point. Threads can enter
the &quot;not running&quot; state through a variety of means.
Following is a list of the different possible events that can
cause a thread to be temporarily halted:
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">suspend</FONT></TT>
method is called.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">sleep</FONT></TT>
method is called.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">wait</FONT></TT>
method is called.
<LI><FONT COLOR=#000000>The thread is blocking for I/O.</FONT>
</UL>
<P>
For each of these actions causing a thread to enter the &quot;not
running&quot; state, there is an equivalent response to get the
thread running again. Following is a list of the corresponding
events that can put a thread back in the &quot;runnable&quot;
state:
<UL>
<LI><FONT COLOR=#000000>If a thread is suspended, the </FONT><TT><FONT FACE="Courier">resume</FONT></TT>
method is called.
<LI><FONT COLOR=#000000>If a thread is sleeping, the number of
specified milliseconds elapse.</FONT>
<LI><FONT COLOR=#000000>If a </FONT>thread is waiting, the object
owning the condition variable calls <TT><FONT FACE="Courier">notify</FONT></TT>
or <TT><FONT FACE="Courier">notifyAll.</FONT></TT>
<LI><FONT COLOR=#000000>If a thread is blocking for I/O, the I/O
operation finishes.</FONT>
</UL>
<H3><A NAME="Dead">Dead</A></H3>
<P>
A thread enters the &quot;dead&quot; state when it is no longer
needed. Dead threads cannot be revived and executed again. A thread
can enter the &quot;dead&quot; state through one of two approaches,
which follow:
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">run</FONT></TT>
method finishes executing.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">stop</FONT></TT>
method is called.
</UL>
<P>
The first approach is the natural way for a thread to die; you
can think of a thread dying when its <TT><FONT FACE="Courier">run</FONT></TT>
method finishes executing as death by natural causes. In contrast
to this is a thread dying by way of the <TT><FONT FACE="Courier">stop</FONT></TT>
method; calling the <TT><FONT FACE="Courier">stop</FONT></TT>
method kills a thread in an asynchronous fashion.
<P>
Even though the latter approach sounds kind of abrupt, it is often
very useful. For example, it's common for applets to kill their
threads using <TT><FONT FACE="Courier">stop</FONT></TT> when their
own <TT><FONT FACE="Courier">stop</FONT></TT> method is called.
The reason for this is that an applet's <TT><FONT FACE="Courier">stop</FONT></TT>
method is usually called in response to a user leaving the Web
page containing the applet. You don't want threads out there executing
for an applet that isn't even active, so killing the threads makes
perfect sense.
<H2><A NAME="Synchronization"><FONT SIZE=5 COLOR=#FF0000>Synchronization</FONT></A>
</H2>
<P>
Throughout the discussion of threads thus far, you've really only
learned about threads from an asynchronous perspective. In other
words, you've only been concerned with getting threads up and
running and not worrying too much about how they actually execute.
You can only think in these terms when you are dealing with a
single thread or with threads that don't interact with the same
data. In reality, there are many instances where it is useful
to have multiple threads running and accessing the same data.
In this type of scenario, the asynchronous programming approach
just won't work; you must take extra steps to synchronize the
threads so they don't step on each other's toes.
<P>
The problem of thread synchronization occurs when multiple threads
attempt to access the same resources or data. As an example, imagine
the situation where two threads are accessing the same data file;
one thread may be writing to the file while the other thread is
simultaneously reading from it. This type of situation can create
some very unpredictable, and therefore undesirable, results.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
When data objects are shared between competing threads, they are referred to as <I>condition variables</I>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
When you are dealing with threads that are competing for limited
resources, you simply must take control of the situation to ensure
that each thread gets equal access to the resources in a predictable
manner. A system where each thread is given a reasonable degree
of access to resources is called a <I>fair system</I>. The two
situations you must try to avoid when implementing a fair system
are starvation and deadlock. <I>Starvation</I> occurs when a thread
is completely cut off from the resources and can't make any progress;
the thread is effectively frozen. Where starvation can apply to
a number of threads individually, <I>deadlock</I> occurs when
two or more threads are waiting for a mutual condition that can
never be satisfied; they are starving each other.
<H3><A NAME="AHypotheticalExample">A Hypothetical Example</A>
</H3>
<P>
A popular hypothetical example that more clearly demonstrates
the problem of deadlock is the dining philosophers. The story
goes that there are five hungry philosophers sitting around a
table preparing to eat. In front of each philosopher is a bowl
of rice, while between each philosopher there is a chopstick.
To take a bite of rice, a philosopher needs two chopsticks: one
from the left and one from the right. In this situation, the philosophers
are equivalent to threads, with the chopsticks representing the
limited, shared resources they all need access to. Their desired
function is to eat the rice, which requires access to a pair of
chopsticks.
<P>
The philosophers are only allowed to pick up one chopstick at
a time, and they must always pick up the left chopstick and then
the right. When a philosopher gets both chopsticks, he can take
a bite of rice and then put down both chopsticks. This sounds
like a pretty reasonable system of sharing the limited resources
so everyone can eat. But consider what happens when each philosopher
goes after the chopsticks with equal access to them. Each philosopher
immediately grabs the chopstick to his left, resulting in every
philosopher having a single chopstick. They all then reach for
the chopstick on their right, which is now being held by the philosopher
to their right. They are all waiting for another chopstick, so
they each just sit holding a single chopstick indefinitely. Both
figuratively and literally, they are starving each other!
<P>
This is a very good example of how a seemingly fair system can
easily go awry. One potential solution to this problem is to force
each philosopher to wait a varying amount of time before attempting
to grab each chopstick. This approach definitely helps, and the
philosophers will probably get to eat some rice, but the potential
for deadlock, and therefore starvation, is still there. You are
counting on blind luck to save the day and keep the philosophers
well fed. In case you didn't guess, this isn't the ideal approach
to solving deadlock problems.
<P>
You have two approaches to solving deadlock in a situation like
this: prevention or detection. Prevention means designing the
system so that deadlock is impossible. Detection, on the other
hand, means allowing for deadlock but detecting it and dealing
with its consequences when they arise. As with a medical illness,
it doesn't take a huge mental leap to realize that prevention
usually involves much less pain than detection, which results
in sort of a chemotherapy for deadlock. My vote is clearly for
avoiding deadlock in the first place. Besides, trying to detect
deadlock can often be a daunting task in and of itself.
<P>
Getting back to the famished philosophers, the root of the problem
is the fact that there is no order imposed on the selection of
chopsticks. By assigning a priority order to the chopsticks, you
can easily solve the deadlock problem; just assign increasing
numbers to the chopsticks. Then force the philosophers to always
pick up the chopstick with the lower number first. This results
in the philosopher sitting between chopsticks 1 and 2 and the
philosopher sitting between chopsticks 1 and 5 both going for
chopstick 1. Whoever gets it first is then able to get the remaining
chopstick, while the other philosopher is left waiting. When the
lucky philosopher with two chopsticks finishes his bite and returns
the chopsticks, the process repeats itself, allowing all the philosophers
to eat. Deadlock has been successfully avoided!
<H3><A NAME="SynchronizingThreads">Synchronizing Threads</A></H3>
<P>
If you're thinking the dining philosophers example seems fairly
simple, you're right. But don't get too confident yet-real-world
thread synchronization situations can get extremely messy. Fortunately,
Java provides a very powerful solution to the whole issue: the
<TT><FONT FACE="Courier">synchronized</FONT></TT> modifier. The
<TT><FONT FACE="Courier">synchronized</FONT></TT> modifier is
used to flag certain parts of your code as synchronized, resulting
in limited, predictable access for threads. More specifically,
only one thread is allowed access to a synchronized section of
code at a time.
<P>
For synchronized methods, it works like this: each synchronized
method is given a lock, which determines if it can be accessed,
similar to a real lock. When a thread attempts to access the method,
it must first see if it is locked, in which case the thread is
denied access. If the method isn't locked, the thread gets access
and the method then becomes locked. Pretty simple, right?<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Locks can apply to both methods as well as entire classes, but not directly to individual blocks of code. You are allowed to specify an object or class that is locked for a particular block of synchronized code, but the block itself isn't locked.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Synchronized sections of code are called <I>critical sections</I>,
implying that access to them is critical to the successful threaded
execution of the program. Critical sections are also sometimes
referred to as <I>atomic operations</I>, meaning that they appear
to other threads as if they occur at once. In other words, just
as an atom is a discrete unit of matter, atomic operations effectively
act like a discrete operation to other threads, even though they
may really contain many operations inside.
<P>
You can use the <TT><FONT FACE="Courier">synchronized</FONT></TT>
modifier to mark critical sections in your code and make them
threadsafe. Following are some examples of using the <TT><FONT FACE="Courier">synchronized</FONT></TT>
modifier:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">synchronized public void addEmUp() {
<BR>
&nbsp;&nbsp;float a, b;<BR>
&nbsp;&nbsp;a += b;<BR>
&nbsp;&nbsp;b += a;<BR>
}<BR>
<BR>
public void moveEmOut() {<BR>
&nbsp;&nbsp;Rectangle rect;<BR>
&nbsp;&nbsp;synchronized (rect) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;rect.width -= 2;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;rect.height -= 2;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The first example shows how to secure an entire method and make
it synchronized; only one thread is allowed to execute the <TT><FONT FACE="Courier">addEmUp</FONT></TT>
method at a time. The <TT><FONT FACE="Courier">moveEmOut</FONT></TT>
method, on the other hand, contains a synchronized block of code
within it. The synchronized block protects the width of the rectangle
from being modified by multiple threads at once. Notice that the
<TT><FONT FACE="Courier">rect</FONT></TT> object itself is used
as the lock for the block of code. Also notice that the modification
of the height of the rectangle isn't included in the synchronized
block, and therefore is subject to access by multiple threads
at once.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
It's important to note that even though there are legitimate situations where you will need to make a block of code synchronized, in general it is better to apply synchronization at the method level. Employing method synchronization as opposed to block synchronization facilitates a more object-oriented design and results in code that is easier to debug and maintain.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
There is a subtle problem when using synchronized methods that
you may not have thought about. Check out the following code sample:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class countEngine {<BR>
&nbsp;&nbsp;private static int count;<BR>
&nbsp;&nbsp;public synchronized void decCount() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count--;<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">decCount</FONT></TT> method is synchronized,
so it appears that the <TT><FONT FACE="Courier">count</FONT></TT>
member variable is protected from misuse. However, <TT><FONT FACE="Courier">count</FONT></TT>
is a class variable, not an instance variable, because it is declared
as being static. The lock on the synchronized method is performed
on the instance object, so the class data isn't protected. The
solution is to synchronize the block using the class as the locked
object, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class countEngine {<BR>
&nbsp;&nbsp;private static int count;<BR>
&nbsp;&nbsp;public void decCount() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;synchronized (getClass()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count--;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that the <TT><FONT FACE="Courier">getClass</FONT></TT>
method is called to retrieve the class for the synchronized block.
This is a perfect example of where you have to use block synchronization
over method synchronization to get a desired result.
<H3><A NAME="VolatileVariables">Volatile Variables</A></H3>
<P>
In rare cases where you don't mind threads modifying a variable
whenever they please, Java provides a means of maintaining the
variable's integrity. The <TT><FONT FACE="Courier">volatile</FONT></TT>
modifier allows you to specify that a variable will be modified
asynchronously by threads. The purpose of the <TT><FONT FACE="Courier">volatile</FONT></TT>
modifier is to protect against variable corruption through registered
storage of the variable. In an asynchronous environment, corruption
can sometimes occur when a variable is stored in CPU registers.
The <TT><FONT FACE="Courier">volatile</FONT></TT> modifier tells
the runtime system to always reference a variable directly from
memory, instead of using a register. Furthermore, the variable
is read from and written back to memory after each access, just
to be safe. It's fairly rare that you'll need to use the <TT><FONT FACE="Courier">volatile</FONT></TT>
modifier, but if you feel like living on the edge, it's there
for your enjoyment!
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned about multithreading from both a
conceptual level and a practical programming level, while seeing
exactly what facilities Java provides to support multithreaded
programming. You saw the two techniques for creating threads using
the <TT><FONT FACE="Courier">Thread</FONT></TT> class and the
<TT><FONT FACE="Courier">Runnable</FONT></TT> interface. You then
took a look at the Java scheduler and how it affects thread priority.
You moved on to daemons and thread groups, and why they are important.
You finished up by tackling the issue of thread synchronization,
which is something you will often have to contend with in multithreaded
programming. Fortunately, you saw how Java provides plenty of
support for handling the most common types of synchronization
problems.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



