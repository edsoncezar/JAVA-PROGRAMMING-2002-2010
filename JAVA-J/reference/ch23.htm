<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 23</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using Observers</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Introduction" >Introduction</A>
<UL>
<LI><A HREF="#InterfaceObserver" >Interface Observer</A>
<LI><A HREF="#ClassObservable" >Class Observable</A>
<LI><A HREF="#PuttingThemTogether" >Putting Them Together</A>
</UL>
<LI><A HREF="#ASimpleExampleTheSlideValueApplet" >A Simple Example: The SlideValue Applet</A>
<UL>
<LI><A HREF="#TheObservable" >The Observable</A>
<LI><A HREF="#TheObserver" >The Observer</A>
<LI><A HREF="#TheController1" >The Controller</A>
<LI><A HREF="#TheHTMLContainer" >The HTML Container</A>
<LI><A HREF="#SlideValueInteraction" >SlideValue Interaction</A>
</UL>
<LI><A HREF="#FlexibleObjectOrientedDesign" >Flexible Object-Oriented Design</A>
<LI><A HREF="#ObserverasaDesignPattern" >Observer as a Design PatternIK</A>
<UL>
<LI><A HREF="#SomeImplicationsofUsingObserver" >Some Implications of Using Observer</A>
<LI><A HREF="#Interactions" >Interactions</A>
<LI><A HREF="#ObserverImplementationTradeOffs" >Observer Implementation Trade-Offs</A>
</UL>
<LI><A HREF="#TheModelViewControllerParadigm" >The Model-View-Controller Paradigm</A>
<UL>
<LI><A HREF="#TheModelTheObservable" >The Model (The Observable)</A>
<LI><A HREF="#TheViewTheObserver" >The View (The Observer)</A>
<LI><A HREF="#TheController2" >The Controller</A>
<LI><A HREF="#TheAdvantagesofMVC" >The Advantages of MVC</A>
</UL>
<LI><A HREF="#TheAppletCADApplet" >The AppletCAD Applet</A>
<UL>
<LI><A HREF="#TheApplet" >The Applet</A>
<LI><A HREF="#TheObservabl" >The Observable</A>
<LI><A HREF="#TheObservers" >The Observers</A>
<LI><A HREF="#TheController3" >The Controller</A>
<LI><A HREF="#HTMLContainer" >HTML Container</A>
<LI><A HREF="#Interaction" >Interaction</A>
</UL>
<LI><A HREF="#OtherApplicationsofObserver" >Other Applications of Observer</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<H2><A NAME="Introduction"><FONT SIZE=5 COLOR=#FF0000>Introduction</FONT></A>
</H2>
<P>
Consider an applet-call it Frammitz 1.0-comprising a large data
structure, a sophisticated user interface, and some complex control
logic. How would you go about constructing such an applet? As
a good object-oriented developer, you immediately say: &quot;Aha!
That data structure should go in its own class! While I'm at it,
I'll put the logic in there too!&quot; Uttering the battle cry
of the followers of OO-&quot;Encapsulate!&quot;-you separate the
data from the interface. You then reap the many expected benefits-increased
abstraction and readability, and reduced complexity (which helps
during maintenance, too). By partitioning the system into interface
and behavior, you reduce the coupling between classes. You also
pave the way for later reuse of either piece. By keeping the interface
separate, you avoid the &quot;event-spaghetti&quot; code that
plagues many object-oriented GUI environments. So, you have two
classes: a UI in the form of an applet, and the data with its
rules. Because the rules for handling the data are important,
you make sure that the only way to access the data is through
methods that enforce the rules. Otherwise, a malicious object
could circumvent the model's logic. Now you have a full-fledged
model and its user interface.
<P>
Consider the user interface a bit more closely. The user interface
arbitrates between the user and the model. So, it makes sense
to think of the user interface from two perspectives. First, what
about the model needs to be presented? Second, what tasks will
a user perform on that model? Thus, thinking in terms of a model,
what does a UI really need to do? Well, it needs to present the
model in a comprehensible way. Most of the time, it also needs
to allow the user to interact with the model. An unspoken assumption
is that the interface always accurately reflects the contents
of the model. That is, the state of the interface should always
be consistent with that of the model. All right then, we need
two sets of methods in the user interface, a group of display
methods to present the model, and a group of control methods,
which can alter the model. (These usually end up being <TT><FONT FACE="Courier">paint</FONT></TT>
and <TT><FONT FACE="Courier">action</FONT></TT> methods.) So,
we code the <TT><FONT FACE="Courier">paint</FONT></TT> and <TT><FONT FACE="Courier">action</FONT></TT>
methods to access Frammitz's associated data object. The <TT><FONT FACE="Courier">paint</FONT></TT>
methods read the model's state from one set of accessor methods.
The <TT><FONT FACE="Courier">action</FONT></TT> methods change
the model's state through a different set of accessor and logic
methods.
<P>
Flash forward a few weeks (or maybe days). For the most part,
all went well on Frammitz version 1.0. You ran into a little sticky
spot when implementing the control methods. You see, any time
the model changed, you had to redisplay the new data. Because
the control methods were changing the model, they had to call
the display methods to update the display. So, it got a little
messy-the control methods were calling the display methods all
over the place-but it works. Version 1.0 is out the door (although
that particular metaphor probably needs to be updated for the
Webbed World).
<P>
Disaster! Frammitz 1.0 is a wild success. Your users love it,
and your boss loves that your users love it. Why is that a disaster?
Because your users love it so much that they are requesting all
kinds of wild enhancements-things like totally new ways of looking
at the model, or totally new ways of interacting with it, or new
rules for the model itself. &quot;While you're at it, how hard
would it be to add multithreading?&quot; Sound familiar? Odds
are, you've been here at least once. Nothing fails like success,
because now you must find a way to add new views and new rules.
Suddenly, what seemed like &quot;a little sticky spot&quot; starts
to look like exponentially proliferating methods, with all the
maintenance and stability problems that that implies. Worse yet,
because this applet is constantly being shipped all over the world
in byte-codes, adding even a few kilobytes to your code size can
turn the most loyal of users against you. Frammitz 2.0 starts
to look unlikely.
<P>
Now, imagine that a simple design change in the beginning could
make changing views simple. Or that it could make new interaction
modes possible, without doubling the number of methods and interconnections
in your class. Even better, imagine that your users could create
their own views, without affecting your model! Now you're cooking
with gas! Decoupling your classes is the secret. You can achieve
complete decoupling in many cases by using a class and an interface
defined in package <TT><FONT FACE="Courier">java.util</FONT></TT>.
It provides a class,<TT><FONT FACE="Courier"> Observable,</FONT></TT>and
an interface, <TT><FONT FACE="Courier">Observer, </FONT></TT>that
can make it happen. <TT><FONT FACE="Courier">Observable</FONT></TT>s
collaborate with <TT><FONT FACE="Courier">Observer</FONT></TT>s
to automatically keep <TT><FONT FACE="Courier">Observer</FONT></TT>s
up to date. The <TT><FONT FACE="Courier">Observer</FONT></TT>s
can use these notifications to synchronize their state with that
of the <TT><FONT FACE="Courier">Observable</FONT></TT>s, or to
update their display, or to trigger some other action.
<P>
This chapter will present the parts of the <TT><FONT FACE="Courier">Observer</FONT></TT>/<TT><FONT FACE="Courier">Observable</FONT></TT>
pair and describe their interaction with the aid of a simple example.
By examining <TT><FONT FACE="Courier">Observer</FONT></TT>/<TT><FONT FACE="Courier">Observable</FONT></TT>
as a <I>design pattern</I>, it will discuss the implications of
using the <B>Observer</B> pattern. It will also explore an important
object-oriented architecture enabled by <B>Observer</B>, which
originated in Smalltalk-80, called Model-View-Controller or MVC.
A more sophisticated example will illustrate the flexibility provided
by using MVC. A final section will briefly discuss other applications
of <B>Observer</B>, outside of the GUI realm. (<B>Observer</B>
in boldface refers to the pattern name. <TT><FONT FACE="Courier">Observer</FONT></TT>
in monospaced type refers to the interface defined by <TT><FONT FACE="Courier">java.util.Observer</FONT></TT>,
and <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT> refers
to any class that implements <TT><FONT FACE="Courier">Observer</FONT></TT>.
Don't worry, each of these is discussed in detail later on.)
<H3><A NAME="InterfaceObserver">Interface <TT><FONT SIZE=4 FACE="Courier">Observer</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">Observer</FONT></TT> interface is
shown in Listing 23.1. It is quite simple, consisting of only
one method declaration-<TT><FONT FACE="Courier">update</FONT></TT>.
By defining <TT><FONT FACE="Courier">update</FONT></TT> within
a class, you make that class an <TT><FONT FACE="Courier">Observer</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 23.1. The definition of interface </B><TT><B><FONT FACE="Courier">Observer</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">package java.util;<BR>
<BR>
public interface Observer {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void update(Observable o, Object arg);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
By convention, an interface name usually ends in &quot;-able,&quot; but not this time. Here, the class name ends in &quot;-able,&quot; but the interface name does not. Admittedly, this is not terribly consistent, but imagine how confusing it would be if the &quot;<TT><FONT FACE="Courier">Observable</FONT></TT>&quot; were actually the thing doing the observing, and the &quot;<TT><FONT FACE="Courier">Observer</FONT></TT>&quot; were the thing being observed!
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<TT><FONT FACE="Courier">Observer</FONT></TT>s subscribe to <TT><FONT FACE="Courier">Observable</FONT></TT>s.
One <TT><FONT FACE="Courier">Observer</FONT></TT> can subscribe
to many <TT><FONT FACE="Courier">Observer</FONT></TT>s, but there
is only one <TT><FONT FACE="Courier">update()</FONT></TT> method,
which all of the <TT><FONT FACE="Courier">Observable</FONT></TT>s
will call. The <TT><FONT FACE="Courier">Observer</FONT></TT> can
use the first argument to <TT><FONT FACE="Courier">update()</FONT></TT>
to tell which <TT><FONT FACE="Courier">Observable</FONT></TT>
sent the notification. The second argument is available for whatever
use the <TT><FONT FACE="Courier">Observable</FONT></TT> supplies.
Generally, <TT><FONT FACE="Courier">arg</FONT></TT> will be one
of two things:
<UL>
<LI><FONT COLOR=#000000>The data item within the </FONT><TT><FONT FACE="Courier">Observable</FONT></TT>
that changed.
<LI><FONT COLOR=#000000>An event object of whatever protocol the
</FONT><TT><FONT FACE="Courier">Observer</FONT></TT> and <TT><FONT FACE="Courier">Observable</FONT></TT>
agree upon.
</UL>
<P>
Using <TT><FONT FACE="Courier">arg</FONT></TT> for an application-specific
protocol can optimize the updates greatly; however, it increases
the coupling between the classes.
<P>
Remember that Java considers interfaces to be types. Suppose a
class <TT><FONT FACE="Courier">PassMe</FONT></TT> extends <TT><FONT FACE="Courier">Applet</FONT></TT>
and implements <TT><FONT FACE="Courier">Observer</FONT></TT>.
Then, an instance of <TT><FONT FACE="Courier">PassMe</FONT></TT>
can legitimately be passed to any of the following functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void GiveMeAnApplet(Applet a);
<BR>
public void GiveMeAnObserver(Observer o);<BR>
public void GiveMeAPassMe(PassMe p);</FONT></TT>
</BLOCKQUOTE>
<P>
Moreover, <TT><FONT FACE="Courier">GiveMeAnObserver</FONT></TT>
can take an instance of any other class that implements <TT><FONT FACE="Courier">
Observer</FONT></TT>, whatever its class type or superclass may
be. This first-class rank of interfaces is the key to Java's <B>Observer</B>
mechanism. (For more details on interfaces and inheritance, see
the sidebar &quot;Interface vs. Implementation Inheritance&quot;
later in this chapter.)
<H3><A NAME="ClassObservable">Class <TT><FONT SIZE=4 FACE="Courier">Observable</FONT></TT></A>
</H3>
<P>
The public and protected interface to class <TT><FONT FACE="Courier">Observable</FONT></TT>
is shown in Listing 23.2.
<HR>
<BLOCKQUOTE>
<B>Listing 23.2. The definition of class </B><TT><B><FONT FACE="Courier">Observable</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">package java.util;<BR>
<BR>
public class Observable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void addObserver(Observer
o);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void deleteObserver(Observer
o);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized int countObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void notifyObservers();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void notifyObservers(Object
arg);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void deleteObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected synchronized void setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected synchronized void clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected synchronized boolean hasChanged();
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Remember that this is a class, so your data items and models will
use <TT><FONT FACE="Courier">Observable</FONT></TT> by inheriting
from it. Although they are not declared as final, there is usually
no reason to override the provided implementations for these methods.
You can see that this class is well protected for use by multithreaded
applications. Indeed, allowing changes from any thread to be immediately
reflected in other threads is one of the best uses for the <TT><FONT FACE="Courier">Observer</FONT></TT>/<TT><FONT FACE="Courier">Observable</FONT></TT>
pair.
<P>
The <TT><FONT FACE="Courier">addObserver()</FONT></TT> and <TT><FONT FACE="Courier">deleteObserver()</FONT></TT>
methods allow an <TT><FONT FACE="Courier">Observer</FONT></TT>
to subscribe or unsubscribe to this <TT><FONT FACE="Courier">Observable</FONT></TT>.
Notice that they each take a parameter of type <TT><FONT FACE="Courier">Observer</FONT></TT>.
This implies that they can be passed instances of any class that
implements <TT><FONT FACE="Courier">Observer</FONT></TT>. Internally,
<TT><FONT FACE="Courier">Observable</FONT></TT> maintains a vector
of all the <TT><FONT FACE="Courier">Observer</FONT></TT>s that
have been added to it. When <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
is called, the <TT><FONT FACE="Courier">update()</FONT></TT> method
of each subscribed <TT><FONT FACE="Courier">Observer</FONT></TT>
is invoked with an optional argument to indicate what changed.
<P>
The <TT><FONT FACE="Courier">setChanged()</FONT></TT>, <TT><FONT FACE="Courier">clearChanged()</FONT></TT>,
and <TT><FONT FACE="Courier">hasChanged()</FONT></TT> methods
allow a subclass of <TT><FONT FACE="Courier">Observable</FONT></TT>
to keep a &quot;dirty flag&quot; to indicate when the <TT><FONT FACE="Courier">Observer</FONT></TT>s
need to be notified. Typically, an <TT><FONT FACE="Courier"> Observable</FONT></TT>
will call <TT><FONT FACE="Courier">setChanged()</FONT></TT> as
soon as a state change occurs. It will not call <TT><FONT FACE="Courier">clearChanged()</FONT></TT>
until it notifies its <TT><FONT FACE="Courier">Observer</FONT></TT>s.
Although these methods are protected, you may sometimes find it
useful to define pass-through methods in your subclass. Allowing
another object to set and clear this flag can sometimes speed
up notifications.
<P>
Notice that there are two forms of <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>,
one with an <TT><FONT FACE="Courier">Object</FONT></TT> argument
and one with no arguments. The simpler form of <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
just calls <TT><FONT FACE="Courier">notifyObservers(null)</FONT></TT>.
(That is why the simpler form is not synchronized.) For simple
data items, the first form is adequate. Sometimes it will be useful
to provide the <TT><FONT FACE="Courier">Observer</FONT></TT> with
more information about <I>what</I> has changed. In a complex <TT><FONT FACE="Courier">Observable</FONT></TT>,
it may be costly to redisplay everything, so the <TT><FONT FACE="Courier">Observer</FONT></TT>
would like to optimize its redisplay. Often, this is impossible,
because it can be difficult to deduce what aspect of an <TT><FONT FACE="Courier">Observable</FONT></TT>
has changed. Because you can pass any <TT><FONT FACE="Courier">Object</FONT></TT>
to <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>, your
particular <TT><FONT FACE="Courier">Observable</FONT></TT> can
define a protocol for its <TT><FONT FACE="Courier">Observer</FONT></TT>s.
For example, an <TT><FONT FACE="Courier">Observable</FONT></TT>
that maintained a vector of Points might pass the changed Point
to its <TT><FONT FACE="Courier">Observer</FONT></TT>s. Be careful,
however, that this protocol does not couple the <TT><FONT FACE="Courier">Observer</FONT></TT>
too tightly to the <TT><FONT FACE="Courier">Observable</FONT></TT>.
Your <TT><FONT FACE="Courier">Observable</FONT></TT> should consider
this argument a hint to the <TT><FONT FACE="Courier">Observer</FONT></TT>,
something which can help the <TT><FONT FACE="Courier">Observer</FONT></TT>,
but could safely be ignored.
<H3><A NAME="PuttingThemTogether">Putting Them Together</A></H3>
<P>
Neither <TT><FONT FACE="Courier">Observer</FONT></TT> nor <TT><FONT FACE="Courier">Observable</FONT></TT>
is useful by itself. Used together, <TT><FONT FACE="Courier">Observer</FONT></TT>
and <TT><FONT FACE="Courier">Observable</FONT></TT> create a <I>publish-subscribe</I>
protocol. The <TT><FONT FACE="Courier">Observable</FONT></TT>
publishes notifications, to which <TT><FONT FACE="Courier">Observer</FONT></TT>s
subscribe. It sends notifications to any and all interested <TT><FONT FACE="Courier">Observer</FONT></TT>s,
without knowing or caring what the concrete classes of the <TT><FONT FACE="Courier">Observer</FONT></TT>s
are. Any number of <TT><FONT FACE="Courier">Observer</FONT></TT>s
can subscribe to a single <TT><FONT FACE="Courier">Observable</FONT></TT>.
Also, each <TT><FONT FACE="Courier">Observer</FONT></TT> can subscribe
to more than one <TT><FONT FACE="Courier">Observable</FONT></TT>.
This creates a one-to-many dependency between objects so that
when the <TT><FONT FACE="Courier">Observable</FONT></TT> changes
state, all of its dependents (<TT><FONT FACE="Courier">Observer</FONT></TT>s)
are notified and can update themselves automatically.
<P>
You cannot use either the <TT><FONT FACE="Courier">Observer</FONT></TT>
interface or the <TT><FONT FACE="Courier">Observable</FONT></TT>
class as is. In order to make use of this publish-subscribe protocol,
you must subclass <TT><FONT FACE="Courier">Observable</FONT></TT>
<I>and</I>  implement <TT><FONT FACE="Courier">Observer</FONT></TT>.
In the rest of this chapter, <TT><FONT FACE="Courier">Observer</FONT></TT>
refers to the interface, whereas <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>
refers to a class that implements <TT><FONT FACE="Courier">Observer</FONT></TT>.
Likewise, <TT><FONT FACE="Courier">Observable</FONT></TT> refers
to the class <TT><FONT FACE="Courier">Observable</FONT></TT>,
whereas <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
refers to a specific subclass of <TT><FONT FACE="Courier">Observable</FONT></TT>.
Figure 23.1 illustrates the relationships involved between <TT><FONT FACE="Courier">Observer</FONT></TT>,
its <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>, the
<TT><FONT FACE="Courier">ConcreteObservable</FONT></TT> under
scrutiny, and <TT><FONT FACE="Courier">Observable</FONT></TT>.
<P>
<A HREF="f23-1.gif" ><B>Figure 23.1: </B><I>Relationships between </I>Observer, ConcreteObserver, Observable, <I>and</I> ConcreteObservable</A>.
<P>
The <TT><FONT FACE="Courier">Observable</FONT></TT> knows its
<TT><FONT FACE="Courier">Observer</FONT></TT>s but does not know
what they are. This important distinction arises because <TT><FONT FACE="Courier">Observer</FONT></TT>
is an interface. Each <TT><FONT FACE="Courier">Observer</FONT></TT>
can be from vastly different,  unrelated classes. Because they
implement the correct interface, <TT><FONT FACE="Courier">Observable</FONT></TT>
can send the notification without any regard for what each <TT><FONT FACE="Courier">Observer</FONT></TT>
does on receipt of the message.
<P>
In Figure 23.2, you can see the flow of events that occurs when
an <TT><FONT FACE="Courier">Observable</FONT></TT>'s state is
changed. The initial &quot;set&quot; message can come from an
<TT><FONT FACE="Courier">Observer</FONT></TT> or from some other
controlling class. The accessor methods that cause state changes
must set the &quot;dirty&quot; flag by calling <TT><FONT FACE="Courier">setChanged()</FONT></TT>.
At some point <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
gets called, often from within the accessor method itself. Sometimes,
another object will call it. Both methods have advantages. (See
the section &quot;Observer Implementation Trade-Offs&quot; later
in this chapter.) In this case, the <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
itself calls <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>.
Within <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>,
the <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT> calls
the <TT><FONT FACE="Courier">update()</FONT></TT> method on each
<TT><FONT FACE="Courier">ConcreteObserver</FONT></TT> in turn.
The order in which the <TT><FONT FACE="Courier">Observer</FONT></TT>s
are notified is undefined. (Even though you can look at the source
code for <TT><FONT FACE="Courier">Observable</FONT></TT> and see
exactly what the order will be, that is an implementation detail,
not part of <TT><FONT FACE="Courier">Observable'</FONT></TT>s
contract! The abstraction of <TT><FONT FACE="Courier">Observable</FONT></TT>
does not define the notification order, so you should not rely
on the implementation. After all, implementations change without
warning.) After the <TT><FONT FACE="Courier">Observer</FONT></TT>s
have been notified, the <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
calls <TT><FONT FACE="Courier">clearChanged()</FONT></TT>. It
is very important that all of the crucial data items in a <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
are private. If any were made public, other objects could modify
the members without calling <TT><FONT FACE="Courier">setChanged()</FONT></TT>
or <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>, completely
defeating the purpose of using <TT><FONT FACE="Courier">Observer</FONT></TT>s
in the first place.
<P>
<A HREF="f23-2.gif" ><B>Figure 23.2: </B><I>Object interaction diagram.</I></A>
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Sometimes, it will be useful to add public methods to your <TT><FONT FACE="Courier">Observable</FONT></TT> to pass through to <TT><FONT FACE="Courier">setChanged()</FONT></TT> and <TT><FONT FACE="Courier">clearChanged()</FONT></TT>. For example, if your controller is in the process of making several small changes to different parts of the <TT><FONT FACE="Courier">Observable</FONT></TT>'s state, you may want to defer the <TT><FONT FACE="Courier">notifyObservers()</FONT></TT> call until all of the changes are done. Avoiding superfluous updates can boost performance significantly. By eliminating unnecessary updates, you also eliminate the annoying display flicker from the extra updates.
</BLOCKQUOTE>

</TD></TR>
<TR VALIGN=TOP><TD WIDTH=590><BLOCKQUOTE>
On the other hand, adding that sort of knowledge to your controller increases the coupling between the controller and the <TT><FONT FACE="Courier">Observable</FONT></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="ASimpleExampleTheSlideValueApplet"><FONT SIZE=5 COLOR=#FF0000>A
Simple Example: The </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">SlideValue</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Applet</FONT></A></H2>
<P>
Let's use <TT><FONT FACE="Courier">Observer</FONT></TT> and <TT><FONT FACE="Courier">Observable</FONT></TT>
to create a simple applet. This applet will consist of a scrollbar
and a text field. We want the text field to always reflect the
value of the scrollbar. For this example, the relationship will
be one-way. That is, changes to the text field do not need to
be reflected in the scrollbar. Adding the updates in the other
direction is just an application of the same techniques used here.
Figure 23.3 shows the <TT><FONT FACE="Courier">SlideValue</FONT></TT>
applet in action.
<P>
<A HREF="f23-3.gif" ><B>Figure 23.3:</B> <I>The </I>SlideValue<I> applet in action.</I></A>
<P>
The most basic approach, and the one taken most often by new designers,
would be to construct an applet class with a scrollbar, a text
field, and a private integer. The class would have an event handler
for the scrollbar changes, which would update the internal integer
and call a method to put a string in the text field. Although
this approach has the benefit of keeping everything in one class,
there really is no way to separate the behavior from the interface.
Any future changes in either presentation or behavior would require
touching every part of the class that deals with presentation
and behavior.
<P>
A more sophisticated approach separates the data, the view, and
the controller. By using a separate data class, derived from <TT><FONT FACE="Courier">Observable</FONT></TT>,
we can implement whatever logic is necessary to maintain a consistent
state. In addition, we can change that logic without having to
make any corresponding changes in the user interface. Because
the text field needs to update itself when the data value changes,
we will derive a class from <TT><FONT FACE="Courier">java.awt.TextField</FONT></TT>,
which implements <TT><FONT FACE="Courier">Observer</FONT></TT>.
<H3><A NAME="TheObservable">The Observable</A></H3>
<P>
In this case, the <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
is <TT><FONT FACE="Courier">Value</FONT></TT>, shown in Listing
23.3. It mainly consists of the value itself, <TT><FONT FACE="Courier">val</FONT></TT>,
and two methods to set and return the value. Look carefully at
the <TT><FONT FACE="Courier">set()</FONT></TT> method. The extra
code in this method sets the changed flag, notifies any interested
<TT><FONT FACE="Courier">Observer</FONT></TT>s, and then clears
the changed flag. (If the changed flag is not set, <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
will do nothing.) As an alternative to the boolean flag provided
by <TT><FONT FACE="Courier">Observable</FONT></TT>, your <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
class can also override the <TT><FONT FACE="Courier">hasChanged()</FONT></TT>
method to perform more sophisticated detection.
<P>
When <TT><FONT FACE="Courier">Value</FONT></TT> calls <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>,
it uses the form without parameters. Because there is only one
item of interest (one state variable) in this class, passing anything
to the notification would be somewhat superfluous.
<HR>
<BLOCKQUOTE>
<B>Listing 23.3. </B><TT><B><FONT FACE="Courier">Value.java</FONT></B></TT><B>,
the </B><TT><B><FONT FACE="Courier">ConcreteObservable</FONT></B></TT><B>
for the </B><TT><B><FONT FACE="Courier">SlideValue</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** Value.java<BR>
**<BR>
** ConcreteObserver class for the SlideValue example<BR>
**<BR>
*/<BR>
<BR>
import java.util.Observable;<BR>
<BR>
class Value extends Observable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float val;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void Value(float v) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void set(float v) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public float get() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return val;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheObserver">The Observer</A></H3>
<P>
For this example, the only view into the data is a simple text
field. For this reason, our <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>
will be derived from <TT><FONT FACE="Courier">java.awt.TextField</FONT></TT>,
which will implement <TT><FONT FACE="Courier">Observer</FONT></TT>.
<TT><FONT FACE="Courier">Observer</FONT></TT> is an interface,
so any class can implement it, whatever its heritage. Listing
23.4 shows <TT><FONT FACE="Courier">View.java</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 23.4. </B><TT><B><FONT FACE="Courier">View.java</FONT></B></TT><B>,
the </B><TT><B><FONT FACE="Courier">ConcreteObserver</FONT></B></TT><B>
for the </B><TT><B><FONT FACE="Courier">SlideValue</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** View.java<BR>
**<BR>
** ConcreteObserver for the SlideValue example<BR>
**<BR>
*/<BR>
<BR>
import java.awt.TextField;<BR>
import java.util.Observer;<BR>
import java.util.Observable;<BR>
import Value;<BR>
<BR>
class View extends TextField implements Observer {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void update(Observable o, Object
arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value v = (Value)o;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setText(Float.toString(v.get()));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Because the <TT><FONT FACE="Courier">update</FONT></TT> method
is passed an <TT><FONT FACE="Courier">Observable</FONT></TT>,
<TT><FONT FACE="Courier">View</FONT></TT> must cast the <TT><FONT FACE="Courier">Observable</FONT></TT>
to a <TT><FONT FACE="Courier">Value</FONT></TT>. In this example,
<TT><FONT FACE="Courier">View</FONT></TT> will only be used to
observe <TT><FONT FACE="Courier">Value</FONT></TT>, so this cast
is safe. In a production class, you would want to use the <TT><FONT FACE="Courier">instanceof</FONT></TT>
operator to ensure safe casting. In fact, if you have several
<TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>s you want
to observe from a single <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>,
a good approach would be to define a protocol by which the <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>
can query the state of the <TT><FONT FACE="Courier">Observable</FONT></TT>s.
<H3><A NAME="TheController1">The Controller</A></H3>
<P>
The controller for <TT><FONT FACE="Courier">SlideValue</FONT></TT>
is embedded directly in the applet class. In general, the controller
should have its own class also. In this case, however, we are
primarily interested in the  interaction between <TT><FONT FACE="Courier">Value</FONT></TT>
and <TT><FONT FACE="Courier">View</FONT></TT>. Therefore, embedding
the controller in the applet class helps clarify that interaction.
(See Listing 23.5.)
<HR>
<BLOCKQUOTE>
<B>Listing 23.5. </B><TT><B><FONT FACE="Courier">SlideValue</FONT></B></TT><B>
applet definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** SlideValue.java<BR>
**<BR>
** Applet container for SlideValue example<BR>
**<BR>
*/<BR>
<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import Value;<BR>
import View;<BR>
<BR>
public class SlideValue extends Applet {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Value&nbsp;&nbsp;&nbsp;&nbsp;
value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private View&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Scrollbar controller;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up a layout
manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(200, 55);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
value, view, and controller.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = new Value();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view = new View();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller = new
Scrollbar(Scrollbar.HORIZONTAL, 0, 10, 0, 100);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the view
to the model's notification list.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.addObserver(view);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Put the view
and the controller into the UI.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;,
controller);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,
view);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
Scrollbar) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.set((float)controller.getValue());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.handleEvent(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This simple applet really just creates the components and defines
the relationships. It uses the Border Layout Manager described
in <A HREF="ch17.htm" >Chapter 17</A>, &quot;Programming the User
Interface,&quot; to place the <TT><FONT FACE="Courier">View</FONT></TT>
and <TT><FONT FACE="Courier">ScrollBar</FONT></TT> objects. For
this example, the <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>
and <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT> are
both created by the applet itself, and the <TT><FONT FACE="Courier">Observer</FONT></TT>
is added to the notify list right here. In general, the applet
itself does not need to create all of the relationships. You can
even have the constructor for the <TT><FONT FACE="Courier">Observer</FONT></TT>
take an <TT><FONT FACE="Courier">Observable</FONT></TT> as a parameter,
although you will usually not want to introduce another class
dependency. By constructing the relationship outside of the two
classes being related, you reduce the coupling between those classes
and allow them to be related in different ways as the occasions
arise.
<H3><A NAME="TheHTMLContainer">The HTML Container</A></H3>
<P>
The containing page for this applet is extremely basic. Listing
23.6 shows the HTML code. It simply gives the applet a region
of the page and provides links to the Java code.
<HR>
<BLOCKQUOTE>
<B>Listing 23.6. HTML container page for the </B><TT><B><FONT FACE="Courier">SlideValue</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;title&gt;SlideValue&lt;/title&gt;
<BR>
&lt;hr&gt;<BR>
&lt;applet code=SlideValue.class&gt;<BR>
&lt;/applet&gt;<BR>
&lt;hr&gt;<BR>
&lt;a href=&quot;SlideValue.java&quot;&gt;SlideValue.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;a href=&quot;View.java&quot;&gt;View.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;a href=&quot;Value.java&quot;&gt;Value.java&lt;/a&gt;&lt;p&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><TT><FONT SIZE=4 FACE="Courier"><A NAME="SlideValueInteraction">SlideValue</A></FONT></TT><FONT SIZE=4>
Interaction</FONT></H3>
<P>
Figure 23.4 shows the interaction diagram for the <TT><FONT FACE="Courier">SlideValue</FONT></TT>
applet. The chain of events begins when the user acts upon the
scrollbar. This results in a call to <TT><FONT FACE="Courier">SlideValue.handleEvent()</FONT></TT>,
which sets the value of <TT><FONT FACE="Courier">Value</FONT></TT>.
At this point, the controller is finished. After <TT><FONT FACE="Courier">set</FONT></TT>
is called, <TT><FONT FACE="Courier">SlideValue</FONT></TT> leaves
the picture. None of the interaction from this point on involves
the main applet. Instead, everything happens between the <TT><FONT FACE="Courier">Value</FONT></TT>
and its <TT><FONT FACE="Courier">Observer</FONT></TT>s (just the
single <TT><FONT FACE="Courier">TextField</FONT></TT> view this
time around).
<P>
<A HREF="f23-4.gif" ><B>Figure 23.4:</B> <I>Event interaction diagram for </I>SlideValue<I>.</I></A>
<P>
<TT><FONT FACE="Courier">Value</FONT></TT> publishes its state,
and <TT><FONT FACE="Courier">View</FONT></TT> subscribes to it.
By relating the classes this way, all changes to <TT><FONT FACE="Courier">Value</FONT></TT>'s
state are automatically reflected in <TT><FONT FACE="Courier">View</FONT></TT>.
Additional views can be added easily. Further, the applet code
does not need to know anything about the state of <TT><FONT FACE="Courier">Value</FONT></TT>
or <TT><FONT FACE="Courier">Value</FONT></TT>'s implementation.
It does not need to know anything about how <TT><FONT FACE="Courier">View</FONT></TT>
creates its display or gets  updates. By reducing the amount of
knowledge one class needs about another, we have reduced the coupling.
To illustrate, let's enhance <TT><FONT FACE="Courier">SlideValue</FONT></TT>
to include a second view, a gauge that shows the <TT><FONT FACE="Courier">Value</FONT></TT>
as a percentage. (See Figure 23.5.)
<P>
<A HREF="f23-5.gif" ><B>Figure 23.5:</B> SlideValue<I> in action, with a </I>GaugeView<I> added.</I></A>
<P>
The new view will be a subclass of <TT><FONT FACE="Courier">Panel</FONT></TT>,
and, of course, it will implement <TT><FONT FACE="Courier">Observer</FONT></TT>.
Listing 23.7 shows the new class. Although <TT><FONT FACE="Courier">GaugeView</FONT></TT>
does maintain an integer, <TT><FONT FACE="Courier">lastKnownPercentage</FONT></TT>,
which is fetched from <TT><FONT FACE="Courier">Value</FONT></TT>,
it is not really copying the state of <TT><FONT FACE="Courier">Value</FONT></TT>.
It is processed after retrieving it from <TT><FONT FACE="Courier">Value</FONT></TT>
(a cast from <TT><FONT FACE="Courier">float</FONT></TT> to <TT><FONT FACE="Courier">int</FONT></TT>)
and treated as read-only elsewhere. A member used this way is
more like a cached value than a state variable. The cached value
is guaranteed to be up-to-date, because any time the <TT><FONT FACE="Courier">Value</FONT></TT>
changes, <TT><FONT FACE="Courier">GaugeView</FONT></TT> gets notified!
An equally valid technique would be to store a reference to <TT><FONT FACE="Courier">Value</FONT></TT>
in <TT><FONT FACE="Courier">GaugeView</FONT></TT> and get the
value directly from <TT><FONT FACE="Courier">Value</FONT></TT>
whenever it is needed. In this case, the added overhead of the
extra method calls far outweighs the added storage for the extra
integer. For a more complex model, that might not be the case.
<HR>
<BLOCKQUOTE>
<B>Listing 23.7. The new </B><TT><B><FONT FACE="Courier">GaugeView</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** GaugeView.java<BR>
**<BR>
** A new ConcreteObserver for the SlideValue example<BR>
**<BR>
*/<BR>
<BR>
import java.awt.Panel;<BR>
import java.awt.Graphics;<BR>
import java.awt.Dimension;<BR>
import java.awt.FontMetrics;<BR>
import java.awt.Color;<BR>
import java.util.Observer;<BR>
import java.util.Observable;<BR>
import Value;<BR>
<BR>
class&nbsp;&nbsp;&nbsp;GaugeView extends Panel implements Observer
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int lastKnownPercentage;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void update(Observable o, Object
arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics&nbsp;&nbsp;g
= getGraphics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;
v = (Value)o;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastKnownPercentage
= (int)v.get();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension&nbsp;&nbsp;&nbsp;&nbsp;d
= size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics&nbsp;&nbsp;fm
= g.getFontMetrics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textHeight
= fm.getAscent() + fm.getDescent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer s
= new StringBuffer();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.append(lastKnownPercentage);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.append(&quot;%&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(getForeground());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0,
0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)(d.width
* (lastKnownPercentage / 100.0)),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.height);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.lightGray);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(s.toString(),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)((d.width
- fm.stringWidth(s.toString()))/2),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)((d.height
- textHeight)/2 + fm.getAscent()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 23.8 shows the modifications to <TT><FONT FACE="Courier">SlideValue</FONT></TT>
in bold. Notice that the only changes required to add a new view
were in the code that creates the view itself! The <TT><FONT FACE="Courier">Value</FONT></TT>
and the existing <TT><FONT FACE="Courier">View</FONT></TT> did
not change at all-not one line.
<HR>
<BLOCKQUOTE>
<B>Listing 23.8. The modified </B><TT><B><FONT FACE="Courier">SlideValue</FONT></B></TT><B>
applet class with changes shown in bold.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** SlideValue.java<BR>
**<BR>
** Applet container for SlideValue example<BR>
**<BR>
*/<BR>
<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import Value;<BR>
import View;<BR>
<B>import GaugeView;<BR>
<BR>
</B>public class SlideValue extends Applet {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Value&nbsp;&nbsp;&nbsp;&nbsp;
value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private View&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view;
<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;private GaugeView gauge;<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;private Scrollbar controller;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set up a layout
manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(200, 55);
<BR>
<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
value, views, and controller.<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = new
Value();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view = new View();
<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gauge = new
GaugeView();<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller
= new Scrollbar(Scrollbar.HORIZONTAL, 0, 10, 0, 100);<BR>
<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the
views to the model's notification list.<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.addObserver(view);
<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.addObserver(gauge);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Put the views
and the controller into the UI.<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;,
controller);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,
view);<BR>
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;,
gauge);<BR>
&nbsp;</B>&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
Scrollbar) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.set((float)controller.getValue());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.handleEvent(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
No way could you add a new feature to a monolithic applet that
easily! Because we used <TT><FONT FACE="Courier"> Observer</FONT></TT>s,
the new view dropped right in without disturbing the existing
classes.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=590><B>Interface Versus Implementation Inheritance</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=590>
<BLOCKQUOTE>
Java supports several advanced object-oriented constructs, including interfaces. An interface is a collection of method signatures, without actual implementations. A class can declare that it implements one or more interfaces. Think of an interface as a contract between your class and other objects. By implementing interfaces, your class commits to providing methods with the same signatures as in the interface. Java treats interfaces as first class types; you can declare variables of interface types just as you would declare variables of class types. Although a class can only inherit from one base class, it can implement several interfaces. The main distinction is that interfaces do not override implementations. (In other words, you cannot call &quot;super&quot; methods in an interface method.)</BLOCKQUOTE>
<BLOCKQUOTE>
Interfaces are useful when you need to require certain behavior from client objects, but do not necessarily want all of the client objects to share a common parent. For example, it is impractical to require that all <TT><FONT FACE="Courier">Observer</FONT></TT>s inherit from a common base class. That would preclude you from subclassing <TT><FONT FACE="Courier">TextField</FONT></TT>, <TT><FONT FACE="Courier">Panel</FONT></TT>, <TT><FONT FACE="Courier">Thread</FONT></TT>, and so on as <TT><FONT FACE="Courier">Observer</FONT></TT>s.
</BLOCKQUOTE>
<BLOCKQUOTE>
There are two situations that become somewhat confusing. First, what happens when a class implements two interfaces with the same method? Because no implementation comes with either interface, there is no conflict. The class simply provides one actual method that can be called from either interface. Second, what happens when you subclass a class that implements an interface? The subclasses automatically implement the interface, through the parent class's method. In fact, you can override the parent class's method (even calling the &quot;super&quot; method). Your class will still legally implement the interface. (For an example of this usage, see the classes <TT><FONT FACE="Courier">TwoDView</FONT></TT> and <TT><FONT FACE="Courier">XYView</FONT></TT> in the <TT><FONT FACE="Courier">AppletCAD</FONT></TT> example later in this chapter.)
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="FlexibleObjectOrientedDesign"><FONT SIZE=5 COLOR=#FF0000>Flexible
Object-Oriented Design</FONT></A></H2>
<P>
Designing flexible, reusable object-oriented software is difficult
in any language. Balancing the needs of the problem at hand with
the desire for reuse is difficult, even for the most seasoned
designer. In fact, most of the thought involved in creating any
software goes toward solving problems during design. With a good
design, the actual coding becomes largely mechanical. So, how
can we create good designs, designs that can evolve with the requirements
of a project?
<P>
Experienced object-oriented designers know better than to solve
every problem from scratch. Rather, when faced with a problem,
experienced designers will compare it to similar problems they
have faced in the past and apply a solution that worked before.
They tend to work with a group of tried-and-true designs, adapting
them to the problem at hand. This is not the same as code reuse.
Actual code reuse is rare and vastly overstated. Instead, they
reuse designs by extracting recurring patterns of classes, relationships,
and interaction. These <I>design patterns</I> solve specific problems
that occur over and over again across a wide variety of domains.
By recognizing and identifying a design pattern, you become able
to reuse that design by applying it to new problems. Design patterns
make it easier to take a successful architecture of classes, communicating
objects, and relationships to a new problem.
<P>
In general, design patterns are not code. Instead, they collect
a common interaction and a common set of objects at an abstract
level. The actual coding depends on the particular problem. Design
patterns are not a template mechanism, like the templates in C++.
They are also not classes that you can directly apply. Moreover,
design patterns are not language-specific. The pattern itself
is completely abstract. It is the kernel of a solution, not the
solution itself. In the case of Java, there are classes and interfaces
that allow you to apply some patterns easily, but this is an instance
of a pattern. This distinction-between the pattern and one implementation
of the pattern-is the same as the distinction between a class
and an instance of that class. One is abstract, describing <I>how
</I>to construct something. The second is the product of that
construction.
<P>
The designers of the Java classes collectively represent decades
of experience with object- oriented designs. Not surprisingly,
the built-in Java classes include instantiations of several design
patterns. One particularly well-known design pattern is <B>Observer</B>.
Also not surprisingly, the instantiation of the <B>Observer</B>
pattern comprises the <TT><FONT FACE="Courier">Observer</FONT></TT>
interface and the <TT><FONT FACE="Courier">Observable</FONT></TT>
class. From here on, this chapter will refer to the aggregate
of <TT><FONT FACE="Courier">Observer</FONT></TT>, <TT><FONT FACE="Courier">Observable</FONT></TT>,
and their interaction as <B>Observer</B>. (Remember, <B>Observer</B>
in boldface refers to the pattern name, while <TT><FONT FACE="Courier">
Observer</FONT></TT> in monospaced type refers to the interface
defined by <TT><FONT FACE="Courier">java.util.Observer</FONT></TT>.
<TT><FONT FACE="Courier">ConcreteObserver</FONT></TT> refers to
any class that implements <TT><FONT FACE="Courier">Observer</FONT></TT>.)
<H2><A NAME="ObserverasaDesignPattern"><FONT SIZE=5 COLOR=#FF0000>Observer
as a Design Pattern</FONT></A></H2>
<P>
The need to partition an object-oriented system into a collection
of interdependent classes leads to a common difficulty. Often,
related classes must maintain a consistent state. A label must
reflect the contents of a string, or a choice box must only display
the choices allowed by a policy determined by another object.
Tight coupling between classes is one (poor) way to achieve coherence.
Many early object-oriented designs relied upon classes having
such carnal knowledge of each other. This approach works. It is
easy to design and code. On the other hand, the tight coupling
severely limits-or eliminates-their reusability. Such systems
do not grow or evolve well.
<P>
Many GUI toolkits solve this problem by separating the interface
classes from the underlying model. As in the earlier example,
classes defining the application data and the interface can each
be reused or replaced independently. Multiple views of the application
data can coexist. For all intents and purposes, the views will
behave as if they have full knowledge of each other. Changes to
one view are automatically reflected in the others. Figure 23.6
shows a conceptual example of this partitioning. In this example,
three views into the application data need to be kept synchronized
with the data itself. Such a system will behave as if the views
are tightly coupled, when, in fact, quite the opposite is true.
<P>
<A HREF="f23-6.gif" ><B>Figure 23.6:</B> <I>Conceptual model of the model/interface partitioning and interaction</I></A><I>.</I>
<P>
This type of interaction is characteristic of the <B>Observer</B>
design pattern. As described earlier, the key parts of <B>Observer</B>
are the <TT><FONT FACE="Courier">Observer</FONT></TT> and the
<TT><FONT FACE="Courier">Observable</FONT></TT>. The <TT><FONT FACE="Courier">Observable</FONT></TT>
may have any number of <TT><FONT FACE="Courier">Observer</FONT></TT>s,
drawn from any number of potentially unrelated classes. Whenever
the <TT><FONT FACE="Courier">Observable</FONT></TT>'s public state
changes, all of its <TT><FONT FACE="Courier">Observer</FONT></TT>s
are notified of the change. All <TT><FONT FACE="Courier">Observer</FONT></TT>s
are notified. If an <TT><FONT FACE="Courier">Observer</FONT></TT>
initiated the state change, it will still receive the notification
and should postpone its update until it receives the notification.
When an <TT><FONT FACE="Courier">Observer</FONT></TT> receives
a notification, it queries the <TT><FONT FACE="Courier">Observable</FONT></TT>
in order to synchronize its state with that of the <TT><FONT FACE="Courier">
Observable</FONT></TT>.
<P>
This pattern is sometimes referred to as Publish-Subscribe or
Dependents. Each of the three names reflects a different perspective
on the interaction. (Chris Warth, the Java developer who implemented
this pattern, evidently preferred <TT><FONT FACE="Courier">Observer</FONT></TT>.)
The <TT><FONT FACE="Courier">Observable</FONT></TT> publishes
notifications, to which the <TT><FONT FACE="Courier">Observer</FONT></TT>s
subscribe. Or, looking at it another way, the <TT><FONT FACE="Courier">Observer</FONT></TT>s
are dependent on the <TT><FONT FACE="Courier">Observable</FONT></TT>.
<P>
Whatever name you prefer, there are several situations in which
this pattern is applicable:
<UL>
<LI><FONT COLOR=#000000>When two or more objects need to remain
synchronized, without making assumptions about the objects themselves.
(This is the essence of decoupling.)</FONT>
<LI><FONT COLOR=#000000>When a change to one object can trigger
actions in an unspecified number of other objects. The change
can come from an external object or agent, or from an internal
event, such as a clock tick. These notifications can cascade.</FONT>
<LI><FONT COLOR=#000000>When an abstraction has more than one
interdependent part. By separating the pieces of the abstraction
into multiple objects, you can reuse or replace the pieces independently.
(This follows the maxim: &quot;If it changes, encapsulate it.
If it doesn't </FONT>change, encapsulate it anyway.&quot;)
</UL>
<H3><A NAME="SomeImplicationsofUsingObserver">Some Implications
of Using Observer</A></H3>
<P>
This pattern allows you to independently reuse or replace <TT><FONT FACE="Courier">Observer</FONT></TT>s
and <TT><FONT FACE="Courier">Observable</FONT></TT>s. This tremendous
level of flexibility does not come without a cost, however. The
most obvious cost is complexity. By using <B>Observer</B>, you
do add a certain degree of complexity to your system. There will
be at least one additional class, if nothing else. For anything
other than a small system, the added complexity is a small price
to pay, both in terms of code size and development time. Furthermore,
to anyone familiar with the <B>Observer</B> pattern, the intent
of your code will be immediately obvious. (This is a bonus awarded
for using a well-known pattern!)
<P>
<B>Observer</B> carries a more insidious cost you must be aware
of. Because the notification protocol is very generic, an <TT><FONT FACE="Courier">Observer</FONT></TT>
often has no details on what part of the <TT><FONT FACE="Courier">Observable</FONT></TT>'s
state changes, or who made the change. Without adding to the protocol,
it can be difficult for an <TT><FONT FACE="Courier">Observer</FONT></TT>
to deduce the nature and origin of a change. Adding such a protocol
can improve performance, sometimes dramatically, by eliminating
unnecessary work in the <TT><FONT FACE="Courier">Observer</FONT></TT>s
and by allowing <TT><FONT FACE="Courier">Observer</FONT></TT>s
to ignore notifications in which they have no interest. At the
same time, however, adding the extra protocol increases the coupling
between the classes.
<P>
Another possible solution to this problem would be to allow an
<TT><FONT FACE="Courier">Observer</FONT></TT> to subscribe to
specific parts of an <TT><FONT FACE="Courier">Observable</FONT></TT>.
The Java team evidently decided that the benefits of that approach
were outweighed by the added conceptual and code complexity required.
It would not be difficult, however, to create your own implementation
of the <B>Observer</B> pattern that did allow partial subscriptions.
<P>
Because multiple <TT><FONT FACE="Courier">Observer</FONT></TT>s
do not know about each other's existence, they may be ignorant
of the ultimate cost of a simple state change. A small, relatively
harmless-seeming change can trigger many updates, even a cascade
of updates, because an <TT><FONT FACE="Courier">Observer</FONT></TT>
of one item may be an <TT><FONT FACE="Courier"> Observable</FONT></TT>
to its own <TT><FONT FACE="Courier">Observer</FONT></TT>s. <TT><FONT FACE="Courier">Observer</FONT></TT>s
do not know the implementation details of the <TT><FONT FACE="Courier">Observable</FONT></TT>,
so a particular <TT><FONT FACE="Courier">Observer</FONT></TT>
cannot predict which changes will trigger notifications.
<P>
The coupling between <TT><FONT FACE="Courier">Observable</FONT></TT>s
and their <TT><FONT FACE="Courier">Observer</FONT></TT>s is minimal.
The <TT><FONT FACE="Courier">Observer</FONT></TT>s do need a little
more information about the <TT><FONT FACE="Courier">Observable</FONT></TT>,
but still relatively little. Because an <TT><FONT FACE="Courier">Observable</FONT></TT>
knows nothing about the concrete class of an <TT><FONT FACE="Courier">Observer</FONT></TT>,
<TT><FONT FACE="Courier">Observer</FONT></TT>s can be modified
or added long after the initial design.
<P>
An added bonus that Java awards you for using <B>Observer</B>
is that there is often no need to download some of the <TT><FONT FACE="Courier">Observer</FONT></TT>s.
If your applet includes ten potential views, but the user only
calls for two of them, there is no need to download the other
eight classes. This kind of runtime customization can really improve
the perceived performance of your applet.
<H3><A NAME="Interactions">Interactions</A></H3>
<P>
The publish-subscribe interaction is depicted in Figure 23.7.
This basically follows the interaction you observed in the <TT><FONT FACE="Courier">SlideValue</FONT></TT>
example. Several questions arise about this diagram. First, how
are these relationships created? Also, when should <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
be called? <B>Observer</B> does not specify the answers. Instead,
when you implement the pattern, you decide what is the best option
for this application. (This tailoring is a fundamental characteristic
of a design pattern, and it is one of the things that distinguish
a pattern from an actual design. A pattern describes the core
of a solution to a problem-you can use it a million times over
and never do it the same way twice.)
<P>
<A HREF="f23-7.gif" ><B>Figure 23.7:</B> <I>Basic </I>Observer/Observable<I> interaction during a </I>notifyObservers<I>.</I></A>
<P>
Figure 23.8 depicts a cascaded notification, in which <TT><FONT FACE="Courier">ConcreteObserver2</FONT></TT>
is also an <TT><FONT FACE="Courier">Observable</FONT></TT> for
<TT><FONT FACE="Courier">ConcreteObserver3</FONT></TT>. You might
use an arrangement like this when dealing with a layered system.
Because the coupling between <TT><FONT FACE="Courier">Observer</FONT></TT>s
and <TT><FONT FACE="Courier">Observable</FONT></TT>s is very loose,
you can span architectural layers without violating the system
layering. In Figure 23.8, for example, <TT><FONT FACE="Courier">ConcreteObservable</FONT></TT>
might be at the data access layer, <TT><FONT FACE="Courier">ConcreteObserver2</FONT></TT>
at the logic layer, and <TT><FONT FACE="Courier">ConcreteObserver3</FONT></TT>
at the interface layer.
<P>
<A HREF="f23-8.gif" ><B>Figure 23.8:</B> <I>Cascaded notification when an </I>Observer<I> is also </I>Observable<I>.</I></A>
<P>
It is possible to have mutually dependent <TT><FONT FACE="Courier">Observable</FONT></TT>s
that are both also <TT><FONT FACE="Courier">Observer</FONT></TT>s.
These objects would interact exactly as in Figure 23.7. This time,
however, the classes each need some knowledge about the other.
They must be careful not to trigger a notification during their
<TT><FONT FACE="Courier">update</FONT></TT> methods, or a vicious
cycle of notifications will ensue. (This can really be a problem
in multithreaded applications, because one thread will go completely
out to lunch and eat processor cycles, but everything else will
seem to work fine. In fact, other <TT><FONT FACE="Courier">Observer</FONT></TT>s
will often still behave correctly.) Such a storm of notifications
can be exceedingly difficult to detect.
<H3><A NAME="ObserverImplementationTradeOffs">Observer Implementation
Trade-Offs</A></H3>
<P>
This section discusses some of the decisions made by the Java
team. It also explores some of the implementation choices you
will need to make when using <B>Observer</B>.
<P>
<TT><FONT FACE="Courier">Observable</FONT></TT>s need to know
about their <TT><FONT FACE="Courier">Observer</FONT></TT>s. <TT><FONT FACE="Courier">Observable</FONT></TT>s
could maintain a simple array, an associative array (a hash table),
a linked list, and so on. The Java team chose to use a subclass
of <TT><FONT FACE="Courier">Vector</FONT></TT> to maintain the
<TT><FONT FACE="Courier">Observer</FONT></TT>s. Strictly speaking,
this is part of the implementation details of <TT><FONT FACE="Courier">Observable</FONT></TT>,
and we should ignore such details. However, because we are inheriting
from <TT><FONT FACE="Courier">Observable</FONT></TT>, implementation
details such as this have some direct implications. By using 
<TT><FONT FACE="Courier">Vector</FONT></TT> to contain the <TT><FONT FACE="Courier">Observer</FONT></TT>s,
we can have an arbitrary number of them, while still maintaining
a good memory/speed balance. Thus, an <TT><FONT FACE="Courier">Observer</FONT></TT>
with no <TT><FONT FACE="Courier">Observable</FONT></TT>s incurs
minimal overhead. Sequential and random access to the <TT><FONT FACE="Courier">Observer</FONT></TT>
list allows good performance when adding or deleting <TT><FONT FACE="Courier">Observer</FONT></TT>s.
Therefore, we can create <TT><FONT FACE="Courier">Observable</FONT></TT>s
with many <TT><FONT FACE="Courier">Observer</FONT></TT>s with
confidence that performance will not degrade unduly.
<P>
In some implementations of <B>Observer</B>, <TT><FONT FACE="Courier">Observer</FONT></TT>s
maintain references to their <TT><FONT FACE="Courier">Observable</FONT></TT>s.
This leads to a number of additional synchronization problems,
especially when deleting <TT><FONT FACE="Courier">Observable</FONT></TT>s.
To avoid this problem, the Java implementation of <TT><FONT FACE="Courier">Observer</FONT></TT>
has no reference to the <TT><FONT FACE="Courier">Observable</FONT></TT>.
One consequence of this decision is that <TT><FONT FACE="Courier">Observer</FONT></TT>s
cannot access their <TT><FONT FACE="Courier">Observable</FONT></TT>'s
state outside of the <TT><FONT FACE="Courier">update</FONT></TT>
method. As in the <TT><FONT FACE="Courier">GaugeView</FONT></TT>
class in the <TT><FONT FACE="Courier">SlideValue</FONT></TT> example,
the <TT><FONT FACE="Courier">Observer</FONT></TT> must cache any
information it needs in methods like <TT><FONT FACE="Courier">paint</FONT></TT>.
An alternative approach would have <TT><FONT FACE="Courier">update</FONT></TT>
in your <TT><FONT FACE="Courier">ConcreteObserver</FONT></TT>
store the <TT><FONT FACE="Courier">Observable</FONT></TT> reference
passed to it, at which point we come full circle to the problem
of dangling references.
<P>
Sometimes, it makes sense for a single <TT><FONT FACE="Courier">Observer</FONT></TT>
to depend on multiple <TT><FONT FACE="Courier">Observable</FONT></TT>s.
For example, a complicated form may incorporate data from multiple
data sources, or a three- dimensional rendering may include multiple
models. For situations like this, the <TT><FONT FACE="Courier">Observable</FONT></TT>
 reference passed to <TT><FONT FACE="Courier">update</FONT></TT>
can disambiguate <I>what</I> is being updated. If each <TT><FONT FACE="Courier">Observable</FONT></TT>
of interest is from a separate class, the <TT><FONT FACE="Courier">instanceof</FONT></TT>
keyword can provide enough information. If some of the <TT><FONT FACE="Courier">Observable</FONT></TT>s
are from the same classes, your <TT><FONT FACE="Courier">Observer</FONT></TT>
may need to keep references to all of its <TT><FONT FACE="Courier">Observable</FONT></TT>s
and compare the object references.
<P>
Does it seem as if many of these issues imply that <TT><FONT FACE="Courier">Observer</FONT></TT>s
should keep references to their <TT><FONT FACE="Courier">Observable</FONT></TT>s?
You may ask why the Java team did not incorporate these references
into <TT><FONT FACE="Courier">Observer</FONT></TT>. Well, first
of all, <TT><FONT FACE="Courier">Observer</FONT></TT> is an interface-it
has no data members. More importantly, however, the Java implementation
is the most basic and generic one. Nothing in the Java implementation
precludes adding an <TT><FONT FACE="Courier">Observable</FONT></TT>
reference in your <TT><FONT FACE="Courier">Observer</FONT></TT>s.
If the implementation already had such references, you would not
be able to remove them from your <TT><FONT FACE="Courier">Observer</FONT></TT>s.
In other words, you can embellish the existing classes at will,
but it is impossible to delete items from parent classes. This
philosophy is apparent in much of the Java class architecture.
Wherever possible, the Java developers have provided enough of
a framework to allow the embellishment, but not require it.
<P>
One of the questions you must answer when using <TT><FONT FACE="Courier">Observer</FONT></TT>s
is &quot;Who calls <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>?&quot;
There are basically two options:
<UL>
<LI><FONT COLOR=#000000>Have the </FONT><TT><FONT FACE="Courier">Observable</FONT></TT>
itself call <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
when it changes its own state. The advantage of this approach
is that the objects that request the state changes do not need
to know that the object is an <TT><FONT FACE="Courier">Observable</FONT></TT>.
It is impossible to subvert the publish-subscribe mechanism, whether
intentionally or accidentally. The developers of the client classes
do not need to remember to call <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>.
In the face of multiple, rapid updates, this approach will cause
several notifications, which may degrade performance.
<LI><FONT COLOR=#000000>Have the client object call </FONT><TT><FONT FACE="Courier">notifyObservers()</FONT></TT>
when it is finished making state changes. Although this approach
can provide dramatically improved performance by not triggering
unnecessary updates, it is not as safe. Client objects have an
additional responsibility, making errors more likely. Client may
forget to call <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>,
or they might deliberately avoid the call. In the Java environment,
you can never really guarantee that your class will be used only
in the intended manner.
</UL>
<P>
If you decide to have client objects call <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>,
your <TT><FONT FACE="Courier">Observable</FONT></TT> will need
pass-through methods for the <TT><FONT FACE="Courier">setChanged()</FONT></TT>
and <TT><FONT FACE="Courier">clearChanged()</FONT></TT> methods.
The <TT><FONT FACE="Courier">notifyObservers()</FONT></TT> methods
in <TT><FONT FACE="Courier">Observable</FONT></TT> check <TT><FONT FACE="Courier">hasChanged()</FONT></TT>.
If <TT><FONT FACE="Courier">hasChanged()</FONT></TT> returns <TT><FONT FACE="Courier">false</FONT></TT>,
<TT><FONT FACE="Courier">notifyObservers()</FONT></TT> does nothing.
<P>
An issue of consistency relates to this question of responsibility.
It is very important that <TT><FONT FACE="Courier">Observable</FONT></TT>s
publish notifications only when their internal state is consistent.
Otherwise, <TT><FONT FACE="Courier"> Observer</FONT></TT>s may
update their state from an inconsistent <TT><FONT FACE="Courier">Observable</FONT></TT>.
Intentional violations of this rule are not a big problem-they
are easily caught-but inherited operations can lead to violations.
For example, consider the following code fragment:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ParentClass extends Observable
{<BR>
&#133;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void setState(float value) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_ParentState
= value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class ChildClass extends ParentClass {<BR>
&#133;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void setState(float value) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.setState(value);&nbsp;&nbsp;&nbsp;&nbsp;
// notifyObservers gets called.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setChanged();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildState += value;&nbsp;&nbsp;&nbsp;&nbsp;
// Too late!<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearChanged();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
By the time <TT><FONT FACE="Courier">m_ChildState</FONT></TT>
is updated, the notifications have already been sent, while the
state was inconsistent. Sending another notification will not
help, because there is no telling what the <TT><FONT FACE="Courier">Observer</FONT></TT>
did with the bogus values in the meantime. If making all state-changing
methods in your <TT><FONT FACE="Courier">Observable</FONT></TT>
final is an option, you should do so. If not, you can use another
technique that is more or less bulletproof. The trick is to remove
the notification code from the methods that get inherited. Or,
stated another way, inherit only the state modification code.
The following code fragment illustrates this technique:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ParentClass extends Observable
{<BR>
&#133;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final void setState(float value)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internalSetState(value);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void internalSetState(float
value) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_ParentState
= value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class ChildClass extends ParentClass {<BR>
&#133;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void internalSetState(float
value) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.internalSetState(value);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ChildState += value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</FONT></TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=590><B>Multithreaded Observers</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=590>
<BLOCKQUOTE>
A multithreaded application is an ideal environment for using Observer. Often, controllers and views execute in separate threads. Using an <TT><FONT FACE="Courier">Observable</FONT></TT> allows the controller object, in its thread, to make changes in a synchronized manner. At the same time, the <TT><FONT FACE="Courier">Observer</FONT></TT>s automatically get notified. Be careful, because <TT><FONT FACE="Courier">update()</FONT></TT> gets called in the context of the controller that made the changes. If you intend to use <TT><FONT FACE="Courier">Observer</FONT></TT>s in a multithreaded application, all of your <TT><FONT FACE="Courier">update()</FONT></TT> methods should be synchronized. In addition, if your <TT><FONT FACE="Courier">Observer</FONT></TT> needs to do a lot of work in response to an update, it should do it in the context of the <TT><FONT FACE="Courier">Observer</FONT></TT>'s thread and not tie up the controller's thread. Take a look at the following code fragment for an idea of how this would work.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Public class MyObserver implements Observer {<BR>
&nbsp;&nbsp;&nbsp;boolean bUpdateNeeded;<BR>
&#133;<BR>
&nbsp;&nbsp;&nbsp;public void update(Observable o, Object arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateSync(o, arg);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;private synchronized void updateSync(Observable o, Object arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bUpdateNeeded = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&#133;<BR>
&nbsp;&nbsp;&nbsp;public void RunsInThread() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Wait for notice that an update is needed. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(bUpdateNeeded == false) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bUpdateNeeded = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Do the update */<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="TheModelViewControllerParadigm"><FONT SIZE=5 COLOR=#FF0000>The
Model-View-Controller Paradigm</FONT></A></H2>
<P>
Many GUI toolkits (aside from visual tools like Visual Basic or
Powerbuilder) partition the classes into user interface and application
data classes. (These are sometimes referred to as the presentation
and logic layers.) Smalltalk-80 bestowed upon us the Model/View/Controller
(MVC) architecture for presentation and logic layers. MVC refines
the idea of presentation and logic layers by introducing another
partition. An MVC triad consists of cooperating objects: the Model,
the View, and the Controller. The Controller and View are typically
user interface objects. The Controller allows a user to modify
the Model. Once modified, the Model notifies the View that a change
has occurred. The View queries the Model and displays the updated
information. By separating the objects this way, the interactions
are greatly simplified, the coupling is reduced, and the responsibilities
of each object are very clear. The Model never has a user interface
component. The View never changes the Model. The Controller never
directly interacts with the View. Figure 23.9 shows the connections
in an application with one Model, two Views, and two Controllers.
You can see that the upper half of the figure looks just like
the connections between an <TT><FONT FACE="Courier">Observable</FONT></TT>
and two <TT><FONT FACE="Courier">Observer</FONT></TT>s. Of course,
that is hardly a coincidence. In many ways, you can consider MVC
as one of the earliest occurrences of the <B>Observer</B> pattern.
<P>
<A HREF="f23-9.gif" ><B>Figure 23.9:</B> <I>An example of a Model-View-Controller architecture</I></A><I>.</I>
<P>
Although Java does not directly refer to MVC, the built-in <B>Observer</B>
mechanism forms the foundation upon which you can build MVC applications.
Java applications built with an MVC architecture evolve well over
time. They can easily adopt new interfaces, new models, and new
displays. Ideally, each component of MVC can be replaced or reused
independently of the whole.
<H3><A NAME="TheModelTheObservable">The Model (The <TT><FONT SIZE=4 FACE="Courier">Observable</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
The first, and most pivotal, component of MVC is the Model-the
aggregation of the application data and its internal rules. The
model encapsulates all behavior that the data has <I>on its own</I>.
It enforces consistency, handles persistence, and, most importantly,
ensures that all accesses to its state variables go through accessor
methods. The Model publishes notifications whenever its state
changes. Many Views can subscribe to these notifications.
<P>
In Java, a Model inherits from <TT><FONT FACE="Courier">Observable</FONT></TT>.
It can contain other objects and implement whatever interfaces
are helpful. The Model should not directly communicate with a
View or a Controller. Likewise, the Model should not create network
connections. (Odds are that the network connection would have
been used for one of three purposes: to report the Model's status,
to initiate some action on the remote side as a result of the
Model's state, or to query an external system and change the Model's
state accordingly. The first two should be done by <TT><FONT FACE="Courier">Observer</FONT></TT>s
anyway, and the last one is a Controller's job.) The Model should
always be able to stand alone, without the rest of the application
around it. It should be completely independent. The Model always
behaves in a reactive mode.
<H3><A NAME="TheViewTheObserver">The View (The <TT><FONT SIZE=4 FACE="Courier">Observer</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
The View is the visual display of the Model, or a relevant portion
of the Model. A spreadsheet might have chart, graph, and tabular
views into the underlying Model. The View does nothing more than
display the Model; it never manipulates it. A View must always
reflect the current state of its Model. Therefore, a View subscribes
to its Model's notifications.
<P>
Of course, a Java View implements the <TT><FONT FACE="Courier">Observer</FONT></TT>
interface. It can be a subclassed <TT><FONT FACE="Courier">Component</FONT></TT>,
<TT><FONT FACE="Courier">Container</FONT></TT>, or <TT><FONT FACE="Courier">Panel</FONT></TT>.
Although there can be <TT><FONT FACE="Courier">Observer</FONT></TT>s
that are not Views (that is, have no user interface), all Views
are <TT><FONT FACE="Courier">Observer</FONT></TT>s. Each View
should be aware that there may be many other Views, and take care
to be &quot;friendly.&quot; Update is called synchronously. Therefore,
if an update requires long calculations or extensive processing,
it should spawn a new thread to do the work. That way, the Model
can continue with its notifications.
<H3><A NAME="TheController2">The Controller</A></H3>
<P>
The Controller determines how the Model will react to the user
interface. Most of the time, the Controller <I>is </I>the user
interface. The Controller does not directly manipulate the View,
but the View reflects its changes to the Model.
<P>
A Java controller can be any graphical component or group of components.
Most of the time, the controller itself will be a Panel subclass,
with a number of components within it.
<H3><A NAME="TheAdvantagesofMVC">The Advantages of MVC</A></H3>
<P>
The three advantages of using MVC are flexibility, flexibility,
and flexibility. You can create new views for a model without
modifying the model in the slightest. You can create new controllers
without changing the model or the views. You can create and destroy
any number of views at runtime. In short, MVC applications can
grow and evolve, without turning into &quot;code jungles.&quot;
<P>
The objects in an MVC application interact in a very well-defined
way, which reduces bugs and enhances maintainability. The role
of each object is clear. Because the number of interactions is
kept to a minimum, the relationships are not fragile. Changes
to one class frequently do not require changes to other classes.
In an MVC application, the architecture is clear and obvious to
even a casual observer.
<P>
An interesting point about MVC applications is that they are generally
devoid of a mediator or controller object. One object does set
up the relationships, and that object &quot;owns&quot; the others,
in the sense that it is responsible for destroying them. But really,
there is not a single overseer. This has good and bad consequences.
On the plus side, by avoiding a single overseer, MVC objects interact
quickly and simply. On the down side, it is sometimes unclear
which object owns the MVC objects.
<H2><A NAME="TheAppletCADApplet"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">AppletCAD</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Applet</FONT></A></H2>
<P>
Now, let's apply the full <B>Observer</B> pattern within the context
of the Model/View/Controller architecture. This applet will use
multiple views of a common data model, with a distinct controller.
Figure 23.10 shows the applet in action. The main container uses
a grid layout to hold four panels. Three of the panels are views
that implement <TT><FONT FACE="Courier">Observer</FONT></TT>.
The fourth panel is the controller. Each view presents a two-dimensional
projection of three-dimensional points, similar to the editing
mode found in many CAD packages. The controller allows the user
to add a new point at the specified coordinates.
<P>
<A HREF="f23-10.gif" ><B>Figure 23.10:</B> <I>The </I>AppletCAD<I> applet with several points added.</I></A>
<H3><A NAME="TheApplet">The Applet</A></H3>
<P>
Listing 23.9 shows the code for the applet itself. Event-handling
code is conspicuous by its absence. The applet class constructs
the model, views, and controller. It creates the relationships.
Then, it gets out of the picture. After the MVC components are
created, they handle all of the interaction. There is no further
need for the applet to involve itself.
<HR>
<BLOCKQUOTE>
<B>Listing 23.9. </B><TT><B><FONT FACE="Courier">AppletCAD</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** AppletCAD.java<BR>
**<BR>
** Applet container for AppletCAD example<BR>
**<BR>
*/<BR>
<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import PointList;<BR>
import Point3D;<BR>
<BR>
public class AppletCAD extends Applet {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private XYView&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
xyView;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private YZView&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
yzView;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private XZView&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
xzView;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private CoordControl coordControl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private PointList&nbsp;&nbsp;&nbsp;&nbsp;pointList;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
model<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointList = new
PointList();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
views<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xyView = new XYView();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yzView = new YZView();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xzView = new XZView();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
controller<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coordControl =
new CoordControl(pointList);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Subscribe the
views to the model.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointList.addObserver(xyView);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointList.addObserver(yzView);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointList.addObserver(xzView);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add the views
and controller,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// using a layout
manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
GridLayout(2, 2));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(xyView);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(yzView);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(xzView);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(coordControl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Insets insets() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Insets(5,
5, 5, 5);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheObservabl">The <TT><FONT SIZE=4 FACE="Courier">Observabl</FONT></TT></A><FONT SIZE=4 FACE="Courier">e</FONT>
</H3>
<P>
<TT><FONT FACE="Courier">Point3D</FONT></TT>, shown in Listing
23.10, is used by the data model, the views, and the controller.
It is simply a three-dimensional analogue to <TT><FONT FACE="Courier">Point</FONT></TT>.
It has public members x, y, and z, which are all integers.
<HR>
<BLOCKQUOTE>
<B>Listing 23.10. The </B><TT><B><FONT FACE="Courier">Point3D</FONT></B></TT><B>
class used by the model, views, and controller.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** Point3D.java<BR>
**<BR>
** An x, y, z coordinate<BR>
**<BR>
*/<BR>
<BR>
public class Point3D {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int x, y, z;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Point3D(int ix, int iy, int iz)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = ix;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = iy;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z = iz;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void move(int nx, int ny, int nz)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = nx;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = ny;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z = nz;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void translate(int tx, int ty,
int tz) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += tx;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += ty;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z += tz;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The data model for this applet is shown in Listing 23.11. If Java
supported multiple inheritance, <TT><FONT FACE="Courier">PointList</FONT></TT>
would inherit from <TT><FONT FACE="Courier">Observable</FONT></TT>
and from <TT><FONT FACE="Courier">Vector</FONT></TT>. Instead,
it inherits from <TT><FONT FACE="Courier">Observable</FONT></TT>
and aggregates a <TT><FONT FACE="Courier">Vector</FONT></TT>.
It would have been equally possible to inherit from <TT><FONT FACE="Courier">
Vector</FONT></TT> and aggregate an <TT><FONT FACE="Courier">Observable</FONT></TT>
with a reference back to <TT><FONT FACE="Courier">Vector</FONT></TT>.
Semantically, the two are equivalent. For this example, <TT><FONT FACE="Courier">PointList</FONT></TT>
does not define pass-through methods for all of the methods in
<TT><FONT FACE="Courier">Vector</FONT></TT>. In the <TT><FONT FACE="Courier">addElement</FONT></TT>
and <TT><FONT FACE="Courier">setElementAt</FONT></TT> methods,
you can see the update notifications being generated.
<P>
<TT><FONT FACE="Courier">PointList</FONT></TT> does not have any
intrinsic behavior other than storage. In another application,
it might perform validation on the points, or provide persistent
storage. Because the <TT><FONT FACE="Courier">Observer</FONT></TT>s
and controller have no details about the inner workings of <TT><FONT FACE="Courier">PointList</FONT></TT>,
these features could be added without changing a single line of
code in the other classes.
<HR>
<BLOCKQUOTE>
<B>Listing 23.11. </B><TT><B><FONT FACE="Courier">PointList</FONT></B></TT><B>
class from the </B><TT><B><FONT FACE="Courier">AppletCAD</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** PointList.java<BR>
**<BR>
** An Observable which includes a vector of Point3D.<BR>
**<BR>
*/<BR>
<BR>
import java.util.*;<BR>
import Point3D;<BR>
<BR>
public class PointList extends Observable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Vector _points;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public PointList() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_points = new
Vector(10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public PointList(int capacity) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_points = new
Vector(capacity);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final Enumeration elements() {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _points.elements();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final synchronized void addElement(Object
obj) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_points.addElement(obj);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final int indexOf(Object elem)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return _points.indexOf(elem);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final synchronized void setElementAt(Object
obj, int index) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_points.setElementAt(obj,
index);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObservers();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearChanged();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheObservers">The Observers</A></H3>
<P>
Although there are three <TT><FONT FACE="Courier">Observer</FONT></TT>s,
each from their own class, they are sufficiently alike that we
can examine just one. All three <TT><FONT FACE="Courier">Observer</FONT></TT>s
are derived from a common base class. (This is not necessary in
general; it happened to be convenient for this applet.) That base
class, <TT><FONT FACE="Courier">TwoDView</FONT></TT>, is shown
in Listing 23.12, followed by the derived class <TT><FONT FACE="Courier">XYView</FONT></TT>
in Listing 23.13.
<HR>
<BLOCKQUOTE>
<B>Listing 23.12. </B><TT><B><FONT FACE="Courier">TwoDView</FONT></B></TT><B>,
the base class for two-dimensional views in the </B><TT><B><FONT FACE="Courier">AppletCAD</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** TwoDView.java<BR>
**<BR>
** Two dimensional view for AppletCAD example<BR>
**<BR>
*/<BR>
<BR>
import java.awt.*;<BR>
import java.util.*;<BR>
import PointList;<BR>
import Point3D;<BR>
<BR>
public abstract class TwoDView extends Panel implements Observer
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected PointList pl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private final int OVALWIDTH = 2;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void update(Observable item, Object
arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item instanceof
PointList) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pl
= (PointList)item;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Don't
know how to observe that!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension d =
size();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.paint(g);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.darkGray);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fill3DRect(0,
0, d.width, d.height, true);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawPoints(g);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Insets insets() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Insets(5,
5, 5, 5);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public final void drawPoints(Graphics
g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point3D&nbsp;&nbsp;&nbsp;&nbsp;
vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
point;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pl != null)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point
= new Point(0, 0);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(Enumeration
e = pl.elements(); e.hasMoreElements();) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex
= (Point3D)e.nextElement();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;projectPoint(vertex,
point);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawPoint(g,
point);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void drawPoint(Graphics g, Point
p) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillOval(p.x
- OVALWIDTH/2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.y
- OVALWIDTH/2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OVALWIDTH,
OVALWIDTH);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Sub-classes must implement this.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected abstract void projectPoint(Point3D
v, Point p);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT><FONT FACE="Courier">TwoDView</FONT></TT> does maintain a
reference to the model-<TT><FONT FACE="Courier">PointList</FONT></TT>.
It updates this reference each time <TT><FONT FACE="Courier">update</FONT></TT>
is called. Whenever a redisplay occurs, it obtains an enumerator
from <TT><FONT FACE="Courier">PointList</FONT></TT> (which in
turn obtains it from its <TT><FONT FACE="Courier">Vector</FONT></TT>).
<TT><FONT FACE="Courier">TwoDView</FONT></TT> walks the enumerator,
drawing each point. In order to draw a three-dimensional point
on a two-dimensional screen, <TT><FONT FACE="Courier">TwoDView</FONT></TT>
projects the point onto two dimensions. The details of the projection
are deferred to a subclass by the abstract <TT><FONT FACE="Courier">projectPoint</FONT></TT>
method. The current three subclasses each select two dimensions
of the three, performing an orthogonal projection. As an exercise,
you could add a fourth view to perform a perspective or orthographic
projection for realistic three-dimensional visualization, simply
by inheriting from <TT><FONT FACE="Courier">TwoDView</FONT></TT>
and performing the calculations in <TT><FONT FACE="Courier">projectPoint</FONT></TT>.
A completely unrelated view might display each point as coordinates.
By implementing <TT><FONT FACE="Courier">Observer</FONT></TT>,
you can add a new view without affecting any other class in the
applet (except for <TT><FONT FACE="Courier">AppletCAD</FONT></TT>,
of course, which would need to construct the new view).
<HR>
<BLOCKQUOTE>
<B>Listing 23.13. </B><TT><B><FONT FACE="Courier">XYView</FONT></B></TT><B>
class, a concrete subclass of </B><TT><B><FONT FACE="Courier">TwoDView</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** XYView.java<BR>
**<BR>
** Two dimensional view for AppletCAD example<BR>
**<BR>
*/<BR>
<BR>
import java.awt.*;<BR>
import TwoDView;<BR>
import Point3D;<BR>
<BR>
public class XYView extends TwoDView {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void projectPoint(Point3D v,
Point p) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.x = v.x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.y = v.y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheController3">The Controller</A></H3>
<P>
For this example, the controller is a simple derivative of <TT><FONT FACE="Courier">Panel</FONT></TT>,
shown in Listing 23.14. In response to the Add Point button, it
constructs a new <TT><FONT FACE="Courier">Point3D</FONT></TT>
with the coordinates entered in the text fields. It then asks
the <TT><FONT FACE="Courier">PointList</FONT></TT> to add the
new point. Notice that the views and the controller each have
a reference to the model, but the model has no direct references
to any other class. This is quite typical of a model/view/controller
system. The model stands independently, whereas its manipulators
must know how to find the model. The model simply knows that certain
<TT><FONT FACE="Courier">Observer</FONT></TT>s have expressed
an interest in its state.
<HR>
<BLOCKQUOTE>
<B>Listing 23.14. </B><TT><B><FONT FACE="Courier">CoordControl</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
** CoordControl.java<BR>
**<BR>
** Coordinate entry controller for AppletCAD example.<BR>
**<BR>
*/<BR>
<BR>
import java.awt.*;<BR>
import java.util.*;<BR>
import PointList;<BR>
import Point3D;<BR>
<BR>
public class CoordControl extends Panel {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private static String dimension[] = {&quot;X:&quot;,
&quot;Y:&quot;, &quot;Z:&quot;};<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private PointList&nbsp;&nbsp;_model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Button&nbsp;&nbsp;&nbsp;&nbsp;
_addButton;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private TextField&nbsp;&nbsp;_field[];
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public CoordControl(PointList pl) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints
c;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextField&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textField;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Remember the
model.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_model = pl;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(Color.lightGray);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setFont(new Font(&quot;Times&quot;,
Font.PLAIN, 12));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create the
controls.&nbsp;&nbsp;Use a GridBagLayout.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g = new GridBagLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new GridBagConstraints();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(g);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.fill = GridBagConstraints.HORIZONTAL;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add a caption
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = new Label(&quot;Coordinates&quot;,
Label.CENTER);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx = 0.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth =
GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(label,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(label);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add a label
and text field for each dimension<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_field = new TextField[3];
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i = 0; i &lt;
3; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label
= new Label(dimension[i], Label.RIGHT);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx
= .1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(label,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(label);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_field[i]
= new TextField();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx
= 1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth
= GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(_field[i],
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(_field[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add a button
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_addButton = new
Button(&quot;Add Point&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx = 0.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth =
GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setConstraints(_addButton,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(_addButton);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object target
= e.target;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(e.id == Event.ACTION_EVENT)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(target
== _addButton) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createPoint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.handleEvent(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private final void createPoint() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point3D p = new
Point3D(0, 0, 0);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.x = Integer.parseInt(_field[0].getText());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.y = Integer.parseInt(_field[1].getText());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.z = Integer.parseInt(_field[2].getText());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_model.addElement(p);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="HTMLContainer">HTML Container</A></H3>
<P>
The HTML container for this applet is shown in Listing 23.15.
It just reserves some space for the applet and provides links
to the applet code.
<HR>
<BLOCKQUOTE>
<B>Listing 23.15. HTML container for the </B><TT><B><FONT FACE="Courier">AppletCAD</FONT></B></TT><B>
example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;html&gt;<BR>
&lt;title&gt;AppletCAD&lt;/title&gt;<BR>
&lt;body&gt;<BR>
&lt;h1&gt;AppletCAD&lt;/h1&gt;<BR>
&lt;hr&gt;<BR>
&lt;applet code=AppletCAD.class width=300 height=400&gt;<BR>
&lt;/applet&gt;<BR>
&lt;menu&gt;<BR>
&lt;li&gt;&lt;a href=&quot;AppletCAD.java&quot;&gt;AppletCAD.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;PointList.java&quot;&gt;PointList.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;Point3D.java&quot;&gt;Point3D.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;CoordControl.java&quot;&gt;CoordControl.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;TwoDView.java&quot;&gt;TwoDView.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;XYView.java&quot;&gt;XYView.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;YZView.java&quot;&gt;YZView.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;li&gt;&lt;a href=&quot;XZView.java&quot;&gt;XZView.java&lt;/a&gt;&lt;br&gt;
<BR>
&lt;/menu&gt;<BR>
&lt;hr&gt;<BR>
&lt;/html&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Interaction">Interaction</A></H3>
<P>
The model, view, and controller classes in the <TT><FONT FACE="Courier">AppletCAD</FONT></TT>
example interact independently of the applet itself. The event
diagram in Figure 23.11 should look familiar. <TT><FONT FACE="Courier">AppletCAD</FONT></TT>
is really nothing more than a concrete implementation of the MVC
architecture, so the event diagram looks very similar. In this
concrete example, as in the previous example, you can see that
the Model, <TT><FONT FACE="Courier">PointList</FONT></TT>, calls
its own <TT><FONT FACE="Courier">notifyObservers()</FONT></TT>.
This yields adequate performance because the controller does not
allow for rapid batches of updates. This class deals with the
consistency problem by making all of its state-changing methods
final. (This is one advantage of Java over C++ or Delphi.)
<P>
<A HREF="f23-11.gif" ><B>Figure 23.11:</B> <I>Event interaction diagram for the </I>AppletCad<I> example.</I></A>
<P>
The chain of events begins when the user clicks the Add Point
button on the controller panel. The controller knows the model,
and it passes a new <TT><FONT FACE="Courier">Point3D</FONT></TT>
to the model. In response, the model notifies all interested <TT><FONT FACE="Courier">Observer</FONT></TT>s
of the update. In this example, all three views derive from a
common base class. They all share the implementation of <TT><FONT FACE="Courier">update()</FONT></TT>.
<B>Observer</B> does not require this. The <TT><FONT FACE="Courier">update()</FONT></TT>
method of a different view might store these points in an object
store, or even send a message to another applet or server. Nothing
limits <TT><FONT FACE="Courier">Observer</FONT></TT>s to graphical
entities. The three views each query the model for its state,
by enumerating the <TT><FONT FACE="Courier">Point3D</FONT></TT>s
and drawing each point. Notice that the applet itself is missing
from the event diagram.
<P>
Sometimes, instead of having the controller directly manipulate
the model, you might want the controller to construct a &quot;Command&quot;
object and pass it to a mediator. In that case, the mediator would
have the reference to the model. Whether your controller directly
manipulates the model or goes through an intermediary, the model
has no knowledge of which  controller sent a message. In fact,
it has no knowledge of how many or what type of controllers exist.
The model is decoupled from the controller(s), and it never needs
to interact with the controller.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You might ask, &quot;What about a controller that adapts its interface according to the state of the model?&quot; In that case, what you really have is a controller that is also a view! Remember the discussion earlier about mutually dependent classes? Clearly, it is also possible to have dependency trees or graphs! Be even more careful than usual with dependency graphs. They must be acyclic, or you risk &quot;update storms.&quot;</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="OtherApplicationsofObserver"><FONT SIZE=5 COLOR=#FF0000>Other
Applications of Observer</FONT></A></H2>
<P>
Although most of this chapter has focused on <B>Observer</B> in
the context of user interfaces, it has far more general applications.
<B>Observer</B> applies whenever one object depends on another
object's state. In other words, any time objects must remain consistent,
think <B>Observer</B>. Here are a few examples outside of the
GUI realm, which might spark some ideas.
<P>
For example, a simulation might require a <TT><FONT FACE="Courier">Clock</FONT></TT>
object to notify the actors on each second. By implementing the
<TT><FONT FACE="Courier">Clock</FONT></TT> as an <TT><FONT FACE="Courier">Observable</FONT></TT>,
the notification mechanism comes for free. By working at a higher,
more abstract level, the simulation developers can focus on the
important issues and not get bogged down in mechanics.
<P>
A point-of-sale system might use <B>Observer</B> to tally receipts.
Whenever the cash register object rings up a sale, an inventory
object needs to be notified. Call the cash register an <TT><FONT FACE="Courier">Observable</FONT></TT>
and call the inventory an <TT><FONT FACE="Courier">Observer</FONT></TT>,
and you've got it. Again, two objects need to remain synchronized.
Here, the inventory object itself might also be an <TT><FONT FACE="Courier">Observable</FONT></TT>,
with an automatic ordering system object as the <TT><FONT FACE="Courier">Observer</FONT></TT>.
<P>
Real-time data collection systems usually need some sort of data
quality monitor. The monitor should raise an alert or flag data
that falls outside of normal tolerances, due to bad inputs or
malfunctioning hardware. The sensor input processing objects are
<TT><FONT FACE="Courier">Observable</FONT></TT>s, and the monitor
can be an <TT><FONT FACE="Courier">Observer</FONT></TT>. In fact,
the logging or post-processing objects can also be <TT><FONT FACE="Courier">Observer</FONT></TT>s.
<P>
The <B>Observable</B> pattern easily accomplishes these necessary
tasks. By providing the <TT><FONT FACE="Courier">Observer</FONT></TT>/<TT><FONT FACE="Courier">Observable</FONT></TT>
pair, Java assists you in creating extremely flexible object-oriented
software. In the near future, Java will also run on cellular phones,
television set-top boxes, and network computers. When that happens,
the need to decouple dependent objects in Java applications will
increase tenfold, as we try to support a mind-boggling variety
of environments and interfaces.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Using the <TT><FONT FACE="Courier">java.util.Observer</FONT></TT>
interface and <TT><FONT FACE="Courier">java.util.Observable</FONT></TT>
class can greatly enhance your application's flexibility. By decoupling
dependent classes, <TT><FONT FACE="Courier">Observable</FONT></TT>s
establish a one-to-many publish-subscribe protocol. <TT><FONT FACE="Courier">Observer</FONT></TT>s
are automatically notified of changes to the <TT><FONT FACE="Courier">Observable</FONT></TT>s
state. <TT><FONT FACE="Courier">Observer</FONT></TT>s are often
used as user interface components. The design pattern <B>Observer</B>
captures this relationship as a &quot;solution to a problem in
a context.&quot; Design patterns provide a common vocabulary.
The <B>Observer</B> pattern can be implemented with many variations
for different situations. One such implementation is the Model-View-Controller
architecture from Smalltalk-80. MVC separates the system into
a Model, one or more Views, and one or more Controllers. The Model
is an <TT><FONT FACE="Courier">Observable</FONT></TT>, and the
Views are <TT><FONT FACE="Courier">Observer</FONT></TT>s.
<P>
<B>Observer</B> has many applications beyond the GUI realm. Any
time an object depends upon another object, <B>Observer</B> is
applicable. <TT><FONT FACE="Courier">Observer</FONT></TT>s and
<TT><FONT FACE="Courier">Observable</FONT></TT>s can be mutually
dependent and layered. They can have dependency graphs, but cyclic
graphs introduce special problems.
<P>
By using <TT><FONT FACE="Courier">Observer</FONT></TT>s in your
applications, you gain several benefits, including flexibility,
readability, maintainability, and robustness. <TT><FONT FACE="Courier">Observer</FONT></TT>s
are more flexible because <TT><FONT FACE="Courier">Observer</FONT></TT>s
can be extended, added, or replaced without changing the underlying
<TT><FONT FACE="Courier">Observable</FONT></TT>. Your code becomes
more readable because the <B>Observer</B> pattern can easily be
recognized and provides a well-known framework. Maintainability
and robustness come directly from the fact that the classes are
decoupled, reducing the ripple effect.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



