<HTML>
<HEAD>
<TITLE>developer.com - Reference</TITLE>

<META NAME="Author" CONTENT="developer.com">
<META NAME="Keywords" CONTENT="javascript, ActiveX, VRML, Push, channel,
push channel, applet, directory, news, community, developer, internet,
intranet, java, java applet, J++, javabeans, java products, tools, java
tools, JDK, java development kit, java development environment, JIT,
JavaPlan, enterprise tools, JVM, Java Virtual Machine, Java resources, API,
browser, java documentation, CDF, Common Desktop Format, RDF, Resource
Description Framework, Netcaster, Netcast, Castanet, meta-language, metadata,
solaris, Solaris, SUN, CGI, Perl, Oracle, database, network, Netscape API,
Apache, apache, SSL, mSQL, Netscape, Fasttrack, FastTrack,
industry standard, ActiveX bridge, web, internet, site, site
design, microsoft, active server pages, asp, iis, nt, win95, 95, html, cgi,
frontpage, business, corporate, vbscript, javascript, activex, isapi,
database, access, sql, server, www, 3.0, 3.01, 3.02, 3.03, 3.04, 4.0,
4.0b2, 4.01, 4.03, 4.04, connection, online, commerce, publisher,
publishing, publish, webmaster, dynamic html, dhtml, windows 98, netscape,
netscape software, shareware, magazines, jobs, japan, free, freeware, free
stuff">
<META NAME="description" CONTENT="Developer.com is the leading online
service for developers. It includes Gamelan, the official 
directory for Java, as well
as news, information, tutorials, and directories for other Internet technologies
including ActiveX, JavaScript, perl, VRML, Java Beans, push technologies, and
other Internet and intranet technologies. Developer.com is also the home of
Developer Direct, the Professional Developer's Store, where developers can
purchase and download thousands of Web, authoring and other development
products at some of today's lowest prices.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">

</HEAD>
<BODY BACKGROUND="/images/curve_r-wide.gif" BGCOLOR="#FFFFFF" TEXT="#000000" 
LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<TABLE>
<TR><TD VALIGN=TOP WIDTH=120>
<A HREF="/" >
<IMG SRC="/images/masthead_r.gif" WIDTH="100" HEIGHT="78" BORDER="0"
ALT="Developer.com Logo"></a>
</TD><TD>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCBAN.REF/DT=null">
<img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCBAN.REF/DT=null" HEIGHT="60" WIDTH="468" ALT="Click here to support our advertisers"><BR><CENTER>Click here to support our advertisers</CENTER></a>
</TD></TR>
</TABLE>
<!--outer table--><TABLE>
<!--outer table--><TR>
<!--outer table--><TD VALIGN="TOP">

<!--navbar info -->

<table><tr><td>

<A HREF="http://www.developerdirect.com/" >
<IMG SRC="/images/button_s.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>SHOPPING</b></font></a>

</td></tr><tr><td>

<A HREF="/community/jobs/c_jobs.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>JOB BANK</B></font></a>

</td></tr><tr><td>

<A HREF="http://www.classifieds2000.com/cgi-cls/display.exe?Developer+computer+searchcomputercategories">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>CLASSIFIEDS</B></font></a>

</td></tr><tr><td>

<A HREF="/directories/directories.html">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>DIRECTORIES</B></font></a>

</td></tr><tr><td>

<A HREF="/reference/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>REFERENCE</B></font></a>

<br>

<a href="/reference/r_library.html">
<FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">
Online Library</a></font>

</td></tr><tr><td>

<A HREF="/classroom/">
<IMG SRC="/images/button_r.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>LEARNING CENTER</B></font></a>

</td></tr><tr><td>

<A HREF="/journal/">
<IMG SRC="/images/button_n.gif" width="15" height="11" BORDER="0"><B><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000">JOURNAL</font></B></a>

</td></tr><tr><td>

<A HREF="/news/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>NEWS CENTRAL</b></font></a>

</td></tr><tr><td>

<A HREF="/downloads/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>DOWNLOADS</b></font></a>

</td></tr><tr><td>

<A HREF="/community/" >
<IMG SRC="/images/button_c.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><B>COMMUNITY</B></font></a>

</td></tr><tr><td>

<A HREF="/calendar/">
<IMG SRC="/images/button_d.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>CALENDAR</b></font></a>

</td></tr><tr><td>

<A HREF="/about/">
<IMG SRC="/images/button_a.gif" width="15" height="11" BORDER="0"><FONT FACE="Arial, Helvetica" SIZE="-1" color="#000000"><b>ABOUT US</b></a></font>

</td></tr></table>
<table>
<tr>
<td>
<form action="/subscribe/list.cgi" method=post >
<img src="/images/rule.gif" width="100" height="2"><br>
<B><FONT FACE="Arial, Helvetica" SIZE="-1">Journal:</b></font><br>
<input name='email' value='your e-mail' size="11">
<input type='hidden'  name='state' value='Subscribe'>
</td>
</tr>
<tr>
<td>
<input type='submit' value='Subscribe'>
<br>
<font size="-1">Get the weekly email highlights from the most popular journal for developers!
<br>
<a href="http://www.developer.com/subscribe.html">Current issue</a>
<img src="/images/rule.gif" width="100" height="2">
<input type='hidden' name='name' value='New Subscriber'>
</FORM>
</td>
</tr>
</table>
<!--/navbar-->
<font size="-1">
<A HREF="http://www.developer.com">developer.com</a><BR>
<A HREF="http://www.developerdirect.com">developerdirect.com</a><BR>
<A HREF="http://www.htmlgoodies.com">htmlgoodies.com</a><BR>
<A HREF="http://www.javagoodies.com">javagoodies.com</a><br>
<A HREF="http://www.jars.com">jars.com</a><BR>
<a href="http://www.intranetjournal.com">intranetjournal.com</a><br>
<a href="http://www.javascripts.com">javascripts.com</a><br>
</font>
<!--outer table--></TD>

<!--outer table--><TD VALIGN="TOP">
<BLOCKQUOTE>
<P>

<img src="/images/header_r.gif" width="440" height="50">
<P>
<MAP NAME ="header_r2.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/author.html"
      COORDS ="361,0,440,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/basic.html"
      COORDS ="254,0,360,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/help.html"
      COORDS ="183,0,251,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/cool.html"
      COORDS ="100,0,181,29">
<AREA SHAPE ="RECT"
      HREF ="/reference/mybook.html"
      COORDS ="0,0,100,29">
</MAP>

<MAP NAME ="header_r1.gif.map">

<AREA SHAPE ="RECT"
      HREF ="/reference/personalize.html"
      COORDS ="339,0,439,29">
</MAP>

<p>


<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
<H1><FONT COLOR=#FF0000>Chapter 17</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Programming the User Interface</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#IntroductionandBasicConcepts" >Introduction and Basic Concepts</A>
<LI><A HREF="#PlatformIndependenceGoneTodayHere" >Platform Independence: Gone Today, Here Tomorrow</A>
<LI><A HREF="#AbstractWindowToolkitAWT" >Abstract Window Toolkit (AWT)</A>
<UL>
<LI><A HREF="#GraphicsClass" >Graphics Class</A>
<LI><A HREF="#TheupdatepaintandrepaintMethods" >The update, paint, and repaint Methods</A>
<LI><A HREF="#WorkingwithColor" >Working with Color</A>
<LI><A HREF="#GeometricClasses" >Geometric Classes</A>
<LI><A HREF="#TheToolkit" >The Toolkit</A>
</UL>
<LI><A HREF="#Drawing" >Drawing</A>
<UL>
<LI><A HREF="#DrawingText" >Drawing Text</A>
<LI><A HREF="#DrawingLines" >Drawing Lines</A>
<LI><A HREF="#DrawingShapes" >Drawing Shapes</A>
<LI><A HREF="#FillingShapes" >Filling Shapes</A>
<LI><A HREF="#Animation" >Animation</A>
</UL>
<LI><A HREF="#InteractiveInterfaceElements" >Interactive Interface Elements</A>
<UL>
<LI><A HREF="#ComponentClassSharedFeaturesofAllA" >Component Class-Shared Features of All Active GUI Elements</A>
<LI><A HREF="#Containers" >Containers</A>
<LI><A HREF="#Panels" >Panels</A>
<LI><A HREF="#Insets" >Insets</A>
<LI><A HREF="#Frames" >Frames</A>
<LI><A HREF="#Windows" >Windows</A>
<LI><A HREF="#Labels" >Labels</A>
<LI><A HREF="#Buttons" >Buttons</A>
<LI><A HREF="#Checkboxes" >Checkboxes</A>
<LI><A HREF="#RadioButtons" >Radio Buttons</A>
<LI><A HREF="#ChoiceMenus" >Choice Menus</A>
<LI><A HREF="#ScrollingLists" >Scrolling Lists</A>
<LI><A HREF="#TheTextComponentClassInvisiblebutUs" >The TextComponent Class-Invisible but Useful</A>
<LI><A HREF="#TextField" >TextField</A>
<LI><A HREF="#TextArea" >TextArea</A>
<LI><A HREF="#Canvases" >Canvases</A>
</UL>
<LI><A HREF="#OrganizingYourInterfacewithLayouts" >Organizing Your Interface with Layouts</A>
<UL>
<LI><A HREF="#NoLayoutManager" >No Layout Manager</A>
<LI><A HREF="#FlowLayout" >FlowLayout</A>
<LI><A HREF="#GridLayout" >GridLayout</A>
<LI><A HREF="#GridBagLayout" >GridBagLayout</A>
<LI><A HREF="#BorderLayout" >BorderLayout</A>
<LI><A HREF="#CardLayout" >CardLayout</A>
<LI><A HREF="#CustomLayouts" >Custom Layouts</A>
</UL>
<LI><A HREF="#Images" >Images</A>
<UL>
<LI><A HREF="#LoadingImagesfromFilesImageObserver" >Loading Images from Files (ImageObserver)</A>
<LI><A HREF="#ClippingImagesCropImageFilterMediaT" >Clipping Images (CropImageFilter, MediaTracker)</A>
<LI><A HREF="#FilteringImagesRGBImageFilter" >Filtering Images (RGBImageFilter)</A>
<LI><A HREF="#BuildingImagesOntheFlyMemoryImageS" >Building Images On-the-Fly (MemoryImageSource)</A>
<LI><A HREF="#ConvertingImagestoArraysPixelGrabbe" >Converting Images to Arrays (PixelGrabber)</A>
</UL>
<LI><A HREF="#Wndows" >Windows</A>
<LI><A HREF="#Frame" >Frames</A>
<UL>
<LI><A HREF="#CursorControl" >Cursor Control</A>
<LI><A HREF="#Menus" >Menus</A>
</UL>
<LI><A HREF="#Dialog" >Dialog</A>
<LI><A HREF="#FileDialog" >FileDialog</A>
<LI><A HREF="#WorkingwithApplications" >Working with Applications</A>
<LI><A HREF="#AppletMethodsofInterest" >Applet Methods of Interest</A>
<LI><A HREF="#ExtendingtheAWT" >Extending the AWT</A>
<UL>
<LI><A HREF="#ExtendingComponentstheImageButton" >Extending Components (the Image Button)</A>
<LI><A HREF="#UsingOtherPeoplesClasses" >Using Other People's Classes</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL></UL>
<HR>
<H2><A NAME="IntroductionandBasicConcepts"><FONT SIZE=5 COLOR=#FF0000>Introduction
and Basic Concepts</FONT></A></H2>
<P>
This chapter covers the various tools Java provides to help you
build the user interface for your Java application or applet.
Java provides a rich set of tools to make platform-independent,
easy-to-use graphical user interfaces. Your Java project can use
three groups of interface elements:
<UL>
<LI><B>Drawing</B>: Non-interactive interface items such as lines,
rectangles, ovals, and arcs in both filled and unfilled versions.
<LI><B>Interactive elements</B>: Interface elements that enable
the user to interact with your project. They consist of things
such as buttons, menus, and text areas.
<LI><B>Images</B>: Bitmaps that can be built on-the-fly or read
in as GIF or JPEG format files.
</UL>
<P>
If you've ever programmed a <I>graphical user interface</I> (GUI)
for the Mac, Windows, or UNIX, you'll find that the basic tools
are familiar. Java is catching on because, unlike previous languages,
the interface is pretty much platform independent so that you
don't have to maintain multiple code bases-one for each target
platform.
<H2><A NAME="PlatformIndependenceGoneTodayHere"><FONT SIZE=5 COLOR=#FF0000>Platform
Independence: Gone Today, Here Tomorrow</FONT></A></H2>
<P>
Although Java is technically platform independent, discrepancies
still exist between platforms. These differences result from three
different mechanisms:
<UL>
<LI><B>Implementation:</B> The hooks from Java to the client machine's
operating system are implemented by different teams on each machine.
Although they work with a single standard, they introduce different
bugs at different times. A particular interface feature that works
in JDK 1.0.2 for the Mac might not work in JDK 1.0.2 for Windows,
for example, and the bug list for JDK 1.0.2 on Windows is different
(and longer) than the bug list for the same version of the JDK
on the Mac. The good news is that as Java matures, these types
of differences will go away. Check <TT><A TARGET="resource window" HREF="http://java.sun.com/products/JDK/">http://java.sun.com/products/JDK/</A></TT>
to find links to the latest information on the current version
of the JDK and associated bug lists.
<LI><B>Design:</B> Because Java uses the operating system on each
platform to provide basic GUI elements (such as buttons), applications
and applets look different on each platform. On the Mac, for example,
a windows menu bar is placed at the top of the screen rather than
in the window. This is very different from what users see on Windows
or UNIX machines, but it's what Mac users expect. Although you
can control the amount of space used by an item, you can't control
the detailed look and feel. These differences are there as long
as different operating systems are used. This actually is nice,
because your users see interfaces that are familiar to them. Imagine
the uproar if you tried to make Mac users live with a Motif interface!
<LI><B>Standards or the lack thereof: </B>The Java language standard
strives to be complete and unambiguous. Unfortunately, defining
a computer language so that everyone who implements it does so
in an exactly identical fashion is very difficult. You should
expect some ambiguities in the standard; it is interpreted in
slightly different ways by the people who implement Java on different
platforms. These discrepancies tend to be eliminated over time;
the larger the discrepancy, the quicker it is stomped out.
</UL>
<P>
Because you can't really do much about any of these issues, you
need to test your projects on as many different platforms as you
think they will run on. For applets that are used on the Internet,
that means pretty much every platform, whereas for an application
running on your company's intranet, it might mean only Sun and
SGI. The good news is that for simple interfaces, you'll find
that although everything doesn't look identical across platforms,
the matchup is pretty good. If you don't have access to multiple
platforms, you can be fairly sure that your interface will look
pretty much the same on any platform that supports Java.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If the content of the WWW site on which you're going to use the applet is machine specific, you probably don't have to worry about the applet not being pretty on other platforms. If you have a Mac software site, you probably won't get a whole lot of visits from Windows users.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="AbstractWindowToolkitAWT"><FONT SIZE=5 COLOR=#FF0000>Abstract
Window Toolkit (AWT)</FONT></A></H2>
<P>
The Abstract Window Toolkit (or Alternative Window Toolkit, depending
on who you talk to) is a visual interface kit that comes with
all the current implementations of Java. As its name indicates,
though, the intent is for other-hopefully, more powerful and easier
to use-toolkits to be developed by various vendors in the future.
For now, if you want to do any interface work in Java, the AWT
package is the way to go.
<P>
Figures 17.1 through 17.3 show the inheritance hierarchy of the
classes commonly used in building interfaces.
<P>
<A HREF="f17-1.gif" ><B>Figure 17.1 : </B><I>AWT classes that inherit from </I><B>Java.lang object.</B></A>
<P>
<A HREF="f17-2.gif" ><B>Figure 17.2 : </B><I>All the classes that control the placement of objects on the screen inherit from the </I><B>Java.lang object.</B><I>class.</I></A>
<P>
<A HREF="f17-3.gif" ><B>Figure 17.3 : </B><I>The </I><B>Applet.</B><I>class inherits from</I><B> java.awt.Panel,</B><I>so you can draw directly to an applet.</I></A>
<P>
These class structures might seem a bit intimidating at first,
but if you glance through them, you'll see that most AWT classes
just inherit from <TT><FONT FACE="Courier">Object</FONT></TT>.
In addition, all the interactive elements (except menus) inherit
from <TT><FONT FACE="Courier">Component</FONT></TT>. The only
other very important thing to note is that because <TT><FONT FACE="Courier">Applet</FONT></TT>
inherits from <TT><FONT FACE="Courier">Panel</FONT></TT> (which
inherits from <TT><FONT FACE="Courier">Container</FONT></TT>),
applets can directly contain other objects such as buttons, canvases,
and so on. This section describes how you can build hierarchies
of containers in applets.
<P>
All the other classes are described as they become relevant in
the following sections. Use the diagrams included in these sections
as quick references when you want to find out what capabilities
a class inherits.
<H3><A NAME="GraphicsClass"><TT><FONT SIZE=4 FACE="Courier">Graphics</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">Graphics</FONT></TT> class is part
of the AWT. It's contained in <TT><FONT FACE="Courier">java.awt.Graphics</FONT></TT>,
and it's the basic class for everything you'll draw on-screen.
Applets have associated <TT><FONT FACE="Courier">Graphics</FONT></TT>
instances, as do various components such as buttons. Drawing methods,
such as <TT><FONT FACE="Courier">drawLine</FONT></TT>, work on
a <TT><FONT FACE="Courier">Graphics</FONT></TT> instance, so you'll
see many calls in this form in a typical Java applet:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(10,10,20,20);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">Graphics</FONT></TT> class uses a
standard computer coordinate system with the origin in the upper-
left corner, as shown in Figure 17.4.
<P>
<A HREF="f17-4.gif" ><B>Figure 17.4 : </B><I>The Java </I><B>Graphics</B> <I>class coordinate system.</I></A>
<P>
All coordinate measurements in Java are done in pixels. The size
of items, therefore, in absolute units such as inches or millimeters,
differs on various machines due to differing pixels/inch values.
<P>
You'll find that whenever your program has to draw something,
you'll be using <TT><FONT FACE="Courier">Graphics</FONT></TT>
class methods. The following sections discuss the most useful
methods. Here's a listing of the methods that aren't covered later
in this chapter, but that occasionally will be useful.
<H5>clipRect(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
Changes the clipping region to the intersection of the current
clipping rectangle and the one specified in the input arguments.
This means that the clipping region can only get smaller.
</BLOCKQUOTE>
<H5>copyArea(int x, int y, int width,
int height, int new_x, int new_y)</H5>
<BLOCKQUOTE>
Copies the rectangular area defined by <TT><FONT FACE="Courier">x</FONT></TT>,
<TT><FONT FACE="Courier">y</FONT></TT>, <TT><FONT FACE="Courier">width</FONT></TT>,
and <TT><FONT FACE="Courier">height</FONT></TT> to a rectangle
defined by <TT><FONT FACE="Courier">new_x</FONT></TT>, <TT><FONT FACE="Courier">new_y</FONT></TT>,
<TT><FONT FACE="Courier">width</FONT></TT>, and <TT><FONT FACE="Courier">height</FONT></TT>
in the same <TT><FONT FACE="Courier">Graphics</FONT></TT> object.
</BLOCKQUOTE>
<H5>Graphics, create()</H5>
<BLOCKQUOTE>
Makes a clone of the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object.
</BLOCKQUOTE>
<H5>Graphics, create(int x, int y, int
width, int height)</H5>
<BLOCKQUOTE>
Makes a clone of the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object, but with a clipping region defined by the intersection
of the current clipping rectangle and the one specified by <TT><FONT FACE="Courier">x</FONT></TT>,
<TT><FONT FACE="Courier">y</FONT></TT>, <TT><FONT FACE="Courier">width</FONT></TT>,
and <TT><FONT FACE="Courier">height</FONT></TT>. In addition,
the origin of the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object returned by this call is set to <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>.
</BLOCKQUOTE>
<H5>setPaintMode()</H5>
<BLOCKQUOTE>
Sets the painting mode to draw over; it is used to undo the effects
of <TT><FONT FACE="Courier">setXORMode</FONT></TT>.
</BLOCKQUOTE>
<H5>setXORMode(Color a_color)</H5>
<BLOCKQUOTE>
Sets the drawing mode to exclusive <TT><FONT FACE="Courier">OR</FONT></TT>.
The color is bitwise exclusive <TT><FONT FACE="Courier">OR</FONT></TT>ed
with the current color and the foreground color to produce the
final color.
</BLOCKQUOTE>
<H5>translate(int x, int y)</H5>
<BLOCKQUOTE>
Translates the origin of the <TT><FONT FACE="Courier">Graphics</FONT></TT>
area to the specified point.
</BLOCKQUOTE>
<H3><A NAME="TheupdatepaintandrepaintMethods">The <TT><FONT SIZE=4 FACE="Courier">update</FONT></TT><FONT SIZE=4>,
</FONT><TT><FONT SIZE=4 FACE="Courier">paint</FONT></TT><FONT SIZE=4>,
and </FONT><TT><FONT SIZE=4 FACE="Courier">repaint</FONT></TT><FONT SIZE=4>
Methods</FONT></A></H3>
<P>
You'll encounter three key methods over and over again as you
work with the various user interface elements.
<H5>repaint</H5>
<BLOCKQUOTE>
Requests a redraw of an item or an entire interface. It then calls
<TT><FONT FACE="Courier">update</FONT></TT>.
</BLOCKQUOTE>
<H5>update</H5>
<BLOCKQUOTE>
Controls what happens when <TT><FONT FACE="Courier">repaint</FONT></TT>
is called; you can override this method.
</BLOCKQUOTE>
<H5>paint</H5>
<BLOCKQUOTE>
Determines what's done when any item is redrawn. It's called whenever
something needs to be redrawn-for example, when a window is uncovered.
All displayable entities have <TT><FONT FACE="Courier">paint</FONT></TT>
methods that they inherit from <TT><FONT FACE="Courier">Component</FONT></TT>.
<BR>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Interactive elements, such as buttons, are redrawn automatically; you don't have to implement a <TT><FONT FACE="Courier">paint</FONT></TT> method for them.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
All these methods are defined in the <TT><FONT FACE="Courier">Component</FONT></TT>
class. This means that all the various interactive controls and
applets inherit these methods. Although all these methods can
be overridden, you'll find that <TT><FONT FACE="Courier">paint</FONT></TT>
and <TT><FONT FACE="Courier">update</FONT></TT> are the ones you
work with most often. Listing 17.1 shows a simple example of how
<TT><FONT FACE="Courier">paint</FONT></TT> and <TT><FONT FACE="Courier">repaint</FONT></TT>
can be used.
<HR>
<BLOCKQUOTE>
<B>Listing 17.1. An example of </B><TT><B><FONT FACE="Courier">paint</FONT></B></TT><B>
and </B><TT><B><FONT FACE="Courier">repaint</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class paint_methods extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start () {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
+= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//wait
50 milliseconds and then call repaint again<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(50);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw a string
to the screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Hello,
World!&quot;, 25, y );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
After you run this code, you see the phrase <TT><FONT FACE="Courier">Hello,
World!</FONT></TT> slide down the screen. You're probably wondering
why you don't see many copies of <TT><FONT FACE="Courier">Hello,
World!</FONT></TT> on-screen at the same time. The answer is the
<TT><FONT FACE="Courier">update</FONT></TT> method. Listing 17.2
shows the default <TT><FONT FACE="Courier">update</FONT></TT>
method.
<HR>
<BLOCKQUOTE>
<B>Listing 17.2. The default </B><TT><B><FONT FACE="Courier">update</FONT></B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(getBackground()); //set the
drawing color to the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//background
color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0,0,width,height); //fill the
window with the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//background
color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(getForeground()); //reset the
foreground color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;paint(g); //call paint to redraw everything
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The first three lines erase whatever is in the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object so that anything that was drawn before it is deleted. You
can change this behavior by overriding the <TT><FONT FACE="Courier">update</FONT></TT>
method. The version of the <TT><FONT FACE="Courier">update</FONT></TT>
method shown in Listing 17.3, when added to the applet in Listing
17.1, gives you the result shown in Figure 17.5 because the screen
isn't erased between calls to <TT><FONT FACE="Courier">paint</FONT></TT>.
<P>
<A HREF="f17-5.gif" ><B>Figure 17.5 : </B><I>Overriding the </I><B>update</B> <I>method.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.3. A revised </B><TT><B><FONT FACE="Courier">update</FONT></B></TT><B>
method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;paint(g); //call paint to redraw everything
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
One thing to remember about calling the <TT><FONT FACE="Courier">repaint</FONT></TT>
method is that it doesn't always execute immediately. Java repaints
as soon as it can, but sometimes repaints pile up because the
computer is busy. Remember that your applet might be running on
some fairly slow platforms; in this case, Java throws out some
of the repaints, discarding the oldest repaints first. Because
of this practice, three other versions of <TT><FONT FACE="Courier">repaint</FONT></TT>
are available with different input parameters.
<H5>repaint(long time_in_milliseconds)</H5>
<BLOCKQUOTE>
Tries to call <TT><FONT FACE="Courier">update</FONT></TT> for
the number of milliseconds specified in the input argument. If
<TT><FONT FACE="Courier">update</FONT></TT> can't be called by
the end of the specified time, <TT><FONT FACE="Courier">repaint</FONT></TT>
gives up. Note that no error is thrown if the method gives up.
You will want to use this version primarily for animations, when
you know that repaints will occur frequently.
</BLOCKQUOTE>
<H5>repaint(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
Repaints only the rectangular part of the screen defined by <TT><FONT FACE="Courier">x</FONT></TT>,
<TT><FONT FACE="Courier">y</FONT></TT>, <TT><FONT FACE="Courier">width</FONT></TT>,
and <TT><FONT FACE="Courier">height</FONT></TT>.
</BLOCKQUOTE>
<H5>repaint(long time, int x, int y,
int width, int height)</H5>
<BLOCKQUOTE>
Combines the previous two <TT><FONT FACE="Courier">repaint</FONT></TT>
versions so that only a portion of the screen is updated. If it
can't be done before the specified time elapses (in milliseconds),
it is skipped.
</BLOCKQUOTE>
<BLOCKQUOTE>
When you invoke <TT><FONT FACE="Courier">repaint</FONT></TT> on
a container, such as an applet, the AWT takes care of invoking
<TT><FONT FACE="Courier">update</FONT></TT> on all the items in
the container-even ones inside other containers that are in the
top-level container.
</BLOCKQUOTE>
<H3><A NAME="WorkingwithColor">Working with Color</A></H3>
<P>
The AWT provides very generalized color support. The abstract
<TT><FONT FACE="Courier">ColorModel</FONT></TT> class enables
you to define how colors are represented. The AWT comes with two
predefined color models: <TT><FONT FACE="Courier">IndexColorModel</FONT></TT>
and <TT><FONT FACE="Courier">DirectColorModel</FONT></TT>. <TT><FONT FACE="Courier">IndexColorModel</FONT></TT>
is used when images have a lookup table of colors and each pixel's
value is an index in the lookup table. The pixel's color is determined
by the color value in the lookup table specified by the index.
<TT><FONT FACE="Courier">DirectColorModel</FONT></TT> uses a 32-bit
integer to hold the data for the color. Regardless of which color
model you use, you still can represent individual colors as 32-bit
integers (as described later in this section). In general, you
won't have to worry about the <TT><FONT FACE="Courier">ColorModel</FONT></TT>
class.
<H4>RGB and HSB Color Formats</H4>
<P>
The AWT's normal color model is RGB; in this model, a color is
defined by its <TT><FONT FACE="Courier">red</FONT></TT>, <TT><FONT FACE="Courier">green</FONT></TT>,
and <TT><FONT FACE="Courier">blue</FONT></TT> components. Each
of these three values is an <TT><FONT FACE="Courier">int</FONT></TT>
with a value between <TT><FONT FACE="Courier">0</FONT></TT> and
<TT><FONT FACE="Courier">255</FONT></TT>. An RGB value can be
stored in an <TT><FONT FACE="Courier">int</FONT></TT> with bits
31 through 24 being unused, bits 23 through 16 for the <TT><FONT FACE="Courier">red</FONT></TT>
value, bits 15 through 8 storing the <TT><FONT FACE="Courier">green</FONT></TT>
value, and bits 0 through 7 for the <TT><FONT FACE="Courier">blue</FONT></TT>
component of the color. The applet in Listing 17.4 shows how to
extract the color components from an <TT><FONT FACE="Courier">int</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 17.4. Extracting color components from an integer.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class unpack_color extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//getRGB is a
static method so you invoke it with the name of the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//class. You don't
need a specific instance.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int temp = Color.white.getRGB();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unpack_colors(temp);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void unpack_colors(int the_color)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int red, green,
blue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the highest
order byte is unused<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the next highest
byte is red<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = the_color
&amp; 0x00FF0000;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//shift the value
to the right so it's in the range 0-255<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = red &gt;&gt;
16;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the next-to-last
byte is green<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = the_color
&amp; 0x0000FF00;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//shift the value
to the right so it's in the range 0-255<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = green
&gt;&gt; 8;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the lowest byte
is blue<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = the_color
&amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;red
= &quot; + red + &quot; green= &quot; + green +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
blue= &quot; + blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
A <TT><FONT FACE="Courier">Color</FONT></TT> class is available
that enables you to use a single object rather than three <TT><FONT FACE="Courier">int</FONT></TT>s
to define a color. Most AWT methods that use colors require you
to pass them an instance of a <TT><FONT FACE="Courier">Color</FONT></TT>
object.
<P>
The <TT><FONT FACE="Courier">Color</FONT></TT> class also has
several methods for manipulating and creating colors.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
All of the method descriptions in this chapter start with the type of value returned by the method (if no type is shown it's void) followed by the method name and its input arguments. For example, <BR>
means that the <TT><FONT FACE="Courier">clipRect</FONT></TT> method does not return a value.<BR>
<TT><FONT FACE="Courier">Graphics, create()<BR>
</FONT></TT>means that the <TT><FONT FACE="Courier">create</FONT></TT> method returns a value of type <TT><FONT FACE="Courier">Graphics</FONT></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H5>Color, brighter()</H5>
<BLOCKQUOTE>
Returns a new color that is approximately 1.5 times brighter than
the current color.
</BLOCKQUOTE>
<H5>Color, darker()</H5>
<BLOCKQUOTE>
Returns a color about 70 percent as bright as the original color.
</BLOCKQUOTE>
<H5>boolean, equals(Object item)</H5>
<BLOCKQUOTE>
Checks to see whether two colors are the same.
</BLOCKQUOTE>
<H5>int, getBlue()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">blue</FONT></TT> component
of a color.
</BLOCKQUOTE>
<H5>Color, getColor(String color)</H5>
<BLOCKQUOTE>
Returns an instance of the <TT><FONT FACE="Courier">Color</FONT></TT>
class given a string containing a decimal or hexadecimal number.
For example, <TT><FONT FACE="Courier">0x0000FF</FONT></TT> produces
a deep blue. This is a static method. This version and the next
two versions are useful primarily when reading in parameters from
HTML.
</BLOCKQUOTE>
<H5>Color, getColor(String color, Color
default)</H5>
<BLOCKQUOTE>
Performs the same function as the preceding, except if the string
isn't in the right format, it returns the color defined by the
second parameter.
</BLOCKQUOTE>
<H5>Color, getColor(String color, int
rgb)</H5>
<BLOCKQUOTE>
Performs the same function as the preceding, except you supply
a default packed integer with RGB values, not an instance of <TT><FONT FACE="Courier">color</FONT></TT>.
</BLOCKQUOTE>
<H5>Color, getHSBColor(float hue, float
saturation, float brightness)</H5>
<BLOCKQUOTE>
Returns an instance of the <TT><FONT FACE="Courier">Color</FONT></TT>
class based on the supplied HSB values (<TT><FONT FACE="Courier">hue</FONT></TT>,
<TT><FONT FACE="Courier">saturation</FONT></TT>, and <TT><FONT FACE="Courier">brightness</FONT></TT>).
This is a static method.
</BLOCKQUOTE>
<H5>int, getGreen()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">green</FONT></TT> component
of the color.
</BLOCKQUOTE>
<H5>int, HSBtoRGB(float hue, float saturation,
float brightness)</H5>
<BLOCKQUOTE>
Produces an integer containing the RGB values of a color-with
<TT><FONT FACE="Courier">blue</FONT></TT> in the lowest byte,
<TT><FONT FACE="Courier">green</FONT></TT> in the second byte,
and <TT><FONT FACE="Courier">red</FONT></TT> in the third byte-when
given the three HSB values. This is a static method.
</BLOCKQUOTE>
<H5>int, getRGB()</H5>
<BLOCKQUOTE>
Returns the packed-integer version of the RGB values of a color.
</BLOCKQUOTE>
<H5>int, getRed()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">red</FONT></TT> component
of a color.
</BLOCKQUOTE>
<H5>float[], RGBtoHSB(int r, int g, int
b)</H5>
<BLOCKQUOTE>
Returns an array of floats containing the <TT><FONT FACE="Courier">h</FONT></TT>,
<TT><FONT FACE="Courier">s</FONT></TT>, and <TT><FONT FACE="Courier">b</FONT></TT>
values of the equivalent color to the specified <TT><FONT FACE="Courier">r</FONT></TT>,
<TT><FONT FACE="Courier">g</FONT></TT>, and <TT><FONT FACE="Courier">b</FONT></TT>
values.
</BLOCKQUOTE>
<H4>Using HSB Colors</H4>
<P>
As you probably guessed from the names of some of these methods,
the AWT also lets you work with the HSB model. In this model,
colors are represented as hue, saturation, and brightness.
<UL>
<LI><B>Hue:</B> The hue-red or blue, for example-portion of the
color. The value runs from <TT><FONT FACE="Courier">0</FONT></TT>
to <TT><FONT FACE="Courier">1/4 PI</FONT></TT>, with <TT><FONT FACE="Courier">0</FONT></TT>
corresponding to red and <TT><FONT FACE="Courier">1/4 PI</FONT></TT>
to violet.
<LI><B>Saturation:</B> Determines how far from gray a color is.
The value runs from <TT><FONT FACE="Courier">0</FONT></TT> to
<TT><FONT FACE="Courier">1</FONT></TT>. A value of <TT><FONT FACE="Courier">0</FONT></TT>
corresponds to a gray scale. By varying this parameter, you can
fade out a color picture.
<LI><B>Brightness: </B>Determines how bright a given color is.
The value runs from <TT><FONT FACE="Courier">0</FONT></TT> to
<TT><FONT FACE="Courier">1</FONT></TT>. A brightness of <TT><FONT FACE="Courier">0</FONT></TT>
gives you black. A value of <TT><FONT FACE="Courier">1</FONT></TT>
gives you the brightest color of the given hue and saturation
possible.
</UL>
<P>
There are a number of reasons to use the HSB representation. You
can convert a color image to black and white by just setting the
saturation of all the pixels to <TT><FONT FACE="Courier">0</FONT></TT>.
Similarly, if you want to create a continuous color spectrum,
it's easy to smoothly change the hue to get a continuum-within
the limits of the color support of your monitor and Web browser-of
colors. The applet shown in Listing 17.5 creates the rainbow shown
in Figure 17.6; trust me-even though you can see it only in black
and white, it looks great in color.
<P>
<A HREF="f17-6.gif" ><B>Figure 17.6 : </B><I>A Java rainbow brought to you by the wonders of HSB. Because you easily can create color objects with RGB or HSB values, you can use both in any program.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.5. Creating a rainbow.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class rainbow extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int n_steps;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int rainbow_width;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float h,s,b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y,i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color temp_color;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int patch_width,patch_height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float incr;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_steps = 256;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define how much
the Hue will change between steps<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr = (float)(0.25*Math.PI/n_steps);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rainbow_width
= 256;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//figure out how
wide each step would be<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch_width =
(int)(rainbow_width/n_steps);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch_height =
50;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fix the value
of Saturation to the maximum value<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = (float)1.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fix the value
of Brightness to the maximum value<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = (float)1.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 40;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw a set of
rectangles filled with the colors of<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the rainbow
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_steps;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h
= incr*i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create
a new color using the HSB parameters<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp_color
= Color.getHSBColor(h,s,b);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set
the current drawing color to the new color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(temp_color);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
+= patch_width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw
a rectangle whose upper lefthand corner is at<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//x,y
and which is patch_width wide and patch_height<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tall
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(x,y,patch_width,patch_height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="GeometricClasses">Geometric Classes</A></H3>
<P>
Several generally useful classes exist that are used to contain
information about locations and shapes. They're used as arguments
for many of the drawing-related methods.
<H4><TT><FONT FACE="Courier">Dimension</FONT></TT></H4>
<P>
Stores a width and a height as attributes. You can access these
attributes with this code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Dimension d;<BR>
int w,h;<BR>
h = d.height;<BR>
w = d.width;</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">Point</FONT></TT></H4>
<P>
Represents an x and y coordinate. The points <TT><FONT FACE="Courier">x</FONT></TT>
and <TT><FONT FACE="Courier">y</FONT></TT> are accessible. <TT><FONT FACE="Courier">Point</FONT></TT>
also supports two methods.
<H5>move(int x, int y)</H5>
<BLOCKQUOTE>
Sets the <TT><FONT FACE="Courier">x</FONT></TT> and <TT><FONT FACE="Courier">y</FONT></TT>
values of the point to the input parameter values.
</BLOCKQUOTE>
<H5>translate(int delta_x, int delta_y)</H5>
<BLOCKQUOTE>
Adds the input parameter values to the current <TT><FONT FACE="Courier">x</FONT></TT>
and <TT><FONT FACE="Courier">y</FONT></TT> values of the point-for
example, <TT><FONT FACE="Courier">x = x + delta_x</FONT></TT>.
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">Polygon</FONT></TT></H4>
<P>
Represents an arbitrarily ordered list of vertices. You can directly
access the three main attributes.
<H5>int x[]</H5>
<BLOCKQUOTE>
Specifies the array of <TT><FONT FACE="Courier">x</FONT></TT>
values for the vertices.
</BLOCKQUOTE>
<H5>int y[]</H5>
<BLOCKQUOTE>
Specifies the array of <TT><FONT FACE="Courier">y</FONT></TT>
values. The <I>n</I>th <TT><FONT FACE="Courier">y</FONT></TT>
value and the <I>n</I>th <TT><FONT FACE="Courier">x</FONT></TT>
value define a vertex location.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Polygon</FONT></TT> has several useful
methods.
</BLOCKQUOTE>
<H5>int npoints</H5>
<BLOCKQUOTE>
Specifies the number of vertices.
</BLOCKQUOTE>
<H5>addPoint(int x, int y)</H5>
<BLOCKQUOTE>
Adds a new vertex to the polygon.
</BLOCKQUOTE>
<H5>Rectangle, getBoundingBox()</H5>
<BLOCKQUOTE>
Returns the smallest rectangle that contains all the vertices.
</BLOCKQUOTE>
<H5>boolean, inside(int x, int y)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the point
defined by <TT><FONT FACE="Courier">x</FONT></TT> and <TT><FONT FACE="Courier">y</FONT></TT>
is inside the polygon.
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">Rectangle</FONT></TT></H4>
<P>
This has four public instance variables: the x and y coordinates
of its upper-left corner (unless the height or width is negative,
in which case the origin is in one of the other corners), its
width, and its height. <TT><FONT FACE="Courier">Rectangle</FONT></TT>
has a number of methods that make working with rectangular regions
easy.
<H5>add(int x, int y)</H5>
<BLOCKQUOTE>
Adds the specified <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>
point to a <TT><FONT FACE="Courier">Rectangle</FONT></TT> by growing
the rectangle to the smallest rectangle that contains the original
rectangle and the point.
</BLOCKQUOTE>
<H5>add(Point a_point)</H5>
<BLOCKQUOTE>
Performs the same function as the preceding method, except the
input parameter is a point rather than two integers.
</BLOCKQUOTE>
<H5>add(Rectangle a_rectangle)</H5>
<BLOCKQUOTE>
Grows the rectangle to the smallest one that contains the original
rectangle and the rectangle supplied as the input parameter.
</BLOCKQUOTE>
<H5>grow(int delta_w, int delta_h)</H5>
<BLOCKQUOTE>
Grows the rectangle by the specified amount in height and width.
Each side of the rectangle moves a distance <TT><FONT FACE="Courier">delta_w</FONT></TT>
so that the overall width of the rectangle increases by <TT><FONT FACE="Courier">2*delta_w</FONT></TT>.
If the original rectangle width and height are <TT><FONT FACE="Courier">50</FONT></TT>,<TT><FONT FACE="Courier">50</FONT></TT>
and the two input parameters to grow are <TT><FONT FACE="Courier">50</FONT></TT>,<TT><FONT FACE="Courier">75</FONT></TT>,
the new width and height would be <TT><FONT FACE="Courier">150</FONT></TT>,<TT><FONT FACE="Courier">200</FONT></TT>.
</BLOCKQUOTE>
<H5>boolean, inside(int x, int y)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the point
<TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>
is inside the rectangle.
</BLOCKQUOTE>
<H5>Rectangle, intersection(Rectangle
rect)</H5>
<BLOCKQUOTE>
Returns a rectangle that contains the intersection of the two
rectangles. If the rectangles don't overlap, the resulting rectangle
has <TT><FONT FACE="Courier">0</FONT></TT> height and width.
</BLOCKQUOTE>
<H5>boolean, intersects(Rectangle rect)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the rectangles
overlap, including just a shared edge or vertex.
</BLOCKQUOTE>
<H5>boolean, isEmpty()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the height
or width of a rectangle is <TT><FONT FACE="Courier">0</FONT></TT>.
</BLOCKQUOTE>
<H5>move(int x, int y)</H5>
<BLOCKQUOTE>
Sets the origin of the rectangle to <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>.
</BLOCKQUOTE>
<H5>reshape(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
Sets the origin of the rectangle to <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>,
its width to <TT><FONT FACE="Courier">width</FONT></TT>, and its
height to <TT><FONT FACE="Courier">height</FONT></TT>.
</BLOCKQUOTE>
<H5>resize(int width, int height)</H5>
<BLOCKQUOTE>
Sets the width of the rectangle to <TT><FONT FACE="Courier">width</FONT></TT>
and its height to <TT><FONT FACE="Courier">height</FONT></TT>.
</BLOCKQUOTE>
<H5>translate(int d_x, int d_y)</H5>
<BLOCKQUOTE>
Moves the rectangle a distance <TT><FONT FACE="Courier">d_x</FONT></TT>
in x and <TT><FONT FACE="Courier">d_y</FONT></TT> in y.
</BLOCKQUOTE>
<H5>Rectangle, union(Rectangle rect)</H5>
<BLOCKQUOTE>
Returns a new rectangle that is the smallest one that contains
both rectangles.
</BLOCKQUOTE>
<H3><A NAME="TheToolkit">The <TT><FONT SIZE=4 FACE="Courier">Toolkit</FONT></TT></A>
</H3>
<P>
This abstract class serves as a bridge between the platform-specific
and the platform-independent parts of Java. It's the interface
used to create peers for components such as buttons, and its methods
let Java programs find out about platform-specific features such
as the available fonts and the characteristics of the desktop.
Because this is an abstract class, you don't instantiate it, but
it does have a number of useful methods, including the following.
<P>
The <TT><FONT FACE="Courier">Toolkit</FONT></TT> is your primary
interface to machine-dependent information and interfaces. It's
usable in applications and applets. Methods that are implemented
by the <TT><FONT FACE="Courier">Applet</FONT></TT> class, such
as <TT><FONT FACE="Courier">getImage</FONT></TT>, are available
in applications via the <TT><FONT FACE="Courier">Toolkit</FONT></TT>.
You can use the static method <TT><FONT FACE="Courier">getDefaultToolkit()</FONT></TT>
to get the <TT><FONT FACE="Courier">Toolkit</FONT></TT>, as in
this snippet:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Toolkit current_toolkit = Toolkit.getDefaultToolkit();
<BR>
} catch(AWTError e) {}<BR>
</FONT></TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The peer of a component is the platform-specific interface definition of the methods that the component has to support. Implementing a Java component on a new platform (Linux, for example) consists of writing native methods to fill in the peer interface definition.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H5>Dimension: getScreenSize()</H5>
<BLOCKQUOTE>
Returns the screen size in pixels.
</BLOCKQUOTE>
<H5>int: getScreenResolution()</H5>
<BLOCKQUOTE>
Returns the screen resolution in pixels/inch.
</BLOCKQUOTE>
<H5>ColorModel: getColorModel()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">ColorModel</FONT></TT>, which
defines how color is represented on the platform.
</BLOCKQUOTE>
<H5>String[]: getFontList()</H5>
<BLOCKQUOTE>
Gets a list of the names of the fonts available on the platform.
</BLOCKQUOTE>
<H5>FontMetrics: getFontMetrics(Font
font)</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">FontMetrics</FONT></TT>,
which provide measurements of a font's screen size, for the specified
font on the desktop.
</BLOCKQUOTE>
<H5>Image: getImage(String filename)</H5>
<BLOCKQUOTE>
Gets an image from the file specified in the input argument.
</BLOCKQUOTE>
<H5>Image: getImage(URL a_url)</H5>
<BLOCKQUOTE>
Gets an image from a specified URL.
</BLOCKQUOTE>
<H5>boolean, prepareImage(Image an_image,
int width, int height, ImageObserver obs)</H5>
<BLOCKQUOTE>
Forces the loading of an image, with a given width and height.
You can use the image observer to monitor the progress of loading
the image. If <TT><FONT FACE="Courier">width</FONT></TT> and <TT><FONT FACE="Courier">height</FONT></TT>
aren't the current dimensions of the image, the image is scaled.
</BLOCKQUOTE>
<H5>int, checkImage(Image an_image, int
width, int height, ImageObserver obs)</H5>
<BLOCKQUOTE>
Returns an integer that can be tested to determine the status
of the image. <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
constants that you can <TT><FONT FACE="Courier">AND</FONT></TT>
with the returned value are <TT><FONT FACE="Courier">WIDTH</FONT></TT>,
<TT><FONT FACE="Courier">HEIGHT</FONT></TT>, <TT><FONT FACE="Courier">PROPERTIES</FONT></TT>,
<TT><FONT FACE="Courier">SOMEBITS</FONT></TT>, <TT><FONT FACE="Courier">FRAMEBITS</FONT></TT>,
and <TT><FONT FACE="Courier">ALLBITS</FONT></TT>. If the returned
value <TT><FONT FACE="Courier">AND</FONT></TT>ed with <TT><FONT FACE="Courier">ALLBITS</FONT></TT>
returns <TT><FONT FACE="Courier">TRUE</FONT></TT>, the image is
fully loaded.
</BLOCKQUOTE>
<H5>Image: createImage(ImageProducer
an_image_source)</H5>
<BLOCKQUOTE>
Takes an image source, such as a filter, and creates an image.
</BLOCKQUOTE>
<H2><A NAME="Drawing"><FONT SIZE=5 COLOR=#FF0000>Drawing</FONT></A>
</H2>
<P>
The methods and tools described in this section enable you to
draw simple graphical items that are non-interactive-although
you can use the <TT><FONT FACE="Courier">Canvas</FONT></TT> component
and/or the location of mouse clicks to make these items behave
as though they were interactive. If you've ever written code for
a modern GUI, or even Windows, you'll find most of the drawing
utilities fairly familiar. All these operations are implemented
as methods on the <TT><FONT FACE="Courier">Graphics</FONT></TT>
class. Because anything you can draw on has a <TT><FONT FACE="Courier">Graphics</FONT></TT>
class as an attribute, this doesn't limit the utility of these
functions.
<H3><A NAME="DrawingText">Drawing Text</A></H3>
<P>
You've already seen an example of drawing text using the <TT><FONT FACE="Courier">drawString</FONT></TT>
method. The general syntax for that method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Graphics g;<BR>
g.drawString(String string_to_draw, int x_position, int y_position)</FONT></TT>
</BLOCKQUOTE>
<P>
You also can use the <TT><FONT FACE="Courier">drawChars</FONT></TT>
method if you have an array of type <TT><FONT FACE="Courier">char</FONT></TT>
rather than a string.
<H4>Working with Fonts</H4>
<P>
Back in the dark ages, before the Mac and the desktop publishing
revolution, people were used to having only a few fonts available
for use on the computer. Things have changed dramatically since
then; now people commonly buy CD-ROMs with more than 1,000 fonts
for $50. Unfortunately, Java reintroduces a new generation to
the wonders of limited fonts. This probably will change rapidly
as Java and the Internet standards mature, but for right now,
typographic simplicity is the order of the day.
<P>
You can create instances of the <TT><FONT FACE="Courier">Font</FONT></TT>
class using this creator syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Font a_font = new Font(String name_of_font,
int font_style, int font_size);</FONT></TT>
</BLOCKQUOTE>
<P>
The generally available fonts follow:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Courier<BR>
Dialog<BR>
Helvetica<BR>
Symbol<BR>
TimesRoman</FONT></TT>
</BLOCKQUOTE>
<P>
Because the set of available fonts may change, you might want
to use a variation of the applet shown in Listing 17.6 to check
for what fonts are available; this code works in applications
as well.
<HR>
<BLOCKQUOTE>
<B>Listing 17.6. Checking for available fonts.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class discover_fonts extends Applet<BR>
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String FontList[];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font a_font;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontList = getToolkit().getFontList();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;FontList.length;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_font
= new Font(FontList[i],Font.BOLD,12);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(a_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;This
is the &quot; + FontList[i] + <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
Font&quot;,25, 15*(i + 1));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This applet just gets a list of strings containing the names of
the available fonts. Figure 17.7 shows the output of this applet.
<P>
<A HREF="f17-7.gif" ><B>Figure 17.7 : </B><I>The available fonts.</I></A>
<P>
The last line is Symbol font. The style for all the fonts was
set to bold by using the font constant <TT><FONT FACE="Courier">Font.BOLD</FONT></TT>.
You also can use <TT><FONT FACE="Courier">Font.ITALIC</FONT></TT>
and <TT><FONT FACE="Courier">Font.PLAIN</FONT></TT>. You can combine
styles by bitwise <TT><FONT FACE="Courier">OR</FONT></TT>ing them.
This line produces a font that is both italic and bold, for example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Font a_font = new Font(&quot;Helvetica&quot;,(Font.BOLD
| Font.ITALIC),12);<BR>
</FONT></TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Not all fonts support all styles. Courier prints the same no matter what you set the style to, as you can see in Figure 17.7.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Measuring Fonts, Centering Text</H4>
<P>
You'll find that you often need to precisely position text in
an applet. The <TT><FONT FACE="Courier">FontMetrics</FONT></TT>
class provides an easy way to find out how much space text drawn
with a given instance of <TT><FONT FACE="Courier">Font</FONT></TT>
will be. Just in case you're not a typographic expert, Table 17.1
provides some quick definitions of the key font measurement terms,
illustrated in Figure 17.8.
<P>
<A HREF="f17-8.gif" ><B>Figure 17.8 : </B><I>Font terminology.</I></A>
<BR>
<P>
<CENTER><B>Table 17.1. </B><TT><B><FONT FACE="Courier">FontMetrics</FONT></B></TT><B>
terms.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=78>Height</TD><TD WIDTH=513>The height of the tallest character in a font. It's therefore the maximum vertical distance you need to reserve when drawing a string with the font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=78>Baseline</TD><TD WIDTH=513>The bottom of all characters are positioned on this imaginary line. The descent part of a character, such as the bottom curl on a g, lies below this line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=78>Ascent</TD><TD WIDTH=513>Measures the height of the character above the baseline. This can include the amount of whitespace recommended by the font designer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=78>Descent</TD><TD WIDTH=513>Measures the height (or, more appropriately, depth) of the character below the baseline. This can include the amount of whitespace recommended by the font designer.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The applet shown in Listing 17.7 shows you how to access the <TT><FONT FACE="Courier">FontMetrics</FONT></TT>
information. The result is shown in Figure 17.9.
<P>
<A HREF="f17-9.gif" ><B>Figure 17.9 : </B><I>Viewing </I><B>FontMetrics</B> <I>information.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.7. Accessing </B><TT><B><FONT FACE="Courier">FontMetrics</FONT></B></TT><B>
information.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class font_metrics extends Applet<BR>
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font a_font;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics a_font_metric;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String the_message;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int string_width,
font_height,font_ascent, font_descent;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int font_ascent_no_white,
font_descent_no_white;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_message =
&quot;Alien Space Monsters! &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make a new font
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_font = new Font(&quot;Helvetica&quot;,Font.BOLD,16);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(a_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the metrics
for the font<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_font_metric
= g.getFontMetrics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the width
of the message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string_width =
a_font_metric.stringWidth(the_message);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the height
of the font<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font_height =
a_font_metric.getHeight();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the ascent
of the font; this includes whitespace <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//recommended
by the font designer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font_ascent =
a_font_metric.getAscent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the descent
of the font; this includes whitespace <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//recommended
by the font designer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font_descent =
a_font_metric.getDescent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the ascent
without whitespace<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font_ascent_no_white
= a_font_metric.getMaxAscent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the descent
without whitespace<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font_descent_no_white
= a_font_metric.getMaxDescent();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//now show these
values to the user<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(the_message,
10,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += font_height
+ 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Message
width is &quot; + string_width, 10,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += font_height
+ 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Font
height is &quot; + font_height, 10,y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += font_height
+ 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Font
ascent is &quot; + font_ascent +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
without white space it's &quot; + font_ascent_no_white , 10,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += font_height
+ 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Font
descent is &quot; + font_descent +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;
without white space it's &quot; + font_descent_no_white , 10,y);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This information is useful in a number of ways. First, notice
how the tops of the letters in the first line in Figure 17.9 are
cut off. That's because when you specify the y coordinate for
a string, you're specifying the location of the baseline-not the
upper-left corner of the text that is being drawn. To figure out
where to put the baseline, you just need to look at the value
of the ascent. Instead of defining the first value of y as 10,
just change it to this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">y = font_ascent + 2; //the extra 2 provides
some whitespace <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//that
the font otherwise lacks</FONT></TT>
</BLOCKQUOTE>
<P>
The first line now is completely visible, as Figure 17.10 shows.
<P>
<A HREF="f17-10.gif" ><B>Figure 17.10 : </B><I>Keeping your text in sight.</I></A>
<P>
Another common use for <TT><FONT FACE="Courier">FontMetrics</FONT></TT>
data is to center text in an area. The code in Listing 17.8 centers
text in an area.
<HR>
<BLOCKQUOTE>
<B>Listing 17.8. Centering text.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;public void draw_centered_text(Graphics
g, String the_msg,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int width, int height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fm = g.getFontMetrics();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//find out how
much free space there is on either side of the string by<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//subtracting
the width of the string from the width of the window and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//dividing by
2<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = (width - fm.stringWidth(the_msg))/2;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//find out how
much free space there is above<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//and below the
string's baseline<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = fm.getAscent()
+ (height - fm.getHeight())/2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw the string
so that the baseline is centered<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(the_msg,x,y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You can get the width and height of an applet's area by using the <TT><FONT FACE="Courier">getSize</FONT></TT> method, which returns a <TT><FONT FACE="Courier">Dimension</FONT></TT> value. The <TT><FONT FACE="Courier">height()</FONT></TT> and <TT><FONT FACE="Courier">width()</FONT></TT> methods of the <TT><FONT FACE="Courier">Dimension</FONT></TT> class enable you to get the height and width values.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Figure 17.11 shows the result of centering text in a window.
<P>
<A HREF="f17-11.gif" ><B>Figure 17.11 : </B><I>Centering text.</I></A>
<H3><A NAME="DrawingLines">Drawing Lines</A></H3>
<P>
Three methods for drawing lines currently are available in Java.
Listing 17.9 shows a small applet that demonstrates how to draw
straight lines, arcs, and a point.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
No special command for drawing individual pixels is available. Just use <TT><FONT FACE="Courier">drawLine</FONT></TT> as shown in Listing 17.9; alternatively, you can use <TT><FONT FACE="Courier">drawRect</FONT></TT> or <TT><FONT FACE="Courier">fillRect</FONT></TT>, which are discussed later in this section.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.9. Drawing straight lines, arcs, and a point.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class drawpoint extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x_final, y_final;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this draws a
line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(10,10,100,100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this draws a
point at 10,30<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(10,30,10,30);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this draws an
arc<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawArc(50,50,30,30,0,180);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this draws a
filled arc<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(50,100,20,40,90,90);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This applet generates the picture shown in Figure 17.12.
<P>
<A HREF="f17-12.gif" ><B>Figure 17.12 : </B><I>A point, a line, an arc and a filled arc.</I></A>
<P>
Here are the full descriptions for the three line-drawing methods.
<H5>drawLine(int x_start, int y_start,
int x_end, int y_end)</H5>
<BLOCKQUOTE>
This draws a line between two points.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x_start: Starting x position<BR>
y_start: Starting y position<BR>
x_end: Final x position<BR>
y_end: Final y position</FONT></TT>
</BLOCKQUOTE>
<H5>drawArc(int x, int y, int width,
int height, int start_angle, int delta_angle)</H5>
<BLOCKQUOTE>
This routine draws an arc, a segment of an ellipse, or a circle,
as Figure 17.13 shows.<BR>
<A HREF="f17-13.gif" ><B>Figure 17.13 : </B><I>Parameters for</I> <B>drawArc</B> <I>and</I> <B>fillArc</B> <I>method.</I></A>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: Upper-left corner of the
rectangle that contains the ellipse the arc is from.<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: Upper-left corner of the
rectangle that contains the ellipse the arc is from.<BR>
<TT><FONT FACE="Courier">width</FONT></TT>: The width of the rectangle
that contains the ellipse the arc is from.<BR>
<TT><FONT FACE="Courier">height</FONT></TT>: The height of the
rectangle that contains the ellipse the arc is from.<BR>
<TT><FONT FACE="Courier">start_angle</FONT></TT>: The angle at
which the arc starts; 0 degrees is at the 3 o'clock position,
and the value increases in the counterclockwise direction.
</BLOCKQUOTE>
<H5>fillArc(int x, int y, int width,
int height, int start_angle, int delta_angle)</H5>
<BLOCKQUOTE>
This is the same as <TT><FONT FACE="Courier">drawArc</FONT></TT>,
except that the arc is filled with the current color.
</BLOCKQUOTE>
<BLOCKQUOTE>
One of the key shortcomings with current Java drawing routines
is that you can't specify a line width. All the drawing commands
draw unit-width lines. If you want to draw thicker lines, you
can follow an approach similar to the one shown in Listing 17.10.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 17.10. Drawing thicker lines.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;public void draw_thick_line(Graphics
g, int x_start,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
y_start, int x_final,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
y_final, int width) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;width;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawLine(x_start+i,y_start
+ i,x_final+i,y_final+i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This method just draws several lines to make a thicker line. You
can use the same approach for the shapes you'll see in the next
section.
<P>
The final way to draw very complex lines is to use the <TT><FONT FACE="Courier">drawPolygon</FONT></TT>
method, which is described in the next section. With it, you can
draw arbitrarily complex paths.
<H3><A NAME="DrawingShapes">Drawing Shapes</A></H3>
<P>
Java provides a standard set of methods for drawing typical geometric
shapes, such as rectangles, ovals, and polygons. It also has a
method for drawing 3D rectangles (rectangles with shading to make
them look 3D), but because the line widths are so narrow, it's
almost impossible to see the 3D effect under normal circumstances.
The syntax for the various shape-drawing methods follow.
<H5>drawRect(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
This draws a traditional rectangle.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">width</FONT></TT>: Width of the rectangle
<BR>
<TT><FONT FACE="Courier">height</FONT></TT>: Height of the rectangle
</BLOCKQUOTE>
<H5>drawRoundRect(int x, int y, int width,
int height, int r_width, int r_height)</H5>
<BLOCKQUOTE>
This draws a rectangle with rounded corners. You define the amount
of curvature by setting the width and height of the rectangle
that contains the curved corner (see Figure 17.14).
</BLOCKQUOTE>
<P>
<A HREF="f17-14.gif" ><B>Figure 17.14 : </B><I>Defining the degree of roundness for rounded rectangles.</I></A>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">width</FONT></TT>: Width of the rectangle
<BR>
<TT><FONT FACE="Courier">height</FONT></TT>: Height of the rectangle
<BR>
<TT><FONT FACE="Courier">r_width</FONT></TT>: Width of the rectangle
that defines the roundness of the corner<BR>
<TT><FONT FACE="Courier">rectangle</FONT></TT>: Defines the roundness
of the corner<BR>
<TT><FONT FACE="Courier">r_height</FONT></TT>: Height of the rectangle
that defines the roundness of the corner
</BLOCKQUOTE>
<H5>draw3DRect(int x, int y, int width,
int height, boolean flag)</H5>
<BLOCKQUOTE>
This draws a rectangle with a 3D shadow. Because the lines are
so thin, you can't really see the shadow.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: Upper-left corner<BR>
<TT><FONT FACE="Courier">width</FONT></TT>: Width of rectangle
<BR>
<TT><FONT FACE="Courier">height</FONT></TT>: Height of rectangle
<BR>
<TT><FONT FACE="Courier">flag</FONT></TT>: If <TT><FONT FACE="Courier">TRUE</FONT></TT>,
the rectangle is raised; if <TT><FONT FACE="Courier">FALSE</FONT></TT>,
the rectangle is indented
</BLOCKQUOTE>
<H5>drawPolygon(int x[], int y[], int
n_points)</H5>
<BLOCKQUOTE>
This takes two lists-one with x and one with y coordinates-and
draws a line between successive points. The polygon will not close
automatically. If you want a closed polygon, you must make sure
that the first and last points have the same coordinates.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: An array of integers with
the x coordinates of the polygon's vertices<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: An array of integers with
the y coordinates of the polygon's vertices<BR>
<TT><FONT FACE="Courier">n_points</FONT></TT>: Number of vertices
in the polygon
</BLOCKQUOTE>
<H5>drawOval(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
This draws an oval. If <TT><FONT FACE="Courier">width</FONT></TT>
and <TT><FONT FACE="Courier">height</FONT></TT> have the same
value, you get a circle.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x</FONT></TT>: Upper-left corner of the
rectangle that contains the oval (see Figure 17.15)<BR>
<TT><FONT FACE="Courier">y</FONT></TT>: Upper-left corner of the
rectangle that contains the oval<BR>
<TT><FONT FACE="Courier">width</FONT></TT>: Width of the rectangle
that contains the oval<BR>
<TT><FONT FACE="Courier">height</FONT></TT>: Height of the rectangle
that contains the oval
</BLOCKQUOTE>
<P>
<A HREF="f17-15.gif" ><B>Figure 17.15 : </B><I>Defining the size of an oval with the </I><B>width </B><I>and </I><B>height </B><I>parameters.</I></A>
<H3><A NAME="FillingShapes">Filling Shapes</A></H3>
<P>
For each method starting with &quot;draw,&quot; there is another
method that starts with &quot;fill.&quot; The &quot;fill&quot;
methods have the same parameters and behave in the same way, except
that they draw versions of the shapes filled with the current
color.
<P>
The applet in Listing 17.11 shows how the draw and fill versions
of the various commands work. It produces the screen shown in
Figure 17.16.
<P>
<A HREF="f17-16.gif" ><B>Figure 17.16 : </B><I>The various drawing functions in action.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.11. Using the draw and fill commands.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class drawshapes extends Applet<BR>
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y,x_o,width,height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the x coordinates
for the polygon vertices<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x_list[] =
{80,90,120,83,80};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the y coordinates
for the two polygons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y_list[] ={5,35,60,40,10};
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int y_list_1[]
= {70,95,120,100,70};<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawRect(10,5,20,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(10,27,20,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawOval(50,5,20,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillOval(50,27,20,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawPolygon(x_list,
y_list, 5);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillPolygon(x_list,y_list_1,5);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawRoundRect(130,5,20,20,5,5);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRoundRect(130,27,20,20,10,15);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw3DRect(160,5,20,20,true);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw3DRect(160,27,20,20,false);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width = 2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = 2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 10;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_o = 30;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 50;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw a set of
ten regular and filled rectangles and ovals<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;10;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
+= 25;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width
+= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height
+= 2;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawRect(x,y,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawOval(x_o,y,width,height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The 3D rectangles don't look all that three-dimensional. The effect
is subtle, and you should experiment with it on different platforms
and with different color combinations to find one that looks good.
Figure 17.17 shows the result of an applet that draws two standard
3D rectangles-one raised and the other sunken-with white lines
on a black background. It then draws two thick-sided 3D rectangles
by drawing several 3D rectangles together. You can see-assuming
that the print quality of the book is good enough-in the standard
3D rectangles that in both cases two sides of the rectangle are
slightly darker than the other two sides. Just in case you had
trouble seeing that (and I know that I did), this effect is fairly
clear on the thick-sided 3D rectangles.
<P>
<A HREF="f17-17.gif" ><B>Figure 17.17 : </B><I>The secret of 3D rectangles.</I></A>
<H3><A NAME="Animation">Animation</A></H3>
<P>
One of the keys to the success of Java is its capability to add
animation and action to Web pages without requiring you to download
huge video files. Even though Java is an interpreted language
(assuming that your users' browsers don't have a JIT-Just In Time
compiler-installed), it's more than fast enough for most animation
tasks. Listing 17.12 shows a simple animation that moves a yellow
square over a red and blue checkerboard pattern. Figure 17.18
shows a screen shot-unmoving, unfortunately.
<P>
<A HREF="f17-18.gif" ><B>Figure 17.18 : </B><I>Animation in action-well use your imagination.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.12. A simple animation applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
public class simplest_animation extends Applet implements Runnable
<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int x_pos,y_pos;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int n_squares;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int dh,dw;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Color color_1,color_2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Color square_color;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int square_size;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int square_step;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(50);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int w_height,
w_width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the starting
point of the moving square<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_pos = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_pos = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the size
of the moving square<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_size =
40;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set how much
the square moves between screen redraws<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_step =
2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//specifies the
number of squares on each side of the checkerboard<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_squares = 10;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the size
of the applet's drawing area<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w_height = size().height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w_width = size().width;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//determine the
size of the squares in the checkerboard<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh = w_height/n_squares;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw = w_width/n_squares;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the colors
for the checkerboard. <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Could have used
Color.blue and <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Color.red instead
of creating new color instances<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color_1 = new
Color(0,0,255);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color_2 = new
Color(255,0,0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the color
for the moving square<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_color =
new Color(255,255,0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void draw_check(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j,offset;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this draws a
checkerboard<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_squares;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
= i * dh;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;n_squares;j++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
= j * dw;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(((j + offset)% 2) &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(color_1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(color_2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(x,y,dw,dh);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw the blue
and red checkerboard background<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_check(g);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//increment the
position of the moving square<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the drawing
color to the square color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(square_color);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw a filled
rectangle that moves<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(x_pos,y_pos,square_size,
square_size);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
What you can't see unless you run the applet is that the whole
image is flickering; you can see the background through the yellow
square. All in all, the word that comes to mind is <I>ugly</I>-hardly
the sort of thing that will help sell a Web page. You can reduce
this flicker in several ways. A large part of the flicker occurs
when <TT><FONT FACE="Courier">repaint</FONT></TT> invokes the
<TT><FONT FACE="Courier">update</FONT></TT> method. You saw earlier
in this chapter that the <TT><FONT FACE="Courier">update</FONT></TT>
method erases the applet by drawing a background colored rectangle.
This erasing, followed by the drawing of the background rectangle,
causes a lot of the flicker. You can avoid this by overriding
the <TT><FONT FACE="Courier">update</FONT></TT> method with this
version:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
This eliminates the flicker in most of the image, but you'll still
see flicker in the region of the rectangle. That's because the
background is drawn and then the square is drawn over it. Your
eye sees the background and then the yellow square every time
the screen is redrawn. One way to reduce the amount of drawing
that has to be done is to tell the AWT to redraw only the part
of the screen that has changed.
<P>
The version of the <TT><FONT FACE="Courier">paint</FONT></TT>
method shown in Listing 17.13 does just that. It creates two rectangles:
one for where the square is and one for where it will be after
it's moved in this call to <TT><FONT FACE="Courier">paint</FONT></TT>.
The <TT><FONT FACE="Courier">union</FONT></TT> method on <TT><FONT FACE="Courier">Rectangle</FONT></TT>
then is used to get the smallest rectangle that contains both
those rectangles. That rectangle is the one that contains all
the changes between the two frames. Next, <TT><FONT FACE="Courier">clipRect</FONT></TT>
is used to tell the AWT to repaint only this rectangle.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Instead of creating two new rectangles each time <TT><FONT FACE="Courier">paint</FONT></TT> is called, you could save the second rectangle in an instance variable and then use it as the old rectangle in the next call to <TT><FONT FACE="Courier">paint</FONT></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.13. Repainting the minimal area.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics
g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle old_r,
new_r,to_repaint;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_check(getGraphics());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Figure
out where the square is now<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_r = new Rectangle(x_pos,y_pos,square_size,square_size);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Figure out where
the square will be after this method executes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_r = new Rectangle((x_pos
+ square_step),(y_pos + <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_step),square_size,
square_size);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find the smallest
rectangle that contains the old and new positions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_repaint = new_r.union(old_r);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Tell Java to
only repaint the areas that have been<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // affected by the moving
square<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.clipRect(to_repaint.x,to_repaint.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to_repaint.width,to_repaint.height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(square_color);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(x_pos,y_pos,square_size,
square_size);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Although using <TT><FONT FACE="Courier">clipRect</FONT></TT> reduces
the amount of work the AWT has to do, it's still not fast enough
to fool your eye. To do that, you need to use double buffering.
<P>
Double buffering involves doing all your drawing to an invisible,
off-screen bitmap-an image, actually-and then copying that off-screen
image to the applet. This is called <I>bitblitting</I> on the
Mac and results in much faster drawing. Listing 17.14 shows the
commented changes you need to make in the animation applet to
do double buffering.
<HR>
<BLOCKQUOTE>
<B>Listing 17.14. Using double buffering.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class simple_animation extends
Applet implements Runnable<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//Define an image to use for offscreen
drawing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image offscreen;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Graphics offscreen_graphics;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the offscreen
image and get its Graphics instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen = createImage(size().width,size().height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics
= offscreen.getGraphics();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//draw the background
checkerboard<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_check();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void draw_check() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j,offset;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_squares;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
= i * dh;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;n_squares;j++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x
= j * dw;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(((j + offset)% 2) &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics.setColor(color_1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics.setColor(color_2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics.fillRect(x,y,dw,dh);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle old_r,
new_r,to_repaint;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_r = new Rectangle(x_pos,y_pos,square_size,square_size);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_r = new Rectangle((x_pos
+ square_step),(y_pos +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_step),square_size,
square_size);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_repaint = new_r.union(old_r);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_check();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//just draw what's
needed except for the first time<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x_pos &lt;
1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.clipRect(to_repaint.x,to_repaint.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
to_repaint.width,to_repaint.height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y_pos += square_step;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//same as before
but now the square is drawn to the offscreen image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics.setColor(square_color);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offscreen_graphics.fillRect(x_pos,y_pos,square_size,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_size);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//now that the
offscreen image is all done draw the whole thing <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//to the screen
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(offscreen,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="InteractiveInterfaceElements"><FONT SIZE=5 COLOR=#FF0000>Interactive
Interface Elements</FONT></A></H2>
<P>
These items are the ones that enable the user to dynamically interact
with your program. They range from buttons to text display areas.
Although different operating systems tend to use slightly different
interaction elements, the AWT provides a rich enough set that
users on all platforms will feel pretty much at home. This is
especially true because the visual representation of each item
actually is generated by the host operating system on the machine
on which the application or applet is running. In addition, freeware,
shareware, and commercial widget kits already exist that extend
the basic elements provided by the AWT (see the section &quot;Extending
the AWT,&quot; later in this chapter, for more details).
<H3><A NAME="ComponentClassSharedFeaturesofAllA"><TT><FONT SIZE=4 FACE="Courier">Component</FONT></TT><FONT SIZE=4>
Class-Shared Features of All Active GUI Elements</FONT></A></H3>
<P>
As you saw in Figure 17.3, all the active components (other than
menus), such as <TT><FONT FACE="Courier">Button</FONT></TT>, inherit
from the <TT><FONT FACE="Courier">Component</FONT></TT> class.
The <TT><FONT FACE="Courier">Component</FONT></TT> methods provide
a wide selection of functionality applicable to any interactive
graphical element. Although you can't create an instance of <TT><FONT FACE="Courier">Component</FONT></TT>,
you'll use its methods fairly often. <TT><FONT FACE="Courier">Component</FONT></TT>
has a lot of methods, but this section lists some of the ones
you'll use fairly often. These methods are invoked in response
to various types of events. In all cases, if the method returns
<TT><FONT FACE="Courier">TRUE</FONT></TT>, it means that the method
has handled the event. If <TT><FONT FACE="Courier">FALSE</FONT></TT>
is returned, the event is passed up the event chain. You can use
these methods on multiple objects to deal with the same event.
<H5>boolean, action(Event e, Object o)</H5>
<BLOCKQUOTE>
This method usually is overridden. It's called whenever an <TT><FONT FACE="Courier">ACTION_EVENT</FONT></TT>
occurs on a component. Events are discussed in <A HREF="ch21.htm" >Chapter 21</A>,
&quot;Event Handling.&quot;
</BLOCKQUOTE>
<H5>boolean, keyDown(Event e, int key)</H5>
<BLOCKQUOTE>
This is called when a <TT><FONT FACE="Courier">KEY_PRESS</FONT></TT>
or <TT><FONT FACE="Courier">KEY_ACTION</FONT></TT> event reaches
a component. The <TT><FONT FACE="Courier">key</FONT></TT> parameter
specifies which key was involved. You can use this to have components
respond to key clicks.
</BLOCKQUOTE>
<H5>boolean, keyUp(Event e, int key)</H5>
<BLOCKQUOTE>
This method is invoked when the component receives a <TT><FONT FACE="Courier">KEY_RELEASE</FONT></TT>
event.
</BLOCKQUOTE>
<H5>boolean, lostFocus(Event e, Object
o)</H5>
<BLOCKQUOTE>
This is called when the object receives a <TT><FONT FACE="Courier">LOST_FOCUS</FONT></TT>
event.
</BLOCKQUOTE>
<H5>boolean, mouseDown(Event e, int x,
int y)</H5>
<BLOCKQUOTE>
This is invoked when the component receives a <TT><FONT FACE="Courier">MOUSE_DOWN</FONT></TT>
event, caused by the user clicking the mouse inside the component.
The x and y coordinates are in the coordinate system of the component,
where 0,0 is in the upper-left corner.
</BLOCKQUOTE>
<H5>boolean, mouseDrag(Event e, int x,
int y)</H5>
<BLOCKQUOTE>
This is invoked when the user drags the mouse with the mouse button
down over the component, generating a <TT><FONT FACE="Courier">MOUSE_DRAG</FONT></TT>
event.
</BLOCKQUOTE>
<H5>boolean, mouseEnter(Event e, int
x, int y)</H5>
<BLOCKQUOTE>
This is invoked each time the mouse goes over the component, generating
a <TT><FONT FACE="Courier">MOUSE_ENTER</FONT></TT> event.
</BLOCKQUOTE>
<H5>boolean, mouseExit(Event e, int x,
int y)</H5>
<BLOCKQUOTE>
This is called when the component receives a <TT><FONT FACE="Courier">MOUSE_EXIT</FONT></TT>
event. The <TT><FONT FACE="Courier">x</FONT></TT> and <TT><FONT FACE="Courier">y</FONT></TT>
values-which are expressed in the component's coordinates-represent
the first point outside the component's bounding rectangle that
the mouse goes over.
</BLOCKQUOTE>
<BLOCKQUOTE>
Although <TT><FONT FACE="Courier">Component</FONT></TT> has a
large selection of methods, the following are the ones you'll
use most often.
</BLOCKQUOTE>
<H5>Rectangle, bounds()</H5>
<BLOCKQUOTE>
Returns the bounding rectangle that contains the component.
</BLOCKQUOTE>
<H5>int, checkImage(Image img, ImageObserver
iobs)</H5>
<BLOCKQUOTE>
Monitors the status of an image as it's being composed. You can
use this to wait to display a component, such as a <TT><FONT FACE="Courier">Canvas</FONT></TT>,
that uses an image until the image is ready.
</BLOCKQUOTE>
<H5>Image, createImage(int width, int
height)</H5>
<BLOCKQUOTE>
Creates a new <TT><FONT FACE="Courier">Image</FONT></TT> of the
specified size.
</BLOCKQUOTE>
<H5>disable()</H5>
<BLOCKQUOTE>
Disables the component so that the user can't interact with it.
(This is a synchronized method.) The AWT draws a disabled component
differently than an enabled one.
</BLOCKQUOTE>
<H5>enable()</H5>
<BLOCKQUOTE>
Enables a disabled component. This is a synchronized method.
</BLOCKQUOTE>
<H5>Color, getBackground()</H5>
<BLOCKQUOTE>
Returns the color of the background for the component.
</BLOCKQUOTE>
<H5>Font, getFont()</H5>
<BLOCKQUOTE>
Returns the current font for the component.
</BLOCKQUOTE>
<H5>FontMetrics, getFontMetrics()</H5>
<BLOCKQUOTE>
Gets the <TT><FONT FACE="Courier">FontMetrics</FONT></TT>, which
contains information about the size of text on the current platform,
for the component.
</BLOCKQUOTE>
<H5>Color, getForeground()</H5>
<BLOCKQUOTE>
Returns the foreground color-the one that will be used to draw
lines, fill shapes, and so on.
</BLOCKQUOTE>
<H5>Graphics, getGraphics()</H5>
<BLOCKQUOTE>
Gets the <TT><FONT FACE="Courier">Graphics</FONT></TT> object
associated with the component. You can then use drawing methods,
such as <TT><FONT FACE="Courier">fillRect</FONT></TT>, that are
associated with the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object to draw on the component.
</BLOCKQUOTE>
<H5>hide()</H5>
<BLOCKQUOTE>
Makes the component invisible. This is a synchronized method.
</BLOCKQUOTE>
<H5>boolean, inside(int x, int y)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">y</FONT></TT>
lies inside the component's bounding rectangle. <TT><FONT FACE="Courier">x</FONT></TT>
and <TT><FONT FACE="Courier">y</FONT></TT> should be specified
in the coordinate system of the container that holds the component.
The container's coordinate system origin is in the upper-left
corner of the container. This is a synchronized method.
</BLOCKQUOTE>
<H5>invalidate()</H5>
<BLOCKQUOTE>
Sets a flag indicating that the component has been changed in
a way that requires the Layout Manager to be called to lay out
the screen again. A button's name might be made longer, for example,
so the button will need to be resized.
</BLOCKQUOTE>
<H5>boolean, isEnabled()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the component
is enabled to respond to user actions.
</BLOCKQUOTE>
<H5>boolean, isShowing()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the component
is visible in its parent's window. It can be visible but not showing
if its height or width is <TT><FONT FACE="Courier">0</FONT></TT>
or if its location is outside the parent's window; for example,
it might have been scrolled off-screen.
</BLOCKQUOTE>
<H5>boolean, isVisible()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the component
currently is visible. You can make a component invisible by invoking
its <TT><FONT FACE="Courier">hide</FONT></TT> method.
</BLOCKQUOTE>
<H5>Point, location()</H5>
<BLOCKQUOTE>
Returns a point that contains the coordinates of the component's
origin.
</BLOCKQUOTE>
<H5>move(int x, int y)</H5>
<BLOCKQUOTE>
Moves the component to the specified position in the parent container's
coordinate system.
</BLOCKQUOTE>
<H5>paint(Graphics g)</H5>
<BLOCKQUOTE>
Redraws the component when it needs to be redrawn. Unless you
want some custom behavior, the default method ensures that the
component is drawn properly.
</BLOCKQUOTE>
<H5>boolean, prepareImage(Image img,
ImageObserver img_obs)</H5>
<BLOCKQUOTE>
Enables you to get an image ready for display prior to displaying
it on the component. Another version enables you to specify a
size for the image so that it can be scaled.
</BLOCKQUOTE>
<H5>repaint(long time)</H5>
<BLOCKQUOTE>
Repaints this component by a specified time or cancels the request.
</BLOCKQUOTE>
<H5>repaint(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
Repaints the specified part of the component.
</BLOCKQUOTE>
<H5>repaint(long time, int x, int y,
int width, int height)</H5>
<BLOCKQUOTE>
Tries to repaint the specified region. If it can't do so before
the specified time, it quits.
</BLOCKQUOTE>
<H5>reshape(int x, int y, int width,
int height)</H5>
<BLOCKQUOTE>
Enables you to specify the position and size of the component.
This is a synchronized method.
</BLOCKQUOTE>
<H5>resize(int width, int height)</H5>
<BLOCKQUOTE>
Scales the component to fit in the defined bounding rectangle
maintaining the same origin. This is the same as the version below
except you specify the width and height separately rather than
with a <TT><FONT FACE="Courier">Dimension</FONT></TT> object.
</BLOCKQUOTE>
<H5>resize(Dimension dim)</H5>
<BLOCKQUOTE>
Scales the component to fit in the defined bounding rectangle
maintaining the same origin.
</BLOCKQUOTE>
<H5>setBackground(Color a_color)</H5>
<BLOCKQUOTE>
Sets the background color for a component. This is a synchronized
method.
</BLOCKQUOTE>
<H5>setFont(Font a_font)</H5>
<BLOCKQUOTE>
Specifies the font that will be used for any text drawn in the
component. This is a synchronized method.
</BLOCKQUOTE>
<H5>setForeground(Color a_color)</H5>
<BLOCKQUOTE>
Sets the color used for drawing lines and filling in shapes. This
is a synchronized method.
</BLOCKQUOTE>
<H5>show()</H5>
<BLOCKQUOTE>
Makes the component visible if it had been hidden.
</BLOCKQUOTE>
<H5>Dimension, size()</H5>
<BLOCKQUOTE>
Returns the height and width of the component.
</BLOCKQUOTE>
<H5>update(Graphics g)</H5>
<BLOCKQUOTE>
Erases the contents of the component's graphic area every time
it's called.
</BLOCKQUOTE>
<H5>validate()</H5>
<BLOCKQUOTE>
Causes the component to see whether it or any of the components
it contains is invalid. If any are invalid, the Layout Manager
is called to bring things up-to-date. See the section &quot;Buttons,&quot;
later in this chapter, for an example of how to use <TT><FONT FACE="Courier">invalidate</FONT></TT>/<TT><FONT FACE="Courier">validate</FONT></TT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
Remember that all the interactive interface elements, including
containers such as applets and windows, inherit from <TT><FONT FACE="Courier">Component</FONT></TT>.
</BLOCKQUOTE>
<H3><A NAME="Containers">Containers</A></H3>
<P>
The AWT containers contain classes that can contain other elements.
Windows, panels, dialog boxes, frames, and applets are all containers.
Whenever you want to display a component such as a button or pop-up
menu, you'll use a container to hold it. The base class for all
containers is-surprise! surprise!-the <TT><FONT FACE="Courier">Container</FONT></TT>
class.
<P>
The <TT><FONT FACE="Courier">Container</FONT></TT> class has a
number of methods that make it easy to add and remove components
as well as to control the relative positioning and layout of those
components. Containers can contain other containers, for example,
so a window can contain several panels.
<P>
<TT><FONT FACE="Courier">Container</FONT></TT> is an abstract
class, and the methods you'll use most often follow.
<H5>add(Component a_component)</H5>
<BLOCKQUOTE>
Adds a component to the container.
</BLOCKQUOTE>
<H5>add(Component a_component, int pos)</H5>
<BLOCKQUOTE>
Adds a component at the specified z position. This is a synchronized
method. Be warned that the order of clipping based on relative
z position may vary between machines. This problem should be fixed
eventually, though.
</BLOCKQUOTE>
<H5>int, countComponents()</H5>
<BLOCKQUOTE>
Returns the number of top-level components of a container. It
doesn't count components inside components; for example, a panel
with three buttons inside a window is counted only as one component
for the window.
</BLOCKQUOTE>
<H5>Component, getComponent(int index)</H5>
<BLOCKQUOTE>
Returns a reference to the <TT><FONT FACE="Courier">index</FONT></TT>
component. The <TT><FONT FACE="Courier">index </FONT></TT>value
is determined when the component is added. This is a synchronized
method. This throws <TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>.
</BLOCKQUOTE>
<H5>Component[], getComponents()</H5>
<BLOCKQUOTE>
Returns an array of references to all the components in the container.
This is a synchronized method.
</BLOCKQUOTE>
<H5>insets, insets()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">insets</FONT></TT> object
for the container. Insets define the empty space the Layout Manager
reserves around the edge of the container-the minimum distance
from the edge of a component to the edge of the container.
</BLOCKQUOTE>
<H5>remove(Component a_component)</H5>
<BLOCKQUOTE>
Removes the component from the container. This is a synchronized
method.
</BLOCKQUOTE>
<H5>setLayout(LayoutManager lm)</H5>
<BLOCKQUOTE>
Sets the Layout Manager the container will use. If you supply
<TT><FONT FACE="Courier">NULL</FONT></TT> as the argument, no
Layout Manager is used; you can use absolute positioning.
</BLOCKQUOTE>
<H3><A NAME="Panels">Panels</A></H3>
<P>
<TT><FONT FACE="Courier">Applet</FONT></TT> inherits from this
class, so this section examines <TT><FONT FACE="Courier">Panel</FONT></TT>
in detail so that you can understand how the various demonstration
applets work. The other container classes are discussed later
in this section.
<P>
<TT><FONT FACE="Courier">Panel</FONT></TT> inherits from <TT><FONT FACE="Courier">Container</FONT></TT>.
It doesn't create its own window because it's used to group components
inside other containers. Panels enable you to group items in a
display in a way that might not be allowed by the available Layout
Managers. If you have a number of entries in your interface, for
example, that have a label and a text field, you can define a
panel that contains a label and a text field and add the panel
so that the label and the text field always stay together on the
same line (which wouldn't be the case if you added the two items
separately). Without the panel, the Layout Manager could put the
label and the text field on different lines. Panels also are useful
in Layout Managers in which only one item is allowed in an area,
such as the <TT><FONT FACE="Courier">BorderLayout</FONT></TT>
Manager. By using a panel, you can put several components in a
single <TT><FONT FACE="Courier">BorderLayout</FONT></TT> area,
such as <TT><FONT FACE="Courier">North</FONT></TT>.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A Layout Manager autopositions and sizes the various interface components, taking into account the screen resolution and the window size.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="Insets">Insets</A></H3>
<P>
An inset object defines the amount of empty space around the edge
of a panel. The creator method for insets follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Insets, new Insets(int top, int left,
int bottom, int right)</FONT></TT>
</BLOCKQUOTE>
<P>
This defines a new <TT><FONT FACE="Courier">Insets</FONT></TT>
instance, which defines the boundaries specified by the input
arguments.
<P>
You can change the amount of empty space, which is set to <TT><FONT FACE="Courier">0</FONT></TT>
by default, by overriding the <TT><FONT FACE="Courier">Insets</FONT></TT>
method of the container. The applet in Listing 17.15 defines its
own panel class that does that. It defines a plain panel and a
custom version that overrides the <TT><FONT FACE="Courier">Insets</FONT></TT>
method. Each of the items has four buttons added. Both items have
white backgrounds so that you can see the size of the item, not
just where the buttons are.
<HR>
<BLOCKQUOTE>
<B>Listing 17.15. Defining a panel class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class HelloWorld extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panel a;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_panel b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridLayout gl;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button buttons[];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create a new
GridLayout to force the 4 buttons to arrange themselves<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in a 2 by 2
grid<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl = new GridLayout(2,2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create two panels
to contain the 8 buttons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = new Panel();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = new my_panel();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell the panels
to use the GridLayout manager rather than the default<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//FlowLayout manager
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.setLayout(gl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.setLayout(gl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make the backgrounds
of the panels white so you<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//can see them
in the picture<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.setBackground(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.setBackground(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the panels
to the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make the buttons
and add them to the panels<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buttons = new
Button[8];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;
8;i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buttons[i]
= new Button(&quot;Button &quot; + i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(i &lt;4) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.add(buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.add(buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
class my_panel extends Panel {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//This class exists so we can override
the insets method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Insets insets() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Insets(5,10,15,20);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The applet generates the applet interface shown in Figure 17.19;
look closely to see the white background for the first panel.
Because the insets for the top panel default to <TT><FONT FACE="Courier">0</FONT></TT>,
the panel background is the same size as the space required by
the buttons. The custom panel is larger than the buttons because
of the inset's value; the space on each side is different because
the four values assigned to the inset are all different.
<P>
<A HREF="f17-19.gif" ><B>Figure 17.19 : </B><I>Panels with the default insets and with custom insets.</I></A>
<H3><A NAME="Frames">Frame</A></H3>
<P>
A <I>frame</I> is a full-fledged, top-level, resizable window
with a menu bar. You can specify the title, an icon, and a cursor.
See the &quot;Frames&quot; section for examples.
<H3><A NAME="Windows">Windows</A></H3>
<P>
This class isn't used very often, but it's a top-level window
without borders and a menu bar.
<H3><A NAME="Labels">Labels</A></H3>
<P>
<I>Labels</I> are text items that don't really do much. By using
a label instead of <TT><FONT FACE="Courier">drawString</FONT></TT>,
you can use the Layout Managers to control text placement in a
platform- and monitor-independent manner. The code in Listing
17.16 shows how to use labels. About the only significant flexibility
you have, other than the alignment of the text, is the capability
to change the font used (see Figure 17.20).
<P>
<A HREF="f17-20.gif" ><B>Figure 17.20 : </B><I>Aligning text and modifying the fonts for labels.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.16. Using labels.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class label_example extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Label the_labels[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up an array
of labels<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels = new
Label[3];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create a label
with the default format<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[0]
= new Label(&quot;on the left&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//these two commands
show how to set the color of a Label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the text itself
is drawn with the Foreground color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[0].setBackground(Color.red);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[0].setForeground(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make a new Font
and then assign it to the label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font a_font =
new Font(&quot;TimesRoman&quot;,Font.PLAIN,24);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[0].setFont(a_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create a centered
label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[1]
= new Label(&quot;middle&quot;, Label.CENTER);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make a new Font
and then assign it to the label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_font = new Font(&quot;TimesRoman&quot;,Font.BOLD,24);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[1].setFont(a_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Create a label
aligned to the right<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[2]
= new Label(&quot;on the right&quot;, Label.RIGHT);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make a new Font
and then assign it to the label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_font = new Font(&quot;Helvetica&quot;,Font.ITALIC,18);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[2].setFont(a_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//these two commands
show how to set the color of a Label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the text itself
is drawn with the Foreground color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[2].setBackground(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_labels[2].setForeground(Color.blue);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the three
labels to the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;3;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_labels[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The label creators and the most useful methods for the <TT><FONT FACE="Courier">Label</FONT></TT>
class follow:
<H5>new Label(String label)</H5>
<BLOCKQUOTE>
Produces a label with the specified string.
</BLOCKQUOTE>
<H5>new Label(String label,int positioning)</H5>
<BLOCKQUOTE>
Produces a label with the string aligned according to the second
value, which should be one of the three constants <TT><FONT FACE="Courier">Label.CENTER</FONT></TT>,
<TT><FONT FACE="Courier">Label.LEFT</FONT></TT>, or <TT><FONT FACE="Courier">Label.RIGHT</FONT></TT>.
</BLOCKQUOTE>
<H5>String, getText()</H5>
<BLOCKQUOTE>
Returns the label string.
</BLOCKQUOTE>
<H5>setText(String new_label)</H5>
<BLOCKQUOTE>
Changes the label text.
</BLOCKQUOTE>
<H3><A NAME="Buttons">Buttons</A></H3>
<P>
Java buttons are just like the buttons in every other GUI. They
are text surrounded by a shape, and they generate an <TT><FONT FACE="Courier">ACTION_EVENT</FONT></TT>
event-the argument is a button's label-after the user clicks them.
Java uses the native operating system-Mac, Windows, UNIX, and
so on-to actually draw the buttons, so the look and feel of the
buttons will be what is expected by users on each platform. Listing
17.17 shows a simple example of using buttons; see <A HREF="ch21.htm" >Chapter 21</A>
for more information on handling events.
<HR>
<BLOCKQUOTE>
<B>Listing 17.17. Using buttons.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class buttons extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button a_button;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make a new button
called &quot;Howdy&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_button = new
Button(&quot;Howdy!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the button
to the Applet, which extends Panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a_button);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action (Event e, Object
o) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension&nbsp;&nbsp;d_should;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//check
the button label and toggle between the two values<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(((String)o).equals(&quot;Howdy!&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_button.setLabel(&quot;Alien
Space Monster!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_button.setLabel(&quot;Howdy!&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//mark
the button as having changed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_button.invalidate();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell
the applet to validate the layout<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This applet starts out with a single button and then toggles the
name of the button between two values every time the button is
clicked. Figure 17.21 shows the applet before the button is clicked,
and Figure 17.22 shows it afterward.
<P>
<A HREF="f17-21.gif" ><B>Figure 17.21 : </B><I>A simple button.</I></A>
<P>
<A HREF="f17-22.gif" ><B>Figure 17.22 : </B><I>A button in action </I></A>
<P>
Notice how the <TT><FONT FACE="Courier">invalidate</FONT></TT>
method, inherited from <TT><FONT FACE="Courier">Component</FONT></TT>,
is used to mark the button as having changed in a way that would
affect the layout. That isn't sufficient to force the applet to
automatically lay out the screen again, although it ensures that
the next time the screen is redrawn, things will look okay, so
you have to invoke the <TT><FONT FACE="Courier">validate</FONT></TT>
method, inherited from <TT><FONT FACE="Courier">Component</FONT></TT>,
on the applet.
<P>
The available button creator calls and the key button methods
follow.
<H5>new Button()</H5>
<BLOCKQUOTE>
Creates a button with no label (see Figure 17.23).
</BLOCKQUOTE>
<P>
<A HREF="f17-23.gif" ><B>Figure 17.23 : </B><I>A button without a label.</I></A>
<H5>new Button(String the_button_label)</H5>
<BLOCKQUOTE>
Creates a button with the specified label.
</BLOCKQUOTE>
<H5>setLabel(String the_new_label)</H5>
<BLOCKQUOTE>
Sets the button label to the specified string.
</BLOCKQUOTE>
<H5>String getLabel()</H5>
<BLOCKQUOTE>
Returns the current button label as a string.
</BLOCKQUOTE>
<H3><A NAME="Checkboxes">Checkboxes</A></H3>
<P>
<I>Checkboxes</I> are text items with a checkable icon next to
them. They're generally used when you want the user to be able
to set several options prior to making a decision. You usually
don't do anything when a checkbox is checked or unchecked, you
usually just read the values of the checkboxes when some other
control, such as a button or menu item, is activated. Just in
case you do want the code to do something when a box's state changes,
checkboxes generate an <TT><FONT FACE="Courier">ACTION_EVENT</FONT></TT>
with the new <TT><FONT FACE="Courier">Checkbox</FONT></TT> state
as the argument after the user clicks on them.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Radio buttons look just like checkboxes, but they are grouped and only one radio button in a group can be checked at any given time. The next section discusses how to implement radio buttons.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The code in Listing 17.18 produces the applet interface shown
in Figure 17.24.
<P>
<A HREF="f17-24.gif" ><B>Figure 17.24 : </B><I>Checkboxes in action.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.18. Checkboxes without a bank.<BR>
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class checkboxes extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checkbox box_1,
box_2, box_3;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_1 = new Checkbox();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_2 = new Checkbox(&quot;this
is a labeled checkbox&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_3 = new Checkbox(&quot;Labeled
and checked&quot;, null, true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_3);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The creator's methods for <TT><FONT FACE="Courier">Checkbox</FONT></TT>
and the key checkbox methods follow.
<H5>new Checkbox()</H5>
<BLOCKQUOTE>
Creates a new checkbox with no label.
</BLOCKQUOTE>
<H5>new Checkbox(String the_label)</H5>
<BLOCKQUOTE>
Creates a new checkbox with a label.
</BLOCKQUOTE>
<H5>new Checkbox(String the_label, CheckboxGroup
null, boolean checked?)</H5>
<BLOCKQUOTE>
Creates a new checkbox that is labeled and checked. The middle
argument is used with radio buttons.
</BLOCKQUOTE>
<H5>setLabel(String the_new_label)</H5>
<BLOCKQUOTE>
Changes the label of a checkbox.
</BLOCKQUOTE>
<H5>String getLabel()</H5>
<BLOCKQUOTE>
Returns the current label as a string.
</BLOCKQUOTE>
<H5>boolean getState()</H5>
<BLOCKQUOTE>
Gets the current checkbox state (checked = <TT><FONT FACE="Courier">TRUE</FONT></TT>).
</BLOCKQUOTE>
<H5>setState(boolean new_state)</H5>
<BLOCKQUOTE>
Sets the checkbox state.
</BLOCKQUOTE>
<H3><A NAME="RadioButtons">Radio Buttons</A></H3>
<P>
Checkboxes and radio buttons look different. Even though radio
buttons are made up of checkboxes, they're called radio buttons
because that's what they're called in most current GUIs. The only
functional difference is that only one of the items in a radio
button group can be selected at one time, like the buttons on
your car radio. This is useful when you want your user to select
one of a set of options. The AWT creates a radio button group
by associating a <TT><FONT FACE="Courier">CheckboxGroup</FONT></TT>
instance with all the checkboxes in the group, as shown in Listing
17.19.
<HR>
<BLOCKQUOTE>
<B>Listing 17.19. Creating a radio button group.<BR>
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class radio_buttons extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckboxGroup
group;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checkbox box_1,box_2,box_3;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckboxGroup
group_1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checkbox box_1_1,box_2_1,box_3_1;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the first
radio button group<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group = new CheckboxGroup();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_1 = new Checkbox(&quot;Yes&quot;,
group, true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_2 = new Checkbox(&quot;No&quot;,
group, false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_3 = new Checkbox(&quot;Maybe&quot;,
group, false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the second
group<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group_1 = new
CheckboxGroup();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_1_1 = new
Checkbox(&quot;Yes&quot;, group_1, false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_2_1 = new
Checkbox(&quot;No&quot;, group_1, false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box_3_1 = new
Checkbox(&quot;Maybe&quot;, group_1, false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the components
to the applet panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_3);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_1_1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_2_1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(box_3_1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Figure 17.25 shows the interface to this applet. The first thing
to note is that the second group doesn't have any button selected.
That's because none of them were created with a checked state.
As soon as the user clicks one of them, though, it won't be possible
to return all of them to the unchecked state. Clicking a selected
item, such as Yes in the first group, does not change its state
to unchecked. Selecting one of the other buttons in the first
group deselects Yes and selects the button you clicked.
<P>
<A HREF="f17-25.gif" ><B>Figure 17.25 : </B><I>Radio buttons (nearly the same as checkboxes).</I></A>
<P>
Radio buttons have only one creator method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">new Checkbox(String the_label, CheckboxGroup
a_group, boolean checked?)</FONT></TT>
</BLOCKQUOTE>
<P>
This creates a new <TT><FONT FACE="Courier">Checkbox</FONT></TT>
that is labeled and checked. The middle argument defines which
radio button group the checkbox belongs to.
<P>
In order to use radio buttons, you also need to create a new checkbox<TT><FONT FACE="Courier">
</FONT></TT>group. Use this code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">new CheckboxGroup()</FONT></TT>
</BLOCKQUOTE>
<P>
Because radio buttons are implemented as checkboxes, the methods
described in the &quot;Checkboxes&quot; section are the ones you'll
use to get and set information.
<H3><A NAME="ChoiceMenus">Choice Menus</A></H3>
<P>
<I>Choice menus</I>-often called <I>pop-up menus</I>-are designed
to allow the user to select an option from a menu and see the
value chosen at all times. Figures 17.26 and 27 show how this
works. The label of the Choice menu is the currently selected
menu item. Choice menus can be constructed as shown in Listing
17.20.
<P>
<A HREF="f17-26.gif" ><B>Figure 17.26 : </B><I>Selecting from a Choice menu.</I></A>
<P>
<A HREF="f17-27.gif" ><B>Figure 17.27 : </B><I>Showing the currently selected menu item.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.20. Creating a Choice menu.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class popup_menus extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choice a_menu;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the new
choice item<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu = new Choice();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the menu
items<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Red&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Green&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Blue&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the menu
to the applet panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a_menu);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
You can add any number of items to a Choice menu, but you can't
add hierarchical menus as you can with regular menus. The creator
method and other useful methods follow.
<H5>new Choice()</H5>
<BLOCKQUOTE>
Creates a new Choice item.
</BLOCKQUOTE>
<H5>addItem(String the_item_name)</H5>
<BLOCKQUOTE>
Adds an item to the Choice menu. It can throw a <TT><FONT FACE="Courier">NullPointerException</FONT></TT>.
This is a synchronized method.
</BLOCKQUOTE>
<H5>int countItems()</H5>
<BLOCKQUOTE>
Returns the number of items currently in the menu.
</BLOCKQUOTE>
<H5>String getItem(int menu_item_number)</H5>
<BLOCKQUOTE>
Returns the text of the specified menu item (item 0 is the first
item in the menu).
</BLOCKQUOTE>
<H5>int getSelectIndex()</H5>
<BLOCKQUOTE>
Returns the index of the currently selected item (item 0 is the
first item in the menu).
</BLOCKQUOTE>
<H5>String getSelectedItem()</H5>
<BLOCKQUOTE>
Returns the text of currently selected menu items.
</BLOCKQUOTE>
<H5>select(int menu_item)</H5>
<BLOCKQUOTE>
Changes the selection to the specified item. This is a synchronized
method, and it can throw <TT><FONT FACE="Courier">IllegallArgumentException</FONT></TT>.
</BLOCKQUOTE>
<H5>select(String menu_item_name)</H5>
<BLOCKQUOTE>
Selects the menu item for which the name is the specified string.
</BLOCKQUOTE>
<H3><A NAME="ScrollingLists">Scrolling Lists</A></H3>
<P>
<I>Scrolling lists</I> display multiple lines of text, and each
line corresponds to a selection item. Scroll bars are displayed
if the text is larger than the available space. The user can select
one or more of the lines. Your program can read the user's selections.
Lists generate three event types:
<UL>
<LI><TT><B><FONT FACE="Courier">ACTION_EVENT</FONT></B></TT><B>:
</B>When a list item is double-clicked. The argument is the name
of the list item.
<LI><TT><B><FONT FACE="Courier">LIST_SELECT</FONT></B></TT><B>:</B>
When a list item is selected. The argument is the name of the
list item selected.
<LI><TT><B><FONT FACE="Courier">LIST_DESELECT</FONT></B></TT><B>:</B>
When a list item is deselected. The argument is the name of the
item deselected.
</UL>
<P>
The applet shown in Listing 17.21 shows how to create single-
and multiple-choice scrolling lists. Figure 17.28 shows the resulting
interface elements. Note that the scrollbar for the left list
is disabled because all the items in the list are visible.
<P>
<A HREF="f17-28.gif" ><B>Figure 17.28 : </B><I>Single- and Multiple-choice lists.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.21. Creating single- and multiple-choice scrolling
lists.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class list extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List mult_choice,
single_choice;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define a scrolling
list that shows 6 elements at a time and that<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//allows the selection
of multiple items at the same time<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice =
new List(6,true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice
= new List();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define the list
entries<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Red&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Green&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Blue&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Yellow&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Black&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult_choice.addItem(&quot;Azure&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Chicago&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Detroit&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Los
Angeles&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Atlanta&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Washington&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;Lincoln&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_choice.addItem(&quot;LaGrange&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the lists
to the applet panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(mult_choice);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(single_choice);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The key methods you'll most commonly use with lists follow.
<H5>addItem(String item_label)</H5>
<BLOCKQUOTE>
Adds the specified item to the end of the current list of items
in the list. This is a synchronized method.
</BLOCKQUOTE>
<H5>addItem(String item_label, int location)</H5>
<BLOCKQUOTE>
Adds the specified item to the list at the specified location.
This is a synchronized method. Remember that the first item in
the list is numbered 0. For example, <TT><FONT FACE="Courier">addItem(&quot;a
test&quot;, 3)</FONT></TT> puts <TT><FONT FACE="Courier">&quot;a
test&quot;</FONT></TT> into the fourth position in the list and
slides the previous fourth entry and all entries after it down
one.
</BLOCKQUOTE>
<H5>int clear()</H5>
<BLOCKQUOTE>
Removes all the entries in the list. This is a synchronized method.
</BLOCKQUOTE>
<H5>int countItems()</H5>
<BLOCKQUOTE>
Returns the number of items currently in the list.
</BLOCKQUOTE>
<H5>delItem(int location)</H5>
<BLOCKQUOTE>
Deletes the list item at the specified location. This is a synchronized
method.
</BLOCKQUOTE>
<H5>delItems(int first, int last)</H5>
<BLOCKQUOTE>
Deletes all the items between the <TT><FONT FACE="Courier">first</FONT></TT>
and <TT><FONT FACE="Courier">last</FONT></TT> location, inclusive.
This is a synchronized method. For example, <TT><FONT FACE="Courier">delItems(1,3)</FONT></TT>-note
the <TT><FONT FACE="Courier">s</FONT></TT> at the end of <TT><FONT FACE="Courier">Item</FONT></TT>-deletes
the second, third, and fourth entries in the list; remember that
the first location is 0.
</BLOCKQUOTE>
<H5>deselect(int location)</H5>
<BLOCKQUOTE>
Deselects the item at the specified location. This is a synchronized
method.
</BLOCKQUOTE>
<H5>String getItem(int location)</H5>
<BLOCKQUOTE>
Returns the label of the list item at the specified location.
</BLOCKQUOTE>
<H5>int getRows()</H5>
<BLOCKQUOTE>
Returns the number of rows currently visible to the user.
</BLOCKQUOTE>
<H5>int getSelectedIndex()</H5>
<BLOCKQUOTE>
Throws an <TT><FONT FACE="Courier">ArrayIndexOutofBoundsException</FONT></TT>
if it's invoked on a list where more than one item is selected.
The method returns <TT><FONT FACE="Courier">-1</FONT></TT> if
no items are selected. This is a synchronized method.
</BLOCKQUOTE>
<H5>int[] getSelectedIndexes()</H5>
<BLOCKQUOTE>
Returns an array of the locations of the selected items. This
is a synchronized method. It works with a single selection and
with single-selection lists. It returns <TT><FONT FACE="Courier">-1</FONT></TT>
if no items are selected.
</BLOCKQUOTE>
<H5>String getSelectedItem()</H5>
<BLOCKQUOTE>
Returns the location of the currently selected item. This is a
synchronized method. A runtime <TT><FONT FACE="Courier">Exception</FONT></TT>
is thrown if this method is called on a multiple-selection list.
For that reason, and the fact that <TT><FONT FACE="Courier">getSelectedItems</FONT></TT>
will work with a single item, it's best to avoid this method.
If no item is selected, it returns <TT><FONT FACE="Courier">NULL</FONT></TT>.
</BLOCKQUOTE>
<H5>String[] getSelectedItems()</H5>
<BLOCKQUOTE>
Returns an array of <TT><FONT FACE="Courier">String</FONT></TT>s
containing the names of the currently selected list items. This
is a synchronized method. It returns an empty array if no items
are selected. In that case, trying to access the 0th array item,
as in
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String [] picked = list.getSelectedItems()
<BR>
String x = picked[0];<BR>
raises an ArrayIndexOutofBoundsException.</FONT></TT>
</BLOCKQUOTE>
<H5>makeVisible(int location)</H5>
<BLOCKQUOTE>
Forces the item at the specified location to be visible. This
is a synchronized method. It comes in handy because not all choices
are visible to the user if the number of visible rows is less
than the number of list items. The specified location is moved
to the top of the visible area.
</BLOCKQUOTE>
<H5>replaceItem(String new_label, int
location)</H5>
<BLOCKQUOTE>
Changes the name of the label specified by the value of <TT><FONT FACE="Courier">location</FONT></TT>.
This is a synchronized method.
</BLOCKQUOTE>
<H5>select(int location)</H5>
<BLOCKQUOTE>
Selects the specified item. This is a synchronized method.
</BLOCKQUOTE>
<BLOCKQUOTE>
Because the <TT><FONT FACE="Courier">List</FONT></TT> class has
such an extensive set of methods for manipulating the list's contents,
it's a good choice for displaying information that is going to
change often. It would be a good choice for showing recently visited
pages-with event support to rapidly return to those pages-or the
list of shopping items the user wants to purchase.
</BLOCKQUOTE>
<H3><A NAME="TheTextComponentClassInvisiblebutUs">The <TT><FONT SIZE=4 FACE="Courier">TextComponent</FONT></TT><FONT SIZE=4>
Class-Invisible but Useful</FONT></A></H3>
<P>
This class is abstract, but it's extended by both <TT><FONT FACE="Courier">TextField</FONT></TT>s
and <TT><FONT FACE="Courier">TextArea</FONT></TT>s. All the methods
covered here are available in both those GUI elements. <TT><FONT FACE="Courier">TextComponent</FONT></TT>
provides the basic tools for finding out what text is in a <TT><FONT FACE="Courier">Text</FONT></TT>
item (<TT><FONT FACE="Courier">getText</FONT></TT>), setting the
text in an item (<TT><FONT FACE="Courier">setText</FONT></TT>),
and selecting pieces of text (<TT><FONT FACE="Courier">setSelect</FONT></TT>).
When using <TT><FONT FACE="Courier">TextField</FONT></TT>s or
<TT><FONT FACE="Courier">TextArea</FONT></TT>s, you won't have
to worry about managing the cursor location, the insertion point
(the vertical cursor that tells the user where newly typed text
will be inserted), or the marking of the selected text. All these
functions are done for you by the AWT. The most useful <TT><FONT FACE="Courier">TextComponent</FONT></TT>
methods follow.
<H5>String getSelectedText()</H5>
<BLOCKQUOTE>
Returns the text currently selected in the text item. The text
may have been selected by the user or through the <TT><FONT FACE="Courier">setSelection</FONT></TT>
method.
</BLOCKQUOTE>
<H5>int getSelectionEnd()</H5>
<BLOCKQUOTE>
Returns the index of the last character in the selection +1. Suppose
that you pick a single character such as index <TT><FONT FACE="Courier">3</FONT></TT>;
this method returns <TT><FONT FACE="Courier">4</FONT></TT>. If
no characters are selected, this method returns the location of
the insertion point. In that case, this method and <TT><FONT FACE="Courier">getSelectionStart</FONT></TT>
return the same value.
</BLOCKQUOTE>
<H5>int getSelectionStart()</H5>
<BLOCKQUOTE>
Returns the index of the first character in the current selection
or the location of the insertion point if nothing is selected.
</BLOCKQUOTE>
<H5>String getText()</H5>
<BLOCKQUOTE>
Returns all the text in the text item.
</BLOCKQUOTE>
<H5>select(int start, int stop)</H5>
<BLOCKQUOTE>
Selects the text specified by input arguments. As with <TT><FONT FACE="Courier">getSelectionEnd</FONT></TT>,
the end value should be the index of the last character you want
to select +1. If <TT><FONT FACE="Courier">start</FONT></TT> and
<TT><FONT FACE="Courier">stop</FONT></TT> are the same value,
the insertion point is placed immediately before the character
with that index.
</BLOCKQUOTE>
<H5>selectAll</H5>
<BLOCKQUOTE>
Selects all the text in the text item.
</BLOCKQUOTE>
<H5>setEditable(boolean state)</H5>
<BLOCKQUOTE>
Enables you to toggle between whether or not a text item is editable
by the user.
</BLOCKQUOTE>
<H5>setText(String new_text)</H5>
<BLOCKQUOTE>
Enables you to set the text in the text item. This replaces all
the text in the item. If you want to insert or append text, you
need to use <TT><FONT FACE="Courier">getText</FONT></TT>, modify
the string, and then use <TT><FONT FACE="Courier">setText</FONT></TT>
to put the modified string back in the text item. Note that <TT><FONT FACE="Courier">TextArea</FONT></TT>
has <TT><FONT FACE="Courier">insert</FONT></TT> and <TT><FONT FACE="Courier">append</FONT></TT>
methods.
</BLOCKQUOTE>
<BLOCKQUOTE>
The applet in Listing 17.22 shows you how the various methods
work. You'll see more about the unique characteristics of <TT><FONT FACE="Courier">TextField</FONT></TT>s
and <TT><FONT FACE="Courier">TextArea</FONT></TT>s in the next
two sections. Figure 17.29 shows the applet's interface. You can
use this little applet to help you understand how the various
input parameters work. By selecting text and then clicking the
Selection Report button, for example, you can see what input parameters
you need to use in the <TT><FONT FACE="Courier">select</FONT></TT>
method to get that same selection.
</BLOCKQUOTE>
<P>
<A HREF="f17-29.gif" ><B>Figure 17.29 : </B><I>Exploring the parameters of </I><B>TextComponent</B> <I>methods.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.22. </B><TT><B><FONT FACE="Courier">TextField</FONT></B></TT><B>s
and </B><TT><B><FONT FACE="Courier">TextArea</FONT></B></TT><B>s
in action.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class text_stuff extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea text_space;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea selection;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button show_selection, make_selection;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextField start, stop;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String sample_text;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This string
could have included \n to force returns<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sample_text =
&quot;This is a very long piece of text which is&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; designed
to show how &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;a text area
can hold a lot of text without you having to do a lot of&quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;work.&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;In general
text areas are good for holding large chunks of text or for&quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;getting
&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;long answers
back from the user.&nbsp;&nbsp;TextAreas have lots of methods
for &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;manipulating
the their contents and for controlling how the text is &quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scrolled&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define the TextArea
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space = new
TextArea(sample_text,8,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define the report
TextArea<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection = new
TextArea(&quot;&quot;,10,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the button
to show the selection values<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_selection
= new Button(&quot;Selection Report&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the text
field to input the start of the selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = new TextField(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the text
field to input the end of the selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stop = new TextField(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make the labels
for the two input fields<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Label l_start
= new Label(&quot;Start of selection&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Label l_stop =
new Label(&quot;End of selection&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define the button
to make the selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make_selection
= new Button(&quot;Make selection&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add everything
to the applet's panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(text_space);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(show_selection);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(selection);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(l_start);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(start);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(l_stop);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(stop);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(make_selection);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//handle mouse clicks on the two buttons
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action (Event e, Object
o) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int start_location,stop_location;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String report,
temp;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//check
the button label to decide which button was clicked<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(((String)o).equals(&quot;Make selection&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//read
the text from the text field to <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
the start of the selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= start.getText();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//convert
the text to an integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_location
= Integer.parseInt(temp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
the text from the text field to <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define
the end of the selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= stop.getText();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//convert
the text to an integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stop_location
= Integer.parseInt(temp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set
the selection to the interval defined by <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the
values in the text fields<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space.select(start_location,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
stop_location);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= &quot;Selection Start = &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
the start of the current selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= report + text_space.getSelectionStart() + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
the end of the current selection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= report + &quot;Selection End = &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= report + text_space.getSelectionEnd() + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
the selected text<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= report + &quot;Selected Text is: &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;report
= report + text_space.getSelectedText() + &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//put
the report in the text area<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selection.setText(report);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TextField"><TT><FONT SIZE=4 FACE="Courier">TextField</FONT></TT></A>
</H3>
<P>
Text fields are designed to be used to allow the user to input
short pieces of text-usually no more than a few words or a single
number. You also can use them to display information to the user,
such as a phone number or the current sum of the costs of the
items the user is going to order. Because <TT><FONT FACE="Courier">TextField</FONT></TT>
extends <TT><FONT FACE="Courier">TextComponent</FONT></TT>, you
can define whether the user can edit the contents of a <TT><FONT FACE="Courier">TextField</FONT></TT>.
The example in Listing 17.23 shows the various types of text fields
you can create. Figures 17.30 and 17.31 show how changing the
size of the window causes the text fields' sizes to change.
<P>
<A HREF="f17-30.gif" ><B>Figure 17.30 : </B><I>Text fields with limited space.</I></A>
<P>
<A HREF="f17-31.gif" ><B>Figure 17.31 : </B><I>With</I> <B>FlowLayout</B>,<I> the size of </I><B>TextField</B><I>s change as the window size changes.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.23. Creating </B><TT><B><FONT FACE="Courier">TextField</FONT></B></TT><B>s.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class text_field extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextField t[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Label&nbsp;&nbsp;l[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int n_fields;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;GridLayout gl;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This defines
a new layout manager with 4 rows and 2 columns<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//You'll learn
about layout managers in a few pages<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl = new GridLayout(4,2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell the applet
to use this new layout manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//rather than
the default one<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(gl);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_fields = 4;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new TextField[n_fields];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l = new Label[n_fields];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the labels
and text fields<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t[0] = new TextField();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l[0] = new Label(&quot;TextField
no input params&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t[1] = new TextField(35);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l[1] = new Label(&quot;35
character wide TextField&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t[2] = new TextField(&quot;Merry
Christmas!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l[2] = new Label(&quot;TextField
with initial text&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t[3] = new TextField(&quot;Enter
your Swiss bank account #&quot;,20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l[3] = new Label(&quot;TextField
with initial text and fixed width&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add all the
components to the applet panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_fields;i++){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(l[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(t[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TextArea"><TT><FONT SIZE=4 FACE="Courier">TextArea</FONT></TT></A>
</H3>
<P>
Text areas are designed to hold large chunks of text, where large
is more than one line. <TT><FONT FACE="Courier">TextArea</FONT></TT>
extends <TT><FONT FACE="Courier">TextComponent</FONT></TT> by
adding a number of additional methods as well as automatic scrolling
of the text. Listing 17.24 shows examples of the different <TT><FONT FACE="Courier">TextArea</FONT></TT>
creator methods displayed in Figure 17.32.
<P>
<A HREF="f17-32.gif" ><B>Figure 17.32 : </B><I>Different ways to create text areas.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.24. </B><TT><B><FONT FACE="Courier">TextArea</FONT></B></TT><B>
creator methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class text_areas extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea text_space[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Label labels[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int n_fields;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String sample_text;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_fields = 4;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels = new Label[n_fields];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space = new
TextArea[n_fields];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This string
could have included \n to force returns<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sample_text =
&quot;This is a very long piece of text which is&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; designed
to show how &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;a text area
can hold a lot of text without you having to do a lot of&quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;work.&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;In general
text areas are good for holding large chunks of text or for&quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;getting
&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;long answers
back from the user.&nbsp;&nbsp;TextAreas have lots of methods
for &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;manipulating
the their contents and for controlling how the text is &quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;scrolled&quot;;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define the TextAreas
and their labels.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[0] = new
Label(&quot;default text area&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space[0]
= new TextArea();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[1] = new
Label(&quot;5 by 30 text area&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space[1]
= new TextArea(5,30);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[2] = new
Label(&quot;Filled with a sample string&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space[2]
= new TextArea(sample_text);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels[3] = new
Label(&quot;8 by 50 text area with a sample string&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space[3]
= new TextArea(sample_text,8,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add everything
to the applet's panel<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;i&lt;n_fields;i++){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(labels[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(text_space[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT><FONT FACE="Courier">TextArea</FONT></TT> extends <TT><FONT FACE="Courier">TextComponent</FONT></TT>
in several ways, but one of the most useful ones is its support
of more powerful text-manipulation methods, such as <TT><FONT FACE="Courier">insert</FONT></TT>
and <TT><FONT FACE="Courier">append</FONT></TT>. The most useful
<TT><FONT FACE="Courier">TextArea</FONT></TT> methods follow.
<H5>new TextArea()</H5>
<BLOCKQUOTE>
Defines a default empty <TT><FONT FACE="Courier">TextArea</FONT></TT>.
</BLOCKQUOTE>
<H5>new TextArea(int rows, int columns)</H5>
<BLOCKQUOTE>
Defines an empty <TT><FONT FACE="Courier">TextArea</FONT></TT>
with the specified number of rows and columns.
</BLOCKQUOTE>
<H5>new TextArea(String the_contents)</H5>
<BLOCKQUOTE>
Defines a <TT><FONT FACE="Courier">TextArea</FONT></TT> that contains
the specified string.
</BLOCKQUOTE>
<H5>new TextArea(String the_contents,
int rows, int columns)</H5>
<BLOCKQUOTE>
Defines a <TT><FONT FACE="Courier">TextArea</FONT></TT> containing
the specified string and with a set number of rows and columns.
</BLOCKQUOTE>
<H5>appendText(String new_text)</H5>
<BLOCKQUOTE>
Appends the specified string to the current contents of the <TT><FONT FACE="Courier">TextArea</FONT></TT>.
</BLOCKQUOTE>
<H5>int, getColumns()</H5>
<BLOCKQUOTE>
Returns the current width of the <TT><FONT FACE="Courier">TextArea</FONT></TT>
in columns.
</BLOCKQUOTE>
<H5>int, getRows()</H5>
<BLOCKQUOTE>
Returns the current number of rows in a <TT><FONT FACE="Courier">TextArea</FONT></TT>.
</BLOCKQUOTE>
<H5>insertText(String the_text, int where_to_add)</H5>
<BLOCKQUOTE>
Inserts the specified string at the specified location.
</BLOCKQUOTE>
<H5>replaceText(String new_text, int
start, int stop)</H5>
<BLOCKQUOTE>
Takes the text between <TT><FONT FACE="Courier">start</FONT></TT>
and <TT><FONT FACE="Courier">stop</FONT></TT>, inclusive, and
replaces it with the specified string.
</BLOCKQUOTE>
<H3><A NAME="Canvases">Canvases</A></H3>
<P>
A <I>canvas</I> is an empty space-a starting point for complex
interface elements such as a picture button. A canvas is a place
to draw. You use it instead of just drawing to a panel, as in
an applet, so you can take advantage of the Layout Manager's capability
to keep your interface machine- independent. The applet in Listing
17.25 draws to the screen and to a canvas, as shown in Figure
17.33.
<P>
<A HREF="f17-33.gif" ><B>Figure 17.33 : </B><I>Drawing on a canvas without being an artist.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.25. Drawing to the screen and to a canvas.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class canvas_example extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;drawing_area drawing;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Graphics drawing_graphics;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Don't need to
do this but we don't want the Canvas <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//being resized
by the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Layout Manager.
Layout Managers are discussed later in this chapter.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(null);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawing = new
drawing_area();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(drawing);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This is just
here to show that you can combine direct drawing to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the applet panel
with Canvases<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;Hello,
World!&quot;, 25, 125 );<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
//Can't have more than one public class in a source file but 
<BR>
//you can have several<BR>
//non-public ones<BR>
class drawing_area extends Canvas {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Font my_font;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;drawing_area() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up a font
for this Canvas to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_font = new
Font(&quot;TimesRoman&quot;, Font.BOLD,16);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the size
of the Canvas<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(100,100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//By overriding
the paint method you can control what is<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//drawn in a canvas.
If you want to avoid flicker you might<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//also want to
override the update method as discussed in the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//animation section.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Fill a rectangle
with the default color, black<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0,0,100,100);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the foreground
color to white so we can read the text<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.white);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(my_font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;this
is a test&quot;, 10,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Be careful and
reset the color or the next time paint is called the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//rectangle will
be filled with white and the text will be invisible<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.black);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="OrganizingYourInterfacewithLayouts"><FONT SIZE=5 COLOR=#FF0000>Organizing
Your Interface with Layouts</FONT></A></H2>
<P>
The traditional method for building a GUI has been to position
various interface elements, such as buttons, at specific locations
inside a window and then to allow the user to move the windows
around. Java has had to explore new approaches to defining the
layout of components because of the diversity of standards that
it has to support. Although the AWT does let you specify the absolute
location of components, it also gives you Layout Managers that
let you define the relative placement of components that will
look the same on a wide spectrum of display devices.
<P>
Although you can build your own Layout Manager, it's easiest to
use one of the Managers that come with the AWT. In addition, freeware
Layout Managers currently are available; these are discussed along
with how to build your own Layout Manager, and more will be arriving
in the future.
<H3><A NAME="NoLayoutManager">No Layout Manager</A></H3>
<P>
Although most containers come with a preset <TT><FONT FACE="Courier">FlowLayout</FONT></TT>
Manager, you can tell the AWT to use absolute positions with the
following line of code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">setLayout(null);</FONT></TT>
</BLOCKQUOTE>
<P>
This eliminates the default Layout Manager, or any other one that
the container had been using, enabling you to position components
by using absolute coordinates. Keep in mind, though, that absolute
coordinates won't look the same on all platforms. Listing 17.26
shows a little applet that uses absolute coordinates and the <TT><FONT FACE="Courier">resize</FONT></TT>
and <TT><FONT FACE="Courier">reshape</FONT></TT> methods from
the <TT><FONT FACE="Courier">Component</FONT></TT> 
<P>
class to position and size a label and a text field. Figure 17.34
shows the resulting applet. If you don't use <TT><FONT FACE="Courier">resize</FONT></TT>
or <TT><FONT FACE="Courier">reshape</FONT></TT>, you won't see
the components. This approach to layouts can run into problems
when the size of a font varies between platforms. You can use
the <TT><FONT FACE="Courier">FontMetrics</FONT></TT> class to
figure out the size of a font relative to some standard size and
then scale your absolute coordinates, but it's probably easier
to just implement a custom Layout Manager.
<P>
<A HREF="f17-34.gif" ><B>Figure 17.34 : </B><I>A simple applet with absolute positioning.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.26. Positioning and sizing a label and text field.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class no_layout extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Label a_label;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextField a_textfield;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(null);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_label = new
Label(&quot;A label&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a_label);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//change the size
of the Label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_label.resize(40,50);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_textfield =
new TextField(20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a_textfield);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the size
and position of the TextField<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_textfield.reshape(20,40,140,10);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="FlowLayout"><TT><FONT SIZE=4 FACE="Courier">FlowLayout</FONT></TT></A>
</H3>
<P>
This is the default Layout Manager that every panel uses unless
you use the <TT><FONT FACE="Courier">setLayout</FONT></TT> method
to change it. It keeps adding components to the right of the preceding
one until it runs out of space; then it starts with the next row.
The code in Listing 17.27 shows how to place 30 buttons in an
applet using <TT><FONT FACE="Courier">FlowLayout</FONT></TT>.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The creation of a new layout and the use of the <TT><FONT FACE="Courier">setLayout</FONT></TT> method are superfluous in this case because the panel comes with a <TT><FONT FACE="Courier">FlowLayout</FONT></TT> as a default. They're included here to show you how you create and define the Layout Manager for a panel.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.27. Placing 30 buttons in an applet using </B><TT><B><FONT FACE="Courier">FlowLayout</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class flowlayout extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button the_buttons[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n_buttons;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowLayout fl;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make a new FlowLayout
manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fl = new FlowLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell the applet
to use the FlowLayout Manager<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(fl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_buttons = 30;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons =
new Button[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make all the
buttons and add them to the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_buttons;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= &quot;Button &quot; + i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[i]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This sample applet generates the interfaces shown in Figures 17.35
and 17.36. You might be wondering how this is possible. The answer
is that the <TT><FONT FACE="Courier">FlowLayout</FONT></TT> Manager
follows its rule; it places elements in a row until there isn't
room for more and then goes to the next, regardless of the size
of the container.
<P>
<A HREF="f17-35.gif" ><B>Figure 17.35 : FlowLayout </B><I>of 30 buttons with one window size.</I></A>
<P>
<A HREF="f17-36.gif" ><B>Figure 17.36 : </B><I>Same applets, same Layout Manager, same buttons, different window size.</I></A>
<H3><A NAME="GridLayout"><TT><FONT SIZE=4 FACE="Courier">GridLayout</FONT></TT></A>
</H3>
<P>
<TT><FONT FACE="Courier">GridLayout</FONT></TT>'s simple rule
is to allow the user to define the number of rows and columns
in the layout. <TT><FONT FACE="Courier">GridLayout</FONT></TT>
then sticks one item in each grid cell. The cells are all the
same size. The size of the cells is determined by the number of
cells and the size of the container. Figures 17.37 and 17.38 show
how <TT><FONT FACE="Courier">GridLayout</FONT></TT> positions
the items for two window sizes in the applet shown in Listing
17.28.
<P>
<A HREF="f17-37.gif" ><B>Figure 17.37 : GridLayout </B><I>with a small window.</I></A>
<P>
<A HREF="f17-38.gif" ><B>Figure 17.38 : </B><I>The same applet with a larger window.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.28. Using the </B><TT><B><FONT FACE="Courier">GridLayout</FONT></B></TT><B>
Manager.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class gridlayout extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button the_buttons[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n_buttons;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridLayout gl;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up a grid
that is 3 rows and 10 columns. There is a 10 pixel space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//between rows
and 15 pixels between columns<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl = new GridLayout(3,10,10,15);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(gl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_buttons = 30;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons =
new Button[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_buttons;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= &quot;Button &quot; + i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[i]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
As you see in this listing, the <TT><FONT FACE="Courier">GridLayout</FONT></TT>
creator method enables you to define gaps between components.
<P>
There are two <TT><FONT FACE="Courier">GridLayout</FONT></TT>
creator methods:
<H5>new GridLayout(int rows, int cols)</H5>
<BLOCKQUOTE>
Makes a <TT><FONT FACE="Courier">GridLayout</FONT></TT> with the
specified number of rows and columns.
</BLOCKQUOTE>
<H5>new GridLayout(int rows, int cols,
int horizontal_gap, int vertical_gap)</H5>
<BLOCKQUOTE>
Makes a <TT><FONT FACE="Courier">GridLayout</FONT></TT> with the
specified rows and columns and with the specified empty space
around each component.
</BLOCKQUOTE>
<H3><A NAME="GridBagLayout"><TT><FONT SIZE=4 FACE="Courier">GridBagLayout</FONT></TT></A>
</H3>
<P>
This is the most powerful, complex, and hard-to-use Layout Manager
that comes with the AWT. Although it gives you the most flexibility,
you should plan to spend some time experimenting with its parameters
before you get a layout that you like. The basic principle of
<TT><FONT FACE="Courier">GridBagLayout</FONT></TT> is that you
associate a constraint object, an instance of <TT><FONT FACE="Courier">GridBagConstraints</FONT></TT>,
with each component in the layout. The <TT><FONT FACE="Courier">GridBagLayout</FONT></TT>
Manager uses those constraints to determine how to lay out the
components on an invisible grid, where each component can occupy
one or more grid cells. The creator methods for <TT><FONT FACE="Courier">GridBagConstraints</FONT></TT>
take no input parameters; you customize the instance by changing
the following instance variables.
<H5>anchor</H5>
<BLOCKQUOTE>
Specifies how a component is to be aligned if a component is smaller
than the allocated space. The available constants follow:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">CENTER</FONT></TT>: Puts the component
in the middle of the area.<BR>
<TT><FONT FACE="Courier">EAST</FONT></TT>: Aligns it with the
right-middle side.<BR>
<TT><FONT FACE="Courier">NORTH</FONT></TT>: Aligns it with the
top-middle.<BR>
<TT><FONT FACE="Courier">NORTHEAST</FONT></TT>: Puts it in the
upper-right corner.<BR>
<TT><FONT FACE="Courier">NORTHWEST</FONT></TT>: Puts it in the
upper-left corner.<BR>
<TT><FONT FACE="Courier">SOUTH</FONT></TT>: Aligns it with the
bottom-middle.<BR>
<TT><FONT FACE="Courier">SOUTHEAST</FONT></TT>: Puts it in the
lower-right corner.<BR>
<TT><FONT FACE="Courier">SOUTHWEST</FONT></TT>: Puts it in the
lower-left corner.<BR>
<TT><FONT FACE="Courier">WEST</FONT></TT>: Aligns it with the
left-middle side.
</BLOCKQUOTE>
<H5>fill</H5>
<BLOCKQUOTE>
Determines what happens if the space allotted to a component is
larger than its default size. The allowable values follow:
<P>
<B>BOTH</B>: Tells
the component to fill the space in both directions.<BR>
<B>HORIZONTAL</B>:
Tells the component to fill the space in the horizontal direction.
<BR>
<B>NONE</B>: Leaves the component at its default size.<BR>
<B>VERTICAL</B>:
Tells the component to fill the space in the vertical direction.
</BLOCKQUOTE>
<BR><H5>gridheight</H5>
<BLOCKQUOTE>
Specifies the height of the component in grid cells. The constant
<TT><FONT FACE="Courier">REMAINDER</FONT></TT> specifies that
the component is the last one in the column and therefore should
get all the remaining cells.
</BLOCKQUOTE>
<H5>gridwidth</H5>
<BLOCKQUOTE>
Specifies the width of the component in grid cells. The constant
<TT><FONT FACE="Courier">REMAINDER</FONT></TT> specifies that
the component is the last one in the row and therefore should
get all the cells remaining in the row.
</BLOCKQUOTE>
<H5>gridx</H5>
<BLOCKQUOTE>
Specifies the grid position of the left side of a component in
the horizontal direction. The constant <TT><FONT FACE="Courier">RELATIVE</FONT></TT>
specifies the position to the right of the previous component.
</BLOCKQUOTE>
<H5>gridy</H5>
<BLOCKQUOTE>
Specifies the grid position of the top of a component in the vertical
direction. The constant <TT><FONT FACE="Courier">RELATIVE</FONT></TT>
specifies the position below the previous component.
</BLOCKQUOTE>
<H5>insets</H5>
<BLOCKQUOTE>
Enables you to set an instance of the <TT><FONT FACE="Courier">Insets</FONT></TT>
class that specifies the whitespace reserved around an object.
It provides more flexibility than <TT><FONT FACE="Courier">ipadx</FONT></TT>
and <TT><FONT FACE="Courier">ipady</FONT></TT> because it allows
different whitespace on the left than on the right and different
whitespace on the top than on the bottom of the component.
</BLOCKQUOTE>
<H5>ipadx</H5>
<BLOCKQUOTE>
Specifies the amount of padding (empty space) to put on either
side of a component. This increases the effective size of the
component.
</BLOCKQUOTE>
<H5>ipady</H5>
<BLOCKQUOTE>
Specifies the amount of padding to put above and below the component.
</BLOCKQUOTE>
<H5>weightx</H5>
<BLOCKQUOTE>
Specifies how extra horizontal space (space not needed for the
default component sizes) is allocated between components. This
is a relative value, normally chosen to be between <TT><FONT FACE="Courier">0</FONT></TT>
and <TT><FONT FACE="Courier">1</FONT></TT>, and the values of
the components are compared when allocating space. If one component
has a weight of <TT><FONT FACE="Courier">.7</FONT></TT> and another
has a weight of <TT><FONT FACE="Courier">.2</FONT></TT>, for example,
the one with weight <TT><FONT FACE="Courier">.7</FONT></TT> gets
more of the extra space than the one with <TT><FONT FACE="Courier">.2</FONT></TT>.
</BLOCKQUOTE>
<H5>weighty</H5>
<BLOCKQUOTE>
Same as <TT><FONT FACE="Courier">weightx</FONT></TT> but for the
vertical direction.
</BLOCKQUOTE>
<BLOCKQUOTE>
As you play around with this Layout Manager, you'll discover that
it's very powerful but not entirely intuitive. Listing 17.29 shows
an example that gives you a feeling for what <TT><FONT FACE="Courier">GridBagLayout</FONT></TT>
can do.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 17.29. Using </B><TT><B><FONT FACE="Courier">GridBagLayout</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class gridbaglayout extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button the_buttons[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n_buttons;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout
gbl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints
gbc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define a new
GridBagLayout<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl = new GridBagLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//define a new
GridBagConstraints. this will be used <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//for all the
components<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc = new GridBagConstraints();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if a component
gets more space than it needs don't grow <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the component
to fit the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//available space
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.fill = GridBagConstraints.NONE;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if a component
doesn't fill the space assigned to it <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//put it in the
top middle of the area<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.anchor = GridBagConstraints.NORTH;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pad the size
of the component<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.ipadx = 5;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.ipady = 5;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if there is
more width available than needed for <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the components
give this<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//component a
weight of .3 when allocating the extra horizontal space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weightx =
.3;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weighty =
.1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(gbl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_buttons = 15;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons =
new Button[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;9;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//start
a new row after every 3 buttons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(j == 3) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make
this component the last one in the row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth
= GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= &quot;Button &quot; + i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[i]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell
GridBagLayout which constraint object to use. you can use<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the
same constraint object for many components even if you<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//change
the instance variables values in the constraints object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//for
different components<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[i],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this
sets the gridwidth to its default value. it cleans up the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//REMAINDER
value assigned to the last button in a row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//change the weight
for allocating extra space to subsequent<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weightx =
.4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weighty =
.2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = &quot;Button
9&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[9]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if there's extra
space put the component in the upper right corner<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.anchor = GridBagConstraints.NORTHEAST;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make it the
last component in the row<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth
= GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[9],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[9]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = &quot;Button
10&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[10]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if the component
has extra space assigned grow the component to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fill it in both
the x and y direction<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.fill = GridBagConstraints.BOTH;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this line is
unnecessary because the value of gridwidth is retained<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//from when it
was set for the previous button<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth
= GridBagConstraints.REMAINDER;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[10],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[10]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = &quot;Button
11&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[11]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if there's extra
space align the component with the right hand side<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.anchor = GridBagConstraints.EAST;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//change the weights
for allocating extra space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weightx =
.5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.weighty =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//don't grow the
component in either direction if there's extra space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.fill = GridBagConstraints.NONE;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[11],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[11]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = &quot;Button
12&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[12]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//pad the component--on
the Mac the component grows<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.ipadx = 20;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the allocation
of width to the default.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//note that it
had been set to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//REMAINDER above
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridwidth
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//put this component
to the right and below the previous one<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridx = GridBagConstraints.RELATIVE;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.gridy = GridBagConstraints.RELATIVE;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[12],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[12]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = &quot;Button
13&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[13]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the pad
space to 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.ipadx = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//align the component
with the left hand side of the available space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbc.anchor = GridBagConstraints.WEST;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gbl.setConstraints(the_buttons[13],gbc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_buttons[13]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This applet has the interface shown in Figures 17.39 and 17.40.
The two figures show how <TT><FONT FACE="Courier">GridBagLayout</FONT></TT>
behaves as the window resizes.
<P>
<A HREF="f17-39.gif" ><B>Figure 17.39 : </B><I>The large window layout.</I></A>
<P>
<A HREF="f17-40.gif" ><B>Figure 17.40 : </B><I>The small window layout.</I></A>
<H3><A NAME="BorderLayout"><TT><FONT SIZE=4 FACE="Courier">BorderLayout</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">BorderLayout</FONT></TT> divides
the container into five pieces; four form the four borders of
the container and the fifth is the center. You can add one component
to each of these five areas. Because the component can be a panel,
you can add more than one interface element, such as a button,
to each of the five areas. <TT><FONT FACE="Courier">BorderLayout</FONT></TT>
makes room for the items in the four border areas (referred to
as <TT><FONT FACE="Courier">North</FONT></TT>, <TT><FONT FACE="Courier">South</FONT></TT>,
<TT><FONT FACE="Courier">East</FONT></TT>, and <TT><FONT FACE="Courier">West</FONT></TT>),
and then whatever is left over is assigned to the <TT><FONT FACE="Courier">Center</FONT></TT>
area. This layout is nice if you want to place scrollbars around
a panel, place the scrollbars in the border regions, use all four
scrollbars or just two, and place the panel you want to scroll
in the center.
<P>
Listing 17.30 shows an example of the <TT><FONT FACE="Courier">BorderLayout</FONT></TT>
in action, which generates the screen shown in Figure 17.41.
<P>
<A HREF="f17-41.gif" ><B>Figure 17.41 : </B><I>The </I><B>BorderLayout.</B></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.30. Using </B><TT><B><FONT FACE="Courier">BorderLayout</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class borderlayout extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button the_buttons[];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n_buttons;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BorderLayout bl;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bl = new BorderLayout(10,15);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(bl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_buttons = 5;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons =
new Button[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add the buttons
to the various &quot;geographic&quot; regions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[0]
= new Button(&quot;North Button&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;,the_buttons[0]);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[1]
= new Button(&quot;South Button&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,the_buttons[1]);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[2]
= new Button(&quot;East Button&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;East&quot;,the_buttons[2]);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[3]
= new Button(&quot;West Button&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;West&quot;,the_buttons[3]);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[4]
= new Button(&quot;In the Middle&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;,the_buttons[4]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="CardLayout"><TT><FONT SIZE=4 FACE="Courier">CardLayout</FONT></TT></A>
</H3>
<P>
The <TT><FONT FACE="Courier">CardLayout</FONT></TT> is different
from the others because it enables you to create virtual screen
real estate by defining multiple <TT><FONT FACE="Courier">Card</FONT></TT>s,
one of which is visible at any time. Each <TT><FONT FACE="Courier">Card</FONT></TT>
contains a panel that can contain any number of interface elements,
including other panels. If you've ever used HyperCard on the Mac,
you'll be familiar with this Rolodex<FONT FACE="Symbol">&#137;</FONT>
type of interface. It's also similar to the tabbed dialog boxes
that are the rage in Microsoft products, but <TT><FONT FACE="Courier">Card</FONT></TT>s
lack any built-in way to go from <TT><FONT FACE="Courier">Card</FONT></TT>
to <TT><FONT FACE="Courier">Card</FONT></TT>; you have to provide
an interface for that.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Commercial widgets that implement tabbed dialog boxes are available; see the section &quot;Extending the AWT,&quot; later in this chapter.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The example in Listing 17.31 generates a group of five cards.
Each card has a button that takes you to the next card. You can
tell which card you're on by looking at the button name.
<HR>
<BLOCKQUOTE>
<B>Listing 17.31. Generating a group of five cards.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class cardlayout extends Applet{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button the_buttons[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Panel&nbsp;&nbsp;the_panels[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CardLayout cl;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n_buttons;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String name;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl = new CardLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(cl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_buttons = 5;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_panels = new
Panel[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons =
new Button[n_buttons];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this loop creates
the 5 panels and adds a button to each<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;n_buttons;i++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_panels[i]
= new Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= &quot;Button &quot; + i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_buttons[i]
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_panels[i].add(the_buttons[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name
= &quot;Card &quot; + i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//give
the panel a name to be used to access it<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(name,
the_panels[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.show(this,&quot;Card
2&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public boolean
action (Event e, Object o) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension&nbsp;&nbsp;d_should;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//when the button
is clicked this takes you to the next card, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//it will cycle
around so that when you're <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//at card 4 this
will take you to card 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl.next(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Figure 17.42 shows the second card in the stack. Clearly, you
could make a tabbed dialog box interface by using a row of buttons
across the top of all the cards (one for each card in the group)
or with a canvas at the top with a set of tabs drawn on it.
<P>
<A HREF="f17-42.gif" ><B>Figure 17.42 : </B><I>Card two of a </I><B>CardLayout</B><I> Manager interface.</I></A>
<H3><A NAME="CustomLayouts">Custom Layouts</A></H3>
<P>
You can develop your own Layout Managers by creating a new class
that implements <TT><FONT FACE="Courier">LayoutManager</FONT></TT>
and overrides the following five methods.
<H5>addLayoutComponent(String area_name,
Component a_component)</H5>
<BLOCKQUOTE>
Adds a component to the layout. If your layout has multiple named
areas (such as <TT><FONT FACE="Courier">North</FONT></TT> in <TT><FONT FACE="Courier">BorderLayout</FONT></TT>),
the name specifies which region the component should go to. If
your layout doesn't keep any special information about the component,
you can make this method do nothing.
</BLOCKQUOTE>
<H5>removeLayoutComponent(Component c)</H5>
<BLOCKQUOTE>
Removes a component from the layout. If you don't keep any special
information about a component, you can make this method do nothing.
</BLOCKQUOTE>
<H5>Dimension, preferredLayoutSize(Container
the_parent)</H5>
<BLOCKQUOTE>
Computes the preferred size for the container that holds the layout.
</BLOCKQUOTE>
<H5>Dimension, minimumLayoutSize(Container
the_parent)</H5>
<BLOCKQUOTE>
Returns the minimum size needed for the layout.
</BLOCKQUOTE>
<H5>layoutContainer(Container the_parent)</H5>
<BLOCKQUOTE>
Lays out the components using the <TT><FONT FACE="Courier">reshape</FONT></TT>
method. This is where you put the logic for deciding how to position
components.
</BLOCKQUOTE>
<BLOCKQUOTE>
Although implementing a custom Layout Manager isn't earth-shatteringly
complex, the good news is that there are lots of people in the
Java community-and some already are making custom Layout Managers.
You can get a <TT><FONT FACE="Courier">PackerLayout</FONT></TT>,
for example, which is very similar to the layout approach used
in tcl/tk-another mainly UNIX programming language. Before spending
the time building your own Layout Manager, do a Web search to
make sure that you can't save the time by using someone else's
work.
</BLOCKQUOTE>
<BLOCKQUOTE>
Here are some sample Layout Managers that you can get on the Web.
I haven't tried them, so don't view this as a recommendation;
instead, it merely should be a starting point in your quest to
avoid writing any more code than necessary.
</BLOCKQUOTE>
<P>
<B>Fractional Layout Manager</B>
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.mcs.net/~elunt/Java/FractionalLayoutDescription.html">http://www.mcs.net/~elunt/Java/FractionalLayoutDescription.html</A></TT>
</BLOCKQUOTE>
<P>
<B>Layout Manager Launch</B>
<P>
(a collection of links to various Layout Managers)
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.softbear.com/people/larry/javalm.htm">http://www.softbear.com/people/larry/javalm.htm</A></TT>
</BLOCKQUOTE>
<P>
<B>Packer Layout Manager</B>
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.geom.umn.edu/~daeron/apps/ui/pack/gui.html">http://www.geom.umn.edu/~daeron/apps/ui/pack/gui.html</A></TT>
</BLOCKQUOTE>
<P>
<B>Relative Layout Manager</B>
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www-elec.enst.fr/java/RelativeLayout.java">http://www-elec.enst.fr/java/RelativeLayout.java</A></TT>
</BLOCKQUOTE>
<P>
<B>Rule-Based Layout Manager</B>
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.sealevelsoftware.com/sealevel/testrule.htm">http://www.sealevelsoftware.com/sealevel/testrule.htm</A></TT>
</BLOCKQUOTE>
<P>
<B>Tree Layout Manager</B>
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://www.sbktech.org/tree.html">http://www.sbktech.org/tree.html</A></TT><BR>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
One problem with custom Layout Mangers is that they have to be downloaded over the network, while the AWT Layout Managers already reside on the local machine. Because a Layout Manager can be large (more than 10 KB), this is an issue if a lot of your users will be working with 14.4-Kbps or 28.8-Kbps modems. If your users have T1 lines, it's not an issue.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Images"><FONT SIZE=5 COLOR=#FF0000>Images</FONT></A>
</H2>
<P>
The developers of Java knew that working with images is a critical
part of any modern programming language with a goal of implementing
user interfaces that meet the criteria of users. Because Java
is platform independent, though, it couldn't use any of the platform-specific
formats, such as the Mac's PICT standard. Fortunately, there already
are two platform-independent formats: GIF and JPEG. These formats
are especially nice because they are compressed so that transmitting
them takes less of the limited network bandwidth. The AWT supports
both these compression formats, but it uses neither of them internally.
Although you can read in GIF and JPEG files, they are converted
into images, which are just bitmaps. All the work you do in Java
with images is based on the <TT><FONT FACE="Courier">Image</FONT></TT>
class. For some strange reason, even though there is a special
package for image-manipulation-related classes (<TT><FONT FACE="Courier">java.awt.image</FONT></TT>),
the <TT><FONT FACE="Courier">Image</FONT></TT> class itself resides
in the top-level <TT><FONT FACE="Courier">java.awt</FONT></TT>
package.
<P>
<TT><FONT FACE="Courier">Image</FONT></TT> is an abstract class
designed to support bitmapped images in a platform-independent
manner. Although this class provides just the basics for working
with images, it does have several methods you'll find useful.
<P>
Java uses a model of image producers and image consumers. <I>Image
producers</I> generate pixels from a file or <TT><FONT FACE="Courier">Image</FONT></TT>
object, and <I>image consumers</I> use and/or display those pixels.
Both <TT><FONT FACE="Courier">ImageConsumer</FONT></TT> and <TT><FONT FACE="Courier">ImageProducer</FONT></TT>
are Java interfaces. AWT comes with <TT><FONT FACE="Courier">ImageProducer</FONT></TT>s
for reading from local files and URLs, arrays in memory, and <TT><FONT FACE="Courier">Image</FONT></TT>
objects. It also comes with <TT><FONT FACE="Courier">CropImageFilter</FONT></TT>,
<TT><FONT FACE="Courier">RGBImageFilter</FONT></TT>, and <TT><FONT FACE="Courier">PixelGrabber</FONT></TT>,
which implement the <TT><FONT FACE="Courier">ImageConsumer</FONT></TT>
interface.
<H5>Graphics, getGraphics()</H5>
<BLOCKQUOTE>
Returns the graphics object for this image. You can use this to
draw to the image using the drawing methods discussed in the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object section, &quot;<TT><FONT FACE="Courier">Graphics</FONT></TT>
Class.&quot;
</BLOCKQUOTE>
<H5>int, getHeight(ImageObserver imgobs)</H5>
<BLOCKQUOTE>
Returns the height of the image. The <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
class monitors the construction of the image-as it's loaded over
the Internet, for example. The <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
is notified when the image is fully loaded into memory if it isn't
at the time this method is called.
</BLOCKQUOTE>
<H5>Object, getProperty(String prop_name,
ImageObserver imgobs)</H5>
<BLOCKQUOTE>
Returns the value of one of the image properties. The specific
properties depend on the original image format. Three properties
are supported by Java:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">comments</FONT></TT>: A string full of
information defined by the person who made the image file.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">croprect</FONT></TT>: If a Java <TT><FONT FACE="Courier">croprect</FONT></TT>
filter is used, this holds the boundary of the original image.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">filters</FONT></TT>: If Java image filters
are used to make the image, they are listed here.
</BLOCKQUOTE>
<H5>ImageProducer, getSource()</H5>
<BLOCKQUOTE>
Returns an instance of <TT><FONT FACE="Courier">ImageProducer</FONT></TT>,
which serves as a source for the pixels in an image.
</BLOCKQUOTE>
<H5>int, getWidth()</H5>
<BLOCKQUOTE>
Returns the width of the image.
</BLOCKQUOTE>
<H3><A NAME="LoadingImagesfromFilesImageObserver">Loading Images
from Files (<TT><FONT SIZE=4 FACE="Courier">ImageObserver</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
Java makes it easy to load images from files located on the server.
Security restrictions vary between browsers, but even Netscape,
which tends to have the tightest security, allows you to get images
from files in the same directory from which the Java classes are
loaded. The simple applet shown in Listing 17.32 loads in an image,
monitors the loading with an <TT><FONT FACE="Courier">ImageObserver</FONT></TT>,
and then displays the image (see Figure 17.43).
<P>
<A HREF="f17-43.gif" ><B>Figure 17.43 : </B><I>Displaying a GIF file.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.32. Showing a GIF image.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
import java.awt.image.*;<BR>
<BR>
<BR>
public class imagetest extends Applet implements ImageObserver,
Runnable{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image the_picture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean image_ready;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we'll use this
flag to see when the image is ready to use<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the image
from the same location as the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//HTML document
this applet is on<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture =
getImage(getDocumentBase(),&quot;test.gif&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//overriding this method allows you to
monitor the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;//status of the loading of the image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean imageUpdate(Image img,int
status, int x,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
y, int width, int height){<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((status &amp;
ALLBITS) == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Monitor
the load status<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Processing
image &quot; + x + &quot; &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y
+ &quot; width, height &quot; + width + &quot; &quot; + height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Image
fully read in&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Give the thread
that's loading the image more cycles by minimizing the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//priority of
the applet's animation thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.setPriority(Thread.MIN_PRIORITY);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//cycle while
you're waiting for the image to load. You could put in a<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//message telling
the user what's going on as well<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!image_ready)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(50);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Draw the image.
The &quot;this&quot; assigns the applet <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//as the image
observer for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this drawing.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready =
g.drawImage(the_picture,0,0,this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Notice that the applet itself implements the <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
interface so that when an <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
is called for, as in the <TT><FONT FACE="Courier">drawImage</FONT></TT>
method call, <TT><FONT FACE="Courier">this</FONT></TT> is used.
The only other change you have to make to your applet is to override
the <TT><FONT FACE="Courier">imageUpdate</FONT></TT> method with
one of your own to track the image-loading process. Although the
behavior of this seems to vary a bit between platforms (probably
due to differences in the way thread priorities are handled),
you can use it to see when an image is ready to be displayed.
But there is a better way, using the <TT><FONT FACE="Courier">MediaTracker</FONT></TT>
class, which you'll see in the next section.
<H3><A NAME="ClippingImagesCropImageFilterMediaT">Clipping Images
(<TT><FONT SIZE=4 FACE="Courier">CropImageFilter</FONT></TT><FONT SIZE=4>,
</FONT><TT><FONT SIZE=4 FACE="Courier">MediaTracker</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
If you're using Java on the Internet, you'll find that you'll
want to crop images more often than you might expect. The reason
for this is that there is a fairly significant overhead associated
with sending a file from the server to the client. As a result,
you can make your applet load faster if you send one file that
is 2x pixels on a side instead of four files that are 1x pixels
on a side. If you go with one large file, you'll find that the
<TT><FONT FACE="Courier">CropImageFilter</FONT></TT> class will
make it easy to cut out pieces of the image. This is a good way
to work with multi-frame animations. Put all the animations in
a single file and then use <TT><FONT FACE="Courier">CropImageFilter</FONT></TT>
to make a separate image for each cell in the animation.
<H4><TT><FONT FACE="Courier">CropImageFilter</FONT></TT> Creator
</H4>
<P>
You won't use any of <TT><FONT FACE="Courier">CropImageFilter</FONT></TT>'s
methods other than its creator:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">new CropImageFilter(int x, int y, int
width, int height)</FONT></TT>
</BLOCKQUOTE>
<P>
The input parameters define the rectangular region that will be
selected. The coordinates are with respect to the upper-left corner
of the image, which is set to 0,0.
<P>
The applet in Listing 17.33 reads in a GIF file, creates a new
image that is the upper-left corner of the original image, and
then displays both images, as shown in Figure 17.44.
<P>
<A HREF="f17-44.gif" ><B>Figure 17.44 : </B><I>The original and the cropped image.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.33. Cropping an image.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.applet.Applet;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
<BR>
public class crop_image extends Applet implements&nbsp;&nbsp;Runnable{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image the_picture, cropped_picture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean image_ready;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker the_tracker;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.setPriority(Thread.MIN_PRIORITY);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(3000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CropImageFilter
c_i_filter;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Define a MediaTracker
to monitor the completion status of an image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//You need to
supply a component as the argument. <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//In this case
the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is used<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker =
new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture =
getImage(getDocumentBase(),&quot;test.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tell MediaTracker
to monitor the progress of the image and <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//assign the image
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the index of
0--the index value is arbitrary<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(the_picture,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Define an image
cropping filter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c_i_filter = new
CropImageFilter(0,0,32,32);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Apply the filter
to the image and make a new image of the cropped area<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cropped_picture
= createImage(new FilteredImageSource(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture.getSource(),c_i_filter));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Monitor the
cropped image to see when it's done<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(cropped_picture,1);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Wait till both
images are ready<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_tracker.checkID(0,true)
&amp; <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.checkID(1,true))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(the_picture,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(cropped_picture,70,70,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Waiting
for image to fully load&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H4><TT><FONT FACE="Courier">MediaTracker</FONT></TT></H4>
<P>
The applet shown in Figure 17.44 also demonstrates how to use
the <TT><FONT FACE="Courier">MediaTracker</FONT></TT> class to
monitor images that are being loaded or built. All you have to
do is create a new instance of the <TT><FONT FACE="Courier">MediaTracker</FONT></TT>
class.
<P>
To create a <TT><FONT FACE="Courier">MediaTracker</FONT></TT>
instance to monitor the loading of images associated with the
specified component, use this code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">new MediaTracker(Component a_component)</FONT></TT>
</BLOCKQUOTE>
<P>
To track images, you'll use these <TT><FONT FACE="Courier">MediaTracker</FONT></TT>
methods:
<H5>addImage(Image an_image, int id)</H5>
<BLOCKQUOTE>
Tells <TT><FONT FACE="Courier">MediaTracker</FONT></TT> to monitor
the specified image. The ID is used in other method calls to identify
the image. You can use any value for the ID, and you can assign
the same ID to more than one image.
</BLOCKQUOTE>
<H5>addImage(Image an_image, int id,
int width, int height)</H5>
<BLOCKQUOTE>
Functions like the preceding method, except that it registers
a scaled image where <TT><FONT FACE="Courier">width</FONT></TT>
and <TT><FONT FACE="Courier">height</FONT></TT> are the new dimensions
of the image. This is a synchronized method.
</BLOCKQUOTE>
<H5>boolean, checkAll()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> when the images
have loaded or stopped loading due to an error. Use the <TT><FONT FACE="Courier">isErrorAny</FONT></TT>
and/or <TT><FONT FACE="Courier">isErrorID</FONT></TT> methods
to check for problems.
</BLOCKQUOTE>
<H5>boolean, checkAll(boolean load_flag)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if all images
have finished loading or encountered an error. This is a synchronized
method. It forces the images to load if the input parameter is
<TT><FONT FACE="Courier">TRUE</FONT></TT>.
</BLOCKQUOTE>
<H5>boolean, checkID(int the_id)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the specified
image (or group of images, if more than one image has the same
ID) has finished loading or stopped due to an error.
</BLOCKQUOTE>
<H5>boolean, checkID(int the_id, boolean
load_flag)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the images
with the specified ID are loaded or have encountered an error.
If <TT><FONT FACE="Courier">load_flag</FONT></TT> is <TT><FONT FACE="Courier">TRUE</FONT></TT>,
this synchronized method starts to load the image if it isn't
already loading.
</BLOCKQUOTE>
<H5>Object[], getErrorsAny()</H5>
<BLOCKQUOTE>
Returns an array of media objects for those images that encountered
errors. This is a synchronized method. You can print these objects
by using the <TT><FONT FACE="Courier">.toString</FONT></TT> method
on them.
</BLOCKQUOTE>
<H5>Object[], getErrorsID(int id)</H5>
<BLOCKQUOTE>
Returns an array of media objects for the images with the specified
ID that encountered an error while loading. This is a synchronized
method.
</BLOCKQUOTE>
<H5>boolean, isErrorAny()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if any image
currently being tracked has a problem. This is a synchronized
method.
</BLOCKQUOTE>
<H5>boolean, isErrorID(int id)</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if any image
with the specified ID has received an error while loading. This
is a synchronized method.
</BLOCKQUOTE>
<H5>int, statusAll(boolean load_flag)</H5>
<BLOCKQUOTE>
Returns the status of the loading of all the images. <TT><FONT FACE="Courier">AND</FONT></TT>ing
the returned value with <TT><FONT FACE="Courier">MediaTracker.ERRORED</FONT></TT>
returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if there is
an error. If the input parameter is <TT><FONT FACE="Courier">TRUE</FONT></TT>,
this method starts loading the images if they haven't already
been loaded.
</BLOCKQUOTE>
<H5>int, statusID(int id, boolean load_flag)</H5>
<BLOCKQUOTE>
Functions similarly to <TT><FONT FACE="Courier">statusAll</FONT></TT>,
except for a single ID.
</BLOCKQUOTE>
<H5>waitForAll()</H5>
<BLOCKQUOTE>
Waits until all images are loaded or encounter an error. If this
method is interrupted, it throws the <TT><FONT FACE="Courier">InterruptedException</FONT></TT>
error.
</BLOCKQUOTE>
<H5>boolean, waitForAll(long time_in_ms)</H5>
<BLOCKQUOTE>
Functions similarly to <TT><FONT FACE="Courier">waitForAll</FONT></TT>,
except that it will timeout after the specified time. This is
a synchronized method.
</BLOCKQUOTE>
<H5>waitForID(int id)</H5>
<BLOCKQUOTE>
Functions similarly to <TT><FONT FACE="Courier">waitForAll</FONT></TT>,
except for a single ID.
</BLOCKQUOTE>
<H5>boolean, waitForID(int id, long time_in_ms)</H5>
<BLOCKQUOTE>
Functions similarly to <TT><FONT FACE="Courier">waitForAll</FONT></TT>,
except for a single ID. This is a synchronized method.
</BLOCKQUOTE>
<BLOCKQUOTE>
As you can see from the applet in Listing 17.33, though, you only
need to use a couple of methods to monitor image loading in most
circumstances.<BR>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java will not be able to garbage-collect images that have been monitored by <TT><FONT FACE="Courier">MediaTracker</FONT></TT>, because <TT><FONT FACE="Courier">MediaTracker</FONT></TT> retains references to them unless the <TT><FONT FACE="Courier">MediaTracker</FONT></TT> instance itself can be garbage-collected. If you load and then delete images, make sure to set all references to the <TT><FONT FACE="Courier">MediaTracker</FONT></TT> you used to <TT><FONT FACE="Courier">NULL</FONT></TT> if you want Java to free up the space used by the images.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="FilteringImagesRGBImageFilter">Filtering Images (<TT><FONT SIZE=4 FACE="Courier">RGBImageFilter</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
Image filters provide an easy way to transform images. The <TT><FONT FACE="Courier">RGBImageFilter</FONT></TT>
makes it easy to execute transformations that only require information
about the pixel being modified. Although that excludes a wide
range of common transformations, it does support a large number,
such as converting to grayscale, image fade out, and color separation.
The applet in Listing 17.34 takes an image, inverts all the colors,
and then displays the before and after pictures (see Figure 17.45).
<P>
<A HREF="f17-45.gif" ><B>Figure 17.45 : </B><I>Inverting colors with </I><B>RGBImageFilter.</B></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.34. Using an </B><TT><B><FONT FACE="Courier">RGBImageFilter</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.applet.Applet;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
<BR>
public class rgbimagefilter extends Applet implements&nbsp;&nbsp;Runnable{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image the_picture, filtered_image;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean image_ready;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker the_tracker;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//Sep is the new class that extends RGBImageFilter
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Sep image_filter;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.setPriority(Thread.MIN_PRIORITY);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(3000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker =
new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture =
getImage(getDocumentBase(),&quot;test.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(the_picture,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//modify the image
and track the process<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter_image();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(filtered_image,1);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void filter_image() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_filter =
new Sep();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the new
filtered image using the getSource method on the input<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//picture as a
pixel producer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filtered_image
= createImage(new FilteredImageSource <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the_picture.getSource(),image_filter));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//wait for both
images to be loaded before drawing them<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_tracker.checkID(0,true)
&amp; <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.checkID(1,true))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_ready
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(the_picture,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(filtered_image,60,60,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Waiting
for image to fully load&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class Sep extends RGBImageFilter{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Sep() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This specifies
that this class can work with IndexColorModel where<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//each pixel contains
a pointer to a color in a lookup table rather than<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//a 32 bit color
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canFilterIndexColorModel
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int filterRGB(int x, int y, int
rgb) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int blue,red,green,new_color;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get the three
color components from the rgb int<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = rgb &amp;
0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = (rgb &amp;
0x0000FF00) &gt;&gt; 8;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = (rgb &amp;
0x00FF0000) &gt;&gt; 16;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//These three
lines invert the color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = 255 - blue;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = 255 -
green;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = 255 - red;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create the new
color and then get the int version of the color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_color = (new
Color(red,blue,green)).getRGB();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new_color;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
All the work is done in the <TT><FONT FACE="Courier">filterRGB</FONT></TT>
method, which is called for each pixel or every color in the lookup
table for indexed color models. You can put any algorithm in that
method that only requires information about that one color and/or
pixel. If your transformation is position dependent (it's a function
of x and/or y), you can't work with an indexed color model because
the <TT><FONT FACE="Courier">filterRGB</FONT></TT> method, in
this case, is called only for the colors in the lookup table-not
for every pixel.
<H3><A NAME="BuildingImagesOntheFlyMemoryImageS">Building Images
On-the-Fly (<TT><FONT SIZE=4 FACE="Courier">MemoryImageSource</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
The AWT provides a class, <TT><FONT FACE="Courier">MemoryImageSource</FONT></TT>,
that makes it easy to convert an array of data into an image.
This is useful if you're building images on-the-fly-drawing the
Mandelbrot set, for example. In Listing 17.35, the image is a
gradient fill that's built as an array of integers and then converted
to an image (see Figure 17.46).
<P>
<A HREF="f17-46.gif" ><B>Figure 17.46 : </B><I>A gradient fill generated as an array of integers.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.35. Working with pixel values.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.image.*;<BR>
import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class memory_image extends Applet implements Runnable<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image working;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker the_tracker;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int pixels[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int max_x, max_y;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(3000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_x = 256;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_y = 256;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker =
new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the pixel
array that we're going to convert to an image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels = new int[max_x
* max_y];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the new
image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_pixels();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init_pixels() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y,i, j;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double step;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//this method
does a gradient fill starting with black at the top<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//and going to
blue at the bottom<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//step is used
to determine how much the color changes between rows<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step = 255.0/max_y;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color c = new
Color(0,0,0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ci = c.getRGB();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (y=0;y&lt;max_y;y++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//get
a new color for each row. notice that the fastest cycling<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
in the array is x. variable<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c
= new Color(0,0,Math.round((float)(j*step)));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci
= c.getRGB();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(x=0;x&lt;max_x;x++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels[i++]=
ci;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make the image
and use MediaTracker to see when it's <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//done being processed
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;working = createImage(new
MemoryImageSource<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(max_x,max_y,pixels,0,max_y));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(working,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if the image
is done display it, otherwise let the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//user know what's
going on<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_tracker.checkID(0,true))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(working,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;please
wait&quot;,50,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
After you have an image from the <TT><FONT FACE="Courier">int</FONT></TT>
array, you can use all the other image-processing tools with them.
<H3><A NAME="ConvertingImagestoArraysPixelGrabbe">Converting Images
to Arrays (<TT><FONT SIZE=4 FACE="Courier">PixelGrabber</FONT></TT><FONT SIZE=4>)</FONT></A>
</H3>
<P>
If you're going to process images, you often want to work with
the pixel data as an array. The AWT provides a class, <TT><FONT FACE="Courier">java.awt.image.PixelGrabber</FONT></TT>,
to do just that. This class has two creator methods, plus some
other useful methods.
<H5>new PixelGrabber(Image img, int x,
int y, int width, int height, int[] pixels, int offset, int linewidth)</H5>
<BLOCKQUOTE>
Takes the region of the image defined by <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">
y</FONT></TT>, <TT><FONT FACE="Courier">height</FONT></TT>, and
<TT><FONT FACE="Courier">width</FONT></TT> and puts it into the
pixel's array with the specified offset and line width.
</BLOCKQUOTE>
<H5>new PixelGrabber(ImageProducer img,
int x, int y, int width, int height, int[] pixels, int offset,
int linewidth)</H5>
<BLOCKQUOTE>
Takes the region of the image produced by the image producer defined
by <TT><FONT FACE="Courier">x</FONT></TT>,<TT><FONT FACE="Courier">
y</FONT></TT>, <TT><FONT FACE="Courier">height</FONT></TT>, and
<TT><FONT FACE="Courier">width</FONT></TT> and puts it into the
pixel's array with the specified offset and line width.
</BLOCKQUOTE>
<H5>boolean, grabPixels()</H5>
<BLOCKQUOTE>
Throws <TT><FONT FACE="Courier">InterruptedException</FONT></TT>
if it's interrupted. It takes the image data and puts it into
the pixel array. This is a synchronized method.
</BLOCKQUOTE>
<H5>int, status()</H5>
<BLOCKQUOTE>
Returns the status of getting the pixels from an image. The return
value uses the same flag constants as the <TT><FONT FACE="Courier">ImageObserver</FONT></TT>
class. This is a synchronized method.
</BLOCKQUOTE>
<BLOCKQUOTE>
The applet in Listing 17.36 reads in a GIF file, fills in an array
with the pixel values, applies an averaging filter to the data
(which uses information about each pixel's neighbors), and then
converts the pixel array back to an image. This results in the
screen shown in Figure 17.47.
</BLOCKQUOTE>
<P>
<A HREF="f17-47.gif" ><B>Figure 17.47 : </B><I>An average filter applied to a grayscale image.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.36. A filter that uses data from a pixel's local
area.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.image.*;<BR>
import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class pixel_grabber extends Applet implements Runnable
<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image working;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Thread the_thread;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker the_tracker;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int pixels[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int max_x, max_y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image the_picture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image the_modified_picture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean done_flag;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (the_thread
== null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.stop();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_thread.sleep(3000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch(InterruptedException e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//when
the original image is loaded transform it. <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The
use of the flag<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//makes
sure you only transform the image once<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_tracker.checkID(0,true)
&amp; !(done_flag)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform_image();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done_flag
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done_flag = false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_x = 64;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_y = 64;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker =
new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the pixel
array that we're going to <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fill with data
from the image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels = new int[max_x
* max_y];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture =
getImage(getDocumentBase(),&quot;test.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(the_picture,0);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void transform_image() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelGrabber pg;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x,y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double sum, temp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the PixelGrabber
to capture the full image, unscaled<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg = new PixelGrabber(the_picture,
0,0,max_x,max_y,pixels,0,max_y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fill the pixel's
array with the image data<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pg.grabPixels();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch(InterruptedException
e) {};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//just to show
something happened apply an averaging filter. <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This is designed
to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//work with grayscale
images because it assumes all of the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//color components
are<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//equal. It takes
the Blue component of a pixel and its <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//four neighbors,
averages them,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//and then sets
the pixel color to that average<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (x=3;x&lt;(max_x
- 3);x++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(y=3;y&lt;(max_y - 3);y++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= pixels[x + y * max_y] &amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum
= 0.2 * temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= pixels[(x - 1) + y * max_y] &amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum
= sum + 0.2 * temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= pixels[(x+1) + y * max_y] &amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum
= sum + 0.2 * temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= pixels[x + (y - 1) * max_y] &amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum
= sum + 0.2 * temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp
= pixels[x + (y + 1) * max_y] &amp; 0x000000FF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum
= sum + 0.2 * temp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
gray = (int)Math.round(sum);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color
c = new Color(gray,gray,gray);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels[x
+ y * max_y] = c.getRGB() ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//here we use
MemoryImageSource to convert the pixel array into an Image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_modified_picture
= createImage(new<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MemoryImageSource(max_x,max_y,pixels,0,max_y));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(the_modified_picture,1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if the image
is done display it, otherwise let <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the user know
what's going on<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_tracker.checkID(0,true)
) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(the_picture,0,0,this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
the_tracker.checkID(1,true)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(the_modified_picture,
64,64,this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;please
wait&quot;,50,50);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Wndows"><FONT SIZE=5 COLOR=#FF0000>Window</FONT></A><FONT SIZE=5 COLOR=#FF0000>s</FONT>
</H2>
<P>
The <TT><FONT FACE="Courier">Window</FONT></TT> class implements
a window with no borders and no menu bar. This generally isn't
a useful class on its own, but because <TT><FONT FACE="Courier">Frame</FONT></TT>
and <TT><FONT FACE="Courier">Dialog</FONT></TT>-which are useful-extend
it, it's useful to take a quick look at <TT><FONT FACE="Courier">Window</FONT></TT>'s
methods.
<H5>dispose()</H5>
<BLOCKQUOTE>
This gets rid of the window's peer. When the window is destroyed,
you need to call this method. This is a synchronized method.
</BLOCKQUOTE>
<H5>Toolkit, getToolkit()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">Toolkit</FONT></TT> associated
with the window.
</BLOCKQUOTE>
<H5>show()</H5>
<BLOCKQUOTE>
Displays the window, making it visible and moving it to the front.
This is a synchronized method.
</BLOCKQUOTE>
<H5>toBack()</H5>
<BLOCKQUOTE>
Moves the window behind all other windows in the application.
</BLOCKQUOTE>
<H5>toFront()</H5>
<BLOCKQUOTE>
Moves the window in front of all other windows.
</BLOCKQUOTE>
<BLOCKQUOTE>
User interactions with a window can cause it to generate the <TT><FONT FACE="Courier">WINDOW_DESTROY</FONT></TT>,
<TT><FONT FACE="Courier">WINDOW_ICONIFY</FONT></TT>, <TT><FONT FACE="Courier">WINDOW_DEICONIFY</FONT></TT>,
and <TT><FONT FACE="Courier">WINDOW_MOVED</FONT></TT> events.
<BR>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Here's another example of how the AWT conforms to the expectations of platform users. On the Mac, the window doesn't reduce to an icon, because that is not the sort of behavior a Mac user would expect.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Frame"><FONT SIZE=5 COLOR=#FF0000>Frame</FONT></A><FONT SIZE=5 COLOR=#FF0000>s</FONT>
</H2>
<P>
A <TT><FONT FACE="Courier">Frame</FONT></TT> implements a resizable
window that supports a menu bar, cursor, icon, and title.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=590><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=590>
<BLOCKQUOTE>
An AWT frame has nothing to do with an HTML frame, which is a concept for defining panes inside a window and was developed by Netscape. A Java frame only applies within an applet window or a Java application.  You can't use a Java frame to set up <TT><FONT FACE="Courier">Frame</FONT></TT>s on an HTML page.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
This is your basic application-type window, which looks like the
windows you'll see in most programs. You can use frames with an
applet; in fact, it's the only way to use dialog boxes and menu
bars.
<P>
Frames generate the same events as windows, which they extend:
<TT><FONT FACE="Courier">WINDOW_DESTROY</FONT></TT>, <TT><FONT FACE="Courier">WINDOW_ICONIFY</FONT></TT>,
<TT><FONT FACE="Courier">WINDOW_DEICONIFY</FONT></TT>, and <TT><FONT FACE="Courier">WINDOW_MOVED</FONT></TT>.
<P>
The only parameter you can pass to the <TT><FONT FACE="Courier">Frame</FONT></TT>
constructor is a <TT><FONT FACE="Courier">String</FONT></TT>,
which will be the window title. You generally will create your
own class that extends <TT><FONT FACE="Courier">Frame</FONT></TT>
and contains event-handling methods that override <TT><FONT FACE="Courier">Component</FONT></TT>
methods such as <TT><FONT FACE="Courier">action</FONT></TT>, <TT><FONT FACE="Courier">mouseDown</FONT></TT>,
and <TT><FONT FACE="Courier">keyDown</FONT></TT>. When you extend
the class, you can make creator methods with more input parameters.
One useful technique when you're using <TT><FONT FACE="Courier">Frame</FONT></TT>s
with applets is to pass the applet, using <TT><FONT FACE="Courier">this</FONT></TT>-the
Java construct that refers to the object in whose scope the program
line is in-to the <TT><FONT FACE="Courier">Frame</FONT></TT> so
that the <TT><FONT FACE="Courier">Frame</FONT></TT> methods can
invoke applet methods and read/write applet instance variables.
<P>
The most useful <TT><FONT FACE="Courier">Frame</FONT></TT> methods
follow.
<H5>dispose()</H5>
<BLOCKQUOTE>
Enables you to free up windowing resources when you're done with
a <TT><FONT FACE="Courier">Frame</FONT></TT>. This is a synchronized
method.
</BLOCKQUOTE>
<H5>int, getCursorType()</H5>
<BLOCKQUOTE>
Returns the integer constant that defines which cursor currently
is displayed. The available <TT><FONT FACE="Courier">Frame</FONT></TT>
final static (constant) values follow:
</BLOCKQUOTE>
<BLOCKQUOTE>
CROSSHAIR_CURSOR<BR>
DEFAULT_CURSOR<BR>
E_RESIZE_CURSOR<BR>
HAND_CURSOR<BR>
MOVE_CURSOR<BR>
N_RESIZE_CURSOR<BR>
NE_RESIZE_CURSOR<BR>
NW_RESIZE_CURSOR<BR>
S_RESIZE_CURSOR<BR>
SE_RESIZE_CURSOR<BR>
SW_RESIZE_CURSOR<BR>
TEXT_CURSOR<BR>
W_RESIZE_CURSOR<BR>
WAIT_CURSOR
</BLOCKQUOTE>
<H5>Image, getIconImage()</H5>
<BLOCKQUOTE>
Returns the image being used when the window is reduced to an
icon.
</BLOCKQUOTE>
<H5>MenuBar, getMenuBar()</H5>
<BLOCKQUOTE>
Returns the frame's menu bar.
</BLOCKQUOTE>
<H5>String, getTitle()</H5>
<BLOCKQUOTE>
Returns the frame's title.
</BLOCKQUOTE>
<H5>boolean, isResizable()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the frame
can be resized. This attribute can be toggled using the <TT><FONT FACE="Courier">setResizable</FONT></TT>
method.
</BLOCKQUOTE>
<H5>remove(MenuComponent mb)</H5>
<BLOCKQUOTE>
Removes the menu bar associated with the frame. This is a synchronized
method.
</BLOCKQUOTE>
<H5>setCursor(int cursor_constant)</H5>
<BLOCKQUOTE>
Sets the current cursor to the one specified by the input argument.
</BLOCKQUOTE>
<H5>setIconImage(Image icon)</H5>
<BLOCKQUOTE>
Sets the icon to be used when the frame is reduced to an icon
to the input image.
</BLOCKQUOTE>
<H5>setMenuBar(MenuBar mb)</H5>
<BLOCKQUOTE>
Sets the menu bar for the frame. This is a synchronized method.
</BLOCKQUOTE>
<H5>setResizable(boolean flag)</H5>
<BLOCKQUOTE>
Changes the frame size if the input parameter is <TT><FONT FACE="Courier">TRUE</FONT></TT>.
If the input is <TT><FONT FACE="Courier">FALSE</FONT></TT>, the
frame is a fixed size.
</BLOCKQUOTE>
<H5>setTitle(String new_title)</H5>
<BLOCKQUOTE>
Sets the window title.
</BLOCKQUOTE>
<BLOCKQUOTE>
The applet in Listing 17.37 shows you how to work with a frame.
A button on the applet shows the frame. The user then can enter
text in a <TT><FONT FACE="Courier">TextArea</FONT></TT> on the
frame. When the user closes the frame (either with the button
in the frame or the one in the applet), the frame is hidden and
the text in the frame's <TT><FONT FACE="Courier">TextArea</FONT></TT>
is put into the <TT><FONT FACE="Courier">TextArea</FONT></TT>
in the applet. The applet and the frame are shown in Figures 17.48
and 17.49.
</BLOCKQUOTE>
<P>
<A HREF="f17-48.gif" ><B>Figure 17.48 : </B><I>The applet window.</I></A>
<P>
<A HREF="f17-49.gif" ><B>Figure 17.49 : </B><I>The new frame.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.37. Working with frames.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class frame_test extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;input_frame a_frame;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button b_open, b_close;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea the_message;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean frame_visible;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_open = new Button(&quot;Open
frame&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_close = new
Button(&quot;Close frame&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_open);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_close);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_message =
new TextArea(5,20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_message);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame_visible
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_frame = create_dialog(&quot;Enter
a message&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Uncomment these
next two lines if you want the frame showing <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//when the applet
starts<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//a_frame.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//frame_visible
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public input_frame create_dialog(String
the_title) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create a new
frame. pass this so that the frame can <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//access the applet's
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//instance variables
in order to pass information back.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_frame = new
input_frame(the_title,this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set its size
to 200 by 200<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_frame.resize(200,200);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a_frame;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String item_name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle mouse
clicks on the two buttons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item_name
= (String)the_arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Open
frame&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!frame_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_frame.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame_visible
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Close
frame&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(frame_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_frame.hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame_visible
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
}<BR>
<BR>
class input_frame extends Frame {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button close_frame;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextArea text_space;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//this has to be of type frame_test not
Applet. If you use Applet <BR>
&nbsp;&nbsp;&nbsp;&nbsp;//instead of frame_test it<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//will still compile but you won't be
able to use my_<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//parent to access the instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//variables of the frame_test applet such
as frame_visible.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frame_test my_parent;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;input_frame(String the_title, frame_test
host) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(the_title);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowLayout fl;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_parent = host;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//have to define
a layout manager for the frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fl = new FlowLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(fl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close_frame =
new Button(&quot;Close frame&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(close_frame);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_space = new
TextArea(&quot;Enter your input&quot;,5,10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(text_space);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//By overriding the hide method we ensure
that the text<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//from the dialog is sent back<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//to the applet if the frame is closed
by clicking on the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;//close frame button in the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//applet.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void hide() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String the_input;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_input = text_space.getText();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//use the reference
to the applet to pass data back by accessing the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TextArea component
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_parent.the_message.insertText(the_input,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_parent.frame_visible
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event an_event,
Object arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String button_name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String the_input;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (an_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button_name
= (String)arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(button_name.equals(&quot;Close
frame&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//we
don't have to do anything to copy the text to <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the
applet here because we overrode the <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//hide
method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Notice how the applet extends the <TT><FONT FACE="Courier">Frame</FONT></TT>
class and passes the applet object, using <TT><FONT FACE="Courier">this</FONT></TT>,
to the frame so the <TT><FONT FACE="Courier">Frame</FONT></TT>
methods can work with applet data. In general, creating frames
is straightforward because the AWT does most of the work for you.
Frames are the basic element for Java application interfaces.
<H3><A NAME="CursorControl">Cursor Control</A></H3>
<P>
For some strange reason, the capability to control the cursor
is in the <TT><FONT FACE="Courier">Frame</FONT></TT> class, so
when you can control the cursor, the user sees when a frame has
focus. The applet in Listing 17.38 enables you to select the cursor
from a pop-up menu. Figure 17.50 shows the frame that enables
you to select the cursor. The actual cursor images are platform
dependent. This is yet another way to make sure that users on
every platform feel comfortable with the interface.
<P>
<A HREF="f17-50.gif" ><B>Figure 17.50 : </B><I>A pop-up menu to pick the cursor.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.38. Selecting the cursor from a pop-up menu.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class cursor_test extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;a_frame a_window;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button b_open, b_close;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean window_visible;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_open = new Button(&quot;Open
Window&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_close = new
Button(&quot;Close Window&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_open);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_close);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create_dialog(&quot;Pick
a cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public a_frame create_dialog(String the_title)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create a new
Frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window = new
a_frame(the_title,this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set its size
to 300 by 80 pixels<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window.resize(300,80);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a_window;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String item_name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle mouse
clicks on the two buttons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item_name
= (String)the_arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Open
Window&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!window_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window_visible
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Close
Window&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(window_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window.hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window_visible
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
}<BR>
<BR>
class a_frame extends Frame {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button close_window;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Choice a_menu;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//this has to be of type cursor_test not
Applet. If you <BR>
&nbsp;&nbsp;&nbsp;&nbsp;//use Applet instead of cursor_test it
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//will still compile but you won't be
able to use my_<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//parent to access the instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//variables of the dialogs applet such
as window_visible.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;cursor_test my_parent;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;a_frame(String the_title, cursor_test
host) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(the_title);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowLayout fl;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_parent = host;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//have to define
a layout manager for the window<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fl = new FlowLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(fl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close_window =
new Button(&quot;Close Window&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(close_window);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu = new Choice();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Crosshair
cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Default
Arrow cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window to the Right cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Hand
cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Move
Window cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window Upwards cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window using NorthEast corner cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window using NorthWest corner cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window Downwards cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window using SouthEast corner cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resize
Window using SouthWest corner cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Text
Editing cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Resizing
Window to the left cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_menu.addItem(&quot;Hourglass
cursor&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(a_menu);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event an_event,
Object arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String button_name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String the_input;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String item_name;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (an_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button_name
= (String)arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(button_name.equals(&quot;Close
Window&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my_parent.window_visible = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(an_event.target
instanceof Choice) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item_name
= (String)arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Crosshair
cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.CROSSHAIR_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Default
Arrow cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.DEFAULT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window to the Right cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.E_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Hand
cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.HAND_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Move
Window cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.MOVE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window Upwards cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.N_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window using NorthEast corner cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.NE_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window using NorthWest corner cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.NW_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window Downwards cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.S_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window using SouthEast corner cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.SE_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resize
Window using SouthWest corner cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.SW_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Text
Editing cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.TEXT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Resizing
Window to the left cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.W_RESIZE_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Hourglass
cursor&quot;)){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCursor(Frame.WAIT_CURSOR);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Menus">Menus</A></H3>
<P>
You can put a menu bar in a frame or window, but not an applet.
Refer to the illustration in Figure 17.3 showing the five menu-related
classes: <TT><FONT FACE="Courier">MenuComponent</FONT></TT>, <TT><FONT FACE="Courier">MenuBar</FONT></TT>,
<TT><FONT FACE="Courier">Menu</FONT></TT>, <TT><FONT FACE="Courier">MenuItem</FONT></TT>,
and <TT><FONT FACE="Courier">CheckboxMenuItem</FONT></TT>.
<P>
All the other menu classes inherit from <TT><FONT FACE="Courier">MenuComponent</FONT></TT>.
<TT><FONT FACE="Courier">MenuComponent</FONT></TT> is an abstract
class, but you'll use these methods fairly often.
<H5>Font, getFont()</H5>
<BLOCKQUOTE>
Returns the font used for the current item.
</BLOCKQUOTE>
<H5>setFont(Font a_font)</H5>
<BLOCKQUOTE>
Sets the font to be used to display the item on which the menu
is invoked.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">MenuBar</FONT></TT> class is a container
for a set of menus displayed with a frame. The key <TT><FONT FACE="Courier">MenuBar</FONT></TT>
methods follow.
</BLOCKQUOTE>
<H5>Menu, add(Menu a_menu)</H5>
<BLOCKQUOTE>
Adds a menu to the menu bar. The return value is a handle to the
added menu. Menus are added left to right. This is a synchronized
method.
</BLOCKQUOTE>
<H5>int, countMenus()</H5>
<BLOCKQUOTE>
Returns the number of menus currently in the menu bar.
</BLOCKQUOTE>
<H5>Menu, getHelpMenu()</H5>
<BLOCKQUOTE>
Returns the menu that is defined as the Help menu for the menu
bar.
</BLOCKQUOTE>
<H5>Menu, getMenu(int pos)</H5>
<BLOCKQUOTE>
Returns the menu item at a given location in the menu bar.
</BLOCKQUOTE>
<H5>remove(int pos)</H5>
<BLOCKQUOTE>
Removes the menu at the specified position. This is a synchronized
method.
</BLOCKQUOTE>
<H5>remove(MenuComponent menu)</H5>
<BLOCKQUOTE>
Removes the specified menu from the menu bar. This is a synchronized
method.
</BLOCKQUOTE>
<H5>setHelpMenu(Menu a_menu)</H5>
<BLOCKQUOTE>
Sets the specified menu to be the Help menu, which always is placed
on the right side of the menu bar. This is a synchronized method.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Menu</FONT></TT> class implements
pull-down menus. There are two constructor methods and some useful
<TT><FONT FACE="Courier">Menu</FONT></TT> methods.
</BLOCKQUOTE>
<H5>new Menu(String a_label)</H5>
<BLOCKQUOTE>
Creates a new menu with the specified label.
</BLOCKQUOTE>
<H5>new Menu(String a_label, boolean
tear_off)</H5>
<BLOCKQUOTE>
Creates a new menu with the specified label, which can be torn
off from the menu bar.
</BLOCKQUOTE>
<H5>MenuItem, add(MenuItem an_entry)</H5>
<BLOCKQUOTE>
Adds the specified menu item to the menu. You make hierarchical
menus by adding menus to another menu. This is a synchronized
method.
</BLOCKQUOTE>
<H5>add(String label)</H5>
<BLOCKQUOTE>
Adds a new entry to the menu.
</BLOCKQUOTE>
<H5>addSeparator()</H5>
<BLOCKQUOTE>
Adds a separating line to the menu.
</BLOCKQUOTE>
<H5>int, countItems()</H5>
<BLOCKQUOTE>
Returns a count of the number of items in the menu.
</BLOCKQUOTE>
<H5>MenuItem, getItem(int position)</H5>
<BLOCKQUOTE>
Returns the menu item at the specified location.
</BLOCKQUOTE>
<H5>boolean, isTearOff()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the menu
has tear off enabled.
</BLOCKQUOTE>
<H5>remove(int position)</H5>
<BLOCKQUOTE>
Removes the menu item at the specified location. This is a synchronized
method.
</BLOCKQUOTE>
<H5>remove(MenuComponent an_item)</H5>
<BLOCKQUOTE>
Removes the specified menu item. This is a synchronized method.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">MenuItem</FONT></TT> class implements
the functionality of a single entry in a pull-down menu. When
you create one, you have to supply its label (as a string) as
the input parameter. You use the <TT><FONT FACE="Courier">add</FONT></TT>
method to add <TT><FONT FACE="Courier">MenuItem</FONT></TT>s to
menus. The most useful <TT><FONT FACE="Courier">MenuItem</FONT></TT>
methods follow.
</BLOCKQUOTE>
<H5>disable()</H5>
<BLOCKQUOTE>
Grays out a menu item and prevents the user from selecting it.
</BLOCKQUOTE>
<H5>enable()</H5>
<BLOCKQUOTE>
Enables a menu item so the user can select it.
</BLOCKQUOTE>
<H5>enable(boolean some_statement)</H5>
<BLOCKQUOTE>
Enables a menu item if the logical statement evaluates to <TT><FONT FACE="Courier">TRUE</FONT></TT>.
</BLOCKQUOTE>
<H5>StringgetLabel()</H5>
<BLOCKQUOTE>
Returns the item's label.
</BLOCKQUOTE>
<H5>boolean, isEnabled()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the user
can select the item.
</BLOCKQUOTE>
<H5>setLabel(String new_label)</H5>
<BLOCKQUOTE>
Changes the label of the menu item to the specified string.
</BLOCKQUOTE>
<BLOCKQUOTE>
An <TT><FONT FACE="Courier">ACTION_EVENT</FONT></TT> is generated
whenever a menu item is selected by the user.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">CheckboxMenuItem</FONT></TT> class
extends <TT><FONT FACE="Courier">MenuItem</FONT></TT> and implements
the functionality of a menu item with an associated checkbox.
The two methods of this class that will come in handy follow.
</BLOCKQUOTE>
<H5>boolean, getState()</H5>
<BLOCKQUOTE>
Returns <TT><FONT FACE="Courier">TRUE</FONT></TT> if the menu
item is checked.
</BLOCKQUOTE>
<H5>setState(boolean new_state)</H5>
<BLOCKQUOTE>
Sets the state of the menu item.
</BLOCKQUOTE>
<BLOCKQUOTE>
The applet in Listing 17.39 shows how to use menus. It creates
a new frame to support the menu bar because you can't put a menu
bar in an applet itself. The two buttons in the main applet window
enable you to open and close the frame. Figure 17.51 shows the
applet interface. Menus are a good example of how different your
interfaces can look on different platforms. Mac users expect menu
bars to show up at the top of the screen as the focus changes
between windows. As a result, the peer classes on the Mac put
the menu bar at the top of the screen rather than inside the frame,
as a UNIX or Windows user would expect. Although the functionality
is the same as you would see on any other platform, the details
are designed to make Mac users feel comfortable. This is one of
the strong points of Java: users on any platform will see an interface
that looks familiar. Unfortunately, it does mean that you, the
programmer, will have to spend a little extra time thinking about
the implications of these types of differences on your user interface.
</BLOCKQUOTE>
<P>
<A HREF="f17-51.gif" ><B>Figure 17.51 : </B><I>The menu bar.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.39. Using a menu bar.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class menu_test extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Frame f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button b_open, b_close;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean window_visible;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Menu m_about, m_tools,
m_sub;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//these buttons
will allow us to control the new window<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_open = new Button(&quot;Open
Window&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_close = new
Button(&quot;Close Window&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_open);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_close);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make a new frame
because the applet can't have a menu bar<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = new
Frame(&quot;test&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set the initial
size of the frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.resize(200,200);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make a new menu
bar and attach it to the frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MenuBar mb = new
MenuBar();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.setMenuBar(mb);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set up the various
menu items<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_about = new
Menu(&quot;About&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_about.add(new
MenuItem(&quot;Credits&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_about.add(new
MenuItem(&quot;Register&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_about.add(new
MenuItem(&quot;Help&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_tools = new
Menu(&quot;Tools&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_tools.add(new
MenuItem(&quot;Line&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_tools.add(new
MenuItem(&quot;Square&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//add a checkbox
menu item<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_tools.add(new
CheckboxMenuItem(&quot;Dashed Lines&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create a hierarchical
menu<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_sub = new Menu(&quot;Colors&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_sub.add(&quot;Red&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_sub.add(&quot;White&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_sub.add(&quot;Blue&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Make the menu
hierarchical by adding it as though it were a menu<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//item<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_tools.add(m_sub);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mb.setHelpMenu(m_about);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mb.add(m_tools);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mb.add(m_about);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//show the new
frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.show();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window_visible
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String item_name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle mouse
clicks on the two buttons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item_name
= (String)the_arg;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Open
Window&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!window_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window_visible
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item_name.equals(&quot;Close
Window&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(window_visible)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window_visible
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Dialog"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Dialog</FONT></TT></A>
</H2>
<P>
You can build your own dialog boxes using <TT><FONT FACE="Courier">Frame</FONT></TT>s,
but the <TT><FONT FACE="Courier">Dialog</FONT></TT> class enables
you to create modal dialog boxes. A modal dialog box forces the
user to deal with the dialog box before doing anything else. Although
this generally isn't a good idea, certain types of actions, such
as notifying a user of a problem, require user input before the
program can do anything else.
<P>
Dialog boxes are containers, so you can add components to them,
but their default Layout Manager is <TT><FONT FACE="Courier">BorderLayout</FONT></TT>
rather than <TT><FONT FACE="Courier">FlowLayout</FONT></TT>. User
interaction with dialog boxes can generate the <TT><FONT FACE="Courier">WINDOW_DESTROY</FONT></TT>,
<TT><FONT FACE="Courier">WINDOW_ICONIFY</FONT></TT>, <TT><FONT FACE="Courier">WINDOW_DEICONIFY</FONT></TT>,
and <TT><FONT FACE="Courier">WINDOW_MOVED</FONT></TT> events.
As with other window-related classes, you should call the <TT><FONT FACE="Courier">dispose</FONT></TT>
method (inherited from <TT><FONT FACE="Courier">Window</FONT></TT>)
when the window is destroyed in order to free up window system
resources.
<P>
The two dialog creator methods follow.
<H5>new Dialog(Frame a_parent, boolean
modal_flag)</H5>
<BLOCKQUOTE>
Creates a new dialog box that is modal if the second argument
is <TT><FONT FACE="Courier">TRUE</FONT></TT>.
</BLOCKQUOTE>
<H5>new Dialog(Frame a_parent, String
dialog_title, boolean modal_flag)</H5>
<BLOCKQUOTE>
Functions like the preceding method, except that you can specify
the name of the dialog box.
</BLOCKQUOTE>
<BLOCKQUOTE>
Unfortunately, <TT><FONT FACE="Courier">Dialog</FONT></TT>s can
be created only as children of <TT><FONT FACE="Courier">Frame</FONT></TT>s,
as you can see from the arguments to the creator functions. This
might make you think that you can't use <TT><FONT FACE="Courier">Dialog</FONT></TT>s
with your applets but, through the use of a minor subterfuge,
you can. The secret, demonstrated in Listing 17.40, is to make
a <TT><FONT FACE="Courier">Frame</FONT></TT> but not show it.
The applet extends the <TT><FONT FACE="Courier">Dialog</FONT></TT>
class and makes a simple <TT><FONT FACE="Courier">Dialog</FONT></TT>
that is shown in Figure 17.52.
</BLOCKQUOTE>
<P>
<A HREF="f17-52.gif" ><B>Figure 17.52 : </B><I>A dialog box in action.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.40. Using a dialog.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
<BR>
<BR>
public class dialogs extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Frame a_window;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;user_dialog real_dialog;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button show_dialog;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//You need a Frame
to make a dialog but you don't have to display it.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window = new
Frame(&quot;Testing Dialogs&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This is a non-modal
dialog, that is the user can <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//switch between
windows<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//while the dialog
is active.&nbsp;&nbsp;Change the false to true <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//to make it modal
and force<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the user to
deal with and dismiss it before doing anything else.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_dialog =
new user_dialog(a_window,&quot;The Sky Is Falling!&quot;,false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_dialog =
new Button(&quot;Show Dialog&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(show_dialog);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//There's only
one button so we just make sure that a button was clicked<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_dialog.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
class user_dialog extends Dialog {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button b_ok, b_cancel;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;user_dialog(Frame a_frame,String the_title,
boolean modal) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(a_frame,the_title,modal);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowLayout fl;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_ok = new Button(&quot;Ok&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fl = new FlowLayout();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(fl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(b_ok);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//resize the dialog
so the title, &quot;The Sky Is Falling!&quot; <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//shows. You should
use<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//FontMetrics
here to see how many pixels wide that phrase is on a given<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//platform<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(200,40);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Hide
the dialog. If you're not going to use it again you should call
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//window.dispose
to get rid of it. Hide just makes it invisible<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="FileDialog"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">FileDialog</FONT></TT></A>
</H2>
<P>
This class enables you to access the user's native file opening
and saving dialog boxes. It's a modal dialog box that you can
create with the following two creator methods.
<H5>new FileDialog(Frame a_parent, String
title)</H5>
<BLOCKQUOTE>
Creates a file selection modal dialog box with the specified title.
</BLOCKQUOTE>
<H5>new FileDialog(Frame a_parent, String
title, int mode_flag)</H5>
<BLOCKQUOTE>
Functions like the preceding method, except that you can specify,
using the third parameter, whether this is a file selection or
a file saving dialog box. The two constants you should use follow:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">FileDialog.LOAD</FONT></TT>: Open File
dialog box<BR>
<TT><FONT FACE="Courier">FileDialog.SAVE</FONT></TT>: Save File
dialog box
</BLOCKQUOTE>
<BLOCKQUOTE>
The general approach to using this class is to create the dialog
box and then show it when you want the user to select or save
a file. When the user finishes with the modal dialog box, you
use the <TT><FONT FACE="Courier">getDirectory</FONT></TT> and
<TT><FONT FACE="Courier">getFile</FONT></TT> methods to get a
path to the file that's to be saved or loaded. The methods you'll
find most useful for <TT><FONT FACE="Courier">FileDialog</FONT></TT>
follow.
</BLOCKQUOTE>
<H5>String, getDirectory()</H5>
<BLOCKQUOTE>
Returns the directory to the file the user has selected or the
directory where the user wants to save a file. The string uses
backslashes to separate directories and it doesn't end with a
backslash. A file on disk Space inside folder Files, for example,
would return <TT><FONT FACE="Courier">/Space/Files</FONT></TT>.
</BLOCKQUOTE>
<H5>String, getFile()</H5>
<BLOCKQUOTE>
Returns the name of the file to be opened or the name the file
is to be saved as.
</BLOCKQUOTE>
<H5>FilenameFilter, getFilenameFilter()</H5>
<BLOCKQUOTE>
Returns the <TT><FONT FACE="Courier">FilenameFilter</FONT></TT>-an
interface specification that enables you to filter which files
appear in the dialog box-associated with the File dialog box.
</BLOCKQUOTE>
<H5>int, getMode()</H5>
<BLOCKQUOTE>
Returns the mode of the dialog box.
</BLOCKQUOTE>
<H5>setDirectory(String default_directory)</H5>
<BLOCKQUOTE>
Enables you to set the directory the user sees when the dialog
box opens. Specify the directory with the same string format returned
by the <TT><FONT FACE="Courier">getDirectory</FONT></TT> method.
</BLOCKQUOTE>
<H5>setFile(String a_file)</H5>
<BLOCKQUOTE>
Sets the file in the dialog box.
</BLOCKQUOTE>
<H5>setFilenameFilter(FilenameFilter
a_filter)</H5>
<BLOCKQUOTE>
Associates an instance of the <TT><FONT FACE="Courier">FilenameFilter</FONT></TT>
with the dialog box. The one method in the <TT><FONT FACE="Courier">FilenameFilter</FONT></TT>
class is called for every file, and only those that pass the test
are displayed.
</BLOCKQUOTE>
<BLOCKQUOTE>
The applet in Listing 17.41 generates the two File dialog boxes
shown in Figures 17.53 and 17.54, depending on the second parameter
in the creation function.
</BLOCKQUOTE>
<P>
<A HREF="f17-53.gif" ><B>Figure 17.53 : </B><I>The File Open dialog box with the mode set to </I><B>FileDialog.Load.</B></A>
<P>
<A HREF="f17-54.gif" ><B>Figure 17.54 : </B><I>The File Save dialog box with the mode set to </I><B>FileDialog.Save.</B></A>
<HR>
<BLOCKQUOTE>
<B>Listing 17.41. Generating File dialog boxes.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.Applet;<BR>
import java.io.*;<BR>
<BR>
<BR>
public class file_dialog extends Applet<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Frame a_window;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FileDialog real_dialog;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Button show_dialog;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//You need a Frame
to make a dialog but you don't have to display it.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_window = new
Frame(&quot;Testing Dialogs&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//This is a dialog
that lets you save files. By changing <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the last parameter
to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// FileDialog.LOAD
you'll get a dialog that lets you open a file.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_dialog =
new FileDialog(a_window,&quot;Save File to:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_dialog =
new Button(&quot;Show File Dialog&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(show_dialog);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean action(Event the_event,
Object the_arg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//There's only
one button so we just make sure that a button was clicked<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(the_event.target
instanceof Button) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_dialog.show();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
a_file = real_dialog.getFile();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
a_directory = real_dialog.getDirectory();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a_directory
+ &quot; &quot; + a_file);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">FilenameFilter</FONT></TT> interface
is very simple; it has only one method:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean, accept(File directory, String
file_name)</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This is called for each file. The input parameters are the directory
the file is in and the filename. You can use this information
to decide whether a file should be shown in the dialog box. If
the method returns <TT><FONT FACE="Courier">TRUE</FONT></TT>,
the file is shown.
</BLOCKQUOTE>
<BLOCKQUOTE>
You can implement a <TT><FONT FACE="Courier">FilenameFilter</FONT></TT>
as shown in Listing 17.42.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 17.42. Implementing a </B><TT><B><FONT FACE="Courier">FilenameFilter</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class my_filenameFilter implements
FilenameFilter {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my_filenameFilter() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean accept(File a_directory,
String file_name) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//some code to
decide if the file should be displayed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">FilenameFilter</FONT></TT>s are useful
in preventing a user from inadvertently picking the wrong file.
</BLOCKQUOTE>
<H2><A NAME="WorkingwithApplications"><FONT SIZE=5 COLOR=#FF0000>Working
with Applications</FONT></A></H2>
<P>
Although all the examples in this chapter have been applets (a
conscious choice because most of the current excitement about
Java is related to its role in the WWW), you can use almost all
these techniques in an application. Unless you're using applet-specific
methods, you can replace <TT><FONT FACE="Courier">Applet</FONT></TT>
with <TT><FONT FACE="Courier">Panel</FONT></TT>. So, instead of
extending <TT><FONT FACE="Courier">Applet</FONT></TT>, you extend
<TT><FONT FACE="Courier">Panel</FONT></TT>. You also can still
extend the <TT><FONT FACE="Courier">Applet</FONT></TT> class but
put the <TT><FONT FACE="Courier">Applet</FONT></TT> into a <TT><FONT FACE="Courier">Frame</FONT></TT>.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An example of an applet-specific method is <TT><FONT FACE="Courier">getImage</FONT></TT>. In an application, you can use the <TT><FONT FACE="Courier">Toolkit</FONT></TT>'s <TT><FONT FACE="Courier">getImage</FONT></TT> method instead and everything else stays the same.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Remember that <TT><FONT FACE="Courier">Applet</FONT></TT> inherits from <TT><FONT FACE="Courier">Component</FONT></TT>, so you can place an applet in a container-such as a frame-just as you would put a button in the frame.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The general approach is to add a main method to your code, create
a <TT><FONT FACE="Courier">Frame</FONT></TT>, add your class that
extends <TT><FONT FACE="Courier">Applet</FONT></TT> or <TT><FONT FACE="Courier">Panel</FONT></TT>
to the <TT><FONT FACE="Courier">Frame</FONT></TT>, and then call
the <TT><FONT FACE="Courier">init</FONT></TT> and <TT><FONT FACE="Courier">startup</FONT></TT>
methods for the class that extends <TT><FONT FACE="Courier">Applet</FONT></TT>.
Make sure that the event handler for the <TT><FONT FACE="Courier">Frame</FONT></TT>
handles the <TT><FONT FACE="Courier">WINDOW_DESTROY</FONT></TT>
method properly.
<H2><A NAME="AppletMethodsofInterest"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Applet</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Methods of Interest</FONT></A></H2>
<P>
Most of what's covered in this chapter is independent of the <TT><FONT FACE="Courier">Applet</FONT></TT>
class's methods. The following are the methods that are of use
when building the user interface.
<H5>Image, getImage(URL a_url)</H5>
<BLOCKQUOTE>
Loads the GIF or JPEG image at the specified URL.
</BLOCKQUOTE>
<H5>Image, getImage(URL a_url, String
relative_file_location)</H5>
<BLOCKQUOTE>
Enables you to specify a base URL, as you would get from <TT><FONT FACE="Courier">getDocumentBase()</FONT></TT>,
and an address relative to that address.
</BLOCKQUOTE>
<H5>showStatus(String a_message)</H5>
<BLOCKQUOTE>
Displays the specified message to the user. In the applet viewer,
it's placed in the bottom edge of the applet window. The specific
place where the display occurs is browser dependent.
</BLOCKQUOTE>
<BLOCKQUOTE>
Clearly, you can build pretty much any Java program that doesn't
rely on these methods, so switching between applets and applications
shouldn't be too difficult as far as your GUI is concerned.
</BLOCKQUOTE>
<H2><A NAME="ExtendingtheAWT"><FONT SIZE=5 COLOR=#FF0000>Extending
the AWT</FONT></A></H2>
<P>
You can add more elements to your interface toolbox in two ways:
you can extend existing components yourself or you can use someone
else's classes.
<H3><A NAME="ExtendingComponentstheImageButton">Extending Components
(the Image Button)</A></H3>
<P>
One of the nice features of object-oriented programming is that
you can extend existing classes and add new functionality with
minimal effort. The applet in Listing 17.43 contains the code
for a class called <TT><FONT FACE="Courier">image_button_component</FONT></TT>,
which behaves like a button but has an image for its interface
rather than the regular button picture.
<HR>
<BLOCKQUOTE>
<B>Listing 17.43. The </B><TT><B><FONT FACE="Courier">image_button_component</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.applet.Applet;<BR>
import java.awt.*;<BR>
<BR>
<BR>
public class image_button extends Applet {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MediaTracker the_tracker;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;image_button_component&nbsp;&nbsp;the_button;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image the_picture,
inverse_picture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//load the two
images, one for the regular <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//button image
and one for when the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//mouse button
is held down on the button<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker =
new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_picture =
getImage(getDocumentBase(),&quot;test.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(the_picture,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverse_picture
= getImage(getDocumentBase(),&quot;invert.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.addImage(inverse_picture,0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Wait until both
images are fully loaded.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_tracker.waitForID(0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch(InterruptedException
e) {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the_button = new
image_button_component(the_picture,inverse_picture);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(the_button);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event e, int
x, int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof
image_button_component) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;image_button_component
clicked&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class image_button_component extends Canvas {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image my_image, inverse_image;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean mousedown_flag;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public image_button_component(Image an_image,Image
i_image) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_image = an_image;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverse_image
= i_image;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the button starts
unclicked<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mousedown_flag
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//make sure the
canvas image is drawn<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//override these methods to tell the layout
manager <BR>
&nbsp;&nbsp;&nbsp;&nbsp;//the size of the button which is defined
by the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//size of the image. This assumes that
the two images are the same size.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Dimension minimumSize() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Dimension(my_image.getWidth(null),my_image.getHeight(null));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Dimension preferredSize() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Dimension(my_image.getWidth(null),my_image.getHeight(null));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//make sure the button image is changed
when the mouse is clicked<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean mouseDown(Event e, int
x, int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mousedown_flag
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//return false
so the event is passed on so the mouseDown <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//method in the
applet can use it<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean mouseUp(Event e, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mousedown_flag
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//return true
because the applet doesn't need this <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//event but you
might want to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//return false
to make this more button like<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//determine which
image to draw based on the mouse state<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!mousedown_flag)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(my_image,0,0,null);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(inverse_image,0,0,null);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The applet loads in two images-one for the regular button and
one for when it's clicked-and then creates a new instance of the
<TT><FONT FACE="Courier">image_button_component</FONT></TT> class.
The button is shown in Figure 17.55, whereas Figure 17.56 shows
the button after being clicked with the mouse. Although this class
doesn't do much, you can put in whatever behavior you want just
as though it were a standard button.
<P>
<A HREF="f17-55.gif" ><B>Figure 17.55 : </B><I>An image button.</I></A>
<P>
<A HREF="f17-56.gif" ><B>Figure 17.56 : </B><I>The same image button after being clicked with the mouse.</I></A>
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
One technique to note is that you can assign multiple images to the same <TT><FONT FACE="Courier">MediaTracker</FONT></TT> ID and then just wait for that one ID to finish loading instead of looking for multiple IDs to load. Of course, if speed is a concern, you might want to load the basic image first, draw the interface, and then hope that the user doesn't click the button until the second image is loaded. You can use an even better solution if you're working with a <TT><FONT FACE="Courier">Frame</FONT></TT>. You can load the first image, draw the interface, and then set the cursor to <TT><FONT FACE="Courier">WAIT_CURSOR</FONT></TT> until the second image is loaded. Users will be able to start familiarizing themselves with the interface while the second image is loading.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="UsingOtherPeoplesClasses">Using Other People's Classes</A>
</H3>
<P>
Although you can improve the AWT by extending its classes, you're
probably better off buying that sort of thing from someone else
if the functionality you require is very complex. The following
list is a very limited one of various commercial Java classes
that bring more sophisticated interfaces to your toolbox. Inclusion
in this list shouldn't be viewed as an endorsement. Java has too
many bugs, and these tools run afoul of them, for anyone to make
definitive statements about the quality of any given package.
In addition, things are changing too rapidly to give complex software
libraries like these an in-depth evaluation and still get this
book out before 1998. View this list as a set of starting points
for your search for work-saving classes to jazz up your Java program's
interface.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
One thing to keep in mind when looking at these classes is that, unlike the AWT, they have to be downloaded from the server if you're using them in an applet. Because some of these files are large, it could be a problem if the people who will be viewing your applet have slow connections.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In general, all the components have many more methods and adjustable parameters than I mention here. If you see a component that seems in the ballpark for meeting your requirements, check with the vendor for more details.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H6>Microline Component Toolkit<BR>
(<TT>info@mlsoft.com <A TARGET="resource window" HREF="http://www.mlsoft.com/mct/mct.html">http://www.mlsoft.com/mct/mct.html</A></TT>)
</H6>
<BLOCKQUOTE>
This is a commercial toolkit that comes with a nice printed manual
to help you understand how to use it. Table 17.2 lists the primary
components.<BR>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 17.2. Microline Component Toolkit components.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=99><I>Component</I></TD><TD WIDTH=491><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Grid</FONT></TT></TD>
<TD WIDTH=491>A two-dimensional scrolling array of cells, much like a standard spreadsheet. This type of interface component also can be called a table.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Misc</FONT></TT></TD>
<TD WIDTH=491>Includes methods to draw shadows and word-wrap text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Progress</FONT></TT>
</TD><TD WIDTH=491>A customizable progress bar.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">TabPanel</FONT></TT>
</TD><TD WIDTH=491>A tabbed panel that enables you to switch between window contents by clicking on tabs at the top of the window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Tree</FONT></TT></TD>
<TD WIDTH=491>A hierarchical view where you can show and hide the items inside containers. If you want to show a file structure, for example, the folders would have arrows next to them. After you click on an arrow, the items in the folder are shown.
</TD></TR>
</TABLE></CENTER>
<P>
<H6>Jlibraries<BR>
(<TT><A TARGET="resource window" HREF="http://www.roguewave.com/products/jlibraries/jlibraries.html">http://www.roguewave.com/products/jlibraries/jlibraries.html</A></TT>)
</H6>
<BLOCKQUOTE>
This is a set of three libraries: one with tools, one with financial
functions, and one with widgets. Table 17.3 lists the main widgets.
<BR>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 17.3. Jlibraries main widgets.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=142><I>Widget</I></TD><TD WIDTH=449><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142>Grid control</TD><TD WIDTH=449>A spreadsheet-like widget.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142>Group box</TD><TD WIDTH=449>Enables you to group related sets of controls.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142>Image button</TD><TD WIDTH=449>Enables you to create an image button.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142>Tabbed dialog box</TD><TD WIDTH=449>A dialog box with tabs on the top that enable you to switch between screens.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142>Toolbar</TD><TD WIDTH=449>A toolbar with icons.
</TD></TR>
</TABLE></CENTER>
<P>
<H6>Connect! Widgets Pro<BR>
(<TT><A TARGET="resource window" HREF="http://www.connectcorp.com/Index.html">http://www.connectcorp.com/Index.html</A></TT><FONT SIZE=1>)</FONT>
</H6>
<BLOCKQUOTE>
This is a very extensive kit of useful widgets. Although it's
expensive, if you use many of the widgets you'll save a lot of
time. The lack of printed documentation is a drawback but not
too horrible. Table 17.4 lists these widgets.<BR>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 17.4. Connect! Widgets Pro widgets.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=186><I>Widget</I></TD><TD WIDTH=405><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>3D label</TD><TD WIDTH=405>Same functionality as label, but with a 3D look and text coloring.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Calendar</TD><TD WIDTH=405>Shows a calendar for a specified date.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Combo box</TD><TD WIDTH=405>An editable, searchable text field with a drop-down listbox. There are some platform dependencies in this one.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Direction button</TD><TD WIDTH=405>Makes a button with an arrow pointing in the specified direction.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Editable, searchable </TD><TD WIDTH=405>An enhanced choice control.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Choice listbox</TD><TD WIDTH=405></TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Enhanced text fields</TD><TD WIDTH=405>Components that restrict the type of data that can be entered.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Grid control</TD><TD WIDTH=405>An option in the multicolumn listbox.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Group box panel</TD><TD WIDTH=405>A panel with a label and a visual boundary.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Image buttons</TD><TD WIDTH=405>Enables you to associate different images with different button states-Normal, Pressed, and Disabled-and the position of the image with respect to the button text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Image canvas</TD><TD WIDTH=405>A picture button type of widget.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Image listbox</TD><TD WIDTH=405>A standard listbox, but you can add images to each of the entries.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Key Press Manager panel</TD><TD WIDTH=405>Extends panel and supports tabbing between components and some key accelerators.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Multicolumn listbox</TD><TD WIDTH=405>A listbox with multiple columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Performance Animator</TD><TD WIDTH=405>A class that makes an animation from a single image file that saves download time, hence improving performance.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Pop-up context menu</TD><TD WIDTH=405>A better version than the one in the AWT.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Progress gauge</TD><TD WIDTH=405>A 3D color progress indicator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Scrolling panel</TD><TD WIDTH=405>A panel with built-in scrolling.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Spin control</TD><TD WIDTH=405>Spin control and list spin control widgets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Splitter panel</TD><TD WIDTH=405>A panel that is split into subareas, each of which can be a splitter panel. Nice for rectangular-style layouts.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186>Tab panel</TD><TD WIDTH=405>A standard tab dialog box widget.
</TD></TR>
</TABLE></CENTER>
<P>
<H6>jKit/Grid<BR>
(<TT><A TARGET="resource window" HREF="http://www.objectshare.com/">http://www.objectshare.com/</A></TT>)
</H6>
<BLOCKQUOTE>
This is a table component.
</BLOCKQUOTE>
<H6>JavaGRID<BR>
(<TT><A TARGET="resource window" HREF="http://www.vincent.se/Products/JavaGRID/JavaGRID.html">http://www.vincent.se/Products/JavaGRID/JavaGRID.html</A></TT>)
</H6>
<BLOCKQUOTE>
This is another table component.
</BLOCKQUOTE>
<BLOCKQUOTE>
In addition to widget and utility collections such as these, a
number of data display collections exist that have various charting
types, such as bar and pie charts.
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned how to build the user interface for
Java applets and applications using the AWT. You saw how to draw
pictures using the <TT><FONT FACE="Courier">Graphics</FONT></TT>
class and how to use the various GUI elements, such as buttons
and menus, to give your project an easy-to-use interface that
uses the graphical look and feel users are used to. Finally, you
saw how to extend that interface and what sorts of freeware, shareware,
and commercial tools are available to enhance the basic AWT repertoire
of interface widgets.
<P>
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>

<!-- reference library footer #1-->
</CENTER>
<IMG SRC="/images/rule.gif" WIDTH="460" HEIGHT="5" VSPACE="5"
ALT="Ruler image"><br>

<FONT SIZE="-1">

Contact <a href="mailto:reference@developer.com">
reference@developer.com</a> with questions or comments.<br>


<a href="/legal/">
Copyright 1998</a> 
<a href="http://www.earthweb.com" target="_top">
EarthWeb Inc.</a>,  All rights reserved.<BR>
PLEASE READ THE <a href="/reference/usage.html">ACCEPTABLE USAGE STATEMENT</a>.
<BR>
Copyright 1998 Macmillan Computer Publishing. All rights reserved.
</FONT>
</BLOCKQUOTE>


<!--outer table--><TD VALIGN="TOP">

<!--right side ads -->
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD1.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD1.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>
<a target="resource window" href="http://adserver.developer.com/cgi-bin/accipiter/adclick.exe/AREA=DCAD2.REF" alt="Click here for more info"><img src="http://adserver.developer.com/cgi-bin/accipiter/adserver.exe/AREA=DCAD2.REF" alt="Click here for more info" height="88" width="88" border="0"></a>
<P>



</td>
</tr>
</table>
</BODY>
</HTML>



