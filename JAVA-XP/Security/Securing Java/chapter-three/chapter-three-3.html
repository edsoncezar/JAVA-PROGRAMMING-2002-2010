<html>
<head>
<title>Signed Code (Ch. 3, Sec. 3) [Securing Java]</title>
<META NAME="description" CONTENT="Securing Java: Getting Down to Business with Mobile Code.  This is the online version of the print book, featuring a searchable index, java links, and the full text of the book."> 

<META NAME="keywords" CONTENT="java security,mobile code,sandbox,applets,smart cards,Gary McGraw,Edward Felten">

</head>
<body background="..\images\back-poss.jpg" bgcolor="#FFFFFF" text="#37371C" link="#FF0000" vlink="#820000" alink="#008080">

<center>
<table width="90%" bgcolor="#F5F5F5" cellspacing=0 cellpadding=0>
<tr><td> 
<a href="..\order.html"><img src="..\images\buyit.gif" width=100 height=45 border=0 alt="BUY IT!"></a>

<center>


<img src="..\images\chapt-three.gif" width=593 height=63 border=0 alt="Securing Java">
</center>
<br clear=all>
<center>
<table border=0 width=100%><tr><td width=60 align=center>
<a href="chapter-three-2.html">
<img src="..\images\arrow6.gif" width=60 height=60 border=0 align="middle" alt="Previous Page"><br>
<font size="-2" face="Helvetica,sans-serif">Previous Page</font></a>
</td><td align=center><font size="+2" color="#000000"><b>Beyond the Sandbox: Signed Code and Java 2
</b></font><br>

<b>CHAPTER SECTIONS:</b> <a href="chapter-three-1.html">1</a> / <a href="chapter-three-3.html">2</a> / <b>3</b> / <a href="chapter-three-4.html">4</a> / <a href="chapter-three-5.html">5</a> / <a href="chapter-three-6.html">6</a> / <a href="chapter-three-7.html">7</a> / <a href="chapter-three-8.html">8</a><p>

<font size="+2" color="#000000"><b>Section 3 -- Signed Code</b></font>
</td><td width=60 align=center>
<a href="chapter-three-4.html">
<img src="..\images\arrow7.gif" width=60 height=60 border=0 align="middle" alt="Next Page"><br>
<font size="-2" face="Helvetica,sans-serif">Next Page</font></a>
</td></tr></table>
</center><p>


The capability to digitally sign Java byte code (at least byte code files placed in a Java archive, called a JAR file) was introduced with JDK 1.1 and greatly expanded with Java 2. Digital signing capability is an important part of the new Java security regimen. This is exciting because digital signing radically alters the amount of trust you can place in a piece of code. A Tutorial on signing Java code with the current tools from Microsoft, Netscape, and Sun can be found in <a href="..\appdx-c\index.html">Appendix C</a>.<p>

One particular kind of cryptography tool allows a chunk of digital information (including, of course, Java byte code) to be signed by a person or organization. See Figure 3.1. Because a digital signature has special mathematical properties, it is difficult to forge. Your browser can verify a signature, allowing you to be fairly certain that a particular person or organization vouches for the code. That means you can instruct your browser always to accept applets signed by some party that you trust, or always to reject applets signed by some party that you don't trust. Same thing goes for a nonbrowser-based VM, which can be instructed (through policy) how to treat application code signed by particular entities.<p>

It is important to recognize that even if you know exactly which Web pages you are visiting and who created them, you probably don't know who wrote each applet that appears on the pages you visit. Applets are shuffled around on the Net like Beanie Babies in a fifth-grade classroom.<p>

Contrary to popular belief, you don't always know where information is coming from on the Internet. A nasty attack called IP spoofing allows a bad guy to send you network traffic that claims to come from someplace else. For instance, you might think the traffic is coming from "whitehouse.gov", when it's really coming from "cracker.org". IP spoofing used to be considered just a theoretical possibility, but it has actually happened in recent years. The best-known example is an attack by the infamous cracker Kevin Mitnick on a machine managed by computer security worker Tsutomu Shimomura.  Mitnick's attack led to his eventual capture and conviction [Shimomura and Markoff, 1996].<p>

An attack known as Web spoofing shows that even in the absence of IP spoofing, it is not always clear that you are visiting the site you may think you're visiting [Felten, et al., 1997]. An attacker can lure you into a "false Web" that looks just like the real one, except that the attacker can see everything you do, including anything you type into a form, and the attacker can modify the traffic between you and any Web server. All of this is possible even if your browser tells you that you have a "secure" connection. See Figure 3.2.<p>

<center>
<table border=0 width=370><tr><td>
<img src="..\images\fig03.02.gif" width=370 height=214 alt="Fig 3.2"><br>
<font size="-2" face="Helvetica"><p>
<center><b>Figure 3.2  A Web Spoofing attack can be carried out with extensive use of a browser's mobile code capability.</b></center><br>
The Princeton Team has implemented a demonstration of Web Spoofing that makes extensive use of JavaScript. Once an attacker has lured the victim to the attack server (shown as www.attacker.org), the attacker can control the victim's view of the Web by acting as a rewriting proxy. Clever use of JavaScript makes all changes invisible to the victim and can even appear to offer encrypted traffic.
</font>
</td></tr></table>
</center>
<p>

Even if you ignore the possibility of spoofing, using the return address of an applet (that is, knowing the Web site where you got the applet code) still isn't good enough to base a trust decision on. A digital signature holds much more information. For example, such a signature could tell you that although the applet is being redistributed by a site you don't trust, it was originally signed by someone you do trust. Or it can tell you that although the applet was written and distributed by someone you don't know, your friend has signed the applet, attesting that it is safe. Or perhaps it can simply tell you which of the thousands of users at aol.com signed the applet.<p><br>


<center><font size="+1"><b>Digital Signatures</b></font></center><p>

So how do you sign a piece of code? The key to certification and authentication is the use of digital signatures. The idea is simple: to provide a way for people to sign electronic documents so that these signatures can be used in the same way we use signatures on paper documents. In order to be useful, a digital signature should satisfy five properties [Schneier, 1995]. It should be:
<OL>
	<LI>Verifiable: Anyone should be able to validate a signature.
	<LI>Unforgeable: It should be impossible for anyone but you to attach your signature to a document.
	<LI>Nonreusable: It should be impossible to "lift'' a signature off one document and attach it to another.
	<LI>Unalterable: It should be impossible for anyone to change the document after it has been signed, without making the signature invalid.
	<LI>Nondeniable: It should be impossible for the signer to disavow the signature once it is created.
</OL>

Mathematicians and computer scientists have devised several digital signature schemes that appear to work quite well. The full details are very technical. If you're interested in learning more about such schemes, Bruce Schneier's excellent book, Applied Cryptography, is a good place to start [Schneier, 1995].<p>

The digital signatures used for Java code are based on public-key cryptography. If Alice wants to be able to sign documents, she must first use a special mathematical technique to generate two large numbers: her own private key, and her public key. As the names suggest, Alice keeps her private key to herself. Keeping it secret is essential. Her public key, however, is announced to the world.<p>

Alice's private key is used for signing electronic documents. Her public key is used to verify those signatures. See Figure 3.1. Anyone who knows the private key (hopefully only Alice!) can run a special computation involving the document and Alice's private key. The result of this process is a digitally signed version of the document. <p>

Anyone who knows Alice's public key can verify her signature by running a special computation involving the signed document and Alice's public key. Since only Alice knows the private key, she is the only one who can put her signature on documents. Since everyone knows her public key, anyone can verify that the signature is hers.<p>

Everything sounds great. You tell your browser to trust applets signed by Alice by registering Alice's public key. Whenever applets claim to come from Alice, the browser can verify that claim by comparing the registered public key to the signed applet. If the applet is not from Alice, it can be rejected.<p><br>


<center><font size="+1"><b>Key Distribution</b></font></center><p>

But how do you know what Alice's public key is?<p>

If you know Alice, she can call you on the phone and tell you her public key. In this case, you will know the key is valid because you recognize Alice's voice. This doesn't work if you don't know Alice. How do you know the person on the other end of the phone is Alice? Maybe it's Alice's evil twin Zelda, trying to pass off Zelda's public key as Alice's so she can forge Alice's signature.<p>

One way around this problem is to ask Alice's twin brother Allan to help. Alice can create a document containing her public key and have Allan sign that document. If you trust Allan and you know Allan's public key, then the document tells you reliably what Alice's public key is.<p>

But how do you know Allan's public key? You can't ask Alice and Allan to vouch for each other's public keys, because Zelda could create a false Alice key and a false Allan key and use them to sign documents vouching for each other! This leaves us stuck with a chicken-and-egg problem.<p>

The usual solution is to use a certification authority (CA). The CA, Claire in our example, is in the business of certifying keys. Alice goes to the CA's office with her birth certificate, passport, driver's license, and DNA sample. Once she has convinced Claire that she really is Alice, she tells Claire her public key, and Claire signs an electronic document that contains Alice's public key. That document serves as an electronic credential for Alice.<p>

After Alice has a credential, key distribution is much easier. Alice can plaster copies of her credential everywhere: on bulletin boards, on her homepage, and at the end of every email message she sends. Better yet, whenever Alice signs a document, she can attach a copy of her credential to the signed document. On receiving the document, you can first check the credential by verifying Claire's signature, and then verify Alice's signature using the public key included with the document. Zelda can't trick you into accepting a bogus public key for Alice, because she can't forge Claire's signature. Figure 3.3 shows the process by which a signature on a piece of signed code can be validated.<p>

<center>
<table border=0 width=318><tr><td>
<img src="..\images\fig03.03.gif" width=318 height=134 alt="Fig 3.3"><br>
<font size="-2" face="Helvetica"><p>
<center><b>Figure 3.3  Validating a signature on signed code.</b></center><br>
In this example, a piece of code is signed by the private key of thing1. The corresponding public key, available on thing1's certificate can be used to validate the signature carried by the code. For added security and to make key management more reasonable, browsers typically validate the CA signature carried on the certificate.
</font>
</td></tr></table>
</center>
<p>

The beauty of this approach is that if everyone can visit Claire and get a credential, then no one has to remember any keys except for his or her own private key (to sign documents), and Claire's public key (to verify credentials). There are still two problems, though. Everyone must trust Claire. As the authority, she can impersonate anyone. And you still need a reliable way to get Claire's public key. It doesn't help to have Claire get a credential from Claire's mom, Elena. You would have no more reliable way of knowing who Elena is.<p>

There is no technological solution to this. Claire's key will probably be hard-wired into your browser software, or entered by support staff at install time. As long as you get a valid copy of the browser, and no one has messed with your hard disk, everything will be okay. How do you know you have a valid copy of the browser? It will be signed by the browser vendor. How do you know the browser vendor's signature is valid? Don't ask-there lies madness.<p><br>


<center><font size="+1"><b>What Signing Can't Do</b></font></center><p>
Even if the signing and signature-checking mechanisms work perfectly and are able to reveal who signed each applet, a huge unsolved problem still remains. Technology can tell you who signed an applet, but it can't tell you whether that person is trustworthy. That's a decision you have to make based on human judgment. And you'd better make the right decision.<p>


<center>
<table width=95%>
<tr>
<td width=60 align=center>
<a href="chapter-three-2.html">
<img src="..\images\arrow6.gif" width=60 height=60 border=0 align="middle" alt="Previous Page"><br>
<font size="-2" face="Helvetica,sans-serif">Previous Page</font></a>
</td><td align=center>
<center>
<FORM METHOD=post ACTION="/cgi-bin/texis/webinator/newsearch/">
<font size="-1" face="Helvetica">
<INPUT TYPE="text" NAME="arg" SIZE=25></font><br>
<INPUT TYPE="hidden" NAME=proximity VALUE="rank">
<INPUT TYPE="hidden" NAME=suffixproc VALUE="max">
<INPUT TYPE="hidden" NAME="db" value="db9">
<INPUT NAME=cmd TYPE=submit VALUE="Search the Book"><br>
<font size="-1" face="Arial">
<a href="http://www.rstcorp.com/searchhelp.html">Search Help</a></font></FORM>
</center>

</td><td width=60 align=center>
<a href="chapter-three-4.html">
<img src="..\images\arrow7.gif" width=60 height=60 border=0 align="middle" alt="Next Page"><br>
<font size="-2" face="Helvetica,sans-serif">Next Page</font></a>
</td></tr></table>
</center>

<hr>
<p><br>

<map name="menu">
<area shape="RECT" coords="4,16,116,35" href="..\toc.html">
<area shape="RECT" coords="11,37,105,57" href="..\preface.html">
<area shape="RECT" coords="198,13,218,50" href="..\chapter-one\index.html">
<area shape="RECT" coords="226,12,248,41" href="..\chapter-two\index.html">
<area shape="RECT" coords="253,17,274,50" href="index.html">
<area shape="RECT" coords="279,27,301,59" href="..\chapter-four\index.html">
<area shape="RECT" coords="308,16,329,49" href="..\chapter-five\index.html">
<area shape="RECT" coords="335,9,357,41" href="..\chapter-six\index.html">
<area shape="RECT" coords="362,17,381,48" href="..\chapter-seven\index.html">
<area shape="RECT" coords="387,27,410,59" href="..\chapter-eight\index.html">
<area shape="RECT" coords="414,17,438,50" href="..\chapter-nine\index.html">
<area shape="RECT" coords="519,11,593,32" href="..\..\www.securingjava[1].com\index.html">
<area shape="RECT" coords="538,36,593,58" href="..\help.html">
</map>

<center>
<img src="..\images\menumap3.gif" width=600 height=75 border=0 alt="Menu Map -- Text links below" usemap="#menu" ismap><p>
<font size="-1" face="Helvetica,Arial">
Chapter... <a href="..\preface.html">Preface</a> -- <a href="..\chapter-one\index.html">1</a> -- <a href="..\chapter-two\index.html">2</a> -- <a href="index.html">3</a> -- <a href="..\chapter-four\index.html">4</a> -- <a href="..\chapter-five\index.html">5</a> -- <a href="..\chapter-six\index.html">6</a> -- <a href="..\chapter-seven\index.html">7</a> -- <a href="..\chapter-eight\index.html">8</a> -- <a href="..\chapter-nine\index.html">9</a> -- <a href="..\appdx-a\index.html">A</a> -- <a href="..\appdx-b\index.html">B</a> -- <a href="..\appdx-c\index.html">C</a> -- <a href="..\references\index.html">Refs</a><br>

<a href="..\..\www.securingjava[1].com\index.html">Front</a> -- <a href="..\toc.html">Contents</a> -- <a href="..\help.html">Help</a>
</font>
</center>

<p align=right>
<font size="-7" face="Helvetica,Arial,sans-serif">
Copyright &copy;1999 Gary McGraw and Edward Felten.<br>
All rights reserved.<br>
Published by <a href="http://www.wiley.com/">John Wiley &amp; Sons, Inc.</a>
</font>

</td>
</tr></table>


</body>
</html>

