<html>
<head>
<title>How Does the Use of Java Impact Smart Card Security? (Ch. 8, Sec. 7) [Securing Java]</title>
<META NAME="description" CONTENT="Securing Java: Getting Down to Business with Mobile Code.  This is the online version of the print book, featuring a searchable index, java links, and the full text of the book."> 

<META NAME="keywords" CONTENT="java security,mobile code,sandbox,applets,smart cards,Gary McGraw,Edward Felten">

</head>
<body background="..\images\back-poss.jpg" bgcolor="#FFFFFF" text="#37371C" link="#FF0000" vlink="#820000" alink="#008080">

<center>
<table width="90%" bgcolor="#F5F5F5" cellspacing=0 cellpadding=0>
<tr><td> 
<a href="..\order.html"><img src="..\images\buyit.gif" width=100 height=45 border=0 alt="BUY IT!"></a>

<center>


<img src="..\images\chapt-eight.gif" width=593 height=63 border=0 alt="Securing Java">
</center>
<br clear=all>
<center>
<table border=0 width=100%><tr><td width=60 align=center>
<a href="chapter-eight-6.html">
<img src="..\images\arrow6.gif" width=60 height=60 border=0 align="middle" alt="Previous Page"><br>
<font size="-2" face="Helvetica,sans-serif">Previous Page</font></a>
</td><td align=center><font size="+2" color="#000000"><b>Java Card Security: How Smart Cards and Java Mix
</b></font><br>

<b>CHAPTER SECTIONS:</b> <a href="chapter-eight-1.html">1</a> / <a href="chapter-eight-2.html">2</a> / <a href="chapter-eight-3.html">3</a> / <a href="chapter-eight-4.html">4</a> / <a href="chapter-eight-5.html">5</a> / <a href="chapter-eight-6.html">6</a> / <b>7</b> / <a href="chapter-eight-8.html">8</a><p>

<font size="+2" color="#000000"><b>Section 7 -- How Does the Use of Java Impact Smart Card Security?</b></font>
</td><td width=60 align=center>
<a href="chapter-eight-8.html">
<img src="..\images\arrow7.gif" width=60 height=60 border=0 align="middle" alt="Next Page"><br>
<font size="-2" face="Helvetica,sans-serif">Next Page</font></a>
</td></tr></table>
</center><p>


Much of the base security model found in Java's JDK 1.0.2 (and explained in Chapter 2) is not present in Card Java. For example, Card Java has no Security Manager class. This means the whole concept of security for Card Java applets is significantly different from the case of applets running on a standard browser-based VM. Fortunately, some of Card Java's "missing parts" may actually enhance the security situation; unfortunately, some of the changes introduce new security risks.<p><br>


<center><font size="+1"><b>How Card Java Lessens Security Risks</b></font></center><p>

One of the most difficult problems in Java security is figuring out how to preserve type safety, while at the same time allowing dynamic class loading (see Chapter 2). If you can confuse the VM about the types of objects it is manipulating, you can break the security model. In its current form, Card Java takes care of this problem by removing dynamic class loading, making type safety easier to enforce. Class loading has always been problematic in Java and has introduced a number of serious security holes. Because it has no dynamic class loading, Card Java is less risky than regular Java from this perspective.<p>

Another constraint imposed by Card Java, lack of threading, makes security analysis of applet code much easier than it is normally. Threading is difficult to implement properly and to use properly, plus threading takes a fair amount of overhead in the VM and significantly impacts the VM footprint. Although there can be multiple applets resident on the same smart card, Card Java systems allow only one applet to be selected at a time. (The multiple-resident-applications concept introduces risks of its own, which we address later.)<p><br>


<center><font size="+1"><b>How Card Java Increases Security Risks</b></font></center><p>

Lack of threads and the absence of dynamic class loading impact security in a positive way, but the opposite effect can be seen with other Card Java features. In other words, the removal of some features of Java (clearly intended to make possible the migration to Card Java) may introduce new security problems. Risks that are introduced involve:
<UL>
	<LI>Lack of garbage collection
	<LI>Exception propagation problems
	<LI>Multiple applications and applet firewalling
	<LI>Object-sharing loopholes
	<LI>Access to native code
</UL>

These problems and their risks are discussed next.<p>

Garbage collection is a good example of a feature whose absence has a security impact. Without a system for freeing allocated memory, the problem of denial-of-service attacks is exacerbated. The Card Java 2.0 specification does not require implementation of garbage collection on a card (in fact, implementing garbage collection on a card would be no small feat). As a result, even subtle programming errors can wreak havoc on a smart card. Memory leaks are a classic problem in languages such as C++ that do not support automatic garbage collection [Hastings and Joyce, 1992]. (Note that the term memory leak refers to memory becoming full when objects are inefficiently created and destroyed.) Since Card Java does not support garbage collection, logic errors in applet code may over time exhaust free memory, rendering the card useless. This problem is especially acute on cards with limited memory resources. Another closely related issue is the "dangling reference" problem, in which a program frees memory even though it still has a pointer to that memory. The problem is that the freed memory may be recycled for another purpose, and then the old "dangling" pointer may be used, resulting in memory corruption. Unfortunately, garbage collection is expensive in terms of both time and computational resources. Nevertheless, the risk of memory leaks is real. The requirement to ensure that these kinds of errors do not occur raises the need for extensive testing and analysis of Card Java applet code.<p>

Exception propagation is an interesting issue for Card Java as well, since uncaught exceptions could lead to a card being muted (disabled for normal use). The potentially fatal effect of unhandled exceptions implies another significant exposure to unintended denial of service, once again resulting from subtle programming errors. As with memory exhaustion, the requirement to ensure that these kinds of errors do not occur raises the requirements for extensive testing and analysis of the Card Java applet code.<p>

Since Card Java allows multiple applications to be resident on the same smart card, there is a risk of interapplication attacks. This risk is especially relevant in situations where applets may be provided by competing vendors. Card Java defines applet firewalls meant to protect applets from one another, although it is not exactly clear what technology underlies this terminology. It appears that the main protections between applets are related to memory management; in particular, applets are not allowed to access memory arbitrarily on the card. As a default, they can only get access to objects that they own (which are mapped into card memory during applet installation). It is clear that the memory protection mechanisms must be perfectly implemented to allow safe use of multiple applets. Plans are in the works for smart card applications that cooperate with each other. Imagine, for example, a card that works both as a debit card and as a frequent flyer card. Such plans may introduce more security risk than they are worth.<p>

One feature that is in high demand in systems with multiple applications is object sharing. Card Java 2.0 includes an object sharing approach that includes a loophole. The current approach is described as follows:

<blockquote>
The JCRE keeps track of the currently selected applet as well as the currently active applet. The currently active applet value is referred to as the applet execution context. When a virtual method is invoked on an object, the applet execution context is changed to correspond to the applet that owns that object. When that method returns, the previous context is restored. Invocations of static methods have no effect on the applet execution context. The applet execution context and sharing status of an object together determine if access to an object is permissible [Sun Microsystems, 1997].
</blockquote>

To illustrate the implications of this approach, consider an example with three applets named A, B, and C as shown in Figure 8.3. Applet A shares an object it owns, x, with applet B. Applet B shares an object it owns, y, with applet C. A virtual method in the object owned by B, called y.bar, and shared with C invokes a virtual method in the object owned by A, called x.foo. Now if applet C is selected, it has permission to invoke virtual methods of the object owned by applet B, including the one that in turn invokes the virtual method in an object owned by applet A. In other words, C indirectly invokes x.foo.<p>

<center>
<table border=0 width=323><tr><td>
<img src="..\images\fig08.03.gif" width=323 height=98 alt="Fig 8.3"><br>
<font size="-2" face="Helvetica"><p>
<center><b>Figure 8.3  Sharing a virtual method with another applet is tantamount to allowing that applet complete control over the method.</b></center><br>
The problem is illustrated here. Applet A may think it is sharing method foo() only with Applet B, but Applet B can in turn share the method (through method bar()) with Applet C. If A doesn't want to share with C, this may be a problem.<p>
<center><b>PLEASE NOTE:</b> In the above image, between Applets B and C should read "<b>share (y,C)</b>."</center></font>
</td></tr></table>
</center>
<p>

In short, if virtual methods are used, granting an applet permission to access an object amounts to also granting that applet the ability to export indirect access to that object to any other applet. This has a clear weakening effect on any assurance about the protection of an object. For static methods, such access is prohibited, since static methods do not change the applet context. Restricting virtual methods in the same way that static methods are restricted may add some complexity to sharing schemes. The upshot of this change would be that an applet will be forced to share the object explicitly with all other applets that directly or indirectly need to be granted access permission.<p>

By far the biggest risk presented in the design of Card Java is a potential ability for a vendor to add and use Native methods on the platform. Obviously, this will compromise portability (applets that use Native methods will not be automatically portable to other cards), and it may expose the card to dangerous code that exists outside the applet firewalls. In fact, if Native methods are available, the concept of firewalls deteriorates. Native code is not restricted by the JCRE mediation of access, and misuse is possible.<p>

The very real security concern is that an attack applet will make use of Native code to carry out operations that would otherwise be stopped by the JCRE. When Native code executes, all bets are off for the Java Virtual Machine and its protection mechanisms. Native code in applets completely breaks the idea behind Java security. Attack applets are likely to make use of Native method calls.<p>

The five new risks we have covered were introduced into Java with its transformation to Card Java. Although Card Java certainly presents an intriguing new set of risks in terms of security, it does nothing to address several important fundamental security concerns associated with smart cards, including the problem of physical attacks and the terminal problem (both discussed earlier in the chapter). It is important to keep in mind that the non-Java-related problems have a real impact on card security and that they are not solved by Card Java.<p>


<center>
<table width=95%>
<tr>
<td width=60 align=center>
<a href="chapter-eight-6.html">
<img src="..\images\arrow6.gif" width=60 height=60 border=0 align="middle" alt="Previous Page"><br>
<font size="-2" face="Helvetica,sans-serif">Previous Page</font></a>
</td><td align=center>
<center>
<FORM METHOD=post ACTION="/cgi-bin/texis/webinator/newsearch/">
<font size="-1" face="Helvetica">
<INPUT TYPE="text" NAME="arg" SIZE=25></font><br>
<INPUT TYPE="hidden" NAME=proximity VALUE="rank">
<INPUT TYPE="hidden" NAME=suffixproc VALUE="max">
<INPUT TYPE="hidden" NAME="db" value="db9">
<INPUT NAME=cmd TYPE=submit VALUE="Search the Book"><br>
<font size="-1" face="Arial">
<a href="http://www.rstcorp.com/searchhelp.html">Search Help</a></font></FORM>
</center>

</td><td width=60 align=center>
<a href="chapter-eight-8.html">
<img src="..\images\arrow7.gif" width=60 height=60 border=0 align="middle" alt="Next Page"><br>
<font size="-2" face="Helvetica,sans-serif">Next Page</font></a>
</td></tr></table>
</center>

<hr>
<p><br>

<map name="menu">
<area shape="RECT" coords="4,16,116,35" href="..\toc.html">
<area shape="RECT" coords="11,37,105,57" href="..\preface.html">
<area shape="RECT" coords="198,13,218,50" href="..\chapter-one\index.html">
<area shape="RECT" coords="226,12,248,41" href="..\chapter-two\index.html">
<area shape="RECT" coords="253,17,274,50" href="..\chapter-three\index.html">
<area shape="RECT" coords="279,27,301,59" href="..\chapter-four\index.html">
<area shape="RECT" coords="308,16,329,49" href="..\chapter-five\index.html">
<area shape="RECT" coords="335,9,357,41" href="..\chapter-six\index.html">
<area shape="RECT" coords="362,17,381,48" href="..\chapter-seven\index.html">
<area shape="RECT" coords="387,27,410,59" href="index.html">
<area shape="RECT" coords="414,17,438,50" href="..\chapter-nine\index.html">
<area shape="RECT" coords="519,11,593,32" href="..\..\www.securingjava[1].com\index.html">
<area shape="RECT" coords="538,36,593,58" href="..\help.html">
</map>

<center>
<img src="..\images\menumap3.gif" width=600 height=75 border=0 alt="Menu Map -- Text links below" usemap="#menu" ismap><p>
<font size="-1" face="Helvetica,Arial">
Chapter... <a href="..\preface.html">Preface</a> -- <a href="..\chapter-one\index.html">1</a> -- <a href="..\chapter-two\index.html">2</a> -- <a href="..\chapter-three\index.html">3</a> -- <a href="..\chapter-four\index.html">4</a> -- <a href="..\chapter-five\index.html">5</a> -- <a href="..\chapter-six\index.html">6</a> -- <a href="..\chapter-seven\index.html">7</a> -- <a href="index.html">8</a> -- <a href="..\chapter-nine\index.html">9</a> -- <a href="..\appdx-a\index.html">A</a> -- <a href="..\appdx-b\index.html">B</a> -- <a href="..\appdx-c\index.html">C</a> -- <a href="..\references\index.html">Refs</a><br>

<a href="..\..\www.securingjava[1].com\index.html">Front</a> -- <a href="..\toc.html">Contents</a> -- <a href="..\help.html">Help</a>
</font>
</center>

<p align=right>
<font size="-7" face="Helvetica,Arial,sans-serif">
Copyright &copy;1999 Gary McGraw and Edward Felten.<br>
All rights reserved.<br>
Published by <a href="http://www.wiley.com/">John Wiley &amp; Sons, Inc.</a>
</font>

</td>
</tr></table>


</body>
</html>

