<HTML>
<HEAD>
<TITLE>Book Errata</TITLE>
<LINK REV="OWNER" HREF="mailto:shartley@mcs.drexel.edu">
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" ALINK="#FF0000" VLINK="#000080">

<H1>Book Errata</H1>

<P>
<SCRIPT LANGUAGE="JavaScript">
<!--hide from non-JavaScript browsers
   document.write("Last modified on "+document.lastModified);
 // end hiding -->
</SCRIPT>
</P>

<P>
<DL>
<DT> Page 33, bottom.
<DD> Each time a one-point crossover operation is performed,
     the crossover point is chosen randomly.
<DT> Page 54.
<DD> ``If a thread in the running state calls its <TT>yield</TT> method,
     it gives up the CPU and is put back in the runnable set
     in the runnable state.''
     Even if several threads are runnable,
     there is no guarantee that the next thread to run on the CPU is
     not the one that just yielded.
<DT> Page 55.
<DD> ``The Java thread scheduler ensures that the highest priority
     runnable thread (or one of them if there are several)
     is running on the CPU.''
     This is not accurate.
     According to page 415 of <I>The Java Language Specification</I> [21],
     the scheduler usually ensures this, but it is not guaranteed that the
     highest priority thread is always executing on the CPU.
<DT> Page 57.
<DD> Thus Library Class 3.2 (<TT>Scheduler</TT>)
     does not guarantee time slicing, but it works in practice.
<DT> Page 79.
<DD> Change ``But it does allow starvation in the presence of contention''
     to ``It also does not allow starvation in the presence of contention.''
<DT> Page 79.
<DD> Delete ``In contrast to Dekker's solution,''
<DT> Page 81.
<DD> Change the right-most entry in Table 3.2's line for Dekker's algorithm
     from ``no'' to ``yes.''
<DT> Page 87, Exercise 6.
<DD> Change ``Show how starvation in the presence of contention might occur
     in Dekker's solution.'' to ``Show that starvation in the presence of
     contention does not occur in Dekker's solution even if one thread
     executes on a fast CPU and the other thread on a slow CPU ([25] page 25
     is in error).''
<DT> Page 90.
<DD> The producer and consumer code using shared binary semaphores does
     illustrate a delay/wakeup without the race condition described in
     Section 3.5.4 on page 83.  However, the page 90 code still has many
     race conditions and bugs.  Finding and fixing them makes a good exercise.
<DT> Pages 106, 121.
<DD> The commands to induce starvation should be (change <TT>-n5</TT> to
     <TT>-p5</TT>)
     <PRE>
     javac dphi.java dpdr.java
     java DiningPhilosophers -p5 -R300 1 100 10 1 1 100 100 1 100 1
     </PRE>
<DT> Page 119.
<DD> Exercise 0. <B>Fix the Remaining Bugs.</B>
     Find and fix the bugs and race conditions remaining in the producer
     and consumer shared binary semaphore code on page 90.
<DT> Page 128.
<DD> Exercise 18. <B>Fix Another Bug.</B>
     Although the code on page 114 fixes the scheduling flaw, it has a race
     condition rendering it incorrect.  The race condition can be fixed by
     adding <TT>if (wakeup == 1)</TT> after <TT>wakeup++</TT> and before
     <TT>V(blocked)</TT> in the <TT>up()</TT> method.  Devise a sequence
     of events illustrating this race condition and verify the fix.
     (David Hemmendinger, ``Comments on `A Correct and Unrestrictive
     Implementation of General Semaphores' (by Kearns)','' <I>ACM Operating
     Systems Review</I>, Vol. 23, No. 1, 1989.)
<DT> Page 135.
<DD> If several threads are blocked, waiting to acquire the lock on
     an object that is currently held by some other thread,
     there is no guarantee that the thread waiting the longest will be
     the next one to acquire the lock when it is released.
<DT> Page 137, top.
<DD> A <TT>notify()</TT> removes an arbitrary thread from the wait set,
     if there is one.  The thread must reacquire the monitor lock and therefore
     competes with all other threads trying to acquire the monitor lock,
     having called a <TT>synchronized</TT> method, or reacquire the monitor
     lock, having been notified.  Thus the notified thread is not necessarily
     in the runnable (ready) set, but might still be blocked.
<DT> Pages 139--140 and 391.
<DD> Class 5.7.
     There is a race condition in this platoon-based monitor for the
     starvation-free database readers and writers problem.  Suppose several
     readers are currently reading the database.  Then, suppose several
     writers arrive and wait.  Next, suppose several more readers arrive and
     wait due to the waiting writers.  Then, suppose the currently reading
     readers all finish and exit the database.  One of the waiting writers
     now writes the database.  When it finishes, all waiting readers that
     arrived before it finished writing are to enter the database next.
     However, if one of those readers enters and exits the database before
     any of the other readers enters, then one of the waiting writers and
     one of the remaining readers can enter the database at the same time,
     possible corrupting it.
<DT> Page 166.
<DD> Exercise 27. <B>Fix Class 5.7.</B>
     Fix the platooning so that when a writer finishes writing all waiting
     readers that arrived before it finished writing are allowed into the
     database before another writer is allowed to enter.
<DT> Page 393.
<DD> Library Class 5.1.
     The interrupt/notify race condition is still present.  Suppose several
     threads are blocked in <TT>wait()</TT> inside <TT>P()</TT>.  Next, suppose
     one is notified by a thread calling <TT>V()</TT>.  The notified thread
     is removed from the wait set and now needs to reacquire the monitor lock
     in order to continue execution in the monitor.  Now suppose the notified
     thread is interrupted before reacquiring the monitor lock.  An
     <TT>InterruptedException</TT> exception is thrown and the thread executes
     its <TT>catch</TT> block when it reacquires the monitor lock.  However,
     <TT>value</TT> is less than zero, so the thread does another <TT>wait</TT>
     and the notify is lost.
<DT> Page 399.
<DD> Class 5.9.
     A similar problem to Library Class 5.1 on page 393.
</DL>
</P>

<HR>

<P>
<ADDRESS><A HREF="http://www.mcs.drexel.edu/~shartley">SJH</A></ADDRESS>
<ADDRESS>
<A HREF="mailto:shartley@mcs.drexel.edu">shartley@mcs.drexel.edu</A>
</ADDRESS>
</P>
</BODY>
</HTML>
