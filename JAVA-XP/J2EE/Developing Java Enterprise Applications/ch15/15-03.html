<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:What Are Enterprise JavaBeans?</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="15-02.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="15-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading7"></A><FONT COLOR="#000077">Container Providers</FONT></H4>
<P>An integral part of the beans specification is the container. This container is considered the real service provider; the server is just a host for the container. In reality, the EJB server provider will almost always be the container provider. This is because the container needs to deal with the server for threading information, resource management, and numerous other facilities that will be hard to define in a way that makes separating the server and container reasonable. However, that is one goal of future versions of the EJB specification and may eventually become standard. Until then, the container providers will probably be the server providers, and most server providers will provide a single type of container. Some may provide multiple containers that define services in different ways. For example, Sun might provide one container that uses CORBA and another that uses straight RMI to communicate, as pictured in Figure 15.5.
</P>
<P><A NAME="Fig4"></A><A HREF="images\15-04.jpg"><IMG SRC="images\15-04t.jpg"></A>
<BR><A HREF="images\15-04.jpg"><FONT COLOR="#000077"><B>Figure 15.4</B></FONT></A>&nbsp;&nbsp;Enterprise beans on several tiers.</P>
<P><A NAME="Fig5"></A><A HREF="images\15-05.jpg"><IMG SRC="images\15-05t.jpg"></A>
<BR><A HREF="images\15-05.jpg"><FONT COLOR="#000077"><B>Figure 15.5</B></FONT></A>&nbsp;&nbsp;Multiple container types.</P>
<P>Other constraints on the container might be the databases it can access or the transaction-processing services that it can use. Although the existence of these services is required by the specification, their implementation is not. Some services may be available through varying incompatible mechanisms, and it is the container&#146;s job to translate the EJBs&#146; requests to their specific format. It will be the deployer&#146;s job to determine which container, or server, to use to support the other applications in a distributed system.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading8"></A><FONT COLOR="#000077">Administrators</FONT></H4>
<P>Because EJBs represent network resources, they may need to be administered. The administrator will be tasked with keeping track of resource usage, making sure that the JNDI contexts are properly initialized, and any other tasks that guarantee the EJB&#146;s continued availability.
</P>
<H3><A NAME="Heading9"></A><FONT COLOR="#000077">When to Use EJBs</FONT></H3>
<P>Enterprise JavaBeans fall into two broad categories: session beans and entity beans. <I>Session beans</I> provide application services. A session bean is used when the server should provide a particular service to the client, such as adding two numbers or performing a database query. <I>Entity beans</I> are data objects. An entity bean represents a part of an application, such as a customer name or checking account. Developing enterprise beans involves choosing which type of bean to use. Under the EJB 1.0 specification, EJB hosts are not required to support entity beans, although some do already.</P>
<P>Session beans fall into two subcategories: stateless and stateful. <I>Stateless session beans</I> are really just a collection of disassociated methods. When a client interacts with a stateless bean, he may send one message to one bean and the next message to another bean, all without noticing the switch. By definition, a stateless bean has no state. <I>Stateful session beans</I> do have state. When a client creates or finds a stateful session bean, he implicitly starts a session that uses the same bean throughout. When the client finishes using the bean, he removes it, thus ending the session. While the session is open, the stateful bean may use its instance variables to store information about the ongoing interaction.</P>
<P>Session beans share the following characteristics:</P>
<DL>
<DD><B>Session beans represent application functionality.</B> Beans do take up server resources, deployment time, and administrative resources. Don&#146;t create a different bean for every single method in an application. Use beans that group like functionalities together, such as using an ATM bean that supports withdrawals and deposits instead of a withdrawal bean and a deposit bean. That said, don&#146;t go too far in the other direction, creating beans with hundreds of methods. In many cases, 5 to 15 methods is just right. If the bean is really specific to a particular problem, you might provide fewer; it is rare that more is a good idea. In cases in which beans provide a lot of functionality, rely on frameworks and libraries underneath them to create an effective object-oriented model. Think of the bean as the interface to your model in the same way a graphical user interface sits on top of a client application.
<DD><B>Each bean interacts only with one client at a time.</B> The server may use pools of beans to minimize the total number of beans created, but a bean will not be used for two clients at the same time. Stateless beans may, however, be used for several clients on a message-by-message basis. For example, client one might send executeA to a bean, then client two might send executeA before client one sends executeB. This is okay for stateless beans because they don&#146;t assume any shared data across message calls. A server can even load-balance requests to a stateless bean between multiple computers transparently to the client.
<DD><B>Session beans can be aware of transactions.</B> These transactions can be propagated to the resources that an EJB accesses, such as database connections and other EJBs.
<DD><B>Sessions beans do not represent persistent data but can access it.</B> If the server crashes, all of the session beans are recreated from scratch, as needed. They are not backed up. The partial exception to this rule is that stateful session beans should be serializable because the server may need to offload them to disk if the client is not currently sending messages to them, the server load is high, and the client session is still open. For example, if the client went to lunch early, the server could be busy and want to free up resources. In this case, the server will notify the bean that it is storing it temporarily. The bean will be notified again when it is reloaded to service a client message.
<DD><B>Session beans can be thought of as short-lived.</B> Although a server may keep the same bean in a pool for many months, the client interaction really defines a bean&#146;s lifetime.
</DL>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="15-02.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="15-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

