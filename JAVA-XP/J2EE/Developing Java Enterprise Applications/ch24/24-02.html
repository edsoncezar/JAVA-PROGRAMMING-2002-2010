<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Architecture Review</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-01.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<DL>
<DT><B>RMI and distributed objects.</B>
<DD>Like JDBC, RMI is an enabling technology. Many applications and libraries use RMI to form their network connections. Other applications may rely on raw sockets or HTTP connections to interact with servlets and the Web Server. The goal of RMI is to provide a transparent link between two Java applications. Of course, this link can never be completely transparent, because of the issues inherent with network programming, especially that crazy guy with an ax that keeps cutting ethernet cables. All networking solutions involve some issues. RMI tries to encapsulate possible errors into RemoteException objects that can be handled with standard Java exception handling.
<BR>As mentioned in Chapter 1, &#147;An Introduction to Java Enterprise Development,&#148; Java IDL and other Java/CORBA technologies are not included in this book. This omission was based on the amount of material that would need to be discussed and not intended to disparage CORBA in any way. In fact, we believe that CORBA and Java IDL are likely to form the foundation for many enterprise applications. Many programmers will probably use RMI over IIOP as well. At the time of this writing, RMI over IIOP was not sufficiently implemented to include in our discussion. However, from your perspective, it should not be very different from general RMI. Sun is working with the Object Management Group to make CORBA, IIOP, and Java work together as closely and transparently as possible.
<DT><B>Enterprise JavaBeans.</B>
<DD>Enterprise JavaBeans are designed to become the standard building blocks for corporate server applications. Whenever your application is implemented on a server, definitely consider using an EJB host server, such as WebLogic, and Enterprise JavaBeans. This combination allows you to rely on heavily tested services from the server provider and focus your resources on application-specific programming. The component design of Enterprise JavaBeans makes them a great way to encapsulate business rules and processes. They can also form the foundation of a library that provides standard services that your enterprise applications require, such as data processing or report generation.
<BR>In a very real sense, Enterprise JavaBeans are simply a way to do work. Deciding whether or not to use them is really a decision of whether or not you want to purchase an EJB host, if you do not already have one. Certainly, smaller deployments may not warrant the expense or overhead of an EJB installation. In this case, consider using straight RMI or CORBA to access the server. In mixed installations, you could possibly provide RMI wrappers for Enterprise JavaBeans on small boxes, such as laptops, and save the EJB hosts for larger deployments, such as the corporate network. This design allows you to reuse the Enterprise JavaBeans at both levels.
<DT><B>Java Messaging Service.</B>
<DD>The Java Messaging Service is designed to act as a front end to messaging providers. In many cases, these providers use some form of server to implement messaging and may provide transaction management and Enterprise JavaBeans hosting as well. Messaging as a technology is a great way to objectify the communication between applications. Messaging providers ensure the integrity of this communication and even support delayed communications, storing a message until a receiver is available. The other big advantage of messaging, when a server is involved, is that a client can maintain a single connection to the server that provides access to dozens, hundreds, or even thousands of other programs. This resource optimization alone makes messaging a powerful distributed computing technique.
<BR>Given that messaging is a powerful tool, the question is, why use it, or why use anything else? The answer is not simple, but there are a few things that make it easier to consider. First, messaging decouples the communicating programs. This is great when you may want to change the program at either end of the communication or if you want to allow multicast-style communication in which one client talks to multiple listeners. The down side to decoupling is that there is a performance cost. For example, accessing a database with messages is not likely to be as efficient as a direct connection and would be efficient only if the messages were highly optimized, network traffic low, and the database library implementation poor. Messaging is really a great example of trading flexibility for performance and resources. In some ways, as in the case of network connections, you can save resources. In others, as in the case of the number of network hops to access a program, you increase resource usage. When deciding between messaging and direct connections, weigh the resource usage and performance as a primary guide against the flexibility that you can gain.
</DL>

<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="24-01.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="24-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

