<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Overview of Distributed Objects</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="12-03.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="..\ch13\13-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>If you want a seamless, powerful solution that is Java-centric, RMI is your best bet today. Developed by Sun, RMI is a Java solution for distributed objects. The model illustrated in Figure 12.5 has been influenced by other vendors and is widely becoming accepted as a standard way for remote Java applications to communicate. Versions of RMI that support IIOP will be coming soon as well. Once this happens, true interoperability between objects using RMI and objects using CORBA will be possible. In addition, any application that supports IIOP will be accessible to RMI objects.
</P>
<P>The goals for RMI include:</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;Capability to use multiple transports such as IIOP
<DD><B>&#149;</B>&nbsp;&nbsp;Distributed garbage collection for active objects
<DD><B>&#149;</B>&nbsp;&nbsp;Ease of use
<DD><B>&#149;</B>&nbsp;&nbsp;Integrate the distributed object model into the Java language in a natural way while retaining most of the Java language&#146;s object semantics
<DD><B>&#149;</B>&nbsp;&nbsp;Make apparent the differences between the distributed object model and local Java object model
<DD><B>&#149;</B>&nbsp;&nbsp;Make writing reliable distributed applications as simple as possible while maintaining the Java security and safety features
<P><A NAME="Fig5"></A><A HREF="images\12-05.jpg"><IMG SRC="images\12-05t.jpg"></A>
<BR><A HREF="images\12-05.jpg"><FONT COLOR="#000077"><B>Figure 12.5</B></FONT></A>&nbsp;&nbsp;RMI model.</P>
<DD><B>&#149;</B>&nbsp;&nbsp;Support for non-persistent, persistent, and lazy activated objects›&#151;that is, objects that are instantiated when first called
<DD><B>&#149;</B>&nbsp;&nbsp;Support seamless remote invocation on objects in different virtual machines
</DL>
<P>RMI&#146;s distributed object scheme is comprised of the following:
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;An interface (called a stub) that represents your remote object in your local address space:
<PRE>
public interface CreditCardVerifyer extends sr <B>java.rmi.Remote</B>
</PRE>
<DD><B>&#149;</B>&nbsp;&nbsp;A set of classes that you can subclass to create your remote object:
<PRE>
   public class CreditCardVerifyerImpl
           extends <B>UnicastRemoteObject</B>
           implements CreditCardVerifyer
</PRE>
<DD><B>&#149;</B>&nbsp;&nbsp;A server called rmiregistry that tracks registered objects by name. To register your object, you would call the bind method of java.rmi.Naming. This method binds the instantiated object into rmiregistry with the associated name:
<PRE>
   CreditCardVerifyerImpl ccv = new CreditCardVerifyerImpl();
 java.rmi.Naming.bind(&#147;rmi://myserver.com/<B>creditcard</B>&#148;, obj);
</PRE>
</DL>
<P>To access a remote object, call the lookup () method of a class called java.rmi.Naming. In this method, specify the URL for the object you want to access. For example:
</P>
<PRE>
CreditCardVerifyer ccv = new CreditCardVerifyerImpl();
 String url = &#147;rmi://myserver.com/<B>creditcard</B>&#148;;
// bind url to remote object
java.rmi.Naming.bind(url, ccv);
        ...
// lookup account
ccv = (CreditCardVerifyer)java.rmi.Naming.lookup(url);
</PRE>
<P>As shown in Figure 12.5, RMI consists of three layers. One layer is the stub/skeleton layer, which acts as a stand-in used for communicating with the remote object. Another is the remote reference layer, which handles the strategy for connecting to the remote object, including point-to-point connection, object replication, reconnection strategies if the object becomes unavailable, and so on. The final layer is the transport layer, which initializes a connection with the remote object&#146;s address space and manages remote object tracking.
</P>
<H3><A NAME="Heading6"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Distributed object programming is a valuable tool for enterprise developers. The scheme you use depends on the tools and applications with which you plan to communicate. If you are planning to connect with legacy systems, CORBA should be considered because it is supported by the greatest number of vendors. If you need a Microsoft-centric solution, DCOM seems like an obvious choice. In general, if you are planning to implement a new system in Java, you should consider RMI the most logical choice. It takes advantage of features of Java such as the object model, security, and garbage collection. With the addition of multiple transport support, such as IIOP, you can integrate with systems that implement CORBA as well. RMI seems like the best of both worlds for the Java programmer.
</P>
<P>The next chapter explores the entire RMI API and builds a small, distributed example. Chapter 14, &#147;A Network File-Locking Server,&#148; provides a more extensive example of using RMI.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="12-03.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="..\ch13\13-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

