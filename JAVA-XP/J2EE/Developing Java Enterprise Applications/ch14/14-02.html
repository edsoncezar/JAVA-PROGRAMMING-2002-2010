<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:A Network File-Locking Server</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="14-01.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="14-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">NLS: The Lock Server</FONT></H4>
<P>The NetworkLockServer interface is implemented in a class called NLS. The following code defines the NLS class that extends UnicastRemoteObject and provides implementations for all of the remote methods. Most of the work in handling shared file-lock requests is actually handled by the SharedFileLock class, which keeps a list of unique locks for each path. These locks are used to test whether a file is locked when the server is asked.
</P>
<PRE>
import java.io.*;
 import java.util.*;
import java.security.*;
import java.rmi.*;
import java.rmi.server.*;

public class NLS extends UnicastRemoteObject 
implements NetworkLockServer
{
    private boolean locked;
    
    public NLS() throws RemoteException
    {
    }
    
<B>    public FileLock 
     getSharedLockFor(String path)
    {
        return SharedFileLock.getLockFor(path);
    }
    public boolean isFileLocked(String absPath)
        throws RemoteException
    {
        FileLock lock;
        
        lock = getSharedLockFor(absPath);
        
        return lock.isLocked();
    }</B>
</PRE>
<P>The lock method ensures that multiple requests to lock this file will not collide. The first request locks the file, and all others must wait until the file lock is released.
</P>
<PRE>
    public synchronized void lock()
     {
        while(locked)
        {
            try
            {
                wait();
            }
            catch(Exception exp)
            {
            }
        }
        
        locked = true;
    }
    
</PRE>
<P>The lock is released, and the next request to lock the file can now be processed. The method notifyAll wakes up all threads that are waiting on this object based on the wait method called in the lock method described previously.
</P>
<PRE>
    public synchronized void unlock()
     {
        locked = false;
        notifyAll();
    }
</PRE>
<P>The main method is the bootstrap for the NLS. It installs the standard RMI security manager, creates an NLS instance, and binds it in the registry specified in the URL passed into main as args[0].
</P>
<PRE>
    public static void main(String args[])
     {
        // Create and install a security manager.
        SecurityManager mng;
        NLS nls;
        
        try
        {
            System.out.println(<B>&#147;</B>Setting Security Manager.<B>&#148;</B>);
<B>            mng = new RMISecurityManager();
            System.setSecurityManager(mng);</B>
            System.out.println(<B>&#147;</B>Set Security Manager.<B>&#148;</B>);
            
            System.out.println(<B>&#147;</B>Creating server.<B>&#148;</B>);
<B>            nls = new NLS();
</B>            System.out.println(<B>&#147;</B>Created server.<B>&#148;</B>);
            
            System.out.println(<B>&#147;</B>Starting to bind server.<B>&#148;</B>);
            
            if(args.length&gt0)
<B>                Naming.rebind(&#147;//&#148;+args[0]+&#147;/&#148;
                        +NetworkLockServer.NLS_NAME, nls);
</B>            else
            {
                System.out.println(<B>&#147;</B>No Server Specified.<B>&#147;</B>);
                System.exit(0);
            }
      
            System.out.println(<B>&#147;</B>NLS bound in registry<B>&#147;</B>);
        }
        catch (Exception e)
        {
            System.out.println(<B>&#147;</B>Network Lock Server: <B>&#148;</B> 
                                 + e.getMessage());
            e.printStackTrace();
            System.exit(0);
        }
    }
}
</PRE>
<P>NLS provides a main method that sets up the correct SecurityManager, creates an NLS object, and registers and binds it. Notice that command-line arguments are used to specify the server for the RMI registry.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">SharedFileLock: The FileLock Implementation</FONT></H4>
<P>The SharedFileLock class is the most complex in this example. It is the one that implements the FileLock interface. The following code defines the SharedFileLock class by importing the necessary packages and declaring the class as extending UnicastRemoteObject and implementing the FileLock interface.
</P>
<PRE>
import java.io.*;
import java.util.*;
import java.rmi.*;
import java.rmi.server.*;

public class SharedFileLock
 extends UnicastRemoteObject implements FileLock
{
</PRE>
<P>Next, two instance variables are defined to store a file object that represents the file that the lock is locking and the lock file that embodies the lock itself.
</P>
<PRE>
    private File file;
    private File lockFile;
</PRE>
<P>Then a static hash table called locks is used to map paths onto file locks, so that a unique lock can be used for each path, rather than having multiple locks per file.
</P>
<PRE>
    private static Hashtable locks = new Hashtable();
</PRE>
<P>In order for this unique lock mechanism to work, the class provides a method for getting a lock based on a path. This method, getLockFor, creates a lock, if necessary, and stores it in the lock&#146;s hash table under its absolute path.
</P>
<PRE>
    public synchronized static SharedFileLock 
      getLockFor(String path)
    {
        SharedFileLock retVal = null;
        File tmp = new File(path);
        String absPath = tmp.getAbsolutePath();
        
        try
        {
            retVal = (SharedFileLock) locks.get(absPath);
        
            if(retVal == null)
            {
                retVal = new SharedFileLock(tmp);
                locks.put(absPath,retVal);
            }
        }
        catch(Exception exp)
        {
            retVal = null;
        }
        
        return retVal;
    }
</PRE>
<P>In order to force programs to use the getLockFor method, the constructor for SharedFileLock is defined as protected. This constructor accepts a File object representing the file to lock and creates another file object using the primary file&#146;s path of the File object to represent the lock file. A lock file with a name of the form .<I>filename.</I>lck is used, where <I>filename</I> is the actual name of the file. On some UNIX systems, this file will be hidden and may also be hidden in Windows, depending on the user&#146;s settings.</P>
<PRE>
    protected SharedFileLock(File f) 
     throws RemoteException
    {
        String parent,name;
        String lckPath;
        
        file = f;
        
        parent = file.getParent();
        name = file.getName();
        
<B>        lckPath = parent+File.separator+&#147;.&#148;+name+&#147;.lck&#148;;
</B>        
        lockFile = new File(lckPath);
    }
</PRE>
<P>To check if the lock is active, we test if the lock file exists, using the following isLocked method.
</P>
<PRE>
    public synchronized boolean isLocked()
     {
        return lockFile.exists();
    }
</PRE>
<P>To lock the file, first wait until it is not locked, then create the lock file. Because this wait can take an inordinate amount of time in the case of a file locked for editing, the isLocked methods are provided to allow programs to check whether they want to attempt the lock. A wait statement is used inside a while loop to reduce CPU usage. When a client requests that a SharedFileLock lock, the request first waits for the object&#146;s lock, then checks to see whether the file is already locked. If the file is locked, the client&#146;s requesting thread waits for notification. This notification is provided in the unlock method, discussed below.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="14-01.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="14-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

