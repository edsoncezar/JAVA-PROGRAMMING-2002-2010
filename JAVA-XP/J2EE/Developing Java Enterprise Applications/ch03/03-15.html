<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Basic JDBC Programming</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="03-14.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="03-16.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P><FONT SIZE="+1"><B>rollbackTransaction</B></FONT></P>
<P>The rollbackTransaction method works similarly to the commitTransaction() method. If this method is successful, the current transaction rolls back and all changes done within the scope of the transaction are undone.
</P>
<PRE>
public boolean rollbackTransaction()
 {
    boolean rollbackIsOk = false;
    try
    {
        //Check if auto commit is on. If it is, don&#146;t roll back.
        rollbackIsOk = !connection.getAutoCommit();

        if(rollbackIsOk)
        {
            // rollback transaction
            connection.rollback();

            //Turn on Auto Commit; this is default.
            connection.setAutoCommit(true);
        }
        }catch(SQLException e)
        {
            System.out.println(e);
            rollbackIsOk = false;
        }

        //refresh
        if(rollbackIsOk)
            this.executeQuery();
        return rollbackIsOk;
    }
}
</PRE>
<P><FONT SIZE="+1"><B>Miscellaneous Table&#150;Related Methods</B></FONT></P>
<P>The following are housekeeping methods required by the JDBCTableModel.
</P>
<P>The close method is called to close the connection to the database and all associated resources.</P>
<PRE>
public void close() throws SQLException
 {
    resultSet.close();
    statement.close();
    connection.close();
}
</PRE>
<P>The close method is called from finalize(), which has been overridden to call close.
</P>
<PRE>
protected void finalize() throws Throwable
 {
    close();
    super.finalize();
}
</PRE>
<P>The getColumnName method is a convenience method that returns the name of a column based on its positional index.
</P>
<PRE>
public String getColumnName(int col)
 {
    String retVal;

    retVal = (String) names.elementAt(col);

    if(retVal == null)
        retVal = &#147;&#148;;

    return retVal;
}
</PRE>
<P>The method isCellEditable returns true if the column is one of the first five. This method is a sort of &#147;hack,&#148; so we don&#146;t have to add too much code for processing the logic of each individual column. The intent is to keep the example straightforward:
</P>
<PRE>
public boolean isCellEditable(int row, int col)
 {
/*
  Only the first four columns after the product id are
  updateable in this example (adjust for index difference).
*/
    return ((col &lt 6) &amp&amp (col &gt 0));
}
</PRE>
<P>The getColumnCount method returns the number of columns in the table.
</P>
<PRE>
 public int getColumnCount()

{
     return names.size();
}
</PRE>
<P>The getRowCount method returns the number of rows in the table.
</P>
<PRE>
public int getRowCount()
 {
    return data.size();
}
</PRE>
<P>The getValueAt method returns the value of a specific cell of the table.
</P>
<PRE>
 public Object getValueAt(int row, int col)

{
     Vector rowData = (Vector)data.elementAt(row);

     return rowData.elementAt(col);
}
</PRE>
<P><FONT SIZE="+1"><B>WindowCloser</B></FONT></P>
<P>WindowCloser is used to respond to a windowClosing event. It quits the application.
</P>
<PRE>
class WindowCloser extends WindowAdapter
 {
    public void windowClosing(WindowEvent e)
    {
        Window win = e.getWindow();
        win.setVisible(false);
        System.exit(0);
    }
}
</PRE>
<P>This example highlights the basic use of JDBC 1.0. Sun has recently released the specification for JDBC 2.0, which is even more powerful. The next section highlights some of the features that will be available when JDBC 2.0 product is released in full.
</P>
<H3><A NAME="Heading19"></A><FONT COLOR="#000077">JDBC 2.0 Features</FONT></H3>
<P>JDBC 2.0 adds many new features to the overall architecture of JDBC. When drivers start supporting these features, database access activities will be even easier and more flexible. In general, JDBC 2.0 supports the goals of JDBC 1.0, which include ease of use and good integration with the rest of the Java 2 platform, and Java philosophy of software design.
</P>
<P>The specific goals of JDBC 2.0 include the following:</P>
<DL>
<DD><B>Leverage the strengths of the JDBC 1.0 and Java APIs.</B> JDBC 1.0 goals are still important for the further development of JDBC.
<DD><B>Maintain compatibility with JDBC 1.0 applications and drivers.</B> This is an important goal because it ensures that as JDBC improves, your current applications won&#146;t stop working. In fact, your application is guaranteed to work with JDBC 2.0 drivers.
<DD><B>Leverage JavaBeans.</B> JavaSoft believes it is important for JDBC as a core data access technology to leverage the JavaBeans component model. JDBC 2.0 supports JavaBeans by implementing a RowSet object capable of tracking a set of records, even when not connected to the data source. This object is a serializable JavaBean, which can be used as a data container in any tool or application that supports JavaBeans.
<DD><B>Provide advanced database features.</B> JDBC 1.0 does a good job of providing capabilities equivalent to ODBC. JDBC 2.0 takes a hard look at database&#150;specific features that add more power and provides mechanism for tapping into these features. Features include more support for Binary Large Objects (BLObs) and scrollable cursors.
</DL>
<P>JDBC 2.0 is designed so that JDBC 1.0 programmers can easily adopt its functionality. JDBC 2.0 extends the capabilities of JDBC 1.0.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading20"></A><FONT COLOR="#000077">Database Enhancements</FONT></H4>
<P>There are many improvements in the JDBC 2.0 specification. The most notable improvements include these:
</P>
<DL>
<DD><B>Scrollable cursors.</B> These are implemented using ResultSet, which maintains an internal pointer called a <I>cursor. </I>The cursor<I> </I>indicates the row in the <I>result set that is currently being accessed</I>. In JDBC 2.0, these cursors may be used to move backward as well as forward. This allows the user to manipulate a record and come back to it later without having to requery the database.
<DD><B>Advanced data type support.</B> JDBC 2.0 provides better mapping support between Java objects and SQL3 data types such as BLObs. Additionally, there is support for user&#150;defined types.
<DD><B>Non&#150;SQL database support.</B> JDBC 2.0 provides some support for non&#150;SQL databases so that drivers for data sources like file systems and non&#150;SQL databases are easier to use.
<DD><B>Batch updates.</B> Batch updates allow you to store several database calls, then execute them all at once. If auto commit is off, these statements can be grouped in a single transaction, or they can be executed as a set of separate transactions.
<DD><B>Persistence of Java objects.</B> Support for type mapping and better object support allow drivers to ease the process of storing Java objects and custom types in a database.
<DD><B>Connection pooling.</B> Connection pooling may be implemented on top of the JDBC driver layer, allowing for a connection cache that works between JDBC drivers used by your application. This is a performance feature that enables you to share a connection to a database, allowing you to avoid the high cost of creating and destroying database connections.
</DL>
<P>JDBC 2.0 is more powerful because it allows you more flexibility in how you access and manipulate data. It is also easy to use because it simply extends the features of JDBC 1.0, which means everything you have learned here will apply to JDBC 2.0. However, there are some design changes, as discussed in the next section.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="03-14.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="03-16.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

