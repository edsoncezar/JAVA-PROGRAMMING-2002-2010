<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Programming with the Java Messaging Service</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-14.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-16.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The server will serialize messages sent to a topic into a single sequence. This ensures that the client checking the queue will receive each message only once, and that the messages will be received in the order in which they were sent. The JMS provider is expected to keep messages for a topic available as long as the provider is running. Persistent messages should be maintained even if the server is shut down and restarted. Unlike Queues, the receivers for a topic may or may not be durable. In other words, a queue receiver expects to get messages that are sent while it is not running, but a topic subscriber can choose to ignore these missed messages.
</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>Due to the similarities between using Queues and Topics, all of the examples from the discussion on point-to-point messaging are not repeated here. If you are planning to use publish-subscribe messaging, it will be useful to also look over the point-to-point examples for more complete coverage.</FONT><HR>
</BLOCKQUOTE>
<H4 ALIGN="LEFT"><A NAME="Heading23"></A><FONT COLOR="#000077">Topic Connection Factory</FONT></H4>
<P>Clients that want to use topics and the publish-subscribe messaging model need to retrieve a topic-oriented connection factory from JNDI. This factory implements the TopicConnectionFactory interface, which extends the ConnectionFactory interface described previously. The TopicConnectionFactory provides two methods for creating connections:
</P>
<PRE>
public TopicConnection createTopicConnection() throws JMSException
public TopicConnection createTopicConnection(String userName
                                            , String password)
                                              throws JMSException
</PRE>
<P>Both of these methods return an object that implements the TopicConnection interface. The first method uses the default user identification; the second takes a user name and password. These values may or may not be used by the JMS provider.
</P>
<P>MiniJMS registers a TopicConnectionFactory in JNDI using the name TopicConnectionFactory, so given a context, you can look it up using code such as:</P>
<PRE>
factory = (TopicConnectionFactory)
            context.lookup(&#147;TopicConnectionFactory &#148;);
</PRE>
<P>This code simply looks up an object in the JNDI context and casts it appropriately.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading24"></A><FONT COLOR="#000077">Topic Connections</FONT></H4>
<P>The TopicConnection is a special kind of Connection designed for publish-subscribe messaging and inherits the methods from that interface, as listed in Table 20.1. TopicConnection also defines three new methods. The first:
</P>
<PRE>
public TopicSession createTopicSession(boolean transacted,
                                       int acknowledgeMode)
                                       throws JMSException
</PRE>
<P>is used to create a session for your publish-subscribe messaging. This method takes a Boolean that indicates whether the returned session will use transactions and an integer that indicates the acknowledgment mode.
</P>
<P>The second and third methods defined in TopicConnection are:</P>
<PRE>
public ConnectionConsumer createConnectionConsumer(Topic topic
                                     , String messageSelector
                                     , ServerSessionPool sessionPool
                                     , int maxMessages)
                                     throws JMSException
public ConnectionConsumer
        createDurableConnectionConsumer(Topic topic
                                     , String messageSelector
                                     , ServerSessionPool sessionPool
                                     , int maxMessages)
                                       throws JMSException
</PRE>
<P>These methods are for use in an application server and are not really part of the client API.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading25"></A><FONT COLOR="#000077">Topic Sessions</FONT></H4>
<P>The session created by a TopicConnection implements the TopicSession interface. This interface extends the Session interface described above and adds methods specific to publish-subscribe messages.
</P>
<P>The first thing that a TopicSession can do is create a special type of MessageProducer called a TopicPublisher. Use the method:</P>
<PRE>
public TopicPublisher createPublisher(Topic topic)
                                         throws JMSException
</PRE>
<P>to create this object for a specific topic.
</P>
<P>The session can also create special MessageConsumers called TopicSubscribers for a queue. There are four methods for creating consumers. The first two methods create normal subscribers:</P>
<PRE>
public TopicSubscriber createSubscriber(Topic topic)
                                      throws JMSException

public TopicSubscriber createSubscriber(Topic topic
                                    , String messageSelector
                                    , boolean noLocal)
                                     throws JMSException
</PRE>
<P>The second two create durable subscribers:
</P>
<PRE>
public TopicSubscriber createDurableSubscriber(Topic topic
                                      , String name)
                                      throws JMSException

public TopicSubscriber createDurableSubscriber(Topic topic
                                    , String name
                                    , String messageSelector
                                    , boolean noLocal)
                                     throws JMSException
</PRE>
<P>The noLocal flag in these methods indicates whether a subscriber wants to receive messages sent by the client that created the subscription. The main difference between creating durable subscribers and plain subscribers is that durable subscribers have a name. This name is used to store messages for the subscriber when it is unavailable for message delivery. In usage, the main difference is that a durable subscriber will receive messages that were sent to it while it was not running, and a nondurable subscriber will not.
</P>
<P>Because a durable subscriber implies persistence, they require a mechanism for removing them from the JMS system. This mechanism is the TopicSession method:</P>
<PRE>
public void unsubscribe(java.lang.String name) throws JMSException
</PRE>
<P>which takes the name of the durable subscription and unsubscribes it.
</P>
<P>Finally, the TopicSession can be used to create Topics. The method:</P>
<PRE>
public Topic createTopic(String topicName) throws JMSException
</PRE>
<P>creates a real topic. This method may not be supported by all providers. Instead, providers may and should provide administration tools for defining queues. The name of a topic can be provider specific, so using create topic is not a portable coding convention.
</P>
<P>The TopicSession can also create temporary topics using the method:</P>
<PRE>
public TemporaryTopic createTemporaryTopic() throws JMSException
</PRE>
<P>Temporary topics are deleted automatically when the client stops using them. You can also use TemporaryTopic&#146;s delete method to force deletion of the topic. Often, temporary topics are created to act as the reply-to destination for messages. The name of a temporary topic is defined by the provider&#146;s code, so this method is portable across JMS providers.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading26"></A><FONT COLOR="#000077">The Topic Publisher</FONT></H4>
<P>The TopicPublisher provides four methods for sending messages to a topic. These methods are listed in Table 20.12.
</P>
<P>The publisher also provides the method getTopic to access its default topic.</P>
<P>The following example program displays a user interface, pictured in Figure 20.6, that allows the user to select a topic and send messages to it. This example is similar to the QueueSenderTest described earlier. TopicPublisherTest is a JPanel that handles user events by creating messages for a specified topic.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-14.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-16.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

