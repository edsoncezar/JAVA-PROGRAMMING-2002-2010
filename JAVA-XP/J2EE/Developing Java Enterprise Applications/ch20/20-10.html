<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Programming with the Java Messaging Service</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-09.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-11.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The session can also create special MessageConsumers called QueueReceivers for a queue. There are two methods for creating consumers; both take a Queue and one takes a message selector.
</P>
<PRE>
public QueueReceiver createReceiver(Queue queue) throws JMSException
public QueueReceiver createReceiver(Queue queue
                                    ,String messageSelector)
                                      throws JMSException
</PRE>
<P>A QueueSession can also create an object called a QueueBrowser for inspecting the contents of a queue:
</P>
<PRE>
public QueueBrowser createBrowser(Queue queue) throws JMSException
public QueueBrowser createBrowser(Queue queue
                                  ,String messageSelector)
                                  throws JMSException
</PRE>
<P>JMS does not require the browser to provide an up-to-the-minute picture of the queue.
</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>Not all providers will support queue browsers, because they may represent unreasonable resource usage. MiniJMS does not support them.</FONT><HR>
</BLOCKQUOTE>
<P>The queue browser implements four methods, described in Table 20.10, for accessing its information. These methods are used to get the queue and selector associated with the browser, get an enumeration for the messages in the queue, and close the browser.
</P>
<P>The primary method of interest is probably the getEnumeration method, which returns an Enumeration that steps through the messages in the browser&#146;s queue.</P>
<P>Finally, the QueueSession can be used to create Queues. The method:</P>
<PRE>
public Queue createQueue(String queueName) throws JMSException
</PRE>
<P>creates a real queue. This method may not be supported by all providers. Instead, providers may and should provide administration tools for defining queues. The name of a queue can be provider specific, so using create queue is not a portable coding convention.
</P>
<P>The QueueSession can also create temporary queues using the method:</P>
<PRE>
public TemporaryQueue createTemporaryQueue() throws JMSException
</PRE>
<P>Temporary queues are deleted automatically when the client stops using them. You can also use the TemporaryQueue&#146;s delete method to force deletion of the queue. Often, temporary queues are created to act as the reply-to destination for messages. The name of a temporary queue is defined by the provider&#146;s code, so this method is portable across JMS providers.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading19"></A><FONT COLOR="#000077">The Queue Sender</FONT></H4>
<P>In order to send messages to a Queue, you use the QueueSession to create a QueueSender. This object defines four methods for sending a message to a queue. These methods are described in Table 20.11.
</P>
<P>The sender also provides the method getQueue to access its default queue.</P>
<P>The following example shows how a QueueSender is used in an application. QueueSenderTest defines a JFC application. The application displays a window, pictured in</P>
<TABLE WIDTH="100%"><TR>
<TD CAPTION ALIGN="LEFT" COLSPAN="2"><B>Table 20.10</B> QueueBrowser Methods
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TH VALIGN="TOP" WIDTH="50%" ALIGN="LEFT">METHOD
<TH VALIGN="TOP" ALIGN="LEFT">DESCRIPTION
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public Queue getQueue() throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Returns the Queue associated with this browser.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public String getMessageSelector() throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Returns the browser&#146;s assigned message selector.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public Enumeration getEnumeration() throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Returns an Enumeration for the queue&#146;s messages.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public void close() throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Closes the browser and frees resources.
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<P>
</P>
<TABLE WIDTH="100%"><TR>
<TD CAPTION ALIGN="LEFT" COLSPAN="2"><B>Table 20.11</B> QueueSender Methods
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TH VALIGN="TOP" WIDTH="50%" ALIGN="LEFT">METHOD
<TH VALIGN="TOP" ALIGN="LEFT">DESCRIPTION
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public void send(Message msg) throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Sends a message to the sender&#146;s queue with the default mode, priority, and timeToLive.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public void send(Message msg, int deliveryMode, int priority, long timeToLive) throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Sends a message to the sender&#146;s queue with the specified mode, priority, and timeToLive.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public void send(Queue queue, Message message) throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Sends a message to the specified queue with the default mode, priority, and timeToLive.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>public void send(Queue queue, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Sends a message to the specified queue with the specified mode, priority, and timeToLive.
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<P>Figure 20.2, that contains fields for assigning the queue to send to and the message to send. Once the user assigns a queue, he or she can send messages to it by typing in the Send field and pressing Enter or the Send button.
</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>Many of the examples in this chapter use the same basic style as this one, in the sense that they are JFC programs. As a result, all of the code for each example is not shown every time. The entire code is shown for this first example only. Refer to the CD-ROM for the complete code on further examples.<P>This is the first example in the chapter, so be sure to reread the section on running these examples at the beginning of the chapter before you try to run this one or any of the others.
</P>
</FONT><HR>
</BLOCKQUOTE>
<P>The first part of the QueueSenderTest class definition imports the appropriate packages and defines the class name. Variables for all of the JMS objects that will be created are also defined, as are the text fields that are used to interact with the user. To improve maintenance, constant strings are used for the action commands on the text fields and buttons.
</P>
<P><A NAME="Fig2"></A><A HREF="images\20-02.jpg"><IMG SRC="images\20-02t.jpg"></A>
<BR><A HREF="images\20-02.jpg"><FONT COLOR="#000077"><B>Figure 20.2</B></FONT></A>&nbsp;&nbsp;QueueSenderTest.</P>
<PRE>
import javax.jms.*;
import javax.naming.*;
import minijms.*;

import com.sun.java.swing.*;
import java.awt.*;
import java.awt.event.*;

public class QueueSenderTest extends JPanel
 implements ActionListener
{
    JTextField sendField;
    JTextField queueField;

    <B>javax.jms.QueueSession session;
    javax.jms.QueueSender sender;
    javax.jms.QueueConnection conn;
    javax.jms.QueueConnectionFactory factory;</B>

    public static final String send_action=&#148;send&#148;;
    public static final String queue_action=&#148;queue&#148;;
</PRE>
<P>Next, define the constructor for the QueueSenderTest object. A user name that will act as the name used to create the connection is provided. MiniJMS uses this name to identify various clients, but it may be ignored by some providers. The first part of the constructor defines variables.
</P>
<PRE>
    public QueueSenderTest(String user)
    {
        JLabel label;
        JButton button;
        JPanel tmp;
        Context context;
        Font f = new Font(&#147;Serif&#148;,Font.PLAIN,16);

        setFont(f);
</PRE>
<P>Then create the JMS objects for sending messages. At this point, only objects that don&#146;t require a destination to be specified are created. Once the user specifies a queue name, the remaining objects are created. Note the use of MiniJMSUtils, discussed earlier, to create the JNDI context using a properties file in the example directory.
</P>
<PRE>
try
        {
                    <B>MiniJMSUtils.init(&#147;queuesender.properties&#148;);</B>
            context = MiniJMSUtils.context;

            <B>factory
             = (QueueConnectionFactory)
             context.lookup(&#147;QueueConnectionFactory&#148;);

            conn
             = factory.createQueueConnection(user,null);

            session =
            conn.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);</B>

            if(session == null) throw new Exception();
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
            System.exit(0);
        }
</PRE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-09.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-11.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

