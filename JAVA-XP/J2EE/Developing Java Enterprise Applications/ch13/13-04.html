<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Introduction to Java RMI</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="13-03.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="13-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The last part of the RMI relationship is the connection between the client and server.
</P>
<TABLE WIDTH="100%"><TD CAPTION ALIGN="LEFT" COLSPAN="2"><B>Table 13.4</B> Server System Properties
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT" WIDTH="35%">PROPERTY
<TH VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">DESCRIPTION
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="35%"><SMALL>java.rmi.server.codebase</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">A URL indicating the code base from which classes should be loaded for network clients.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="35%"><SMALL>java.rmi.server.disableHttp</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">If true, RMI will not use HTTP to try to tunnel through firewalls. The default is false, indicating that HTTP is used to wrap RMI calls.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="35%"><SMALL>java.rmi.server.hostname</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">Sets the server&#146;s fully qualified host name, if the name is unavailable via DNS. This value is not set by default.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="35%"><SMALL>java.rmi.dgc.leaseValue</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">The time in milliseconds until the server notices that the client is no longer connected. The default is 10 minutes.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="35%"><SMALL>java.rmi.server.logCalls</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT" WIDTH="55%">If true, the RMI library will log information about calls. The default is false.
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">Connecting the Client and Server</FONT></H4>
<P>All distributed object systems must be able to locate remote objects on the network and provide mechanisms for communicating between objects. These mechanisms are used to create the initial connection between two programs based on the well-known locating service.
</P>
<P>RMI provides a service called the rmiregistry that keeps track of objects by name. An application connects to the registry on a known port and requests access to an object based on the unique name with which it was registered. Once this connection is made, the client object can invoke methods of the remote object as though it were located in the same virtual machine as the client. Think of the registry as a telephone operator that can connect you to a specific person based on a known value&#151;their telephone number. Everyone knows how to locate the operator, so everyone can access other objects.</P>
<P>Use the java.rmi.Naming class to locate a registry and bind or lookup objects in it. The Naming class uses a string URL of the format //host:port/name to indicate the host and port for the object&#146;s rmiregistry process and the name of the object itself. For example, the URL //192.168.0.172:8099/blaster will locate the object named blaster on the machine 192.168.0.172 at port 8099. If no port is provided, the default port for the rmiregistry service is used.</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>Don&#146;t confuse the java.rmi.Naming class with the JNDI Naming package. Although they do provide similar services, the RMI Naming class specifically locates objects in an RMI registry. Sun provides a JNDI provider that accesses the RMI registry if you prefer to use it instead of the Naming class.</FONT><HR>
</BLOCKQUOTE>
<P>The methods defined in Naming are similar to the methods in a JNDI context. However, all of the methods for Naming are static and don&#146;t require the creation of any objects to access them. A complete list of methods for java.rmi.Naming is provided in Table 13.5. Essentially, objects can be bound to the registry with a name or found in the registry by name.
</P>
<P>All of the exceptions listed in Table 13.5 are either MalformedURLExceptions, indicating that the URL is incorrect, or described in Tables 13.2 or 13.3.</P>
<P>Programs will often use the rebind method in Naming to insure that if the name is in use, it is replaced. This could be dangerous if several programs used the same name, but it can help during the development phase by allowing the server to be run over and over without trouble.</P>
<P>Servers don&#146;t have to rely on the rmiregistry service to make themselves available to Naming lookups. Instead, a server can create a private registry. This will allow the server to run autonomously, without requiring that the rmiregistry process be run concurrently to manage lookup requests.</P>
<P>To create a private registry, use the class rmi.registry.LocateRegistry. This class provides two methods, listed here, for creating a private registry.</P>
<PRE>
public static Registry createRegistry(int port)
                      throws RemoteException;

public static Registry createRegistry(int port,
                      RMIClientSocketFactory csf,
                      RMIServerSocketFactory ssf)
                      throws RemoteException
</PRE>
<P>The objects returned from these methods implement the Registry interface. Registry provides the same methods as Naming and defines the static variable REGISTRY_PORT that indicates the default port used for a private registry.
</P>
<P>LocateRegistry also provides methods for finding a registry based on a port and host name. These methods are used by the Naming class to locate the rmiregistry service&#146;s registry object. They can also be used to locate a private registry. However, clients need to access the registry using the LocateRegistry object only if the server is expecting the client to use a custom Socket class.</P>
<P>When a client looks up a server, it receives a stub that implements the server&#146;s remote interface. Messages sent to this stub can take three kinds of arguments. Primitive types, like int, are sent as data across the connection. Objects that implement Serializable are serialized and sent along with the message, thus creating a copy on either end. Objects that implement Remote initiate the creation of an RMI relationship between the receiver and the sender. Thus passing remote objects across the wire can create more RMI relationships. However, for an object to be available for RMI, it must be exported using the UnicastRemoteObject classes exportObject methods or using the Activation frameworks.</P>
<P>Remember that if two programs have a bidirectional conversation in which both are sending and receiving messages, they are both clients and servers. This situation usually occurs when one program registers in the registry and the other finds it before sending itself as an argument to a message. The registry is the bootstrap used to create the initial connection. Passing remote objects across the connection is the mechanism for adding bidirectionality to the relationship.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="13-03.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="13-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

