<HTML>
<HEAD>


<TITLE>Developing Java Enterprise Applications:Transactions, JTA, and JTS</TITLE>





<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="..\ch21\21-06.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="22-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">CHAPTER 22<BR>Transactions, JTA, and JTS
</FONT></H2>
<P>A <I>transaction</I> is a single unit of work. Transactions define a boundary around a set of operations. For example, most commercial databases use transactions to group changes to data. These database transactions ensure that if a purchase is recorded, the accompanying customer balance is adjusted accordingly. Failure to perform either operation will cause both to fail.</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>If you are familiar with transactions, you will probably want to skip the next discussion and go directly to the section, &#147;Transactions in Java.&#148;</FONT><HR>
</BLOCKQUOTE>
<P>Transactions are associated with a set of resources and operations. Database transactions, for example, are associated with the database&#146;s data and the operations that can interact with it. Transactions enact three basic operations, pictured in Figure 22.1. First, a transaction can be started. Starting a transaction marks the current state of a system. Committing a transaction updates the system to include all of the changes made since the transaction was started. Rolling back a transaction cancels all of the operations performed since the transaction began, returning the system to its initial state.
</P>
<P>In a sense, that is all there is to transactions. As a programmer, you will use them to bracket code that should be executed or that will fail as single unit. The term <I>atomic</I> is used to indicate this unified nature of transactions. In this context, the word <I>atomic</I> means that the transaction can only succeed completely or fail completely. It cannot partially succeed.</P>
<P><A NAME="Fig1"></A><A HREF="images\22-01.jpg"><IMG SRC="images\22-01t.jpg"></A>
<BR><A HREF="images\22-01.jpg"><FONT COLOR="#000077"><B>Figure 22.1</B></FONT></A>&nbsp;&nbsp;Transaction operations.</P>
<P>Logically, it is necessary to associate transactions with some form of locking. For example, if one client tries to update a counter from 4 to 5, then rolls back the change, the counter should be at 4. If the counter is not locked throughout the transaction&#146;s scope, another client could update the counter to 5, resulting in either the second change being lost or the first rollback being ineffective. The locks associated with transactions are very similar to the locks used to protect data in multithreaded programs.
</P>
<P>Transaction locks can often be grouped into one of several categories. Locks can be <I>optimistic</I>, as pictured in Figure 22.2&#151;meaning that the transaction doesn&#146;t really lock the data, but hopes that the underlying data is unchanged during its operations.</P>
<P>If there is a change to the underlying data, the commit or rollback operation fails. Optimistic locks are common in situations in which data is not shared very much and reduces the resource usage associated with locking. Figure 22.3 shows an example of how an optimistic lock can fail. In this example, one transaction gets data from the store, updates it, and inserts the data into the store. Another transaction performs the same three operations. But because the operations overlap in time, the update at step 5 will be overridden by the update in step 6, without the transaction that performs the update knowing that the data has changed since it first copied it.</P>
<P><A NAME="Fig2"></A><A HREF="images\22-02.jpg"><IMG SRC="images\22-02t.jpg"></A>
<BR><A HREF="images\22-02.jpg"><FONT COLOR="#000077"><B>Figure 22.2</B></FONT></A>&nbsp;&nbsp;Optimistic locking.</P>
<P><A NAME="Fig3"></A><A HREF="images\22-03.jpg"><IMG SRC="images\22-03t.jpg"></A>
<BR><A HREF="images\22-03.jpg"><FONT COLOR="#000077"><B>Figure 22.3</B></FONT></A>&nbsp;&nbsp;Failed optimistic lock.</P>
<P><I>Pessimistic locks</I> protect their data throughout the transaction scope. This ensures that the commit or rollback will not be affected by other clients or transaction scopes. However, pessimistic locks are the most resource intensive and can, in some instances, make it hard for transactions to share data optimally.</P>
<P>Java programs do not really deal with the locking associated with transactions. You will, however, need to recognize that these locks may underlay the operations that you take. This means that like thread programming, transaction programming can produce deadlocks when a transaction tries to acquire a resource held by another transaction. One example of a deadlock, pictured in Figure 22.4, occurs when the first transaction locks resource 1 before trying to lock resource 2 while the second transaction locks resource 2 and then tries to lock resource 1. As a result, transaction 1 is waiting on transaction 2, and transaction 2 is waiting on transaction 1, so neither can proceed.</P>
<P>Threads are, in fact, a great analogy for transactions. In most cases, transactions are used when multiple clients are accessing a resource. However, transactions can also be used by several threads in a single&#150;client program. In this analogy, transactions group operations the same way that threads group operations.</P>
<P>Database transactions are a great example of a single resource&#146;s use of transactions to protect itself and its data. As enterprise&#150;level computing resources have grown and become more complex, there has been a demand for transactions that can span several databases or other resources. These transactions are called <I>distributed transactions</I> because their scope can span multiple resources on numerous computers.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="..\ch21\21-06.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="22-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

