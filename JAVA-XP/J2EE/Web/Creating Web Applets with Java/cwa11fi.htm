<HTML>

<HEAD>

<TITLE>Creating Web Applets with Java cwa11fi.htm</TITLE>

<LINK REL="ToC" HREF="index.htm">

<LINK REL="Next" HREF="cwa12fi.htm">

<LINK REL="Previous" HREF="cwa10fi.htm"></HEAD>

<BODY TEXT="#000000" LINK="#0000FF" VLINK="#FF0000"  bgcolor=white >









<P><A HREF="cwa10fi.htm"><IMG SRC="http://docs.rinet.ru/WebApp/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/WebApp/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="cwa12fi.htm"><IMG SRC="http://docs.rinet.ru/WebApp/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>


</P><UL>

<LI>

<A HREF="#I1">&#151; 11 &#151;Building a User Interface</A></LI>

<UL>

<UL>

<LI>

<A HREF="#I3">Introduction to the AWT</A></LI>

<UL>

<LI>

<A HREF="#I4">A Simple Example</A></LI>

<LI>

<A HREF="#I5">Don't Panic: Some Practical Advice for Using the AWT</A></LI></UL>

<LI>

<A HREF="#I6">Event Handling</A></LI>

<UL>

<LI>

<A HREF="#I7">Adding Basic Event Handling</A></LI>

<LI>

<A HREF="#I8">Using Event Handling Methods</A></LI></UL>

<LI>

<A HREF="#I9">Components</A></LI>

<UL>

<LI>

<A HREF="#I10">Interface Components</A></LI>

<LI>

<A HREF="#I11">Common Methods of All Components</A></LI>

<UL>

<LI>

<A HREF="#I12">Setting Foreground and Background Color</A></LI>

<LI>

<A HREF="#I13">Disabling and Enabling</A></LI></UL>

<LI>

<A HREF="#I14">Containers</A></LI>

<LI>

<A HREF="#I15">Layouts</A></LI></UL>

<LI>

<A HREF="#I16">Designing a User Interface</A></LI>

<LI>

<A HREF="#I17">Summary</A></LI></UL></UL></UL>



<H1 ALIGN="CENTER">

<CENTER><A ID="I1" NAME="I1">

<BR>

<FONT SIZE=5><A ID="I2" NAME="I2"></A><B>&#151; 11 &#151;</B>

<BR><B>Building a User Interface</B>

<BR></FONT></A></CENTER></H1>

<P>If you want to create an applet with anything more than bare-bones user interaction, you must create a user interface for users to use. The Abstract Window Toolkit is a Java package made specifically for this task.

<BR></P>

<P>This chapter covers the basic aspects of building a user interface, including the essentials of the AWT and what you need to construct the interface and make it work. This chapter also covers how to make your interface a little better looking by 
manipulating colors, layout, and so on. Building user interfaces can be quite complex and is the subject of many books on its own. But this chapter should get you started in the right direction for creating user-friendly interfaces for your applets right 
away.

<BR></P>

<H3 ALIGN="CENTER">

<CENTER><A ID="I3" NAME="I3">

<FONT SIZE=4><B>Introduction to the AWT</B>

<BR></FONT></A></CENTER></H3>

<P>What do you think of when you hear the term <I>user interface</I>? Most people would list some variation of the following:

<BR></P>

<UL>

<LI>Buttons

<BR>

<BR></LI>

<LI>Windows

<BR>

<BR></LI>

<LI>Checkboxes

<BR>

<BR></LI>

<LI>Menus

<BR>

<BR></LI>

<LI>Scrollbars

<BR>

<BR></LI></UL>

<P>These items are what is known as <I>interface components</I>. The creators of Java realized that people would want this kind of functionality and included the capability to create applets with user interface components.

<BR></P>

<P>The Abstract Window Toolkit(normally referred to as the AWT) is a well-thought-out class and very portable windowing library. This standard part of the Java environment provides all the basic functionality one would expect to use in a modern windowing 
system: buttons, scrollbars, menus and other standard window components.

<BR></P>

<P>The AWT manages to preserve the look and feel of the user's system, so AWT-based applications won't get a reputation for having a Java-specific look. This characteristic is a positive thing as people tend to get very attached to their operating systems 

and resist using programs that work or look differently.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I4" NAME="I4">

<FONT SIZE=3><B>A Simple Example</B>

<BR></FONT></A></CENTER></H4>

<P>The bulk of the AWT is built around the Component class. A component is just the representation in Java of a user interface object. A component is the base object from which all AWT visual elements are subclassed, but for now just think of components as 

a set of building blocks that can be arranged as you please to do whatever you want.

<BR></P>

<P>One of the most basic components is a button. Listing 11.1 shows the cod for a simple applet that uses the AWT to display a button.

<BR></P>

<UL>

<LH><B>Listing 11.1. A simple button applet.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Example1 extends Applet {

    Button hiButton;

    public void init() {

        hiButton = new Button(&quot;Click Me!&quot;);

        add(hiButton);

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Example1.class width=250 height=100&gt;&lt;/applet&gt;</PRE>

<P>When the code is compiled and viewed, the applet shown in Figure 11.1 is displayed. Although the applet doesn't do much at this point, the button is functional.

<BR></P>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa01.gif">Figure 11.1. A simple applet that uses the </B><B>AWT.</A></B></P>

<P>What is important at this point is not to understand exactly what every line means, but to get a general feel for what is going on:

<BR></P>

<OL>

<LI>A button component is created with the label &quot;Click Me!&quot;

<BR>

<BR></LI>

<LI>The button is added to a container; in this case, the container is an applet.

<BR>

<BR></LI></OL>

<P>For a windowing program that produces output, there is surprisingly little code here. Almost all the real work of handling the user interface is hidden behind the scenes. If you are using basic components, it's relatively easy to keep your code simple. 

However, if you want to extend the functionality of the basic components, the complexity of your code increases.

<BR></P>

<P>When a component is created, it is usually added to a container. A <I>container</I> is an area of the screen in which components (and even other containers) can be placed. You can keep creating containers within containers indefinitely. The calculator 
example at the end of the chapter demonstrates this type of flexibility.

<BR></P>

<P>This flexibility is one of the biggest advantages of programming the AWT. The AWT enables you to think of the user interface as objects and concentrate on the relationships between objects, a concept which fits well with Java's object-oriented 
programming environment.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I5" NAME="I5">

<FONT SIZE=3><B>Don't Panic: Some Practical Advice for Using the AWT</B>

<BR></FONT></A></CENTER></H4>

<P>Programming any graphical interface can be a daunting task. Correspondingly, the AWT is one of the most difficult parts of Java to master. However, as long as you keep in mind a few basic tenets from the outset, the AWT is certainly manageable.

<BR></P>

<P>First, every viewable item in the AWT is subclassed from Component. Subclassing is just shorthand for &quot;is inherited from&quot;(inheritance is covered in detail in Chapter 9). This subclassing provides a core set of functions (things like setting 
color) that work across all components. Look at the API documentation to check where the class you using is inherited from. Usually the function you are looking for is a step or two up the chain, hidden in a parent class.

<BR></P>

<P>Second, everything in the AWT is event-driven. Unlike many styles of programming, you construct your program to respond to user actions rather than proceed in a linear manner. Although this approach adds a level of complexity to your programs, it also 
makes them much more usable.

<BR></P>

<P>Third, components are never placed on the page in absolute positions. Java was designed from the beginning to run on many different platforms and keep the look and feel of applets consistent with the operating system's native environment. The size and 
precise shape of a button, for example, isn't known to an interface designer. Therefore, all components are placed inside containers that are relative to other components. Although this way of doing things seems strange at first, it is a very powerful 
technique that will make your applications more robust.

<BR></P>

<HR ALIGN=CENTER>

<NOTE>

<IMG SRC="http://docs.rinet.ru/WebApp/note.gif" WIDTH = 35 HEIGHT = 35>Note: If you've ever done Windows or Macintosh programming before, many of the underlying concepts are very similar to programming with AWT, especially if you've used a class library like OWL or MFC. The major 
difference is simplicity. Most concepts in the AWT are much more straightforward than other development environments.

<BR></NOTE>

<HR ALIGN=CENTER>

<H3 ALIGN="CENTER">

<CENTER><A ID="I6" NAME="I6">

<FONT SIZE=4><B>Event Handling</B>

<BR></FONT></A></CENTER></H3>

<P>An <I>event</I> is a communication from the outside world to the program that something has occurred. The following are a few basic event types:

<BR></P>

<UL>

<LI><B>Mouse clicks.</B> This type of event is generated when the mouse button is clicked while positioned over a component.

<BR>

<BR></LI>

<LI><B>Mouse movement.</B> Whenever the mouse is moved over a component, many events are sent to the component informing it what coordinate in the component the mouse has moved to.

<BR>

<BR></LI>

<LI><B>Action events.</B> When the user manipulated a component that allows interaction with the user, an action event is created by default, and the owner of the component (usually the container in which the component is placed) is notified that something 

happened.

<BR>

<BR></LI></UL>

<P>One of the most important things to understand about the AWT is how events are handled. Without events, your application cannot respond to user actions.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I7" NAME="I7">

<FONT SIZE=3><B>Adding Basic Event Handling</B>

<BR></FONT></A></CENTER></H4>

<P>Listing 11.2 shows the code that adds basic event handling to the example from earlier in the chapter.

<BR></P>

<UL>

<LH><B>Listing 11.2. The Button applet with event handling.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Example2 extends Applet {

    Button hiButton;

    public void init() {

        hiButton = new Button(&quot;Click Me!&quot;);

        add(hiButton);

    }

    public boolean action(Event evt, Object what) {

        if (evt.target == hiButton) {

            hiButton.setLabel(&quot;Clicked!&quot;);

            return true;

        }

        else

            return false;

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Example2.class width=250 height=100&gt;&lt;/applet&gt;</PRE>

<P>Figure 11.2 shows the output of the modified applet. All that has been changed is the addition of the action() method. When a component that has an action associated with it (for example, a button) is manipulated by the user, the action() method of that 

component is called.

<BR></P>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa02.gif">Figure 11.2. Adding simple event handling.</A></B></P>

<P>This example uses the default Button class instead of subclassing a new one. The default event handler tries to handle the action() event inside of the Button class, but cannot find a handler that will take the event. The default event handler then 
passes the event up the chain of components to the container that holds the component. It keeps passing the event until it finds a handler that accepts the event or hits the top of the chain.

<BR></P>

<P>To understand exactly what's happening, look at the first line of the action() method:

<BR></P>

<PRE>public boolean action(Event evt, Object what) {</PRE>

<P>All event handlers have a form similar to this line. They accept a parameter of type Event that provides detailed information about the event. The action() method also takes a parameter of type Object(a generic object) that lets you know what action is 

occurring. You can ignore this parameter in this example because there is only one possible action for a button. Lastly, event handlers return a boolean value indicating true if the event was handled or false if it was not.

<BR></P>

<P>The next line of the action() method is as follows:

<BR></P>

<PRE>If (evt.target == hiButton) {</PRE>

<P>In this line, the target of the event is being checked to see whether or not it is the button. Because evt.target and hiButton are both objects, you can check to see whether they are the same object.

<BR></P>

<P>The action() method then shows the following line:

<BR></P>

<PRE>hiButton.setLabel(&quot;Clicked!&quot;);</PRE>

<P>Because the button was clicked, setLabel is used to change the button to reflect that it was clicked.

<BR></P>

<P>The action() method ends with the following lines:

<BR></P>

<PRE>    return true;

}

else

    return false;</PRE>

<P>Finally, if the event was handled, true is returned. If the event wasn't handled, false is returned. The event handler keeps searching for a method that will accept the event. Acceptance of the event is signaled by returning true.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I8" NAME="I8">

<FONT SIZE=3><B>Using Event Handling Methods</B>

<BR></FONT></A></CENTER></H4>

<P>In almost all cases, you will want to use the event handling methods that Sun has provided for you. Table 11.1 summarizes these methods. Remember that everything is relative to the component. For example, the mouseMove() method of a component is called 

when the mouse is moved inside that component.

<BR></P>

<UL>

<LH><B>Table 11.1. A summary of event handling methods.</B>

<BR></LH></UL>

<TABLE BORDER>

<TR>

<TD>

<PRE><I>Event Type</I>

<BR></PRE>

<TD>

<PRE><I>Method</I>

<BR></PRE>

<TR>

<TD>

<P>Action taken</P>

<TD>

<P>action(Event evt, Object what)</P>

<TR>

<TD>

<P>Mouse button pressed</P>

<TD>

<P>mouseDown(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Mouse button released</P>

<TD>

<P>mouseUp(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Mouse moved</P>

<TD>

<P>mouseMove(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Mouse dragged</P>

<TD>

<P>mouseDrag(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Mouse enters component</P>

<TD>

<P>mouseEnter(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Mouse exits component</P>

<TD>

<P>mouseExit(Event evt, int x, int y)</P>

<TR>

<TD>

<P>Key pressed</P>

<TD>

<P>keyDown(Event evt, int key)</P>

<TR>

<TD>

<P>Key released</P>

<TD>

<P>keyUp(Event evt, int key)</P></TABLE>

<P>When would you want to use methods other than action()? The answer is when you want to change the behavior of a component as opposed to just using it. The action() method only reports events that are essential to the function of the component, such as a 

mouse click on a button. Listing 11.3 shows new behavior added to the preceding example.

<BR></P>

<UL>

<LH><B>Listing 11.3. The button applet with new behaviors.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Example3 extends Applet {

    Button hiButton;

    public void init() {

        hiButton = new Button(&quot;Click Me!!!&quot;);

        add(hiButton);

    }

    public boolean mouseEnter(Event evt, int x, int y) {

        hiButton.setLabel(&quot;Go Away!&quot;);

        return true;

    }

    public boolean mouseExit(Event evt, int x, int y) {

        hiButton.setLabel(&quot;Stay Away!&quot;);

        return true;

    }

    public boolean action(Event evt, Object what) {

        if (evt.target == hiButton) {

            hiButton.setLabel(&quot;Clicked!&quot;);

            return true;

        }

        else

            return false;

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Example3.class width=250 height=100&gt;&lt;/applet&gt;</PRE>

<P>Figure 11.3 shows the output of the applet. Whenever the mouse moves over the applet, the user is informed that perhaps clicking the button isn't such a good idea.

<BR></P>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa03.gif">Figure 11.3. An applet with live feedback.</A></B></P>

<P>In most circumstances, you will only need to use action() to handle all the events in your applet. However, knowing how to handle things at a lower level gives you a great deal more control that can come in handy. Suppose you had an animation applet 
that you wanted to only animate when the mouse was over it. The mouseEnter() and mouseExit() methods would enable you to program this action.

<BR></P>

<H3 ALIGN="CENTER">

<CENTER><A ID="I9" NAME="I9">

<FONT SIZE=4><B>Components</B>

<BR></FONT></A></CENTER></H3>

<P>Components are the building blocks from which all programs using the AWT are built. Many other classes handle the components and the interactions between them, but if it's on-screen, it's a component.

<BR></P>

<P>All components have the following things in common:

<BR></P>

<UL>

<LI>A screen position and a size

<BR>

<BR></LI>

<LI>A foreground and background color

<BR>

<BR></LI>

<LI>Being either enabled or disabled

<BR>

<BR></LI>

<LI>A standard interface to handle events

<BR>

<BR></LI></UL>

<P>AWT components can be broken down conceptually into three major categories:

<BR></P>

<UL>

<LI>Interface components encompass all the standard controls normally associated with a windowing system. Examples of these include buttons, text labels, scrollbars, pick lists, and text entry fields.

<BR>

<BR></LI>

<LI>Containers encompass areas in which components can be placed. Groups of components can then be grouped together to form a more cohesive object to be manipulated. A panel is an example of this type of component. One way to think of a container is as a 
bookcase and components are the books that are placed there.

<BR>

<BR></LI>

<LI>Windows are a very special case of the Component class. All other components are added onto a container that already exists, whereas a Window is an actual separate window with a completely new area to create an interface upon. Dialog boxes and frames 
are examples of this type of component. Normally windows are not used with applet programming.

<BR>

<BR></LI></UL>

<H4 ALIGN="CENTER">

<CENTER><A ID="I10" NAME="I10">

<FONT SIZE=3><B>Interface Components</B>

<BR></FONT></A></CENTER></H4>

<P>Interface components are components specifically designed to give information to or get information from the user. The button used in previous examples is a prototypical example of an interface component. Table 11.2 lists the components available in 
Java.

<BR></P>

<UL>

<LH><B>Table 11.2. Standard components.</B>

<BR></LH></UL>

<TABLE BORDER>

<TR>

<TD>

<PRE><I>Component</I>

<BR></PRE>

<TD>

<PRE><I>Explanation</I>

<BR></PRE>

<TR>

<TD>

<P>Button</P>

<TD>

<P>A clickable button</P>

<TR>

<TD>

<P>Canvas</P>

<TD>

<P>A generic component, a blank canvas</P>

<TR>

<TD>

<P>Checkbox</P>

<TD>

<P>A clickable box</P>

<TR>

<TD>

<P>Label</P>

<TD>

<P>A simple text label</P>

<TR>

<TD>

<P>List</P>

<TD>

<P>A list of things to select from</P>

<TR>

<TD>

<P>Scrollbar</P>

<TD>

<P>A bar to scroll around a document</P>

<TR>

<TD>

<P>TextField</P>

<TD>

<P>A one-line field to edit text</P>

<TR>

<TD>

<P>TextArea</P>

<TD>

<P>Like a TextField, but allows multiple lines</P></TABLE>

<P>Earlier it was mentioned that straightforwardness was one of the hallmarks of the design of the AWT. Listing 11.4 demonstrates this fact with the code for an applet that uses multiple interface components. Figure 11.4 shows what this applet looks like 
on-screen.

<BR></P>

<UL>

<LH><B>Listing 11.4. An applet to showcase multiple components.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class ManyComp extends Applet {

    Button aButton;

    Checkbox aBox;

    Label aLabel;

    TextField aTextField;

    public void init() {

        aButton = new Button(&quot;Ok&quot;);

        aBox = new Checkbox(&quot;Show&quot;);

        aLabel = new Label(&quot;Hello!&quot;);

        aTextField = new TextField(&quot;37&quot;, 5);

        add(aButton);

        add(aBox);

        add(aLabel);

        add(aTextField);

    }

}</PRE>

<P>The HTML for this applet is as follows:

<BR></P>

<PRE>&lt;applet code=ManyComp.class width=250 height=600&gt;&lt;/applet&gt;</PRE>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa04.gif">Figure 11.4. An applet with many components.</A></B></P>

<P>The variable declarations in this example are pretty straightforward. To make sure you understand exactly what's going on, this section provides a line-by-line explanation.

<BR></P>

<P>The following line creates a button with the caption Ok:

<BR></P>

<PRE>aButton = new Button(&quot;Ok&quot;);</PRE>

<P>The next line creates a checkbox with the caption Show. A checkbox is a labeled box that can be checked on or off.

<BR></P>

<PRE>aBox = new Checkbox(&quot;Show&quot;);</PRE>

<P>In the following line, a label containing the string Hello! is created. A label is just text that is drawn on-screen, usually to clarify things.

<BR></P>

<PRE>aLabel = new Label(&quot;Hello!&quot;);</PRE>

<P>Finally, a TextField that contains 37 and allows up to five characters to display is created. A user can type in a text field, and text fields are one of the principal means of entering data into an applet.

<BR></P>

<PRE>aTextField = new TextField(&quot;37&quot;, 5);</PRE>

<H4 ALIGN="CENTER">

<CENTER><A ID="I11" NAME="I11">

<FONT SIZE=3><B>Common Methods of All Components</B>

<BR></FONT></A></CENTER></H4>

<P>The bulk of the AWT is subclassed from the Component class. Thankfully, the Component class contains a great deal of functionality that is available to all those subclassed components, as described in the following sections.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I12" NAME="I12">

<FONT SIZE=3><B>Setting Foreground and Background Color</B>

<BR></FONT></A></CENTER></H5>

<P>Color in Java is abstracted into the Color class, which has a number of static variables to represent color (see Table 11.3) and the capability to specify an arbitrary color with an instance of the Color object:

<BR></P>

<PRE>Color aColor = new Color(int r, int g, int b)</PRE>

<P>In this example, the r, g, and b are the red, green, and blue components specified in a 24-bit palette. In the 24-bit color palette, each color (R, G, or B) is represented by a number from 0 to 254. By specifying the value of each color, you can create 

up to 16.7 million colors. However, if you want to use a fairly common color, such as red, Java provides some standard, pre-defined color variables, which are listed in Table 11.3.

<BR></P>

<UL>

<LH><B>Table 11.3. Standard color variables available in Java.</B>

<BR></LH></UL>

<P>black</P>

<P>blue</P>

<P>cyan</P>

<P>darkGray</P>

<P>gray</P>

<P>green</P>

<P>lightGray</P>

<P>magenta</P>

<P>orange</P>

<P>pink</P>

<P>red</P>

<P>white</P>

<P ALIGN="CENTER">

<CENTER>yellow</CENTER></P>

<P>You can set the foreground color of a component with the setForeground method:

<BR></P>

<PRE>setForeground(Color.green)</PRE>

<P>This code sets the foreground color of the component to green. The foreground color is usually what is being drawn. For instance, on a label, the foreground would be the text itself and the background would be what the text is drawn upon.

<BR></P>

<P>You can set the background color with the setBackground() method:

<BR></P>

<PRE>void setBackground(Color.black)</PRE>

<P>This code sets the background color to black.

<BR></P>

<H5 ALIGN="CENTER">

<CENTER><A ID="I13" NAME="I13">

<FONT SIZE=3><B>Disabling and Enabling</B>

<BR></FONT></A></CENTER></H5>

<P>A component can be turned on or turned off by setting it to enabled or disabled. To enable the component, use the enable() method:

<BR></P>

<PRE>enable()</PRE>

<P>To disable a component, use the disable() method:

<BR></P>

<PRE>disable()</PRE>

<P>When a component is enabled, it has all the functionality you would expect: a button can be clicked, text can be entered into a text field, and so on. When a component is disabled, a user cannot interact with the component at all. For example, an applet 

that lets you calculate a loan might only let you click the Calculate button when all of the fields (amount, interestrate, and so forth) have been completed. Disabling the button until the applet checked the fields, and then enabling the button would allow 

this control.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I14" NAME="I14">

<FONT SIZE=3><B>Containers</B>

<BR></FONT></A></CENTER></H4>

<P>Containers are components that can contain other components, including other containers. Think of them as a way to subdivide the user interface into plots in which components can be placed or subdivided further.

<BR></P>

<P>The two general types of containers are panels and windows. The major difference between them is that a panel is a defined area on a window that already exists, and a window is an entirely new window. Also, the Applet class is a subclass of Panel, so an 

applet can be treated just like a panel.

<BR></P>

<P>The example in Listing 11.5 uses the add() method to add components to the panel. Figure 11.5 shows the results.

<BR></P>

<UL>

<LH><B>Listing 11.5. A simple button applet.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Example4 extends Applet {

    Button button1, button2;

    public void init() {

        button1 = new Button(&quot;First&quot;);

        add(button1);

        button2 = new Button(&quot;Second&quot;);

        add(button2);

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Example4.class width=250 height=100&gt;&lt;/applet&gt;</PRE>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa05.gif">Figure 11.5. A simple applet displaying two </B><B>buttons.</A></B></P>

<P>After the component is created, all that needs to be done is to call the add() method for the container with the specified component. If your interface is quite simple, adding components to a container in this manner may be enough. However, if you want 

to have some control over the placement of the components, you can use a layout.

<BR></P>

<H4 ALIGN="CENTER">

<CENTER><A ID="I15" NAME="I15">

<FONT SIZE=3><B>Layouts</B>

<BR></FONT></A></CENTER></H4>

<P>A layout can be thought of as a template that is placed over a container to define how components will be added. The most common layout is BorderLayout(), which orients components according to compass points except that the center area gets all leftover 

space. Table 11.4 lists all the layouts.

<BR></P>

<UL>

<LH><B>Table 11.4. A summary of layout methods and their features.</B>

<BR></LH></UL>

<TABLE BORDER>

<TR>

<TD>

<PRE><I>Layout</I>

<BR></PRE>

<TD>

<PRE><I>Description</I>

<BR></PRE>

<TR>

<TD>

<P>BorderLayout()</P>

<TD>

<P>Layout according to compass points</P>

<TR>

<TD>

<P>GridLayout()</P>

<TD>

<P>Layout on a grid</P>

<TR>

<TD>

<P>GridBagLayout()</P>

<TD>

<P>Layout on a grid where elements can be different sizes</P>

<TR>

<TD>

<P>CardLayout()</P>

<TD>

<P>Layout that contains a series of cards that can be flipped through</P>

<TR>

<TD>

<P>FlowLayout()</P>

<TD>

<P>Layout that puts components left to right</P></TABLE>

<P>The layout of a panel is established with the setLayout() method, and then new components are added using the add() method with an argument indicating placement, which can be north, south, west, east, or center. This argument comes before the component 

to be added. Listing 11.6 shows an applet that utilizes the borderLayout() method. Figure 11.6 shows the resulting applet is shown in.

<BR></P>

<UL>

<LH><B>Listing 11.6. Using layouts to control placement of components.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Example5 extends Applet {

    Button button1, button2;

    public void init() {

        setLayout(new BorderLayout());

        button1 = new Button(&quot;First&quot;);

        add(&quot;North&quot;, button1);

        button2 = new Button(&quot;Second&quot;);

        add(&quot;South&quot;, button2);

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Example5.class width=250 height=100&gt;&lt;/applet&gt;</PRE>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa06.gif">Figure 11.6. Demonstrating the </B><B>borderLayout()</B><B> </B><B>method.</A></B></P>

<P>In addition to BorderLayout, the most commonly used layouts are FlowLayout and GridLayout. A FlowLayout places components onto the container one after the other, left to right, top to bottom. This layout does not allow much flexibility in designing a 
user interface, but it is the most straightforward.

<BR></P>

<P>A GridLayout allows components to be placed one after another on a rigid grid. Although this layout sounds like the FlowLayout, it differs in that a GridLayout attempts to make all of the components placed on it the same size. Therefore, this layout 
makes sense for things like keypads or a screen that needs to be divided into equal sections.

<BR></P>

<H3 ALIGN="CENTER">

<CENTER><A ID="I16" NAME="I16">

<FONT SIZE=4><B>Designing a User Interface</B>

<BR></FONT></A></CENTER></H3>

<P>Suppose you wanted to create simple calculator applet. It would make sense to build the user interface first, and then add functionality one step at a time. A calculator would definitely require a display, so you could add that first using the code in 
Listing 11.7.

<BR></P>

<UL>

<LH><B>Listing 11.7. The calculator display.</B></LH></UL>

<PRE>import java.awt.*;

import java.applet.Applet;

public class Calculator extends Applet {

    Label display;

    public void init() {

        setLayout(new BorderLayout());

        display = new Label(&quot;0&quot;, 10);

        add(&quot;North&quot;, display);

    }

}</PRE>

<P>A BorderLayout makes sense in this example because the display will always be at the top of the screen. Adding the keypad is a bit trickier. The keypad needs 10 number buttons and 4 operation keys grouped together, which calls for a few more panels with 

the appropriate keys added. Listing 11.8 shows how to manipulate the layouts to produce the applet shown in Figure 11.7.

<BR></P>

<UL>

<LH><B>Listing 11.8. The calculator keypad.</B></LH></UL>

<PRE>import java.applet.Applet;

import java.AWT.*;

public class Calculator extends Applet {

    Label display;

    Panel bottom;

    Panel num_panel;

    Panel func_panel;

    Button number[] = new Button[10];

    Button function[] = new Button[6];

    public void init() {

        setLayout(new BorderLayout());

        display = new Label(&quot;0&quot;, Label.RIGHT);

        add(&quot;North&quot;, display);

        bottom = new Panel();

        bottom.setLayout(new BorderLayout());

        num_panel = new Panel();

        num_panel.setLayout(new GridLayout(4,3));

        for (int x=9; x&gt;=0; x--) {

            number[x] = new Button((new String()).valueOf(x));

            num_panel.add(number[x]);

        }

        function[4] = new Button(&quot;.&quot;);

        num_panel.add(function[4]);

        function[5] = new Button(&quot;=&quot;);

        num_panel.add(function[5]);

        bottom.add(&quot;Center&quot;, num_panel);

        func_panel = new Panel();

        func_panel.setLayout(new GridLayout(4,1));

        function[0] = new Button(&quot;+&quot;);

        function[1] = new Button(&quot;-&quot;);

        function[2] = new Button(&quot;*&quot;);

        function[3] = new Button(&quot;/&quot;);

        for (int x=0; x&lt;4; x++)

            func_panel.add(function[x]);

        bottom.add(&quot;East&quot;, func_panel);

        add(&quot;Center&quot;, bottom);

    }

}</PRE>

<P>The HTML for the applet is as follows:

<BR></P>

<PRE>&lt;applet code=Calculator.class width=135 height=140&gt;&lt;/applet&gt;</PRE>

<P><B><A HREF="http://docs.rinet.ru/WebApp/11cwa07.gif">Figure 11.7. A first try at a calculator applet </B><B>user interface.</A></B></P>

<P>The original panel has been subdivided twice. At the top of the applet is the label for the display; below that is a panel for all the keys. However, this panel must be again subdivided to group the number and function keys separately. Thus a number 
panel and a function panel are added.

<BR></P>

<P>Because the lower panels contain keys, the GridLayout fits the purpose perfectly. This layout allows a grid to be specified and then components are added left to right, top to bottom until the grid is full. The function panel is then added to the East 
(right) side of the lower panel leaving the rest of the space to the number keys. The number keys are specified to be Center and thus to use up all the space remaining in the panel.

<BR></P>

<P>This code provides a mock-up of how the final calculator would look and gives an idea of not just user interface considerations that will need to be considered, but also design decisions that are integral to the whole applet. For example, should all the 

processing be contained in the main Applet class, or should the panels become separate classes to isolate functionality and promote code reuse?

<BR></P>

<H3 ALIGN="CENTER">

<CENTER><A ID="I17" NAME="I17">

<FONT SIZE=4><B>Summary</B>

<BR></FONT></A></CENTER></H3>

<P>This chapter covered how to go about building a user interface in Java using the AWT. Remember these key points:

<BR></P>

<UL>

<LI>Components are the foundation of Java user interfaces.

<BR>

<BR></LI>

<LI>Components are placed onto containers.

<BR>

<BR></LI>

<LI>A layout determines the placement of components on containers.

<BR>

<BR></LI>

<LI>Components talk to each other through events.

<BR>

<BR></LI></UL>

<P>If you keep these basic tenets in mind, you should be able to put together simple applets with a great deal of functionality. Just keep in mind how these pieces fit together and how they function together, you might even want to keep track of these in 
writing while you work on your applets. Understanding how these pieces fit together and how they function with each other in your applet can keep errors in your interface to a minimum and make debugging them much easier.

<BR></P>

<P>Now you're ready for the big time. The following chapters take you through some real-world applets. Chapter 12 covers the TickerTape applet, which scrolls user-specified text on-screen. Chapter 13 covers the SlideShow applet, which allows users to set 
up a series of images in a slide show, complete with a soundtrack.

<BR></P>

<P><A HREF="cwa10fi.htm"><IMG SRC="http://docs.rinet.ru/WebApp/bluprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/WebApp/blutoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="cwa12fi.htm"><IMG SRC="http://docs.rinet.ru/WebApp/blunext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>


</P></BODY></HTML>

