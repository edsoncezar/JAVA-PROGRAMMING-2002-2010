<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>EJB Servers by Gopalan Suresh Raj</title>
</head>

<body bgcolor="#FFFFFF">

<p align="center"><a
        href="http://www.execpc.com/~gopalan/index.html"><img
        src="..\..\resources\wc.gif"
        border="0" width="200" height="45"></a></p>

<p align="center"><font color="#000080" size="5" face="Arial"><strong>EJB
Servers</strong></font><font face="Verdana"><br>
</font><a href="http://www.execpc.com/~gopalan/personal/cv.html"><font
color="#000080" size="4" face="Verdana">Gopalan Suresh Raj</font></a></p>

<p><font size="2" face="Verdana">An EJB application server is
required when using EJBs. It's part of the architecture; it
contains the EJB container. Generally speaking, the primary goals
of an application server are to improve performance and simplify
development. An application server combines the capabilities of a
TP monitor with distributed object technology.</font></p>

<p><font size="2" face="Verdana">The most important feature in a
TP monitor, and likewise in an application server, is efficient
resource management. Application servers pool and recycle
expensive system resources such as network connections,
processes, threads, memory, and database connections. As a
developer, you don't really want to write your own thread
management and synchronization services within your application
code. You don't want to write code within your application to
pre-create database connections, cache them in a pool and then
allocate them to other applications as needed. You want the
application server to do that for you. Application servers
provide automatic thread management and database connection
management.</font></p>

<p><font size="2" face="Verdana">EJB increases the simplicity
level even more than a plain application server. EJB automates
complicated middleware services such as transactions, security,
state management, and persistence.</font></p>

<p><font size="2" face="Verdana">Distributed objects need to know
where to find each other (naming services), whom to trust
(security) and how to manage their life cycles. Services such as
naming services, distributed transaction control, security
mechanisms, remote access, persistence, resource pooling or
threading, instance pooling and concurrency issues, etc. are
automatically handled (and built into) by the EJB server. EJB
also defines design patterns and naming conventions.</font></p>

<p><font size="2" face="Verdana">An EJB server implementation
needs a runtime system. The specification does not prescribe
which one. It could be a database, it could be a legacy
transaction system, or it could be CORBA based. EJB is based on
the Java Transaction Service (JTS). JTS is to a large extent the
Java mapping of CORBA's Object Transaction Service (OTS). It thus
takes care of the &quot;plumbing&quot; that needs to be
accomplished when coming up with distributed enterprise
solutions, thus, freeing up the enterprise component developer to
focus on programming the business logic. </font></p>

<p><font size="2" face="Verdana">The best of both worlds can be
combined by layering EJB servers on top of CORBA OTS/SSL. That
gives you the strength of the CORBA platform including the
plumbing capabilities to non-Java environments and the
easy-to-use APIs of the EJB spec.</font></p>

<p><font size="4" face="Arial"><b>Server Infrastructure</b></font></p>

<p><font size="2" face="Verdana">The EJB server provides an
organized framework for EJB Containers to execute in. Some of the
important services that EJB Servers typically provides are as
follows:</font></p>

<p><font face="Arial"><b>Distributed Transactional support</b></font></p>

<p><font size="2" face="Verdana">Distributed transaction
management involves two possible layers of distribution: multiple
application participants and multiple data resource managers.
Each layer must be managed separately. JTS/OTS focuses on
managing the multiple application participants while XA and DTC
focus on managing the multiple data resource managers.</font></p>

<p><font size="2" face="Verdana">In a distributed object
environment, a single transaction may involve a number of
different objects. One object starts the transaction, then it
calls some number of methods in other objects to execute the
work, then when everything is complete, the object commits the
transaction. JTS/OTS defines an object, called the <i>transaction
context</i>, that keeps track of all the object participants in
the transaction. When the transaction commits, the OTS forwards
the commit request to a transaction coordinator (TC) to manage
the data resource managers. An OTS can provide its own TC, or it
can delegate it to a third party - either the transaction
coordinator in a database or a separate distributed</font></p>

<p><font size="2" face="Verdana">transaction coordinator (such as
Microsoft's DTC or an XA-compliant transaction coordinator like
Encina or Tuxedo). Most EJB implementations (e.g., WebLogic,
Bluestone, Novera, Persistence, Oracle AS, Oracle8i) use the
database delegation approach, so they don't support heterogeneous
transactions. As of now, GemStone, Inprise, Secant, OrchidSoft
and IBM WebSphere are the only EJB servers that provide an
integrated distributed TC service.</font></p>

<p><font size="2" face="Verdana">Although EJBs can be used to
implement non-transactional systems, the model was designed to
support distributed transactions. EJB requires the application
server to use a distributed transaction management system that
supports two-phase commit protocols. EJB transactions are based
on JTS, the Java Binding of CORBA OTS. Individual enterprise
beans do not need to specify transaction demarcation code to
participate in distributed transactions. The EJB environment
automatically manages the start, commit and rollback of
transactions on behalf of the EJBean. Transaction policies can be
defined during the deployment process using declarative
statements. Optionally, transactions can be controlled by the
client application.</font></p>

<p><font size="1" face="Verdana"></font>&nbsp;</p>

<h1><font size="4" face="Arial">EJB Transaction Management</font></h1>

<p><font size="2" face="Verdana">Each transaction is a set of
atomic operations. In methods that have transactions in them, the
method either executes completely or returns a failure notice.
Thus, the method cannot return if it is only partially complete,
nor can it hang indefinitely. </font></p>

<p><font size="2" face="Verdana">It's also possible to undo the
action using a <em>rollback mechanism</em>. These kinds of
transactions are very common in the database world since they
help maintain coherency of content data. Each executed method
functions as a separate transaction. The Figure below, shows how
transactions are handled.</font></p>
<div align="center"><center>

<table border="1" cellpadding="5" cellspacing="1">
    <tr>
        <td><p align="center"><font size="1" face="Verdana"><img
        src="tranman.gif" width="468" height="469"><br>
        </font><i>Figure: Transactional Sessions.</i></p>
        </td>
    </tr>
</table>
</center></div>

<p><font size="2" face="Verdana">The basics of transactional
programming are the same, except when calling the EJB's methods.
The figure above is a sequence diagram which corresponds to the
code below and shows what happens when the </font><font size="1"
face="Verdana">getStockPrice()</font><font size="2"
face="Verdana"> method is invoked. </font></p>

<p><font size="2" face="Verdana">The code snippet below is
important in that, not only does it show how to build
transactional code into your Beans, but it also shows you how to
connect to a remote CORBA Server Object using EJBs.</font></p>
<div align="center"><center>

<table border="1" bgcolor="#F4F4F4">
    <tr>
        <td><font size="2" face="Lucida Console">import
        javax.ejb.*; <br>
        import <strong>javax.jts.UserTransaction; </strong><br>
        import java.rmi.*; <br>
        import org.omg.CORBA.*; <br>
        import org.omg.CosNaming.*; <br>
        import Trader.*; <br>
        <br>
        public class <strong>QuoteBean</strong> implements <strong>SessionBean</strong>
        { <br>
        <br>
        &nbsp;SessionContext ctx; <br>
        &nbsp;public <strong>StockTrader trader</strong>; <br>
        <br>
        &nbsp;<strong>public double getStockPrice (String
        company) </strong><br>
        &nbsp; throws RemoteException { <br>
        &nbsp; // Code for Transactions in the EJBean <br>
        &nbsp; <strong>UserTransaction tx =
        ctx.getUserTransaction (); <br>
        &nbsp; tx.begin (); </strong><br>
        &nbsp; double value = <strong>trader.getStockPrice
        (company); </strong><br>
        &nbsp; if (value &gt; 0) <br>
        &nbsp;<strong>&nbsp; tx.commit (); </strong><br>
        &nbsp; else <br>
        &nbsp;&nbsp;<strong> tx.rollback (); </strong><br>
        &nbsp; return value; <br>
        &nbsp;} <br>
        <br>
        &nbsp;// Implement the methods mandated by the EJB Spec <br>
        &nbsp;public<strong> void ejbCreate () </strong>{} <br>
        &nbsp;public <strong>void ejbActivate () </strong>{} <br>
        &nbsp;public <strong>void ejbPassivate ()</strong>{} <br>
        &nbsp;public <strong>void ejbRemove ()</strong> {} <br>
        <br>
        &nbsp;// Set the Session context and also get a reference
        to the <br>
        &nbsp;// Stock Trader CORBA server object running on a
        remote system. <br>
        &nbsp;public <strong>void setSessionContext
        (SessionContext ctx)</strong> <br>
        &nbsp; throws RemoteException { <br>
        <br>
        &nbsp; <strong>this.ctx = ctx;</strong> <br>
        &nbsp; try { <br>
        &nbsp;&nbsp; // Create and initialize the ORB <br>
        &nbsp;&nbsp; ORB orb = <strong>ORB.init (args, null); </strong><br>
        &nbsp;&nbsp; // Get the root naming context <br>
        &nbsp;&nbsp; org.omg.CORBA.Object objRef = <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <strong>orb.resolve_initial_references
        (&quot;NameService&quot;);</strong> <br>
        &nbsp;&nbsp; NamingContext ncRef = <strong>NamingContextHelper.narrow
        (objRef); </strong><br>
        &nbsp;&nbsp; // Resolve the object reference in naming <br>
        &nbsp;&nbsp; NameComponent nc = new NameComponent
        (&quot;NASDAQ&quot;, &quot;&quot;); <br>
        &nbsp;&nbsp; NameComponent path [] = {nc}; <br>
        &nbsp;&nbsp; trader = <strong>TraderHelper.narrow
        (ncRef.resolve (path)); </strong><br>
        &nbsp; } catch (Exception e) { <br>
        &nbsp;&nbsp; e.printStackTrace (); <br>
        &nbsp; } <br>
        &nbsp;} <br>
        } <br>
        &nbsp; </font></td>
    </tr>
</table>
</center></div>

<p><font size="2" face="Verdana">Before a method is called, the
client will need to indicate that a new transaction is starting
using the <code>javax.jts.UserTransaction.begin()</code> call.</font></p>

<p><font size="2" face="Verdana">When a method is called by the
client, the container signals the EJB instance with the </font><font
size="1" face="Verdana">afterBegin()</font><font size="2"
face="Verdana"> call. The EJB then begins processing the method
call.</font></p>

<p><font size="2" face="Verdana">At this point, one of two things
can happen: The client may request that the method call be
committed, or change its mind and execute a rollback. When the
client requests that the method be committed to action, the
container informs the EJB that it is ready to receive the
information with the <code>beforeCompletion()</code> signal. When
the EJB's processing of the method call is complete and the
action has been committed, the EJB first sends a response back to
the client (if there is a response), then the container sends the
<code>afterCompletion()</code> signal, as </font><font size="1"
face="Verdana">True</font><font size="2" face="Verdana">, to the
EJB. </font></p>

<p><font size="2" face="Verdana">If the client changes its mind,
it can execute a rollback call after the method call is started.
The container sends a <code>setRollbackOnly()</code> signal to
the EJB to undo whatever it may have done. When the rollback is
complete, the container sends the <code>afterCompletion()</code>
signal, as </font><font size="1" face="Verdana">False</font><font
size="2" face="Verdana">, indicating to the EJB that it should
reinitialize itself. </font></p>

<p><font size="2" face="Verdana">The passivation and activation
methods defined in the EJB interface to the container work just
the same as before with the exception that an EJB instance cannot
be made passive while a transaction is in progress. One further
thing to note is that a transaction does not have to be limited
to just one method call. In fact, a number of method calls can be
packaged inside a single transaction. This allows the client to
execute complex operations while still reserving the ability to
roll them all back in case of need. </font></p>

<p><font face="Arial"><b>Multithreading and Resource Pooling</b></font></p>

<p><font size="2" face="Verdana">An enterprise Bean is not
allowed to use thread synchronization primitives. Hence the
keyword </font><font size="1" face="Verdana">synchronized</font><font
size="2" face="Verdana"> should never appear in an EJB Bean
implementation code.</font></p>

<p><font size="2" face="Verdana">The EJB spec allows the server
to passivate an Entity Bean between methods, even</font></p>

<p><font size="2" face="Verdana">within a transaction. This is to
allow the server to perform scalable state management</font></p>

<p><font size="2" face="Verdana">and resource pooling. When the
container passivates Bean X, it first calls </font><font size="1"
face="Verdana">ejbStore()</font><font size="2" face="Verdana"> to
allow the Bean to synchronize its updated state with the
underlying database. When the</font></p>

<p><font size="2" face="Verdana">container reactivates Bean X in
the future, it will </font><font size="1" face="Verdana">ejbLoad()</font><font
size="2" face="Verdana"> the state stored in the database.The
loaded state is the state saved at the most recent </font><font
size="1" face="Verdana">ejbStore()</font><font size="2"
face="Verdana"> by the transaction. Note that the database is
doing all the necessary synchronization with other transactions
for free. </font></p>

<p><font size="2" face="Verdana">As far as threading is
concerned, the EJB spec makes it explicitly illegal for an
enterprise Bean to start new threads. The EJB server to ensure
that the system is manageable must control all thread creations.
Allowing enterprise beans to start threads would lead to serious
problems. For example, image two concurrent threads running with
the same transaction context trying to access an underlying
database. If one thread is reading data while the other thread is
updating the data, it is completely unpredictable what data the
first thread would read. Another problem is that the EJB server
will not be able to guarantee the X/Open checked transaction
semantics because it would have little knowledge of whether all
threads involved in a transaction have terminated before the
transaction's commit starts.</font></p>

<p><font face="Arial"><b>Security</b></font></p>

<p><font size="2" face="Verdana">EJB server implementations may
choose to use connection-based authentication in which the client
program establishes a connection to the EJB server and the
client's identity is attached to the connection at connection
establishment time.</font></p>

<p><font size="2" face="Verdana">The communication mechanism
between the client and the server propagates the client's
identity to the server. However, the EJB spec does not specify
how the EJB server should accomplish this. The </font><font
size="1" face="Verdana">getCallerIdentity()</font><font size="2"
face="Verdana"> method should always retrieve the identity of the
current caller. </font></p>

<p><font size="2" face="Verdana">The EJB/CORBA mapping prescribes
this mechanism - it specifies that the CORBA Principal
propagation mechanism be used. This means that the client ORB
adds the client's principal to each client request.</font></p>

<p><font size="2" face="Verdana">If two EJB servers, X and Y,
from two different vendors both implement the EJB/CORBA mapping,
it is possible for enterprise beans running on system X to access
enterprise beans running on system Y as if they were local
enterprise beans (and vice versa). The transaction context will
be properly propagated using the OTS propagation protocol between
the transaction managers running at the two sites. The same
applies to security, although one of the systems will have to
provide mapping of principals.</font></p>

<p><font size="2" face="Verdana">The same level of
interoperability exists between client systems and a server
system. If both systems implement the EJB/CORBA mapping, they
will be able to interoperate even if they are from different
vendors. This means, for example, if the EJB/CORBA client runtime
becomes part of the JRE, and JRE is part of a browser, then the
browser can run applets that are clients to any EJB server that
implements the EJB/CORBA mapping. The downloaded applet only
includes the application-specific client stubs, but not a
server-specific ORB, transaction proxy, or EJB runtime. This
level of interoperability was the primary motivation for doing
the EJB/CORBA mapping.</font></p>

<p><font face="Arial"><b>CORBA/IIOP compatibility</b></font></p>

<p><font size="2" face="Verdana">While the EJB spec allows the
EJB server implementors to use any communication protocol between
the client and server, the EJB/CORBA mapping document is
prescriptive with respect to what goes on the wire. This allows
both system-level and application-level interoperability between
products from vendors who choose to implement the EJB/CORBA
protocol as the underlying communication protocol.</font></p>

<p><font size="2" face="Verdana">Java clients will optionally
communicate with server components using IIOP. Java clients will
have a choice of APIs &#150; either the Java RMI or the Java
mapping of the CORBA IDL interface. Non-Java clients communicate
with the server components using IIOP and the appropriate
language mapping. Clients wishing to use the COM+ protocol
communicate with the server component through a COM-CORBA bridge.
Also realize that the client of an EJB can itself be a server
component (eg., a servlet), so an HTTP-only web client can use a
servlet to make EJB invocations. </font></p>

<p><font size="2" face="Verdana">IIOP is perfectly fine to speak
RMI and hence, <b>RMI/IIOP</b> is trivially easy to do. However, <b>RMI/JRMP</b>
is a simple protocol to do simple things. It needs to change and
look an awful lot like IIOP and CORBA when it's finally mature.
It thus comes down to what is missing from JRMP that is present
in IIOP. In JRMP for example, it is impossible to transparently
add support for distributed transactions, security, etc. The
protocol simply doesn't support the addition of information to
the message on the client end, and the support for retrieving
this information on the server side. This means that any system
built using JRMP has to deal with transactions and security as
part of the message, rather than as part of the context of the
message, which is added, modified and interpreted by services
that are neither the client nor the server.</font></p>

<p><a href="..\ejb.html"><font
size="2" face="Verdana">click here to go to</font><font size="4"
face="Verdana"> </font><br>
<font size="4" face="Verdana">My EJB HomePage...</font></a></p>

<table border="1" cellpadding="2" width="95%">
    <tr>
        <td valign="top" width="100%" bgcolor="#004080"><font
        color="#FFCC00" size="4" face="Verdana">About the Author...</font></td>
    </tr>
    <tr>
        <td valign="top" width="100%" bgcolor="#FFF2F2"><a
        href="http://www.execpc.com/~gopalan/personal/cv.html"><font
        color="#000080" size="2" face="Tahoma"><strong>Gopalan
        Suresh Raj</strong></font></a><font size="2"
        face="Tahoma"><strong> </strong>is a Software Architect,
        Developer and an active Author. He is contributing author
        to a couple of books &quot;<strong>Enterprise Java
        Computing-Applications and Architecture</strong>&quot;
        and &quot;<strong>The Awesome Power of JavaBeans</strong>&quot;.
        His expertise spans enterprise component architectures
        and distributed object computing. Visit him at his </font><a
        href="http://www.execpc.com/~gopalan"><font size="2"
        face="Tahoma"><strong>Web Cornucopia</strong><sup><strong>©</strong></sup></font></a><font
        size="2" face="Tahoma"> site (<strong>http://www.execpc.com/~gopalan</strong>)
        or mail him at </font><a href="mailto:gopalan@execpc.com"><font
        size="2" face="Tahoma"><strong>gopalan@execpc.com</strong></font></a><font
        size="2" face="Tahoma">.</font></td>
    </tr>
</table>

<hr>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td align="center"><p align="center"><a
        href="http://www.execpc.com/~gopalan/index.html"><font
        color="#000000"><img
        src="..\..\resources\home(2).gif"
        alt="Go to the Component Engineering Cornucopia page"
        width="65" height="44" start="fileopen"></font></a></p>
        </td>
        <td align="center" colspan="2"><p align="center"><font
        color="#000080" size="4" face="Arial Narrow"><strong>This
        site was developed and is maintained by </strong></font><a
        href="http://www.execpc.com/~gopalan/personal/cv.html"
        style="COLOR: rgb(0,0,128)"><font color="#000080"
        size="4" face="Arial Narrow"><strong>Gopalan Suresh Raj</strong></font></a></p>
        <p align="center"><font color="#000080" size="4"
        face="Arial Narrow"><strong>This page has been visited </strong></font><font
        color="#000080"><img
        src="..\..\..\..\counter.execpc.com\cgi-bin\nph-count\width=5&link=~gopalan_misc_compare3.html"></font><font
        color="#000080" size="4" face="Arial Narrow"><strong>
        times since September 21,1998.</strong></font></p>
        </td>
    </tr>
</table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td align="center"><p align="center"><font
        color="#800000" size="3">Last Updated : Dec 19, '98</font></p>
        </td>
        <td colspan="2"><p align="center"><a
        href="mailto:gopalan@execpc.com"><font color="#800000"
        size="4" face="Arial Narrow">If you have any questions,
        comments, or problems regarding this site, please write
        to me I would love to hear from you</font></a><font
        color="#800000" size="4" face="Arial Narrow">.</font></p>
        </td>
    </tr>
</table>

<hr>
<div align="center"><center>

<table border="0" cellspacing="1" width="693" height="54">
    <tr>
        <td width="689" height="27"><p align="center"><font
        color="#000000" size="1" face="Courier New">Copyright (c)
        1997-98, </font><a
        href="http://www.execpc.com/~gopalan/personal/cv.html"
        style="COLOR: rgb(0,0,128)"><font color="#000000"
        size="1" face="Courier New">Gopalan Suresh Raj</font></a><font
        color="#000000" size="1" face="Courier New"> - All rights
        reserved. </font><a
        href="http://www.execpc.com/~gopalan/misc/cpright.html"
        style="COLOR: rgb(0,0,128)"><font color="#000000"
        size="1" face="Courier New">Terms of use</font></a><font
        color="#000000" size="1" face="Courier New">.</font></p>
        </td>
    </tr>
    <tr>
        <td width="689" height="27"><p align="center"><font
        color="#000000" size="1" face="Courier New">All products
        and companies mentioned at this site are trademarks of
        their respective owners.</font></p>
        </td>
    </tr>
</table>
</center></div><!-- start of NedStat code -->

<p align="center"><a
href="http://usa.nedstat.net/cgi-bin/viewstat?name=java_tutorial"><img
src="..\..\..\..\usa.nedstat.net\cgi-bin\nedstat.gif\name=java_tutorial"
align="right" border="0" hspace="0"></a> <!-- end of NedStat code --> </p>
<script language="JavaScript">
<!--
  document.write("<img src=\"http://usa.nedstat.net/cgi-bin/referstat.gif?name=java_tutorial&refer="+escape(top.document.referrer)+"\" width=1 height=1 alt=\"\">");
// -->
</script>

<!-- eXTReMe digital Web Tracking Code Starts Here -->
<a target="_top" href="http://w.extreme-dm.com/?login=javatrac">
<img name=im src="..\..\..\..\w1.extreme-dm.com\i.gif" height=38
border=0 width=41 alt=""></a><script language="javascript"><!--
an=navigator.appName;d=document;function
pr(){d.write("<img src=\"http://w0.extreme-dm.com",
"/0.gif?tag=javatrac&j=y&srw="+srw+"&srb="+srb+"&",
"rs="+r+"&l="+escape(d.referrer)+"\" height=1 ",
"width=1>");}srb="na";srw="na";//-->
</script><script language="javascript1.2"><!--
s=screen;srw=s.width;an!="Netscape"?
srb=s.colorDepth:srb=s.pixelDepth;//-->
</script><script language="javascript"><!--
r=41;d.images?r=d.im.width:z=0;pr();//-->
</script><noscript><img height=1 width=1 alt=""
src="..\..\..\..\w0.extreme-dm.com\0.gif\tag=javatrac&j=n"></noscript>
<!-- eXTReMe digital Web Tracking Code Ends Here  -->


</body>
</html>
