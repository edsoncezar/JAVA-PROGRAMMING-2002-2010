<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<link REL="stylesheet" TYPE="text/css" HREF="../cursos.css" />
<title>JSP e Tags Extensions</title>
</head>

<body>

<h1 align="center">JSP e Tag Extensions<br>
(&quot;Custom Tags&quot; ou &quot;Taglibs&quot;)</h1>

<h2>Introdução</h2>

<h3>Por quê?</h3>

<ul>
  <li>Para ajudar a separar a lógica de negócio da lógica de apresentação,
    Struts (seção anterior) oferece vários tags que, essencialmente, estendem
    a especificação JSP</li>
  <li>Desta forma, ajudamos a resolver os problemas de JSP que mencionamos
    anteriormente:
    <ul>
      <li>Scriptlets misturam lógica com apresentação</li>
      <li>Scriptlets quebram a separação de papeis desenvolvedor/web designer</li>
      <li>Páginas JSP ficam mais difíceis de ler e manter com a presença de
        scriptlets</li>
    </ul>
  </li>
  <li>Veja também a vantagem de tags em &quot;<a href="../../recursos/JSP%20best%20practices.htm">JSP Best Practices</a>&quot;</li>
  <li>Nesta seção, queremos ver como escrever tais tags</li>
</ul>

<h3>Conceitos-chave de tags</h3>

<ul>
  <li>Os conceitos-chave de tags são:
    <ul>
      <li><font color="#0080FF">Nome do tag</font>
        <ul>
          <li>Cada tag, digamos &lt;logic:iterate&gt; é identificado unicamente
            através de um prefixo (logic, p. ex.) e de um sufixo (iterate, p.
            ex.)</li>
        </ul>
      </li>
      <li><font color="#0080FF">Atributos</font>
        <ul>
          <li>Um tag pode ter atributos</li>
          <li>A sintaxe XML é usada para atributos</li>
          <li>Atributos podem ser obrigatórios ou opcionais</li>
          <li>Exemplo: No exemplo abaixo, os tags são &quot;id&quot;, &quot;name&quot;,
            &quot;property&quot;<br>
            <font color="#0080FF">&lt;logic:iterate id=&quot;subscription&quot;
            name=&quot;user&quot; property=&quot;subscriptions&quot;&gt;</font></li>
        </ul>
      </li>
      <li><font color="#0080FF">Aninhamento</font>
        <ul>
          <li>Tags podem se aninhar e tags aninhados podem cooperar (ou não)</li>
          <li>Exemplo: montar um Select HTML a partir de uma coleção<br>
            <font color="#0080FF">      &lt;html:select property=&quot;type&quot;&gt;<br>
            &nbsp;&nbsp;&nbsp;        &lt;html:options collection=&quot;serverTypes&quot;
            property=&quot;value&quot;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            labelProperty=&quot;label&quot;/&gt;<br>
      &lt;/html:select&gt;</font></li>
        </ul>
      </li>
      <li><font color="#0080FF">Conteúdo do corpo</font>
        <ul>
          <li>O corpo de um tag é o que tem entre os elementos de início e de
            fim do tag</li>
          <li>Um tag pode (ou não) manipular o corpo</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3>Tag Handlers e Tag Library Descriptors (TLDs)</h3>

<ul>
  <li>A funcionalidade de um tag é implementada com uma classe Java chamada o
    &quot;tag handler&quot;</li>
  <li>O tag handler é um JavaBean
    <ul>
      <li>Por exemplo, os atributos do tag são propriedades do bean</li>
    </ul>
  </li>
  <li>Um Tag Library Descriptors (TLDs) é um arquivo XML que descreve uma
    biblioteca de tags contendo um ou mais tags
    <ul>
      <li>A diretiva JSP &quot;taglib&quot; é usada para importar os tags em
        qualquer página JSP que queiram usá-los</li>
    </ul>
  </li>
</ul>

<h3>Usos típicos de tags</h3>
<ul>
  <li>Tags são tipicamente usados para:
    <ul>
      <li>Esconder a complexidade de acessar fontes de dados do autor da página
        que freqüentemente não conhece bem o modelo de dados da empresa</li>
      <li>Para introduzir novas variáveis de script na página</li>
      <li>Para filtrar ou transformar o conteúdo do tag (corpo), até
        interpretando-o em outra linguagem (SQL, ...)</li>
      <li>Para fazer iterações sem usar scriptlets</li>
    </ul>
  </li>
  <li>Tags são tipicamente altamente parametrizados para que sejam o mais
    genéricos possível</li>
</ul>
<h3>The good news</h3>
<ul>
  <li>Implementar novos tags é relativamente simples</li>
</ul>

<h2>Primeiro Exemplo: Simple Tag</h2>

<ul>
  <li>Este tag não tem atributo, nem corpo
  </li>
  <li>O tag gera algo dinâmico em HTML
  </li>
  <li>A saída do tag será:
  </li>
</ul>

<pre class="clsCode">Hello, world.
My name is &lt;classe de implementação do tag handler&gt; and it's &lt;data e horas&gt;</pre>

<ul>
  <li>Nosso tag vai se chamar &quot;hello&quot;
  </li>
</ul>

<h3>O que queremos</h3>

<ul>
  <li>O tag será usado numa página <a href="../src/tags/hello/hello.jsp">hello.jsp</a>
    como segue:
  </li>
</ul>

<pre class="clsCode">&lt;%@ taglib uri=&quot;/hello&quot; prefix=&quot;examples&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;First custom tag&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
Saida estatica.
&lt;p/&gt;
&lt;i&gt;
  &lt;examples:hello&gt;
  &lt;/examples:hello&gt;
&lt;/i&gt;
Mais saida estatica.
  &lt;/body&gt;
&lt;/html&gt;</pre>

<h3>O tag handler</h3>

<ul>
  <li>O próximo passo é criar o tag handler
    <ul>
      <li>O tag handler está no arquivo <a href="../src/tags/hello/WEB-INF/classes/tagext/HelloTag.java">HelloTag.java</a></li>
      <li>Os métodos mais importantes neste momento são <font color="#0080FF">doStartTag()</font>
        e <font color="#0080FF">doEndTag()</font> chamados quando os elementos
        de início e fim de tag são vistos, respectivamente
        <ul>
          <li>São métodos de callback chamados pelo JSP Engine</li>
        </ul>
      </li>
      <li>Podemos estender TagSupport que faz muito do trabalho de um tag</li>
    </ul>
  </li>
</ul>

<pre class="clsCode">package tagext;

import java.io.IOException;
import java.util.Date;
import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;

/**
*    Implementation of a tag to generate a single piece of HTML.
*    @author    Rod Johnson
*/
public class HelloTag extends TagSupport {

    /**
    *    This method will be called when the JSP engine encounters the start
    *    of a tag implemented by this class
    */
    public int doStartTag() throws JspTagException {
        // This return value means that the JSP engine should evaluate
        // the contents and any child tags of this tag
        return EVAL_BODY_INCLUDE;
    }

    /**
    *    This method will be called when the JSP engine encounters the end
    *    of a tag implemented by this class
    */
    public int doEndTag() throws JspTagException {
        String dateString = new Date().toString();
        try {
            pageContext.getOut().write(&quot;Hello world.&lt;br/&gt;&quot;);
            pageContext.getOut().write(&quot;My name is &quot; + getClass().getName() +
                                        &quot; and it's &quot; + dateString + &quot;&lt;p/&gt;&quot;);
        }
        catch (IOException ex) {
            throw new JspTagException(&quot;Fatal error: hello tag could not write to JSP out&quot;);
        }

        // This return value means that the JSP engine should continue to
        // evaluate the rest of this page
        return EVAL_PAGE;
    }
}    // class HelloTag&nbsp;</pre>

<ul>
  <li>Os valores retornados por doStartTag() e doEndTag() fazem parte da
    interação entre JSP Engine e o tag
  <li>Os comentários do código indicam o que são EVAL_BODY_INCLUDE e
    EVAL_PAGE</li>
</ul>
<h3>O Tag Library Descriptor</h3>

<ul>
  <li>Agora, precisamos de um Tag Library Descriptor (arquivo <a href="../src/tags/hello/WEB-INF/tlds/hello.tld">hello.tld</a>)
</ul>
<pre class="clsCode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;!DOCTYPE taglib
        PUBLIC &quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.1//EN&quot;
        &quot;http://java.sun.com/j2ee/dtds/web-jsptaglibrary_1_1.dtd&quot;&gt;
&lt;taglib&gt;
  &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
  &lt;jspversion&gt;1.1&lt;/jspversion&gt;
  &lt;shortname&gt;examples&lt;/shortname&gt;

  &lt;info&gt;Simple example library.&lt;/info&gt;

  &lt;tag&gt;
    &lt;name&gt;hello&lt;/name&gt;
    &lt;tagclass&gt;tagext.HelloTag&lt;/tagclass&gt;
    &lt;bodycontent&gt;JSP&lt;/bodycontent&gt;
    &lt;info&gt;Simple example&lt;/info&gt;
  &lt;/tag&gt;
&lt;/taglib&gt;</pre>

<ul>
  <li>O bodycontent pode ser &quot;JSP&quot; ou &quot;tagdependent&quot;
    <ul>
      <li>&quot;tagdependent&quot; seria usado quando o tag consume e interpreta
        o conteúdo (um query SQL, por exemplo)</li>
    </ul>
</ul>
<h3>Colocando para funcionar</h3>

<ul>
  <li>Agora, vamos fazer isso funcionar
    <ul>
      <li>Construa a seguinte árvore de arquivos e diretórios:<br>
        <br>
        <font color="#0080FF">hello.jsp<br>
        WEB-INF/<br>
        &nbsp;&nbsp;&nbsp; web.xml<br>
        classes/<br>
        &nbsp;&nbsp;&nbsp; tagext/<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HelloTag.class<br>
        tlds/<br>
        &nbsp;&nbsp;&nbsp; hello.tld</font></li>
    </ul>
  <li>O arquivo META-INF/MANIFEST.MF não aparece aqui e será criado
    automaticamente pelo comando jar
  <li>O arquivo <a href="../src/tags/hello/WEB-INF/web.xml">web.xml </a>contém:
</ul>
<pre class="clsCode">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE web-app PUBLIC '-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN' 'http://java.sun.com/j2ee/dtds/web-app_2.2.dtd'&gt;

&lt;web-app&gt;
  &lt;display-name&gt;tagext&lt;/display-name&gt;
  &lt;description&gt;Tag extensions examples&lt;/description&gt;
  
  &lt;session-config&gt;
    &lt;session-timeout&gt;0&lt;/session-timeout&gt;
  &lt;/session-config&gt;
  
  &lt;taglib&gt;
  	&lt;taglib-uri&gt;/hello&lt;/taglib-uri&gt;
  	&lt;taglib-location&gt;/WEB-INF/tlds/hello.tld&lt;/taglib-location&gt;
  &lt;/taglib&gt;
  
&lt;/web-app&gt;</pre>

<ul>
  <li>Agora, podemos criar o arquivo de aplicação .WAR:
</ul>
<pre class="clsCode">jar -cvf hello.war WEB-INF hello.jsp</pre>

<ul>
  <li>Coloque hello.war no diretório web-apps do Tomcat e reinicie Tomcat
    <ul>
      <li>Ou faça deployment para seu servidor J2EE</li>
    </ul>
  <li>Agora, navegue para a URL http://localhost:8000/hello/hello.jsp</li>
</ul>
<p align="center"><img border="0" src="tags.h1.gif" width="721" height="279"></p>

<h2>Segundo Exemplo: Um tag com atributos</h2>

<h3>O que queremos</h3>

<ul>
  <li>Queremos examinar o tag <font color="#0080FF">&lt;app:checkLogon/&gt;</font>
    usado na aplicação de cadastro de assinaturas de email feita com Struts</li>
  <li>O que o tag faz:
    <ul>
      <li>Nada, se o usuário estiver logado</li>
      <li>Encaminha para /logon.jsp, caso contrário</li>
    </ul>
  </li>
  <li>Que parâmetros queremos?
    <ul>
      <li>&quot;name&quot;, a chave do bean de escopo de sessão que indica que
        há usuário logado
        <ul>
          <li>Default: &quot;user&quot;</li>
        </ul>
      </li>
      <li>&quot;page&quot;, que indica a página de logon, caso não haja
        usuário logado
        <ul>
          <li>Default: &quot;logon.jsp&quot;</li>
        </ul>
      </li>
    </ul>
    <p>O código do handler segue e é fácil de entender quando se sabe que:
    <ul>
      <li>Para cada atributo do tag, deve haver uma propriedade do bean tag
        handler
        <ul>
          <li>No nosso caso, as propriedades &quot;name&quot; e &quot;page&quot;</li>
        </ul>
      </li>
      <li>doStartTag() retorna SKIP_BODY porque o corpo do tag não precisa ser
        avaliado
        <ul>
          <li>Este tag nem tem corpo</li>
        </ul>
      </li>
      <li>doEndTag() retorna EVAL_PAGE quando há um usuário logado para
        indicar que o resto da página precisa ser avaliada e SKIP_PAGE, caso
        contrário</li>
      <li>doEndTag() usa &quot;pageContext.forward(page);&quot; para desviar
        para a página de login</li>
      <li>O método release() é chamado no final do processamento do tag
        <ul>
          <li>Ele deve zerar (ou inicializar) o estado do bean e devolver
            quaisquer recursos alocados</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<pre class="clsCode">package org.apache.struts.webapp.example;

import java.io.IOException;
import javax.servlet.http.HttpSession;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.TagSupport;
import org.apache.struts.action.Action;
import org.apache.struts.util.BeanUtils;
import org.apache.struts.util.MessageResources;


/**
 * Check for a valid User logged on in the current session.  If there is no
 * such user, forward control to the logon page.
 *
 * @author Craig R. McClanahan
 * @author Marius Barduta
 * @version $Revision: 1.1 $ $Date: 2003/04/25 13:04:37 $
 */

public final class CheckLogonTag extends TagSupport {
    // --------------------------------------------------- Instance Variables
    /**
     * The key of the session-scope bean we look for.
     */
    private String name = Constants.USER_KEY;

    /**
     * The page to which we should forward for the user to log on.
     */
    private String page = &quot;/logon.jsp&quot;;

    // ----------------------------------------------------------- Properties
    /**
     * Return the bean name.
     */
    public String getName() {
        return (this.name);
    }

    /**
     * Set the bean name.
     *
     * @param name The new bean name
     */
    public void setName(String name) {
        this.name = name;
    }


    /**
     * Return the forward page.
     */
    public String getPage() {
        return (this.page);
    }


    /**
     * Set the forward page.
     *
     * @param page The new forward page
     */
    public void setPage(String page) {
        this.page = page;
    }

    // ------------------------------------------------------- Public Methods
    /**
     * Defer our checking until the end of this tag is encountered.
     *
     * @exception JspException if a JSP exception has occurred
     */
    public int doStartTag() throws JspException {
        return (SKIP_BODY);
    }

    /**
     * Perform our logged-in user check by looking for the existence of
     * a session scope bean under the specified name.  If this bean is not
     * present, control is forwarded to the specified logon page.
     *
     * @exception JspException if a JSP exception has occurred
     */
    public int doEndTag() throws JspException {
        // Is there a valid user logged on?
        boolean valid = false;
        HttpSession session = pageContext.getSession();
        if ((session != null) &amp;&amp; (session.getAttribute(name) != null))
            valid = true;
    
        // Forward control based on the results
        if (valid)
            return (EVAL_PAGE);
        else {
            try {
                pageContext.forward(page);
            } catch (Exception e) {
                throw new JspException(e.toString());
            }
            return (SKIP_PAGE);
        }
    }

    /**
     * Release any acquired resources.
     */
    public void release() {
        super.release();
        this.name = Constants.USER_KEY;
        this.page = &quot;/logon.jsp&quot;;
    }
}</pre>

<h2>Terceiro Exemplo: Outro tag com parâmetros</h2>

<h3>O que queremos</h3>

<ul>
  <li>Queremos examinar o tag <font color="#0080FF">&lt;logic:present/&gt;</font>
    do pacote Struts</li>
  <li>O que ele faz?
    <ul>
      <li>Aqui está a documentação do tag</li>
    </ul>
  </li>
</ul>
<table>
  <tr>
    <td bgColor="#023264"><font color="#ffffff" face="arial,helvetica,sanserif"><strong>present</strong>
      - Generate the nested body content of this tag if the specified value is
      present in this request.</font></td>
  </tr>
  <tr>
    <td>
      <blockquote>
        <INFO>
        <p>Depending on which attribute is specified, this tag checks the
        current request, and evaluates the nested body content of this tag only
        if the specified value <strong>is</strong> present. Only one of the
        attributes may be used in one occurrence of this tag, unless you use the
        <code>property</code> attribute, in which case the <code>name</code>
        attribute is also required.</p>
      </blockquote>
    </td>
  </tr>
  <tr>
    <td>
      <blockquote>
        <table border="1" cellPadding="2" cellSpacing="2">
          <tbody>
            <tr>
              <th width="15%">Attribute Name</th>
              <th>Description</th>
            </tr>
            <tr>
              <td align="middle">cookie</td>
              <td><INFO>
                <p>Checks for the existence of a cookie with the specified name.<br>
                </p>
                </INFO>
                [RT Expr]<font color="#0080FF"> [Jacques: significa que pode ser
                um &quot;request-time expression&quot;]</font></td>
            </tr>
            <tr>
              <td align="middle">header</td>
              <td><INFO>
                <p>Checks for the existence of an HTTP header with the specified
                name. The name match is performed in a case insensitive manner.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">name</td>
              <td><INFO>
                <p>Checks for the existence of a JSP bean, in any scope, with
                the specified name. If <code>property</code> is also specified,
                checks for a non-null property value for the specified property.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">parameter</td>
              <td><INFO>
                <p>Checks for the existence of at least one occurrence of the
                specified request parameter on this request, even if the
                parameter value is a zero-length string.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">property</td>
              <td><INFO>
                <p>Checks for the existence of a non-null property value,
                returned by a property getter method on the JSP bean (in any
                scope) that is specified by the <code>name</code> attribute.
                Property references can be simple, nested, and/or indexed.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">role</td>
              <td><INFO>
                <p>Checks whether the currently authenticated user (if any) has
                been associated with the specified security role.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">scope</td>
              <td><INFO>
                <p>The bean scope within which to search for the bean named by
                the <code>name</code> property, or &quot;any scope&quot; if not
                specified.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">user</td>
              <td><INFO>
                <p>Checks whether the currently authenticated user principal has
                the specified name.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </td>
  </tr>
</table>
<ul>
  <li>Primeiro, vamos ver uma classe abstrata genérica que serve para todos os
    tags semelhantes de Struts (&lt;logic:present&gt;, &lt;logic:match&gt;, &lt;logic:equal&gt;,
    ...)
    <ul>
      <li>Há uma propriedade para cada atributo do tag</li>
      <li>O código importante está em <font color="#0080FF">azul</font></li>
    </ul>
  </li>
</ul>
<pre class="clsCode">package org.apache.struts.taglib.logic;

import javax.servlet.jsp.JspException;
import javax.servlet.jsp.tagext.TagSupport;
import org.apache.struts.util.MessageResources;

/**
 * Abstract base class for the various conditional evaluation tags.
 *
 * @author Craig R. McClanahan
 * @version $Revision: 1.1 $ $Date: 2003/04/25 13:04:37 $
 */
public abstract class ConditionalTagBase extends TagSupport {
    // ------------------------------------------------------------- Properties
    /**
     * The name of the cookie to be used as a variable.
     */
    protected String cookie = null;

    public String getCookie() {
        return (this.cookie);
    }

    public void setCookie(String cookie) {
        this.cookie = cookie;
    }

    /**
     * The name of the HTTP request header to be used as a variable.
     */
    protected String header = null;

    public String getHeader() {
        return (this.header);
    }

    public void setHeader(String header) {
        this.header = header;
    }

    /**
     * The message resources for this package.
     */
    protected static MessageResources messages =
     MessageResources.getMessageResources
        (&quot;org.apache.struts.taglib.logic.LocalStrings&quot;);

    /**
     * The name of the JSP bean to be used as a variable (if
     * &lt;code&gt;property&lt;/code&gt; is not specified), or whose property is to be
     * accessed (if &lt;code&gt;property&lt;/code&gt; is specified).
     */
    protected String name = null;

    public String getName() {
        return (this.name);
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * The name of the HTTP request parameter to be used as a variable.
     */
    protected String parameter = null;

    public String getParameter() {
        return (this.parameter);
    }

    public void setParameter(String parameter) {
        this.parameter = parameter;
    }

    /**
     * The name of the bean property to be used as a variable.
     */
    protected String property = null;

    public String getProperty() {
        return (this.property);
    }

    public void setProperty(String property) {
        this.property = property;
    }

    /**
     * The name of the security role to be checked for.
     */
    protected String role = null;

    public String getRole() {
        return (this.role);
    }

    public void setRole(String role) {
        this.role = role;
    }

    /**
     * The scope to search for the bean named by the name property, or
     * &quot;any scope&quot; if null.
     */
    protected String scope = null;

    public String getScope() {
        return (this.scope);
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    /**
     * The user principal name to be checked for.
     */
    protected String user = null;

    public String getUser() {
        return (this.user);
    }

    public void setUser(String user) {
        this.user = user;
    }

    // --------------------------------------------------------- Public Methods

    /**
     * Perform the test required for this particular tag, and either evaluate
     * or skip the body of this tag.
     *
     * @exception JspException if a JSP exception occurs
     */
<font color="#0080FF">    public int doStartTag() throws JspException {
        if (condition())
            return (EVAL_BODY_INCLUDE);
        else
            return (SKIP_BODY);
    }
</font>
    /**
     * Evaluate the remainder of the current page normally.
     *
     * @exception JspException if a JSP exception occurs
     */
<font color="#0080FF">    public int doEndTag() throws JspException {
        return (EVAL_PAGE);
    }
</font>

    /**
     * Release all allocated resources.
     */
    public void release() {
        super.release();
        cookie = null;
        header = null;
        name = null;
        parameter = null;
        property = null;
        role = null;
        scope = null;
        user = null;
    }

    // ------------------------------------------------------ Protected Methods
    /**
     * Evaluate the condition that is being tested by this particular tag,
     * and return &lt;code&gt;true&lt;/code&gt; if the nested body content of this tag
     * should be evaluated, or &lt;code&gt;false&lt;/code&gt; if it should be skipped.
     * This method must be implemented by concrete subclasses.
     *
     * @exception JspException if a JSP exception occurs
     */
<font color="#0080FF">    protected abstract boolean condition() throws JspException;
</font>}</pre>
<ul>
  <li>Agora, podemos ver o tag handler para &lt;logic:present&gt;
    <ul>
      <li>Examine o código em <font color="#0080FF">azul</font></li>
      <li>O tag pode testar a presença de várias coisas mas destacamos apenas
        a forma de verificar a presença de um parâmetro</li>
      <li>O leitor pode estudar o resto do código com atenção</li>
    </ul>
  </li>
</ul>
<pre class="clsCode">package org.apache.struts.taglib.logic;

import java.security.Principal;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.PageContext;
import org.apache.struts.util.PropertyUtils;
import org.apache.struts.util.RequestUtils;

/**
 * Evalute the nested body content of this tag if the specified value
 * is present for this request.
 *
 * @author Craig R. McClanahan
 * @version $Revision: 1.1 $ $Date: 2003/04/25 13:04:37 $
 */
public class PresentTag extends ConditionalTagBase {
    // ------------------------------------------------------ Protected Methods
    /**
     * Evaluate the condition that is being tested by this particular tag,
     * and return &lt;code&gt;true&lt;/code&gt; if the nested body content of this tag
     * should be evaluated, or &lt;code&gt;false&lt;/code&gt; if it should be skipped.
     * This method must be implemented by concrete subclasses.
     *
     * @exception JspException if a JSP exception occurs
     */
<font color="#0080FF">    protected boolean condition() throws JspException {
        return (condition(true));
    }</font>

    /**
     * Evaluate the condition that is being tested by this particular tag,
     * and return &lt;code&gt;true&lt;/code&gt; if the nested body content of this tag
     * should be evaluated, or &lt;code&gt;false&lt;/code&gt; if it should be skipped.
     * This method must be implemented by concrete subclasses.
     *
     * @param desired Desired outcome for a true result
     *
     * @exception JspException if a JSP exception occurs
     */
    protected boolean condition(boolean desired) throws JspException {
        // Evaluate the presence of the specified value
        boolean present = false;
        if (cookie != null) {
            Cookie cookies[] =
                ((HttpServletRequest) pageContext.getRequest()).
                getCookies();
            if (cookies == null)
                cookies = new Cookie[0];
            for (int i = 0; i &lt; cookies.length; i++) {
                if (cookie.equals(cookies[i].getName())) {
                    present = true;
                    break;
                }
            }
        } else if (header != null) {
            String value =
                ((HttpServletRequest) pageContext.getRequest()).
                getHeader(header);
            present = (value != null);
        } else if (name != null) {
            Object value = null;
            try {
                value =
                    RequestUtils.lookup(pageContext, name, property, scope);
            } catch (JspException e) {
                value = null;
            }
            present = (value != null);
<font color="#0080FF">        } else if (parameter != null) {
            String value =
                pageContext.getRequest().getParameter(parameter);
            present = (value != null);
</font>        } else if (role != null) {
            HttpServletRequest request =
                (HttpServletRequest) pageContext.getRequest();
            present = request.isUserInRole(role);
        } else if (user != null) {
            HttpServletRequest request =
                (HttpServletRequest) pageContext.getRequest();
            Principal principal = request.getUserPrincipal();
            present = (principal != null) &amp;&amp;
                user.equals(principal.getName());
        } else {
            JspException e = new JspException
                (messages.getMessage(&quot;logic.selector&quot;));
            RequestUtils.saveException(pageContext, e);
            throw e;
        }
        return (present == desired);
    }
}</pre>

<h2>Quarto&nbsp; Exemplo: Um tag com corpo</h2>

<h3>O que queremos</h3>

<ul>
  <li>Queremos examinar o tag <font color="#0080FF">&lt;logic:iterate/&gt;</font>
    do pacote Struts</li>
  <li>O que ele faz?
    <ul>
      <li>Aqui está a documentação do tag</li>
    </ul>
  </li>
</ul>
<table>
  <tr>
    <td bgColor="#023264"><font color="#ffffff" face="arial,helvetica,sanserif"><strong>iterate</strong>
      - Repeat the nested body content of this tag over a specified collection.</font></td>
  </tr>
  <tr>
    <td>
      <blockquote>
        <INFO>
        <p>Repeats the nested body content of this tag once for every element of
        the specified collection, which must be an <code>Iterator</code>, a <code>Collection</code>,
        a <code>Map</code> (whose values are to be iterated over), or an array.
        The collection to be iterated over must be specified in one of the
        following ways:<br>
        </p>
        <ul>
          <li>As a runtime expression specified as the value of the <code>collection</code>
            attribute.
          <li>As a JSP bean specified by the <code>name</code> attribute.
          <li>As the property, specified by the <code>property</code>, of the
            JSP bean specified by the <code>name</code> attribute.</li>
        </ul>
        <p>The collection to be iterated over MUST conform to one of the
        following requirements in order for iteration to be successful:<br>
        </p>
        <ul>
          <li>An array of Java objects (but not primitive data types such as
            &quot;int&quot;)
          <li>An implementation of <code>java.util.Collection</code>, including <code>ArrayList</code>
            and <code>Vector</code>.
          <li>An implementation of <code>java.util.Enumeration</code>.
          <li>An implementation of <code>java.util.Iterator</code>.
          <li>An implementation of <code>java.util.Map</code>, including <code>HashMap</code>,
            <code>Hashtable</code>, and <code>TreeMap</code>. <strong>NOTE</strong>
            - See below for additional information about accessing Maps.</li>
        </ul>
        <p>Normally, each object exposed by the iterate tag is an element of the
        underlying collection you are iterating over. However, if you iterate
        over a <code>Map</code>, the exposed object is of type <code>Map.Entry</code>
        that has two properties:<br>
        </p>
        <ul>
          <li><code>key</code> - The key under which this item is stored in the
            underlying Map.
          <li><code>value</code> - The value that corresponds to this key.</li>
        </ul>
        <p>So, if you wish to iterate over the values of a Hashtable, you would
        implement code like the following:<br>
        </p>
        <code>&lt;logic:iterate id=&quot;element&quot; name=&quot;myhashtable&quot;&gt;<br>
        Next element is &lt;bean:write name=&quot;element&quot; property=&quot;value&quot;/&gt;<br>
        &lt;/logic:iterate&gt;</code>
        <p>If the collection you are iterating over can contain <code>null</code>
        values, the loop will still be performed but no page scope attribute (named
        by the <code>id</code> attribute) will be created for that loop
        iteration. You can use the <code>&lt;logic:present&gt;</code> and <code>&lt;logic:notPresent&gt;</code>
        tags to test for this case.<br>
        </p>
        <p><strong>WARNING</strong> - Currently, this tag cannot deal with
        arrays of primitive data types. Only arrays of Java objects (including
        Strings) are supported.<br>
        </p>
        </INFO>
      </blockquote>
    </td>
  </tr>
  <tr>
    <td>
      <blockquote>
        <table border="1" cellPadding="2" cellSpacing="2">
          <tbody>
            <tr>
              <th width="15%">Attribute Name</th>
              <th>Description</th>
            </tr>
            <tr>
              <td align="middle">collection</td>
              <td><INFO>
                <p>A runtime expression that evaluates to a collection (conforming
                to the requirements listed above) to be iterated over.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">id</td>
              <td><INFO>
                <p>The name of a page scope JSP bean that will contain the
                current element of the collection on each iteration, if it is
                not <code>null</code>.<br>
                </p>
                </INFO>
                [Required] [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">indexId</td>
              <td><INFO>
                <p>The name of a page scope JSP bean that will contain the
                current index of the collection on each iteration.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">length</td>
              <td><INFO>
                <p>The maximum number of entries (from the underlying collection)
                to be iterated through on this page. This can be either an
                integer that directly expresses the desired value, or the name
                of a JSP bean (in any scope) of type <code>java.lang.Integer</code>
                that defines the desired value. If not present, there will be no
                limit on the number of iterations performed.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">name</td>
              <td><INFO>
                <p>The name of the JSP bean containing the collection to be
                iterated (if <code>property</code> is not specified), or the JSP
                bean whose property getter returns the collection to be iterated
                (if <code>property</code> is specified).<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">offset</td>
              <td><INFO>
                <p>The zero-relative index of the starting point at which
                entries from the underlying collection will be iterated through.
                This can be either an integer that directly expresses the
                desired value, or the name of a JSP bean (in any scope) of type <code>java.lang.Integer</code>
                that defines the desired value. If not present, zero is assumed
                (meaning that the collection will be iterated from the beginning.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">property</td>
              <td><INFO>
                <p>Name of the property, of the JSP bean specified by <code>name</code>,
                whose getter returns the collection to be iterated.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">scope</td>
              <td><INFO>
                <p>The bean scope within which to search for the bean named by
                the <code>name</code> property, or &quot;any scope&quot; if not
                specified.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
            <tr>
              <td align="middle">type</td>
              <td><INFO>
                <p>Fully qualified Java class name of the element to be exposed
                through the JSP bean named from the <code>id</code> attribute.
                If not present, no type conversions will be performed. NOTE: The
                actual elements of the collection must be assignment-compatible
                with this class, or a request time ClassCastException will occur.<br>
                </p>
                </INFO>
                [RT Expr]</td>
            </tr>
          </tbody>
        </table>
      </blockquote>
    </td>
  </tr>
</table>
<ul>
  <li>Agora, podemos ver o código do tag handler</li>
</ul>
<pre class="clsCode">package org.apache.struts.taglib.logic;

import java.util.Arrays;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Map;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.BodyTagSupport;

import org.apache.struts.util.IteratorAdapter;
import org.apache.struts.util.MessageResources;
import org.apache.struts.util.PropertyUtils;
import org.apache.struts.util.RequestUtils;
import org.apache.struts.util.ResponseUtils;

/**
 * Custom tag that iterates the elements of a collection, which can be
 * either an attribute or the property of an attribute.  The collection
 * can be any of the following:  an array of objects, an Enumeration,
 * an Iterator, a Collection (which includes Lists, Sets and Vectors),
 * or a Map (which includes Hashtables) whose elements will be iterated over.
 *
 * @author Craig R. McClanahan
 * @version $Revision: 1.1 $ $Date: 2003/04/25 13:04:37 $
 */

public class IterateTag extends BodyTagSupport {
    // ----------------------------------------------------- Instance Variables
    /**
     * Iterator of the elements of this collection, while we are actually
     * running.
     */
    protected Iterator iterator = null;

    /**
     * The number of elements we have already rendered.
     */
    protected int lengthCount = 0;

    /**
     * The actual length value (calculated in the start tag).
     */
    protected int lengthValue = 0;

    /**
     * The message resources for this package.
     */
    protected static MessageResources messages =
    MessageResources.getMessageResources
    (&quot;org.apache.struts.taglib.logic.LocalStrings&quot;);

    /**
     * The actual offset value (calculated in the start tag).
     */
    protected int offsetValue = 0;

    /**
     * Has this tag instance been started?
     */
    protected boolean started = false;

    // ------------------------------------------------------------- Properties
    /**
     * The collection over which we will be iterating.
     */
    protected Object collection = null;

    public Object getCollection() {
        return (this.collection);
    }

    public void setCollection(Object collection) {
        this.collection = collection;
    }


    /**
     * The name of the scripting variable to be exposed.
     */
    protected String id = null;

    public String getId() {
        return (this.id);
    }

    public void setId(String id) {
        this.id = id;
    }

    /**
     * &lt;p&gt;Return the zero-relative index of the current iteration through the
     * loop.  If you specify an &lt;code&gt;offset&lt;/code&gt;, the first iteration
     * through the loop will have that value; otherwise, the first iteration
     * will return zero.&lt;/p&gt;
     *
     * &lt;p&gt;This property is read-only, and gives nested custom tags access to
     * this information.  Therefore, it is &lt;strong&gt;only&lt;/strong&gt; valid in
     * between calls to &lt;code&gt;doStartTag()&lt;/code&gt; and &lt;code&gt;doEndTag()&lt;/code&gt;.
     * &lt;/p&gt;
     */
    public int getIndex() {
        if (started)
            return (offsetValue + lengthCount - 1);
        else
            return (0);
    }

    /**
     * The name of the scripting variable to be exposed as the current index.
     */
    protected String indexId = null;

    public String getIndexId() {
        return (this.indexId);
    }

    public void setIndexId(String indexId) {
        this.indexId = indexId;
    }

    /**
     * The length value or attribute name (&lt;=0 means no limit).
     */
    protected String length = null;

    public String getLength() {
        return (this.length);
    }

    public void setLength(String length) {
        this.length = length;
    }

    /**
     * The name of the collection or owning bean.
     */
    protected String name = null;

    public String getName() {
        return (this.name);
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * The starting offset (zero relative).
     */
    protected String offset = null;

    public String getOffset() {
        return (this.offset);
    }

    public void setOffset(String offset) {
        this.offset = offset;
    }

    /**
     * The property name containing the collection.
     */
    protected String property = null;

    public String getProperty() {
        return (this.property);
    }

    public void setProperty(String property) {
        this.property = property;
    }

    /**
     * The scope of the bean specified by the name property, if any.
     */
    protected String scope = null;

    public String getScope() {
        return (this.scope);
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    /**
     * The Java class of each exposed element of the collection.
     */
    protected String type = null;

    public String getType() {
        return (this.type);
    }

    public void setType(String type) {
        this.type = type;
    }

    // --------------------------------------------------------- Public Methods
    /**
     * Construct an iterator for the specified collection, and begin
     * looping through the body once per element.
     *
     * @exception JspException if a JSP exception has occurred
     */
<font color="#0080FF">    public int doStartTag() throws JspException {

    // Acquire the collection we are going to iterate over
        Object collection = this.collection;
    if (collection == null)
            collection =
                RequestUtils.lookup(pageContext, name, property, scope);
        if (collection == null) {
            JspException e = new JspException
                (messages.getMessage(&quot;iterate.collection&quot;));
            RequestUtils.saveException(pageContext, e);
            throw e;
        }


    // Construct an iterator for this collection
    if (collection.getClass().isArray())
        collection = Arrays.asList((Object[]) collection);
    if (collection instanceof Collection)
        iterator = ((Collection) collection).iterator();
    else if (collection instanceof Iterator)
        iterator = (Iterator) collection;
    else if (collection instanceof Map)
        iterator = ((Map) collection).entrySet().iterator();
    else if (collection instanceof Enumeration)
        iterator = new IteratorAdapter((Enumeration)collection);
       else {
        JspException e = new JspException
            (messages.getMessage(&quot;iterate.iterator&quot;));
            RequestUtils.saveException(pageContext, e);
            throw e;
        }

    // Calculate the starting offset
    if (offset == null)
        offsetValue = 0;
    else {
        try {
            offsetValue = Integer.parseInt(offset);
        } catch (NumberFormatException e) {
        Integer offsetObject =
          (Integer) pageContext.findAttribute(offset);
        if (offsetObject == null)
            offsetValue = 0;
        else
            offsetValue = offsetObject.intValue();
        }
    }
    if (offsetValue &lt; 0)
        offsetValue = 0;

    // Calculate the rendering length
    if (length == null)
        lengthValue = 0;
    else {
        try {
        lengthValue = Integer.parseInt(length);
        } catch (NumberFormatException e) {
        Integer lengthObject =
          (Integer) pageContext.findAttribute(length);
        if (lengthObject == null)
            lengthValue = 0;
        else
            lengthValue = lengthObject.intValue();
        }
    }
    if (lengthValue &lt; 0)
        lengthValue = 0;
    lengthCount = 0;

    // Skip the leading elements up to the starting offset
    for (int i = 0; i &lt; offsetValue; i++) {
        if (iterator.hasNext()) {
            Object element = iterator.next();
        }
    }

    // Store the first value and evaluate, or skip the body if none
    if (iterator.hasNext()) {
        Object element = iterator.next();
            if (element == null)
                pageContext.removeAttribute(id);
            else
                pageContext.setAttribute(id, element);
        lengthCount++;
            started = true;
            if (indexId != null)
                pageContext.setAttribute(indexId, new Integer(getIndex()));
        return (EVAL_BODY_TAG);
        } else
            return (SKIP_BODY);

    }</font>

    /**
     * Make the next collection element available and loop, or
     * finish the iterations if there are no more elements.
     *
     * @exception JspException if a JSP exception has occurred
     */
<font color="#0080FF">    public int doAfterBody() throws JspException {

        // Render the output from this iteration to the output stream
        if (bodyContent != null) {
            ResponseUtils.writePrevious(pageContext, bodyContent.getString());
            bodyContent.clearBody();
        }

        // Decide whether to iterate or quit
        if ((lengthValue &gt; 0) &amp;&amp; (lengthCount &gt;= lengthValue))
            return (SKIP_BODY);
        if (iterator.hasNext()) {
            Object element = iterator.next();
            if (element == null)
                pageContext.removeAttribute(id);
            else
                pageContext.setAttribute(id, element);
            lengthCount++;
            if (indexId != null)
                pageContext.setAttribute(indexId, new Integer(getIndex()));
            return (EVAL_BODY_TAG);
        } else
            return (SKIP_BODY);
    }
</font>
    /**
     * Clean up after processing this enumeration.
     *
     * @exception JspException if a JSP exception has occurred
     */
    public int doEndTag() throws JspException {
        // Clean up our started state
        started = false;

        // Continue processing this page
        return (EVAL_PAGE);
    }


    /**
     * Release all allocated resources.
     */
    public void release() {
        super.release();
        iterator = null;
        lengthCount = 0;
        lengthValue = 0;
        offsetValue = 0;

        id = null;
        collection = null;
        length = null;
        name = null;
        offset = null;
        property = null;
        scope = null;
        started = false;
    }
}</pre>
<ul>
  <li>O objetivo de doStartTag() é:
    <ul>
      <li>Acertar a coleção a tratar (collection)</li>
      <li>Acertar o offset inicial (offset)</li>
      <li>Acertar o número máximo de iterações (length)</li>
      <li>Se a coleção estiver vazia, retornar SKIP_BODY</li>
      <li>Se a coleção não estiver vazia:
        <ul>
          <li>Expor indexId como &quot;scripting variable&quot; contendo o
            índice do objeto corrente</li>
          <li>Expor o objeto como scripting variable &quot;id&quot;</li>
          <li>Retornar EVAL_BODY_TAG para mandar avaliar o corpo</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Agora, examine doAfterBody(), chamado após a avaliação do corpo. O
    objetivo é:
    <ul>
      <li>Por a iteração corrente do corpo para fora
        <ul>
          <li>O corpo pode ser diferente a cada iteração devido ao valor das
            scripting variables</li>
        </ul>
      </li>
      <li>Decidir se continua (retorna EVAL_BODY_TAG) ou pára (retorna
        SKIP_BODY)</li>
    </ul>
  </li>
</ul>
<p class="botref">tags <a href="../j2ee-2.htm">programa</a> </p>
