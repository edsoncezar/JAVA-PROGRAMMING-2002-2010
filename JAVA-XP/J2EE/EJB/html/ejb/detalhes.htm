<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<link REL="stylesheet" TYPE="text/css" HREF="../cursos.css" />
<title>Detalhes sobre o modelo EJB</title>
</head>

<body>

<h1 align="center">Detalhes sobre o modelo EJB</h1>

<h2>Localização, Factory e Interfaces</h2>

<p align="center"><img src="ejb3.gif" alt="ejb3.gif (13287 bytes)" width="705"
height="526"></p>

<ul>
  <li>A <font color="#0080FF">interface Home </font>e o <font color="#0080FF">Home Object</font><ul>
      <li>Interface de Factory para <font color="#0080FF">criar, localizar e remover </font>instâncias
        de Beans</li>
      <li>O desenvolvedor de Beans define esta interface</li>
      <li>O Home Object implementa a interface Home<ul>
          <li>Implementa todos os serviços de lifecycle do Bean</li>
          <li>Lembre que os Beans <em>não </em>são acessados diretamente</li>
          <li>Apenas o container (Home Object e EJBObject) acessa os Beans</li>
        </ul>
      </li>
      <li>O Home Object é automaticamente construído pelas ferramentas do Container Provider a
        partir da interface especificada</li>
      <li>O Home Object deve ser localizado pelo cliente através dos serviços de Naming (JNDI) do
        EJB Server<ul>
          <li>É assim que tudo começa</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>A <font color="#0080FF">interface Remote</font> e o <font color="#0080FF">EJBObject</font><ul>
      <li>Especifica os Business Methods do Bean</li>
      <li>O cliente acessa o EJBObject e este interpõe a funcionalidade desejada (persistência,
        transação, segurança, gerência de estado), e acessa o Bean</li>
      <li>Quem realmente implementa a interface Remote é o EJBObject, não o Bean</li>
      <li>O EJBObject é gerado automaticamente pelas ferramentas do Container Provider a partir
        da interface especificada</li>
    </ul>
  </li>
  <li>Convenções de nomes para EJB</li>
</ul>

<table border="1" width="100%">
  <tr>
    <td width="33%" align="center"><big><strong>Item</strong></big></td>
    <td width="33%" align="center"><big><strong>Sintaxe</strong></big></td>
    <td width="34%" align="center"><big><strong>Exemplo</strong></big></td>
  </tr>
  <tr>
    <td width="33%">Nome do EJB no DD</td>
    <td width="33%">&lt;nome&gt;EJB</td>
    <td width="34%">AccountEJB</td>
  </tr>
  <tr>
    <td width="33%">Nome de display do EJB JAR no DD</td>
    <td width="33%">&lt;nome&gt;JAR</td>
    <td width="34%">AccountJAR</td>
  </tr>
  <tr>
    <td width="33%">Classe de implementação do EJB</td>
    <td width="33%">&lt;nome&gt;Bean</td>
    <td width="34%">AccountBean</td>
  </tr>
  <tr>
    <td width="33%">Home interface </td>
    <td width="33%">&lt;nome&gt;Home</td>
    <td width="34%">AccountHome</td>
  </tr>
  <tr>
    <td width="33%">Remote interface</td>
    <td width="33%">&lt;nome&gt;</td>
    <td width="34%">Account</td>
  </tr>
</table>

<h2>Tipos de Beans</h2>
<div align="left">

<table border="1" width="100%">
  <tr>
    <td width="19%" bgcolor="#FFFF00"><p align="center"><big>Característica</big></td>
    <td width="41%" bgcolor="#FFFF00"><p align="center"><big>Session Bean</big></td>
    <td width="41%" bgcolor="#FFFF00"><p align="center"><big>Entity Bean</big></td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">O que o Bean&nbsp; representa</td>
    <td width="41%"><ul>
      <li>Uma conversação transiente com um cliente</li>
      <li>Pode ser considerado uma extensão do cliente que o criou</li>
      <li>Pode acessar um banco de dados usando JDBC ou acessando um Entity Bean</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Dão uma visão OO de um BD</li>
      <li>Representam dados num banco de dados e os métodos que agem sobre os dados</li>
      <li>Num SGBDR, cada Bean poderia&nbsp; representar um registro de uma tabela, por exemplo</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Tempo de vida</td>
    <td width="41%"><ul>
      <li>Igual ao tempo de vida do cliente. Existe somente durante uma sessão cliente/servidor<br>
        (curto espaço de tempo)</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Persiste tanto quanto os dados do banco de dados (longo espaço de tempo)</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Atributos</td>
    <td width="41%"><ul>
      <li>Representam o estado da conversação. Este estado é mantido entre chamadas a métodos
        mas não depois que a sessão acaba</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Representam dados de um banco de dados (colunas de uma tabela, por exemplo)</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Persistência<br>
    (além da sessão)</td>
    <td width="41%"><ul>
      <li>O Bean deve gerenciar sua própria persistência</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Gerenciada automaticamente pelo Container</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Compartilhamento</td>
    <td width="41%"><ul>
      <li>Um único Bean por cliente (sem compartilhamento)</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Acesso compartilhado entre clientes</li>
      <li>Container gerencia a concorrência</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Criação</td>
    <td width="41%"><ul>
      <li>No início de uma sessão</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Identificado usando uma chave primária</li>
      <li>A criação de um novo Bean insere dados num banco de dados</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Durabilidade</td>
    <td width="41%"><ul>
      <li>Não sobrevive a um crash de servidor</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Sobrevive a um crash de servidor</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Transação</td>
    <td width="41%"><ul>
      <li>Pode ser &quot;transaction-aware&quot;, se assim for programado</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>Transacional</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="19%" bgcolor="#FFFF00">Exemplo</td>
    <td width="41%"><ul>
      <li>Shopping Cart</li>
    </ul>
    </td>
    <td width="41%"><ul>
      <li>User Account Bean mantendo os dados associados a um usuário num site de compras</li>
    </ul>
    </td>
  </tr>
</table>
</div>

<h3>Diferenças entre dois tipos de Session Beans</h3>

<ul>
  <li>O tipo é definido no Deployment Descriptor</li>
</ul>
<div align="left">

<table border="1" width="100%">
  <tr>
    <td width="22%" bgcolor="#FFFF00"><p align="center"><big>Característica</big></td>
    <td width="23%" bgcolor="#FFFF00"><p align="center"><big>Stateful Session Bean</big></td>
    <td width="64%" bgcolor="#FFFF00"><p align="center"><big>Stateless Session Bean</big></td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FFFF00">Gerência de estado</td>
    <td width="23%"><ul>
      <li>Gerenciado automaticamente pelo Container<br>
        (Activation, Passivation)</li>
    </ul>
    </td>
    <td width="64%"><ul>
      <li>Não há estado a ser gerenciado</li>
      <li>Bean pode sair da memória sem salvar qualquer coisa (não há &quot;Passivation&quot;)</li>
      <li>Beans são intercambiáveis e podem ser alocados de um &quot;pool&quot;</li>
    </ul>
    <p align="center"><img src="Pool-Session-Beans-Stateless.gif" width="427" height="294"
    alt="Pool-Session-Beans-Stateless.gif (5199 bytes)"></td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FFFF00">Responsabilidades</td>
    <td width="23%"><ul>
      <li>Estado conversacional pode ser mantido no Bean</li>
    </ul>
    </td>
    <td width="64%"><ul>
      <li>O cliente tem que manter qualquer estado necessário</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FFFF00">Performance</td>
    <td width="23%"><ul>
      <li>Mais pesado</li>
    </ul>
    </td>
    <td width="64%"><ul>
      <li>Extremamente lightweight</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="22%" bgcolor="#FFFF00">Exemplo</td>
    <td width="23%"><ul>
      <li>Shopping Cart</li>
    </ul>
    </td>
    <td width="64%"><ul>
      <li>Verificação de crédito<br>
        (Todo o trabalho pode ser feito numa única chamada de método)</li>
      <li>Mailer Bean para enviar mail confirmando uma compra</li>
      <li>Bean que valida um ID de empregado</li>
      <li>Acesso a um Catálogo de Produtos. Embora pareça melhor usar um Entity bean aqui,
        devido à persistência, lembre que o catálogo não está associado a um cliente
        particular e que nenhum estado sobre o cliente deve ser mantido. Porém, um estado geral,
        não específico a um cliente particular pode ser mantido. Podemos usar Stateless Beans
        para montar uma cache do catálogo à medida que este é acessado. O Bean provê browsing
        e searching no catálogo. Como o Bean poderá manipular várias linhas do catálogo ao
        mesmo tempo (no search, p. ex.) e oferecer uma visão compartilhada de informação, o
        Bean poderá ser compartilhado.</li>
    </ul>
    </td>
  </tr>
</table>
</div>

<h3>Regras para escolher o tipo de Bean</h3>

<ul>
  <li>Uso de Entity Beans<ul>
      <li>Quando o estado do Business Object deve ser armazenado de forma persistente e o
        comportamento do objeto tem a ver basicamente com o acesso ao estado</li>
      <li>Para prover acesso concorrente por múltiplos clientes, quando o estado não é
        específico a um cliente</li>
      <li>Para representar uma única linha lógica de um BD</li>
      <li>Para prover robustez. Se dados de um cliente devem permanecer quando uma sessão de
        cliente acabou ou depois de um crash de servidor, use um Entity Bean</li>
    </ul>
  </li>
  <li>Uso de Stateful Session Bean<ul>
      <li>Para manter estado específico a um cliente (estado conversacional). Não há
        compartilhamento com outros clientes</li>
      <li>Para representar objetos não persistentes (objetos com curto tempo de vida e que não
        precisam permanecer depois de uma sessão ou após um crash de servidor)</li>
      <li>Para representar o workflow entre Business Objects (para administrar as interações
        entre Business Objects)</li>
    </ul>
  </li>
  <li>Uso de Stateless Session Bean<ul>
      <li>Para modelar serviços reutilizáveis (prevendo um serviço genérico para os clientes,
        sem manter dados específicos de um cliente)</li>
      <li>Para prover alto desempenho (porém, lembre que o cliente terá que manter o estado, se
        necessário)</li>
      <li>Para operar sobre múltiplas linhas lógicas de um BD (para representar uma visão
        compartilhada de dados fixos)</li>
      <li>Para prover uma visão procedural dos dados (quando se foge do modelo OO e todos os
        dados necessários são fornecidos na entrada e todos os resultados retornados no fim do
        procedimento)</li>
    </ul>
  </li>
  <li>Business Logic deve estar nos Session Beans<ul>
      <li>Para escalabilidade, prefira Stateless Session Beans</li>
      <li>O uso de Stateful Beans deve ser minimizado</li>
    </ul>
  </li>
  <li>Para acesso a BD, prefira Entity Beans para:<ul>
      <li>Ter uma visão OO dos dados</li>
      <li>Não ter que tratar de aspectos transacionais, de persistência, de segurança, etc.</li>
    </ul>
  </li>
  <li>Faça com que o cliente acesse apenas Session Beans<ul>
      <li>Esconda os Entity Beans atrás de Session Beans</li>
      <li>Por quê?<ul>
          <li>Para possibilitar armazenar estado transacional o que não deve ser feito em Entity
            Beans</li>
          <li>Se houver aspectos transacionais não triviais a considerar, eles podem ser tratados no
            Session Bean (escrito por um especialista) e o Application Developer não vai ter que
            saber nada sobre transações</li>
          <li>Melhora a integridade dos Bancos de Dados, já que o Application Developer não vai
            manipular o BD diretamente. Ele só usaria Session Beans</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Há um outro tipo de bean (Message-Driven) que não veremos<ul>
      <li>Usado para processar mensagens assíncronas</li>
    </ul>
  </li>
</ul>

<h2>Detalhes sobre os serviços automáticos</h2>

<h3>Gerência de estado</h3>

<ul>
  <li>Para gerenciar recursos limitados, o Container pode expulsar (&quot;passivar&quot;) um
    Bean (fazendo com que ele ocupe menos recursos temporariamente)<ul>
      <li>Não ocorre para Stateless Session Beans</li>
    </ul>
  </li>
  <li>O Container decide como e quando fazer isso</li>
  <li>Tem <em>hook methods</em> ejbActivate() e ejbPassivate() que permitem colocar a lógica
    adicional desejada para estes momentos<ul>
      <li>Lembra que o container é um framework e oferece <em>hook methods</em></li>
      <li>Normalmente, os <em>hooks methods </em>nada fazem porque o framework já tratou de tudo</li>
    </ul>
  </li>
</ul>

<h3>Gerência de persistência</h3>

<ul>
  <li>Para Entity Beans</li>
  <li>Além de simplicidade, uma outra vantagem fundamental de usar persistência Bean-managed
    é que posso mudar a fonte de dados subjacente no futuro e nada afetar no componente ou
    nas aplicações que o usam</li>
  <li>Tem vários hook methods que podem ser utilizadas<ul>
      <li>ejbCreate(), ejbRemove(), ejbLoad(), ejbStore(), ejbActivate(), ejbPAssivate()</li>
    </ul>
  </li>
  <li>A persistência pode ser tratada pelo próprio Bean (Bean-managed persistence)<ul>
      <li>Usar só se a ação default do container não for adequada</li>
      <li>Apoia-se nos métodos ejbLoad() e ejbStore(), principalmente, usando chamadas JDBC, por
        exemplo</li>
    </ul>
  </li>
  <li>Pode ser Container-managed com várias alternativas de implementação em existência<ul>
      <li>Serialização do componente</li>
      <li>Mapeamento de campos do Bean para colunas de uma única tabela de um SGBD Relacional<ul>
          <li>O mapeamento é feito em tempo de deployment</li>
        </ul>
      </li>
      <li>Se o Bean envolver várias tabelas, pode-se criar uma View e mapear os campos do Bean
        para colunas da view<ul>
          <li>Porém, lembre que vários BDs não permitem atualizar os dados de uma view</li>
        </ul>
      </li>
      <li>Implementação de complex joins através de um mapeamento Object-Relational, com uma
        ferramenta visual especial</li>
    </ul>
  </li>
</ul>

<h3>Gerência de transações</h3>

<ul>
  <li>Para Session Beans e Entity Beans</li>
  <li>Suporta transações distribuídas<ul>
      <li>Envolvendo vários bancos de dados</li>
    </ul>
  </li>
  <li>Demarcação de transação pode ser feita das seguintes formas:<ul>
      <li>Com código usando javax.jts.UserTransaction</li>
      <li>Automaticamente feito pelo Container com instruções no Deployment Descriptor<ul>
          <li>Demarcação: os atributos de demarcação podem se aplicar ao Bean todo ou a métodos
            individuais</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Tipos de atributos de transação:<ul>
      <li>TX_NOT_SUPPORTED: chamada feita fora do contexto de qualquer transação</li>
      <li>TX_BEAN_MANAGED: o Bean se vira</li>
      <li>TX_REQUIRED: ao entrar no método, usa o contexto atual de transação se houver, caso
        contrário, crie um novo contexto de transação</li>
      <li>TX_SUPPORTS: Se o método for chamado dentro de um contexto de transação, ok; caso
        contrário, também ok.</li>
      <li>TX_REQUIRES_NEW: Um novo contexto de transação é sempre criado</li>
      <li>TX_MANDATORY: Se não houver contexto de transação, lança exceção</li>
    </ul>
  </li>
  <li>Tratamento de concorrência:<ul>
      <li>Vários níveis de isolamento de transação disponíveis (no deployment descriptor)</li>
      <li>Esses níveis dizem quanto de <em>outras</em> transações as suas estarão vendo
        durante a execução</li>
      <li>Existe uma relação inversamente proporcional entre altos níveis de isolamento e o
        nível de concorrência<ul>
          <li>Se você quiser mais isolamento, mais locks serão usados pelo BD, haverá menos
            concorrência e os tempos de espera crescerão</li>
        </ul>
      </li>
      <li>Para entender os níveis de isolamento, precisamos entender três situações que podem
        ocorrer:<ul>
          <li>Problema 1: Transação A modifica uma linha; transação B lê a mesma linha;
            transação A faz rollback e a linha desaparece. Esta situação chama-se <font
            color="#0080FF">dirty read</font>.</li>
          <li>Problema 2: Transação A lê uma linha; transação B modifica a linha; transação A
            lê a linha novamente e vê valores diferentes. Esta situação chama-se <font
            color="#0080FF">non-repeatable read</font>.</li>
          <li>Problema 3: Transação A seleciona um conjunto de linhas satisfazendo um critério de
            pesquisa (cláusula WHERE); Transação B insere linhas que também satisfazem a pesquisa;
            Transação A repete a pesquisa e recebe novos dados. Esta situação chama-se <font
            color="#0080FF">phantom read</font>.</li>
        </ul>
      </li>
      <li>No EJB, 4 níveis de isolamento são possíveis:<ul>
          <li>TRANSACTION_READ_UNCOMMITTED<ul>
              <li>Permite dirty reads, non-repeatable reads e phantom reads</li>
            </ul>
          </li>
          <li>TRANSACTION_READ_COMMITTED<ul>
              <li>Permite non-repeatable reads e phantom reads</li>
            </ul>
          </li>
          <li>TRANSACTION_REPEATABLE_READ<ul>
              <li>Permite phantom reads</li>
            </ul>
          </li>
          <li>TRANSACTION_SERIALIZABLE<ul>
              <li>Não permite as situações acima</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3>Segurança</h3>

<ul>
  <li>Usa o modelo de segurança normal do Java (no JDK)<ul>
      <li>java.security</li>
    </ul>
  </li>
  <li>Tudo é declarado no Deployment descriptor</li>
  <li>Resumo<ul>
      <li>Pode estabelecer &quot;roles&quot;</li>
      <li>Pode associar usuários a roles</li>
      <li>Pode executar certos métodos com privilégios especiais</li>
      <li>Autorização com Access Control Lists<ul>
          <li>Cada método pode ter uma lista de usuários que podem chamá-lo</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2>Detalhes adicionais sobre o Container</h2>

<ul>
  <li>Agora que sabemos mais sobre EJB, podemos listar as coisas que o Container faz<ul>
      <li>Swap de Beans de/para disco</li>
      <li>Gerência de persistência</li>
      <li>Disponibiliza um Home Object (o factory) para criar e localizar Beans</li>
      <li>Registra o Home Object no serviço de nomes (JNDI) para que o cliente possa achá-lo</li>
      <li>Cria, inicializa e remove Beans</li>
      <li>Se encarrega de executar os Business Methods no contexto apropriado de transação</li>
      <li>Implementa serviços básicos de segurança</li>
      <li>Resource pooling (exemplo: conexões de bancos de dados)</li>
      <li>Outros serviços dependentes do fornecedor:<ul>
          <li>Load Balancing</li>
          <li>Fail-over transparente</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2>Resumo: Usar Enterprise Beans ou não?</h2>

<ul>
  <li>Mais você tem dos seguintes requisitos, mais chances há de tirar
    proveito de Enterprise Beans:
    <ul>
      <li>Gerência de persistência (EJB trata isso automaticamente)</li>
      <li>Acesso concorrente a dados (EJB trata isso automaticamente)</li>
      <li>Acesso remoto a dados (Beans EJB podem ser acessados remotamente)</li>
      <li>Modelo de desenvolvimento baseado em componentes</li>
      <li>Transportabilidade (executar em vários ambientes operacionais)</li>
      <li>Controle de transações</li>
      <li>Controle de segurança</li>
      <li>Alta disponibilidade</li>
      <li>Escalabilidade</li>
      <li>Neutralidade com respeito a clientes (cliente pode ser thin, thick,
        web service, CORBA, .Net, ser escrito em qualquer linguagem, ...)</li>
    </ul>
  </li>
</ul>

<p class="botref">detalhes <a href="../j2ee-2.htm">programa</a> </p>
</body>
</html>
