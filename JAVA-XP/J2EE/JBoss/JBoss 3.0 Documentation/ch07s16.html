<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Container configuration</title><link rel="stylesheet" href="styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vimages/callouts/"><link rel="home" href="index.html" title="JBoss 3.0 Documentation"><link rel="up" href="ch07.html" title="Chapter 7. Advanced container configuration : use of jboss.xml"><link rel="previous" href="ch07s13.html" title="Declaring an EJB reference"><link rel="next" href="ch07s22.html" title="Web container configuration : use of jboss-web.xml"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table border="0" cellpadding="0" cellspacing="0" height="65"><tr height="65"><td rowspan="2"><img src="images\jboss.gif" border="0"></td><td rowspan="2" background="images\gbar.gif" width="100%" align="right" valign="top"><a href="index.html"><img src="images\doc.gif" border="0"></a><a href="ch07.html"><img src="images\toc.gif" border="0"></a><a href="ch07s13.html"><img src="images\prev.gif" border="0"></a><a href="ch07s22.html"><img src="images\next.gif" border="0"></a></td></tr><tr></tr></table><div class="section"><a name="d0e2700"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e2700"></a>Container configuration</h2></div></div><p>When you deploy an application, JBoss creates a container for each of your 
beans. This container will be used 
only for this particular bean. It must be configured according to the type of 
the bean (CMP Entity Bean, Stateful
Session Bean, etc.). Different standard configurations are stored in the 
standardjboss.xml file. You may provide
additional custom configurations in the jboss.xml file for your application.</p><div class="section"><a name="d0e2705"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2705"></a>Standard Configurations</h3></div></div><p>JBoss currently provides a standard configuration for each type of bean. These 
configurations are stored in the 
standardjboss.xml file. There are currently 8 standard configurations. If you 
don't provide anything else (as we 
advise you to do, at least at the beginning), JBoss will automatically choose 
the right standard configuration for 
your container. The available configurations are the following: <div class="itemizedlist"><ul><li><p><a name="d0e2711"></a>Standard CMP EntityBean</p></li><li><p><a name="d0e2714"></a>Standard BMP EntityBean </p></li><li><p><a name="d0e2717"></a>Standard Stateless SessionBean </p></li><li><p><a name="d0e2720"></a>Standard Stateful SessionBean </p></li><li><p><a name="d0e2723"></a>Standard Message Driven Bean</p></li><li><p><a name="d0e2726"></a>jdk1.2.2 CMP EntityBean </p></li><li><p><a name="d0e2729"></a>jdk1.2.2 BMP EntityBean </p></li><li><p><a name="d0e2732"></a>jdk1.2.2 Stateless SessionBean </p></li><li><p><a name="d0e2735"></a>jdk1.2.2 Stateful SessionBean </p></li></ul></div>
			</p><p>The first five ones are to be used in all cases. The four last 
ones are deprecated and will disappear in the future.</p><p>They were used if you run JBoss with a jdk1.2.2 JVM as explain below.  From now the VM version
is detected and using the five first configurations is the rule.</p></div><div class="section"><a name="d0e2743"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2743"></a>[Deprecated]How do I configure my bean for jdk1.2.2 clients ?</h3></div></div><p>If you run JBoss on a jdk1.3 JVM, but your clients use jdk1.2.2, the standard 
configuration won't work (the protocols 
are not backward compatible). In this case, you have to force JBoss to use the 
corresponding jdk1.2.2 configuration. 
You do that by providing a jboss.xml file. This file must be in the META-INF 
directory of your jar file, along with 
ejb-jar.xml. In the section for your bean, simply add a &lt;configuration-name&gt; tag. Your xml files will look like 
this (note that the &lt;ejb-name&gt; tags in the 2 xml files must match) 
ejb-jar.xml:
</p><pre class="programlisting">
&lt;ejb-jar&gt;                                                                      
 
  &lt;enterprise-beans&gt;
                                                                      
    &lt;session&gt;
      &lt;ejb-name&gt;Bean A&lt;/ejb-name&gt;
      &lt;home&gt;AHome&lt;/home&gt;
      &lt;remote&gt;A&lt;/remote&gt;
      &lt;ejb-class&gt;ABean&lt;/ejb-class&gt;
      &lt;session-type&gt;Stateful&lt;/session-type&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
      &lt;/ejb-ref&gt;
    &lt;/session&gt;

  &lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;
</pre><p>jboss.xml: </p><pre class="programlisting">
&lt;jboss&gt;                                                               
  &lt;enterprise-beans&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;Bean A&lt;/ejb-name&gt;
      &lt;configuration-name&gt;jdk1.2.2 Stateful SessionBean&lt;configuration-name&gt;    
 
    &lt;/session&gt;
  &lt;enterprise-beans&gt;
&lt;/jboss&gt;
</pre></div><div class="section"><a name="d0e2754"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2754"></a>Custom configurations</h3></div></div><p>You may want to provide your own advanced configuration. For example, you may 
want to increase the size of your pool, 
or use a different instance cache. To do this, you must define your 
configuration in jboss.xml in the &lt;container-configurations&gt; tag. Then you have to use your new 
configuration in the bean section of your jboss.xml file.
For example, if you want to log calls to your bean, your file will look like 
this : 
</p><pre class="programlisting">
&lt;jboss&gt;                                                               
  &lt;enterprise-beans&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;Bean A&lt;/ejb-name&gt;
      &lt;configuration-name&gt;Logging Configuration&lt;configuration-name&gt;
    &lt;/session&gt;
  &lt;enterprise-beans&gt;
  ...
  &lt;container-configurations&gt;
    &lt;container-configuration&gt;
      &lt;container-name&gt;Logging Configuration&lt;/container-name&gt;
      &lt;call-logging&gt;true&lt;/call-logging&gt;
      &lt;container-invoker&gt;org.jboss.ejb.plugins.jrmp.server.JRMPContainerInvoker&lt;/container-invoker&gt;
      &lt;container-interceptors&gt;
         &lt;interceptor&gt;org.jboss.ejb.plugins.LogInterceptor&lt;/interceptor&gt;
         &lt;!-- CMT --&gt;
         &lt;interceptor transaction="Container"&gt;org.jboss.ejb.plugins.TxInterceptorCMT&lt;/interceptor&gt;
         &lt;interceptor transaction="Container" metricsEnabled="true"&gt;org.jboss.ejb.plugins.MetricsInterceptor&lt;/interceptor&gt;
         &lt;interceptor transaction="Container"&gt;org.jboss.ejb.plugins.StatefulSessionInstanceInterceptor&lt;/interceptor&gt;
         &lt;!-- BMT --&gt;
         &lt;interceptor transaction="Bean"&gt;org.jboss.ejb.plugins.StatefulSessionInstanceInterceptor&lt;/interceptor&gt;
         &lt;interceptor transaction="Bean"&gt;org.jboss.ejb.plugins.TxInterceptorBMT&lt;/interceptor&gt;
         &lt;interceptor transaction="Bean" metricsEnabled="true"&gt;org.jboss.ejb.plugins.MetricsInterceptor&lt;/interceptor&gt;
         &lt;interceptor&gt;org.jboss.ejb.plugins.SecurityInterceptor&lt;/interceptor&gt;
      &lt;/container-interceptors&gt;
      &lt;instance-cache&gt;org.jboss.ejb.plugins.StatefulSessionInstanceCache&lt;/instance-cache&gt;
      &lt;persistence-manager&gt;org.jboss.ejb.plugins.StatefulSessionFilePersistenceManager&lt;/persistence-manager&gt;
      &lt;transaction-manager&gt;org.jboss.tm.TxManager&lt;/transaction-manager&gt;
      &lt;container-invoker-conf&gt;
         &lt;RMIObjectPort&gt;4444&lt;/RMIObjectPort&gt;
         &lt;Optimized&gt;False&lt;/Optimized&gt;
      &lt;/container-invoker-conf&gt;
         &lt;container-cache-conf&gt;
            &lt;cache-policy&gt;org.jboss.ejb.plugins.LRUEnterpriseContextCachePolicy&lt;/cache-policy&gt;      
            &lt;cache-policy-conf&gt;
               &lt;min-capacity&gt;1&lt;/min-capacity&gt;
               &lt;max-capacity&gt;1&lt;/max-capacity&gt;
               &lt;overager-period&gt;300&lt;/overager-period&gt;
               &lt;max-bean-age&gt;600&lt;/max-bean-age&gt;
               &lt;resizer-period&gt;400&lt;/resizer-period&gt;
               &lt;max-cache-miss-period&gt;60&lt;/max-cache-miss-period&gt;
               &lt;min-cache-miss-period&gt;1&lt;/min-cache-miss-period&gt;
               &lt;cache-load-factor&gt;0.75&lt;/cache-load-factor&gt;
            &lt;/cache-policy-conf&gt;
         &lt;/container-cache-conf&gt;
    &lt;/container-configuration&gt;
  &lt;/container-configurations&gt;
  ...
&lt;/jboss&gt;
</pre></div><div class="section"><a name="d0e2761"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2761"></a>Content of a container configuration</h3></div></div><p>These are the different things you can customize in a &lt;container-configuration&gt; tag in jboss.xml. See the jboss.xml DTD 
for
more details: 
</p><div class="itemizedlist"><ul><li><p><a name="d0e2767"></a>&lt;call-logging&gt; this tag must have a boolean value: true 
or false. It tells the container if calls to this bean must be 
logged or not. It is set to false in standard configurations. 
</p></li><li><p><a name="d0e2770"></a>&lt;container-invoker&gt; the container invoker is the entry point to the container. Currently, only the RMI/JRMP container invoker is available.
</p></li><li><p><a name="d0e2773"></a>&lt;container-interceptors&gt; the stack of JBoss interceptors for this bean. You can add your custom interceptor here (for expert use only)
</p></li><li><p><a name="d0e2776"></a>&lt;instance-pool&gt; the instance pool is a set (a "pool") of 
free (ie not currently associated to a context) instances of the
bean. When an instance of the bean is no longer used, it is thrown back to the 
pool. This is not used for Stateful Session 
Beans, since the instances are not reusable. 
</p></li><li><p><a name="d0e2779"></a>&lt;instance-cache&gt; the cache contains the instances of a 
bean which are currently associated to a context. If it grows too 
big, the cache may decide to passivate some of the instances. This is not used 
for Stateless Session Beans, since these 
are directly reusable after a call. 
</p></li><li><p><a name="d0e2782"></a>&lt;persistence-manager&gt; the persistence manager is in 
charge of storing permanent information in the instance of a bean. 
For BMP Entities, it will merely transmit orders to the bean; for Stateful 
Sessions and CMP Entities, it has to save the 
state of the bean. This is not used for Stateless Session Beans, since they 
don't have a state to save. 
</p></li><li><p><a name="d0e2785"></a>&lt;container-invoker-conf&gt; configuration of the container invoker. 
</p><p> There are several elements which can nest within
container-invoker-conf, one of which is &lt;Optimized&gt;.  This
controls the behavior of bean method calls within the Java VM in which
jboss is running.  If the value of Optimized is "false" then the
container will behave per the EJB spec and all objects passed into and
out of bean remote methods will be marshalled over RMI regardless of
whether the client is running remotely or in the same VM as jboss.</p><p> If the value of Optimized is "true" then objects passed between
bean methods and clients in the jboss java VM will be passed by
reference rather than by value.  This is <span class="emphasis"><i>much</i></span>
more efficient (and can result in substantial performance
improvements) but can result in unexpected behavior.  For example, if
a bean has a member object and returns that object from a get() method
then the EJB-specified behavior is to make a copy of that object which
is returned over RMI to the caller.  Therefore if the caller modifies
the returned object in any way she will modify the copy of the object.
If Optimized is "true" then the caller will modify the original object
per se, rather than a copy.</p><p>Another element is &lt;RMIObjectPort&gt;, it defines the port on which JBoss runs its RMI Server.  It has to 
be changed when running multiple instances of JBoss on the same server.</p><p>The other elements are specific to Message Driven Beans and are explained in <a href="ch08s20.html#mdb.config.advanced" title="Advanced MDB configuration">the section called &#8220;Advanced MDB configuration&#8221;</a></p></li><li><p><a name="d0e2800"></a>&lt;container-cache-conf&gt; configuration of the cache. See below for more details.
</p></li><li><p><a name="d0e2803"></a>&lt;role-mapping-manager&gt;, &lt;security-domain&gt;, &lt;authentication-module&gt; : security options. 
See <a href="ch13s78.html" title="JAAS Based Security in JBoss">the section called &#8220;JAAS Based Security in JBoss&#8221;</a>.</p></li><li><p><a name="d0e2808"></a>&lt;container-pool-conf&gt; configuration of the pool. Mainly, 
the minimum and maximum size of the pool. 
</p></li><li><p><a name="d0e2811"></a>
&lt;commit-option&gt; must be A, B, C, D (from JBoss 2.4). </p><p>
Option A: The container caches the beans state between transactions.
This options assumes that the bean/container is the only one accessing
the persistent data. Therefore the container synchronizes the
memory state from the persistent storage only (via ejbLoad) when
absolutely neccessary (when the state isn't cached yet), that is
before the first business method executes on a found bean or after
the bean is passivated and reactivated to serve another business
method. This behaviour is regardless of wether the business method
executes inside or outside a transaction.</p><p>
Option B: The container caches the bean between transactions.
However, unlike option A the container does not have exclusive
access to the persistent storage. Therefore, the container will
synchronize the memory state (via ejbLoad) at the beginning of
each transaction. Thus business methods executing in a transaction
context don't see much benefit from the container caching the bean,
whereas business methods executing outside a transaction context
(transaction attributes Never, NotSupported or Supports) access
the cached (and invalid) state of the bean.</p><p>
Option C: The container does not cache bean instances and instances
memory state is synchronized on every transaction start (via ejbLoad).
For business methods executing outside a transaction the synchronization
is done too, but as the ejbLoad executes in the same transaction context
as the triggering business method, the state must still be considered
invalid and might already have changed in the persistent storage when
the business method executes.</p><p>
Option D: This is a JBoss specific feature available from version 2.4. It enables a lazy read schema, where
the beans state is cached between transactions as with option A,
but resynchronized from the persistent storage from time to time
(via ejbLoad). The default time between resynchronizations is 30
seconds but you may configure the time (in seconds) with
&lt;optiond-refresh-rate&gt;42&lt;/optiond-refresh-rate&gt;.</p><p>
With all four commit options the container must synchronize the
bean instances cached state with the persistent storage (via ejbStore)
at the end of each transaction (just before a commit is done)
to be sure the whole transactions state is consistently persistet.
As of the EJB specification there is no safe way for the container to
decide, if the beans state actually has changed since transaction
start, so ejbStore is called, even when all access to the beans
business methods was read only. Note, however, that JBoss supports
an optional method public boolean isModified() in the beans
implementation. If this method returns false, the call to ejbStore
is skipped at commit time.</p><p>
A final note to executing business methods outside of a transaction
context: when reading the beans state you always must consider
the result as invalid and usable for rough display purposes only,
i.e. to fill in a large table, having benefit from bean caching (with
options A, B and D) and avoiding unneccessary concurrency; even with
commit option A, though you get the actual state initially, another
concurrent client might change the beans state a microsecond after
your read. Never write access a bean outside a transaction context
believing ejbStore will be called for synchronization, it typically
will not (though somtimes it might, when the container passivates
the bean) be called. Read the EJB specification 1.1 sections 9.1.7.1
and 11.6.3 carefully, if you plan to use the transaction attributes
Never, NotSupported or Supports.</p><p>
To safely write a bean depending on it's current state ever (re)read
and write the bean within one and the same transaction context.
</p></li></ul></div></div><div class="section"><a name="adv.config-cache"></a><div class="titlepage"><div><h3 class="title"><a name="adv.config-cache"></a>Advanced cache configuration</h3></div></div><p>JBoss currently provides the possibility to choose the cache configuration for 
each container configuration. You may want 
to define your own cache settings, and to do so you must specify them in 
jboss.xml under the &lt;instance-cache&gt; tag and 
subtags. Currently 2 cache algorithms have been implemented: a no passivation 
cache algorithm (so that all the bean are
kept in memory, unless the bean is an entity bean and you specified for it 
commit option C), and a least recently used (LRU)
cache algorithm (so that bean less frequently used are passivated to save 
server resources).
</p><p>Let's see how to configure both caches. The examples below are about entity 
beans, but the cache settings applies as well
for stateful session beans.For the no passivation cache, jboss.xml will look 
like this:</p><pre class="programlisting">
&lt;jboss&gt;                                                               
  &lt;enterprise-beans&gt;
    &lt;entity&gt;
      &lt;ejb-name&gt;Bean A&lt;/ejb-name&gt;
      &lt;configuration-name&gt;No Passivation Configuration&lt;configuration-name&gt;
    &lt;/entity&gt;
  &lt;enterprise-beans&gt;
  ...
  &lt;container-configurations&gt;
    &lt;container-configuration&gt;
      &lt;container-name&gt;No Passivation Configuration&lt;/container-name&gt;
      ...
      &lt;instance-cache&gt;org.jboss.ejb.plugins.EntitySessionInstanceCache&lt;/instance-cache&gt;
      &lt;container-cache-conf&gt;
        &lt;cache-policy&gt;org.jboss.ejb.plugins.NoPassivationCachePolicy&lt;/cache-policy&gt;
      &lt;/container-cache-conf&gt;
      ...
    &lt;/container-configuration&gt;
  &lt;/container-configurations&gt;
  ...
&lt;/jboss&gt;                                                               
</pre><p>No further settings are available for the no passivation cache.
For the LRU cache, jboss.xml will look like this:</p><pre class="programlisting">
&lt;jboss&gt;                                                               
  &lt;enterprise-beans&gt;
    &lt;entity&gt;
      &lt;ejb-name&gt;Bean A&lt;/ejb-name&gt;
      &lt;configuration-name&gt;LRU Configuration&lt;configuration-name&gt;
    &lt;/entity&gt;
  &lt;enterprise-beans&gt;
  ...
  &lt;container-configurations&gt;
    &lt;container-configuration&gt;
      &lt;container-name&gt;LRU Configuration&lt;/container-name&gt;
      ...
      &lt;instance-cache&gt;org.jboss.ejb.plugins.EntitySessionInstanceCache&lt;/instance-cache&gt;
      &lt;container-cache-conf&gt;
        &lt;cache-policy&gt;org.jboss.ejb.plugins.LRUEnterpriseContextCachePolicy&lt;/cache-policy&gt; 
     
        &lt;cache-policy-conf&gt;
          &lt;min-capacity&gt;5&lt;/min-capacity&gt;
          &lt;max-capacity&gt;200&lt;/max-capacity&gt;
          &lt;overager-period&gt;300&lt;/overager-period&gt;
          &lt;max-bean-age&gt;600&lt;/max-bean-age&gt;
          &lt;resizer-period&gt;400&lt;/resizer-period&gt;
          &lt;max-cache-miss-period&gt;60&lt;/max-cache-miss-period&gt;
          &lt;min-cache-miss-period&gt;1&lt;/min-cache-miss-period&gt;
          &lt;cache-load-factor&gt;0.75&lt;/cache-load-factor&gt;
        &lt;/cache-policy-conf&gt;
      &lt;/container-cache-conf&gt;
      ...
    &lt;/container-configuration&gt;
  &lt;/container-configurations&gt;
  ...
&lt;/jboss&gt; 
</pre><div class="itemizedlist"><ul><li><p><a name="d0e2842"></a>&lt;cache-policy-conf&gt; and its subtags are optional, so you 
can specify none, few or all of them.
&lt;min-capacity&gt; specifies the minimum capacity of the cache. The 
cache can be empty, but will have room for at least
5 beans (in the above case); this value cannot be less than 2; the resizer 
(see below) will shrink the cache capacity 
down to but not less than this value.
</p></li><li><p><a name="d0e2845"></a>&lt;max-capacity&gt; specifies the maximum capacity of the 
cache. The cache can be empty, but will have room for at most 200
beans (in the above case); this value cannot be less than the minimum 
capacity; the resizer (see below) will enlarge the
cache capacity up to but not more than this value.
</p></li><li><p><a name="d0e2848"></a>&lt;overager-period&gt; specifies the period of the overager, 
that is a periodic task that runs (in the above case) every 300
seconds. Purpose of this periodic task is to see if in the cache there are 
very old beans, and to passivate them. 
The age at which a bean is considered too old is also configurable (see 
below). While the period of this task is 300 seconds, the first run happens at 
a random time between 0 and 300 seconds.
</p></li><li><p><a name="d0e2851"></a>&lt;max-bean-age&gt; specifies the max age a bean can have 
before being passivated by the overager (in this case 600 seconds).
The tag &lt;resizer-period&gt; specifies the period of the resizer, that 
is a periodic task that runs (in the above case) every 
400 seconds. Purpose of this periodic task is to shrink / enlarge the cache 
capacity upon 3 other parameters (see below).
While the period of this task is 400 seconds, the first run happens at a 
random time between 0 and 400 seconds. 
</p></li><li><p><a name="d0e2854"></a>&lt;max-cache-miss-period&gt;,&lt;min-cache-miss-period&gt; 
and &lt;cache-load-factor&gt; control the resizer in this way: the 
number of 
cache misses is internally recorded. When the resizer runs, it sees what is 
the cache miss rate from the last time it ran.
If there is more than (in the above case) one cache miss every 1 second 
(min-cache-miss-period) then the resizer tries to 
enlarge the cache; if there is less than (in this case) one cache miss every 
60 seconds (max-cache-miss-period) then the 
resizer tries to shrink the cache. How much is the cache enlarged / shrinked ? 
Here is where the load-factor comes in the
picture. When the resizer shrinks, it tries to shrink the cache so that (in 
this case) the ratio number of beans / cache 
capacity is 0.75; when the resizer enlarges, it tries to enlarge the cache by 
a factor 1 / 0.75 == 1.333 (in the above case) plus a correction calculated 
from the cache miss rate (so that the more cache miss rate you have, the more 
the cache is enlarged, starting from at least 1.333; so if you really have a 
lot of cache misses, the resizer may decide to enlarge the cache of a factor 
2.0 instead of 1.333 - if there is room for that).
</p></li></ul></div></div></div><table border="0" cellpadding="0" cellspacing="0" height="65"><tr height="65"><td rowspan="2"><img src="images\gbar.gif" width="432" height="79"></td><td rowspan="2" background="images\gbar.gif" width="100%" align="right" valign="top"><a href="index.html"><img src="images\doc.gif" border="0"></a><a href="ch07.html"><img src="images\toc.gif" border="0"></a><a href="ch07s13.html"><img src="images\prev.gif" border="0"></a><a href="ch07s22.html"><img src="images\next.gif" border="0"></a></td></tr><tr></tr></table></body></html>