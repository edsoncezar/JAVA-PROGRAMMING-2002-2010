<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Swing Chapter3</TITLE>
<META NAME="subject" CONTENT="Frames and Panes">
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Templates\A_author.dot">
</HEAD>
<BODY LINK="#0000ff">

<I><FONT FACE="AGaramond" SIZE=7><P>Part II - The Basics</P>
</I></FONT><FONT FACE="TIMES" SIZE=3><P ALIGN="JUSTIFY">Part II consists of twelve chapters containing discussion and examples of the basic Swing components. Chapter 3 introduces frames, panels and borders, including an example showing how to create a custom rounded-edge border. Chapter 4 is devoted to layout managers with a comparison of the most commonly used layouts, a contributed section on the use of </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="TIMES" SIZE=3>, the construction of several custom layouts, and the beginnings of a JavaBeans property editing environment with the ability to change the layout manager dynamically. Chapter 5 covers labels and buttons, and presents the construction of a custom transparent polygonal button designed for use in applets, as well as a custom tooltip manager to provide proper tooltip functionality for these polygonal buttons. Chapter 6 is about using and customizing tabbed panes, including an example showing how t!
o customize </FONT><FONT FACE="Courier" SIZE=2>JTabbedPane </FONT><FONT FACE="TIMES" SIZE=3>and its UI delegate to build a tabbed pane which uses background images. Chapter 7 discusses scroll panes and how to customize scrolling functionality. Examples show how to use the row and column headers for tracking scroll position, how to change the speed of scrolling through implementation of the </FONT><FONT FACE="Courier" SIZE=2>Scrollable</FONT><FONT FACE="TIMES" SIZE=3> interface, how to implement grab-and-drag scrolling, and how to programmatically invoke scrolling. Chapter 8 takes a brief look at split panes with an example showing how to base programmatic actions on the position of the divider (a gas model simulation). Chapter 9 covers combo boxes with examples showing how to build custom combo box models and cell renderers, add functionlity to the default combo box editor, and serialize a combo box model for later use. Chapter 10 is about list boxes with examples of buildin!
g a custom tab-based cell renderer, adding keyboard search fu!
nc!
tionality for quick item selection, and constructing a custom checkbox cell renderer. Chapter 11 introduces the text components and undo/redo functionality with basic examples and discussions of each (text package coverage continues in chapters 19 and 20). Chapter 12 is devoted to menu bars, menus, menu items, toolbars and actions. Examples include the construction of a basic text editor with floatable toolbar, custom toolbar buttons, and a custom color chooser menu item. Chapter 13 discusses progress bars, sliders and scroll bars, including a custom scroll pane, a slider-based date chooser, a JPEG image quality editor, and an FTP client application. Chapter 14 covers dialogs, option panes, and file and color choosers. Examples demonstrate the basics of custom dialog creation and the use of </FONT><FONT FACE="Courier" SIZE=2>JOptionPane</FONT><FONT FACE="TIMES" SIZE=3>, as well as how to add a custom component to </FONT><FONT FACE="Courier" SIZE=2>JColorChooser</FONT><FONT F!
ACE="TIMES" SIZE=3>, and how to customize </FONT><FONT FACE="Courier" SIZE=2>JFileChooser</FONT><FONT FACE="TIMES" SIZE=3> to allow multiple file selection and the addition of a custom component (a ZIP/JAR archive creation, extraction and preview tool).</P>
</FONT><I><FONT FACE="AGaramond" SIZE=7><P>Chapter 3. Frames, Panels, and Borders</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this chapter:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Frames and Panels overview</LI></P>
<P ALIGN="JUSTIFY"><LI>Borders</LI></P>
<P ALIGN="JUSTIFY"><LI>Creating a custom border</LI></P></UL>

<P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><I><FONT FACE="AGaramond" SIZE=5><P>3.1&#9;Frames and panels overview</P>
</FONT><FONT FACE="AGaramond"><P>3.1.1&#9;JFrame</P>
<P>class javax.swing.JFrame</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The main container for a Swing-based application is </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3>. All objects associated with a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> are managed by its only child, an instance of </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3>. </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> is a simple container for several child panes. When we add components to a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> we don’t directly add them to the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> as we did with an AWT </FONT><FONT FACE="Courier" SIZE=2>Frame</FONT><FONT FACE="AGaramond" SIZE=3>. Instead we have to specify exactly which pane of the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FA!
CE="AGaramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> we want the component to be placed in. In most cases components are added to the </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3> by calling:</P>
<P ALIGN="JUSTIFY"> </P>
</FONT><FONT FACE="Courier" SIZE=2><P>    myJFrame.getContentPane().add(myComponent);</P>
</FONT><FONT FACE="Courier" SIZE=1><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Similarly when setting a layout for a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=2>’s</FONT><FONT FACE="AGaramond" SIZE=3> contents we usually just want to set the layout for the </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3>:</P>
</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier"><CODE><P>    </FONT></CODE><FONT FACE="Courier" SIZE=2>myJFrame.</FONT><FONT FACE="Courier"><CODE>getContentPane().setLayout(new FlowLayout());</P>
</FONT></CODE><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Each </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> contains a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> as protected field </FONT><FONT FACE="Courier" SIZE=2>rootPane</FONT><FONT FACE="AGaramond" SIZE=3>. Figure 3.1 illustrates the hierarchy of a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> and its </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3>. The lines in this diagram extend downward representing the &quot;has a&quot; relationship of each container. We will see </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> in action soon enough.</P>
</FONT><FONT SIZE=2>
<P><IMG SRC="image38.gif" WIDTH=371 HEIGHT=230></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.1 Default JFrame and JRootPane &quot;has a&quot; relationship</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-1.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.2&#9;JRootPane</P>
<P>class javax.swing.JRootPane</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Each </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> contains several components referred to here by variable name: </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> (a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> by default), </FONT><FONT FACE="Courier" SIZE=2>layeredPane</FONT><FONT FACE="AGaramond" SIZE=3> (a </FONT><FONT FACE="Courier" SIZE=2>JLayeredPanel</FONT><FONT FACE="AGaramond" SIZE=3>), </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3> (a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> by default) and </FONT><FONT FACE="Courier" SIZE=2>menuBar</FONT><FONT FACE="AGaramond" SIZE=3> (a </FONT><FONT FACE="Courier" SIZE=2>JMenuBar</FONT><FONT FACE="AGaramond" SIZE=3>).</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=2> and </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=2> are just variable names used by </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=2>. They are not unique Swing classes, as some explanations might lead you to believe. </P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

</FONT><FONT SIZE=2><P><IMG SRC="image39.gif" WIDTH=312 HEIGHT=203></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.2 glassPane </P>
</B><P>&lt;&lt;file figure3-2.gif&gt;&gt;</P>
<B>
</B></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> is initialized as a non-opaque </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> that sits on top of the </FONT><FONT FACE="Courier" SIZE=2>JLayeredPane</FONT><FONT FACE="AGaramond" SIZE=3> as illustrated in Figure 3.3. This component is very useful in situations where we need to intercept mouse events to display a certain cursor over the whole frame or redirect the current application focus. The </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> can be any component but is a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> by default. To change the </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> from a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> to another component a call t!
o the  </FONT><FONT FACE="Courier" SIZE=2>setGlassPane()</FONT><FONT FACE="AGaramond" SIZE=3> method must be made:</P>
</FONT><FONT FACE="Courier" SIZE=2>
<P>    </FONT><FONT FACE="Courier"><CODE>setGlassPane(myComponent);</P>
</FONT></CODE><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Though the </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> does sit on top of the </FONT><FONT FACE="Courier" SIZE=2>layeredPane</FONT><FONT FACE="AGaramond" SIZE=3> it is, by default, not visible. It can be set visible  (i.e. show itself) by calling:</P>
</FONT><FONT FACE="Courier" SIZE=2>
<P>    </FONT><FONT FACE="Courier"><CODE>getGlassPane().setVisible(true);</P>
</FONT></CODE><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3> allows you to display components in front of an existing </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3>‘s contents. In chapter 15 we will find that can be useful as an invisible panel for detecting internal frame focus changes.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image40.gif" WIDTH=369 HEIGHT=226></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.3 Default JFrame contents of the JLayeredPane FRAME_CONTENT_LAYER</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-3.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3>, and optional </FONT><FONT FACE="Courier" SIZE=2>menuBar</FONT><FONT FACE="AGaramond" SIZE=3>, are contained within </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=2>’s </FONT><FONT FACE="Courier" SIZE=2>layeredPane</FONT><FONT FACE="AGaramond" SIZE=3> at the </FONT><FONT FACE="Courier" SIZE=2>FRAME_CONTENT_LAYER</FONT><FONT FACE="AGaramond" SIZE=3> (this is layer -30000; see chapter 15). The </FONT><FONT FACE="Courier" SIZE=2>menuBar</FONT><FONT FACE="AGaramond" SIZE=3> does not exist by default but can be set by calling the </FONT><FONT FACE="Courier" SIZE=2>setJMenuBar()</FONT><FONT FACE="AGaramond" SIZE=3> method:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier"><CODE><P>    JMenuBar menu = new JMenuBar();</P>
<P>    setJMenuBar(menu);</P>
</FONT></CODE><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">When the </FONT><FONT FACE="Courier" SIZE=2>JMenuBar</FONT><FONT FACE="AGaramond" SIZE=3> is set it is automatically positioned at the top of the </FONT><FONT FACE="Courier" SIZE=2>FRAME_CONTENT_LAYER</FONT><FONT FACE="AGaramond" SIZE=3>. The rest of the layer is occupied by the </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3> as illustrated in Figure 3.3.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3> is, by default, an opaque </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>. It can be set to any other component by calling:</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier"><CODE><P>    setContentPane(myComponent);</P>
</FONT></CODE><FONT FACE="Courier" SIZE=2><P> </P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: The default layout for the </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=2> is </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=2>. The default layout for any other </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=2> is </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=2>. Be careful not to set the layout of a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=2> directly. This will generate an exception. Setting the layout of the </FONT><FONT FACE="Courier" SIZE=2>rootPane</FONT><FONT FACE="AGaramond" SIZE=2> is also something that should be avoided because every </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=2> uses its own custom layout manager called </FONT><FONT FACE="Courier" SIZE=2>RootLayout</FONT><FONT FACE="AGaramond" SIZE=2>!
. We will discuss layout managers more in chapter 4.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond"><P>3.1.3&#9;RootLayout</P>
<P>class javax.swing.JRootPane.RootLayout</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">RootLayout</FONT><FONT FACE="AGaramond" SIZE=3> is a layout manager built specifically to manage </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=2>’s</FONT><FONT FACE="AGaramond" SIZE=3> </FONT><FONT FACE="Courier" SIZE=2>layeredPane</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>glassPane</FONT><FONT FACE="AGaramond" SIZE=3>, and </FONT><FONT FACE="Courier" SIZE=2>menuBar</FONT><FONT FACE="AGaramond" SIZE=3>. If it is replaced by another layout manager that manager must be able to handle the positioning of these components. </FONT><FONT FACE="Courier" SIZE=2>RootLayout</FONT><FONT FACE="AGaramond" SIZE=3> is an inner class defined within </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> and as such, is not intended to have any use outside of this class. Thus it is not discussed in this text. </P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.4&#9;The RootPaneContainer interface</P>
<P>abstract interface javax.swing.RootPaneContainer</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The purpose of the </FONT><FONT FACE="Courier" SIZE=2>RootPaneContainer</FONT><FONT FACE="AGaramond" SIZE=3> interface is to organize a group of methods that should be used to access a container’s </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> and its different panes (see API docs). Because </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3>‘s main container is a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3>, it implements this interface (as does </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>JDialog</FONT><FONT FACE="AGaramond" SIZE=3>). If we were to build a new component which uses a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> as its main container we would most likely implement the </FONT><FONT FACE="Courier"!
 SIZE=2>RootPaneContainer</FONT><FONT FACE="AGaramond" SIZE=3> interface. (Note that this interface exists for convenience, consistency, and organizational purposes. We are encouraged to, but certainly not required to, use it in our own container implementations.)</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.5&#9;The WindowConstants interface</P>
<P>abstract interface javax.swing.WindowConstants</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">We can specify how a </FONT><FONT FACE="Courier" SIZE=2>JFrame, JInternalFrame, or JDialog</FONT><FONT FACE="AGaramond" SIZE=3> acts in response to the user closing it through use of the </FONT><FONT FACE="Courier" SIZE=2>setDefaultCloseOperation()</FONT><FONT FACE="AGaramond" SIZE=3> method. There are three possible settings, as defined by  </FONT><FONT FACE="Courier" SIZE=2>WindowConstants</FONT><FONT FACE="AGaramond" SIZE=3> interface fields:</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier"><CODE><P>    WindowConstants.DISPOSE_ON_CLOSE</P>
<P>    WindowConstants.DO_NOTHING_ON_CLOSE</P>
<P>    WindowConstants.HIDE_ON_CLOSE<BR>
</P>
</FONT></CODE><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The names are self-explanatory. </FONT><FONT FACE="Courier" SIZE=2>DISPOSE_ON_CLOSE</FONT><FONT FACE="AGaramond" SIZE=3> disposes of the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> and its contents,  </FONT><FONT FACE="Courier" SIZE=2>DO_NOTHING_ON_CLOSE</FONT><FONT FACE="AGaramond" SIZE=3> renders the close button useless, and </FONT><FONT FACE="Courier" SIZE=2>HIDE_ON_CLOSE</FONT><FONT FACE="AGaramond" SIZE=3> just removes the container from view. (</FONT><FONT FACE="Courier" SIZE=2>HIDE_ON_CLOSE</FONT><FONT FACE="AGaramond" SIZE=3> may be useful if we may need the conatiner, or something it contains, at a later time but do not want it to be visible until then. </FONT><FONT FACE="Courier" SIZE=2>DO_NOTHING_ON_CLOSE</FONT><FONT FACE="AGaramond" SIZE=3> is very useful as you will see below.)</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.6&#9;The WindowListener interface</P>
<P>abstract interface java.awt.event.WindowListener</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Classes that want explicit notification of window events (such as window closing, iconification, etc.) need to implement this interface. Normally the </FONT><FONT FACE="Courier" SIZE=2>WindowAdapter</FONT><FONT FACE="AGaramond" SIZE=3> class is extended instead. &quot;When the window's status changes by virtue of being opened, closed, activated or deactivated, iconified or deiconified, the relevant method in the listener object is invoked, and the </FONT><FONT FACE="Courier"><CODE>WindowEvent</FONT></CODE><FONT FACE="AGaramond" SIZE=3> is passed to it.&quot;<B><SUP>API</P>
</B></SUP><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The methods any implementation of this interface must define are:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier"><CODE><P>    void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowActivated</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2>  </P>
</FONT><FONT FACE="Courier"><CODE><P>    void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowClosed</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2>  </P>
</FONT><FONT FACE="Courier"><CODE><P>    void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowClosing</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2> <BR>
    </FONT><FONT FACE="Courier"><CODE>void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowDeactivated</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2> <BR>
    </FONT><FONT FACE="Courier"><CODE>void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowDeiconified</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2> <BR>
    </FONT><FONT FACE="Courier"><CODE>void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowIconified</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2> <BR>
    </FONT><FONT FACE="Courier"><CODE>void</FONT></CODE><FONT FACE="Courier" SIZE=2> windowOpened</FONT><FONT FACE="Courier"><CODE>(</FONT></CODE><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="Courier"><CODE> e)</FONT></CODE><FONT FACE="Courier" SIZE=2> </P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.7&#9;WindowEvent</P>
<P>class java.awt.event.WindowEvent</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The type of event used to indicate that a window has changed state. This event is passed to every </FONT><FONT FACE="Courier"><CODE>WindowListener</FONT></CODE><FONT FACE="AGaramond" SIZE=3> or </FONT><FONT FACE="Courier"><CODE>WindowAdapter</FONT></CODE><FONT FACE="AGaramond" SIZE=3> object which is registered on the source window to receive such events. Method </FONT><FONT FACE="Courier" SIZE=2>getWindow()</FONT><FONT FACE="AGaramond" SIZE=3> returns the window that generated the event. Method </FONT><FONT FACE="Courier" SIZE=2>paramString()</FONT><FONT FACE="AGaramond" SIZE=3> retreives a </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3> describing the event type and its source, among other things.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">There are six types of </FONT><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="AGaramond" SIZE=3>s that can be generated; each is represented by the following static </FONT><FONT FACE="Courier" SIZE=2>WindowEvent</FONT><FONT FACE="AGaramond" SIZE=3> fields: </FONT><FONT FACE="Courier" SIZE=2>WINDOW_ACTIVATED</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_CLOSED</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_CLOSING</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_DEACTIVATED</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_DEICONIFIED</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_ICONIFIED</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>WINDOW_OPENED</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.8&#9;WindowAdapter</P>
<P>abstract class java.awt.event.WindowAdapter</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This is an abstract implementation of the </FONT><FONT FACE="Courier" SIZE=2>WindowListener</FONT><FONT FACE="AGaramond" SIZE=3> interface. It is normally more convenient to extend this class than to implement </FONT><FONT FACE="Courier" SIZE=2>WindowListener</FONT><FONT FACE="AGaramond" SIZE=3> directly.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Notice that none of the </FONT><FONT FACE="Courier" SIZE=2>WindowConstants</FONT><FONT FACE="AGaramond" SIZE=3> close operations actually terminate program execution. This can be accomplished by extending </FONT><FONT FACE="Courier" SIZE=2>WindowAdapter</FONT><FONT FACE="AGaramond" SIZE=3> and overriding the methods we are interested in handling (in this case just the </FONT><FONT FACE="Courier" SIZE=2>windowClosed()</FONT><FONT FACE="AGaramond" SIZE=3> method). We can create an instance of this extended class, cast it to a </FONT><FONT FACE="Courier" SIZE=2>WindowListener</FONT><FONT FACE="AGaramond" SIZE=3> object, and register this listener with the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> using the </FONT><FONT FACE="Courier" SIZE=2>addWindowListener()</FONT><FONT FACE="AGaramond" SIZE=3> method. This can easily be added to any application as follows:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" size=3><pre>WindowListener l = new WindowAdapter() {
    public void windowClosing(WindowEvent e) {
	System.exit(0);
    }
};
myJFrame.addWindowListener(l);
</pre>
<P ALIGN="JUSTIFY"></P>
</FONT></CODE><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The best method of all is to combine </FONT><FONT FACE="Courier" SIZE=2>WindowAdapter</FONT><FONT FACE="AGaramond" SIZE=3> and values from the </FONT><FONT FACE="Courier" SIZE=2>WindowConstants</FONT><FONT FACE="AGaramond" SIZE=3> interface to present the user with an exit confirmation dialog as follows:</P>
</FONT><FONT FACE="Courier"><CODE><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" size=3><pre>myJFrame.setDefaultCloseOperation (WindowConstants.DO_NOTHING_ON_CLOSE);
WindowListener l = new WindowAdapter() {
   public void windowClosing(WindowEvent e) {
      int confirm = JOptionPane.showOptionDialog(myJFrame,"Really Exit?", "Exit Confirmation",
		                                   JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,
          					   null, null, null);
      if (confirm == 0) {
        myJFrame.dispose();
        System.exit(0);
      }
   };
};
    
myJFrame.addWindowListener(l);
</pre>
</FONT></CODE><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: This can also be done for </FONT><FONT FACE="Courier" SIZE=2>JDialog</FONT><FONT FACE="AGaramond" SIZE=2>. However, to do the same thing for a </FONT><FONT FACE="Courier" SIZE=2>JInternalFrame</FONT><FONT FACE="AGaramond" SIZE=2> we must build a custom </FONT><FONT FACE="Courier" SIZE=2>JInternalFrame</FONT><FONT FACE="AGaramond" SIZE=2> subclass and implement the </FONT><FONT FACE="Courier" SIZE=2>PropertyChangeListener</FONT><FONT FACE="AGaramond" SIZE=2> interface. See chapter 16 for details.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Inserting this code into your application will always display the dialog shown in figure 3.4 when the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> close button is pressed. Note that this functionality is not used until later chapters in which we work with applications where closing may cause a loss of unsaved material.</P>
</FONT><FONT FACE="Courier"><CODE><P ALIGN="JUSTIFY"></P>
<P><IMG SRC="image76.gif" WIDTH=270 HEIGHT=117></P>
</FONT></CODE><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.4 Application exit confirmation dialog         </P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-4.gif&gt;&gt;</P>
</FONT><FONT FACE="Courier"><CODE><P>&nbsp;</P><DIR>

</FONT></CODE><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Reference: Dialogs and </FONT><FONT FACE="Courier" SIZE=2>JOptionPane</FONT><FONT FACE="AGaramond" SIZE=2> are discussed in Chapter 14.</P>
</FONT><FONT FACE="Courier"><CODE><P>&nbsp;</P></DIR>

</FONT></CODE><I><FONT FACE="AGaramond"><P>3.1.9&#9;Custom frame icons</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Often we want to use a custom icon to represent our application frame. Because </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> is a subclass of </FONT><FONT FACE="Courier" SIZE=2>awt.Frame</FONT><FONT FACE="AGaramond" SIZE=3> we can set its icon using the </FONT><FONT FACE="Courier" SIZE=2>setIconImage()</FONT><FONT FACE="AGaramond" SIZE=3> method. This method is intended to set the minimized icon to use for this frame. On some platforms this icon is also used for a title bar image (e.g. Windows).</P>
<P ALIGN="JUSTIFY"> </P><DIR>

</FONT><B><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">UI Guideline: Brand Identity. </B>Use the frame icon to establish and reinforce your brand identity. Pick a simple image which can be effective in the small space and re-used throughout the application and any accompanying material. Fig 3-5 shows the Sun Coffee Cup which was itilise as a brand mark for Java.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

</FONT><FONT FACE="Courier"><CODE><P>    ImageIcon image = new ImageIcon("spiral.gif");</P>
<P>    myFrame.setIconImage(image.getImage());</P>
</FONT></CODE><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">There is no limit to the size of the icon that can be used. A </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> will resize any image passed to </FONT><FONT FACE="Courier" SIZE=2>setIconImage()</FONT><FONT FACE="AGaramond" SIZE=3> to fit the bound it needs. Figure 3.5 shows the top of a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> with a custom icon. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image77.gif" WIDTH=164 HEIGHT=44></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.5 JFrame custom Icon         </P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-5.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.10&#9;Centering a frame on the screen </P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">By default a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> displays itself in the upper left-hand corner of the screen. Often it is desirable to place it in the center of the screen. Using the </FONT><FONT FACE="Courier" SIZE=2>getToolkit()</FONT><FONT FACE="AGaramond" SIZE=3> method of the </FONT><FONT FACE="Courier" SIZE=2>Window</FONT><FONT FACE="AGaramond" SIZE=3> class (of which </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> is a second level subclass), we can communicate with the operating system and query the size of the screen. (The </FONT><FONT FACE="Courier" SIZE=2>Toolkit</FONT><FONT FACE="AGaramond" SIZE=3> methods make up the bridge between Java components and their native, operating-system-specific, peer components.)</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>getScreenSize()</FONT><FONT FACE="AGaramond" SIZE=3> method gives us the information we need:</P>
</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier"><CODE><P>    Dimension dim = getToolkit().getScreenSize();</P>
</FONT></CODE><FONT SIZE=2>
<P><IMG SRC="image41.gif" WIDTH=167 HEIGHT=151></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.6 Screen coordinates</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-6.gif&gt;&gt;</P>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">When setting the location of the </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3>, the upper left hand corner of the frame is the relevant coordinate. So to center a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> on the screen we need to subtract half its width and half its height from the center-of-screen coordinate:</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier"><CODE><P>    myJFrame.setLocation(dim.width/2 - myJFrame.getWidth()/2, </P>
<P>      dim.height/2 - myJFrame.getHeight()/2);</P>
<P>&nbsp;</P>
</FONT></CODE><I><FONT FACE="AGaramond"><P>3.1.11&#9;JApplet</P>
<P>class javax.swing.JApplet</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">JApplet</FONT><FONT FACE="AGaramond" SIZE=3> is the Swing equivalent of the AWT </FONT><FONT FACE="Courier" SIZE=2>Applet</FONT><FONT FACE="AGaramond" SIZE=3> class. Like </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>JApplet</FONT><FONT FACE="AGaramond" SIZE=3>’s main child component is a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> and its structure is the same. </FONT><FONT FACE="Courier" SIZE=2>JApplet</FONT><FONT FACE="AGaramond" SIZE=3> acts just like </FONT><FONT FACE="Courier" SIZE=2>Applet</FONT><FONT FACE="AGaramond" SIZE=3> and we will not go into detail about how applets work. </P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Reference: We suggest that readers unfamiliar with applets refer to the Java tutorial to learn more:  http://java.sun.com/docs/books/tutorial/</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Several examples in later chapters are constructed as Swing applets and we will see </FONT><FONT FACE="Courier" SIZE=2>JApplet</FONT><FONT FACE="AGaramond" SIZE=3> in action soon enough. Appendix A contains information about deploying Swing-based applets for use in a browser, Java 2 applet security issues, and working with JAR archives.</P>
</FONT><I><FONT FACE="AGaramond"><P>3.1.12 JWindow</P>
<P>class javax.swing.JWindow</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">JWindow</FONT><FONT FACE="AGaramond" SIZE=3> is very similar to </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> except that it has no title bar, and is not resizable, minimizable, maximizable, or closable. Thus it cannot be dragged without writing custom code to do so (e.g. </FONT><FONT FACE="Courier" SIZE=2>JToolBar</FONT><FONT FACE="AGaramond" SIZE=3>’s UI delegate provides this functionality for docking and undocking). We normally use </FONT><FONT FACE="Courier" SIZE=2>JWindow</FONT><FONT FACE="AGaramond" SIZE=3> to display a temporary message or splash screen logo. Since </FONT><FONT FACE="Courier" SIZE=2>JWindow</FONT><FONT FACE="AGaramond" SIZE=3> is a </FONT><FONT FACE="Courier" SIZE=2>RootPaneContainer</FONT><FONT FACE="AGaramond" SIZE=3>, we can treat it just like </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> or </FONT><FONT FACE="Courier" SIZE=2!
>JApplet</FONT><FONT FACE="AGaramond" SIZE=3> when manipulating its contents. </P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: We will use </FONT><FONT FACE="Courier" SIZE=2>JWindow</FONT><FONT FACE="AGaramond" SIZE=2> to display a splash screen in several complex examples later to provide simple feedback to the user when potentially long startup times are encountered.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond"><P>3.1.12&#9;JPanel</P>
<P>class javax.swing.JPanel</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This is the simple container component commonly used to organize a group or groups of child components inside another container. </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> is an integral part of </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3>, as we discussed above, and is used in each example throughout this book. Each </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>’s child components are managed by a layout manager. A layout manager controls the size and location of each child in a container. </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>’s default layout manager is </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3> (we will discuss this more in chapter 4). The only exception to this is </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGa!
ramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3>, which is managed by a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3> by default.</P>
</FONT><I><FONT FACE="AGaramond" SIZE=5><P>3.2&#9;Borders</P>
</FONT><FONT FACE="AGaramond"><P>package javax.swing.border</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>border</FONT><FONT FACE="AGaramond" SIZE=3> package provides us with the following border classes which can be applied to any Swing component:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>BevelBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A 3D border with a raised or lowered appearance.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>CompoundBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A combination of two borders: an inside border and an outside border.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>EmptyBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A transparent border used to define empty space (often referred to as <I>white space</I>) around a component.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>EtchedBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A border with an etched lineappearance.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>LineBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A flat border with a specified thickness and color.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>MatteBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A border consisting of either a flat color or tiled image.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>SoftBevelBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A 3D border with a raised or lowered appearance, and rounded edges.</P></DIR>
</DIR>

</FONT><B><FONT FACE="Courier" SIZE=2><P>  </B>TitledBorder</P><DIR>
<DIR>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">A border allowing a </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3> title in a specific location and position. We can set the title font, color, justification, and position of the title text using </FONT><FONT FACE="Courier" SIZE=2>TitleBorder </FONT><FONT FACE="AGaramond" SIZE=3>methods and constants where necessary (see API docs).</P>
<P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">To set the border of  a Swing component we simply call </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>setBorder()</FONT><FONT FACE="AGaramond" SIZE=3> method. There is also a convenience class called </FONT><FONT FACE="Courier" SIZE=2>BorderFactory</FONT><FONT FACE="AGaramond" SIZE=3>, contained in the </FONT><FONT FACE="Courier" SIZE=2>javax.swing</FONT><FONT FACE="AGaramond" SIZE=3> package (not the </FONT><FONT FACE="Courier" SIZE=2>javax.swing.border</FONT><FONT FACE="AGaramond" SIZE=3> package as you might think), which contains a group of static methods used for constructing borders quickly. For example, to create an </FONT><FONT FACE="Courier" SIZE=2>EtchedBorder</FONT><FONT FACE="AGaramond" SIZE=3> we can use </FONT><FONT FACE="Courier" SIZE=2>BorderFactory</FONT><FONT FACE="AGaramond" SIZE=3> as follows:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P>   myComponent.setBorder(BorderFactory.createEtchedBorder());</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The border classes do not provide methods set their dimensions, colors, etc. Insetad of modifying an existing border we are normally expected to create a new instance to replace the old one. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image90.gif" WIDTH=450 HEIGHT=450></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.7 Simple Borders demonstration</P>
</B></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&lt;&lt;file figure3-7.gif&gt;&gt;</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The following code creates a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> containing twelve </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>s using borders of all types. Figure 3.7 illustrates:</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: BorderTest.java</P>
<P ALIGN="JUSTIFY">see \Chapter3\1</P>
</B><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" size=3><pre>
import java.awt.*;
import javax.swing.*;
import javax.swing.border.*;
class BorderTest extends JFrame
{
  public BorderTest()
  {
    setTitle("Border Test");
    setSize(450, 450);

    JPanel content = (JPanel) getContentPane(); 
    content.setLayout(new GridLayout(6,2));

    JPanel p = new JPanel();
    p.setBorder(new BevelBorder (BevelBorder.RAISED));
    p.add(new JLabel("RAISED BevelBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new BevelBorder (BevelBorder.LOWERED));
    p.add(new JLabel("LOWERED BevelBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new LineBorder (Color.black, 5));
    p.add(new JLabel("Black LineBorder, thickness = 5"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new EmptyBorder (10,10,10,10));
    p.add(new JLabel("EmptyBorder with thickness of 10"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new EtchedBorder (EtchedBorder.RAISED));
    p.add(new JLabel("RAISED EtchedBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new EtchedBorder (EtchedBorder.LOWERED));
    p.add(new JLabel("LOWERED EtchedBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new SoftBevelBorder (SoftBevelBorder.RAISED));
    p.add(new JLabel("RAISED SoftBevelBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new SoftBevelBorder (SoftBevelBorder.LOWERED));
    p.add(new JLabel("LOWERED SoftBevelBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new MatteBorder (new ImageIcon("spiral.gif")));
    p.add(new JLabel("MatteBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new TitledBorder (
      new MatteBorder (new ImageIcon("spiral.gif")),
      "Title String"));
    p.add(new JLabel("TitledBorder using MatteBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new TitledBorder (
      new LineBorder (Color.black, 5),
      "Title String"));
    p.add(new JLabel("TitledBorder using LineBorder"));
    content.add(p);

    p = new JPanel();
    p.setBorder(new TitledBorder (
      new EmptyBorder (10,10,10,10),
      "Title String"));
    p.add(new JLabel("TitledBorder using EmptyBorder"));
    content.add(p);

    setVisible(true);
  }

  public static void main(String args[])
  {
    new BorderTest();
  }
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">UI Guideline: </P>
<P ALIGN="JUSTIFY">Borders for Visual Layering. </B>Use borders to create a visual association between components on a view. Bevelled borders are graphically very strong and can be used to strongly associate items. Windows Look &amp; Feel does this. For example buttons use a RAISED BevelBorder and data fields use a LOWERED BevelBorder. If you want to visually associate components or draw attention to a component then you can create a <I>visual layer</I> by careful use of BevelBorder. If you want to draw attention to a particular button or group of buttons, you might consider thickening the RAISED bevel using </FONT><FONT FACE="Courier" SIZE=2>BorderInsets</FONT><FONT FACE="AGaramond" SIZE=2> discussed in 3.2.2</P>
<B><P ALIGN="JUSTIFY">Borders for Visual Grouping.</B> Use borders to create Group Boxes. EtchedBorder and LineBorder are particularly effective for this, as they are graphically weaker then BevelBorder. EmptyBorder is also very useful for grouping. It uses the power of negative (white) space to visually associate the contained components and draw the viewer eye to the group. </P>
<P ALIGN="JUSTIFY">You may wish to create a visual grouping of attributes or simply signify the bounds of a set of choices. Grouping related Radio Buttons and Checkboxes is particularly useful.</P>
<B><P ALIGN="JUSTIFY">Achieving Visual Integration and Balance using Negative Space. </B>Use a compound border including an EmptyBorder to increase the Negative (white) Space around a Component or Panel. Visually, a Border sets what is known as a Ground (or area) for a Figure. The Figure is what is contained within the Border. It is important to keep Figure and Ground in balance. This is done by providing adequate white space around the Figure. The stronger the border, the more white space will be required e.g. a BevelBorder will require more white space than an EtchedBorder. Ref. Mullet 95 (see Appendix B).</P>
<B><P ALIGN="JUSTIFY">Border for Visual Grouping with Layering. </B>Doubly compounded borders can be used to group information and communicate hierarchy using Visual Layering. Consider the following implementation (fig 3-8). Here we are indicating a common belonging for the attributes within the border. They are both attributes of Customer. Because we have indicated the label Customer (top LHS) in the border title, we do not need to repeat the label for each field. We are further communicating the type of the Customer with the VIP label (bottom RHS).</P>
<P ALIGN="JUSTIFY">Visual Layering of the hierachy involved is achieved by position and font.</P>
<P ALIGN="JUSTIFY">(i) Position: In western cultures, the eye is trained to scan from top left to bottom right. Thus something located top left has a visual higher rank than something located bottom right.</P>
<P ALIGN="JUSTIFY">(ii) Font: By bolding the Customer, we are clearly communicating it as the highest ranking detail.<BR>
What we are displaying is a Customer of type VIP. Not a VIP of type Customer. The positioning and re-inforcing with heavier font, clearly communicate this message</P>
</FONT><FONT SIZE=2></DIR>

<P><IMG SRC="image227.gif" WIDTH=323 HEIGHT=152></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.8 Visual Grouping with Layering</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure3-8.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>3.2.2&#9;Inside Borders</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">It is important to understand that borders are not components. In fact </FONT><FONT FACE="Courier" SIZE=2>AbstractBorder</FONT><FONT FACE="AGaramond" SIZE=3>, the abstract class all border classes are derived from, directly extends </FONT><FONT FACE="Courier" SIZE=2>Object</FONT><FONT FACE="AGaramond" SIZE=3>. Thus we cannot attach action and mouse listeners, set tool tips, etc.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: This has certain side effects, one of which is that borders are much less efficient in painting themselves. There is no optimization support like there is in </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=2>. We <I>can</I> do intersting things like use a very thick </FONT><FONT FACE="Courier" SIZE=2>MatteBorder</FONT><FONT FACE="AGaramond" SIZE=2> to tile a panel with an image, but this is an inefficient (and also unreliable) solution. In general don’t use really large borders for anything. If you need an extremely large border consider simulating one using </FONT><FONT FACE="Courier" SIZE=2>JLabel</FONT><FONT FACE="AGaramond" SIZE=2>s and a container managed by </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=2>.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">One major benefit of </FONT><FONT FACE="Courier" SIZE=2>Border</FONT><FONT FACE="AGaramond" SIZE=3>s not being components is that we can use a single </FONT><FONT FACE="Courier" SIZE=2>Border</FONT><FONT FACE="AGaramond" SIZE=3> instance with an arbitrary number of components. In large scale apps this can reduce a significant amount of overhead.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">When a Swing component is assigned a border its </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> are defined by that border’s width and height settings. When layout managers lay out </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=3>s, as we will see in the next chapter, they take into account their </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> and normally use </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>getInsets()</FONT><FONT FACE="AGaramond" SIZE=3> method to obtain this information. Inside the </FONT><FONT FACE="Courier" SIZE=2>getInsets()</FONT><FONT FACE="AGaramond" SIZE=3> method, the current border is asked to provide its </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> using the </FONT><FONT FACE="Courier" SIZE=2>getBorderInsets() </FONT><FONT FACE="A!
Garamond" SIZE=3>method.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> class consists of four publicly accessible </FONT><FONT FACE="Courier" SIZE=2>int</FONT><FONT FACE="AGaramond" SIZE=3> values: </FONT><FONT FACE="Courier" SIZE=2>bottom</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>left</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>right</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>top</FONT><FONT FACE="AGaramond" SIZE=3>. </FONT><FONT FACE="Courier" SIZE=2>TitleBorder</FONT><FONT FACE="AGaramond" SIZE=3> must compute its </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> based on its current font and text position which will not effect every side and requires handling for many different cases--without a doubt this is the most complex border provided by Swing. In the case of </FONT><FONT FACE="Courier" SIZE=2>CompoundBorder</FONT><FO!
NT FACE="AGaramond" SIZE=3>, both its outer and inner </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> are retrieved through calls to </FONT><FONT FACE="Courier" SIZE=2>getBorderInsets()</FONT><FONT FACE="AGaramond" SIZE=3> and then summed. A </FONT><FONT FACE="Courier" SIZE=2>MatteBorder</FONT><FONT FACE="AGaramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> are determined by the width and height of its image. </FONT><FONT FACE="Courier" SIZE=2>BevelBorder</FONT><FONT FACE="AGaramond" SIZE=3> and  </FONT><FONT FACE="Courier" SIZE=2>EtchedBorder</FONT><FONT FACE="AGaramond" SIZE=3>, have </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> values: 2, 2, 2, 2. </FONT><FONT FACE="Courier" SIZE=2>SoftBevelBorder</FONT><FONT FACE="AGaramond" SIZE=3> has Insets values: 3, 3, 3, 3. </FONT><FONT FACE="Courier" SIZE=2>EmptyBorder</FONT><FONT FACE="AGaramond" SIZE=3>’s </FONT><FONT F!
ACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE!
=3!
> are simply the values that were passed in to the constructor. Each of </FONT><FONT FACE="Courier" SIZE=2>LineBorder</FONT><FONT FACE="AGaramond" SIZE=3>’s </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> values equals the thickness that was specified in the constructor (or 1 as the default).</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Border</FONT><FONT FACE="AGaramond" SIZE=3>s get painted last in the </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=3> rendering pipeline to ensure that they always appear on top of their associated component. </FONT><FONT FACE="Courier" SIZE=2>AbstractBorder</FONT><FONT FACE="AGaramond" SIZE=3> defines methods to get a </FONT><FONT FACE="Courier" SIZE=2>Rectangle</FONT><FONT FACE="AGaramond" SIZE=3> representing the interior region of the component a border is attached to: </FONT><FONT FACE="Courier" SIZE=2>getInteriorRectangle()</FONT><FONT FACE="AGaramond" SIZE=3>. Any </FONT><FONT FACE="Courier" SIZE=2>JComponent</FONT><FONT FACE="AGaramond" SIZE=3> subclass implementing its own painting methods may be interested in this area. Combined with the </FONT><FONT FACE="Courier" SIZE=2>Graphics</FONT><FONT FACE="AGaramond" SIZE=3> clipping area, components may use this information to minimize!
 their rendering work (refer back to chapter 2).</P>
</FONT><I><FONT FACE="AGaramond" SIZE=5><P>3.3 Creating a custom border</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">To create a custom border we can implement the </FONT><FONT FACE="Courier" SIZE=2>javax.swing.Border</FONT><FONT FACE="AGaramond" SIZE=3> interface and define the following three methods:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">void paintBorder(Component c, Graphics g)</FONT><FONT FACE="AGaramond" SIZE=3>: perform the border rendering--only paint within the </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> region.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Insets getBorderInsets(Component c)</FONT><FONT FACE="AGaramond" SIZE=3>: return an </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> instance representing the top, bottom, left, and right thicknesses.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">boolean isBorderOpaque()</FONT><FONT FACE="AGaramond" SIZE=3>: return whether or not the border is opaque or transparent.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The following class is a simple implementation of a custom rounded-rectangle border which we call </FONT><FONT FACE="Courier" SIZE=2>OvalBorder</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><IMG SRC="image228.gif" WIDTH=300 HEIGHT=150></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 3.9 A custom rounded-corner Border implementation.</P>
</B></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&lt;&lt;file figure3-9.gif&gt;&gt;</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: OvalBorder.java</P>
<P ALIGN="JUSTIFY">see \Chapter3\2</P>
</B><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" size=3><pre>
import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

public class OvalBorder implements Border
{
  protected int m_w=6;
  protected int m_h=6;
  protected Color m_topColor = Color.white;
  protected Color m_bottomColor = Color.gray;

  public OvalBorder() {
    m_w=6;
    m_h=6;
  }

  public OvalBorder(int w, int h) {
    m_w=w;
    m_h=h;
  }

  public OvalBorder(int w, int h, Color topColor, 
   Color bottomColor) {
    m_w=w;
    m_h=h;
    m_topColor = topColor;
    m_bottomColor = bottomColor;
  }

  public Insets getBorderInsets(Component c) {
    return new Insets(m_h, m_w, m_h, m_w);
  }

  public boolean isBorderOpaque() { return true; }

  public void paintBorder(Component c, Graphics g, 
   int x, int y, int w, int h) {
    w--;
    h--;
    g.setColor(m_topColor);
    g.drawLine(x, y+h-m_h, x, y+m_h);
    g.drawArc(x, y, 2*m_w, 2*m_h, 180, -90);
    g.drawLine(x+m_w, y, x+w-m_w, y);
    g.drawArc(x+w-2*m_w, y, 2*m_w, 2*m_h, 90, -90);

    g.setColor(m_bottomColor);
    g.drawLine(x+w, y+m_h, x+w, y+h-m_h);
    g.drawArc(x+w-2*m_w, y+h-2*m_h, 2*m_w, 2*m_h, 0, -90);
    g.drawLine(x+m_w, y+h, x+w-m_w, y+h);
    g.drawArc(x, y+h-2*m_h, 2*m_w, 2*m_h, -90, -90);
  }

  public static void main(String[] args) {
    JFrame frame = new JFrame("Custom Border: OvalBorder");
    JLabel label = new JLabel("OvalBorder");
    ((JPanel) frame.getContentPane()).setBorder(new CompoundBorder(
      new EmptyBorder(10,10,10,10), new OvalBorder(10,10)));
    frame.getContentPane().add(label);
    frame.setBounds(0,0,300,150);
    frame.setVisible(true);
  }
}
</pre>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Understanding the Code</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">This border consists of a raised shadowed rectangle with rounded corners. Instance variables:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int m_w</FONT><FONT FACE="AGaramond" SIZE=3>: left and right inset value.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int m_h</FONT><FONT FACE="AGaramond" SIZE=3>: top and bottom inset value.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Color m_topColor</FONT><FONT FACE="AGaramond" SIZE=3>: non-shadow color.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Color m_bottomColor</FONT><FONT FACE="AGaramond" SIZE=3>: shadow color.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Three constructors are provided to allow optional specification of the width and height of left/right and top/bottom inset values respectively. We can also specify the shadow color (bottom color) and non-shadow color (top color). The inset values default to 6, the top color defaults to white, and the shadow color defaults to gray.</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>isBorderOpaque()</FONT><FONT FACE="AGaramond" SIZE=3> method always returns true to signify that this border’s region will always be completely filled. </FONT><FONT FACE="Courier" SIZE=2>getBorderInsests()</FONT><FONT FACE="AGaramond" SIZE=3> simpley returns an Insets instance made up of the left/right and top/bottom inset values specified in a constructor.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>paintBorder()</FONT><FONT FACE="AGaramond" SIZE=3> method is responsible of rendering our border and simply paints a sequence of four lines and arcs in the approproate colors. By simply reversing the use of </FONT><FONT FACE="Courier" SIZE=2>bottomColor</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>topColor</FONT><FONT FACE="AGaramond" SIZE=3> we can switch from a raised look to a lowered look (a more flexible implementation might include a raised/lowered flag, and an additional constructor parameter used to specify this).</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>main()</FONT><FONT FACE="AGaramond" SIZE=3> method creates a </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> with content pane surrounded by a </FONT><FONT FACE="Courier" SIZE=2>CompoundBorder</FONT><FONT FACE="AGaramond" SIZE=3>. The outer border is an </FONT><FONT FACE="Courier" SIZE=2>EmptyBorder</FONT><FONT FACE="AGaramond" SIZE=3> to provide white space, and the inner border is an instance of our </FONT><FONT FACE="Courier" SIZE=2>OvalBorder</FONT><FONT FACE="AGaramond" SIZE=3> class with inset values of 10.</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Running the Code</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Figure 3.9 illustrates. Try running this class and resize the parent frame. Note that with a very small width or height the border does not render itself pleasantly. A more professional implementation would take this into account in the </FONT><FONT FACE="Courier" SIZE=2>paintBorder()</FONT><FONT FACE="AGaramond" SIZE=3> routine.</P></FONT></BODY>
</HTML>
