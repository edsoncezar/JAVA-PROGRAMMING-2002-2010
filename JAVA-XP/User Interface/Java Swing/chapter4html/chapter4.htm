<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Swing Chapter 4</TITLE>
<META NAME="subject" CONTENT="Layout Managers">
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Templates\A_author.dot">
</HEAD>
<BODY LINK="#0000ff">

<I><FONT FACE="AGaramond" SIZE=7><P>Chapter 4. Layout Managers</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this chapter:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Layouts overview</LI></P>
<P ALIGN="JUSTIFY"><LI>Comparing common layout managers</LI></P>
<P ALIGN="JUSTIFY"><LI>Using GridBagLayout, by James Tan</LI></P>
<P ALIGN="JUSTIFY"><LI>Choosing the right layout</LI></P>
<P ALIGN="JUSTIFY"><LI>Custom layout manager: part I - Label/field pairs</LI></P>
<P ALIGN="JUSTIFY"><LI>Custom layout manager: part II - Common interfaces</LI></P>
<P ALIGN="JUSTIFY"><LI>Dynamic layout in a JavaBeans container</LI></P></UL>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.1&#9;Layouts overview</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this chapter we present several examples showing how to use various layouts to satisfy specific goals, and how to create two custom layout managers that simplify the construction of many common interfaces. We also show how to construct a basic container for JavaBeans which must be able to manage a dynamic number of components. But before we present these examples it is helpful to understand the big picture of layouts, which classes use their own custom layouts, and exactly what it means to be a layout manager.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">All layout managers implement one of two interfaces defined in the </FONT><FONT FACE="Courier" SIZE=2>java.awt</FONT><FONT FACE="AGaramond" SIZE=3> package: </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> or its subclass, </FONT><FONT FACE="Courier" SIZE=2>LayoutManager2</FONT><FONT FACE="AGaramond" SIZE=3>. </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> declares a set of methods that are intended to provide a straight-forward, organized means of managing component positions and sizes in a container. Each implementation of </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> defines these methods in different ways accoring to its specific needs. </FONT><FONT FACE="Courier" SIZE=2>LayoutManager2</FONT><FONT FACE="AGaramond" SIZE=3> enhances this by adding methods intended to aid in managing component postitions and sizes using <I>constraints-based</!
I> objects. Constraints-based objects usually store position and sizing information about one component and implementations of </FONT><FONT FACE="Courier" SIZE=2>LayoutManager2</FONT><FONT FACE="AGaramond" SIZE=3> normally store one contraints-based object per component. For instance, </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> uses a </FONT><FONT FACE="Courier" SIZE=2>Hashtable</FONT><FONT FACE="AGaramond" SIZE=3> to map each </FONT><FONT FACE="Courier" SIZE=2>Component</FONT><FONT FACE="AGaramond" SIZE=3> it manages to its own </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> object.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Figure 4.1 shows all the classes implementing </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>LayoutManager2</FONT><FONT FACE="AGaramond" SIZE=3>. Note that there are several UI classes implementing these interfaces to provide custom layout functionality for themselves. The other classes--the classes we are most familar and concerned with--are built solely to provide help in laying out containers they are assigned to. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Each container should be assigned one layout manager, and no layout manager should be used to manage more than one container.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: In the case of several UI components shown in figure 4.1, the container and the layout manager are the same object. Normally, however, the container and the layout manager are separate objects that communicate heavily with each other.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

</FONT><FONT SIZE=2><P><IMG SRC="image290.gif" WIDTH=400 HEIGHT=325></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.1 LayoutManager and LayoutManager2 implementations </P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-1.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.1&#9;LayoutManager</P>
<P>abstract interface java.awt.LayoutManager</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This interface must be implemented by any layout manager. Two methods are especially noteworthy:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">layoutContainer(Container parent) </FONT><FONT FACE="AGaramond" SIZE=3>calculates and sets the bounds for all components in the given container.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">preferredLayoutSize(Container parent) </FONT><FONT FACE="AGaramond" SIZE=3>calculates the preferred size requirements to lay out components in the given container and returns a </FONT><FONT FACE="Courier" SIZE=2>Dimension </FONT><FONT FACE="AGaramond" SIZE=3>instance representing this size.</P></DIR>

</FONT><I><FONT FACE="AGaramond"><P>4.1.2&#9;LayoutManager2</P>
<P>abstract interface java.awt.LayoutManager2</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This interface extends </FONT><FONT FACE="Courier" SIZE=2>LayoutManager </FONT><FONT FACE="AGaramond" SIZE=3>to provide a framework for those layout managers that use constraints-based layouts. Method</FONT><FONT FACE="Courier" SIZE=2> addLayoutComponent(Component comp, Object constraints) a</FONT><FONT FACE="AGaramond" SIZE=3>dds a new component associated with a constraints-based object which carries information about how to lay out this component. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A typical implementation is </FONT><FONT FACE="Courier" SIZE=2>BorderLayout </FONT><FONT FACE="AGaramond" SIZE=3>which requires a direction (north, east, etc.) to position a component. In this case the constraint objects used are static </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3>s such as </FONT><FONT FACE="Courier" SIZE=2>BorderLayout.NORTH</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>BorderLayout.EAST</FONT><FONT FACE="AGaramond" SIZE=3>, etc. We are normally blind to the fact that </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3> is constraints-based because we are never required to manipulate the constraint objects at all. This is not the case with layouts such as </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3>, where we must work directly with the contraint objects (instances of </FONT><FONT FACE="Courier" SIZE=2>Grid!
BagConstraints</FONT><FONT FACE="AGaramond" SIZE=3>).</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.3&#9;BoxLayout</P>
<P>class javax.swing.BoxLayout</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> organizes the components it manages along either the x-axis or y-axis of the owner panel. The only constructor, </FONT><FONT FACE="Courier" SIZE=2>BoxLayout(Container target, int axis)</FONT><FONT FACE="AGaramond" SIZE=3>, takes a reference to the </FONT><FONT FACE="Courier" SIZE=2>Container</FONT><FONT FACE="AGaramond" SIZE=3> component it will manage and a direction (</FONT><FONT FACE="Courier" SIZE=2>BoxLayout.X_AXIS</FONT><FONT FACE="AGaramond" SIZE=3> or </FONT><FONT FACE="Courier" SIZE=2>BoxLayout.Y_AXIS</FONT><FONT FACE="AGaramond" SIZE=3>). Components are laid out according to their preferred sizes and not wrapped, even if the container does not provide enough space.</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.4&#9;Box</P>
<P>class javax.swing.Box</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">To make using the </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> manager easier, Swing also provides a class named </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=3> which is a container with an automatically assigned </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> manager. To create an instance of this container we simply pass the desired alignment to its constructor. The </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=3> class also supports the insertion of invisible blocks (instances of </FONT><FONT FACE="Courier" SIZE=2>Box.Filler</FONT><FONT FACE="AGaramond" SIZE=3>--see below) allowing regions of unused space to be specified. These blocks are basically lightweight components with bounds (position and size) but no view. </P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.5&#9;Filler</P>
<P>static class javax.swing.Box.Filler</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This static inner class defines invisible components that affect a container’s layout. The </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=3> class provides convenient static methods for the creation of three different variations: glue, struts, and rigid areas.</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">createHorizontalGlue()</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>createVerticalGlue()</FONT><FONT FACE="AGaramond" SIZE=3>: returns a component which fills the space between its neighboring components, pushing them aside to occupy all available space (this functionality is more analagous to a spring than it is to glue).</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">createHorizontalStrut(int width)</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>createVerticalStrut(int height)</FONT><FONT FACE="AGaramond" SIZE=3>: returns a fixed-width (height) component which provides a fixed gap between its neighbors.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">createRigidArea(Dimension d)</FONT><FONT FACE="AGaramond" SIZE=3>: returns an invisible component of fixed width and height.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: All relevant </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=2> methods are static and, as such, they can be applied to any container managed by a </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=2>, not just instances of </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=2>. </FONT><FONT FACE="Courier" SIZE=2>Box</FONT><FONT FACE="AGaramond" SIZE=2> should be thought of as utilities class as much as it is a container.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond"><P>4.1.6&#9;FlowLayout</P>
<P>class java.awt.FlowLayout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This is a simple layout which places components from left to right in a row using the preferred component sizes (i.e. size returned by </FONT><FONT FACE="Courier" SIZE=2>getPreferredSize()</FONT><FONT FACE="AGaramond" SIZE=3>) until no space in the container is available. When no space is available a new row is started. Because this placement depends on the current size of the container we cannot always guarantee in advance which row a component will be placed in.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3> is too simple to rely on in serious applications where we want to be sure, for instance, that a set of buttons will reside at the bottom of a dialog and not on it's right side. However, it can be useful as a pad for a single component to ensure that this component will be placed in the center of a container. Note that </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3> is the default layout for all </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>s (the only exception is the content pane of a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=3> which is always initialized with a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>).</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.7&#9;GridLayout</P>
<P>class java.awt.GridLayout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This layout places components in a rectangular grid. There are three constructors:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridLayout()</FONT><FONT FACE="AGaramond" SIZE=3>: creates a layout with one column per component. Only one row is used.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridLayout(int rows, int cols)</FONT><FONT FACE="AGaramond" SIZE=3>: creates a layout with the given number of rows and columns.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridLayout(int rows, int cols, int hgap, int vgap)</FONT><FONT FACE="AGaramond" SIZE=3>: creates a layout with the given number of rows and columns, and the given size of horizontal and vertical gaps between each row and column.</P></DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> places components from left to right and from top to bottom assigning the same size to each. It forces occupation of all available container space and shares this space evenly between components. When not used carefully this can lead to undesirable component sizing, such as text boxes three times higher than expected.</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.8&#9;GridBagLayout</P>
<P>class java.awt.GridBagLayout, class java.awt.GridBagConstraints</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This layout extends the capabilities of </FONT><FONT FACE="Courier New" SIZE=3>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> to become constraints-based. It breaks the container's space into equal rectangular pieces (like bricks in a wall) and places each component in one or more of these pieces. You need to create and fill a </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> object for each component to inform </FONT><FONT FACE="Courier New" SIZE=3>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> how to place and size that component.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> can be effectively used for placement of components, if no special behavior is required on resizing. However, due to it's complexity it usually requires some helper methods or classes to handle all necessary constraints information. James Tan, a usability expert and </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> extraordinaire, gives a comprehensive overview of this manager in section 4.3. He also presents a helper class to ease the burden of dealing with </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.9&#9;BorderLayout</P>
<P>class java.awt.BorderLayout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This layout divides a container into five regions: center, north, south, east, and west. To specify the region to place a component in we use </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3>s of the form &quot;Center,&quot; &quot;North,&quot; etc., or the static </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3> fields defined in </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>: </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>.</FONT><FONT FACE="Courier New" SIZE=3>CENTER</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>.</FONT><FONT FACE="Courier New" SIZE=3>NORTH</FONT><FONT FACE="AGaramond" SIZE=3>, etc. During the layout process, components in the north and south regions will first be alotted their preferred heig!
ht (if possible) and the width of the container. Once south and north components have been assigned sizes, components in the east and west regions will attempt to occupy their preferred width and any remaining height between the north and south components. A component in the center region will occupy all remaining available space. </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=2> </FONT><FONT FACE="AGaramond" SIZE=3>is very useful, especially in conjunction with other layouts as we will see in this and future chapters.</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.10&#9;CardLayout</P>
<P>class java.awt.CardLayout</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">CardLayout</FONT><FONT FACE="AGaramond" SIZE=3> treats all components similar to cards of equal size overlapping one another. Only one card component is visible at any given time (figure 4.2 illustrates). Methods </FONT><FONT FACE="Courier" SIZE=2>first()</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>last()</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>next()</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>previous()</FONT><FONT FACE="AGaramond" SIZE=3>, and </FONT><FONT FACE="Courier" SIZE=2>show()</FONT><FONT FACE="AGaramond" SIZE=3> can be called to switch between components in the parent </FONT><FONT FACE="Courier" SIZE=2>Container</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image346.gif" WIDTH=344 HEIGHT=196></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.2 CardLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-2.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">In a stack of several cards, only the top-most card is visible. The following code a simple </FONT><FONT FACE="Courier" SIZE=2>CardLayout</FONT><FONT FACE="AGaramond" SIZE=3> demo, which endlessly flips through four cards containing buttons.</P>
</FONT><I><FONT FACE="AGaramond"><P>4.1.11&#9;JPanel</P>
<P>class javax.swing.JPanel</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class represents a generic lightweight container. It works in close cooperation with layout managers. The default constructor creates a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3> with </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3>, but different layouts can be specified in the constructor or assigned using the </FONT><FONT FACE="Courier" SIZE=2>setLayout()</FONT><FONT FACE="AGaramond" SIZE=3> method (see chapter 3 for more about </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>). </P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: The content pane of a </FONT><FONT FACE="Courier" SIZE=2>JRootPane</FONT><FONT FACE="AGaramond" SIZE=2> container is a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=2> which, by default, is assigned a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=2>, not a </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=2>.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: We have purposely omitted the discussion of several layout managers here (e.g. </FONT><FONT FACE="Courier" SIZE=2>ViewportLayout</FONT><FONT FACE="AGaramond" SIZE=2>, </FONT><FONT FACE="Courier" SIZE=2>ScrollPaneLayout</FONT><FONT FACE="AGaramond" SIZE=2>, </FONT><FONT FACE="Courier" SIZE=2>JRootPane.RootPaneLayout</FONT><FONT FACE="AGaramond" SIZE=2>, etc.) because they are rarely used by developers and are more appropriately discussed in terms of the components that rely on them. For instance, we discuss </FONT><FONT FACE="Courier" SIZE=2>ViewportLayout</FONT><FONT FACE="AGaramond" SIZE=2> and </FONT><FONT FACE="Courier" SIZE=2>ScrollPaneLayout</FONT><FONT FACE="AGaramond" SIZE=2> in chapter 7.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.2&#9;Comparing common layout managers</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The following example demonstrates the most commonly used AWT and Swing layout managers. It shows a set of </FONT><FONT FACE="Courier" SIZE=2>JInternalFrames</FONT><FONT FACE="AGaramond" SIZE=3> containing identical sets of components, each using a different layout. The purpose of this example is to allow direct simultaneous layout manager comparisons using resizable containers.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image97.gif" WIDTH=500 HEIGHT=380></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.3 Comparing common layouts</P>
</B></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&lt;&lt;file figure4-3.gif&gt;&gt;</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: CommonLayouts.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\1</P>
</B></FONT><FONT FACE="Courier" SIZE=3>

<pre>
import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

public class CommonLayouts extends JFrame 
{
  public CommonLayouts() {
    super("Common Layout Managers");
    setSize(500, 380);

    JDesktopPane desktop = new JDesktopPane();
    getContentPane().add(desktop);

    JInternalFrame fr1 = 
      new JInternalFrame("FlowLayout", true, true);
    fr1.setBounds(10, 10, 150, 150);
    Container c = fr1.getContentPane();
    c.setLayout(new FlowLayout());
    c.add(new JButton("1"));
    c.add(new JButton("2"));
    c.add(new JButton("3"));
    c.add(new JButton("4"));
    desktop.add(fr1, 0);

    JInternalFrame fr2 = 
      new JInternalFrame("GridLayout", true, true);
    fr2.setBounds(170, 10, 150, 150);
    c = fr2.getContentPane();
    c.setLayout(new GridLayout(2, 2));
    c.add(new JButton("1"));
    c.add(new JButton("2"));
    c.add(new JButton("3"));
    c.add(new JButton("4"));
    desktop.add(fr2, 0);

    JInternalFrame fr3 = 
      new JInternalFrame("BorderLayout", true, true);
    fr3.setBounds(330, 10, 150, 150);
    c = fr3.getContentPane();
    c.add(new JButton("1"), BorderLayout.NORTH);
    c.add(new JButton("2"), BorderLayout.EAST);
    c.add(new JButton("3"), BorderLayout.SOUTH);
    c.add(new JButton("4"), BorderLayout.WEST);
    desktop.add(fr3, 0);

    JInternalFrame fr4 = new JInternalFrame("BoxLayout - X", 
      true, true);
    fr4.setBounds(10, 170, 250, 120);
    c = fr4.getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.X_AXIS));
    c.add(new JButton("1"));
    c.add(Box.createHorizontalStrut(12));
    c.add(new JButton("2"));
    c.add(Box.createGlue());
    c.add(new JButton("3"));
    c.add(Box.createHorizontalGlue());
    c.add(new JButton("4"));
    desktop.add(fr4, 0);

    JInternalFrame fr5 = new JInternalFrame("BoxLayout - Y", 
      true, true);
    fr5.setBounds(330, 170, 150, 180);
    c = fr5.getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    c.add(new JButton("1"));
    c.add(Box.createVerticalStrut(10));
    c.add(new JButton("2"));
    c.add(Box.createGlue());
    c.add(new JButton("3"));
    c.add(Box.createVerticalGlue());
    c.add(new JButton("4"));
    desktop.add(fr5, 0);
        
    try { 
      fr1.setSelected(true); 
    } 
    catch (java.beans.PropertyVetoException ex) {}

    WindowListener wndCloser = new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    };
    addWindowListener(wndCloser);
        
    setVisible(true);
  }

  public static void main(String argv[]) {
    new CommonLayouts();
  }
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Understanding the Code</P>
</B></FONT><I><FONT FACE="AGaramond"><P>Class CommonLayouts</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>CommonLayouts </FONT><FONT FACE="AGaramond" SIZE=3>constructor creates five </FONT><FONT FACE="Courier" SIZE=2>JInternalFrames</FONT><FONT FACE="AGaramond" SIZE=3> and places them in a </FONT><FONT FACE="Courier" SIZE=2>JDesktopPane</FONT><FONT FACE="AGaramond" SIZE=3>. Each of these frames contains four </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3>s labeled &quot;1,&quot; &quot;2,&quot; &quot;3&quot; and &quot;4.&quot; Each frame is assigned a unique layout manager: a </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3>, a 2x2 </FONT><FONT FACE="Courier" SIZE=2>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3>, a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>, an x-oriented </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3>, and a y-oriented </FONT!
><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> respectively. Note that the internal frames using </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> also use strut and glue filler components to demonstrate their behavior.</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Running the Code</P>
<P ALIGN="JUSTIFY"></P>
</B><P ALIGN="JUSTIFY">Figure 4.3 shows </FONT><FONT FACE="Courier" SIZE=2>CommonLayouts</FONT><FONT FACE="AGaramond" SIZE=3> in action. Note the differences in each frame’s content as it changes size:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3> places components in one or more rows depending on the width of the container.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> assigns an equal size to all components and fills all container space.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">BorderLayout </FONT><FONT FACE="AGaramond" SIZE=3>places components along the sides of the container.</P>
<P ALIGN="JUSTIFY">x-oriented </FONT><FONT FACE="Courier" SIZE=2>BoxLayout </FONT><FONT FACE="AGaramond" SIZE=3>always places components in a row. The distance between the first and second components is 12 pixels (determined by the horizontal strut component). Distances between the second, third, and fourth components are equalized and take up all remaining width (determined by the two glue filler components).</P>
<P ALIGN="JUSTIFY">y-oriented </FONT><FONT FACE="Courier" SIZE=2>BoxLayout </FONT><FONT FACE="AGaramond" SIZE=3>always places components in a column. The distance between the first and second components is 10 pixels (determined by the vertical strut component). Distances between the second, third, and fourth components are equalized and take up all available height (determined by the two glue filler components).</P></DIR>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.3&#9;Using GridBagLayout </P>
</FONT><FONT FACE="AGaramond"><P>...by James Tan, Systems Analyst, United Overseas Bank Singapore, jamestan@earthling.net </P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Of all the layouts included with Swing and AWT, </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> is by far the most complex. In this section, we will walk through the various constraints attributes it relies on, along with several short examples showing how to use them. We follow up this discussion with a comprehensive input dialog example putting together all these attributes. We then conclude this section with the construction and demonstration of a helper class designed to make using </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> more convenient. </P>
<P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.1&#9;Default behavior of GridBagLayout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">By simply setting a container’s layout to a </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> and adding </FONT><FONT FACE="Courier" SIZE=2>Component</FONT><FONT FACE="AGaramond" SIZE=3>s to it, the result will be a row of components, each set to their preferred size, tightly packed and placed in the center of the container. Unlike </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> will allow components to be clipped by the edge of the managing container, and it will not move child components down into a new row. The following code demonstrates, and figure 4.4 shows the result:</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
  JInternalFrame fr1 = new JInternalFrame ("Example 1", true, true );
  fr1.setBounds( 5, 5, 270, 100 );
  cn = fr1.getContentPane();
  cn.setLayout( new GridBagLayout() );
  cn.add( new JButton( "Wonderful" ) );
  cn.add( new JButton( "World" ) );
  cn.add( new JButton( "Of" ) );
  cn.add( new JButton( "Swing !!!" ) );
  desktop.add( fr1, 0 );
</pre>
</FONT><FONT SIZE=2>
<P><IMG SRC="file://C:\My Documents\Swing\Example1.gif" WIDTH=270 HEIGHT=100></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.4 Default GridBagLayout behaviour</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-4.gif&gt;&gt;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.2&#9;Introducing GridBagConstraint</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">When a component is added to a container which has been assigned a </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3>, a default </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> object is used by the layout manager to place the component accordingly, as in the above example. By creating and setting a </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3>’ attributes and passing it in as an additional parameter in the </FONT><FONT FACE="Courier" SIZE=2>add()</FONT><FONT FACE="AGaramond" SIZE=3> method, we can flexibly manage the placement of our components. </P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Below are the various attributes we can set in a </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> object along with their default values. The behaviour of these attributes will be explained in the examples that follow.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
public int gridx = GridBagConstraints.RELATIVE; 
public int gridy = GridBagConstraints.RELATIVE;
public int gridwidth = 1;
public int gridheight = 1;
public double weightx = 0.0;
public double weighty = 0.0;
public int anchor = GridBagConstraints.CENTER;
public int fill = GridBagConstraints.NONE;
public Insets insets = new Insets( 0, 0, 0, 0 );
public int ipadx = 0;
public int ipady = 0;
</pre>
</FONT><I><FONT FACE="AGaramond"><P>4.3.3&#9;Using the gridx, gridy, insets, ipadx and ipady constraints</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>gridx</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>gridy</FONT><FONT FACE="AGaramond" SIZE=3> constraints (or column and row constraints) are used to specify the exact grid cell location where we want our component to be placed. Components placement starts from the upper left corner of the container, and </FONT><FONT FACE="Courier" SIZE=2>gridx</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>gridy</FONT><FONT FACE="AGaramond" SIZE=3> begin with values of 0. Specifying negative values for either of these attributes is equivalent to setting them to </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints.RELATIVE</FONT><FONT FACE="AGaramond" SIZE=3>, which means that the next component added will be placed directly after the previous </FONT><FONT FACE="Courier" SIZE=2>gridx</FONT><FONT FACE="AGaramond" SIZE=3> or </FONT><FON!
T FACE="Courier" SIZE=2>gridy</FONT><FONT FACE="AGaramond" SIZE=3> location.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>insets</FONT><FONT FACE="AGaramond" SIZE=3> constraint adds an invisible exterior padding around the associated component. Negative values can be used which will force the component to be sized larger than the cell it is contained in.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>ipadx</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>ipady</FONT><FONT FACE="AGaramond" SIZE=3> constraints add an interior padding which increases the preferred size of the associated component. Specifically,it adds </FONT><FONT FACE="Courier" SIZE=2>ipadx * 2</FONT><FONT FACE="AGaramond" SIZE=3> pixels to the preferred width and </FONT><FONT FACE="Courier" SIZE=2>ipady * 2</FONT><FONT FACE="AGaramond" SIZE=3> pixels to the preferred height (</FONT><FONT FACE="Courier" SIZE=2>* 2</FONT><FONT FACE="AGaramond" SIZE=3> because this padding applies to both sides of the component).</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this example we place the &quot;Wonderful&quot; and &quot;World&quot; buttons in the first row and the other two buttons in the second row. We also associate insets with each button so they don’t look too cluttered, and they vary in both height and width.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>  
<pre>
  JInternalFrame fr2 = new JInternalFrame("Example 2", true, true );
  fr2.setBounds( 5, 110, 270, 140 );
  cn = fr2.getContentPane();
  cn.setLayout( new GridBagLayout() );

  c = new GridBagConstraints();
  c.insets = new Insets( 2, 2, 2, 2 );
  c.gridx = 0;   // column 0
  c.gridy = 0;   // row 0
  c.ipadx = 5;   // increases component width by 10 pixels
  c.ipady = 5;   // increases component height by 10 pixels
  cn.add( new JButton( "Wonderful" ), c );

  c.gridx = 1;   // column 1
  c.ipadx = 0;   // reset the padding to 0
  c.ipady = 0;
  cn.add( new JButton( "World" ), c );                              

  c.gridx = 0;   // column 0
  c.gridy = 1;   // row 1
  cn.add( new JButton( "Of" ), c );                                 

  c.gridx = 1;   // column 1 
  cn.add( new JButton( "Swing !!!" ), c );                            

  desktop.add( fr2, 0 );
</pre>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">We begin by creating a </FONT><FONT FACE="Courier" SIZE=3>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> object to set the constraints for the first button component. We pass it in together with the button in the </FONT><FONT FACE="Courier" SIZE=2>add()</FONT><FONT FACE="AGaramond" SIZE=3> method. We reuse this same constraints object by changing the relevant attributes and passing in again for each remaining component. This conserves memory and also relieves us of having to reassign a whole new group of attributes. Figure 4.5 shows the result.</P>
</FONT><FONT SIZE=2>
<P><IMG SRC="example2.html" WIDTH=270 HEIGHT=140></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.5 Using the gridx, gridy, insets, ipadx and ipady constraints.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-5.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.4&#9;Using weightx and weighty constraints</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">When the container in the above example is resized, the components respect the constraints we have assigned, but the whole group remains in the center of the container. Why don’t the buttons grow to occupy a proportional amount of the increased space surrounding them? The answer lies in the use of the </FONT><FONT FACE="Courier" SIZE=2>weightx</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>weighty</FONT><FONT FACE="AGaramond" SIZE=3> constraints, which both default to zero when </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints</FONT><FONT FACE="AGaramond" SIZE=3> is instantiated.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">These two constraints specify how any extra space in a container should be distributed among each component’s cell. The </FONT><FONT FACE="Courier" SIZE=2>weightx</FONT><FONT FACE="AGaramond" SIZE=3> attribute is used to specify the fraction of extra horizontal space to occupy. Similarly, </FONT><FONT FACE="Courier" SIZE=2>weighty</FONT><FONT FACE="AGaramond" SIZE=3> is used to specify the fraction of extra vertical space to occupy.  Both constraints can be assigned values ranging from </FONT><FONT FACE="Courier" SIZE=2>0.0</FONT><FONT FACE="AGaramond" SIZE=3> to </FONT><FONT FACE="Courier" SIZE=2>1.0</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">For example, lets say we have two buttons, A and B, placed in columns 0 and 1 of row 0 respectively. If we specify </FONT><FONT FACE="Courier" SIZE=2>weightx = 1.0</FONT><FONT FACE="AGaramond" SIZE=3> for the first button and </FONT><FONT FACE="Courier" SIZE=2>weightx = 0</FONT><FONT FACE="AGaramond" SIZE=3> for the second button, when we resize the container, all extra space will be distributed to the first button’s cell -- 50% on the left of the button and 50% on the right. The other button will be pushed to the right of the container as far as possible. Figure 4.6 illustrates.</P>
</FONT><FONT SIZE=2>
<P><IMG SRC="image347.gif" WIDTH=203 HEIGHT=78></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.6 weightx and weighty constraints.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-6.gif&gt;&gt;</P>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Getting back to our &quot;Wonderful&quot; &quot;World&quot; &quot;Of&quot; &quot;Swing !!!&quot; example, we now modify all button cells to share any extra container space equally as the container is resized. Specifying </FONT><FONT FACE="Courier" SIZE=2>weightx = 1.0</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>weighty = 1.0</FONT><FONT FACE="AGaramond" SIZE=3>, and keeping these attributes constant as each component is added, will tell </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> to use all available space for each cell. </P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
  JInternalFrame fr3 = new JInternalFrame("Example 3", true, true );
  fr3.setBounds( 5, 255, 270, 140 );                                
  cn = fr3.getContentPane();                                        
  cn.setLayout( new GridBagLayout() );                               

  c = new GridBagConstraints();                                      
  c.insets = new Insets( 2, 2, 2, 2 );                               
  c.weighty = 1.0;
  c.weightx = 1.0;                                                   
  c.gridx = 0;                                                       
  c.gridy = 0;                                                       
  cn.add( new JButton( "Wonderful" ), c );                           

  c.gridx = 1;                                                       
  cn.add( new JButton( "World" ), c );                               

  c.gridx = 0;                                                       
  c.gridy = 1;                                                       
  cn.add( new JButton( "Of" ), c );                                  

  c.gridx = 1;                                                       
  cn.add( new JButton( "Swing !!!" ), c );                           

  desktop.add( fr3, 0 );</P>
</pre>
</FONT><FONT SIZE=2>
<P><IMG SRC="file://C:\My Documents\Swing\Example3.gif" WIDTH=270 HEIGHT=140></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.7 Using weightx and weighty constraints.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-7.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.5&#9;Using gridwidth and gridheight constraints</P>
</I></FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> also allows us to span components across multiple cell using the </FONT><FONT FACE="Courier" SIZE=2>gridwidth</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>gridheight</FONT><FONT FACE="AGaramond" SIZE=3> constraints. To demonstrate we modify our example to force the &quot;Wonderful&quot; button to occupy 2 rows and the &quot;World&quot; button to occupy 2 columns. Figure 4.8 illustrates. Note that occupying more cells forces more rows and/or columns to be created based on current container size.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
  JInternalFrame fr4 = new JInternalFrame("Example 4", true, true );
  fr4.setBounds( 280, 5, 270, 140 );                                 
  cn = fr4.getContentPane();                                         
  cn.setLayout( new GridBagLayout() );                               

  c = new GridBagConstraints();                                      
  c.insets = new Insets( 2, 2, 2, 2 );                               
  c.weighty = 1.0;                                                   
  c.weightx = 1.0;                                                   
  c.gridx = 0;                                                       
  c.gridy = 0;                                                       
  c.gridheight = 2; // span across 2 rows 
  cn.add( new JButton( "Wonderful" ), c );   
                        
  c.gridx = 1;                                                       
  c.gridheight = 1; // remember to set back to 1 row 
  c.gridwidth = 2; // span across 2 columns 
  cn.add( new JButton( "World" ), c );                               

  c.gridy = 1;                                                       
  c.gridwidth = 1; // remember to set back to 1 column 
  cn.add( new JButton( "Of" ), c );                                  

  c.gridx = 2;                                                       
  cn.add( new JButton( "Swing !!!" ), c );                           

  desktop.add( fr4, 0 );
</pre>
</FONT><FONT FACE="Courier New" SIZE=1>
</FONT><FONT SIZE=2><P><IMG SRC="file://C:\My Documents\Swing\Example4.gif" WIDTH=270 HEIGHT=140></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figures 4.8 Using gridwidth and gridheight constraints.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-8.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.6&#9;Using anchor constraints</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">We can control how a component is aligned within its cell(s) by setting the </FONT><FONT FACE="Courier" SIZE=2>anchor</FONT><FONT FACE="AGaramond" SIZE=3> constraint. By default this is set to </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints.CENTER</FONT><FONT FACE="AGaramond" SIZE=3>, which forces the component to be centered within its occupied cell(s). We can choose from the following </FONT><FONT FACE="Courier" SIZE=2>anchor</FONT><FONT FACE="AGaramond" SIZE=3> settings:</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=2><P>  GridBagConstraints.NORTH</P>
<P>  GridBagConstraints.SOUTH</P>
<P>  GridBagConstraints.EAST</P>
<P>  GridBagConstraints.WEST</P>
<P>  GridBagConstraints.NORTHEAST</P>
<P>  GridBagConstraints.NORTHWEST</P>
<P>  GridBagConstraints.SOUTHEAST</P>
<P>  GridBagConstraints.SOUTHWEST</P>
<P>  GridBagConstraints.CENTER</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Below we’ve modified our example to anchor the &quot;Wonderful&quot; button </FONT><FONT FACE="Courier" SIZE=2>NORTH</FONT><FONT FACE="AGaramond" SIZE=3> and the &quot;World&quot; button SOUTHWEST. The &quot;Of&quot; and &quot;Swing !!!&quot; buttons are achored in the CENTER of their cells. Figure 4.9 illustrates.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
  JInternalFrame fr5 = new JInternalFrame("Example 5", true, true );
  fr5.setBounds( 280, 150, 270, 140 );                               
  cn = fr5.getContentPane();                                         
  cn.setLayout( new GridBagLayout() );                               

  c = new GridBagConstraints();                                      
  c.insets = new Insets( 2, 2, 2, 2 );                               
  c.weighty = 1.0;                                                   
  c.weightx = 1.0;                                                   
  c.gridx = 0;                                                       
  c.gridy = 0;                                                        
  c.gridheight = 2;                                                  
  c.anchor = GridBagConstraints.NORTH;
  cn.add( new JButton( "Wonderful" ), c );                           

  c.gridx = 1;                                                       
  c.gridheight = 1;                                                  
  c.gridwidth = 2;                                                   
  c.anchor = GridBagConstraints.SOUTHWEST; 
  cn.add( new JButton( "World" ), c );                               

  c.gridy = 1;                                                       
  c.gridwidth = 1;                                                   
  c.anchor = GridBagConstraints.CENTER;
  cn.add( new JButton( "Of" ), c );                                  

  c.gridx = 2;                                                       
  cn.add( new JButton( "Swing !!!" ), c );                           

  desktop.add( fr5, 0 );
</pre>
</FONT><FONT SIZE=2>
<P>&nbsp;</P>
<P><IMG SRC="file://C:\My Documents\Swing\Example5.gif" WIDTH=270 HEIGHT=140></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.9 Using gridwidth and gridheight constraints.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-9.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.7&#9;Using fill constraints</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The most common reason for spanning multiple cells is because we want the component contained in that cell to occupy this enlarged space. To do this we use the </FONT><FONT FACE="Courier" SIZE=2>gridheight</FONT><FONT FACE="AGaramond" SIZE=3>/</FONT><FONT FACE="Courier" SIZE=2>gridwidth</FONT><FONT FACE="AGaramond" SIZE=3> constraints as described above, as well as the </FONT><FONT FACE="Courier" SIZE=2>fill</FONT><FONT FACE="AGaramond" SIZE=3> constraint. The </FONT><FONT FACE="Courier" SIZE=2>fill</FONT><FONT FACE="AGaramond" SIZE=3> constraint can be assigned any of the following values:</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=2><P>  GridBagConstraints.NONE</P>
<P>  GridBagConstraints.HORIZONTAL</P>
<P>  GridBagConstraints.VERTICAL</P>
<P>  GridBagConstraints.BOTH</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Below we modify our example to force the &quot;Wonderful&quot; button to occupy all available cell space, both vertically and horizontally. The &quot;World&quot; button now occupies all available horizontal cell space, but continues to use its preferred vertical size. The &quot;Of&quot; button does not make use of the fill constraint and simply uses its preferred size. The &quot;Swing !!!&quot; button occupies all available vertical cell space, but uses its preferred horizontal size. Figure 4.10 illustrates.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier New" SIZE=3><P>
<pre>  
  JInternalFrame fr6 = new JInternalFrame("Example 6", true, true );
  fr6.setBounds( 280, 295, 270, 140 );                               
  cn = fr6.getContentPane();                                         
  cn.setLayout( new GridBagLayout() );                               

  c = new GridBagConstraints();                                      
  c.insets = new Insets( 2, 2, 2, 2 );                               
  c.weighty = 1.0;                                                   
  c.weightx = 1.0;                                                   
  c.gridx = 0;                                                       
  c.gridy = 0;                                                       
  c.gridheight = 2;                                                  
  c.fill = GridBagConstraints.BOTH;
  cn.add( new JButton( "Wonderful" ), c );                           

  c.gridx = 1;                                                       
  c.gridheight = 1;                                                  
  c.gridwidth = 2;                                                   
  c.fill = GridBagConstraints.HORIZONTAL;
  cn.add( new JButton( "World" ), c );   
                            
  c.gridy = 1;                                                       
  c.gridwidth = 1;                                                   
  c.fill = GridBagConstraints.NONE;
  cn.add( new JButton( "Of" ), c );
                                  
  c.gridx = 2;                                                       
  c.fill = GridBagConstraints.VERTICAL;
  cn.add( new JButton( "Swing !!!" ), c );                           

  desktop.add( fr6, 0 );
</pre>
</FONT><FONT SIZE=2>
<P><IMG SRC="file://C:\My Documents\Swing\Example6.gif" WIDTH=270 HEIGHT=140></P>
<P>Figure 4.10 Using fill constraints.</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.8 Putting it all together: Constructing a complaints dialog</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Figure 4.11 shows a sketch of a generic complaints dialog that can be used for various forms of user feedback. This sketch shows clearly how we plan to lay out the various components, and the columns and rows in which they will be placed. In order to set the constraints correctly so that the components will be laid out as shown, we must do the following:</P><DIR>

<P ALIGN="JUSTIFY">For the &quot;Short Description&quot; text field, we set the </FONT><FONT FACE="Courier" SIZE=2>gridwidth</FONT><FONT FACE="AGaramond" SIZE=3> constraint to </FONT><FONT FACE="Courier" SIZE=2>3</FONT><FONT FACE="AGaramond" SIZE=3> and the </FONT><FONT FACE="Courier" SIZE=2>fill</FONT><FONT FACE="AGaramond" SIZE=3> constraint to </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraints.HORIZONTAL</FONT><FONT FACE="AGaramond" SIZE=3>. In order to make this field occupy all the horizontal space available, we also need to set the </FONT><FONT FACE="Courier" SIZE=2>weightx </FONT><FONT FACE="AGaramond" SIZE=3>constraints to </FONT><FONT FACE="Courier" SIZE=2>1.0</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY">For the &quot;Description&quot; text area, we set the </FONT><FONT FACE="Courier" SIZE=2>gridwidth</FONT><FONT FACE="AGaramond" SIZE=3> constraint to </FONT><FONT FACE="Courier" SIZE=2>3</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>gridheight</FONT><FONT FACE="AGaramond" SIZE=3> to </FONT><FONT FACE="Courier" SIZE=2>2</FONT><FONT FACE="AGaramond" SIZE=3>, and the </FONT><FONT FACE="Courier" SIZE=2>fill</FONT><FONT FACE="AGaramond" SIZE=3> constraint to </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraint.BOTH</FONT><FONT FACE="AGaramond" SIZE=3>. In order to make this field occupy all available horizontal and vertical space, we set the weightx and weighty constraints to </FONT><FONT FACE="Courier" SIZE=2>1.0</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY">For the &quot;Name,&quot; &quot;Telephone,&quot; &quot;Sex&quot; and &quot;ID Number&quot; input fields, we want each to use their preferred width. Since widths each exceed the width of one cell, we set </FONT><FONT FACE="Courier" SIZE=2>gridwidth</FONT><FONT FACE="AGaramond" SIZE=3> to </FONT><FONT FACE="Courier" SIZE=2>3</FONT><FONT FACE="AGaramond" SIZE=3>, and set </FONT><FONT FACE="Courier" SIZE=2>weightx</FONT><FONT FACE="AGaramond" SIZE=3> to </FONT><FONT FACE="Courier" SIZE=2>0.0</FONT><FONT FACE="AGaramond" SIZE=3> so that they have enough space to fit but they will not use any additional available horizontal space.</P>
<P ALIGN="JUSTIFY">For the &quot;Help&quot; button, we set the </FONT><FONT FACE="Courier" SIZE=2>anchor</FONT><FONT FACE="AGaramond" SIZE=3> constraint to </FONT><FONT FACE="Courier" SIZE=2>GridBagConstraint.NORTH</FONT><FONT FACE="AGaramond" SIZE=3> so that it will stick together with the upper two buttons, &quot;Submit&quot; and &quot;Cancel.&quot; The </FONT><FONT FACE="Courier" SIZE=2>fill</FONT><FONT FACE="AGaramond" SIZE=3> constraint is set to </FONT><FONT FACE="Courier" SIZE=2>HORIZONTAL</FONT><FONT FACE="AGaramond" SIZE=3> to force each of these buttons to occupy all available horizontal cell space.</P>
<P ALIGN="JUSTIFY">All labels use their preferred sizes, and each component in this dialog is anchored </FONT><FONT FACE="Courier" SIZE=2>WEST</FONT><FONT FACE="AGaramond" SIZE=3>.</P></DIR>

</FONT><FONT SIZE=2><P><IMG SRC="image291.gif" WIDTH=601 HEIGHT=393></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.11 Sketch of a generic complaints dialog.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-11.gif&gt;&gt;</P>

</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Our implementation follows, and figure 4.12 shows the resulting dialog.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;

public class ComplaintsDialog extends JDialog
{
   public ComplaintsDialog( JFrame frame )
   {
      super( frame, true );
      setTitle( "Simple Complaints Dialog" );
      setSize( 500, 300 );

      // Creates a panel to hold all my components
      JPanel panel = new JPanel( new BorderLayout() );
      panel.setLayout( new GridBagLayout() );
      // give the panel a border gap of 5 pixels
      panel.setBorder( new EmptyBorder( new Insets( 5, 5, 5, 5 ) ) );
      getContentPane().add( BorderLayout.CENTER, panel );
      
      GridBagConstraints c = new GridBagConstraints();

      // Define preferred sizes for my entry fields
      Dimension shortField = new Dimension( 40, 20 );
      Dimension mediumField = new Dimension( 120, 20 );
      Dimension longField = new Dimension( 240, 20 );
      Dimension hugeField = new Dimension( 240, 80 );

      // Spacing between the label and the field
      EmptyBorder border = new EmptyBorder( new Insets( 0, 0, 0, 10 ) );
      EmptyBorder border1 = new EmptyBorder( new Insets( 0, 20, 0, 10 ) );

      // add some space around all my components to avoid cluttering
      c.insets = new Insets( 2, 2, 2, 2 );

      // anchors all my components to the west
      c.anchor = GridBagConstraints.WEST;

      // Short description label and field
      JLabel lbl1 = new JLabel( "Short Description" );
      lbl1.setBorder( border ); // add some space on the right
      panel.add( lbl1, c );
      JTextField txt1 = new JTextField();
      txt1.setPreferredSize( longField );
      c.gridx = 1;
      c.weightx = 1.0; // use all available horizontal space
      c.gridwidth = 3; // spans across 3 columns
      c.fill = GridBagConstraints.HORIZONTAL; // fills up the 3 columns
      panel.add( txt1, c );

      // Description label and field
      JLabel lbl2 = new JLabel( "Description" );
      lbl2.setBorder( border );
      c.gridwidth = 1;
      c.gridx = 0;
      c.gridy = 1;;
      c.weightx = 0.0; // do not use any available horizontal space
      panel.add( lbl2, c );
      JTextArea area1 = new JTextArea();
      JScrollPane scroll = new JScrollPane( area1 );
      scroll.setPreferredSize( hugeField );
      c.gridx = 1;
      c.weightx = 1.0; // use all available horizontal space
      c.weighty = 1.0; // use all available vertical space
      c.gridwidth = 3; // spans across 3 columns
      c.gridheight = 2; // spans across 2 rows
      c.fill = GridBagConstraints.BOTH; // fills up the cols & rows
      panel.add( scroll, c );

      // Severity label and combo box
      JLabel lbl3 = new JLabel( "Severity" );
      lbl3.setBorder( border );
      c.gridx = 0;
      c.gridy = 3;
      c.gridwidth = 1;
      c.gridheight = 1;
      c.weightx = 0.0;
      c.weighty = 0.0;
      c.fill = GridBagConstraints.NONE;
      panel.add( lbl3, c );
      JComboBox combo3 = new JComboBox();
      combo3.addItem( "A" );
      combo3.addItem( "B" );
      combo3.addItem( "C" );
      combo3.addItem( "D" );
      combo3.addItem( "E" );
      combo3.setPreferredSize( shortField );
      c.gridx = 1;
      panel.add( combo3, c );

      // Priority label and combo box
      JLabel lbl4 = new JLabel( "Priority" );
      lbl4.setBorder( border1 );
      c.gridx = 2;
      panel.add( lbl4, c );
      JComboBox combo4 = new JComboBox();
      combo4.addItem( "1" );
      combo4.addItem( "2" );
      combo4.addItem( "3" );
      combo4.addItem( "4" );
      combo4.addItem( "5" );
      combo4.setPreferredSize( shortField );
      c.gridx = 3;
      panel.add( combo4, c );

      // Name label and text field
      JLabel lbl5 = new JLabel( "Name" );
      lbl5.setBorder( border );
      c.gridx = 0;
      c.gridy = 4;
      panel.add( lbl5, c );
      JTextField txt5 = new JTextField();
      txt5.setPreferredSize( longField );
      c.gridx = 1;
      c.gridwidth = 3;
      panel.add( txt5, c );

      // Telephone label and text field
      JLabel lbl6 = new JLabel( "Telephone" );
      lbl6.setBorder( border );
      c.gridx = 0;
      c.gridy = 5;
      panel.add( lbl6, c );
      JTextField txt6 = new JTextField();
      txt6.setPreferredSize( mediumField );
      c.gridx = 1;
      c.gridwidth = 3;
      panel.add( txt6, c );

      // Sex label and radio button
      JLabel lbl7 = new JLabel( "Sex" );
      lbl7.setBorder( border );
      c.gridx = 0;
      c.gridy = 6;
      panel.add( lbl7, c );
      JPanel radioPanel = new JPanel();
      // Creates a FlowLayout layout JPanel with 5 pixel of horizontal gaps
      // and no vertical gaps
      radioPanel.setLayout( new FlowLayout( FlowLayout.LEFT, 5, 0 ) );
      ButtonGroup group = new ButtonGroup();
      JRadioButton radio1 = new JRadioButton( "Male" );
      radio1.setSelected( true );
      group.add( radio1 );
      JRadioButton radio2 = new JRadioButton( "Female" );
      group.add( radio2 );
      radioPanel.add( radio1 );
      radioPanel.add( radio2 );
      c.gridx = 1;
      c.gridwidth = 3;
      panel.add( radioPanel, c);

      // ID Number label and text field
      JLabel lbl8 = new JLabel( "ID Number" );
      lbl8.setBorder( border );
      c.gridx = 0;
      c.gridy = 7;
      c.gridwidth = 1;
      panel.add( lbl8, c );
      JTextField txt8 = new JTextField();
      txt8.setPreferredSize( mediumField );
      c.gridx = 1;
      c.gridwidth = 3;
      panel.add( txt8, c );

      // Okay button
      JButton submitBtn = new JButton( "Submit" );
      c.gridx = 4;
      c.gridy = 0;
      c.gridwidth = 1;
      c.fill = GridBagConstraints.HORIZONTAL;
      panel.add( submitBtn, c );

      // Cancel button
      JButton cancelBtn = new JButton( "Cancel" );
      c.gridy = 1;
      panel.add( cancelBtn, c );

      // Help button
      JButton helpBtn = new JButton( "Help" );
      c.gridy = 2;
      c.anchor = GridBagConstraints.NORTH; // anchor north
      panel.add( helpBtn, c );

      WindowListener wndCloser = new WindowAdapter()
      {
         public void windowClosing(WindowEvent e)
         {
             System.exit(0);
         }
      };
      addWindowListener( wndCloser );

      setVisible( true );
   }

   public static void main( String[] args )
   {
      new ComplaintsDialog( new JFrame() );
   }
}
</pre>
</FONT><FONT FACE="Courier New" SIZE=1>
</FONT><FONT SIZE=2><P><IMG SRC="image292.gif" WIDTH=553 HEIGHT=307></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.12 The Complaints Dialog.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;figure4-12.gif&gt;&gt;</P>
<P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond"><P>4.3.9&#9;Simple Helper class example</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">As we can see from the code above, constructing dialogs with more than a few components easily becomes a very tedious task and reduces source code legibility as well as organization. One way to make the use of </FONT><FONT FACE="Courier" SIZE=2>GridBagLayout</FONT><FONT FACE="AGaramond" SIZE=3> cleaner and easier is to create a helper class that manages all constraints for us, and provides self-explanitory method names and predefined parameters.</P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Below is the source code of a simple helper class we have constructed for this purpose. The method names used are easier to understand and laying out our components using row and column parameters is more intuitive than </FONT><FONT FACE="Courier" SIZE=2>gridx</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>gridy</FONT><FONT FACE="AGaramond" SIZE=3>. Methods implemented in this class are each a variation of one of the following:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">addComponent</FONT><FONT FACE="AGaramond" SIZE=3>: used to add a component that needs to adhere to its preferred size.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">addAnchoredComponent</FONT><FONT FACE="AGaramond" SIZE=3>: used to add a component that needs to be anchored.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">addFilledComponent</FONT><FONT FACE="AGaramond" SIZE=3>: used to add a component that will fill the entire cell space allocated to it.</P>
</FONT><FONT SIZE=2></DIR>

</FONT><FONT FACE="Courier" SIZE=3>
<pre>
import javax.swing.*;
import java.awt.*;

public class GriddedPanel extends JPanel
{
    private GridBagConstraints constraints;
    // define some default constraints values
    private static final int C_HORZ = GridBagConstraints.HORIZONTAL;
    private static final int C_NONE = GridBagConstraints.NONE;
    private static final int C_WEST = GridBagConstraints.WEST;
    private static final int C_WIDTH = 1;
    private static final int C_HEIGHT = 1;


    // Creates a grid bag layout panel using a default insets constraints.

    public GriddedPanel()
    {
        this( new Insets( 2, 2, 2, 2 ) );
    }


    // Creates a grid bag layout panel using the specified insets
    // constraints.

    public GriddedPanel( Insets insets )
    {
        super( new GridBagLayout() );
        // creates the constraints object and set the desired
        // default values
        constraints = new GridBagConstraints();
        constraints.anchor = GridBagConstraints.WEST;
        constraints.insets = insets;
    }


    // Adds the component to the specified row and col.

    public void addComponent( JComponent component, int row, int col )
    {
        addComponent( component, row, col, C_WIDTH,
                      C_HEIGHT, C_WEST, C_NONE );
    }


    // Adds the component to the specified row and col that spans across
    // a specified number of columns and rows.

    public void addComponent( JComponent component, int row, int col,
                              int width, int height )
    {
       addComponent( component, row, col, width, height, C_WEST, C_NONE );
    }


    // Adds the component to the specified row and col that anchors at
    // the specified position.

    public void addAnchoredComponent( JComponent component, int row,
                                      int col, int anchor )
    {
       addComponent( component, row, col, C_WIDTH, C_HEIGHT, anchor, C_NONE );
    }


    // Adds the component to the specified row and col that spans across
    // a specified number of columns and rows that anchors at the specified
    // position.

    public void addAnchoredComponent( JComponent component, int row, int col,
                                      int width, int height, int anchor )
    {
       addComponent( component, row, col, width, height, anchor, C_NONE );
    }


    // Adds the component to the specified row and col filling the column
    // horizontally.

    public void addFilledComponent( JComponent component, int row, int col )
    {
        addComponent( component, row, col, C_WIDTH, C_HEIGHT, C_WEST, C_HORZ );
    }

    // Adds the component to the specified row and col with the specified
    // filling direction.

    public void addFilledComponent( JComponent component, int row, int col,
                                    int fill )
    {
       addComponent( component, row, col, C_WIDTH, C_HEIGHT, C_WEST, fill );
    }


    // Adds the component to the specified row and col that spans across
    // a specified number of columns and rows with the specified filling
    // direction.


    public void addFilledComponent( JComponent component, int row, int col,
                                    int width, int height, int fill )
    {
       addComponent( component, row, col, width, height, C_WEST, fill );
    }
    
    
    // Adds the component to the specified row and col that spans across
    // a specified number of columns and rows with the specified filling
    // direction and an anchoring position.
    
    public void addComponent( JComponent component, int row, int col,
                              int width, int height, int anchor, int fill )
    {
       // sets the constraints object
       constraints.gridx = col;
       constraints.gridy = row;
       constraints.gridwidth = width;
       constraints.gridheight = height;
       constraints.anchor = anchor;
       double weightx = 0.0;
       double weighty = 0.0;
       
       // only use the extra horizontal or vertical spaces if the component
       // spans more than one column or/and row.
       if( width > 1 )
       {
          weightx = 1.0;
       }
       if( height > 1 )
       {   
          weighty = 1.0;
       }

       switch( fill )
       {
           case GridBagConstraints.HORIZONTAL:
               constraints.weightx = weightx;
               constraints.weighty = 0.0;
               break;
           case GridBagConstraints.VERTICAL:
               constraints.weighty = weighty;
               constraints.weightx = 0.0;
               break;
           case GridBagConstraints.BOTH:
               constraints.weightx = weightx;
               constraints.weighty = weighty;
               break;
           case GridBagConstraints.NONE:
               constraints.weightx = 0.0;
               constraints.weighty = 0.0;
               break;
           default:
               break;
       }
       constraints.fill = fill;
       add( component, constraints );
    }
}
</pre>
</FONT><FONT SIZE=1>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Below is the source code used to construct the same complaints dialog as above, using our helper class methods instead of manipulating the constraints directly. Note that the size of the code has been reduced and the readability improved. Also note that we add components starting at row 1 and column 1, rather than row 0 and column 0, as this is the most common numbering scheme for rows and columns (see figure 4.11). </P>
</FONT><FONT SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;

public class ComplaintsDialog2 extends JDialog
{
   public ComplaintsDialog2( JFrame frame )
   {
      super( frame, true );
      setTitle( "Simple Complaints Dialog" );
      setSize( 500, 300 );

      // Creates the helper class panel to hold all my components
      GriddedPanel panel = new GriddedPanel();
      // give the panel a border gap of 5 pixels
      panel.setBorder( new EmptyBorder( new Insets( 5, 5, 5, 5 ) ) );
      getContentPane().add( BorderLayout.CENTER, panel );
      
      // Define preferred sizes for my entry fields
      Dimension shortField = new Dimension( 40, 20 );
      Dimension mediumField = new Dimension( 120, 20 );
      Dimension longField = new Dimension( 240, 20 );
      Dimension hugeField = new Dimension( 240, 80 );

      // Spacing between the label and the field
      EmptyBorder border = new EmptyBorder( new Insets( 0, 0, 0, 10 ) );
      EmptyBorder border1 = new EmptyBorder( new Insets( 0, 20, 0, 10 ) );

      // Short description label and field
      JLabel lbl1 = new JLabel( "Short Description" );
      lbl1.setBorder( border ); // add some space on the right
      panel.addComponent( lbl1, 1, 1 );
      JTextField txt1 = new JTextField();
      txt1.setPreferredSize( longField );
      panel.addFilledComponent( txt1, 1, 2, 3, 1, GridBagConstraints.HORIZONTAL );

      // Description label and field
      JLabel lbl2 = new JLabel( "Description" );
      lbl2.setBorder( border );
      panel.addComponent( lbl2, 2, 1 );
      JTextArea area1 = new JTextArea();
      JScrollPane scroll = new JScrollPane( area1 );
      scroll.setPreferredSize( hugeField );
      panel.addFilledComponent( scroll, 2, 2, 3, 2, GridBagConstraints.BOTH );

      // Severity label and combo box
      JLabel lbl3 = new JLabel( "Severity" );
      lbl3.setBorder( border );
      panel.addComponent( lbl3, 4, 1 );
      JComboBox combo3 = new JComboBox();
      combo3.addItem( "A" );
      combo3.addItem( "B" );
      combo3.addItem( "C" );
      combo3.addItem( "D" );
      combo3.addItem( "E" );
      combo3.setPreferredSize( shortField );
      panel.addComponent( combo3, 4, 2 );

      // Priority label and combo box
      JLabel lbl4 = new JLabel( "Priority" );
      lbl4.setBorder( border1 );
      panel.addComponent( lbl4, 4, 3 );
      JComboBox combo4 = new JComboBox();
      combo4.addItem( "1" );
      combo4.addItem( "2" );
      combo4.addItem( "3" );
      combo4.addItem( "4" );
      combo4.addItem( "5" );
      combo4.setPreferredSize( shortField );
      panel.addComponent( combo4, 4, 4 );

      // Name label and text field
      JLabel lbl5 = new JLabel( "Name" );
      lbl5.setBorder( border );
      panel.addComponent( lbl5, 5, 1 );
      JTextField txt5 = new JTextField();
      txt5.setPreferredSize( longField );
      panel.addComponent( txt5, 5, 2, 3, 1 );

      // Telephone label and text field
      JLabel lbl6 = new JLabel( "Telephone" );
      lbl6.setBorder( border );
      panel.addComponent( lbl6, 6, 1 );
      JTextField txt6 = new JTextField();
      txt6.setPreferredSize( mediumField );
      panel.addComponent( txt6, 6, 2, 3, 1 );

      // Sex label and radio button
      JLabel lbl7 = new JLabel( "Sex" );
      lbl7.setBorder( border );
      panel.addComponent( lbl7, 7, 1 );
      JPanel radioPanel = new JPanel();
      // Creates a FlowLayout layout JPanel with 5 pixel of horizontal gaps
      // and no vertical gaps
      radioPanel.setLayout( new FlowLayout( FlowLayout.LEFT, 5, 0 ) );
      ButtonGroup group = new ButtonGroup();
      JRadioButton radio1 = new JRadioButton( "Male" );
      radio1.setSelected( true );
      group.add( radio1 );
      JRadioButton radio2 = new JRadioButton( "Female" );
      group.add( radio2 );
      radioPanel.add( radio1 );
      radioPanel.add( radio2 );
      panel.addComponent( radioPanel, 7, 2, 3, 1 );

      // ID Number label and text field
      JLabel lbl8 = new JLabel( "ID Number" );
      lbl8.setBorder( border );
      panel.addComponent( lbl8, 8, 1 );
      JTextField txt8 = new JTextField();
      txt8.setPreferredSize( mediumField );
      panel.addComponent( txt8, 8, 2, 3, 1 );

      // Okay button
      JButton submitBtn = new JButton( "Submit" );
      panel.addFilledComponent( submitBtn, 1, 5 );

      // Cancel button
      JButton cancelBtn = new JButton( "Cancel" );
      panel.addFilledComponent( cancelBtn, 2, 5 );

      // Help button
      JButton helpBtn = new JButton( "Help" );
      panel.addComponent( helpBtn, 3, 5, 1, 1, GridBagConstraints.NORTH,
                          GridBagConstraints.HORIZONTAL );


      WindowListener wndCloser = new WindowAdapter()
      {
         public void windowClosing(WindowEvent e)
         {
             System.exit(0);
         }
      };
      addWindowListener( wndCloser );

      setVisible( true );
   }

   public static void main( String[] args )
   {
      new ComplaintsDialog2( new JFrame() );
   }
}
</pre>

</FONT><FONT FACE="Courier New" SIZE=1><P>&nbsp;</P>
</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.4&#9;Choosing the right layout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this section we’ll show how to choose the right combination of layouts and intermediate containers to satisfy a pre-defined program specification. Consider a sample application which makes airplane ticket reservations. The following specification describes which components should be included and how they should be placed in the application frame:</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

<P ALIGN="JUSTIFY">1. A text field labeled "Date:", a combo box labeled "From:", and a combo box labeled "To:" must reside at the top of frame. Labels must be placed to the left side of their corresponding component. The text field and combo boxes must be of equal size, reside in a column, and occupy all available width.</P>
<P ALIGN="JUSTIFY">2. A group of radio buttons titled "Options" must reside in the top right corner of the frame. This group must include "First class", "Business", and "Coach" radio buttons.</P>
<P ALIGN="JUSTIFY">3. A list component titled "Available Flights" must occupy the central part of the frame and it should grow or shrink when the size of the frame changes.</P>
<P ALIGN="JUSTIFY">4. Three buttons titled "Search", "Purchase", and "Exit" must reside at the bottom of the frame. They must form a row, have equal sizes, and be center-aligned.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Our </FONT><FONT FACE="Courier" SIZE=2>FlightReservation</FONT><FONT FACE="AGaramond" SIZE=3> example demonstrates how to fulfill these requirements. We do not process any input from these controls and do not attempt to put them to work; we just display them on the screen in the correct position and size . (Three variants are shown to accomplish the layout of the text fields, combo boxes, and their associated labels. Two are commented out, and a discussion of each is given below.)</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: A similar control placement assignment is part of Sun’s Java Developer certification exam.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

</FONT><FONT SIZE=2><P><IMG SRC="image186.gif" WIDTH=400 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.13 FlightReservation layout - Variant 1</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-13.gif&gt;&gt;</P>

<P><IMG SRC="image348.gif" WIDTH=400 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.14 FlightReservation layout - Variant 2</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-14.gif&gt;&gt;</P>

<P><IMG SRC="image187.gif" WIDTH=400 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.15 FlightReservation layout - Variant 3</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-15.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: FlightReservation.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\3</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

public class FlightReservation extends JFrame 
{
  public FlightReservation() {
    super("Flight Reservation Dialog");
    setSize(400, 300);

    JPanel p1 = new JPanel();
    p1.setLayout(new BoxLayout(p1, BoxLayout.X_AXIS));

    JPanel p1r = new JPanel();
    p1r.setBorder(new EmptyBorder(10, 10, 10, 10));

    // Variant 1
    p1r.setLayout(new GridLayout(3, 2, 5, 5));

    p1r.add(new JLabel("Date:"));
    p1r.add(new JTextField());
        
    p1r.add(new JLabel("From:"));
    JComboBox cb1 = new JComboBox();
    cb1.addItem("New York");
    p1r.add(cb1);

    p1r.add(new JLabel("To:"));
    JComboBox cb2 = new JComboBox();
    cb2.addItem("London");
    p1r.add(cb2);

    p1.add(p1r);

    ///////////////
    // Variant 2 //
    ///////////////
    // JPanel p11 = new JPanel();
    // p11.setLayout(new BoxLayout(p11, BoxLayout.Y_AXIS));
    // 
    // JPanel p12 = new JPanel();
    // p12.setLayout(new BoxLayout(p12, BoxLayout.Y_AXIS));
    //
    // p11.add(new JLabel("Date:"));
    // p12.add(new JTextField());
    //
    // p11.add(new JLabel("From:"));
    // JComboBox cb1 = new JComboBox();
    // cb1.addItem("New York");
    // p12.add(cb1);
    //   
    // p11.add(new JLabel("To:"));
    // JComboBox cb2 = new JComboBox();
    // cb2.addItem("London");
    // p12.add(cb2);
    //
    // p1.add(p11);
    // p1.add(Box.createHorizontalStrut(10));
    // p1.add(p12);
       
    ///////////////
    // Variant 3 //
    ///////////////
    // JPanel p11 = new JPanel();
    // p11.setLayout(new GridLayout(3, 1, 5, 5));
    // 
    // JPanel p12 = new JPanel();
    // p12.setLayout(new GridLayout(3, 1, 5, 5));
    //
    // p11.add(new JLabel("Date:"));
    // p12.add(new JTextField());
    // 
    // p11.add(new JLabel("From:"));
    // JComboBox cb1 = new JComboBox();
    // cb1.addItem("New York");
    // p12.add(cb1);
    // 
    // p11.add(new JLabel("To:"));
    // JComboBox cb2 = new JComboBox();
    // cb2.addItem("London");
    // p12.add(cb2);
    // 
    // p1r.setLayout(new BorderLayout());
    // p1r.add(p11, BorderLayout.WEST);
    // p1r.add(p12, BorderLayout.CENTER);
    // p1.add(p1r);

    JPanel p3 = new JPanel();
    p3.setLayout(new BoxLayout(p3, BoxLayout.Y_AXIS));
    p3.setBorder(new TitledBorder(new EtchedBorder(), 
      "Options"));

    ButtonGroup group = new ButtonGroup();
    JRadioButton r1 = new JRadioButton("First class");
    group.add(r1);
    p3.add(r1);

    JRadioButton r2 = new JRadioButton("Business");
    group.add(r2);
    p3.add(r2);

    JRadioButton r3 = new JRadioButton("Coach");
    group.add(r3);
    p3.add(r3);

    p1.add(p3);
      
    getContentPane().add(p1, BorderLayout.NORTH);

    JPanel p2 = new JPanel(new BorderLayout());
    p2.setBorder(new TitledBorder(new EtchedBorder(), 
      "Available Flights"));
    JList list = new JList();
    JScrollPane ps = new JScrollPane(list);
    p2.add(ps, BorderLayout.CENTER);
    getContentPane().add(p2, BorderLayout.CENTER);

    JPanel p4 = new JPanel();
    JPanel p4c = new JPanel();
    p4c.setLayout(new GridLayout(1, 3, 5, 5));
        
    JButton b1 = new JButton("Search");
    p4c.add(b1);
        
    JButton b2 = new JButton("Purchase");
    p4c.add(b2);
        
    JButton b3 = new JButton("Exit");
    p4c.add(b3);

    p4.add(p4c);
    getContentPane().add(p4, BorderLayout.SOUTH);

    WindowListener wndCloser = new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    };
    addWindowListener(wndCloser);
        
    setVisible(true);
  }

  public static void main(String argv[]) {
    new FlightReservation();
  }
}
</pre>
</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Understanding the Code</P>
</B></FONT><I><FONT FACE="AGaramond"><P>Class FlightReservation</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The constructor of the </FONT><FONT FACE="Courier" SIZE=2>FlightReservation </FONT><FONT FACE="AGaramond" SIZE=3>class creates and positions all necessary GUI components. We will explain step by step how we've chosen intermediate containers and their layouts to fulfill the requirements listed at the beginning of this section.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The frame (more specifically it's </FONT><FONT FACE="Courier New" SIZE=2>contentPane</FONT><FONT FACE="AGaramond" SIZE=3>) is managed by a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3> by default. A text field, and the combo boxes and associated labels are added in a separate container to the north along with the radio buttons; push buttons in the south; and the list component is placed in the center. This guarantees that top and bottom (north and south) containers will receive their natural height, and that the central component (the list) will occupy all remaining space.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The intermediate container, </FONT><FONT FACE="Courier" SIZE=2>JPanel p1r</FONT><FONT FACE="AGaramond" SIZE=3>, holds the text field, combo boxes, and their associated labels and is placed in panel </FONT><FONT FACE="Courier" SIZE=2>p1</FONT><FONT FACE="AGaramond" SIZE=3> which is managed by a horizontally aligned </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3>. The </FONT><FONT FACE="Courier" SIZE=2>p1r</FONT><FONT FACE="AGaramond" SIZE=3> panel is surrounded by an </FONT><FONT FACE="Courier New" SIZE=3>EmptyBorder</FONT><FONT FACE="AGaramond" SIZE=3> to provide typical surrounding white space. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">This example offers three variants of managing </FONT><FONT FACE="Courier" SIZE=2>p1r</FONT><FONT FACE="AGaramond" SIZE=3> and its six child components. The first variant uses a 3x2 </FONT><FONT FACE="Courier" SIZE=2>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3>. This places labels and boxes in two columns opposite one another. Since this panel resides in the north region of the </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>, it receives its natural (preferable) height. In the horizontal direction this layout works satisfactory: it resizes boxes and labels to occupy all available space. The only remaining problem is that </FONT><FONT FACE="Courier New" SIZE=3>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> assigns too much space to the labels (see figure 4.13). We do not need to make labels equal in size to their corresponding input boxes. We need only allow them to occupy their preferred width.</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">The second variant uses two vertical </FONT><FONT FACE="Courier New" SIZE=3>BoxLayouts</FONT><FONT FACE="AGaramond" SIZE=3> so one can hold labels and the other can hold the corresponding text field and combo boxes. If you try recompiling and running the code with this variant you'll find that the labels now occupy only their necessary width, and the boxes occupy all remaining space (see figure 4.14). This is good, but another problem arises: now the labels are aligned exactly opposite with their corresponding components. Instead, they are shifted in the vertical direction!</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The third variant offers the best solution. It places the labels and their corresponding components in two columns, but uses 3x1</FONT><FONT FACE="Courier" SIZE=2> GridLayout</FONT><FONT FACE="AGaramond" SIZE=3>s instead of </FONT><FONT FACE="Courier New" SIZE=3>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3>s. This places all components evenly in the vertical direction. To provide only the minimum width to the labels (the first column) and assign all remaining space to the boxes (the second column) we place these two containers into another intermediate container managed by a </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>: labels in the west, and corresponding components in the center. This solves our problem (see figure 4.15). The only downside to this solution is that it requires the construction of three intermediate containers with different layouts. In the next section we’ll show how to build a custom layout manag!
er that simplifies this relatively common layout task.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Now let's return to the remaining components. A group of </FONT><FONT FACE="Courier" SIZE=2>JRadioButtons</FONT><FONT FACE="AGaramond" SIZE=3> seems to be the simplest part of our design. They're placed into an intermediate container, </FONT><FONT FACE="Courier" SIZE=2>JPanel p3</FONT><FONT FACE="AGaramond" SIZE=3>, with a </FONT><FONT FACE="Courier" SIZE=2>TitledBorder</FONT><FONT FACE="AGaramond" SIZE=3> containing the required title: "Options". A vertical </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3> is used to place these components in a column and a </FONT><FONT FACE="Courier" SIZE=2>ButtonGroup </FONT><FONT FACE="AGaramond" SIZE=3>is used to coordinate their selection. This container is then added to panel </FONT><FONT FACE="Courier" SIZE=2>p1</FONT><FONT FACE="AGaramond" SIZE=3> (managed by a horizontal </FONT><FONT FACE="Courier" SIZE=2>BoxLayout</FONT><FONT FACE="AGaramond" SIZE=3>) to sit on the eastern side of!
 panel </FONT><FONT FACE="Courier" SIZE=2>p1r</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>JList</FONT><FONT FACE="AGaramond" SIZE=3> component is added to a </FONT><FONT FACE="Courier" SIZE=2>JScrollPane</FONT><FONT FACE="AGaramond" SIZE=3> to provide scrolling capabilities. It is then placed in an intermediate container, </FONT><FONT FACE="Courier" SIZE=2>JPanel p2</FONT><FONT FACE="AGaramond" SIZE=3>, with a </FONT><FONT FACE="Courier" SIZE=2>TitledBorder</FONT><FONT FACE="AGaramond" SIZE=3> containing the required title "Available Flights".</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: We do not want to assign a </FONT><FONT FACE="Courier" SIZE=2>TitledBorder</FONT><FONT FACE="AGaramond" SIZE=2> to the </FONT><FONT FACE="Courier" SIZE=2>JScrollPane</FONT><FONT FACE="AGaramond" SIZE=2> itself because this would substitute its natural border, resulting in a quite awkward scroll pane view. So we nest the </FONT><FONT FACE="Courier" SIZE=2>JScrollPane</FONT><FONT FACE="AGaramond" SIZE=2> in its own </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=2> with a </FONT><FONT FACE="Courier" SIZE=2>TitledBorder</FONT><FONT FACE="AGaramond" SIZE=2>.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Since the list grows and shrinks when the frame is resized and the group of radio buttons (residing to the right of the list) must occupy only the necessary width, it only makes sense to placed it in the center of the </FONT><FONT FACE="Courier New" SIZE=3>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>. We can then use the south region for the three remaining buttons.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Since all three buttons must be equal in size, they're added to a </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>,</FONT><FONT FACE="Courier" SIZE=2> p4c</FONT><FONT FACE="AGaramond" SIZE=3>, with a 1x3 </FONT><FONT FACE="Courier" SIZE=2>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3>. However, this </FONT><FONT FACE="Courier" SIZE=2>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> will occupy all available width (fortunately it's limited in the vertical direction by parent </FONT><FONT FACE="Courier" SIZE=2>BorderLayout</FONT><FONT FACE="AGaramond" SIZE=3>). This is not exactly the behavior we are looking for. To resolve this problem we use another intermediate container, </FONT><FONT FACE="Courier" SIZE=2>JPanel p4</FONT><FONT FACE="AGaramond" SIZE=3>, with a </FONT><FONT FACE="Courier" SIZE=2>FlowLayout</FONT><FONT FACE="AGaramond" SIZE=3>. This sizes the only added component, </FONT><FONT FACE="Courier" SIZE=2>p4c</FONT><F!
ONT FACE="AGaramond" SIZE=3>, based on its preferred size and centers it both vertically and horizontally.</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Running the Code</P>
<P ALIGN="JUSTIFY"></P>
</B><P ALIGN="JUSTIFY">Figure 4.13, 4.14, and 4.15 show the resulting placement of our components in the parent frame using the first, second, and third variants described above. Note that variant 3’s placement satisfies our specification. Note also that components are resized as expected when the frame container is resized. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">When the frame is stretched in the horizontal direction, the text field, combo boxes, and list component consume additional space, and the buttons at the bottom are shifted to the center. When the frame is stretched in the vertical direction, the list component and the panel containing the radio buttons consume all additional space and all other components remain unchanged.</P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">UI Guideline : Harnessing the Power of Java Layouts </P>
</B><P ALIGN="JUSTIFY">Layout managers are powerful but awkward to use. In order to maximize the effectiveness of the visual communication we must make extra effort with the code. Making a bad choice of layout or making sloppy use of default settings may lead to designs which look poor or communicate badly.</P>
<P ALIGN="JUSTIFY">In this example, we have shown three alternative designs for the same basic specification. Each exhibit pros and cons and highlight the design trade-offs which can be made, reflecting the principles which were discussed in chapter 2.</P>
<B><I><P ALIGN="JUSTIFY">A sense of balance</I>. </P>
</B><P ALIGN="JUSTIFY">This occurs when there is sufficient white space used to balance the size of the components. An unbalanced panel can be fixed by bordering the components with a compound border including an empty border.</P>
<B><I><P ALIGN="JUSTIFY">A sense of scale</P>
</B></I><P ALIGN="JUSTIFY">Balance can be further affected by the extraordinary size of some components such as the combo boxes shown in Fig 4.14. The combo boxes are bit too big for the purpose intended. This affects the sense of scale as well as the balance of the design. Its important to size comboboxes appropriately. Layout managers have a tendency to stretch components to be larger than might be desirable.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.5&#9;Custom layout manager: part I -Label/field pairs</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This example is intended to familiarize you with developing custom layouts. You may find this knowledge useful in cases where the traditional layouts are not satisfactory or are too complex. In developing large scale applications it is often more convenient to build custom layouts, such as the one we develop here, to help with specific tasks. This often provides increased consistency, and may save a significant amount of coding in the long run.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The example in the previous section highlighted a problem: what is the best way to lay out input field components (e.g. text fields, combo boxes, etc.) and their corresponding labels? We have seen that it can be done using a combination of several intermediate containers and layouts. This section shows how we can simplify the process by using a custom-built layout manager. The goal is to construct a layout manager that knows how to lay out labels and their associated input fields in two columns, allocating the minimum required space to the column containing the labels, and using the remainder for the column containing the input fields.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">First we need to clearly state our design goals for this layout manager, which we will appropriately call </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>. It is always a good idea to reserve plenty of time for thinking about your design. Well-defined design specifications can save you tremendous amounts of time in the long run, and can help pinpoint flaws and oversights before they arise in the code. (We strongly recommend that adopting a design specification stage become part of your development regimin.)</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> specification:</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

<P ALIGN="JUSTIFY">1. This layout manager will be applied to a container that has all the necessary components added to it in the following order: </FONT><FONT FACE="Courier" SIZE=2>label1</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>field1</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>label2</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>field2</FONT><FONT FACE="AGaramond" SIZE=3>, etc. (Note that when components are added to a container they are tracked in a list. If no index is specified when a component is added to a container it will be added to the end of the list using the next available index.  As usual this indexing starts from 0. A component can be retreived by index using the </FONT><FONT FACE="Courier" SIZE=2>getComponent(int index)</FONT><FONT FACE="AGaramond" SIZE=3> method.) If the labels and fields are added correctly, all even numbered components in the container will correspond!
 to labels, and all odd numbered components will correspond to input fields.</P>
<P ALIGN="JUSTIFY">2. The components must be placed in pairs forming two vertical columns.</P>
<P ALIGN="JUSTIFY">3. Components making up each pair must be placed opposite one another (i.e. </FONT><FONT FACE="Courier" SIZE=2>label1</FONT><FONT FACE="AGaramond" SIZE=3> </FONT><FONT FACE="Courier" SIZE=2>field1</FONT><FONT FACE="AGaramond" SIZE=3>). Each pair’s label and field must receive the same preferable height, which should be the preferred height of the field. </P>
<P ALIGN="JUSTIFY">4. Each left component (labels) must receive the same width. This width should be the maximum preferable width of all left components.</P>
<P ALIGN="JUSTIFY">5. Each right component (input fields) must also receive the same width. This width should occupy all the remaining space left over from that taken by the left components column.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The code below introduces our custom </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> class which satisfies the above design specification. This class is placed in its own package named </FONT><FONT FACE="Courier" SIZE=2>dl</FONT><FONT FACE="AGaramond" SIZE=3>. The code used to construct the GUI is alsmot identical to that of the previous example. However, we now revert back to variant 1 and use an instance of </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> instead of a </FONT><FONT FACE="Courier" SIZE=2>GridLayout</FONT><FONT FACE="AGaramond" SIZE=3> to manage the </FONT><FONT FACE="Courier" SIZE=2>p1r</FONT><FONT FACE="AGaramond" SIZE=3> </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image188.gif" WIDTH=400 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.16 Using DialogLayout - custom layout manager part I</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-16.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: FlightReservation.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\4</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

import dl.*;

public class FlightReservation extends JFrame 
{
  public FlightReservation() {
    super("Flight Reservation Dialog [Custom Layout]");
    setSize(400, 300);

    JPanel p1 = new JPanel();
    p1.setLayout(new BoxLayout(p1, BoxLayout.X_AXIS));

    JPanel p1r = new JPanel();
    p1r.setBorder(new EmptyBorder(10, 10, 10, 10));

    // Variant 1
    p1r.setLayout(new DialogLayout(20, 5));

    p1r.add(new JLabel("Date:"));
    p1r.add(new JTextField());
        
    p1r.add(new JLabel("From:"));
    JComboBox cb1 = new JComboBox();
    cb1.addItem("New York");
    p1r.add(cb1);

    p1r.add(new JLabel("To:"));
    JComboBox cb2 = new JComboBox();
    cb2.addItem("London");
    p1r.add(cb2);

    p1.add(p1r);

    ///////////////
    // Variant 2 //
    ///////////////
    // p11.setLayout(new BoxLayout(p11, BoxLayout.Y_AXIS));
    // 
    // JPanel p12 = new JPanel();
    // p12.setLayout(new BoxLayout(p12, BoxLayout.Y_AXIS));
    //
    // p11.add(new JLabel("Date:"));
    // p12.add(new JTextField());
    //
    // p11.add(new JLabel("From:"));
    // JComboBox cb1 = new JComboBox();
    // cb1.addItem("New York");
    // p12.add(cb1);
    //
    // p11.add(new JLabel("To:"));
    // JComboBox cb2 = new JComboBox();
    // cb2.addItem("London");
    // p12.add(cb2);
    //
    // p1.add(p11);
    // p1.add(Box.createHorizontalStrut(10));
    // p1.add(p12);
       
    ///////////////
    // Variant 3 //
    ///////////////
    // JPanel p11 = new JPanel();
    // p11.setLayout(new GridLayout(3, 1, 5, 5));
    // 
    // JPanel p12 = new JPanel();
    // p12.setLayout(new GridLayout(3, 1, 5, 5));
    //
    // p11.add(new JLabel("Date:"));
    // p12.add(new JTextField());
    // 
    // p11.add(new JLabel("From:"));
    // JComboBox cb1 = new JComboBox();
    // cb1.addItem("New York");
    // p12.add(cb1);
    // 
    // p11.add(new JLabel("To:"));
    // JComboBox cb2 = new JComboBox();
    // cb2.addItem("London");
    // p12.add(cb2);
    // 
    // p1r.setLayout(new BorderLayout());
    // p1r.add(p11, BorderLayout.WEST);
    // p1r.add(p12, BorderLayout.CENTER);
    // p1.add(p1r);

    JPanel p3 = new JPanel();
    p3.setLayout(new BoxLayout(p3, BoxLayout.Y_AXIS));
    p3.setBorder(new TitledBorder(new EtchedBorder(), 
      "Options"));

    ButtonGroup group = new ButtonGroup();
    JRadioButton r1 = new JRadioButton("First class");
    group.add(r1);
    p3.add(r1);

    JRadioButton r2 = new JRadioButton("Business");
    group.add(r2);
    p3.add(r2);

    JRadioButton r3 = new JRadioButton("Coach");
    group.add(r3);
    p3.add(r3);

    p1.add(p3);
      
    getContentPane().add(p1, BorderLayout.NORTH);

    JPanel p2 = new JPanel(new BorderLayout());
    p2.setBorder(new TitledBorder(new EtchedBorder(), 
      "Available Flights"));
    JList list = new JList();
    JScrollPane ps = new JScrollPane(list);
    p2.add(ps, BorderLayout.CENTER);
    getContentPane().add(p2, BorderLayout.CENTER);

    JPanel p4 = new JPanel();
    JPanel p4c = new JPanel();
    p4c.setLayout(new GridLayout(1, 3, 5, 5));
        
    JButton b1 = new JButton("Search");
    p4c.add(b1);
        
    JButton b2 = new JButton("Purchase");
    p4c.add(b2);
        
    JButton b3 = new JButton("Exit");
    p4c.add(b3);

    p4.add(p4c);
    getContentPane().add(p4, BorderLayout.SOUTH);

    WindowListener wndCloser = new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    };
    addWindowListener(wndCloser);
        
    setVisible(true);
  }

  public static void main(String argv[]) {
    new FlightReservation();
  }
}
</pre>

</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">DialogLayout.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\4\dl</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
package dl;

import java.awt.*;
import java.util.*;

public class DialogLayout implements LayoutManager 
{
	protected int m_divider = -1;
	protected int m_hGap = 10;
	protected int m_vGap = 5;

	public DialogLayout() {}

	public DialogLayout(int hGap, int vGap) 
	{
		m_hGap = hGap;
		m_vGap = vGap;
	}

	public void addLayoutComponent(String name, Component comp) {}

	public void removeLayoutComponent(Component comp) {}

	public Dimension preferredLayoutSize(Container parent)
	{
		int divider = getDivider(parent);
		
		int w = 0;
		int h = 0;
		for (int k=1 ; k<parent.getComponentCount(); k+=2) 
		{
			Component comp = parent.getComponent(k);
			Dimension d = comp.getPreferredSize();
			w = Math.max(w, d.width);
			h += d.height + m_vGap;
		}
		h -= m_vGap;

		Insets insets = parent.getInsets();
		return new Dimension(divider+w+insets.left+insets.right, 
			h+insets.top+insets.bottom);
	}

	public Dimension minimumLayoutSize(Container parent)
	{
		return preferredLayoutSize(parent);
	}

	public void layoutContainer(Container parent)
	{
		int divider = getDivider(parent);
		
		Insets insets = parent.getInsets();
		int w = parent.getWidth() - insets.left - insets.right - divider;
		int x = insets.left;
		int y = insets.top;

		for (int k = 1 ; k < parent.getComponentCount(); k+=2) 
		{
			Component comp1 = parent.getComponent(k-1);
			Component comp2 = parent.getComponent(k);
			Dimension d = comp2.getPreferredSize();
			
			comp1.setBounds(x, y, divider-m_hGap, d.height);
			comp2.setBounds(x+divider, y, w, d.height);
			y += d.height + m_vGap;
		}
	}

	public int getHGap()
	{
		return m_hGap;
	}

	public int getVGap()
	{
		return m_vGap;
	}

	public void setDivider(int divider)
	{
		if (divider > 0)
			m_divider = divider;
	}
	
	public int getDivider()
	{
		return m_divider;
	}

	protected int getDivider(Container parent)
	{
		if (m_divider > 0)
			return m_divider;

		int divider = 0;
		for (int k=0 ; k < parent.getComponentCount(); k += 2) 
		{
			Component comp = parent.getComponent(k);
			Dimension d = comp.getPreferredSize();
			divider = Math.max(divider, d.width);
		}
		divider += m_hGap;
		return divider;
	}

	public String toString() 
	{
		return getClass().getName() + "[hgap=" + m_hGap + ",vgap=" 
			+ m_vGap + ",divider=" + m_divider + "]";
	}
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Understanding the Code</P>
</B></FONT><I><FONT FACE="AGaramond"><P>Class FlightReservation</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class now imports package </FONT><FONT FACE="Courier" SIZE=2>dl</FONT><FONT FACE="AGaramond" SIZE=3> and sets that layout for </FONT><FONT FACE="Courier" SIZE=2>JPanel p1r</FONT><FONT FACE="AGaramond" SIZE=3> (which contains the labels and input fields). Package </FONT><FONT FACE="Courier" SIZE=2>dl</FONT><FONT FACE="AGaramond" SIZE=3> contains our custom layout, </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><I><FONT FACE="AGaramond"><P>Class DialogLayout</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class implements the </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> interface to serve as our custom layout manager. Three instance variables are needed:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int m_divider</FONT><FONT FACE="AGaramond" SIZE=3>: width of the left components. This can be calculated or set to some mandatory value.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int m_hGap</FONT><FONT FACE="AGaramond" SIZE=3>: horizontal gap between components.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int m_vGap</FONT><FONT FACE="AGaramond" SIZE=3>: vertical gap between components.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Two constructors are available to create a </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>: a no-argument default constructor and a constructor which takes horizontal and vertical gap sizes as parameters. The rest of the code implements methods from the </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> interface. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Methods </FONT><FONT FACE="Courier" SIZE=2>addLayoutComponent()</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>removeLayoutComponent()</FONT><FONT FACE="AGaramond" SIZE=3> are not used in this class and receive empty implementations. We do not support an internal collection of the components to be managed. Rather, we refer to these component directly from the container which is being managed.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The purpose of the </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize()</FONT><FONT FACE="AGaramond" SIZE=3> method is to return the preferable container size required to lay out the components in the given container according to the rules used in this layout. In our implementation we first determine the </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> size (the width of the first column plus the horizontal gap, </FONT><FONT FACE="Courier" SIZE=2>m_hGap</FONT><FONT FACE="AGaramond" SIZE=3>) by calling the </FONT><FONT FACE="Courier" SIZE=2>getDivider()</FONT><FONT FACE="AGaramond" SIZE=3> custom method. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P>        int divider = getDivider(parent);</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">If no positive divider size has been specified using the </FONT><FONT FACE="Courier" SIZE=2>setDivider()</FONT><FONT FACE="AGaramond" SIZE=3> method (see below), the </FONT><FONT FACE="Courier" SIZE=2>getDivider() </FONT><FONT FACE="AGaramond" SIZE=3>method looks at each even indexed component in the container (this should be all the labels if the components were added to the container in the correct order) and returns the largest preferred width found plus the horizontal gap value, </FONT><FONT FACE="Courier" SIZE=2>m_hGap</FONT><FONT FACE="AGaramond" SIZE=3> (which defaults to 10 if the default constructor is used):</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
    if (m_divider &gt; 0)
      return m_divider;

    int divider = 0;
    for (int k=0 ; k&lt;parent.getComponentCount(); k+=2) {
      Component comp = parent.getComponent(k);
      Dimension d = comp.getPreferredSize();
      divider = Math.max(divider, d.width);
    }
    divider += m_hGap;
    return divider;
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Now, back to the </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize()</FONT><FONT FACE="AGaramond" SIZE=3> method. Once </FONT><FONT FACE="Courier" SIZE=2>getDivider</FONT><FONT FACE="AGaramond" SIZE=3> returns we then examine all components in the container with odd indices (this should be all the input fields) and determine the maximum width, </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3>. This is found by checking the preferred width of each input field. While we are determining this maximum width, we are also continuing to accumulate the height, </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3>, of the whole input fields column by summing each field’s preferred height (not forgetting to add the vertical gap size, </FONT><FONT FACE="Courier" SIZE=2>m_vGap</FONT><FONT FACE="AGaramond" SIZE=3>, each time; notice that </FONT><FONT FACE="Courier" SIZE=2>m_vGap</FONT><FONT FACE="AGaramond" SIZE=3> is sub!
tracted from the height at the end because there is no vertical gap for the last field). (Remember that </FONT><FONT FACE="Courier" SIZE=2>m_vGap</FONT><FONT FACE="AGaramond" SIZE=3> defaults to 5 if the the default constructor is used.)</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
    int w = 0;
    int h = 0;
    for (int k=1 ; k&lt;parent.getComponentCount(); k+=2) {
      Component comp = parent.getComponent(k);
      Dimension d = comp.getPreferredSize();
      w = Math.max(w, d.width);
      h += d.height + m_vGap;
    }
    h -= m_vGap;
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">So at this point we have determined the width of the labels column (including the space between columns), </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3>, and the preferred hieght, </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3>, and width, </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3>, of the input fields column. So </FONT><FONT FACE="Courier" SIZE=2>divider+w</FONT><FONT FACE="AGaramond" SIZE=3> gives us the preferred width of the container, and h gives us the total preferred height. Not forgetting to take into account any </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> that might have been applied to the container, we can now return the correct preferred size:</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
    Insets insets = parent.getInsets();
    return new Dimension(divider+w+insets.left+insets.right, 
                         h+insets.top+insets.bottom);
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The purpose of the </FONT><FONT FACE="Courier" SIZE=2>minimumLayoutSize()</FONT><FONT FACE="AGaramond" SIZE=3> method is to return the minimum size required to lay out the components in the given container according to the rules used in this layout. We return </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize()</FONT><FONT FACE="AGaramond" SIZE=3> in this method, because we chose not to make a distinction between minimum and preferable sizes (to avoid over-complication).</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">layoutContainer()</FONT><FONT FACE="AGaramond" SIZE=3> is the most important method in any layout manager. This method is responsible for actually assigning the bounds (position and size) for the components in the container being managed. First it determines the size of the </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> (as discussed above), which represents the width of the labels column plus an additional </FONT><FONT FACE="Courier" SIZE=2>m_hGap</FONT><FONT FACE="AGaramond" SIZE=3>. From this it determines the width, </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3>, of the fields column by subtracting the container's left and right insets and </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> from the width of the whole container:</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
    int divider = getDivider(parent);
        
    Insets insets = parent.getInsets();
    int w = parent.getWidth() - insets.left - insets.right - divider;
    int x = insets.left;
    int y = insets.top;
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Now all pairs of components are examined in turn. Each left component receives a width equal to </FONT><FONT FACE="Courier" SIZE=2>divider-m_hGap</FONT><FONT FACE="AGaramond" SIZE=3>, and all right components receive a width of </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3>. Both left and right components receive the preferred height of the right component (which should be the input field). </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Coordinates of the left components are assigned starting with the container’s </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>x</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>y</FONT><FONT FACE="AGaramond" SIZE=3>. Notice that </FONT><FONT FACE="Courier" SIZE=2>y</FONT><FONT FACE="AGaramond" SIZE=3> is continually incremented based on the preferred height of each right component plus the vertical gap, </FONT><FONT FACE="Courier" SIZE=2>m_vGap</FONT><FONT FACE="AGaramond" SIZE=3>. The right components are assigned a y-coordinate identical to their left component counterpart, and an x-coordinate of </FONT><FONT FACE="Courier" SIZE=2>x+divider</FONT><FONT FACE="AGaramond" SIZE=3> (remember that </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> includes the horizontal gap, </FONT><FONT FACE="Courier" SIZE=2>m_hGap</FONT><FONT FACE="AGar!
amond" SIZE=3>):</P>
</FONT><FONT FACE="Courier" SIZE=2>
</FONT><FONT FACE="Courier" SIZE=3><P>
<pre>
    for (int k=1 ; k&lt;parent.getComponentCount(); k+=2) {
      Component comp1 = parent.getComponent(k-1);
      Component comp2 = parent.getComponent(k);
      Dimension d = comp2.getPreferredSize();
            
      comp1.setBounds(x, y, divider-m_hGap, d.height);
      comp2.setBounds(x+divider, y, w, d.height);
      y += d.height + m_vGap;
    }
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>setDivider()</FONT><FONT FACE="AGaramond" SIZE=3> allows us to manually set the size of the left column. The </FONT><FONT FACE="Courier" SIZE=2>int</FONT><FONT FACE="AGaramond" SIZE=3> value passed as parameter gets stored in the </FONT><FONT FACE="Courier" SIZE=2>m_divider</FONT><FONT FACE="AGaramond" SIZE=3> instance variable. Whenever </FONT><FONT FACE="Courier" SIZE=2>m_divider</FONT><FONT FACE="AGaramond" SIZE=3> is greater than 0 the calculations of </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> size are overridden in the </FONT><FONT FACE="Courier" SIZE=2>getDivider()</FONT><FONT FACE="AGaramond" SIZE=3> method and this value is returned instead.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>toString</FONT><FONT FACE="AGaramond" SIZE=3> method provides typical class name and instance variable information. (It is always a good idea to implement informative </FONT><FONT FACE="Courier" SIZE=2>toString()</FONT><FONT FACE="AGaramond" SIZE=3> methods for each class. Although we don’t consistently do this throughout this text, we feel that production code should always include this functionality.)</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Running the Code</P>
<P ALIGN="JUSTIFY"></P>
</B><P ALIGN="JUSTIFY">At this point you can compile and execute this example. Figure 4.16 shows the sample interface introduced in the previous section now using </FONT><FONT FACE="Courier New" SIZE=3>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> to manage the layout of the input fields (text field and two combo boxes) and their corresponding labels. Note that the labels occupy only their preferred space and do not resize when the frame resizes. The gap between labels and boxes can be managed easily by manually setting the </FONT><FONT FACE="Courier" SIZE=2>divider</FONT><FONT FACE="AGaramond" SIZE=3> size with the </FONT><FONT FACE="Courier" SIZE=2>setDivider()</FONT><FONT FACE="AGaramond" SIZE=3> method (discussed above). The input fields form the right column and occupy all remaining space. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Using </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>, all that is required is adding the labels and input fields in the correct order. We can now use this layout manager each time we encounter label/input field pairs without worrying about intermediate containers. In the next section we build upon </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> to create an even more general layout manager that can be used to create complete dialog interfaces very easily.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><B><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">UI Guideline : Alignment across controls as well as within</B> It is a common mistake in UI Design to achieve good alignment with a control or component but fail to achieve this across a whole screen, panel or dialog. Unfortunately, the architecture of Swing lends itself to this problem. For example, if you have 4 custom components which inherit from a JPanel, each has its own Layout Manager and each is functional in its own right. Then you wish to build a composite component which requires all four. So you create a new Component with a Grid Layout for example, then add each of your 4 components in turn.<BR>
The result can be very messy. The fields within each component will align e.g. 3 radio buttons, but those radio buttons will not align with say 3 TextFields in the next component. Why not? The answer is simple. With Swing, there is no way for the layout manager within each component to negotiate with the others. So alignment cannot be achieved across the components. The answer to this problem is that you must flatten out the design into a single panel, as DialogLayout achieves.</P>
</FONT><FONT SIZE=2><P>&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.6&#9;Custom layout manager: part II - Common interfaces</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In section 4.4 we saw how to choose intermediate containers and appropriate layouts for placing components according to a given specification. This required the use of several intermediate containers and several variants were developed in a search for the best solution. This raises the question: can we somehow just add components one after another to a container which is intelligent enough to lay them out as we would typically expect? The answer is yes, to a certain extent.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">In practice the contents of many Java frames and dialogs are constructed using a scheme similar to the following (we realize that this is a big generalization, but you will see these situations arise in many examples throughout this text):</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

<P ALIGN="JUSTIFY">1. Groups (or panels) of controls are laid out in the vertical direction.</P>
<P ALIGN="JUSTIFY">2. Labels and their corresponding input fields form two-column structures as described in the previous section.</P>
<P ALIGN="JUSTIFY">3. Large components (e.g. lists, tables, text areas, trees, etc.) are usually placed in scroll panes and occupy all space in the horizontal direction.</P>
<P ALIGN="JUSTIFY">4. Groups of buttons, including check boxes and radio buttons, are centered in an intermediate container and laid out in the horizontal direction. (In this example we purposefully avoid the vertical placement of buttons for simplicity.)</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The example in this section shows how to build a layout manager that places components according to this specification. Its purpose is to further demonstrate that layout managers can be built to define template-like pluggable containers. By adhering to intelligently designed specifications, such templates can be developed to help maximize code reuse and increase productivity. Additionally, in the case of large-scale applications, several different interface designers may consider sharing customized layout managers to enforce interface consistency.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The code below introduces our new custom layout manager, </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3>, which builds upon </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>. To provide boundaries between control groupings, we construct a new component, </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3>. </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3> is simply a label containing text and a horizontal bar that is drawn across the container. Both </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3> are added to our </FONT><FONT FACE="Courier" SIZE=2>dl</FONT><FONT FACE="AGaramond" SIZE=3> package. The </FONT><FONT FACE="Courier" SIZE=2>FlightReservation</FONT><FONT FACE="AGaramond" SIZE=!
3> class now shows how to construct the sample airline ticket reservation interface we have been working with since section 4.4 using </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3>. In order to comply with our new layout scheme we are forced to place the radio buttons in a row above the list component. The main things to note are that the code involved to build this interface is done with little regard for the existence of a layout manager, and absolutely no intermediate containers are need to be created!</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: Constructing custom layout managers for use in a single application is not recommended. Only build them when you know that they will be reused again and again to perform common layout tasks. In general, custom layout manager classes belong within custom packages or embedded as inner classes in custom components. They normally do not belong being defined in applications themselves.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

</FONT><FONT SIZE=2><P><IMG SRC="image189.gif" WIDTH=344 HEIGHT=377></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.17 Using DialogLayout2 custom layout manager.</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-17.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: FlightReservation.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\5</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;

import dl.*;

public class FlightReservation extends JFrame 
{
  public FlightReservation() {
    super("Flight Reservation Dialog [Custom Layout - 2]");

    Container c = getContentPane();
    c.setLayout(new DialogLayout2(20, 5));

    c.add(new JLabel("Date:"));
    c.add(new JTextField());
        
    c.add(new JLabel("From:"));
    JComboBox cb1 = new JComboBox();
    cb1.addItem("New York");
    c.add(cb1);

    c.add(new JLabel("To:"));
    JComboBox cb2 = new JComboBox();
    cb2.addItem("London");
    c.add(cb2);

    c.add(new DialogSeparator("Available Flights"));
    JList list = new JList();
    JScrollPane ps = new JScrollPane(list);
    c.add(ps);
        
    c.add(new DialogSeparator("Options"));

    ButtonGroup group = new ButtonGroup();
    JRadioButton r1 = new JRadioButton("First class");
    group.add(r1);
    c.add(r1);

    JRadioButton r2 = new JRadioButton("Business");
    group.add(r2);
    c.add(r2);

    JRadioButton r3 = new JRadioButton("Coach");
    group.add(r3);
    c.add(r3);
        
    c.add(new DialogSeparator());
        
    JButton b1 = new JButton("Search");
    c.add(b1);
        
    JButton b2 = new JButton("Purchase");
    c.add(b2);
        
    JButton b3 = new JButton("Exit");
    c.add(b3);

    WindowListener wndCloser = new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    };
    addWindowListener(wndCloser);
        
    pack();
    setVisible(true);
  }

  public static void main(String argv[]) {
    new FlightReservation();
  }
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The Code: DialogLayout2.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\5\dl</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
package dl;

import java.awt.*;
import java.util.*;

import javax.swing.*;

public class DialogLayout2 
	implements LayoutManager 
{
	protected static final int COMP_TWO_COL = 0;
	protected static final int COMP_BIG = 1;
	protected static final int COMP_BUTTON = 2;

	protected int m_divider = -1;
	protected int m_hGap = 10;
	protected int m_vGap = 5;
	protected Vector m_v = new Vector();

	public DialogLayout2() {}

	public DialogLayout2(int hGap, int vGap) 
	{
		m_hGap = hGap;
		m_vGap = vGap;
	}

	public void addLayoutComponent(String name, Component comp) {}

	public void removeLayoutComponent(Component comp) {}

	public Dimension preferredLayoutSize(Container parent)
	{
		m_v.removeAllElements();
		int w = 0;
		int h = 0;
		int type = -1;

		for (int k=0 ; k < parent.getComponentCount(); k++) 
		{
			Component comp = parent.getComponent(k);
			int newType = getLayoutType(comp);
			if (k == 0)
				type = newType;

			if (type != newType)
			{
				Dimension d = preferredLayoutSize(m_v, type);
				w = Math.max(w, d.width);
				h += d.height + m_vGap;
				m_v.removeAllElements();
				type = newType;
			}

			m_v.addElement(comp);
		}

		Dimension d = preferredLayoutSize(m_v, type);
		w = Math.max(w, d.width);
		h += d.height + m_vGap;

		h -= m_vGap;

		Insets insets = parent.getInsets();
		return new Dimension(w+insets.left+insets.right, 
			h+insets.top+insets.bottom);
	}

	protected Dimension preferredLayoutSize(Vector v, int type)
	{
		int w = 0;
		int h = 0;
		switch (type)
		{
		case COMP_TWO_COL:
			int divider = getDivider(v);
			for (int k=1 ; k < v.size(); k+=2) 
			{
				Component comp = (Component)v.elementAt(k);
				Dimension d = comp.getPreferredSize();
				w = Math.max(w, d.width);
				h += d.height + m_vGap;
			}
			h -= m_vGap;
			return new Dimension(divider+w, h);

		case COMP_BIG:
			for (int k=0 ; k < v.size(); k++) 
			{
				Component comp = (Component)v.elementAt(k);
				Dimension d = comp.getPreferredSize();
				w = Math.max(w, d.width);
				h += d.height + m_vGap;
			}
			h -= m_vGap;
			return new Dimension(w, h);

		case COMP_BUTTON:
			Dimension d = getMaxDimension(v);
			w = d.width + m_hGap;
			h = d.height;
			return new Dimension(w*v.size()-m_hGap, h);
		}
		throw new IllegalArgumentException("Illegal type "+type);
	}

	public Dimension minimumLayoutSize(Container parent)
	{
		return preferredLayoutSize(parent);
	}

	public void layoutContainer(Container parent)
	{
		m_v.removeAllElements();
		int type = -1;

		Insets insets = parent.getInsets();
		int w = parent.getWidth() - insets.left - insets.right;
		int x = insets.left;
		int y = insets.top;

		for (int k=0 ; k < parent.getComponentCount(); k++) 
		{
			Component comp = parent.getComponent(k);
			int newType = getLayoutType(comp);
			if (k == 0)
				type = newType;

			if (type != newType)
			{
				y = layoutComponents(m_v, type, x, y, w);
				m_v.removeAllElements();
				type = newType;
			}
			
			m_v.addElement(comp);
		}

		y = layoutComponents(m_v, type, x, y, w);
		m_v.removeAllElements();
	}

	protected int layoutComponents(Vector v, int type,
		int x, int y, int w)
	{
		switch (type)
		{
		case COMP_TWO_COL:
			int divider = getDivider(v);
			for (int k=1 ; k < v.size(); k+=2) 
			{
				Component comp1 = (Component)v.elementAt(k-1);
				Component comp2 = (Component)v.elementAt(k);
				Dimension d = comp2.getPreferredSize();
				
				comp1.setBounds(x, y, divider, d.height);
				comp2.setBounds(x+divider, y, w-divider, d.height);
				y += d.height + m_vGap;
			}
			//y -= m_vGap;
			return y;

		case COMP_BIG:
			for (int k=0 ; k < v.size(); k++) 
			{
				Component comp = (Component)v.elementAt(k);
				Dimension d = comp.getPreferredSize();
				comp.setBounds(x, y, w, d.height);
				y += d.height + m_vGap;
			}
			//y -= m_vGap;
			return y;

		case COMP_BUTTON:
			Dimension d = getMaxDimension(v);
			int ww = d.width*v.size() + m_hGap*(v.size()-1);
			int xx = x + Math.max(0, (w - ww)/2);
			for (int k=0 ; k < v.size(); k++) 
			{
				Component comp = (Component)v.elementAt(k);
				comp.setBounds(xx, y, d.width, d.height);
				xx += d.width + m_hGap;
			}
			return y + d.height;
		}
		throw new IllegalArgumentException("Illegal type "+type);
	}

	public int getHGap()
	{
		return m_hGap;
	}

	public int getVGap()
	{
		return m_vGap;
	}

	public void setDivider(int divider)
	{
		if (divider > 0)
			m_divider = divider;
	}
	
	public int getDivider()
	{
		return m_divider;
	}

	protected int getDivider(Vector v)
	{
		if (m_divider > 0)
			return m_divider;

		int divider = 0;
		for (int k = 0 ; k < v.size(); k += 2) 
		{
			Component comp = (Component)v.elementAt(k);
			Dimension d = comp.getPreferredSize();
			divider = Math.max(divider, d.width);
		}
		divider += m_hGap;
		return divider;
	}

	protected Dimension getMaxDimension(Vector v)
	{
		int w = 0;
		int h = 0;
		for (int k = 0 ; k < v.size(); k++) 
		{
			Component comp = (Component)v.elementAt(k);
			Dimension d = comp.getPreferredSize();
			w = Math.max(w, d.width);
			h = Math.max(h, d.height);
		}
		return new Dimension(w, h);
	}

	protected int getLayoutType(Component comp)
	{
		if (comp instanceof AbstractButton)
			return COMP_BUTTON;
		else if (comp instanceof JPanel || 
			comp instanceof JScrollPane || 
			comp instanceof DialogSeparator)
			return COMP_BIG;
		else
			return COMP_TWO_COL;
	}

	public String toString() 
	{
		return getClass().getName() + "[hgap=" + m_hGap + ",vgap=" 
			+ m_vGap + ",divider=" + m_divider + "]";
	}
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The Code: DialogSeparator.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\5\dl</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
package dl;

import java.awt.*;

import javax.swing.*;

public class DialogSeparator extends JLabel
{
	public static final int OFFSET = 15;

	public DialogSeparator() {}

	public DialogSeparator(String text) 
	{
		super(text);
	}

	public Dimension getPreferredSize()
	{
		return new Dimension(getParent().getWidth(), 20);
	}

	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	}

	public Dimension getMaximumSize()
	{
		return getPreferredSize();
	}

	public void paint(Graphics g)
	{
		g.setColor(getBackground());
		g.fillRect(0, 0, getWidth(), getHeight());

		Dimension d = getSize();
		int y = (d.height-3)/2;
		g.setColor(Color.white);
		g.drawLine(1, y, d.width-1, y);
		y++;
		g.drawLine(0, y, 1, y);
		g.setColor(Color.gray);
		g.drawLine(d.width-1, y, d.width, y);
		y++;
		g.drawLine(1, y, d.width-1, y);

		String text = getText();
		if (text.length()==0)
			return;

		g.setFont(getFont());
		FontMetrics fm = g.getFontMetrics();
		y = (d.height + fm.getAscent())/2;
		int l = fm.stringWidth(text);

		g.setColor(getBackground());
		g.fillRect(OFFSET-5, 0, OFFSET+l, d.height);

		g.setColor(getForeground());
		g.drawString(text, OFFSET, y);
	}
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Understanding the Code</P>
</B></FONT><I><FONT FACE="AGaramond"><P>Class FlightReservation</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This variant of our airplane ticket reservation sample application uses an instance of </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> as a layout for the whole content pane. Note that no other </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>s are used, and no other layouts are involved. All components are added directly to the content pane and managed by the new layout. This incredibly simplifies the creation of the user interface. Note, however, that we still need to add the label/input field pairs in the correct order because </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> manages these pairs identically to </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Note that instances of our </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3> class are used to provide borders between groups of components. </P>
</FONT><I><FONT FACE="AGaramond"><P>Class DialogLayout2</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class implements the </FONT><FONT FACE="Courier" SIZE=2>LayoutManager</FONT><FONT FACE="AGaramond" SIZE=3> interface to serve as a custom layout manager. It builds on features from </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> to manage all components in its associated container. Three constants declared at the top of the class correspond to the three types of components which are recognized by this layout:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int COMP_TWO_COL</FONT><FONT FACE="AGaramond" SIZE=3>: text fields, comboboxes, and their associated labels which must be laid out in two columns using a </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int COMP_BIG</FONT><FONT FACE="AGaramond" SIZE=3>: wide components (instances of </FONT><FONT FACE="Courier" SIZE=2>JPanel</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>JScrollPane</FONT><FONT FACE="AGaramond" SIZE=3>, or </FONT><FONT FACE="Courier" SIZE=2>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3>) which must occupy the maximum horizontal container space wherever they are placed.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">int COMP_BUTTON</FONT><FONT FACE="AGaramond" SIZE=3>: button components (instances of </FONT><FONT FACE="Courier" SIZE=2>AbstractButton</FONT><FONT FACE="AGaramond" SIZE=3>) which must all be given an equal size, laid out in a single row, and centered in the container.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The instance variables used in </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> are the same as those used in </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> with one addition: we declare </FONT><FONT FACE="Courier" SIZE=2>Vector m_v</FONT><FONT FACE="AGaramond" SIZE=3> to be used as a temporary collection of components.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">To lay out components in a given container we need to determine, for each component, which category it falls under with regard to our </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2.COMP_XX</FONT><FONT FACE="AGaramond" SIZE=3> constants. All components of the same type  added in a contiguous sequence must be processed according to the specific rules described above.</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize() </FONT><FONT FACE="AGaramond" SIZE=3>steps through the list of components in a given container and determines their type with our custom </FONT><FONT FACE="Courier" SIZE=2>getLayoutType()</FONT><FONT FACE="AGaramond" SIZE=3> method (see below) and stores it in the </FONT><FONT FACE="Courier" SIZE=2>newType</FONT><FONT FACE="AGaramond" SIZE=3> local variable. Local variable </FONT><FONT FACE="Courier" SIZE=2>type</FONT><FONT FACE="AGaramond" SIZE=3> holds the type of the <I>previous</I> component in the sequence. For the first component in the container, </FONT><FONT FACE="Courier New" SIZE=2>type</FONT><FONT FACE="AGaramond" SIZE=3> receives the same value as </FONT><FONT FACE="Courier" SIZE=2>newType</FONT><FONT FACE="AGaramond" SIZE=3>. </P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
  public Dimension preferredLayoutSize(Container parent) {
    m_v.removeAllElements();
    int w = 0;
    int h = 0;

    int type = -1;
    for (int k=0 ; k&lt;parent.getComponentCount(); k++) {
      Component comp = parent.getComponent(k);
      int newType = getLayoutType(comp);
      if (k == 0)
        type = newType;
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">If we find a break in the sequence of types this triggers a call to the overloaded </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize(Vector v, int type)</FONT><FONT FACE="AGaramond" SIZE=3> method (discussed below) which determines the preferred size for a temporary collection of the components stored in the </FONT><FONT FACE="Courier" SIZE=2>Vector m_v</FONT><FONT FACE="AGaramond" SIZE=3>. Then </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3> local variables, which are accumulating the total preferred width and height for this layout, are adjusted, and the temporary collection, </FONT><FONT FACE="Courier" SIZE=2>m_v </FONT><FONT FACE="AGaramond" SIZE=3>is cleared. The newly processed component is then added to </FONT><FONT FACE="Courier New" SIZE=3>m_v</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      if (type != newType) {
        Dimension d = preferredLayoutSize(m_v, type);
        w = Math.max(w, d.width);
        h += d.height + m_vGap;
        m_v.removeAllElements();
        type = newType;
      }

      m_v.addElement(comp);
    }
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Once our loop finishes we make the unconditional call to </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize()</FONT><FONT FACE="AGaramond" SIZE=3> to take into account the last (unprocessed) sequence of components and update </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3> accordingly (just as we did in the loop). We then subtract the vertical gap value, </FONT><FONT FACE="Courier" SIZE=2>m_vGap</FONT><FONT FACE="AGaramond" SIZE=3>, from </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3> because we know that we have just processed the last set of components and therefore there is no vertical gap necessary. Taking into account any </FONT><FONT FACE="Courier" SIZE=2>Insets</FONT><FONT FACE="AGaramond" SIZE=3> set on the container, we can now return the computed preferred size as a </FONT><FONT !
FACE="Courier" SIZE=2>Dimension</FONT><FONT FACE="AGaramond" SIZE=3> instance:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
    Dimension d = preferredLayoutSize(m_v, type);
    w = Math.max(w, d.width);
    h += d.height + m_vGap;

    h -= m_vGap;

    Insets insets = parent.getInsets();
    return new Dimension(w+insets.left+insets.right, 
      h+insets.top+insets.bottom);
  }
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The overloaded method </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize(Vector v, int type)</FONT><FONT FACE="AGaramond" SIZE=3> computes the preferred size to lay out a collection of components of a given type. This size is accumulated in </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>h</FONT><FONT FACE="AGaramond" SIZE=3> local variables. For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_TWO_COL</FONT><FONT FACE="AGaramond" SIZE=3> this method invokes a mechanism that should be familiar (see section 4.5). For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_BIG</FONT><FONT FACE="AGaramond" SIZE=3> this method adjusts the preferable width and increments the height for each component, since these components will be placed in a column:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      case COMP_BIG:
        for (int k=0 ; k&lt;v.size(); k++) {
          Component comp = (Component)v.elementAt(k);
          Dimension d = comp.getPreferredSize();
          w = Math.max(w, d.width);
          h += d.height + m_vGap;
        }
        h -= m_vGap;
        return new Dimension(w, h);
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_BUTTON</FONT><FONT FACE="AGaramond" SIZE=3> this method invokes our </FONT><FONT FACE="Courier" SIZE=2>getMaxDimension</FONT><FONT FACE="AGaramond" SIZE=3> method (see below) to calculate the desired size of a single component. Since all components of this type will have an equal size and be contained in one single row, the resulting width for this collection is calculated through multiplication by the number of components, </FONT><FONT FACE="Courier" SIZE=2>v.size()</FONT><FONT FACE="AGaramond" SIZE=3>:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      case COMP_BUTTON:
        Dimension d = getMaxDimension(v);
        w = d.width + m_hGap;
        h = d.height;
        return new Dimension(w*v.size()-m_hGap, h);
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>layoutContainer(Container parent)</FONT><FONT FACE="AGaramond" SIZE=3> assigns bounds to the components in the given container. (Remember that this is the method that actually performs the layout of its associated container.) It processes an array of components similar to the </FONT><FONT FACE="Courier" SIZE=2>preferredLayoutSize() </FONT><FONT FACE="AGaramond" SIZE=3>method. First it steps through the components in the given container, forms a temporarily collection from contiguous components of the same type, and calls the overloaded </FONT><FONT FACE="Courier" SIZE=2>layoutComponents(Vector v, int type, int x, int y, int w)</FONT><FONT FACE="AGaramond" SIZE=3> method to lay out that collection.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>layoutContainer(Vector v, int type, int x, int y, int w)</FONT><FONT FACE="AGaramond" SIZE=3> lays out components from the temporary collection of a given type, starting from the given coordinates </FONT><FONT FACE="Courier" SIZE=2>x</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>y</FONT><FONT FACE="AGaramond" SIZE=3>, and using the specified width, </FONT><FONT FACE="Courier" SIZE=2>w</FONT><FONT FACE="AGaramond" SIZE=3>, of the container. It returns an adjusted y-coordinate which may be used to lay out a new set of components.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_TWO_COL</FONT><FONT FACE="AGaramond" SIZE=3> this method lays out components in two columns identical to how </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> did this (see section 4.5). For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_BIG</FONT><FONT FACE="AGaramond" SIZE=3> the method assigns all available width to each component:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      case COMP_BIG:
        for (int k=0 ; k&lt;v.size(); k++) {
          Component comp = (Component)v.elementAt(k);
          Dimension d = comp.getPreferredSize();
          comp.setBounds(x, y, w, d.height);
          y += d.height + m_vGap;
        }
        return y;
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">For a collection of type </FONT><FONT FACE="Courier" SIZE=2>COMP_BUTTON</FONT><FONT FACE="AGaramond" SIZE=3> this method assigns an equal size to each component and places them in the center arranged horizontally:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      case COMP_BUTTON:
        Dimension d = getMaxDimension(v);
        int ww = d.width*v.size() + m_hGap*(v.size()-1);
        int xx = x + Math.max(0, (w - ww)/2);
        for (int k=0 ; k&lt;v.size(); k++) {
          Component comp = (Component)v.elementAt(k);
          comp.setBounds(xx, y, d.width, d.height);
          xx += d.width + m_hGap;
        }
        return y + d.height;
</pre>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note that a more sophisticated implementation might split a sequence of buttons up into several rows if not enough space is available. We do not do that here to avoid over-complication. This might be an interesting exercise to give you more practice at customizing layout managers.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The remainder of the </FONT><FONT FACE="Courier New" SIZE=3>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> class contains methods which were either explained already, or are simple enough to be considered self-explanatory.</P>
</FONT><I><FONT FACE="AGaramond"><P>Class DialogSeparator</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class implements a component used to separate two groups of components placed in a column. It extends </FONT><FONT FACE="Courier" SIZE=2>JLabel</FONT><FONT FACE="AGaramond" SIZE=3> to inherit all its default characteristics (font, foreground, etc.). Two available constructors allow the creation of a </FONT><FONT FACE="Courier New" SIZE=3>DialogSeparator</FONT><FONT FACE="AGaramond" SIZE=3> with or without a text label.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>getPreferredSize</FONT><FONT FACE="AGaramond" SIZE=3> returns a fixed height, and a width equal to the width of the container. Methods </FONT><FONT FACE="Courier" SIZE=2>getMinimumSize()</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>getMaximumSize()</FONT><FONT FACE="AGaramond" SIZE=3> simply delegate calls to the </FONT><FONT FACE="Courier" SIZE=2>getPreferredSize() </FONT><FONT FACE="AGaramond" SIZE=3>method.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=2>paintComponent()</FONT><FONT FACE="AGaramond" SIZE=3> method draws a separating bar with a raised appearance across the available component space, and draws the title text (if any) at the left-most side taking into account a pre-defined offset, 15.</P>
<B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Running the Code</P>
<P ALIGN="JUSTIFY"></P>
</B><P ALIGN="JUSTIFY">At this point you can compile and execute this example. Figure 4.17 shows our sample application which now uses </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3> to manage the layout of <I>all</I> components. You can see that we have the same set of components placed and sized in accordance with our general layout scheme presented in the beginning of this section. The most important thing to note is that we did not have to use any intermediate containers and layouts to achieve this: all components are added directly to the frame’s content pane which is intelligently managed by </FONT><FONT FACE="Courier" SIZE=2>DialogLayout2</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><B><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">UI Guideline : Consistency of Button Placement</B> </P>
<P ALIGN="JUSTIFY">It is important to be consistent with the placement of buttons in Dialogs and Option Panes. In the example shown here, a symmetrical approach to button placement has been adopted. This is a good safe choice. It ensures balance. With Data Entry Dialogs it is also common to use an asymmetrical layout such as Bottom RHS of the dialog.</P>
<P ALIGN="JUSTIFY">In addition to achieving balance with the layout, by being consistent with your placement you allow the User to rely on directional memory to find a specific button location. Directional Memory is strong. Once the User learns where you have placed buttons, they will quickly be able to locate the correct button in many dialog and option situations. It is therefore, vital that you place buttons in a consistent order e.g. OK, Cancel, always and never Cancel, OK.</P>
<P ALIGN="JUSTIFY">As a general rule, always use symmetrical layout with option dialogs and be consistent with whatever you decide to use for data entry dialogs.</P>
<P ALIGN="JUSTIFY">It makes sense to develop custom components such as JOKCancelButtons and JYesNoButtons. You can then re-use these components every time you need a such a set of buttons. This encapsulates the placement and ensures consistency.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">&nbsp;</P></DIR>

</FONT><I><FONT FACE="AGaramond" SIZE=5><P>4.7&#9;Dynamic layout in a JavaBeans container</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">In this section we will use different layouts to manage JavaBeans in a simple container application. This will help us to further understand the role of layouts in dynamically managing containers with a variable number of components. This example also sets up the framework for a powerful bean editor environment developed in chapter 18 using </FONT><FONT FACE="Courier" SIZE=2>JTable</FONT><FONT FACE="AGaramond" SIZE=3>s. By allowing modification of component properties we can use this environment to experiment with preferred, maximum, and minimum sizes, and observe the behavior different layout managers exibit in various situations. This provides us with the ability to learn much more about each layout manager, and allows us to prototype simple interfaces without actually implementing them.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">This example consists of a frame container that allows the creation, loading, and saving of JavaBeans using serialization. Beans can be added and removed from this container and we implement a focus mechanism to visually identify the currently selected bean. Most importantly, the layout manager of this container can be changed at run-time. (You may want to review the JavaBeans material in chapter 2 before attempting to work through this example.)</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image102.gif" WIDTH=300 HEIGHT=300>&nbsp;</P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.18 BeanContainer displaying 4 Clock components using a FlowLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-18.gif&gt;&gt;</P>

<P><IMG SRC="image103.gif" WIDTH=300 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.19 BeanContainer displaying 4 Clock components using a GridLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-19.gif&gt;&gt;</P>

<P><IMG SRC="image104.gif" WIDTH=300 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.20 BeanContainer displaying 4 Clock components using a horizontal BoxLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-20.gif&gt;&gt;</P>

<P><IMG SRC="image105.gif" WIDTH=300 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.21 BeanContainer displaying 4 Clock components using a vertical BoxLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-21.gif&gt;&gt;</P>

<P><IMG SRC="image106.gif" WIDTH=300 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.22 BeanContainer displaying 4 Clock components using a DialogLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-22.gif&gt;&gt;</P>

<P><IMG SRC="image107.gif" WIDTH=300 HEIGHT=300></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.23 BeanContainer displaying button/input field pairs using DialogLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-23.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=2><P><IMG SRC="image108.gif" WIDTH=454 HEIGHT=352></P>
</FONT><B><FONT FACE="Univers 45 Light" SIZE=1><P>Figure 4.24 BeanContainer displaying button/input field pairs using DialogLayout</P>
</B></FONT><FONT SIZE=2><P>&lt;&lt;file figure4-24.gif&gt;&gt;</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">The Code: BeanContainer.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\6</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.beans.*;
import java.lang.reflect.*;

import javax.swing.*;

import dl.*;

public class BeanContainer extends JFrame implements FocusListener
{
  protected File m_currentDir = new File(".");
  protected Component m_activeBean;
  protected String m_className = "clock.Clock";
  protected JFileChooser m_chooser = new JFileChooser();

  public BeanContainer() {
    super("Simple Bean Container");
    getContentPane().setLayout(new FlowLayout());
   
    setSize(300, 300);

    JPopupMenu.setDefaultLightWeightPopupEnabled(false);

    JMenuBar menuBar = createMenuBar();
    setJMenuBar(menuBar);

    WindowListener wndCloser = new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    };
    addWindowListener(wndCloser);

    setVisible(true);
  }

  protected JMenuBar createMenuBar() {
    JMenuBar menuBar = new JMenuBar();
    
    JMenu mFile = new JMenu("File");

    JMenuItem mItem = new JMenuItem("New...");
    ActionListener lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {  
        Thread newthread = new Thread() {
          public void run() {
            String result = (String)JOptionPane.showInputDialog(
              BeanContainer.this, 
              "Please enter class name to create a new bean", 
              "Input", JOptionPane.INFORMATION_MESSAGE, null, 
              null, m_className);
            repaint();
            if (result==null)
              return;
            try {
              m_className = result;
              Class cls = Class.forName(result);
              Object obj = cls.newInstance();
              if (obj instanceof Component) {
                m_activeBean = (Component)obj;
                m_activeBean.addFocusListener(
                  BeanContainer.this);
                m_activeBean.requestFocus();
                getContentPane().add(m_activeBean);
              }
              validate();
            }
            catch (Exception ex) {
              ex.printStackTrace();
              JOptionPane.showMessageDialog(
                BeanContainer.this, "Error: "+ex.toString(),
                "Warning", JOptionPane.WARNING_MESSAGE);
            }
          }
        };
        newthread.start();
      }
    };
    mItem.addActionListener(lst);
    mFile.add(mItem);

    mItem = new JMenuItem("Load...");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {  
        Thread newthread = new Thread() {
          public void run() {
            m_chooser.setCurrentDirectory(m_currentDir);
            m_chooser.setDialogTitle(
              "Please select file with serialized bean");
            int result = m_chooser.showOpenDialog(
              BeanContainer.this);
            repaint();
            if (result != JFileChooser.APPROVE_OPTION)
              return;
            m_currentDir = m_chooser.getCurrentDirectory();
            File fChoosen = m_chooser.getSelectedFile();
            try {
              FileInputStream fStream = 
                new FileInputStream(fChoosen);
              ObjectInput  stream  =  
                new ObjectInputStream(fStream);
              Object obj = stream.readObject();
              if (obj instanceof Component) {
                m_activeBean = (Component)obj;
                m_activeBean.addFocusListener(
                  BeanContainer.this);
                m_activeBean.requestFocus();
                getContentPane().add(m_activeBean);
              }
              stream.close();
              fStream.close();
              validate();
            }
            catch (Exception ex) {
              ex.printStackTrace();
              JOptionPane.showMessageDialog(
                BeanContainer.this, "Error: "+ex.toString(),
                "Warning", JOptionPane.WARNING_MESSAGE);
            }
            repaint();
          }
        };
        newthread.start();
      }
    };
    mItem.addActionListener(lst);
    mFile.add(mItem);

    mItem = new JMenuItem("Save...");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        Thread newthread = new Thread() {
          public void run() {
            if (m_activeBean == null)
              return;
            m_chooser.setDialogTitle(
              "Please choose file to serialize bean");
            m_chooser.setCurrentDirectory(m_currentDir);
            int result = m_chooser.showSaveDialog(
              BeanContainer.this);
            repaint();
            if (result != JFileChooser.APPROVE_OPTION)
              return;
            m_currentDir = m_chooser.getCurrentDirectory();
            File fChoosen = m_chooser.getSelectedFile();
            try {
              FileOutputStream fStream = 
                new FileOutputStream(fChoosen);
              ObjectOutput stream  =  
                new ObjectOutputStream(fStream);
              stream.writeObject(m_activeBean);
              stream.close();
              fStream.close();
            }
            catch (Exception ex) {
              ex.printStackTrace();
            JOptionPane.showMessageDialog(
              BeanContainer.this, "Error: "+ex.toString(),
              "Warning", JOptionPane.WARNING_MESSAGE);
            }
          }
        };
        newthread.start();
      }
    };
    mItem.addActionListener(lst);
    mFile.add(mItem);

    mFile.addSeparator();

    mItem = new JMenuItem("Exit");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        System.exit(0);
      }
    };
    mItem.addActionListener(lst);
    mFile.add(mItem);
    menuBar.add(mFile);
    
    JMenu mEdit = new JMenu("Edit");

    mItem = new JMenuItem("Delete");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        if (m_activeBean == null)
          return;
        getContentPane().remove(m_activeBean);
        m_activeBean = null;
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    mEdit.add(mItem);
    menuBar.add(mEdit);

    JMenu mLayout = new JMenu("Layout");
    ButtonGroup group = new ButtonGroup();

    mItem = new JRadioButtonMenuItem("FlowLayout");
    mItem.setSelected(true);
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e){
        getContentPane().setLayout(new FlowLayout());
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    group.add(mItem);
    mLayout.add(mItem);

    mItem = new JRadioButtonMenuItem("GridLayout");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e){
        int col = 3;
        int row = (int)Math.ceil(getContentPane().
          getComponentCount()/(double)col);
        getContentPane().setLayout(new GridLayout(row, col, 10, 10));
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    group.add(mItem);
    mLayout.add(mItem);
    
    mItem = new JRadioButtonMenuItem("BoxLayout - X");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        getContentPane().setLayout(new BoxLayout(
          getContentPane(), BoxLayout.X_AXIS));
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    group.add(mItem);
    mLayout.add(mItem);
    
    mItem = new JRadioButtonMenuItem("BoxLayout - Y");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        getContentPane().setLayout(new BoxLayout(
          getContentPane(), BoxLayout.Y_AXIS));
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    group.add(mItem);
    mLayout.add(mItem);
    
    mItem = new JRadioButtonMenuItem("DialogLayout");
    lst = new ActionListener() { 
      public void actionPerformed(ActionEvent e) {
        getContentPane().setLayout(new DialogLayout());
        validate();
        repaint();
      }
    };
    mItem.addActionListener(lst);
    group.add(mItem);
    mLayout.add(mItem);

    menuBar.add(mLayout);

    return menuBar;
  }

  public void focusGained(FocusEvent e) {
    m_activeBean = e.getComponent();
    repaint();
  }

  public void focusLost(FocusEvent e) {}

  // This is a heavyweight component so we override paint
  // instead of paintComponent. super.paint(g) will
  // paint all child components first, and then we 
  // simply draw over top of them.
  public void paint(Graphics g) {
    super.paint(g);

    if (m_activeBean == null)
      return;

    Point pt = getLocationOnScreen();
    Point pt1 = m_activeBean.getLocationOnScreen();
    int x = pt1.x - pt.x - 2;
    int y = pt1.y - pt.y - 2;
    int w = m_activeBean.getWidth() + 2;
    int h = m_activeBean.getHeight() + 2;

    g.setColor(Color.black);
    g.drawRect(x, y, w, h);
  }

  public static void main(String argv[]) {
    new BeanContainer();
  }
}
</pre>
</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">The Code: Clock.java</P>
<P ALIGN="JUSTIFY">see \Chapter4\6\clock</P>
</B></FONT><FONT FACE="Courier" SIZE=3>
<pre>
package clock;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;

public class Clock 
	extends    JButton
	implements Customizer, Externalizable, Runnable
{

	protected PropertyChangeSupport m_helper;
	protected boolean  m_digital = false;
	protected Calendar m_calendar;
	protected Dimension m_preffSize;

	public Clock()
	{
		m_calendar = Calendar.getInstance();
		m_helper = new PropertyChangeSupport(this);

		Border br1 = new EtchedBorder(EtchedBorder.RAISED, 
			Color.white, new Color(128, 0, 0));
		Border br2 = new MatteBorder(4, 4, 4, 4, Color.red);
		setBorder(new CompoundBorder(br1, br2));

		setBackground(Color.white);
		setForeground(Color.black);

		(new Thread(this)).start();
	}

	public void writeExternal(ObjectOutput out)   
		throws IOException
	{
		out.writeBoolean(m_digital);
		out.writeObject(getBackground());
		out.writeObject(getForeground());
		out.writeObject(getPreferredSize());
	}

	public void readExternal(ObjectInput in)
		throws IOException, ClassNotFoundException
	{
		setDigital(in.readBoolean());
		setBackground((Color)in.readObject());
		setForeground((Color)in.readObject());
		setPreferredSize((Dimension)in.readObject());
	}

	public Dimension getPreferredSize()
	{
		if (m_preffSize != null)
			return m_preffSize;
		else
			return new Dimension(50, 50);
	}
	
	public void setPreferredSize(Dimension preffSize)
	{
		m_preffSize = preffSize;
	}

	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	}

	public Dimension getMaximumSize()
	{
		return getPreferredSize();
	}

	public void setDigital(boolean digital)
	{
		m_helper.firePropertyChange("digital",
			new Boolean(m_digital), 
			new Boolean(digital));
		m_digital = digital;
		repaint();
	}

	public boolean getDigital()
	{
		return m_digital;
	}

	public void addPropertyChangeListener(
		PropertyChangeListener lst)
	{
		if (m_helper != null)
			m_helper.addPropertyChangeListener(lst);
	}

	public void removePropertyChangeListener(
		PropertyChangeListener lst)
	{
		if (m_helper != null)
			m_helper.removePropertyChangeListener(lst);
	}

	public void setObject(Object bean) {}

	public void paintComponent(Graphics g)
	{
                super.paintComponent(g);
                Color colorRetainer = g.getColor();

		g.setColor(getBackground());
		g.fillRect(0, 0, getWidth(), getHeight());
		getBorder().paintBorder(this, g, 0, 0, getWidth(), getHeight());

		m_calendar.setTime(new Date());	// get current time
		int hrs = m_calendar.get(Calendar.HOUR_OF_DAY);
		int min = m_calendar.get(Calendar.MINUTE);

		g.setColor(getForeground());
		if (m_digital)
		{
			String time = ""+hrs+":"+min;
			g.setFont(getFont());
			FontMetrics fm = g.getFontMetrics();
			int y = (getHeight() + fm.getAscent())/2;
			int x = (getWidth() - fm.stringWidth(time))/2;
			g.drawString(time, x, y);
		}
		else
		{
			int x = getWidth()/2;
			int y = getHeight()/2;
			int rh = getHeight()/4;
			int rm = getHeight()/3;

			double ah = ((double)hrs+min/60.0)/6.0*Math.PI;
			double am = min/30.0*Math.PI;

			g.drawLine(x, y, (int)(x+rh*Math.sin(ah)), 
				(int)(y-rh*Math.cos(ah)));
			g.drawLine(x, y, (int)(x+rm*Math.sin(am)), 
				(int)(y-rm*Math.cos(am)));
		}

                g.setColor(colorRetainer);
	}

	public void run()
	{
		while (true)
		{
			repaint();
			try
			{
				Thread.sleep(30*1000);
			}
			catch(InterruptedException ex) { break; }
		}
	}
}
</pre>

</FONT><B><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Understanding the Code</P>
</B></FONT><I><FONT FACE="AGaramond"><P>Class BeanContainer</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class extends </FONT><FONT FACE="Courier" SIZE=2>JFrame</FONT><FONT FACE="AGaramond" SIZE=3> to provide the frame for this application. It also implements the </FONT><FONT FACE="Courier" SIZE=2>FocusListener</FONT><FONT FACE="AGaramond" SIZE=3> interface to manage focus transfer between beans in the container. This class declares four instance variables:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">File m_currentDir</FONT><FONT FACE="AGaramond" SIZE=3>: the most recent directory used to load and save beans.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Component m_activeBean</FONT><FONT FACE="AGaramond" SIZE=3>: a bean component which currently has the focus.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">String m_className</FONT><FONT FACE="AGaramond" SIZE=3>: fully qualified class name of our custom </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> bean,</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">JFileChooser m_chooser</FONT><FONT FACE="AGaramond" SIZE=3>: used for saving and loading beans.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The only GUI provided by the container itself is the menu bar. The</FONT><FONT FACE="Courier" SIZE=2> createMenuBar() method </FONT><FONT FACE="AGaramond" SIZE=3>creates the menu bar, its items, and their corresponding action listeners. Three menus are added to the menu bar: &quot;File,&quot; &quot;Edit,&quot; and &quot;Layout.&quot; </P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: All code corresponding to &quot;New...,&quot; &quot;Load..., and &quot;Save...&quot; in the &quot;File&quot; menu is wrapped in a separate thread to avoid unnecesary load on the event-dispatching thread. See chapter 2 for more about multithreading.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Menu item &quot;New...&quot; in the &quot;File&quot; menu displays an input dialog (using the </FONT><FONT FACE="Courier" SIZE=2>JOptionPane.showInputDialog()</FONT><FONT FACE="AGaramond" SIZE=3> method) to enter the class name of a new bean to be added to the container. Once a name has been entered, the program attempts to load that class, create a new class instance using a default constructor, and add that new object to the container. The newly created component requests the focus and receives a </FONT><FONT FACE="Courier New" SIZE=3>this</FONT><FONT FACE="AGaramond" SIZE=3> reference to </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3> as a </FONT><FONT FACE="Courier" SIZE=2>FocusListener</FONT><FONT FACE="AGaramond" SIZE=3>. Note that any caught exceptions will be displayed in a message box.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Menu item &quot;Load...&quot; from the &quot;File&quot; menu displays a </FONT><FONT FACE="Courier" SIZE=2>JFileChooser</FONT><FONT FACE="AGaramond" SIZE=3> dialog to select a file containing a previously serialized bean component. If this succeeds, the program opens an input stream on this file and reads the first stored object. If this object is derived from the </FONT><FONT FACE="Courier New" SIZE=3>java.awt.Component</FONT><FONT FACE="AGaramond" SIZE=3> class it is added to the container. The loaded component requests the focus and receives a </FONT><FONT FACE="Courier New" SIZE=3>this</FONT><FONT FACE="AGaramond" SIZE=3> reference to </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3> as a </FONT><FONT FACE="Courier" SIZE=2>FocusListener</FONT><FONT FACE="AGaramond" SIZE=3>. Note that any caught exceptions will be displayed in a message box.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Menu item &quot;Save...&quot; from the &quot;File&quot; menu displays a </FONT><FONT FACE="Courier" SIZE=2>JFileChooser</FONT><FONT FACE="AGaramond" SIZE=3> dialog to select a file destination for serializing the bean component which currently has the focus. If this succeeds, the program opens an output stream on that file and writes the currently active component to that stream. Note that any caught exceptions will be displayed in a message box.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Menu item &quot;Exit&quot; simply quits and closes the application with </FONT><FONT FACE="Courier New" SIZE=2>System.exit(0)</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">The &quot;Edit&quot; menu contains a single item titled &quot;Delete&quot; which removes the currently active bean from the container:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      getContentPane().remove(m_activeBean);
      m_activeBean = null;
      validate();
      repaint();
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Menu "Layout" contains several </FONT><FONT FACE="Courier" SIZE=2>JRadioButtonMenuItems</FONT><FONT FACE="AGaramond" SIZE=3> managed with a </FONT><FONT FACE="Courier" SIZE=2>ButtonGroup group</FONT><FONT FACE="AGaramond" SIZE=3>. These items are titled &quot;FlowLayout,&quot; &quot;GridLayout,&quot; &quot;BoxLayout - X,&quot; &quot;BoxLayout - Y,&quot; and &quot;DialogLayout.&quot; Each item receives an </FONT><FONT FACE="Courier" SIZE=2>ActionListener</FONT><FONT FACE="AGaramond" SIZE=3> which sets the corresponding layout manager of the application frame’s content pane, calls </FONT><FONT FACE="Courier" SIZE=2>validate</FONT><FONT FACE="AGaramond" SIZE=3> to lay out the container again, and the </FONT><FONT FACE="Courier" SIZE=2>repaint</FONT><FONT FACE="AGaramond" SIZE=3>s it. For example:</P>
</FONT><FONT FACE="Courier" SIZE=3>
<pre>
      getContentPane().setLayout(new DialogLayout());
      validate();
      repaint();
</pre>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>focusGained</FONT><FONT FACE="AGaramond" SIZE=3> stores a reference to the component which currently has the focus into instance variable </FONT><FONT FACE="Courier" SIZE=2>m_activebean</FONT><FONT FACE="AGaramond" SIZE=3>. Method </FONT><FONT FACE="Courier" SIZE=2>paint()</FONT><FONT FACE="AGaramond" SIZE=3> is implemented to draw a rectangle around the component which currently has the focus. It is important to note here the static </FONT><FONT FACE="Courier" SIZE=2>JPopupMenu</FONT><FONT FACE="AGaramond" SIZE=3> method called in the </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3> constructor:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier" SIZE=2><P>      JPopupMenu.setDefaultLightWeightPopupEnabled(false);</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">This method forces all popup menus (which menu bars use to display their contents) to use heavyweight popups rather than lightweight popups. By default popup menus are lightweight unless they cannot fit within their parent container’s bounds. The reason we disable this is because our </FONT><FONT FACE="Courier" SIZE=2>paint() </FONT><FONT FACE="AGaramond" SIZE=3>method will render the bean selection rectangle over top of the lightweight popups otherwise.</P>
</FONT><I><FONT FACE="AGaramond"><P>Class Clock</P>
</I></FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY">This class is a sample bean clock component which can be used in a bean container just as any other bean. This class extends the </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3> component to inherit it's focus grabbing functionality. This class also implements three interfaces: </FONT><FONT FACE="Courier" SIZE=2>Customizer</FONT><FONT FACE="AGaramond" SIZE=3> to handle property listeners, </FONT><FONT FACE="Courier" SIZE=2>Externalizable</FONT><FONT FACE="AGaramond" SIZE=3> to completely manage its own serialization, and </FONT><FONT FACE="Courier" SIZE=2>Runnable</FONT><FONT FACE="AGaramond" SIZE=3> to be run by a thread. Four instance variables are declared:</P><DIR>

</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">PropertyChangeSupport m_helper</FONT><FONT FACE="AGaramond" SIZE=3>: an object to manage </FONT><FONT FACE="Courier" SIZE=2>PropertyChangeListeners</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">boolean m_digital</FONT><FONT FACE="AGaramond" SIZE=3>: a custom property for this component which manages the display state of the clock (digital or arrow-based).</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Calendar m_calendar</FONT><FONT FACE="AGaramond" SIZE=3>: helper object to handle Java's time objects (instances of </FONT><FONT FACE="Courier" SIZE=2>Date</FONT><FONT FACE="AGaramond" SIZE=3>).</P>
</FONT><FONT FACE="Courier" SIZE=2><P ALIGN="JUSTIFY">Dimension m_preffSize</FONT><FONT FACE="AGaramond" SIZE=3>: a preferred size for this component which may be set using the </FONT><FONT FACE="Courier" SIZE=2>setPreferredSize</FONT><FONT FACE="AGaramond" SIZE=3> method.</P>
<P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The constructor of the </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> class creates the helper objects and sets the border for this component as a </FONT><FONT FACE="Courier" SIZE=2>CompoundBorder</FONT><FONT FACE="AGaramond" SIZE=3> containing an </FONT><FONT FACE="Courier" SIZE=2>EtchedBorder</FONT><FONT FACE="AGaramond" SIZE=3> and a </FONT><FONT FACE="Courier" SIZE=2>MatteBorder</FONT><FONT FACE="AGaramond" SIZE=3> imitating the border of a real clock. It then sets the background and foreground colors and starts a new </FONT><FONT FACE="Courier" SIZE=2>Thread</FONT><FONT FACE="AGaramond" SIZE=3> to run the clock.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Method </FONT><FONT FACE="Courier" SIZE=2>writeExternal()</FONT><FONT FACE="AGaramond" SIZE=3> writes the current state of a </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> object into an </FONT><FONT FACE="Courier" SIZE=2>ObjectOutput</FONT><FONT FACE="AGaramond" SIZE=3> stream. Four properties are written: </FONT><FONT FACE="Courier" SIZE=2>m_digital</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>Background</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>Foreground</FONT><FONT FACE="AGaramond" SIZE=3>, and </FONT><FONT FACE="Courier" SIZE=2>PreferredSize</FONT><FONT FACE="AGaramond" SIZE=3>. Method </FONT><FONT FACE="Courier" SIZE=2>readExternal()</FONT><FONT FACE="AGaramond" SIZE=3> reads the previously saved state of a </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> object from an </FONT><FONT FACE="Courier" SIZE=2>ObjectInput</FONT><FONT FACE!
="AGaramond" SIZE=3> stream. It reads these four properties and applies them to the object previously created with the default constructor. These methods are called from the &quot;Save&quot; and &quot;Load&quot; menu bar action listener code in </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3>. Specifically, they are called when </FONT><FONT FACE="Courier" SIZE=2>writeObject</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>readObject</FONT><FONT FACE="AGaramond" SIZE=3> are invoked.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: The serialization mechanism in Swing has not yet matured. You can easily find that both lightweight and heavyweight components throw exceptions during the process of serialization. This is the reason we implement the </FONT><FONT FACE="Courier New" SIZE=2>Externalizable</FONT><FONT FACE="AGaramond" SIZE=2> interface to take complete control over the serialization of the </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=2> bean. Another reason is that the default serialization mechanism tends to serialize a substantial amount of unnecessary information, whereas our custom implementation stores only the necessities.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">The rest of this class need not be explained here, as it does not relate directly to the topic of this chapter and represents a simple example of a bean component. If you're interested, take note of the </FONT><FONT FACE="Courier New" SIZE=3>paintComponent()</FONT><FONT FACE="AGaramond" SIZE=3> method which, depending on whether the clock is in digital mode or not (determined by </FONT><FONT FACE="Courier" SIZE=2>m_digital</FONT><FONT FACE="AGaramond" SIZE=3>), either computes the current position of the clock's arrows and draws them, or renders the time as a drawn </FONT><FONT FACE="Courier" SIZE=2>String</FONT><FONT FACE="AGaramond" SIZE=3>.</P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Running the Code</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">This application provides a framework for experimenting with any available JavaBeans, as well as with both lightweight (Swing) and heavyweight (AWT) components: we can create, serialize, delete, and restore them. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Note that we can apply several layouts to manage these components dynamically. Figures 4.18-4.23 show </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3> using five different layout managers to arrange four </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> beans. To create a bean choose &quot;New&quot; from the &quot;File&quot; menu and type the fully qualifies name of the class. For instance, to create a </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> you need to type &quot;clock.Clock&quot; in the input dialog. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Once you’ve experimented with </FONT><FONT FACE="Courier" SIZE=2>Clock</FONT><FONT FACE="AGaramond" SIZE=3> beans try loading some Swing JavaBeans. Figure 4.24 shows </FONT><FONT FACE="Courier" SIZE=2>BeanDialog</FONT><FONT FACE="AGaramond" SIZE=3> with two </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3>s, and two </FONT><FONT FACE="Courier" SIZE=2>JTextField</FONT><FONT FACE="AGaramond" SIZE=3>s. They were created in the following order (and thus have corresponding container indices): </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>JTextField</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3>, </FONT><FONT FACE="Courier" SIZE=2>JTextField</FONT><FONT FACE="AGaramond" SIZE=3>. Try doing this and remember that you need to specify fully qualified class names such as &quot;javax.swing.JButton&qu!
ot; when adding a new bean. Note that this ordering adhere’s to our </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> label/input field pairs scheme, except that here we are using buttons in place of labels. So when we set </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=3>’s layout to </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> we know what to expect.</P>
<P ALIGN="JUSTIFY">&nbsp;</P><DIR>

</FONT><FONT FACE="AGaramond" SIZE=2><P ALIGN="JUSTIFY">Note: You will notice selection problems with components such as </FONT><FONT FACE="Courier" SIZE=2>JComboBox</FONT><FONT FACE="AGaramond" SIZE=2>, </FONT><FONT FACE="Courier" SIZE=2>JSplitPane</FONT><FONT FACE="AGaramond" SIZE=2> and </FONT><FONT FACE="Courier" SIZE=2>JLabel</FONT><FONT FACE="AGaramond" SIZE=2> (which has no selection mechanism). Because of </FONT><FONT FACE="Courier" SIZE=2>JComboBox</FONT><FONT FACE="AGaramond" SIZE=2> is actually a container containing a button, it is impossible to give it the current focus after it has been added to </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=2>. A more complete version of </FONT><FONT FACE="Courier" SIZE=2>BeanContainer</FONT><FONT FACE="AGaramond" SIZE=2> would take this into account and implement more robust focus requesting behavior.</P>
</FONT><FONT FACE="AGaramond" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>

<P ALIGN="JUSTIFY">Later in this book, after a discussion of tables, we add powerful functionality to this example allowing the manipulation of bean properties. It is highly suggested that you skip ahead for a moment and run this example: (<B>see \Chapter18\8</B>). </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Start the chapter 18 example and create </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3> and </FONT><FONT FACE="Courier" SIZE=2>JTextField</FONT><FONT FACE="AGaramond" SIZE=3> beans exactly as you did above. Select </FONT><FONT FACE="Courier" SIZE=2>DialogLayout</FONT><FONT FACE="AGaramond" SIZE=3> from the &quot;Layout&quot; menu and then click on the top-most JButton to give it the focus. Now select &quot;Properties&quot; from the &quot;Edit&quot; menu. A separate frame will pop up with a </FONT><FONT FACE="Courier" SIZE=2>JTable</FONT><FONT FACE="AGaramond" SIZE=3> containing all of the </FONT><FONT FACE="Courier" SIZE=2>JButton</FONT><FONT FACE="AGaramond" SIZE=3>’s properties. Navigate to the &quot;label&quot; property and change it to &quot;Button 1&quot; (by double clicking on its &quot;Value&quot; field). Now select the corresponding top-most </FONT><FONT FACE="Courier" SIZE=2>JTextField</FONT><FONT FACE="AGaramond" S!
IZE=3> and change its &quot;preferredSize&quot; property to &quot;4,40&quot;. Figure 4.24 illustrates what you should see. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">By changing the preferred, maximum, and minimum sizes, as well as other component properties, we can directly examine the behavior different layout managers impose on our container. Experimenting with this example is a very convenient way to learn more about how the layout managers behave. It also forms the foundation for an interface development environment (IDE), which many developers use to simplify interface design.</P></FONT></BODY>
</HTML>
