<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Draft//EN">
<html> <head>
<title>Programming user interfaces with the JFC</title>

<link href="file://\home\jan\tutorials\swingtut\stylesheet.css" rel="stylesheet" type="text/css">
<meta name="copyright" content="&copy;Jan Newmarch ">

<!-- <base href="file:///home/jan/tutorials/swingtut/"> -->

<!--#exec cmd="/usr/local/bin/meta.pl" -->
</head>

<body>

<h1 align=center> Programming user interfaces with the JFC </h1>
<h2> Jan Newmarch </h2>
<div class="section">


Last modified: 25 January, 1999.
<br>
These slides are Copyright Jan Newmarch, 1998.
<br>

<hr class=PAGE-BREAK>

<h1 align=center>
Abstract
</h1>
<div class="subsection">

<p>
This tutorial looks at GUI programming using the new JFC/Swing classes.
It assumes a background of the AWT, and concentrates on additional
features and changes from the AWT.

</div>

<hr class=PAGE-BREAK>

<h1 align=center> OVERVIEW </h1>
<div class="subsection">

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>Evolution of Java GUI programming </h1>
<div class="subsection">

<ul>
  <li> The AWT (Abstract Window Toolkit) has been present in all versions
      of Java
  <li> The AWT objects are built above native code objects, giving a native
      look-and-feel
  <li> The AWT objects are a least common denominator of all platforms
  <li> The Swing objects are a separate library for JDK 1.1
  <li> The Swing objects are in pure Java, and have the same look-and-feel
      on all platforms
  <li> The L&F of Swing objects can be customised to particular styles
  <li> In JDK 1.2, the Swing objects are part of the Java Foundation Classes
  <li> The JFC objects will provide a superset of each platform's objects
  <li> The AWT objects will decrease in importance over time
</ul>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1> Greater set of objects </h1>
<div class="subsection">

The Swing set includes
<ul>
  <li> JButton
  <li> JCheckbox
  <li> JCheckboxMenuItem
  <li> JColorChooser
  <li> JComboBox
  <li> JDesktopIcon
  <li> JDesktopPane
  <li> JDialog
  <li> JDirectoryPane
  <li> JEditorPane
  <li> JFileChooser
  <li> JFrame
  <li> JInternalFrame
  <li> JLabel
  <li> JLayeredPane
  <li> JList
  <li> JMenu
  <li> JMenuBar
  <li> JMenuItem
  <li> JOptionPane
  <li> JPanel
  <li> JPasswordField
  <li> JPopupMenu
  <li> JProgressBar 
  <li>      JRadioButton 
  <li>      JRadioButtonMenuItem 
  <li>      JRootPane 
  <li>      JScrollBar 
  <li>      JScrollPane 
  <li>      JSeparator 
  <li>      JSlider 
  <li>      JSplitPane 
  <li>      JTabbedPane
  <li>      JTable 
  <li>      JTextArea 
  <li>      JTextField 
  <li>      JTextPane 
  <li>      JToggleButton 
  <li>      JToolBar 
  <li>      JToolTip 
  <li>      JTree 
  <li>      JViewport 
  <li>      JWindow 
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Capability </h1>
<div class="subsection"> 

<ul>
  <li> Each object has greater capabilities than its
      corresponding AWT object
  <li> Some capabilities are object-specific
  <li> Some are available across all objects
      <ul>
	<li> internationalisation
	<li> customisable UI
      </ul>
</ul>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1> JFrame</h1>
<div class="subsection"> 

<ul>
  <li> JFrame is the Swing equivalent of Frame
  <li> It adds double buffering to avoid flickering
      during drawing
  <li> It has a slightly different interface to
      geometry management - things are added to a contentPane
  <li> It can hold a JMenuBar
</ul>
<img src="jframe.gif">
</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1>  Hello World using Swing</h1>
<div class="subsection"> 

<pre>
import javax.swing.*;

public class JHello extends JFrame {

  public static void main(String argv[])
  {
    new JHello();
  }

  JHello() {
    JLabel hello = new JLabel("Hello World");
    getContentPane().add(hello, "Center");
    setSize(200, 200);
    setVisible(true);
  }
}
</pre>
</div> <!-- subsection -->


<hr class=PAGE-BREAK>

<h1 align=center> JBUTTON  </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  JButton </h1>
<div class="subsection"> 

<ul>
  <li> JButton's can have an image and/or text label
      with controllable placement
  <li> Similarly for JLabel, JCheckBox, JRadioButton
  <li> These extend appearance of corresponding AWT objects
</ul>
<img src="jbutton.gif">

</div> <!-- subsection -->
<br>
<hr class=PAGE-BREAK>


<h1>  JButton with Image </h1>
<div class="subsection"> 

A button may be made with an icon image
<pre> 
import javax.swing.*;
import java.awt.*;

public class JButtonImage extends JFrame {

  public static void main(String argv[]) {
	new JButtonImage().setVisible(true);
  }
</pre>
<h1>  </h1>
<pre> 
  public JButtonImage() {
    ImageIcon image1 =
              new ImageIcon("bart.gif");
    ImageIcon image2 =
              new ImageIcon("swing.small.gif");
    JButton btn1 = new JButton(image1);
    JButton btn2 = new JButton(image2);

    Container pane = getContentPane();
    pane.setLayout(new GridLayout(1, 2));
    pane.add(btn1);
    pane.add(btn2);
    pack();
  }
}
</pre>

If the image has a transparent background (the second one),
it looks better on pressing the button
</div> <!-- subsection -->
<br>
<hr class=PAGE-BREAK>


<h1>  JButton with more icons and text </h1>
<div class="subsection"> 

Pressed, rollover and disabled icons can also be set
<br>
<img src="abstractbuttonicons.gif">
<br>
<pre> 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class TestRollover extends JFrame {

  static public void main(String argv[]) {
    new TestRollover().setVisible(true);
  }

</pre>
<h1>  </h1>
<pre> 
  public TestRollover() {
    ImageIcon left =
              new ImageIcon("left.gif");
    ImageIcon leftRollover =
              new ImageIcon("leftRollover.gif");
    ImageIcon leftDown =
              new ImageIcon("leftDown.gif");

    JButton button = new JButton("Left",
                                 left);
    button.setPressedIcon(leftDown);
    button.setRolloverIcon(leftRollover);
    button.setRolloverEnabled(true);
    button.setToolTipText(
       "This is a Button with a RolloverIcon");

    getContentPane().add(button, "Center");
    pack();
  }
}
</pre></div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  JButton with animated icon </h1>
<div class="subsection"> 


<ul>
  <li> The image can be animated by using a multipart gif file
  <li> No other changes are needed
  <li> See Checkbox in SwingSet
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Property change listeners </h1>
<div class="subsection"> 

<ul>
  <li> Most components have state that can change
  <li> Some of this is Bean's information, and generates
    ChangeEvents
  <li> For example, JButton fires an event on change of text,
      any icon, alignment or text position, or change in
      the model (button pressed, released, etc)
</ul>

</div> <!-- subsection -->




<hr class=PAGE-BREAK>

<h1 align=center> EVENTS  </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>
<h1>  AWT events
</h1>
<ul>
<li>
Event model in Java 1.0 is poor s/w engineering, based on
class <code>Event</code>
<li>
In Java 1.1 it changes to a new model called <em/delegation/,
based on class <code>AWTEvent</code>
<li> This event handling model is unchanged for Java 1.2
<li> Event handling is the same for Swing and AWT components
<li>
Events are handled by listeners,
not by subclasses of GUI objects
</ul>

<hr class=PAGE-BREAK>

<h1>  AWT Event classes
</h1>
<p>
The class AWTEvent has subclasses:
  <ul>
  <li>
  ComponentEvent
  <li>
  FocusEvent
  <li>
  KeyEvent
  <li>
  MouseEvent
  <li>
  WindowEvent
  <li>
  ActionEvent
  <li>
  AdjustmentEvent
  <li>
  ItemEvent
</ul>

<hr class=PAGE-BREAK>

<h1>  AWT Event ids
</h1>
Some of these classes have an <code>id</code> value to distinguish between them
<ul>
<li>
KeyEvent: KEY_PRESSED, KEY_RELEASED, KEY_TYPED

<li>
ComponentEvent: COMPONENT_MOVED, COMPONENT_RESIZED, COMPONENT_SHOWN,
  COMPONENT_HIDDEN
<li>
MouseEvent: MOUSE_CLICKED, MOUSE_DRAGGED, MOUSE_PRESSED, etc
</ul>

<hr class=PAGE-BREAK>

<h1>  Triggering events
</h1>
Events are posted by user actions (or may be done programmatically)
<ul>
<li>
ActionEvent
  <ul>
  <li>
  click on JButton
  <li>
  click on JMenuItem
  <li>
  press &lt;enter&gt; key in JTextField
  </ul>
</ul>

<hr class=PAGE-BREAK>

<h1>  Listeners
</h1>
Listeners are objects that handle events
<ul>
<li>
ActionEvent handled by ActionListener
<li>
KeyEvent handled by KeyListener
<li>
Mouse motion events handled by MouseMotionListener (optimisation)
<li>
Other Mouse events handled by MouseListener 
</ul>

<hr class=PAGE-BREAK>

<h1>  Listeners as interfaces
</h1>
Listeners are defined as interfaces and must be implemented by the
application

<pre> 
public interface ActionListener
       extends EventListener {
  public void actionPerformed(ActionEvent e);
}

public interface MouseListener
       extends EventListener {
  public void mouseClicked(MouseEvent e);
  public void mousePressed(MouseEvent e);
  public void mouseReleased(MouseEvent e);
  public void mouseEntered(MouseEvent e);
  public void mouseExited(MouseEvent e);
}
</pre>


<hr class=PAGE-BREAK>

<h1>  Registering listeners
</h1>
<ul>
<li>
Each GUI object generates certain events
<li>
For each class of AWTEvent there is an add&lt;Event&gt;Listener
<li>
<i>e.g.</i>
    For Button, MenuItem and TextField there is a method
<code>addActionListener()</code>
<li>
<i>e.g.</i>
    For all Component and JComponent
<code>addMouseListener()</code>
</ul>

<hr class=PAGE-BREAK>

<h1>  Simple Delegation program (1)
</h1>

<pre> 
import javax.swing.*;
import java.awt.event.ActionListener;

public class JDelegateDemo
             extends JFrame {
  public static void main(String argv[]) {
    new JDelegateDemo().setVisible(true);
  }

  public JDelegateDemo() {
    // create the GUI objects
    JButton left = new JButton("Left");
    JButton right = new JButton("Right");
    JLabel label = new JLabel("       ",
                   SwingConstants.CENTER);
</pre><h1> </h1>
<pre> 
    // set their geometry
    Container pane = getContentPane();
    pane.add(left, "West");
    pane.add(right, "East");
    pane.add(label, "Center");
    pack();

    // continue constructor
    // create a listener and add it to each Button
    SimpleListener simple = 
        new SimpleListener(label);
    left.addActionListener(simple);
    right.addActionListener(simple);    
  }
}
</pre><h1> </h1>
<pre> 

/**
 * A listener object that is invoked
 * when a Button is activated it finds
 * the Button's label and sets it in a Label
 */
class SimpleListener implements ActionListener {

  private JLabel label;

  public SimpleListener(JLabel l) {
    // the listener needs to know the Label
    // it will act on 
    label = l;
  }
</pre><h1> </h1>
<pre> 

  public void actionPerformed(ActionEvent e) {
    // get the label showing in whichever
    // Button was pressed
    String name = e.getActionCommand();

    // set this in the Label object
    label.setText(name);
  }
}    
</pre>

<hr class=PAGE-BREAK>



<h1>  Event Delivery Model</h1>
<div class="subsection"> 

<ul>
  <li> The path taken by events is different for AWT components
      and Swing components
  <li> Native events are generated by user actions, such as
      mouse clicks.
  <li> Native events are translated into Java events, and
      sent to a Java object which has a native window
  <li>  The difference is that all AWT objects have a native
      window, but only some Swing objects such as JFrame
      have one
  <li> For the AWT, events have to be finally delivered to
      native objects to have visual effect
  <li> For Swing, a container has to pass events to its
      Swing components to have visual as well as semantic
      effect
</ul>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Event Model (2)</h1>
<div class="subsection"> 

For a mouse press and mouse release on a Button inside a Frame,
the following sequences for Java using X Windows occur
<br>
<img src="awtbtnpress.gif">
<br>
<img src="awtbtnrelease.gif">
<br>
The Motif Pushbutton recognises that it has been clicked
and sends an ActionEvent
<br>
<img src="awtaction.gif">

</div> <!-- subsection -->


<hr class=PAGE-BREAK>


<h1>  Event Model (3)</h1>
<div class="subsection"> 

For a mouse press and mouse release on a JButton inside a JFrame,
the following sequences for Java using X Windows occur
<br>
<img src="swingbtnpress.gif">
<br>
<img src="swingbtnrelease.gif">
<br>
The JButton now recognises it has been clicked
<br>
<img src="swingaction.gif">
</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1> Changing key values (1)
</h1>

<pre>
import java.awt.*;
import java.awt.event.*;

public class MapKey extends Frame {
  public static void main(String argv[]) {
    new MapKey().setVisible(true);
  }
  public MapKey() {
    TextField text = new TextField(20);
    add(text);	
    pack();
    text.addKeyListener(new ToUpper());
  }
}
</pre>

<hr class=PAGE-BREAK>

<h1> Changing key values (2)
</h1>

<pre>

class ToUpper implements KeyListener {
    
  public void keyTyped(KeyEvent e) {
    // empty
  }

  public void keyPressed(KeyEvent e) {
    e.setModifiers(Event.SHIFT_MASK);
  }

  public void keyReleased(KeyEvent e) {
    // empty
  }
}
</pre>





<hr class=PAGE-BREAK>

<h1> Consuming events
</h1>
<ul>
<li>
Events may need to be ``blocked'' from reaching objects sometimes
  <ul>
  <li>
  In password entry, keystrokes need to be caught by the application
  but not reach the Text object for display
  <li>
  A GUI builder might use mouse clicks to select objects such as
  Button, but not activate the Button
  </ul>
<li>
The delegation model allows this for key and mouse events
<li>
Events are discarded by calling the method
    <code>AWTEvent.consume()</code>
</ul>

<hr class=PAGE-BREAK>

<h1> Consuming events
</h1>

This key listener discards non-alphabetic events:
<pre>
public class Alpha implements KeyListener {
  public void keyPressed(KeyEvent e) {
    if (! Character.isLetter(e.getKeyChar())) {
      Toolkit.getDefaultToolkit().beep();
      e.consume();
     }
  }
  public void keyReleased(KeyEvent e) {
    // empty
  }
  public void keyTyped(KeyEvent e) {
    // empty
  }
}
</pre>

<hr class=PAGE-BREAK>

<h1> Generating Events
</h1>

<ul>
<li>
Events may be created and placed on the event queue for applications
<li>
The event queue is found from 
<code>Toolkit.getDefaultToolkit().getSystemEventQueue()</code>
<li>
The event queue is not accessible yet from applets (need applet queue)
<li>
Posting events works for Swing objects, but not for AWT objects
</ul>


<hr class=PAGE-BREAK>
<h1 align=center>  GEOMETRY </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  Insets 
</h1>

<ul>
<li>
An inset gives a top, bottom, left and right border within which a Container
lays out its contents.
<li>
Insets should probably be treated as readonly
</ul>

<hr class=PAGE-BREAK>


<h1>  Borders </h1>
<div class="section">

<ul>
  <li> Borders of various kinds can be created, using the insets
  <li> Types include: bevelled, etched, empty, lined
  <li> Borders can be chained to e.g. add a title to a bevel border
</ul>

<pre> 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;

public class TestBorder extends JFrame {

    static public void main(String argv[]) {
    new TestBorder().setVisible(true);
  }
</pre>
<h1>  </h1>
<pre> 
  public TestBorder() {

    Border border = BorderFactory.
                       createBevelBorder(
                           BevelBorder.RAISED);
    JLabel label = new JLabel("Hello");
    label.setBorder(border);
    getContentPane().add(label, "Center");
    pack();
  }
}
</pre>
</div> <!-- section -->

<hr class=PAGE-BREAK>


<h1> Layout Objects </h1>
<div class="section">


<ul>
<li>
Geometry layout is done by an associated Layout object
<li>
Layout objects include
  <ul>
  <li>
  BorderLayout - NSEW layout
  <li>
  FlowLayout - left-to-right with overflow
  <li>
  GridLayout - regular rectangular grid
  <li>
  GridBagLayout - general gridded layout
  </ul>
<li>
CardLayout allows ``flipping'' through a set of ``cards''
</ul>
</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  BorderLayout
</h1>

<ul>
<li>
Objects are added to the "North", "South", "West", "East" or "Center"
<li>
    Safer programs may use BorderLayout.NORTH, etc
    (compiler catches errors)
<li>
This is the default layout for JFrame

<li>
An example program is
<br>
<img src="borderlayout.gif">
</ul>

<hr class=PAGE-BREAK>

<h1>  BorderLayout (2)
</h1>

<pre> 
import java.awt.*;

class TestBorderLayout extends JFrame {
  public TestBorderLayout() {
    Container pane = getContentPane();
    pane.add(new JButton("Push Me W"), "West");
    pane.add(new JButton("Push Me E"), "East");
    pane.add(new JButton("Push Me S"), "South");
    pane.add(new JButton("Push Me N"), "North");
    setSize(400, 200);
    setVisible(true);
  }
}
</pre>

<hr class=PAGE-BREAK>

<h1>  Building your own manager
</h1>
<ul>
<li>
LayoutManager is declared as an interface
<pre> 
public interface LayoutManager {
  void addLayoutComponent(String name, Component comp);
  void removeLayoutComponent(Component comp);
  Dimension preferredLayoutSize(Container parent);
  Dimension minimumLayoutSize(Container parent);
  void layoutContainer(Container parent);
}
</pre>
</ul>

<hr class=PAGE-BREAK>

<h1>  Building your own manager
</h1>
The following manager sets the size of its (single) child (ignoring insets):
<pre> 
class SizeLayout implements LayoutManager {
  Dimension size;

  public SizeLayout() {
    size = new Dimension(0, 0);
  }

  public SizeLayout(Dimension s) {
    size = new Dimension(s);
  }

</pre>
<h1>  </h1>
<pre> 
  public void setSize(Dimension s) {
    size = new Dimension(s);
  }

  public Dimension getSize() {
    return new Dimension(size);
  }

  public void
  addLayoutComponent(String n, Component c) {
  }

  public void
  removeLayoutComponent(Component c) {
  }

</pre>
<h1>  </h1>
<pre> 
  public Dimension
  preferredLayoutSize(Container parent) {
    if (parent.countComponents() == 0)
      return new Dimension(width, height);

    // use the first component added
    Component c = parent.getComponent(0);
    return c.preferredSize();
  }

</pre>
<h1>  </h1>
<pre> 
  public Dimension
  minimumLayoutSize(Container parent) {
    if (parent.countComponents() == 0)
      return new Dimension(width, height);

    // use the first component added
    Component c = parent.getComponent(0);
    return c.minimumSize();
  }

</pre>
<h1>  </h1>
<pre> 
  public void
  layoutContainer(Container parent) {
    if (parent.countComponents() == 0)
      return;

    // use the first component added
    Component c = parent.getComponent(0);
    c.setBounds(0, 0, size.width, size.height);
    c.validate();
  }
}
</pre>

<hr class=PAGE-BREAK>


<h1>  Building constraint managers</h1>
<div class="section">

<ul>
  <li> LayoutManager2 contains extra methods for building constraint managers
</ul>
</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1> Reusing GridBagLayout</h1>
<div class="section">

Layout managers can also be built by restricting the use of
a complex manager such as <code>GridBagLayout</code>.
This manager gives a ``box of buttons'' layout

<pre> 
public class ButtonBoxLayout
       implements LayoutManager {

  GridBagLayout gridbag = new GridBagLayout();
  GridBagConstraints constraints =
             new GridBagConstraints();

  public void
  addLayoutComponent(String name, Component comp) {
    // empty -this should never be called
  }
</pre>
<h1>  </h1>
<pre> 
  public void
  removeLayoutComponent(Component comp) {
    // empty - no state maintained here
  }

  // the next three methods restore state
  // if the parent has had changes done to
  // its children, before calling gridbag
  public Dimension
  preferredLayoutSize(Container parent) {
    if ( ! parent.isValid()) {
      layoutButtons(parent);
    }
    return gridbag.preferredLayoutSize(parent);
  }

</pre>
<h1>  </h1>
<pre> 
  public Dimension
  minimumLayoutSize(Container parent) {
    if ( ! parent.isValid()) {
      layoutButtons(parent);
    }
    return gridbag.minimumLayoutSize(parent);
  }

  public void
  layoutContainer(Container parent) {
    if ( ! parent.isValid()) {
      layoutButtons(parent);
    }
    gridbag.layoutContainer(parent);
  }

</pre>
<h1>  </h1>
<pre> 
  /**
   * Find the height of the first component,
   * and add half of it
   * above and below using ipady.
   * Find the largest width, and set ipadx
   * for all components to give it that width
   */
  protected void layoutButtons(Container parent) {

    int width = parent.getSize().width;
    int nbuttons = parent.getComponentCount();

    if (nbuttons == 0)
      return;

</pre>
<h1>  </h1>
<pre> 
    constraints.weightx = 1.0;
    // stretch each component vertically
    constraints.ipady =
         parent.getComponent(0).
            getPreferredSize().height/2;

    // find the largest width
    Dimension compSize;
    int maxWidth = 0;
    for (int n = 0; n &lt; nbuttons; n++) {
      compSize = parent.getComponent(n).
                getPreferredSize();
      maxWidth = Math.max(compSize.width, maxWidth);
    }

</pre>
<h1>  </h1>
<pre> 
    // use the largest width or increase
    // using available space
    maxWidth = Math.max(width/(nbuttons*2), maxWidth);

    // set the ipadx to make each button the same size
    for (int n = 0; n &lt; nbuttons; n++) {
      Component component = parent.getComponent(n);

      compSize = component.getPreferredSize();
      constraints.ipadx = maxWidth - compSize.width;
      gridbag.setConstraints(component, constraints);
    }
  }
 }
</pre>

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1> Composite Objects</h1>
<div class="section">

Rather than doing geometry afresh each time, one can create
new composite objects which are just reused in toto

<pre> 
public class LabelledTextField extends JPanel {
  protected JLabel label;
  protected JTextField text;

  public LabelledTextField(String lab, int cols) {
    setLayout(new BorderLayout());
    label = new JLabel(lab);
    text = new JTextField(cols);
    add(label, BorderLayout.WEST);
    add(text, BorderLayout.CENTER);
  }

</pre>
<h1>  </h1>
<pre> 
  public String getText() {
    return text.getText();
  }

  public void addActionListener(ActionListener al) {
    text.addActionListener(al);
  }
}
</pre>
</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1 align=center> ARCHITECTURE </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  Swing component architecture </h1>
<div class="subsection"> 

<ul>
  <li> Swing uses a simplified version of Model-View-Controller
  <li> Each component has a <i>view</i> (UI) and a <i>model</i>
  <li> The model and the view (UI) can be independently changed
</ul>
<img src="componentarch.gif">

</div> <!-- subsection -->
<br>
<hr class=PAGE-BREAK>


<h1>  JButton structure </h1>
<div class="subsection"> 

<ul>
  <li> A JButton is a subclass of AbstractButton
  <li> An AbstractButton has a ButtonModel which can be
      manipulated by
      <pre> 
      public ButtonModel getModel();
      public void setButtonModel(ButtonModel);
      </pre>
  <li> An AbstractButton has a ButtonUI which can be
      manipulated by
      <pre> 
      public ButtonUI getUI();
      public void setUI(ButtonUI ui);
      </pre>
</ul>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  ButtonModel </h1>
<div class="subsection"> 

<ul>
  <li> ButtonModel contains many state features of a button, such as
      isArmed, isSelected, isEnabled, isPressed, isRollover,
      keyAccelerator, actionCommand.
  <li> It also maintains lists of listeners: actionListener, changeListener
  <li> These are usually accessed by methods in JButton
      <pre> 
      public boolean isSelected() {
          return model.isSelected():
      }
      </pre>
</ul>

<img src="buttonmodel.gif">

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  ButtonUI </h1>
<div class="subsection"> 

<ul>
  <li> The UI elements do not maintain component state.
  <li> They implement methods
      <pre> 
      paint()
      getPreferredSize()
      getMinimumSize()
      </pre>
  <li> A ButtonUI asks JButton and its model for any state
</ul>
<img src="buttonui.gif">

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Button UI elements </h1>
<div class="subsection"> 

<ul>
  <li> An AbstractButton holds many UI elements that are
      independent of presentation: defaultIcon, PressedIcon,
      etc, and image/text alignment such as verticalAlignment,
      verticalTextPosition
</ul>

<img src="buttonuielmts.gif">

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Button listeners </h1>
<div class="subsection"> 

There is a set of listeners to decouple model and view from
state change listeners
<br>
<img src="buttonlistener.gif">
<br>
<img src="modellistener.gif">

<ul>
  <li> A BasicButtonListener responds to events (such as
      mousePressed()) by calling methods in DefaultButtonModel
      (such as setArmed(true))
  <li> A ButtonChangeListener responds to change events posted
      by the model and fires a state change notification
      in the Button
  <li> A state change notification in the Button is noticed
      by the BasicButtonListener which calls repaint() in the
      Button
  <li> repaint() in the Button calls paint() in the
      BasicButtonUI
</ul>
Looking for state changes by listeners simplifies the model
and view a little.

</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1> Button instance </h1>

<img src="buttoninstance.gif">

<br>
<hr class=PAGE-BREAK>

<h1>  Changing the model </h1>
<div class="subsection"> 

<ul>
  <li> Problem: create a button that counts how often it
      has been pressed
  <li> A state count of the number of times needs to be kept
  <li> Define a new model CountButtonModel to extend
      DefaultButtonModel by this count
  <li> Define a new class CountButton to install this model
  <li> Hide the model by access method getCount() on
      CountButton
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  CountButtonModel
</h1>
<div class="subsection"> 

<pre> 
public class CountButtonModel
         extends DefaultButtonModel {

  protected int count = 0;

  public int getCount() {
    return count;
  }

  public void setPressed(boolean b) {
    // b is true if pressed,
    // false if released
    super.setPressed(b);
    if (b) {
      count++;
    }
  }
}
</pre>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  CountButton </h1>
<div class="subsection"> 

<pre> 
public class CountButton extends JButton {

  public CountButton() {
    this(null, null);
  }

  public CountButton(Icon icon) {
    this(null, icon);
  }
  
  public CountButton(String text) {
    this(text, null);
  }
    
</pre>
<h1>  </h1>
<pre> 
  public CountButton(String text, Icon icon) {
    super(text, icon);
    // Create the model
    setModel(new CountButtonModel());
  }

  public int getCount() {
    return ((CountButtonModel) model).getCount();
  }
}
</pre>
</div> <!-- subsection -->
<h1> </h1>


<hr class=PAGE-BREAK>

Using the CountButton is done by e.g.
<pre> 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import CountButton;

public class TestCountButton extends JFrame
               implements ActionListener{

  static public void main(String argv[]) {
    new TestCountButton().setVisible(true);
  }

</pre>
<h1>  </h1>
<pre> 
  public TestCountButton() {
    CountButton btn = new CountButton("Press me");
    getContentPane().add(btn, BorderLayout.CENTER);
    pack();
    btn.addActionListener(this);
  }

  public void actionPerformed(ActionEvent evt) {
    CountButton btn = (CountButton) evt.getSource();
    System.out.println("Count: " + btn.getCount());
  }             
}

</pre>
<hr class=PAGE-BREAK>


<h1>  Changing the UI </h1>
<div class="subsection"> 

<ul>
  <li> The supplied UI's are <i>standard</i>(Windows),
    <i>motif</i>, <i>jlf</i> (Java Look and Feel)
  <li> Microsoft have not yet granted permission for
      the standard L&F to be available on non-Windows
      platforms
  <li> Changing the UI involves two calls
      <pre> 
      UIManager.setLookAndFeel(String)
      SwingUtilities.updateComponentTreeUI(Component)
      </pre>
      where the String is eg
      "javax.swing.motif.MotifLookAndFeel" and
      the Component is the toplevel Frame or Applet
  <li> Building your own L&F means writing a UI for every
      component.
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>
<h1 align=center> JLIST  </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  JList </h1>
<div class="subsection"> 

<ul>
  <li> JList extends functionality of List, and requires
      programmatic changes
  <li> JList has a list of Object, not just String
  <li> The list can be set by a constructor
  <li> The contents of a JList are stored in the ListModel
      model,
      and you change the list by methods of the model
  <li> The UI uses a CellRenderer to paint each element
      of a list, and this can be set by an application
  <li> The listeners are ListSelectionListeners rather
      than ItemListeners
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  JList with Strings </h1>
<div class="subsection"> 

<ul>
  <li> A JList with a set of String is best made
      using a constructor
      <pre> 
      String [] elmts = {"one", "two", "three"};
      Jlist list = new JList(elmts);
      </pre>
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Simple JList example</h1>
<div class="subsection"> 

This uses a list of Strings, like List

<pre> 
import javax.swing.event.*;
import javax.swing.*;

public class TestList extends JFrame 
       implements ListSelectionListener {

static public void main(String argv[]) {
    new TestList().setVisible(true);
  }

  public TestList() {
    String [] elmts = {"one", "two", "three"};
    JList list = new JList(elmts);
    getContentPane().add(list, "Center");
    pack();
    list.addListSelectionListener(this);
  }

</pre>
<h1> </h1>
<pre> 

  public void valueChanged(ListSelectionEvent evt) {
    JList list = (JList)
                 evt.getSource();
    String value = (String)
                 list.getSelectedValue();
    if (value != null &&
        ! evt.getValueIsAdjusting()) {
      System.out.println("Selected: " +
                          value);
    }
  }
}
</pre>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  JList using Icons </h1>
<div class="subsection"> 

This shows a list of icons

<pre> 
import javax.swing.event.*;
import javax.swing.*;

public class TestIconList extends JFrame 
     implements ListSelectionListener {
  static public void main(String argv[]) {
    new TestIconList().setVisible(true);
  }

</pre>
<h1> </h1>
<pre> 
  public TestIconList() {
    ImageIcon images[] = new ImageIcon[2];
    images[0] = new ImageIcon("bart.gif");
    images[1] = new ImageIcon("swing.small.gif");

    JList list = new JList(images);
    getContentPane().add(list, "Center");
    pack();
    list.addListSelectionListener(this);
  }

</pre>
<h1> </h1>
<pre> 
  public void valueChanged(ListSelectionEvent evt) {
    JList list = (JList) evt.getSource();
    int value = list.getSelectedIndex();
    if (value != -1 && ! evt.getValueIsAdjusting()) {
      System.out.println("Selected: " + value);
    }
  }
}
</pre>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Rendering JList with a Component </h1>
<div class="subsection"> 

This shows a list of image+text, where rendering is done
by calling paint() on a JLabel:

<pre> 
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;

public class TestLabelList extends JFrame {

  static public void main(String argv[]) {
    new TestLabelList().setVisible(true);
  }

  public TestLabelList() {

    JList list = new JList(new String [] {"Bart", "Swing"});
    getContentPane().add(list, "Center");
    list.setCellRenderer(new LabelCellRenderer());
    pack();
  }
}

</pre>
<h1> </h1>
<pre> 
class LabelCellRenderer extends JLabel 
            implements ListCellRenderer {

  static protected ImageIcon images[] = {
    new ImageIcon("bart.gif"),
    new ImageIcon("swing.small.gif")
  };

  public LabelCellRenderer() {
    setOpaque(true);
  }

</pre>
<h1> </h1>
<pre> 
  public Component
  getListCellRendererComponent(
               JList list, 
               Object value, 
               int index, 
               boolean isSelected, 
               boolean cellHasFocus) {
    setText(value.toString());
    setIcon(images[index]);
    setBackground(isSelected ?
            Color.red : Color.white);
    setForeground(isSelected ?
            Color.white : Color.black);
    return this;
  }
}
</pre>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Rendering JList yourself </h1>
<div class="subsection"> 

Draw your own shapes in a JList
<pre> 
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;

public class TestDrawList extends JFrame 
     implements ListSelectionListener {
  static public void main(String argv[]) {
    new TestDrawList().setVisible(true);
  }

</pre>
<h1> </h1>
<pre> 
  public TestDrawList() {

    JList list = new JList(new String []
                 {"Circle", "Square"});
    getContentPane().add(list, "Center");
    list.setCellRenderer(new DrawCellRenderer());

    // fix cell sizes since list doesn't know them
    list.setFixedCellWidth(30);
    list.setFixedCellHeight(30);
    pack();
  }
}

</pre>
<h1> </h1>
<pre> 
class DrawCellRenderer extends JComponent 
     implements ListCellRenderer {

  protected int index;
  boolean selected;

  public boolean isOpaque() {
    return true;
  }

</pre>
<h1> </h1>
<pre> 
  public Component
  getListCellRendererComponent(
            JList list, 
            Object value, 
            int index, 
            boolean selected, 
            boolean cellHasFocus) {
    this.index = index;
    this.selected = selected;
    return this;
  }

</pre>
<h1> </h1>
<pre> 
  public void paint(Graphics g) {
    Color fg, bg;

    if (selected) {
      fg = Color.green;
      bg = Color.black;
    } else {
      fg = Color.red;
      bg = Color.white;
    }

</pre>
<h1> </h1>
<pre> 
    // fill background
    g.setColor(bg);
    g.fillRect(0, 0, getWidth(), getHeight());

    // draw shape
    g.setColor(fg);
    if (index == 0) {
      g.fillOval(5, 5, 25, 25);
    } else {
      g.fillRect(5, 5, 25, 25);
    }
  }
}
</pre>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Scrolling list </h1>
<div class="subsection"> 

<ul>
  <li> Scrolling is not a part of JList
  <li> Use a ScrollPane
    <pre> 
    JScrollPane scrollPane = new JScrollPane();
      scrollPane.getViewport().setView(list);
      </pre>
</ul>


</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1 align=center> TEXT </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>
<h1>  Text replacements</h1>
<div class="subsection"> 

<ul>
  <li> JTextArea acts as a drop in replacement for TextArea
  <li> JTextField acts as a drop in replacement for TextField
  <li> JPasswordField is a safer replacement for JTextField used
      with setEchoChar()
  <li> JTextPane can display multiple fonts, colours, etc.
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1>  Model </h1>
<div class="subsection"> 

<p>
The model is known as a <code>Document</code>, and can be shared
between Text objects.

<pre>
import javax.swing.*;
import java.awt.*;
import javax.swing.border.*;

public class Text2 extends JFrame {

  public static void main(String argv[]) {
    new Text2().setVisible(true);
  }
  
  public Text2() {
    JTextArea text1 = new JTextArea("starting text", 5, 30);
    JTextArea text2 = new JTextArea(5, 30);
    text2.setDocument(text1.getDocument());

    Border border = BorderFactory.
                       createLineBorder(Color.black);
    text1.setBorder(border);
    text2.setBorder(border);

    Container pane = getContentPane();
    pane.setLayout(new GridLayout(2, 1));
    pane.add(text1);
    pane.add(text2);
    pack();
  }
  
}
</pre>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>

<h1>  Styles </h1>
<div class="subsection"> 

<ul>
  <li> A style is a set of text display characteristics
      such as FontSize, ForegroundColor, isItalic, etc
  <li> A style is manipulated by e.g.
      <pre> 
      StyleConstants.setForeground(style, Color.red)
      </pre>
  <li> A StyleContext can hold many styles
  <li> A JTextPane can have a DefaultStyledDocument as a model
  <li> A DefaultStyledDocument has a StyleContext
  <li> Styles can be applied to portions or all of a Document
      by e.g.
      <pre> 
      JTextPane.setCharacterAttributes(Style, Boolean)
      DefaultStyledDocument.setLogicalStyle(int, Style)
      </pre>
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Changing document colours </h1>
<div class="subsection"> 

This program allows you to select a colour from a menu.
Any text entered after that will be in that colour
<pre> 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;

public class TestStyle extends JFrame
         implements ActionListener {

  private Style redStyle, blueStyle, greenStyle;
  private JTextPane text;

  public static void main(String argv[]) {
    new TestStyle().setVisible(true);
  }

</pre>
<h1> </h1>
<pre> 
  public TestStyle() {
    JTextPane text = createEditor();
    getContentPane().add(text, "Center");
    setJMenuBar(createMenu());
    setSize(200, 200);
  }

</pre>
<h1> </h1>
<pre> 
  private JMenuBar createMenu() {
    JMenuBar mbar = new JMenuBar();
    JMenu color = new JMenu("Color");
    mbar.add(color);

    JMenuItem mi = new JMenuItem("Red");
    color.add(mi);
    mi.addActionListener(this);

    mi = new JMenuItem("Blue");
    color.add(mi);
    mi.addActionListener(this);

    mi = new JMenuItem("Green");
    color.add(mi);
    mi.addActionListener(this);

    return mbar;
  }

</pre>
<h1> </h1>
<pre> 
  public void actionPerformed(ActionEvent evt) {
    Style style = null;
    String color = (String) evt.getActionCommand();
    if (color.equals("Red")) {
      style = redStyle;
    } else if (color.equals("Blue")) {
      style = blueStyle;
    } else if (color.equals("Green")) {
      style = greenStyle;
    }
    text.setCharacterAttributes(style, false);
  }

</pre>
<h1> </h1>
<pre> 
  private JTextPane createEditor() {
    StyleContext sc = createStyles();
    DefaultStyledDocument doc = new DefaultStyledDocument(sc);

    return (text = new JTextPane(doc));
  }

</pre>
<h1> </h1>
<pre> 
  private StyleContext createStyles() {
    StyleContext sc = new StyleContext();

    redStyle = sc.addStyle(null, null);
    StyleConstants.setForeground(redStyle,
                   Color.red);

    blueStyle = sc.addStyle(null, null);
    StyleConstants.setForeground(blueStyle,
                   Color.blue);

    greenStyle = sc.addStyle(null, null);
    StyleConstants.setForeground(greenStyle,
                   Color.green);
    StyleConstants.setFontSize(greenStyle, 24);

    return sc;
  }
}
</pre>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Convenience Action Listeners</h1>
<div class="subsection"> 

<ul>
  <li> StyledEditorKit has a set of ActionListener's that
    do the actionPerformed() for you
  <li> These can be added to e.g. MenuItem
  
    <pre> 
    ActionListener a =
        new StyledEditorKit.ForegroundAction(
               "set-foreground-red",
              Color.red);
    mi.addActionListener(a);
    </pre>
  <li> See Sun example StylePad for more examples
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  FileChooser
</h1>

<ul>
  <li> Some widgets can be used standalone,
    or can be embedded in dialogs
  <li> <code>JFileChooser</code> and <code>JColorChooser</code>
    have a convenience method to post a dialog
  <li> Standalone mode for <code>JFileChooser</code>
      doesn't work properly in Swing 1.0, but does in
      JDK 1.2 beta 4
</ul>

<hr class=PAGE-BREAK>
<h1>  </h1>

<pre> 
// using an embedded JFileChooser

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class BasicChooser extends JFrame 
                implements ActionListener {
  JFileChooser chooser;

  static public void main(String argv[]) {
    new BasicChooser().setVisible(true);
  }

</pre>
<h1>  </h1>
<pre> 
  public BasicChooser() {
    getContentPane().add(chooser = new JFileChooser(), 
               BorderLayout.CENTER);
    chooser.addActionListener(this);
    pack();
  }

  public void actionPerformed(ActionEvent e) {
    System.out.println(chooser.getSelectedFile().
                   getName());
  }
}
</pre>
<hr class=PAGE-BREAK>

<pre> 
// using a JFileChooser in a dialog

import java.awt.*;
import javax.swing.*;

public class BasicChooser extends JFrame {
  JFileChooser chooser;

  static public void main(String argv[]) {
    BasicChoser bc = new BasicChooser();
    bc.setVisible(true);
    chooser.showOpenDialog(bc);
    if(returnVal == JFileChooser.APPROVE_OPTION) {
      System.out.println("You selected file: " +
      chooser.getSelectedFile().getName());
    }
  }

</pre>
<h1> </h1>
<pre> 
  public BasicChooser() {
    setSize(100, 100);
  }
}
</pre>

<hr class=PAGE-BREAK>
<h1>  Menus
</h1>

<ul>
<li>
All menu components are subclassed from JMenuComponent (JMenuBar, JMenu,
JMenuItem, JCheckboxMenuItem).
<li>
Menus are pulldown  or popup
<li>
Menus can be changed by the setJMenu() of JFrame.
This unmaps the old menu and maps the new one
<li> Menus can be set on any element, not just JFrames
</ul>

<hr class=PAGE-BREAK>

<h1>  JMenuBar
</h1>
<ul>
<li>
JMenuBar provides a horizontal bar containing menu selections
<li>
Pulldown menus hang from there
<li>
It is added to Frame by Frame's method setJMenu(JMenuBar)
</ul>


<hr class=PAGE-BREAK>


<h1>  JMenu
</h1>
<ul>
  <li>
The default constructor 
<pre> 
JMenu(String label)
</pre>
creates a non-tearable menu.
<li>
    The constructor
<pre> 
JMenu(String label, boolean tearOff)
</pre>
allows control of this
</ul>

<hr class=PAGE-BREAK>

<h1>  JMenuItem and JCheckboxMenuItem
</h1>
<ul>
<li>
JMenuItem is an ordinary selection element
<li>
A JMenuItem with name ``-'' is a separator
<li>
A constructor allows a ``hot-key'' to be associated
with a JMenuItem
<li>
JCheckboxMenuItem can be set to on or off
</ul>

<hr class=PAGE-BREAK>

<h1> Menus, toolbars and abstract actions</h1>
<div class="section">
<ul>
  <li> Menus can be created as above
  <li> Toolbars can be created using <code>JToolBar</code>
  <li> Often they duplicate behaviour, i.e. have the same
      listeners
  <li> Often they must be manipulated together e.g. disabled
  <li> <code>AbstractAction</code> looks after this
</ul>

</pre>
<h1> </h1>
<pre> 
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;

public class TestAction extends JFrame {
  OpenAction openAction = new OpenAction();
  SaveAction saveAction = new SaveAction();
  
  public static void main(String argv[]) {
    new TestAction().show();
  }

</pre>
<h1> </h1>
<pre> 
  TestAction()
  {
    createMenu();
    createToolBar();
    setSize(300, 300);
  }
  
</pre>
<h1> </h1>
<pre> 
  private void createMenu()
  {
    JMenuBar mb = new JMenuBar();
    JMenu fileB = new JMenu("File");
    mb.add(fileB);
    
    fileB.add(openAction);
    fileB.add(saveAction);
    
    setJMenuBar(mb);
  }
  
</pre>
<h1> </h1>
<pre> 
  private void createToolBar() {
    JToolBar bar = new JToolBar();
    bar.add(openAction);
    bar.add(saveAction);
    getContentPane().add(bar, BorderLayout.NORTH);
  }
}
  
</pre>
<h1> </h1>
<pre> 
class OpenAction extends AbstractAction {
  
  public OpenAction() {
    super("Open", new ImageIcon("open.gif"));
  }
  
  public void actionPerformed(ActionEvent e) {
    System.out.println("Open action");
  }
}

</pre>
<h1> </h1>
<pre> 
class SaveAction extends AbstractAction {
  
  public SaveAction() {
    super("Save", new ImageIcon("save.gif"));
  }
  
  public void actionPerformed(ActionEvent e) {
    System.out.println("Save action");
  }
}
</pre>

</div> <!-- section -->

<hr class=PAGE-BREAK>
<h1 align=center> DIALOGS </h1>
<div class="section">

</div> <!-- section -->

<hr class=PAGE-BREAK>

<h1>  Dialogs </h1>
<div class="subsection"> 
<ul>
  <li> JOptionPane allows simple dialogs to be built
  <li> The dialogs are modal
  <li> The simplest use is just a oneline inline call
</ul>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Dialog types </h1>
<div class="subsection"> 

The dialog types can be
<ul>
  <li> ERROR_MESSAGE
  <li> INFORMATION_MESSAGE
  <li> WARNING_MESSAGE
  <li> QUESTION_MESSAGE
  <li> PLAIN_MESSAGE
</ul>
This controls the default icon used
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Dialog buttons </h1>
<div class="subsection"> 

The dialog buttons can be
<ul>
  <li> DEFAULT_OPTION
  <li> YES_NO_OPTION
  <li> YES_NO_CANCEL


  <li> OK_CANCEL
</ul>
You can choose your own buttons (labels or images)
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Default warning dialog </h1>
<div class="subsection"> 

Use JOptionPane.showMessageDialog():
<pre> 
import javax.swing.*;
import java.awt.event.*;

public class TestWarning extends JFrame 
             implements ActionListener {

  public static void main(String argv[]) {
    new TestWarning().setVisible(true);
  }

  public TestWarning() {
    JButton btn = new JButton("Show dialog");
    getContentPane().add(btn, "Center");
    pack();
    btn.addActionListener(this);
  }

</pre>
<h1> </h1>
<pre> 
  public void actionPerformed(ActionEvent evt) {
    JOptionPane.showMessageDialog(this,
              "Warning", 
              "Warning Dialog", 
               JOptionPane.WARNING_MESSAGE);
  }
}
</pre>
</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Confirmation dialog </h1>
<div class="subsection"> 

<pre> 
import javax.swing.*;
import java.awt.event.*;

public class TestConfirmation extends JFrame 
             implements ActionListener {

  public static void main(String argv[]) {
    new TestConfirmation().setVisible(true);
  }

</pre>
<h1> </h1>
<pre> 
  public TestConfirmation() {
    JButton btn = new JButton("Show dialog");
    getContentPane().add(btn, "Center");
    pack();
    btn.addActionListener(this);
  }

</pre>
<h1> </h1>
<pre> 
  public void actionPerformed(ActionEvent evt) {
    int response = JOptionPane.showConfirmDialog(this,
              "Answer Yes or No", 
              "Confirmation Dialog", 
               JOptionPane.YES_NO_OPTION);
    String responseStr = null;
    if (response == JOptionPane.YES_OPTION) {
      responseStr = "Yes";
    } else {
      responseStr = "No";
    }
    System.out.println("Response: " + responseStr);
  }
}
</pre>

</div> <!-- subsection -->


<hr class=PAGE-BREAK>


<h1>  Input dialog </h1>
<div class="subsection"> 

<pre> 
import javax.swing.*;
import java.awt.event.*;

public class TestInput extends JFrame 
             implements ActionListener {

  public static void main(String argv[]) {
    new TestInput().setVisible(true);
  }

</pre>
<h1> </h1>
<pre> 
  public TestInput() {
    JButton btn = new JButton("Show dialog");
    getContentPane().add(btn, "Center");
    pack();
    btn.addActionListener(this);
  }

</pre>
<h1> </h1>
<pre> 
  public void actionPerformed(ActionEvent evt) {
    String response = JOptionPane.showInputDialog(this,
              "Enter name", 
              "Input Dialog", 
               JOptionPane.DEFAULT_OPTION);
    System.out.println("Response: " + response);
  }
}
</pre>

</div> <!-- subsection -->

<hr class=PAGE-BREAK>


<h1>  Other dialogs </h1>
<div class="subsection"> 

<ul>
  <li> You can also present a list of options and choose one
  <li> More general dialogs have to be custom built - including
    you doing the placement of buttons (a special layout
    manager, SyncingLayoutManager, is <i>not</i> public)
</ul>

</div> <!-- subsection -->


</div section>

<hr class=PAGE-BREAK>

<h1>  Keyboard traversal </h1>
<div class="section">

<ul>
  <li> There is a default keyboard traversal mechanism,
      such as TAB moving focus to the right in GridLayout
  <li> Additional control may be obtained using the
      <code>registerKeyboardAction()</code>, which adds
      an <code>ActionListener</code> to specified keys
</ul>

<h1>  </h1>

The following program moves an X around a 3x3 set of buttons
by use of the arrow keys
<pre> 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;

public class TestKeyboardAction extends JFrame
                  implements ActionListener {

  protected JButton [] buttons = new JButton[9];

  static public void main(String argv[]) {
    new TestKeyboardAction().show();
  }

</pre>
<h1> </h1>
<pre> 
  public TestKeyboardAction() {
    Container pane = getContentPane();
    pane.setLayout(new GridLayout(3, 3));

    Border border = BorderFactory.
               createLineBorder(
                 Color.black);
    KeyStroke up = KeyStroke.getKeyStroke(
                 KeyEvent.VK_UP, 0);
    KeyStroke down = KeyStroke.getKeyStroke(
                 KeyEvent.VK_DOWN, 0);
    KeyStroke left = KeyStroke.getKeyStroke(
                 KeyEvent.VK_LEFT, 0);
    KeyStroke right = KeyStroke.getKeyStroke(
                 KeyEvent.VK_RIGHT, 0);

</pre>
<h1> </h1>
<pre> 
    JRootPane rootPane = getRootPane();
    rootPane.registerKeyboardAction(this,
            "up", up,
            JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    rootPane.registerKeyboardAction(this,
            "down", down,
            JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    rootPane.registerKeyboardAction(this,
            "right", right,
            JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    rootPane.registerKeyboardAction(this,
            "left", left,
            JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

</pre>
<h1>  </h1>
<pre> 
    for (int n = 0; n &lt; 9; n++) {
      JButton button = new JButton();
      button.setBorder(border);
      button.setName(new Integer(n).toString());
      pane.add(button);

      buttons[n] = button;
    }
    setSize(200, 200);
  }

</pre>
<h1> </h1>
<pre>   
  public void actionPerformed(ActionEvent e) {

    Component focusOwner = getFocusOwner(); // Window method
    String name = focusOwner.getName(); // get btn's name
    int index = Integer.parseInt(name); // as an int
    buttons[index].setText(""); // clear text
    String action = e.getActionCommand();

</pre>
<h1>  </h1>
<pre> 
    // find next index for this action
    if (action.equals("up")) {
      index = (index &lt; 3) ? index + 6 : index - 3;
    } else if (action.equals("down")) {
      index = (index &gt; 5) ? index - 6 : index + 3;
    } else if (action.equals("left")) {
      index = (index == 0) ? index = 8 : index - 1;
    } else { // assume right
      index = (index == 8) ? index = 0 : index + 1;
    }

</pre>
<h1>  </h1>
<pre> 
    buttons[index].setText("X"); // set text in next btn
    buttons[index].requestFocus(); // and focus to it
  }
}

</pre>
</div> <!-- section -->

<hr class=PAGE-BREAK>


<h1>  Further Information </h1>
<div class="subsection"> 

<ul>
  <li> Swing 0.5 has a nice overview. This disappeared in
    later versions
  <li> JDK 1.2 beta has source code for the Swing set,
       in package java.awt.swing, and Swing 1.1 has it in
       package javax.swing.
  <li> The Javadoc documentation can be downloaded from java.sun.com
<li>
</ul>
</div> <!-- subsection -->

<br>
<hr>
<br>
<address>Jan Newmarch <a href="http://jan.netcomp.monash.edu.au/">(http://jan.netcomp.monash.edu.au)</a></address>
<a href="mailto:jan.newmarch@infotech.monash.edu.au">jan.newmarch@infotech.monash.edu.au</a><br>
<!-- hhmts start -->
Last modified: Thu Jan 28 10:23:50 EST 1999
<!-- hhmts end -->
<br>Copyright &copy;Jan Newmarch</body> </html>


<hr>
All material on this site is under the copyright restriction and
permissions of the Open Content license,
<a href="http://www.opencontent.org/opl.shtml">
http://www.opencontent.org/opl.shtml </a>


