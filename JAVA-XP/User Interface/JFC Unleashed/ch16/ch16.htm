<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 16 - Split Pane</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch15\ch15.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch17\ch17.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;16<br>
Split Pane</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TheTTFONTSIZEJSplitPaneFONTTTFONTSIZEClassFONT">
The <TT>JSplitPane</TT> Class
</A>
<UL>
<LI><A HREF="#TTFONTSIZEJSplitPaneFONTTTFONTSIZEDividerConfigurationFONT">
<TT>JSplitPane</TT> Divider
Configuration</A>
<LI><A HREF="#ControllingComponentSizes">
Controlling Component Sizes</A>
<LI><A HREF="#NestingTTFONTSIZEJSplitPaneFONTTTFONTSIZEInstancesFONT">
Nesting <TT>JSplitPane</TT>
Instances</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Many modern user interfaces allow multiple views to appear in
the same frame. The user can drag the divider between the views
to allocate the space given to each view. The JFC provides the
<TT>JSplitPane</TT> class to manage two components that can be
interactively resized by the user. Each split pane manages two
components. However, the child components themselves may be instances
of the <TT>JSplitPane</TT> class. The nesting of split panes allows
an arbitrary number of resizable panes to be available in a single
window.
<P>
In this chapter, you will learn
<UL>
<LI>How to use the <TT>JSplitPane</TT> class.
<LI>How to configure the <TT>JSplitPane</TT> divider.
<LI>How to nest <TT>JSplitPane</TT> instances.
</UL>
<H2><A NAME="TheTTFONTSIZEJSplitPaneFONTTTFONTSIZEClassFONT">
The <TT>JSplitPane</TT> Class
</A></H2>
<P>
The <TT>JSplitPane</TT> class manages two child components that
are separated by a divider. When the mouse cursor is over the
divider, it changes to the Resize icon. The user can drag the
divider to alter the size of the two components. The components
can be stacked on top of each other or be placed side-by-side.
<P>
The default <TT>JSplitPane</TT> constructor creates a split pane
that positions the two managed components side-by-side. The following
code fragment creates a split pane and adds two managed components:
<BLOCKQUOTE>
<PRE>
splitPane = new JSplitPane();
splitPane.setRightComponent( rightComponent );
splitPane.setLeftComponent( leftComponent );
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setRightComponent</TT> and <TT>setLeftComponent</TT> methods
specify the two components that the split pane manages. When the
components are aligned top-to-bottom, the <TT>setTopComponent</TT>
and <TT>setBottomComponent</TT> methods can be used to specify
the managed components. If the split pane is configured right-to-left,
the <TT>setTopComponent</TT> method specifies the left component
and the <TT>setBottomComponent</TT> method specifies the right
component. Similarly, if the split pane is configured for top-to-bottom
placement, the <TT>setLeftComponent</TT> method specifies the
top component and the <TT>setRightComponent</TT> method specifies
the bottom component.
<P>
The current components in each region in the split pane can be
queried with the <TT>getBottomComponent</TT>, <TT>getTopComponent</TT>,
<TT>getRightComponent</TT>, and <TT>getLeftComponent</TT> methods.
The <TT>getBottomComonent</TT> and <TT>getRightComponent</TT>
methods return the same component. Similarly, <TT>getTopComponent</TT>
and <TT>getLeftComponent</TT> both return the other component
in the split pane. If either of the managed components is <TT>null</TT>,
the other component receives the entire area allocated to the
split pane, and the user cannot drag the divider. Unfortunately,
there is no visual feedback to the user that the divider is disabled.
The cursor also still changes to the Resize icon, telling the
user that the drag operation should succeed.
<P>
The default constructor of the <TT>JSplitPane</TT> class creates
two instances of the <TT>JButton</TT> class and adds them as the
left and right components in the split pane. Thus, if you create
a split pane using the default constructor and don't add any components,
you'll get a split pane containing two buttons, as shown in Figure
16.1.
<P>
<A HREF="javascript:popUp('f16-1.gif')"><B>Figure 16.1 :</B> <I>The JSplitPane instance resulting from
the default constructor</I>.</A>
<P>
The orientation for the split pane can be specified at construction
or changed later with the setOrientation method. One of two constants,
VERTICAL_SPLIT or HORIZONTAL_SPLIT, defined in the JSplitPane
class, is passed to this method. The parameter specifies the orientation
of the managed components, not the divider component. The default
orientation is HORIZONTAL_SPLIT, which results in a left-to-right
component placement. The current orientation can be queried with
the getOrientation method. The orientation is a bound property
of the JSplitPane class. The complete list of bound properties
introduced in the JSplitPane class is shown in Table 16.1. The
property names are constants defined in the JSplitPane class.
<P>
There is a version of the constructor for the <TT>JSplitPane</TT>
class in which the orientation and managed components can be specified.
An example usage of this constructor is shown next. When a vertical
split pane is constructed, the components are specified top and
then bottom. When a horizontal split pane is constructed, the
components are specified left and then right.
<BLOCKQUOTE>
<PRE>
splitPane = new JSplitPane( JSplitPane.VERTICAL_SPLIT,
                topComponent, bottomComponent );
splitPane = new JSplitPane( JSplitPane.HORIZONTAL_SPLIT,
                leftComponent, rightComponent );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 16.1&nbsp;&nbsp;Bound Properties Defined by the
</B><TT><B>JSPLITPANE</B></TT><B>
Class</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=192><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=192><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>DIVIDER_SIZE_PROPERTY</TT></TD><TD WIDTH=192><TT>setDividerSize</TT>
</TD><TD WIDTH=192><TT>getDividerSize</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ONE_TOUCH_EXPANDABLE_PROPERTY</TT></TD><TD WIDTH=192><TT>setOneTouchExpandable</TT>
</TD><TD WIDTH=192><TT>isOneTouchExpandable</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>LAST_DIVIDER_LOCATION_PROPERTY</TT></TD><TD WIDTH=192><TT>setLastDividerLocation</TT>
</TD><TD WIDTH=192><TT>getLastDividerLocation</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ORIENTATION_PROPERTY</TT></TD><TD WIDTH=192><TT>setOrientation</TT>
</TD><TD WIDTH=192><TT>getOrientation</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CONTINUOUS_LAYOUT_PROPERTY</TT></TD><TD WIDTH=192><TT>setContinuousLayout</TT>
</TD><TD WIDTH=192><TT><TT>isContinuousLayout</TT></TT></TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
By default, when the user drags the divider, the components in
the split pane are not redrawn until the drag operation is complete.
However, the <TT>setContinuousLayout</TT> method can be passed
the parameter of <TT>true</TT> to force the components to be laid
out and painted as the user drags the divider. The current value
of this property can be queried with the <TT>isContinuousLayout</TT>
method. Be careful about setting the <TT>CONTINUOUS_LAYOUT_PROPERTY</TT>
to <TT>true</TT>. For complex components in the split pane, the
dragging can become very slow, making your application appear
sluggish to the user.
<P>
The <TT>JSplitPaneTest</TT> application is a complete example
of the <TT>JSplitPane</TT> class. It is shown in Listing 16.1.
A <TT>static</TT> <TT>main</TT> method is provided to execute
the application. In the <TT>main</TT> method, an <TT>ApplicationFrame</TT>
instance is instantiated. Then an instance of the <TT>JSplitPaneTest</TT>
class is constructed and added to the content pane of the frame.
Finally, the frame is displayed. In the <TT>JSplitPaneTest</TT>
class' constructor, a <TT>JSplitPane</TT> instance is created
and a table and tabbed pane are added to the right and left sides,
respectively. The table and tabbed pane classes were presented
in Chapters 11 and 12, and the details of their usage won't be
repeated here. The frame containing the split pane created by
the <TT>JSplitPaneTest</TT> application is shown in Figure 16.2.
<P>
<A HREF="javascript:popUp('f16-2.gif')"><B>Figure 16.2 :</B> <I>The JSplitPaneTest application window</I>.</A>
<P>
<HR>
<P>
<B>Listing 16.1&nbsp;&nbsp;The JSplitPaneTest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import java.io.Serializable;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;

import com.foley.utility.JBox;
import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JSplitPane in a frame.
 * The components in the split pane are a table and
 * a tabbed pane.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class JSplitPaneTest extends Object { 
     
    /**
     * The splitPane for the test.
     **/
    JSplitPane splitPane;
    
    
    /**
     * JSplitPaneTest, Constructor
     * &lt;p&gt;
     * Create a splitpane and add a table and tabbedpane
     * to the splitpane.
     **/
    public JSplitPaneTest() { 
        splitPane = new JSplitPane();
        splitPane.setRightComponent( createTabbedPane() );
        splitPane.setLeftComponent( createTable() );
    } 
    

    /**
     * @return The split pane.
     **/
    public JSplitPane getSplitPane() { 
        return( splitPane );
    } 
    
    
    /**
     * Create the tabbed pane used in the application.
     * Add a few interesting tabs.
     * &lt;p&gt;
     * @return The tab pane instance for this application.
     **/
    protected JTabbedPane createTabbedPane() { 
        JTabbedPane tabbedPane = new JTabbedPane();

        addTab( tabbedPane, &quot;Tab1&quot; );        
        addTab( tabbedPane, &quot;Tab2&quot; );        
        addTab( tabbedPane, &quot;Tab3&quot; );        
        
        tabbedPane.setForegroundAt( 0, Color.red );
        tabbedPane.setBackgroundAt( 0, Color.yellow );
        tabbedPane.setForegroundAt( 1, Color.yellow );
        tabbedPane.setBackgroundAt( 1, Color.red );
        
        return( tabbedPane );
    } 
    
    
    /**
     * Create a table and place the table in a scrollpane.
     * &lt;p&gt;
     * @return  The scrollpane containing the table.
     **/
    public JComponent createTable() { 
        JTable table = new JTable( new TableTestModel() );
        
        //
        // Create and register a Color class renderer.
        //
        DefaultTableCellRenderer colorRenderer = 
            new DefaultTableCellRenderer() { 
            public void setValue( Object value ) { 
                setBackground( ( Color )value );
            } 
        } ;

        colorRenderer.setOpaque( true );
        table.setDefaultRenderer( Color.class, colorRenderer );
        table.setDefaultRenderer( Boolean.class, 
                                  new SelectedCheckBoxRenderer() );
        
        JScrollPane scrollPane = new JScrollPane( table );
        return( scrollPane );
    } 
    
    
    /**
     * Create a JLabel and add it to the tabbed pane.
     * The text of the label matches the tab's text, and
     * is simply the number of tabs created during this
     * run of the application.
     **/
    private void addTab( final JTabbedPane tabbedPane, String name ) { 
        final JPanel panel = new JPanel();
        panel.setLayout( new BorderLayout() );
        
        panel.add( new JLabel( name ), BorderLayout.NORTH );
        final JTextField textField = new JTextField( name );
        
        JBox box = JBox.createHorizontalJBox();
        box.add( new JLabel( &quot;Tab name: &quot; ) );
        textField.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                //
                // Update the title of our tab to that entered.
                //
                String newTitle = textField.getText();
                int index = tabbedPane.indexOfComponent( panel );
                tabbedPane.setTitleAt( index, newTitle );
                //
                // validate and paint the tabs to display properly.
                //
                tabbedPane.revalidate();
                tabbedPane.repaint();
            }  
        }  );
        
        box.add( textField );
        panel.add( box, BorderLayout.SOUTH );
        
        tabbedPane.add( panel, name );
        tabbedPane.revalidate();
        
    }     
    
    
    /**
     * Application entry point.
     * Create the frame, and display a splitpane in it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;JSplitPaneTest&quot; );
        JSplitPaneTest test = new JSplitPaneTest();
                        
        frame.getContentPane().add( test.getSplitPane(), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // JSplitPaneTest


/**
 * Table model that returns the Class of the data in
 * a particular column. This allows the table to set
 * renderers for the data.
 **/
class TableTestModel extends AbstractTableModel 
    implements Serializable { 

    /**
     * The data in the model.
     **/
    Object[][] data = { 
     {  &quot;Mike&quot;, Color.blue, new Boolean( true ), new Integer( 9 ) } ,
     {  &quot;Mari&quot;, Color.red, new Boolean( true ), new Integer( 6 ) } ,
     {  &quot;Molly&quot;, Color.yellow, new Boolean( false ), new Integer( 1 ) } ,
     {  &quot;Betsy&quot;, Color.orange, new Boolean( false ), new Integer( 8 ) } ,
     {  &quot;Bobby&quot;, Color.lightGray, new Boolean( true ), new Integer( 7 ) } ,
     {  &quot;Trisha&quot;, Color.gray, new Boolean( false ), new Integer( 10 ) } ,
     {  &quot;Sam&quot;, Color.white, new Boolean( true ), new Integer( 12 ) } ,
     {  &quot;John&quot;, Color.black, new Boolean( false ), new Integer( 11 ) }  } ;

    /**
     * The column names for the model.
     **/
    String[] columnNames = {  &quot;Name&quot;, &quot;Color&quot;, &quot;Enabled&quot;, &quot;Size&quot; } ;


    /**
     * TableTestModel, constructor.
     **/
    TableTestModel() { 
        super();
    } 


    /**
     * getRowCount, from TableModel.
     *
     * @return The number of rows in the data.
     **/
    public int getRowCount() { 
        return( data.length );
    } 


    /**
     * getColumnCount, from TableModel.
     *
     * @return The number of columns in the data.
     **/
    public int getColumnCount() { 
        return( data[0].length );
    } 

    /**
     * getValueAt, from TableModel.
     *
     * @param row The row of the reqeusted data object.
     * @param column The column of the reqeusted data object.
     * @return The object at the specified cell.
     **/
    public Object getValueAt( int row, int column ) { 
        return( data[ row ][ column ] );
    } 

    /**
     * setValueAt, from TableModel.
     *
     * Set the data value in the given location to the
     * given object.
     *
     * @param value The new data object.
     * @param row The row of the new data object.
     * @param column The column of the new data object.
     **/
    public void setValueAt( Object value, int row, int column ) { 
        if( column == 0 )
            throw new RuntimeException( 
                      &quot;The Name column is not editable&quot; );

        data[ row ][ column ] = value;
        fireTableCellUpdated( row, column );
    } 


    /**
     * getColumnName, from TableModel.
     *
     * @param column The column index whose name is desired.
     * @return The name of the column with the given index.
     **/
    public String getColumnName( int column ) { 
        return( columnNames[ column ] );
    } 

    /**
     * getColumnClass, from TableModel.
     *
     * @param column The column index whose Class is desired.
     * @return The Class of the data for the column with the given index.
     **/
    public Class getColumnClass( int column ) { 
        return( data[0][ column ].getClass() );
    } 


    /**
     * isCellEditable, from TableModel.
     *
     * All columns except the first are editable in this model.
     *
     * @param row The row of the cell whose editablility is requested.
     * @param column The column of the cell whose state is requested.
     * @return true if the cell is editable, false otherwise.
     **/
    public boolean isCellEditable( int row, int column ) { 
        if( column == 0 ) { 
            return( false );
        }  else { 
            return( true );
        } 
    } 
} 


/**
 * ColorCellRenderer is a rendering class that expects
 * Color values. When this is the case, it paints the color
 * as the background of the label. If not, show the String
 * returned from the toString method of the value Object.
 *
 * @author Mike Foley
 **/
class ColorCellRenderer extends JLabel
    implements ListCellRenderer, Serializable { 

    Border selectedWhiteBorder;
    Border selectedBlackBorder;

    /**
     * ColorCellRenderer, default constructor.
     * We must be opaque so the background is painted.
     **/
    public ColorCellRenderer() { 
        setOpaque( true );
        selectedWhiteBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.white );
        selectedBlackBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.black );
    } 


    /**
     * Configure ourself for the state passed.
     * If the value is a Color, set the background to that
     * color. If not use the toString method of the value
     *
     **/
    public Component getListCellRendererComponent(
        JList list,
        Object value,
        int index,
        boolean isSelected,
        boolean cellHasFocus)
    { 

        if( value instanceof Color ) { 
            setText( &quot;      &quot; );
            setBackground( ( Color )value );
            if( isSelected ) { 
                if( value.equals( Color.white ) )
                    setBorder( selectedBlackBorder );
                else
                    setBorder( selectedWhiteBorder );
            }  else { 
                setBorder( null );
            } 
        }  else { 
            setText( value.toString() );
            if( isSelected ) { 
                setBackground( list.getSelectionBackground() );
                setForeground( list.getSelectionForeground() );
            }  else { 
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            } 
        } 


        return this;
    } 

}  // ColorCellRenderer


/**
 * The SelectedCheckBoxRenderer class is almost the same as the
 * default check box renderer in the JTable class. However, it
 * paints the cell in the normal table selected colors when it is
 * selected. This avoids the white areas in the table for Boolean
 * columns. Also, if all columns in the table are Boolean, you
 * wouldn't be able to see the selected row using the default 
 * renderer!
 *
 * @author Mike Foley
 **/
class SelectedCheckBoxRenderer extends JCheckBox
    implements TableCellRenderer, Serializable { 

    private Border noFocusBorder;
    private Color unselectedForeground;
    private Color unselectedBackground;


    /**
     * SelectedCheckBoxRenderer, default constructor.
     *
     * We need to be opaque so our background color is painted.
     * Create our border. Keep a reference around so it can be
     * reset when we are not selected.
     * Center the checkbox to match the position of the Boolean editor.
     **/
    public SelectedCheckBoxRenderer() { 
           super();
       setOpaque( true );

        noFocusBorder = BorderFactory.createEmptyBorder( 1, 2, 1, 2 );
        setBorder( noFocusBorder );

        setHorizontalAlignment( JLabel.CENTER );
    } 


    /**
     * Set the foreground color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new foreground color.
     **/
    public void setForeground(Color c) { 
        super.setForeground(c);
        unselectedForeground = c;
    } 


    /**
     * Set the background color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new background color.
     **/
    public void setBackground(Color c) { 
        super.setBackground(c);
        unselectedBackground = c;
    } 


    /**
     * Clear the foreground and background colors after
     * updating the UI. This will cause the colors to be
     * read from the table property portion of the UI.
     **/
    public void updateUI() { 
        super.updateUI();
            setForeground( null );
            setBackground( null );
    } 


    /**
     * getTableCellRendererComponent, from TableCellRenderer
     *
     * Configure the checkbox for the given state.
     *
     **/
    public Component getTableCellRendererComponent( JTable table, 
                         Object value,
                         boolean isSelected, 
                         boolean hasFocus, 
                         int row, int column ) { 

        //
        // Check or uncheck the JCheckBox.
        //
        setSelected((value != null &amp;&amp; ((Boolean)value).booleanValue()));

        //
        // If we are selected, paint in the table's selection colors.
        //
            if( isSelected ) { 
               super.setForeground( table.getSelectionForeground() );
               super.setBackground( table.getSelectionBackground() );
            }  else { 
                super.setForeground( ( unselectedForeground != null ) ?
                      unselectedForeground : table.getForeground() );
                super.setBackground( ( unselectedBackground != null ) ? 
                      unselectedBackground : table.getBackground() );
        }  // else

        //
        // If we have the focus, paint in the focus color for the table.
        // and set the focus border.
        // If not, set the no focus border.
        //
            if( hasFocus ) { 
                setBorder( UIManager.getBorder( 
                          &quot;Table.focusCellHighlightBorder&quot; ) );
                if (table.isCellEditable(row, column)) { 
                    super.setForeground( UIManager.getColor( 
                                        &quot;Table.focusCellForeground&quot; ) );
                    super.setBackground( UIManager.getColor( 
                                     &quot;Table.focusCellBackground&quot; ) );
                } 
            }  else { 
                setBorder( noFocusBorder );
            } 

        return( this );
    } 

}  // SelectedCheckBoxRenderer
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TTFONTSIZEJSplitPaneFONTTTFONTSIZEDividerConfigurationFONT">
<TT>JSplitPane</TT> Divider
Configuration</A></H3>
<P>
In the <TT>JSplitPaneTest</TT> application, the default configuration
for the divider was used. The size of the slider is look-and-feel
dependent. The divider in the Windows look-and-feel is three pixels
wide, in the Java look-and-feel it is eight pixels wide, and in
the motif look-and-feel it is a whopping 18 pixels wide. If the
default value of the divider is not appropriate for your application,
you can specify it by using the <TT>setDividerSize</TT> method.
The current size of the divider can be queried with the <TT>getDividerSize</TT>
method. As shown in Table 16.1, the divider's size is a bound
property of the <TT>JSplitPane</TT> class.
<P>
The divider can be configured with a region that allows either
panel to be collapsed by clicking the mouse over the control.
Once collapsed, the panel can be restored to its original size
by clicking on the other arrow in the one-touch control. The <TT>setOneTouchExpandable</TT>
method activates or deactivates this control. Its current state
can be queried with the <TT>isOneTouchExpandable</TT> method.
The <TT>oneTouchExpandable</TT> property is a bound property of
the <TT>JSplitPane</TT> class. Add the following line of code
to the <TT>JSplitPaneTest</TT> constructor to enable one-touch
expansion mode in the split pane:
<P>
<TT>splitPane.setOneTouchExpandable( true
);</TT>
<P>
The resulting window is shown in Figure 16.3. The one-touch region
is the area with the two black arrows at the top of the divider.
Clicking the top arrow collapses the left region, and clicking
the bottom arrow collapses the right region. Figure 16.4 shows
the window after the top arrow has been clicked to collapse the
region containing the table. The bottom arrow would be clicked
to restore the window to its original layout.
<P>
<A HREF="javascript:popUp('f16-3.gif')"><B>Figure 16.3 :</B> <I>A one-touch control added to JSplitPane</I>.</A>
<P>
<A HREF="javascript:popUp('f16-4.gif')"><B>Figure 16.4 :</B> <I>and a collapsed JSplitPane</I>.</A><P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
When you're using the one-touch control, the default divider size of the Windows and Java look-and-feels makes the control difficult to click. This is more of a factor with the Windows look-and-feel. Increasing the size of the divider to 10 pixels or more gives the controls more space, allowing them to be clicked easier.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The location of the divider can be specified by the application
using the <TT>setDividerLocation</TT> method. The integer parameter
to this method is look-and-feel dependent. However, the current
look-and-feel implementations interpret this parameter as a pixel
count. It is the x location for a horizontally aligned split pane
and the y location for a vertically aligned split pane. The current
value of the divider can be queried with the <TT>getDividerLocation</TT>
method.
<P>
The previous divider location is a bound property of the split
pane. When the continuous layout property is <TT>false</TT>, a
property change listener will be notified of the last divider
location after a drag operation is complete. The name of the property
in the <TT>PropertyChangeEvent</TT> is the <TT>String</TT> defined
by the <TT>LAST_DIVIDER_LOCATION_PROPERTY</TT> constant in the
<TT>JSplitPane</TT> class. If the continuous layout property is
<TT>true</TT>, the listener will receive a stream of change events
as the user drags the divider. The <TT>getDividerLocation</TT>
method can be used to query the current location of the divider
in the <TT>propertyChange</TT> method. The <TT>getLastDividerLocation</TT>
method can be called to query the divider's previous location.
This value is also delivered to listeners by the <TT>PropertyChange</TT>
event.
<P>
There is a <TT>setLastDividerLocation</TT> method that is used
by the look-and-feel implementations to set this property and
initiate the <TT>PropertyChangeEvent</TT> being fired. This method
is rarely used by user applications.
<P>
There is also a variant of the <TT>setDividerLocation</TT> method
that takes a <TT>double</TT> as its parameter. The parameter must
be between 0.0 and 1.0. It is interpreted as the percentage of
the split pane given to the top or left component, depending on
the orientation. The remainder of the area is given to the other
component. Calling this method will also cause a <TT>LAST_DIVIDER_LOCATION_PROPERTY</TT>
<TT>PropertyChangeEvent</TT> to be sent to any <TT>PropertyChangeListeners</TT>
listeners registered on the split pane.
<P>
The minimum and maximum placement locations for the divider can
be queried with the <TT>getMinimumDividerLocation</TT> and <TT>getMaximumDividerLocation</TT>
methods. These values cannot be set directly by the application.
Instead, they are determined by the preferences of the components
managed by the split pane. Component sizing is discussed in the
next section.
<H3><A NAME="ControllingComponentSizes">
Controlling Component Sizes</A></H3>
<P>
The <TT>JSplitPane</TT> class manages two AWT component children.
When either or both of these components are instances of the <TT>JComponent</TT>
class, the <TT>JSplitPane</TT> class respects the <TT>minimumSize</TT>
property of the child. If this property is set to a nonzero value
in the child component, the divider can't move into a position
that would make that component smaller than its minimum size.
However, if the split pane is contained in the content pane of
a <TT>JFrame</TT> instance, as in the <TT>JSplitPaneTest</TT>
application shown earlier in this chapter, resizing the frame
can make a component smaller than its minimum size. This causes
the divider to jump to the component's minimum size the next time
the user drags it.
<P>
When the split pane is smaller than the combined minimum sizes
of its managed children, the user cannot drag the divider. Unfortunately,
the user doesn't get any visual feedback that this condition has
been entered. The cursor still changes to the Resize icon, telling
the user that the divider can be dragged. This gives the user
the impression that there is something wrong with the application
when in fact there is not. To correct this problem, the splitpane
should not change the shape of the cursor to the Resize icon when
the user is not able to resize the panes.
<P>
The components managed by the split pane can be reset to their
preferred sizes through the <TT>resetToPreferredSize</TT> method.
The divider will be moved to the appropriate location in the split
pane after the components are sized.
<P>
A commonly misunderstood aspect of the <TT>JSplitPane</TT> class
is the <TT>minimumSize</TT> property. If the components managed
by the split pane have <TT>0</TT> in the <TT>Split</TT> dimension,
the split pane will give its entire area to one of the components,
and the other component will not be seen. This condition is demonstrated
by the <TT>JSplitPaneTest2</TT> application, shown in Listing
16.2. The resulting window is shown in Figure 16.5. To alleviate
this condition, the <TT>minimumSize</TT> property can be set on
the component or the location of the divider can be specified
by the application.
<P>
<A HREF="javascript:popUp('f16-5.gif')"><B>Figure 16.5 :</B> <I>A JSplitPane with a 0 minimum size component</I>.</A>
<P>
<HR>
<P>
<B>Listing 16.2&nbsp;&nbsp;The JSplitPaneTest2 Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JSplitPane in a frame.
 * It demonstrates a 0 minimum size of one of the components
 * in the split pane.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class JSplitPaneTest2 extends Object { 
     
    /**
     * The splitPane for the test.
     **/
    JSplitPane splitPane;
    

    /**
     * JSplitPaneTest2, Constructor
     * &lt;p&gt;
     * Create a splitpane and add a table and tabbed pane
     * to the splitpane.
     **/
    public JSplitPaneTest2() { 
        splitPane = new JSplitPane();

        splitPane.setRightComponent( 
                  new JScrollPane( new JLabel( &quot;Hello&quot; ) ) );
        
        JComponent left = new JComponent() { } ;
        splitPane.setLeftComponent( left );
        
    } 
    

    /**
     * @return The split pane.
     **/
    public JSplitPane getSplitPane() { 
        return( splitPane );
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display a splitpane in it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;JSplitPaneTest2&quot; );
        JSplitPaneTest2 test = new JSplitPaneTest2();
                        
        frame.getContentPane().add( test.getSplitPane(), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // JSplitPaneTest2
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="NestingTTFONTSIZEJSplitPaneFONTTTFONTSIZEInstancesFONT">
Nesting <TT>JSplitPane</TT>
Instances</A></H3>
<P>
The <TT>JSplitPane</TT> class manages two child components at
most. However, the child components can themselves be split panes.
You can create almost any combination of resizable panes by <I>nesting</I>
split panes.
<P>
The <TT>NestedJSplitPaneTest</TT> application is shown in Listing
16.3. This application creates a horizontally aligned split pane.
A separate, vertically aligned split pane is added as the right
and left components in the first split pane. A label is added
as the top and bottom components in each of the nested split panes.
This creates a window with four regions, as shown in Figure 16.6.
Moving the vertical divider alters the size of all four components
displayed in the window. Moving either horizontal divider only
alters the size of the two components in that nested split pane.
<P>
<A HREF="javascript:popUp('f16-6.gif')"><B>Figure 16.6 :</B> <I>Nested JSplitPane instances</I>.</A>
<P>
<HR>
<P>
<B>Listing 16.3&nbsp;&nbsp;The NestedJSplitPaneTest Application
<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JSplitPane in a frame.
 * It demonstrates nested split panes.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class NestedJSplitPaneTest extends Object { 
     
    /**
     * The splitPane for the test.
     **/
    JSplitPane splitPane;
    

    /**
     * NestedJSplitPaneTest, Constructor
     * &lt;p&gt;
     * Create a splitpane that contains separate split
     * panes as its children.
     **/
    public NestedJSplitPaneTest() { 
        
        JSplitPane right = new JSplitPane( JSplitPane.VERTICAL_SPLIT,
                                       new JLabel( &quot;Top Right&quot; ),
                                       new JLabel( &quot;Bottom Right&quot; ) );
        JSplitPane left = new JSplitPane( JSplitPane.VERTICAL_SPLIT,
                                       new JLabel( &quot;Top Left&quot; ),
                                       new JLabel( &quot;Bottom Left&quot; ) );
        splitPane = new JSplitPane( JSplitPane.HORIZONTAL_SPLIT, 
                                    left, right );
        
    } 
    

    /**
     * @return The split pane.
     **/
    public JSplitPane getSplitPane() { 
        return( splitPane );
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display a splitpane in it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;NestedJSplitPane Test&quot; );
        NestedJSplitPaneTest test = new NestedJSplitPaneTest();
                        
        frame.getContentPane().add( test.getSplitPane(), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // NestedJSplitPaneTest
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The <TT>JSplitPane</TT> class manages two child components that
can be placed side-by-side or one on top of the other. A divider
visually separates the two components. The default size and look
of the divider are look-and-feel specific. The user can drag the
divider to alter the size of the two child components contained
in the split pane. The split pane respects the <TT>minimumSize</TT>
property of <TT>JComponent</TT> children. This may restrict the
user from resizing the child components to arbitrary sizes.
<P>
To overcome the limitation of a split pane managing only two children,
split panes can be nested. By specifying one or both children
of the split pane as another instance of the <TT>JSplitPane</TT>
class, you can create almost any layout.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch15\ch15.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch17\ch17.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
