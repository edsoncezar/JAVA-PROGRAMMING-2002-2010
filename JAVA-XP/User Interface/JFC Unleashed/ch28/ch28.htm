<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 28 - Undo and Redo</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch27\ch27.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch29\ch29.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;28<br>
Undo and Redo</H1>
<HR>
<p>

<UL>
<LI><A HREF="#SupportingBasicUndoOperations">
Supporting Basic Undo Operations</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEAbstractUndoableEditFONTTTFONTSIZEClassFONT">
The <TT>AbstractUndoableEdit</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEStateEditableFONTTTFONTSIZEInterfaceFONT">
The <TT>StateEditable</TT>
Interface</A>
<LI><A HREF="#TheTTFONTSIZEStateEditFONTTTFONTSIZEClassFONT">
The <TT>StateEdit</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEUndoManagerFONTTTFONTSIZEClassFONT">
The <TT>UndoManager</TT>
Class</A>
</UL>
<LI><A HREF="#ABasicUndoExample">
A Basic Undo Example</A>
<UL>
<LI><A HREF="#OverviewoftheTTFONTSIZETextAreaUndoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>TextAreaUndoDemo</TT>
Example</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEUndoableTextAreaFONTTTFONTSIZEClassFONT">
Overview of the <TT>UndoableTextArea</TT>
Class</A>
</UL>
<LI><A HREF="#SupportingUndowithSwingTextComponents">
Supporting Undo with Swing Text Components</A>
<UL>
<LI><A HREF="#OverviewoftheTTFONTSIZEDocumentUndoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>DocumentUndoDemo</TT>
Example</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The ability to undo and redo operations that change the state
of a document (or any kind of data) is a powerful and useful feature.
However, it's not the kind of feature that can be retrofitted
to an application in the latter stages of development. It's much
better to design the underlying data management to support undo
from the beginning. The Java Foundation Classes make this task
much easier by providing support for undo and redo operations
in the <TT>javax.swing.undo</TT> package.
<P>
In this chapter you will learn
<UL>
<LI>How basic undo support works in JFC<BR>
Implementing undo support in Java is much easier than in C or
C++. You'll be surprised at how easy it is to add undo support
to your editable objects.
<LI>How to create and manage undoable objects<BR>
To make an object undoable, you simply implement the <TT>StateEditable</TT>
interface. Then you can use the <TT>UndoManager</TT> class to
manage undoable edits represented by the <TT>StateEdit</TT> class.
</UL>
<H2><A NAME="SupportingBasicUndoOperations">
Supporting Basic Undo Operations</A></H2>
<P>
The JFC <TT>javax.swing.undo</TT> package provides a complete
framework for implementing and managing undoable edits to objects.
Although the framework is a part of Swing, you're not restricted
to using it with Swing components (components based on <TT>JComponent</TT>).
You can use JFC's undo framework with any type of component, including
AWT components.
<P>
There are several interfaces and classes you need to be familiar
with to implement basic undo support:
<UL>
<LI>The <TT>UndoableEdit</TT> interface is an interface for edits
that can be undone and redone.
<LI>The <TT>AbstractUndoableEdit</TT> class is a minimal implementation
of the <TT>UndoableEdit</TT> interface and is the base class for
most of the classes in the <TT>javax.swing.undo</TT> package.
<LI>The <TT>StateEditable</TT> interface is an interface for objects
that are editable.
<LI>The <TT>StateEdit</TT> class represents the state of an editable
object.
<LI>The <TT>UndoManager</TT> class represents an object that manages
edits on a single editable object.
</UL>
<H3><A NAME="TheTTFONTSIZEAbstractUndoableEditFONTTTFONTSIZEClassFONT">
The <TT>AbstractUndoableEdit</TT>
Class</A></H3>
<P>
The <TT>AbstractUndoableEdit</TT> class is an implementation of
the <TT>UndoableEdit</TT> interface. Technically, <TT>AbstractUndoableEdit</TT>
is not an abstract class. However, it is used much like an abstract
class-you don't instantiate it directly, but instead instantiate
subclasses of it. Most of the classes in the <TT>undo</TT> package
are extensions of <TT>AbstractUndoableEdit</TT>.
<BLOCKQUOTE>
<PRE>
public class AbstractUndoableEdit extends Object implements UndoableEdit 
{ 
    public AbstractUndoableEdit();
    public void undo();
    public void redo();
    public void die();
    public boolean canUndo();
    public boolean canRedo();
    public boolean addEdit(UndoableEdit edit);
    public boolean replaceEdit(UndoableEdit edit);
    public boolean isSignificant();
    public String getPresentationName();
    public String getUndoPresentationName();
    public String getRedoPresentationName();
    public String toString();
} 
</PRE>
</BLOCKQUOTE>
<P>
You probably won't instantiate the <TT>AbstractUndoableEdit</TT>
class directly, but you'll use its descendants like <TT>StateEdit</TT>
and <TT>UndoManager</TT>. The <TT>AbstractUndoableEdit</TT> methods
are discussed in the sections related to these classes.
<H3><A NAME="TheTTFONTSIZEStateEditableFONTTTFONTSIZEInterfaceFONT">
The <TT>StateEditable</TT>
Interface</A></H3>
<P>
The <TT>StateEditable</TT> interface is an interface that undoable
objects must implement. It provides a mechanism for the undo manager
to command objects to save and restore their state. 
<BLOCKQUOTE>
<PRE>
public interface StateEditable extends Object { 
    public abstract void storeState(Hashtable hashtable);
    public abstract void restoreState(Hashtable hashtable);
} 
</PRE>
</BLOCKQUOTE>
<P>
<TT>StateEditable</TT> has only two methods, <TT>storeState</TT>
and <TT>restoreState</TT>. Undoable edit objects implement these
methods to save and restore their editable data to and from the
given hash table.
<H3><A NAME="TheTTFONTSIZEStateEditFONTTTFONTSIZEClassFONT">
The <TT>StateEdit</TT> Class
</A></H3>
<P>
The <TT>StateEdit</TT> class, an extension of <TT>AbstractUndoableEdit</TT>,
represents the state of an editable object. Each time you want
to make an undoable change to editable data, you create a <TT>StateEdit</TT>
object and pass it to the undo manager.
<BLOCKQUOTE>
<PRE>
public class StateEdit extends AbstractUndoableEdit 
{ 
  // Public constructors
    public StateEdit(StateEditable editableObject);
    public StateEdit(StateEditable editableObject, String presentationName);
  // Public instance methods
    public void end();
    public String getPresentationName();
    public void redo();
    public void undo();
} 
</PRE>
</BLOCKQUOTE>
<P>
To construct a <TT>StateEdit</TT>, you supply an undoable object
(an object that implements <TT>StateEditable</TT>) and, optionally,
a <I>presentation name</I> for the
edit. A presentation name is a <TT>String</TT> that can be presented
to the user to identify the edit. For example, &quot;delete text&quot;
or &quot;paste image.&quot; 
<P>
When you instantiate a <TT>StateEdit</TT> object, the undoable
object associated with the edit will be requested to save its
state (via the <TT>storeState</TT> method that the object must
implement as part of the <TT>StateEditable</TT> interface). After
you change the data in the undoable object, you call the <TT>StateEdit.end</TT>
method to end the edit. The object will again be asked to save
its state.
<P>
The <TT>undo</TT> method will cause the object to restore its
state and the <TT>redo</TT> method will cause it to redo the changes.
You don't normally call these methods directly from an application.
Instead, the undo manager calls them when you call the undo manager
to undo or redo the last edit.
<H3><A NAME="TheTTFONTSIZEUndoManagerFONTTTFONTSIZEClassFONT">
The <TT>UndoManager</TT>
Class</A></H3>
<P>
The <TT>UndoManager</TT> class represents a manager of undoable
edit operations. Normally there is an undo manager for each undoable
object. For example, each instance of an undoable text area would
have an instance of an undo manager as would each instance of
a document in a word processor.
<BLOCKQUOTE>
<PRE>
public class UndoManager extends CompoundEdit 
                         implements UndoableEditListener 
{ 
  // Public constructor
    public UndoManager();
  // Public instance methods
    public synchronized boolean addEdit(UndoableEdit edit);
    public synchronized boolean canRedo();
    public synchronized boolean canUndo();
    public synchronized boolean canUndoOrRedo();
    public synchronized void discardAllEdits();
    public synchronized int getLimit();
    public synchronized String getUndoPresentationName();
    public synchronized String getUndoOrRedoPresentationName();
    public synchronized String getRedoPresentationName();
    public synchronized void redo();
    public synchronized void setLimit(int limit);
    public String toString();
    public synchronized void undo();
    public void undoableEditHappened(UndoableEditEvent event);
    public synchronized void undoOrRedo();
} 
</PRE>
</BLOCKQUOTE>
<P>
When you complete an edit operation, you call the <TT>StateEdit.end</TT>
method and then add the completed edit (<TT>StateEdit</TT> object)
to an undo manager with <TT>UndoManager.addEdit</TT>. The undo
manager keeps the edits in a list in the order in which they occurred.
When you call <TT>undo</TT>, the undo manager will undo the most
recently added edit. <TT>redo</TT> will redo the most recently
undone edit. <TT>canUndo</TT> and <TT>canRedo</TT> query to see
if there are any edits to be undone or redone.
<P>
The <TT>setLimit</TT> and <TT>getLimit</TT> methods allow you
to control the maximum number of edits that an undo manager will
store. The default (if you don't call <TT>setLimit</TT>) is 100
edits. The <TT>discardAllEdits</TT> method will cause an undo
manager to discard all of its edits.
<P>
The <TT>getUndoPresentationName</TT> and <TT>getRedoPresentationName</TT>
methods will retrieve the presentation names of the next undoable
and redoable edits. If you use <TT>setLimit</TT> to set the edit
limit of an undo manager to be one, the edit becomes an undo/redo
toggle. In this mode of operation, you use the <TT>undoOrRedo</TT>
method to undo or redo the edit, whichever is appropriate in the
context of the toggle. The other methods you use in the toggle
mode are <TT>getUndoOrRedoPresentationName</TT> and <TT>canUndoOrRedo</TT>.
<P>
The <TT>undoableEditHappened</TT> method is present to implement
the <TT>UndoableEditListener</TT> interface. You can use this
interface to notify an undo manager whenever undoable edits occur.
<H2><A NAME="ABasicUndoExample">
A Basic Undo Example</A></H2>
<P>
Look at an example of a basic undo implementation to see how these
classes are used. Listing 28.1 is the complete source for <TT>TextAreaUndoDemo</TT>,
an example that extends AWT's <TT>TextArea</TT> class to be undoable.
Figure 28.1 shows the completed demo.
<P>
<A HREF="javascript:popUp('f28-1.gif')"><B>Figure 28.1 :</B> <I>TextAreaUndoDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 28.1&nbsp;&nbsp;</B><TT><B>TEXTAREAUNDODEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* TextAreaUndoDemo.java
 *
 * Illustrates the basic concepts of supporting undo and redo
 * by adding this support to an extension of the TextArea class.
 */

import java.util.Hashtable;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.undo.*;

/* App class
 */
public class TextAreaUndoDemo { 
    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        TextAreaUndoDemoPanel panel = new TextAreaUndoDemoPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;TextAreaUndoDemo&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // Set initial frame size and make visible
        frame.setSize (300, 200);
        frame.setVisible(true);
    } 
} 


/* App panel class
 */
class TextAreaUndoDemoPanel extends JPanel { 
    // Constructor
    public TextAreaUndoDemoPanel() { 
        setLayout(new BorderLayout());

        // create an undoable text area
        // must be final to be accessed by 
        // anonymous inner classes (listeners)
        final UndoableTextArea text 
                  = new UndoableTextArea(&quot;Your text here.&quot;);

        // create a toolbar for buttons
        JToolBar toolbar = new JToolBar();

        // create undo and redo buttons
        // add listeners for buttons
        JButton buttonUndo, buttonRedo;
        buttonUndo = new JButton(&quot;Undo&quot;);
        buttonUndo.addActionListener (new ActionListener () { 
            public void actionPerformed (ActionEvent event) { 
                text.undo ();
            } 
        } );
        buttonRedo = new JButton(&quot;Redo&quot;);
        buttonRedo.addActionListener (new ActionListener () { 
            public void actionPerformed (ActionEvent event) { 
                text.redo ();
            } 
        } );

        // add buttons to toolbar
        toolbar.add(buttonUndo);
        toolbar.add(buttonRedo);

        // add toolbar and text area to panel
        add(toolbar, &quot;North&quot;);
        add(text, &quot;Center&quot;);
    } 
} 

/* UndoableTextArea: An undoable extension of TextArea
 */
class UndoableTextArea extends TextArea implements StateEditable { 
    private final static String KEY_STATE 
  = &quot;UndoableTextAreaKey&quot;;  // hash key
    private boolean textChanged = false;
    private UndoManager undoManager;
    private StateEdit currentEdit;
    
    
    // Constructors
    //
    // For all constructors, call corresponding superclass constructor
    // and then do initialization to make TextArea undoable
    public UndoableTextArea() { 
        super();
        initUndoable();
    } 
    public UndoableTextArea(String string) { 
        super(string);
        initUndoable();
    } 
    public UndoableTextArea(int rows, int columns) { 
        super(rows, columns);
        initUndoable();
    }
    public UndoableTextArea(String string, int rows, int columns) { 
        super(string, rows, columns);
        initUndoable();
    } 
    public UndoableTextArea(String string, int rows, 
                            int columns, int scrollbars) { 
        super(string, rows, columns, scrollbars);
        initUndoable();
    } 

    
    // Public methods
    //

    // method to undo last edit 
    public boolean undo() { 
        try { 
            undoManager.undo();
            return true;
        } 
        catch (CannotUndoException exc) { 
            System.out.println(&quot;Can't undo&quot;);
            return false;
        } 
    } 

    // method to redo last edit 
    public boolean redo() { 
        try { 
            undoManager.redo();
            return true;
        } 
        catch (CannotRedoException ex) { 
            System.out.println(&quot;Can't redo&quot;);
            return false;
        } 
    } 


    // Implementation of StateEditable interface
    //
    
    // save and restore data to/from hashtable
    public void storeState(Hashtable state) { 
        state.put(KEY_STATE, getText());
    } 
    public void restoreState(Hashtable state) { 
        Object data = state.get(KEY_STATE);
        if (data != null) { 
            setText((String)data);
        } 
    } 


    // Private methods
    //

    // Snapshots current edit state
    private void takeSnapshot() { 
        // snapshot only if text changed
        if (textChanged) { 
            // end current edit and notify undo manager
            currentEdit.end();
            undoManager.addEdit(currentEdit);

            // reset text changed semaphore and create a new current edit
            textChanged = false;
            currentEdit = new StateEdit(this);
        } 
    } 

    // Helper method to initialize object to be undoable
    private void initUndoable () { 
        // create an undo manager to manage undo operations
        undoManager = new UndoManager();

        // create a StateEdit object to represent the current edit
        currentEdit = new StateEdit(this);

        // add listeners for various edit-related events
        // use these events to determine when to snapshot current edit

        // key listener looks for action keys (non-character keys)
        addKeyListener(new KeyAdapter() { 
            public void keyPressed(KeyEvent event) { 
                if (event.isActionKey()) { 
                    // snapshot on any action keys
                    takeSnapshot();
                } 
            } 
        } );

        // focus listener looks for loss of focus
        addFocusListener(new FocusAdapter() { 
            public void focusLost(FocusEvent event) { 
                // snapshot when control loses focus
                takeSnapshot();
            } 
        } );

        // text listener looks for text changes
        addTextListener(new TextListener() { 
            public void textValueChanged(TextEvent event) { 
                textChanged = true;
                
                // snapshot on every change to text
                // might be too granular to be practical
                //
                // this will shapshot every keystroke when typing
                takeSnapshot();
            } 
        } );
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZETextAreaUndoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>TextAreaUndoDemo</TT>
Example</A></H3>
<P>
The <TT>TextAreaUndoDemo</TT> example consists of three classes:
<UL>
<LI><TT>TextAreaUndoDemo</TT> is a public class that contains
the <TT>main</TT> entry point method. 
<LI><TT>TextAreaUndoDemoPanel</TT> is a panel (<TT>JPanel)</TT>
that contains the user interface for the application.
<LI><TT>UndoableTextArea</TT>, an extension of <TT>TextArea</TT>,
is an implementation of an undoable text area.
</UL>
<P>
The <TT>main</TT> entry point creates a frame (<TT>JFrame</TT>)
and an instance of <TT>TextAreaUndoDemoPanel</TT> that it adds
to the frame. 
<P>
The constructor for <TT>TextAreaUndoDemoPanel</TT> creates a toolbar
with two buttons (for &quot;Undo&quot; and &quot;Redo&quot;),
and an undoable text area (instance of <TT>UndoableTextArea</TT>).
The listeners for the buttons call the <TT>undo</TT> and <TT>redo</TT>
methods of the undoable text area object. Note that the text variable
representing the undoable text area must be declared as <TT>final</TT>
so it can be accessed by the anonymous inner classes used to implement
the button listeners.
<P>
The undo-related functionality of this example is contained in
the implementation of the <TT>UndoableTextArea</TT> class, which
is discussed in detail in the following section. 
<H3><A NAME="OverviewoftheTTFONTSIZEUndoableTextAreaFONTTTFONTSIZEClassFONT">
Overview of the <TT>UndoableTextArea</TT>
Class</A></H3>
<P>
As stated earlier, the <TT>UndoableTextArea</TT> class extends
the AWT <TT>TextArea</TT> class. In the constructors for this
class, the <TT>TextArea</TT> constructors are overridden with
constructors that call a helper method, called <TT>initUndoable</TT>,
to handle initialization related to making the class undoable.
The constructors then call the corresponding superclass constructor.
<P>
The <TT>initUndoable</TT> helper method creates an undo manager
to manage edits and a <TT>StateEdit</TT> object to represent the
current edit state. <TT>initUndoable</TT> then adds listeners
for key, focus, and text events. These listeners are all implemented
inline in anonymous inner classes. The purpose of the listeners
is to detect significant edits to the text area contents so the
edits can be registered with the undo manager. Each of these listeners
call the <TT>takeSnapshot</TT> helper method to take a snapshot
of the current edit state.
<P>
<TT>takeSnapshot</TT> checks the <TT>textChanged</TT> flag to
see if the contents of the text area have changed since the last
snapshot. It's possible, for example, to get a focus lost event
when there have been no edits to the text area. The text listener
sets the <TT>textChanged</TT> flag when the <TT>textValueChanged</TT>
event occurs. If <TT>textChanged</TT> is true, <TT>takeSnapshot</TT>
ends the current edit and adds it to the undo manager. It then
resets the <TT>textChanged</TT> flag and creates a new <TT>StateEdit</TT>
object to represent the new edit state of the text area.
<P>
The final addition to the <TT>TextArea</TT> class is the implementation
of the <TT>StateEditable</TT> interface. The two methods in this
interface are <TT>storeState</TT> and <TT>restoreState.</TT> The
undo manager calls these methods when you request an undo or redo
operation. <TT>TextAreaUndoDemo</TT> implements these methods
by using the <TT>TextArea</TT> <TT>getText</TT> and <TT>setText</TT>
methods to save and restore the entire contents of the text area.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The undo implementation in <TT>TextAreaUndoDemo</TT> is fine for relatively small amounts of text but would be impractical for an application such as a word processor. It would be too expensive (in terms of both performance and memory usage) to save the entire contents of a document each time an edit is made. This type of application requires an undo design that implements undo for lower-level objects such as text elements (paragraphs, words, and so on).
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The following sections describe in detail how <TT>TextAreaUndoDemo</TT>
implements the <TT>StateEditable</TT> interface and takes snapshots
of its edit state.
<H4>Implementing the <TT>StateEditable</TT> Interface</H4>
<P>
Like all objects that are undoable, <TT>UndoableTextArea</TT>
implements the <TT>StateEditable</TT> interface. There are only
two methods in the <TT>StateEditable</TT> interface: <TT>storeState</TT>
and <TT>restoreState</TT>. 
<BLOCKQUOTE>
<PRE>
public abstract void storeState(Hashtable);
public abstract void restoreState(Hashtable);
</PRE>
</BLOCKQUOTE>
<P>
Undoable objects must provide an implementation of these two methods
to save and restore the state of the object's editable data. From
the following <TT>TextAreaUndoDemo</TT> code fragment, you can
see that the <TT>storeState</TT> method simply puts the text area's
text (its editable data) into the given hashtable. Likewise, <TT>restoreState</TT>
pulls the text out of the hashtable and restores it to the text
area.
<BLOCKQUOTE>
<PRE>
// Implementation of StateEditable interface
//
    
// save and restore data to/from hashtable
public void storeState(Hashtable state) { 
    state.put(KEY_STATE, getText());
} 
public void restoreState(Hashtable state) { 
    Object data = state.get(KEY_STATE);
    if (data != null) { 
        setText((String)data);
    } 
}
</PRE>
</BLOCKQUOTE>
<H4>Taking Snapshots of Edits</H4>
<P>
In addition to implementing the <TT>StateEditable</TT> interface
to store and restore edits, objects that support undoable edits
must take <I>snapshots</I> of their
data. Snapshots are <BR>
representations of the object's editable data taken before and
after undoable changes have been made to the data. Implementing
a snapshot consists of ending the current edit (represented as
a <TT>StateEdit</TT> object), adding it to the undo manager, and
then creating a new object to represent the current edit. The
following code fragment shows how the <TT>TextAreaUndoDemo</TT>
example takes snapshots of its data.
<BLOCKQUOTE>
<PRE>
// Snapshots current edit state
private void takeSnapshot() { 
    // snapshot only if text changed
    if (textChanged) { 
        // end current edit and notify undo manager
        currentEdit.end();
        undoManager.addEdit(currentEdit);

        // reset text changed semaphore and create a new current edit
        textChanged = false;
        currentEdit = new StateEdit(this);
    } 
}

</PRE>
</BLOCKQUOTE>

<p>

<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The frequency with which you snapshot edits determines the granularity of changes to an undoable object's data. In the <TT>TextAreaUndoDemo</TT> example, the text listener in the <TT>UndoableTextArea</TT> class snapshots edits each time the <TT>textValueChanged</TT> method gets called. This a very granular undo implementation as this method is called on each key- stroke.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
Note that when you end an edit by calling the <TT>end</TT> method,
the corresponding object's <TT>storeState</TT> method will be
called to store the object's data.
<H2><A NAME="SupportingUndowithSwingTextComponents">
Supporting Undo with Swing Text Components</A></H2>
<P>
The <TT>TextAreaUndoDemo</TT> example demonstrates how to add
undo and redo support to an AWT <TT>TextArea</TT> component. To
implement undo support in this example, you had to monitor edits
made to the text and take snapshots of the text before and after
undoable edits. The snapshots were passed to an undo manager that
kept track of the edits and managed undo and redo operations.
This example provides a good illustration of how to add undo support
to AWT components and to your own objects, but is not directly
applicable to Swing text components.
<P>
Swing text components are quite a bit more sophisticated than
their AWT counterparts. They are based on a Model View Controller
(MVC) architecture, where the model is represented by an object
implementing the <TT>Document</TT> interface, and the view and
controller are combined in a text component based on <TT>JTextComponent</TT>.
See <A HREF="..\ch07\ch07.htm" >Chapter 7</A> &quot;Text Components,&quot; for details on the
architecture of Swing text components.
<P>
Much of the underlying plumbing required to support undo and redo
is built into the Swing text components. There are only a couple
of steps you need to take to provide basic undo support with components
based on <TT>JTextComponent</TT>.
<UL>
<LI>Create an <TT>UndoManager</TT> object to manage undo operations.
<LI>Register the <TT>UndoManager</TT> object as an undoable edit
listener to the model (<TT>document</TT>).
</UL>
<P>
You can then call the undo manager's <TT>undo</TT> and <TT>redo</TT>
methods to undo and redo edits to the document. Listing 28.2 is
the complete source for <TT>DocumentUndoDemo</TT>, an example
that implements undo support on a <TT>JTextArea</TT> component.
The appearance and operation of this example is identical to the
previous <TT>TextAreaUndoDemo</TT> example.
<p>
<HR>
<P>
<B>Listing 28.2&nbsp;&nbsp;</B><TT><B>DOCUMENTUNDODEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* DocumentUndoDemo.java
 *
 * Illustrates how to support undo and redo in 
 * components based on the JTextComponent class.
 */

import java.awt.BorderLayout;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.undo.*;
import javax.swing.text.Document;

/* App class
 */
public class DocumentUndoDemo { 
    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        DocumentUndoDemoPanel panel = new DocumentUndoDemoPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;DocumentUndoDemo&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // Set initial frame size and make visible
        frame.setSize (300, 200);
        frame.setVisible(true);
    } 
} 


/* App panel class
 */
class DocumentUndoDemoPanel extends JPanel { 
    // Constructor
    public DocumentUndoDemoPanel() { 
        setLayout(new BorderLayout());

        // create a JTextArea component
        JTextArea text = new JTextArea(&quot;Your text here.&quot;);
        
        // create an undo manager to manage undo operations
        final UndoManager undoManager = new UndoManager();

        // install undo manager instance as listener for undoable edits
        text.getDocument().addUndoableEditListener(undoManager);

        // create a toolbar for undo/redo buttons
        JToolBar toolbar = new JToolBar();

        // create undo and redo buttons
        // add listeners for buttons
        JButton buttonUndo, buttonRedo;
        buttonUndo = new JButton(&quot;Undo&quot;);
        buttonUndo.addActionListener (new ActionListener () { 
            public void actionPerformed (ActionEvent event) { 
                try {  undoManager.undo (); } 
                catch (CannotUndoException ex) {  
                    System.out.println(&quot;Can't undo&quot;);
                } 
            } 
        } );
        buttonRedo = new JButton(&quot;Redo&quot;);
        buttonRedo.addActionListener (new ActionListener () { 
            public void actionPerformed (ActionEvent event) { 
                try {  undoManager.redo (); } 
                catch (CannotRedoException ex) {  
                    System.out.println(&quot;Can't redo&quot;);
                } 
            } 
        } );

        // add buttons to toolbar
        toolbar.add(buttonUndo);
        toolbar.add(buttonRedo);

        // add toolbar and text area to panel
        add(toolbar, &quot;North&quot;);
        add(text, &quot;Center&quot;);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEDocumentUndoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>DocumentUndoDemo</TT>
Example</A></H3>
<P>
The <TT>DocumentUndoDemo</TT> example is quite a bit simpler than
the previous <TT>TextAreaUndoDemo</TT> example. There are only
two classes: the main application class, <TT>DocumentUndoDemo,</TT>
and the <TT>DocumentUndoDemoPanel</TT> class, an extension of
<TT>JPanel</TT>.
<P>
The constructor for the <TT>DocumentUndoDemoPanel</TT> class creates
a <TT>JTextArea</TT> component and an <TT>UndoManager</TT> instance
to manage undo operations. The constructor then gets the document
associated with the text area and adds the <TT>UndoManager</TT>
instance as an undoable edit listener for the document.
<BLOCKQUOTE>
<PRE>
// create a JTextArea component
JTextArea text = new JTextArea(&quot;Your text here.&quot;);
        
// create an undo manager to manage undo operations
final UndoManager undoManager = new UndoManager();

// install undo manager instance as listener for undoable edits
text.getDocument().addUndoableEditListener(undoManager);
</PRE>
</BLOCKQUOTE>
<P>
This is all that you need to do to make a Swing text component
support undo and redo operations-everything else (maintaining
current edit state, snapshotting edits, saving and restoring state,
and so on) is handled by the text component itself. 
<P>
All that remains in this example is creating and hooking up the
user interface. The <BR>
following code fragment creates two buttons with action listeners
implemented in <BR>
anonymous inner classes. The listeners call the <TT>undo</TT>
and <TT>redo</TT> methods in the previously created undo manager
to undo and redo edits.
<BLOCKQUOTE>
<PRE>
// create undo and redo buttons
// add listeners for buttons
JButton buttonUndo, buttonRedo;
buttonUndo = new JButton(&quot;Undo&quot;);
buttonUndo.addActionListener (new ActionListener () { 
     public void actionPerformed (ActionEvent event) { 
        try {  undoManager.undo (); } 
        catch (CannotUndoException ex) {  
            System.out.println(&quot;Can't undo&quot;);
        } 
    } 
} );
buttonRedo = new JButton(&quot;Redo&quot;);
buttonRedo.addActionListener (new ActionListener () { 
    public void actionPerformed (ActionEvent event) { 
        try {  undoManager.redo (); } 
        catch (CannotRedoException ex) {  
            System.out.println(&quot;Can't redo&quot;); 
        } 
    } 
} );
</PRE>
</BLOCKQUOTE>
<P>
Note that you must catch the <TT>CannotUndoException</TT> and
<TT>CannotRedoException</TT> exceptions when you call the undo
manager's <TT>undo</TT> and <TT>redo </TT>methods. 
<P>
A good exercise would be to add some code to this example to disable
the undo and redo buttons when undo or redo operations are not
available. You can use the undo manager's <TT>canUndo</TT> and
<TT>canRedo</TT> methods to obtain this information. You could
also access the presentation names of the edit associated with
the next undo and redo operations and present these names to the
user.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The <TT>javax.swing.undo</TT> package includes low-level support
for adding undo and redo capability to any editable component.
The <TT>TextAreaUndoDemo</TT> example illustrates how to use this
package to add undo support to an AWT <TT>TextArea</TT> component.
You can take the same approach and apply it to many different
types of editable components. If you're using Swing text components,
however, the task of implementing undo and redo is made much easier.
Support for undo and redo is built in to all of the components
based on <TT>JTextComponent</TT>. The second example, <TT>DocumentUndoDemo</TT>,
illustrates how to use the undo support built in to Swing text
components.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch27\ch27.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch29\ch29.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
