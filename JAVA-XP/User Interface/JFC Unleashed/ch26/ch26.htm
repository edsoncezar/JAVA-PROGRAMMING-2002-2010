<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 26 - Focus Managers</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch25\ch25.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch27\ch27.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;26<br>
Focus Managers</H1>
<HR>
<p>

<UL>
<LI><A HREF="#AboutFocusandFocusManagers">
About Focus and Focus Managers</A>
<LI><A HREF="#HowSwingsDefaultFocusManagerWorks">
How Swing's Default Focus Manager Works</A>
<LI><A HREF="#ManagingFocusfromComponents">
Managing Focus from Components</A>
<UL>
<LI><A HREF="#ExampleUsingTTFONTSIZErequestFocusFONTTTFONTSIZEtoExplicitlySettheFocusFONT">
Example Using <TT>requestFocus</TT>
to Explicitly Set the Focus</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEHotFocusFONTTTFONTSIZEExampleFONT">
Overview of the <TT>HotFocus</TT>
Example</A>
<LI><A HREF="#GettingNotificationofFocus">
Getting Notification of Focus</A>
<LI><A HREF="#ExampleUsingFocusNotification">
Example Using Focus Notification</A>
<LI><A HREF="#OverviewofTTFONTSIZEHotFocusFONTTTFONTSIZEExampleFONT">
Overview of <TT>HotFocus2</TT>
Example</A>
<LI><A HREF="#ExampleUsingComponentManagedFocus">
Example Using Component-Managed Focus</A>
<LI><A HREF="#OverviewofTTFONTSIZEComponentManagedFocusFONTTTFONTSIZEExampleBRFONT">
Overview of <TT>ComponentManagedFocus</TT>
Example<BR>
</A>
</UL>
<LI><A HREF="#UsingtheFocusManager">
Using the Focus Manager</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEFocusManagerFONTTTFONTSIZEClassFONT">
The <TT>FocusManager</TT>
Class</A>
<LI><A HREF="#IssueswithMixingAWTandSwingComponents">
Issues with Mixing AWT and Swing Components</A>
</UL>
<LI><A HREF="#WritingaCustomFocusManager">
Writing a Custom Focus Manager</A>
<UL>
<LI><A HREF="#ExampleUsingaCustomFocusManager">
Example Using a Custom Focus Manager</A>
<LI><A HREF="#OverviewofTTFONTSIZECustomFocusManagerFONTTTFONTSIZEExampleFONT">
Overview of <TT>CustomFocusManager</TT>
Example</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Focus management, coupled with keyboard accelerators and shortcuts,
allows a GUI application to be navigated and operated with a keyboard.
The 1.1 version of the JDK provided focus management services
as a part of AWT, but did not allow applications much flexibility
in modifying the default focus management behavior. JFC goes a
step further by encapsulating focus management services for Swing
components into public classes. This encapsulation allows JFC
applications more control over managing focus changes-applications
can even provide their own focus manager if necessary.
<P>
This chapter describes how to use the JFC's focus management capabilities.
For details on how to use keyboard accelerators and shortcuts,
see <A HREF="..\ch29\ch29.htm" >Chapter 29</A>, &quot;Keyboard Navigation.&quot;
<P>
In this chapter, you will learn
<UL>
<LI>About focus and focus managers<BR>
For many applications, you won't really need to be concerned with
focus management. However, if you're doing complicated dialog
boxes or forms, you might want more control over how the focus
manager moves the focus between your components.
<LI>How Swing's focus management works <BR>
Focus management comes &quot;for free&quot; with JFC, but even
if you're content with the default focus management services,
it helps to understand a bit about how the default focus management
operates.
<LI>How to explicitly set the focus to a component<BR>
You can use this technique to implement &quot;hot&quot; components-components
that grab the focus whenever they are under the mouse.
<LI>How to detect when a component receives the focus<BR>
You can use this technique to create components that change their
appearance or make a sound when they get the focus.
<LI>How to manage focus at the component level<BR>
You can override the behavior of the default focus manager by
creating components that manage focus changes.
<LI>How to write a custom focus manager<BR>
If you can't get the results you want with the default focus manager
or by managing focus at the component level, you can write a custom
focus manager for your application.
</UL>
<H2><A NAME="AboutFocusandFocusManagers">
About Focus and Focus Managers</A></H2>
<P>
The term <I>focus</I> is shorthand
for <I>input focus</I> or <I>current
input focus</I>. The component that has the focus is the
component that receives keyboard input events. For example, you
can type text into a text field if and only if the text field
has the focus. Likewise with button controls (<TT>JButton</TT>
objects)-the button that has the focus will respond to the Return
key by actuating and firing action events, just as if you had
clicked the button with the mouse. Only one component can have
the focus at a time. Focus is usually indicated visually so that
it's clear to the user what component has the focus.
<P>
The focus order in AWT's focus manager is based on the order in
which you add components to their container-you cannot change
this behavior. JFC, however, abstracts and encapsulates focus
management into the <TT>FocusManager</TT> and <TT>DefaultFocusManager</TT>
classes. With JFC, you can create and use your own focus manager.
<H2><A NAME="HowSwingsDefaultFocusManagerWorks">
How Swing's Default Focus Manager Works</A></H2>
<P>
The default focus manager in Swing responds to the Tab key to
advance the focus and the Shift+Tab key combination to move the
focus back to the component that previously had the focus. The
use of Tab and Shift+Tab for focus traversal is common to many
operating environments.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
When a user interface control such as a button or menu has the focus, you can use the Return, Enter, or Spacebar key to actuate the control. You can also actuate the control with the mnemonic key, if one is set for the component. The focus manager does not control this behavior, however; it's controlled by the look-and-feel implementation. See <A HREF="..\ch30\ch30.htm" >Chapter 30</A>, &quot;Pluggable Look-and-Feel,&quot; for details on various look-and-feel implementations.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
Swing's default focus manager determines which component will
get the focus next with an algorithm that's based on the order
in which the components were added to their container. This is
the same algorithm as AWT used for focus management. Because most
layout managers arrange components in the order in which they
were added, this focus management algorithm generally works quite
well. The focus proceeds from the upper-left area of a container
to its lower-right area. In a grid of components, focus moves
left-to-right across the first row and then down to the beginning
of the next row and so on. Focus will traverse all focusable components
in a container before passing to another container. 
<H2><A NAME="ManagingFocusfromComponents">
Managing Focus from Components</A></H2>
<P>
Focus management is a cooperative effort between components and
the focus manager. Many focus-management operations can be handled
at the component level, without having to create a custom focus
manager. For example, components can request the focus and transfer
the focus to the next focusable component in the component hierarchy.
Components can also inform the focus manager that they will manage
focus change operations.
<P>
The <TT>JComponent</TT> class provides several methods for controlling
focus. A few of these methods are actually <TT>Component</TT>
methods, but are presented here for the sake of completeness.
<BLOCKQUOTE>
<PRE>
// Public instance methods
  public void addFocusListener(FocusListener listener);
  public void grabFocus();
  public boolean hasFocus();
  public boolean isRequestFocusEnabled();
  public void removeFocusListener(FocusListener listener);
  public void requestFocus();
  public void setRequestFocusEnabled(boolean enable);
  public void transferFocus();
// Overrides
  public boolean isFocusTraversable();
  public boolean isManagingFocus();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>hasFocus</TT> method can be used to determine if a component
currently has the focus. If the component has the focus, <TT>hasFocus</TT>
returns <TT>true</TT>.
<P>
The <TT>setRequestFocusEnabled</TT> method enables a component
to accept focus change requests with the <TT>requestFocus</TT>
method. You can use <TT>isRequestFocusEnabled</TT> to determine
if a component is enabled for focus change requests.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Disabling focus change requests will not prevent the component from getting focus from the focus manager. It will prevent the component from getting the focus when the focus is explicitly requested with the <TT>requestFocus</TT> method.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The <TT>grabFocus</TT> method will set the focus to a component,
regardless of whether the component is enabled to receive explicit
focus change requests. This method is meant to be used only by
focus managers. Unless you're writing your own focus manager,
you should use <TT>requestFocus</TT> to set the focus to a component.
<P>
The <TT>transferFocus</TT> method transfers the focus to the next
focusable component in the component hierarchy.
<P>
The <TT>requestDefaultFocus</TT> method applies to containers-components
that contain other focusable components. When called on a container,
<TT>requestDefaultFocus</TT> will set the focus to the component
that gets the focus by default. This is normally the first component
that was added to the container.
<P>
The <TT>addFocusListener</TT> method allows components to listen
for focus events. Components can use a focus listener to determine
when they gain and lose the focus. <TT>removeFocusListener</TT>
will remove a focus listener from a component.
<P>
The <TT>isFocusTraversable</TT> method is a method you can override
to control whether a component can get the focus. Components that
cannot normally receive the focus, like text labels and panels,
should return <TT>false</TT> from <TT>isFocusTraversable</TT>.
This override is also useful if you want to receive keystroke
events in components that aren't normally focusable.
<P>
The <TT>isManagingFocus</TT> method is a method you can override
for components that manage their own focus changes. If you override
<TT>isManagingFocus</TT> and return <TT>true</TT>, the focus manager
will send the component's key listener Tab and Shift+Tab keystrokes.
See the &quot;Example Using Component-Managed Focus&quot; section
later in this chapter for an example that overrides <TT>isManagingFocus</TT>.
<H3><A NAME="ExampleUsingTTFONTSIZErequestFocusFONTTTFONTSIZEtoExplicitlySettheFocusFONT">
Example Using <TT>requestFocus</TT>
to Explicitly Set the Focus</A></H3>
<P>
Often, you'll want to override the default behavior of the focus
manager and set the focus to a specific component. For example,
when you instantiate a dialog box, you might want to set the focus
to a user interface element that must be acted on before the dialog
box can be closed. Or, if it's a dialog box that is presented
mainly for user confirmation, you'll want to set the focus to
the OK button so the user can easily dismiss it. To explicitly
set the focus to a component, you simply call the component's
<TT>requestFocus</TT> method.
<P>
Listing 26.1 is the complete source for <TT>HotFocus</TT>, an
application that uses <TT>requestFocus</TT> to explicitly set
the focus to the component that is under the mouse. See Figure
26.1 for the output of this code.
<P>
<A HREF="javascript:popUp('f26-1.gif')"><B>Figure 26.1 :</B> <I>HotFocus example</I>.</A>
<P>
<HR>
<P>
<B>Listing 26.1&nbsp;&nbsp;</B><TT><B>HOTFOCUS.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* HotFocus.java
 *
 * Illustrates how to explicitly set the focus to a component.
 */

import java.awt.event.*;
import javax.swing.*;

/* App class
 */
public class HotFocus { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        HotFocusPanel panel = new HotFocusPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;HotFocus&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (150, 150);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class HotFocusPanel extends JPanel { 
    // Constructor
    public HotFocusPanel () { 
        super();

        // create twelve buttons, arranged in four rows of three
        // use boxes to lay out to appear like a telephone keypad
        HotButton b0, b1, b2, b3, b4, b5, b6, b7, b8, b9,
                  bAsterisk, bPound;
        MyBox bx_h1 = new MyBox(BoxLayout.X_AXIS);  // row 1
        MyBox bx_h2 = new MyBox(BoxLayout.X_AXIS);  // row 2
        MyBox bx_h3 = new MyBox(BoxLayout.X_AXIS);  // row 3
        MyBox bx_h4 = new MyBox(BoxLayout.X_AXIS);  // row 4
        MyBox bx_v1 = new MyBox(BoxLayout.Y_AXIS);  

        bx_h1.add(b1 = new HotButton(&quot;1&quot;));
        bx_h1.add(b2 = new HotButton(&quot;2&quot;));
        bx_h1.add(b3 = new HotButton(&quot;3&quot;));
        bx_h2.add(b4 = new HotButton(&quot;4&quot;));
        bx_h2.add(b5 = new HotButton(&quot;5&quot;));
        bx_h2.add(b6 = new HotButton(&quot;6&quot;));
        bx_h3.add(b7 = new HotButton(&quot;7&quot;));
        bx_h3.add(b8 = new HotButton(&quot;8&quot;));
        bx_h3.add(b9 = new HotButton(&quot;9&quot;));
        bx_h4.add(bAsterisk = new HotButton(&quot;*&quot;));
        bx_h4.add(b0 = new HotButton(&quot;0&quot;));
        bx_h4.add(bPound = new HotButton(&quot;#&quot;));

        // stack 4 row boxes in a vertical (column) box
        bx_v1.add(bx_h1);
        bx_v1.add(bx_h2);
        bx_v1.add(bx_h3);
        bx_v1.add(bx_h4);

        // add vertical box to panel
        add(bx_v1);
    } 
} 

// HotButton class
//
// An extension of JButton that requests the focus
// when the mouse enters the button.
class HotButton extends JButton { 
    // Constructor
    public HotButton(String text) { 
        super(text);

        // ensure that component can request focus
        // default is true, but just to be sure...
        setRequestFocusEnabled(true);
        
        // add a listener for mouse enter
        addMouseListener(new MouseAdapter() { 
            public void mouseEntered(MouseEvent event) { 
                // Request the focus (if don't already have it)
                if(!hasFocus()) {  requestFocus(); } 
            } 
        } );
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel
{ 
    // Constructor
    public MyBox(int axis) { 
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEHotFocusFONTTTFONTSIZEExampleFONT">
Overview of the <TT>HotFocus</TT>
Example</A></H3>
<P>
The <TT>HotFocus</TT> example creates a panel containing twelve
buttons in a layout designed to resemble a telephone keypad. The
buttons are contained in boxes so they are arranged in four rows
with three buttons in each row. The buttons are created from the
<TT>HotButton</TT> class, an extension of <TT>JButton</TT>.
<BLOCKQUOTE>
<PRE>
// HotButton class
//
// A simple extension of JButton that requests the focus
// when the mouse enters the button.
class HotButton extends JButton { 
    // Constructor
    public HotButton(String text) { 
        super(text);

        // ensure that component can request focus
        // default is true, but just to be sure...
        setRequestFocusEnabled(true);
        
        // add a listener for mouse enter
        addMouseListener(new MouseAdapter() { 
            public void mouseEntered(MouseEvent event) { 
                // request the focus (if don't already have it)
                if(!hasFocus()) {  requestFocus(); } 
            } 
        } );
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>HotButton</TT> constructor calls <TT>setRequestFocusEnabled</TT>
to ensure that the component will respond to focus requests. The
constructor then adds a mouse listener implemented in an anonymous
inner class to detect when the mouse is over the button. When
the <TT>mouseEntered</TT> event is received, the listener calls
<TT>hasFocus</TT> to see if the button has the focus and, if not,
it calls <TT>requestFocus</TT> to get the focus. The result is
a button that gets the focus whenever it is under the mouse.
<H3><A NAME="GettingNotificationofFocus">
Getting Notification of Focus</A></H3>
<P>
Swing makes use of AWT's focus listener mechanism to notify components
of focus changes. To get focus notification in a component, you
must perform the following steps:
<UL>
<LI>Call the <TT>addFocusListener</TT> method to add a focus listener.
<LI>Implement a focus listener by subclassing the <TT>FocusAdapter</TT>
class.
<LI>Override the <TT>focusGained</TT> and <TT>focusLost</TT> methods
in the focus listener to process focus changes.
</UL>
<H3><A NAME="ExampleUsingFocusNotification">
Example Using Focus Notification</A></H3>
<P>
Listing 26.2 is the complete source for <TT>HotFocus2</TT>, an
example based on the previous <TT>HotFocus</TT> example. If you
run the <TT>HotFocus</TT> example, you'll notice that the visual
changes that occur when a component gets the focus are pretty
subtle. <TT>HotFocus2</TT> builds on <TT>HotFocus</TT> by detecting
focus changes and altering the appearance of buttons when they
have the focus (see Figure 26.2).
<P>
<A HREF="javascript:popUp('f26-2.gif')"><B>Figure 26.2 :</B> <I>The HotFocus2 example</I>.</A>
<P>
<HR>
<P>
<B>Listing 26.2&nbsp;&nbsp;</B><TT><B>HOTFOCUS2.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* HotFocus2.java
 *
 * Illustrates how to explicitly set the focus 
 * and detect focus changes.
 */

import java.awt.Color;
import java.awt.event.*;
import javax.swing.*;

/* App class
 */
public class HotFocus2 { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        HotFocus2Panel panel = new HotFocus2Panel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;HotFocus2&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (150, 150);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class HotFocus2Panel extends JPanel { 
    // Constructor
    public HotFocus2Panel () { 
        super();

        // create twelve buttons, arranged in four rows of three
        // use boxes to lay out to appear like a telephone keypad
        HotButton b0, b1, b2, b3, b4, b5, b6, b7, b8, b9,
                  bAsterisk, bPound;
        MyBox bx_h1 = new MyBox(BoxLayout.X_AXIS);  // row 1
        MyBox bx_h2 = new MyBox(BoxLayout.X_AXIS);  // row 2
        MyBox bx_h3 = new MyBox(BoxLayout.X_AXIS);  // row 3
        MyBox bx_h4 = new MyBox(BoxLayout.X_AXIS);  // row 4
        MyBox bx_v1 = new MyBox(BoxLayout.Y_AXIS);  

        bx_h1.add(b1 = new HotButton(&quot;1&quot;));
        bx_h1.add(b2 = new HotButton(&quot;2&quot;));
        bx_h1.add(b3 = new HotButton(&quot;3&quot;));
        bx_h2.add(b4 = new HotButton(&quot;4&quot;));
        bx_h2.add(b5 = new HotButton(&quot;5&quot;));
        bx_h2.add(b6 = new HotButton(&quot;6&quot;));
        bx_h3.add(b7 = new HotButton(&quot;7&quot;));
        bx_h3.add(b8 = new HotButton(&quot;8&quot;));
        bx_h3.add(b9 = new HotButton(&quot;9&quot;));
        bx_h4.add(bAsterisk = new HotButton(&quot;*&quot;));
        bx_h4.add(b0 = new HotButton(&quot;0&quot;));
        bx_h4.add(bPound = new HotButton(&quot;#&quot;));

        // stack 4 row boxes in a vertical (column) box
        bx_v1.add(bx_h1);
        bx_v1.add(bx_h2);
        bx_v1.add(bx_h3);
        bx_v1.add(bx_h4);

        // add vertical box to panel
        add(bx_v1);
    } 
} 

// HotButton class
//
// An extension of JButton that requests the focus
// when the mouse enters the button. Also listens for
// focus changes and changes button appearance
// when button gets the focus.
class HotButton extends JButton { 
    private boolean bFocusIndicated = false;
    private Color originalColor;

    // constructor
    public HotButton(String text) { 
        super(text);

        // ensure that component can request focus
        // default is true, but just to be sure...
        setRequestFocusEnabled(true);
        
        // add a listener for mouse enter
        addMouseListener(new MouseAdapter() { 
            public void mouseEntered(MouseEvent event) { 
                // request the focus (if don't already have it)
                if(!hasFocus()) {  requestFocus(); } 
            } 
        } );
        // add a listener for focus events
        addFocusListener(new FocusAdapter() { 
            public void focusGained(FocusEvent e) { 
                if(!bFocusIndicated) { 
                    // set background to a darker color to indicate focus
                    originalColor = getBackground();
                    setBackground(originalColor.darker());
                    bFocusIndicated = true;
                } 
            } 
            public void focusLost(FocusEvent e) { 
                // restore original background color
                setBackground(originalColor);
                bFocusIndicated = false;
            } 
        } );
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel
{ 
    // Constructor
    public MyBox(int axis) { 
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZEHotFocusFONTTTFONTSIZEExampleFONT">
Overview of <TT>HotFocus2</TT>
Example</A></H3>
<P>
Like the previous <TT>HotFocus</TT> example, all of the focus-related
functionality of <TT>HotFocus2</TT> resides in the extension to
the <TT>JButton</TT> class, <TT>HotButton</TT>. The following
code fragment shows how the <TT>HotButton</TT> class implements
a focus listener to handle focus changes.
<BLOCKQUOTE>
<PRE>
// Add a listener for focus events
addFocusListener(new FocusAdapter() { 
    public void focusGained(FocusEvent e) { 
        if(!bFocusIndicated) { 
            // Set background to a brighter color to indicate focus
            originalColor = getBackground();
            setBackground(originalColor.darker());
            bFocusIndicated = true;
        } 
    } 
    public void focusLost(FocusEvent e) { 
        // Restore background color
        setBackground(originalColor);
        bFocusIndicated = false;
    } 
} );
</PRE>
</BLOCKQUOTE>
<P>
When the button gets the focus, get and save the background color
and then call the <TT>Color.darker</TT> method to make the background
color darker. When the button loses the focus, restore the background
to the original background color.
<P>
Since you can't be assured that a component with the focus won't
receive additional <TT>focusGained</TT> events, you must keep
track of whether a <TT>HotButton</TT> component has the focus
or not. To accomplish this, use the <TT>focusLost</TT> and <TT>focusGained</TT>
events to set the <TT>bFocusIndicated</TT> class member. You can't
use the <TT>hasFocus</TT> method for this purpose because it will
always return <TT>true</TT> when called while handling <TT>focusGained</TT>
events.
<H3><A NAME="ExampleUsingComponentManagedFocus">
Example Using Component-Managed Focus</A></H3>
<P>
The previous two examples show how a component can set the focus
to itself and how a component can detect when it gains and loses
the focus. You can also create components that manage focus traversal
by listening for keystrokes and determining which components get
the focus when the user presses the Tab and Shift+Tab keys. To
create a component that manages focus traversal, you must implement
the following steps:
<UL>
<LI>Override the <TT>isManagingFocus</TT> method to tell the focus
manager that the component is managing focus traversal. The focus
manager will then allow the Tab and Shift+Tab keystrokes to pass
to the component.
<LI>Add a key listener to listen for the Tab and Shift+Tab keystrokes.
<LI>Implement some way of determining which component gets the
focus when you detect a Tab or Shift+Tab keystroke.
</UL>
<P>
Listing 26.3 is the complete source for <TT>ComponentManagedFocus</TT>,
an example that overrides the focus manager and manages focus
traversal at the component level. This example uses the same telephone
keypad button arrangement as the <TT>HotFocus</TT> and <TT>HotFocus2</TT>
examples, but manages focus changes so that the focus traverses
vertically instead of horizontally. Note that the <TT>ComponentManagedFocus</TT>
example does not change the focus to components under the mouse
or indicate focus by darkening button colors (although you could
easily add this capability to this example).
<P>
<HR>
<P>
<B>Listing 26.3&nbsp;&nbsp;</B><TT><B>COMPONENTMANAGEDFOCUS.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* ComponentManagedFocus.java
 *
 * Illustrates how to implement component-managed 
 * focus changes instead of using the focus manager.
 */

import java.awt.event.*;
import javax.swing.*;

/* App class
 */
public class ComponentManagedFocus { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        ComponentManagedFocusPanel panel = 
  new ComponentManagedFocusPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;ComponentManagedFocus&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (150, 150);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class ComponentManagedFocusPanel extends JPanel { 
    // Constructor
    public ComponentManagedFocusPanel () { 
        super();

        // create twelve buttons, arranged in four rows of three.
        // use boxes to lay out to appear like a telephone keypad.
        MyButton b0, b1, b2, b3, b4, b5, b6, b7, b8, b9,
                 bAsterisk, bPound;
        MyBox bx_h1 = new MyBox(BoxLayout.X_AXIS);  // row 1
        MyBox bx_h2 = new MyBox(BoxLayout.X_AXIS);  // row 2
        MyBox bx_h3 = new MyBox(BoxLayout.X_AXIS);  // row 3
        MyBox bx_h4 = new MyBox(BoxLayout.X_AXIS);  // row 4
        MyBox bx_v1 = new MyBox(BoxLayout.Y_AXIS);  

        bx_h1.add(b1 = new MyButton(&quot;1&quot;));
        bx_h1.add(b2 = new MyButton(&quot;2&quot;));
        bx_h1.add(b3 = new MyButton(&quot;3&quot;));
        bx_h2.add(b4 = new MyButton(&quot;4&quot;));
        bx_h2.add(b5 = new MyButton(&quot;5&quot;));
        bx_h2.add(b6 = new MyButton(&quot;6&quot;));
        bx_h3.add(b7 = new MyButton(&quot;7&quot;));
        bx_h3.add(b8 = new MyButton(&quot;8&quot;));
        bx_h3.add(b9 = new MyButton(&quot;9&quot;));
        bx_h4.add(bAsterisk = new MyButton(&quot;*&quot;));
        bx_h4.add(b0 = new MyButton(&quot;0&quot;));
        bx_h4.add(bPound = new MyButton(&quot;#&quot;));

        // set focus control such that focus traverses top to bottom,
        // left to right. For example, 1,4,7,*,2,5,8,0,3,6,9,#,1...
        b1.setFocusControl(b4, bPound);
        b2.setFocusControl(b5, bAsterisk);
        b3.setFocusControl(b6, b0);
        b4.setFocusControl(b7, b1);
        b5.setFocusControl(b8, b2);
        b6.setFocusControl(b9, b3);
        b7.setFocusControl(bAsterisk, b4);
        b8.setFocusControl(b0, b5);
        b9.setFocusControl(bPound, b6);
        bAsterisk.setFocusControl(b2, b7);
        b0.setFocusControl(b3, b8);
        bPound.setFocusControl(b1, b9);
                           
        // stack 4 row boxes in a vertical (column) box
        bx_v1.add(bx_h1);
        bx_v1.add(bx_h2);
        bx_v1.add(bx_h3);
        bx_v1.add(bx_h4);

        // add vertical box to panel
        add(bx_v1);
    } 
} 

// MyButton class
//
// An extension of JButton that adds a new method, setFocusControl,
// that allows setting previous and next components to get the focus.
class MyButton extends JButton { 
    private JComponent nextFocus = null;
    private JComponent prevFocus = null;
    
    // Constructor
    public MyButton(String text) { 
        super(text);

        // add a listener for key events
        addKeyListener(new KeyAdapter() { 
            public void keyPressed(KeyEvent event) { 
                // look for tab key
                if(event.getKeyCode() == KeyEvent.VK_TAB 
                || event.getKeyChar() == '\ t') { 
                    // is shift pressed?
                    if ((event.getModifiers() 
                    &amp; ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) { 
                        // set previous focus
                        if (prevFocus != null) { 
                            prevFocus.requestFocus();
                            event.consume();
                        } 
                    } 
                    else { 
                        // set next focus
                        if (nextFocus != null) { 
                            nextFocus.requestFocus();
                            event.consume();
                        } 
                    } 
                } 

            } 
        } );
    } 

    // Sets previous and next components to get the focus
public void setFocusControl(JComponent nextFocus, 
                            JComponent prevFocus) { 
        this.nextFocus = nextFocus;
        this.prevFocus = prevFocus;
    } 

// Override to inform focus manager that 
    // component is managing focus changes
    public boolean isManagingFocus() { 
        return true;
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel
{ 
    // Constructor
    public MyBox(int axis) { 
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZEComponentManagedFocusFONTTTFONTSIZEExampleBRFONT">
Overview of <TT>ComponentManagedFocus</TT>
Example<BR>
</A></H3>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</TD></TR>
<TR VALIGN=TOP><TD WIDTH=600><BLOCKQUOTE>
Instead of algorithmically determining focus traversal based on component location or position in the containment hierarchy, this example takes a hard-coded approach to solving the focus-traversal problem. This approach works well only when you have a fixed number of focusable components and do not want focus traversal to be dependent on component layout.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The <TT>ComponentManagedFocus</TT> example is similar in structure
to the <TT>HotFocus</TT> and <TT>HotFocus2</TT> examples. The
constructor for the <TT>ComponentManagedFocusPanel</TT> class,
an extension of <TT>JPanel</TT>, creates twelve instances of <TT>MyButton</TT>
that it arranges in boxes to form four rows of three buttons each.
The constructor then calls the <TT>setFocusControl</TT> method
to specify which button gets the next and previous focus. This
is a method added to the <TT>MyButton</TT> class that extends
<TT>JButton</TT>.
<P>
Take a look at <TT>MyButton</TT>, the class that extends <TT>JButton</TT>
to implement component-managed focus traversal. <TT>MyButton</TT>
adds two private data members, <TT>nextFocus</TT> and <TT>prevFocus</TT>,
to store the next and previous components in the focus-traversal
sequence. These data members are set by a public method added
to <TT>MyButton</TT>, <TT>setFocusControl</TT>.
<BLOCKQUOTE>
<PRE>
// Sets previous and next components to get the focus
public void setFocusControl(JComponent nextFocus, JComponent prevFocus) { 
    this.nextFocus = nextFocus;
    this.prevFocus = prevFocus;
} 
</PRE>
</BLOCKQUOTE>
<P>
There is another method added to <TT>MyButton</TT>, <TT>isManagingFocus</TT>.
This method is an override to tell the focus manager that the
component is managing focus traversal. To receive Tab and Shift+Tab
keystrokes, a component must override <TT>isManagingFocus</TT>
and return <TT>true</TT>.
<BLOCKQUOTE>
<PRE>
// Override to inform focus manager that 
// component is managing focus changes
public boolean isManagingFocus() { 
    return true;
} 
</PRE>
</BLOCKQUOTE>
<P>
The final element to managing focus traversal in <TT>MyButton</TT>
is the key listener that listens for the Tab and Shift+Tab keystrokes.
The constructor for <TT>MyButton</TT> adds a key listener that
is implemented in an anonymous inner class. 
<BLOCKQUOTE>
<PRE>
// add a listener for key events
addKeyListener(new KeyAdapter() { 
    public void keyPressed(KeyEvent event) { 
        // look for tab key
        if(event.getKeyCode() == KeyEvent.VK_TAB 
        || event.getKeyChar() == '\ t') { 
            // is shift pressed?
            if ((event.getModifiers() 
            &amp; ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) { 
                // set previous focus
                if (prevFocus != null) { 
                    prevFocus.requestFocus();
                    event.consume();
                } 
            } 
            else { 
                // set next focus
                if (nextFocus != null) { 
                    nextFocus.requestFocus();
                    event.consume();
                } 
            } 
        } 

    } 
} );
</PRE>
</BLOCKQUOTE>
<P>
If the key listener gets a <TT>keyPressed</TT> event, it checks
to see if the keystroke is a Tab or Shift+Tab. If the keystroke
is a Tab or Shift+Tab, the listener calls the <TT>requestFocus</TT>
method on the component referenced by the appropriate <TT>nextFocus</TT>
or <TT>prevFocus</TT> data member (the data members set with the
<TT>setFocusControl</TT> method). Note that the listener calls
<TT>event.consume</TT> to prevent Tab and Shift+Tab <TT>keyPressed</TT>
events from propagating any further.
<H2><A NAME="UsingtheFocusManager">
Using the Focus Manager</A></H2>
<P>
While most focus management can be handled at the component level,
you may want to write your own focus manager or change the behavior
of the default focus manager. JFC provides two classes that encapsulate
focus management for Swing components: <TT>FocusManager</TT> and
<TT>DefaultFocusManager</TT>. The <TT>FocusManager</TT> class
is an abstract class that provides the basic underlying structure
for supporting installable focus managers. The <TT>DefaultFocusManager</TT>
class extends <TT>FocusManager</TT> and represents the implementation
of the default focus manager.
<H3><A NAME="TheTTFONTSIZEFocusManagerFONTTTFONTSIZEClassFONT">
The <TT>FocusManager</TT>
Class</A></H3>
<P>
You use the <TT>FocusManager</TT> class (in the <TT>com.sun.java.swing</TT>
package) when writing your own focus manager. Listing 26.4 gives
the class signature for the <TT>FocusManager</TT> class.
<P>
<HR>
<P>
<B>Listing 26.4&nbsp;&nbsp;</B><TT><B>FOCUSMANAGER</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public abstract class FocusManager extends Object { 
  // Public class data
    public static String FOCUS_MANAGER_CLASS_PROPERTY;
    public static Hashtable managers;
  // Public class methods
    public static FocusManager getCurrentManager();
    public static void setCurrentManager(FocusManager focusManager);
    public static void disableSwingFocusManager();
    public static boolean isFocusManagerEnabled();
  // Public abstract instance methods
    public abstract void processKeyEvent(Component component, 
                                         KeyEvent event);
    public abstract void focusNextComponent(Component component);
    public abstract void focusPreviousComponent(Component component);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The static class methods <TT>getCurrentManager</TT>, <TT>setCurrentManager</TT>,
<TT>disableSwingFocusManager</TT>, and <TT>isFocusManagerEnabled</TT>
give you access to the current focus manager and allow you to
disable the Swing focus management services as well as install
your own focus manager.
<P>
The abstract methods <TT>processKeyEvent</TT>, <TT>focusNextComponent</TT>,
and <TT>focusPreviousComponent</TT> are methods you must override
and implement if you are writing a focus manager.
<H3><A NAME="IssueswithMixingAWTandSwingComponents">
Issues with Mixing AWT and Swing Components</A></H3>
<P>
There are actually two focus managers present in JFC. In addition
to the Swing focus manager for managing focus with Swing components,
JFC includes the AWT focus manager to manage focus for AWT components.
If you are mixing AWT and Swing components in a component hierarchy,
you need to disable the Swing focus manager by calling the static
<TT>FocusManager</TT> method <TT>disableSwingFocusManager</TT>.
<P>
<TT>FocusManager.disableSwingFocusManager();</TT>
<P>
When you disable the Swing focus manager, your application will
use the AWT focus manager for Swing components as well as AWT
components.
<H2><A NAME="WritingaCustomFocusManager">
Writing a Custom Focus Manager</A></H2>
<P>
If Swing's default focus manager is not adequate for the needs
of your application, you can replace it with your own focus manager.
To create a custom focus manager, you extend the abstract <TT>FocusManager</TT>
class and implement the methods <TT>processKeyEvent</TT>, <TT>focusNextComponent</TT>,
and <TT>focusPreviousComponent</TT>. The <TT>processKeyEvent</TT>
method receives keystrokes from the component that currently has
the focus. In the implementation for <TT>processKeyEvent</TT>,
you listen for Tab and Shift+Tab keystrokes and use <TT>grabFocus</TT>
to set the focus to the appropriate component. <TT>focusNextComponent</TT>
and <TT>focusPreviousComponent</TT> are methods you must implement
to change the focus to the previous or next component to get the
focus after a given component. Creating the structure for a custom
focus manager is fairly straight-forward-the challenge is in creating
a general-purpose algorithm for determining focus traversal.
<H3><A NAME="ExampleUsingaCustomFocusManager">
Example Using a Custom Focus Manager</A></H3>
<P>
Take a look at an example of a custom focus manager. The <TT>CustomFocusManager</TT>
<BR>
example is a different version of the focus-traversal implementation
in the <TT>ComponentManagedFocus</TT> example. By all appearances,
the applications operate identically-focus traverses vertically
top-to-bottom instead of horizontally like the default focus manager.
<P>
The difference is in the implementation of focus management. While
the <TT>ComponentManagedFocus</TT> example handles focus changes
at the component level, <TT>CustomFocusManager</TT> implements
the same algorithm in a custom focus manager. Listing 26.5 is
the complete source for <TT>CustomFocusManager</TT>.
<P>
<HR>
<P>
<B>Listing 26.5&nbsp;&nbsp;</B><TT><B>CUSTOMFOCUSMANAGER.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* CustomFocusManager.java
 *
 * Illustrates how to implement a custom focus manager.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.FocusManager;

/* App class
 */
public class CustomFocusManager { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        CustomFocusManagerPanel panel = new CustomFocusManagerPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;CustomFocusManager&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // create and install custom focus manager
        FocusManager fm = new MyFocusManager();
        FocusManager.setCurrentManager(fm);

        // set initial frame size and make visible
        frame.setSize (150, 150);
        frame.setVisible(true);
    } 
} 


/* App panel class
 */
class CustomFocusManagerPanel extends JPanel { 
    // Constructor
    public CustomFocusManagerPanel () { 
        super();

        // create twelve buttons, arranged in four rows of three.
        // use boxes to lay out to appear like a telephone keypad.
        MyButton b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, 
                 bAsterisk, bPound;
        MyBox bx_h1 = new MyBox(BoxLayout.X_AXIS);  // row 1
        MyBox bx_h2 = new MyBox(BoxLayout.X_AXIS);  // row 2
        MyBox bx_h3 = new MyBox(BoxLayout.X_AXIS);  // row 3
        MyBox bx_h4 = new MyBox(BoxLayout.X_AXIS);  // row 4
        MyBox bx_v1 = new MyBox(BoxLayout.Y_AXIS);  

        bx_h1.add(b1 = new MyButton(&quot;1&quot;));
        bx_h1.add(b2 = new MyButton(&quot;2&quot;));
        bx_h1.add(b3 = new MyButton(&quot;3&quot;));
        bx_h2.add(b4 = new MyButton(&quot;4&quot;));
        bx_h2.add(b5 = new MyButton(&quot;5&quot;));
        bx_h2.add(b6 = new MyButton(&quot;6&quot;));
        bx_h3.add(b7 = new MyButton(&quot;7&quot;));
        bx_h3.add(b8 = new MyButton(&quot;8&quot;));
        bx_h3.add(b9 = new MyButton(&quot;9&quot;));
        bx_h4.add(bAsterisk = new MyButton(&quot;*&quot;));
        bx_h4.add(b0 = new MyButton(&quot;0&quot;));
        bx_h4.add(bPound = new MyButton(&quot;#&quot;));

        // set focus control such that focus traverses top to bottom,
        // left to right. For example, 1,4,7,*,2,5,8,0,3,6,9,#,1...
        b1.setNextFocus(b4);        b1.setPreviousFocus(bPound);
        b2.setNextFocus(b5);        b2.setPreviousFocus(bAsterisk);
        b3.setNextFocus(b6);        b3.setPreviousFocus(b0);
        b4.setNextFocus(b7);        b4.setPreviousFocus(b1);
        b5.setNextFocus(b8);        b5.setPreviousFocus(b2);
        b6.setNextFocus(b9);        b6.setPreviousFocus(b3);
        b7.setNextFocus(bAsterisk); b7.setPreviousFocus(b4);
        b8.setNextFocus(b0);        b8.setPreviousFocus(b5);
        b9.setNextFocus(bPound);    b9.setPreviousFocus(b6);
        bAsterisk.setNextFocus(b2); bAsterisk.setPreviousFocus(b7);
        b0.setNextFocus(b3);        b0.setPreviousFocus(b8);
        bPound.setNextFocus(b1);    bPound.setPreviousFocus(b9);
                           
        // stack 4 row boxes in a vertical (column) box
        bx_v1.add(bx_h1);
        bx_v1.add(bx_h2);
        bx_v1.add(bx_h3);
        bx_v1.add(bx_h4);

        // add vertical box to panel
        add(bx_v1);
    } 
} 

/* Interface that components must implement to
 * operate with custom focus manager in this example.
 */
interface MyFocusManagerSupport { 
    // Sets next component to get the focus
    public void setNextFocus(JComponent component);
    // Sets previous component to get the focus
    public void setPreviousFocus(JComponent component);
    // Returns next component to get focus
    public JComponent getNextFocus();
    // Returns previous component to get focus
    public JComponent getPreviousFocus();
} 

/* MyButton class
 *
 * An extension of JButton that implements
 * MyFocusManagerSupport interface.
 */
class MyButton extends JButton implements MyFocusManagerSupport { 
    private JComponent nextFocus = null;
    private JComponent previousFocus = null;
    
    // Constructor
    public MyButton(String text) { 
        super(text);
    } 

    // Implementation of MyFocusManagerSupport interface
    
    public void setNextFocus(JComponent component) { 
        nextFocus = component;
    } 
    
    public void setPreviousFocus(JComponent component) { 
        previousFocus = component;
    } 
    
    public JComponent getPreviousFocus() {  return (previousFocus); } 
    
    public JComponent getNextFocus() {  return (nextFocus); }  
} 

/* MyFocusManager class
 *
 * An implementation of a custom focus manager.
 *
 * Components managed by this focus manager must
 * implement the MyFocusManagerSupport interface.
 */
class MyFocusManager extends FocusManager { 
    public MyFocusManager() { 
       super();
    } 

    // Implementations of abstract FocusManager methods

    // Handles key events on component with current focus
    public void processKeyEvent(Component component, KeyEvent event) { 
        if(component instanceof MyFocusManagerSupport) { 
            MyButton focusedButton = (MyButton) component;
                                      
            // look for tab key
            if(event.getKeyCode() == KeyEvent.VK_TAB 
               || event.getKeyChar() == '\ t') { 
                // change focus only on key pressed events
                if(event.getID() == KeyEvent.KEY_PRESSED) { 
                    // is shift pressed?
                    if ((event.getModifiers()
  &amp; ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) { 
                        // set previous focus
                        focusPreviousComponent(component);
                    } 
                    else { 
                        // set next focus
                        focusNextComponent(component);
                    } 
                } 
                // consume all tab key events
                event.consume();
            } 
        } 
    } 
    
    // Changes focus to component that gets focus after given component
    public void focusNextComponent(Component component) { 
        // ensure given component is one we can manage
        if(component instanceof MyFocusManagerSupport) { 
            MyFocusManagerSupport focusedComponent 
  = (MyFocusManagerSupport) component;
            if (focusedComponent.getNextFocus() != null) { 
                focusedComponent.getNextFocus().grabFocus();
            }            
        } 
    } 
    
    // Changes focus to component that gets focus before given component
    public void focusPreviousComponent(Component component) { 
        // ensure given component is one we can manage
        if(component instanceof MyFocusManagerSupport) { 
            MyFocusManagerSupport focusedComponent 
  = (MyFocusManagerSupport) component;
            if (focusedComponent.getPreviousFocus() != null) { 
                focusedComponent.getPreviousFocus().grabFocus();
            }            
        } 
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel
{ 
    // Constructor
    public MyBox(int axis) { 
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZECustomFocusManagerFONTTTFONTSIZEExampleFONT">
Overview of <TT>CustomFocusManager</TT>
Example</A></H3>
<P>
The focus traversal algorithm used by <TT>CustomFocusManager</TT>
is simple-for each component, you must specify the previous and
next components to get the focus. The example defines an interface,
<TT>MyFocusManagerSupport</TT>, that components must implement
to be managed by this custom focus manager.
<BLOCKQUOTE>
<PRE>
/* Interface that components must implement to
 * operate with custom focus manager in this example.
 */
interface MyFocusManagerSupport { 
    // Sets next component to get the focus
    public void setNextFocus(JComponent component);

    // Sets previous component to get the focus
    public void setPreviousFocus(JComponent component);

    // Returns next component to get focus
    public JComponent getNextFocus();

    // Returns previous component to get focus
    public JComponent getPreviousFocus();
} 
</PRE>
</BLOCKQUOTE>
<P>
The interface includes methods for setting and getting the previous
and next components to get the focus. The only focusable components
in this example are the buttons represented by the <TT>MyButton</TT>
class, an extension of <TT>JButton</TT>. <TT>MyButton</TT> simply
provides a constructor for a textual button and implements the
<TT>MyFocusManagerSupport</TT> interface by adding two private
data members to store the next and previous components to get
the focus.
<P>
Before looking at the implementation of the custom focus manager,
consider how it is installed. After creating the panel containing
the application's user interface and adding it to a frame, the
main entry point in the <TT>CustomFocusManager</TT> class creates
an instance of <TT>MyFocusManager</TT> and installs it with the
<TT>FocusManager.setCurrentManager</TT> static class method.
<BLOCKQUOTE>
<PRE>
// create and install custom focus manager
FocusManager fm = new MyFocusManager();
FocusManager.setCurrentManager(fm);
</PRE>
</BLOCKQUOTE>
<P>
The custom focus manager is implemented in the <TT>MyFocusManager</TT>
class, an extension of the abstract <TT>FocusManager</TT> class.
In addition to a default constructor, <TT>MyFocusManager</TT>
includes implementations of the three abstract <TT>FocusManager</TT>
methods: <TT>processKeyEvent</TT>, <TT>focusNextComponent</TT>,
and <TT>focusPreviousComponent</TT>. 
<P>
The following code fragment is the implementation of the <TT>focusNextComponent</TT>
method.
<BLOCKQUOTE>
<PRE>
// Changes focus to component that gets focus after given component
public void focusNextComponent(Component component) { 
    // ensure given component is one we can manage
    if(component instanceof MyFocusManagerSupport) { 
    MyFocusManagerSupport focusedComponent 
  = (MyFocusManagerSupport) component;
        if (focusedComponent.getNextFocus() != null) { 
            focusedComponent.getNextFocus().grabFocus();
        }            
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
The first thing <TT>focusNextComponent</TT> does is to check the
given component to make sure it implements the <TT>MyFocusManagerSupport</TT>
interface. The custom focus manager in this example can only manage
focus traversal for components that implement this interface.
<TT>focusNextComponent</TT> then calls the <TT>getNextFocus</TT>
method on the given component to determine which component gets
the next focus. If <TT>getNextFocus</TT> doesn't return <TT>null</TT>,
the component's <TT>grabFocus</TT> method is called to give it
the focus. The <TT>focusPreviousComponent</TT> method is implemented
similarly to <TT>focusNextComponent</TT>.
<P>
The <TT>processKeyEvent</TT> method receives keystroke events
for the component that currently has the focus. Its role is to
listen for the keystrokes that change the focus (Tab and Shift+Tab)
and call the <TT>focusNextComponent</TT> and <TT>focusPreviousComponent</TT>
methods to change the focus.
<BLOCKQUOTE>
<PRE>
// Handles key events on component with current focus
public void processKeyEvent(Component component, KeyEvent event) { 
    if(component instanceof MyFocusManagerSupport) { 
        MyButton focusedButton = (MyButton) component;
                                      
        // look for tab key
        if(event.getKeyCode() == KeyEvent.VK_TAB 
  || event.getKeyChar() == '\ t') { 
            // change focus only on key pressed events
            if(event.getID() == KeyEvent.KEY_PRESSED){ 
                // is shift pressed?
                if ((event.getModifiers() 
  &amp; ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK) { 
                    // set previous focus
                    focusPreviousComponent(component);
                } 
                else { 
                    // set next focus
                    focusNextComponent(component);
                } 
            } 
            // consume all tab key events
            event.consume();
        } 
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
Note that <TT>processKeyEvent</TT> changes focus only on <TT>KEY_PRESSED</TT>
events and consumes <TT>KEY_RELEASED</TT> and <TT>KEY_TYPED</TT>
events without taking any action. The result is that all Tab and
Shift+Tab keystroke events are consumed by the focus manager and
will never reach the component with the focus.
<P>
This implementation of a custom focus manager is useful if you
want to control focus traversal for components, regardless of
the order in which they are added to a container or how a layout
manager arranges them. A more challenging exercise would be to
write a focus manager that manages focus traversal with an algorithm
based on component location.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
Focus management is a collaborative effort between the focus manager
and individual components. JFC enhances the focus management capabilities
of AWT by making some of the classes that manage focus traversal
public classes, and by adding to the focus-related methods in
the <TT>JComponent</TT> class. 
<P>
With JFC, you can explicitly set the focus to a component, manage
focus changes from components, and detect when components gain
and lose the focus. This chapter illustrates each of these techniques
with examples. The <TT>HotFocus</TT> example shows you how to
set the focus to a component whenever it is under the mouse. <TT>HotFocus2</TT>
adds to this example by detecting when components gain the focus
and indicating the focus visually. The <TT>ComponentManagedFocus</TT>
example shows you how to manage focus from components by subclassing
the <TT>JButton</TT> class and adding some methods to set the
next and previous components to get the focus.
<P>
JFC also allows you to install a custom focus manager to replace
the default focus manager for an application. Very few applications
will actually need a custom focus manager though-most focus management
needs can be handled with the default focus manager. The <TT>CustomFocusManager</TT>
example illustrates how to implement a custom focus manager.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch25\ch25.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch27\ch27.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
