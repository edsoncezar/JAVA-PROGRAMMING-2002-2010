<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 29 - Keyboard Navigation</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch28\ch28.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch30\ch30.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;29<br>
Keyboard Navigation</H1>
<HR>
<p>


<UL>
<LI><A HREF="#AboutAcceleratorsMnemonicsandShortcuts">
About Accelerators, Mnemonics, and Shortcuts</A>
<LI><A HREF="#UsingMnemonics">
Using Mnemonics</A>
<UL>
<LI><A HREF="#AddingMnemonicstoButtonsandMenus">
Adding Mnemonics to Buttons and Menus </A>
<LI><A HREF="#ExampleUsingMnemonics">
Example Using Mnemonics</A>
<LI><A HREF="#OverviewofTTFONTSIZEBasicMnemonicDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>BasicMnemonicDemo</TT>
Example</A>
</UL>
<LI><A HREF="#UsingMenuAccelerators">
Using Menu Accelerators</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEKeyStrokeFONTTTFONTSIZEClassFONT">
The <TT>KeyStroke</TT> Class
</A>
<LI><A HREF="#ExampleUsinganAccelerator">
Example Using an Accelerator</A>
<LI><A HREF="#OverviewofTTFONTSIZEBasicAcceleratorDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>BasicAcceleratorDemo</TT>
Example</A>
</UL>
<LI><A HREF="#UsingShortcutsHotKeys">
Using Shortcuts (Hot Keys)</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEJComponentregisterKeyboardActionFONTTTFONTSIZEMethodFONT">
The <TT>JComponent.registerKeyboardAction</TT>
Method</A>
<LI><A HREF="#MoreTTFONTSIZEJComponentFONTTTFONTSIZEShortcutMethodsFONT">
More <TT>JComponent</TT>
Shortcut Methods</A>
<LI><A HREF="#ASimpleExampleUsingaShortcut">
A Simple Example Using a Shortcut</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEBasicShortcutDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>BasicShortcutDemo</TT>
Example</A>
</UL>
<LI><A HREF="#KeyboardNavigationwithTTFONTSIZEActionFONTTTFONTSIZEObjectsFONT">
Keyboard Navigation with <TT>Action</TT>
Objects</A>
<UL>
<LI><A HREF="#ExampleUsingKeyNavigationwithActionObject">
Example Using Key Navigation with Action Object</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEKeyNavigationDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>KeyNavigationDemo</TT>
Example</A>
</UL>
<LI><A HREF="#UsingMnemonicswithLabels">
Using Mnemonics with Labels</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Even though you can count on almost any computer having a mouse
or some other type of pointing device, it's important to design
graphical user interfaces that can be navigated and operated with
a keyboard. Accelerators, mnemonics, and shortcuts are user-interface
techniques that enable common interface controls like buttons
and menus to be navigated and operated with keystrokes. Swing
supports all of these techniques, which, coupled with its focus
management services, allow you to create graphical user interfaces
that are easily navigable with keystrokes.
<P>
In this chapter, you will learn
<UL>
<LI>The difference between accelerators, mnemonics, and shortcuts
<BR>
These terms can be confusing-even JFC is sometimes inconsistent
in its use of these terms.
<LI>How to add keyboard navigation to menus and buttons<BR>
Accelerators and mnemonics are keyboard navigation techniques
associated with menu and button controls. These techniques provide
a means of navigating and operating a user interface.
<LI>How to create and use shortcuts<BR>
Shortcuts (sometimes known as hot keys) directly associate a keystroke
combination with an action-there are often no user-interface elements
associated with shortcuts.
<LI>How to add keyboard navigation to menus and buttons created
from action objects<BR>
Rather than explicitly creating menu items and buttons, you can
create them by adding action objects to a menu or toolbar container.
You can also add keyboard navigation to components created by
using this powerful technique.
<LI>How to use mnemonics with labels<BR>
There are times when you may want to use a label to identify a
component rather than including text within the component. The
<TT>JLabel</TT> component allows you to specify a mnemonic for
an associated component.
</UL>
<H2><A NAME="AboutAcceleratorsMnemonicsandShortcuts">
About Accelerators, Mnemonics, and Shortcuts</A></H2>
<P>
Accelerators, mnemonics, and shortcuts are similar (but not identical)
mechanisms for navigating and operating user interfaces with keystrokes.
These terms aren't always used consistently, which can lead to
some confusion about their meaning. In this book, use the following
definitions:
<UL>
<LI><I>Mnemonics</I> (sometimes called
keyboard equivalents) are associated with <TT>AbstractButton</TT>
objects-objects such as <TT>JButton</TT>, <TT>JMenu</TT>, and
<TT>JMenuItem</TT>. Mnemonics typically use the Alt key modifier,
but modifier key usage depends on the look-and-feel implementation.
<LI><I>Shortcuts</I> (sometimes called
hot keys) are associated with action listener objects (objects
that implement the <TT>ActionListener</TT> interface). Shortcuts
result in an immediate action, often with no visual changes to
the corresponding interface elements (for example, the menus do
not pop up on the execution of a shortcut-driven command). With
shortcuts, you can specify the modifier key for the keystroke
associated with the shortcut. Unlike the accelerator modifier
key, the shortcut modifier key does not depend on the look-and-feel
implementation.
<LI><I>Accelerators</I> are simply
shortcuts that are associated with menu items. They have all of
the same characteristics as shortcuts.
</UL>
<P>
It's good design practice to use mnemonics on all menus and menu
items, and to use accelerators on all frequently accessed menu
items. You should also use mnemonics as much as possible on the
user-interface components in dialog boxes. Reserve the use of
shortcuts for heavily used, repetitive commands such as zooming
in or out on a graphical view.
<H2><A NAME="UsingMnemonics">
Using Mnemonics</A></H2>
<P>
As stated earlier, mnemonics are associated with textual menus
and buttons. Mnemonic keys are often identified by underlining
the letter corresponding to the mnemonic key. For example, in
the File menu, the mnemonic is usually the &quot;f&quot; key,
in which case the &quot;F&quot; in File appears with an underline.
<P>
The modifier key for mnemonics depends on the look-and-feel that
is used. Most look-and-feel implementations use the Alt key as
the modifier.
<H3><A NAME="AddingMnemonicstoButtonsandMenus">
Adding Mnemonics to Buttons and Menus </A></H3>
<P>
The <TT>AbstractButton</TT> class, the class upon which all Swing
buttons and menus are based, includes three methods for setting
and getting key mnemonics:
<BLOCKQUOTE>
<PRE>
public void setMnemonic(int keycode);
public void setMnemonic(char keychar);
public int getMnemonic();
</PRE>
</BLOCKQUOTE>
<P>
The two <TT>setMnemonic</TT> methods allow you to set a mnemonic
by specifying either a virtual key code or a character. The <TT>KeyEvent</TT>
class includes constants for specifying virtual key codes. For
example, the following code fragment creates an Exit button and
sets its mnemonic to &quot;x.&quot;
<BLOCKQUOTE>
<PRE>
JButton button = new JButton(&quot;Exit&quot;);
button.setMnemonic(KeyEvent.VK_X);
</PRE>
</BLOCKQUOTE>
<P>
Since the menu classes <TT>JMenu</TT> and <TT>JMenuItem</TT> are
extensions of <TT>AbstractButton</TT>, you can use these same
two <TT>setMnemonic</TT> methods to set mnemonics for menus. 
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JMenuItem</TT> class has a constructor that allows you to specify the mnemonic when you create a textual menu item. The <TT>JMenu</TT> class does not have a similar constructor-you must use the <TT>setMnemonic</TT> method to set a mnemonic with <TT>JMenu</TT> objects.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="ExampleUsingMnemonics">
Example Using Mnemonics</A></H3>
<P>
Listing 29.1 is the complete source for <TT>BasicMnemonicDemo</TT>,
an application illustrating how to implement a button and a menu
with mnemonics. Figure 29.1 shows the output of this code.
<P>
<A HREF="javascript:popUp('f29-1.gif')"><B>Figure 29.1 :</B> <I>BasicMnemonicDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 29.1&nbsp;&nbsp;</B><TT><B>BASICMNEMONICDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* BasicMnemonicDemo.java
 *
 * A  basic JFC application with a button
 * and menu that use mnemonics.
 *
 * Illustrates how to set mnemonics for buttons and menus.
 */

import java.awt.BorderLayout;
import java.awt.event.*;
import javax.swing.*;


/* Application class
 */
public class BasicMnemonicDemo extends JPanel { 

    // Constructor
    public BasicMnemonicDemo() { 
        setLayout(new BorderLayout());
        
        // create an action listener for use with exit button and menu
        ActionListener exitActionListener = new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                System.exit(0);
            } 
        } ;

        // create a non-floatable toolbar
        JToolBar toolbar = new JToolBar();
        toolbar.setFloatable(false);

        // create an exit button, add to toolbar
        JButton button = new JButton(&quot;Exit&quot;);
        button.addActionListener(exitActionListener);
        button.setMnemonic(KeyEvent.VK_X);
        toolbar.add(button);

        // create a menu bar with a File menu
        JMenuBar menubar = new JMenuBar();
        JMenu menuFile = new JMenu(&quot;File&quot;);
        menuFile.setMnemonic(KeyEvent.VK_F);
        menubar.add(menuFile);

        // create an Exit menu item, add to File menu
        JMenuItem itemExit = new JMenuItem(&quot;Exit&quot;,KeyEvent.VK_X);
        itemExit.addActionListener(exitActionListener);
        menuFile.add(itemExit);

        // add toolbar and menu bar to panel
        add(toolbar, BorderLayout.SOUTH);
        add(menubar, BorderLayout.NORTH);
    } 
    
    // The main entry point
    public static void main(String s[]) { 
        // create an instance of the app
        BasicMnemonicDemo appPanel = new BasicMnemonicDemo();

        // create a frame for app
        JFrame frame = new JFrame(&quot;BasicMnemonicDemo&quot;);

        // add a window listener for close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content frame
        frame.getContentPane().add(appPanel);

        // make frame visible, set initial size
        frame.setVisible(true);
        frame.setSize(200, 150);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZEBasicMnemonicDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>BasicMnemonicDemo</TT>
Example</A></H3>
<P>
The <TT>BasicMnemonicDemo</TT> example consists of a single class,
<TT>BasicMnemonicDemo</TT>, which extends <TT>JPanel</TT>. The
<TT>main</TT> entry point method creates an instance of this panel
and then creates a frame. After adding a window listener for <TT>windowClosing</TT>
events, <TT>main</TT> adds the panel to the frame's content pane.
<P>
The constructor for the <TT>BasicMnemonicDemo</TT> class creates
an action listener implemented in an inner class. This action
listener is associated with both the Exit button and the Exit
menu item. The action listener's <TT>actionPerformed</TT> method
simply exits the application with a call to <TT>System.exit</TT>.
<BLOCKQUOTE>
<PRE>
// create an action listener for use with exit button and menu
ActionListener exitActionListener = new ActionListener() { 
    public void actionPerformed(ActionEvent e) { 
        System.exit(0);
    } 
} ;
</PRE>
</BLOCKQUOTE>
<P>
The constructor goes on to create a toolbar, a button, a menu
bar, a menu, and a menu item. The constructor uses <TT>setMnemonic</TT>
to set mnemonics for the button, menu, and menu item. Note that
there is no modifier key specified with mnemonics-the modifier
key is determined by the look-and-feel implementation. Most implementations
use the Alt key as the modifier key for mnemonics. 
<BLOCKQUOTE>
<PRE>
// create a non-floatable toolbar
JToolBar toolbar = new JToolBar();
toolbar.setFloatable(false);

// create an exit button, add to toolbar
JButton button = new JButton(&quot;Exit&quot;);
button.addActionListener(exitActionListener);
button.setMnemonic(KeyEvent.VK_X);
toolbar.add(button);

// create a menu bar with a File menu
JMenuBar menubar = new JMenuBar();
JMenu menuFile = new JMenu(&quot;File&quot;);
menuFile.setMnemonic(KeyEvent.VK_F);
menubar.add(menuFile);

// create an Exit menu item, add to File menu
JMenuItem itemExit = new JMenuItem(&quot;Exit&quot;, KeyEvent.VK_X);
itemExit.addActionListener(exitActionListener);
menuFile.add(itemExit);
</PRE>
</BLOCKQUOTE>
<P>
After creating all of the button and menu components, the constructor
adds the toolbar and the menu bar to the panel.
<BLOCKQUOTE>
<PRE>
// add toolbar and menu bar to panel
add(toolbar, BorderLayout.SOUTH);
add(menubar, BorderLayout.NORTH);
</PRE>
</BLOCKQUOTE>
<P>
The result is an application that exits (via the button's action
listener) when you press the Alt+X key combination. If you press
the Alt+F key combination, the File menu drops down and then if
you press Alt+X, the menu's action listener exits the application.
Note that this application uses the same action listener for both
the button and the menu item, but you could use separate listeners.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
In addition to the modifier-key combination, some look-and-feel implementations, including the Metal look-and-feel, execute menu item actions when only the mnemonic key is pressed (with no modifier). For an illustration of this behavior, run the <TT>BasicMnemonicDemo</TT> example and press the Alt+F key combination, and then press the X key.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H2><A NAME="UsingMenuAccelerators">
Using Menu Accelerators</A></H2>
<P>
In addition to a mnemonic, menu items can have an accelerator.
An accelerator is a keystroke combination that immediately invokes
the action associated with the menu item. For example, the Exit
menu in the preceding example could have an accelerator, Ctrl+X,
that quits the application. The keystroke combinations for menu
accelerators appear in the right side of the menu item when it
is displayed. See Figure 29.2 for an illustration of the appearance
of a menu with an accelerator.
<P>
The <TT>MenuItem</TT> class has two methods for getting and setting
accelerators.
<BLOCKQUOTE>
<PRE>
public void setAccelerator(KeyStroke keyStroke);
public KeyStroke getAccelerator();
</PRE>
</BLOCKQUOTE>
<P>
Unlike mnemonics, where modifier keys are determined by the look-and-feel
implementation, accelerators allow you to specify a modifier key.
The <TT>setAccelerator</TT> method uses the <TT>KeyStroke</TT>
class to specify a keystroke combination that can (but is not
required to) include a modifier key.
<H3><A NAME="TheTTFONTSIZEKeyStrokeFONTTTFONTSIZEClassFONT">
The <TT>KeyStroke</TT> Class
</A></H3>
<P>
The following code gives the signature of the <TT>KeyStroke</TT>
class. This class is used to specify shortcuts as well as menu
accelerators. See the &quot;Using Shortcuts (Hot Keys)&quot; section
later in this chapter for details on using shortcuts.
<BLOCKQUOTE>
<PRE>
public class KeyStroke extends Object implements Serializable 
{ 
    // Static methods to get a shared instance of a KeyStroke object
    public static KeyStroke getKeyStroke(char keychar);
    public static KeyStroke getKeyStroke(int keycode, int modifiers, 
                                         boolean onRelease);
    public static KeyStroke getKeyStroke(int keycode, int modifiers);
    public static KeyStroke getKeyStrokeForEvent(KeyEvent event);

    public char getKeyChar();
    public int getKeyCode();
    public int getModifiers();
    public boolean isOnKeyRelease();
    public int hashCode();
    public boolean equals(Object);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>KeyStroke</TT> class doesn't have a public constructor-instead,
the class provides four class methods to create <TT>KeyStroke</TT>
objects. The following code fragment show how to use three of
these class methods to create <TT>KeyStroke</TT> objects from
a key character and a virtual key code combined with a key modifier
(Shift, Alt, Ctrl, Meta). The third method creates a <TT>KeyStroke</TT>
that triggers an action on key release-the default is to trigger
the action on key press event.
<BLOCKQUOTE>
<PRE>
// Create a &quot;q&quot; KeyStroke object from a key character
KeyStroke k1 = KeyStroke.getKeyStroke('q');

// Create a &quot;Ctrl+Q&quot; KeyStroke object that activates on key press event
KeyStroke k2 = KeyStroke.getKeyStroke(KeyEvent.VK_Q, 
                                      InputEvent.CTRL_MASK);

// Create a &quot;Ctrl+Q&quot; KeyStroke object that activates on key release event
KeyStroke k3 = KeyStroke.getKeyStroke(KeyEvent.VK_Q, 
                                      InputEvent.CTRL_MASK, 
                                      true);
</PRE>
</BLOCKQUOTE>
<P>
There is also a class method that creates a <TT>KeyStroke</TT>
object from a <TT>KeyEvent</TT> object. The ID of the <TT>KeyEvent</TT>
object can be either <TT>KEY_PRESSED</TT>, <TT>KEY_RELEASED</TT>,
or <TT>KEY_TYPED</TT>.
<P>
You can specify any combination of the following constants (or
none at all) for the modifier key combination when creating a
<TT>KeyStroke</TT> object (see Table 29.1).<BR>
<P>
<CENTER><B>Table 29.1&nbsp;&nbsp;</B><TT><B>KEYSTROKE</B></TT><B>
Key Modifier Constants</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD COLSPAN=2 WIDTH=192>Constant</TD><TD WIDTH=144>Meaning
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=2 WIDTH=192><TT>Event.CTRL_MASK</TT></TD><TD WIDTH=144>The Ctrl key
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=2 WIDTH=192><TT>Event.ALT_MASK</TT></TD><TD WIDTH=144>The Alt key
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=2 WIDTH=192><TT>Event.SHIFT_MASK</TT></TD><TD WIDTH=144>The Shift key
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=2 WIDTH=192><TT>Event.META_MASK</TT></TD><TD WIDTH=144>The Meta key*
</TD></TR>
</TABLE>
<p><FONT SIZE=-1>* Note that the Meta key may not be present on all keyboards.</FONT></p>
</CENTER>
</CENTER>
<P>
<H3><A NAME="ExampleUsinganAccelerator">
Example Using an Accelerator</A></H3>
<P>
Listing 29.2 is the complete source for <TT>BasicAcceleratorDemo</TT>,
an application illustrating the implementation of a menu with
a mnemonic and an accelerator. Figure 29.2 shows the output of
this code.
<P>
<A HREF="javascript:popUp('f29-2.gif')"><B>Figure 29.2 :</B> <I>BasicAccelerator Demo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 29.2&nbsp;&nbsp;</B><TT><B>BASICACCELERATORDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* BasicAcceleratorDemo.java
 *
 * A basic JFC application with a menu
 * that has a mnemonic and an accelerator.
 *
 * Illustrates how to set a mnemonic
 * and accelerator for a menu item.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


/* Application class
 */
public class BasicAcceleratorDemo extends JPanel { 

    // Constructor
    public BasicAcceleratorDemo() { 
        setLayout(new BorderLayout());
        
        // create an action listener for use with exit menu
        ActionListener quitActionListener = new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                System.exit(0);
            } 
        } ;

        // create a menu bar with a File menu
        JMenuBar menubar = new JMenuBar();
        JMenu menuFile = new JMenu(&quot;File&quot;);
        menuFile.setMnemonic(KeyEvent.VK_F);
        menubar.add(menuFile);

        // create an Exit menu item with mnemonic,
        // set accelerator, action listener
        JMenuItem itemExit = new JMenuItem(&quot;Exit&quot;, KeyEvent.VK_X);
        itemExit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, 
                                                       Event.CTRL_MASK));
        itemExit.addActionListener(quitActionListener);

        // add menu item to menu, add menu bar to panel
        menuFile.add(itemExit);
        add(menubar, BorderLayout.NORTH);
    } 
    
    // The main entry point
    public static void main(String s[]) { 
        // create an instance of the app
        BasicAcceleratorDemo appPanel = new BasicAcceleratorDemo();

        // create a frame for app
        JFrame frame = new JFrame(&quot;BasicAcceleratorDemo&quot;);

        // add a window listener for close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content frame
        frame.getContentPane().add(appPanel);

        // make frame visible, set initial size
        frame.setVisible(true);
        frame.setSize(200, 100);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZEBasicAcceleratorDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>BasicAcceleratorDemo</TT>
Example</A></H3>
<P>
The <TT>BasicAcceleratorDemo</TT> example is structured very much
like the previous <TT>BasicMnemonicDemo</TT> example. There is
a single class, <TT>BasicAcceleratorDemo</TT>, that extends <TT>JPanel</TT>.
The constructor creates an action listener with an <TT>actionPerformed</TT>
method that calls <TT>System.exit</TT> to exit the application.
This action listener is identical to the action listener in the
previous <TT>BasicMnemonicDemo</TT> example.
<BLOCKQUOTE>
<PRE>
// create an action listener for use with exit menu
ActionListener quitActionListener = new ActionListener() { 
    public void actionPerformed(ActionEvent e) { 
        System.exit(0);
    } 
} ;
</PRE>
</BLOCKQUOTE>
<P>
After creating a menu bar and menu, the constructor creates a
menu item with a mnemonic specified as a virtual key code and
calls the <TT>setAccelerator</TT> method to set the accelerator
to the Ctrl+X key combination. The constructor then adds an action
listener for the menu item.
<BLOCKQUOTE>
<PRE>
// create an Exit menu item with mnemonic, 
// set accelerator, action listener
JMenuItem itemExit = new JMenuItem(&quot;Exit&quot;, KeyEvent.VK_X);
itemExit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, 
                                               Event.CTRL_MASK));
itemExit.addActionListener(quitActionListener);
</PRE>
</BLOCKQUOTE>
<P>
When you run the <TT>BasicAcceleratorDemo</TT> example and press
the Ctrl+X key combination, the <TT>actionPerformed</TT> method
in the menu item's action listener is called to exit the application.
<H2><A NAME="UsingShortcutsHotKeys">
Using Shortcuts (Hot Keys)</A></H2>
<P>
JFC provides a very flexible environment for implementing shortcuts.
Unlike mnemonics and accelerators, shortcuts are not associated
with a particular user interface control like a button or menu.
Instead, shortcuts directly associate a keystroke combination
with an action. The shortcut action can be any <TT>ActionListener</TT>
object.<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JMenu</TT> class implements accelerators by using a shortcut to associate a keystroke combination with the menu's action listener.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="TheTTFONTSIZEJComponentregisterKeyboardActionFONTTTFONTSIZEMethodFONT">
The <TT>JComponent.registerKeyboardAction</TT>
Method</A></H3>
<P>
You can associate shortcuts with any <TT>JComponent</TT> object
by calling the <TT>registerKeyboardAction</TT> method.
<BLOCKQUOTE>
<PRE>
public void registerKeyboardAction(ActionListener action, 
                                   KeyStroke keystroke,
                                   int condition);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>action</TT> parameter specifies the action listener whose
<TT>actionPerformed</TT> method will be called when the shortcut
is executed. The <TT>keystroke</TT> parameter specifies the keystroke
that will trigger the shortcut. The keystroke is specified by
use of a <TT>KeyStroke</TT> object (see the section on the <TT>KeyStroke</TT>
class earlier in this chapter). The <TT>condition</TT> parameter
specifies the focus conditions under which the shortcut will be
triggered.
<P>
<TT>JComponent</TT> also provides the <TT>unregisterKeyboardAction</TT>
and <TT>resetKeyboardActions</TT> methods to unregister shortcuts.
<TT>unregisterKeyboardAction</TT> will unregister one specific
shortcut and <TT>resetKeyboardActions</TT> will unregister all
shortcuts registered for a component.
<H4>Focus Conditions for Shortcuts</H4>
<P>
The reason that the <TT>registerKeyboardAction</TT> method is
a <TT>JComponent</TT> method is because shortcuts are controlled
by the focus condition of the associated component. You must specify
one (and only one) of the following <TT>JComponent</TT>-based
constants to specify a focus condition when registering shortcuts:
<UL>
<LI><TT>WHEN_FOCUSED&nbsp;&nbsp;</TT>To indicate that the action
be invoked when the specified keystroke is received while the
component has the focus
<LI><TT>WHEN_IN_FOCUSED_WINDOW&nbsp;&nbsp;</TT>To indicate that
the action be invoked when the specified keystroke is received
while any component in the component's window hierarchy has the
focus
<LI><TT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&nbsp;&nbsp;</TT>To
indicate that the action be invoked when the specified keystroke
is received when the component has the focus or an ancestor of
the component has the focus
</UL>
<P>
Being able to specify a combination of a keystroke and a focus
condition for a shortcut allows you to bind arbitrary key combinations
to the appropriate component action in a hierarchical structure
of components.<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
It's not allowable to have the same keystroke registered under multiple focus conditions. When you register a keystroke that is already registered as a shortcut, you replace the original shortcut with a new shortcut.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="MoreTTFONTSIZEJComponentFONTTTFONTSIZEShortcutMethodsFONT">
More <TT>JComponent</TT>
Shortcut Methods</A></H3>
<P>
The <TT>JComponent</TT> class has several methods that are useful
for working with shortcuts in addition to the methods discussed
earlier for registering and unregistering shortcuts:
<BLOCKQUOTE>
<PRE>
public KeyStroke[] getRegisteredKeyStrokes();
public int getConditionForKeyStroke(KeyStroke keystroke);
public ActionListener getActionForKeyStroke(KeyStroke keystroke);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>getActionForKeyStroke</TT> method returns the object that
will perform the action registered for a given shortcut (registered
keystroke). 
<P>
The <TT>getRegisteredKeyStrokes</TT> method returns an array of
all registered shortcuts. 
<P>
The <TT>getConditionForKeyStroke</TT> method returns the focus
condition associated with a given shortcut.
<H3><A NAME="ASimpleExampleUsingaShortcut">
A Simple Example Using a Shortcut</A></H3>
<P>
Listing 29.3 is the complete source for <TT>BasicShortcutDemo</TT>,
an application illustrating the implementation of a keyboard shortcut.
Figure 29.3 shows the output of this code.
<P>
<A HREF="javascript:popUp('f29-3.gif')"><B>Figure 29.3 :</B> <I>BasicShortcutDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 29.3&nbsp;&nbsp;</B><TT><B>BASICSHORTCUTDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* BasicShortcutDemo.java
 *
 * A basic JCF application with a Ctrl+Q keyboard shortcut.
 *
 * Illustrates how to create a KeyStroke object and
 * use the registerKeyboardAction method to register
 * the keystroke as a keyboard shortcut.
 */

import java.awt.event.*;
import javax.swing.*;


/* Application class
 */
public class BasicShortcutDemo extends JPanel { 

    // App constructor
    public BasicShortcutDemo() { 
        // Add some text to the app panel
        add(new JLabel(&quot;Press Ctrl+Q to quit.&quot;));

        // Create an action listener for registered keystrokes
        ActionListener actionQuit = new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                System.exit(0);
            } 
        } ;

        // Create a keystroke and register it as a shortcut
        KeyStroke keyStrokeQuit 
  = KeyStroke.getKeyStroke(KeyEvent.VK_Q, InputEvent.CTRL_MASK);
        registerKeyboardAction(actionQuit, keyStrokeQuit,
                               JComponent.WHEN_IN_FOCUSED_WINDOW);
    } 

    // The main entry point
    public static void main(String s[]) { 
        // Create an instance of the app
        BasicShortcutDemo appPanel = new BasicShortcutDemo();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;BasicShortcutDemo&quot;);

        // Add a window listener for close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content frame
        frame.getContentPane().add(appPanel);

        // Make frame visible, set initial size
        frame.setVisible(true);
        frame.setSize(200, 100);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEBasicShortcutDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>BasicShortcutDemo</TT>
Example</A></H3>
<P>
The <TT>BasicShortcutDemo</TT> example consists of a single class,
<TT>BasicShortcutDemo</TT>, that extends <TT>JPanel</TT>. The
constructor creates a label to display the text &quot;Press Ctrl+Q
to quit.&quot; It then creates an action listener for the shortcut,
which is implemented in an inner class.
<BLOCKQUOTE>
<PRE>
// Create an action for registered keystrokes
ActionListener actionQuit = new ActionListener() { 
    public void actionPerformed(ActionEvent e) { 
        System.exit(0);
    } 
} ;
</PRE>
</BLOCKQUOTE>
<P>
The action listener's <TT>actionPerformed</TT> method exits the
application by calling <TT>System.exit</TT>.
<P>
After creating the action listener, the constructor creates a
<TT>KeyStroke</TT> object and registers it as a keyboard action
associated with the <TT>actionQuit</TT> action listener.
<BLOCKQUOTE>
<PRE>
// Create a keystroke and register it as a shortcut
KeyStroke keyStrokeQuit = KeyStroke.getKeyStroke(KeyEvent.VK_Q,
                                                 InputEvent.CTRL_MASK);
registerKeyboardAction(actionQuit, keyStrokeQuit,
                       JComponent.WHEN_IN_FOCUSED_WINDOW);
</PRE>
</BLOCKQUOTE>
<P>
This code registers the Ctrl+Q keystroke as a keyboard action
that is valid whenever the <TT>BasicShortcutDemo</TT> panel is
in a window with the focus; that is, whenever the application
has the focus.
<H2><A NAME="KeyboardNavigationwithTTFONTSIZEActionFONTTTFONTSIZEObjectsFONT">
Keyboard Navigation with <TT>Action</TT>
Objects</A></H2>
<P>
JFC allows you to add <TT>Action</TT> objects directly to menus
and toolbars without having to create a menu item or button object.
When you use this approach, JFC creates the menu item or button
and associates it with the given action. This can be a powerful
feature to use if you're designing a user interface that maps
actions to more than one control because it allows you to centralize
control of the interface in the code for the action object. When
you disable an action by calling its <TT>setEnabled</TT> method,
JFC will automatically change the state of the corresponding interface
controls (buttons and menus) to be disabled.
<P>
<TT>AbstractButton</TT> does not use properties to implement mnemonics
and accelerators, so you can't use the <TT>Action.putValue</TT>
method to set these values. Instead, you take the objects returned
from the <TT>add</TT> method you use to add the action to a container.
The <TT>JToolbar.add</TT> method returns an object of type <TT>JButton</TT>,
and the <TT>JMenu.add</TT> method returns an object of type <TT>JMenuItem</TT>.
You can then call the <TT>setMnemonic</TT> and <TT>setAccelerator</TT>
methods, as you would if you explicitly created the button or
menu item.
<H3><A NAME="ExampleUsingKeyNavigationwithActionObject">
Example Using Key Navigation with Action Object</A></H3>
<P>
Listing 29.4 is the complete source for <TT>KeyNavigationDemo</TT>,
an example that creates a keyboard-navigable button and menu item
from an <TT>Action</TT> object. Figure 29.4 shows the output of
this code.
<P>
<A HREF="javascript:popUp('f29-4.gif')"><B>Figure 29.4 :</B><I>KeyNavigationDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 29.4&nbsp;&nbsp;</B><TT><B>KEYNAVIGATIONDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* KeyNavigationDemo.java
 *
 * Illustrates how to set mnemonics and
 * key accelerators when implementing buttons
 * and menu items using Action objects.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/* Application class
 */
public class KeyNavigationDemo extends JPanel { 

    // Constructor
    public KeyNavigationDemo() { 
        setLayout(new BorderLayout());
        
        // create action for exit command
        AbstractAction actionExit = new AbstractAction() { 
            public void actionPerformed(ActionEvent e) { 
                System.exit(0);
            } 
        } ;
        actionExit.putValue(Action.NAME, &quot;Exit&quot;);
                
        // create a non-floatable toolbar
        JToolBar toolbar = new JToolBar();
        toolbar.setFloatable(false);

        // add action to toolbar, set mnemonic for returned button
        JButton buttonExit = toolbar.add(actionExit);
        buttonExit.setMnemonic(KeyEvent.VK_X);

        // create a menu bar with a File menu
        JMenuBar menubar = new JMenuBar();
        JMenu menuFile = new JMenu(&quot;File&quot;);
        menuFile.setMnemonic(KeyEvent.VK_F);
        menubar.add(menuFile);

        // add action to menu, set mnemonic and 
        // accelerator for returned menu item
        JMenuItem itemExit = menuFile.add(actionExit);
        itemExit.setMnemonic(KeyEvent.VK_X);
        itemExit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, 
                                                       Event.CTRL_MASK));
        
        // add toolbar and menu bar to panel
        add(toolbar, BorderLayout.SOUTH);
        add(menubar, BorderLayout.NORTH);
    } 
    
    // The main entry point
    public static void main(String s[]) { 
        // create an instance of the app
        KeyNavigationDemo appPanel = new KeyNavigationDemo();

        // create a frame for app
        JFrame frame = new JFrame(&quot;KeyNavigationDemo&quot;);

        // add a window listener for close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content frame
        frame.getContentPane().add(appPanel);

        // make frame visible, set initial size
        frame.setVisible(true);
        frame.setSize(200, 150);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEKeyNavigationDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>KeyNavigationDemo</TT>
Example</A></H3>
<P>
Visually and functionally, the <TT>KeyNavigationDemo</TT> example
is identical to the <TT>BasicShortcutDemo</TT> example. The difference
is in the implementation-the <TT>KeyNavigationDemo</TT> example
creates its button and menu item from an <TT>Action</TT> object.
The <TT>KeyNavigation</TT> example uses a single class, <TT>KeyNavigationDemo</TT>,
that extends <TT>JPanel</TT>. The constructor for this class creates
an instance of an <TT>AbstractAction</TT> object whose <TT>actionPerformed</TT>
method calls <TT>System.exit</TT> to exit the application. One
difference in this example is that it uses an <TT>AbstractAction</TT>
object rather than an <TT>ActionListener</TT> object to represent
the exit action. After creating the action, you then call the
<TT>putValue</TT> method to set the name property of the action.
This property determines the text that will appear on the button
or menu item when the action is added to a toolbar or menu.
<BLOCKQUOTE>
<PRE>
// create action for exit command
AbstractAction actionExit = new AbstractAction() { 
    public void actionPerformed(ActionEvent e) { 
        System.exit(0);
    } 
} ;
actionExit.putValue(Action.NAME, &quot;Exit&quot;);
</PRE>
</BLOCKQUOTE>
<P>
After creating a toolbar, the constructor adds the exit action
to it and sets the mnemonic on the returned button object. The
following code fragment shows how the action is added to the toolbar
and how a mnemonic is set on the returned button object.
<BLOCKQUOTE>
<PRE>
// add action to toolbar, set mnemonic for returned button
JButton buttonExit = toolbar.add(actionExit);
buttonExit.setMnemonic(KeyEvent.VK_X);
</PRE>
</BLOCKQUOTE>
<P>
The constructor then creates a menu bar and adds a &quot;File&quot;
menu to it. After adding the exit action to the menu, the code
goes on to set a mnemonic and accelerator for the returned menu
item. The following fragment shows how the action is added to
the menu, and how the mnemonic and accelerator are set on the
returned menu item object.
<BLOCKQUOTE>
<PRE>
// add action to menu, set mnemonic and accelerator for returned menu item
JMenuItem itemExit = menuFile.add(actionExit);
itemExit.setMnemonic(KeyEvent.VK_X);
itemExit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, 
                                               Event.CTRL_MASK));
</PRE>
</BLOCKQUOTE>
<P>
The result is an application with a single &quot;Exit&quot; button
in a toolbar and a &quot;File&quot; menu with an &quot;Exit&quot;
menu item. The mnemonic is Alt+Q for both the button and menu
item. The menu item also has an accelerator, Ctrl+Q.
<P>
Creating user interface controls from action objects is a powerful
and efficient way to construct both simple and complex user interfaces.
For more information on using this technique, see <A HREF="..\ch04\ch04.htm" >Chapter 4</A> &quot;JFC
Programming Techniques.&quot;
<H2><A NAME="UsingMnemonicswithLabels">
Using Mnemonics with Labels</A></H2>
<P>
The <TT>JLabel</TT> component allows you to display a mnemonic
and associate it with another component. This technique can be
useful if you have some graphical user-interface components that
do not display any textual information. Labels are static controls
and do not normally respond to user input. However, if you associate
a label with a component and specify a mnemonic for the label,
pressing the mnemonic key combination will transfer the focus
to the associated component.
<P>
The following are the <TT>JLabel</TT> methods for working with
mnemonics.:
<BLOCKQUOTE>
<PRE>
void setDisplayedMnemonic(char character);
void setDisplayedMnemonic(int keycode);
int getDisplayedMnemonic();
void setLabelFor(Component component);
Component getLabelFor();
</PRE>
</BLOCKQUOTE>
<P>
Like buttons and menus, label objects provide two methods that
allow you to set a mnemonic by specifying the mnemonic as a character
or a virtual key code. However, the names of the methods are different
for labels. For buttons and menus, the methods to <TT>set</TT>
and <TT>get</TT> mnemonics are <TT>setMnemonic</TT> and <TT>getMnemonic</TT>.
For labels, the methods are <TT>setDisplayedMnemonic</TT> and
<TT>getDisplayedMnemonic</TT>.
<P>
To use a mnemonic with a label, you must associate the label with
a component by using the <TT>setLabelFor</TT> method. The associated
component will get the focus whenever the mnemonic key combination
is pressed.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
An essential part of good user interface design is providing the
ability for users to navigate and operate an application with
a keyboard as well as a mouse. Swing components provide three
types of keyboard navigation: accelerators, mnemonics, and shortcuts.
These keyboard navigation devices are all similar in effect-they
allow you to associate a keystroke with a component (or in the
case of shortcuts, an action). Depending on the type of component
and the current look-and-feel for the application, the associated
keystroke will change the focus to the component and/or cause
an action to be executed. The use of these keyboard navigation
devices is illustrated with three examples: <TT>BasicAcceleratorDemo</TT>,
<TT>BasicMnemonicDemo</TT>, and <TT>BasicShortcutDemo</TT>.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch28\ch28.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch30\ch30.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
