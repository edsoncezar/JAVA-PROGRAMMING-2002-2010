<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 9 - Menus and Toolbars</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch08\ch08.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch10\ch10.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;9<br>
Menus and Toolbars</H1>
<HR>
<p>

<UL>
<LI><A HREF="#CreatingMenus">
Creating Menus</A>
<UL>
<LI><A HREF="#ManipulatingItemsinMenus">
Manipulating Items in Menus</A>
<LI><A HREF="#TTFONTSIZEJMenuItemFONTTTFONTSIZEEventsFONT">
<TT>JMenuItem</TT> Events
</A>
<LI><A HREF="#TTFONTSIZEJMenuFONTTTFONTSIZEEventsFONT">
<TT>JMenu</TT> Events
</A>
</UL>
<LI><A HREF="#TypesofMenuItems">
Types of Menu Items</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEJMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JMenuItem</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEJMenuFONTTTFONTSIZEClassFONT">
The <TT>JMenu</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEJCheckBoxMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JCheckBoxMenuItem</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEJRadioButtonMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JRadioButtonMenuItem</TT>
Class</A>
</UL>
<LI><A HREF="#PlacingMenus">
Placing Menus</A>
<UL>
<LI><A HREF="#FrameMenus">
Frame Menus</A>
<LI><A HREF="#PopupMenus">
Pop-up Menus</A>
<LI><A HREF="#TheTTFONTSIZEMenuElementFONTTTFONTSIZEInterfaceFONT">
The <TT>MenuElement</TT>
Interface</A>
</UL>
<LI><A HREF="#CreatingToolbars">
Creating Toolbars</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Menus and toolbars have become an integral tool for launching
operations in modern graphical user interfaces. Menus typically
contain the full suite of operations supported by the application.
Context sensitive pop-up menus are often available over various
areas of the application.
<P>
Toolbars, also known as buttonbars, often contain only commonly
used operations. Each operation is represented by an image on
a button. However, many applications now support multiple toolbars,
each containing related operations. These can be shown and hidden
by the user as required.
<P>
JFC menus and toolbars are <TT>Action</TT>-aware components. This
allows <TT>Action</TT> instances to be added directly to these
components.
<P>
In this chapter, the JFC components for implementing menus and
toolbars are presented. You will learn
<UL>
<LI>How to create menus
<LI>How to add a menubar to a frame
<LI>How to create pop-up menus
<LI>How to create toolbars
</UL>
<H2><A NAME="CreatingMenus">
Creating Menus</A></H2>
<P>
The JFC provides components for creating menus that can be attached
to a frame or used in a pop-up menu. The implementation of a menu
is contained in the <TT>JMenu</TT> class. Instances of the <TT>JMenu</TT>
class contain instances of <TT>JMenuItem</TT>s. A menu item can
be textual, it can contain an image, and it can be a radio or
toggle button. Cascading menus are implemented by a menu containing
another instance of the <TT>JMenu</TT> class. The cascading effect
can be nested to any level desired.
<H3><A NAME="ManipulatingItemsinMenus">
Manipulating Items in Menus</A></H3>
<P>
A simple menu can be implemented by creating a <TT>JMenu</TT>
instance and adding items to the menu. This technique is shown
in the application that follows. The menu is created with the
<TT>createMenu</TT> method that returns a <TT>JMenuBar</TT> instance.
In this simple example, a single <TT>JMenu</TT> named <TT>File</TT>
is created. The menu items are added to the menu. For a more complex
menu, multiple <TT>JMenu</TT> instances can be added to the menubar.
You will see examples of this later in the chapter. In the <TT>frameInit</TT>
method, the menubar is added to the frame. Adding menus to a frame
and using pop-up menus are discussed later in this chapter. The
menu resulting from the following code is shown in Figure 9.1
after it has been added to a <TT>JFrame</TT> instance. The <TT>JFrame</TT>
class was presented in the previous chapter.
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.event.*;
import java.util.*;
import javax.swing.*;

import com.foley.utility.*;

/**
 * An application that creates a menu in a frame.
 *
 * @author Mike Foley
 **/
public class MenuTest extends JFrame { 

    public static MenuTest frame;


    /**
     * MenuTest, null constructor.
     **/
    public MenuTest() { 
        this( null );
    }  // MenuTest


    /**
     * MenuTest, constructor.
     *
     * @param title The title for the frame.
     **/
    public MenuTest( String title ) { 
        super( title );
    }  // MenuTest


    /**
     * frameInit, from JFrame
     *
     * Create the contrent for this frame.
     **/
    protected void frameInit() { 
        
        //
        // Let our super create the content and associated panes.
        //
        super.frameInit();
                
        JMenuBar menubar = createMenu();
        setJMenuBar( menubar );

    }  // frameInit


    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        JMenuBar menubar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.add( &quot;New&quot; );
        file.add( &quot;Open...&quot; );
        file.add( &quot;Close&quot; );
        file.addSeparator();
        file.add( &quot;Save&quot; );
        file.add( &quot;Save As...&quot; );
        file.addSeparator();
        file.add( &quot;Exit&quot; );

        menubar.add( file );
        
        return( menubar );

    }  // createMenu
       
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new MenuTest( &quot;Menu Test&quot; );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // MenuTest
</PRE>
</BLOCKQUOTE>
<P>
This menu uses a convenience version of the <TT>add</TT> method.
The items in the menu are created in the <TT>add</TT> method and
given the name of the <TT>String</TT> instance passed as the parameter.
The <TT>addSeparator</TT> method is used to add an instance of
the <TT>JSeparator</TT> class to the menu. The <TT>add</TT> and
<TT>addSeparator</TT> methods append the new item to the end of
the menu items contained in the menu.
<P>
<A HREF="javascript:popUp('f9-1.gif')"><B>Figure 9.1 :</B> <I>File menu attached to a JFrame</I>.</A>
<P>
It is often convenient to create the <TT>JMenuItem</TT> and add
the instance to the menu. This way, the code creating the menu
has a handle to the item, allowing easy manipulation of the item.
The <TT>JMenuItem</TT> class inherits from the <TT>AbstractButton</TT>
class. As such, it will generate the same events as other buttons.
Button events were discussed in <A HREF="..\ch06\ch06.htm" >Chapter 6</A> &quot;The Button Hierarchy.&quot;
A typical technique for adding functionality to a menu is to add
an <TT>ActionListener</TT> to each item in the menu. This is shown
in the following modified version of the <TT>createMenu</TT> method:
<BLOCKQUOTE>
<PRE>
    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        JMenuBar menubar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.add( &quot;New&quot; );
        file.add( &quot;Open...&quot; );
        file.add( &quot;Close&quot; );
        file.addSeparator();
        file.add( &quot;Save&quot; );
        file.add( &quot;Save As...&quot; );
        file.addSeparator();
        
        //
        // Create the menuitem ourself, and add
        // an ActionListener.
        //
        JMenuItem item = new JMenuItem( &quot;Exit&quot; );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );
        
        menubar.add( file );
        
        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<P>
In this example, the <TT>JMenuItem</TT> for the Exit menu item
is explicitly created. The menu item can also be created with
an icon. Since the menu item is an extension of the <TT>AbstractButton</TT>
class, it can contain a string, an icon, or both. With the handle
of the <TT>JMenuItem</TT>, an <TT>ActionListener</TT> can be added
to the item. When the menu item is selected, the <TT>actionPerformed</TT>
method will be called. The item is added to the menu by using
the version of the <TT>add</TT> method in the <TT>JMenu</TT> class
that takes a <TT>JMenuItem</TT> instance as its parameter. As
with the previous version of the <TT>add</TT> method, the new
item is appended to the list of items in the menu.
<P>
There is also a version of the <TT>add</TT> method in the <TT>JMenu</TT>
class that takes a <TT>Component</TT> as its parameter. This allows
any <TT>Component</TT> instance to be added to a menu. For example,
the following version of the <TT>createMenu</TT> method creates
another <TT>JMenu</TT> and adds an instance of the <TT>JComboBox</TT>
class to the menu. The second menu is also added to the menubar,
creating a menu with two items on the frame. The resulting menu
is shown in Figure 9.2. Listeners could be added to the <TT>JComboBox</TT>
instance to receive events when items in the combo box are selected.
<BLOCKQUOTE>
<PRE>
/**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        JMenuBar menubar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.add( &quot;New&quot; );
        file.add( &quot;Open...&quot; );
        file.add( &quot;Close&quot; );
        file.addSeparator();
        file.add( &quot;Save&quot; );
        file.add( &quot;Save As...&quot; );
        file.addSeparator();
        
        //
        // Create the menuitem ourself, and add
        // an ActionListener.
        //
        JMenuItem item = new JMenuItem( &quot;Exit&quot; );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );
        
        menubar.add( file );
        
        //
        // Add a JComboBox to the menu.
        //
        JMenu combo = new JMenu( &quot;ComboBox&quot; );
        Vector data = new Vector();
        data.addElement( &quot;Apple&quot; );
        data.addElement( &quot;Grape&quot; );
        data.addElement( &quot;Orange&quot; );
        JComboBox comboBox = new JComboBox( data );
        combo.add( comboBox );
        
        menubar.add( combo );
        
        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f9-2.gif')"><B>Figure 9.2 :</B> <I>Menubar with a JComboBox instance</I>.</A>
<P>
The <TT>JMenu</TT> class is <TT>Action</TT> aware. This allows
<TT>Action</TT> instances to be added to a menu by using the version
of the <TT>add</TT> method that takes an <TT>Action</TT> as its
parameter. The <TT>JMenu</TT> class obtains the name and small
icon from the <TT>Action</TT> instance and uses these to construct
a <TT>JMenuItem</TT>. The <TT>Action</TT> is added as an <TT>ActionListener</TT>
of the menu item. This ensures that the <TT>Action</TT> is called
when the menu item is selected. A private <TT>PropertyChangeListener</TT>
in the <TT>JMenu</TT> instance is added to the <TT>Action</TT>.
This listener is notified of changes to the <TT>Action</TT>. If
the <TT>Action</TT>'s name or small icon changes, the <TT>PropertyChangeListener</TT>
will update the menu item to the new values. Also, if the enabled
status of the <TT>Action</TT> changes, the enabled status of the
menu item will update to reflect the current enabled state of
the <TT>Action</TT>. Finally, the menu item is added to the menu.
<P>
As an example of using an <TT>Action</TT> instance in a menu,
an <TT>ExitAction</TT> is created and added to a menu. The <TT>ExitAction</TT>
class was presented in <A HREF="..\ch04\ch04.htm" >Chapter 4</A> &quot;JFC Programming Techniques.&quot;
The modified <TT>createMenu</TT> method is shown in the following
code. The combo box from the previous section was omitted from
this example. In this version of the <TT>createMenu</TT> method,
the explicit creation of the menu item and adding the <TT>ActionListener</TT>
are not required. This work is performed in the <TT>JMenu</TT>
class when the <TT>Action</TT> instance is added to the menu.
<BLOCKQUOTE>
<PRE>
    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        JMenuBar menubar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.add( &quot;New&quot; );
        file.add( &quot;Open...&quot; );
        file.add( &quot;Close&quot; );
        file.addSeparator();
        file.add( &quot;Save&quot; );
        file.add( &quot;Save As...&quot; );
        file.addSeparator();
        
        //
        // Add an Action to the menu.
        //
        file.add( new ExitAction() );
        
        menubar.add( file );

        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<P>
An instance of the <TT>ExitAction</TT> is added to a menu using
the <TT>add</TT> method of the <TT>JMenu</TT> class. The line
of code to add the <TT>Action</TT> is shown next. Figure 9.3 shows
the <TT>ExitAction</TT> on the menu. Notice how the name and icon
associated with the <TT>Action</TT> are placed on the menu without
intervention from the calling code. The <TT>actionPerformed</TT>
method in the <TT>ExitAction</TT> instance is called when the
menu item is chosen. This of course will exit the application.
When applications are designed by using <TT>Action</TT>s to encapsulate
application behavior, creating menus is very simple.
<P>
<TT>file.add( new ExitAction() );</TT>
<P>
<A HREF="javascript:popUp('f9-3.gif')"><B>Figure 9.3 :</B> <I>ExitAction in the File menu</I>.</A>
<P>
The various overloaded versions of the <TT>add</TT> method work
nicely when creating menus. The items in the menu are appended
to the existing items in the menu. Thus the items are displayed
in the order they are added to the menu. The <TT>JMenu</TT> class
provides other methods to manipulate items in the menu. As data
in an application changes state, menu items may need to be added
or removed from an application's menu system. To provide this
functionality, overloaded <TT>insert</TT> and <TT>remove</TT>
methods are provided. There are versions of the <TT>insert</TT>
method that correspond to the <TT>add</TT> methods allowing <TT>String</TT>,
<TT>Action</TT>, and <TT>JMenuItem</TT> instances to be passed
as parameters.
<P>
Each of the <TT>insert</TT> methods takes an integer offset as
its second parameter. This specifies the position in the menu
where the new item is to be inserted. The existing menu items
are numbered from zero. For the File menu shown in the examples
so far in this chapter, the item list in the menu looks like that
shown in Figure 9.4. After the following lines of code are executed
to insert the Print menu items, the menu looks as shown in Figure
9.5. This example uses the convenience method <TT>insertSeparator</TT>
to insert a <TT>JSeparator</TT> into the menu after the printing-related
items.
<BLOCKQUOTE>
<PRE>
file.insert( &quot;Print Setup...&quot;, 7 );
file.insert( new PrintAction(), 8 );
file.insertSeparator( 9 );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f9-4.gif')"><B>Figure 9.4 :</B> <I>Inserting a menu item</I>.</A>
<P>
<A HREF="javascript:popUp('f9-5.gif')"><B>Figure 9.5 :</B> <I>Print menu item inserted</I>.</A>
<P>
If a negative position is passed to any of the insert methods,
an IllegalArgumentException is thrown. On the other hand, if an
index greater than the number of items in the menu is specified,
the item to be inserted is placed at the end of the items in the
list. In this case, the insert method behaves similarly to the
add method.
<P>
Menu items can be removed by index or by specifying the <TT>JMenuItem</TT>
instance to be removed from the menu. The <TT>JMenu</TT> class
provides the <TT>removeAll</TT> method to clear all items from
the menu. To remove the Save operation-related menu items from
the previous examples, the following lines of code could be executed:
<BLOCKQUOTE>
<PRE>
file.remove( saveMenuItem );
file.remove( 4 );
file.remove( 4 );
</PRE>
</BLOCKQUOTE>
<P>
The first <TT>remove</TT> call takes a reference to the Save menu
item as a parameter. This causes the Save menu item, located at
position four, to be removed from the menu. The other items in
the list slide down so there is not a gap in the item list after
an item has been removed from the menu. The menu item order before
and after this menu item has been removed is shown in Figure 9.6.
The next call removes the item at position four. This is now the
Save As&#133; menu item. Once again, the remaining menu items
slide down to fill in the gap left by the removed menu item. The
last call once again removes the menu item at position four, which
is now a separator.
<P>
<A HREF="javascript:popUp('f9-6.gif')"><B>Figure 9.6 :</B> <I>Save menu item removed</I>.</A>
<P>
Similar to the insert method, when a negative index is passed
to any of the remove methods, an IllegalArgumentException is thrown.
However, unlike the insert methods, when an index greater than
the number of items in the menu is passed to a remove method,
an ArrayIndexOutOfBoundsException is thrown. This exception seems
to be more of a bug than a feature. I would expect that proper
error handling for such an index should result in an IllegalArgumentException
being thrown.
<H3><A NAME="TTFONTSIZEJMenuItemFONTTTFONTSIZEEventsFONT">
<TT>JMenuItem</TT> Events
</A></H3>
<P>
The <TT>JMenuItem</TT> class is a descendant of the <TT>AbstractButton</TT>
class described in <A HREF="..\ch06\ch06.htm" >Chapter 6</A> Instances of the <TT>JMenuItem</TT>
class fire the events defined for that class, as well as events
from its ancestors. Among these are <TT>ChangeEvent</TT>, <TT>ItemEvent</TT>,
and <TT>ActionEvent</TT> defined for buttons. The <TT>JMenuItem</TT>
class also fires <TT>MenuKeyEvent</TT> and <TT>MenuDragMouseEvent</TT>
instances. A <TT>MenuKeyEvent</TT> is fired when a keystroke has
been received by the menu item. The <TT>MenuKeyEvent</TT> class
extends the <TT>java.awt.event.KeyEvent</TT> class. The path of
the menu item in the menu hierarchy is delivered with the event.
<BLOCKQUOTE>
<PRE>
public class MenuKeyEvent extends KeyEvent { 
    private MenuElement path[];
    private MenuSelectionManager manager;

    public MenuKeyEvent(Component source, int id, long when, 
                       int modifiers, int keyCode, char keyChar,
                       MenuElement p[], MenuSelectionManager m) { 
        super(source, id, when, modifiers, keyCode, keyChar);
        path = p;
        manager = m;
    } 

    public MenuElement[] getPath() { 
        return path;
    } 

    public MenuSelectionManager getMenuSelectionManager() { 
       return manager;
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
A <TT>MenuKeyEvent</TT> is delivered in each of the three methods
defined in the <TT>MenuKeyListener</TT> interface, shown next.
A <TT>MenuKeyListener</TT> is called when a key is pressed and
released in a menu. The <TT>menuKeyTyped</TT> method is called
after a key press and release in the menu. A <TT>MenuKeyListener</TT>
is added to a <TT>JMenuItem</TT> by calling the <TT>addMenuKeyListener</TT>
method. It can be removed with the <TT>removeMenuKeyListener</TT>
method.
<BLOCKQUOTE>
<PRE>
public interface MenuKeyListener extends EventListener { 
    /**
     * Invoked when a key has been typed.
     * This event occurs when a key press is followed by a key release.
     */
    void menuKeyTyped(MenuKeyEvent e);

    /**
     * Invoked when a key has been pressed.
     */
    void menuKeyPressed(MenuKeyEvent e);

    /**
     * Invoked when a key has been released.
     */
    void menuKeyReleased(MenuKeyEvent e);
}
</PRE>
</BLOCKQUOTE>
<P>
When the mouse is dragged over a <TT>JMenuItem</TT> instance,
it fires <TT>MenuDragMouseEvent</TT> events to registered listeners.
The <TT>MenuDrawMouseEvent</TT> class is shown next. The <TT>MenuDrawMouseEvent</TT>
class extends the <TT>java.awt.event.MouseEvent</TT> class. As
such, it delivers with it the standard mouse event information
such as mouse coordinates and click count. Similarly to the <TT>MenuKeyEvent</TT>,
the path to the menu item where the event occurred is delivered
with the event.
<BLOCKQUOTE>
<PRE>
public class MenuDragMouseEvent extends MouseEvent { 
    private MenuElement path[];
    private MenuSelectionManager manager;

    public MenuDragMouseEvent(Component source, int id, long when,
                             int modifiers, int x, int y, int clickCount,
                             boolean popupTrigger, MenuElement p[],
                             MenuSelectionManager m) { 
        super( source, id, when, modifiers, x, y, 
               clickCount, popupTrigger );
        path = p;
        manager = m;
    } 

    public MenuElement[] getPath() { 
        return path;
    }

    public MenuSelectionManager getMenuSelectionManager() { 
       return manager;
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
A <TT>MenuDragMouseEvent</TT> instance is delivered to <TT>MenuDragMouseListener</TT>
in one of the four methods contained in the <TT>MenuDragMouseListener</TT>
interface shown next. The names of the methods describe which
mouse gesture causes the corresponding method to be called. The
<TT>addMenuDragMouseListener</TT> method is called to add a <TT>MenuDragMouseListener</TT>
to a menu item, and the <TT>removeMenuDragMouseListener</TT> will
remove the listener from the menu item.
<BLOCKQUOTE>
<PRE>
public interface MenuDragMouseListener extends EventListener { 
    void menuDragMouseEntered(MenuDragMouseEvent e);
    void menuDragMouseExited(MenuDragMouseEvent e);
    void menuDragMouseDragged(MenuDragMouseEvent e);
    void menuDragMouseReleased(MenuDragMouseEvent e);
}<BR>
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TTFONTSIZEJMenuFONTTTFONTSIZEEventsFONT">
<TT>JMenu</TT> Events
</A></H3>
<P>
The <TT>JMenu</TT> class extends the <TT>JMenuItem</TT> class.
Instances of the <TT>JMenu</TT> class fire the events defined
for that class, as well as events from its ancestors. Among these
are <TT>ChangeEvent</TT>, <TT>ItemEvent</TT>, <TT>ActionEvent</TT>
(described for buttons in <A HREF="..\ch06\ch06.htm" >Chapter 6</A>, and the <TT>MenuKeyEvent</TT>
and <TT>MenuDragMouseEvent</TT> shown in the previous section.
The <TT>JMenu</TT> class also defines the <TT>MenuEvent</TT> that
is delivered to <TT>MenuListener</TT>s in one of the methods defined
in the <TT>MenuListener</TT> interface. The <TT>MenuEvent</TT>
is shown in the following code listing. As seen in this listing,
unlike the events fired from the <TT>JMenuItem</TT> class, the
<TT>MenuEvent</TT> doesn't deliver additional information from
the standard <TT>java.util.EventObject</TT>. Thus, the only information
delivered by the <TT>MenuEvent</TT> is the source of the event.
<BLOCKQUOTE>
<PRE>
public class MenuEvent extends EventObject { 
    public MenuEvent(Object source) { 
        super(source);
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
<TT>MenuEvent</TT>s can be delivered to one of the three methods
defined in the <TT>MenuListener</TT> interface. These methods
are shown in the following code. The <TT>menuSelected</TT> method
is called when a menu is shown. This method provides a hook allowing
the listener to customize the menu before it is displayed. The
<TT>menuDeselected</TT> method is called when the menu is hidden.
The current implementation of the JFC does not use the <TT>menuCanceled</TT>
method.
<BLOCKQUOTE>
<PRE>
public interface MenuListener extends EventListener { 
    void menuSelected(MenuEvent e);
    void menuDeselected(MenuEvent e);
    void menuCanceled(MenuEvent e);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>addMenuListener</TT> and <TT>removeMenuListener</TT> methods
are used to add and remove a <TT>MenuListener</TT> from an instance
of the <TT>JMenu</TT> class.
<H2><A NAME="TypesofMenuItems">
Types of Menu Items</A></H2>
<P>
The examples in the previous section showed <TT>JMenu</TT> instances
that contained instances of the <TT>JMenuItem</TT> class. <TT>JMenuItem</TT>
instances may be the most common items added to menus, but they
are not the only choice. The JFC contains three classes that extend
<TT>JMenuItem</TT> and are designed to be used in menus. These
are the <TT>JCheckBoxMenuItem</TT> and <TT>JRadioButtonMenuItem</TT>
classes, as well as the <TT>JMenu</TT> class itself. These classes,
as well as an in-depth discussion of the <TT>JMenuItem</TT> class,
are presented in this section.
<H3><A NAME="TheTTFONTSIZEJMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JMenuItem</TT> Class
</A></H3>
<P>
As was seen in the previous section, instances of the <TT>JMenu</TT>
class often create <TT>JMenuItem</TT> instances to add to the
menu. However, the code constructing the menu can create the <TT>JMenuItem</TT>
itself and add the instance to the menu. The primary reason for
doing this is to have a reference to the <TT>JMenuItem</TT> instance.
The instance can then be customized or have event listeners added
to it. It should be noted that the <TT>add</TT> method returns
the <TT>JMenuItem</TT> instance added to the menu when a <TT>JMenuItem</TT>
or <TT>Action</TT> is passed as a parameter. However, when a <TT>String</TT>
is passed as a parameter, the <TT>JMenuItem</TT> is not returned
from the <TT>add</TT> method. The reason for this difference is
to mimic the API from the AWT <TT>Menu</TT> class. In this writer's
opinion, this is an example where providing a better API for the
<TT>JMenu</TT> class should have been more important than being
API compatible with the AWT <TT>Menu</TT> class.
<P>
The <TT>JMenuItem</TT> class is an extension of the <TT>AbstractButton</TT>
class. Instances of the <TT>JMenuItem</TT> class can contain text,
an icon, or both. The methods for managing the icon position relative
to the text for a button, presented in <A HREF="..\ch06\ch06.htm" >Chapter 6</A> apply for the
<TT>JMenuItem</TT> class. The previous section showed creating
text-only menu items. The following lines of code show how to
create a <TT>JMenuItem</TT> containing only an icon and both text
and an icon on the same menu item. When both text and an icon
are contained on a menu item, it is customary to have the icon
to the left of the text. However, the default placement of the
icon is to the right of the text. This requires a call to the
<TT>setHorizontalTextPosition</TT> method to place the icon to
the left of the text. The inherited access methods for setting
and querying the <TT>JMenuItem</TT> text <TT>String</TT> and <TT>Icon</TT>
instances are available to alter these properties after menu creation.
As with any button, the menu items' enabled status can be set.
In this example, the <TT>JMenuItem</TT> is disabled. The resulting
menu from the previous examples and the menu items in the following
version of the <TT>createMenu</TT> method are shown in Figure
9.7.
<P>
<A HREF="javascript:popUp('f9-7.gif')"><B>Figure 9.7 :</B> <I>Images and dis-abled Exit JMenuItem</I>.</A>
<BLOCKQUOTE>
<PRE>
/**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        Icon saveIcon = null;
        Icon exitIcon = null;
        
        try { 
            //
            // Load the images used.
            //
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 

        JMenuBar menubar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.add( &quot;New&quot; );
        file.add( &quot;Open...&quot; );
        file.add( &quot;Close&quot; );
        file.addSeparator();

        // Add a save item containing only an Icon
        JMenuItem saveMenuItem = new JMenuItem( saveIcon );
        file.add( saveMenuItem );
        file.add( &quot;Save As...&quot; );
        file.addSeparator();

        // Add an Exit item containing both text and an Icon
        JMenuItem exitMenuItem = new JMenuItem( &quot;Exit&quot;, exitIcon );
        exitMenuItem.setHorizontalTextPosition( SwingConstants.RIGHT );
        exitMenuItem.setEnabled( false );
        exitMenuItem.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( exitMenuItem );
        
        
        menubar.add( file );

        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<P>
The <TT>JMenuItem</TT> class allows a mnemonic to be set for the
item. The mnemonic corresponds to one of the letters in the menu
item's text. When specified, the mnemonic character displays with
an underline on the menu item and allows the item to be selected
via keyboard input. The <TT>JMenu</TT> class is an extension of
<TT>JMenuItem</TT>, so a mnemonic can be set on the menu itself.
The mnemonic is set with the <TT>setMnemonic</TT> method and can
be queried with the <TT>getMnemonic</TT> method. The parameter
to the <TT>setMnemonic</TT> method should be one of the constants
defined in the <TT>java.awt.event.KeyEvent</TT> class. This ensures
portability in the mnemonic specified. The mnemonic can also be
specified at construction time by using the version of the constructor
that takes the item's text and mnemonic as parameters. However,
there is not a constructor that takes the item's text, icon, and
mnemonic as parameters.
<P>
Accelerator keystrokes can be assigned to menu items. This allows
the item to be selected without traversing the menus. Accelerators
provide a shortcut for advanced users of the application. The
<TT>setAccelerator</TT> method can be used to set the accelerator,
and the <TT>getAccelerator</TT> method is used to query the current
accelerator in effect for the menu item. The <TT>setAccelerator</TT>
method requires an instance of the <TT>KeyStroke</TT> class as
a parameter. As was shown in <A HREF="..\ch03\ch03.htm" >Chapter 3</A> &quot;<TT>JComponent</TT>,&quot;
the <TT>Keystroke</TT> class provides a shared instance of a representation
of a key typed on the keyboard. To obtain a shared instance, one
of the overloaded static <TT>KeyStroke.getKeyStroke</TT> methods
is used.
<P>
The version of the <TT>MenuTest</TT> application in Listing 9.1
adds mnemonics and accelerators to the File menu used throughout
this chapter. In the <TT>createMenu</TT> method for each menu
item, the instance is created, and then the <TT>setMnemonic</TT>
and <TT>setAccelerator</TT> methods are called to specify those
properties. Then the customized menu item is added to the menu.
The resulting menu is shown in Figure 9.8. In this example code
listing, the Exit menu item is the only item with functionality
attached to the item. It will close the application if selected.
<P>
<A HREF="javascript:popUp('f9-8.gif')"><B>Figure 9.8 :</B> <I>Mnemonics and accelerators added to the
File menu</I>.</A><P>
<HR>
<P>
<B>Listing 9.1&nbsp;&nbsp;File Menu with Mnemonics and Icons<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that creates a menu in a frame.
 *
 * @author Mike Foley
 **/
public class MenuTest extends JFrame { 

    public static MenuTest frame;


    /**
     * MenuTest, null constructor.
     **/
    public MenuTest() { 
        this( null );
    }  // MenuTest


    /**
     * MenuTest, constructor.
     *
     * @param title The title for the frame.
     **/
    public MenuTest( String title ) { 
        super( title );
    }  // MenuTest


    /**
     * frameInit, from JFrame
     *
     * Create the contrent for this frame.
     **/
    protected void frameInit() { 
        
        //
        // Let our super create the content and associated panes.
        //
        super.frameInit();
                
        JMenuBar menubar = createMenu();
        setJMenuBar( menubar );

    }  // frameInit


    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        Icon newIcon = null;
        Icon openIcon = null;
        Icon closeIcon = null;
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;
        Icon exitIcon = null;
        
        try { 
            //
            // Load the images used.
            //
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );           
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );           
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 

        JMenuBar menubar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenuItem item = new JMenuItem( &quot;New&quot;, newIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_N );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_N, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Open&quot;, openIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_O );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_O, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Close&quot;, closeIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_C );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_C, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_S, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        file.add( item );

        file.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        file.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_P, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
       file.add( item );

       menubar.add( file );

       return( menubar );

    }  // createMenu
       
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new MenuTest( &quot;Menu Test&quot; );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // MenuTest
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheTTFONTSIZEJMenuFONTTTFONTSIZEClassFONT">
The <TT>JMenu</TT> Class
</A></H3>
<P>
The <TT>JMenu</TT> class itself is an extension of the <TT>JMenuItem</TT>
class. This implies that <TT>JMenu</TT> instances can be added
to other instances of the <TT>JMenu</TT> class, enabling cascaded
menus.
<P>
Listing 9.2 shows how to change the New menu item in the <TT>createMenu</TT>
method into a cascaded menu. The additional menu contains menu
items for many different New types. The resulting menu is shown
in Figure 9.9.
<P>
<A HREF="javascript:popUp('f9-9.gif')"><B>Figure 9.9 :</B> <I>A cascading File/New menu</I>.</A><P>
<HR>
<P>
<B>Listing 9.2&nbsp;&nbsp;File Menu with Cascading New Menu<BR>
</B>
<BLOCKQUOTE>
<PRE>
    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        Icon newIcon = null;
        Icon openIcon = null;
        Icon closeIcon = null;
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;
        Icon exitIcon = null;
        
        try { 
            //
            // Load the images used.
            //
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );           
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );           
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 

        JMenuBar menubar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        //
        // Change New menu into a cascaded menu.
        //
        JMenu newMenu = new JMenu( &quot;New&quot; );
        newMenu.setMnemonic( KeyEvent.VK_N );
        newMenu.setIcon( newIcon );
        newMenu.setHorizontalTextPosition( SwingConstants.RIGHT );
        
        JMenuItem item = new JMenuItem( &quot;Frame&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_F );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Window&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_W );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Icon&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_I );
        newMenu.add( item );
        
        file.add( newMenu );
                
        item = new JMenuItem( &quot;Open&quot;, openIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_O );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_O, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Close&quot;, closeIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_C );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_C, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_S, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        file.add( item );

        file.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        file.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_P, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );

        menubar.add( file );

        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>createMenu</TT> method shown here can be placed into any
of the sample applications presented earlier in this chapter for
testing. Notice how adding a <TT>JMenu</TT> instance to another
<TT>JMenu</TT> instance created the cascaded menu. Also notice
that the <TT>JMenu</TT> class does not have a constructor that
takes an <TT>Icon</TT> instance as a parameter. However, an icon
can still be added to the menu by calling the <TT>setIcon</TT>
method. This technique could be used to add icons to the menus
on the menubar; however, this is not a common practice.
<P>
The <TT>JMenu</TT> class provides methods for querying the items
contained in the menu. The <TT>getMenuComponentCount</TT> method
returns the number of items in the menu. The <TT>getMenuComponent</TT>
method returns the component at the specified index. The <TT>getMenuComponents</TT>
method returns an array of all the components in the menu. The
<TT>getItemCount</TT> method is equivalent to the <TT>getMenuComponentCount</TT>
method, and is provided for compatibility with the AWT menus.
The <TT>getItem </TT>method is equivalent to the <TT>getMenuComponent</TT>
method, except it returns an instance of the <TT>JMenuItem</TT>
class. If the component at the specified index is not an instance
of the <TT>JMenuItem</TT> class, the <TT>getItem</TT> method returns
the <TT>JMenu</TT> itself, (<TT>this</TT>). The rational for this
is unknown. The <TT>isMenuComponent</TT> can be used to determine
if a component is in the menu's submenu hierarchy.
<P>
The <TT>isTopLevelMenu</TT> method returns <TT>true</TT> if the
menu is attached to a menubar. The <TT>isPopupMenuVisible</TT>
can be used to determine if the menu's pop-up menu is currently
visible. The <TT>isSelected</TT> method returns <TT>true</TT>
if the menu is currently popped up. The <TT>isSelected</TT> method
is similar but slightly different from the <TT>isPopupMenuVisible</TT>
method. A menu can be popped up, but the pop-up menu's window
may not be visible.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JMenu </TT>class contains a constructor that takes a <TT>boolean</TT> parameter specifying that the menu be a tear-off menu. This property must be specified at creation time; there is not a<TT> set </TT>method for the property. The<TT> isTearOff </TT>method can be used to query the status of this property. Even though these methods are in the <TT>JMenu </TT>class's API, tear-off menus are not yet implemented in the JFC menu system.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheTTFONTSIZEJCheckBoxMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JCheckBoxMenuItem</TT>
Class</A></H3>
<P>
The <TT>JCheckBoxMenuItem</TT> class is an extension of the <TT>JMenuItem</TT>
class. As such, the discussion in the previous section applies
to the <TT>JCheckBoxMenuItem</TT> class. An instance of the <TT>JCheckBoxMenuItem</TT>
represents a menu item that will display selected or unselected.
The visual representation is defined by the current look-and-feel.
However, it is typical for a check to be placed on a selected
check box menu item. 
<P>
The <TT>setSelected</TT> method is used to select or unselect
the menu item. The <TT>getSelected</TT> method queries the current
selected state of the item. The <TT>setState</TT> and <TT>getState</TT>
methods perform the same functionality as the <TT>setSelected</TT>
and <TT>getSelected</TT> methods. These methods are provided for
compatibility with other component toolkits. The <TT>setSelected</TT>
and <TT>getSelected</TT> pair are the standard methods for selection
in menus and buttons in the JFC. These methods should be used
instead of the <TT>setState</TT> and <TT>getState</TT> pair. The
initial selected state can also be specified in the constructor.
If an initial selection state is not specified, the item will
not be selected.
<P>
The following version of the <TT>createMenu</TT> method adds two
<TT>JCheckBoxMenuItem</TT> instances to an Options menu. The first
check box is not initially selected, and the second check box
corresponding to the Echo menu item is initially selected. Mnemonics
and accelerators are set for each check box menu item. Typing
the accelerator key performs the same task as selecting the item
in the menu. The next time the window is displayed, the check
box will reflect that the item had been selected. Notice how the
call to the <TT>setHorizontalTextPosition</TT> method is not required
to position the icon properly for check box menu items. The default
position for an icon is to the left of the text, as is customary
for menu items. The resulting menu, when the <TT>createMenu</TT>
shown in Listing 9.3 is added to the <TT>MenuTest</TT> application,
is shown in Figure 9.10.
<P>
<A HREF="javascript:popUp('f9-10.gif')"><B>Figure 9.10:</B> <I>A menu that contains JCheckBoxMenuItem
instances</I>.</A><P>
<HR>
<P>
<B>Listing 9.3&nbsp;&nbsp;Options Menu with JCheckBoxMenuItem
<BR>
</B>
<BLOCKQUOTE>
<PRE>
    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        Icon newIcon = null;
        Icon openIcon = null;
        Icon closeIcon = null;
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;
        Icon exitIcon = null;
        Icon logIcon = null;
        Icon echoIcon = null;
        
        try { 
            //
            // Load the images used.
            //
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );           
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );           
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
            logIcon = ImageLoader.loadIcon( &quot;log.gif&quot; );
            echoIcon = ImageLoader.loadIcon( &quot;echo.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 

        JMenuBar menubar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenu newMenu = new JMenu( &quot;New&quot; );
        newMenu.setMnemonic( KeyEvent.VK_N );
        
        JMenuItem item = new JMenuItem( &quot;Frame&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_F );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Window&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_W );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Icon&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_I );
        newMenu.add( item );
        
        file.add( newMenu );
                
        item = new JMenuItem( &quot;Open&quot;, openIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_O );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_O, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Close&quot;, closeIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_C );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_C, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_S, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        file.add( item );

        file.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        file.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_P, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );

        menubar.add( file );

        //
        // Create an options menu containing two
        // CheckBoxMenuItems.
        //
        JMenu options = new JMenu( &quot;Options&quot; );
        options.setMnemonic( KeyEvent.VK_O );

        JCheckBoxMenuItem cbItem = new JCheckBoxMenuItem( &quot;Log&quot;, logIcon );
        cbItem.setMnemonic( KeyEvent.VK_L );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_L, Event.CTRL_MASK ) );
        options.add( cbItem );

        cbItem = new JCheckBoxMenuItem( &quot;Echo&quot;, echoIcon, true );
        cbItem.setMnemonic( KeyEvent.VK_E );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_E, Event.CTRL_MASK ) );
        options.add( cbItem );
        
        menubar.add( options );

        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheTTFONTSIZEJRadioButtonMenuItemFONTTTFONTSIZEClassFONT">
The <TT>JRadioButtonMenuItem</TT>
Class</A></H3>
<P>
Like the <TT>JCheckBoxMenuItem</TT> presented in the last section,
the <TT>JRadioButtonMenuItem</TT> class is an extension of the
<TT>JMenuItem</TT> class. As such, the discussion in the <TT>JMenuItem</TT>
section applies to the <TT>JRadioButtonMenuItem</TT> class. An
instance of the <TT>JRadioButtonMenuItem</TT> represents a menu
item that will display selected or unselected. The visual representation
is defined by the current look-and-feel. However, it is typical
for a filled or empty circle to be placed on the radio button
menu item to represent the selected or unselected state of the
menu item. It is typical to place the radio buttons into an instance
of the <TT>ButtonGroup</TT> class. The button group ensures that
only one of the buttons in the group is selected at a given time.
See the &quot;Radio Button Groups&quot; section of <A HREF="..\ch06\ch06.htm" >Chapter 6</A> for
a complete description of using radio buttons in button groups.
<P>
The version of the <TT>createMenu</TT> method in Listing 9.4 adds
a button group for selecting the foreground color to the Options
menu from the previous section. A cascading menu is used for the
color selection menu. This helps visually separate the radio button
menu items from the rest of the menu. Like the <TT>JCheckBoxMenuItem</TT>,
the icon in instances of the <TT>JRadioButtonMenuItem</TT> class
is placed in the standard location-to the left of the text. However,
unlike the <TT>JCheckBoxMenuItem</TT> class, the <TT>JRadioButtonMenuItem</TT>
doesn't contain a constructor allowing the selected state of the
button to be specified. A separate call to the <TT>setSelected</TT>
method is required to set the initially selected button in the
group. After being configured, each radio button is added to both
the menu and the button group.
<P>
Although it is customary to use the first letter of the menu item
as the mnemonic, this example contains two items with the same
first letter. To prevent multiple items from using the same mnemonic,
the letter &quot;u&quot; is used for the item named Blue. As we
have seen in the previous sections, the <TT>setAccelerator</TT>
method is used to specify the accelerator key combination in the
<TT>JRadioButtonMenuItem</TT> instances. When the <TT>createMenu</TT>
method shown in Listing 9.4 is used in the <TT>MenuTest</TT> application
shown earlier in this chapter, the resulting menu is the one shown
in Figure 9.11.
<P>
<A HREF="javascript:popUp('f9-11.gif')"><B>Figure 9.11:</B> <I>A menu that contains JRadioButtonMenu Item
instances</I>.</A><P>
<HR>
<P>
<B>Listing 9.4&nbsp;&nbsp;Options Menu with JRadioButtonMenuItem
Instances<BR>
</B>
<BLOCKQUOTE>
<PRE>
    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        Icon newIcon = null;
        Icon openIcon = null;
        Icon closeIcon = null;
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;
        Icon exitIcon = null;
        Icon logIcon = null;
        Icon echoIcon = null;
        Icon whiteIcon = null;   
        Icon blackIcon = null;   
        Icon redIcon = null;   
        Icon blueIcon = null;   
        
        try { 
            //
            // Load the images used.
            //
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );           
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );           
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
            logIcon = ImageLoader.loadIcon( &quot;log.gif&quot; );
            echoIcon = ImageLoader.loadIcon( &quot;echo.gif&quot; );
            whiteIcon = ImageLoader.loadIcon( &quot;white.gif&quot; );
            blackIcon = ImageLoader.loadIcon( &quot;black.gif&quot; );
            redIcon = ImageLoader.loadIcon( &quot;red.gif&quot; );
            blueIcon = ImageLoader.loadIcon( &quot;blue.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 

        JMenuBar menubar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenu newMenu = new JMenu( &quot;New&quot; );
        newMenu.setMnemonic( KeyEvent.VK_N );
        
        JMenuItem item = new JMenuItem( &quot;Frame&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_F );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Window&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_W );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Icon&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_I );
        newMenu.add( item );
        
        file.add( newMenu );
                
        item = new JMenuItem( &quot;Open&quot;, openIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_O );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_O, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Close&quot;, closeIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_C );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_C, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_S, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        file.add( item );

        file.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        file.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_P, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );

        menubar.add( file );

        //
        // Create an options menu containing two
        // CheckBoxMenuItems.
        //
        JMenu options = new JMenu( &quot;Options&quot; );
        options.setMnemonic( KeyEvent.VK_O );

        JCheckBoxMenuItem cbItem = new JCheckBoxMenuItem( &quot;Log&quot;, logIcon );
        cbItem.setMnemonic( KeyEvent.VK_L );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_L, Event.CTRL_MASK ) );
        options.add( cbItem );

        cbItem = new JCheckBoxMenuItem( &quot;Echo&quot;, echoIcon, true );
        cbItem.setMnemonic( KeyEvent.VK_E );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_E, Event.CTRL_MASK ) );
        options.add( cbItem );
        
        JMenu foreground = new JMenu( &quot;Foreground&quot; );
        foreground.setMnemonic( KeyEvent.VK_F );
        
        ButtonGroup group = new ButtonGroup();
        
JRadioButtonMenuItem rbItem = 
                  new JRadioButtonMenuItem( &quot;White&quot;, whiteIcon );
        rbItem.setForeground( Color.white );
        rbItem.setMnemonic( KeyEvent.VK_W );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_W, Event.CTRL_MASK ) );
 foreground.add( rbItem );
        group.add( rbItem );
        
        rbItem = new JRadioButtonMenuItem( &quot;Black&quot;, blackIcon );
        rbItem.setForeground( Color.black );
        rbItem.setSelected( true );
        rbItem.setMnemonic( KeyEvent.VK_B );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_B, Event.CTRL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        rbItem = new JRadioButtonMenuItem( &quot;Red&quot;, redIcon );
        rbItem.setForeground( Color.red );
        rbItem.setMnemonic( KeyEvent.VK_R );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                       troke.getKeyStroke( 
                            RL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        options.add( foreground );

        menubar.add( options );

        return( menubar );

    }  // createMenu
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="PlacingMenus">
Placing Menus</A></H2>
<P>
The previous section showed how to create menus and add the various
types of menu items supported by the JFC to a menu. The examples
showed the resulting menu attached to a frame. In the JFC, a menu
can be attached to a frame or used in a pop-up menu. Both of these
scenarios will be presented in this section<I>.</I>
<H3><A NAME="FrameMenus">
Frame Menus</A></H3>
<P>
In the JFC, an instance of the <TT>JFrame</TT> class can contain
one menubar that is displayed across the top of the frame, immediately
below the title bar. The menubar is an instance of the <TT>JMenuBar</TT>
class. In turn, the menubar can contain one or more menus that
are instances of the <TT>JMenu</TT> class. The menubar is attached
to the frame by using the <TT>JFrame </TT>class's <TT>setJMenuBa</TT>r
method. The <TT>setMenuBar</TT> method inherited from the <TT>awt.Frame</TT>
class is not used for this purpose.
<P>
The menu shown in Figure 9.11 was attached to the <TT>JFrame</TT>
class's <TT>frameInit</TT> method. The menubar is created in the
<TT>createMenu</TT> method called from the <TT>frameInit</TT>
method. The menu is added to the frame by using the <TT>setJMenuBar</TT>
method. Using a separate method to create the menubar allows subclasses
to override the menu and change the menu. The menu could also
be created in the constructor. However, the frame has multiple
constructors and only one <TT>frameInit</TT> method. This technique
is demonstrated in the previous examples in this chapter.
<P>
In the <TT>JMenuBar</TT> class, the add method is used to append
the given menu to the list of top-level menus already contained
on the menubar. The menus appear on the menubar in the order they
are added. The remove method can be used to remove a menu at a
given index.
<P>
Some look-and-feel implementations of the menubar treat the Help
menu differently than other menus. It is customary to have the
Help menu the last menu; some look-and-feel implementations place
the Help menu to the far right of the menubar. The <TT>JMenuBar
</TT>class provides the <TT>setHelpMenu</TT> method to specify
which menu should be treated as the Help menu. The Help menu can
be queried with the <TT>getHelpMenu</TT> method.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The current implementation of the <TT>JMenuBar</TT> class contains the <TT>setHelpMenu</TT> and <TT>getHelpMenu</TT> methods presented in the previous paragraph. However, they are not yet implemented and throw an error if called. An implementation for these methods should be available in a future version of the <TT>JMenuBar</TT> class.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The current menus contained in the menubar can be queried using
the <TT>getMenu</TT> method. The index of the desired menu is
passed to the method. The number of menus contained on a menubar
can be determined using the <TT>getMenuC</TT> method. The <TT>getSubElements</TT>
method can be used to obtain an array of <TT>MenuElement</TT>
instances, one for each menu in the menubar. To iterate through
the menus on a menubar, the following code snippet could be used.
<BLOCKQUOTE>
<PRE>
for( int i = 0; i &lt; menuBar.getMenuCount(); i++ ) { 
     JMenu menu = menuBar.getMenu( i );
     // Operate on menu.
     System.out.println( i + &quot;: &quot; + menu );
} 
</PRE>
</BLOCKQUOTE>
<P>
A <TT>JMenuBar</TT> instance delegates selection management to
a <TT>SingleSelectionModel</TT> instance. The model can be queried
with the <TT>getSelectionModel</TT> method and set with the <TT>setSelectionModel</TT>
method. However, the default selection model is sufficient for
most applications. The selection model is not a bound property
in the <TT>JMenuBar</TT> class. The <TT>setSelected</TT> method
can be used to set the currently selected component in the menu.
This is a convenient method that passes the selection to the <TT>SingleSelectionModel</TT>
instance.
<H3><A NAME="PopupMenus">
Pop-up Menus</A></H3>
<P>
Instances of the <TT>JPopupMenu</TT> class are used by the <TT>JMenu</TT>
class to display their menus. This use of the class is typically
hidden from application developers. However, a developer can create
an instance of the <TT>JPopupMenu</TT> class to provide a menu
anywhere desired. These are often used to provide context-sensitive
menus that are displayed when the user clicks on a component.
<P>
Creating and configuring a pop-up menu is very similar to creating
a frame menu. The instance of the <TT>JPopupMenu</TT> class is
created, and then <TT>Action</TT>s, <TT>Component</TT>s, and <TT>JMenuItem</TT>s
can be added or inserted into the pop-up menu. Conspicuously missing
from the <TT>JPopupMenu</TT> class API are methods to remove menu
items from the menu. The pop-up menu can contain a label, used
like a title. The label can be specified at construction time
and set and queried later by using the <TT>setLabel</TT> and <TT>getLabel</TT>
methods.
<P>
A <TT>Component</TT> contained in the pop-up menu can be obtained
by calling the <TT>getComponentAtIndex</TT> method with the index
of the desired <TT>Component</TT>. Conversely, the index of a
<TT>Component</TT> in the menu can be determined with the <TT>getComponentIndex</TT>
method.
<P>
The pop-up menu can be displayed and positioned by using the <TT>show</TT>
method. This method takes an invoker <TT>Component</TT> in which
the pop-up menu is to be displayed, and the x and y coordinates
in the invoker's coordinate space. The <TT>setVisible</TT> method
is used to hide the menu and to redisplay it if required. The
current visibility of the menu can be determined using the <TT>isVisible</TT>
method. The menu can be moved with the <TT>setLocation</TT> method.
A pop-up menu can be used over a different <TT>Component</TT>
by changing the invoker via the <TT>setInvoker</TT> method. The
current invoker <TT>Component</TT> can be queried by using the
<TT>getInvoker</TT> method.
<P>
The <TT>ApplicationMouseListener</TT> class is used to listen
for the <TT>popupTrigger</TT> <TT>MouseEvent</TT>. When it is
detected, the pop-up menu is created and displayed. The source
of the <TT>MouseEvent</TT> is used as the invoker <TT>Component</TT>.
The coordinates where the mouse was located at the time of the
event are queried from the event and used to position the pop-up
menu at the mouse location. It should be noted that the <TT>MouseListener</TT>
needs to check for the pop-up trigger in both the <TT>mousePressed</TT>
and <TT>mouseReleased</TT> methods. This is because pop-up menus
are triggered by different events for different look-and-feels.
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;


/**
 * Pop up the context sensitive menu when the pop-up
 * trigger event is delivered.
 **/
class ApplicationMouseListener extends MouseAdapter 
    implements MouseListener { 
        
    /** 
     * See if the mouse event is the pop-up trigger. If so, 
     * display the pop-up menu.
     *
     * @param e The mouse event causing this call.
     **/
    public void mouseReleased( MouseEvent e ) { 
        if( e.isPopupTrigger() ) { 
showPopupMenu( ( Component )e.getSource(), 
                           e.getX(), e.getY() );
        } 
    }     
    

    /** 
     * See if the mouse event is the pop-up trigger. If so, 
     * display the pop-up menu.
     *
     * @param e The mouse event causing this call.
     **/
    public void mousePressed( MouseEvent e ) { 
        if( e.isPopupTrigger() ) { 
showPopupMenu( ( Component )e.getSource(), 
                           e.getX(), e.getY() );
        } 
    }     


    /**
     * Display the pop-up menu using the given invoker, and at the
     * specified location.
     *
     * @param invoker The component used as the menu's invoker.
     * @param x The X coordinate for the pop-up menu.
     * @param y The Y coordinate for the pop-up menu.
     **/
    private void showPopupMenu( Component invoker, int x, int y ) { 
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;
        
        try { 
            //
            // Load the images used.
            //
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            return;
        } 

        JPopupMenu popup = new JPopupMenu( &quot;Title&quot; );
          
        JMenuItem item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
        popup.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        popup.add( item );

        popup.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        popup.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
        popup.add( item );
            
        popup.show( invoker, x, y );
        
    } 
    
}  // ApplicationMouseListener
</PRE>
</BLOCKQUOTE>
<P>
Listing 9.5 demonstrates how the <TT>ApplicationMouseListener</TT>
shown here is registered with each <TT>Component</TT> added to
the content pane of an <TT>ApplicationFrame</TT>. This is done
by using a <TT>ContainerListener</TT> instance. When the <TT>componentAdded</TT>
method is called, the <TT>ApplicationMouseListener</TT> instance
is registered with the new <TT>Component</TT>. If the <TT>componentRemoved</TT>
method is called, the <TT>MouseListener</TT> instance is removed
from the <TT>Component</TT> being removed from the content pane.
This technique only works for simple containers without deeply
nested components. For arbitrary container hierarchies, a more
complex <TT>ContainerListener</TT> would be required. The pop-up
menu created by this sample code is shown in Figure 9.12.
<P>
<A HREF="javascript:popUp('f9-12.gif')"><B>Figure 9.12:</B> <I>A JPopupMenu in the ApplicationFrame</I>.</A>
<P>
<HR>
<P>
<B>Listing 9.5&nbsp;&nbsp;MouseListener Added to all Components
of an ApplicationFrame<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;

import java.awt.event.*;

import java.io.Serializable;

import javax.swing.*;

import javax.swing.border.*;

import javax.swing.event.*;


/**
 * A toplevel frame. The frame customizes the
 * Icon and content in the frameInit method.
 *
 * @author Mike Foley
 **/
public class ApplicationFrame extends JFrame implements Serializable { 

    private static Icon exitIcon;
    private static Icon closeIcon;
    private static Icon saveIcon;
    private static Icon saveasIcon;
    private static Icon openIcon;
    private static Icon newIcon;
    private static Icon printIcon;
    private static Icon printsetupIcon;
    private static Icon logIcon;
    private static Icon echoIcon;
    private static Icon whiteIcon;
    private static Icon blackIcon;
    private static Icon redIcon;
    private static Icon blueIcon;
    
    /**
     * The MouseListener for content components. This will
     * pop up a menu is the popupTrigger is received.
     **/
    private MouseListener mouseListener;
    
    
    /**
     * Load images used in the frame.
     **/
    static { 
        try { 
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            logIcon = ImageLoader.loadIcon( &quot;log.gif&quot; );
            echoIcon = ImageLoader.loadIcon( &quot;echo.gif&quot; );
            whiteIcon = ImageLoader.loadIcon( &quot;white.gif&quot; );
            blackIcon = ImageLoader.loadIcon( &quot;black.gif&quot; );
            redIcon = ImageLoader.loadIcon( &quot;red.gif&quot; );
            blueIcon = ImageLoader.loadIcon( &quot;blue.gif&quot; );
        }  catch( InterruptedException ie ) { 
        } 
        
    } 
    
    
    /**
     * ApplicationFrame, null constructor.
     **/
    public ApplicationFrame() { 
        this( null );
    } 

    
    /**
     * ApplicationFrame, constructor.
     *
     * @param title The title for the frame.
     **/
    public ApplicationFrame( String title ) { 
        super( title );
    } 


    /**
     * Customize the frame for our application.
     **/
    protected void frameInit() { 
        //
        // Let the super create the panes.
        super.frameInit();
                
        try { 
            Image bullseye = ImageLoader.loadImage( &quot;bullseye.gif&quot; );
            setIconImage( bullseye );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Could not laod image bullseye.gif&quot; );
            ie.printStackTrace();
        } 
        
        JMenuBar menuBar = createMenu();
        setJMenuBar( menuBar );

        createApplicationContent();
                
    }  // frameInit


    /**
     * Create the content for the applictaion
     **/
    protected void createApplicationContent() { 
        
        mouseListener = createMouseListener();
        Container content = getContentPane();
        content.addContainerListener( new ContainerListener() { 
            public void componentAdded( ContainerEvent e ) { 
                Component c = e.getChild();
                c.addMouseListener( mouseListener );
            } 
            public void componentRemoved( ContainerEvent e ) { 
                Component c = e.getChild();
                c.removeMouseListener( mouseListener );
            } 
        }  );
        
        JPanel center = new JPanel();
        center.setLayout( new GridLayout( 4, 2 ) );
        
        center.add( new JLabel( &quot;Name: &quot;, SwingConstants.RIGHT ) );
        center.add( new JTextField() );
        center.add( new JLabel( &quot;Street: &quot;, SwingConstants.RIGHT ) );
        center.add( new JTextField() );
center.add( new JLabel( &quot;City and State: &quot;, 
                                SwingConstants.RIGHT ) );
        center.add( new JTextField() );
        center.add( new JLabel( &quot;Zip Code: &quot;, SwingConstants.RIGHT ) );
        center.add( new JTextField() );
        
center.setBorder( BorderFactory.createBevelBorder( 
                                        BevelBorder.LOWERED ) );
        
        content.add( BorderLayout.CENTER, center );
        
    }  // createApplicationContent


    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 
        JMenuBar menuBar = new JMenuBar();
        
        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenu newMenu = new JMenu( &quot;New&quot; );
        newMenu.setMnemonic( KeyEvent.VK_N );
        
        JMenuItem item = new JMenuItem( &quot;Frame&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_F );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Window&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_W );
        newMenu.add( item );
        
        item = new JMenuItem( &quot;Icon&quot; );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_I );
        newMenu.add( item );
        
        file.add( newMenu );
        
        item = new JMenuItem( &quot;Open&quot;, openIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_O );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_O, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Close&quot;, closeIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_C );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_C, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_S, Event.CTRL_MASK ) );
        file.add( item );
        
        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        file.add( item );

        file.addSeparator();
        
        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        file.add( item );
        
        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_P, Event.CTRL_MASK ) );
        file.add( item );
        
        file.addSeparator();
        
        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );
                
        menuBar.add( file );
        
        JMenu options = new JMenu( &quot;Options&quot; );
        options.setMnemonic( KeyEvent.VK_O );

        JCheckBoxMenuItem cbItem = new JCheckBoxMenuItem( &quot;Log&quot;, logIcon );
        cbItem.setMnemonic( KeyEvent.VK_L );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_L, Event.CTRL_MASK ) );
        options.add( cbItem );

        cbItem = new JCheckBoxMenuItem( &quot;Echo&quot;, echoIcon, true );
        cbItem.setMnemonic( KeyEvent.VK_E );
cbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_E, Event.CTRL_MASK ) );
        options.add( cbItem );

        JMenu foreground = new JMenu( &quot;Foreground&quot; );
        foreground.setMnemonic( KeyEvent.VK_F );
        
        ButtonGroup group = new ButtonGroup();
        
JRadioButtonMenuItem rbItem = 
                      new JRadioButtonMenuItem( &quot;White&quot;, whiteIcon );
        rbItem.setForeground( Color.white );
        rbItem.setMnemonic( KeyEvent.VK_W );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_W, Event.CTRL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        rbItem = new JRadioButtonMenuItem( &quot;Black&quot;, blackIcon );
        rbItem.setForeground( Color.black );
        rbItem.setSelected( true );
        rbItem.setMnemonic( KeyEvent.VK_B );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_B, Event.CTRL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        rbItem = new JRadioButtonMenuItem( &quot;Red&quot;, redIcon );
        rbItem.setForeground( Color.red );
        rbItem.setMnemonic( KeyEvent.VK_R );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_R, Event.CTRL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        rbItem = new JRadioButtonMenuItem( &quot;Blue&quot;, blueIcon );
        rbItem.setForeground( Color.blue );
        rbItem.setMnemonic( KeyEvent.VK_U );
        rbItem.setAccelerator( KeyStroke.getKeyStroke( 
                               KeyEvent.VK_U, Event.CTRL_MASK ) );
        foreground.add( rbItem );
        group.add( rbItem );
        
        options.add( foreground );
        
        menuBar.add( options );
                


        return( menuBar );
        
    }  // createMenuBar
    
    
    /**
     * Create the mouse listener for the frame.
     *
     * @return The MouseListener for the content in the frame.
     **/
    protected MouseListener createMouseListener() { 
        return new ApplicationMouseListener();
    } 
    

    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/       
    public static void main( String[] args ) { 
        
ApplicationFrame frame = 
                         new ApplicationFrame( &quot;ApplicationFrame&quot; );
        frame.pack();
        frame.setVisible( true );
        
    } 
    
}  // ApplicationFrame
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Pop-up Menu Events</H4>
<P>
Similar to the way the <TT>JMenu</TT> class fired <TT>MenuEvent</TT>s
to the methods defined in the <TT>MenuListener</TT> interface,
the <TT>JPopupMenu</TT> class fires <TT>PopupMenuEvent</TT>s to
the methods defined in the <TT>PopupMenuListener</TT> interface.
A quick comparison of the <TT>MenuEvent</TT> shown earlier in
this chapter and the <TT>PopupMenuEvent</TT> shown next reveals
that the <TT>PopupMenuEvent</TT> is the same as the <TT>MenuEvent</TT>.
Neither delivers information with the event beyond what is contained
in the <TT>EventObject</TT> class. The reason for the new class
is to distinguish between event types. 
<BLOCKQUOTE>
<PRE>
public class PopupMenuEvent extends EventObject { 
    public PopupMenuEvent(Object source) { 
        super(source);
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
Similarly, comparison of the <TT>MenuListener</TT> interface,
shown earlier in this chapter, and the <TT>PopupMenuListener</TT>
interface, shown in the following code, reveals semantically equivalent
methods defined in each interface. Unfortunately, the names of
the methods are different. The names in the <TT>PopupMenuListener</TT>
interface are much more descriptive than the equivalents in the
<TT>MenuListener</TT> interface. The <TT>popupMenuWillBecomeVisible</TT>
method is called immediately before the pop-up menu is shown.
The <TT>popupMenuWillBecomeInvisible</TT> is called immediately
before the menu is hidden. Finally, the <TT>popupMenuCanceled</TT>
method is called if the menu was dismissed without an item being
selected.
<BLOCKQUOTE>
<PRE>
public interface PopupMenuListener extends EventListener { 
    
    /**
     *  This method is called before the pop-up menu becomes visible 
     */
    void popupMenuWillBecomeVisible(PopupMenuEvent e);

    /**
     * This method is called before the pop-up menu becomes invisible
     * Note that a JPopupMenu can become invisible any time 
     */
    void popupMenuWillBecomeInvisible(PopupMenuEvent e);

    /**
     * This method is called when the pop-up menu is canceled
     */
    void popupMenuCanceled(PopupMenuEvent e);
} 
</PRE>
</BLOCKQUOTE>
<P>
<TT>PopupMenuListener</TT>s can be added to pop-up menus created
by the <TT>JMenu</TT> class and pop-up menus created by the application
directly. For example, the following code can be used to add a
<TT>PopupMenuListener</TT> to the pop-up menu created by the Options
menu in the <TT>ApplicationFrame</TT>'s menu presented in the
previous code.
<BLOCKQUOTE>
<PRE>
JMenu options = new JMenu( &quot;Options&quot; );
options.setMnemonic( KeyEvent.VK_O );
// Option menu created and added to the menubar.

JPopupMenu optionsPopUpMenu = options.getPopupMenu();
optionsPopUpMenu.addPopupMenuListener( new PopupMenuListener() { 
    public void popupMenuWillBecomeVisible(PopupMenuEvent e) { 
        System.out.println( &quot;popupMenuWillBecomeVisible&quot; );
    } 
    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) { 
        System.out.println( &quot;popupMenuWillBecomeInvisible&quot; );
    } 
    public void popupMenuCanceled(PopupMenuEvent e) { 
        System.out.println( &quot;popupMenuCanceled&quot; );
    } 
}  );
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheTTFONTSIZEMenuElementFONTTTFONTSIZEInterfaceFONT">
The <TT>MenuElement</TT>
Interface</A></H3>
<P>
The <TT>MenuElement</TT> interface should be implemented by any
<TT>Component</TT> that is added to a <TT>JMenu</TT> instance.
However, as you have seen in the previous section, this requirement
is not enforced. This interface is shown in the following:
<BLOCKQUOTE>
<PRE>
public interface MenuElement { 
    
    /**
* Process a mouse event. event is a MouseEvent with source being 
     * the receiving element's component.
     * path is the path of the receiving element in the menu
     * hierarchy including the receiving element itself.
     * manager is the MenuSelectionManager for the menu hierarchy.
* This method should process the MouseEvent and change the 
     * menu selection if necessary
     * by using MenuSelectionManager's API
* Note: you do not have to forward the event to sub-components. 
     * This is done automatically
     * by the MenuSelectionManager
     */
    public void processMouseEvent( MouseEvent event,MenuElement path[],
                                   MenuSelectionManager manager);


    /**
     *  Process a key event. 
     */
public void processKeyEvent( KeyEvent event, MenuElement path[],
                                 MenuSelectionManager manager);

    /**
     * Call by the MenuSelection when the MenuElement is added or remove 
     * from the menu selection.
     */
    public void menuSelectionChanged(boolean isIncluded);

    /**
* This method should return an array containing the 
     * sub-elements for the receiving menu element
     */
    public MenuElement[] getSubElements();
    
    /*
* This method should return the java.awt.Component 
     * used to paint the receiving element.
* The returned component will be used to convert 
     * events and detect if an event is inside
     * a MenuElement's component.
     */
    public Component getComponent();
} 
</PRE>
</BLOCKQUOTE>
<P>
The JFC menu items delegate to their UI object the <TT>processMouseEvent</TT>
and <TT>processKeyEvent</TT> methods. The <TT>menuSelectionChanged</TT>
method is used to inform the <TT>Component</TT> when it is added
or removed from the menu selection. The <TT>Component</TT> should
update its selection state accordingly. The <TT>Component</TT>
returns an array of <TT>MenuElement</TT> instances that are children
of that item from the <TT>getSubElements</TT>. If the <TT>Component</TT>
doesn't have any children menu items, it should return an array
of length <TT>0</TT>, not <TT>null</TT>. The <TT>getComponent</TT>
method returns the <TT>Component</TT> used to paint the menu.
The <TT>JMenu</TT> and <TT>JMenuItem</TT> classes return <TT>this</TT>
from the <TT>getComponent</TT> method.
<H2><A NAME="CreatingToolbars">
Creating Toolbars</A></H2>
<P>
Many applications contain one or more toolbars. The JFC provides
the <TT>JToolBar</TT> class to facilitate adding toolbars to your
application or applet. The <TT>JToolBar</TT> class implements
a floating toolbar that can be dragged off the original frame
into its own frame. It can then be redocked onto any side of the
original frame. To accomplish this functionality, the <TT>JToolBar</TT>
class is designed to work with a container employing a <TT>BorderLayout</TT>
for <TT>Component</TT> positioning. To allow the toolbar to be
docked on any side of the frame, user components should only occupy
the center region of the <TT>BorderLayout</TT>, leaving the north,
south, east, and west regions for the toolbar. The current version
of the JFC is designed for a single toolbar in a region. Thus,
creating complex toolbars still requires additional user code.
<P>
Any component can be added to a toolbar by using the <TT>add</TT>
method. In practice, the most common components contained on a
toolbar are instances of the <TT>JButton</TT> class displaying
icons. The <TT>JToolBar</TT> class is <TT>Action</TT> aware. This
allows <TT>Action</TT> instances to be added to the toolbar directly.
The toolbar will query the <TT>Action</TT> for its name and small
icon and will place these on a <TT>JButton</TT> instance that
is added to the toolbar.
<P>
The toolbar instance configures itself with a <TT>BoxLayout</TT>
layout manager oriented along the x axis for horizontally oriented
toolbars and along the y axis for vertical toolbars. Components
added to the toolbar will be placed to the right of existing components
in the toolbar for horizontal toolbars, and below existing components
in vertical toolbars. The <TT>JToolBar</TT> class does not provide
any insert methods. However, remove methods are inherited from
the AWT <TT>Container</TT> class. Reordering a toolbar can be
performed by removing components and adding them in a different
order. The <TT>getComponentIndex</TT> method will return the index
of the given component. This method returns <TT>-1</TT> if the
component is not found in the toolbar. The inverse of this method,
<TT>getComponentAtIndex</TT>, returns the <TT>Component</TT> at
the given index. This method returns <TT>null</TT> if the index
is larger than the number of components in the toolbar and will
throw an <TT>ArrayIndexException</TT> if the index is negative.
<P>
Passing the <TT>setOrientation</TT> method the constant <TT>HORIZONTAL</TT>
or <TT>VERTICAL</TT>, defined in the <TT>SwingConstants</TT> interface,
can change the orientation of a toolbar. When the orientation
is changed, a new <TT>BoxLayout</TT> layout manager with the proper
axis for the new orientation is created and set for the toolbar.
The toolbar is then revalidated and repainted to reflect the new
orientation. The current orientation can be queried by using the
<TT>getOrientation</TT> method. The orientation of the toolbar
is not a bound property.
<P>
The following code creates a toolbar and adds it to the <TT>ApplicationFrame</TT>
presented earlier in this section. The toolbar is created in the
protected <TT>createToolBar</TT> method called from the modified
<TT>frameInit</TT> method shown next. This allows extensions of
the <TT>ApplicationFrame</TT> class to change the default toolbar
if desired. The toolbar is added to the north region of the content
pane. Recall that the content pane is configured with a <TT>BorderLayout</TT>
by default. Instances of the <TT>JButton</TT> class are created
containing icons and added to the toolbar. The <TT>ExitAction</TT>
is also added to the toolbar. The resulting frame containing the
toolbar is shown in Figure 9.13.
<BLOCKQUOTE>
<PRE>
/**
 * Customize the frame for our application.
 **/
 protected void frameInit() { 
    //
    // Let the super create the panes.
    super.frameInit();

    // Create the menu, and add it to the frame              
    JMenuBar menuBar = createFrameMenu();
    setJMenuBar( menuBar );

    // Create the toolbar, and add it to the NORTH region
    // of the content pane.
    JToolBar toolBar = createToolBar();
    Container content = getContentPane();
    content.add( BorderLayout.NORTH, toolBar );
        
    createApplicationContent();
                
}  // frameInit

/**
 * Create the toolbar for the frame.
 * &lt;p&gt;
 * @return The toolbar for the frame.
 **/
protected JToolBar createToolBar() { 
    JToolBar toolBar = new JToolBar();
    
    // Add items to the toolbar.
    toolBar.add( new JButton( newIcon ) );
    toolBar.add( new JButton( openIcon ) );
    toolBar.add( new JButton( saveIcon ) );
    toolBar.add( new JButton( closeIcon ) );
    toolBar.addSeparator();
    toolBar.add( new JButton( printIcon ) );
    toolBar.addSeparator();
    toolBar.add( new ExitAction() );
    return( toolBar );
}
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f9-13.gif')"><B>Figure 9.13:</B> <I>This is a JToolBar added to the ApplicationFrame</I>.</A>
<P>
The first thing that stands out in Figure 9.13 is that when adding
an Action instance to a toolbar, both the name and icon associated
with the Action are added to the JButton placed on the toolbar.
Thus, if Actions and user-created buttons are added to a toolbar,
care must be taken to ensure a consistent look. A better createToolbar
method is shown in Listing 9.6. The updated toolbar is shown in
Figure 9.14.
<P>
<A HREF="javascript:popUp('f9-14.gif')"><B>Figure 9.14:</B> <I>A better JToolBar for the ApplicationFrame</I>.</A>
<P>
<HR>
<P>
<B>Listing 9.6&nbsp;&nbsp;Toolbar with Associated Actions and
Icons<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Create the toolbar for the frame.
 * &lt;p&gt;
 * @return The toolbar for the frame.
 **/
protected JToolBar createToolBar() { 
    JToolBar toolBar = new JToolBar();
        
    JButton button = new JButton( &quot;New&quot;, newIcon );
    button.setHorizontalTextPosition(JButton.CENTER);
    button.setVerticalTextPosition(JButton.BOTTOM);
    toolBar.add( button );
        
    button = new JButton( &quot;Open&quot;, openIcon );
    button.setHorizontalTextPosition(JButton.CENTER);
    button.setVerticalTextPosition(JButton.BOTTOM);
    toolBar.add( button );

    button = new JButton( &quot;Save&quot;, saveIcon );
    button.setHorizontalTextPosition(JButton.CENTER);
    button.setVerticalTextPosition(JButton.BOTTOM);
    toolBar.add( button );

    button = new JButton( &quot;Close&quot;, closeIcon );
    button.setHorizontalTextPosition(JButton.CENTER);
    button.setVerticalTextPosition(JButton.BOTTOM);
    toolBar.add( button );

    toolBar.addSeparator();
        
    button = new JButton( &quot;Print&quot;, printIcon );
    button.setHorizontalTextPosition(JButton.CENTER);
    button.setVerticalTextPosition(JButton.BOTTOM);
    toolBar.add( button );

    toolBar.addSeparator();
        
    toolBar.add( new ExitAction() );
        
    return( toolBar );
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>addSeparator</TT> method adds space between the buttons
on the toolbar. This allows the buttons to be easily grouped by
functionality.
<P>
The dimpled region to the far left of the toolbar in Figure 9.14
provides a handle that can be dragged to detach the toolbar from
the frame. The toolbar can be docked on a different side of the
frame or left in its own window. These options are shown in Figures
9.15 and 9.16. This region is specific to the Metal look-and-feel
and is not present in the Windows look-and-feel. When using the
Windows look-and-feel, the toolbar can be dragged to any region
in the frame where a button is not located.
<P>
<A HREF="javascript:popUp('f9-15.gif')"><B>Figure 9.15:</B> <I>The JToolBar in its own window</I>.</A>
<P>
<A HREF="javascript:popUp('f9-16.gif')"><B>Figure 9.16:</B> <I>The JToolBar in the south region</I>.</A>
<P>
There are situations where it is not desirable to allow the user
to move the toolbar. The toolbar can be fixed in the location
set by the application by calling the JToolBar setFloatable method
with a parameter of false. The state of the floatable property
can be queried with the isFloatable method. This property can
be changed at runtime to alter whether or not the toolbar is floatable.
When the toolbar is not floatable, the dimpled drag region of
the toolbar is not displayed in the Metal look-and-feel. This
type of toolbar is shown in Figure 9.17. The default setting is
to allow the toolbar to float. The floatable property is not bound
in the JToolBar class.
<P>
<A HREF="javascript:popUp('f9-17.gif')"><B>Figure 9.17:</B> <I>A fixed instance of the JToolBar class</I>.</A>
<P>
The margin between the toolbar's border and its components can
be set with the setMargin method. This method takes an Insets
instance to specify the margin on each side of the toolbar. The
getMargin method returns an Insets instance with the current margins
for the toolbar. The margin property is bound in the JToolBar
class with the name of margin. This is the only bound property
defined in the JToolBar class. This property seems redundant.
The JToolBar class inherits from the JComponent class. As such,
it contains the border property that can be used for the same
purpose as the margin property.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
Menus and toolbars are an important part of a modern graphical
user interface. The JFC provides a rich set of APIs for building
these user interface components. Menus can contain text and/or
icons. Check box and radio button menu items are supported. Any
depth of cascading menus can be implemented. A menu can be attached
to a frame or popped up anywhere desired.
<P>
The JFC provides the <TT>JToolBar</TT> class for adding toolbars
to a frame. The toolbar will float by default. This allows the
toolbar to be docked to any side of the frame or placed in its
own window. You can specify that the toolbar not be allowed to
float. In that case, the user will not be able to drag it off
the frame or to a different location.
<P>
Both menus and toolbars are <TT>Action</TT>-aware components.
This allows <TT>Action</TT> instances to be added directly to
menus and toolbars. The menu and toolbar will update their visual
representations if the name, icon, or enabled status of the <TT>Action</TT>
changes. This provides an easy way to ensure that the menu- and
toolbar-enabled statuses are in sync with application actions.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch08\ch08.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch10\ch10.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
