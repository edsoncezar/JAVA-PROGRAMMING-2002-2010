<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 15 - Scrolling Components</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch14\ch14.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch16\ch16.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;15<br>
Scrolling Components</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TheTTFONTSIZEJViewportFONTTTFONTSIZEClassFONT">
The <TT>JViewport</TT> Class
</A>
<UL>
<LI><A HREF="#TTFONTSIZEViewportLayoutFONTTTFONTSIZELayoutManagerFONT">
<TT>ViewportLayout</TT> Layout
Manager</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJScrollPaneFONTTTFONTSIZEClassFONT">
The <TT>JScrollPane</TT>
Class</A>
<UL>
<LI><A HREF="#TTFONTSIZEScrollPaneLayoutFONTTTFONTSIZELayoutManagerFONT">
<TT>ScrollPaneLayout</TT>
Layout Manager</A>
<LI><A HREF="#ScrollingPolicy">
Scrolling Policy</A>
<LI><A HREF="#SpecifyingRowandColumnHeadings">
Specifying Row and Column Headings</A>
<LI><A HREF="#SpecifyingCornerComponents">
Specifying Corner Components</A>
</UL>
<LI><A HREF="#TTFONTSIZEJComponentFONTTTFONTSIZEScrollingSupportFONT">
<TT>JComponent</TT> Scrolling
Support</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
We have seen the need for scrolling large components earlier in
this book when dealing with the <TT>JList</TT> and <TT>JTable</TT>
classes. Many applications contain data structures or pictures
that cannot be displayed completely on the computer's screen.
Often this situation is handled by creating a large component
displaying the data or picture and allowing the user to scroll
the component to see the portion of the component that they want.
When creating large lists and tables, we saw how easy it was to
enable these components to be scrolled. At that time, however,
the scrolling support contained in the JFC was not fully described.
These capabilities are described in this chapter.
<P>
The JFC provides the <TT>JScrollPane</TT> class to allow any component
to be easily scrolled. The <TT>JScrollPane</TT> class manages
horizontal and vertical scrollbars, column and row header components,
corner components, and a viewport. However, all components may
not be visible in every scroll pane. The viewport in the scroll
pane manages the actual component that is to be scrolled. The
horizontal header scrolls right and left as the content scrolls,
but not vertically. It is always on top of the data. The column
header component behaves similarly, but for columns. It moves
up and down with the content but does not move horizontally.
<P>
In this chapter, you will learn
<UL>
<LI>How the <TT>JViewport</TT> class works
<LI>How the <TT>JScrollPane</TT> class works
<LI>How to manage the scrollbar policy
<LI>How to add headers to the scroll pane
</UL>
<H2><A NAME="TheTTFONTSIZEJViewportFONTTTFONTSIZEClassFONT">
The <TT>JViewport</TT> Class
</A></H2>
<P>
The <TT>JViewport</TT> class is used by the <TT>JScrollPane</TT>
class to manage the view of the underlying component being displayed
in the scroll pane. The <TT>JViewport</TT> class extends the <TT>JComponent</TT>
class. When a scrollbar contained in the scroll pane is scrolled,
it is the viewport that moves. A viewport can be thought of as
the viewer on a camcorder. As the camcorder is moved about, different
portions of the scenery are visible in the viewer. As the camcorder
moves right, additional scenery on the right is visible and scenery
to the left is removed from the viewer. A viewport displaying
a portion of a large component is shown in Figure 15.1.
<P>
<A HREF="javascript:popUp('f15-1.gif')"><B>Figure 15.1 :</B> <I>JViewport instance displaying a portion
of a large component</I>.</A>
<P>
The JViewport class contains a single default constructor. The
constructor configures the viewport with its layout manager, a
ViewportLayout instance by default. However, extensions of the
JViewport can change the default layout manager by overriding
the createLayoutManager method and returning a different layout
manager. Typically, JViewport instances are not created by user
code. Instead, the viewport created by the JScrollPane class is
used. This is demonstrated later in this chapter.
<P>
A <TT>JViewport</TT> instance manages one child, a descendant
of the AWT <TT>Component</TT> class. The child component can be
a container itself and can contain many other components, but
the viewport itself has only a single child. The child is set
and queried with the <TT>setView</TT> and <TT>getView</TT> methods.
When the component is set via the <TT>setView</TT> method, the
viewport adds a component listener to the component. If the component
is later resized, the viewport notifies listeners that have registered
for changes by using the <TT>addChangeListener</TT> method. A
listener is removed with the <TT>removeChangeListener</TT> method.
<P>
A viewport can be configured to create an offscreen image that
buffers the visual representation of the visible portion of the
child component. This allows the viewport to scroll faster. When
the viewport's <TT>paint</TT> method is called, if the viewport
has not been scrolled, the component is drawn to the image that
is then copied to the display. If the viewport has been scrolled,
the image is moved the appropriate amount and then the exposed
portion of the child component is drawn to the image. The complete
image is then copied to the display. This allows scrolling to
be performed faster by not having to repaint the entire component
when a small scroll is performed. The offscreen image is known
as a <I>backing store</I>. To enable
the backing store, <TT>true</TT> is passed to the <TT>setBackingStoreEnabled</TT>
method. The current state of this attribute can be queried via
the <TT>isBackingStoreEnabled</TT> method.
<P>
Whether to use a backing store is a classic tradeoff between time
and memory. Using the extra memory for the backing store allows
the scrolling to be performed faster. Unfortunately, calling <TT>setBackingStoreEnabled</TT>
with a parameter of <TT>false</TT> does not free the storage allocated
for the backing store image. This means that once the backing
store is enabled, the offscreen image will not be garbage collected
until the entire viewport is eligible for garbage collection,
even though it is no longer used.
<P>
When a component is first added to a viewport, its upper-left
corner is aligned with the upper-left corner of the viewport.
This will not be the case once the component is scrolled. If it
is required to determine which portion of the view is visible,
the <TT>JViewport</TT> class provides the <TT>getExtentSize</TT>
and <TT>getViewPosition</TT> methods to query the size of the
visible portion of the component and the position of the component
in the upper-left corner of the viewport. The <TT>getViewRect</TT>
method returns an AWT <TT>Rectangle</TT> instance that combines
the information of the previous two calls. These locations as
they relate to the underlying component are shown in Figure 15.2.
The size of the underlying view can be queried with the <TT>getViewSize</TT>
method. If the viewport does not contain a component, a size of
<TT>(0,0)</TT> is returned. Otherwise the size of the component
is returned. If the size has not been explicitly set, the preferred
size of the component is returned.
<P>
<A HREF="javascript:popUp('f15-2.gif')"><B>Figure 15.2 :</B> <I>JViewport class positioning of a large
component</I>.</A>
<P>
It is also possible to programmatically alter which portion of
the underlying component is visible in the viewport. The setViewPosition
method defines which point of the component will be located in
the upper-left corner of the viewport. The setExtentSize method
will define the size of the visible portion of the component.
The setViewSize method will set the size of the underlying component.
Changing either the view position or the extent size causes the
viewport to notify change listeners that a change has occurred.
However, the exact nature of the change is not delivered with
the change event. The listener must query the viewport for its
new state. The view can also be scrolled by using the scrollRectToVisible
method. This method ensures that the given rectangle is visible.
<H3><A NAME="TTFONTSIZEViewportLayoutFONTTTFONTSIZELayoutManagerFONT">
<TT>ViewportLayout</TT> Layout
Manager</A></H3>
<P>
The default behavior of the <TT>JViewport</TT> class is to create
an instance of the <TT>ViewportLayout</TT> class to manage its
single child component. The <TT>ViewportLayout</TT> class assumes
it is managing a <TT>JViewport</TT> instance, so it is not a general-purpose
layout manager. The layout manager can be set to a different layout
manager if required. Also, extensions to the <TT>JViewport</TT>
class can override the <TT>createLayoutManager</TT> method to
return a different class of <TT>LayoutManager</TT> for the viewport.
<P>
The <TT>ViewportLayout</TT> layout manager positions components
that are smaller than the viewport in the upper-left corner, leaving
extra space below or to the right of the component. However, if
the origin of the component is displayed and the component is
smaller than the viewport in either direction, the component is
resized to the size of the viewport in that direction. If both
directions are smaller than the viewport, the component will be
resized to the viewport's size. If the component implements the
<TT>Scrollable</TT> interface and is set to track the viewport's
size, the component is sized to the viewport's size.
<H2><A NAME="TheTTFONTSIZEJScrollPaneFONTTTFONTSIZEClassFONT">
The <TT>JScrollPane</TT>
Class</A></H2>
<P>
The JFC class that is typically used for scrolling a component
is the <TT>JScrollPane</TT> class. The <TT>JScrollPane</TT> class
is an extension of the <TT>JComponent</TT> class and manages a
<TT>JViewport</TT> instance, scrollbars, and viewport headings.
The <TT>JViewport</TT> class manages the component that is to
be scrolled and was described in the previous section. Instances
of the <TT>JScrollBar</TT> class, described in <A HREF="..\ch10\ch10.htm" >Chapter 10</A>, &quot;<TT>JList</TT>,
<TT>JComboBox</TT>, and Bound Controls,&quot; are used for the
scrollbars. The heading instances are also of the <TT>JViewport</TT>
class. One heading can be specified for the horizontal axis and
another for the vertical axis.
<P>
The <TT>JScrollPane</TT> class manages a single viewport in the
center of its area. The viewport is specified by using the <TT>setViewport</TT>
method. Instead of specifying the viewport, the component to be
scrolled can be specified by using the <TT>setViewportView</TT>
method. In this case, the <TT>JScrollPane</TT> class creates the
viewport itself. By default, an instance of the <TT>JViewport</TT>
class is used for the viewport. However, extensions to the <TT>JScrollPane</TT>
class can override the <TT>createViewport</TT> method to return
an extension of the <TT>JViewport</TT> class to be used. The <TT>getViewport</TT>
method can be used to query the current viewport in the <TT>JScrollPane</TT>
instance. This method will return <TT>null</TT> if there is not
a viewport defined in the scroll pane. The viewport is a bound
property of the <TT>JScrollPane</TT> class.
<P>
Listing 15.1 shows a simple application that displays <TT>JLabel</TT>
instances stacked in a box. The version of the <TT>JScrollPane</TT>
constructor taking the view component as a parameter is used.
The resulting application is shown in Figure 15.3.
<P>
<A HREF="javascript:popUp('f15-3.gif')"><B>Figure 15.3 :</B> <I>The ScrollPaneTest application</I>.</A>
<P>
<HR>
<P>
<B>Listing 15.1&nbsp;&nbsp;The ScrollPaneTest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;
import com.foley.utility.JBox;


/**
 * An application that displays a large component
 * in a JScrollPane.
 *
 * @author Mike Foley
 **/
public class ScrollPaneTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the component, scrollpane and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;ScrollPane Test&quot; );
        
        Font ourFont = new Font( &quot;Helvitica&quot;, Font.BOLD, 24 );
        JBox box = JBox.createVerticalJBox();
        
        JLabel label = new JLabel();
        label.setText( &quot;This is a long message that will not&quot; +
                       &quot; fit on may displays. &quot; +
                       &quot;Better scroll it!&quot; );
        label.setFont( ourFont );
        box.add( label );
        
        label = new JLabel();
        label.setText( &quot;The JBox contains many labels.&quot; );
        label.setFont( ourFont );
        box.add( label );
        
        label = new JLabel();
        label.setText( &quot;Each label is stacked on top of&quot; +
                       &quot; each other in a JBox container.&quot; );
        label.setFont( ourFont );
        box.add( label );
        
        label = new JLabel();
        label.setText( &quot;It may be too tall as well as too wide.&quot; );
        label.setFont( ourFont );
        box.add( label );
        
        label = new JLabel();
        label.setText( &quot;Better scroll it!&quot; );
        label.setFont( ourFont );
        label.setAutoscrolls( true );
        box.add( label );
        
        JScrollPane scrollPane = new JScrollPane( box );
        
        frame.getContentPane().add( scrollPane, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ScrollPaneTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>JScrollPane</TT> class overrides the <TT>isOpaque</TT>
method defined in the <TT>JComponent</TT> class. Recall that this
method returns <TT>true</TT> if the component paints every pixel
in its area. The <TT>JScrollPane</TT> class checks the opaque
property of the component being scrolled in its viewport. Only
if this property is <TT>true</TT>, and the component is at least
as big as the viewport, does the <TT>JScrollPane</TT> class return
<TT>true</TT> from the <TT>isOpaque</TT> method. Thus, the <TT>JScrollPane</TT>
class is only opaque if the component being scrolled is opaque.
<P>
The border for a scroll pane can be set by using the standard
<TT>setBorder</TT> method inherited from <TT>JComponent</TT>.
This places a border around the center component as well as any
scrollbars, headers, or corners that may be visible. If a border
is desired around the viewport only, the <TT>setViewportBorder</TT>
method can be used. This property is a bound property defined
for the <TT>JScrollPane</TT> class. Clients listening for property
change events will receive a change of the property name <TT>viewportBorder</TT>.
The current state of this property is queried with the <TT>getViewportBorder</TT>
method. This property, as well as the other bound properties introduced
in the <TT>JScrollPane</TT> class, are presented in Table 15.1.
<BR>
<P>
<CENTER><B>Table 15.1&nbsp;&nbsp;Bound Properties Introduced by
the </B><TT><B>JSCROLLPANE</B></TT><B>
Class</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=150><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=150><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=150><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>VerticalScroll 
<BR>
BarPolicy</TT>
</TD><TD WIDTH=150><TT>setVerticalScroll <BR>
BarPolicy</TT>
</TD><TD WIDTH=150><TT>getVerticalScroll <BR>
BarPolicy</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>HorizontalScroll <BR>
BarPolicy</TT>
</TD><TD WIDTH=150><TT>setHorizontalScroll <BR>
BarPolicy</TT>
</TD><TD WIDTH=150><TT>getHorizontalScroll<BR>
BarPolicy</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>viewportBorder</TT></TD><TD WIDTH=150><TT>setViewportBorder</TT>
</TD><TD WIDTH=150><TT>getViewportBorder</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>horizontal\ ScrollBar</TT></TD><TD WIDTH=150><TT>setHorizontalScrollBar</TT>
</TD><TD WIDTH=150><TT>getHorizontal 
<BR>
ScrollBar</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>verticalScrollBar</TT></TD><TD WIDTH=150><TT>setVerticalScrollBar</TT>
</TD><TD WIDTH=150><TT>getVerticalScrollBar</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>viewport</TT></TD><TD WIDTH=150><TT>setViewport</TT>
</TD><TD WIDTH=150><TT>getViewport</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>rowHeader</TT></TD><TD WIDTH=150><TT>setRowHeader</TT>
</TD><TD WIDTH=150><TT>getRowHeader</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>columnHeader</TT></TD><TD WIDTH=150><TT>setColumnHeader</TT>
</TD><TD WIDTH=150><TT>getColumnHeader</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>LOWER_LEFT_CORNER</TT></TD><TD WIDTH=150><TT>setCorner</TT>
</TD><TD WIDTH=150><TT>getCorner</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>LOWER_RIGHT_CORNER</TT></TD><TD WIDTH=150><TT>setCorner</TT>
</TD><TD WIDTH=150><TT>getCorner</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>UPPER_LEFT_CORNER</TT></TD><TD WIDTH=150><TT>setCorner</TT>
</TD><TD WIDTH=150><TT>getCorner</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>UPPER_RIGHT_CORNER</TT></TD><TD WIDTH=150><TT>setCorner</TT>
</TD><TD WIDTH=150><TT>getCorner</TT></TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The <TT>JScrollPane</TT> class overrides the <TT>isValidateRoot</TT>
method defined in the <TT>JComponent</TT> class to return <TT>true</TT>.
This means that child components that call the <TT>revalidate</TT>
method will be validated. This eliminates the need to call <TT>invalidate</TT>
followed immediately by <TT>validate</TT>, seen in many AWT-based
applications. For a full discussion of the <TT>revalidate</TT>
and <TT>isValidateRoot</TT> methods, see <A HREF="..\ch03\ch03.htm" >Chapter 3</A> &quot;<TT>JComponent</TT>.&quot;
<H3><A NAME="TTFONTSIZEScrollPaneLayoutFONTTTFONTSIZELayoutManagerFONT">
<TT>ScrollPaneLayout</TT>
Layout Manager</A></H3>
<P>
By default, the <TT>JScrollPane</TT> class uses an instance of
the <TT>ScrollPaneLayout</TT> class, or one of its descendants,
for its layout manager. This class manages the nine potential
children of the scroll pane. These are the viewport in the center,
the horizontal scrollbar on the bottom, the vertical scrollbar
on the right, the column header on the top, the row header on
the left, and the four corner components.
<P>
The <TT>ScrollPaneLayout</TT> class sizes the horizontal scrollbar
and the column header to their preferred heights and to the width
of the scroll pane, less the width of the row <BR>
header and vertical scrollbar, if either is visible. Similarly,
the vertical scrollbar and the row header are sized to their preferred
widths and to the height of the scroll pane, less the height of
the column header and horizontal scrollbar, if either is visible.
The viewport is given the remainder of the scroll pane's size,
assuming there is space still available. The corner components
are sized to the height and width of their adjacent components
if they are visible. For example, the lower-right corner is the
height of the horizontal scrollbar and the width of the vertical
scrollbar if these components are visible. The corner component
is not visible if its adjacent components are not visible. The
<TT>ScrollPaneLayout</TT> class will size it to a width and height
of zero, making it not visible.
<H3><A NAME="ScrollingPolicy">
Scrolling Policy</A></H3>
<P>
How the <TT>JScrollPane</TT> class displays its scrollbars can
be configured. The scrollbars can always be displayed, never displayed,
or displayed as required. The &quot;as required&quot; policy will
display scrollbars when the center component's size extends beyond
the viewport's size and hide them when the component is smaller
than this size. The horizontal and vertical scrollbars are hidden
and shown independently of each other.
<P>
Specifying the scrolling policy for instances of the <TT>JScrollPane</TT>
class is done independently for the horizontal and vertical directions.
The <TT>setHorizontalScrollBarPolicy</TT> and <TT>setVerticalScrollBarPolicy</TT>
methods are used to set the policy for each direction. Both of
these methods take a single parameter that is a constant defined
in the <TT>ScrollPaneConstants</TT> interface. Allowed values
for the <TT>setVerticalScrollBarPolicy</TT> method are <TT>VERTICAL_SCROLLBAR_AS_NEEDED</TT>,
<TT>VERTICAL_SCROLLBAR_ALWAYS</TT>, and <TT>VERTICAL_SCROLLBAR_NEVER</TT>.
Similarly, for the <TT>setHorizontalScrollBarPolicy</TT> method
the defined constants for the scrolling policy are <TT>HORIZONTAL_SCROLLBAR_AS_NEEDED</TT>,
<TT>HORIZONTAL_SCROLLBAR_ALWAYS</TT>, and <TT>HORIZONTAL_SCROLLBAR_NEVER</TT>.
There are also versions of the <TT>JScrollPane</TT> class's constructor
that allow the scrolling policy to be specified. The scrolling
policy for each direction can be independently queried by using
the <TT>getHorizontalScrollBarPolicy</TT> and getVerticalScrollBarPolicy
methods. The default scrolling policy is &quot;as needed&quot;
in both directions. The scrolling policy of each direction is
a bound property of the <TT>JScrollPane</TT> class.
<P>
A handle to each individual scrollbar can be obtained via the
<TT>getHorizontalScrollBar</TT> and <TT>getVerticalScrollBar</TT>
methods. Once this handle is obtained, the methods in the <TT>JScrollBar</TT>
class can be called directly. For example, it is often desirable
to set the unit and block increments via the <TT>setUnitIncrement</TT>
and <TT>setBlockIncrement</TT> methods defined in the <TT>JScrollBar</TT>
class for the scrollbars.
<H3><A NAME="SpecifyingRowandColumnHeadings">
Specifying Row and Column Headings</A></H3>
<P>
The methods to set the headings in a scroll pane are named <TT>setRowHeader</TT>
and <TT>setColumnHeader</TT>. These names suggest tabular data
in the scroll pane, but this does not have to be the case. These
methods take an instance of the <TT>JViewport</TT> class and set
it as the header in the appropriate direction. When a column header
view is set, it scrolls right and left in sync with the main view,
but it doesn't scroll up or down. Similarly, a row header view
scrolls up and down with the main view, but does not scroll right
or left. The current headers can be queried via the <TT>getRowHeader</TT>
and <TT>getColumnHeader</TT> methods. Each of these methods returns
<TT>null</TT> if a header has not been specified for that axis.
Both the <TT>rowHeader</TT> and <TT>columnHeader</TT> properties
are bound in the <TT>JScrollPane</TT> class.
<P>
As was mentioned in the previous paragraph, the <TT>setRowHeader</TT>
and <TT>setColumnHeader</TT> methods require a viewport as their
parameter. The <TT>setRowHeaderView</TT> and <TT>setColumnHeaderView</TT>
methods allow any component to be specified for the header. These
methods will create a viewport if necessary and will set the given
component as the view for the viewport. If a column header had
been previously specified, it is reused by setting its view property
to the component passed as the argument to these methods. <P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Using either of the <TT>setRowHeaderView</TT> or <TT>setColumnHeaderView</TT> methods can cause difficulty when replacing a header. Since the existing viewport is reused, a view header property change event is not fired by the <TT>JScrollPane</TT> class. Since the <TT>JViewport</TT> class does not fire a property change event when its view is changed, there is no way to be informed of this change. This condition is exacerbated by the fact that a property change event is fired if a header has not already been set for the scroll pane. This appears to be a bug rather than a feature.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Header views can be added to the <TT>ScrollPaneTest</TT> application
presented earlier in this chapter by adding the following lines
of code after the scroll pane has been created. The resulting
scroll pane is shown in Figure 15.4.
<P>
<A HREF="javascript:popUp('f15-4.gif')"><B>Figure 15.4 :</B> <I>Headers added to the ScrollPaneTest application</I>.</A>
<BLOCKQUOTE>
<PRE>
scrollPane.setColumnHeaderView( 
                new JLabel( &quot;Column Header&quot;, SwingConstants.CENTER )
);scrollPane.setRowHeaderView( new JLabel( &quot;Row Header&quot; ) );
</PRE>
</BLOCKQUOTE>
<H3><A NAME="SpecifyingCornerComponents">
Specifying Corner Components</A></H3>
<P>
When a <TT>JScrollPane</TT> instance contains headers and scrollbars,
there is a gap in the corners of the scroll pane where these components
meet. A component can be specified that is placed into each corner
with the <TT>setCorner</TT> method. This single method is used
to set the component in any of the corners. The first parameter
to this method must be one of the corner location constants defined
in the <TT>ScrollPaneConstants</TT> interface. The constants are
<TT>LOWER_LEFT_CORNER</TT>, <TT>LOWER_RIGHT_CORNER</TT>, <TT>UPPER_LEFT_CORNER</TT>,
and <TT>UPPER_RIGHT_CORNER</TT>. Notice that these and the other
scrollbar constants are defined in the <TT>ScrollPaneConstants</TT>
interface, not the <TT>SwingConstants</TT> interface. The size
of the corner component is determined by the available space due
to the height and width of the headers and/or scrollbar that the
corner is next to. The default scroll pane layout manager ignores
the preferred size of the corner component itself. The current
component defined for a corner can be queried with the <TT>getCorner</TT>
method. The corner being queried is also specified with one of
the corner constants defined in the <TT>ScrollPaneConstants</TT>
interface. The corner components are bound properties in the <TT>JScrollPane</TT>
class.
<P>
The following lines of code will add corner components to the
<TT>ScrollPaneTest</TT> application. Each corner is a different
color to make it obvious when each corner is visible. It is instructive
to resize the application to display and hide the scrollbars to
see when the corners are displayed. Removing one and then the
other header and then both headers and executing the application
will give all possible cases for corner components being displayed.
The resulting scroll pane is shown in Figure 15.5.
<P>
<A HREF="javascript:popUp('f15-5.gif')"><B>Figure 15.5 :</B> <I>Corners added to the ScrollPaneTest application</I>.</A>
<BLOCKQUOTE>
<PRE>
JLabel lowerLeftCorner = new JLabel();
lowerLeftCorner.setOpaque( true );
lowerLeftCorner.setBackground( Color.blue );
scrollPane.setCorner( ScrollPaneConstants.LOWER_LEFT_CORNER, 
                      lowerLeftCorner );
                
JLabel lowerRightCorner = new JLabel();
lowerRightCorner.setOpaque( true );
lowerRightCorner.setBackground( Color.yellow );
scrollPane.setCorner( ScrollPaneConstants.LOWER_RIGHT_CORNER, 
                      lowerRightCorner );
        
JLabel upperLeftCorner = new JLabel();
upperLeftCorner.setOpaque( true );
upperLeftCorner.setBackground( Color.green );
scrollPane.setCorner( ScrollPaneConstants.UPPER_LEFT_CORNER, 
                      upperLeftCorner );
                
JLabel upperRightCorner = new JLabel();
upperRightCorner.setOpaque( true );
upperRightCorner.setBackground( Color.red );
scrollPane.setCorner( ScrollPaneConstants.UPPER_RIGHT_CORNER, 
                      upperRightCorner );
					  
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
A current bug in the <TT>ScrollPaneLayout</TT> class causes the wrong component to be removed from the layout. Removing the lower-right component will null the lower-left component, in effect removing the wrong component from the layout manager.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="TTFONTSIZEJComponentFONTTTFONTSIZEScrollingSupportFONT">
<TT>JComponent</TT> Scrolling
Support</A></H2>
<P>
As we saw in <A HREF="..\ch03\ch03.htm" >Chapter 3</A> the <TT>JComponent</TT> class contains
the <TT>autoscrolls</TT> property that is set with the <TT>setAutoscrolls</TT>
method. When this property is <TT>true</TT>, an instance of the
<TT>Autoscroller</TT> class is created for the component. This
class extends the <TT>MouseAdapter</TT> utility class and overrides
the <TT>mouseDragged</TT> method. This method scrolls the component
in the viewport when the mouse is dragged.
<P>
When you are creating a custom component that will likely be contained
in a scrollpane, the class should implement the <TT>Scrollable</TT>
interface shown in Listing 15.2. The methods in this interface
provide hints for the <TT>scrolling</TT> class. Currently four
JFC classes implement this interface. They are the <TT>JTable</TT>,
<TT>JTextComponent</TT>, <TT>JTree</TT>, and <TT>JList</TT> classes.
<P>
<HR>
<P>
<B>Listing 15.2&nbsp;&nbsp;The </B><TT><B>SCROLLABLE</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface Scrollable  
{ 
    /**
     * Returns the preferred size of the viewport for a view component.
     * For example the preferred size of a JList component is the size
     * required to accommodate all of the cells in its list, however the
     * value of preferredScrollableViewportSize is the size required for
     * JList.getVisibleRowCount() rows.   A component without any 
     * properties that would affect the viewport size should just return
     * getPreferredSize() here.
     * 
     * @return The preferredSize of a JViewport whose view is this
     *         Scrollable.
     * @see JViewport#getPreferredSize
     */
    Dimension getPreferredScrollableViewportSize();


    /**
     * Components that display logical rows or columns should compute
     * the scroll increment that will completely expose one new row
     * or column, depending on the value of orientation.  Ideally, 
     * components should handle a partially exposed row or column by 
     * returning the distance required to completely expose the item.
     * &lt;p&gt;
     * Scrolling containers, like JScrollPane, will use this method
     * each time the user requests a unit scroll.
     * 
     * @param visibleRect The view area visible within the viewport
     * @param orientation Either SwingConstants.VERTICAL or
       SwingConstants.HORIZONTAL.
     * @param direction Less than zero to scroll up/left, greater 
     *                  than zero for down/right.
     * @return The &quot;unit&quot; increment for scrolling in the specified 
     *         direction
     * @see JScrollBar#setUnitIncrement
     */
    int getScrollableUnitIncrement( Rectangle visibleRect,
     int orientation, int direction);


    /**
     * Components that display logical rows or columns should compute
     * the scroll increment that will completely expose one block
     * of rows or columns, depending on the value of orientation. 
     * &lt;p&gt;
     * Scrolling containers, like JScrollPane, will use this method
     * each time the user requests a block scroll.
     * 
     * @param visibleRect The view area visible within the viewport
     * @param orientation Either SwingConstants.VERTICAL or 
     *                    SwingConstants.HORIZONTAL.
     * @param direction Less than zero to scroll up/left, greater 
     *                  than zero for down/right.
     * @return The &quot;block&quot; increment for scrolling in the 
     *         specified direction.
     * @see JScrollBar#setBlockIncrement
     */
    int getScrollableBlockIncrement( Rectangle visibleRect, 
                                     int orientation, int direction );


    /**
     * Return true if a viewport should always force the width of this 
     * Scrollable to match the width of the viewport.  For example a 
     * normal text view that supported line wrapping would return true
     * here, since it would be undesirable for wrapped lines to disappear
     * beyond the right edge of the viewport.  Note that returning true
     * for a Scrollable whose ancestor is a JScrollPane effectively
     * disables horizontal scrolling.
     * &lt;p&gt;
     * Scrolling containers, like JViewport, will use this method each 
     * time they are validated.  
     * 
     * @return True if a viewport should force the Scrollables width
     *         to match its own.
     */
    boolean getScrollableTracksViewportWidth();

    /**
     * Return true if a viewport should always force the height of this 
     * Scrollable to match the height of the viewport.  For example a 
     * columnar text view that flowed text in left to right columns 
     * could effectively disable vertical scrolling by returning
     * true here.
     * &lt;p&gt;
     * Scrolling containers, like JViewport, will use this method each 
     * time they are validated.  
     * 
     * @return True if a viewport should force the Scrollables height
     *         to match its own.
     */
    boolean getScrollableTracksViewportHeight();
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The JFC provides rich support for scrolling components. The <TT>JScrollPane</TT>
class manages a viewport, scrollbars, headers, and corner components.
These components work together to allow any component to be scrolled.
The <TT>JViewport</TT> class occupies the center region of the
scroll pane. The viewport can contain a single child. That child
is the component that is scrolled. The viewport acts as a window
where a portion of the child component can be seen. As the component
is scrolled, different portions of the child component are displayed.
A backing store can be used to enhance scrolling. When enabled,
an offscreen image is created and used for painting. The scrolling
policy can be set to only display the scrollbars when they are
needed, to always display the scrollbars, or to never display
the scrollbars. The <TT>JScrollPane</TT> class is a validated
root container.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch14\ch14.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch16\ch16.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
