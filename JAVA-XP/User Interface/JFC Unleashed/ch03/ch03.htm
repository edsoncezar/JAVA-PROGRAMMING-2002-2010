<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 3 - JComponent</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch02\ch02.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch04\ch04.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;3<br>
JComponent</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TopoftheJFCVisualComponentHierarchy">
Top of the JFC Visual Component Hierarchy</A>
<LI><A HREF="#ClientProperties">
Client Properties</A>
<LI><A HREF="#ToolTipSupport">
ToolTip Support</A>
<LI><A HREF="#TTFONTSIZEBorderFONTTTFONTSIZEPropertyFONT">
<TT>Border</TT> Property
</A>
<LI><A HREF="#SizePreferences">
Size Preferences</A>
<LI><A HREF="#KeystrokeHandling">
Keystroke Handling</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEKeyStrokeFONTTTFONTSIZEClassFONT">
The <TT>KeyStroke</TT> Class
</A>
</UL>
<LI><A HREF="#ScrollingSupport">
Scrolling Support</A>
<LI><A HREF="#FocusTransversalSupport">
Focus Transversal Support</A>
<LI><A HREF="#PropertyListenerSupport">
Property Listener Support</A>
<LI><A HREF="#PluggableLookandFeelSupport">
Pluggable Look-and-Feel Support</A>
<LI><A HREF="#MiscellaneousFeatures">
Miscellaneous Features</A>
<UL>
<LI><A HREF="#AccessibilitySupport">
Accessibility Support</A>
<LI><A HREF="#ParentChanges">
Parent Changes</A>
<LI><A HREF="#DebugGraphics">
Debug Graphics</A>
<LI><A HREF="#DoubleBuffering">
Double Buffering</A>
<LI><A HREF="#EfficiencyMethods">
Efficiency Methods</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The <TT>JComponent</TT> class is the root of the visual component
class hierarchy in the JFC. The visual components are known as
the &quot;J&quot; classes. This is because each of the class names
begins with the letter J. As such, the functionality contained
in the <TT>JComponent</TT> class is available to all the visual
components contained in the JFC. The <TT>JComponent</TT> class
turns into a repository of functionality required for all visual
components. This includes keystroke handling, accessibility support,
borders, and much more. This common functionality makes the <TT>JComponent</TT>
class a large and complex one that must be thoroughly understood
to take full advantage of the JFC toolkit. A hint of the complexity
and sheer size of the <TT>JComponent</TT> class is the approximately
30 <TT>javadoc</TT> pages for the class that accompany the JFC
toolkit.
<P>
This chapter will dissect the <TT>JComponent</TT> class, looking
at each segment of its functionality individually. Specifically,
you will see the following:
<UL>
<LI>The visual class hierarchy
<LI>Pluggable look-and-feel support in <TT>JComponent</TT>
<LI>Keystroke handling in <TT>JComponent</TT>
<LI>The <TT>Border</TT> property
<LI>Scrolling support
<LI>Accessibility support
<LI>Internationalization support
</UL>
<H2><A NAME="TopoftheJFCVisualComponentHierarchy">
Top of the JFC Visual Component Hierarchy</A></H2>
<P>
The <TT>JComponent</TT> class sits atop the hierarchy of the visual
classes contained in the JFC. This hierarchy is shown in Figure
3.1. Its position in the hierarchy implies that its functionality
is common to all visual components in the JFC toolkit. This makes
understanding the <TT>JComponent</TT> class critical to taking
full advantage of the JFC toolkit.
<P>
The <TT>JComponent</TT> class is an abstract class that extends
the AWT <TT>Container</TT> class. The <TT>Container</TT> class
extends the AWT <TT>Component</TT> class. In the AWT, there is
a distinction between components that are containers and those
that are not. For example, the AWT <TT>Label</TT> class extends
<TT>Component</TT>. As such, other components cannot be added
to instances of the <TT>Label</TT> class. However, the AWT <TT>Panel</TT>
class extends the <TT>Container</TT> class, which does allow components
to be added to it. Thus, the position in the class hierarchy defines
if a class can act as a container or not. With the <TT>JComponent</TT>
class extending the <TT>Component</TT> class, this distinction
doesn't exist in the JFC. Thus, every <TT>JComponent</TT> is a
container, even though many are not designed to be used as such.
This forces those classes to carry the extra baggage of being
a container, even though it is not used. This is an unfortunate
consequence of the JFC being layered on top of the AWT. Most,
if not all, of the functionality contained in the <TT>JComponent</TT>
class would be better suited in the <TT>Component</TT> class.
<P>
<A HREF="javascript:popUp('f3-1.gif')"><B>Figure 3.1 :</B> <I>JFC visual component class hierarchy</I>.</A>
<H2><A NAME="ClientProperties">
Client Properties</A></H2>
<P>
A client property is a piece of information that can be attached
to an instance of any JFC visual component. The property consists
of a name-value pair. The name is a key that uniquely identifies
the value for a particular instance. Internally, client properties
are implemented as a <TT>Dictionary</TT>, specifically an instance
of the <TT>HashTable</TT> class. Client properties are used internally
by the JFC in many situations. For example, a component's ToolTip,
keyboard bindings, and the next focus component are all stored
as client properties on a component.
<P>
Client properties are not limited to use within the JFC itself.
Components that extend JFC visual components can store data in
client properties as well as arbitrary code that creates and uses
instances of JFC visual components. The former will be discussed
in Part V of this book, &quot;Extending JFC Components,&quot;
while the later will be discussed here.
<P>
An arbitrary <TT>Object</TT> can be associated with a JFC visual
component instance by using the <TT>putClientProperty</TT> method
contained in the <TT>JComponent</TT> class. When the property
is placed on the component, a key is associated with the object.
The client property can be obtained later via the <TT>getClientProperty</TT>
method and the key used when adding the property. A simple example
of using a client property is shown in the following:
<BLOCKQUOTE>
<PRE>
JButton button = new JButton( &quot;Help&quot; );
button.putClientProperty( &quot;SpecialColor&quot;, Color.blue );
Color myColor = ( Color )button.getClientProperty( &quot;SpecialColor&quot; );
</PRE>
</BLOCKQUOTE>
<P>
This example adds a client property with the <TT>String</TT> key
<TT>&quot;SpecialColor&quot;</TT> to an instance of the <TT>JButton</TT>
class. In this example, a string is used as the key, but an arbitrary
object can be used as the key. The property in the example is
a <TT>Color</TT> but, like the key, the property can be of any
type. If the property value is <TT>null</TT> in the <TT>putClientProperty</TT>
call, the property is removed from the instance. However, <TT>null</TT>
cannot be used as the key. If this occurs, a <TT>NullPointerException</TT>
is thrown. The <TT>getClientProperty</TT> method returns the object
associated with the given key for the instance. If there has not
been an object associated with the key, <TT>null</TT> is returned.
Any number of client properties can be added to a component. However,
each property must have a unique key.
<P>
When a client property is set, a <TT>PropertyChange</TT> event
is fired by the component that contains the property. The name
of the property change event is the value returned from the <TT>toString</TT>
method key used to store the client property. This provides a
very versatile mechanism for attaching data to a visual component
and allowing other objects to listen for changes in this property.
<H2><A NAME="ToolTipSupport">
ToolTip Support</A></H2>
<P>
ToolTips are the pop-up windows common in modern user interfaces
that present the user with a short informative message when the
mouse rests over the component. ToolTips are also known as <I>flyover</I>
help. The <TT>JComponent</TT> class contains a client property
for ToolTips. The ToolTip is stored as a client property rather
than a member variable to save space. All <TT>JComponent</TT>
instances do not contain ToolTips, so allocating a reference to
a string in every instance is obsessive.
<P>
The <TT>setToolTipText</TT> method can be used to set the ToolTip
for a J component. The following is a simple example for adding
a ToolTip to a <TT>JButton</TT> instance:
<BLOCKQUOTE>
<PRE>
JButton button = new JButton( &quot;Help&quot; );
button.setToolTipText( &quot;Open the on-line help for this window&quot; );
</PRE>
</BLOCKQUOTE>
<P>
When the <TT>setToolTipText</TT> method is called with a non-<TT>null</TT>
string, the component is registered with the ToolTip manager to
enable ToolTips. If the string is <TT>null</TT>, the component
is removed from the ToolTip manager. The ToolTip manager and its
options are described in <A HREF="..\ch25\ch25.htm" >Chapter 25</A>, &quot;ToolTips and Debug
Graphics.&quot;
<P>
The current value of the <TT>ToolTip</TT> property can be queried
with the <TT>getToolTipText</TT> method. This method returns the
current <TT>String</TT> value of the <TT>ToolTip</TT> client property
or <TT>null</TT> if a ToolTip hasn't been registered for the component.
<P>
There are many situations when the ToolTip for a component is
not static. Instead, it depends on the current state of the component
or where the mouse is located in the component. When creating
components that extend the <TT>JComponent</TT> class, the <TT>getToolTipText</TT>
method that requires a <TT>MouseEvent</TT> as its parameter can
be overridden. In this method, the component determines the ToolTip
for the current state of the component and for the mouse event.
The <TT>String</TT> ToolTip is returned from this method and used
as the ToolTip. The component can also specify where the ToolTip
is to be displayed. The <TT>JComponent</TT> class contains the
<TT>getToolTipLocation</TT> method. The ToolTip manager calls
this method before displaying a ToolTip for the component. If
the method returns <TT>null</TT> as the default implementation
in <TT>JComponent</TT>, the ToolTip manager determines the location
for the ToolTip. However, this method can be overridden to return
a <TT>Point</TT> that the ToolTip manager will use as the location
for the ToolTip. 
<H2><A NAME="TTFONTSIZEBorderFONTTTFONTSIZEPropertyFONT">
<TT>Border</TT> Property
</A></H2>
<P>
The <TT>JComponent</TT> class contains a <TT>Border</TT> property.
This property refers to a class that implements the <TT>Border</TT>
interface. When a border has been specified for a component, the
component handles painting the border.
<P>
Having a <TT>Border</TT> property in the <TT>JComponent</TT> class
provides an easy mechanism for adding a border to any <TT>JComponent</TT>
instance. Moreover, since a <TT>JComponent</TT> is a <TT>Container</TT>,
it provides an easy mechanism for adding a border to a group of
components. For example, Figure 3.2 shows the results of running
the following code:
<BLOCKQUOTE>
<PRE>
JPanel panel = new JPanel();
panel.setLayout( new GridLayout( 3, 2 ) );
JLabel label = new JLabel( &quot;First Name&quot; );
panel.add( label );
JTextField firstNameText = new JTextField();
panel.add( firstNameText );
label = new JLabel( &quot;Last Name&quot; );
panel.add( label );
JTextField lastNameText = new JTextField();
panel.add( lastNameText );
label = new JLabel( &quot;Age&quot; );
panel.add( label );
JTextField ageText = new JTextField();
panel.add( ageText );
panel.setBorder( BorderFactory.createTitledBorder( &quot;Age Data&quot; ) );
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f3-2.gif')"><B>Figure 3.2 :</B> <I>Border around multiple components</I>.</A>
<P>
In the figure, a titled border is placed around a <TT>JPanel</TT>
instance that contains labels and text fields. A border is added
to a component by using the <TT>setBorder</TT> method contained
in the <TT>JComponent</TT> class. The <TT>Border</TT> property
is a bound property of a <TT>JComponent</TT> with the name <TT>border</TT>.
Unfortunately, at the time of this writing, the property names
are hard coded in the <TT>JComponent</TT> class rather than defining
constants with the property name. The complete list of bound properties
defined in the <TT>JComponent</TT> class is presented in Table
3.1 later in this chapter. Setting the border will invalidate
the component. Similarly, the current border can be queried by
using the <TT>getBorder</TT> method. In the example, only one
component contains a border; however, any number of components
can contain a border to achieve the desired visual effect.
<P>
A complete description of creating and using borders is presented
in <A HREF="..\ch05\ch05.htm" >Chapter 5</A> &quot;Basic Components.&quot;
<P>
The <TT>Border</TT> property has another roll in the <TT>JComponent</TT>
class. When a border has been set for a <TT>JComponent</TT> instance,
the size of the border is used as the <TT>insets</TT> property
for that component. Recall that <TT>JComponent</TT> extends the
AWT <TT>Container</TT> class, so even JFC classes that aren't
typically used as containers have the <TT>insets</TT> property.
When the <TT>getInsets</TT> method of the <TT>JComponent</TT>
class is called, it first checks if the border has been set. If
so, the border's <TT>Insets</TT> are returned to the caller. If
not, the <TT>Insets</TT> from the <TT>getInsets</TT> method of
its parent class, <TT>Container</TT>, are returned.
<H2><A NAME="SizePreferences">
Size Preferences</A></H2>
<P>
<TT>AWT</TT> components contain the trio of methods <TT>getPreferredSize</TT>,
<TT>getMinimumSize</TT>, and <TT>getMaximumSize</TT> to aid layout
managers when they are arranging containers. In these methods,
the component is to determine the requested size based on its
current state. For example, the <TT>JLabel</TT> class determines
its preferred size based on its font and text that needs to be
displayed. By default the <TT>JComponent</TT> class behaves the
same as the AWT <TT>Component</TT> class for size calculations.
However, <TT>JComponent</TT> adds the <TT>setPreferredSize</TT>,
<TT>setMinimumSize</TT>, and <TT>setMaximumSize</TT> methods for
setting the sizes. If one of the sizes has been explicitly set
via one of these methods, the associated &quot;get&quot; method
returns that size, rather than computing the size based on state.
Thus the value specified in the &quot;set&quot; method takes precedence
over a calculated value.
<P>
After having learned from the AWT that hard-coding component sizes
is bad and that the preferred technique is to dynamically determine
size based on font, screen resolution, and so on, why has the
JFC changed the rules? The truth of the matter is that the rules
have not changed. Everything you have learned about dynamically
determining a component's size still applies. However, the JFC
gives you the flexibility to alter the sizing behavior of a component
that the layout manager will use. For example, you may want a
certain label to always occupy at least the left 25 percent of
a container, regardless of the text it contains. This functionality
can be achieved easily by using the <TT>setMinumumSize</TT> method
of the label. Also, some classes of components, such as a <TT>JViewPort</TT>,
don't have natural minimum, maximum, or preferred sizes. You may
want to set these sizes to achieve the desired layout of a container.
<P>
After a size has been explicitly set by using one of the &quot;set&quot;
methods, setting the size to <TT>null</TT> will restore default
behavior. This allows size overriding to be turned on and off
via any of the setter methods.
<P>
Each of the three sizes is a bound property in the <TT>JComponent</TT>
class. A complete list of bound properties defined in the <TT>JComponent</TT>
class is presented in Table 3.1 later in this chapter.
<H2><A NAME="KeystrokeHandling">
Keystroke Handling</A></H2>
<P>
The <TT>JComponent</TT> class provides a wealth of keystroke handling
functionality. These methods provide a much higher level interface
than processing individual keystroke events in a subclass of <TT>JComponent</TT>.
You are also able to set which action is executed for a keystroke
that occurs in a <TT>JComponent</TT> without having to subclass
the component.
<P>
The <TT>registerKeyboardAction</TT> method is used to bind a <TT>KeyStroke</TT>
to an <TT>ActionListener</TT>. When the <TT>KeyStroke</TT> is
detected, the <TT>actionPerformed</TT> method of the <TT>ActionListener</TT>
is called. Registering a keyboard action for a component enables
keyboard events for that component. Internally, the <TT>JComponent</TT>
class stores a <TT>Hashtable</TT> of registered keyboard actions
as a client property. One of three conditions can be specified
when binding the <TT>KeyStroke</TT> with the <TT>ActionListener</TT>.
<P>
The first, <TT>WHEN_FOCUSED</TT>, requires that the <TT>KeyStroke</TT>
event occur in the component when it has the keyboard focus for
the action to be invoked. The second, <TT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</TT>,
will invoke the action if the component is the ancestor of the
component with the focus or is itself the focus component. This
condition is useful for registering keystroke actions on a dialog
box for dialog box default behavior. For example, the Escape key
could be mapped to the cancel action in the content pane of a
<TT>JDialog</TT> instance. Then, when this key is typed in any
<TT>JComponent</TT> in the dialog box, the cancel action would
be invoked. The last condition, <TT>WHEN_IN_FOCUSED_WINDOW</TT>,
will invoke the action if the component is in the same window
as the component where the <TT>KeyStroke</TT> was entered. This
is convenient when you do not want to register the keystrokes
at the top of a containment hierarchy. The same effect can be
achieved by having a cancel button that registers the close action
to the escape <TT>KeyStroke</TT> with the <TT>WHEN_IN_FOCUSED_WINDOW</TT>
condition. In this situation, when the escape key is pressed in
any <TT>JComponent</TT> in the dialog box, the cancel button's
close action would be invoked. Let's look at an example of each
of these cases.
<P>
The first example, shown next, registers a keyboard action to
the <TT>ageText</TT> <TT>JTextField</TT> component shown in Figure
3.2. This code will cause the <TT>textActionListener</TT>'s <TT>actionPerformed</TT>
method to be called whenever the Escape key is entered in the
<TT>ageText</TT> component and only in the <TT>ageText</TT> component.
<BLOCKQUOTE>
<PRE>
ActionListener textActionListener = new ActionListener () { 
    public void actionPerformed( ActionEvent event ) { 
        System.out.println( &quot;textActionListener &quot; + event );
    } 
} ;
        
ageText.registerKeyboardAction( textActionListener,
                             KeyStroke.getKeyStroke( KeyEvent.VK_ESCAPE, 0 ),
                             JComponent.WHEN_FOCUSED );
</PRE>
</BLOCKQUOTE>
<P>
This code example introduces two new classes; <TT>KeyStroke</TT>
and <TT>KeyEvent</TT>. The <TT>KeyStroke</TT> class is part of
the JFC, and the <TT>KeyEvent</TT> class is part of the AWT. A
complete discussion of the <TT>KeyEvent</TT> class is beyond the
scope of this book. However, it is sufficient to say that the
<TT>KeyEvent</TT> class contains virtual bindings for keystrokes.
These are defined with constants defined in the class. Each virtual
key constant begins with the <TT>VK_</TT> preface. Using the constants
defined in the <TT>KeyEvent</TT> class will ensure that your application
is not dependent on a particular keystroke mapping. The previous
example uses the <TT>VK_ESCAPE</TT> constant that, as its name
implies, represents the Escape key.
<P>
The second class introduced in the previous example is the JFC
<TT>KeyStroke</TT> class. This class encapsulates a key being
typed on the keyboard and is the subject of the next section.
<P>
Changing the condition in the <TT>registerKeyboardAction</TT>
method from <TT>WHEN_FOCUS</TT> to <TT>WHEN_IN_FOCUSED_WINDOW</TT>,
shown next, will cause the <TT>textActionListener</TT> to get
called when the Escape key is entered in any of the <TT>JTextField</TT>
instances in the panel. If there were more components in the same
window as the <TT>ageText</TT> component, the Escape key being
typed in any of those components would cause the <TT>textActionListener</TT>
to be invoked.
<BLOCKQUOTE>
<PRE>
ageText.registerKeyboardAction( textActionListener,
                          KeyStroke.getKeyStroke( KeyEvent.VK_ESCAPE, 0 ),
                          JComponent.WHEN_IN_FOCUSED_WINDOW );
</PRE>
</BLOCKQUOTE>
<P>
A similar effect can be obtained by changing the <TT>WHEN_IN_FOCUSED_WINDOW</TT>
condition to <TT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</TT> and registering
the keyboard action with the <TT>JPanel</TT> instance instead
of the <TT>ageText</TT> <TT>JTextField</TT> instance.
<BLOCKQUOTE>
<PRE>
panel.registerKeyboardAction( textActionListener,
                              KeyStroke.getKeyStroke( KeyEvent.VK_ESCAPE, 0 ),
                              JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT );
</PRE>
</BLOCKQUOTE>
<P>
Because the three <TT>JTextField</TT> instances in this example
are children of the <TT>JPanel</TT> instance, the <TT>textActionListener</TT>
is invoked when the Escape key is entered in any of the instances.
Unlike the previous example, if there were other panels that were
siblings to this panel, the <TT>textActionListener</TT> would
not be invoked if the Escape key was entered in the sibling panels.
However, if the other components were also children of the panel,
the <TT>textActionListener</TT> would be invoked.
<P>
It is interesting to notice that the source of the event delivered
to the <TT>ActionListener</TT> is the component on which the keyboard
action is registered. This may or may not be the component where
the event originated. For instance, in the previous example the
source of the event is the <TT>JPanel</TT> instance, not the <TT>JTextField</TT>
instance where the keystroke was typed.
<P>
There is an overloaded version of the <TT>registerKeyboardAction</TT>
method that contains a <TT>String</TT> parameter. This method's
signature is shown next. When this version of the method is used,
the <TT>String</TT> parameter is specified as the action command
in the <TT>ActionEvent</TT> delivered to the <TT>ActionListener</TT>
when the <TT>KeyStroke</TT> is received.
<BLOCKQUOTE>
<PRE>
public void registerKeyboardAction(ActionListener anAction, String aCommand,
                                   KeyStroke aKeyStroke, int aCondition )
</PRE>
</BLOCKQUOTE>
<P>
If a keyboard action is registered on a component that exactly
matches an existing keyboard action registered for that component,
the new action replaces the old action. The <TT>KeyStroke</TT>
must exactly match the existing <TT>KeyStroke</TT>, including
modifiers.
<P>
A keyboard action can be removed from a component by using the
<TT>unregisterKeyboardAction</TT> method. This method requires
one parameter, the <TT>KeyStroke</TT> that fires the action. If
there is not an action registered for the <TT>KeyStroke</TT> instance
specified in the <TT>unregisterKeyboardAction</TT> call, the method
does nothing. All registered keyboard actions can be removed from
an instance of a <TT>JComponent</TT> by using the <TT>resetKeyboardActions</TT>
method. This method clears the <TT>Hashtable</TT> used internally
to store registered <TT>KeyStroke</TT>s.
<P>
The keystrokes registered on a <TT>JComponent</TT> instance can
be queried with the <TT>getRegisteredKeyStrokes</TT> method. This
method returns an array of <TT>KeyStroke</TT> instances. As mentioned
earlier in this section, the keyboard actions are stored in a
<TT>Hashtable</TT> client property in the <TT>JComponent</TT>
class. Thus the <TT>Hashtable</TT> is enumerated and its elements
are stored in an array before being returned to the caller. If
there are no keyboard actions registered for the instance, an
empty array (an array of length <TT>0</TT>) is returned.
<P>
The condition for a <TT>KeyStroke</TT> can be queried by using
the <TT>getConditionForKeyStroke</TT> method. This method takes
the <TT>KeyStroke</TT> to be checked as a parameter and returns
the condition specified for that <TT>KeyStroke</TT>, or <TT>UNDEFINED_CONDITION</TT>
if the <TT>KeyStroke</TT> has not been registered for the <TT>JComponent</TT>.
<P>
The action that will be invoked when a <TT>KeyStroke</TT> is received
in a <TT>JComponent</TT> instance can be queried with the <TT>getActionForKeyStroke</TT>
method. This method takes a <TT>KeyStroke</TT> instance and returns
the <TT>ActionListener</TT> whose <TT>actionPerformed</TT> method
will be called when the <TT>KeyStroke</TT> with proper modifiers
is entered. If an action is not registered for the given <TT>KeyStroke</TT>,
<TT>null</TT> is returned.
<H3><A NAME="TheTTFONTSIZEKeyStrokeFONTTTFONTSIZEClassFONT">
The <TT>KeyStroke</TT> Class
</A></H3>
<P>
A <TT>KeyStroke</TT> instance contains its key character, key
code, modifiers, and a flag for key pressed or released state.
The key character is the character representation of the <TT>KeyStroke</TT>
instance. The key code is the integer code defined in the <TT>KeyEvent</TT>
class. The modifier field represents any modifier for the <TT>KeyStroke</TT>.
Common modifiers are the Ctrl and Alt keys. The final field represents
if the <TT>KeyStroke</TT> instance is a key pressed or key released
keystroke.
<P>
The application does not create <TT>KeyStroke</TT> instances.
Instead, the <TT>KeyStroke</TT> class caches instances, and the
application obtains a handle to a <TT>KeyStroke</TT> instance
with one of the overloaded <TT>getKeyStroke</TT> methods. These
methods are <TT>public</TT> <TT>static</TT> methods, allowing
them to be called from any other class. There are currently five
variants of the <TT>getKeyStrokeMethod</TT>, shown next.
<BLOCKQUOTE>
<PRE>
public static KeyStroke getKeyStroke(char keyChar)
public static KeyStroke getKeyStroke(char keyChar, boolean onKeyRelease)
public static KeyStroke getKeyStroke(int keyCode, int modifiers, boolean onKeyRelease)
public static KeyStroke getKeyStroke(int keyCode, int modifiers)
public static KeyStroke getKeyStroke(String representation)
</PRE>
</BLOCKQUOTE>
<P>
These access methods match nicely to the attributes within a <TT>KeyStroke</TT>
instance. The possible modifiers for variants that take a modifier
are <TT>java.awt.Event.SHIFT_MASK</TT>, <TT>java.awt.Event.CTRL_MASK</TT>,
<TT>java.awt.Event.META_MASK</TT>, <TT>java.awt.Event.ALT_MASK</TT>.
A <TT>KeyStroke</TT> without a modifier is specified by using
<TT>0</TT> for the modifier. The modifiers can be logically <TT>OR</TT>ed
together to specify multiple modifiers. For example, to obtain
the <TT>KeyStroke</TT> for the popular command Ctrl+Alt+Delete
<TT>KeyStroke</TT> would be as follows:
<P>
<TT>KeyStroke.getKeyStroke( KeyEvent.VK_DELETE,
CTRL_MASK | ALT_MASK ),</TT>
<P>
At the time of this writing, the <TT>getKeyStroke</TT> method
taking a <TT>String</TT> parameter is not implemented.
<P>
The <TT>KeyStroke</TT> class defines a convenience method, <TT>getKeyStrokeForEvent</TT>,
that will extract the <TT>KeyStroke</TT> from a <TT>KeyEvent</TT>.
The following is the method's signature:
<P>
<TT>public static KeyStroke getKeyStrokeForEvent(KeyEvent
anEvent)</TT>
<P>
Once a <TT>KeyStroke</TT> instance is in hand, access methods
defined in the <TT>KeyStroke</TT> class can be used to query the
instance's attributes. These methods are:
<BLOCKQUOTE>
<PRE>
public char getKeyChar()
public int getKeyCode()
public int getModifiers()
public boolean isOnKeyRelease()
</PRE>
</BLOCKQUOTE>
<P>
You should notice that there are no corresponding setter methods
for the attributes. <TT>KeyStroke</TT> instances are immutable.
This allows the instances to be cached and shared. If the instances
were not immutable, one method could change the <TT>KeyStroke</TT>
that is shared between many methods in an application. This of
course could have disastrous consequences.
<H2><A NAME="ScrollingSupport">
Scrolling Support</A></H2>
<P>
The JFC provides traditional scrolling of any component by using
the <TT>JScrollPane</TT> and <TT>JViewport</TT> classes. Once
the component is placed in a viewport contained in a scroll pane,
scrollbars can be used to translate the view of the component.
The <TT>JComponent</TT> class also supports autoscrolling. When
the <TT>JComponent</TT> instance has autoscrolling enabled, the
component will scroll when the mouse is dragged in the component.
Thus, with autoscrolling enabled, the user of the application
can scroll the component by dragging the mouse from within the
component. With autoscrolling enabled, the scrollbars are not
required; however, they can be used as normal.
<P>
The <TT>setAutoscrolls</TT> method is used to enable or disable
autoscrolling for a <TT>JComponent</TT> instance. This method
takes one <TT>boolean</TT> parameter. Passing <TT>true</TT> enables
autoscrolling, and <TT>false</TT> disables autoscrolling. The
<TT>getAutoscrolls</TT> method is used to query the current state
of autoscrolling. Notice that the method is <TT>getAutoscrolls</TT>
and not <TT>isAutoscrolling</TT> as you might have expected. Also,
autoscrolling is not a bound property in the <TT>JComponent</TT>
class.
<P>
The autoscrolling feature gives the <TT>JComponent</TT> developer
a tremendous amount of power from within the toolkit itself. A
complete autoscrolling example will be presented in <A HREF="..\ch15\ch15.htm" >Chapter 15</A>,
&quot;Scrolling Components.&quot;
<P>
When a <TT>JComponent</TT> is contained in a <TT>JViewport</TT>
instance contained in a <TT>JScrollPane</TT> instance, the <TT>scrollRectToVisible</TT>
method can be used to programmatically display any portion of
the component in the viewport. This method climbs the <TT>JComponent</TT>
instance's lineage until the viewport containing the instance
is found. Once the viewport is found, the <TT>scrollRectToVisible</TT>
of the viewport is called. The <TT>scrollRectToVisible</TT> takes
one parameter, an AWT <TT>Rectangle</TT> instance. The coordinates
of the rectangle are translated as the search up the parent hierarchy
is performed.
<H2><A NAME="FocusTransversalSupport">
Focus Transversal Support</A></H2>
<P>
The JFC contains a default focus manager that will determine which
component will obtain the focus when a focus transversal request
is made. The default focus manager will determine the next component
to receive input focus and transfer focus to that component. The
default search algorithm is a top-to-bottom, left-to-right search.
The search algorithm can be modified by altering the focus manager
itself, or by having the components in the view contain hints
for the focus manager. The focus manager is discussed in detain
in <A HREF="..\ch26\ch26.htm" >Chapter 26</A>, &quot;Focus Managers.&quot;
<P>
The <TT>JComponent</TT> class contains the <TT>setNextFocusableComponent</TT>
method to set the component that should receive the input focus
after the component whose property was set. This method takes
a single component as an argument that is stored in a client property
in the <TT>JComponent</TT>. Calling this method with a <TT>null</TT>
parameter will clear the property. The focus manager calls the
<TT>getNextFocusableComponent</TT> method to retrieve the component
that should receive the focus next. If this method returns <TT>null</TT>,
the focus manager determines the next component to receive focus
by itself. This is a <TT>public</TT> method, so it can be called
by classes other than the focus manager if required.
<P>
The default focus transversal order for the <TT>JTextField</TT>
instances shown in Figure 3.2 can be reversed by using the code
shown next. This example demonstrates that care must be taken
when setting the next focus component. It is very easy to create
a focus transversal order that isn't expected by the user. This
will make your application difficult to use.
<BLOCKQUOTE>
<PRE>
firstNameText.setNextFocusableComponent( ageText );
lastNameText.setNextFocusableComponent( firstNameText );
ageText.setNextFocusableComponent( lastNameText );<BR>
</PRE>
</BLOCKQUOTE>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
A bug in the <TT>DefaultFocusManager </TT>that is used by the JFC throws an array out-of-bounds exception when a next focus component has been set by using the <TT>setNextFocusableComponent </TT>method.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>isFocusTraversable</TT> method can be called to determine
if a <TT>JComponent</TT> instance can acquire the input focus.
Subclasses may need to override this method to return <TT>true</TT>
if they can obtain the input focus. The default implementation
in the <TT>JComponent</TT> class will only return <TT>true</TT>
if a registered <TT>KeyStroke</TT> action has the <TT>WHEN_FOCUSED</TT>
condition. Subclasses may also need to override the <TT>isFocusCycleRoot</TT>
method. When this method returns <TT>true</TT>, it tells the focus
manager that this component contains its own focus cycle. This
will keep the focus cycling within this component and not departing
to other components on the next focus component event. The default
implementation of this method returns <TT>false</TT>. A <TT>JComponent</TT>
instance can manage its own focus by returning <TT>true</TT> from
the <TT>isManagingFocus</TT> method. When this is the case, the
focus manager will ignore focus transversal events in that component.
It is the responsibility of the component to handle these events
properly. The default implementation of this method in the <TT>JComponent</TT>
class returns <TT>false</TT>.
<P>
A component can ask the focus manager for the input focus or to
give focus to a component by calling the <TT>requestFocus</TT>
method. However, the component must have the <TT>requestFocuesEnabled</TT>
property set to <TT>true</TT> for this method to succeed. The
<TT>setRequestFocusEnabled</TT> method can be used to enable or
disable the <TT>requestFocusEnabled</TT> property. Its default
value is <TT>true</TT>, allowing the focus to be requested for
the component. The current state of this property can be queried
by using the <TT>isRequestFocusEnabled</TT> method. The <TT>requestFocusEnabled</TT>
property is not bound. It should be noted that setting this property
to <TT>false</TT> does not disable the component from receiving
the focus, only from receiving it programmatically via the <TT>requestFocus</TT>
method. As was shown earlier, the <TT>isFocusTraversable</TT>
method can be used to disable a component from receiving the input
focus. The <TT>hasFocus</TT> method can be used to determine if
a component currently has the input focus. The <TT>requestDefaultFocus</TT>
can be called on a container to give the input focus to the component
that is the default for that container. For example, the default
focus component on a dialog box can be the OK button.
<H2><A NAME="PropertyListenerSupport">
Property Listener Support</A></H2>
<P>
The JFC visual components are compliant with the JavaBeans specification.
The <TT>JComponent</TT> class contains the methods for manipulating
property change listeners and convenience methods for sending
notifications to the listeners. Recall that a property change
listener can register with an object and be notified when a bound
property in that object changes. There are two types of property
change listeners: <TT>PropertyChangeListener</TT> and <TT>VetoableChangeListener</TT>.
A <TT>PropertyChangeListener</TT> simply receives notifications
when properties change in the object that the listener registered
with. A <TT>VetoableChangeListener</TT> can take a more active
role in the changing of the property. When a vetoable listener
receives a change notification, it may throw a <TT>PropertyVetoException</TT>
to abort the property change in the object to which it was listening.
A complete description of the property change protocol is beyond
the scope of this book but can be obtained from the JavaBeans
specification.
<P>
Since the <TT>JComponent</TT> class is the root of the visual
component hierarchy in the JFC toolkit, it makes sense for this
class to contain the methods to add and remove property change
listeners. The <TT>JComponent</TT> class contains the required
<TT>add</TT> and <TT>remove</TT> methods that are compliant with
the <TT>JavaBeans</TT> specification. The signatures for these
methods are as follows:
<BLOCKQUOTE>
<PRE>
public void addPropertyChangeListener(
    java.beans.PropertyChangeListener listener)
public void removePropertyChangeListener(
    java.beans.PropertyChangeListener listener)
public void addVetoableChangeListener(
    java.beans.VetoableChangeListener listener)
public void removeVetoableChangeListener(
    java.beans.VetoableChangeListener listener)
</PRE>
</BLOCKQUOTE>
<P>
The bound properties in <TT>JComponent</TT> are presented in Table
3.1. You will immediately see that all of the property names are
not defined as constants in this class or any other class or interface.
This forces you to embed the <TT>String</TT> property name somewhere
in your code, either where you use the property or in a constant
that you define. This is incredibly poor programming practice
whose example should not be followed in your code. As developers,
I think we should expect more from a core toolkit such as the
JFC. The <TT>JComponent</TT> properties are not vetoable. The
concrete subclass of the <TT>JComponent</TT> class that your code
is listening for property change events from may define additional
properties as well as those defined in the <TT>JComponent</TT>
class. You are guaranteed that all the &quot;J&quot; visual components
contain these bound properties.<BR>
<P>
<CENTER><B>Table 3.1&nbsp;&nbsp;Bound Properties Defined in the
</B><TT><B>JCOMPONENT</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=197><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>UI</TT></TD><TD WIDTH=197><TT>setUI</TT>
</TD><TD WIDTH=197><TT>not available</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>PreferredSize</TT></TD><TD WIDTH=197><TT>setPreferredSize</TT>
</TD><TD WIDTH=197><TT>getPreferredSize</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>MaximumSize</TT></TD><TD WIDTH=197><TT>setMaximumSize</TT>
</TD><TD WIDTH=197><TT>getMaximumSize</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>MinimumSize</TT></TD><TD WIDTH=197><TT>setMinimumSize</TT>
</TD><TD WIDTH=197><TT>getMinimumSize</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Border</TT></TD><TD WIDTH=197><TT>setBorder</TT>
</TD><TD WIDTH=197><TT>getBorder</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Opaque</TT></TD><TD WIDTH=197><TT>setOpaque</TT>
</TD><TD WIDTH=197><TT>isOpaque</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Ancestor</TT></TD><TD WIDTH=197><TT>addNotify</TT>
</TD><TD WIDTH=197><TT>getParent</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Ancestor</TT></TD><TD WIDTH=197><TT>removeNotify</TT>
</TD><TD WIDTH=197><TT>getParent</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>property key name</TT></TD><TD WIDTH=197><TT>putClientProperty</TT>
</TD><TD WIDTH=197><TT>getClientProperty</TT></TD></TR>
</TABLE></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The property change support contained in the <TT>JComponent </TT>class is to migrate to the AWT <TT>Component </TT>class in a future release of the JDK.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>add</TT> and <TT>remove</TT> families of methods are <TT>public</TT>
methods that are used by clients of the component. The <TT>JComponent</TT>
class also defines a family of <TT>protected</TT> methods that
fire the property change events. These methods simplify property
management for subclasses of the <TT>JComponent</TT> class. The
convenience methods are listed next. Notice how there are <TT>firePropertyChange</TT>
methods that take intrinsic types as parameters. These <TT>fire</TT>
methods create the objects of the corresponding type for the caller
before firing the actual event. It is interesting to notice that
the corresponding methods are not provided for firing vetoable
events.
<BLOCKQUOTE>
<PRE>
firePropertyChange(String propertyName, Object oldValue, Object newValue) 
firePropertyChange(String propertyName, byte oldValue, byte newValue) 
firePropertyChange(String propertyName, char oldValue, char newValue) 
firePropertyChange(String propertyName, short oldValue, short newValue) 
firePropertyChange(String propertyName, int oldValue, int newValue) 
firePropertyChange(String propertyName, long oldValue, long newValue) 
firePropertyChange(String propertyName, float oldValue, float newValue) 
firePropertyChange(String propertyName, double oldValue, double newValue) 
firePropertyChange(String propertyName, boolean oldValue, boolean newValue) 

fireVetoableChange(String propertyName, Object oldValue, Object newValue)
</PRE>
</BLOCKQUOTE>
<P>
You will see these methods again in Part V of this book when you
are creating your own <TT>JComponent</TT> subclasses.
<H2><A NAME="PluggableLookandFeelSupport">
Pluggable Look-and-Feel Support</A></H2>
<P>
The <TT>JComponent</TT> class is where the pluggable look-and-feel
support is located. The <TT>JComponent</TT> class defines the
methods that subclasses must override if they support the pluggable
look-and-feel architecture. The <TT>UIManager</TT> uses these
methods to determine the user interface class for instances. They
are typically used when an instance is created to initialize the
user interface and when the look-and-feel changes for the application.
The <TT>UIManager</TT> is discussed in <A HREF="..\ch30\ch30.htm" >Chapter 30</A>, &quot;Pluggable
Look-and-Feel.&quot;
<P>
The <TT>getUIClassID</TT> method returns the <TT>String</TT> class
name for the look-and-feel class for the component. This <TT>String</TT>
is actually a key into the look-and-feel user interface table
contained in the <TT>UIManager</TT>. The value associated with
this key will determine the user interface class for the component.
A complete reference to how the user-interface object is created
for a component is presented in Part V of this book. When the
component's look-and-feel needs changing, the public <TT>updateUI</TT>
method is called. This method must query the <TT>UIManager</TT>
for the current user interface for the class and then set the
user interface for itself. The <TT>updateUI</TT> method is nearly
identical in all <TT>JComponent</TT> sub-classes. A typical example,
from the <TT>JLabel</TT> class, is shown next. The <TT>update</TT>
method is required to allow a type-safe <TT>setUI</TT> method.
<BLOCKQUOTE>
<PRE>
public void updateUI() { 
    setUI((LabelUI)UIManager.getUI(this));
    invalidate();
} 
</PRE>
</BLOCKQUOTE>
<P>
Subclasses of <TT>JComponent</TT> override the <TT>setUI</TT>
method and change the user interface parameter to the specific
type required for that component. The subclass then calls its
parent's <TT>setUI</TT> method. This allows the <TT>setUI</TT>
method to be type safe while still allowing the functionality
to be encapsulated in the <TT>JComponent</TT> class. The following
is the <TT>setUI</TT> method in the <TT>JLabel</TT> class:
<BLOCKQUOTE>
<PRE>
public void setUI(LabelUI ui) { 
    super.setUI(ui);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setUI</TT> method contained in the <TT>JComponent</TT>
class is shown next. It takes a <TT>ComponentUI</TT> instance
as a parameter. The other user interface classes must extend this
class for the user interface methods in the JFC to work. This
method un-installs the current user interface and then installs
the new user interface. As we saw in the previous section, the
user interface is a bound property.
<BLOCKQUOTE>
<PRE>
protected void setUI(ComponentUI newUI) { 
    /* We do not check that the UI instance is different
     * before allowing the switch in order to enable the
     * same UI instance *with different default settings*
     * to be installed.
     */
    if (ui != null) { 
        ui.uninstallUI(this);
    } 
    ComponentUI oldUI = ui;
    ui = newUI;
    if (ui != null) { 
        ui.installUI(this);
    } 
    invalidate();
    firePropertyChange(&quot;UI&quot;, oldUI, ui);
}
</PRE>
</BLOCKQUOTE>
<P>
These methods will be demonstrated further in Part V of this book.
<H2><A NAME="MiscellaneousFeatures">
Miscellaneous Features</A></H2>
<P>
Until now, this chapter has presented major functional units contained
in the <TT>JComponent</TT> class. The <TT>JComponent</TT> class
also contains some smaller units of functionality that are explored
in this section.
<H3><A NAME="AccessibilitySupport">
Accessibility Support</A></H3>
<P>
The <TT>JComponent</TT> class contains an <TT>accessibleContext</TT>
property. This property can be queried with the <TT>getAccessibleContext</TT>
method. The <TT>JComponent</TT> class provides the framework for
supporting accessibility but does not implement the functionality.
The <TT>JComponent</TT> class cannot do this; it doesn't have
the required information to do so. Instead, subclasses provide
the information and work in the framework defined in <TT>JComponent</TT>.
Also, <TT>JComponent</TT> doesn't implement the <TT>Accessible</TT>
interface. Subclasses that add the required knowledge to allow
the <TT>accessibleContext</TT> defined in <TT>JComponent</TT>
to have meaning should implement this interface. Accessibility
is discussed further in <A HREF="..\ch33\ch33.htm" >Chapter 33</A>, &quot;Accessibility.&quot;
<H3><A NAME="ParentChanges">
Parent Changes</A></H3>
<P>
The <TT>JComponent</TT> class overrides the <TT>addNotify</TT>
and <TT>removeNotify</TT> methods contained in the <TT>java.awt.Component</TT>
class. These methods are called when the parent of a <TT>JComponent</TT>
subclass is set or removed for the instance. The parent class'
methods are still called, but both these methods fire a property
change event with the name of <TT>ancestor</TT>. Thus, a bound
property named <TT>ancestor</TT> has been added for JFC components
that are fired when the familiar <TT>addNotify</TT> and <TT>removeNotify</TT>
methods are called. This property is to be moved into the <TT>Component</TT>
class in a future version of the JDK.
<H3><A NAME="DebugGraphics">
Debug Graphics</A></H3>
<P>
The <TT>JComponent</TT> class introduces the concept of debug
graphics. When debug graphics are enabled, a component paints
itself slowly, allowing the component developer to easily see
how the component is painting itself. Debug graphics are enabled
or disabled for a component via the <TT>setDebugGraphicsOptions</TT>
method. The current state of these options can be queried with
the <TT>getDebugGraphicsOptions</TT> method. A complete description
of using debug graphics and available options is presented in
<A HREF="..\ch25\ch25.htm" >Chapter 25</A>.
<H3><A NAME="DoubleBuffering">
Double Buffering</A></H3>
<P>
A serious problem with the AWT is poor painting performance. Many
component developers reduced this problem by double buffering
their components. When a component is double buffered, it paints
to an offscreen buffer and then updates the display in a single
operation. Even though this makes the painting of a component
slower than painting directly to the screen, it appears better
to the user because the display update is done very quickly. The
user does not see the raw painting operation, only the result
when the display is updated.
<P>
Double buffering was such a common painting optimization that
it was built into the JFC. Having double buffering contained in
the toolkit allows for further optimizations to be made. When
a component is double buffered, its children are also double buffered
using the same buffer. When each component managed its double
buffering, multiple offscreen images were created-one for each
component. The JFC optimizes the buffer creation to a single buffer
for the top-level component. This single buffer is shared by all
the components contained in that component. This saves a significant
amount of memory.
<P>
The <TT>setDoubleBuffered</TT> method is used to enable double
buffering for a component that extends <TT>JComponent</TT>. This
method takes a single <TT>boolean</TT> parameter specifying the
state for double buffering. The <TT>isDoubleBuffered</TT> method
can be used to determine if a component is currently double buffered.
While these methods are contained in the <TT>JComponent</TT> class,
they rarely need to be called by application code. The content
pane of JFC top-level components has double buffering enabled.
As will be shown in <A HREF="..\ch08\ch08.htm" >Chapter 8</A> &quot;Frame Windows,&quot; the
content pane is the parent in most JFC component hierarchies.
Thus, the components added to the content pane are double buffered,
even if their <TT>setDoubleBuffered</TT> method is not explicitly
called.
<H3><A NAME="EfficiencyMethods">
Efficiency Methods</A></H3>
<P>
Creating unnecessary temporary objects can cause significant performance
problems in a Java application. The AWT <TT>Component</TT> class
creates objects and returns them to the caller in its <TT>getBounds</TT>,
<TT>getSize</TT>, and <TT>getLocation</TT> methods. In many applications,
the object returned from these methods is a temporary object.
To avoid the creation of the object, new versions of these methods
have been added to the <TT>JComponent</TT> class. The new version
takes an instance of the class that is returned from the method.
The parameter object is altered to contain the values from the
component, and it is also returned from the method. The old and
new techniques for using <TT>getBounds</TT> are shown next. This
will be more efficient if the <TT>getBounds</TT> method is called
for multiple components because the same <TT>Rectangle</TT> instance
can be shared for all the calls.
<BLOCKQUOTE>
<PRE>
//
// Original JDK 1.1 getBounds technique
// This caused a Rectangle to be created in 
// the getBounds method.
//
Rectangle bounds = component.getBounds();

//
// New JDK 1.2 getBounds technique
//
Rectangle bounds = new Rectangle();
component.getBounds( bounds );
</PRE>
</BLOCKQUOTE>
<P>
Another common programming technique is to call the <TT>getSize</TT>
method and then use the <TT>height</TT> and <TT>width</TT> properties
from the returned <TT>Rectangle</TT>. The <TT>JComponent</TT>
class defines the <TT>getWidth</TT> and <TT>getHeight</TT> methods
that return these properties directly without creating a <TT>Rectangle</TT>
instance. Similarly, there are the <TT>getX</TT> and <TT>getY</TT>
methods to return the x and y coordinates without creating a <TT>Point</TT>
instance, as would be done if the <TT>getLocation</TT> method
were called. An example of the old and new techniques for the
<TT>getSize</TT> method is shown next.
<BLOCKQUOTE>
<PRE>
//
// JDK 1.1 getSize technique.
// This caused two Rectangle instances to be created.
//
int width = component.getSize().width;
int height = component.getSize().height;

//
// New JDK 1.2 technique
int width = component.getWidth();
int height = component.getHeight();<BR>
</PRE>
</BLOCKQUOTE>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Identical versions of the methods described in this section contained in the <TT>Jcomponent </TT>class have also been added to the <TT>Component </TT>class. Because the <TT>Jcomponent </TT>class is a descendent of the <TT>Component </TT>class, this is an obvious duplication of code. The methods should be removed from the <TT>JComponent </TT>class. However, wherever they reside, these methods should be used to increase the performance of your components and applications.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter has taken a long look at the <TT>JComponent</TT>
class. This class serves as the root of the visual component hierarchy
contained in the JFC. As such, it has become a dumping ground
for functionality required by all the visual components.
<P>
You looked at how client properties are an efficient place to
store data that may or may not be present for a given component.
You saw that all <TT>JComponent</TT> instances may contain a ToolTip
and a border. You saw how a single method call is all it takes
to enable double buffering for a component. The <TT>JComponent</TT>
class contains methods for handling keystrokes and automatic scrolling.
Using the family of focus methods contained in the <TT>JComponent</TT>
class, hints can be given to the focus manager for how focus transversal
should occur. A component can also be specified to not be able
to acquire the input focus programmatically or not at all. You
were also introduced to the look-and-feel support contained in
the <TT>JComponent</TT> class. This support is the foundation
of the pluggable look-and-feel architecture contained in the JFC.
<P>
As much material as this chapter covered about the <TT>JComponent</TT>
class, it is not complete. There is more functionality that is
used primarily by subclasses. This additional functionality is
presented in Part V of this book.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch02\ch02.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch04\ch04.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
