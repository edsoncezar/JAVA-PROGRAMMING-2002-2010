<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 25 - ToolTips and Debug Graphics</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch24\ch24.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch26\ch26.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;25<br>
ToolTips and Debug Graphics</H1>
<HR>
<p>

<UL>
<LI><A HREF="#ToolTipsBasics">
ToolTips Basics</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEToolTipManagerFONTTTFONTSIZEClassFONT">
The <TT>ToolTipManager</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEJToolTipFONTTTFONTSIZEClassFONT">
The <TT>JToolTip</TT> Class
</A>
</UL>
<LI><A HREF="#ToolTipsExample">
ToolTips Example</A>
<UL>
<LI><A HREF="#OverviewoftheTTFONTSIZEToolTipsDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>ToolTipsDemo</TT>
Example</A>
<LI><A HREF="#UsingtheToolTipManager">
Using the ToolTip Manager</A>
<LI><A HREF="#UsingCustomToolTips">
Using Custom ToolTips</A>
</UL>
<LI><A HREF="#UsingDebugGraphics">
Using Debug Graphics</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEDebugGraphicsFONTTTFONTSIZEClassFONT">
The <TT>DebugGraphics</TT>
Class</A>
<LI><A HREF="#EnablingDebugGraphicsOptions">
Enabling Debug Graphics Options</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEFlashGraphicsDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>FlashGraphicsDemo</TT>
Example</A>
<LI><A HREF="#TheLoggingOption">
The Logging Option</A>
<LI><A HREF="#TheFlashOption">
The Flash Option</A>
<LI><A HREF="#TheBufferedOption">
The Buffered Option</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
<TT>ToolTips</TT> are pop-up text labels that appear when the
mouse cursor comes to rest over a component. They are also known
as fly-over text or hover text. ToolTips can be used with any
Swing component (<TT>JComponent</TT>), but are most commonly associated
with user interface controls such as buttons.
<P>
All Swing components provide debug support for graphics-related
operations. This feature can be useful for debugging drawing problems
with components. 
<P>
In this chapter, you will learn
<UL>
<LI>How to create basic and customized ToolTips.<BR>
Implementing ToolTips with Swing components is really easy-it
takes one line of code to create a basic ToolTip. 
<LI>How to use the <TT>ToolTipManager</TT> class to control the
behavior of ToolTips.<BR>
You can globally disable ToolTips for your application. You can
also change various delay settings that control how ToolTips respond
to mouse actions.
<LI>How to use Swing's debug graphics capabilities.<BR>
Debug graphic capabilities include logging drawing operations
and drawing offscreen buffer operations to an external window.
</UL>
<H2><A NAME="ToolTipsBasics">
ToolTips Basics</A></H2>
<P>
ToolTips are represented by the <TT>JToolTip</TT> class in the
<TT>com.sun.java.swing</TT> package. However, unless you're interested
in creating your own customized ToolTips, you don't need to directly
use this class.
<P>
Any Swing component (including frames and panels as well as menus
and tree controls) can have ToolTips by calling a single <TT>JComponent</TT>
method, <TT>setToolTipText</TT>.
<BLOCKQUOTE>
<PRE>
// Create a button with a ToolTip
JButton b = new JButton(&quot;Quit&quot;);
b.setToolTipText(&quot;Exits the application&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Calling the <TT>setToolTipText</TT> method is all you need to
do to make use of the basic ToolTip capability of Swing components.
Advanced use of ToolTips includes using custom ToolTips and using
the ToolTip manager to control how ToolTips respond to mouse movement.
<H3><A NAME="TheTTFONTSIZEToolTipManagerFONTTTFONTSIZEClassFONT">
The <TT>ToolTipManager</TT>
Class</A></H3>
<P>
You might want to alter the default behavior of ToolTips or even
disable them altogether. Swing provides the <TT>ToolTipManager</TT>
class (see Listing 25.1) to allow you to enable and disable ToolTips
as well as set the characteristics of ToolTip behavior. 
<P>
<HR>
<P>
<B>Listing 25.1&nbsp;&nbsp;</B><TT><B>TOOLTIPMANAGER</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class ToolTipManager extends MouseAdapter
                            implements MouseMotionListener { 
  // Public class method
    public static ToolTipManager sharedInstance(); 
  // Public instance methods
    // methods to enable/disable and change response of ToolTips
    public void setEnabled(boolean enable); 
    public void setDismissDelay(int delay); 
    public void setInitialDelay(int delay); 
    public void setReshowDelay(int delay); 
    public boolean isEnabled(); 
    public int getDismissDelay(); 
    public int getInitialDelay(); 
    public int getReshowDelay(); 
    public void setLightWeightPopupEnabled(boolean enable);
    public boolean isLightWeightPopupEnabled();
    // overrides for mouse event handling
    public void mouseDragged(MouseEvent e); 
    public void mouseEntered(MouseEvent e); 
    public void mouseExited(MouseEvent e); 
    public void mouseMoved(MouseEvent e); 
    public void mousePressed(MouseEvent e); 
    // methods called by components to register with ToolTip manager
    public void registerComponent(JComponent component); 
    public void unregisterComponent(JComponent component);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Note that the <TT>ToolTipManager</TT> class does not have a public
constructor. This is because an instance of the class already
exists as a part of the system. Instead of calling a constructor
to create an instance of the <TT>ToolTipManager</TT> class, you
get a reference to the system's instance by calling the static
class method <TT>sharedInstance</TT>. The following line of code
uses <TT>sharedInstance</TT> to call the <TT>setEnabled</TT> method
to disable ToolTips.
<P>
<TT>ToolTipManager.sharedInstance().setEnabled(false);</TT>
<H4>Controlling ToolTip Behavior</H4>
<P>
The methods you'll find most useful in this class are the methods
that change ToolTip behavior: <TT>setEnabled</TT>, <TT>setInitialDelay</TT>,
 <TT>setDismissDelay</TT>, and <TT>setReshowDelay</TT>. <TT>setEnabled</TT>
enables and disables ToolTips globally for an application. The
delay-related functions change how ToolTips respond to the mouse.
<UL>
<LI>The <I>initial delay</I> determines
how long the mouse must stop over a component before the ToolTip
is made visible.
<LI>The <I>dismiss delay</I> determines
how long the ToolTip will remain visible.
<LI>The <I>reshow delay</I> determines
the amount of time after the mouse exits a component with a visible
ToolTip that the ToolTip will redisplay immediately (without waiting
for the initial delay).
</UL>
<P>
The <TT>isEnabled</TT>, <TT>getInitialDelay</TT>, <TT>getDismissDelay</TT>,
and <TT>getReshowDelay</TT> methods return the current settings
of the ToolTip manager. The remaining methods are methods the
ToolTip manager overrides to handle mouse events.
<H4>Lightweight Versus Heavyweight ToolTips</H4>
<P>
The <TT>ToolTipManager</TT> class includes two methods, <TT>setLightWeightPopupEnabled</TT>
and <TT>isLightWeightPopupEnabled</TT>, to control whether ToolTips
are rendered as lightweight (Swing) or heavyweight (AWT) components.
By default, ToolTips are rendered as lightweight components. If
you are mixing Swing and AWT components in an application, you
should disable lightweight ToolTips as shown in the following
line of code.
<P>
<TT>ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);</TT>
<H3><A NAME="TheTTFONTSIZEJToolTipFONTTTFONTSIZEClassFONT">
The <TT>JToolTip</TT> Class
</A></H3>
<P>
If for some reason you need more control over the appearance of
ToolTips, you can supply your own implementation of ToolTips by
extending the <TT>JToolTip</TT> class (see Listing 25.2).
<P>
<HR>
<P>
<B>Listing 25.2&nbsp;&nbsp;</B><TT><B>JTOOLTIP</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class JToolTip extends JComponent implements Accessible 
{ 
  // Public constructor
    public JToolTip();
  // Public instance methods
    public ToolTipUI getUI();
    public void updateUI();
    public getUIClassID();
    public void setTipText(String string);
    public String getTipText();
    public void setComponent(JComponent component);
    public JComponent getComponent();
    public getAccessibleContext();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
ToolTips are instantiated on-the-fly, at the time they need to
be displayed. A listener (the <TT>ToolTipManager</TT>) listens
for mouse movement within a component and instantiates a <TT>JToolTip</TT>
object when it's time to display a ToolTip. To supply a customized
ToolTip, you override the component's <TT>createToolTip</TT> method
as shown in the following code fragment.
<BLOCKQUOTE>
<PRE>
// Create a quit button with custom ToolTip
JButton b = new JButton(&quot;Quit&quot;) { 
    // Override to use custom tooltip
    public JToolTip createToolTip() { return(new CustomToolTip(this));} 
} 
</PRE>
</BLOCKQUOTE>
<P>
<TT>ToolTip</TT> objects extend <TT>JComponent</TT> which extends
<TT>Component</TT>, one of the cornerstone objects of AWT. Thus,
if you want to create more sophisticated customized ToolTips,
you can override <TT>Component</TT> methods such as <TT>paint</TT>,
<TT>setBackground</TT>, and <TT>setFont</TT>.
<H2><A NAME="ToolTipsExample">
ToolTips Example</A></H2>
<P>
Listing 25.3 is the complete source for <TT>ToolTipsDemo</TT>,
an application that illustrates basic and advanced capabilities
of ToolTips. Figure 25.1 shows the completed <TT>ToolTipsDemo</TT>.
<P>
<A HREF="javascript:popUp('f25-1.gif')"><B>Figure 25.1 :</B> <I>The ToolTipsDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 25.3&nbsp;&nbsp;</B><TT><B>TOOLTIPSDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* ToolTipsDemo.java
 *
 * Illustrates basic and customized ToolTips.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.border.*;

/* App class
 */
public class ToolTipsDemo { 
    // Main entry point
    public static void main(String s[]) { 
        
        // create app panel
        ToolTipsDemoPanel panel = new ToolTipsDemoPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;ToolTipsDemo&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (250, 450);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class ToolTipsDemoPanel extends JPanel { 
    // Constructor
    public ToolTipsDemoPanel() { 
        super();

        // create 2 radio buttons with custom ToolTips
        JRadioButton rb1 = new JRadioButton(&quot;Enable tool tips&quot;, true) { 
            // override to use custom tooltip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        rb1.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                ToolTipManager.sharedInstance().setEnabled(true);
            } 
        } );
        rb1.setToolTipText(&quot;Enables tool tips for all components&quot;);
        JRadioButton rb2 = new JRadioButton(&quot;Disable tool tips&quot;, false) { 
            // override to use custom tooltip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        rb2.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                ToolTipManager.sharedInstance().setEnabled(false);
            } 
        } );
        rb2.setToolTipText(&quot;Disables tool tips for all components&quot;);

        // add radio buttons to a button group
        ButtonGroup group = new ButtonGroup();
        group.add(rb1);
        group.add(rb2);

        // arrange radio buttons in box and panel(to provide label)
        MyBox box1 = new MyBox(BoxLayout.Y_AXIS);
        box1.add(rb1);
        box1.add(rb2);
        JPanel panel1 = new JPanel();
        panel1.setBorder(new TitledBorder(&quot;Tool Tips&quot;));
        panel1.add(box1);

        // create 3 sliders with change listeners
        // each slider overrides createToolTip to use a custom ToolTip
        // slider 1
        final JSlider s1 = new JSlider(JSlider.HORIZONTAL, 0, 10000, 0) { 
            // override to use custom tooltip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        s1.setPaintTicks(true);
        s1.setPaintLabels(true);
        s1.setMajorTickSpacing(5000);
        s1.setMinorTickSpacing(1000);
        s1.setSnapToTicks(true);
        s1.setValue(ToolTipManager.sharedInstance().getDismissDelay());
        s1.addChangeListener(new ChangeListener() { 
            public void stateChanged(ChangeEvent e) { 
ToolTipManager.sharedInstance().setDismissDelay(
  s1.getValue());
            } 
        } );
        s1.setToolTipText(
  &quot;Changes Tool Tip Manager's dismiss delay setting&quot;);
        // add slider to panel that has titled border 
        JPanel panel2 = new JPanel();
        panel2.setBorder(new TitledBorder(&quot;Dismiss Delay&quot;));
        panel2.add(s1);
        // slider 2
        final JSlider s2 = new JSlider(JSlider.HORIZONTAL, 0, 10000, 0) { 
            // override to use custom tooltip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        s2.setPaintTicks(true);
        s2.setPaintLabels(true);
        s2.setMajorTickSpacing(5000);
        s2.setMinorTickSpacing(1000);
        s2.setSnapToTicks(true);
        s2.setValue(ToolTipManager.sharedInstance().getInitialDelay());
        s2.addChangeListener(new ChangeListener() { 
            public void stateChanged(ChangeEvent e) { 
                ToolTipManager.sharedInstance().setInitialDelay(
  s2.getValue());
            } 
        } );
        s2.setToolTipText(
            &quot;Changes Tool Tip Manager's initial delay setting&quot;);
        // add slider to panel that has titled border 
        JPanel panel3 = new JPanel();
        panel3.setBorder(new TitledBorder(&quot;Initial Delay&quot;));
        panel3.add(s2);
        // slider 3
        final JSlider s3 = new JSlider(JSlider.HORIZONTAL, 0, 10000, 0) { 
            // override to use custom tooltip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        s3.setPaintTicks(true);
        s3.setPaintLabels(true);
        s3.setMajorTickSpacing(5000);
        s3.setMinorTickSpacing(1000);
        s3.setSnapToTicks(true);
        s3.setValue(ToolTipManager.sharedInstance().getReshowDelay());
        s3.addChangeListener(new ChangeListener() { 
            public void stateChanged(ChangeEvent e) { 
                ToolTipManager.sharedInstance().setReshowDelay(
  s3.getValue());
            } 
        } );
        s3.setToolTipText(
  &quot;Changes Tool Tip Manager's reshow delay setting&quot;);
        // add slider to panel that has titled border 
        JPanel panel4 = new JPanel();
        panel4.setBorder(new TitledBorder(&quot;Reshow Delay&quot;));
        panel4.add(s3);

        // add radio button and slider panels to vertical box
        MyBox box2 = new MyBox(BoxLayout.Y_AXIS);
        box2.add(panel1);   // radio buttons
        box2.add(panel2);   // sliders
        box2.add(panel3);   //
        box2.add(panel4);   //
        // put box in panel that has titled border
        JPanel panel5 = new JPanel();
        panel5.setBorder(new TitledBorder(&quot;Tool Tips Tweaks&quot;));
        panel5.add(box2);
        add(panel5);

        // create a quit button with custom ToolTip
        JButton b = new JButton(&quot;Quit&quot;) { 
            // override to use custom ToolTip
            public JToolTip createToolTip() { 
                return(new CustomToolTip(this));
            } 
        } ;
        b.setToolTipText(&quot;Exits the application&quot;);
        b.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                System.exit(0);
            } 
        } );
        add(b);
    } 

    // Override to use custom ToolTip on panel
    public JToolTip createToolTip() {  return(new CustomToolTip(this)); } 
} 


// A custom ToolTip class that simply changes the
// background color of the basic ToolTip.
class CustomToolTip extends JToolTip { 
    // Constructor
    public CustomToolTip(JComponent component) { 
        super();
        setComponent(component);
        setBackground(Color.yellow);
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel
{ 
    public MyBox(int axis) { 
        super();
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEToolTipsDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>ToolTipsDemo</TT>
Example</A></H3>
<P>
The <TT>ToolTipsDemo</TT> example consists of three classes:
<UL>
<LI><TT>ToolTipsDemo</TT> is a public class that contains the
<TT>main</TT> entry point method.
<LI><TT>ToolTipsDemoPanel</TT> is a panel (<TT>JPanel)</TT> that
contains the user interface for the application.
<LI><TT>CustomToolTip</TT> is an implementation of a custom ToolTip.
</UL>
<P>
The <TT>main</TT> entry point creates a frame (<TT>JFrame</TT>)
and an instance of <TT>ToolTipsDemoPanel</TT> that it adds to
the frame. 
<P>
The constructor for <TT>ToolTipsDemoPanel</TT> creates two radio
buttons and three sliders to provide an interface for changing
ToolTip manager settings. The radio buttons and sliders are contained
in panels with titled borders used to identify the controls. Each
component that uses a custom ToolTip overrides the <TT>createToolTip</TT>
method and returns an instance of <TT>CustomToolTip</TT>.
<H3><A NAME="UsingtheToolTipManager">
Using the ToolTip Manager</A></H3>
<P>
The following fragment is the code that creates the radio button
that enables ToolTips.
<BLOCKQUOTE>
<PRE>
JRadioButton rb1 = new JRadioButton(&quot;Enable tool tips&quot;, true) { 
    // override to use custom tooltip
    public JToolTip createToolTip() { return(new CustomToolTip(this));} 
} ;
rb1.addActionListener(new ActionListener() { 
    public void actionPerformed(ActionEvent e) { 
        ToolTipManager.sharedInstance().setEnabled(true);
    } 
} );
rb1.setToolTipText(&quot;Enables tool tips for all components&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The radio button has an action listener implemented in an anonymous
inner class. When an action event is received via the <TT>actionPerformed</TT>
method, the listener gets a shared instance of the ToolTip manager
and calls its <TT>setEnabled</TT> method to enable ToolTips.
<P>
The sliders are implemented like the radio buttons. The following
code fragment creates the slider that controls the dismiss delay
for ToolTips.
<BLOCKQUOTE>
<PRE>
final JSlider s1 = new JSlider(JSlider.HORIZONTAL, 0, 10000, 0) { 
    // override to use custom tooltip
    public JToolTip createToolTip() {  return(new CustomToolTip(this)); } 
} ;
s1.setPaintTicks(true);
s1.setPaintLabels(true);
s1.setMajorTickSpacing(5000);
s1.setMinorTickSpacing(1000);
s1.setSnapToTicks(true);
s1.setValue(ToolTipManager.sharedInstance().getDismissDelay());
s1.addChangeListener(new ChangeListener() { 
    public void stateChanged(ChangeEvent e) { 
        ToolTipManager.sharedInstance().setDismissDelay(s1.getValue());
    } 
} );
s1.setToolTipText(&quot;Changes Tool Tip Manager's dismiss delay setting&quot;);
</PRE>
</BLOCKQUOTE>
<P>
One important difference between the slider and radio button implementation
is that the slider variables are declared as <TT>final</TT>, to
be accessed by the change listener because it is implemented in
an inner class. (The radio button listeners were also implemented
in an inner class, but they did not need to access the radio button
instance.)
<P>
<TT>ToolTipManager.sharedInstance().setDismissDelay(s1.getValue());</TT>
<P>
The dismiss delay is set to the value returned by the slider's
<TT>getValue</TT> method.
<H3><A NAME="UsingCustomToolTips">
Using Custom ToolTips</A></H3>
<P>
The <TT>ToolTipsDemo</TT> example uses a very simple version of
a customized ToolTip-it simply changes the background color of
ToolTips to yellow. As shown earlier, each component that uses
a custom ToolTip must override the <TT>createToolTip</TT> method
and return an instance of the custom ToolTip. The following code
fragment creates the Quit button, which uses a custom ToolTip.
<BLOCKQUOTE>
<PRE>
// create a quit button with custom ToolTip
JButton b = new JButton(&quot;Quit&quot;) { 
    // override to use custom ToolTip
    public JToolTip createToolTip() {  return(new CustomToolTip(this)); } 
} ;
b.setToolTipText(&quot;Exits the application&quot;);
</PRE>
</BLOCKQUOTE>
<P>
To implement custom ToolTips, <TT>ToolTipsDemo</TT> simply extends
the <TT>JToolTip</TT> class.
<BLOCKQUOTE>
<PRE>
// A custom ToolTip class that simply changes the
// background color of the basic ToolTip.
class CustomToolTip extends JToolTip { 
    // Constructor
    public CustomToolTip(JComponent component) { 
        super();
        setComponent(component);
        setBackground(Color.yellow);
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
The constructor for <TT>CustomToolTip</TT> takes a single parameter
specifying the component with which the ToolTip is to be associated.
The contents of this parameter are passed to the <TT>JToolTip.setComponent</TT>
method. The constructor then sets the background color to yellow.
You could also call <TT>setFont</TT> here to change the font used
for custom ToolTips.
<H2><A NAME="UsingDebugGraphics">
Using Debug Graphics</A></H2>
<P>
All Swing components come with built-in debug capability for graphics
operations. This capability resides in the <TT>DebugGraphics</TT>
class, which is an extension of the AWT <TT>Graphics</TT> class.
<H3><A NAME="TheTTFONTSIZEDebugGraphicsFONTTTFONTSIZEClassFONT">
The <TT>DebugGraphics</TT>
Class</A></H3>
<P>
<TT>DebugGraphics</TT> is a rather large class-it has more than
50 public methods. Fortunately, you only need to use a few of
these methods to access the debug graphics capabilities of <TT>JComponent</TT>
objects. 
<BLOCKQUOTE>
<PRE>
// Public constants (for getting and setting debug options) 
public static final int LOG_OPTION;
public static final int FLASH_OPTION;
public static final int BUFFERED_OPTION;
public static final int NONE_OPTION;

// Public class methods to change debug options
public static void setFlashColor(Color color);
public static Color flashColor();
public static void setFlashTime(int time);
public static int flashTime();
public static void setFlashCount(int count);
public static int flashCount();
public static void setLogStream(PrintStream stream);
public static PrintStream logStream();
</PRE>
</BLOCKQUOTE>
<P>
The remaining methods in the <TT>DebugGraphics</TT> class are
<TT>Graphics</TT> method overrides that you normally won't need
to use. 
<P>
There are several static class methods you can use to change debug
graphics options: <TT>setFlashColor</TT>, <TT>setFlashTime</TT>,
<TT>setFlashCount</TT>, and <TT>setLogStream</TT>. Because these
methods are static class methods, you don't need to create a <TT>DebugGraphics</TT>
object to call them. 
<H3><A NAME="EnablingDebugGraphicsOptions">
Enabling Debug Graphics Options</A></H3>
<P>
Debug graphics is enabled on a per-component basis. To enable
debug graphics (by default it's disabled), you call the <TT>JComponent.setDebugGraphicsOptions</TT>
method and specify one the following debug options:
<UL>
<LI><TT>DebugGraphics.LOG_OPTION</TT> to specify that graphics
operations be logged
<LI><TT>DebugGraphics.FLASH_OPTION</TT> to specify that drawing
operations be performed slowly, and flash so you can observe the
order and manner of component rendering
<LI><TT>DebugGraphics.BUFFERED_OPTION</TT> to specify that drawing
operations be rendered in an external window
</UL>
<P>
When you set debug graphic options with <TT>setDebugGraphicsOptions</TT>,
the options you specify are combined with options that have been
set previously. To disable all debug graphics options, call <TT>setDebugGraphicsOptions</TT>
with the <TT>DebugGraphics.NONE_OPTION</TT> option.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600><BLOCKQUOTE>
When you call a component's <TT>setDebugGraphicsOptions</TT> method, the settings also apply to components that are contained by the target component.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
You must disable double buffering when using debug graphics. The
following line of code shows how you can use the repaint manager
to disable double buffering.
<P>
<TT>RepaintManager.currentManager(this).setDoubleBufferingEnabled(false);</TT>
<H4>Example Using Flash Option</H4>
<P>
Listing 25.4 is the complete source for <TT>FlashGraphicsDemo</TT>,
an application that illustrates how to use the debug graphics
flash option. Figure 25.2 shows the completed <TT>FlashGraphicsDemo</TT>.
<P>
<A HREF="javascript:popUp('f25-2.gif')"><B>Figure 25.2 :</B> <I>The FlashGraphicsDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 25.4&nbsp;&nbsp;</B><TT><B>FLASHGRAPHICSDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* FlashGraphicsDemo.java
 *
 * Application illustrating use of debug graphics flash option.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/* App class
 */
public class FlashGraphicsDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        FlashGraphicsDemoPanel panel = new FlashGraphicsDemoPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;FlashGraphicsDemo&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (350, 120);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class FlashGraphicsDemoPanel extends JPanel { 
    // Constructor
    public FlashGraphicsDemoPanel () { 
        // set flash option parameters
        DebugGraphics.setFlashCount(2);
        DebugGraphics.setFlashColor(Color.red);
        DebugGraphics.setFlashTime(25);

        // double buffering must be disabled
        // to use debug graphics options!!
        RepaintManager.currentManager(this).setDoubleBufferingEnabled(false);

        // create a panel containing some debug objects
        final JPanel debugPanel = new JPanel();
        debugPanel.add(new JButton(&quot;Button&quot;));
        debugPanel.add(new JSlider());

        // create a check box to turn debug on/off
        JCheckBox cb = new JCheckBox(&quot;Enable Flash Graphics Debug&quot;);
        cb.addItemListener(new ItemListener() { 
            public void itemStateChanged(ItemEvent e) { 
                if(e.getStateChange() == ItemEvent.SELECTED) { 
                    // enable flash option
                    debugPanel.setDebugGraphicsOptions(DebugGraphics.FLASH_OPTION);
                    debugPanel.repaint();
                } 
                else { 
                    // disable flash option
                    debugPanel.setDebugGraphicsOptions(DebugGraphics.NONE_OPTION);
                } 
            } 
        } );

        // create a repaint button
        JButton b = new JButton(&quot;Repaint&quot;);
        b.addActionListener (new ActionListener () { 
            public void actionPerformed (ActionEvent e) { 
                // repaint panel containing debug components
                debugPanel.repaint();
            } 
        } );

        // add components to panel
        add(cb);
        add(b);
        add(debugPanel);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEFlashGraphicsDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>FlashGraphicsDemo</TT>
Example</A></H3>
<P>
The <TT>FlashGraphicsDemo</TT> example consists of two classes:
<UL>
<LI><TT>FlashGraphicsDemo</TT> is a public class that contains
the <TT>main</TT> entry point method.
<LI><TT>FlashGraphicsDemoPanel</TT> is a panel (<TT>JPanel)</TT>
that contains the user interface for the application.
</UL>
<P>
The <TT>main</TT> entry point creates a frame (<TT>JFrame</TT>)
and an instance of <TT>FlashGraphicsDemoPanel</TT> that it adds
to the frame. 
<P>
The constructor for <TT>FlashGraphicsDemoPanel</TT> first sets
parameters for the flash option by calling the <TT>DebugGraphics</TT>
class methods <TT>setFlashCount</TT>, <TT>setFlashColor</TT>,
and <TT>setFlashTime</TT>. It then disables double buffering and
creates a debug panel containing a button and slider to illustrate
how components are drawn when you enable the flash option. After
creating a button that allows you to cause a repaint of the debug
panel, the constructor creates a check box component that allows
you to enable and disable the flash option. The following code
fragment shows how the item listener for this check box enables
and disables the flash option.
<BLOCKQUOTE>
<PRE>
JCheckBox cb = new JCheckBox(&quot;Enable Flash Graphics Debug&quot;);
cb.addItemListener(new ItemListener() { 
    public void itemStateChanged(ItemEvent e) { 
        if(e.getStateChange() == ItemEvent.SELECTED) { 
            // enable flash option
            debugPanel.setDebugGraphicsOptions(DebugGraphics.FLASH_OPTION);
            debugPanel.repaint();
        } 
        else { 
            // disable flash option
            debugPanel.setDebugGraphicsOptions(DebugGraphics.NONE_OPTION);
        } 
    } 
} );
</PRE>
</BLOCKQUOTE>
<P>
After creating the check box and adding an item listener, the
constructor adds the check box, the repaint button, and the debug
panel to the main application panel.
<H3><A NAME="TheLoggingOption">
The Logging Option</A></H3>
<P>
The debug graphics logging option (<TT>DebugGraphics.LOG_OPTION</TT>)
will cause graphics operations to be logged on the standard output
stream. If you wish, you can use the <TT>DebugGraphics.setLogStream</TT>
method to specify a different stream for logging operations.
<P>
Logging operations can generate quite a bit of output. Listing
25.5 is the partial (about 15% of the total) debug output generated
by drawing a basic <TT>JButton</TT> object.
<P>
<HR>
<P>
<B>Listing 25.5&nbsp;&nbsp;Output Generated by Enabling Debug
Graphic Logging </B>(<TT><B>LOG_OPTION</B></TT><B>)
<BR>
</B>
<BLOCKQUOTE>
<PRE>
Graphics(0-1) Enabling debug
Graphics(0-1) Enabling debug
Graphics(1-1) Enabling debug
Graphics(1-1) Setting color: ColorUIResource[r=0,g=0,b=0]
Graphics(1-1) Setting font: FontUIResource[family=Dialog,name=Arial,
style=bold,size=12]
Graphics(2-1) Setting color: ColorUIResource[r=204,g=204,b=204]
Graphics(2-1) Filling rect: Rectangle[x=0,y=0,width=77,height=25]
Graphics(2-1) Setting font: FontUIResource[family=Dialog,name=Arial,
style=bold,size=12]
Graphics(2-1) Setting color: ColorUIResource[r=0,g=0,b=0]
Graphics(2-1) Drawing string: &quot;Button&quot; at: Point[x=17,y=16]
Graphics(1-1) Translating by: Point[x=0,y=0]
Graphics(1-1) Setting color: ColorUIResource[r=102,g=102,b=102]
Graphics(1-1) Drawing line: from (0, 0) to (74, 0)
Graphics(1-1) Drawing line: from (75, 0) to (75, 22)
Graphics(1-1) Drawing line: from (75, 23) to (1, 23)
Graphics(1-1) Drawing line: from (0, 23) to (0, 1)
Graphics(1-1) Setting color: ColorUIResource[r=255,g=255,b=255]
Graphics(1-1) Drawing line: from (1, 1) to (75, 1)
Graphics(1-1) Drawing line: from (76, 1) to (76, 23)
Graphics(1-1) Drawing line: from (76, 24) to (2, 24)
Graphics(1-1) Drawing line: from (1, 24) to (1, 2)
Graphics(1-1) Setting color: ColorUIResource[r=204,g=204,b=204]
Graphics(1-1) Drawing line: from (0, 24) to (1, 23)
Graphics(1-1) Drawing line: from (76, 0) to (75, 1)
Graphics(1-1) Translating by: Point[x=0,y=0]
Graphics(0-1) Setting new clipRect: Rectangle2D$Float[x=0.0,y=0.0,
w=87.0,h=35.0]
Graphics(0-1) Drawing image: BufferedImage@6fb03d9: type = 1 
DirectColorModel: rmask=ff0000 gmask=ff00 bmask=ff amask=0 
IntegerComponentRaster: width = 192 height = 173 
#Bands = 3 #DataElements 1 xOff = 0 yOff = 0 
dataOffset[0] 0 at: Point[x=0,y=0]
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheFlashOption">
The Flash Option</A></H3>
<P>
The debug graphics flash option causes drawing operations to flash
several times in a specified color before being rendered correctly.
There are three <TT>DebugGraphics</TT> static class methods that
allow you to control the number of times the drawing operations
flash, the delay between the flashes, and the flash color.
<BLOCKQUOTE>
<PRE>
public static void setFlashColor(Color color);
public static void setFlashTime(int time);
public static void setFlashCount(int count);
</PRE>
</BLOCKQUOTE>
<P>
Using the flash option allows you to observe the order of drawing
operations that occur when a component is rendered.
<H3><A NAME="TheBufferedOption">
The Buffered Option</A></H3>
<P>
The buffered option will cause operations to the component's offscreen
buffer to be rendered in an external frame window.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
ToolTips can be a very effective way to provide information about
a component when it's under the mouse cursor. All Swing components
support ToolTips with the <TT>setToolTipText</TT> method. The
<TT>ToolTipsDemo</TT> example shows how to use basic ToolTips
as well as how to create and use customized ToolTips.
<P>
Swing components also provide several options of debug graphics
capability. You can use these debug graphics options to better
understand how components are rendered so you can correct drawing-related
problems you may encounter in your code.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch24\ch24.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch26\ch26.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
