<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Thu, Mar 11, 1999 12:15 PM-->
<HTML>
<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">
	<META NAME="Author" Content="Steph Mineart">
	<TITLE>JFC -- Appendix B -com.foley.chart Package Source Code </TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">
<H1 ALIGN="CENTER"><IMG SRC="..\button\sams.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0"></H1>
<H1 ALIGN="CENTER">JFC Unleashed</H1>
<H1 ALIGN="CENTER"><A HREF="..\apa\apa.htm"><IMG SRC="..\button\previous.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\index.htm"><IMG SRC="..\button\contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\apc\apc.htm"><IMG
SRC="..\button\next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A></H1>
<CENTER>
<P>
<HR>
</CENTER>
<H1 ALIGN="CENTER">Appendix&nbsp;B<BR>
com.foley.chart Package Source Code</H1>
<UL>
	<LI><A HREF="#TTFONTSIZEFAxisFONTTTFONTSIZEClassFONT"><TT>FAxis</TT> Class</A>
	<LI><A HREF="#TTFONTSIZEFAxisUIFONTTTFONTSIZEClassFONT"><TT>FAxisUI</TT> Class</A>
	<LI><A HREF="#TTFONTSIZEFChartFONTTTFONTSIZEClassFONT"><TT>FChart</TT> Class</A>
	<LI><A HREF="#TTFONTSIZEFChartLayoutManagerFONTTTFONTSIZEClassFONT"><TT>FChartLayoutManager</TT>
	Class</A>
	<LI><A HREF="#TTFONTSIZEFChartUIFONTTTFONTSIZEClassFONT"><TT>FChartUI</TT> Class</A>
	<LI><A HREF="#TTFONTSIZEMetalFAxisUIFONTTTFONTSIZEClassFONT"><TT>MetalFAxisUI</TT>
	Class</A>
	<LI><A HREF="#TTFONTSIZEMetalFChartUIFONTTTFONTSIZEClassFONT"><TT>MetalFChartUI</TT>
	Class</A>
	<LI><A HREF="#TTFONTSIZEWindowsFAxisUIFONTTTFONTSIZEClassFONT"><TT>WindowsFAxisUI</TT>
	Class</A>
	<LI><A HREF="#TTFONTSIZEWindowsFChartUIFONTTTFONTSIZEClassFONT"><TT>WindowsFChartUI</TT>
	Class</A>
</UL>
<P>
<HR>
</P>
<P>The complete source listings for the classes contained in the <TT>com.foley.chart</TT>
package presented in <A HREF="..\ch24\ch24.htm">Chapter 24</A>, &quot;Building a
Custom Component,&quot; are contained in this appendix.
<H2><A NAME="TTFONTSIZEFAxisFONTTTFONTSIZEClassFONT"></A><TT>FAxis</TT> Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;
import java.io.*;
import java.util.*;

import javax.swing.*;
import javax.accessibility.*;


/**
 * Class FAxis.
 * FAxis is an axis component designed to work with the 
 * FChart class, but could be used on any component that 
 * needs an axis.
 * &lt;p&gt;
 * The Axis's range is defined in a BoundedRangeModel.
 * &lt;p&gt;
 * @beaninfo
 *      attribute: isContainer false
 *    description: An axis component
 * &lt;p&gt;
 * @version 1.2
 * @author Mike Foley
 **/
public class FAxis extends JComponent 
    implements SwingConstants, Serializable, Accessible
{ 
    /**
     * @see #getUIClassID
     * @see #readObject
     **/
    private static final String uiClassID = &quot;FAxisUI&quot;;

    private boolean paintTicks = true;
    private boolean paintLabels = true;
    
    /**
     * Bound property names.
     **/
    private static String MODEL_PROPERTY = &quot;model&quot;;
    private static String ORIENTATION_PROPERTY = &quot;orientation&quot;;
    private static String MAJORTICKSPACING_PROPERTY = &quot;majorTickSpacing&quot;;
    private static String MINORTICKSPACING_PROPERTY = &quot;minorTickSpacing&quot;;
    private static String MAJORTICKSIZE_PROPERTY = &quot;majorTickSize&quot;;
    private static String MINORTICKSIZE_PROPERTY = &quot;minorTickSize&quot;;
    private static String PAINTTICKS_PROPERTY = &quot;paintTicks&quot;;
    private static String PAINTLABELS_PROPERTY = &quot;paintLabels&quot;;
    private static String PAINTLABELTABLE_PROPERTY = &quot;labelTable&quot;;
    
    /**
     * The data model that handles the numeric maximum value,
     * minimum value, and current-position value for the slider.
     */
    protected BoundedRangeModel dataModel;

    /**
     * The number of values between the major tick marks - the 
     * larger marks that break up the minor tick marks.
     */
    protected int majorTickSpacing = 20;

    /**
     * The number of values between the minor tick marks - the 
     * smaller marks that occur between the major tick marks.
     * @see #setMinorTickSpacing
     **/
    protected int minorTickSpacing = 5;
    private int majorTickSize = 10;
    private int minorTickSize = 5;

    /**
     * @see #setOrientation
     **/
    protected int orientation;


    /**
     * The labels for the axis.
     **/
    private Dictionary labelTable;
    

    /** 
     * Ensure that the given orientation is valid for this
     * component. Using typed constants would be better, but
     * we want to use the constants defined in the SwingConstants
     * interface so our class works similiar to core classes.
     * &lt;p&gt;
     * @param orientation The required orientation for the axis.
     **/
    private void checkOrientation( int orientation ) { 
        switch (orientation) { 
        case VERTICAL:
        case HORIZONTAL:
            break;
        default:
throw new IllegalArgumentException(
            &quot;orientation must be one of: VERTICAL, HORIZONTAL&quot;);
        } 
    } 


    /**
     * Creates a horizontal axis with the range 0 to 100.
     **/
    public FAxis() { 
        this( HORIZONTAL, 0, 100 );
    } 


    /**
     * Creates a slider using the specified orientation with the 
     * range 0 to 100.
     **/
    public FAxis(int orientation) { 
        this( orientation, 0, 100 );
    } 


    /**
     * Creates a horizontal slider using the specified min and max.
     **/
    public FAxis( int min, int max ) { 
        this( HORIZONTAL, min, max );
    } 


    /**
     * Creates a slider with the specified orientation and the
     * specified mimimum, and maximum.
     * 
     * @exception IllegalArgumentException 
     *            if orientation is not one of VERTICAL, HORIZONTAL
     *
     * @see #setOrientation
     * @see #setMinimum
     * @see #setMaximum
     **/
    public FAxis( int orientation, int min, int max ) 
    { 
        checkOrientation( orientation );
        this.orientation = orientation;
        setModel( new DefaultBoundedRangeModel( 0, 0, min, max ) );
        updateUI();
    } 


    /**
     * Creates a horizontal axis using the specified
     * BoundedRangeModel.
     **/
    public FAxis( BoundedRangeModel brm ) 
    { 
        this.orientation = JSlider.HORIZONTAL;
        setModel( brm );
        updateUI();
    } 


    /**
     * Gets the UI object which implements the L&amp;F for this component.
     *
     * @return the FAxisUI object that implements the Slider L&amp;F
     **/
    public FAxisUI getUI() { 
        return( ( FAxisUI )ui );
    } 


    /**
     * Sets the UI object which implements the L&amp;F for this component.
     *
     * @param ui the FAxisUI L&amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *       bound: true
     *      hidden: true
* description: The UI object that implements 
     *              the slider's LookAndFeel.
     **/
    public void setUI( FAxisUI ui ) { 
        super.setUI( ui );
    } 


    /**
     * Notification from the UIFactory that the L&amp;F has changed. 
     * Called to replace the UI with the latest version from the 
     * default UIFactory.
     *
     * @see JComponent#updateUI
     **/
    public void updateUI() { 
        updateLabelUIs();
        setUI((FAxisUI)UIManager.getUI(this));
    } 


    /**
     * Returns the name of the L&amp;F class that renders this component.
     *
     * @return &quot;FAxisUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     **/
    public String getUIClassID() { 
        return uiClassID;
    } 


    /**
* Called internally to replace the label UIs with the latest 
     * versions from the UIFactory when the UIFactory notifies us via
     * &lt;code&gt;updateUI&lt;/code&gt; that the L&amp;F has changed.
     *
     * @see JComponent#updateUI
     **/
    protected void updateLabelUIs() { 
        if ( getLabelTable() == null ) { 
            return;
        } 
        Enumeration labels = getLabelTable().keys();
        while ( labels.hasMoreElements() ) { 
            Object value = getLabelTable().get( labels.nextElement() );
            if ( value instanceof JComponent ) { 
                JComponent component = (JComponent)value;
                component.updateUI();
                component.setSize( component.getPreferredSize()  );
            } 
        } 
    } 


    /**
     * Returns data model that handles the sliders three 
     * fundamental properties: minimum, maximum, value.
     * 
     * @see #setModel
     **/
    public BoundedRangeModel getModel() { 
        return dataModel;
    } 


    /**
     * Sets the model that handles the sliders three 
     * fundamental properties: minimum, maximum, value.
     * 
     * @see #getModel
     * @beaninfo
     *       bound: true
     * description: The sliders BoundedRangeModel.
     **/
    public void setModel(BoundedRangeModel newModel) 
    { 
        BoundedRangeModel old = getModel();

        dataModel = newModel;

        if (newModel != null) { 

            if (accessibleContext != null) { 
                accessibleContext.firePropertyChange(
                        AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
                        (old == null 
                         ? null : new Integer(old.getValue())),
                        (newModel == null 
                         ? null : new Integer(newModel.getValue())));
            } 
        } 

        firePropertyChange( MODEL_PROPERTY, old, dataModel );
    } 


    /**
     * Returns the minimum value supported by the slider. 
     *
     * @return the value of the models minimum property
     * @see #setMinimum
     **/
    public int getMinimum() {  
        return getModel().getMinimum(); 
    } 


    /**
     * Sets the model's minimum property.
     *
     * @see #getMinimum
     * @see BoundedRangeModel#setMinimum
     * @beaninfo
     *   preferred: true
     * description: The slider's minimum value.
     **/
    public void setMinimum(int minimum) {  
        getModel().setMinimum(minimum); 
    } 


    /**
     * Returns the maximum value supported by the slider.
     *
     * @return the value of the model's maximum property
     * @see #setMaximum
     **/
    public int getMaximum() {  
        return getModel().getMaximum(); 
    } 


    /**
     * Sets the model's maximum property.  
     * 
     * @see #getMaximum
     * @see BoundedRangeModel#setMaximum
     * @beaninfo
     *   preferred: true
     * description: The slider's maximum value.
     */
    public void setMaximum(int maximum) {  
        getModel().setMaximum(maximum); 
    } 


    /**
     * @return VERTICAL or HORIZONTAL
     * @see #setOrientation
     */
    public int getOrientation() {  
        return orientation; 
    } 


    /**
     * Set the scrollbar's orientation to either VERTICAL or HORIZONTAL.
     * 
* @exception IllegalArgumentException 
     *            if orientation is not one of VERTICAL, HORIZONTAL
     * @see #getOrientation
     * @beaninfo
     *   preferred: true
     *       bound: true
* description: Set the scrollbar's orientation to either 
     *              VERTICAL or HORIZONTAL.
     *        enum: VERTICAL SwingConstants.VERTICAL 
     *              HORIZONTAL SwingConstants.HORIZONTAL
     * 
     */
    public void setOrientation(int orientation) 
    {  
        checkOrientation(orientation);
        int old = orientation;
        this.orientation = orientation;
        firePropertyChange( ORIENTATION_PROPERTY, old, orientation );

        if ((old != orientation) &amp;&amp; (accessibleContext != null)) { 
            accessibleContext.firePropertyChange(
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    ((old == VERTICAL) 
                     ? AccessibleState.VERTICAL : 
                       AccessibleState.HORIZONTAL),
                    ((orientation == VERTICAL) 
                     ? AccessibleState.VERTICAL : 
                       AccessibleState.HORIZONTAL));
        } 
    } 
    

    /**
* This method returns the major tick spacing.  The number that is 
     * returned represents the distance, measured in values, between 
     * each major tick mark. If you have a slider with a range from 0 
     * to 50 and the major tick spacing is set to 10, you will get 
     * major ticks next to the following values: 0, 10, 20, 30, 40, 50.
     *
     * @return the number of values between major ticks
     * @see #setMajorTickSpacing
     */
    public int getMajorTickSpacing() {  
        return majorTickSpacing; 
    } 


    /**
* This method sets the major tick spacing.  The number that is 
     * passed in represents the distance, measured in values, between 
     * each major tick mark. If you have a slider with a range from 0 
     * to 50 and the major tick spacing is set to 10, you will get major
     * ticks next to the following values: 0, 10, 20, 30, 40, 50.
     *
     * @see #getMajorTickSpacing
     * @beaninfo
     *       bound: true
     * description: Sets the number of values between major tick marks.
     * 
     */
    public void setMajorTickSpacing(int n) { 
        int old = majorTickSpacing;
        majorTickSpacing = n;
firePropertyChange( MAJORTICKSPACING_PROPERTY, 
                            old, majorTickSpacing);
    } 


    
    /**
* This method returns the minor tick spacing.  The number that is 
     * returned represents the distance, measured in values, between each
     * minor tick mark. If you have a slider with a range from 0 to 50
     * and the minor tick spacing is set to 10, you will get minor ticks
     * next to the following values: 0, 10, 20, 30, 40, 50.
     *
     * @return the number of values between minor ticks
     * @see #getMinorTickSpacing
     */
    public int getMinorTickSpacing() {  
        return minorTickSpacing; 
    } 


    /**
* This method sets the minor tick spacing.  The number that is 
     * passed in represents the distance, measured in values, between 
     * each minor tick mark. If you have a slider with a range from 0 to
     * 50 and the minor tick spacing is set to 10, you will get minor 
     * ticks next to the following values: 0, 10, 20, 30, 40, 50.
     *
     * @see #getMinorTickSpacing
     * @beaninfo
     *       bound: true
     * description: Sets the number of values between minor tick marks.
     */
    public void setMinorTickSpacing(int n) {  
        int old = minorTickSpacing;
        minorTickSpacing = n; 
        firePropertyChange( MINORTICKSPACING_PROPERTY, 
                            old, minorTickSpacing);
    } 


    /**
     *
     * @return The size of major ticks, in pixels
     * @see #setMajorTickSpacing
     **/
    public int getMajorTickSize() {  
        return majorTickSize; 
    } 


    /**
     * @see #getMajorTickSize
     * @beaninfo
     *       bound: true
     * description: Sets the size of major tick marks.
     * 
     **/
    public void setMajorTickSize( int majorTickSize ) { 
        int old = this.majorTickSize;
        this.majorTickSize = majorTickSize;
        firePropertyChange( MAJORTICKSIZE_PROPERTY, old, majorTickSize);
    } 


    /**
     * @return The size of minor ticks, in pixels
     * @see #setMinorTickSpacing
     **/
    public int getMinorTickSize() {  
        return minorTickSize; 
    } 


    /**
     * @see #getMinorTickSize
     * @beaninfo
     *       bound: true
     * description: Sets the size of minor tick marks.
     * 
     **/
    public void setMinorTickSize( int minorTickSize ) { 
        int old = this.minorTickSize;
        this.minorTickSize = minorTickSize;
        firePropertyChange( MINORTICKSIZE_PROPERTY, old, minorTickSize );
    } 


    /**
     * @return true if tick marks are painted, else false
     * @see #setPaintTicks
     **/
    public boolean isPaintTicks() {  
        return paintTicks; 
    } 


    /**
     * Determines whether tick marks are painted on the slider.
     * @see #getPaintTicks
     * @beaninfo
     *       bound: true
     * description: If true tick marks are painted on the slider.
     */
    public void setPaintTicks( boolean b ) {  
        boolean old = paintTicks;
        paintTicks = b;
        firePropertyChange( PAINTTICKS_PROPERTY, old, paintTicks);
    } 


    /**
     * @return true if labels are painted, else false
     * @see #setPaintLabels
     */
    public boolean isPaintLabels() {  
        return paintLabels; 
    } 

    
    /**
     * Determines whether labels are painted on the slider.
     * @see #getPaintLabels
     * @beaninfo
     *       bound: true
     * description: If true labels are painted on the slider.
     */
    public void setPaintLabels(boolean b) { 
        boolean old = paintLabels;
        paintLabels = b;
        firePropertyChange( PAINTLABELS_PROPERTY, old, paintLabels);
    }    


    /**
     * Returns the dictionary of what labels to draw at which values.
     *
     * @return the Dictionary containing labels and where to draw them
     */
    public Dictionary getLabelTable() { 

        if ( labelTable == null &amp;&amp; getMajorTickSpacing() &gt; 0 ) { 
setLabelTable(createStandardLabels( getMajorTickSpacing() ));
        } 

        return labelTable;
    } 


    /**
     * Used to specify what label will be drawn at any given value.
* The key-value pairs are of this format:
     * &lt;B&gt;{  Integer value, java.awt.Component label } &lt;/B&gt;
     *
     * @see #createStandardLabels
     * @see #getLabelTable
     * @beaninfo
     *      hidden: true
     *       bound: true
     * description: Specifies what labels will be drawn for
     *              any given value.
     */
    public void setLabelTable( Dictionary labels ) { 
        Dictionary old = labelTable;
        labelTable = labels;
        updateLabelUIs();
        firePropertyChange( PAINTLABELTABLE_PROPERTY, old, labelTable );
    } 


    /**
* Creates a hashtable that will draw text labels starting at the
     * slider minimum using the increment specified. If you call 
     * createStandardLabels( 10 ) and the slider minimum is zero,
     * then it will make labels for the values 0, 10, 20, 30, and so on.
     * @see #setLabelTable
     */
    public Hashtable createStandardLabels( int increment ) { 
        return createStandardLabels( increment, getMinimum() );
    } 


    /**
* Creates a hashtable that will draw text labels starting at the 
     * start point specified using the increment specified. If you call 
     * createStandardLabels( 10, 2 ), then it will make labels for the 
     * values 2, 12, 22, 32, and so on.
     * @see #setLabelTable
     */
    public Hashtable createStandardLabels( int increment, int start ) { 
        if ( start &gt; getMaximum() || start &lt; getMinimum() ) { 
throw new IllegalArgumentException( 
                &quot;Slider label start point out of range.&quot; );
        } 

        Hashtable table = new Hashtable();

for ( int labelIndex = start; labelIndex &lt;= getMaximum(); 
                                labelIndex += increment ) { 
            table.put( new Integer( labelIndex ), 
                       new JLabel( &quot;&quot;+labelIndex, JLabel.CENTER ) );
        } 

        return table;
    } 


    /**
     * @param value The number to determine where it lies in the chart.
     * @return The pixel where the given value falls on this axis.
     **/
    public int getLocationValue( double value ) { 
    
        Dimension size = getSize();
        Insets insets = getInsets();
        int minimum = getMinimum();
        int range = getMaximum() - minimum;
        int length;
        int start;
        int location;
        
        if( getOrientation() == VERTICAL ) { 
            length = size.height - insets.top - insets.bottom - 1;
            start = insets.bottom;
location = ( int )Math.round( start - 
                 ( ( double )length / ( double )range ) * ( value - minimum ) );
        
            //
            // Range check the location.
            //
            int end = start - length + 1;
            location = Math.min( start, location );
            location = Math.max( end, location );
        }  else { 
            length = size.width - insets.right - insets.left - 1;
            start = insets.left;
location = ( int )Math.round( start + 
      ( ( double )length / ( double )range ) * ( value - minimum ) );
            

        } 
                
        return( location );
    } 
    

    /**
     * Returns a string that displays and identifies this
     * object's properties.
     */
    public String toString()  { 
        String containerString = &quot;&quot;;

if (!isEnabled() &amp;&amp; !isVisible()) 
            containerString = &quot;(not Enabled, not Visible)&quot;;
        else if (!isEnabled()) containerString = &quot;(not Enabled)&quot;;
        else if (!isVisible()) containerString = &quot;(not Visible)&quot;;

        String sliderString =
            containerString +
            ((getOrientation() == 
              VERTICAL) ? &quot;vertical&quot; : &quot;horizontal&quot; ) + &quot;, &quot; +
            &quot;min=&quot; + getMinimum() + &quot;, &quot; +
            &quot;max=&quot; + getMaximum() + &quot;, &quot; +
            &quot;majorTickSpacing=&quot; + getMajorTickSpacing() + &quot;, &quot; +
            &quot;minorTickSpacing=&quot; + getMinorTickSpacing() + &quot;, &quot; +
            &quot;majorTickSize=&quot; + getMajorTickSize() + &quot;, &quot; +
            &quot;paintLabels=&quot; + isPaintLabels() + &quot;, &quot; +
            &quot;paintTicks=&quot; + isPaintTicks();

        return getClass().getName() + &quot;[&quot; + sliderString + &quot;]&quot;;
    } 


    /** 
     * See readObject() and writeObject() in JComponent for more 
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException { 
        s.defaultWriteObject();
     if ((ui != null) &amp;&amp; (getUIClassID().equals(uiClassID))) { 
             ui.installUI(this);
         } 
    } 


/////////////////
// Accessibility support
////////////////

    /**
     * Get the AccessibleContext associated with this JComponent
     *
     * @return the AccessibleContext of this JComponent
     */
    public AccessibleContext getAccessibleContext() { 
        if (accessibleContext == null) { 
            accessibleContext = new AccessibleFAxis();
        } 
        return accessibleContext;
    } 

    /**
     * The class used to obtain the accessible role for this object.
     * &lt;p&gt;
     **/
    protected class AccessibleFAxis extends AccessibleJComponent
        implements AccessibleValue { 

        /**
         * Get the state set of this object.
         *
* @return an instance of AccessibleState containing 
         *         the current state
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() { 
            AccessibleStateSet states = super.getAccessibleStateSet();
            if (getOrientation() == VERTICAL) { 
                states.add(AccessibleState.VERTICAL);
            }  else { 
                states.add(AccessibleState.HORIZONTAL);
            } 
            return states;
        } 

        /**
         * Get the role of this object.
         *
* @return an instance of AccessibleRole describing 
         *         the role of the object
         */
        public AccessibleRole getAccessibleRole() { 
            return AccessibleRole.SWING_COMPONENT;
        } 

        /**
         * Get the AccessibleValue associated with this object if one
         * exists.  Otherwise return null.
         */
        public AccessibleValue getAccessibleValue() { 
            return this;
        } 

        /**
         * Get the accessible value of this object.
         *
         * @return The current value of this object.
         */
        public Number getCurrentAccessibleValue() { 
            return new Integer(0);
        } 


        /**
         * Set the value of this object as a Number.
         *
         * @return True if the value was set.
         */
        public boolean setCurrentAccessibleValue(Number n) { 
            return( false );
        } 
        

        /**
         * Get the minimum accessible value of this object.
         *
         * @return The minimum value of this object.
         */
        public Number getMinimumAccessibleValue() { 
            return new Integer(getMinimum());
        } 

        /**
         * Get the maximum accessible value of this object.
         *
         * @return The maximum value of this object.
         */
        public Number getMaximumAccessibleValue() { 
            return new Integer(getMaximum());
        } 
        
    }  // AccessibleFAxis
}

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFAxisUIFONTTTFONTSIZEClassFONT"></A><TT>FAxisUI</TT> Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;

import javax.swing.*;

import javax.swing.plaf.ComponentUI;

import java.util.*;


/**
 * Class FAxisUI
 * &lt;p&gt;
 * The user-interface class for rendering FAxis
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class FAxisUI extends ComponentUI { 

    /**
     * The singleton instance of this class.
     **/
    private static FAxisUI shared = new FAxisUI();
       
    /**
     * FAxis, default Constructor.
     **/
    public FAxisUI() { 
        super();
    } 
    
    
    /**
     * Create the UI object for the given component.
     * This class may share the same UI object for
     * all FAxis that are created.
     * &lt;p&gt;
     * @param c The component that needs a UI.
     * @return The singleton UI Object.
     **/
    public static ComponentUI createUI( JComponent c ) { 
        return( shared );
    } 


    public void installUI(JComponent c) { 
  //      axis = (FAxis)c;
/*
        rendererPane = new CellRendererPane();
        table.add(rendererPane);
*/
        installDefaults( ( FAxis )c );
/*        
        installListeners();
        installKeyboardActions();
*/        
    } 
    
    

    


    /**
     * Determine the preferred size for the given FAxis.
     * &lt;p&gt;
     * @param c The component to calculate its preferred size.
     **/
    public Dimension getPreferredSize( JComponent c ) { 
        
        if ( !( c instanceof FAxis ) )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to getPreferredSize for &quot; 
                          + c + &quot; that is not an FAxis.&quot; );
        FAxis axis = ( FAxis )c;

        Dictionary labelTable = axis.getLabelTable();
        
        Dimension d = new Dimension();
        Insets insets = axis.getInsets();
        d.width = insets.left + insets.right;
         d.height = insets.top + insets.bottom;
        int tickSize = axis.getMajorTickSize();
         if( labelTable != null ) { 
             
            //
            // Get the font information.
            //
            Font font = axis.getFont();
            if( font == null ) { 
                font = ( Font )UIManager.get( &quot;Label.font&quot; );   
            } 

         FontMetrics fontMetrics = axis.getToolkit().getFontMetrics(font);
            int fontHeight = fontMetrics.getHeight();
                        
            if( axis.getOrientation() == SwingConstants.VERTICAL ) { 

                //
// Add the label width and height. The width is the 
                // longest single label. The height is the sum of 
                // all labels.
                //
                int width = 0;
                int height = 0;
                int thisWidth;
                
for( Enumeration e = labelTable.elements(); 
               e.hasMoreElements(); ) { 
                    Object o = e.nextElement();
                    if( o instanceof String ) { 
thisWidth = fontMetrics.stringWidth((String)o);
                        height += fontHeight;
                    }  else if( o instanceof Component ) { 
Dimension cSize = 
                    ( ( Component )o ).getPreferredSize();
                        thisWidth = cSize.width;
                        height += cSize.height;
                    }  else { 
thisWidth = 
                    fontMetrics.stringWidth( o.toString() );
                        height += fontHeight;
                    } 
                                        
                    width = Math.max( width, thisWidth );
                } 
                d.width += width + tickSize;
                d.height += height;             
            
            }  else { 
                //
                // Add the label width and height. The width is the sum
                // of the labels. The height is the tallest label.
                //
                int width = 0;
                int height = 0;
                int thisWidth;
                int thisHeight;

for( Enumeration e = labelTable.elements(); 
              e.hasMoreElements(); ) { 
                    Object o = e.nextElement();
                    if( o instanceof String ) { 
thisWidth = fontMetrics.stringWidth((String)o);
                        width += thisWidth;
                        thisHeight = fontHeight;
                    }  else if( o instanceof Component ) { 
Dimension cSize = 
                    ( ( Component )o ).getPreferredSize();
                        thisWidth = cSize.width;
                        width += thisWidth;
                        thisHeight = cSize.height;
                    }  else { 
thisWidth = 
                    fontMetrics.stringWidth( o.toString() );
                        width += thisWidth;
                        thisHeight = fontHeight;
                    } 

                    height = Math.max( height, thisHeight );
                } 
                
             d.width += width;
                d.height += height + tickSize;
            } 
        } 
        return d;
    } 
    
    
    /** 
     * Paint a representation of the &lt;code&gt;chart&lt;/code&gt; instance
     * that was set in installUI().
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param c The component to paint.
     **/
    public void paint( Graphics g, JComponent c ) { 

        if( !( c instanceof FAxis ) )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to paint for &quot; 
                          + c + &quot; that is not an FAxis.&quot; );
        FAxis axis = ( FAxis )c;
             
        g.setColor( axis.getForeground() );
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            int x = size.width - insets.right - 1;
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
             x -= 1;                   
             g.drawLine( x, insets.top,
                          x, size.height - insets.bottom );
        }  else { 
            int y = insets.top;
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
            y += 1;                         
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
        } 

        if( axis.isPaintTicks() ) { 
            paintMinorTicks( g, axis );
            paintMajorTicks( g, axis );
        } 
        if( axis.isPaintLabels() ) { 
            paintLabels( g, axis );
        } 
        
    }  // paint


    /**
     * Paint the minor tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose minor ticks need paints.
     **/
    protected void paintMinorTicks( Graphics g, FAxis axis ) { 

        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMinorTickSpacing();
        int tickSize = axis.getMinorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;

        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
               g.translate( 0, axisHeight );
            int x = size.width - insets.right - 1;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );
                g.drawLine( x - tickSize, position, x, position );
            } 
              g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 

    }  // paintMinorTicks
    

    /**
     * Paint the major tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose major ticks need paints.
     **/
    protected void paintMajorTicks( Graphics g, FAxis axis ) { 

        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMajorTickSpacing();
        int tickSize = axis.getMajorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;

        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
              g.translate( 0, axisHeight );
            int x = size.width - insets.right - 1;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );
                g.drawLine( x - tickSize, position, x, position );
            } 
             g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 
                
    }  // paintMajorTicks


    /**
* Called for every label in the label table.  
     * Used to draw the labels for horizontal axis.
     * The graphics have been translated to labelRect.y already.
     * @see JAxis#setLabelTable
     **/
protected void paintHorizontalLabel( Graphics g, FAxis axis, 
                                         int value, Component label ) { 
        int tickSize = axis.getMajorTickSize();
        int labelCenter = axis.getLocationValue( ( double )value );
int labelLeft = labelCenter &ntilde; 
                  (label.getPreferredSize().width / 2);
        g.translate( labelLeft, tickSize );
        label.paint( g );
        g.translate( -labelLeft, -tickSize );
    } 


    /**
* Called for every label in the label table.  
     * Used to draw the labels for vertical axis.
     * The graphics have been translated to labelRect.x already.
     * @see FAxis#setLabelTable
     */
protected void paintVerticalLabel( Graphics g, FAxis axis, 
                                       int value, Component label ) { 
        int labelCenter = axis.getLocationValue( ( double )value );
int labelTop = labelCenter &ntilde; 
                 (label.getPreferredSize().height / 2);
        g.translate( 0, labelTop );
        label.paint( g );
        g.translate( 0, -labelTop );
    } 


    /**
     * Paint the labels for the axis.
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param axis The axis whose labels to print.
     **/
    public void paintLabels( Graphics g, FAxis axis ) { 

        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
int axisHeight = size.height - (insets.top + insets.bottom) - 1;
        
        Dictionary dictionary = axis.getLabelTable();
        if ( dictionary != null ) { 
            Enumeration keys = dictionary.keys();
            while( keys.hasMoreElements() ) { 
                Integer key = ( Integer )keys.nextElement();
                Component label = ( Component )dictionary.get( key );

                if(axis.getOrientation() == SwingConstants.HORIZONTAL) { 
                     g.translate( 0, insets.top );
paintHorizontalLabel(g, axis, key.intValue(), label);
                  g.translate( 0, -insets.top );
                }  else { 
                  g.translate( insets.right, axisHeight );
                    paintVerticalLabel( g, axis, key.intValue(), label );
                    g.translate( -insets.right, -axisHeight );
                } 
            } 
        } 

    }  // paintLabels
    
}  // FAxisUI


</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFChartFONTTTFONTSIZEClassFONT"></A><TT>FChart</TT> Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;
import java.beans.*;
import java.io.*;

import javax.swing.*;

import javax.swing.table.TableModel;


/**
 * Class FChart
 * A class that displays a chart containing
 * numerical data in a TableModel.
 * &lt;p&gt;
 * @beaninfo
 *      attribute: isContainer false
 *    description: A chart component
 * @author Mike Foley
 * @version 1.2
 **/
public class FChart extends JComponent
    implements Serializable { 

    /**
     * @see #getUIClassID
     **/
    private static final String uiClassID = &quot;FChartUI&quot;;

    /**
     * The X and Y Axis.
     **/
    private FAxis xAxis;
    private FAxis yAxis;

    /**
     * The color of the grid
     **/
    protected Color gridColor = Color.lightGray;

    /**
* The table draws horizontal lines between cells if 
     * showHorizontalLines is true
     **/
    protected boolean showHorizontalLines;

    /**
* The table draws vertical lines between cells if 
     * showVerticalLines is true
     **/
    protected boolean showVerticalLines;

    private TableModel model;

    /**
     * Bound property names.
     **/
    public static final String MODEL_PROPERTY = &quot;model&quot;;
    public static final String XAXIS_PROPERTY = &quot;XAxis&quot;;
    public static final String YAXIS_PROPERTY = &quot;YAxis&quot;;
    public static final String GRIDCOLOR_PROPERTY = &quot;GridColor&quot;;
public static final String SHOWHORIZONTALLINES_PROPERTY = 
                         &quot;ShowHorizontalLines&quot;;
    public static final String SHOWVERTICALLINES_PROPERTY = 
                         &quot;ShowVerticalLines&quot;;


    /**
     * FChart, default constructor.
     **/
    public FChart() { 
        this( null );
    } 


    /**
     * FChart, constructor.
     * &lt;p&gt;
     * Create a chart viewing the given model.
     * &lt;p&gt;
     * @param model The model for the chart to view.
     **/
    public FChart( TableModel model ) { 

        setLayout( new FChartLayoutManager() );
        setXAxis( new FAxis( SwingConstants.HORIZONTAL ) );
        setYAxis( new FAxis( SwingConstants.VERTICAL ) );
        setModel( model );

        updateUI();

    }  // FChart


    /**
     * Initialize this class with the UIManager.
     **/
    public static void initialize() { 

        setLookAndFeelProperties( UIManager.getLookAndFeel() );

UIManager.addPropertyChangeListener( 
            new PropertyChangeListener() { 
            public void propertyChange( PropertyChangeEvent event ) { 
                if( &quot;lookAndFeel&quot;.equals( event.getPropertyName() ) ) { 
setLookAndFeelProperties( 
                ( LookAndFeel )event.getNewValue() );
                } 
            } 
        }  );

    } 


public static void setLookAndFeelProperties( 
                 LookAndFeel lookAndFeel ) { 

        if( lookAndFeel == null )
            return;

        if( lookAndFeel.getID().equals( &quot;Metal&quot; ) ) { 
            //
            // Metal, or Metal complient look-and-feel
            //
UIManager.put( &quot;FChartUI&quot;, &quot;com.foley.chart.MetalFChartUI&quot; );
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.MetalFAxisUI&quot; );
        }  else if( lookAndFeel.getID().equals( &quot;Windows&quot; ) ) { 
            //
            // Windows, or Windows complient look-and-feel
            //
UIManager.put(&quot;FChartUI&quot;, &quot;com.foley.chart.WindowsFChartUI&quot;);
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.WindowsFAxisUI&quot; );
        }  else { 
            //
            // Unsupported look-and-feel, use default
            //
            UIManager.put( &quot;FChartUI&quot;, &quot;com.foley.chart.FChartUI&quot; );
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.FAxisUI&quot; );
         } 

    }  // setLookAndFeelProperties


    /**
     * Returns the L&amp;F object that renders this component.
     *
     * @return the FChartUI object that renders this component
     **/
    public FChartUI getUI() { 
        return( FChartUI )ui;
    } 


    /**
     * Sets the L&amp;F object that renders this component.
     *
     * @param ui  the FChartUI L&amp;F object
     * @see UIDefaults#getUI
     **/
    public void setUI( FChartUI ui ) { 
        super.setUI( ui );
    } 


    /**
     * Notification from the UIManager that the L&amp;F has changed.
     * Replaces the current UI object with the latest version from the
     * UIManager.
     *
     * @see JComponent#updateUI
     **/
    public void updateUI() { 
        setUI( ( FChartUI )UIManager.getUI( this ) );
        invalidate();
    } 


    /**
     * Returns the name of the L&amp;F class that
     * renders this component.
     *
     * @return &quot;FChartUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     **/
    public String getUIClassID() { 
        return uiClassID;
    } 


    /**
     * See readObject() and writeObject() in JComponent for more
     * information about serialization in Swing.
     * &lt;p&gt;
     * @exception IOException If the write cannot be performed.
     **/
    private void writeObject( ObjectOutputStream s )
        throws IOException { 

        s.defaultWriteObject();
         if( ( ui != null ) &amp;&amp; ( getUIClassID().equals( uiClassID ) ) ) { 
             ui.installUI( this );
         } 
    } 


    /**
     * Set the X Axis for the chart.
     * This is a bound property.
     * &lt;p&gt;
     * @param xAxis the new X Axis for the chart.
     * @see #getXAxis
     * @beaninfo
     *       bound: true
     * description: The X Axis for the chart.
     **/
    public void setXAxis( FAxis xAxis ) { 

        FAxis old = this.xAxis;

        if( this.xAxis != null )
            remove( this.xAxis );
        this.xAxis = xAxis;
        if( this.xAxis != null ) { 
            add( xAxis );
            xAxis.setSize( xAxis.getPreferredSize() );
        } 
        firePropertyChange( XAXIS_PROPERTY, old, xAxis );

    } 


    /**
     * @return The current X Axis for the chart.
     * @see #setXAxis
     **/
    public FAxis getXAxis() { 
        return( this.xAxis );
    } 


    /**
     * Set the Y Axis for the chart.
     * This is a bound property.
     * &lt;p&gt;
     * @param yAxis the new Y Axis for the chart.
     * @see #getYAxis
     * @beaninfo
     *       bound: true
     * description: The Y Axis for the chart.
     **/
    public void setYAxis( FAxis yAxis ) { 
        if( this.yAxis != null )
            remove( this.yAxis );
        this.yAxis = yAxis;
        if( this.yAxis != null ) { 
            add( yAxis );
            yAxis.setSize( yAxis.getPreferredSize() );
        } 
    } 


    /**
     * @return the current Y axis for the chart.
     * @see #setYAxis
     **/
    public FAxis getYAxis() { 
        return( this.yAxis );
    } 


    /**
     * Set the model that the chart views.
     * The first column in the model specifies X
     * coordinate values. The remaining columns
     * specify y coordinates for each trace. This
     * implies that a model with four columns has
     * three traces in the chart.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param model The new TableModel for the chart.
     * @see #getModel
     * @beaninfo
     *       bound: true
     * description: The data the chart contains.
     **/
    public void setModel( TableModel model ) { 
        TableModel old = this.model;
        this.model = model;
        firePropertyChange( MODEL_PROPERTY, old, model );
    } 


    /**
     * @return The current data model for the chart.
     * @see #setModel
     **/
    public TableModel getModel() { 
        return( this.model );
    } 


    /**
     * Sets the color used to draw grid lines to &lt;I&gt;color&lt;/I&gt; and 
     * redisplays the receiver. The default color is gray.
     *
     * @param gridColor The Color of the grid
     * @exception IllegalArgumentException if &lt;I&gt;color&lt;/I&gt; is null
     * @see #getGridColor()
     * @beaninfo
     *       bound: true
     * description: The color for the grid in the chart.
     **/
    public void setGridColor( Color gridColor ) { 
        if( gridColor == null ) { 
throw new IllegalArgumentException( 
                &quot;The grid color may not be null.&quot; );
        } 
        Color old = this.gridColor;
        this.gridColor = gridColor;

        firePropertyChange( GRIDCOLOR_PROPERTY, old, gridColor );

        repaint();

    }  // setGridColor


    /**
     * Returns the color used to draw grid lines.
     * The default color is look-and-feel dependent.
     * &lt;p&gt;
     * @return  the color used to draw grid lines
     * @see     #setGridColor()
     **/
    public Color getGridColor() { 
        return gridColor;
    } 


    /**
     * If true, the chart displays grid lines corresponding
     * to the major tick marks on the axis.
     * &lt;p&gt;
     * This is not a bound property. Instead the two component
     * lines are bound. I.e. horizontal lines and vertical lines
     * are bound properties.
     * &lt;p&gt;
     * @param showGrid If true draw grid lines, if false don't.
     * @see #setShowHorizontalLines
     * @see #setShowVerticalLines
     * @beaninfo
     *       bound: false
     * description: True to draw grid lines in the chart.
     **/
    public void setShowGrid( boolean showGrid ) { 
        setShowHorizontalLines( showGrid );
        setShowVerticalLines( showGrid );

        repaint();
    } 


    /**
     * If true, draw horizontal lines on the chart that correspond
     * to the Y axis major tick marks.
     *
* @param showHorizontalLines true if chart should 
     *                            draw horizontal lines.
     * @see #getShowHorizontalLines
     * @see #setShowGrid
     * @see #setShowVerticalLines
     * @beaninfo
     *       bound: true
* description: Whether horizontal lines 
     *              should be drawn on the chart.
     **/
    public void setShowHorizontalLines( boolean showHorizontalLines ) { 

        boolean old = this.showHorizontalLines;
        this.showHorizontalLines = showHorizontalLines;

firePropertyChange( SHOWHORIZONTALLINES_PROPERTY, 
                            old, showHorizontalLines );

        repaint();
    } 


    /**
     * Returns true if the chart draws horizontal lines on
     * the chart, and false if it doesn't.
     * &lt;p&gt;
     * @return true if the chart draws horizontal lines, false otherwise
     * @see #setShowHorizontalLines
     **/
    public boolean isShowHorizontalLines() { 
        return( showHorizontalLines );
    } 


    /**
     * Sets whether the chart draws vertical lines that correspond
     * to the major ticks on the X axis.
     * &lt;p&gt;
* @param showVerticalLines true if the chart should 
     *                          draw vertical lines.
     * @see #getShowVerticalLines
     * @see #setShowGrid
     * @see #setShowHorizontalLines
     * @beaninfo
* description: Whether vertical lines should be 
     *              drawn in between the cells.
     **/
    public void setShowVerticalLines( boolean showVerticalLines ) { 
        boolean old = this.showVerticalLines;
        this.showVerticalLines = showVerticalLines;

firePropertyChange( SHOWVERTICALLINES_PROPERTY, 
                            old, showVerticalLines );

        repaint();
    } 


    /**
     * Returns true if the chart draws vertical lines on
     * the chart, and false if it doesn't.
     * &lt;p&gt;
     * @return true if the chart draws vertical lines, false otherwise
     * @see #setShowVerticalLines
     **/
    public boolean isShowVerticalLines() { 
        return( showVerticalLines );
    } 

    public Color getTraceColor( int trace ) { 
        Color[] color = new Color[4];
        color[0] = java.awt.Color.yellow;
        color[1] = java.awt.Color.blue;
        color[2] = java.awt.Color.red;
        color[3] = java.awt.Color.black;
        return( color[ trace ] );
    } 

}  // FChart

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFChartLayoutManagerFONTTTFONTSIZEClassFONT"></A><TT>FChartLayoutManager</TT>
Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;


/**
 * A layout manager for the FChart Class.
 * &lt;p&gt;
 * The class lays out an X and Y axis. The X axis
 * is along the bottom of the component, and the Y
 * along the left edge.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class FChartLayoutManager extends Object 
    implements LayoutManager { 
    
    /**
     * Adds the specified component with the specified name to
     * the layout.
     * @param name the component name
     * @param comp the component to be added
     */
    public void addLayoutComponent( String name, Component comp ) { 
        // Not used.
    } 
    

    /**
     * Removes the specified component from the layout.
     * @param comp the component to be removed
     */
    public void removeLayoutComponent( Component comp ) { 
        // Not used.
    } 


    /**
     * Calculates the preferred size dimensions for the specified 
     * panel given the components in the specified parent container.
     * @param parent the component to be laid out
     *  
     * @see #minimumLayoutSize
     */
    public Dimension preferredLayoutSize( Container parent ) { 

        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );

        FChart chart = ( FChart )parent;
        Insets insets = chart.getInsets();
        
        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        
        Dimension xAxisSize = xAxis.getPreferredSize();
        Dimension yAxisSize = yAxis.getPreferredSize();
        
        Dimension ourSize = new Dimension();
ourSize.width = insets.right + insets.left + 
                  xAxisSize.width + yAxisSize.width + 10;
        ourSize.height = insets.top + insets.bottom + 
                   xAxisSize.height + yAxisSize.height + 10;

        return( ourSize );
        
    }  // preferredLayoutSize


    /** 
     * Calculates the minimum size dimensions for the specified 
     * panel given the components in the specified parent container.
     * @param parent the component to be laid out
     * @see #preferredLayoutSize
     */
    public Dimension minimumLayoutSize( Container parent ) { 

        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );

        FChart chart = ( FChart )parent;
        Insets insets = chart.getInsets();

        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        
        Dimension xAxisSize = xAxis.getMinimumSize();
        Dimension yAxisSize = yAxis.getMinimumSize();
        
        Dimension ourSize = new Dimension();
ourSize.width = insets.right + insets.left + 
                  xAxisSize.width + yAxisSize.width;
        ourSize.height = insets.top + insets.bottom + 
                   xAxisSize.height + yAxisSize.height;

        return( ourSize );

    }  // minimumLayoutSize


    /** 
     * Lays out the container in the specified panel.
     * @param parent the component which needs to be laid out 
     */
    public void layoutContainer( Container parent ) { 
        
        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );

        FChart chart = ( FChart )parent;
        Dimension ourSize = chart.getSize();
        Insets insets = chart.getInsets();

        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        Dimension xAxisSize = xAxis.getPreferredSize();
        Dimension yAxisSize = yAxis.getPreferredSize();

        xAxis.setBounds( yAxisSize.width + insets.left, 
                       ourSize.height - xAxisSize.height - insets.bottom,
                       ourSize.width - yAxisSize.width &ntilde; 
                 insets.right - insets.left, 
                       xAxisSize.height );
        yAxis.setBounds( insets.top, 
                        insets.left, 
                        yAxisSize.width, 
ourSize.height - xAxisSize.height &ntilde; 
                  insets.top - insets.bottom );
                        
    }  // layoutContainer
    
}  // FChartLayoutManager


</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFChartUIFONTTTFONTSIZEClassFONT"></A><TT>FChartUI</TT> Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;
import java.beans.*;

import javax.swing.JComponent;
import javax.swing.table.TableModel;
import javax.swing.event.*;

import javax.swing.plaf.ComponentUI;


/**
 * Class FChartUI
 * &lt;p&gt;
 * The user-interface class for rendering FChart
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class FChartUI extends ComponentUI 
    implements PropertyChangeListener, TableModelListener { 

    /**
     * The FChart we are rendering.
     **/
    private FChart chart;
    
    
    /**
     * FChartUI, null constructor.
     **/
    public FChartUI() { 
        chart = null;
    } 


    /**
     * This UI may not be shared. Create a new
     * instance for each component.
     * &lt;p&gt;
     * @param c The component needing a UI.
     **/
    public static ComponentUI createUI(JComponent c) { 
        return( new FChartUI() );
    } 


    /**
     * Install ourself as the UI for the given component.
     * We need to get property changes from the chart.
     * This way we can keep in sync with the chart's values.
     * &lt;p&gt;
     * @param c The component we are the UI for.
     **/
    public void installUI( JComponent c ) { 
        chart = ( FChart )c;
        TableModel model = chart.getModel();
        if( model != null ) 
            model.addTableModelListener( this );
        chart.addPropertyChangeListener( this );
    } 
    
    
    /**
     * Uninstall ourself as the UI for the given component.
     * Remove ourself as a PropertyChangeListener.
     * &lt;p&gt;
     * @param c The component we are uninstalling.     
     **/
    public void uninstallUI(JComponent c) { 
        if( chart != c )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to uninstallUI for &quot; 
                          + c + &quot; that is not my chart &quot; + chart + &quot;.&quot; );

        chart.removePropertyChangeListener( this );
        TableModel model = chart.getModel();
        if( model != null ) 
            model.removeTableModelListener( this );
    } 


    /**
     * tableChanged, from TableModelListener
     * &lt;p&gt;
     * The data in the table changed, repaint the chart.
     * &lt;p&gt;
     * @param event The change in the model.
     **/
    public void tableChanged( TableModelEvent event ) { 
        chart.repaint();
    } 


    /**
     * propertyChange, from PropertyChangeListener
     * &lt;p&gt;
     * If the change is a table model change start listening
     * to the new model.
     * &lt;p&gt;
     * @param event The change.
     **/
    public void propertyChange( PropertyChangeEvent event ) { 
        if( event.getPropertyName().equals( FChart.MODEL_PROPERTY ) ) { 
            TableModel model = ( TableModel )event.getOldValue();
            if( model != null )
                model.removeTableModelListener( this );

            model = ( TableModel )event.getNewValue();
            if( model != null ) { 
                model.addTableModelListener( this );
            } 
        } 
    } 


    /**
     * @return The preferred size of this component.
     **/
    public Dimension getPreferredSize( JComponent c ) { 
        
        Insets insets = chart.getInsets();
        
        FAxis axis = chart.getXAxis();
        Dimension ourSize = new Dimension();
        Dimension x = axis.getPreferredSize();        
        
        axis = chart.getYAxis();
        Dimension y = axis.getPreferredSize(); 
        
        ourSize.width = x.width + y.width + insets.right + insets.left;
        ourSize.height = x.height + y.height + 
                   insets.top + insets.bottom;

        return( ourSize );
    } 


    /** 
     * Paint a representation of the &lt;code&gt;chart&lt;/code&gt; instance
     * that was set in installUI().
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param c The component to paint.
     **/
    public void paint( Graphics g, JComponent c ) { 

        if( !( c instanceof FChart ) )
            return;

        TableModel model = chart.getModel();
        //
        // No data, no paint.
        //
        if( model == null )
            return;

        Dimension ourSize = c.getSize();            
        
        FAxis xAxis = chart.getXAxis();        
        FAxis yAxis = chart.getYAxis();
        Dimension yAxisSize = yAxis.getSize();

        g.translate( yAxisSize.width, yAxisSize.height - 1 );

        if( chart.isShowHorizontalLines() ) { 
            paintHorizontalLines( g, xAxis, yAxis );
        } 
                    
        if( chart.isShowVerticalLines() ) { 
            paintVerticalLines( g, xAxis, yAxis );
        } 

        //
        // Now paint the traces.
        //
        for( int j = 1; j &lt; model.getColumnCount(); j++ ) { 

            g.setColor( chart.getTraceColor( j-1 ) );
            
            Number o0 = ( Number )model.getValueAt( 0, 0 );
            Number o1 = ( Number )model.getValueAt( 0, j );
            int x0 = xAxis.getLocationValue( o0.doubleValue() );
            int y0 = yAxis.getLocationValue( o1.doubleValue() );

            for( int i = 1; i &lt; model.getRowCount(); i++ ) { 
                
                o0 = ( Number )model.getValueAt( i, 0 );
                o1 = ( Number )model.getValueAt( i, j );
                int x1 = xAxis.getLocationValue( o0.doubleValue() );
                int y1 = yAxis.getLocationValue( o1.doubleValue() );

                g.drawLine( x0, y0, x1, y1 );
                x0 = x1;
                y0 = y1;
            } 
        } 

        g.translate( -yAxisSize.width, -( yAxisSize.height - 1 ) );

    }  // paint


    /**
     * Paint the vertical grid lines in the chart.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param xAxis The chart's X axis.
     * @param yAxis The chart's Y axis.
     **/
protected void paintVerticalLines( Graphics g, 
                                 FAxis xAxis, FAxis yAxis ) { 

        g.setColor( chart.getGridColor() );

        int minimum = xAxis.getMinimum();
        int maximum = xAxis.getMaximum();
        int spacing = xAxis.getMajorTickSpacing();

        Insets insets = yAxis.getInsets();
        Dimension size = yAxis.getSize();
        int yAxisLength = size.height - (insets.top + insets.bottom) - 1;

        for( int i = minimum + spacing; i &lt;= maximum; i += spacing ) { 
            int position = xAxis.getLocationValue( ( double )i );
            g.drawLine( position, 0, position, -yAxisLength );
        } 

    } 


    /**
     * Paint the horizontal grid lines in the chart.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param xAxis The chart's X axis.
     * @param yAxis The chart's Y axis.
     **/
    protected void paintHorizontalLines( Graphics g, 
                                   FAxis xAxis, FAxis yAxis ) { 

        g.setColor( chart.getGridColor() );

        int minimum = yAxis.getMinimum();
        int maximum = yAxis.getMaximum();
        int spacing = yAxis.getMajorTickSpacing();

        Insets insets = xAxis.getInsets();
        Dimension size = xAxis.getSize();
        int xAxisLength = size.width - (insets.left + insets.right) - 1;

        for( int i = minimum + spacing; i &lt;= maximum; i += spacing ) { 
            int position = yAxis.getLocationValue( ( double )i );
            g.drawLine( 0, position, xAxisLength, position );
        } 

    } 

}  // FChartUI

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEMetalFAxisUIFONTTTFONTSIZEClassFONT"></A><TT>MetalFAxisUI</TT>
Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;

import javax.swing.*;

import javax.swing.plaf.ComponentUI;

import javax.swing.plaf.metal.MetalLookAndFeel;

import java.util.*;


/**
 * Class MetalFAxisUI
 * &lt;p&gt;
 * The Metal user-interface class for rendering FAxis
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class MetalFAxisUI extends FAxisUI { 


    public MetalFAxisUI() { 
    } 


    public static ComponentUI createUI(JComponent c) { 
        return( new MetalFAxisUI() );
    } 


    /** 
     * Paint a representation of the &lt;code&gt;chart&lt;/code&gt; instance
     * that was set in installUI().
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param c The component to paint.
     **/
    public void paint( Graphics g, JComponent c ) { 

        if( !( c instanceof FAxis ) )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to paint for &quot; 
                          + c + &quot; that is not an FAxis.&quot; );
        FAxis axis = ( FAxis )c;
        
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            g.setColor( MetalLookAndFeel.getControl() );
            int x = size.width - insets.right - 1;
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
             x -= 1;                   
            g.setColor( MetalLookAndFeel.getControlHighlight() );
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
             x -= 1;                   
            g.setColor( MetalLookAndFeel.getControlDarkShadow() );
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
        }  else { 
            g.setColor( MetalLookAndFeel.getControlDarkShadow() );
            int y = insets.top;
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
            y += 1;                         
            g.setColor( MetalLookAndFeel.getControlHighlight() );
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
            y += 1;                         
            g.setColor( MetalLookAndFeel.getControl() );
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
        } 
    
        if( axis.isPaintTicks() ) { 
            paintMinorTicks( g, axis );
            paintMajorTicks( g, axis );
        } 
        Color foreground = axis.getForeground();  
        g.setColor( foreground );
        if( axis.isPaintLabels() ) { 
            paintLabels( g, axis );
        } 
        
    }  // paint

    
    /**
     * Paint the minor tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose minor ticks need paints.
     **/
    protected void paintMinorTicks( Graphics g, FAxis axis ) { 
                
        g.setColor( MetalLookAndFeel.getControlDarkShadow() );
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMinorTickSpacing();
        int tickSize = axis.getMinorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;
        
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
               g.translate( 0, axisHeight );
            int x = size.width - insets.right - 4;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( x - tickSize, position, x, position );
            } 
               g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top + 3;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 
                
    }  // paintMinorTicks
    

    /**
     * Paint the major tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose major ticks need paints.
     **/
    protected void paintMajorTicks( Graphics g, FAxis axis ) { 
                
        g.setColor( MetalLookAndFeel.getControlDarkShadow() );
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMajorTickSpacing();
        int tickSize = axis.getMajorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;
        
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
               g.translate( 0, axisHeight );
            int x = size.width - insets.right - 4;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( x - tickSize, position, x, position );
            } 
               g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top + 3;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 
                
    }  // paintMajorTicks

}  // MetalFAxisUI

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEMetalFChartUIFONTTTFONTSIZEClassFONT"></A><TT>MetalFChartUI</TT>
Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;
import java.beans.*;

import javax.swing.JComponent;
import javax.swing.table.TableModel;
import javax.swing.event.*;

import javax.swing.plaf.ComponentUI;


/**
 * Class MetalFChartUI
 * &lt;p&gt;
 * The Metal user-interface class for rendering FChart
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class MetalFChartUI extends FChartUI { 

    public MetalFChartUI() { 
    } 

    public static ComponentUI createUI( JComponent c ) { 
        return( new MetalFChartUI() );
    } 

    public void paint( Graphics g, JComponent c ) { 
        super.paint( g, c );
    } 

}  // MetalFChartUI

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEWindowsFAxisUIFONTTTFONTSIZEClassFONT"></A><TT>WindowsFAxisUI</TT>
Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;

import javax.swing.*;

import javax.swing.plaf.ComponentUI;

import java.util.*;


/**
 * Class WindowsFAxisUI
 * &lt;p&gt;
 * The Windows user-interface class for rendering FAxis
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class WindowsFAxisUI extends FAxisUI { 


    public WindowsFAxisUI() { 
    } 


    public static ComponentUI createUI(JComponent c) { 
        return( new WindowsFAxisUI() );
    } 



    /** 
     * Paint a representation of the &lt;code&gt;chart&lt;/code&gt; instance
     * that was set in installUI().
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param c The component to paint.
     **/
    public void paint( Graphics g, JComponent c ) { 

        if( !( c instanceof FAxis ) )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to paint for &quot; 
                          + c + &quot; that is not an FAxis.&quot; );
        FAxis axis = ( FAxis )c;
                
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            g.setColor( UIManager.getColor(&quot;controlHighlight&quot;) );
            int x = size.width - insets.right - 1;
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
             x -= 1;                   
            g.setColor( UIManager.getColor(&quot;controlLtHighlight&quot;) );
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
             x -= 1;                   
            g.setColor( UIManager.getColor(&quot;controlLtHighlight&quot;) );
             g.drawLine( x, insets.top,
                         x, size.height - insets.bottom );
        }  else { 
            g.setColor( UIManager.getColor(&quot;controlShadow&quot;) );
            int y = insets.top;
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
            y += 1;                         
            g.setColor( UIManager.getColor(&quot;controlShadow&quot;) );
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
            y += 1;                         
            g.setColor( UIManager.getColor(&quot;controlDkShadow&quot;) );
             g.drawLine( insets.left, y,
                         size.width - insets.right - 1, y );
        } 
    
        if( axis.isPaintTicks() ) { 
            paintMinorTicks( g, axis );
            paintMajorTicks( g, axis );
        } 
        Color foreground = axis.getForeground();  
        g.setColor( foreground );
        if( axis.isPaintLabels() ) { 
            paintLabels( g, axis );
        } 
        
    }  // paint

    
    /**
     * Paint the minor tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose minor ticks need paints.
     **/
    protected void paintMinorTicks( Graphics g, FAxis axis ) { 
                
        g.setColor( UIManager.getColor(&quot;controlDkShadow&quot;) );
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMinorTickSpacing();
        int tickSize = axis.getMinorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;
        
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
               g.translate( 0, axisHeight );
            int x = size.width - insets.right - 4;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( x - tickSize, position, x, position );
            } 
               g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top + 3;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 
                
    }  // paintMinorTicks
    

    /**
     * Paint the major tick marks on the axis.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param axis The axis whose major ticks need paints.
     **/
    protected void paintMajorTicks( Graphics g, FAxis axis ) { 
                
        g.setColor( UIManager.getColor(&quot;controlDkShadow&quot;) );
        Insets insets = axis.getInsets();
        Dimension size = axis.getSize();
        BoundedRangeModel model = axis.getModel();
        int minimum = model.getMinimum();
        int maximum = model.getMaximum();
        int spacing = axis.getMajorTickSpacing();
        int tickSize = axis.getMajorTickSize();
        int axisHeight = size.height - (insets.top + insets.bottom) - 1;
        
        if( axis.getOrientation() == SwingConstants.VERTICAL ) { 
            
               g.translate( 0, axisHeight );
            int x = size.width - insets.right - 4;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( x - tickSize, position, x, position );
            }
               g.translate( 0, -axisHeight );
        }  else { 
            int y = insets.top + 3;
            for( int i = minimum; i &lt;= maximum; i += spacing ) { 
                int position = axis.getLocationValue( ( double )i );           
                g.drawLine( position, y, position, y + tickSize );
            } 
        } 
                
    }  // paintMajorTicks

}  // WindowsFAxisUI

</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEWindowsFChartUIFONTTTFONTSIZEClassFONT"></A><TT>WindowsFChartUI</TT>
Class</H2>

<BLOCKQUOTE>
	<PRE>package com.foley.chart;

import java.awt.*;
import java.beans.*;

import javax.swing.JComponent;
import javax.swing.table.TableModel;
import javax.swing.event.*;

import javax.swing.plaf.ComponentUI;


/**
 * Class WindowsFChartUI
 * &lt;p&gt;
 * The Windows user-interface class for rendering FChart
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class WindowsFChartUI extends FChartUI { 

    public WindowsFChartUI() { 
    } 

    public static ComponentUI createUI(JComponent c) { 
        return( new WindowsFChartUI() );
    } 

}  // WindowsFChartUI

</PRE>
</BLOCKQUOTE>
<CENTER>
<P>
<HR SIZE="4">
<A HREF="..\apa\apa.htm"><IMG SRC="..\button\previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\index.htm"><IMG SRC="..\button\contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\apc\apc.htm"><IMG
SRC="..\button\next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A></P>
<P>&copy; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>
</BODY>
</HTML>
