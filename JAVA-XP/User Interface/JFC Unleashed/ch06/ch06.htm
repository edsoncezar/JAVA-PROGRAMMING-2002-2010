<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 6 - The Button Hierarchy</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch05\ch05.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch07\ch07.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;6<br>
The Button Hierarchy</H1>
<HR>
<p>

<UL>
<LI><A HREF="#TheTTFONTSIZEButtonModelFONTTTFONTSIZEInterfaceFONT">
The <TT>ButtonModel</TT>
Interface</A>
<LI><A HREF="#JFCButtonHierarchy">
JFC Button Hierarchy</A>
<LI><A HREF="#SimpleButtonsTheTTFONTSIZEJButtonFONTTTFONTSIZEClassFONT">
Simple Buttons: The <TT>JButton</TT>
Class</A>
<LI><A HREF="#UsingTTFONTSIZEActionFONTTTFONTSIZEswithButtonsFONT">
Using <TT>Action</TT>s with
Buttons</A>
<LI><A HREF="#TTFONTSIZEJToggleButtonFONTTT">
<TT>JToggleButton</TT></A>
<LI><A HREF="#CheckBoxes">
Check Boxes</A>
<LI><A HREF="#RadioButtons">
Radio Buttons</A>
<UL>
<LI><A HREF="#RadioButtonGroups">
Radio Button Groups</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The JFC provides many buttons that can be used in your graphical
user interfaces. These buttons include a push button, check box,
toggle button, and radio button. The various buttons are the first
you have encountered thus far that take advantage of the Model
View Controller architecture on which the JFC is built. In this
chapter, you will learn:
<UL>
<LI>The button model
<LI>The button hierarchy
<LI>How to create push buttons
<LI>Use an <TT>Action</TT>-aware button
<LI>How to create check boxes
<LI>How to create toggle buttons
<LI>How to create radio buttons
</UL>
<H2><A NAME="TheTTFONTSIZEButtonModelFONTTTFONTSIZEInterfaceFONT">
The <TT>ButtonModel</TT>
Interface</A></H2>
<P>
The <TT>ButtonModel</TT> interface defines the methods that must
be implemented by a class that is to behave as a model for a button.
This one interface is used for every button defined in the JFC.
This allows code written for one type of button to work with any
other, provided all interactions are done through the <TT>ButtonModel</TT>
interface.
<P>
The <TT>ButtonModel</TT> interface is presented in Listing 6.1.
The first thing you may notice is that the interface is quite
long, containing over twenty methods. There are three types of
listeners that can be added and five different Boolean states
that can be set and queried. All this for a single button!
<P>
The <TT>ButtonModel</TT> interface inherits from the AWT <TT>ItemSelectable</TT>
interface. The <TT>ItemSelectable</TT> interface is also shown
in the listing. The first interface provides for an <TT>ItemListener</TT>
and a method to query the selected objects.<p>
<HR>
<P>
<B>Listing 6.1&nbsp;&nbsp;</B><TT><B>BUTTONMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ItemSelectable
{ 
          // Methods 3
     public abstract void addItemListener(ItemListener);
     public abstract Object[] getSelectedObjects();
     public abstract void removeItemListener(ItemListener);
} 


public interface ButtonModel extends ItemSelectable { 
    
    /**
     * Indicates partial commitment towards pressing the
     * button. 
     *
     * @return true if the button is armed, and ready to be pressed
     * @see #setArmed
     */
    boolean isArmed();     
        
    /**
     * Indicates if the button has been selected. Only needed for
     * certain types of buttons - such as RadioButton or Checkbox.
     *
     * @return true if the button is selected
     */
    boolean isSelected();
        
    /**
     * Indicates if the button can be selected or pressed by
     * an input device (such as a mouse pointer). (Checkbox-buttons
     * are selected, regular buttons are &quot;pressed&quot;.)
     *
     * @return true if the button is enabled, and therefore
     *         selectable (or pressable)
     */
    boolean isEnabled();
        
    /**
     * Indicates if button has been pressed.
     *
     * @return true if the button has been pressed
     */
    boolean isPressed();

    /**
     * Indicates that the mouse is over the button.
     *
     * @return true if the mouse is over the button
     */
    boolean isRollover();

    /**
     * Marks the button as &quot;armed&quot;. If the mouse button is
     * released while it is over this item, the button's action event
     * fires. If the mouse button is released elsewhere, the
     * event does not fire and the button is disarmed.
     * 
     * @param b true to arm the button so it can be selected
     */
    public void setArmed(boolean b);

    /**
     * Selects or deselects the button.
     *
     * @param b true selects the button,
     *          false deselects the button.
     */
    public void setSelected(boolean b);

    /**
     * Enables or disables the button.
     * 
     * @param b true to enable the button
     * @see #isEnabled
     */
    public void setEnabled(boolean b);

    /**
     * Sets the button to pressed or unpressed.
     * 
     * @param b true to set the button to &quot;pressed&quot;
     * @see #isPressed
     */
    public void setPressed(boolean b);

    /**
     * Sets or clears the button's rollover state
     * 
     * @param b true to turn on rollover
     * @see #isRollover
     */
    public void setRollover(boolean b);

    /**
     * Sets the keyboard mnemonic (shortcut key or
     * accelerator key) for this button.
     *
     * @param key an int specifying the accelerator key
     */
    public void setMnemonic(int key);

    /**
     * Gets the keyboard mnemonic for this model
     *
     * @return an int specifying the accelerator key
     * @see #setMnemonic
     */
    public int  getMnemonic();

    /**
     * Sets the actionCommand string that gets sent as part of the
     * event when the button is pressed.
     *
     * @param s the String that identifies the generated event
     */
    public void setActionCommand(String s);

    /**
     * Returns the action command for this button.
     *
     * @return the String that identifies the generated event
     * @see #setActionCommand
     */
    public String getActionCommand();

    /**
     * Identifies the group this button belongs to -
     * needed for radio buttons, which are mutually
     * exclusive within their group.
     *
     * @param group the ButtonGroup this button belongs to
     */
    public void setGroup(ButtonGroup group);
    
    /**
     * Adds an ActionListener to the button.
     *
     * @param l the listener to add
     */
    void addActionListener(ActionListener l);

    /**
     * Removes an ActionListener from the button.
     *
     * @param l the listener to remove
     */
    void removeActionListener(ActionListener l);

    /**
     * Adds an ItemListener to the button.
     *
     * @param l the listener to add
     */
    void addItemListener(ItemListener l);

    /**
     * Removes an ItemListener from the button.
     *
     * @param l the listener to remove
     */
    void removeItemListener(ItemListener l);

    /**
     * Adds a ChangeListener to the button.
     *
     * @param l the listener to add
     */
    void addChangeListener(ChangeListener l);

    /**
     * Removes a ChangeListener from the button.
     *
     * @param l the listener to remove
     */
    void removeChangeListener(ChangeListener l);

}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The JFC class <TT>DefaultButtonModel</TT> implements the <TT>ButtonModel</TT>
interface and by default it, or a descendant, is used as the model
for JFC buttons. The event flow between the <TT>DefaultButtonModel</TT>
and possible listeners is shown in Figure 6.1. In the figure,
the top label on each arc represents the listener method called
to deliver the event whose name appears below the method name.
<P>
<A HREF="javascript:popUp('f6-1.gif')"><B>Figure 6.1 :</B> <I>ButtonModel event flow</I>.</A>
<P>
A <TT>ChangeEvent</TT> is sent to listeners whenever a state variable
changes. The state variables are the five <TT>boolean</TT> properties
and the mnemonic defined in the model interface. The <TT>ChangeEvent</TT>
class definition is shown next. As can be seen, the class doesn't
add anything to the AWT <TT>EventObject</TT> that it inherits.
The only real information that can be obtained from the event
is the event's source. It is up to the listener to then query
the source to determine what the change was and what action to
take. The methods defined in the <TT>ButtonModel</TT> interface
can be used to determine the button's state.
<BLOCKQUOTE>
<PRE>
public class  ChangeEvent
     extends java.util.EventObject
{ 
          // Constructors 1
     public ChangeEvent(Object);
} 
</PRE>
</BLOCKQUOTE>
<P>
An <TT>ItemEvent</TT> is sent when the selected status of the
button changes. The following is the class definition of <TT>ItemEvent</TT>.
This event, unlike the <TT>ChangeEvent</TT>, carries the item
information in the event itself. The <TT>getStateChange</TT> method
can be called on the event to see if the item has changed to <TT>SELECTED</TT>
or <TT>DESELECTED</TT>. These constants are also defined in the
<TT>ItemEvent</TT> class.
<BLOCKQUOTE>
<PRE>
public class  ItemEvent
     extends java.awt.AWTEvent
{ 
          // Fields 8
     public static final int DESELECTED;
     public static final int ITEM_FIRST;
     public static final int ITEM_LAST;
     public static final int ITEM_STATE_CHANGED;
     public static final int SELECTED;
     Object item;
     private static final long serialVersionUID;
     int stateChange;

          // Constructors 1
     public ItemEvent(ItemSelectable, int, Object, int);

          // Methods 4
     public Object getItem();
     public ItemSelectable getItemSelectable();
     public int getStateChange();
     public String paramString();
}
</PRE>
</BLOCKQUOTE>
<P>
The final event that a class implementing the <TT>ButtonModel</TT>
interface must provide methods for is the <TT>ActionEvent</TT>.
An <TT>ActionEvent</TT> is sent when the button is clicked. Programmatically,
this looks like the button becoming not pressed while being armed.
This implies that the <TT>ActionEvent</TT> is sent from the <TT>setPressed</TT>
method in the <TT>DefaultButtonModel</TT> class. The <TT>ActionEvent</TT>
definition is shown next. Many clients of a button, or a <TT>ButtonModel</TT>,
are only concerned with this one event. An <TT>ActionEvent</TT>
contains an <TT>ActionCommand String</TT>. Listeners of multiple
<TT>ButtonModel</TT> instances often use the <TT>ActionCommand</TT>
<TT>String</TT> to determine which button was pressed. By default
the <TT>ActionCommand</TT> will be the text shown on the button.
However, this can be set with the <TT>setActionCommand</TT> method
and queried with the <TT>getActionCommand</TT> method.
<BLOCKQUOTE>
<PRE>
public class  ActionEvent
     extends java.awt.AWTEvent
{ 
          // Fields 10
     public static final int ACTION_FIRST;
     public static final int ACTION_LAST;
     public static final int ACTION_PERFORMED;
     public static final int ALT_MASK;
     public static final int CTRL_MASK;
     public static final int META_MASK;
     public static final int SHIFT_MASK;
     String actionCommand;
     int modifiers;
     private static final long serialVersionUID;

          // Constructors 2
     public ActionEvent(Object, int, String);
     public ActionEvent(Object, int, String, int);

          // Methods 3
     public String getActionCommand();
     public int getModifiers();
     public String paramString();
} 
</PRE>
</BLOCKQUOTE>
<P>
Examples showing the usage of the listeners for the <TT>ButtonModel</TT>
and the associated events will be presented in the next sections.
<H2><A NAME="JFCButtonHierarchy">
JFC Button Hierarchy</A></H2>
<P>
The JFC doesn't contain a single button, it contains an entire
hierarchy of buttons. Each button provides a different look and
functionality, but all use the <TT>ButtonModel</TT> interface.
The button hierarchy is presented in Figure 6.2. The following
sections present the <TT>JButton</TT> and <TT>JToggleButton</TT>
and their descendents, but the <TT>JMenuItem</TT> and its descendants
will not be presented here. Instead, they are presented in Chapter
9, &quot;Menus and Toolbars.&quot;
<P>
<A HREF="javascript:popUp('f6-2.gif')"><B>Figure 6.2 :</B> <I>The JFC button hierarchy</I>.</A>
<P>
The top of the button hierarchy is the <TT>AbstractButton</TT>
class. Thus the behavior implemented in this class if available
to all JFC buttons. The <TT>AbstractButton</TT> class does not
inherit from the <TT>JLabel</TT> class; however, it defines identical
properties for text and icon alignment as well as text-to-icon
relative positioning. These are the <TT>horizontalAlignment</TT>,
<TT>verticalAlignment</TT>, <TT>horizontalTextPosition</TT>, and
<TT>verticalTextPosition</TT> properties. However, the <TT>horizontalTextPosition</TT>
is a bound property for buttons, even though it was omitted from
labels. See <A HREF="..\ch05\ch05.htm" >Chapter 5</A> &quot;Basic Components,&quot; for a complete
description of these properties. This is a situation where multiple
inheritance, or delegation, in Java could be argued for. At the
very minimum, a properties interface, similar to the <TT>SwingConstants</TT>
interface, could be defined containing the property names for
bound properties that convey the same meaning in multiple classes.
As it stands today, constants for property names are defined in
the <TT>AbstractButton</TT> class, but hard-coded in the <TT>JLabel</TT>
class.
<P>
The <TT>AbstractButton</TT> class provides for a disabled icon
as described in the previous chapter for the <TT>JLabel</TT> class.
However, the <TT>AbstractButton</TT> class contains many more
icons. The other icons allow you to specify the icon when the
button is selected, pressed, rolled over, rolled over and selected,
or disabled and selected. A total of seven icons can be specified
for a single button. The methods to set the various icons and
the associated bound property names are presented in Table 6.1,
which lists all the bound properties introduced in the <TT>AbstractButton</TT>
class. The rollover icons are used when the mouse is rolling over
the button. By default, the rollover icons are not enabled. To
enable rollover behavior, the <TT>setRolloverEnabled</TT> method
must be called with a parameter of <TT>true</TT>. Calling the
method with a parameter of <TT>false</TT> will disable rollover
behavior. The rollover behavior is a bound property named <TT>rolloverEnabled</TT>.
<BR>
<P>
<CENTER><B>Table 6.1&nbsp;&nbsp;AbstractButton Icon Methods and
Property Names</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=192><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=192><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>icon</TT> <TT>setIcon</TT></TD><TD WIDTH=192>&nbsp;
</TD><TD WIDTH=192><TT>getIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>disabledIcon</TT></TD><TD WIDTH=192><TT>setDisabledIcon</TT>
</TD><TD WIDTH=192><TT>getDisabledIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>disabledSelected Icon</TT></TD><TD WIDTH=192><TT>setDisabledSelected Icon</TT>
</TD><TD WIDTH=192><TT>getDisabled SelectedIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>pressedIcon</TT></TD><TD WIDTH=192><TT>setPressedIcon</TT>
</TD><TD WIDTH=192><TT>getPressedIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>rolloverIcon</TT></TD><TD WIDTH=192><TT>setRolloverIcon</TT>
</TD><TD WIDTH=192><TT>getRolloverIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>rolloverSelected Icon</TT></TD><TD WIDTH=192><TT>setRolloverSelected Icon</TT>
</TD><TD WIDTH=192><TT>getRollover SelectedIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>selectedIcon</TT></TD><TD WIDTH=192><TT>setSelectedIcon</TT>
</TD><TD WIDTH=192><TT>getSelectedIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>text</TT></TD><TD WIDTH=192><TT>setText</TT>
</TD><TD WIDTH=192><TT>getText</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>margin</TT></TD><TD WIDTH=192><TT>setMargin</TT>
</TD><TD WIDTH=192><TT>getMargin</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>horizontalAlignment Alignment</TT></TD>
<TD WIDTH=192><TT>setHorizontal Alignment</TT></TD><TD WIDTH=192><TT>getHorizontal</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>verticalAlignment Alignment</TT></TD><TD WIDTH=192><TT>setVertical Alignment</TT>
</TD><TD WIDTH=192><TT>getVertical</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>horizontalText Position</TT></TD><TD WIDTH=192><TT>setHorizontalText Position</TT>
</TD><TD WIDTH=192><TT>getHorizontal TextPosition</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>verticalText Position</TT></TD><TD WIDTH=192><TT>setVerticalText Position</TT>
</TD><TD WIDTH=192><TT>getVerticalText Position</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>borderPainted</TT></TD><TD WIDTH=192><TT>setBorderPainted</TT>
</TD><TD WIDTH=192><TT>isBorderPainted</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>focusPainted</TT></TD><TD WIDTH=192><TT>setFocusPainted</TT>
</TD><TD WIDTH=192><TT>isFocusPainted</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>rolloverEnabled Enabled</TT></TD><TD WIDTH=192><TT>setRollover Enabled</TT>
</TD><TD WIDTH=192><TT>isRollover</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>model</TT></TD><TD WIDTH=192><TT>setModel</TT>
</TD><TD WIDTH=192><TT>getModel</TT></TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The model that contains the button's state can be set and queried
with the <TT>setModel</TT> and <TT>getModel</TT> methods. As was
explained in the previous section, calling the <TT>setActionCommand</TT>
defined in the <TT>ButtonModel</TT> interface specifies the <TT>Action</TT>
command sent as part of the <TT>ActionEvent</TT> when the button
is pressed. The <TT>AbstractButton</TT> class provides a convenience
function, <TT>setActionCommand</TT>, that gets the current model
for the button and calls the model's <TT>setActionCommand</TT>
method. This allows the <TT>Action</TT> command to be set from
the handle to the button. Similarly, the <TT>AbstractButton</TT>
class wraps the <TT>setMnemonic</TT> method from<TT> </TT>the
<TT>ButtonModel</TT> interface. The mnemonic provides a keyboard
interface for pressing the button. The only Boolean properties
from the model that are wrapped by the <TT>AbstractButton</TT>
class are the <TT>selected</TT> and <TT>enabled</TT> properties.
These are the <TT>setSelected</TT> and <TT>setEnabled</TT> methods.
The <TT>AbstractButton</TT> class also wraps the <TT>get</TT>
versions of each of these methods. The wrapper methods allow buttons
to be used easily without interacting with the <TT>ButtonModel</TT>
itself.
<P>
By default, a button that has the keyboard focus will paint itself
with a box around the button's content but inside the border.
This gives the user visual feedback that the button has the focus.
Calling the <TT>setFocusPainted</TT> method and passing a parameter
of <TT>false</TT> will stop this behavior. Calling the method
with a parameter of <TT>true</TT> enables the painting of the
focus visual feedback on the button. The <TT>focusPainted</TT>
property is a bound property named <TT>focusPainted</TT>. The
state of this property can be queried with the <TT>isFocusPainted</TT>
method. The focus painting behavior can also be altered by the
current look-and-feel being used. Similarly, painting the border
can be controlled with the <TT>setBorderPainted</TT> method. When
<TT>false</TT> is passed to this method, a border is not painted
around the button. By default, the value of this property is <TT>true</TT>,
allowing the border to be painted.
<P>
The <TT>AbstractButton</TT> class provides the <TT>doClick</TT>
method to allow the button to be pressed programmatically. The
onscreen button will actually draw itself pressed and then released,
as if a user pressed the button with the mouse. The associated
events will also get fired. For example, an <TT>ActionEvent</TT>
will be sent when the <TT>doClick</TT> method is called.
<H2><A NAME="SimpleButtonsTheTTFONTSIZEJButtonFONTTTFONTSIZEClassFONT">
Simple Buttons: The <TT>JButton</TT>
Class</A></H2>
<P>
The most common button class for normal use is the <TT>JButton</TT>
class. The class provides the user interface component for the
familiar push button. The <TT>JButton</TT> class extends the <TT>AbstractButton</TT>
class, thus the functionality discussed in the previous section
is available to instances of the <TT>JButton</TT> class.
<P>
The previous section contained the theory of button events and
properties contained in the JFC. The <TT>JButton</TT> is the first
concrete button class presented, so look at some examples. Creating
a button is a simple matter. The following code fragment creates
a button with the text OK. The simple button is shown in Figure
6.3 with the Windows look-and-feel. The dashed line around the
button signifies that the button has the keyboard focus. The dashed
line is painted because the <TT>focusPainted</TT> property is
set to <TT>true</TT> by default for this look-and-feel.
<P>
<TT>JButton ok = new JButton( &quot;OK&quot;
);</TT>
<P>
<A HREF="javascript:popUp('f6-3.gif')"><B>Figure 6.3 :</B> <I>A simple OK JButton</I>.</A>
<P>
Whether or not your current OK button does anything can be thought
about like the proverbial tree falling in the woods. If there
is no one there to hear it fall, does it make any noise? The current
button doesn't have any external listeners, so it doesn't fire
any events to your code. However, it is still processing input
events and waiting for your listener, so it can fire events. First,
add a simple <TT>ChangeListener</TT> to print the state changes
as the button undergoes its normal operation. This code example
is shown in Listing 6.2.<p>
<HR>
<P>
<B>Listing 6.2&nbsp;&nbsp;OK Button with Simple </B><TT><B>CHANGELISTENER
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.event.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that prints state changes of a JButton.
 *
 * @author Mike Foley
 **/
public class ButtonEventTest extends Object { 
    
    /**
     * Create a panel containing a button and event listener.
     * The event listener simply dumps the button's state to
     * the console.
     *
     * @return A panel containing a button.
     **/
    static private JPanel createButtonPanel() { 
        
        JPanel buttonPanel = new JPanel();
        JButton ok = new JButton( &quot;OK&quot; );
        buttonPanel.add( ok );
           
        ButtonModel model = ok.getModel();
        System.out.println( &quot;armed=&quot; + model.isArmed() + &quot; &quot; +
                            &quot;enabled=&quot; + model.isEnabled() + &quot; &quot; +
                            &quot;pressed=&quot; + model.isPressed() + &quot; &quot; +
                            &quot;rollover=&quot; + model.isRollover() + &quot; &quot; +
                            &quot;selected=&quot; + model.isSelected() );
        ok.addChangeListener( new ChangeListener() { 
            public void stateChanged( ChangeEvent e ) { 
                JButton button = ( JButton )e.getSource();
                ButtonModel b = button.getModel();
                System.out.println( &quot;armed=&quot; + b.isArmed() + &quot; &quot; +
                            &quot;enabled=&quot; + b.isEnabled() + &quot; &quot; +
                            &quot;pressed=&quot; + b.isPressed() + &quot; &quot; +
                            &quot;rollover=&quot; + b.isRollover() + &quot; &quot; +
                            &quot;selected=&quot; + b.isSelected() );
            } 
        }  );
        
        return( buttonPanel );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Button Event Test&quot; );
        
        JPanel buttons = createButtonPanel();                 
        
        frame.getContentPane().add( buttons, BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ButtonEventTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, an anonymous inner class is used as a change
listener. Since the <TT>ChangeEvent</TT> does not deliver the
state of its source with the event, the button's model is obtained
from the <TT>JButton</TT> instance that is the source of the event.
You can safely cast the <TT>Object</TT> returned from the <TT>getSource</TT>
method of the <TT>ChangeEvent</TT>, because you know the listener
is only registered to one object, the OK <TT>JButton</TT> you
created. The output from the change listener when the button is
pressed and released is shown in Figure 6.4 (extra lines have
been inserted into the output to group related events). The first
line is printed immediately after the button has been created.
This is the default state of the button. The next two <TT>ChangeEvent</TT>s
come after the button is pressed. The first event is from the
button being armed, or ready to fire. The second event is from
the button becoming pressed. The final event is when the button
is released.

<P>
<BLOCKQUOTE>
<B><TT>// Default state of button model.<BR>
armed=false enabled=true pressed=false
rollover=false selected=false<BR>
// Button armed and pressed. Resulting from mouse down over button.
<BR>
armed=true enabled=true pressed=false rollover=false selected=false
<BR>
armed=true enabled=true pressed=true rollover=false selected=false
<BR>
// Button pressed. Resulting from mouse up over button. armed=true
enabled=true pressed=false rollover=false selected=false</TT></B></BLOCKQUOTE>
<P>
<CENTER><B>Figure 6.4 :</B> <I>ButtonEventTest application out-put</I>.</CENTER>
<P>
In the results presented here, the <TT>rollover</TT> property
is always <TT>false</TT>. This is due to the fact that rollover
detection is disabled by default. Adding the following line of
code in the <TT>createButtonPanel</TT> method to the current example,
after the button has been created, will enable rollover detection.
<P>
<TT>ok.setRolloverEnabled( true );</TT>
<P>
The result of the same experiment with rollover detection enabled
is presented in Figure 6.5. The default state of the button hasn't
changed. The second and third lines are from events generated
when the mouse is passed over the button. The first event is when
the mouse enters the button's window, and the second is when it
exits. These events make it clear why the property is named <TT>rollover</TT>.
The final five events are the sequence when the button is pressed
and released, and when the mouse exits the button's window. It
is seen that the middle three events are the same as the previous
example, except the <TT>rollover</TT> property is <TT>true</TT>.
The first and last events are from the mouse entering and exiting
the button's window.

<P>
<BLOCKQUOTE>
<B>
<TT>// Default state of button model.<BR>
armed=false enabled=true pressed=false
rollover=false selected=false</TT>
<P>
<TT>// Mouse rolls over button,no mouse buttons pressed. armed=false
enabled=true pressed=false rollover=true<BR>
              selected=falsearmed=false
enabled=true <BR>
              pressed=false rollover=false selected=false</TT>
<P>
<TT>// Mouse back over button.<BR>
armed=false enabled=true pressed=false
rollover=true selected=false</TT>
<P>
<TT>// Button armed and pressed. Resulting from mouse down over
button.<BR>
armed=true enabled=true pressed=false
rollover=true selected=false<BR>
armed=true enabled=true pressed=true rollover=true selected=false</TT>
<P>
<TT>// Button pressed. Resulting from mouse up over button. armed=true
enabled=true pressed=false rollover=true selected=false</TT>
<P>
<TT>// Mouse not over button any longer.<BR>
armed=true enabled=true pressed=false
rollover=false selected=false</TT></B></BLOCKQUOTE>
<P>
<CENTER><B>Figure 6.5 :</B> <I>Jbutton ChangeEvents with rollover detection
enabled</I>.</CENTER>
<P>
The <TT>ChangeListener</TT> in this example is illustrative for
demonstrating the normal state transitions of the <TT>DefaultButtonModel</TT>.
However, an <TT>ActionListener</TT> is used more frequently in
practice. This listener gets notified whenever the button gets
clicked. The following code is used to add an <TT>ActionListener</TT>
to a button. The <TT>ActionListener</TT> can be added to the <TT>createButtonPanel</TT>
method from the previous example. The <TT>ChangeListener</TT>
can be removed or left in place. The button can have any number
and combination of listeners at any given time. The <TT>ActionListener</TT>
simply prints the <TT>ActionEvent</TT> it receives. The result
from clicking the button with this <TT>ActionListener</TT> is
shown in Figure 6.6. The output assumes that the <TT>ChangeListener</TT>
was removed from the button. It shows that the event was of the
type <TT>ACTION_PERFORMED</TT>, the action command was <TT>OK</TT>,
and the <TT>JButton</TT> was the source of this <TT>ActionEvent</TT>.
<P>

<BLOCKQUOTE>
<B>
<TT>ActionEvent<BR>
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=OK]on<BR>
javax.swing.JButton[,356,5,49x25,<BR>
layout=javax.swing.OverlayLayout]<P>
JButton ok = new JButton( &quot;OK&quot; );<BR>
ok.addActionListener( new ActionListener() { <BR>
    public void actionPerformed( ActionEvent e ) { <BR>
        System.out.println( &quot;ActionEvent &quot; + e );<BR>
    } <BR>
}  );</TT>
</B>
</BLOCKQUOTE>
<P>
<CENTER><B>Figure 6.6 :</B> <I>Output from the ActionListener</I>.</A></CENTER>
<P>
In this simple example, it is obvious from which button the event
came. In many situations, this isn't so clear. For example, the
same <TT>ActionListener</TT> can be listening for events from
many action event sources. In this situation, the action command
can be used to determine which operation to perform in the listener.
Using the action command in the listener also allows multiple
action sources to generate the same behavior. As demonstrated
in the previous example, the default action command for a button
is the text of the button. For all but the most trivial applications,
if the action command is going to be used, it should be explicitly
set. The primary reason for this is that the action command should
not be tied to the text on the button.
<P>
When an application is internationalized, the text that appears
on the button will be read from a resource bundle. Thus, the text
may be different depending on where in the world the application
is executed. If the application explicitly sets the action command,
it <BR>
doesn't matter what text appears on the button. Also, if an icon
is placed on the button without any text, the action command is
undefined. For these reasons, it is preferable to explicitly set
the action command if it is going to be used in your application.
<BLOCKQUOTE>
<PRE>
ResourceBundle bundle = ResourceBundle.getBundle( &quot;LabelResources&quot;, 
                                                  Locale.getDefault() );
JButton ok = new JButton( bundle.getString( &quot;okButton&quot; ) );
ok.setActionCommand( &quot;ok&quot; );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f6-7.gif')"><B>Figure 6.7 :</B> <I>The OK button in a German locale</I>.</A>
<P>
When this code fragment was run in a United States locale, the
button shown in Figure 6.3 would be displayed. If the code were
run in a German locale, the button shown in Figure 6.7 would be
displayed. In the figure, the frame's strings have not been internationalized.
The action command reported in an <TT>ActionEvent</TT> is the
same in both examples, that being the string OK.
<H2><A NAME="UsingTTFONTSIZEActionFONTTTFONTSIZEswithButtonsFONT">
Using <TT>Actions</TT> with
Buttons</A></H2>
<P>
As was seen in <A HREF="..\ch04\ch04.htm" >Chapter 4</A> &quot;JFC Programming Techniques,&quot;
the <TT>Action</TT> interface extends the <TT>ActionListener</TT>
interface. Thus any class that implements the <TT>Action</TT>
interface is an <TT>ActionListener</TT>. This allows an <TT>Action</TT>
to be added directly to a button and invoked when the button is
pressed. This is demonstrated in the following code fragment:
<BLOCKQUOTE>
<PRE>
JButton button = new JButton( &quot;OK&quot; );
Action exitAction = new ExitAction();
button.addActionListener( exitAction );
</PRE>
</BLOCKQUOTE>
<P>
However, using code like this to tie an <TT>Action</TT> to a button
doesn't take full advantage of <TT>Action</TT>. For example, when
an <TT>Action</TT> is disabled, the button should become disabled
as well. For this type of integration, the button needs to be
<TT>Action</TT>-aware. As you will see in <A HREF="..\ch09\ch09.htm" >Chapter 9</A> Swing menus
and toolbars are <TT>Action</TT>-aware. Unfortunately, the <TT>JButton</TT>
class is not.
<P>
To provide an <TT>Action</TT>-aware button, the <TT>JButton</TT>
class can be extended to provide the required functionality. The
<TT>AButton</TT> class shown in Listing 6.3 is such a class. An
instance of the <TT>AButton</TT> class can be used as a substitute
for a <TT>JButton</TT> instance anywhere a button is required.
<p>
<HR>
<P>
<B>Listing 6.3&nbsp;&nbsp;Using the </B><TT><B>ABUTTON</B></TT><B>
Class to Make an </B><TT><B>ACTION</B></TT><B>-Aware
Button<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.beans.*;

import javax.swing.*;


/**
 * The AButton class is an Action-aware button.
 * The button will configure itself to the Action set using
 * the setAction method.
 *
 * The class may only be configured for one Action at
 * a time. If a second Action is set using the setAction
 * method, the first Action will be removed. However, other
 * ActionListeners may be added as normal, using the
 * addActionListener method.
 *
 * @author Mike Foley
 **/
public class AButton extends JButton 
    implements PropertyChangeListener { 

    /**
     * The Action this button is configured for.
     **/
    private Action action;
    
    /**
     * Bound property names.
     **/
    public static final String ACTION_PROPERTY = &quot;action&quot;;
    
    
    /**
     * AButton, default constructor.
     * Creates a button with no set text or icon. 
     **/
    public AButton() { 
        super();
    } 
    
    /**
     * AButton, constructor
     * Creates a button from the given Action. 
     *
     * @see setAction
     * @param action The Action to configure this button to.
     **/
    public AButton( Action action ) { 
        super();
        setAction( action );
    } 
    
    
    /**
     * Configure the button for the given Action.
     * If the button was already configured for
     * an Action, remove that Action from being
     * a listener to this button.
     * The Action is a bound property.
     *
     * @param action The Action to configure this button to.
     **/
    public void setAction( Action action ) { 
        
        Action oldAction = this.action;
        if( oldAction != null ) { 
            //
            // Remove the bind between the button and the
            // old action.
            //
            oldAction.removePropertyChangeListener( this );
            removeActionListener( oldAction );
        } 
        
        this.action = action;
        
        if( action != null ) { 
            
            //
            // Update our appearance to that of the new action.
            //
            setText( ( String )action.getValue( Action.NAME ) );
            setIcon( ( Icon )action.getValue( Action.SMALL_ICON ) );
        
            setEnabled( action.isEnabled() );
        
            //
            // Bind ourself to the new Action.
            //
            action.addPropertyChangeListener( this );
            addActionListener( action );
    
            //
            // Set the text below the Icon.
            //
            setHorizontalTextPosition( JButton.CENTER );
            setVerticalTextPosition( JButton.BOTTOM );
  
        }  else { 
            
            //
            // null Action, set the button's view to 'empty'
            setText( &quot;&quot; );
            setIcon( null );
            
        }  // else
        
        //
        // The Action is a bound property.
        //
        firePropertyChange( ACTION_PROPERTY, oldAction, this.action );
        
    }  // setAction
    

    /**
     * propertyChange, from PropertyChangeListener.
     * Only handle changes from the Action we are configured for.
     *
     * @param event The property change event causing this method call.
     **/
    public void propertyChange( PropertyChangeEvent event ) { 
        if( event.getSource() == action ) { 
            
            //
            // Get the name of the changed property, and
            // update ourself accordinly.
            //
            String propertyName = event.getPropertyName();
            
            if( propertyName.equals( Action.NAME ) ) { 
                setText( ( String )event.getNewValue() );
            }  else if( propertyName.equals(Action.SMALL_ICON)) { 
                setIcon( ( Icon )event.getNewValue() );
                invalidate();
            }  else if( propertyName.equals( &quot;enabled&quot; ) ) { 
                Boolean enabled = ( Boolean )event.getNewValue();
                setEnabled( enabled.booleanValue() );
            }  
            
            //
            // Update our display.
            //
            repaint();
        } 
        
    }  // propertyChange
    
}  // Abutton
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>AButton</TT> class provides a default constructor, as
well as a constructor that takes an <TT>Action</TT> instance.
The second constructor passes the given <TT>Action</TT> instance
to the <TT>setAction</TT> method. This is where the work is done.
If the button had been previously configured for a different <TT>Action</TT>
instance, that tie is broken. The button is removed as a <TT>PropertyChangeListener</TT>
for the <TT>Action</TT>, and the <TT>Action</TT> is removed as
an <TT>ActionListener</TT> from the button. Then, if the new <TT>Action</TT>
is non-<TT>null</TT>, the button is configured from the new <TT>Action</TT>.
The name and icon are retrieved from the new <TT>Action</TT> and
set on the button. The default text placement is below the icon
on the button. However, this can be changed by using the icon
and text placement methods contained in the <TT>JButton</TT> class.
The button's enabled state is set to that of <TT>Action</TT>.
Finally, the button and action are bound together by adding the
<TT>AButton</TT> as a <TT>PropertyChangeListener</TT> to <TT>Action</TT>,
and the <TT>Action</TT> as an <TT>ActionListener</TT> to the button.
If the new <TT>Action</TT> is <TT>null</TT>, the button is cleared.
Its text and icon are set to empty. The button's <TT>Action</TT>
is a bound property of the <TT>AButton</TT> class, so a <TT>PropertyChangeEvent</TT>
is fired at the bottom of the <TT>setAction</TT> method.
<P>
The other non-constructor method in the <TT>AButton</TT> class
is the <TT>propertyChange</TT> method. This method is from the
<TT>PropertyChangeListener</TT> interface and must be implemented
for the <TT>AButton</TT> class to listen to changes in its bound
<TT>Action</TT>. When a <TT>PropertyChangeEvent</TT> is received,
the source is checked. The <TT>AButton</TT> class is only interested
to changes in its bound <TT>Action</TT>. If the source is the
bound <TT>Action</TT>, the changed property is retrieved and the
button is updated. After the button has been updated, it is painted
to update the display.
<P>
A possible limitation to the <TT>AButton</TT> class is that it
only manages one <TT>Action</TT> at a time. This is due to the
fact that the <TT>JButton</TT> class is designed to display one
string and icon at a time. This makes it natural to configure
the button for a single <TT>Action</TT>. However, the <TT>AButton</TT>
class can still invoke multiple <TT>Action</TT>s. The one <TT>Action</TT>
for which the <TT>AButton</TT> is configured is specified with
the <TT>setAction</TT> command, or in the constructor. The other
<TT>Action</TT>s that are to be invoked when the button is pressed
may be added as <TT>ActionListener</TT>s to the button by using
the <TT>addActionListener</TT> method.
<P>
A simple application to test the <TT>AButton</TT> class is shown
in Listing 6.4. It adds an instance of the <TT>AButton</TT> class
that is bound to an <TT>ExitAction</TT> to the center of a frame.
Pressing the button will exit the application. The resulting frame
is shown in Figure 6.8.
<P>
<A HREF="javascript:popUp('f6-8.gif')"><B>Figure 6.8 :</B> <I>AButtonTest application</I>.</A><p>
<HR>
<P>
<B>Listing 6.4&nbsp;&nbsp;Application to Test the </B><TT><B>ABUTTON</B></TT><B>
Class<p>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that displays an AButton in a frame.
 *
 * @author Mike Foley
 **/
public class AButtonTest extends Object { 


    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new JFrame( &quot;Action Button Test&quot; );

        //
        // Create the AButton, and add an ExitAction.
        //
        AButton button = new AButton();
        button.setAction( new ExitAction() );
        



        frame.getContentPane().add( button, BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // AButtonTest
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TTFONTSIZEJToggleButtonFONTTT">
<TT>JToggleButton</TT></A></H2>
<P>
The <TT>JToggleButton</TT> class provides a two-state button.
A two-state button is one that doesn't spring back when released.
The first time the button is clicked, it stays in the pressed
position. The next time the button is pressed, it returns to the
unpressed position. The exact rendering of a pressed button is
look-and-feel dependent. A <TT>JToggleButton</TT> in each position
is shown in Figure 6.9 for the Windows look-and-feel, and in Figure
6.10 for the Metal look-and-feel.
<P>
<A HREF="javascript:popUp('f6-9.gif')"><B>Figure 6.9 : </B><I>JToggleButton using the Windows look-and-feel</I>.</A>
<P>
<A HREF="javascript:popUp('f6-10.gif')"><B>Figure 6.10:</B> <I>JToggleButton using the Metal look-and-feel</I>.</A>
<P>
Like the <TT>JButton</TT> class, the <TT>JToggleButton</TT> class
extends the <TT>AbstractButton</TT> class. The functionality presented
for the <TT>AbstractButton</TT> class is available to instances
of the <TT>JToggleButton</TT> class. The application in Listing
6.5 shows the creation of a <TT>JToggleButton</TT> and adds the
<TT>ChangeListener</TT> and <TT>ActionListener</TT> used in the
previous example. Running the example application is instructive
to see the event flow for a <TT>JToggleButton</TT> instance.<p>
<HR>
<P>
<B>Listing 6.5&nbsp;&nbsp;</B><TT><B>JTOGGLEBUTTON</B></TT><B>
with a </B><TT><B>CHANGELISTENER</B></TT><B>
and </B><TT><B>ACTIONLISTENER<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.event.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that prints state changes of a JToggleButton.
 *
 * @author Mike Foley
 **/
public class ToggleButtonEventTest extends Object { 
    
    /**
     * Create a panel containing a button and event listener.
     * The event listener simply dumps the button's state to
     * the console.
     *
     * @return A panel containing a button.
     **/
    static private JPanel createButtonPanel() { 
        
        JPanel buttonPanel = new JPanel();
        
        JToggleButton toggle = new JToggleButton( &quot;Toggle&quot; );
        buttonPanel.add( toggle );

        toggle.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.out.println( &quot;ActionEvent &quot; + e );
            } 
        }  );
        toggle.addChangeListener( new ChangeListener() { 
            public void stateChanged( ChangeEvent e ) { 
                JToggleButton button = ( JToggleButton )e.getSource();
                ButtonModel m = button.getModel();
                System.out.println( &quot;armed=&quot; + m.isArmed() + &quot; &quot; +
                                    &quot;enabled=&quot; + m.isEnabled() + &quot; &quot; +
                                    &quot;pressed=&quot; + m.isPressed() + &quot; &quot; +
                                    &quot;rollover=&quot; + m.isRollover() + &quot; &quot; +
                                    &quot;selected=&quot; + m.isSelected() );
            } 
        }  );
        
        return( buttonPanel );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;ToggleButton Event Test&quot; );
        
        JPanel buttons = createButtonPanel();                 
        
frame.getContentPane().add( buttons, BorderLayout.CENTER );
                
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ToggleButtonEventTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In the application, the same <TT>ChangeListener</TT> and <TT>ActionListener</TT>
that were presented in the last section for the <TT>JButton</TT>
examples were added to an instance of a <TT>JToggleButton</TT>.
The results of executing this example are presented in Figure
6.11. The first line represents the default state of the <TT>JToggleButton</TT>.
With the exception of the button being armed, this is the same
as the default state of the <TT>JButton</TT>. One <TT>ChangeEvent</TT>
is delivered when the mouse button is pressed the first time.
This is from the <TT>pressed</TT> property changing to <TT>true</TT>.
The next two <TT>ChangeEvents</TT> are delivered when the mouse
is released. The first is from the button being selected, and
the second from the pressed state returning to <TT>false</TT>.
This property is a bit misleading. The button is drawn pressed,
but the <TT>pressed</TT> property is <TT>false</TT>. This is because
the <TT>pressed</TT> property refers to the mouse button, not
the <TT>JToggleButton</TT>. The <TT>selected</TT> property is
the property that represents the drawn state of the <TT>JToggleButton</TT>.
Finally, an <TT>ActionEvent</TT> is delivered.
<P>
<blockquote>
<b>
<TT>// Default state, button 'up'<BR>
armed=true enabled=true pressed=false
rollover=false selected=false</TT>
<P>
<TT>// Mouse button pressed <BR>
armed=true enabled=true pressed=true
rollover=false selected=false</TT>
<P>
<TT>// Mouse released <BR>
armed=true enabled=true pressed=true
rollover=false selected=true <BR>
armed=true enabled=true pressed=false rollover=false selected=true
<BR>
ActionEvent java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=Toggle]
<BR>
on javax.swing.JToggleButton [,381,5,71x25,layout=javax.swing.OverlayLayout]</TT>
<P>
<TT>// Button pressed when button 'down' <BR>
armed=true enabled=true pressed=true
rollover=false selected=true</TT>
<P>
<TT>// Button released <BR>
armed=true enabled=true pressed=true
rollover=false selected=false <BR>
armed=true enabled=true pressed=false rollover=false selected=false
<BR>
ActionEvent java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=Toggle]
on javax.swing.JToggleButton[<BR>
            ,381,5,71x25,layout=javax.swing.OverlayLayout]</TT>
</blockquote>
</b>
<P>
<center><B>Figure 6.11:</B> <I>ChangeListener and ActionListener results</I>.</center>
<P>
The second group of events is delivered as a result of the button
being pressed. That is when the toggle button transitions from
being selected to not being selected. Visually this is the transition
from the button being pressed to not being pressed. The first
<TT>ChangeEvent</TT> is delivered when the mouse button is pressed,
and the <TT>pressed</TT> property transitions to <TT>true</TT>.
The next two <TT>ChangeEvents</TT> are delivered when the button
is released. The first is when the toggle button is no longer
selected (it is not drawn pressed), and the second is to show
that the mouse button is no longer pressed. Once again, an <TT>ActionEvent</TT>
is delivered. For a <TT>JToggleButton</TT>, an <TT>ActionEvent</TT>
is generated for the button being both selected and unselected.
<H2><A NAME="CheckBoxes">
Check Boxes</A></H2>
<P>
The <TT>JCheckBox</TT> class extends the <TT>JToggleButton</TT>
class. It provides a different visual appearance to the same features
as the <TT>JToggleButton</TT>. When a <TT>JCheckBox</TT> is selected,
it is drawn checked instead of pressed as the <TT>JToggleButton</TT>
is. Also, the <TT>JCheckBox</TT> doesn't go up and down as the
other buttons you've seen. The application in Listing 6.6 shows
how to create a <TT>JCheckBox</TT>. The resulting boxes are shown
in Figure 6.12. In the <TT>createCheckBoxPanel</TT> method, an
instance of the <TT>JCheckBox</TT> class can be set to checked
by setting the selected property to <TT>true</TT>. By default,
the check box will not be checked.
<P>
<A HREF="javascript:popUp('f6-12.gif')"><B>Figure 6.12:</B> <I>JCheckBox instances</I>.</A><p>
<HR>
<P>
<B>Listing 6.6&nbsp;&nbsp;</B><TT><B>JCHECKBOX
</B></TT>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that displays a couple of JCheckBox
 * instances.
 *
 * @author Mike Foley
 **/
public class CheckBoxTest extends Object { 
    
    /**
     * Create a panel containing a couple of check boxes.
     *
     * @return A panel containing a button.
     **/
    static private JComponent createCheckBoxPanel() { 
                
        JBox checkBoxPanel = JBox.createVerticalJBox();

        JCheckBox check1 = new JCheckBox( &quot;Option 1&quot; );
        checkBoxPanel.add( check1 );
        JCheckBox check2 = new JCheckBox( &quot;Option 2&quot; );
        check2.setSelected( true );
        checkBoxPanel.add( check2 );
        
        return( checkBoxPanel );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;CheckBox Test&quot; );
        
        JComponent buttons = createCheckBoxPanel();                 
        



        buttons.setBorder( BorderFactory.createLoweredBevelBorder() );

        frame.getContentPane().add( buttons, BorderLayout.CENTER );
                
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // CheckBoxTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As was previously stated, the <TT>JCheckBox</TT> class extends
the <TT>JToggleButton</TT> class. The <TT>JCheckBox</TT> class
does not alter events fired from those defined in the <TT>JToggleButton</TT>
class. Thus, the event flow described in the previous section
for the <TT>JToggleButton</TT> is the same as the event flow for
the <TT>JCheckBox</TT> class. The listeners from the example in
that section can be added to one or both of the <TT>JCheckBox</TT>
instances in this example to print the event flow.
<H2><A NAME="RadioButtons">
Radio Buttons</A></H2>
<P>
The <TT>JRadioButton</TT> class extends the <TT>JToggleButton</TT>
class. It provides a different visual representation than that
given by the <TT>JToggleButton</TT>. The following application
shows how instances of the <TT>JRadioButton</TT> class are created.
The resulting frame containing the radio buttons is shown in Figure
6.13. The <TT>JRadioButton</TT> instances are created in the <TT>createRadioPanel</TT>
method. The first two buttons are left in their default state,
not selected. The third button is selected by passing the <TT>setSelected</TT>
method a parameter of <TT>true</TT>. In this application, more
than one of the radio buttons can be selected at the same time.
The next section describes how to enforce the typical radio button
behavior of only one button in a group being selected at the same
time.
<P>
<A HREF="javascript:popUp('f6-13.gif')"><B>Figure 6.13: </B><I>Instances of the JRadioButton class</I>.</A>
<p>
<HR>
<P>
<B>Listing 6.7&nbsp;&nbsp;</B><TT><B>JRADIOBUTTON</B></TT><B>
Test Application<BR>

</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that displays a few of JRadioButtons
 * instances.
 *
 * @author Mike Foley
 **/
public class RadioButtonTest extends Object { 
    
    /**
     * Create a panel containing a few of radio buttons.
     *
     * @return A panel containing a button.
     **/
    static private JComponent createRadioPanel() { 
                
        JBox radioButtonPanel = JBox.createVerticalJBox();

        JRadioButton radio1 = new JRadioButton( &quot;Option 1&quot; );
        radioButtonPanel.add( radio1 );
        JRadioButton radio2 = new JRadioButton( &quot;Option 2&quot; );
        radioButtonPanel.add( radio2 );
        JRadioButton radio3 = new JRadioButton( &quot;Option 3&quot; );
        radio3.setSelected( true );
        radioButtonPanel.add( radio3 );
        
        return( radioButtonPanel );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Radion Button Test&quot; );
        
        JComponent buttons = createRadioPanel();                 
        


        buttons.setBorder( BorderFactory.createLoweredBevelBorder() );

        frame.getContentPane().add( buttons, BorderLayout.CENTER );
                
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // RadioButtonTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Once again, because the <TT>JRadioButton</TT> class extends the
<TT>JToggleButton</TT> class, it does not alter events fired from
those defined in the <TT>JToggleButton</TT> class. Thus, the event
flow described in the <TT>JToggleButton</TT> section is the same
as the event flow from the <TT>JCheckBox</TT> class.
<H3><A NAME="RadioButtonGroups">
Radio Button Groups</A></H3>
<P>
The most common usage of <TT>JRadioButton</TT> instances is to
place them into a <TT>ButtonGroup</TT>. The <TT>ButtonGroup</TT>
ensures that only one button is selected at any given time. The
following example takes the <TT>JRadioButtons</TT> from the previous
example and places them in a <TT>ButtonGroup</TT>. Calling the
<TT>setSelected</TT> method will set the selected state of the
given <TT>ButtonModel</TT> to the given state. This method takes
a <TT>ButtonModel</TT>, not the button itself. The <TT>getSelection</TT>
method is used to query the currently selected <TT>ButtonModel</TT>.
It is interesting to note that the names of these methods are
not symmetric. The name of the <TT>getSelection</TT> method was
the symmetric name, <TT>getSelected</TT> for many beta releases
of the JFC. The resulting radio buttons will appear the same as
they did in the last example and are shown in Figure 6.13.
<P>
Buttons can be removed from a <TT>ButtonGroup</TT> instance by
using the <TT>remove</TT> method contained in the <TT>ButtonGroup</TT>
class. An <TT>Enumeration</TT> containing the current set of buttons
in the group can be obtained with the <TT>getElements</TT> method.
With the exception of the <TT>remove</TT> method, these methods
are demonstrated in Listing 6.8.<p>
<HR>
<P>
<B>Listing 6.8&nbsp;&nbsp;</B><TT><B>BUTTONGROUP</B></TT><B>
Example Application<BR>

</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.util.Enumeration;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that creates and displays a
 * ButtonGroup.
 *
 * @author Mike Foley
 **/
public class ButtonGroupTest extends JFrame { 
    
    /**
     * Create a panel containing a ButtonGroup
     * consisting of a couple of RadioButtons.
     *
     * @return A panel containing a button group.
     **/
    static private JComponent createButtonGroupPanel() { 
        
        JBox radioPanel = JBox.createVerticalJBox();
        ButtonGroup group = new ButtonGroup();
        JRadioButton radio1 = new JRadioButton( &quot;Option 1&quot; );
        radioPanel.add( radio1 );
        group.add( radio1 );
        JRadioButton radio2 = new JRadioButton( &quot;Option 2&quot; );
        radioPanel.add( radio2 );
        group.add( radio2 );
        JRadioButton radio3 = new JRadioButton( &quot;Option 3&quot; );
        radioPanel.add( radio3 );
        group.add( radio3 );

        // Select the third radio button.
        group.setSelected( radio3.getModel(), true );

        // Get the selected button's model.
        ButtonModel model = group.getSelection();

        // Enumerate the buttons in the group
        for( Enumeration e = group.getElements(); e.hasMoreElements();) { 
            System.out.println( e.nextElement() );
        } 
                
        return( radioPanel );
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Button Group Test&quot; );
        
        JComponent buttons = createButtonGroupPanel();                 
        buttons.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( buttons, BorderLayout.CENTER );
                
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ButtonGroupTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Adding the <TT>JRadioButton</TT>s to the <TT>ButtonGroup</TT>
does not change the events fired from the buttons. However, when
a new button is selected, a <TT>ChangeEvent</TT> will be delivered
to listeners of the previously selected button.
<P>
<TT>JRadioButton</TT> instances are the most common class of buttons
added to a <TT>ButtonGroup</TT> instance. However the <TT>add</TT>
and <TT>remove</TT> methods in the <TT>ButtonGroup</TT> class
take instances of the <TT>AbstractButton</TT> class. This means
that any of the buttons presented in this chapter can be added
to a <TT>ButtonGroup</TT>. It is unfortunate that an interface
was not used to specify this parameter rather than <TT>AbstractButton</TT>.
Then any class that implemented the interface could be added to
a <TT>ButtonGroup</TT>. The <TT>ButtonModel</TT> interface could
have been used for this purpose. Instances of <TT>JToggleButton</TT>
and <TT>JCheckBox</TT> probably lend themselves to being placed
in a <TT>ButtonGroup</TT> more than do instances of the <TT>JButton</TT>
class.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter presented the button hierarchy contained in the JFC.
Buttons are a fundamental user interface component. The JFC provides
a hierarchy of buttons that should address most user interface
needs. Even though the JFC buttons and <TT>JLabel</TT> class are
siblings in the JFC class hierarchy, they both contain the same
functionality for text and icon manipulation. The classes in the
button hierarchy were the first example of the Model View Controller
architecture encountered thus far in this book. The <TT>ButtonModel</TT>
interface was examined, as well as the <TT>AbstractButton</TT>
class that implements this interface. The <TT>AbstractButton</TT>
class is the root of the JFC button hierarchy. The events the
JFC buttons fire were also examined.
<P>
An omission in the JFC is that buttons are not <TT>Action</TT>-aware
components. However, you saw that making an <TT>Action</TT>-aware
button is a simple matter. The <TT>AButton</TT> class that can
configure itself for a single <TT>Action</TT> at a time was presented.
The class listens to changes in the <TT>Action</TT> to keep the
button in sync with the <TT>Action</TT>. When the button is pressed,
the <TT>Action</TT> is invoked.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch05\ch05.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch07\ch07.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
