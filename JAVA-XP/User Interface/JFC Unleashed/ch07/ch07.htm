<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 7 - Text Components</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch06\ch06.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch08\ch08.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;7<br>
Text Components</H1>
<HR>
<p>

<UL>
<LI><A HREF="#TheTTFONTSIZEJTextFieldFONTTTFONTSIZEClassFONT">
The <TT>JTextField</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEJPasswordFieldFONTTTFONTSIZEClassFONT">
The <TT>JPasswordField</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEJTextAreaFONTTTFONTSIZEClassFONT">
The <TT>JTextArea</TT> Class
</A>
<UL>
<LI><A HREF="#ConfiguringaTTFONTSIZEJTextAreaFONTTTFONTSIZEInstanceFONT">
Configuring a <TT>JTextArea</TT> Instance</A>
<LI><A HREF="#ManipulatingTextinaTTFONTSIZEJTextAreaFONTTTFONTSIZEInstanceFONT">
Manipulating Text in a <TT>JTextArea</FONT></TT> Instance</FONT></A>
</UL>
<LI><A HREF="#DocumentModel">
Document Model</A>
<UL>
<LI><A HREF="#InputFiltering">
Input Filtering</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJEditorPaneFONTTTFONTSIZEClassFONT">
The <TT>JEditorPane</TT>
Class</FONT></A>
<UL>
<LI><A HREF="#TextContenttheTTFONTSIZEJTextPaneFONTTTFONTSIZEClassFONT">
Text Content, the <TT>JTextPane</TT>
Class</A>
<LI><A HREF="#HTMLContent">
HTML Content</A>
<LI><A HREF="#RTFContent">
RTF Content</A>
<LI><A HREF="#ContentHandlingMethods">
Content Handling Methods</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Textual components in JFC come in two flavors: API-compatible
replacements for the AWT <TT>TextField</TT> and <TT>TextArea</TT>
classes, as well as a new generation of components that raise
the level of text manipulation components provided in Java. Each
text component allows text to be copied from or to the Clipboard.
<P>
In this chapter, you will learn how to use
<UL>
<LI>The <TT>JTextField</TT> Class
<LI>The <TT>JTextArea</TT> Class
<LI>The <TT>JPasswordField</TT>
<LI>The <TT>JTextPane</TT> Class
<LI>The <TT>JEditorPane</TT> Class
<LI>The Document Model
</UL>
<H2><A NAME="TheTTFONTSIZEJTextFieldFONTTTFONTSIZEClassFONT">
The <TT>JTextField</TT> Class
</A></H2>
<P>
The <TT>JTextField</TT> class provides a lightweight, near API-equivalent
replacement for the AWT <TT>TextField</TT> class. A <TT>JTextField</TT>
instance contains a single line of text that the user can edit.
The <TT>JTextField</TT> class does not provide the <TT>setEchoChar</TT>
and <TT>getEchoChar</TT> methods available in the <TT>TextField</TT>
class. Instead, the <TT>JPasswordField</TT> class is provided
for entering secure information. The <TT>JPasswordField</TT> class
is the topic of the next section.
<P>
The initial text and column width of the text field can be specified
in its constructor. Calling the default constructor will create
an empty text field. The <TT>setText</TT> method can be used to
replace the existing text in the component. Passing <TT>null</TT>
or an empty string to this method will clear the text field. The
<TT>setColumns</TT> method updates the column width of the text
field. The <TT>getColumns</TT> method returns the current value
of this property. When the text field is empty, the <TT>getText</TT>
method will return an empty string, not <TT>null</TT>.
<P>
The alignment of the text in a <TT>JTextField</TT> instance can
be specified with the <TT>setHorizontalAlignment</TT> method.
The parameters for this method are the familiar <TT>LEFT</TT>,
<TT>RIGHT</TT>, and <TT>CENTER</TT> constants defined in the <TT>SwingConstants</TT>
interface that you saw earlier in this book when specifying the
text alignment on labels and buttons. The current value of this
property can be queried with the <TT>getHorizontalAlignment</TT>
method. The horizontal alignment is the only bound property introduced
by the <TT>JTextField</TT> class. The name of the property is
the hard-coded string <TT>horizontalAlignment</TT> defined in
the <TT>JTextField</TT> class.
<P>
If the Enter key is struck in a text field, an <TT>ActionEvent</TT>
is sent to all registered listeners. Calling the <TT>setActionCommand</TT>
method will specify the <TT>ActionCommand</TT> for the event.
If the <TT>ActionCommand</TT> has not been set, the text in the
text field is used. Modifying the <TT>Keymap</TT> for the text
field can disable firing an <TT>ActionCommand</TT> from <TT>JTextField</TT>
instances. The <TT>Keymap</TT> for textual components will be
discussed later in this chapter.
<P>
The most common usage of the <TT>JTextField</TT> class is to obtain
a small amount of text from the user. The <TT>TextFieldTest</TT>
application shown in Listing 7.1 presents a simple example of
a <TT>JTextField</TT> in a frame. It demonstrates reading and
setting the contents in a <TT>JTextField</TT> instance as well
as receiving <TT>ActionEvents</TT> from the component. When the
Enter key is clicked in the text field, the contents of the text
field are printed to the console and then cleared. The resulting
window is shown in Figure 7.1.
<P>
<A HREF="javascript:popUp('f7-1.gif')"><B>Figure 7.1 :</B> <I>The TextFieldTest application</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.1&nbsp; The </B><TT><B>TEXTFIELD</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTextField instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class TextFieldTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the text field and display it.
     * Add an ActionListener to the text field that
     * echos the contents of the field when an
     * ActionEvent is received.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        
        JFrame frame = new ApplicationFrame( &quot;TextField Test&quot; );
        
        JTextField textField = new JTextField( &quot;Initial Data&quot;, 24 );
        textField.setActionCommand( &quot;TestText&quot; );
        
        //
        // Add the ActionListener.
        //
        textField.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                System.out.println( &quot;ActionCommand = &quot; + 
                                    event.getActionCommand() );
                JTextField source = ( JTextField )event.getSource();
                System.out.println( &quot;Text =&quot; + source.getText() );
                source.setText( null );
                System.out.println();
            } 
        }  );
        
        textField.setBorder( BorderFactory.createLoweredBevelBorder() );
        frame.getContentPane().add( textField, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // TextFieldTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>JTextField</TT> class delegates tracking of the columns
that are visible in the text field to a <TT>BoundedRangeModel</TT>
instance. This is of most importance when the entire text contained
in the text field is not visible. The <TT>minimum</TT>, <TT>maximum</TT>,
<TT>value</TT>, and <TT>extent </TT>properties of the model define
the portion of the text visible in the text field. The <TT>getHorizontalVisibility</TT>
method returns the <TT>BoundedRangeModel</TT> used for the text
field. Adjusting the <TT>value</TT> property in the model sets
the first character visible in the text field. The <TT>JTextField</TT>
class contains the <TT>setScrollOffset</TT> and <TT>getScrollOffset</TT>
convenience methods that set and query the <TT>value</TT> property
of the model directly. Once again, the <TT>value</TT> property
only affects text fields that contain a string that is too long
to fit in its display area. Furthermore, the <TT>setScrollOffset</TT>
method does not have any effect until this is the case.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JTextField</TT> class handles strings that do not fit in its display area very poorly. When the user enters an additional character, the existing text as well as the new character are pushed to the left of the insertion position; the insertion position does not move. Typically the text to the right of the insertion position is scrolled right and the insertion position moves right one character. This condition is exacerbated when the insert position is in the first column. In this state, the newly entered text is not visible because it is pushed left out of view, making it appear to the user that the character he or she typed was not accepted by the control.
</BLOCKQUOTE>
<BLOCKQUOTE>
Another odd behavior is that the control tries to display the last character in the text field. This often causes the insertion location to shift left, possibly to the first column, while the user is typing. This is very confusing for the user.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="TheTTFONTSIZEJPasswordFieldFONTTTFONTSIZEClassFONT">
The <TT>JPasswordField</TT>
Class</A></H2>
<P>
The <TT>JPasswordField</TT> class is an extension of the <TT>JTextField</TT>
class that provides a control for entering text but does not display
the originally entered text. Instead, an arbitrary character is
echoed in the Password field. The echo character can be requested.
However, if the look-and-feel implementation contains a custom
graphical technique to display input characters, this request
might not be honored.
<P>
The constructors for the <TT>JPasswordField</TT> class are identical
to those contained in the <TT>JTextField</TT> class. These create
a Password field with the default echo character, the asterisk
<TT>*</TT> character. The <TT>setEchoChar</TT> method specifies
the character to echo in the Password field when the user enters
a character. This is to give feedback that a character was in
fact received. Passing this method the value of <TT>0</TT> resets
the echo character to its default value. The <TT>echoCharIsSet</TT>
method returns <TT>true</TT> if the echo character has been set
and <TT>false</TT> otherwise. The <TT>getEchoChar</TT> returns
the current value of this property. For an unexplained reason,
the echo character is not a bound property of the <TT>JPasswordField</TT>
class.
<P>
When an echo character other than an asterisk is used in a <TT>JPasswordField</TT>
instance, the Password field does not display the alternate echo
character properly. The width of an asterisk is used to advance
the cursor, even when it is not the echo character. This bug makes
using arbitrary echo characters unfeasible at this time. This
can be seen in Figure 7.2 when a <TT>-</TT> is used as the echo
character in a <TT>JPasswordField</TT> instance.
<P>
For security reasons, the <TT>copy</TT> and <TT>cut</TT> methods
are disabled in the <TT>JPasswordField</TT> class. If either of
these actions is attempted, a beep is sounded and the action is
not performed.
<P>
The <TT>getText</TT> method is not used to query the text in a
Password field. Instead, the <TT>getPassword</TT> method is used.
Once again, this is for security reasons. The <TT>getPassword</TT>
method returns an array of characters, rather than a <TT>String</TT>
instance. For security reasons, it is suggested that each character
in the array be overwritten when the calling method is done with
the password.
<P>
The <TT>PasswordFieldTest</TT> application shown in Listing 7.2
presents an application that displays a <TT>JPasswordField</TT>
instance in a frame that resembles a login dialog box. The resulting
frame is shown in Figure 7.2.
<P>
<A HREF="javascript:popUp('f7-2.gif')"><B>Figure 7.2 :</B> <I>The PasswordFieldTest application</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.2&nbsp; The </B><TT><B>PASSWORDFIELDTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JPasswordField instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class PasswordFieldTest extends Object { 

    /**
     * Application entry point.
     * Create a frame and a login type display.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        
        JFrame frame = new ApplicationFrame( &quot;PasswordField Test&quot; );
        
        JPanel panel = new JPanel();
        panel.setLayout( new GridLayout( 2, 2 ) );
        
        JLabel nameLabel = new JLabel( &quot;User Name: &quot;, 
                                       SwingConstants.RIGHT );
        JLabel passwordLabel = new JLabel( &quot;Password: &quot;, 
                                       SwingConstants.RIGHT );
        JTextField userNameTextField = new JTextField( 12 );
        JPasswordField passwordPasswordField = new JPasswordField( 12 );
        passwordPasswordField.setEchoChar( '-' );
        
        panel.add( nameLabel );
        panel.add( userNameTextField );
        panel.add( passwordLabel );
        panel.add( passwordPasswordField );
        
        //
        // Add the ActionListener.
        //
        passwordPasswordField.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                System.out.println( &quot;ActionCommand = &quot; + 
                                    event.getActionCommand() );
                JPasswordField source = 
                               ( JPasswordField )event.getSource();
                char[] password = source.getPassword();
                for( int i = 0; i &lt; password.length; i++ ) { 
                    System.out.print( password[i] );
                    password[i] = ( char )0;                    
                } 
                source.setText( null );
                System.out.println();
                System.out.println();
            } 
        }  );
        
        panel.setBorder( BorderFactory.createLoweredBevelBorder() ); 
        frame.getContentPane().add( panel, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // PasswordFieldTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As can be seen in Figure 7.2, the <TT>PasswordFieldTest</TT> application
uses a <TT>-</TT> character as its echo character. An <TT>ActionListener</TT>
is registered with the Password field to be notified when the
Enter key is pressed. The <TT>ActionListener</TT> calls the <TT>getPassword</TT>
method to query the password and then prints each character to
the console. As suggested, each character in the password array
is cleared after it is used. The Password field control must be
reset after clearing the characters in its password array. If
this is not done, the view will still show the echoed characters
from the previous password. However, calling <TT>getPassword</TT>
will not return those characters. Calling the <TT>setText</TT>
method with a <TT>null</TT> parameter after the password has been
processed performs this.
<P>
The <TT>PasswordFieldTest</TT> application prints the <TT>ActionCommand</TT>
in its <TT>ActionListener</TT> method. The <TT>JPasswordField</TT>
inherits the <TT>ActionCommand</TT> processing from the <TT>JTextFieldClass</TT>.
This sets the <TT>ActionCommand</TT> to the contents of the text
field (the password in this case) if it hasn't explicitly been
set by the application by using the <TT>setActionCommand</TT>
method. This is a security hole in the current <TT>JPasswordField</TT>
implementation. To avoid this security hole, your applications
should always explicitly set the <TT>ActionCommand</TT> by calling
the <TT>setActionCommand</TT> method for each <TT>JPasswordField</TT>
used in the application.
<H2><A NAME="TheTTFONTSIZEJTextAreaFONTTTFONTSIZEClassFONT">
The <TT>JTextArea</TT> Class
</A></H2>
<P>
The <TT>JTextArea</TT> class is a lightweight textual component
that supports multiple lines of plain text. It is meant to be
a replacement for the AWT <TT>TextArea</TT> class and contains
almost the entire API contained in the <TT>TextArea</TT> class.
A fundamental difference in the two classes is that the <TT>TextArea</TT>
class manages scrolling internally while the <TT>JTextArea</TT>
class implements the <TT>Scrollable</TT> interface. This allows
a <TT>JTextArea</TT> instance to be placed into a <TT>JScrollPane</TT>
instance when scrolling is required. It can be used directly when
scrolling is not desired.
<H3><A NAME="ConfiguringaTTFONTSIZEJTextAreaFONTTTFONTSIZEInstanceFONT">
Configuring a <TT>JTextArea</TT>
Instance</A></H3>
<P>
The <TT>JTextArea</TT> class contains many constructors, ranging
from the default constructor to a version where the number of
rows and columns and initial text for the text area can be specified,
with many variants in between. As with all the textual components,
specifying the number of rows and columns is used during the calculation
of the preferred size of the component. Depending on the layout
manager used in the text area's parent container, this value may
or may not affect the size of the component.
<P>
The number of rows and columns in the text area can be altered
after construction by using the <TT>setColumns</TT> and <TT>setRows</TT>
methods. The current value of these properties can be queried
with the <TT>getColumns</TT> and <TT>getRows</TT> methods. It
is odd, but neither of these properties is bound in the <TT>JTextArea</TT>
class. These properties may very well be of interest to a <TT>PropertyChangeListener</TT>
listener, but the current implementation does not fire a <TT>propertyChangeEvent</TT>
when either property changes.
<P>
The <TT>TextAreaTest</TT> application is shown in Listing 7.3.
This is a simple application that displays a <TT>JTextArea</TT>
instance in a frame. This application will be expanded to show
additional capabilities of the <TT>JTextArea</TT> class throughout
this section. The window created from Listing 7.3 is shown in
Figure 7.3.
<P>
<A HREF="javascript:popUp('f7-3.gif')"><B>Figure 7.3 :</B> <I>The TextAreaTest application window</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.3&nbsp; The </B><TT><B>TEXTAREATEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTextArea instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class TextAreaTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the text area and display it.
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        String data = &quot;This is the initial text for the &quot; +
                      &quot;same text area. It should be long &quot; +
                      &quot;enough that it may be wrapped or truncated, &quot; +
                      &quot;depending on the JTextArea instance's settings.&quot;;


        JFrame frame = new ApplicationFrame( &quot;TextField Test&quot; );

        JTextArea textArea = new JTextArea( data, 12, 30 );

        textArea.setBorder( BorderFactory.createLoweredBevelBorder() );        
        frame.getContentPane().add( textArea, BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // TextAreaTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Figure 7.3 demonstrates the default behavior when a line is longer
than the width of the text area. The text area truncates the line
unless line wrapping is enabled. Passing the <TT>setLineWrap</TT>
method a parameter of <TT>true</TT> will enable line wrapping.
Once wrapping is enabled, the <TT>setWrapStyleWord</TT> method
is used to specify whether wrapping is performed at word or character
boundaries. Passing <TT>true</TT> to this method wraps lines at
word boundaries; <TT>false</TT> will enable wrapping at character
boundaries. The <TT>getLineWrap</TT> and <TT>getWrapStyleWord</TT>
methods return the current value of each of these properties.
Both these properties are bound in the <TT>JTextArea</TT> class.
Table 7.1 presents the complete list of bound properties added
in the <TT>JTextArea</TT> class.<BR>
<P>
<CENTER><B>Table 7.1&nbsp; Non-Inherited Bound Properties of the
JTextArea Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=192><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=192><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>tabSize</TT></TD><TD WIDTH=192><TT>setTabSize</TT>
</TD><TD WIDTH=192><TT>getTabSize</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>lineWrap</TT></TD><TD WIDTH=192><TT>getLineWrap</TT></TD>
<TD WIDTH=192><TT>setLineWrap</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>wrapStyleWord</TT></TD><TD WIDTH=192><TT>setWrapStyleWord</TT>
</TD><TD WIDTH=192><TT>getWrapStyleWord</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Adding the following lines to the <TT>TextAreaTest</TT> application
enables line wrapping at word boundaries. The resulting window
is shown in Figure 7.4.
<BLOCKQUOTE>
<PRE>
textArea.setLineWrap( true );
textArea.setWrapStyleWord( true );
</PRE>
</BLOCKQUOTE>
<P>
Instead of enabling line wrapping in a text area, the text area
can be placed in a scroll pane instance. In this situation, instead
of wrapping the text to make it visible in the text area, a scrollbar
is displayed when a line is longer than the width of the text
area. This can be used to alter the visible text in the text area.
A complete description of the <TT>JScrollPane</TT> class is presented
in <A HREF="..\ch15\ch15.htm" >Chapter 15</A>, &quot;Scrolling Components.&quot; The line of code
adding the text area to the frame can be changed as shown to place
the text area into a scroll pane. The resulting window is shown
in Figure 7.5.
<BLOCKQUOTE>
<PRE>
frame.getContentPane().add(
         new JScrollPane( textArea ), BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f7-4.gif')"><B>Figure 7.4 :</B> <I>Line wrapping enabled at word boundaries</I>.</A>
<P>
<A HREF="javascript:popUp('f7-5.gif')"><B>Figure 7.5 :</B> <I>JTextArea in a JScrollPane</I>.</A>
<P>
Figure 7.5 demonstrates the interaction between a scroll pane
and a text area when line wrapping is disabled. The single line
of text is not wrapped, and the user must scroll to see the text.
If there are more lines of text than are visible in the text area,
a vertical scrollbar is displayed to allow scrolling up and down.
Scrolling can be used in conjunction with line wrapping. In this
case, lines are wrapped at the edge of the text area, so the horizontal
scrollbar is not required. However, if there is more text than
can be displayed in the text area, a vertical scrollbar is displayed.
This is shown in Figure 7.6. The text area shown in this figure
has line wrapping enabled at word boundaries and is placed in
a scroll pane.
<P>
<A HREF="javascript:popUp('f7-6.gif')"><B>Figure 7.6 :</B> <I>JTextArea in a JScrollPane with word wrapping
enabled</I>.</A>
<P>
The other bound property defined in the <TT>JTextArea</TT> class
is the tab size. The default value for this property is eight
spaces. It can be set and queried with the <TT>setTabSize</TT>
and <TT>getTabSize</TT> methods, respectively.
<H3><A NAME="ManipulatingTextinaTTFONTSIZEJTextAreaFONTTTFONTSIZEInstanceFONT">
Manipulating Text in a <TT>JTextArea</TT>
Instance</A></H3>
<P>
The initial text in a <TT>JTextArea</TT> instance may be specified
when constructing the text area. The text may be replaced later
using the <TT>setText</TT> method. It can be queried with the
<TT>getText</TT> method. This behavior is the same as seen earlier
in the chapter for the single line <TT>JTextField</TT> class.
<P>
The <TT>JTextArea</TT> class contains methods to programmatically
insert, append, and replace text. The <TT>append</TT> method appends
the given <TT>String</TT> instance to the end of existing text
in the text area. The <TT>insert</TT> method inserts the given
<TT>String</TT> instance at the given column offset in the text
area. Columns are numbered from 0 in a text area, so to insert
a string at the beginning of a text area, the following code fragment
would be used:
<P>
<TT>textArea.insert( 'Text to insert', 0 );</TT>
<P>
The <TT>replaceRange</TT> method can be used to replace a range
of text with a new <TT>String</TT> instance. The new string does
not have to be the same length as the text to be replaced. Indeed,
passing an empty string has the effect of deleting the text in
the given range.
<P>
The number of lines in a text area can be queried with the <TT>getLineCount</TT>
method. The line displaying a given offset in the text area can
be queried with the <TT>getLineOfOffset</TT> method. Methods that
perform the opposite calculations are <TT>getLineStartOffset</TT>
and <TT>getLineEndOffset</TT>. These two methods take a line number
as a parameter and return the offset of the first and last characters
of that line in the text area.
<H2><A NAME="DocumentModel">
Document Model</A></H2>
<P>
Up to this point, the Swing text manipulation components behaved
similarly to their AWT equivalents. However, the JFC textual model
goes well beyond what was provided by the AWT. Even though you
have not seen it yet, the textual components are displaying the
data contained in a complex data model.
<P>
The data model used for JFC textual components is defined in the
<TT>swing.text</TT> package. The data model allows styles to be
added to the text. This allows multiple fonts, point sizes, and
colors to appear in the same component. Images can also be added
to a document model.
<P>
The components presented earlier in this chapter view a document
model. However, they are not capable of rendering all the capabilities
that can be expressed in the model. For this capability to be
realized, two textual components were introduced in the JFC: <TT>JTextPane</TT>
and <TT>JEditorPane</TT>. These classes are discussed in the next
sections.
<P>
The <TT>Document</TT> interface defines the text data model. Methods
are defined for adding and removing listeners in the document.
A document can consist of more than simple characters. Elements
can be inserted into the document to &quot;mark up&quot; the text.
Typical elements are to turn bold or italic fonts on and off.
An element can have an arbitrary set of attributes associated
with it. The set of currently active elements defines how the
text in the document will be rendered in the view.
<P>
The <TT>JTextComponent</TT> class serves as the root of the textual
class hierarchy in the JFC. It manages the caret, commands, and
keymaps. The caret is a pluggable object in the <TT>JTextComponent</TT>
class. The <TT>setCaret</TT> method is provided to change the
caret used for the text component. The <TT>getCaret</TT> method
can be used to query the current caret. The caret is a bound property
in the <TT>JTextComponent</TT> class. The complete list of bound
properties introduced in the <TT>JTextComponent</TT> class is
presented in Table 7.2. With the exception of the <TT>FOCUS_ACCELERATOR_KEY</TT>
property, the property names are hard coded in the <TT>JTextComponent</TT>
class.<BR>
<P>
<CENTER><B>Table 7.2&nbsp; Non-Inherited Bound Properties of the
JTextComponent Class</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=192><B>Setter Method</B>
</TD><TD WIDTH=192><B>Getter Method</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>document</TT></TD><TD WIDTH=192><TT>setDocument</TT>
</TD><TD WIDTH=192><TT>getDocument</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>margin</TT></TD><TD WIDTH=192><TT>setMargin</TT>
</TD><TD WIDTH=192><TT>getMargin</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>caret</TT></TD><TD WIDTH=192><TT>setCaret</TT></TD>
<TD WIDTH=192><TT>getCaret</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>highlighter</TT></TD><TD WIDTH=192><TT>setHighlighter</TT>
</TD><TD WIDTH=192><TT>getHighlighter</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>keymap</TT></TD><TD WIDTH=192><TT>setKeymap</TT>
</TD><TD WIDTH=192><TT>getKeymap</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>caretColor</TT></TD><TD WIDTH=192><TT>setCaretColor</TT>
</TD><TD WIDTH=192><TT>getCaretColor</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>selectionColor</TT></TD><TD WIDTH=192><TT>setSelectionColor</TT>
</TD><TD WIDTH=192><TT>getSelectionColor</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>selectedTextColor</TT></TD><TD WIDTH=192><TT>setSelectedTextColor</TT>
</TD><TD WIDTH=192><TT>getSelectedTextColor</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>disabledTextColor</TT></TD><TD WIDTH=192><TT>setDisabledTextColor</TT>
</TD><TD WIDTH=192><TT>getDisabledTextColor</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>FOCUS_ACCELERATOR_KEY</TT></TD><TD WIDTH=192><TT>setFocusAccelerator</TT>
</TD><TD WIDTH=192><TT>getFocusAccelerator</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>editable</TT></TD><TD WIDTH=192><TT>setEditable</TT>
</TD><TD WIDTH=192><TT>isEditable</TT>
</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
The <TT>JTextComponent</TT> supports a set of built-in commands.
Each command implements the <TT>Action</TT> interface. As you
saw in <A HREF="..\ch06\ch06.htm" >Chapter 6</A> &quot;The Button Hierarchy,&quot; it is easy
to add an action to a button. As you will see in <A HREF="..\ch09\ch09.htm" >Chapter 9</A> &quot;Menus
and Toolbars,&quot; it is just as easy to add an action to menus
and toolbars. The <TT>getActions</TT> method can be called to
query the set of actions supported by a text component. The <TT>ShowTextActions</TT>
application shown in Listing 7.4 queries the actions registered
for a <TT>JTextArea</TT> instance and displays the name of each
action in the text area itself. Unfortunately, descriptions are
not specified for the text actions, so these cannot be displayed.
The application is shown in Figure 7.7.
<P>
<A HREF="javascript:popUp('f7-7.gif')"><B>Figure 7.7 :</B> <I>The ShowTextActions application</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.4&nbsp; The </B><TT><B>SHOWTEXTACTIONS</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays the Actions
 * in a JTextArea instance.
 *
 * @author Mike Foley
 **/
public class ShowTextActions extends Object { 

    /**
     * Application entry point.
     * Create a frame, the text area and display it.
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 


        JFrame frame = new ApplicationFrame( &quot;ShowTextActions&quot; );

        JTextArea textArea = new JTextArea( 12, 30 );

        Action[] actions = textArea.getActions();
        for( int i = 0; i &lt; actions.length; i++ ) { 
            textArea.append( 
                     actions[i].getValue( Action.NAME ).toString() );
            textArea.append( &quot;\ n&quot; );
        } 

        frame.getContentPane().add( new JScrollPane( textArea ), 
                                    BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );

    }  // main

}  // ShowTextActions
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The default actions shown by the <TT>ShowTextActions</TT> application
are defined in the <TT>DefaultEditorKit</TT> class. In that class,
constants are defined for each of the action names displayed in
the application. These constants can be used by applications,
rather than hard coding the action name.
<P>
The <TT>JTextComponent</TT> class provides the <TT>keymap</TT>
property that maps keystrokes to actions. The <TT>getKeymap</TT>
and <TT>setKeymap</TT> methods are provided to query and set the
<TT>keymap</TT> for a given text component. The <TT>keymap</TT>
property is a bound property. The class also maintains a list
of named keymaps. A named keymap can be added by calling the static
<TT>addKeymap</TT> method. The static <TT>getKeymap</TT> method
will return the keymap associated with the string name passed
to the method. This method will return <TT>null</TT> if a keymap
hasn't been added with the given name. The <TT>loadKeymap</TT>
method is a convenience method that loads the given <TT>KeyBinding</TT>
array into the given <TT>keymap</TT> instance. If there already
is a binding associated with an action in the keymap, it will
be replaced with the new binding. The <TT>KeyBinding</TT> class
shown in Listing 7.5 is defined in the <TT>JTextComponent</TT>
class. The class simply maps a <TT>Keystroke</TT> instance to
an action name.<p>
<HR>
<P>
<B>Listing 7.5&nbsp; The </B><TT><B>KEYBINDING</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Binding record for creating key bindings.
 */
public static class KeyBinding { 
        
    /**
     * The key.
     */
    public KeyStroke key;

    /**
     * The name of the action for the key.
     */
    public String actionName;

    /**
     * Creates a new key binding.
     *
     * @param key the key
     * @param actionName the name of the action for the key
     */
    public KeyBinding(KeyStroke key, String actionName) { 
        this.key = key;
        this.actionName = actionName;
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>Keymap</TT> interface shown in Listing 7.6 defines the
responsibilities of a class that can be used as a keymap. The
<TT>JTextComponent</TT> class defines a class named <TT>DefaultKeymap</TT>
that it loads with the name <TT>DEFAULT_KEYMAP</TT>. This keymap
will be shared by all text components created by an application.
<p>
<HR>
<P>
<B>Listing 7.6&nbsp; The </B><TT><B>KEYMAP</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface Keymap { 

    /**
     * Fetches the name of the set of key-bindings.
     *
     * @return the name
     */
    public String getName();

    /**
     * Fetches the default action to fire if a 
     * key is typed (i.e. a KEY_TYPED KeyEvent is received)
     * and there is no binding for it.  Typically this
     * would be some action that inserts text so that 
     * the keymap doesn't require an action for each 
     * possible key.
     *
     * @return the default action
     */
    public Action getDefaultAction();

    /**
     * Set the default action to fire if a key is typed.
     *
     * @param a the action
     */
    public void setDefaultAction(Action a);

    /**
     * Fetches the action appropriate for the given symbolic
     * event sequence.  This is used by JTextController to 
     * determine how to interpret key sequences.  If the
     * binding is not resolved locally, an attempt is made
     * to resolve through the parent keymap, if one is set.
     *
     * @param key the key sequence
     * @returns  the action associated with the key
     *  sequence if one is defined, otherwise null
     */
    public Action getAction(KeyStroke key);

    /**
     * Fetches all of the keystrokes in this map that
     * are bound to some action.
     *
     * @return the list of keystrokes
     */
    public KeyStroke[] getBoundKeyStrokes();

    /**
     * Fetches all of the actions defined in this keymap.
     *
     * @return the list of actions
     */
    public Action[] getBoundActions();

    /**
     * Fetches the keystrokes that will result in 
     * the given action.
     *
     * @param a the action
     * @return the list of keystrokes
     */
    public KeyStroke[] getKeyStrokesForAction(Action a);

    /**
     * Determines if the given key sequence is locally defined.
     *
     * @param key the key sequence
     * @return true if the key sequence is locally defined else false
     */
    public boolean isLocallyDefined(KeyStroke key);

    /**
     * Adds a binding to the keymap.
     *
     * @param key the key sequence
     * @param a the action
     */
    public void addActionForKeyStroke(KeyStroke key, Action a);

    /**
     * Removes a binding from the keymap.
     *
     * @param keys the key sequence
     */
    public void removeKeyStrokeBinding(KeyStroke keys);

    /** 
     * Removes all bindings from the keymap.
     */
    public void removeBindings();

    /**
     * Fetches the parent keymap used to resolve key-bindings.
     *
     * @return the keymap
     */
    public Keymap getResolveParent();

    /**
     * Sets the parent keymap, which will be used to 
     * resolve key-bindings.
     *
     * @param parent the parent keymap
     */
    public void setResolveParent(Keymap parent);

}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The default keymap is loaded in the <TT>JTextComponent</TT> class
with the following code.
<BLOCKQUOTE>
<PRE>
static final KeyBinding[] defaultBindings = { 
    new KeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE, 0),
                   DefaultEditorKit.deletePrevCharAction),
    new KeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),
                   DefaultEditorKit.deleteNextCharAction),
    new KeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0),
                   DefaultEditorKit.forwardAction),
    new KeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0),
                   DefaultEditorKit.backwardAction)
} ;

static { 
    try { 
        keymapTable = new Hashtable(17);
        Keymap binding = addKeymap(DEFAULT_KEYMAP, null);
        binding.setDefaultAction(
                new DefaultEditorKit.DefaultKeyTypedAction());
        EditorKit kit = new DefaultEditorKit();
        loadKeymap(binding, defaultBindings, kit.getActions());
}  catch (Throwable e) { 
        e.printStackTrace();
        keymapTable = new Hashtable(17);
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
From the <TT>defaultBindings</TT> table, you can see that the
default keymap only contains mappings for four simple actions
as well as the default action. The look-and-feel for the application
can add additional bindings to the keymap.
<H3><A NAME="InputFiltering">
Input Filtering</A></H3>
<P>
A common requirement in textual components is to limit the type
of text that can be entered into the component. For example, in
a form where a person's age is entered, only a positive integer
value is allowed. When using an AWT text component, this functionality
was typically achieved by overriding the keyboard-input method
and only passing valid keystrokes to the text component.
<P>
This approach also can be taken with JFC text components; however,
it is not the preferred method. Instead, a custom document class
that only accepts valid values can be created and set for the
text component. This technique has many advantages over keystroke
filtering. First, it works for text pasted into the component
as well as text entered via the keyboard. Second, the custom document
class can be used for any class that expects a document model.
Finally, it allows the data manipulation code to be removed from
the view code.
<P>
The <TT>TextFilterDocument</TT> class shown in Listing 7.7 is
an extension to the <TT>PlainDocument</TT> class. The <TT>insertString</TT>
method is overridden. This method is called whenever text is to
be added to the document. The <TT>TextFilterDocument</TT> class
only allows the characters 0-9 to be added to the document. This
policy is enforced in the <TT>insertString</TT> method. When a
string is to be inserted into the document, each character is
tested. If any character is not a digit, a beep is sounded and
the text is not added to the model. If each character is a digit,
the <TT>PlainDocument</TT> class's version of the <TT>insertString</TT>
method is called with the same parameters as those given to the
method.<p>
<HR>
<P>
<B>Listing 7.7&nbsp; The </B><TT><B>TEXTFILTERDOCUMENT</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.Toolkit;

import javax.swing.text.*;


/**
 * Document to only allow numbers.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class TextFilterDocument extends PlainDocument { 

    /**
     * Valid number strings.
     **/
    public static final String NUMBERS = &quot;0123456789&quot;;


    /**
     * TextFilterDocument, constructor
     **/
    public TextFilterDocument()
{ 
        super();
} 


    /**
     * A String is being inserted into the Document.
     * Ensure that all characters are in NUMBERS.
     *
     * @param offset Where the new string goes.
     * @param string The String to be inserted after check.
     * @param attributeSet Attributes for the new string.
     **/
    public void insertString( int offset, String string, 
                              AttributeSet attributeSet )
        throws BadLocationException { 

        //
        // If nothing to insert, do nothing.
        //
        if( string == null )
            return;

        //
        // Ensure each character in the string is a number.
        //
        for( int i = 0; i &lt; string.length(); i++ ) { 
            if( NUMBERS.indexOf( string.valueOf( 
                string.charAt(i) ) ) == -1 ) { 
                    
                //
                // Not a number, don't insert the string.
                // Beep to let the user know something is wrong.
                //
                Toolkit.getDefaultToolkit().beep();
                return;
            } 
        } 

        //
        // Let our parent do the real work.
        //
        super.insertString( offset, string, attributeSet );

    }  // insertString

}  // TextFilterDocument
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>TextFilterDocument</TT> class can be used as the model
in a <TT>JTextField</TT> instance by using the following line
of code.
<P>
<TT>JTextField integerTextField = new JTextField(
new TextFilterDocument() );</TT>
<P>
If a character other than 0-9 is entered in <TT>integerTextField</TT>,
a beep is sounded and the character is not displayed in the component.
This technique can be extended to form more complex textual filters.
<H2><A NAME="TheTTFONTSIZEJEditorPaneFONTTTFONTSIZEClassFONT">
The <TT>JEditorPane</TT>
Class</A></H2>
<P>
The <TT>JEditorPane</TT> class is a textual component that can
be configured to edit different content types. The <TT>EditorKit</TT>
currently being used by the Editor pane defines the content type
understood by the component. The <TT>setEditorKit</TT> and <TT>getEditorKit</TT>
 methods can be used to set and query the current editor kit.
The editor kit is the only new bound property defined in the <TT>JEditorPane</TT>
class. The JFC provides editor kits for plain, HTML, and RTF text.
Example usage of each of these content types is given in this
section.
<H3><A NAME="TextContenttheTTFONTSIZEJTextPaneFONTTTFONTSIZEClassFONT">
Text Content, the <TT>JTextPane</TT>
Class</A></H3>
<P>
The <TT>JTextPane</TT> class extends the <TT>JEditorPane</TT>
class. It is capable of displaying styled text contained in a
<TT>Document</TT> model. The class configures itself with a <TT>StyledEditorKit</TT>
instance as its editor kit. Passing a <TT>StyledDocument</TT>
to the class's constructor also can create an instance of the
class. The <TT>setDocument</TT> method is overridden to ensure
that the document being set for the <TT>JTextPane</TT> instance
is a <TT>StyledDocument</TT> instance. If this is not the case,
an <TT>IllegalArgumentException</TT> is thrown.
<P>
The remaining methods in the <TT>JTextPane</TT> class are convenience
methods that pass the message to the <TT>StyledDocument</TT> or
<TT>StyledEditorKit</TT>. The <TT>JTextPane</TT> class allows
components and icons to be added as well as text. These are added
by calling the <TT>insertComponent</TT> and <TT>insertIcon</TT>
methods, respectively.
<P>
The <TT>ShowTextPaneActions</TT> application shown in Listing
7.8 is a modified version of the <TT>ShowTextActions</TT> presented
in Listing 7.4. Instead of showing the actions available for a
<TT>JTextArea</TT> instance in a text area, the actions available
for a <TT>JTextPane</TT> instance are shown in a text pane. The
resulting application is shown in Figure 7.8.
<P>
<A HREF="javascript:popUp('f7-8.gif')"><B>Figure 7.8 :</B> <I>The ShowTextPane
Actions application</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.8&nbsp; The </B><TT><B>SHOWTEXTPANEACTIONS</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.text.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays the Actions
 * in a JTextPane instance.
 *
 * @author Mike Foley
 **/
public class ShowTextPaneActions extends Object { 

    /**
     * Application entry point.
     * Create a frame, the text pane and display it.
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 


        JFrame frame = new ApplicationFrame( &quot;ShowTextPaneActions&quot; );

        JTextPane textPane = new JTextPane();
        StyledDocument document = textPane.getStyledDocument();
        Action[] actions = textPane.getActions();
        for( int i = 0; i &lt; actions.length; i++ ) { 
            try { 
                document.insertString( document.getLength(), 
                         actions[i].getValue( Action.NAME ).toString(),
                         null );
                document.insertString( document.getLength(), 
                         &quot;\ t&quot;, null );
                document.insertString( document.getLength(), 
                         actions[i].toString(), null );
                document.insertString( document.getLength(), 
                         &quot;\ n&quot;, null );
            }  catch( BadLocationException bl ) { 
                System.err.println( bl );
            } 
        } 

        frame.getContentPane().add( new JScrollPane( textPane ), 
                                    BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );

    }  // main

}  // ShowTextPaneActions
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ShowTextPaneActions</TT> application is almost identical
to the <TT>ShowTextActions</TT> application. However, in this
version of the application, the action itself is also printed
to the text pane. In the figure you can also see that the <TT>JTextPane</TT>
class wraps lines that are too long to display in the width of
the component.
<H4>Styled Text</H4>
<P>
In the <TT>ShowTextPaneActions</TT> application, a text pane is
being used to display the actions. This allows styles to be added
to the text. The third parameter to the <TT>insertString</TT>
method is the <TT>AttributeSet</TT> to be applied to the text.
Passing <TT>null</TT> for this parameter uses the current attributes
in effect where the text is inserted. If an attribute set is specified,
the text will be formatted by using the format defined by the
given attribute set. The <TT>main</TT> method from the <TT>ShowTextActions</TT>
application can be modified as shown in Listing 7.9 to add styles
to the text added to the text pane. The resulting application
is shown in Figure 7.9.
<P>
<A HREF="javascript:popUp('f7-9.gif')"><B>Figure 7.9 :</B> <I>Styled text in the ShowTextPane
Actions application</I>.</A><p>
<HR>
<P>
<B>Listing 7.9&nbsp; Styles Added to the ShowTextPaneActions Application
<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Application entry point.
 * Create a frame, the text pane and display it.
 * Use styled text in the text pane.
 * @param args Command line parameter. Not used.
 **/
public static void main( String args[] ) { 
        
        
    JFrame frame = new ApplicationFrame( &quot;ShowTextPaneActions&quot; );
        
    MutableAttributeSet bold = new SimpleAttributeSet();
    StyleConstants.setFontFamily( bold, &quot;Times&quot; );
    StyleConstants.setBold( bold, true );
    StyleConstants.setFontSize( bold, 12 );
    
    MutableAttributeSet normal = new SimpleAttributeSet();
    StyleConstants.setFontFamily( normal, &quot;Courier&quot; );
    StyleConstants.setBold( normal, false );
    StyleConstants.setFontSize( normal, 8 );
               
    JTextPane textPane = new JTextPane();
                
    StyledDocument document = textPane.getStyledDocument();
    Action[] actions = textPane.getActions();
    for( int i = 0; i &lt; actions.length; i++ ) { 
        try { 
            document.insertString( document.getLength(), 
                     actions[i].getValue( Action.NAME ).toString(),
                     bold );
            document.insertString( document.getLength(), 
                     &quot;\ t&quot;, bold );
            document.insertString( document.getLength(), 
                     actions[i].toString(), normal );
            document.insertString( document.getLength(), 
                     &quot;\ n&quot;, normal );
        }  catch( BadLocationException bl ) { 
            System.err.println( bl );
        } 
    } 
        
    frame.getContentPane().add( new JScrollPane( textPane ), BorderLayout.CENTER );
        
    frame.pack();
    frame.setVisible( true );
      
}  // main
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>AttributeSet</TT> interface defines an immutable view
of an attribute set. Each attribute in the set is a name/value
pair. The <TT>MutableAttributeSet</TT> interface extends the <TT>AttributeSet</TT>
interface and provides method to add and remove attributes from
the set. The <TT>SimpleAttributeSet</TT> class implements the
<TT>MutableAttributeSet</TT> interface. As such, it can be used
to specify a style in the text pane. The <TT>StyleConstants</TT>
class contains methods that add attributes to a <TT>MutableAttributeSet</TT>
with well-known names. Each method in the class is static. In
the previous example, the font was made bold with the following
line of code:
<P>
<TT>StyleConstants.setBold( bold, true );</TT>
<P>
The <TT>StyleConstants</TT> class adds an attribute to the given
<TT>MutableAttributeSet</TT> with the name <TT>FontConstants.Bold</TT>
and a value of <TT>Boolean.TRUE</TT>. The <TT>FontConstants</TT>
class is defined in the <TT>StyleConstants</TT> class and defines
constants and methods for setting and querying the constants for
such well-known attributes as font family, font size, bold, italic,
and underlined. When using the <TT>StyleConstants</TT> class,
the <TT>FontConstants</TT> class usage is hidden from the calling
code.
<H4>Adding Icons and Components</H4>
<P>
The <TT>JTextPane</TT> class allows icons and components to be
embedded in its content. The <TT>insertComponent</TT> and <TT>insertIcon</TT>
methods are provided for this purpose. These methods are convenience
methods that set the given icon or component in the current attribute
set and replace the text at the current position with an empty
string. Since the icon or component is in the attribute set at
that location, it is drawn in the view.
<P>
The <TT>TextPaneIcons</TT> application shown in Listing 7.10 demonstrates
the usage of these two methods. The resulting window is shown
in Figure 7.10.
<P>
<A HREF="javascript:popUp('f7-10.gif')"><B>Figure 7.10:</B> <I>The TextPaneIcons
application</I>.</A><p>

<HR>
<P>
<B>Listing 7.10&nbsp; The </B><TT><B>TEXTPANEICONS</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.util.Hashtable;

import javax.swing.*;
import javax.swing.text.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays the icons
 * and labels in a JTextPane instance.
 *
 * @author Mike Foley
 **/
public class TextPaneIcons extends Panel { 

    /**
     * The Actions available in a Hashtable.
     * This allows an Action to be looked-up
     * by name.
     **/
    Hashtable commands;


    /**
     * TextPaneIcons, constructor.
     * &lt;p&gt;
     * Create the text panel. This is a panel
     * with a JTextPane in the center region, and
     * buttons in the south.
     **/
    public TextPaneIcons() { 

        setLayout( new BorderLayout() );

        JTextPane textPane = new JTextPane();
        commands = createCommands( textPane );

        add( new JScrollPane( textPane ), BorderLayout.CENTER );

        add( createButtons(), BorderLayout.SOUTH );

    }  // TextPaneIcons


    /**
     * Create the buttons for the application.
     * &lt;p&gt;
     * @return A Component containing the buttons for the application.
     **/
    protected Component createButtons() { 

        JPanel buttons = new JPanel();
        buttons.setLayout( new BoxLayout( buttons, BoxLayout.X_AXIS ) );

        JButton b;

        b = new JButton( &quot;Icon&quot; );
        b.addActionListener( new AddIconAction( &quot;logo.gif&quot; ) );
        buttons.add( b );

        b = new JButton( &quot;Label&quot; );
        b.addActionListener( new AddLabelAction( &quot;Hello&quot; ) );
        buttons.add( b );

        b = new JButton( &quot;Clear&quot; );
        b.addActionListener( new ClearAction() );
        buttons.add( b );

        b = new JButton( &quot;Copy&quot; );
        b.addActionListener( getAction( DefaultEditorKit.cutAction ) );
        buttons.add( b );

        b = new JButton( &quot;Copy&quot; );
        b.addActionListener( getAction( DefaultEditorKit.copyAction ) );
        buttons.add( b );

        b = new JButton( &quot;Paste&quot; );
        b.addActionListener( getAction( DefaultEditorKit.pasteAction ) );
        buttons.add( b );

        return( buttons );        
    } 


    /**
     * Create a Hashtable of the Actions registered for
     * the given JTextComponent. The key for each element
     * is the action's name, and the value is the action
     * itself.
     * &lt;p&gt;
     * @return A Hashtable of Actions.
     **/
    protected Hashtable createCommands( JTextComponent textComponent ) { 

        Hashtable commands = new Hashtable();

     Action[] actions = textComponent.getActions();
         for (int i = 0; i &lt; actions.length; i++) { 
             Action a = actions[i];
             commands.put( a.getValue( Action.NAME ), a );
         } 
         return( commands );
    } 


    /**
     * Look up the Action associated with the given name.
     * Null will be returned if there is not an Action for
     * the given name.
     * &lt;p&gt;
     * @return The Action associated with the given name.
     **/
    protected Action getAction( String name ) { 
     return( ( Action )commands.get( name ) );
    } 


    /**
     * Application entry point.
     * Create a frame, the text pane and display it.
     * Create buttons along the bottom of the
     * window for editing in the text pane.
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;TextPane Icons&quot; );

        frame.getContentPane().add( new TextPaneIcons(), 
                                    BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );

    }  // main


    /**
     * An action that clears the text component.
     **/
    class ClearAction extends TextAction { 

         ClearAction() { 
             super( &quot;Clear&quot; );
             putValue( Action.SHORT_DESCRIPTION, 
                  &quot;Clear the text in the target&quot; );
        } 

         /**
          * Perform the action. If a text component can
          * be obtained from the event, clear it. If not,
          * beep.
          * &lt;p&gt;
          * @param event The event causing us to be called.
          **/
         public void actionPerformed( ActionEvent event ) { 
            JTextComponent target = getTextComponent( event );
            if( target != null ) { 
                try { 
                    Document document = target.getDocument();
                    document.remove( 0, document.getLength() );
                }  catch( BadLocationException ble ) { 
                    System.err.println( ble );
                } 
            }  else { 
                Toolkit.getDefaultToolkit().beep();
            }             
         } 
    }


    /**
     * An action that adds an Icon to
     * the target text pane when invoked.
     **/
    class AddIconAction extends TextAction { 

        /** 
         * The name of the icon to be
         * added to the text pane.
         **/
        private String iconName;

        /**
         * AddIconAction, constructor.
         * &lt;p&gt;
         * @param iconName The name of the image to be added 
         *                 to the text pane
         **/
         public AddIconAction( String iconName ) { 
             super( &quot;Clear&quot; );
             putValue( Action.SHORT_DESCRIPTION, 
                  &quot;Insert an icon into the target&quot; );
             this.iconName = iconName;
         } 

         /**
          * Perform the action. If a textpane component can
          * be obtained from the event, add the icon. If not,
          * beep.
          * &lt;p&gt;
          * @param event The event causing us to be called.
          **/
         public void actionPerformed( ActionEvent event ) { 
            JTextComponent target = getTextComponent( event );
            if( target instanceof JTextPane &amp;&amp; iconName != null ) { 
                Icon icon = new ImageIcon( iconName );
                ( ( JTextPane )target ).insertIcon( icon );
            }  else { 
                Toolkit.getDefaultToolkit().beep();
            } 
         } 

    }  // AddIconAction

    /**
     * An action that adds a JLabel instance to
     * the target text pane when invoked.
     **/
    class AddLabelAction extends TextAction { 
        
        /** 
         * The label for the JLabel instances
         * added to the text pane.
         **/
        private String labelText;

        /**
         * AddLabelAction, constructor.
         * &lt;p&gt;
         * @param labelText The text for the label added to the text pane
         **/
         public AddLabelAction( String labelText ) { 
             super( &quot;AddLabel&quot; );
             putValue( Action.SHORT_DESCRIPTION, 
                  &quot;Insert a label into the target&quot; );
             this.labelText = labelText;
         } 

         /**
          * Perform the action. If a textpane component can
          * be obtained from the event, add the label. If not,
          * beep.
          * &lt;p&gt;
          * @param event The event causing us to be called.
          **/
         public void actionPerformed( ActionEvent event ) { 
            JTextComponent target = getTextComponent( event );
            if( target instanceof JTextPane &amp;&amp; labelText != null ) { 
                JLabel label = new JLabel( labelText ); 
                label.setOpaque( true );
                ( ( JTextPane )target ).insertComponent( label );
            }  else { 
                Toolkit.getDefaultToolkit().beep();
            } 
         } 

    }  // AddLabelAction

}  // TextPaneIcons
</PRE>
</BLOCKQUOTE>
<HR>
<P>
New actions are created for clearing the text pane, inserting
an icon, and inserting a component. These actions, as well as
a few of the standard actions in the <TT>DefaultEditorKit</TT>
class, are added to buttons placed to the bottom of the text pane.
When the button labeled Icon is clicked, a new icon is inserted
into the text pane at the caret location. Similarly, when the
button labeled Label is pressed, a <TT>JLabel</TT> instance is
inserted into the text pane. In each action, a new icon or label
is created. This is because the same icon or label cannot be added
to the text pane multiple times. These actions extend the <TT>TextAction</TT>
class. This class is located in the <TT>swing.text</TT> package
and extends the <TT>AbstractAction</TT> class.
<P>
The <TT>TextAction</TT> class contains the <TT>getTextComponent</TT>
method that will find the <TT>JTextComponent</TT> associated with
the given event. It will return <TT>null</TT> if a <TT>JTextComponent</TT>
is not found. Using this method allows the text actions to not
be bound to a single text component. This allows a single instance
of each text action to be used with any number of text components.
<H3><A NAME="HTMLContent">
HTML Content</A></H3>
<P>
The <TT>HTMLEditorKit</TT> is defined in the <TT>swing.text.html</TT>
package. This editor kit understands HTML content. When an instance
of this class is used as the editor kit in a <TT>JEditorPane</TT>
instance, HTML content can be viewed in the component. The easiest
way to achieve this configuration is to pass an editor pane a
URL pointing to a reference containing HTML content.
<P>
The <TT>TextPaneContent</TT> application shown in Listing 7.11
creates a URL from the first argument passed to the application
on the command line. The <TT>setPage</TT> method of the <TT>JEditorPane</TT>
class is passed this URL. If the content type of the URL is HTML,
the editor pane creates an <TT>HTMLEditorKit</TT> and sets it
for the editor pane. The content is then displayed in the editor
pane. Nothing else needs to be done by the programmer. Also, because
the parameter to the <TT>setPage</TT> method is a URL, the content
doesn't need to reside locally. The <TT>getPage</TT> method can
be used to query the current page displayed in the editor pane.
The <TT>TextPaneContent</TT> application is shown in Figure 7.11.
<P>
If the document associated with the editor pane is a descendant
of the <TT>AbstractDocument</TT> class, the page specified in
the <TT>setPage</TT> method may be loaded asynchronously. Setting
the asynchronous load priority property of the document to a value
greater than or equal to zero enables asynchronous loading of
the page. Setting this property to a negative number forces synchronous
loading of the page. The <TT>setAsynchronousLoadPriority</TT>
method contained in the <TT>AbstractDocument</TT> class may be
used to specify this property. The <TT>getAsynchronousLoadPriority</TT>
may be used to query the current value of this unbound property.
<P>
<A HREF="javascript:popUp('f7-11.gif')"><B>Figure 7.11:</B> <I>The TextPaneContent
application</I>.</A>
<p>
<HR>
<P>
<B>Listing 7.11&nbsp; The </B><TT><B>TEXTPANECONTENT</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import java.net.*;
import java.io.IOException;

import javax.swing.*;
import javax.swing.text.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays the given URL
 * in a text pane.
 *
 * @author Mike Foley
 **/
public class TextPaneContent extends Object { 

    /**
     * Application entry point.
     * Create a frame, the text pane and display it.
     * Load the content of the URL passed as the
     * arguement to the application.
     * &lt;p&gt;
     * @param args A URL to load into the text pane.
     **/
    public static void main( String args[] ) { 

        //
        // Ensure there is a parameter.
//
        if( args.length &lt; 1 ) { 
            System.err.println( &quot;The URL of the content to load must &quot; +
                                &quot;be passed as the first argument to &quot; +
                                &quot;the application.&quot; );
            System.exit( -1 );
        } 

        //
        // See if a URL can be made from the argument.
        //
        URL content = null;
        try { 
            content = new URL( args[0] );
        }  catch( MalformedURLException me ) { 
            System.err.println( &quot;Could not create a URL from the &quot; +
                                &quot;parameter passed to the application.\ n&quot;
                                + args[0] );
            System.exit( -2 );
        } 
        JFrame frame = new ApplicationFrame( &quot;TextPaneContent&quot; );

        JEditorPane editorPane = new JEditorPane();

        try { 
            editorPane.setPage( content );
        }  catch( IOException io ) { 
            System.err.println( &quot;Could not load content from the URL\ n&quot; +
                                content );
            System.exit( -3 );
        } 
        frame.getContentPane().add( new JScrollPane( editorPane ), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // TextPaneContent
</PRE>
</BLOCKQUOTE>
<HR>
<p>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JEditorPane</TT> shows tremendous promise for handling HTML content. However, the current editor kit implementation isn't complete. The editor pane throws an exception when keystrokes are pressed in the component. These problems limit the usage of the HTML editor kit to only displaying simple HTML content.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="RTFContent">
RTF Content</A></H3>
<P>
The <TT>RTFEditorKit</TT> is defined in the <TT>swing.text.rtf</TT>
package. This editor kit understands rich text format (RTF) content.
When an instance of this class is used as the editor kit in a
<TT>JEditorPane</TT> instance, RTF content can be viewed in the
component.
<P>
The <TT>TextPaneContent</TT> application presented in the previous
section will display a URL containing RTF content as well as HTML
content. This is because the <TT>JEditorPane</TT> class will create
an <TT>RTFEditorKit</TT> and set it for the editor pane when a
URL with RTF content is set for the editor. Once again, nothing
else needs to be done by the programmer. The <TT>TextPaneContent</TT>
application loaded with RTF content is shown in Figure 7.12.
<P>
<A HREF="javascript:popUp('f7-12.gif')"><B>Figure 7.12:</B> <I>RTF content in the TextPaneContent application</I>.</A>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>JEditorPane </TT>class's handling of RTF content suffers some of the same shortcomings as its handling of HTML content. The current editor kit implementation doesn't recognize many RTF keywords. Once again, the usage of the RTF editor kit is limited to only displaying simple RTF content.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H3><A NAME="ContentHandlingMethods">
Content Handling Methods</A></H3>
<P>
The <TT>JEditorPane</TT> also recognizes plain text content. In
this case, a plain text editor kit is created and set for the
editor pane. These content types are registered during the static
initialization of the <TT>JEditorPane</TT> class. The code that
performs this operation is shown next. The <TT>registerEditorKitForContentType</TT>
method is called for each content type that the editor pane has
editor kits. The <TT>registerEditorKitForContentType</TT> method
manages a hashtable where the content type is the key and the
name of the class to be used as the editor kit for that content
type is the value.
<P>
The <TT>createEditorKitForContentType</TT> method can be used
to create an editor for one of the known content types. This method
takes the <TT>String</TT> content type as a parameter and returns
the editor kit it creates. It returns <TT>null</TT> if the type
has not been registered or if any other error occurs. The <TT>JEditorPane</TT>
class does not contain a method to query the known content types.
<BLOCKQUOTE>
<PRE>
registerEditorKitForContentType(&quot;text/plain&quot;, 
    &quot; javax.swing.JEditorPane$PlainEditorKit&quot;);
registerEditorKitForContentType(&quot;text/html&quot;, 
    &quot; javax.swing.text.html.HTMLEditorKit&quot;);
registerEditorKitForContentType(&quot;text/rtf&quot;, 
    &quot; javax.swing.text.rtf.RTFEditorKit&quot;);
registerEditorKitForContentType(&quot;application/rtf&quot;, 
    &quot; javax.swing.text.rtf.RTFEditorKit&quot;);
</PRE>
</BLOCKQUOTE>
<P>
If you create an editor kit that you want to handle a content
type, it must be registered by using the <TT>registerEditorKitForContentType</TT>
method, just as the <TT>JEditorPane</TT> class does for text,
HTML, and RTF content. Similarly, if you write a better version
of the HTML or RTF editor pane, that class needs to be registered
with the <TT>JEditorPane</TT> class for it to be used instead
of the version shipped with the JFC.
<P>
The content type can be explicitly set for an editor pane. Calling
the <TT>setContentType</TT> method and passing it the name of
the content type to set for the editor creates the proper editor
kit and sets it for the editor pane. If an unknown content type
is passed to this method, it silently fails. The <TT>getContentType</TT>
method returns the name of content currently being viewed in the
editor.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The text components in the JFC contain basic components that provide
lightweight replacements for the AWT textual components. However,
these components are built by using the Model View Controller
architecture that is common to most JFC components. The model
is defined by the <TT>Document</TT> interface. This interface
provides a more detailed representation than the <TT>JTextArea</TT>
or <TT>JTextField</TT> class can render. To address this deficit,
the <TT>JTextPane</TT> and <TT>JEditorPane</TT> classes are provided.
These classes are able to render the marked-up text represented
in the document model.
<P>
The concept of an editor kit has been defined to encapsulate a
particular textual content. By creating an editor kit, any type
of content can be handled in the document. Editor kits are provided
that understand HTML and RTF data formats.
<P>
The combination of the <TT>Document</TT> interface, the <TT>JEditorPane</TT>
class, and the editor kits provides a substantial enhancement
over the textual components provided in the AWT. Using these components
with the editor kits provided is a relatively easy task. However,
to add custom functionality to an editor kit or to create an editor
kit requires a far deeper understanding of the text package. This
chapter gives an introduction to the deeper understanding required
to achieve this functionality, as well as providing examples of
using the editor kits provided by the JFC.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch06\ch06.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch08\ch08.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
