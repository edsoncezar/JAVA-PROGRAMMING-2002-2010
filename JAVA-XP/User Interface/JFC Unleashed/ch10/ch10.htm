<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 10 - JList, JComboBox, and Bound Controls</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch09\ch09.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch11\ch11.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;10<br>
JList, JComboBox, and Bound Controls</H1>
<HR>
<p>


<UL>
<LI><A HREF="#RubberStampDrawing">
Rubber Stamp Drawing</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEListCellRendererFONTTTFONTSIZEInterfaceFONT">
The <TT>ListCellRenderer</TT>
Interface</A>
<LI><A HREF="#ASimpleTTFONTSIZEListCellRendererFONTTT">
A Simple <TT>ListCellRenderer</TT></A>
</UL>
<LI><A HREF="#UsingtheTTFONTSIZEJListFONTTTFONTSIZEClassFONT">
Using the <TT>JList</TT>
Class</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEListModelFONTTTFONTSIZEInterfaceFONT">
The <TT>ListModel</TT> Interface
</A>
<LI><A HREF="#TheSelectionModel">
The Selection Model</A>
<LI><A HREF="#TTFONTSIZEJListFONTTTFONTSIZEClassandModelInteractionsFONT">
<TT>JList</TT> Class and
Model Interactions</A>
</UL>
<LI><A HREF="#ComboBoxes">
Combo Boxes</A>
<UL>
<LI><A HREF="#ClassicComboBox">
Classic Combo Box</A>
<LI><A HREF="#TheTTFONTSIZEComboBoxModelFONTTT">
The <TT>ComboBoxModel</TT></A>
<LI><A HREF="#TTFONTSIZEJComboBoxFONTTTFONTSIZEClassandModelInteractionFONT">
<TT>JComboBox</TT> Class
and Model Interaction</A>
<LI><A HREF="#EditableComboBox">
Editable Combo Box</A>
</UL>
<LI><A HREF="#BoundedComponents">
Bounded Components</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEBoundedRangeModelFONTTTFONTSIZEInterfaceFONT">
The <TT>BoundedRangeModel</TT>
Interface</A>
<LI><A HREF="#ChangeEventandListenerInterface">
Change Event and Listener Interface</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJSliderFONTTTFONTSIZEControlFONT">
The <TT>JSlider</TT> Control
</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEJScrollBarFONTTTFONTSIZEClassFONT">
The <TT>JScrollBar</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEJProgressBarFONTTTFONTSIZEClassFONT">
The <TT>JProgressBar</TT>
Class</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The <TT>JList</TT> and <TT>JComboBox</TT> classes create components
that allow the user to select from a list of choices. The data
models for these two classes are very similar. In fact, the <TT>ComboBoxModel</TT>
interface extends the <TT>ListModel</TT> interface, adding methods
to set and query a selected item.
<P>
The <TT>JList</TT> and <TT>JComboBox</TT> classes introduce you
to the rendering portion of the Swing component architecture.
When the items in a list or combo box are painted, the component
itself doesn't do the painting. Instead, the painting is delegated
to a renderer object. A single renderer can paint the entire component.
<P>
The JFC contains the <TT>BoundedRangeModel</TT> interface, which
constrains an integer value between a minimum and maximum value.
This data model is used by a number of classes in the JFC, most
of which are presented in this chapter.
<P>
This chapter will introduce a number of new JFC classes and data
models. You will learn:
<UL>
<LI>Rendered drawing
<LI>How to use the <TT>JList</TT> class
<LI>How to use the <TT>JComboBox</TT> class
<LI>How to use the <TT>BoundedRangeModel</TT> interface
<LI>How to use the <TT>JScrollBar</TT> class
<LI>How to use the <TT>JSlider</TT> class
<LI>How to use the <TT>JProgressBar</TT> class
</UL>
<H2><A NAME="RubberStampDrawing">
Rubber Stamp Drawing</A></H2>
<P>
Complex controls such as lists can contain thousands of items
to display. Creating a <TT>JLabel</TT>, or another component,
to display each item in the list would be too resource-intensive
to be practical. However, it would be nice to be able to independently
configure each item in the list for display.
<P>
The JFC solution to this dilemma is to use a rendering component
to visualize an item in the list. When the list needs to paint
an item, the renderer is moved to the location where the item
in the list needs to be displayed, sized correctly, and configured
for the current item. Finally, the renderer paints the item. A
stock <TT>JList</TT> instance uses an instance of the <TT>DefaultListRenderer</TT>
class (which itself is an extension of the <TT>JLabel</TT> class)
to visualize its items. However, a custom renderer can be added
to the list to achieve any visual effect required. As you progress
through this section, you will see that many JFC components employ
a rendering component for visualization (the <TT>JTree</TT> and
<TT>JTable</TT> classes discussed in the next two chapters, to
name a few).
<H3><A NAME="TheTTFONTSIZEListCellRendererFONTTTFONTSIZEInterfaceFONT">
The <TT>ListCellRenderer</TT>
Interface</A></H3>
<P>
The methods that define a rendering entity for instances of the
<TT>JList</TT> class are defined in the <TT>ListCellRenderer</TT>
interface, shown in Listing 10.1. As such, any class can implement
this interface and act as a renderer for a list. In practice,
however, the majority of renderers used are extensions of the
<TT>JLabel</TT> class and implement the <TT>ListCellRenderer</TT>
interface.
<P>
The <TT>ListCellRenderer</TT> interface contains a single method:
<TT>getListCellRendererComponent</TT>. When this method is called,
the renderer must configure the component that will render the
value object passed to the method. The list where the item is
being drawn is passed to this method. This way, if a renderer
needs to know which list it is rendering, it does not need to
keep a reference to the list, allowing a single renderer to be
shared between any number of lists. The current state of the item
in the list is also passed to the <TT>getListCellRendererComponent</TT>
method. This allows the renderer to give visually distinct characteristics
to selected items and items with the input focus. After the renderer
has configured the component, it returns it to the caller.
<P>
The renderer should <I>not</I> create
a new component instance each time the <TT>getListCellRendererComponent</TT>
method is called. Instead, one component should be created and
reconfigured with the current list item on each call. As previously
mentioned, many times the renderer is itself a component. In that
case, the renderer configures itself in the <TT>getListCellRendererComponent</TT>
method and returns this from the method.<P>
<HR>
<P>
<B>Listing 10.1&nbsp;&nbsp;The </B><TT><B>LISTCELLRENDERER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ListCellRenderer
{ 
    /**
     * Return a component that has been configured to display the
     * specified value. That component's &lt;code&gt;paint&lt;/code&gt; method is
     * then called to &quot;render&quot; the cell.  If it is necessary to compute
     * the dimensions of a list because the list cells do not have a
     * fixed size, this method is called to generate a component on which
* &lt;code&gt;getPreferredSize&lt;/code&gt; can be invoked.
* 
     * @param list The JList we're painting.
     * @param value The value returned by 
     *               list.getModel().getElementAt(index).
     * @param index The cells index.
     * @param isSelected True if the specified cell was selected.
     * @param cellHasFocus True if the specified cell has the focus.
     * @return A component whose paint() method will render the 
     *         specified value.
     * 
     * @see JList
     * @see ListSelectionModel
     * @see ListModel
     */
    Component getListCellRendererComponent(
        JList list,
        Object value, 
        int index, 
        boolean isSelected, 
        boolean cellHasFocus);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ASimpleTTFONTSIZEListCellRendererFONTTT">
A Simple <TT>ListCellRenderer</TT></A></H3>
<P>
The <TT>SimpleListCellRenderer</TT> class is shown in Listing
10.2. This class is adapted from the default <TT>ListCellRenderer</TT>
used by the <TT>JList</TT> class, but fixes a couple of bugs contained
in the default renderer. The <TT>SimpleListCellRenderer</TT> class
extends the <TT>JLabel</TT> class. In its constructor, the component
is configured to be opaque, forcing the background color to be
painted by the renderer. The component's border is created in
the constructor, and a reference is kept to the border instance.
<P>
The <TT>getListCellRendererComponent</TT> configures the <TT>JLabel</TT>
to the current state of the given value. If the list item is selected,
the selected colors are queried from the list and set on the label.
If not, the normal colors are obtained from the list and set on
the label. Similarly, the list's font is queried and set on the
label. If the list item is an instance of an icon, it is added
to the label and the text is cleared. Otherwise, the <TT>toString</TT>
method of the list item is called to get the object's string representation.
Finally, the <TT>Border</TT> property is set for the label and
the label is returned to the caller.
<P>
The <TT>getListCellRendererComponent</TT> method of a renderer
has the potential to be called many times. It also has a significant
impact on a list's performance. This being the case, the method
must be efficient. Avoid unnecessary object creation in this method.
Whenever possible, you should reconfigure objects for the current
value rather than creating a new instance.<P>
<HR>
<P>
<B>Listing 10.2&nbsp;&nbsp;The </B><TT><B>SIMPLELISTCELLRENDERER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;
import java.io.*;

import javax.swing.*;
import javax.swing.border.*;


public class SimpleListCellRenderer extends JLabel
    implements ListCellRenderer, Serializable
{ 

    protected static Border emptyBorder;

    public SimpleListCellRenderer() { 
        super();
        
           emptyBorder = BorderFactory.createEmptyBorder( 2, 2, 2, 2 );
           
           //
           // We change the background color, so need to be opaque.
           //
        setOpaque(true);
    } 


    public Component getListCellRendererComponent(
        JList list,
        Object value,
        int index,
        boolean isSelected,
        boolean cellHasFocus)
    { 

        if( isSelected ) { 
            //
            // Draw like any other list when selected.
            //
            setBackground( list.getSelectionBackground() );
            setForeground( list.getSelectionForeground() );
       }  else { 
            //
            // Paint in the list normal foreground and background colors.
            //
            setBackground( list.getBackground() );
            setForeground( list.getForeground() );
       }  // else

       setFont( list.getFont() );

       if( value instanceof Icon ) { 
            setIcon( ( Icon )value);
            setText( &quot;&quot; );
        }  else { 
            setIcon( null );
            setText( (value == null ) ? &quot;&quot; : value.toString() );
       }  // else

       setBorder( ( cellHasFocus ) ? 
                 UIManager.getBorder( &quot;List.focusCellHighlightBorder&quot; ) :
emptyBorder );

    return this;
    } 
    
}  // SimpleListRenderer
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>SimpleListRenderer</TT>, as well as more exciting list
renderers, are demonstrated in the next section covering the <TT>JList</TT>
class.
<H2><A NAME="UsingtheTTFONTSIZEJListFONTTTFONTSIZEClassFONT">
Using the <TT>JList</TT>
Class</A></H2>
<P>
The <TT>JList</TT> class provides the visual representation for
selecting items in a set. In its simplest form, a list can be
instantiated with an array or vector of objects. The list will
create one item in the list for each element in the vector or
array. This technique is demonstrated in the <TT>ListTest</TT>
application for an array in Listing 10.3, which results in the
list shown in Figure 10.1. Similarly, the <TT>setListData</TT>
method can be called to replace the data contained in the list
to the given array or vector.<P>
<HR>
<P>
<B>Listing 10.3&nbsp;&nbsp;The </B><TT><B>LISTTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays JList instances
 * in its frame.
 *
 * @author Mike Foley
 **/
public class ListTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the list and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        String[] data = { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Grape&quot;, &quot;Banana&quot; } ;
        
        JFrame frame = new ApplicationFrame( &quot;List Test&quot; );
        
        JList list = new JList( data );
        
        frame.getContentPane().add( list, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // ListTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The list in the previous example allows multiple items to be selected
in the list. In Figure 10.1, all items are selected except the
item Grape. The default look-and-feel behavior is to perform a
Ctrl+mouse-click to select items after the first item is selected.
The list can be configured to allow the selection of a single
item or multiple items. When multiple item selection is allowed,
the selection can be specified to allow a continuous range or
arbitrary items in the list. The <TT>setSelectionMode</TT> method
can configure the list with the desired selection model.
<P>
<A HREF="javascript:popUp('f10-1.gif')"><B>Figure 10.1 :</B> <I>A simple list created from an array</I>.</A>
<P>
The constants shown in Table 10.1 are defined in the <TT>JList</TT>
class for the acceptable selection modes. The <TT>getSelectionMode</TT>
method returns the current selection mode of the list.<BR>
<P>
<CENTER><B>Table 10.1&nbsp;&nbsp;Selection Modes for a </B><TT><B>JLIST</B></TT></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=295><CENTER><B>Selection Mode</B></CENTER></TD>
<TD WIDTH=295><CENTER><B>Description</B></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>SINGLE_SELECTION</TT></TD><TD WIDTH=295>A single item can be selected at a time.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>SINGLE_INTERVAL_SELECTION</TT> </TD><TD WIDTH=295>Multiple items in one contiguous interval can be selected at a time.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>MULTIPLE_INTERVAL_SELECTION</TT> </TD><TD WIDTH=295>Multiple items can be selected in an order.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The colors used for displaying selected elements can be set and
queried using the <TT>setSelectionForeground</TT>/<TT>getSelectionForeground</TT>
and <TT>setSelectionBackground</TT>/<TT>getSelectionBackground</TT>
methods. These properties are bound in the <TT>JList</TT> class.
<P>
After displaying the list, the user's selection will need to be
queried at some point. The indexes of the selected items, or the
values themselves, can be queried. The <TT>getSelectedIndex</TT>
and <TT>getSelectedValue</TT> methods return the index or value
of the selected item in the list. If multiple selections are allowed,
the index of the first selected item, or its value, is returned.
If there is not a selected item, the <TT>getSelectedIndex</TT>
method returns <TT>-1</TT>, while the <TT>getSelectedValue</TT>
method returns <TT>null</TT>.
<P>
When multiple selection is enabled, the set of selected item's
indexes or the set of selected values can be queried with the
<TT>getSelectedIndices</TT> or <TT>getSelectedValues</TT> methods.
The <TT>getSelectedIndices</TT> method returns an array of the
indices of the selected items in numerical order, from the lowest
index to the highest. Both methods return <TT>null</TT> if the
selection set is empty. If only the range of selected indices
is required, the <TT>getMinSelectionIndex</TT> and <TT>getMaxSelectionIndex</TT>
methods can be used. If there are no items selected, both methods
return <TT>-1</TT>. Also, if only one item is selected, both methods
return the same index.
<P>
In many lists, there will be more data elements than can be displayed
at one time. When this is the case, the list can be added to a
<TT>JScrollPane</TT>. By default, the scroll pane will display
scrollbars when it cannot display the entire contents of the list
in its viewable area. A complete description of the <TT>JScrollPane</TT>
class and its options is presented in <A HREF="..\ch15\ch15.htm" >Chapter 15</A>, &quot;Scrolling
Components.&quot; The <TT>main</TT> method of the <TT>ListTest</TT>
application can be changed to create a list that scrolls, as shown
in Listing 10.4. The <TT>setVisibileRowCount</TT> method was used
to configure the list to display five elements. The <TT>getVisibleRowCount</TT>
method returns the number of elements displayed in the list. The
resulting list is shown in Figure 10.2.
<P>
<A HREF="javascript:popUp('f10-2.gif')"><B>Figure 10.2 :</B> <I>A JList contained in a JScrollPane</I>.</A>
<P>
<HR>
<P>
<B>Listing 10.4</B>&nbsp;&nbsp;Placing a <TT>JLIST</TT> Instance
in a <TT>JSCROLLPANE</TT> Instance<BR>
<BLOCKQUOTE>
<PRE>
public static void main( String args[] ) { 

        String[] data = { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Grape&quot;, &quot;Banana&quot;,
                        &quot;Mango&quot;, &quot;Pineapple&quot;, &quot;Peach&quot;, &quot;Pear&quot; } ;
        
        JFrame frame = new ApplicationFrame( &quot;List Test&quot; );
        
        JList list = new JList( data );
        list.setVisibleRowCount( 5 );
 
        JScrollPane scrollPane = new JScrollPane( list );
        scrollPane.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( scrollPane, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );

    }  // main
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Once the list is in a scroll pane, you may need to programmatically
alter which elements are visible in the viewport. The <TT>ensureIndexIsVisible</TT>
method scrolls the view to force an element at the specified index
to be displayed. If the index is already visible, the method doesn't
alter the list. The range of indexes currently being displayed
can be queried with the <TT>getFirstVisibleIndex</TT> and <TT>getLastVisibleIndex</TT>
methods.
<P>
The bounds of a range of cells in the list can also be queried
with the <TT>getCellBounds</TT> method. The indexes of the first
and last rows are passed to the method, and the <TT>Rectangle</TT>
that bounds the rows containing the indices is returned.
<P>
Instances of the <TT>JList</TT> class do not fire high-level mouse
events. For example, you may want to fire an <TT>ActionEvent</TT>
when a double-click is detected over a list element. This isn't
built into the list, so it has to be programmed by users of the
list. To aid in such development, the <TT>locationToIndex</TT>
method is provided. This method takes a <TT>Point</TT> instance
as a parameter to the method and returns the index of the element
whose bounds contain that point. If the point isn't over an element
in the list, <TT>-1</TT> is returned. A double-click of the left
mouse button on an item in a list can be detected with the following
mouse listener:
<BLOCKQUOTE>
<PRE>
list.addMouseListener( new MouseAdapter() { 
    public void mouseClicked( MouseEvent e ) { 
        if( e.getClickCount() == 2 &amp;&amp; 
            !( e.getModifiers() == InputEvent.ALT_MASK ) &amp;&amp;
            !( e.getModifiers() == InputEvent.META_MASK ) ) { 
            int index = list.locationToIndex(e.getPoint());
            if( 0 &lt;= index )
                System.out.println(&quot;Double-clicked on Item &quot; + index);
        } 
    } 
}  );&gt;
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheTTFONTSIZEListModelFONTTTFONTSIZEInterfaceFONT">
The <TT>ListModel</TT> Interface
</A></H3>
<P>
As you saw in the previous section, the <TT>JList</TT> class provides
convenience methods for creating a list from a vector or array.
However, you will often need to present data in a list that is
contained in a data structure more complex than a simple array
or vector. To do this, the class containing the data can implement
the <TT>ListModel</TT> interface. Then the class can be used as
the data model for a <TT>JList</TT> instance. Listing 10.5 shows
this interface. As you can see, implementing the <TT>ListModel</TT>
is very simple. The class must be able to return the size of the
list, as well as an element at any given index in the range of
0 through one less than the size of the list. The class implementing
the <TT>ListModel</TT> interface must also manage <TT>ListDataListener</TT>
instances.<P>
<HR>
<P>
<B>Listing 10.5&nbsp;&nbsp;The </B><TT><B>LISTMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ListModel
{ 
  /** 
   * Returns the length of the list.
   */
  int getSize();

  /**
   * Returns the value at the specified index.  
   */
  Object getElementAt(int index);

  /**
   * Add a listener to the list that's notified each time a change
   * to the data model occurs.
   * @param l the ListDataListener
   */  
  void addListDataListener(ListDataListener l);

  /**
   * Remove a listener from the list that's notified each time a 
   * change to the data model occurs.
   * @param l the ListDataListener
   */  
  void removeListDataListener(ListDataListener l);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ListDataListener</TT> interface and <TT>ListDataEvent</TT>
class are shown in Listing 10.6. They are implemented by classes
that are interested in changes to a <TT>ListModel</TT>. The <TT>JList</TT>
class implements <TT>ListDataListener</TT> to observe changes
in its data model. It is the responsibility of the model to fire
the appropriate event when the data contained in the model changes.
For example, if the list grows or shrinks, the <TT>intervalAdded</TT>
or <TT>intervalRemoved</TT> method of listeners must be called
so they can update their view.
<P>
The <TT>ListDataEvent</TT> class contains the information about
which items in the list have changed. The type of the event can
be queried with the <TT>getType</TT> method. This method will
return one of the three constants defined in the event. However,
the type is somewhat redundant because an <TT>INTERVAL_ADDED</TT>
type event is the parameter for the <TT>intervalAdded</TT> method,
an <TT>INTERVAL_REMOVED</TT> type event is the parameter for the
<TT>intervalRemoved</TT> method, and an <TT>INTERVAL_CHANGED</TT>
type event is the parameter for the <TT>contentsChanged</TT> method.
The two indices that are contained in the event, and returned
from the <TT>getIndex0</TT> and <TT>getIndex1</TT> methods, define
the range of items that are associated with the event. The range
is inclusive of the values returned from the <TT>get</TT> methods.
<P>
<HR>
<P>
<B>Listing 10.6&nbsp;&nbsp;The </B><TT><B>LISTDATALISTENER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ListDataListener extends EventListener { 

    /** 
     * Sent after the indices in the index0,index1 
     * interval have been inserted in the data model.
     * The new interval includes both index0 and index1.
     */
    void intervalAdded(ListDataEvent e);

    
    /**
     * Sent after the indices in the index0,index1 interval
     * have been removed from the data model.  The interval 
     * includes both index0 and index1.
     */
    void intervalRemoved(ListDataEvent e);


    /** 
     * Sent when the contents of the list have changed in a way 
     * that's too complex to characterize with the previous 
     * methods.  Index0 and index1 bracket the change.
     */
    void contentsChanged(ListDataEvent e);
} 

public class ListDataEvent extends EventObject 
{ 
    public static final int CONTENTS_CHANGED = 0;
    public static final int INTERVAL_ADDED = 1;
    public static final int INTERVAL_REMOVED = 2;

    private int type;
    private int index0;
    private int index1;

    public int getType() {  return type; } 
    public int getIndex0() {  return index0; } 
    public int getIndex1() {  return index1; } 

    public ListDataEvent(Object source,int type,int index0,int index1) { 
        super(source);
    this.type = type;
    this.index0 = index0;
    this.index1 = index1;
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
To aid in building <TT>ListModel</TT> classes, the <TT>AbstractListModel</TT>
class is provided. As its name implies, this is an abstract class.
It manages the <TT>ListDataListeners</TT> and contains methods
to fire events to those listeners. Extensions of this class must
manage the data in the list and implement the <TT>getSize</TT>
and <TT>getElementAt</TT> methods. Extending the <TT>AbstractListModel</TT>
class allows the model to manage the data in the list without
concerning itself with the listeners.
<P>
An example of a <TT>ListModel</TT> is shown in Listing 10.7. The
<TT>CustomListModel</TT> class extends the <TT>AbstractListModel</TT>
class to inherit the <TT>ListDataModelListeners</TT> management
functionality contained in the parent class. The <TT>CustomListModel</TT>
class is a data model that grows and shrinks over time. It configures
a JFC timer to receive notifications every <TT>UPDATE_TIME</TT>
milliseconds. In the <TT>actionPerformed</TT> method called by
the timer, the model adds or removes an item from the list depending
on if the list is currently growing or shrinking. The size of
the list is bounded by 0 and the <TT>maxSize</TT> attribute. The
<TT>actionPerformed</TT> method fires the appropriate event to
notify listeners of the change in the model.
<P>
An interesting observation can be made by looking at the <TT>getElementAt</TT>
method in the <TT>CustomListModel</TT> class. The class does not
contain a data structure, such as an array or vector, for the
elements in the list. This is a key concept of the JFC architecture.
The model need not contain all the data contained in the model
at any given time. It only needs to be capable of returning any
element in the model when it's requested. For example, a JFC model
can be used as the front end to a database. The database can contain
thousands of records, but the JFC model does not need to load
the entire table locally when it is created. Indeed, if a record
is not requested, the model never needs to retrieve that record.
The model can retrieve the records on demand.
<P>
In other circumstances, it may make more sense to preload all
the data into the model so it's immediately available for display.
The architecture of the JFC is flexible enough that the model
developer can decide what is best for the current model being
implemented.<P>
<HR>
<P>
<B>Listing 10.7&nbsp;&nbsp;The </B><TT><B>CUSTOMLISTMODEL</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.list;

import java.awt.event.*;

import javax.swing.*;
import javax.swing.event.*;


/**
 * CustomListModel is a list data model that grows
 * and shrinks over time. The data elements are calculated
 * 'on demand'.
 *
 * @author Mike Foley
 **/
public class CustomListModel extends AbstractListModel 
    implements ActionListener { 
    
    /**
     * The current size of the data model.
     **/
    private int size = 0;

    /**
     * The maximum size that the data model will grow to.
     **/
    private int maxSize = 25;

    /**
     * True if we are growing, false if we are shrinking.
     **/
    private boolean growing;
    
    /**
     * The timer interval. This determines how
     * often the data in the model changes.
     **/
    private static final int UPDATE_TIME = 500;
    
    
    /**
     * CustomListModel, constructor
     * &lt;p&gt;
     * Initialize the model to a size of 0, and growing.
     * Create a timer and start it.
     **/
    public CustomListModel() { 
        size = 0;
        growing = true;    
        
        //
        // Create a Timer that will call
        // our actionPerformed method event
        // UPDATE_TIME milliseconds.
        //
        Timer timer = new Timer( UPDATE_TIME, this );        
        timer.start();
    } 
    
    
    /** 
     * getSize, from ListModel.
     * &lt;p&gt;
     * @return The length of the list.
     **/
    public int getSize() { 
        return( size );
    } 


    /**
     * getElementAt, from ListModel.
     * &lt;p&gt;
     * @return The value at the specified index.  
     * @param index The index of the requested element.
     **/
    public Object getElementAt( int index ) { 
        return( &quot;Model Element: &quot; + index );
    } 
    
    
    /**
     * actionPerformed, from ActionListener.
     * &lt;p&gt;
     * Our timer has expired. If we are growing, increment
     * the size of the model by one. If we have hit the maximum
     * size for the model, change the direction so the next time
     * we are called, we will decrement. Fire an interval added
     * event to notify listeners that a new element is in the model.
     * &lt;p&gt;
     * If we are decrementing, reduce the model size and fire an
     * interval removed event. If the size gets to zero, change the
     * direction so we grow the next time this method is called.
     * &lt;p&gt;
     * @param event The event causing this method to be called.
     **/
    public void actionPerformed( ActionEvent event ) { 
        
        if( growing ) { 
            //
            // We are getting bigger.
            //
            int origSize = getSize();
            size += 1;
            if( maxSize - 1 &lt;= size ) { 
                growing = false;
            } 
            fireIntervalAdded( this, origSize, origSize );
            
        }  else { 
            //
            // We are getting smaller.
            //
            size -= 1;
            if( size &lt; 1 ) { 
                growing = true;
            } 
            fireIntervalRemoved( this, size, size );
            
        } 
        
    }  // actionPerformed
    
}  // CustomListModel
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Listing 10.8 is a test application that works out the <TT>CustomListModel</TT>
class. It creates a frame and places a list as the only component
in the frame. An instance of the <TT>CustomListModel</TT> class
is set as the data model for the list. The running application
is shown in Figure 10.3.
<P>
<A HREF="javascript:popUp('f10-3.gif')"><B>Figure 10.3 :</B> <I>The CustomListMode test application</I>.</A>
<P>
<HR>
<P>
<B>Listing 10.8&nbsp;&nbsp;The </B><TT><B>CUSTOMLISTMODELTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import javax.swing.*;

import com.foley.list.CustomListModel;

import com.foley.utility.ApplicationFrame;

/**
 * An application that displays a JList that
 * uses an instance of the CustomListModel data
 * model.
 *
 * @author Mike Foley
 **/
public class CustomListModelTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the list and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;CustomListModel Test&quot; );
        
        CustomListModel model = new CustomListModel();
        JList list = new JList( model );
        list.setPrototypeCellValue( &quot;Model Element: 00000&quot; );
        
        JScrollPane scrollPane = new JScrollPane( list );
        scrollPane.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( scrollPane );
        
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // CustomListModelTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>CustomListModelTest</TT> application calls the <TT>setPrototypeCellValue</TT>
method contained in the <TT>JList</TT> class. An optimization
in the <TT>JList</TT> class enables the size of the list cells
to be specified once and not dynamically determined for each cell.
When the <TT>setPrototypeCellValue</TT> method is called, the
list configures its renderer with the value passed to the method.
The preferred size of the rendering component is used to set the
fixed cell width and height. The fixed cell width and height can
also be set directly with the <TT>setFixedCellWidth</TT> and <TT>setFixedCellHeight</TT>
methods. Each of these methods has an associated <TT>get</TT>
method and is a bound property of the <TT>JList</TT> class. A
complete list of bound properties added by the <TT>JList</TT>
class is presented in Table 10.2. The bound properties inherited
from <TT>JComponent</TT> and beyond are still fired by <TT>JList</TT>
instances, of course.<BR>
<P>
<CENTER><B>Table 10.2&nbsp;&nbsp;Non-Inherited Bound Properties
of the </B><TT><B>JLIST</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property Name</TD><TD WIDTH=197><CENTER><B>Setter Method
</TD><TD WIDTH=197><CENTER><B>Getter Method</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>prototypeCellValue</TT></TD><TD WIDTH=197><TT>setPrototypeCellValue</TT>
</TD><TD WIDTH=197><TT>getPrototypeCellValue</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>fixedCellWidth</TT></TD><TD WIDTH=197><TT>setFixedCellWidth</TT>
</TD><TD WIDTH=197><TT>getFixedCellWidth</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>fixedCellHeight</TT></TD><TD WIDTH=197><TT>setFixedCellHeight</TT>
</TD><TD WIDTH=197><TT>getFixedCellHeight</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>cellRenderer</TT></TD><TD WIDTH=197><TT>setCellRenderer</TT>
</TD><TD WIDTH=197><TT>getCellRenderer</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>selectionForeground</TT></TD><TD WIDTH=197><TT>setSelectionForeground</TT>
</TD><TD WIDTH=197><TT>getSelectionForeground</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>selectionBackground</TT></TD><TD WIDTH=197><TT>setSelectionBackground</TT>
</TD><TD WIDTH=197><TT>getSelectionBackground</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>visibleRowCount</TT></TD><TD WIDTH=197><TT>getVisibleRowCount</TT>
</TD><TD WIDTH=197><TT>setVisibleRowCount</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>model</TT></TD><TD WIDTH=197><TT>setModel</TT>
</TD><TD WIDTH=197><TT>getModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>selectionModel</TT></TD><TD WIDTH=197><TT>setSelectionModel</TT>
</TD><TD WIDTH=197><TT>getSelectionModel</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>setPrototypeCellValue</TT> method is a nice optimization
contained in the <TT>JList</TT> class. However, it requires a
great deal of information about the data model before it can choose
the correct prototype value. A typical prototype value is the
largest value in the model. This will ensure that every element
in the list has adequate space when displayed. This information
is typically not available to the list or to the client configuring
the list. However, it would be reasonable for the model to know
this information. A nice addition to the <TT>ListModel</TT> interface
would be a <TT>getPrototypeCellValue</TT> method. This would allow
the list to be configured to the correct size without guessing
what that size is.
<H3><A NAME="TheSelectionModel">
The Selection Model</A></H3>
<P>
As shown earlier in this chapter, a list supports multiple modes
for selecting items in it. However, the selection isn't managed
by the list itself. Just as the data is contained in a separate
data model, a separate selection model manages selection. The
responsibilities of a list section model are defined by the <TT>ListSelectionModel</TT>
interface. A class that implements this interface is used to manage
selection in the list. The JFC contains the concrete class <TT>DefaultListSelectionModel</TT>,
which can be used in a list. In fact, the methods for setting
the selection mode and altering the selection set for the list,
presented earlier in the chapter, are simple wrapper methods that
forward the request to the current selection model.
<P>
Implementing the <TT>ListSelectionModel</TT> interface is far
less common than implementing the <TT>ListModel</TT> interface.
In most cases, the <TT>DefaultListSelectionModel</TT> can be used.
However, there are still situations where you want to obtain a
handle on a list selection model, such as to allow multiple lists
to share a single <TT>ListSelectionModel</TT>. This way, when
the selection changes in one list, it will also change in the
lists that share the common model.
<P>
Listing 10.9 contains a simple application to present the idea
of a common <TT>ListSelectionModel</TT>. The <TT>ListSelectionModelTest</TT>
application creates two lists that share a single <TT>ListSelectionModel</TT>.
When an element in either list is selected or deselected, the
corresponding element in the other list is also selected or deselected
(Figure 10.4).
<P>
<A HREF="javascript:popUp('f10-4.gif')"><B>Figure 10.4 :</B> <I>The ListSelection ModelTest application</I>.</A>
<P>
<HR>
<P>
<B>Listing 10.9&nbsp;&nbsp;The </B><TT><B>LISTSELECTIONMODELTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a few JList instances
 * that share the same ListSelectionModel.
 *
 * @author Mike Foley
 **/
public class ListSelectionModelTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the lists and display it.
     * Set the selection model in each list to be the
     * same.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        String[] firstNames = {  &quot;Mike&quot;, &quot;Mari&quot;, &quot;Molly&quot;, 
                                &quot;Betsy&quot;, &quot;Bobby&quot; } ;
        String[] lastNames = {  &quot;Jones&quot;, &quot;Smith&quot;, &quot;Johnson&quot;, 
                               &quot;White&quot;, &quot;Connor&quot; } ;

        JFrame frame = new ApplicationFrame( &quot;ListSelectionModel Test&quot; );
        
        JList list1 = new JList( firstNames );
        JList list2 = new JList( lastNames );
        
        list1.setPrototypeCellValue( &quot;Long First Name&quot; );
        list2.setPrototypeCellValue( &quot;Long Last Name&quot; );

        ListSelectionModel selectionModel = list1.getSelectionModel();
        list2.setSelectionModel( selectionModel );
        
        JScrollPane scrollPane1 = new JScrollPane( list1 );
        JScrollPane scrollPane2 = new JScrollPane( list2 );
        
        scrollPane1.setBorder(BorderFactory.createLoweredBevelBorder());
        scrollPane2.setBorder(BorderFactory.createLoweredBevelBorder());

        frame.getContentPane().add( scrollPane1, BorderLayout.WEST );
        frame.getContentPane().add( scrollPane2, BorderLayout.EAST );
        
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // ListSelectionModelTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ListSelectionModelTest</TT> application works very nicely
because each <TT>ListModel</TT> contains the same number of elements.
If the list models contain a different number of elements, a valid
selection in one list may not be valid in the other. This can
be demonstrated by changing the <TT>lastNames</TT> array to contain
only three members, as in the following line of code:
<P>
<TT>String[] lastNames = {  &quot;Jones&quot;,
&quot;Smith&quot;, &quot;Johnson&quot; } ;</TT>
<P>
The new <TT>ListSelectionModelTest</TT> application is shown in
Figure 10.5.
<P>
Figure 10.5 shows that if the <TT>JList</TT> instance receives
a selection event that is outside the number of elements in the
list, it ignores that selected item. This enables views to share
a single list model even if the data models are not the same size.
It should be mentioned that classes other than <TT>JList</TT>
that use a <TT>ListSelectionModel</TT> to manage selections may
behave differently.
<P>
<A HREF="javascript:popUp('f10-5.gif')"><B>Figure 10.5 :</B> <I>The ListSelection ModelTest application
with non-symmetric lists</I>.</A>
<H4><TT>ListSelectionListener</TT> and <TT>ListSelectionEvent</TT>
</H4>
<P>
To monitor changes in a class that implements the <TT>ListSelectionModel</TT>
interface, the <TT>ListSelectionListener</TT> interface must be
implemented. This interface and the <TT>ListSelectionEvent</TT>
class are shown in Listing 10.10. When the list selection model
changes, the <TT>valueChanged</TT> method of the listener is called.
The parameter to this method is an instance of the <TT>ListSelectionEvent</TT>
class. This event delivers the range of where a selection change
has occurred in the selection model. However, the event does not
tell the listener which elements have changed. It is the responsibility
of the listener to query the model to determine the new selection
state of each element in the range contained in the <TT>ListSelectionEvent</TT>.
<P>
The other piece of information contained in a <TT>ListSelectionEvent</TT>
is the <TT>valueIsAdjusting</TT> flag. When this is <TT>true</TT>,
it tells the listener that there are many events being delivered
in rapid succession. If the listener is a graphical component,
it may choose not to repaint itself until this flag is <TT>false</TT>.
At that time, the rapid series of events will have ended.<P>
<HR>
<P>
<B>Listing 10.10&nbsp;&nbsp;The </B><TT><B>LISTSELECTIONLISTENER</B></TT><B>
Interface and </B><TT><B>LISTSELECTIONEVENT</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ListSelectionListener extends EventListener
{
  /** 
   * Called whenever the value of the selection changes.
   * @param e the event that characterizes the change.
   */
  void valueChanged(ListSelectionEvent e);
} 

public class ListSelectionEvent extends EventObject
{ 
    private int firstIndex;
    private int lastIndex;
    private boolean isAdjusting;

    /** 
     * Represents a change in selection status between firstIndex
     * and lastIndex inclusive (firstIndex is less than or equal to 
     * lastIndex).  At least one of the rows within the range will
     * have changed, a good ListSelectionModel implementation will
     * keep the range as small as possible.
     * 
     * @param firstIndex The first index that changed.
     * @param lastIndex The last index that changed, 
     *                  lastIndex &gt;= firstIndex.
     * @param isAdjusting An indication that this is one of 
     *                    a rapid series of events
     */
    public ListSelectionEvent(Object source, int firstIndex, 
                              int lastIndex, boolean isAdjusting)
{ 
    super(source);
    this.firstIndex = firstIndex;
    this.lastIndex = lastIndex;
    this.isAdjusting = isAdjusting;
    } 

    /**
     * @return The first row whose selection value may have changed.
     */
    public int getFirstIndex() {  return firstIndex; } 

    /**
     * @return The last row whose selection value may have changed.
     */
    public int getLastIndex() {  return lastIndex; } 

    /**
     * @return True if this is one of a rapid series of events
     */
    public boolean getValueIsAdjusting() {  return isAdjusting; } 

}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TTFONTSIZEJListFONTTTFONTSIZEClassandModelInteractionsFONT">
<TT>JList</TT> Class and
Model Interactions</A></H3>
<P>
In the previous sections, you saw the models that the <TT>JList</TT>
view interacts with. The view-to-model interaction is depicted
in Figure 10.6. Arrow 1 is the view initializing from the <TT>ListModel</TT>.
The view adds a listener to the data model so that it will be
notified if the model changes. When the user interacts with the
view, the selection is changed in the <TT>ListSelectionModel</TT>.
This is shown by arrow 2. The view also listens to the model for
selection changes. This allows the selection to be made programmatically
and the view to be updated. If the data in the model changes,
a change event will be sent to the view, as shown by arrow 3.
<P>
<A HREF="javascript:popUp('f10-6.gif')"><B>Figure 10.6 :</B> <I>JList view and model interaction</I>.</A>
<H2><A NAME="ComboBoxes">
Combo Boxes</A></H2>
<P>
A combo box is a visual component similar to a list. It allows
a single element in a list to be selected. The selected element
is shown in the combo box, as well as a control to expand the
combo box into a list. An unexpanded combo box requires less screen
real estate than a list. However, the box must be expanded to
show the possible choices in the combo box.
<H3><A NAME="ClassicComboBox">
Classic Combo Box</A></H3>
<P>
The <TT>JComboBox</TT> class is the JFC visual component that
represents a combo box control. Programming with the <TT>JComboBox</TT>
class is similar to the <TT>JList</TT> class, presented in the
previous section. It contains convenience functions for creating
a combo box and setting the data displayed using an array or vector.
An example of creating a simple combo box is shown in Listing
10.11, and the resulting component is shown in Figure 10.7.<P>
<HR>
<P>
<B>Listing 10.11&nbsp;&nbsp;The </B><TT><B>COMBOBOXTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays JComboBox instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class ComboBoxTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the combo box and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        String[] data = { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Grape&quot;, &quot;Banana&quot;,
                        &quot;Mango&quot;, &quot;Pineapple&quot;, &quot;Peach&quot;, &quot;Pear&quot; } ;
        
        JFrame frame = new ApplicationFrame( &quot;Combobox Test&quot; );
        
        JComboBox combobox = new JComboBox( data );
        combobox.setBorder( BorderFactory.createLoweredBevelBorder() ); 
        frame.getContentPane().add( combobox, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ComboBoxTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first combo box, shown in Figure 10.7, depicts when the control
is first displayed. The first item from the data array is selected
in the combo box. The second combo box appears after the user
clicks on the down-arrow to display the possible choices that
can be selected. The third combo box shows that an item has been
selected.
<P>
<A HREF="javascript:popUp('f10-7.gif')"><B>Figure 10.7 :</B> <I>JComboBox in use: The first item is selected
(top), the user clicks the down-arrow to display choices (middle),
and the new item is selected (bottom)</I>.</A>
<P>
You may not want to have an element selected when the combo box
is initially displayed. This can be accomplished by passing the
<TT>setSelectedIndex</TT> method a parameter of -1.
<P>
The window containing the list of items can be shown or hidden
programmatically. The methods <TT>hidePopup</TT> and <TT>showPopup</TT>
are provided for this purpose. The current visibility of the popup
can be determined with the <TT>isPopupVisible</TT> method. The
maximum number of rows displayed in the popup window can be controlled
using the <TT>setMaximumRowCount</TT> method. The current value
of this property can be queried with the <TT>getMaximumRowCount</TT>
method. The <TT>maximumRowCount</TT> property is a bound property
of the <TT>JComboBox</TT> class. The list of bound properties
introduced by the <TT>JComboBox</TT> class is presented in Table
10.3.
<P>
The pop-up can be specified as a lightweight or heavyweight component
by calling the <TT>setLightWeightPopupEnabled</TT> method. Passing
this method <TT>true</TT> enables lightweight popups. Passing
it <TT>false</TT> enables peer-based popup components. The default
value of this property is <TT>true</TT>, enabling lightweight
popups to be used when they will fit in the current window. This
is important because if your application mixes lightweight and
heavyweight components and a lightweight popup is used, it will
be displayed under any heavyweight components in that area. If
this is the case, lightweight popups have to be disabled. The
<TT>isLightWeightPopupEnabled</TT> method queries the current
state of this property. This is not a bound property of the <TT>JComboBox</TT>
class.<BR>
<P>
<CENTER><B>Table 10.3&nbsp;&nbsp;Non-Inherited Bound Properties
of the </B><TT><B>JCOMBOBOX</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=197><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>model</TT></TD><TD WIDTH=197><TT>setModel</TT>
</TD><TD WIDTH=197><TT>getModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>editable</TT></TD><TD WIDTH=197><TT>setEditable</TT>
</TD><TD WIDTH=197><TT>getEditable</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>maximumRowCount</TT></TD><TD WIDTH=197><TT>setMaximumRowCount</TT>
</TD><TD WIDTH=197><TT>getMaximumRowCount</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>renderer</TT></TD><TD WIDTH=197><TT>setRenderer</TT>
</TD><TD WIDTH=197><TT>getRenderer</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>editor</TT></TD><TD WIDTH=197><TT>setEditor</TT>
</TD><TD WIDTH=197><TT>getEditor</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>enabled</TT></TD><TD WIDTH=197><TT>setEnabled</TT>
</TD><TD WIDTH=197><TT>getEnabled</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
The renderer used by the <TT>JComboBox</TT> class is an instance
of the <TT>ListCellRenderer</TT> class. This class was described
at the beginning of this chapter. The <TT>editor</TT> property
is discussed later in this chapter.
<P>
The selected item and its index can be queried with the <TT>getSelectedItem</TT>
and <TT>getSelectedIndex</TT> methods, respectively. The <TT>getSelectedObjects</TT>
method returns the selected item in an array of length <TT>1</TT>,
or an empty array if there is no item selected. The selected item
can be set programmatically using either the <TT>setSelectedItem</TT>
or <TT>setSelectedIndex</TT> method. The <TT>getItemCount</TT>
method returns the number of items in the combo box. The <TT>getItemAt</TT>
method returns the item at the specified index. What happens when
an index that is out of range is passed to the <TT>getItemAt</TT>
method is unspecified. It is reasonable to expect some type of
<TT>RuntimeException</TT> to be thrown. The <TT>DefaultListModel</TT>
class throws an <TT>ArrayIndexOutOfBoundsException</TT> exception
in this case.
<H3><A NAME="TheTTFONTSIZEComboBoxModelFONTTT">
The <TT>ComboBoxModel</TT></A></H3>
<P>
The data model employed by the <TT>JComboBox</TT> class is an
instance of the <TT>ComboBoxModel</TT>. This interface extends
the <TT>ListModel</TT> interface. This means that the methods
described in the previous section for the <TT>ListModel</TT> class
hold for the <TT>ComboBoxModel</TT> class as well. It also means
that the same class of listener, <TT>ListDataListener</TT>, can
be used for both models. The <TT>ComboBoxModel</TT> adds methods
that support a selected item in the list. The selected item is
the item shown at the top of the combo box and when the combo
box is not expanded. The <TT>ComboBoxModel</TT> interface is shown
here:
<BLOCKQUOTE>
<PRE>
public interface ComboBoxModel extends ListModel { 
  /** 
   * Set the selected item
   **/
  void setSelectedItem(Object anItem);

  /**
   * Return the selected item 
   **/
  Object getSelectedItem();
} 
</PRE>
</BLOCKQUOTE>
<P>
The first thing you may notice about the <TT>ComboBoxModel</TT>
interface is the inconsistencies with the <TT>ListModel</TT>.
The <TT>ComboBoxModel</TT> and the <TT>JComboBox</TT> class call
members of the control &quot;items,&quot; while the <TT>ListModel</TT>
and the <TT>JList</TT> class call the members &quot;elements.&quot;
This type of inconsistency makes working with these two controls
more difficult than it needs be.
<P>
For example, a reference to a <TT>JComboBox</TT> instance calls
the <TT>getItemAt</TT> method to query a member of the combo box,
while a reference to the <TT>ComboBoxModel</TT> calls the <TT>getElementAt</TT>
method to query the exact same member. The following code fragment
demonstrates this inconsistency. If the <TT>ComboBoxTest</TT>
program adds the following line after the creation of the <TT>JComboBox</TT>
instance, both of the <TT>println</TT> statements print Banana.
This is shown in Figure 10.8.
<BLOCKQUOTE>
<PRE>
JComboBox combobox = new JComboBox( data );
ComboBoxModel comboBoxModel = combobox.getModel();       
Object item3 = combobox.getItemAt( 3 );
Object element3 = comboBoxModel.getElementAt( 3 );
System.out.println( &quot;item: &quot; + item3 );
System.out.println( &quot;element: &quot; + element3 );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f10-8.gif')"><B>Figure 10.8 :</B><I> Output from a modified ComboBoxTest application</I>.</A>
<P>
The less obvious question to ask about the <TT>ComboBoxModel</TT>
is: Why is it needed? The only feature added by the <TT>ComboBoxModel</TT>
is management of a selected item. However, in the previous section
you saw the elegant solution of selection state management being
delegated to the <TT>ListSelectionModel</TT> by the <TT>JList</TT>
class. The <TT>JComboBox</TT> class could have used the exact
same solution.
<P>
If the name inconsistencies were resolved and the list selection
model, in single selection mode, or better still a <TT>SingleSelectionModel</TT>
instance, was used by both the <TT>JList</TT> and <TT>JComboBox</TT>
classes, there would be no difference to the programmer in basic
functionality between one control and the other. Sharing models
between different views is a powerful aspect of the MVC architecture.
Unfortunately, the JFC missed the mark with these two particular
controls.
<H3><A NAME="TTFONTSIZEJComboBoxFONTTTFONTSIZEClassandModelInteractionFONT">
<TT>JComboBox</TT> Class
and Model Interaction</A></H3>
<P>
The default model used by instances of the <TT>JComboBox</TT>
class is the <TT>DefaultComboBoxModel</TT> class. It extends the
<TT>AbstractListModel</TT> class presented earlier in this chapter.
When the selected item is changed, it fires a <TT>ContentsChanged</TT>
event with both the start and end indexes set to -1. This obviously
breaks the semantics of the <TT>contentsChanged</TT> method contained
in the <TT>ListDataListener</TT> interface. For better or worse,
this is what is done by the <TT>DefaultComboBoxModel</TT> class.
<P>
The <TT>DefaultComboBoxModel</TT> class implements the <TT>MutableComboBoxModel</TT>
interface, shown in Listing 10.12. This interface is an extension
of the <TT>ComboBoxModel</TT> interface that adds methods to edit
the elements in the combo box. The <TT>addElement</TT> method
appends the given object to the model. The <TT>insertElementAt</TT>
method allows an object to be placed at the given offset into
the model. The <TT>removeElement</TT> method removes the given
element from the model, and the <TT>removeElementAt</TT> method
removes the object at the specified index from the model.<P>
<HR>
<P>
<B>Listing 10.12&nbsp;&nbsp;The </B><TT><B>MUTABLECOMBOBOXMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface MutableComboBoxModel extends ComboBoxModel { 
    /**
     * Adds an item to the end of the model.
     */
    public void addElement( Object obj );

    /**
     * Adds an item to the end of the model.
     */
    public void removeElement( Object obj );

    /**
     * Adds an item at a specific index
     */
    public void insertElementAt( Object obj, int index );

    /**
     * Removes an item at a specific index
     */
    public void removeElementAt( int index );
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>MutableComboBoxModel </TT>interface was a late, and very welcome, addition to the JFC. However, where is the <TT>MutableListModel </TT>interface? An interface that defines methods for changing a list model would allow changes to be made to the model using the API defined in the interface, rather than assuming an implementation for the <TT>ListModel </TT>interface.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>JComboBox</TT> class listens to the <TT>ComboBoxModel</TT>
currently in use. When the selected item changes in the model,
the combo box sends an <TT>ActionEvent</TT> to any <TT>ActionListeners</TT>
of the instance. This allows clients of the <TT>JComboBox</TT>
class to listen for action events from the combo box rather than
selection change events from the model.
<P>
However, caution must be taken here. If a <TT>ComboBoxModel</TT>
other than the default model is used, the <TT>ActionEvent</TT>
notification may break because the <TT>ComboBoxModel</TT> does
not define an event for the selected item being changed. As mentioned
in the previous paragraph, the <TT>DefaultComboBoxModel</TT> class
overloads the semantics of the <TT>ContentsChanged</TT> event.
However, different implementations of the <TT>ComboBoxModel</TT>
interface may not behave the same way. If the <TT>JComboBox</TT>
class does not receive the magic <TT>ContentsChanged</TT> event,
the <TT>ActionEvent</TT> will not be fired from the <TT>JComboBox</TT>
instance. This would not be a problem if the models clearly defined
the event that should be fired when the selected item changes.
This is another argument for using a <TT>ListSelectionModel</TT>,
or the restricted single selection variant <TT>SingleSelectionModel</TT>,
for combo boxes.
<P>
The command string sent in an <TT>ActionEvent</TT> can be set
and queried with the <TT>setActionCommand</TT> and <TT>getActionCommand</TT>
methods. For some unknown reason, <TT>actionCommand</TT> is not
a bound property in the <TT>JComboBox</TT> class.
<H3><A NAME="EditableComboBox">
Editable Combo Box</A></H3>
<P>
A combo box can be configured so the user can type an entry into
the top portion of the control. This allows the user to enter
his choice without selecting from the list. By default, a combo
box is not editable. It can be made so by passing <TT>true</TT>
to the <TT>setEditable</TT> method. The <TT>isEditable</TT> method
returns the current state of the <TT>editable</TT> property. Similarly
to how the painting of items in the combo box is delegated to
a renderer, editing is delegated to an editor. The editor's responsibilities
are defined in the <TT>ComboBoxEditor</TT> interface, shown in
Listing 10.13.<P>
<HR>
<P>
<B>Listing 10.13&nbsp;&nbsp;The </B><TT><B>COMBOBOXEDITOR</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface ComboBoxEditor { 
  
  /** 
   * Return the component that should be added to the tree hierarchy for
   * this editor
   **/
  public Component getEditorComponent();
  
  /** 
   * Set the item that should be edited. Cancel any editing if necessary
   **/
  public void setItem(Object anObject);

  /** 
   * Return the edited item 
   **/
  public Object getItem();

  /** 
   * Ask the editor to start editing and to select everything 
   **/
  public void selectAll();    

  /** 
   * Add an ActionListener. An action event is generated when
   * the edited item changes 
   **/
  public void addActionListener(ActionListener l);

  /**
   * Remove an ActionListener 
   **/
  public void removeActionListener(ActionListener l);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Querying the selected item for an editable combo box is slightly
more complex than it is for a non-editable combo box. The methods
typically used, <TT>getSelectedItem</TT> and <TT>getSelectedIndex</TT>,
are the same. However, the user may type any value into the combo
box editor, including elements that are not in the list of choices
in the <TT>ComboBoxModel</TT>. In this case, the <TT>getSelectedIndex</TT>
method returns <TT>-1</TT>. The <TT>getSelectedItem</TT> method
returns exactly what the user entered into the editor, whether
this string is in the model or not. This behavior is demonstrated
in the <TT>EditableComboBox</TT> application, shown in Listing
10.14.<P>
<HR>
<P>
<B>Listing 10.14&nbsp;&nbsp;The </B><TT><B>EDITABLECOMBOBOXTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays an editable JComboBox instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class EditableComboBoxTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the combo box and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        String[] data = { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Grape&quot;, &quot;Banana&quot;,
                        &quot;Mango&quot;, &quot;Pineapple&quot;, &quot;Peach&quot;, &quot;Pear&quot; } ;
        
        JFrame frame = new ApplicationFrame( &quot;Editable Combobox Test&quot; );
        
        final JComboBox combobox = new JComboBox( data );
        combobox.setEditable( true );
        combobox.setSelectedIndex( -1 );

        combobox.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                System.out.println( combobox.getSelectedIndex() + 
                                    &quot; &quot; + combobox.getSelectedItem() );
}
        }  );
        combobox.setBorder( BorderFactory.createLoweredBevelBorder() );
        frame.getContentPane().add( combobox, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // EditableComboBoxTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, a <TT>JComboBox</TT> instance is created. The
<TT>setEditable</TT> method is called to enable editing. The <TT>setSelectedIndex</TT>
method is passed the value of <TT>-1</TT> to clear the selection
in the combo box. This way, there is no value in the combo box
when it is first displayed. An <TT>ActionListener</TT> is added
to the combo box to receive notification when the selected item
in the combo box changes. When a notification is received, the
selected item and its index are printed to the console. The application
is shown in Figure 10.9.
<P>
<A HREF="javascript:popUp('f10-9.gif')"><B>Figure 10.9 :</B> <I>The EditableComboBox Test application:
Before a selection is made (top), after an item has been selected
(middle), and after editing (bottom)</I>.</A>
<P>
The first panel of Figure 10.9 shows the combo box from the <TT>EditableComboBoxTest</TT>
application before a selection has been made. The editor paints
differently than the non-editable combo box shown in Figure 10.7.
This gives the user visual feedback that the combo box is in fact
editable. The second panel shows the combo box after the item
labeled Grape has been selected. The output from the application
is shown in Figure 10.10. The first line is the result from <TT>ActionListener</TT>
added to the combo box. The item is Grape and its index is 2.
The final slide shows the combo box after editing to contain the
string Bean. Figure 10.10 shows the result from <TT>ActionListener</TT>.
This time, the item is not contained in the <TT>ComboBoxModel</TT>,
so its index returned from the <TT>getSelectedIndex</TT> method
is <TT>-1</TT>. The <TT>ActionEvent</TT> is fired when the user
presses the Enter key after changing the text, or when the editor
loses the input focus.
<P>
<A HREF="javascript:popUp('f10-10.gif')"><B>Figure10.10:</B> <I>Output from the EditableComboBox Test application</I>.</A>
<H4><TT>KeySelection</TT> Managers</H4>
<P>
The <TT>JComboBox</TT> class defines an inner interface that manages
selection in the combo box with keystrokes. The <TT>KeySelectionManager</TT>
interface shown in Listing 10.15 defines a single method, <TT>selectionForKey</TT>.
This method returns the index of the element selected by the given
character in the given <TT>ComboBoxModel</TT>. It returns <TT>-1</TT>
if the character does not select an element.
<P>
The <TT>JComboBox</TT> class contains the <TT>selectWithKeyChar</TT>
method that calls the key selection manager with the given character
and selects the element at the index returned from the key selection
manager. The <TT>selectWithKeyChar</TT> method returns <TT>true</TT>
if an element was selected, <TT>false</TT> otherwise. A <TT>ComboBoxEditor</TT>
could use this capability to streamline editing in a combo box
by allowing the user to select an element in the model by typing
its first character. The <TT>KeySelectionManager</TT> for a combo
box can be set with the <TT>setKeySelectionManager</TT> method
and queried with the <TT>getKeySelectionManager</TT> method. The
<TT>keySelectionManager</TT> is not a bound property.<P>
<HR>
<P>
<B>Listing 10.15&nbsp;&nbsp;The </B><TT><B>KEYSELECTIONMANAGER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface KeySelectionManager { 
    /** Given &lt;code&gt;aKey&lt;/code&gt; and the model, returns the row
     *  that should become selected. Return -1 if no match was
     *  found. 
     *
     * @param  aKey  a char value, usually indicating a keyboard key that
     *               was pressed
     * @param aModel a ComboBoxModel - the component's data model,
     *               containing the list of selectable items 
     * @return an int equal to the selected row, where 0 is the
     *         first item and -1 is none. 
     */
    int selectionForKey(char aKey,ComboBoxModel aModel);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="BoundedComponents">
Bounded Components</A></H2>
<P>
The JFC contains a few components that display information that
falls within a numerical range. These components use the <TT>BoundedRangeModel</TT>
to manage the range and the current value. Examples of range components
in the JFC are scrollbars, sliders, and progress bars. These components
and the <TT>BoundedRangeModel</TT> are discussed in this section.
<H3><A NAME="TheTTFONTSIZEBoundedRangeModelFONTTTFONTSIZEInterfaceFONT">
The <TT>BoundedRangeModel</TT>
Interface</A></H3>
<P>
The <TT>BoundedRangeModel</TT> interface specifies the methods
required for the JFC bounded range model. This type of model specifies
a constrained integer range with a minimum, maximum, and current
value. A listener to the model is defined as a <TT>ChangeListener</TT>.
The <TT>ChangeListener</TT> is notified when any of the properties
of the model change. The <TT>BoundedRangeModel</TT> contains the
<TT>valueIsAdjusting</TT> flag, which allows listeners of the
model to optimize their behavior. This flag is set to <TT>true</TT>
when many changes are going to occur quickly in the model, and
set to <TT>false</TT> when the changes are complete. A typical
example of this behavior is when the user drags a scrollbar.
<P>
The <TT>BoundedRangeModel</TT> defines the <TT>extent</TT> property.
For a view such as a scrollbar, the <TT>extent</TT> represents
the portion of the model that is currently viewed. The <TT>extent</TT>
must be non-negative and the current value in the model, and it
cannot be greater that the model's maximum value.
<P>
The <TT>setRangeProperties</TT> method is defined to allow all
the properties defined by the <TT>BoundedRangeModel</TT> to be
set with a single method call.
<P>
Classes that implement the <TT>BoundedRangeModel</TT> interface
should guarantee the following relationship between the model
properties:
<P>
<TT>minimum &lt;= value &lt;= value + extent
&lt;= maximum</TT>
<P>
Listing 10.16 shows the complete <TT>BoundedRangeModel</TT> interface.
<P>
<HR>
<P>
<B>Listing 10.16&nbsp;&nbsp;The </B><TT><B>BOUNDEDRANGEMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface BoundedRangeModel
{ 
    /**
     * Returns the minimum acceptable value.
     *
     * @return the value of the minimum property
     * @see #setMinimum
     */
    int getMinimum();


    /**
     * Sets the model's minimum to &lt;I&gt;newMinimum&lt;/I&gt;.   The 
     * other three properties may be changed as well, to ensure 
     * that:
     * &lt;pre&gt;
     * minimum &lt;= value &lt;= value+extent &lt;= maximum
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Notifies any listeners if the model changes.
     *
     * @param newMinimum the model's new minimum
     * @see #getMinimum
     * @see #addChangeListener
     */
    void setMinimum(int newMinimum);


    /**
     * Returns the model's maximum.  Note that the upper
     * limit on the model's value is (maximum - extent).
     *
     * @return the value of the maximum property.
     * @see #setMaximum
     * @see #setExtent
     */
    int getMaximum();


    /**
     * Sets the model's maximum to &lt;I&gt;newMaximum&lt;/I&gt;. The other 
     * three properties may be changed as well, to ensure that
     * &lt;pre&gt;
     * minimum &lt;= value &lt;= value+extent &lt;= maximum
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Notifies any listeners if the model changes.
     *
     * @param newMaximum the model's new maximum
     * @see #getMaximum
     * @see #addChangeListener
     */
    void setMaximum(int newMaximum);


    /**
     * Returns the model's current value.  Note that the upper
     * limit on the model's value is &lt;code&gt;maximum - extent&lt;/code&gt; 
     * and the lower limit is &lt;code&gt;minimum&lt;/code&gt;.
     *
     * @return  the model's value
     * @see     #setValue
     */
    int getValue();


    /**
     * Sets the model's current value to &lt;code&gt;newValue&lt;/code&gt; 
     * if &lt;code&gt;newValue&lt;/code&gt; satisfies the model's contraints.
     * Those constraints are:
     * &lt;pre&gt;
     * minimum &lt;= value &lt;= value+extent &lt;= maximum
     * &lt;/pre&gt;
     * Otherwise, if &lt;code&gt;newValue&lt;/code&gt; is less than 
     * &lt;code&gt;minimum&lt;/code&gt; it's set to &lt;code&gt;minimum&lt;/code&gt;,
     * if it's greater than &lt;code&gt;maximum&lt;/code&gt;
     * then it's set to &lt;code&gt;maximum&lt;/code&gt;, and 
     * if it's greater than &lt;code&gt;value+extent&lt;/code&gt; then it's set to 
     * &lt;code&gt;value+extent&lt;/code&gt;.
     * &lt;p&gt;
     * When a BoundedRange model is used with a scrollbar the value
     * specifies the origin of the scrollbar knob (aka the &quot;thumb&quot; or
     * &quot;elevator&quot;).  The value usually represents the origin of the 
     * visible part of the object being scrolled.
     * &lt;p&gt;
     * Notifies any listeners if the model changes.
     *
     * @param newValue the model's new value
     * @see #getValue
     */
    void setValue(int newValue);


    /**
     * This attribute indicates that any upcoming changes to the value
     * of the model should be considered a single event. This attribute
     * will be set to true at the start of a series of changes to the 
     * value, and will be set to false when the value has finished 
     * changing.  Normally this allows a listener to only take action 
     * when the final value change is committed, instead of having to do
     * updates for all intermediate values.
     * &lt;p&gt;
     * Sliders and scrollbars use this property when a drag is under way.
     * 
     * @param b true if the upcoming changes to the value property are 
     *          part of a series
     * @see #getValueIsAdjusting
     */
    void setValueIsAdjusting(boolean b);


    /**
     * Returns true if the current changes to the value property are part
     * of a series.
     * 
     * @return the valueIsAdjustingProperty.  
     * @see #setValueIsAdjusting
     */
    boolean getValueIsAdjusting();


    /**
     * Returns the model's extent, the length of the inner range that
     * begins at the model's value.  
     *
     * @return  the value of the model's extent property
     * @see     #setExtent
     * @see     #setValue
     */
    int getExtent();


    /**
     * Sets the model's extent.  The &lt;I&gt;newExtent&lt;/I&gt; is forced to 
     * be greater than or equal to zero and less than or equal to
     * maximum - value.   
     * &lt;p&gt;
     * When a BoundedRange model is used with a scrollbar the extent
     * defines the length of the scrollbar knob (aka the &quot;thumb&quot; or
     * &quot;elevator&quot;).  The extent usually represents how much of the 
     * object being scrolled is visible.  
     * &lt;p&gt;
     * Notifies any listeners if the model changes.
     *
     * @param  newExtent the model's new extent
     * @see #getExtent
     * @see #setValue
     */
    void setExtent(int newExtent);


    /**
     * This method sets all of the model's data with a single method
     * call. The method results in a single change event being generated.
     * This is convenient when you need to adjust all the model data
     * simultaneously and do not want individual change events to occur.
     * 
     * @see #setValue
     * @see #setExtent
     * @see #setMinimum
     * @see #setMaximum
     * @see #setValueIsAdjusting
     */
    void setRangeProperties( int value, int extent, int min, 
                             int max, boolean adjusting );


    /**
     * Adds a ChangeListener to the model's listener list.
     *
     * @param x the ChangeListener to add
     * @see #removeChangeListener
     */
    void addChangeListener(ChangeListener x);


    /**
     * Removes a ChangeListener from the model's listener list.
     *
     * @param x the ChangeListener to remove
     * @see #addChangeListener
     */
    void removeChangeListener(ChangeListener x);

}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ChangeEventandListenerInterface">
Change Event and Listener Interface</A></H3>
<P>
The <TT>ChangeListener</TT> interface defines the responsibilities
of listeners to a <TT>BoundedRangeModel</TT> instance. This interface
is shown below. The listener must implement one method, the <TT>stateChanged</TT>
method. This method is called when any of the properties in the
bounded range model change. The parameter to the <TT>stateChanged</TT>
method is a <TT>ChangeEvent</TT> instance. This event is also
shown below:
<BLOCKQUOTE>
<PRE>
public interface ChangeListener extends EventListener { 
    void stateChanged(ChangeEvent e);
} 
public class ChangeEvent extends EventObject { 
    public ChangeEvent(Object source) { 
        super(source);
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
As you can see from the <TT>ChangeEvent</TT> class, it does not
deliver any information specific to <TT>BoundedRangeModel</TT>.
Thus, the listener must query the source of the event from the
<TT>ChangeEvent</TT> and query the model for its current state.
Example usages of the <TT>ChangeListener</TT> interface and <TT>ChangeEvent</TT>
class are presented in the next section.
<H2><A NAME="TheTTFONTSIZEJSliderFONTTTFONTSIZEControlFONT">
The <TT>JSlider</TT> Control
</A></H2>
<P>
The <TT>JSlider</TT> class implements a control that allows the
user to select a value from a bounded range. A pointer is drawn,
which the user can slide to select the desired value. The <TT>JSlider</TT>
class employs a <TT>BoundedRangeModel</TT> to manage its range
and the current value. A <TT>JSlider</TT> instance can be created
and displayed using the <TT>SliderTest</TT> application, shown
in Listing 10.17. The resulting slider is shown in Figure 10.11.
<P>
<A HREF="javascript:popUp('f10-11.gif')"><B>Figure 10.11:</B> <I>The SliderTest application</I>.</A><P>
<HR>
<P>
<B>Listing 10.17&nbsp;&nbsp;The </B><TT><B>SLIDERTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JSlider instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class SliderTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the list and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Slider Test&quot; );
        
        JSlider slider = new JSlider();
        
        slider.setBorder( BorderFactory.createLoweredBevelBorder() );
        frame.getContentPane().add( slider, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // SliderTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Calling the default constructor of the <TT>JSlider</TT> class
creates a slider with a range from 0 to 100 and an initial value
of 50. However, from looking at the slider in Figure 10.11, there
is no way of knowing this. The slider can be configured to display
the range and various tick mark options. The <TT>JSlider</TT>
class also contains wrapper methods for the <TT>BoundedRangeModel</TT>
methods. This allows the model's properties to be set by calling
methods on the slider itself rather than the model, if the developer
is so inclined.
<P>
The <TT>setOrientation</TT> method can be called for the slider
to display vertically or horizontally. This method takes an integer
parameter that must be one of the two orientation constants defined
in the <TT>SwingConstants</TT> interface. These constants are
<TT>HORIZONTAL</TT> and <TT>VERTICAL</TT>. An <TT>IllegalArgumentException</TT>
is thrown if a parameter other than one of these two is passed
to the method. The <TT>JSlider</TT> class implements the <TT>SwingConstants</TT>
interface, so the constant can be specified as <TT>SwingConstants.VERTICAL</TT>
or <TT>JSlider.VERTICAL</TT>.
<P>
The <TT>JSlider</TT> class also contains a constructor that takes
the orientation, minimum, maximum, and initial value for the slider.
<P>
Calling the <TT>setInverted</TT> method with a parameter of <TT>true</TT>
can be called to invert the slider. An inverted horizontal slider
contains its maximum value to the left and its minimum value to
the right, and a vertical slider contains its maximum value on
the top and its minimum value on the bottom. The <TT>getInverted</TT>
method will return the current state of the <TT>inverted</TT>
property, which is a bound property of the <TT>JSlider</TT> class.
The complete list of bound properties added by the <TT>JSlider</TT>
is shown in Table 10.4.<BR>
<P>
<CENTER><B>Table 10.4&nbsp;&nbsp;Non-Inherited Bound Properties
of the </B><TT><B>JSLIDER</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=197><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>model</TT></TD><TD WIDTH=197><TT>setModel</TT>
</TD><TD WIDTH=197><TT>getModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>orientation</TT></TD><TD WIDTH=197><TT>setOrientation</TT>
</TD><TD WIDTH=197><TT>getOrientation</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>labelTable</TT></TD><TD WIDTH=197><TT>setLabelTable</TT>
</TD><TD WIDTH=197><TT>getLabelTable</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>inverted</TT></TD><TD WIDTH=197><TT>setInverted</TT>
</TD><TD WIDTH=197><TT>getInverted</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>majorTickSpacing</TT></TD><TD WIDTH=197><TT>setMajorTickSpacing</TT>
</TD><TD WIDTH=197><TT>getMajorTickSpacing</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>minorTickSpacing</TT></TD><TD WIDTH=197><TT>setMinorTickSpacing</TT>
</TD><TD WIDTH=197><TT>getMinorTickSpacing</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>snapToTicks</TT></TD><TD WIDTH=197><TT>setSnapToTicks</TT>
</TD><TD WIDTH=197><TT>getSnapToTicks</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>paintTicks</TT></TD><TD WIDTH=197><TT>setPaintTicks</TT>
</TD><TD WIDTH=197><TT>getPaintTicks</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197>paintTrack</TD><TD WIDTH=197><TT>setPaintTrack</TT>
</TD><TD WIDTH=197><TT>getPaintTrack</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>paintLabels</TT></TD><TD WIDTH=197><TT>setPaintLabels</TT>
</TD><TD WIDTH=197><TT>getPaintLabels</TT></TD></TR>
</TABLE></CENTER>
<P>
<H4>Controlling Tick Marks</H4>
<P>
The <TT>JSlider</TT> class can be configured to display both major
and minor tick marks. The <TT>setMajorTickSpacing</TT> and <TT>setMinorTickSpacing</TT>
methods specify the tick mark spacing. The parameter is the number
of units between tick marks. The number of tick marks drawn depends
on the range of the slider and the spacing parameter. A major
tick mark is drawn at the minimum value, and at every major tick
mark spacing interval after that until the slider's maximum is
reached. The equation for where tick marks are drawn is as follows:
<BLOCKQUOTE>
<PRE>
TickLocation = minimum + n * spacing
Where n = 0,1, range/spacing
</PRE>
</BLOCKQUOTE>
<P>
The same logic is used for the minor tick marks, except that the
minor tick spacing parameter is used. Also, if both a minor and
major tick mark land on the same value, the major tick mark is
drawn.
<P>
Finally, the <TT>setPaintTicks</TT> method must be called with
a parameter of <TT>true</TT> to have the slider paint the tick
marks. The following code can be used in the <TT>SliderTest</TT>
application to create and configure the slider to contain tick
marks:
<BLOCKQUOTE>
<PRE>
JSlider slider = new JSlider();
slider.setMajorTickSpacing( 20 );
slider.setMinorTickSpacing( 5 );
slider.setPaintTicks( true );
</PRE>
</BLOCKQUOTE>
<P>
The resulting slider is shown in Figure 10.12.
<P>
<A HREF="javascript:popUp('f10-12.gif')"><B>Figure 10.12:</B> <I>A JSlider with tick marks</I>.</A>
<P>
The default range for the slider, 0-100, is still being used.
Thus, with a major tick mark spacing of 20, major ticks appear
at 0, 20, 40, 60, 80, and 100. Similarly, with the minor tick
spacing set to 5, minor ticks are expected at 5, 10, 15, 25, 30,
and so on, up to 95. Notice that minor ticks are not expected
at 0, 20, and so on, where the major ticks are located.
<P>
The slider shown in Figure 10.12 allows the value to fall on any
integer value from 0 to 100. Sometimes you want to allow values
to be selected only where the tick marks are displayed. This can
be achieved by passing <TT>true</TT> to the <TT>setSnapToTicks</TT>
method. Passing <TT>false</TT> to this method allows any value
to be selected again.
<H4>Controlling Labels</H4>
<P>
In the previous section, tick marks were added to the slider to
indicate where a selected value lies in the range of possible
values. However, the range still is not shown on the slider. Labels
can be added to the slider by passing <TT>true</TT> to the <TT>setPaintLabels</TT>
method. If the following line is added to the previous version
of the <TT>SliderTest</TT> application, the slider will look as
shown in Figure 10.13.
<P>
<TT>slider.setPaintLabels( true );</TT>
<P>
<A HREF="javascript:popUp('f10-13.gif')"><B>Figure 10.13:</B> <I>Labels added to a slider</I>.</A>
<P>
Figure 10.13 shows that a label has been added for each major
tick mark. For labels to be drawn, the major tick mark spacing
must be specified. However, the tick marks need not be painted.
The labels in Figure 10.13 could be painted without the tick marks
with the following slider configuration:
<BLOCKQUOTE>
<PRE>
JSlider slider = new JSlider();
slider.setMajorTickSpacing( 20 );
</PRE>
</BLOCKQUOTE>
<P>
<TT>slider.setPaintLabels( true );</TT>
<P>
If the values in the slider are to represent percentages, currency,
or some other type of formatted number, you want the labels on
the slider to show the number's type. This can be achieved in
a couple of different ways. One approach is to subclass the <TT>JSlider</TT>
class and create the properly formatted labels. Another approach
is to set the labels using the <TT>setLabelTable</TT> method.
The approach taken depends on the current requirements.
<P>
For a one-shot formatted slider where the major tick mark spacing
and range are not going to change, setting the label table may
be appropriate. However, for a general-purpose slider where the
major tick spacing and range need to be flexible, extending the
<TT>JSlider</TT> class may be more appropriate. In the next sections
we'll look at each alternative.
<P>
<B>Setting the Label Table</B>
<BLOCKQUOTE>
The label table in the <TT>JSlider</TT> class is an AWT dictionary
that contains a mapping from an integer to a component. The slider
uses the components in the dictionary as the labels for the slider.
There must be a label component for every <TT>Integer</TT> value
associated with each major tick mark.
</BLOCKQUOTE>
<BLOCKQUOTE>
To configure a percent slider with labels that correspond to the
major tick spacings, use the code in Listing 10.18. The resulting
slider is shown in Figure 10.14.
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f10-14.gif')"><B>Figure 10.14:</B> <I>The PercentSlider Test application</I>.</A>
<P>
<HR>
<P>
<B>Listing 10.18&nbsp;&nbsp;The </B><TT><B>PERCENTSLIDERTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.util.Hashtable;
import java.text.NumberFormat;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JSlider instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class PercentSliderTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the list and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Percent Slider Test&quot; );
        NumberFormat percent = NumberFormat.getPercentInstance();
        
        Hashtable table = new Hashtable();
        for( int i = 0; i &lt;= 100; i += 20 ) { 
            JLabel l = new JLabel( 
                       percent.format( ( double )i / 100.0 ) );
            table.put( new Integer( i ), l );
        } 
        JSlider slider = new JSlider();
        slider.setMajorTickSpacing( 20 );
        slider.setMinorTickSpacing( 5 );
        slider.setPaintTicks( true );
        slider.setPaintLabels( true );
        slider.setLabelTable( table );   
        slider.setBorder( BorderFactory.createLoweredBevelBorder() );
        frame.getContentPane().add( slider, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // PercentSliderTest
</PRE>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
In the <TT>PercentSliderTest</TT> application, the label table
is created with the percent number formatter. One <TT>JLabel</TT>
instance is created for each major tick on the slider. This creates
a nice slider, but it is not very versatile. If the major tick
spacing parameter is changed, so must the label table. For formatted
sliders whose range or major tick spacing is subject to change,
extending the <TT>JSlider</TT> class provides a better solution.
</BLOCKQUOTE>
<P>
<B>Extending </B><TT><B>JSlider</B></TT>
<BLOCKQUOTE>
The previous section showed how to configure the label table for
a slider. This was adequate for one-shot configurations. However,
to create a general-purpose formatted text slider, an extension
to the <TT>JSlider</TT> class is called for. Luckily, the <TT>JSlider</TT>
class provides the necessary hooks to make this an easy task.
The <TT>JSlider</TT> class calls the <TT>createStandardLabels</TT>
method to create the labels displayed in the slider. Our extension
can override this method to create the formatted labels.
</BLOCKQUOTE>
<BLOCKQUOTE>
Listing 10.19 shows the <TT>PercentSlider</TT> class, which extends
the <TT>JSlider</TT> class. Its public API is identical to the
<TT>JSlider</TT> class, with the exception of the <TT>setLabelTable</TT>
method. This method is not available in the <TT>PercentSlider</TT>
class. This is because creating the label table for the class
is the primary purpose of the <TT>PercentSlider</TT> class. Allowing
users to set this table could remove the percent signs on the
labels. Another enhancement of the <TT>PercentSlider</TT> is that
the labels are created whenever the major tick spacing changes.
This allows an existing percent slider to be reconfigured. The
current implementation of the <TT>JSlider</TT> class does not
allow this-once the labels are created, they are used for the
duration of the class's lifetime, unless the user explicitly sets
or re-creates the table.<BR>
</BLOCKQUOTE>
<HR>
<P>
<B>Listing 10.19&nbsp;&nbsp;The </B><TT><B>PERCENTSLIDER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.text.NumberFormat;
import java.util.Hashtable;

import javax.swing.*;


/**
 * The PercentSlider class is a slider that formats its
 * labels using the % sign.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class PercentSlider extends JSlider 
{ 
    /**
     * PercentSlider, constructor
     * &lt;p&gt;
     * Configure the slider for normal percent range,
     * 0-100 and a current value of 0. The default major
     * tick spacing is set to 25 and minor tick spacing
     * to 5. Both labels and ticks are painted.
     * &lt;p&gt;
     * These values may be changed by the client using the 
     * public API.
     *
     * @see JSlider
     **/
    public PercentSlider() { 
        setMinimum( 0 );
        setMaximum( 100 );
        setValue( 0 );
        setMajorTickSpacing( 25 );
        setMinorTickSpacing( 5 );
        setPaintTicks( true );
        setPaintLabels( true );
        
    } 
    
    
    /**
     * Create labels for the slider. Format each label
     * to contain a percent sign. A label is created
     * for each value from:
     * &lt;p&gt;
     *     start + x * increment
     * &lt;p&gt;
     * until the maximum value is reached.
     * &lt;p&gt;
     * @param increment The delta between labels.
     * @param start The value of the first label.
     * @return The table of labels for the slider.
     **/
    public Hashtable createStandardLabels( int increment, int start ) { 
        if ( start &gt; getMaximum() || start &lt; getMinimum() ) { 
            throw new IllegalArgumentException( 
                      &quot;Slider label start point out of range.&quot; );
        } 
        
        NumberFormat percent = NumberFormat.getPercentInstance();

        Hashtable table = new Hashtable();

        for ( int i = start; i &lt;= getMaximum(); i += increment ) { 
            JLabel l = new JLabel( 
                       percent.format( ( double )i / 100.0 ) );
            table.put( new Integer( i ), l );
        } 

        return table;
    } 


    /**
     * The label table is created by this class. Do not
     * allow it to be set from the outside.
     * &lt;p&gt;
     * @exception RuntimeException If this method is called.
     **/
    public void setLabelTable() { 
        throw new RuntimeException( 
                  &quot;Cannot set the label table for the PercentSlider&quot; );
    } 
    
    
    /**
     * setMajorTickSpacing
     * &lt;p&gt;
     * This method in the JSlider class does not create
     * labels if the label table has been created once.
     * This may cause the labels to be drawn in areas that
     * do not correspond to the major ticks. This is fixed
     * here by creating the label table whenever a new
     * major tick spacing is specified.
     * &lt;p&gt;
     * @param n The new major tick spacing.
     **/
    public void setMajorTickSpacing( int n ) { 
        if( getMajorTickSpacing() != n )
            setLabelTable( createStandardLabels( n ) );
        super.setMajorTickSpacing( n );
    } 
}  // PercentSlider
</PRE>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
The <TT>PercentSliderTest</TT> application can be modified to
display an instance of the <TT>PercentSlider</TT> class. The following
code can be used instead of the code to create and configure the
<TT>JSlider</TT>. The modified <TT>PercentSliderTest</TT> application
produces a slider that looks identical to the previous version
of the application, shown in Figure 10.14.
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
JSlider percentSlider = new PercentSlider();
percentSlider.setBorder( BorderFactory.createLoweredBevelBorder() );
frame.getContentPane().add( percentSlider, BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<H4>Painting the <TT>JSlider</TT>'s Track</H4>
<P>
For some types of controls, such as a volume control, you don't
want to paint the slider's track. The <TT>paintTrack</TT> property
controls this behavior. Passing the <TT>setPaintTrack</TT> method
<TT>false</TT> will stop the slider from painting the track. As
you have seen from the previous examples in this chapter, the
default value for this property is <TT>true</TT>. The <TT>getPaintTrack</TT>
method can query the current setting of this property. The <TT>paintTrack</TT>
property is bound in the <TT>JSlider</TT> class.
<P>
Adding the following line of code to the <TT>PercentSliderTest</TT>
application, shown in the previous section, will disable the track
from being drawn in the slider:
<P>
<TT>slider.setPaintTrack( false );</TT>
<P>
The resulting slider is shown in Figure 10.15.
<P>
<A HREF="javascript:popUp('f10-15.gif')"><B>Figure 10.15:</B> <I>A trackless slider in the PercentSliderTest
application</I>.</A>
<H4>Displaying the <TT>JSlider</TT>'s Value</H4>
<P>
Up to this point, you have displayed and configured <TT>JSlider</TT>
instances, displayed tick marks, and displayed labels for the
range of the slider. However, you have not been able to display
the current value of the slider. Most of the time, this is useful.
It is very rare that a slider is used to alter a value without
showing the user the current value selected in the slider. Unfortunately,
there is no <TT>setPaintValue</TT> method in the <TT>JSlider</TT>
class. Thus, to show the current value of the slider, you must
do some work.
<P>
The <TT>JSlider</TT> class again could be extended to display
the current value somewhere in its space. However, this is not
the approach you'll take here. Instead, a panel is created that
contains the slider and a label for the current value. The panel
will be a mediator between the slider and label. It will listen
for change events from the slider and update the label when such
events are received.
<P>
The <TT>SliderValuePanel</TT> class is shown in Listing 10.20.
In its constructor, the slider and label are created. The slider
is configured to paint tick marks and labels. A <TT>JLabel</TT>
is created to display the current value in the slider. The class
registers itself as a <TT>ChangeListener</TT> to the slider so
that it's notified when the value in the slider changes. The <TT>stateChanged</TT>
method being called performs this function. This method queries
the current value of the slider and writes that value in the label.
The panel is configured with a <TT>BorderLayout</TT> manager.
The slider is placed in the center region and the label in the
south.<P>
<HR>
<P>
<B>Listing 10.20&nbsp;&nbsp;The </B><TT><B>SLIDERVALUEPANEL</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;

import javax.swing.*;
import javax.swing.event.*;


/**
 * The SliderValuePanel class is a panel that contains a
 * slider and a label to display the current value in the slider.
 * &lt;p&gt;
 * The current implementation requires the user to get the slider
 * to configure it. Wrapper methods for the BoundedRangeModel 
 * method should be provided.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class SliderValuePanel extends JPanel 
    implements ChangeListener { 
        
    /**
     * Components in the panel.
     **/
    private JSlider slider;
    private JLabel label;
    
    /**
     * The String that the current value is appended to.
     **/
    private static final String labelBase = &quot;Current Value: &quot;;
    
    
    /**
     * SliderValuePanel, constructor
     * &lt;p&gt;
     * Create the JSlider instance and JLabel instance
     * and arrange them in the panel.
     **/
    public SliderValuePanel() { 
        super();
        
        setLayout( new BorderLayout() );
        
        slider = new JSlider();
        slider.setMajorTickSpacing( 20 );
        slider.setMinorTickSpacing( 5 );
        slider.setPaintTicks( true );
        slider.setPaintLabels( true );
        
        label = new JLabel( labelBase + slider.getValue() );
        
        add( slider, BorderLayout.CENTER );
        add( label, BorderLayout.SOUTH );
        
        slider.addChangeListener( this );
    } 
    
    
    /**
     * Return the slider in this panel. This allows
     * clients to get a handle to the slider and configure
     * it.
     * &lt;p&gt;
     * @return The slider in this panel.
     **/
    public JSlider getSlider() { 
        return( slider );
    } 
    
    
    /**
     * stateChanged, from ChangeListener
     * &lt;p&gt;
     * The slider in the panel value has changed.
     * Update the label's text.
     * &lt;p&gt;
     * @param event The event causing this method to be called.
**/
    public void stateChanged( ChangeEvent event ) { 
        label.setText( labelBase + slider.getValue() );
    } 
    
}  // SliderValuePanel
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>SliderValuePanel</TT> easily could be enhanced so that
the position of the label relative to the slider would be a property
of the panel, rather than hard coded as it currently is. It would
also be useful to allow the slider to be set. This would allow
enhanced sliders, such as the <TT>PercentSlider</TT> presented
earlier in the chapter, to be used with the <TT>SliderValuePanel</TT>
class. A final enhancement would be to change the label to a <TT>JTextField</TT>
so the user could enter the desired value directly. This would
require the panel to listen to changes in the <TT>textfield</TT>
and update the slider after the user entered a new value.
<P>
The <TT>SliderValuePanelTest</TT> application, shown in Listing
10.21, is used to test the <TT>SliderValuePanel</TT> class. This
application creates the <TT>SliderValuePanel</TT> instance and
adds it to a frame for display. The resulting window is shown
in Figure 10.16. When this application is executed, the slider
can be dragged, and the label will update as the slider moves
to display the current value in the slider.
<P>
<A HREF="javascript:popUp('f10-16.gif')"><B>Figure 10.16:</B> <I>The SliderValuePanel Test application</I>.</A>
<P>
<HR>
<P>
<B>Listing 10.21&nbsp;&nbsp;The </B><TT><B>SLIDERVALUEPANELTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;
import com.foley.utility.SliderValuePanel;


/**
 * An application that displays a SliderValuePanelTest instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class SliderValuePanelTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the list and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;SliderValuePanel Test&quot; );

        SliderValuePanel sliderValuePanel = new SliderValuePanel();
        sliderValuePanel.setBorder( 
                         BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( sliderValuePanel, 
                                    BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // SliderValuePanelTest
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheTTFONTSIZEJScrollBarFONTTTFONTSIZEClassFONT">
The <TT>JScrollBar</TT> Class
</A></H3>
<P>
The <TT>JScrollBar</TT> class is used internally by JFC classes.
However, it can be instantiated and used directly by user classes
as well. Like the <TT>JSlider</TT> class, the <TT>JScrollBar</TT>
class employs a <TT>BoundedRangeModel</TT> to manage its range
and current value. In fact, as you saw during the discussion of
the <TT>BoundedRangeModel</TT> interface, some of its properties
are designed with a scrollbar in mind. The <TT>extent</TT> property
comes to mind.
<P>
The <TT>JScrollBar</TT> class contains a wrapper method for the
properties of <TT>BoundedRangeModel</TT>. These methods are convenience
methods that forward their parameters to the model. The <TT>JScrollBar</TT>
class also implements the <TT>java.awt.Adjustable</TT> interface.
As such, it must contain the methods defined in that interface.
The bound properties introduced by the <TT>JScrollBar</TT> class
are presented in Table 10.5.<BR>
<P>
<CENTER><B>Table 10.5&nbsp;&nbsp;Non-Inherited Bound Properties
of the </B><TT><B>JSCROLLBAR</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=197><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>orientation</TT></TD><TD WIDTH=197><TT>setOrientation</TT>
</TD><TD WIDTH=197><TT>getOrientation</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>model</TT></TD><TD WIDTH=197><TT>setModel</TT>
</TD><TD WIDTH=197><TT>getModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>unitIncrement</TT></TD><TD WIDTH=197><TT>setUnitIncrement</TT>
</TD><TD WIDTH=197><TT>getUnitIncrement</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>blockIncrement</TT></TD><TD WIDTH=197><TT>setBlockIncrement</TT>
</TD><TD WIDTH=197><TT>getBlockIncrement</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
Note that the constants used as the parameters for the <TT>setOrientation</TT>
method of the <TT>JScrollBar</TT> class are defined in the AWT
<TT>Adjustable</TT> interface that <TT>JScrollBar</TT> implements.
Earlier in this chapter, you saw constants with the exact same
names and purposes used in the <TT>JSlider</TT> class defined
in the <TT>SwingConstants</TT> class. Having constants with identical
names and meanings in multiple locations is a dangerous habit.
Luckily, the constants are defined with the same values so they
can be used interchangeably. We can only hope that as AWT and
JFC mature, this type of overlap will be eliminated.
<P>
You saw the <TT>JScrollBar</TT> class in action earlier in this
chapter in the <TT>JList</TT> class. You will also see it in later
chapters when the <TT>JScrollPane</TT> class is explored.
<H3><A NAME="TheTTFONTSIZEJProgressBarFONTTTFONTSIZEClassFONT">
The <TT>JProgressBar</TT>
Class</A></H3>
<P>
The <TT>JProgressBar</TT> class provides a class that can show
the progress of an operation. A progress bar is commonly seen
at the bottom of a frame when a lengthy operation is under way.
It is updated periodically to indicate the status of the operation.
<P>
The <TT>JProgressBar</TT> class tracks the minimum, maximum, and
current values in a <TT>BoundedRangeModel</TT> instance. The class
contains the familiar convenience methods for setting and getting
the model's minimum, maximum, and current values. The default
values for these properties define a range from 0 to 100, and
an initial value of 0. These properties are not bound to the <TT>JProgressBar</TT>
class; interested parties must listen to the model to be notified
when these properties change.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
There are no bound properties defined in the <TT>JProgressBar </TT>class. If the model changes for the progress bar and a listener was listening to the old model, it will be unaware of the change. The listener will no longer receive change events from the model that controls the progress bar that it is interested in.
</BLOCKQUOTE>
<BLOCKQUOTE>
To avoid this type of error, the <TT>JProgressBar </TT>class allows a <TT>ChangeListener </TT>to be added to it directly, rather than to its <TT>BoundedRangeModel</TT>. The progress bar listens for changes in the model and forwards all <TT>ChangeEvents </TT>from the model to its registered listeners.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The orientation of the progress bar can be specified with the
<TT>setOrientation</TT> method. Legal values for the orientation
property are the constants <TT>HORIZONTAL</TT> and <TT>VERTICAL</TT>,
defined in the <TT>SwingConstants</TT> interface. The <TT>JProgressBar</TT>
class implements this interface, so the constant can be specified
as either <TT>SwingConstants.HORIZONTAL</TT> or <TT>JProgressBar.HORIZONTAL</TT>.
The <TT>getOrientation</TT> method returns the current value of
this property. The <TT>orientation</TT> property is not bound
in the <TT>JProgressBar</TT> class.
<P>
The <TT>ProgressBarTest</TT> application, shown in Listing 10.22,
creates a <TT>JProgressBar</TT> instance and adds it to a frame.
The application uses the default range for the progress bar and
sets its value to 25. The resulting progress bar is shown in Figure
10.17.
<P>
<A HREF="javascript:popUp('f10-17.gif')"><B>Figure 10.17:</B> <I>The ProgressBarTest application</I>.</A><P>
<HR>
<P>
<B>Listing 10.22&nbsp;&nbsp;The ProgressBarTest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JProgressBar instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class ProgressBarTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the progress bar and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;ProgressBar Test&quot; );
        
        JProgressBar progressBar = new JProgressBar();
        progressBar.setValue( 25 );

        frame.getContentPane().add( progressBar, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // ProgressBarTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Unlike what you saw with the <TT>JSlider</TT> class earlier in
this chapter, the <TT>JProgressBar</TT> class contains a property
for displaying the current value in the progress bar. Passing
<TT>true</TT> to the <TT>setStringPainted</TT> method will paint
the current value in the progress bar as a percentage of the model's
range. By default, the string is not painted. The string painted
in the progress bar can be specified by calling the <TT>setString</TT>
method. This method can be repeatedly called as the progress is
incremented, if desired. Each time it's called, the new string
will be painted in the progress bar. If a string has been specified
for the progress bar using this method, it is painted in the progress
bar rather than calculating the completion percentage. The displayed
string can be queried with the <TT>getString</TT> method. After
a string has been specified, passing <TT>null</TT> to the <TT>setString</TT>
method will restore the default behavior.
<P>
The <TT>isStringPainted</TT> method can be called to query the
current state of the <TT>stringPainted</TT> property. The default
behavior of the <TT>getString</TT> method calls the <TT>getPercentComplete</TT>
method. This method returns a <TT>double</TT> that represents
the <BR>
percentage of the value in range defined in the progress bar's
model. The value is between 0.0 and 1.0.
<P>
Adding the following line of code to the <TT>ProgressBarTest</TT>
application will cause the string to be painted as a percentage
of the model's range. The resulting progress bar is shown in Figure
10.18.
<BLOCKQUOTE>
<PRE>
progressBar.setStringPainted( true );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f10-18.gif')"><B>Figure 10.18:</B> <I>A string displayed in the JProgressBar</I>.</A>
<P>
Passing <TT>false</TT> to the <TT>setBorderPainted</TT> method
will hide the border around the progress bar. The <TT>isBorderPainted</TT>
method will query the current state of the <TT>borderPainted</TT>
property. The default behavior is to paint the border around the
progress bar.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter covered a lot of material. The <TT>ListModel</TT>
and <TT>ListSelectionModel</TT> were presented, as well as how
the <TT>JList</TT> class uses these two models. You also learned
how to use the <TT>JList</TT> class to present the user with a
choice of options.
<P>
The <TT>JComboBox</TT> class and its associated models, <TT>ComboBoxModel</TT>
and <TT>MutableComboBoxModel</TT>, were presented. This class
was compared and contrasted with the <TT>JList</TT> class and
its models, and the inconsistencies between these classes were
explained. Unfortunately, these inconsistencies make programming
the two classes overly complex.
<P>
The <TT>BoundedRangeModel</TT> was presented, as well as three
classes that use this model. You learned about the <TT>JSlider</TT>
class. An extension to the class was presented to demonstrate
how typed labels can be used in a slider. The <TT>JScrollBar</TT>
class was introduced, which will be used more extensively in Chapter
15 when scroll panes are presented. Finally, you learned about
the <TT>JProgressBar</TT> class, which provides a component that
displays the value in its <TT>BoundedRange</TT> model as a percentage
of the model's range.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch09\ch09.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch11\ch11.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
