<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 23 - Creating a Custom Look-and-Feel</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch22\ch22.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch24\ch24.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;23<br>
Creating a Custom Look-and-Feel</H1>
<HR>
<p>

<UL>
<LI><A HREF="#CustomizingExistingLookandFeels">
Customizing Existing Look-and-Feels</A>
<UL>
<LI><A HREF="#DeterminingAvailableProperties">
Determining Available Properties</A>
<LI><A HREF="#UsingUIProperties">
Using UI Properties</A>
<LI><A HREF="#CreatingaTheme">
Creating a Theme</A>
<LI><A HREF="#WhatAboutFeel">
What About Feel?</A>
</UL>
<LI><A HREF="#CreatingaLookandFeel">
Creating a Look-and-Feel</A>
<UL>
<LI><A HREF="#TheTTFONTSIZELookAndFeelFONTTTFONTSIZEClassFONT">
The <TT>LookAndFeel</TT>
Class</A>
<LI><A HREF="#UsingtheUnleashedLookandFeel">
Using the Unleashed Look-and-Feel</A>
</UL>
<LI><A HREF="#TheMultiplexingLookAndFeel">
The Multiplexing Look-And-Feel</A>
<UL>
<LI><A HREF="#AuxiliaryLookandFeels">
Auxiliary Look-and-Feels</A>
<LI><A HREF="#RegisteringAuxiliaryLookandFeels">
Registering Auxiliary Look-and-Feels</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Even though the JFC comes complete with look-and-feel implementations
for popular windowing systems and a platform-neutral look-and-feel,
you may still be required to create a custom look-and-feel. An
example of such a requirement is a corporation that wants a company-branded
application to be available on all platforms used by the company.
This reduces the learning curve for users and reduces the dependency
on hardware platforms. The Java look-and-feel can be used to meet
the requirement of the same user interface on all platforms but
does not meet the branding requirement.
<P>
Another requirement for a custom look-and-feel implementation
is a UI designer who may want to implement a complete look-and-feel
to demonstrate his or her design.
<P>
There are multiple levels of customizations that can be made to
a look-and-feel. These range from changing colors and icons in
an existing look-and-feel implementation to providing a custom
user interface implementation for every component.
<P>
In this chapter, you will learn
<UL>
<LI>How to customize the look of existing look-and-feel implementations
<LI>How to create custom themes
<LI>How to change the feel of a component
<LI>How to create a new look-and-feel
</UL>
<H2><A NAME="CustomizingExistingLookandFeels">
Customizing Existing Look-and-Feels</A></H2>
<P>
An amazing feature of the pluggable look-and-feel architecture
the Swing components are built on is how much of the &quot;look&quot;
can be customized without extending a single class. A look-and-feel
implementation should not hard code its look into the source code.
Instead, properties that define the look are registered with the
<TT>UIManager</TT>. When the user interface delegate is to render
a component, the properties are read from the <TT>UIManager</TT>
and used appropriately for the component.
<P>
A client application can alter the UI properties to create a custom
look. The set of properties that defines a look are often referred
to as a theme. The Java look-and-feel has built-in support for
installing custom themes. An ad hoc approach must be taken with
other look-and-feel implementations.
<H3><A NAME="DeterminingAvailableProperties">
Determining Available Properties</A></H3>
<P>
Setting properties in the <TT>UIManager</TT> provides a simple
mechanism for altering the look of JFC components. However, you
need to know the list of available properties to be able to change
them. The available properties can be determined by examining
the source code for the look-and-feel or by examining the properties
defined in the <TT>UIManager</TT> at runtime. In this section,
a combination of both techniques will be presented.
<P>
The <TT>PropertyViewer</TT> application shown in Listing 23.1
is an application that displays the properties of any of the registered
look-and-feels. In the <TT>createComboBox</TT> method, the registered
look-and-feels are queried from the <TT>UIManager</TT> by using
the following line of code. An array of <TT>LookAndFeelInfo</TT>
objects is returned from the <TT>getInstalled LookAndFeels</TT>
method in the <TT>UIManager</TT> class. The <TT>LookAndFeelInfo</TT>
class is defined in the <TT>UIManager</TT> class and contains
information about a look-and-feel. This class contains two methods
of interest: <TT>getName</TT> and <TT>getClassName</TT>. The name
is a string suitable for use in menus or combo boxes, as shown
here. The <TT>getClassName</TT> returns the name of the class
that defines the look-and-feel. The result is a combo box containing
the name of all the registered look-and-feels available in the
JFC installation.
<BLOCKQUOTE>
<PRE>
UIManager.LookAndFeelInfo[] info = UIManager.getInstalledLookAndFeels();
</PRE>
</BLOCKQUOTE>
<P>
An <TT>ItemListener</TT> is added to the combo box. When the item
is changed, the new look-and-feel is loaded and the properties
are updated in the table. The <TT>setLookAndFeel</TT> method is
used to update the look-and-feel for the application. The look-and-feel
is set by passing the class name of the desired look-and-feel
to the <TT>setLookAndFeel</TT> method contained in the <TT>UIManager</TT>
class. The <TT>setLookAndFeel</TT> method updates the <TT>UIDefaults</TT>
object that will cause the new look-and-feel to be used for newly
created objects. However, it does not alter existing components.
To change the UI object for existing components, call the <TT>updateComponenetTreeUI</TT>
method in the <TT>SwingUtilities</TT> class. As its name implies,
this method updates the UI object for the tree of components starting
at the given component. If this method is called for each top-level
window in an application, the look-and-feel can be totally changed
at runtime. There is a single <TT>JFrame</TT> for this application,
and that is passed to the <TT>updateComponenetTreeUI</TT> method.
The following code fragment demonstrates this technique:
<BLOCKQUOTE>
<PRE>
UIManager.setLookAndFeel( className );        
SwingUtilities.updateComponentTreeUI( 
               JOptionPane.getFrameForComponent( this ) );
</PRE>
</BLOCKQUOTE>
<P>
The <TT>dumpLAFProperties</TT> method is used to query the <TT>UIDefaults</TT>
instance from the <TT>UIManager</TT> and update the table model
using these values. The following code performs this task:
<BLOCKQUOTE>
<PRE>
UIDefaults defaults = UIManager.getDefaults();
Enumeration keys = defaults.keys();
Enumeration elements = defaults.elements();
tableModel.update( keys, elements );
</PRE>
</BLOCKQUOTE>
<P>
The complete <TT>PropertyViewer</TT> application is in Listing
23.1. The executing application is shown in Figure 23.1.
<P>
<HR>
<P>
<B>Listing 23.1&nbsp;&nbsp;The </B><TT><B>PROPERTYVIEWER</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import java.util.*;

import javax.swing.*;
import javax.swing.table.*;

import com.foley.utility.*;


/**
 * An application that displays the properties
 * of the installed look-and-feels
 *
 * @author Mike Foley
 **/
public class PropertyViewer extends JPanel 
    implements ItemListener { 

    JComboBox comboBox;
    JTable table;
    UITableModel tableModel;
    
    
    /**
     * PropertyViewer, constructor
     * &lt;p&gt;
     * Create the 
     **/
    public PropertyViewer() { 
        super();
        
        setLayout( new BorderLayout() );
        
        comboBox = createComboBox();
        tableModel = new UITableModel();
        sorter = new TableSorter( tableModel );
        table = new JTable( sorter );
        
        comboBox.addItemListener( this );
        
        add( comboBox, BorderLayout.NORTH );
        add( new JScrollPane( table ), BorderLayout.CENTER );
        
        dumpLAFProperties();
    } 

            
    /**
     * Create a combo box containing the installed
     * look-and-feels.
     * &lt;p&gt;
     * @return A combo box containing the installed L&amp;Fs.
     **/
    protected JComboBox createComboBox() { 
        JComboBox comboBox = new JComboBox();
        
        UIManager.LookAndFeelInfo[] info = 
            UIManager.getInstalledLookAndFeels();
        for( int i = 0; i &lt; info.length; i++ ) { 
            comboBox.addItem( info[i].getName() );
        } 
        return( comboBox );
    } 
    
    public void itemStateChanged( ItemEvent event ) { 
        if( event.getStateChange() == ItemEvent.SELECTED ) { 
            System.out.println( event.getItem() );
            String name = event.getItem().toString();
            UIManager.LookAndFeelInfo[] info = 
                UIManager.getInstalledLookAndFeels();
            for( int i = 0; i &lt; info.length; i++ ) { 
                if( name.equals( info[i].getName() ) ) { 
                    setLookAndFeel( info[i].getClassName() );                    
                    dumpLAFProperties();
                    break;
                } 
            } 
        } 
    } 


    /**
     * Set the look-and-feel to the given L&amp;F.
     * Update your UI to the new look-and-feel.
     * &lt;p&gt;
     * @param className The class name of the L&amp;F to set.
     **/
    private void setLookAndFeel( String className ) { 
        try { 
            UIManager.setLookAndFeel( className );        
            SwingUtilities.updateComponentTreeUI( 
                JOptionPane.getFrameForComponent( this ) );
        }  catch( Exception e ) { 
            System.err.println( &quot;Cound not set look-and-feel&quot; );
        } 
    } 
    

    /**
     * Print the properties of the current look-
     * and-feel to the text area component.
     **/
    public void dumpLAFProperties() { 
        UIDefaults defaults = UIManager.getDefaults();
        Enumeration keys = defaults.keys();
        Enumeration elements = defaults.elements();
        tableModel.update( keys, elements );
    } 
    
    
    /**
     * Application entry point.
     * Create a frame and a table and display them.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;PropertyViewer&quot; );

        PropertyViewer propertyViewer = new PropertyViewer();
        propertyViewer.setBorder( 
                 BorderFactory.createLoweredBevelBorder() );
        
        Container content = frame.getContentPane();
        content.add( propertyViewer, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // PropertyViewer


class UITableModel extends AbstractTableModel { 

    private Vector keyData;
    private Vector valueData;

    public UITableModel() { 
        super();
        keyData = new Vector();
        valueData = new Vector();
    } 
    
    
    public int getRowCount() { 
        return( keyData.size() );
    } 
    public int getColumnCount() { 
        return( 2 );
    } 
    
    public Class getColumnClass( int column ) { 
        return( String.class );
    } 
    
    public String getColumnName( int column ) { 
        if( column == 0 ) { 
            return( &quot;Key&quot; );
        }  else { 
            return( &quot;Current Value&quot; );
        } 
    } 
    
    public Object getValueAt(int row, int column) { 
        if( column == 0 ) { 
            return( keyData.elementAt( row ) );
        }  else { 
            return( valueData.elementAt( row ) );
        } 
    } 
  
    public void update( Enumeration keys, Enumeration values ) { 
        keyData.removeAllElements();
        valueData.removeAllElements();
        while( keys.hasMoreElements() ) { 
            keyData.addElement( keys.nextElement() );
            valueData.addElement( values.nextElement() );
            
        } 
        fireTableStructureChanged();        
    } 
    
}  // UITableModel
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f23-1.gif')"><B>Figure 23.1 :</B> <I>The PropertyViewer application</I>.</A>
<H3><A NAME="UsingUIProperties">
Using UI Properties</A></H3>
<P>
The previous section presented an application that displays the
look-and-feel properties for any of the installed look-and-feels.
Now that you know what properties are available for customizing
Swing components, you can register your preferences with the <TT>UIManager</TT>.
<P>
As an example, customize the <TT>JTree</TT> class' UI object by
altering some of its properties. Figure 23.1 displays the available
properties for the <TT>JTree</TT> class and their default values
for the Java look-and-feel. Properties range from the foreground
and background colors to the icons used for the various tree node
states. The <TT>main</TT> method of the <TT>TreeTest</TT> application
presented in <A HREF="..\ch11\ch11.htm" >Chapter 11</A>, &quot;Tree Component,&quot; will be modified
to register properties for the <TT>JTree</TT> class's UI object.
The unmodified application is shown in Figure 23.2.
<P>
The following lines of code were added to the <TT>main</TT> method
of the <TT>TreeTest</TT> application before the components were
created. These lines of code set properties in the <TT>UIDefaults</TT>
object. The <TT>put</TT> method in the <TT>UIManager</TT> class
is a convenience method and is the equivalent of first getting
the <TT>UIDefaults</TT> from the <TT>UIManager</TT> and then calling
the <TT>put</TT> method of the <TT>UIDefaults</TT> object directly.
The <TT>UIDefaults</TT> class is an extension of the <TT>Hashtable</TT>
class, allowing the familiar <TT>Hashtable</TT> class's API to
be used when modifying UI properties.
<BLOCKQUOTE>
<PRE>
UIManager.put( &quot;Tree.background&quot;, Color.lightGray );
UIManager.put( &quot;Tree.textForeground&quot;, Color.blue );
UIManager.put( &quot;Tree.textBackground&quot;, Color.yellow );        
UIManager.put( &quot;Tree.font&quot;, new Font( &quot;Helvetica&quot;, Font.BOLD, 24 ) );
UIManager.put( &quot;Tree.leftChildIndent&quot;, new Integer( 24 ) );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f23-2.gif')"><B>Figure 23.2 : </B><I>The unmodified TreeTest application</I>.</A>
<P>
Setting the <TT>&quot;Tree.background&quot;</TT> property in the
first line sets the tree's background color to black. Similarly,
the text foreground and background color properties are set to
blue and yellow, respectively. The font for the tree is set to
an eye-popping 24-point Helvetica bold font. Because of the large
font, the default indentation seemed too small, so the final line
sets this property to 24 pixels. The resulting tree is shown in
Figure 23.3. Any of the UI object's properties can be set by using
this technique.
<P>
<A HREF="javascript:popUp('f23-3.gif')"><B>Figure 23.3 :</B> <I>The modified TreeTest application</I>.</A>
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Care must be taken when setting properties with the <TT>UIManager.put</TT> method. The keys are <TT>String</TT>instances. A typo in the key will execute without producing an error, but the property will not be used. The property will be added to the <TT>UIDefaults</TT> table but, since the key was not correct, when the UI object retrieves the property by using the correct key, your value will not be used. An interface containing all the keys defined as constants would eliminate this type of error.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H4>The <TT>LookAndFeel</TT> Source Files</H4>
<P>
A look-and-feel is defined in a <TT>LookAndFeel</TT> class. The
standard naming convention for this class is the look-and-feel
implementation's name followed by <TT>LookAndFeel</TT>. For example,
the MS Windows look-and-feel is defined in the <TT>WindowsLookAndFeel</TT>
class. The <TT>LookAndFeel</TT> class contains methods to query
the name, description, and ID for the look-and-feel. It also contains
the initialization code for the <TT>UIDefaults</TT> properties.
This file presents a valuable resource for property names and
their default values.
<H3><A NAME="CreatingaTheme">
Creating a Theme</A></H3>
<P>
When using the Java look-and-feel, also known as Metal, changing
the theme can easily alter properties being used in an application.
A theme consists of colors and fonts used by the look-and-feel.
<P>
The Java look-and-feel is designed by using three primary colors
and three secondary colors for most components. The primary colors
are the foreground colors, and the secondary colors are the background
colors. Creating a theme class that specifies these six colors
gives an easy method to change an application's look. Specifying
fonts and colors in the theme can provide further customization.
<P>
The complete <TT>MetalTheme</TT> abstract class is shown in Listing
23.2. The listing shows the complete set of methods that a theme
can override to customize the look-and-feel. The Metal look-and-feel
defines the <TT>DefaultMetalTheme</TT> class, which is a concrete
extension of the <TT>MetalTheme</TT> class. The <TT>DefaultMetalTheme</TT>
class provides the default theme for the Metal look-and-feel and
is also shown in Listing 23.2.
<P>
<HR>
<P>
<B>Listing 23.2&nbsp;&nbsp;The </B><TT><B>METALTHEME</B></TT><B>
and </B><TT><B>DEFAULTMETALTHEME</B></TT><B>
Classes<BR>
</B>
<BLOCKQUOTE>
<PRE>
public abstract class MetalTheme { 

    private static ColorUIResource white = 
                             new ColorUIResource( 255, 255, 255 );
    private static ColorUIResource black = 
                             new ColorUIResource( 0, 0, 0 );

    public abstract String getName();

    // these are blue in Metal Default Theme
    protected abstract ColorUIResource getPrimary1();  
    protected abstract ColorUIResource getPrimary2();
    protected abstract ColorUIResource getPrimary3();

    // these are gray in Metal Default Theme
    protected abstract ColorUIResource getSecondary1();  
    protected abstract ColorUIResource getSecondary2();
    protected abstract ColorUIResource getSecondary3();

    public abstract FontUIResource getControlTextFont();
    public abstract FontUIResource getSystemTextFont();
    public abstract FontUIResource getUserTextFont();
    public abstract FontUIResource getMenuTextFont();
    public abstract FontUIResource getWindowTitleFont();
    public abstract FontUIResource getSubTextFont();

    protected ColorUIResource getWhite() {  return white; } 
    protected ColorUIResource getBlack() {  return black; } 

    public ColorUIResource getFocusColor() {  return getPrimary2(); } 

    public  ColorUIResource getDesktopColor() {  return getPrimary2(); } 

    public ColorUIResource getControl() {  return getSecondary3(); } 
    public ColorUIResource getControlShadow() { 
      return getSecondary2(); 
    } 
    public ColorUIResource getControlDarkShadow() {  
        return getSecondary1(); 
    }
    public ColorUIResource getControlInfo() {  return getBlack(); }  
    public ColorUIResource getControlHighlight() {  return getWhite(); } 
    public ColorUIResource getControlDisabled() {  
        return getSecondary2(); 
    } 

    public ColorUIResource getPrimaryControl() {  return getPrimary3(); } 
    public ColorUIResource getPrimaryControlShadow() {  
        return getPrimary2(); 
    } 
    public ColorUIResource getPrimaryControlDarkShadow() {  
        return getPrimary1(); 
    }   
    public ColorUIResource getPrimaryControlInfo() {  
        return getBlack(); 
    }  
    public ColorUIResource getPrimaryControlHighlight() {  
        return getWhite(); 
    }   

    public ColorUIResource getSystemTextColor() {  
        return getPrimary1(); 
    } 
    public ColorUIResource getControlTextColor() {  
        return getControlInfo(); 
    }   
    public ColorUIResource getInactiveControlTextColor() {  
        return getControlDisabled(); 
    }   
    public ColorUIResource getInactiveSystemTextColor() {  
        return getSecondary2(); 
    } 
    public ColorUIResource getUserTextColor() {  
        return getBlack(); 
    } 
    public ColorUIResource getTextHighlightColor() {  
        return getPrimary3(); 
    } 
    public ColorUIResource getHighlightedTextColor() {  
        return getControlTextColor(); 
    } 

    public ColorUIResource getWindowBackground() {  
        return getWhite(); 
    } 
    public ColorUIResource getWindowTitleBackground() {  
        return getPrimary3(); 
    }
    public ColorUIResource getWindowTitleForeground() {  
        return getBlack(); 
    }   
    public ColorUIResource getWindowTitleInactiveBackground() {  
        return getSecondary3(); 
    } 
    public ColorUIResource getWindowTitleInactiveForeground() {  
        return getBlack(); 
    } 

    public ColorUIResource getMenuBackground() {  
        return getSecondary3(); 
    } 
    public ColorUIResource getMenuForeground() {  
        return  getBlack(); 
    } 
    public ColorUIResource getMenuSelectedBackground() {  
        return getPrimary2(); 
    } 
    public ColorUIResource getMenuSelectedForeground() {  
        return getBlack(); 
    } 
    public ColorUIResource getMenuDisabledForeground() {  
        return getSecondary2(); 
    }
    public ColorUIResource getSeparatorBackground() {  
        return getWhite(); 
    } 
    public ColorUIResource getSeparatorForeground() {  
        return getPrimary1(); 
    } 
    public ColorUIResource getAcceleratorForeground() {  
        return getPrimary1(); 
    } 
    public ColorUIResource getAcceleratorSelectedForeground() {  
        return getBlack(); 
    } 

    public void addCustomEntriesToTable(UIDefaults table) { } 
} 

public class DefaultMetalTheme extends MetalTheme { 

    private final ColorUIResource primary1 = 
                            new ColorUIResource(102, 102, 153);
    private final ColorUIResource primary2 = 
                            new ColorUIResource(153, 153, 204);
    private final ColorUIResource primary3 = 
                            new ColorUIResource(204, 204, 255);

    private final ColorUIResource secondary1 = 
                            new ColorUIResource(102, 102, 102);
    private final ColorUIResource secondary2 = 
                            new ColorUIResource(153, 153, 153);
    private final ColorUIResource secondary3 = 
                            new ColorUIResource(204, 204, 204);

    private final FontUIResource controlFont = 
                       new FontUIResource(&quot;Dialog&quot;, Font.BOLD, 12);
    private final FontUIResource systemFont = 
                       new FontUIResource(&quot;Dialog&quot;, Font.PLAIN, 12);
    private final FontUIResource windowTitleFont = 
                       new FontUIResource(&quot;SansSerif&quot;, Font.BOLD, 12);
    private final FontUIResource userFont = 
                       new FontUIResource(&quot;Dialog&quot;, Font.PLAIN, 12);
    private final FontUIResource smallFont = 
                       new FontUIResource(&quot;Dialog&quot;, Font.PLAIN, 10);

    public String getName() {  return &quot;Steel&quot;; } 

// these are blue in Metal Default Theme
    protected ColorUIResource getPrimary1() {  return primary1; }  
    protected ColorUIResource getPrimary2() {  return primary2; } 
    protected ColorUIResource getPrimary3() {  return primary3; } 

// these are gray in Metal Default Theme
    protected ColorUIResource getSecondary1() {  return secondary1; } 
    protected ColorUIResource getSecondary2() {  return secondary2; } 
    protected ColorUIResource getSecondary3() {  return secondary3; } 

    public FontUIResource getControlTextFont() {  return controlFont;} 
    public FontUIResource getSystemTextFont() {  return systemFont;} 
    public FontUIResource getUserTextFont() {  return userFont;} 
    public FontUIResource getMenuTextFont() {  return controlFont;} 
    public FontUIResource getWindowTitleFont() {  return controlFont;} 
    public FontUIResource getSubTextFont() {  return smallFont;} 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>OutlandishTheme</TT> class presented in Listing 23.3 shows
an extension to the <TT>DefaultMetalTheme</TT> class that overrides
the primary and secondary colors. When this theme is set for the
<TT>TreeTest</TT> application, the result is the window shown
in Figure 23.4. The window using the <TT>DefaultMetalTheme</TT>
was shown in Figure 23.2.
<P>
<HR>
<P>
<B>Listing 23.3&nbsp;&nbsp;The </B><TT><B>OUTLANDISHTHEME</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import javax.swing.plaf.ColorUIResource;

import javax.swing.plaf.metal.DefaultMetalTheme;


/**
 * This class provides an outlandish color theme.
 * The primary and secondary colors are overridden.
 * The fonts and other theme properties are left unaltered.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class OutlandishTheme extends DefaultMetalTheme { 

    public String getName() {  return &quot;OutlandishTheme&quot;; } 

    //
    // Primary Colors.
    //
    private final ColorUIResource primary1 = 
                            new ColorUIResource( 255, 0, 0 );
    private final ColorUIResource primary2 = 
                            new ColorUIResource(200, 25, 25);
    private final ColorUIResource primary3 = 
                            new ColorUIResource(150, 150, 150); 

    protected ColorUIResource getPrimary1() {  return primary1; }   
    protected ColorUIResource getPrimary2() {  return primary2; }  
    protected ColorUIResource getPrimary3() {  return primary3; }  

    //
    // Secondary Colors.
    //
    private final ColorUIResource secondary1 = 
                            new ColorUIResource( 0,  255,  0);
    private final ColorUIResource secondary2 = 
                            new ColorUIResource(25, 200, 25);
    private final ColorUIResource secondary3 = 
                            new ColorUIResource(40, 180, 40);

    protected ColorUIResource getSecondary1() {  return secondary1; } 
    protected ColorUIResource getSecondary2() {  return secondary2; } 
    protected ColorUIResource getSecondary3() {  return secondary3; } 

}  // OutlandishTheme
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f23-4.gif')"><B>Figure 23.4 :</B> <I>The OutlandishTheme set for the TreeTest
application</I>.</A>
<P>
The theme is set for the application by calling the static <TT>setCurrentTheme</TT>
method contained in the <TT>MetalLookAndFeel</TT> class. The following
line of code was added to the <TT>main</TT> method in the <TT>TreeTest</TT>
application to set <TT>OutlandishTheme</TT> for the application.
The theme can be dynamically changed when the application is running.
This allows themes to be selected from a menu or read from a property
file while the application is executing.
<BLOCKQUOTE>
<PRE>
MetalLookAndFeel.setCurrentTheme( new OutlandishTheme() );
<P>
</PRE>
</BLOCKQUOTE>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>Metalworks</TT> demonstration application that is part of the JDK distribution provides many custom themes that can be dynamically changed by selecting the desired theme from a menu. An example of reading a theme from a property file is also demonstrated.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The <TT>OutlandishTheme</TT> only customizes colors. However,
other properties are just as easily specified in a theme. For
example, adding the following lines of code to the <TT>OutlandishTheme</TT>
class will set all the application's fonts to an 18-point sans
serif bold font. Of course all the fonts don't have to be the
same, and typically they aren't. The resulting window is shown
in Figure 23.5. Creating a theme with large fonts is useful when
giving demonstrations of an application.
<P>
<A HREF="javascript:popUp('f23-5.gif')"><B>Figure 23.5 :</B> <I>Large fonts added to the TreeTest application</I>.</A>
<BLOCKQUOTE>
<PRE>
//
// Fonts.
//
private final FontUIResource font = new FontUIResource(&quot;SansSerif&quot;, Font.BOLD, 18);
public FontUIResource getControlTextFont() {  return font;} 
public FontUIResource getSystemTextFont() {  return font;} 
public FontUIResource getUserTextFont() {  return font;} 
public FontUIResource getMenuTextFont() {  return font;} 
public FontUIResource getWindowTitleFont() {  return font;} 
public FontUIResource getSubTextFont() {  return font;} 
</PRE>
</BLOCKQUOTE>
<P>
The last method of interests in the <TT>MetalTheme</TT> class
is the <TT>addCustomEntriesToTable</TT> method. This method is
intended to provide the theme an opportunity to register custom
properties in the <TT>UIDefaults</TT> table. These are the same
UI properties that were identified and set in the previous section.
Being able to set the properties in the theme class allows all
customizations to be encapsulated in the same class. For example,
the customizations to the <TT>TreeUI</TT> shown in the previous
section would be specified in a theme by setting the properties
in the <TT>addCustomEntriesToTable</TT> method. An example for
this method that achieves the same customizations for the <TT>TreeUI</TT>
object is shown next. Notice how the superclass' <TT>addCustomEntriesToTable</TT>
method is called first to initialize the <TT>UIDefaults</TT> table
with values inherited from the parent theme. (In the <TT>DefaultMetalTheme</TT>
this method is empty.) After the table is initialized, the custom
values can be specified in the table. The look-and-feel calls
this method during initialization or when the theme is changed.
After the method returns, the <TT>UIDefaults</TT> object is set
in the <TT>UIManager</TT>.
<BLOCKQUOTE>
<PRE>
public void addCustomEntriesToTable(UIDefaults table) { 
    super.addCustomEntriesToTable(table);

    table.put( &quot;Tree.background&quot;, Color.black );
    table.put( &quot;Tree.textForeground&quot;, Color.blue );
    table.put( &quot;Tree.textBackground&quot;, Color.yellow );        
    table.put( &quot;Tree.font&quot;, new Font( &quot;Helvetica&quot;, Font.BOLD, 24 ) );
    table.put( &quot;Tree.leftChildIndent&quot;, new Integer( 24 ) );

}

</PRE>
</BLOCKQUOTE>

<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600><BLOCKQUOTE>
Themes are an extremely powerful method for customizing an application. Reading the theme from a property file provides an easy mechanism that gives users the ability to customize an application. However, themes are only available when using the Java look-and-feel. This is unfortunate.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="WhatAboutFeel">
What About Feel?</A></H3>
<P>
To this point, all the customizations presented have to do with
the look of an application, not its feel. This is for two reasons.
First, there are not as many hooks in the JFC for customizing
feel. The <TT>UIDefaults</TT> object does not contain properties
that map user gestures to actions. However, this would be a welcome
addition. 
<P>
Secondly, more care must be used when altering the feel of an
application. Changing the way an application responds to user
gestures can make the program difficult to use. For example, if
the feel of a button is changed to require a double-click instead
of a single-click to perform the action, users will not know how
to use the application and can become confused. 
<P>
Changing colors, fonts, and icons can make an application look
drastically different, but the standard components will still
behave the way the user expects. This may not be the situation
when the feel is changed. Moreover, there is no visual clue to
the user that the feel has been changed. Thus, changing the feel
of standard components must be performed with extreme caution
and only for very good reasons.
<P>
When the situation does arise when the feel of a component needs
to be changed, it is possible to do so. The technique is similar
to that shown in the previous chapter when a new UI object was
installed for the <TT>ToolTipUI</TT>.
<H4>Customizing the <TT>TreeUI</TT></H4>
<P>
The <TT>TreeUI</TT> class expands and contracts a node when it
is double-clicked with the mouse. I had an application that opened
a dialog box when a node in the tree was double-clicked, and the
tree expanding or contracting was a distraction to the user. The
<TT>JTree</TT> class and the <TT>TreeUI</TT> implementations do
not contain a property to control this action, so a new UI class
was written and installed for the <TT>JTree</TT> class. The double-click
causing the tree to expand and collapse was the only modification
made to the tree's feel. Since the control immediately to the
left on the node's text expands and collapses the tree, and the
double-click performs another action that the user sees, changing
this aspect of the tree's feel did not detract from the user's
ability to use the application-instead, it enhanced it.
<P>
The <TT>NonExpandingTreeUI</TT> class shown in Listing 23.4 will
prevent a <TT>JTree</TT> instance from expanding and collapsing
when the user double-clicks a node. The <TT>createUI</TT> method
is boilerplate look-and-feel code. It creates the UI object for
the given component-in this case, a new instance of the <TT>NonExpandingTreeUI</TT>
class. The <TT>isToggleEvent</TT> method is defined in the <TT>BasicTreeUI</TT>
class to determine if the given mouse event should toggle the
expansion state of a node. The <TT>BasicTreeUI</TT> class tests
the click count in the event and returns <TT>true</TT> for a count
of two and <TT>false</TT> for other counts. The <TT>NonExpandingTreeUI</TT>
class always returns <TT>false</TT> from this method. Thus, no
mouse event will toggle the node's expansion state.
<P>
<HR>
<P>
<B>Listing 23.4&nbsp;&nbsp;The </B><TT><B>NONEXPANDINGTREEUI</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.event.MouseEvent;

import javax.swing.JComponent;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicTreeUI;


/**
 * A TreeUI that does not automatically expand or
 * collapse the tree on a double click event.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class NonExpandingTreeUI extends BasicTreeUI
{ 

    /**
     * Create the UI object for the given tree. This
     * is a new instance of this class.
     **/
    public static ComponentUI createUI( JComponent tree ) { 
      return( new NonExpandingTreeUI() );
    } 


    /**
     * NonExpandingTreeUI, constructor
     **/
    public NonExpandingTreeUI() { 
          super();
    } 


    /**
     * Returning true indicates the row under the mouse should be toggled
     * based on the event. This is invoked after 
     * checkForClickInExpandControl, implying the location is not in the
     * expand (toggle) control
     * &lt;p&gt;
     * This is the behavior we want to stop, so always return false.
     * &lt;p&gt;
     * @return false
     **/
    protected boolean isToggleEvent( MouseEvent event ) { 
      return( false );
    } 

}  // NonExpandingTreeUI
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>Registering the UI Class</B>
<BLOCKQUOTE>
The code to register the <TT>NonExpandingTreeUI</TT> class is
shown next. This code is the same as that shown in the previous
chapter when the <TT>ToolTipUI</TT> was replaced. Two keys in
the <TT>UIDefaults</TT> table define which UI class will be used
for a component's UI object. The first uses the <TT>uiClassID</TT>,
defined in the component as the key, and maps to the class key.
The second uses the class key defined in the first entry to the
name of the class to use for that UI object. If there is not an
entry in the <TT>UIDefaults</TT> table for the class key, the
class key is assumed to be the name of the class, and an instance
of that class is instantiated. Thus, if the value returned from
the <TT>uiClassID</TT> key lookup is the name of the UI object's
class, the second entry in the table can be omitted. The following
code will map all <TT>TreeUI</TT> requests to the <TT>NonExpandingTreeUI</TT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
try { 
    String nonExpandingTreeUIClassName = 
                &quot;com.foley.utility.NonExpandingTreeUI&quot;;
    UIManager.put( &quot;TreeUI&quot;, nonExpandingTreeUIClassName );
    UIManager.put( nonExpandingTreeUIClassName, 
                Class.forName( nonExpandingTreeUIClassName ) );
}  catch( ClassNotFoundException cnfe ) { 
    System.err.println( &quot;NonExpanding Tree UI class not found&quot; );
    System.err.println( cnfe );
}
</PRE>
</BLOCKQUOTE>

<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><b>NOTE</b></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600><BLOCKQUOTE>
The <TT>NonExpandingTreeUI</TT> class in the previous example extends the <TT>BasicTreeUI</TT> class and is registered for all look-and-feels. This has the side effect of losing the custom look- and-feel behavior defined in the specific look-and-feel <TT>TreeUI</TT> implementations. For exam- ple, the dividing lines available in the Java look-and-feel are not available when the <TT>NonExpandingTreeUI</TT> class is used.
</BLOCKQUOTE>
<BLOCKQUOTE>
The workaround to this situation is to have a version of the NonExpandingTreeUI for each look-and-feel that your application supports. The NonExpandingTreeUI would extend the specific UI, rather than the UI in the basic package. For example, a WindowsNonExpandingTreeUI extends the WindowsTreeUI class, MetalNonExpandingTreeUI extends the MetalTreeUI class, and MacNonExpandingTreeUI extends the MacTreeUI class if your application uses the native look-and-feel on Windows and the Macintosh, and the Java look-and-feel on UNIX platforms.</BLOCKQUOTE>
<BLOCKQUOTE>
If multiple UI classes are supported, the registration process with the UIManager changes slightly. Instead of mapping the TreeUI key to the custom UI class key, the TreeUI map- ping is left alone. Instead, the mapping from the look-and-feel class is altered to the cus- tomized class. The following code shows this:</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
try {
    UIManager.put( &quot;javax.swing.plaf.metal.MetalTreeUI&quot;,
        Class.forName(&quot;com.foley.utility.MetalNonExpandingTreeUI&quot;));
    UIManager.put( &quot;com.sun.java.swing.plaf.windows.WindowsTreeUI&quot;,
        Class.forName(&quot;com.foley.utility.WindowsNonExpandingTreeUI&quot;));
    UIManager.put( &quot;com.sun.java.swing.plaf.windows.MacTreeUI&quot;,
        Class.forName( &quot;com.foley.utility.MacNonExpandingTreeUI&quot; ) );
} catch( ClassNotFoundException cnfe ) {
    System.err.println( &quot;NonExpanding Tree UI classes not found&quot; );
    System.err.println( cnfe );
}</PRE>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H4>General Customization Notes</H4>
<P>
In the previous section, a custom look-and-feel class was created
and registered for the <TT>TreeUI</TT>. The customization was
particularly easy because the behavior you wanted to alter was
defined in a method that you could override. This is a good programming
<BR>
technique. Instead of burying implementation details deep in a
method, define them in properties or query them from a &quot;getter&quot;
method that can be overridden by extensions.
<P>
The classes in the basic package use this technique when creating
the behavior of the look-and-feel. Instead of hard coding the
listeners in the class, protected <TT>create</TT> methods are
called. This allows an extension to override the <TT>create</TT>
method and return a custom listener. If the <TT>isToggleEvent</TT>
method was not defined in the <TT>BasicTreeUI</TT> class, you
could have achieved the same result by changing the mouse listener
for the tree. This would have been more complex, as the other
existing behavior needs to remain. However, the hooks are in place
to replace a listener. For example, in the <TT>installUI</TT>
method in the <TT>BasicTreeUI</TT> class, the following lines
appear:
<BLOCKQUOTE>
<PRE>
// Boilerplate install block
installDefaults();
installListeners();
installKeyboardActions();
installComponents();
</PRE>
</BLOCKQUOTE>
<P>
Any of these methods can be overridden to change the feel of the
component with which the UI is used. Looking at the <TT>installListeners</TT>
method shown next shows that a single class of listener can be
changed by overriding the appropriate <TT>create</TT> method.
For the previous example, the <TT>createMouseListener</TT> method
would have to have been overridden to return the custom mouse
listener. This listener would then have implemented the desired
feel.
<BLOCKQUOTE>
<PRE>
protected void installListeners() { 
    if((propertyChangeListener = createPropertyChangeListener())!= null){ 
        tree.addPropertyChangeListener(propertyChangeListener);
    } 
    if ( (mouseListener = createMouseListener()) != null ) { 
        tree.addMouseListener(mouseListener);
    } 
    if ((focusListener = createFocusListener()) != null ) { 
        tree.addFocusListener(focusListener);
    } 
    if ((keyListener = createKeyListener()) != null) { 
        tree.addKeyListener(keyListener);
    } 
    if((treeExpansionListener = createTreeExpansionListener()) != null) { 
        tree.addTreeExpansionListener(treeExpansionListener);
    } 
    if((treeModelListener = createTreeModelListener()) != null &amp;&amp;
           treeModel != null) { 
        treeModel.addTreeModelListener(treeModelListener);
    } 
    if((selectionModelPropertyChangeListener =
        createSelectionModelPropertyChangeListener()) != null &amp;&amp;
        treeSelectionModel != null) { 
        treeSelectionModel.addPropertyChangeListener
          (selectionModelPropertyChangeListener);
    } 
    if((treeSelectionListener = createTreeSelectionListener()) != null &amp;&amp;
        treeSelectionModel != null) { 
        treeSelectionModel.addTreeSelectionListener(treeSelectionListener);
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
The hooks are in place in the basic package to allow fine-grain
customizations of the look-and-feel class. Creating the customized
feel often involves looking at the UI to be customized in the
basic package and determining the proper location to tie the custom
code into the look-and-feel implementation.
<H2><A NAME="CreatingaLookandFeel">
Creating a Look-and-Feel</A></H2>
<P>
In the last chapter and previous sections in this chapter, you
have seen many techniques for customizing the look-and-feel implementations
delivered with the JFC. You have seen how to customize properties
in the <TT>UIDefaults</TT> table maintained by the <TT>UIManager</TT>,
how to register themes when using the Java look-and-feel, and
how to selectively replace user interface implementations. If
this level of customizing does not meet your requirements, an
entire look-and-feel can be developed. You have already seen most
of the techniques required to create a complete look-and-feel.
In this section, the remaining pieces of the puzzle will be presented,
and a look-and-feel will be implemented.
<H3><A NAME="TheTTFONTSIZELookAndFeelFONTTTFONTSIZEClassFONT">
The <TT>LookAndFeel</TT>
Class</A></H3>
<P>
The elements that comprise a look-and-feel are defined in the
<TT>look-and-feel</TT> class. These elements include description
and function methods, as well as a method to create the <TT>UIDefaults</TT>
table for the look-and-feel. You have already seen examples of
the user interface classes for the <TT>ToolTipUI</TT> and <TT>TreeUI</TT>
objects. 
<P>
The look-and-feel class must be an extension of the abstract <TT>javax.swing.LookAndFeel</TT>
class. <TT>LookAndFeel</TT> is a class, not an interface, that
defines the API for a look-and-feel. This class is shown in Listing
23.5. The class contains three types of methods. There are many
<TT>static</TT> convenience methods that are used internally by
Swing, and they are not overridden by extensions. These methods
include the <TT>installColors</TT>, <TT>installColorsAndFont</TT>,
<TT>installBorder</TT>, <TT>uninstallBorder</TT>, <TT>parseKeyStroke</TT>,
<TT>makeKeyBindings</TT>, and <TT>makeIcon</TT> methods. The next
type of methods are the informational methods. These are typically
one-line or very small methods provided by extensions of the <TT>LookAndFeel</TT>
class. The <TT>getName</TT>, <TT>getID</TT>, <TT>getDescription</TT>,
<TT>isNativeLookAndFeel</TT>, and <TT>isSupportedLookAndFeel</TT>
all fall into this category. The final type of methods in the
<TT>LookAndFeel</TT> class are the functional methods. These are
the methods that are called to install and uninstall a look-and-feel.
The <TT>initialize</TT>, <TT>uninitialize</TT>, and <TT>getDefaults</TT>
methods fall into this category.
<P>
<HR>
<P>
<B>Listing 23.5&nbsp;&nbsp;The </B><TT><B>LOOKANDFEEL</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
public abstract class LookAndFeel 
{ 

    /**
     * Convenience method for initializing a component's foreground
     * and background color properties with values from the current
     * defaults table.  The properties are only set if the current
     * value is either null or a UIResource.
     * 
     * @param c the target component for installing default 
     *          color/font properties
     * @param defaultBgName the key for the default background
     * @param defaultFgName the key for the default foreground
     * 
     * @see #installColorsAndFont
     * @see UIManager#getColor
     */
    public static void installColors(JComponent c,
                             String defaultBgName,
                                     String defaultFgName)
    { 
        Color bg = c.getBackground();
      if (bg == null || bg instanceof UIResource) { 
          c.setBackground(UIManager.getColor(defaultBgName));
      } 

        Color fg = c.getForeground();
      if (fg == null || fg instanceof UIResource) { 
          c.setForeground(UIManager.getColor(defaultFgName));
      }  
    } 


    /**
     * Convenience method for initializing a components foreground
     * background and font properties with values from the current
     * defaults table.  The properties are only set if the current
     * value is either null or a UIResource.
     * 
     * @param c the target component for installing default 
     *           color/font properties
     * @param defaultBgName the key for the default background
     * @param defaultFgName the key for the default foreground
     * @param defaultFontName the key for the default font
     * 
     * @see #installColors
     * @see UIManager#getColor
     * @see UIManager#getFont
     */
    public static void installColorsAndFont(JComponent c,
                                         String defaultBgName,
                                         String defaultFgName,
                                         String defaultFontName) { 
        Font f = c.getFont();
      if (f == null || f instanceof UIResource) { 
          c.setFont(UIManager.getFont(defaultFontName));
      } 

      installColors(c, defaultBgName, defaultFgName);
    } 


    /**
     * Convenience method for installing a component's default Border 
     * object on the specified component if either the border is 
     * currently null or already an instance of UIResource.
     * @param c the target component for installing default border
     * @param defaultBorderName the key specifying the default border
     */
    public static void installBorder(JComponent c, 
        String defaultBorderName) { 
        Border b = c.getBorder();
        if (b == null || b instanceof UIResource) { 
            c.setBorder(UIManager.getBorder(defaultBorderName));
        } 
    } 


    /**
     * Convenience method for un-installing a component's default 
     * border on the specified component if the border is 
     * currently an instance of UIResource.
     * @param c the target component for uninstalling default border
     */
    public static void uninstallBorder(JComponent c) { 
        if (c.getBorder() instanceof UIResource) { 
            c.setBorder(null);
        } 
    } 


    /**
     * @see parseKeyStroke
     */
    private static class ModifierKeyword { 
      final String keyword;
      final int mask;
      ModifierKeyword(String keyword, int mask) { 
          this.keyword = keyword;
          this.mask = mask;
      } 
      int getModifierMask(String s) { 
          return (s.equals(keyword)) ? mask : 0;
      } 
    } ;


    /**
     * @see parseKeyStroke
     */
    private static ModifierKeyword[] modifierKeywords = { 
      new ModifierKeyword(&quot;shift&quot;, InputEvent.SHIFT_MASK),
      new ModifierKeyword(&quot;control&quot;, InputEvent.CTRL_MASK),
      new ModifierKeyword(&quot;meta&quot;, InputEvent.META_MASK),
      new ModifierKeyword(&quot;alt&quot;, InputEvent.ALT_MASK),
      new ModifierKeyword(&quot;button1&quot;, InputEvent.BUTTON1_MASK),
      new ModifierKeyword(&quot;button2&quot;, InputEvent.BUTTON2_MASK),
      new ModifierKeyword(&quot;button3&quot;, InputEvent.BUTTON3_MASK)
    } ;


    /**
     * Parse a string with the following syntax and return an 
     * a KeyStroke:
     * &lt;pre&gt;
     *    &quot;&amp;lt;modifiers&amp;gt;* &amp;lt;key&amp;gt;&quot;
     *    modifiers := shift | control | meta | alt | 
     *                 button1 | button2 | button3
     *    key := KeyEvent keycode name, i.e. the name following &quot;VK_&quot;.
     * &lt;/pre&gt;
     * Here are some examples:
     * &lt;pre&gt;
     *     &quot;INSERT&quot; =&gt; new KeyStroke(0, KeyEvent.VK_INSERT);
     *     &quot;control DELETE&quot; =&gt; new KeyStroke(InputEvent.CTRL_MASK, 
     *                                       KeyEvent.VK_DELETE);
     *     &quot;alt shift X&quot; =&gt; new KeyStroke(InputEvent.CTRL_MASK | 
                                InputEvent.SHIFT_MASK, KeyEvent.VK_X);
     * &lt;/pre&gt;
     */
    private static KeyStroke parseKeyStroke(String s) 
    { 
      StringTokenizer st = new StringTokenizer(s);
      String token;
      int mask = 0;

      while((token = st.nextToken()) != null) { 
          int tokenMask = 0;

          /* if token matches a modifier keyword update mask and continue */

          for(int i = 0; (tokenMask == 0) &amp;&amp; 
              (i &lt; modifierKeywords.length); i++) { 
            tokenMask = modifierKeywords[i].getModifierMask(token);
          } 

          if (tokenMask != 0) { 
            mask |= tokenMask;
            continue;
          }

          /* otherwise token is the keycode name less the &quot;VK_&quot; prefix */

          String keycodeName = &quot;VK_&quot; + token; 
          int keycode;
          try { 
            keycode = KeyEvent.class.getField(keycodeName).getInt(KeyEvent.class);
          } 
          catch (Exception e) { 
            e.printStackTrace();
            throw new Error(&quot;Unrecognized keycode name: &quot; + keycodeName);
          } 

          return KeyStroke.getKeyStroke(keycode, mask);
      } 

      throw new Error(&quot;Can't parse KeyStroke: \ &quot;&quot; + s + &quot;\ &quot;&quot;);
    } 


    /**
     * Convenience method for building lists of KeyBindings.
     * &lt;p&gt;
     * Return an array of KeyBindings, one for each KeyStroke,Action pair
     * in &lt;b&gt;keyBindingList&lt;/b&gt;.  A KeyStroke can either be a string in
     * the format specified by &lt;code&gt;parseKeyStroke&lt;/code&gt; or a KeyStroke
     * object.  Actions are strings.  Here's an example:
     * &lt;pre&gt;
     *      JTextComponent.KeyBinding[] multilineBindings = 
     *                makeKeyBindings( new Object[] { 
     *          &quot;UP&quot;, DefaultEditorKit.upAction,
     *        &quot;DOWN&quot;, DefaultEditorKit.downAction,
     *     &quot;PAGE_UP&quot;, DefaultEditorKit.pageUpAction,
     *   &quot;PAGE_DOWN&quot;, DefaultEditorKit.pageDownAction,
     *       &quot;ENTER&quot;, DefaultEditorKit.insertBreakAction,
     *         &quot;TAB&quot;, DefaultEditorKit.insertTabAction
     *  } );
     * 
     * &lt;/pre&gt;
     * @see #parseKeyStroke
     * @return an array of KeyBindings
     * @param keyBindingList an array of KeyStroke,Action pairs
     */
    public static JTextComponent.KeyBinding[] 
           makeKeyBindings(Object[] keyBindingList) 
    { 
      JTextComponent.KeyBinding[] rv = 
             new JTextComponent.KeyBinding[keyBindingList.length / 2];

      for(int i = 0; i &lt; keyBindingList.length; i += 2) { 
          KeyStroke keystroke = (keyBindingList[i] instanceof KeyStroke)
            ? (KeyStroke)keyBindingList[i]
            : parseKeyStroke((String)keyBindingList[i]);
          String action = (String)keyBindingList[i+1];
          rv[i / 2] = new JTextComponent.KeyBinding(keystroke, action);
      } 

      return rv;
    } 


    /**
     * Utility method that creates a UIDefaults.LazyValue that creates
     * an ImageIcon UIResource for the specified &lt;code&gt;gifFile&lt;/code&gt;
     * filename.
     */
    public static Object makeIcon(final Class baseClass, 
                                  final String gifFile) { 
      return new UIDefaults.LazyValue() { 
          public Object createValue(UIDefaults table) { 
                byte[] buffer = null;
                try { 
                    /* Copy resource into a byte array.  This is
                     * necessary because several browsers consider
                     * Class.getResource a security risk because it
                     * can be used to load additional classes.
                     * Class.getResourceAsStream just returns raw
                     * bytes, which we can convert to an image.
                     */
                    InputStream resource = 
                        baseClass.getResourceAsStream(gifFile);
                    if (resource == null) { 
                        System.err.println(baseClass.getName() + &quot;/&quot; + 
                                           gifFile + &quot; not found.&quot;);
                        return null; 
                    } 
                    BufferedInputStream in = 
                        new BufferedInputStream(resource);
                    ByteArrayOutputStream out = 
                        new ByteArrayOutputStream(1024);
                    buffer = new byte[1024];
                    int n;
                    while ((n = in.read(buffer)) &gt; 0) { 
                        out.write(buffer, 0, n);
                    }
                    in.close();
                    out.flush();

                    buffer = out.toByteArray();
                    if (buffer.length == 0) { 
                        System.err.println(&quot;warning: &quot; + gifFile + 
                                           &quot; is zero-length&quot;);
                        return null;
                    } 
                }  catch (IOException ioe) { 
                    System.err.println(ioe.toString());
                    return null;
                } 

                return new IconUIResource(new ImageIcon(buffer));
          } 
      } ;
    } 

    /**
     * Return a short string that identifies this look and feel, e.g.
     * &quot;CDE/Motif&quot;.  This string should be appropriate for a menu item.
     * Distinct look and feels should have different names, e.g. 
     * a subclass of MotifLookAndFeel that changes the way a few 
     * components are rendered should be called &quot;CDE/Motif My Way&quot;; 
     * something that would be useful to a user trying to select a 
     * L&amp;F from a list of names.
     */
    public abstract String getName();


    /**
     * Return a string that identifies this look and feel.  This string 
     * will be used by applications/services that want to recognize
     * well known look and feel implementations.  Presently
     * the well known names are &quot;Motif&quot;, &quot;Windows&quot;, &quot;Mac&quot;, &quot;Metal&quot;.  Note
     * that a LookAndFeel derived from a well known superclass 
     * that doesn't make any fundamental changes to the look or feel 
     * shouldn't override this method.
     */
    public abstract String getID();


    /** 
     * Return a one line description of this look and feel 
     * implementation, e.g. &quot;The CDE/Motif Look and Feel&quot;. 
     * This string is intended for the user, e.g. in the title 
     * of a window or in a ToolTip message.
     */
    public abstract String getDescription();


    /**
     * If the underlying platform has a &quot;native&quot; look and feel, and this
     * is an implementation of it, return true.  For example a CDE/Motif
     * look and implementation would return true when the underlying 
     * platform was Solaris.
     */
    public abstract boolean isNativeLookAndFeel();


    /**
     * Return true if the underlying platform supports and or permits
     * this look and feel.  This method returns false if the look 
     * and feel depends on special resources or legal agreements that
     * aren't defined for the current platform.  
     * 
     * @see UIManager#setLookAndFeel
     */
    public abstract boolean isSupportedLookAndFeel();


    /**
     * UIManager.setLookAndFeel calls this method before the first
     * call (and typically the only call) to getDefaults().  Subclasses
     * should do any one-time setup they need here, rather than 
     * in a static initializer, because look and feel class objects
     * may be loaded just to discover that isSupportedLookAndFeel()
     * returns false.
     *
     * @see #uninitialize
     * @see UIManager#setLookAndFeel
     */
    public void initialize() { 
    } 


    /**
     * UIManager.setLookAndFeel calls this method just before we're
     * replaced by a new default look and feel.   Subclasses may 
     * choose to free up some resources here.
     *
     * @see #initialize
     */
    public void uninitialize() { 
    } 

    /**
     * This method is called once by UIManager.setLookAndFeel to create
     * the look and feel specific defaults table.  Other applications,
     * for example an application builder, may also call this method.
     *
     * @see #initialize
     * @see #uninitialize
     * @see UIManager#setLookAndFeel
     */
    public UIDefaults getDefaults() { 
        return null;
    } 

    public String toString() { 
        return &quot;[&quot; + getDescription() + &quot; - &quot; + getClass().getName() + &quot;]&quot;;
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Creating a <TT>LookAndFeel</TT> Class</H4>
<P>
The first decision to make when creating a <TT>LookAndFeel</TT>
class is to determine which class to extend. As already pointed
out, the class must be a descendant of the <TT>LookAndFeel</TT>
class that can be extended directly. However, a more common approach
is to extend the <TT>BasicLookAndFeel</TT> class in the <TT>javax.swing.plaf.basic</TT>
package. Even if the <TT>LookAndFeel</TT> class is extended directly,
the programming techniques in the <TT>BasicLookAndFeel</TT> class
should be reviewed. This class provides a good example of a class
that allows extensions to easily alter only the portions that
they need to change. The look-and-feel implementations shipped
with the JFC extend the <TT>BasicLookAndFeel</TT> class, as will
be seen in the example in this section.
<H4>The Informational Methods</H4>
<P>
Regardless of which class your look-and-feel class extends, the
informational methods must be provided. These methods are also
easy to implement. For most custom look-and-feel implementations,
these will be simple one-line methods. These methods for the <TT>UnleashedLookAndFeel</TT>
are shown in Listing 23.6. Look-and-feel implementations that
extend a concrete existing look-and-feel such as Metal should
not override the <TT>getID</TT> method unless they make substantial
changes to the look-and-feel. The <TT>UnleashedLookAndFeel</TT>
look-and-feel does not fall into this category, so the <TT>getID</TT>
method is overridden to return a unique ID for this look-and-feel.
The name and description for the look-and-feel can be any strings
that accurately describe the look-and-feel. The name should be
unique from the collection of known look-and-feel implementations.
Unless you are creating a better look-and-feel for one of the
supported platforms, which really wouldn't be that difficult,
your look-and-feel will return <TT>false</TT> from the <TT>isNativeLookAndFeel</TT>
method. Finally, unless you want to restrict the platforms where
your look-and-feel can execute, your <TT>LookAndFeel</TT> class
should return <TT>true</TT> from the <TT>isSupportedLookAndFeel</TT>
method.
<P>
<HR>
<P>
<B>Listing 23.6&nbsp;&nbsp;</B><TT><B>UNLEASHEDLOOKANDFEEL</B></TT><B>
Informational Methods<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * @return The name for this look-and-feel.     
 **/
public String getName() { 
    return &quot;Unleashed&quot;;
} 


/**
 * We are not a simple extension of an existing
 * look-and-feel, so provide our own ID.
 * &lt;p&gt;
 * @return The ID for this look-and-feel.     
 **/
public String getID() { 
    return &quot;Unleashed&quot;;
} 


/**
 * @return A short description of this look-and-feel.
 **/
public String getDescription() { 
    return &quot;The JFC Unleashed Look and Feel&quot;;
} 

    
/**
 * This is not a native look and feel on any platform.
 * &lt;p&gt;
 * @return false, this isn't native on any platform.
**/
public boolean isNativeLookAndFeel() { 
    return false;
} 


/**
 * This look and feel is supported on all platforms.
 * &lt;p&gt;
 * @return true, this L&amp;F is supported on all platforms.
 **/
public boolean isSupportedLookAndFeel() { 
    return true;
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>The Functional Methods</H4>
<P>
Recall that the <TT>LookAndFeel</TT> class defines three functional
methods: <TT>initialize</TT>, <TT>uninitialize</TT>, and <TT>getDefaults</TT>.
However, these are not abstract methods. Each contains an empty
implementation. The <TT>initialize</TT> method is a hook that
allows the look-and-feel to perform any required initialization
tasks. This method is called by the <TT>UIManager</TT> before
the <TT>getDefaults</TT> method is called. The <TT>uninitialize</TT>
method is called by the <TT>UIManager</TT> before a different
look-and-feel replaces this look-and-feel and provides a hook
to do any post-processing required by the look-and-feel. If any
resources were allocated in the <TT>initialize</TT> method, they
should be released in the <TT>uninitialize</TT> method. The current
look-and-feel implementations that are part of the JFC do not
perform any processing in these methods, nor will the Unleashed
look-and-feel implementation. Thus these methods are not overridden.
<P>
That leaves the <TT>getDefaults</TT> methods. In this method the
look-and-feel must create and initialize the <TT>UIDefaults</TT>
object for the look-and-feel. Recall that the <TT>UIDefaults</TT>
class is an extension of the <TT>Hashtable</TT> class. It maps
component properties to values. The <TT>UIDefaults</TT> object
is fundamental to the customizability features inherent in the
JFC. You have seen how application code can change a property
to alter the look of a component. This technique should be adhered
to when creating your own look-and-feel. Under no circumstances
should a developer hard code fonts, colors, or similar properties
in a component.
<P>
As you saw earlier in this chapter, the standard look-and-feel
implementations that are part of the Java platform define many
properties for each component. Your look-and-feel implementation
should use these properties whenever feasible. It is acceptable
to define new properties that are specific to the new look-and-feel
implementation. However, a new property that has the same meaning
as an existing property should not be defined. Also, an existing
property should not be redefined for a different use in your look-and-feel.
<P>
The <TT>BasicLookAndFeel</TT> class further divides the <TT>getDefaults</TT>
method into class, system, and component defaults. This is shown
in the <TT>getDefaults</TT> method contained in the <TT>BasicLookAndFeel</TT>
class shown next. When extending the <TT>BasicLookAndFeel</TT>
class, only the methods called from this method need to be overridden
in the subclass.
<BLOCKQUOTE>
<PRE>
public UIDefaults getDefaults() { 
        UIDefaults table = new UIDefaults();

        initClassDefaults(table);
        initSystemColorDefaults(table);
        initComponentDefaults(table);

        return table;
} 
</PRE>
</BLOCKQUOTE>
<P>
<B>The </B><TT><B>BasicLookAndFeel</B></TT><B>
</B><TT><B>initClassDefaults</B></TT><B>
Method</B>
<P>
The <TT>initClassDefaults</TT> method registers the <TT>uiClassID</TT>
strings to the class key. You previously saw how this table is
used by the <TT>UIManager</TT> to determine which class to use
as the UI object for a component. This method for the <TT>BasicLookAndFeel</TT>
class is shown in Listing 23.7. To create a look-and-feel that
provides an implementation for every UI class, an implementation
is required for each entry in this table. This gives a graphic
example of how much work is required to create a complete look-and-feel.
<P>
<HR>
<P>
<B>Listing 23.7&nbsp;&nbsp;The </B><TT><B>BASICLOOKANDFEEL</B></TT><B>
Class' </B><TT><B>INITCLASSDEFAULTS</B></TT><B>
Method<BR>
</B>
<BLOCKQUOTE>
<PRE>
protected void initClassDefaults(UIDefaults table) { 
    String basicPackageName = &quot;com.sun.java.swing.plaf.basic.&quot;;
        Object[] uiDefaults = { 
        &quot;ButtonUI&quot;, basicPackageName + &quot;BasicButtonUI&quot;,
        &quot;CheckBoxUI&quot;, basicPackageName + &quot;BasicCheckBoxUI&quot;,
        &quot;ColorChooserUI&quot;, basicPackageName + &quot;BasicColorChooserUI&quot;,
        &quot;MenuBarUI&quot;, basicPackageName + &quot;BasicMenuBarUI&quot;,
        &quot;MenuUI&quot;, basicPackageName + &quot;BasicMenuUI&quot;,
        &quot;MenuItemUI&quot;, basicPackageName + &quot;BasicMenuItemUI&quot;,
        &quot;CheckBoxMenuItemUI&quot;, 
                basicPackageName + &quot;BasicCheckBoxMenuItemUI&quot;,
        &quot;RadioButtonMenuItemUI&quot;, 
                basicPackageName + &quot;BasicRadioButtonMenuItemUI&quot;,
        &quot;RadioButtonUI&quot;, basicPackageName + &quot;BasicRadioButtonUI&quot;,
        &quot;ToggleButtonUI&quot;, basicPackageName + &quot;BasicToggleButtonUI&quot;,
        &quot;PopupMenuUI&quot;, basicPackageName + &quot;BasicPopupMenuUI&quot;,
        &quot;ProgressBarUI&quot;, basicPackageName + &quot;BasicProgressBarUI&quot;,
        &quot;ScrollBarUI&quot;, basicPackageName + &quot;BasicScrollBarUI&quot;,
        &quot;ScrollPaneUI&quot;, basicPackageName + &quot;BasicScrollPaneUI&quot;,
        &quot;SplitPaneUI&quot;, basicPackageName + &quot;BasicSplitPaneUI&quot;,
        &quot;SliderUI&quot;, basicPackageName + &quot;BasicSliderUI&quot;,
        &quot;SeparatorUI&quot;, basicPackageName + &quot;BasicSeparatorUI&quot;,
        &quot;ToolBarSeparatorUI&quot;, 
                basicPackageName + &quot;BasicToolBarSeparatorUI&quot;,
        &quot;PopupMenuSeparatorUI&quot;, 
                basicPackageName + &quot;BasicPopupMenuSeparatorUI&quot;,
        &quot;TabbedPaneUI&quot;, basicPackageName + &quot;BasicTabbedPaneUI&quot;,
        &quot;TextAreaUI&quot;, basicPackageName + &quot;BasicTextAreaUI&quot;,
        &quot;TextFieldUI&quot;, basicPackageName + &quot;BasicTextFieldUI&quot;,
        &quot;PasswordFieldUI&quot;, basicPackageName + &quot;BasicPasswordFieldUI&quot;,
        &quot;TextPaneUI&quot;, basicPackageName + &quot;BasicTextPaneUI&quot;,
        &quot;EditorPaneUI&quot;, basicPackageName + &quot;BasicEditorPaneUI&quot;,
        &quot;TreeUI&quot;, basicPackageName + &quot;BasicTreeUI&quot;,
        &quot;LabelUI&quot;, basicPackageName + &quot;BasicLabelUI&quot;,
        &quot;ListUI&quot;, basicPackageName + &quot;BasicListUI&quot;,
        &quot;ToolBarUI&quot;, basicPackageName + &quot;BasicToolBarUI&quot;,
        &quot;ToolTipUI&quot;, basicPackageName + &quot;BasicToolTipUI&quot;,
        &quot;ComboBoxUI&quot;, basicPackageName + &quot;BasicComboBoxUI&quot;,
        &quot;TableUI&quot;, basicPackageName + &quot;BasicTableUI&quot;,
        &quot;TableHeaderUI&quot;, basicPackageName + &quot;BasicTableHeaderUI&quot;,
        &quot;InternalFrameUI&quot;, basicPackageName + &quot;BasicInternalFrameUI&quot;,
        &quot;StandardDialogUI&quot;, basicPackageName + &quot;BasicStandardDialogUI&quot;,
        &quot;DesktopPaneUI&quot;, basicPackageName + &quot;BasicDesktopPaneUI&quot;,
        &quot;DesktopIconUI&quot;, basicPackageName + &quot;BasicDesktopIconUI&quot;,
        &quot;OptionPaneUI&quot;, basicPackageName + &quot;BasicOptionPaneUI&quot;,
        &quot;PanelUI&quot;, basicPackageName + &quot;BasicPanelUI&quot;,
        &quot;ViewportUI&quot;, basicPackageName + &quot;BasicViewportUI&quot;,
        } ;

        table.putDefaults(uiDefaults);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>The BasicLookAndFeel initSystemColorDefaults Method</B>
<BLOCKQUOTE>
The <TT>initSystemColorDefaults</TT> method registers the system
color default values. The <TT>BasicLookAndFeel</TT> class' implementation
of this method is shown in Listing 23.8. When extending the <TT>BasicLookAndFeel</TT>,
these colors can be used as is, selectively modified, or totally
replaced. To change a color, register a new value with the same
key shown in the <TT>initSystemColorDefaults</TT> method. UI objects
that require a system color in your look-and-feel should obtain
the color from the <TT>UIDefaults</TT> object to ensure that,
when the value changes, the correct color is used.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 23.8&nbsp;&nbsp;The </B><TT><B>BASICLOOKANDFEEL</B></TT><B>
</B><TT><B>INITSYSTEMCOLORDEFAULTS</B></TT><B>
Method<BR>
</B>
<BLOCKQUOTE>
<PRE>
protected void initSystemColorDefaults(UIDefaults table) { 
    String[] defaultSystemColors = { 
        /* Color of the desktop background */
        &quot;desktop&quot;, &quot;#005C5C&quot;, 
        /* Color for captions (title bars) when they are active. */
        &quot;activeCaption&quot;, &quot;#000080&quot;, 
        /* Text color for text in captions (title bars). */
        &quot;activeCaptionText&quot;, &quot;#FFFFFF&quot;, 
        /* Border color for caption (title bar) window borders. */
        &quot;activeCaptionBorder&quot;, &quot;#C0C0C0&quot;, 
        /* Color for captions (title bars) when not active. */
        &quot;inactiveCaption&quot;, &quot;#808080&quot;, 
        /* Text color for text in inactive captions (title bars). */
        &quot;inactiveCaptionText&quot;, &quot;#C0C0C0&quot;, 
        /*Border color for inactive caption (title bar) window borders.*/
        &quot;inactiveCaptionBorder&quot;, &quot;#C0C0C0&quot;, 
        /* Default color for the interior of windows */
        &quot;window&quot;, &quot;#FFFFFF&quot;, 
        /* ??? */
        &quot;windowBorder&quot;, &quot;#000000&quot;, 
        /* ??? */
        &quot;windowText&quot;, &quot;#000000&quot;, 
        /* Background color for menus */
        &quot;menu&quot;, &quot;#C0C0C0&quot;, 
        /* Text color for menus  */
        &quot;menuText&quot;, &quot;#000000&quot;, 
        /* Text background color */
        &quot;text&quot;, &quot;#C0C0C0&quot;, 
        /* Text foreground color */
        &quot;textText&quot;, &quot;#000000&quot;, 
        /* Text background color when selected */
        &quot;textHighlight&quot;, &quot;#000080&quot;, 
        /* Text color when selected */
        &quot;textHighlightText&quot;, &quot;#FFFFFF&quot;, 
        /* Text color when disabled */
        &quot;textInactiveText&quot;, &quot;#808080&quot;, 
        /* Default color for controls (buttons, sliders, etc) */
        &quot;control&quot;, &quot;#C0C0C0&quot;, 
        /* Default color for text in controls */
        &quot;controlText&quot;, &quot;#000000&quot;, 
        /* ??? */
        &quot;controlHighlight&quot;, &quot;#C0C0C0&quot;,
        /* Highlight color for controls */
        &quot;controlLtHighlight&quot;, &quot;#FFFFFF&quot;, 
        /* Shadow color for controls */
        &quot;controlShadow&quot;, &quot;#808080&quot;, 
        /* Dark shadow color for controls */
        &quot;controlDkShadow&quot;, &quot;#000000&quot;, 
        /* Scrollbar background (usually the &quot;track&quot;) */
        &quot;scrollbar&quot;, &quot;#E0E0E0&quot;, 
        /* ??? */
        &quot;info&quot;, &quot;#FFFFE1&quot;, 
        /* ??? */
        &quot;infoText&quot;, &quot;#000000&quot;  
    } ;

    loadSystemColors(table, defaultSystemColors, isNativeLookAndFeel());
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>The BasicLookAndFeel initComponentDefaults Method</B>
<BLOCKQUOTE>
The final method in the <TT>getDefaults</TT> method is the <TT>initComponentDefaults</TT>
method. In this method, the properties for the components contained
in the look-and-feel are registered with the <TT>UIDefaults</TT>
object. It is in this method that the properties you modified
earlier in this section get defined and are given default values.
As with the other default properties, your look-and-feel should
not redefine the standard properties defined in this method. For
example, it would be a mistake to change the key <TT>CheckBox.font</TT>
to <TT>CheckBox.Font</TT> to specify the font in a check box in
a new look-and-feel. However, your look-and-feel may need to define
additional keys to define properties that are new for your look-and-feel
implementation. The <TT>initComponentDefaults</TT> method contained
in the <TT>BasicLookAndFeel</TT> class is shown in Listing 23.9.
The size of this method shows the number and depth of properties
defined in a look-and-feel. It shows how many properties can be
customized without creating a look-and-feel and may give pause
to the decision to create a new look-and-feel.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 23.9&nbsp;&nbsp;The </B><TT><B>BASICLOOKANDFEEL</B></TT><B>
</B><TT><B>INITCOMPONENTDEFAULTS</B></TT><B>
Method<BR>
</B>
<BLOCKQUOTE>
<PRE>
protected void initComponentDefaults(UIDefaults table) { 

    // *** Shared Fonts
    FontUIResource dialogPlain12 =
            new FontUIResource(&quot;Dialog&quot;, Font.PLAIN, 12);
    FontUIResource serifPlain12 =
            new FontUIResource(&quot;Serif&quot;, Font.PLAIN, 12);
    FontUIResource sansSerifPlain12 =
            new FontUIResource(&quot;SansSerif&quot;, Font.PLAIN, 12);
    FontUIResource monospacedPlain12 =
            new FontUIResource(&quot;Monospaced&quot;, Font.PLAIN, 12);
    FontUIResource dialogBold12 =
            new FontUIResource(&quot;Dialog&quot;, Font.BOLD, 12);

    // *** Shared Colors
    ColorUIResource red = new ColorUIResource(Color.red);
    ColorUIResource black = new ColorUIResource(Color.black);
    ColorUIResource white = new ColorUIResource(Color.white);
    ColorUIResource yellow = new ColorUIResource(Color.yellow);
    ColorUIResource gray = new ColorUIResource(Color.gray);
    ColorUIResource lightGray = new ColorUIResource(Color.lightGray);
    ColorUIResource darkGray = new ColorUIResource(Color.darkGray);
    ColorUIResource scrollBarTrack = new ColorUIResource(224, 224, 224);

    // *** Shared Insets
    InsetsUIResource zeroInsets = new InsetsUIResource(0,0,0,0);

    // *** Shared Borders
    Border zeroBorder =
            new BorderUIResource.EmptyBorderUIResource(0,0,0,0);
    Border marginBorder = new BasicBorders.MarginBorder();
    Border etchedBorder = BorderUIResource.getEtchedBorderUIResource();
    Border loweredBevelBorder =
            BorderUIResource.getLoweredBevelBorderUIResource();
    Border raisedBevelBorder =
            BorderUIResource.getRaisedBevelBorderUIResource();
    Border blackLineBorder =
            BorderUIResource.getBlackLineBorderUIResource();
    Border focusCellHighlightBorder =
            new BorderUIResource.LineBorderUIResource(yellow);


    // *** Button value objects

    Object buttonBorder = new BorderUIResource.CompoundBorderUIResource(
                            new BasicBorders.ButtonBorder(
                                   table.getColor(&quot;controlShadow&quot;),
                                   table.getColor(&quot;controlDkShadow&quot;),
                                   table.getColor(&quot;controlHighlight&quot;),
                                   table.getColor(&quot;controlLtHighlight&quot;)),
                            marginBorder);

    Object buttonToggleBorder =
        new BorderUIResource.CompoundBorderUIResource(
                     new BasicBorders.ToggleButtonBorder(
                                   table.getColor(&quot;controlShadow&quot;),
                                   table.getColor(&quot;controlDkShadow&quot;),
                                   table.getColor(&quot;controlHighlight&quot;),
                                   table.getColor(&quot;controlLtHighlight&quot;)),
                     marginBorder);

    Object radioButtonBorder =
        new BorderUIResource.CompoundBorderUIResource(
                     new BasicBorders.RadioButtonBorder(
                                   table.getColor(&quot;controlShadow&quot;),
                                   table.getColor(&quot;controlDkShadow&quot;),
                                   table.getColor(&quot;controlHighlight&quot;),
                                   table.getColor(&quot;controlLtHighlight&quot;)),
                     marginBorder);


    // *** FileChooser / FileView value objects

    Object newFolderIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/NewFolder.gif&quot;);

    Object upFolderIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/UpFolder.gif&quot;);

    Object homeFolderIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/HomeFolder.gif&quot;);

    Object detailsViewIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/DetailsView.gif&quot;);

    Object listViewIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/ListView.gif&quot;);

    Object directoryIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/Directory.gif&quot;);

    Object fileIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/File.gif&quot;);

    Object computerIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/Computer.gif&quot;);

    Object hardDriveIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/HardDrive.gif&quot;);

    Object floppyDriveIcon = LookAndFeel.makeIcon(getClass(),
                                        &quot;icons/FloppyDrive.gif&quot;);


    // *** InternalFrame value objects

    Object internalFrameBorder = new UIDefaults.LazyValue() { 
      public Object createValue(UIDefaults table) { 
        return new BorderUIResource.CompoundBorderUIResource(
                new BevelBorder(BevelBorder.RAISED,
                    table.getColor(&quot;controlHighlight&quot;),
                                table.getColor(&quot;controlLtHighlight&quot;),
                                table.getColor(&quot;controlDkShadow&quot;),
                                table.getColor(&quot;controlShadow&quot;)),
                BorderFactory.createLineBorder(
                    table.getColor(&quot;control&quot;), 1));
      } 
    } ;


    // *** List value objects

    Object listCellRendererActiveValue = new UIDefaults.ActiveValue() { 
        public Object createValue(UIDefaults table) { 
        return new DefaultListCellRenderer.UIResource();
        } 
    } ;


    // *** Menus value objects

    Object menuBarBorder = new BasicBorders.MenuBarBorder(
                                table.getColor(&quot;controlShadow&quot;),
                                table.getColor(&quot;controlLtHighlight&quot;));


    Object menuItemCheckIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getMenuItemCheckIcon();
        } 
    } ;

    Object menuItemArrowIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getMenuItemArrowIcon();
        } 
    } ;

    Object menuArrowIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getMenuArrowIcon();
        } 
    } ;

    Object checkBoxIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getCheckBoxIcon();
        } 
    } ;

    Object radioButtonIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getRadioButtonIcon();
        } 
    } ;


    Object checkBoxMenuItemIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getCheckBoxMenuItemIcon();
        } 
    } ;

    Object radioButtonMenuItemIcon = new UIDefaults.LazyValue() { 
        public Object createValue(UIDefaults table) { 
        return BasicIconFactory.getRadioButtonMenuItemIcon();
        } 
    } ;


    // *** OptionPane value objects
    Object optionPaneMinimumSize = new DimensionUIResource(262, 90);
    Object optionPaneBorder =
        new BorderUIResource.EmptyBorderUIResource(10, 10, 12, 10);
    Object optionPaneButtonAreaBorder =
        new BorderUIResource.EmptyBorderUIResource(6,0,0,0);

    // *** ProgessBar value objects
    Object progressBarBorder =
        new BorderUIResource.LineBorderUIResource(Color.green, 2);

    // ** ScrollBar value objects
    Object minimumThumbSize = new UIDefaults.LazyValue() { 
      public Object createValue(UIDefaults table) { 
        return new DimensionUIResource(8,8);
      } ;
    } ;

    Object maximumThumbSize = new UIDefaults.LazyValue() { 
      public Object createValue(UIDefaults table) { 
        return new DimensionUIResource(4096,4096);
      } ;
    } ;


    // ** Slider value objects
    Object sliderFocusInsets = new InsetsUIResource( 2, 2, 2, 2 );
    Object toolBarSeparatorSize = new DimensionUIResource( 10, 10 );

    // *** SplitPane value objects
    Object splitPaneBorder = new BasicBorders.SplitPaneBorder(
                               table.getColor(&quot;controlLtHighlight&quot;),
                               table.getColor(&quot;controlDkShadow&quot;));

    // ** TabbedBane value objects
    Object tabbedPaneTabInsets = new InsetsUIResource(2, 4, 2, 4);
    Object tabbedPaneTabPadInsets = new InsetsUIResource(2, 2, 2, 1);
    Object tabbedPaneTabAreaInsets = new InsetsUIResource(3, 2, 0, 2);
    Object tabbedPaneContentBorderInsets =
                    new InsetsUIResource(2, 2, 3, 3);


    // *** Text value objects
    Object textFieldBorder = new BasicBorders.FieldBorder(
                                   table.getColor(&quot;controlShadow&quot;),
                                   table.getColor(&quot;controlDkShadow&quot;),
                                   table.getColor(&quot;controlHighlight&quot;),
                                   table.getColor(&quot;controlLtHighlight&quot;));

    Object editorMargin = new InsetsUIResource(3,3,3,3);

    JTextComponent.KeyBinding[] fieldBindings = makeKeyBindings(
        new Object[]{ 
            &quot;ENTER&quot;, JTextField.notifyAction
        } 
    );

    JTextComponent.KeyBinding[] multilineBindings =
        makeKeyBindings( new Object[]{ 
          &quot;UP&quot;, DefaultEditorKit.upAction,
        &quot;DOWN&quot;, DefaultEditorKit.downAction,
         &quot;PAGE_UP&quot;, DefaultEditorKit.pageUpAction,
       &quot;PAGE_DOWN&quot;, DefaultEditorKit.pageDownAction,
           &quot;ENTER&quot;, DefaultEditorKit.insertBreakAction,
         &quot;TAB&quot;, DefaultEditorKit.insertTabAction
        } 
    );

    Object caretBlinkRate = new Integer(500);

    // *** Component Defaults
    Object[] defaults = { 

        // *** Buttons
        &quot;Button.font&quot;, dialogPlain12,
        &quot;Button.background&quot;, table.get(&quot;control&quot;),
        &quot;Button.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;Button.border&quot;, buttonBorder,
        &quot;Button.margin&quot;, new InsetsUIResource(2, 14, 2, 14),
        &quot;Button.textIconGap&quot;, new Integer(4),
        &quot;Button.textShiftOffset&quot;, new Integer(0),

        &quot;ToggleButton.font&quot;, dialogPlain12,
        &quot;ToggleButton.background&quot;, table.get(&quot;control&quot;),
        &quot;ToggleButton.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;ToggleButton.border&quot;, buttonToggleBorder,
        &quot;ToggleButton.margin&quot;, new InsetsUIResource(2, 14, 2, 14),
        &quot;ToggleButton.textIconGap&quot;, new Integer(4),
        &quot;ToggleButton.textShiftOffset&quot;, new Integer(0),

        &quot;RadioButton.font&quot;, dialogPlain12,
        &quot;RadioButton.background&quot;, table.get(&quot;control&quot;),
        &quot;RadioButton.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;RadioButton.border&quot;, radioButtonBorder,
        &quot;RadioButton.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;RadioButton.textIconGap&quot;, new Integer(4),
        &quot;RadioButton.textShiftOffset&quot;, new Integer(0),
        &quot;RadioButton.icon&quot;, radioButtonIcon,

        &quot;CheckBox.font&quot;, dialogPlain12,
        &quot;CheckBox.background&quot;, table.get(&quot;control&quot;),
        &quot;CheckBox.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;CheckBox.border&quot;, radioButtonBorder,
        &quot;CheckBox.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;CheckBox.textIconGap&quot;, new Integer(4),
        &quot;CheckBox.textShiftOffset&quot;, new Integer(0),
        &quot;CheckBox.icon&quot;, checkBoxIcon,

        // *** ColorChooser
        &quot;ColorChooser.font&quot;, dialogPlain12,
        &quot;ColorChooser.background&quot;, table.get(&quot;control&quot;),
        &quot;ColorChooser.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;ColorChooser.selectedColorBorder&quot;, loweredBevelBorder,

        // *** ComboBox
        &quot;ComboBox.font&quot;, dialogPlain12,
        &quot;ComboBox.background&quot;, white,
        &quot;ComboBox.foreground&quot;, black,
        &quot;ComboBox.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;ComboBox.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;ComboBox.disabledBackground&quot;, table.get(&quot;control&quot;),
        &quot;ComboBox.disabledForeground&quot;, table.get(&quot;textInactiveText&quot;),

        // *** FileChooser
        &quot;FileChooser.acceptAllFileFilterText&quot;,
                new String (&quot;All Files (*.*)&quot;),
        &quot;FileChooser.cancelButtonText&quot;, new String(&quot;Cancel&quot;),
        &quot;FileChooser.saveButtonText&quot;, new String(&quot;Save&quot;),
        &quot;FileChooser.openButtonText&quot;, new String(&quot;Open&quot;),
        &quot;FileChooser.updateButtonText&quot;, new String(&quot;Update&quot;),
        &quot;FileChooser.helpButtonText&quot;, new String(&quot;Help&quot;),
        &quot;FileChooser.cancelButtonToolTipText&quot;,
                new String(&quot;Abort file chooser dialog.&quot;),
        &quot;FileChooser.saveButtonToolTipText&quot;,
                new String(&quot;Save selected file.&quot;),
        &quot;FileChooser.openButtonToolTipText&quot;,
                new String(&quot;Open selected file.&quot;),
        &quot;FileChooser.updateButtonToolTipText&quot;,
                new String(&quot;Update directory listing.&quot;),
        &quot;FileChooser.helpButtonToolTipText&quot;,
                new String(&quot;FileChooser help.&quot;),
        &quot;FileChooser.newFolderIcon&quot;, newFolderIcon,
        &quot;FileChooser.upFolderIcon&quot;, upFolderIcon,
        &quot;FileChooser.homeFolderIcon&quot;, homeFolderIcon,
        &quot;FileChooser.detailsViewIcon&quot;, detailsViewIcon,
        &quot;FileChooser.listViewIcon&quot;, listViewIcon,
        &quot;FileView.directoryIcon&quot;, directoryIcon,
        &quot;FileView.fileIcon&quot;, fileIcon,
        &quot;FileView.computerIcon&quot;, computerIcon,
        &quot;FileView.hardDriveIcon&quot;, hardDriveIcon,
        &quot;FileView.floppyDriveIcon&quot;, floppyDriveIcon,

        // *** InternalFrame
        &quot;InternalFrame.titleFont&quot;, dialogBold12,
        &quot;InternalFrame.border&quot;, internalFrameBorder,
        &quot;InternalFrame.icon&quot;,
                LookAndFeel.makeIcon(getClass(), &quot;icons/JavaCup.gif&quot;),

        // Default frame icons are undefined for Basic.
        &quot;InternalFrame.maximizeIcon&quot;,
                BasicIconFactory.createEmptyFrameIcon(),
        &quot;InternalFrame.minimizeIcon&quot;,
                BasicIconFactory.createEmptyFrameIcon(),
        &quot;InternalFrame.iconifyIcon&quot;,
                BasicIconFactory.createEmptyFrameIcon(),
        &quot;InternalFrame.closeIcon&quot;,
                BasicIconFactory.createEmptyFrameIcon(),
        &quot;InternalFrame.activeTitleBackground&quot;,
                table.get(&quot;activeCaption&quot;),
        &quot;InternalFrame.activeTitleForeground&quot;,
                table.get(&quot;activeCaptionText&quot;),
        &quot;InternalFrame.inactiveTitleBackground&quot;,
                table.get(&quot;inactiveCaption&quot;),
        &quot;InternalFrame.inactiveTitleForeground&quot;,
                table.get(&quot;inactiveCaptionText&quot;),

        &quot;DesktopIcon.border&quot;, internalFrameBorder,

        &quot;Desktop.background&quot;, table.get(&quot;desktop&quot;),

        // *** Label
        &quot;Label.font&quot;, dialogPlain12,
        &quot;Label.background&quot;, table.get(&quot;control&quot;),
        &quot;Label.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;Label.disabledForeground&quot;, white,
        &quot;Label.disabledShadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;Label.border&quot;, null,

        // *** List
        &quot;List.font&quot;, dialogPlain12,
        &quot;List.background&quot;, table.get(&quot;window&quot;),
        &quot;List.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;List.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;List.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;List.focusCellHighlightBorder&quot;, focusCellHighlightBorder,
        &quot;List.border&quot;, null,
        &quot;List.cellRenderer&quot;, listCellRendererActiveValue,

        // *** Menus
        &quot;MenuBar.font&quot;, dialogPlain12,
        &quot;MenuBar.background&quot;, table.get(&quot;menu&quot;),
        &quot;MenuBar.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;MenuBar.border&quot;, menuBarBorder,

        &quot;MenuItem.font&quot;, dialogPlain12,
        &quot;MenuItem.acceleratorFont&quot;, dialogPlain12,
        &quot;MenuItem.background&quot;, table.get(&quot;menu&quot;),
        &quot;MenuItem.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;MenuItem.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;MenuItem.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;MenuItem.disabledForeground&quot;, null,
        &quot;MenuItem.acceleratorForeground&quot;, table.get(&quot;menuText&quot;),
        &quot;MenuItem.acceleratorSelectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;MenuItem.border&quot;, marginBorder,
        &quot;MenuItem.borderPainted&quot;, Boolean.FALSE,
        &quot;MenuItem.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;MenuItem.checkIcon&quot;, menuItemCheckIcon,
        &quot;MenuItem.arrowIcon&quot;, menuItemArrowIcon,

        &quot;RadioButtonMenuItem.font&quot;, dialogPlain12,
        &quot;RadioButtonMenuItem.acceleratorFont&quot;, dialogPlain12,
        &quot;RadioButtonMenuItem.background&quot;, table.get(&quot;menu&quot;),
        &quot;RadioButtonMenuItem.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;RadioButtonMenuItem.selectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;RadioButtonMenuItem.selectionBackground&quot;,
                table.get(&quot;textHighlight&quot;),
        &quot;RadioButtonMenuItem.disabledForeground&quot;, null,
        &quot;RadioButtonMenuItem.acceleratorForeground&quot;,
                table.get(&quot;menuText&quot;),
        &quot;RadioButtonMenuItem.acceleratorSelectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;RadioButtonMenuItem.border&quot;, marginBorder,
        &quot;RadioButtonMenuItem.borderPainted&quot;, Boolean.FALSE,
        &quot;RadioButtonMenuItem.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;RadioButtonMenuItem.checkIcon&quot;, radioButtonMenuItemIcon,
        &quot;RadioButtonMenuItem.arrowIcon&quot;, menuItemArrowIcon,

        &quot;CheckBoxMenuItem.font&quot;, dialogPlain12,
        &quot;CheckBoxMenuItem.acceleratorFont&quot;, dialogPlain12,
        &quot;CheckBoxMenuItem.background&quot;, table.get(&quot;menu&quot;),
        &quot;CheckBoxMenuItem.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;CheckBoxMenuItem.selectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;CheckBoxMenuItem.selectionBackground&quot;,
                table.get(&quot;textHighlight&quot;),
        &quot;CheckBoxMenuItem.disabledForeground&quot;, null,
        &quot;CheckBoxMenuItem.acceleratorForeground&quot;,
                table.get(&quot;menuText&quot;),
        &quot;CheckBoxMenuItem.acceleratorSelectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;CheckBoxMenuItem.border&quot;, marginBorder,
        &quot;CheckBoxMenuItem.borderPainted&quot;, Boolean.FALSE,
        &quot;CheckBoxMenuItem.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;CheckBoxMenuItem.checkIcon&quot;, checkBoxMenuItemIcon,
        &quot;CheckBoxMenuItem.arrowIcon&quot;, menuItemArrowIcon,

        &quot;Menu.font&quot;, dialogPlain12,
        &quot;Menu.acceleratorFont&quot;, dialogPlain12,
        &quot;Menu.background&quot;, table.get(&quot;menu&quot;),
        &quot;Menu.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;Menu.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;Menu.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;Menu.disabledForeground&quot;, null,
        &quot;Menu.acceleratorForeground&quot;, table.get(&quot;menuText&quot;),
        &quot;Menu.acceleratorSelectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;Menu.border&quot;, marginBorder,
        &quot;Menu.borderPainted&quot;, Boolean.FALSE,
        &quot;Menu.margin&quot;, new InsetsUIResource(2, 2, 2, 2),
        &quot;Menu.checkIcon&quot;, menuItemCheckIcon,
        &quot;Menu.arrowIcon&quot;, menuArrowIcon,

        &quot;PopupMenu.font&quot;, dialogPlain12,
        &quot;PopupMenu.background&quot;, table.get(&quot;menu&quot;),
        &quot;PopupMenu.foreground&quot;, table.get(&quot;menuText&quot;),
        &quot;PopupMenu.border&quot;, raisedBevelBorder,

        // *** OptionPane
        &quot;OptionPane.font&quot;, dialogPlain12,
        &quot;OptionPane.background&quot;, table.get(&quot;control&quot;),
        &quot;OptionPane.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;OptionPane.messageForeground&quot;, table.get(&quot;controlText&quot;),
        &quot;OptionPane.border&quot;, optionPaneBorder,
        &quot;OptionPane.messageAreaBorder&quot;, zeroBorder,
        &quot;OptionPane.buttonAreaBorder&quot;, optionPaneButtonAreaBorder,
        &quot;OptionPane.minimumSize&quot;, optionPaneMinimumSize,
        &quot;OptionPane.errorIcon&quot;, LookAndFeel.makeIcon(getClass(),
                &quot;icons/Error.gif&quot;),
        &quot;OptionPane.informationIcon&quot;,
                LookAndFeel.makeIcon(getClass(), &quot;icons/Inform.gif&quot;),
        &quot;OptionPane.warningIcon&quot;,
                LookAndFeel.makeIcon(getClass(), &quot;icons/Warn.gif&quot;),
        &quot;OptionPane.questionIcon&quot;,
                LookAndFeel.makeIcon(getClass(), &quot;icons/Question.gif&quot;),

        // *** Panel
        &quot;Panel.font&quot;, dialogPlain12,
        &quot;Panel.background&quot;, table.get(&quot;control&quot;),
        &quot;Panel.foreground&quot;, table.get(&quot;textText&quot;),

        // *** ProgressBar
        &quot;ProgressBar.font&quot;, dialogPlain12,
        &quot;ProgressBar.foreground&quot;,  table.get(&quot;textHighlight&quot;),
        &quot;ProgressBar.background&quot;, table.get(&quot;control&quot;),
        &quot;ProgressBar.selectionForeground&quot;, table.get(&quot;control&quot;),
        &quot;ProgressBar.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;ProgressBar.border&quot;, progressBarBorder,
        &quot;ProgressBar.cellLength&quot;, new Integer(1),
        &quot;ProgressBar.cellSpacing&quot;, new Integer(0),

        // *** Separator
        &quot;Separator.shadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;Separator.highlight&quot;, table.get(&quot;controlLtHighlight&quot;),

        // *** ScrollBar/ScrollPane/Viewport
        &quot;ScrollBar.background&quot;, scrollBarTrack,
        &quot;ScrollBar.foreground&quot;, table.get(&quot;control&quot;),
        &quot;ScrollBar.track&quot;, table.get(&quot;scrollbar&quot;),
        &quot;ScrollBar.trackHighlight&quot;, table.get(&quot;controlDkShadow&quot;),
        &quot;ScrollBar.thumb&quot;, table.get(&quot;control&quot;),
        &quot;ScrollBar.thumbHighlight&quot;, table.get(&quot;controlLtHighlight&quot;),
        &quot;ScrollBar.thumbDarkShadow&quot;, table.get(&quot;controlDkShadow&quot;),
        &quot;ScrollBar.thumbLightShadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;ScrollBar.border&quot;, null,
        &quot;ScrollBar.minimumThumbSize&quot;, minimumThumbSize,
        &quot;ScrollBar.maximumThumbSize&quot;, maximumThumbSize,

        &quot;ScrollPane.font&quot;, dialogPlain12,
        &quot;ScrollPane.background&quot;, table.get(&quot;control&quot;),
        &quot;ScrollPane.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;ScrollPane.border&quot;, etchedBorder,
        &quot;ScrollPane.viewportBorder&quot;, null,

        &quot;Viewport.font&quot;, dialogPlain12,
        &quot;Viewport.background&quot;, table.get(&quot;control&quot;),
        &quot;Viewport.foreground&quot;, table.get(&quot;textText&quot;),

        // *** Slider
        &quot;Slider.foreground&quot;, table.get(&quot;control&quot;),
        &quot;Slider.background&quot;, table.get(&quot;control&quot;),
        &quot;Slider.highlight&quot;, table.get(&quot;controlLtHighlight&quot;),
        &quot;Slider.shadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;Slider.focus&quot;, table.get(&quot;controlDkShadow&quot;),
        &quot;Slider.border&quot;, null,
        &quot;Slider.focusInsets&quot;, sliderFocusInsets,

        // *** SplitPane
        &quot;SplitPane.background&quot;, table.get(&quot;control&quot;),
        &quot;SplitPane.highlight&quot;, table.get(&quot;controlLtHighlight&quot;),
        &quot;SplitPane.shadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;SplitPane.border&quot;, splitPaneBorder,
        &quot;SplitPane.dividerSize&quot;, new Integer(5),

        // *** TabbedPane
        &quot;TabbedPane.font&quot;, dialogPlain12,
        &quot;TabbedPane.background&quot;, table.get(&quot;control&quot;),
        &quot;TabbedPane.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;TabbedPane.lightHighlight&quot;, table.get(&quot;controlLtHighlight&quot;),
        &quot;TabbedPane.highlight&quot;, table.get(&quot;controlHighlight&quot;),
        &quot;TabbedPane.shadow&quot;, table.get(&quot;controlShadow&quot;),
        &quot;TabbedPane.darkShadow&quot;, table.get(&quot;controlDkShadow&quot;),
        &quot;TabbedPane.focus&quot;, table.get(&quot;controlText&quot;),
        &quot;TabbedPane.textIconGap&quot;, new Integer(4),
        &quot;TabbedPane.tabInsets&quot;, tabbedPaneTabInsets,
        &quot;TabbedPane.selectedTabPadInsets&quot;, tabbedPaneTabPadInsets,
        &quot;TabbedPane.tabAreaInsets&quot;, tabbedPaneTabAreaInsets,
        &quot;TabbedPane.contentBorderInsets&quot;, tabbedPaneContentBorderInsets,
        &quot;TabbedPane.tabRunOverlay&quot;, new Integer(2),

        // *** Table
        &quot;Table.font&quot;, dialogPlain12,
        &quot;Table.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;Table.background&quot;, table.get(&quot;window&quot;),
        &quot;Table.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;Table.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;Table.gridColor&quot;, gray,
        &quot;Table.focusCellBackground&quot;, table.get(&quot;window&quot;),
        &quot;Table.focusCellForeground&quot;, table.get(&quot;controlText&quot;),
        &quot;Table.focusCellHighlightBorder&quot;, focusCellHighlightBorder,
        &quot;Table.scrollPaneBorder&quot;, loweredBevelBorder,

        &quot;TableHeader.font&quot;, dialogPlain12,
        &quot;TableHeader.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;TableHeader.background&quot;, table.get(&quot;control&quot;),
        &quot;TableHeader.cellBorder&quot;, raisedBevelBorder,

        // *** Text
        &quot;TextField.font&quot;, sansSerifPlain12,
        &quot;TextField.background&quot;, table.get(&quot;window&quot;),
        &quot;TextField.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;TextField.inactiveForeground&quot;, table.get(&quot;textInactiveText&quot;),
        &quot;TextField.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;TextField.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;TextField.caretForeground&quot;, table.get(&quot;textText&quot;),
        &quot;TextField.caretBlinkRate&quot;, caretBlinkRate,
        &quot;TextField.border&quot;, textFieldBorder,
        &quot;TextField.margin&quot;, zeroInsets,
        &quot;TextField.keyBindings&quot;, fieldBindings,

        &quot;PasswordField.font&quot;, monospacedPlain12,
        &quot;PasswordField.background&quot;, table.get(&quot;window&quot;),
        &quot;PasswordField.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;PasswordField.inactiveForeground&quot;,
                table.get(&quot;textInactiveText&quot;),
        &quot;PasswordField.selectionBackground&quot;,
                table.get(&quot;textHighlight&quot;),
        &quot;PasswordField.selectionForeground&quot;,
                table.get(&quot;textHighlightText&quot;),
        &quot;PasswordField.caretForeground&quot;, table.get(&quot;textText&quot;),
        &quot;PasswordField.caretBlinkRate&quot;, caretBlinkRate,
        &quot;PasswordField.border&quot;, textFieldBorder,
        &quot;PasswordField.margin&quot;, zeroInsets,
        &quot;PasswordField.keyBindings&quot;, fieldBindings,

        &quot;TextArea.font&quot;, monospacedPlain12,
        &quot;TextArea.background&quot;, table.get(&quot;window&quot;),
        &quot;TextArea.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;TextArea.inactiveForeground&quot;, table.get(&quot;textInactiveText&quot;),
        &quot;TextArea.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;TextArea.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;TextArea.caretForeground&quot;, table.get(&quot;textText&quot;),
        &quot;TextArea.caretBlinkRate&quot;, caretBlinkRate,
        &quot;TextArea.border&quot;, marginBorder,
        &quot;TextArea.margin&quot;, zeroInsets,
        &quot;TextArea.keyBindings&quot;, multilineBindings,

        &quot;TextPane.font&quot;, serifPlain12,
        &quot;TextPane.background&quot;, white,
        &quot;TextPane.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;TextPane.selectionBackground&quot;, lightGray,
        &quot;TextPane.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;TextPane.caretForeground&quot;, table.get(&quot;textText&quot;),
        &quot;TextPane.inactiveForeground&quot;, table.get(&quot;textInactiveText&quot;),
        &quot;TextPane.border&quot;, marginBorder,
        &quot;TextPane.margin&quot;, editorMargin,
        &quot;TextPane.keyBindings&quot;, multilineBindings,

        &quot;EditorPane.font&quot;, serifPlain12,
        &quot;EditorPane.background&quot;, white,
        &quot;EditorPane.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;EditorPane.selectionBackground&quot;, lightGray,
        &quot;EditorPane.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;EditorPane.caretForeground&quot;, red,
        &quot;EditorPane.inactiveForeground&quot;, table.get(&quot;textInactiveText&quot;),
        &quot;EditorPane.border&quot;, marginBorder,
        &quot;EditorPane.margin&quot;, editorMargin,
        &quot;EditorPane.keyBindings&quot;, multilineBindings,

        // *** TitledBorder
        &quot;TitledBorder.font&quot;, dialogPlain12,
        &quot;TitledBorder.titleColor&quot;, table.get(&quot;controlText&quot;),
        &quot;TitledBorder.border&quot;, etchedBorder,

        // *** ToolBar
        &quot;ToolBar.font&quot;, dialogPlain12,
        &quot;ToolBar.background&quot;, table.get(&quot;control&quot;),
        &quot;ToolBar.foreground&quot;, table.get(&quot;controlText&quot;),
        &quot;ToolBar.dockingBackground&quot;, table.get(&quot;control&quot;),
        &quot;ToolBar.dockingForeground&quot;, red,
        &quot;ToolBar.floatingBackground&quot;, table.get(&quot;control&quot;),
        &quot;ToolBar.floatingForeground&quot;, darkGray,
        &quot;ToolBar.border&quot;, etchedBorder,
        &quot;ToolBar.separatorSize&quot;, toolBarSeparatorSize,

        // *** ToolTips
        &quot;ToolTip.font&quot;, sansSerifPlain12,
        &quot;ToolTip.background&quot;, table.get(&quot;info&quot;),
        &quot;ToolTip.foreground&quot;, table.get(&quot;infoText&quot;),
        &quot;ToolTip.border&quot;, blackLineBorder,

        // *** Tree
        &quot;Tree.font&quot;, dialogPlain12,
        &quot;Tree.background&quot;, table.get(&quot;window&quot;),
        &quot;Tree.foreground&quot;, table.get(&quot;textText&quot;),
        &quot;Tree.hash&quot;, gray,
        &quot;Tree.textForeground&quot;, table.get(&quot;textText&quot;),
        &quot;Tree.textBackground&quot;, table.get(&quot;text&quot;),
        &quot;Tree.selectionForeground&quot;, table.get(&quot;textHighlightText&quot;),
        &quot;Tree.selectionBackground&quot;, table.get(&quot;textHighlight&quot;),
        &quot;Tree.selectionBorderColor&quot;, black,
        &quot;Tree.editorBorder&quot;, blackLineBorder,
        &quot;Tree.leftChildIndent&quot;, new Integer(7),
        &quot;Tree.rightChildIndent&quot;, new Integer(13),
        &quot;Tree.rowHeight&quot;, new Integer(16),
        &quot;Tree.scrollsOnExpand&quot;, Boolean.TRUE,
        &quot;Tree.openIcon&quot;,
            LookAndFeel.makeIcon(getClass(), &quot;icons/TreeOpen.gif&quot;),
        &quot;Tree.closedIcon&quot;,
            LookAndFeel.makeIcon(getClass(), &quot;icons/TreeClosed.gif&quot;),
        &quot;Tree.leafIcon&quot;,
            LookAndFeel.makeIcon(getClass(), &quot;icons/TreeLeaf.gif&quot;),
        &quot;Tree.expandedIcon&quot;, null,
        &quot;Tree.collapsedIcon&quot;, null,

    } ;

    table.putDefaults(defaults);
    } 
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>The UnleashedLookAndFeel initClassDefaults Method</B>
<BLOCKQUOTE>
The <TT>UnleashedLookAndFeel</TT> class does not contain a <TT>getDefaults</TT>
method. Instead, it inherits the method from its parent class,
<TT>BasicLookAndFeel</TT>, and overrides the <TT>initClassDefaults</TT>
and <TT>initComponentDefaults</TT> methods. It is in the <TT>initClassDefaults</TT>
method that the UI classes comprising the new look-and-feel are
registered. Looking at this method, you will quickly notice that
the Unleashed look-and-feel does not provide UI classes for every
component. When a UI class is not defined in this table, the implementation
is inherited from the basic look-and-feel.
</BLOCKQUOTE>
<BLOCKQUOTE>
In this example, the UI object implementations are only being
provided for a couple of classes. However, the technique for adding
additional UI classes is the same. This points out a powerful
aspect of extending an existing look-and-feel. Your implementation
can start with a couple of UI classes and build from there. The
look-and-feel is operational with a minimal set of UI classes
as the complete set is being developed. This allows you to deploy
the partial look-and-feel implementation with example applications
that create components by using the completed UI classes and obtain
feedback from users. This process can save you from developing
a complete look-and-feel that users will not accept.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 23.10&nbsp; The </B><TT><B>UNLEASHEDLOOKANDFEEL</B></TT><B>
</B><TT><B>INITCLASSDEFAULTS</B></TT><B>
Method<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Initialize the uiClassID to UnleashedComponentUI mapping.
 * &lt;p&gt;
 * @see #getDefaults
 */
 protected void initClassDefaults( UIDefaults table ) { 
    //
    // Register the basic class defaults.
    //
    super.initClassDefaults( table );
        
    String basicPackageName = &quot;com.foley.laf.&quot;;
    Object[] uiDefaults = { 
        &quot;ButtonUI&quot;, basicPackageName + &quot;BasicButtonUI&quot;,
        &quot;TreeUI&quot;, basicPackageName + &quot;UnleashedTreeUI&quot;,
        &quot;LabelUI&quot;, basicPackageName + &quot;BasicLabelUI&quot;,
        &quot;ToolTipUI&quot;, basicPackageName + &quot;UnleashedToolTipUI&quot;,
    } ;

    table.putDefaults( uiDefaults );

}  // initClassDefaults
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>The UnleashedLookAndFeel initComponentDefaults Method</B>
<BLOCKQUOTE>
The <TT>initClassDefaults</TT> method in the <TT>UnleashedLookAndFeel</TT>
is similar to the <TT>initClassDefaults</TT> method. The parent
class's <TT>initComponentDefaults</TT> method is used to register
the bulk of the component default properties. Then the overridden
properties are registered. In the <TT>UnleashedLookAndFeel</TT>,
a UI is provided for the <TT>TreeUI</TT> key. There are five icons
associated with the component that are customized in the <TT>UnleashedLookAndFeel</TT>.
These need to be registered in the <TT>UIDefaults</TT> table in
this method. The <TT>UnleashedLookAndFeel</TT> class' <TT>initComponentDefaults</TT>
method is shown in Listing 23.11.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 23.11&nbsp; The </B><TT><B>UNLEASHEDLOOKANDFEEL</B></TT><B>
</B><TT><B>INITCOMPONENTDEFAULTS</B></TT><B>
Method<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Register the component defaults.
 * Let our parent do the real work, then update the defaults
 * to the icons used in this look-and-feel.
 * &lt;p&gt;
 * @param table The UIDefaults table to configure.
 **/
protected void initComponentDefaults( UIDefaults table ) { 
        
    //
    // Register the basic component defaults.
    //
    super.initComponentDefaults( table );
        
    Object[] defaults = { 
        
        &quot;Tree.openIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeOpen.gif&quot;),
        &quot;Tree.closedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeClosed.gif&quot;),
        &quot;Tree.leafIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeLeaf.gif&quot;),
        &quot;Tree.expandedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeExpanded.gif&quot;),
        &quot;Tree.collapsedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeCollapsed.gif&quot;),
        &quot;Tree.textBackground&quot;, table.get(&quot;window&quot;),
    } ;

    table.putDefaults( defaults );
        
}  // initComponentDefaults
</PRE>
</BLOCKQUOTE>
<HR>
<H4>The Complete <TT>UnleashedLookAndFeel</TT> Class</H4>
<P>
That's it! That's all there is to defining a look-and-feel. The
Unleashed look-and-feel is a first class look-and-feel that can
be used in the same way as any of the stock look-and-feel implementations
that are part of the JFC. The complete listing for the <TT>UnleashedLookAndFeel</TT>
is shown in Listing 23.12.
<P>
<HR>
<P>
<B>Listing 23.12&nbsp; The </B><TT><B>UNLEASHEDLOOKANDFEEL</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.laf;

import java.io.Serializable;

import javax.swing.*;
import javax.swing.plaf.basic.BasicLookAndFeel;


/**
 * @author MikeFoley
 */
public class UnleashedLookAndFeel extends BasicLookAndFeel 
    implements Serializable { 

    /**
     * @return The name for this look-and-feel.     
     **/
    public String getName() { 
        return &quot;Unleashed&quot;;
    } 


    /**
     * We are not a simple extension of an existing
     * look-and-feel, so provide our own ID.
     * &lt;p&gt;
     * @return The ID for this look-and-feel.     
     **/
    public String getID() { 
        return &quot;Unleashed&quot;;
    }


    /**
     * @return A short description of this look-and-feel.
     **/
    public String getDescription() { 
        return &quot;The JFC Unleashed Look and Feel&quot;;
    } 

    
    /**
     * This is not a native look and feel on any platform.
     * &lt;p&gt;
     * @return false, this isn't native on any platform.
     **/
    public boolean isNativeLookAndFeel() { 
        return false;
    } 


    /**
     * This look and feel is supported on all platforms.
     * &lt;p&gt;
     * @return true, this L&amp;F is supported on all platforms.
     **/
    public boolean isSupportedLookAndFeel() { 
        return true;
    }


    /**
     * Initialize the uiClassID to UnleashedComponentUI mapping.
     * &lt;p&gt;
     * @see #getDefaults
     */
    protected void initClassDefaults( UIDefaults table )
    { 
        //
        // Register the basic class defaults.
        //
        super.initClassDefaults( table );
        
      String basicPackageName = &quot;com.foley.plaf.unleashed.&quot;;
          Object[] uiDefaults = { 
               &quot;ButtonUI&quot;, basicPackageName + &quot;BasicButtonUI&quot;,
                 &quot;TreeUI&quot;, basicPackageName + &quot;UnleashedTreeUI&quot;,
                &quot;LabelUI&quot;, basicPackageName + &quot;BasicLabelUI&quot;,
              &quot;ToolTipUI&quot;, basicPackageName + &quot;UnleashedToolTipUI&quot;,
      } ;

          table.putDefaults( uiDefaults );
          
    }  // initClassDefaults


    /**
     * Register the component defaults.
     * Let our parent do the real work, then update the defaults
     * to the icons used in this look-and-feel.
     * &lt;p&gt;
     * @param table The UIDefaults table to configure.
     **/
    protected void initComponentDefaults( UIDefaults table ) { 
        
        //
        // Register the basic component defaults.
        //
        super.initComponentDefaults( table );
        
        Object[] defaults = { 
        
            &quot;Tree.openIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeOpen.gif&quot;),
            &quot;Tree.closedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeClosed.gif&quot;),
            &quot;Tree.leafIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeLeaf.gif&quot;),
           &quot;Tree.expandedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeExpanded.gif&quot;),
           &quot;Tree.collapsedIcon&quot;, 
              LookAndFeel.makeIcon(getClass(), &quot;images/TreeCollapsed.gif&quot;),
          &quot;Tree.textBackground&quot;, table.get(&quot;window&quot;),
          } ;
          
        table.putDefaults( defaults );
        
    }  // initComponentDefaults

    
}  // UnleashedLookAndFeel
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="UsingtheUnleashedLookandFeel">
Using the Unleashed Look-and-Feel</A></H3>
<P>
In the previous section the Unleashed look-and-feel was developed.
Unleashed is an extension of the basic look-and-feel that adds
a couple of UI classes. It can be registered and used just like
any of the look-and-feels that are part of the JFC. The <TT>TestLookAndFeel</TT>
application shown in Listing 23.13 registers the Unleashed look-and-feel,
sets it as the current look-and-feel, and then creates a frame
and components that have a UI class defined in this look-and-feel.
This is a slightly modified version of the <TT>TreeTest</TT> application
presented in <A HREF="..\ch11\ch11.htm" >Chapter 11</A>. In the <TT>main</TT> method the <TT>UIManager</TT>'s
<TT>installLookAndFeel</TT> is called to install the Unleashed
look-and-feel. The two parameters to this method are the look-and-feel's
name and the fully qualified name of the class that defines the
look-and-feel. Then the <TT>setLookAndFeel</TT> method is called
to specify the Unleashed look-and-feel for the application. The
single parameter to this method is the fully qualified class name
of the Unleashed look-and-feel. There is also a version of this
method that takes a reference to the <TT>LookAndFeel</TT> class
that defines the look-and-feel. The resulting window is shown
in Figure 23.6. In the figure, you can see that the <TT>UnleashedLabelUI</TT>
implementation allows for multiple lines in a single label.
<P>
<HR>
<P>
<B>Listing 23.13&nbsp; The </B><TT><B>TESTLOOKANDFEEL</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.border.*;

import com.foley.utility.*;


/**
 * An application that registers the Unleashed
 * look-and-feel and displays a frame containing
 * some of the Swing components that have their
 * UI Object modified with this look-and-feel.
 *
 * @author Mike Foley
 **/
public class LookAndFeelTest
    implements ActionListener, TreeSelectionListener { 

    /**
     * The tree used in the center of the dipslay.
     **/
    JTree tree;

    /**
     * The component where the selected path is displayed.
     **/
    JTextArea textArea;

    /**
     * The text contained in the JTextArea initially and after a clear.
     **/
    private static final String INITIAL_TEXT = &quot;Selected Path Events\ n&quot;;


    /**
     * Create the tree test component.
     * The display is a tree in the center of a BorderLayout.
     * The EAST region contains a JTextArea where selected
     * paths are displayed.
     * The bottom region contains buttons.
     * &lt;p&gt;
     * @return The component containing the tree.
     **/
    public JComponent createTreePanel() { 

        JPanel treePanel = new JPanel();
        treePanel.setLayout( new BorderLayout() );
    
        JLabel title = new JLabel( 
                 &quot;Tree Event Viewer\ nSelect an item in the tree.&quot; );
        title.setHorizontalAlignment( SwingConstants.CENTER );
        treePanel.add( title, BorderLayout.NORTH );

        JSplitPane splitPane = new JSplitPane();
        splitPane.setOneTouchExpandable( true ); 
        treePanel.add( splitPane, BorderLayout.CENTER );
        
        tree = new JTree( createTreeModel() );
        tree.setEditable( true );
        tree.setCellEditor( new TreeLeafEditor( tree ) );
        tree.addTreeSelectionListener( this );
        tree.setBorder( BorderFactory.createLoweredBevelBorder() );
        splitPane.setLeftComponent( tree );
        
        JPanel buttonPanel = new JPanel();
        JButton expand = new JButton( &quot;Expand Selected&quot; );
        expand.addActionListener( this );
        expand.setToolTipText( &quot;This button will expand\ n&quot; +
                         &quot;the selected node in the tree.&quot; );

        JButton clear = new JButton( &quot;Clear Path Display&quot; );
        clear.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                textArea.setText( INITIAL_TEXT );
            } 
        }  );
        clear.setToolTipText( &quot;This button will clear\ n&quot; +
                         &quot;the text in the event log.&quot; );
        buttonPanel.add( expand );
        buttonPanel.add( clear );
        treePanel.add( buttonPanel, BorderLayout.SOUTH );

        textArea = new JTextArea( INITIAL_TEXT, 16, 50 );
        textArea.setBackground( expand.getBackground() );
        textArea.setBorder( null );
        textArea.setBorder( 
                   BorderFactory.createEmptyBorder( 4, 4, 4, 4 ) );
        splitPane.setRightComponent( new JScrollPane( textArea ) );

        treePanel.setBorder( BorderFactory.createLoweredBevelBorder() );

        return( treePanel );
    } 


    /**
     * Create the data model used in the tree contained
     * in the application.
     * &lt;p&gt;
     * @return The data model for the tree.
     **/
    protected TreeModel createTreeModel() { 
        DefaultMutableTreeNode root = 
              new DefaultMutableTreeNode( &quot;Music Collection&quot; );

        DefaultMutableTreeNode albums = 
              new DefaultMutableTreeNode( &quot;Albums&quot; );
        DefaultMutableTreeNode cds = 
              new DefaultMutableTreeNode( &quot;CDs&quot; );
        DefaultMutableTreeNode tapes = 
              new DefaultMutableTreeNode( &quot;Tapes&quot; );

        root.add( albums );
        root.add( cds );
        root.add( tapes );

        DefaultMutableTreeNode stonesAlbums = 
              new DefaultMutableTreeNode( &quot;Rolling Stones&quot; );
        albums.add( stonesAlbums );

        stonesAlbums.add( new DefaultMutableTreeNode( &quot;Hot Rocks&quot; ) );
        stonesAlbums.add( 
              new DefaultMutableTreeNode( &quot;Black and Blue&quot; ) );
        stonesAlbums.add( 
              new DefaultMutableTreeNode( &quot;Sticky Finger&quot; ) );

        DefaultMutableTreeNode c1 = 
              new DefaultMutableTreeNode( &quot;Classical&quot; );
        DefaultMutableTreeNode c2 = 
              new DefaultMutableTreeNode( &quot;Best Rock of the 60's&quot; );
        DefaultMutableTreeNode c3 = 
              new DefaultMutableTreeNode( &quot;70's Disco Favorites&quot; );
        DefaultMutableTreeNode c4 = 
              new DefaultMutableTreeNode( &quot;Broadway Hits&quot; );
        DefaultMutableTreeNode c5 = 
              new DefaultMutableTreeNode( &quot;Country's Best?&quot; );

        cds.add( c1 );
        cds.add( c2 );
        cds.add( c3 );
        cds.add( c4 );
        cds.add( c5 );

        DefaultMutableTreeNode s1 = 
              new DefaultMutableTreeNode( &quot;Rolling Stones&quot; );
        DefaultMutableTreeNode s2 = 
              new DefaultMutableTreeNode( &quot;Beatles&quot; );
        DefaultMutableTreeNode s3 = 
              new DefaultMutableTreeNode( &quot;The Who&quot; );

        c1.add( new DefaultMutableTreeNode( &quot;Beethoven's Fifth&quot; ) );

        c2.add( s1 );
        c2.add( s2 );
        c2.add( s3 );

        s1.add( new DefaultMutableTreeNode( &quot;Gimmie Shelter&quot; ) );
        s1.add( new DefaultMutableTreeNode( &quot;Some Girls&quot; ) );
        s1.add( new DefaultMutableTreeNode( &quot;Emotional Rescue&quot; ) );

        s2.add( new DefaultMutableTreeNode( &quot;White Album&quot; ) );
        s2.add( new DefaultMutableTreeNode( &quot;Abby Road&quot; ) );
        s2.add( new DefaultMutableTreeNode( &quot;Let it be&quot; ) );

        s3.add( new DefaultMutableTreeNode( &quot;Tommy&quot; ) );
        s3.add( new DefaultMutableTreeNode( &quot;The Who&quot; ) );

        c3.add( new DefaultMutableTreeNode( &quot;Saturday Night Fever&quot; ) );
        c3.add( new DefaultMutableTreeNode( &quot;Earth Wind and Fire&quot; ) );

        c4.add( new DefaultMutableTreeNode( &quot;Cats Soundtrack&quot; ) );

        c5.add( new DefaultMutableTreeNode( &quot;Unknown&quot; ) );

        return( new DefaultTreeModel( root ) );

    }  // createTreeModel


    /**
     * actionEvent, from ActionListener.
     * &lt;p&gt;
     * The expand button was pressed. Expand the selected paths
     * in the tree.
     * &lt;p&gt;
     * @param event The actionEvent causing this method call.
     **/
    public void actionPerformed( ActionEvent event ) { 
        TreePath[] paths = tree.getSelectionPaths();
        if( paths != null ) { 
            for( int i = 0; i &lt; paths.length; i++ ) { 
                expandPath( paths[i] );
            } 
        } 
    } 


    /**
     * valueChanged, from TreeSelectionListener.
     * &lt;p&gt;
     * The selected state in the tree changed. Show the
     * selected path in the text area.
     * &lt;p&gt;
     * @param event The event causing this method to be called.
     **/
    public void valueChanged( TreeSelectionEvent event ) { 

        TreePath[] paths = event.getPaths();

        for( int i = 0; i &lt; paths.length; i++ ) { 
            //
            // Diplay the path and state.
            //
            Object[] path = paths[i].getPath();
            textArea.append( event.isAddedPath( paths[i] ) ?
                                &quot;ADDED: &quot; : &quot;REMOVED: &quot; );
            textArea.append( paths[i] + &quot;\ n&quot; );
            for( int j = 0; j &lt; path.length; j++ ) { 
                textArea.append( &quot;\ t&quot; + path[j] + &quot;\ n&quot; );
            } 
            if( event.isAddedPath( paths[i] ) ) { 
                Object pathObject = paths[i].getLastPathComponent();

                //
                // This test is unfortunate. The MutableTreeNode
                // interface does not have a getUserObject method, so
                // we must test for a specific implementation.
                //
                if( pathObject instanceof DefaultMutableTreeNode ) { 
                    Object userObject = ( ( DefaultMutableTreeNode )
                          pathObject ).getUserObject();
                    textArea.append( &quot;User Object: &quot; 
                                       + userObject + &quot;\ n&quot; );
                } 
            } 
        } 
        textArea.append( &quot;-------------------------------------\ n&quot; );

    } 


    /**
     * Expand the node at the end of the given path.
     * This requires expanding all children node of the
     * path recursively until the entire subtree has been
     * expanded.
     **/
    private void expandPath( TreePath path ) { 
        Object o = path.getLastPathComponent();
        if( o instanceof TreeNode ) { 
            for( Enumeration e = ( ( TreeNode )o ).children(); 
                  e.hasMoreElements(); ) { 
                TreeNode node = ( TreeNode )e.nextElement();
                expandChildren( node );
            } 
        } 
    } 


    /**
     * Expand all the children of the given node.
     * &lt;p&gt;
     * @param expandNode The root of the subtree to expand.
     **/
    private void expandChildren( TreeNode expandNode ) { 

        if( expandNode.isLeaf() ) { 

            Stack nodes = new Stack();

            //
            // Push the parents of the current node
            // until the root of the tree is reached.
            //
            TreeNode node = expandNode;
            nodes.push( node );
            while( ( node = node.getParent() ) != null )
                nodes.push( node );

            //
            // Create a path to the node passed into this
            // method by popping each element from the stack.
            //
            TreeNode[] path = new TreeNode[ nodes.size() ];
            for( int i = 0; i &lt; path.length; i++ )
                path[i] = ( TreeNode )nodes.pop();
            TreePath treePath = new TreePath( path );

            //
            // Expand the path.
            //
            tree.expandPath( treePath );

        }  else { 

            //
            // Expand the children children of the 
              // node passed to the method.
            //
            for( Enumeration e = expandNode.children(); 
                  e.hasMoreElements(); ) { 
                expandChildren( ( DefaultMutableTreeNode )
                      e.nextElement() );
            } 

        }  // else

    }  // expandChildren


    /**
     * Application entry point.
     * Create the frame, and place a tree into it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        //
        // Set the look-and-feel to Unleashed.
        //       
        try { 
            String className = 
                   &quot;com.foley.plaf.unleashed.UnleashedLookAndFeel&quot;;
                              UIManager.installLookAndFeel( &quot;Unleashed&quot;,   className );
            UIManager.setLookAndFeel( className );
        }  catch( Exception ex ) { 
            System.err.println( &quot;Could not load look-and-feel&quot; );
            System.err.println( ex );
            ex.printStackTrace();
        } 
        
        LookAndFeelTest treeTest = new LookAndFeelTest();
        JFrame frame = new ApplicationFrame( &quot;Tree Test&quot; );
        frame.getContentPane().add( treeTest.createTreePanel(), 
              BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // LookAndFeelTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f23-6.gif')"><B>Figure 23.6 :</B> <I>The LookAndFeelTest application</I>.</A>
<H2><A NAME="TheMultiplexingLookAndFeel">
The Multiplexing Look-And-Feel</A></H2>
<P>
Up to this point, your focus has been on visual look-and-feels.
However, the multiplexing look-and-feel allows multiple look-and-feels
to be simultaneously active. However, only one of the look-and-feel
implementations is visual. The others are known as auxiliary look-and-feels.
The auxiliary look-and-feels can be used to interact with other
devices such as sound cards or Braille readers.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Notice that the portion of the code in the <TT>LookAndFeelTest</TT> application that creates and configures the user interface is identical to applications presented earlier in this book. The fact that the look-and-feel is different has no effect on the code that creates and configures the user interface. This is a fundamental concept of the pluggable look-and-feel architecture. Indeed, it is its biggest advantage.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>

<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
In the <TT>LookAndFeelTest</TT> application shown in Listing 23.13, the <TT>UnleashedLookAndFeel</TT> is specified in the <TT>main</TT> method as the look-and-feel for this application. The default look-and-feel for a Java installation can be specified by setting the <TT>swing.defaultlaf</TT> property in the <TT>swing.properties</TT> file. The <TT>UnleashedLookAndFeel</TT> could be installed as the default look-and-feel for every Java application by adding the following line to the <TT>swing.properties</TT> file:
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
swing.defaultlaf=com.foley.plaf.unleashed.UnleashedLookAndFeel</PRE>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
If auxiliary look-and-feels are installed in the virtual machine,
a multiplexing UI object is installed when a component's UI object
is created. The multiplexing UI object passes a UI message to
each look-and-feel registered. The visual look-and-feel is used
without modification. In fact, each look-and-feel is unaware that
the multiplexing is occurring. 
<P>
The multiplexing UI object is guaranteed to contain the visual
UI object as the first item in its multiplexed UI object array.
This array is obtained by calling the <TT>getUIs</TT> method of
the multiplexing UI object. This method is available in all classes
in the <TT>swing.plaf.multi</TT> package.
<H3><A NAME="AuxiliaryLookandFeels">
Auxiliary Look-and-Feels</A></H3>
<P>
The intent of auxiliary look-and-feels is to augment the primary
visual look-and-feel used by the application. For this reason,
they tend to be nonvisual. However, there is nothing in the architecture
that prevents an auxiliary look-and-feel from rendering to the
display. This is both a good and a bad thing. This gives the developer
of the auxiliary look-and-feel complete flexibility but also adds
responsibilities. For example, the auxiliary look-and-feel should
not compete with the default look-and-feel to paint a component.
<P>
When creating an auxiliary look-and-feel, you probably will not
extend a visual look-and-feel. This is to avoid painting or processing
input events that conflict with the default look-and-feel when
your auxiliary look-and-feel is used. Instead, you can choose
to extend the classes in the <TT>swing.plaf</TT> package or extend
the <TT>swing.LookAndFeel</TT> class directly. Even when classes
in the <TT>swing.plaf</TT> package are extended, care must be
taken to override any methods that render to the screen. For example,
the <TT>update</TT> method in the <TT>ComponentUI</TT> class clears
the component's background if it is opaque. This behavior is undesirable
in most auxililiary look-and-feels, because it will compete with
the <TT>update</TT> method from the default visual look-and-feel
being used for the application.
<H3><A NAME="RegisteringAuxiliaryLookandFeels">
Registering Auxiliary Look-and-Feels</A></H3>
<P>
Before the multiplexing look-and-feel will be used, one or more
auxiliary look-and-feel implementations must be registered with
the Virtual Machine. This is done by adding entries to the <TT>swing.auxiliarylaf</TT>
property in the <TT>swing.properties</TT> file or calling the
<TT>addAuxiliaryLookandFeel</TT> method in the <TT>UIManager</TT>.
The property file is located in the <TT>$JDKHOME/lib</TT> directory.
Multiple auxiliary look-and-feel implementations can be specified
for this property by separating each look-and-feel with a comma.
Each property entry is the fully qualified class name of the look-and-feel
class. The following line added to the <TT>swing.properties</TT>
file would enable two auxiliary look-and-feel implementations
in the Virtual Machine:
<BLOCKQUOTE>
<PRE>
Swing.auxiliarylaf=com.foley.plaf.debug.DebugLookAndFeel,
                 com.foley.plaf.audio.AudioLookAndFeel
</PRE>
</BLOCKQUOTE>
<P>
After auxiliary look-and-feel implementations are registered in
the Virtual Machine, the multiplexing look-and-feel will be used
without further programmer or user intervention when Swing components
are created. The registered auxiliary look-and-feel implementations
may be queried from the <TT>UIManager</TT> by calling the <TT>getAuxiliaryLookAndFeels</TT>
method. Finally, an auxiliary look-and-feel may be removed from
the Virtual Machine by passing the <TT>removeAuxiliaryLookAndFeel</TT>
method the <TT>LookAndFeel</TT> instance to be removed.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>swing.properties</TT> file is only read at application startup. Changes in this file will not be used until the next time the Virtual Machine is started.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
A tremendous amount of material was presented in this chapter.
The flexibility of the pluggable look-and-feel architecture that
the Swing components are built on was explored. You saw that a
&quot;J&quot; component is not a single object. Instead, it is
two: the component that defines the API that the application programs
to and the user interface object that renders the component on
the display and interacts with the user. The separation of component
class and UI object allows the UI object to be changed without
affecting application code. This is the major strength of the
pluggable look-and-feel architecture.
<P>
This chapter presented many options for configuring a look-and-feel.
The look-and-feel implementations that are part of the JFC define
a multitude of properties that define the characteristics of the
look-and-feel. These properties include such items as colors,
fonts, icons, and borders. An application can modify any or all
of these properties to achieve an enormous amount of customization.
The Java look-and-feel contains a theme mechanism. Changing the
theme provides an easy alternative to changing properties for
colors and fonts in the <TT>UIManager</TT>. A theme can be switched
dynamically while the application is executing. Building a theme
editor will give the user the ability to alter the colors in a
theme while the application is executing. Alternatively, a theme
can be read from a property file to allow the user to edit the
theme file to easily configure the application.
<P>
Customizing the feel of an application isn't as easy as customizing
its look. To customize the feel of a component, its UI object
must be replaced with a customized version. The hooks in the basic
UI implementations that facilitate this process were explored.
A UI class that eliminates the double-click gesture from expanding
or collapsing a node in a tree instance was presented.
<P>
If customizing an existing look-and-feel doesn't meet your requirements,
an entirely new look-and-feel can be created and installed. In
this chapter, the Unleashed look-and-feel was presented. This
look-and-feel implementation, like the standard JFC look-and-feel
implementations, extends the <TT>BasicLookAndFeel</TT> class.
The Unleashed look-and-feel only provides UI classes for a few
components. The other UI classes are those in the basic package.
Adding additional UI classes and registering them in the <TT>UnleashedLook
AndFeel</TT> class can expand the Unleashed look-and-feel. To
develop a look-and-feel that provides a UI class for every component
is a large undertaking. The ability to use existing implementations
and adding classes as they are completed gives the developer a
clear path for completing a look-and-feel. Also, the completed
UI classes can be tested and reviewed as further classes are being
developed. This is a nice way to develop a complete look-and-feel.
<P>
Auxiliary look-and-feels can be used to interface to devices such
as sound cards and Braille readers. When an auxiliary look-and-feel
is registered with the system, the JFC uses the multiplexing look-and-feel.
When a UI object is created for a component, an instance of the
appropriate multiplexing look-and-feel is created. This UI object
manages the visual and auxiliary UI objects. When a UI method
is to be called, the multiplexing UI object calls the corresponding
methods in each look-and-feel. There should only be one visual
look-and-feel being used at any given time.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch22\ch22.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch24\ch24.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
