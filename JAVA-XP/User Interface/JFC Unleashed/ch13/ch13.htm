<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 13 - JPanel and Box Classes</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch12\ch12.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch14\ch14.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;13<br>
JPanel and Box Classes</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TheTTFONTSIZEJPanelFONTTTFONTSIZEClassFONT">
The <TT>JPanel</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEBoxFONTTTFONTSIZEClassFONT">
The <TT>Box</TT> Class
</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEBoxLayoutFONTTTFONTSIZEClassFONT">
The <TT>BoxLayout</TT> Class
</A>
<LI><A HREF="#InvisibleComponents">
Invisible Components</A>
<LI><A HREF="#StaticConfigurationMethods">
Static Configuration Methods</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJBoxFONTTTFONTSIZEClassFONT">
The <TT>JBox</TT> Class
</A>
<UL>
<LI><A HREF="#UsingtheTTFONTSIZEJBoxFONTTTFONTSIZEClassFONT">
Using the <TT>JBox</TT> Class
</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The simplest of the JFC container components is the <TT>JPanel</TT>
class. It provides a lightweight replacement for the AWT <TT>Panel</TT>
class. However, the <TT>JPanel</TT> class extends the <TT>JComponent</TT>
class, not <TT>Panel</TT> as you may have expected.
<P>
The <TT>Box</TT> class is a container component that contains
a <TT>BoxLayout</TT> for its layout manager. The <TT>Box</TT>
class also contains methods for creating and adding invisible
spacing components to the layout. These components give more options
when you're laying out the children of the <TT>Box</TT> container.
The <TT>Box</TT> class breaks form with the rest of the JFC containers.
It does not extend the <TT>JComponent</TT> class; instead, it
extends the AWT <TT>Container</TT> class. This makes <TT>Box</TT>
behave differently than other JFC components. For example, the
<TT>Box</TT> class does not have a <TT>border</TT> property. If
a border is needed around a <TT>Box</TT> container, it must first
be added to a <TT>JPanel</TT> instance, and the border must be
set on the <TT>JPanel</TT> instance.
<P>
In this chapter, you will learn
<UL>
<LI>How to use the <TT>JPanel</TT> class.
<LI>How to use the <TT>Box</TT> class.
<LI>How to add <TT>glue</TT>, <TT>rigid</TT>, and <TT>strut</TT>
components to <TT>Box</TT>.
</UL>
<H2><A NAME="TheTTFONTSIZEJPanelFONTTTFONTSIZEClassFONT">
The <TT>JPanel</TT> Class
</A></H2>
<P>
The <TT>JPanel</TT> class is a lightweight replacement for the
AWT <TT>Panel</TT> class. The primary purpose of the class is
to provide a concrete container in the JFC. If you recall from
the discussion of the <TT>JComponent</TT> class in <A HREF="..\ch03\ch03.htm" >Chapter 3</A>
&quot;<TT>JComponent</TT>,&quot; it is an abstract class. As such,
it cannot be instantiated. The <TT>JPanel</TT> class is provided
to give a concrete container class. Being an extension of the
<TT>JComponent</TT> class, it is a container and inherits the
features contained in that class.
<P>
The <TT>JPanel</TT> class adds very little functionality to its
inherited API. As a matter of fact, its constructors contain most
of the useful functionality. The signatures of the four constructors
contained in the class are shown below. As with its AWT cousin,
the <TT>JPanel</TT> class is configured with a shared instance
of the <TT>FlowLayout</TT> class. However, you can specify any
layout manager desired in the constructor. By default, instances
of the <TT>JPanel</TT> class are double buffered and opaque. As
with any <TT>JComponent</TT>, these properties can be set with
<TT>public</TT> methods:
<BLOCKQUOTE>
<PRE>
JPanel()
JPanel(boolean isDoubleBuffered) 
JPanel(java.awt.LayoutManager layout) 
JPanel(java.awt.LayoutManager layout, boolean isDoubleBuffered) 
</PRE>
</BLOCKQUOTE>
<P>
Later in this chapter, you will see how the <TT>JPanel</TT> class
can be extended to provide a custom container class.
<H2><A NAME="TheTTFONTSIZEBoxFONTTTFONTSIZEClassFONT">
The <TT>Box</TT> Class
</A></H2>
<P>
The <TT>Box</TT> class is an oddity in the JFC. It provides a
lightweight container that is configured with the <TT>BoxLayout</TT>
layout manager. When it's configured to align components along
the y-axis, adding components to the <TT>Box</TT> is like stacking
objects in a box (thus the name of this class and the layout manager).
The <TT>BoxLayout</TT> class is a new layout manager that is part
of the JFC. The <TT>Box</TT> class also contains several static
methods that create invisible components to help control the layout
of the container. What makes the <TT>Box</TT> class unusual is
that it does not extend the <TT>JComponent</TT> class. This means
that the properties contained in that class are not inherited.
This includes, but is not limited to, the <TT>border</TT> property
and keyboard handling. To fully understand the <TT>Box</TT> class,
you must first look at the <TT>BoxLayout</TT> class.
<H3><A NAME="TheTTFONTSIZEBoxLayoutFONTTTFONTSIZEClassFONT">
The <TT>BoxLayout</TT> Class
</A></H3>
<P>
The <TT>BoxLayout</TT> class is a layout manager contained in
the JFC. Conceptually, it is similar to the <TT>FlowLayout</TT>
layout manager contained in the AWT, in that it lays out a container's
components in the order they are added to the container. However,
the <TT>BoxLayout</TT> allows the components to be stacked vertically
as well as placed horizontally. The <TT>BoxLayout</TT> layout
manager also does not wrap components.
<P>
The orientation of the <TT>BoxLayout</TT> is specified at construction
and cannot be altered thereafter. The constants <TT>X_AXIS</TT>
and <TT>Y_AXIS</TT> are defined in the <TT>BoxLayout</TT> class
to specify a left-to-right or top-to-bottom component arrangement,
respectively. The following lines of code could be used to create
a <TT>JPanel</TT> and configure it with a vertically oriented
<TT>BoxLayout</TT> layout manager:
<BLOCKQUOTE>
<PRE>
JPanel panel = new JPanel();
BoxLayout boxLayout = new BoxLayout( panel, BoxLayout.Y_AXIS );
panel.setLayout( boxLayout );
</PRE>
</BLOCKQUOTE>
<P>
You will notice in this code fragment that the <TT>BoxLayout</TT>
class requires an AWT <TT>Container</TT> parameter in its constructor.
This is unlike the AWT layout managers, which do not bind themselves
to the container they are managing at construction. This reference
is used internally by the <TT>BoxLayout</TT> class to ensure that
instances are not shared between multiple container instances.
Because the binding is an AWT <TT>Container</TT> and not a <TT>JComponent</TT>,
the <TT>BoxLayout</TT> class can be used to manage any container.
<P>
The <TT>BoxLayout</TT> class respects a component's minimum and
maximum size properties. When the <TT>BoxLayout</TT> class is
configured to stack components along the y-axis, it tries to size
each component to its preferred height. The layout manager will
try to size each component to the same width, the largest preferred
width in the container. If the container is wider than this width,
the components are sized to the container's width if possible.
<P>
Listing 13.1 contains a simple application that demonstrates this
behavior. Three instances of the <TT>JPanel</TT> class are added
to a panel that is configured with a vertically oriented <TT>BoxLayout</TT>
layout manager. Each panel added to the outer panel is given a
different background color to distinguish it from each others.
The panel is shown in Figure 13.1 at its original size and then
after being enlarged. As shown in the figure, the panels are resized
to fill the space of the container. Also, each panel is sized
equally, horizontally and vertically.
<P>
<A HREF="javascript:popUp('f13-1.gif')"><B>Figure 13.1 :</B> <I>The BoxLayout manager</I>.</A>
<P>
<HR>
<P>
<B>Listing 13.1&nbsp;&nbsp;The BoxLayoutTest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays panels in a
 * panel configured with a BoxLayout layout manager.
 *
 * @author Mike Foley
 **/
public class BoxLayoutTestextends Object { 
    
    /**
     * Application entry point.
     * Create a panel with a BoxLayout layout manager.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot; BoxLayoutTest&quot; );
        
        JPanel panel = new JPanel();
        panel.setBorder( BorderFactory.createLoweredBevelBorder() );
        BoxLayout boxLayout = new BoxLayout( panel, BoxLayout.Y_AXIS );
        panel.setLayout( boxLayout );
        
        //
        // Add three panels to the outer panel.
        // Give each panel a different background color to
        // distinguish them in the window.
        //
        JPanel p = new JPanel();
        p.setBackground( Color.yellow );
        panel.add( p );

        p = new JPanel();
        p.setBackground( Color.blue );
        panel.add( p );

        p = new JPanel();
        p.setBackground( Color.green );
        panel.add( p );


        frame.getContentPane().add( panel, BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // BoxLayoutTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>BoxLayout</TT> class respects the minimum and maximum
sizes of components while laying out a container. You can verify
this by changing the preceding example to set minimum and maximum
sizes for the three panels managed by the <TT>BoxLayout</TT> layout
manager, as shown here:
<BLOCKQUOTE>
<PRE>
JPanel p = new JPanel();
p.setBackground( Color.yellow );
p.setMinimumSize( new Dimension( 200, 10 ) );
p.setMaximumSize( new Dimension( 200, 10 ) );
panel.add( p );

p = new JPanel();
p.setBackground( Color.blue );
p.setMaximumSize( new Dimension( 100, 5 ) );
panel.add( p );

p = new JPanel();
p.setMinimumSize( new Dimension( 300, 20 ) );
p.setMaximumSize( new Dimension( 400, 30 ) );
p.setBackground( Color.green );
panel.add( p );
</PRE>
</BLOCKQUOTE>
<P>
The resulting panel, after the window has been expanded, is shown
in Figure 13.2. As you can see, the maximum size for each of the
color panels has not been exceeded.
<P>
<A HREF="javascript:popUp('f13-2.gif')"><B>Figure 13.2 :</B> <I>Minimum and maximum sizes in the BoxLayout
manager</I>.</A>
<P>
In Figure 13.2, each colored panel is centered in the center panel.
The <TT>BoxLayout</TT> layout manager uses the <TT>alignmentX</TT>
or <TT>alignmentY</TT> property contained in the <TT>AWT Component</TT>
class to determine where components are located when they don't
fill the width of the container for vertical layouts, or the height
for horizontal layouts. Each of the alignment properties is a
<TT>float</TT> value that ranges from 0.0 to 1.0. The value 0.0
represents left alignment for vertical layouts and top alignment
for horizontal layouts. Similarly, 1.0 represents right alignment
for vertical layouts and bottom alignment for horizontal layouts.
A value of 0.5 is center alignment for both types of layouts.
The constants <TT>LEFT_ALIGNMENT</TT>, <TT>RIGHT_ALIGNMENT</TT>,
<TT>TOP_ALIGNMENT</TT>, <TT>BOTTOM_ALIGNMENT</TT>, and <TT>CENTER_ALIGNMENT</TT>
are defined in the AWT <TT>Component</TT> class for these common
placements.
<P>
The <TT>JPanel</TT> class contains default values for the <TT>alignmentX</TT>
and <TT>alignmentY</TT> properties of 0.5, which explains why
the panels are centered in Figure 13.2. However, other classes
may have different default values for these properties. For example,
the <TT>JLabel</TT> class has the <TT>alignmentX</TT> property
set to <TT>Component.LEFT_ALIGNMENT</TT>. You can verify this
by changing the preceding example to create <TT>JLabel</TT> instances
instead of <TT>JPanel</TT> instances. This is shown below. The
<TT>opaque</TT> property is set to <TT>true</TT> for each label.
This wasn't required for the panels because, as you saw in the
previous section, panels are opaque by default:
<BLOCKQUOTE>
<PRE>
JLabel label = new JLabel( &quot;Label 1&quot; );
label.setOpaque( true );
label.setBackground( Color.yellow );
panel.add( label );
        
label = new JLabel( &quot;Label 2&quot; );
label.setOpaque( true );
label.setBackground( Color.blue );
panel.add( label );
        
label = new JLabel( &quot;Label 3&quot; );
label.setOpaque( true );
label.setBackground( Color.green );
panel.add( label );       
</PRE>
</BLOCKQUOTE>
<P>
The resulting window is shown in Figure 13.3. Note that the <TT>JLabel</TT>
class returns its preferred size as its minimum and maximum sizes.
Once again, other classes may behave differently.
<P>
<A HREF="javascript:popUp('f13-3.gif')"><B>Figure 13.3 :</B> <I>JLabel instances in the BoxLayout layout
manager</I>.</A>
<P>
Understanding how the <TT>alignmentX</TT> and <TT>alignmentY</TT>
properties are used by the <TT>BoxLayout</TT> layout manager is
difficult without practice. Listing 13.2 contains an application
that dynamically alters these properties to show how a <TT>BoxLayout</TT>
layout manager uses them when laying out a panel. This application
contains three sliders that alter the <TT>alignmentX</TT> or <TT>alignmentY
</TT>property of the three <TT>JLabel</TT> instances in its left
panel. The application, shown in Figure 13.4, takes a single parameter
that specifies the axis by which to configure the <TT>BoxLayout</TT>
layout manager. Passing the application <TT>horizontal</TT> configures
the layout manager along the x-axis. Specifying <TT>vertical</TT>
or no parameter configures the layout manager for the y-axis.
Moving the sliders allows you to see how the properties are used
by the layout manager.
<P>
<A HREF="javascript:popUp('f13-4.gif')"><B>Figure 13.4 :</B> <I>Horizontal and vertical BoxLayoutTest application</I>.</A>
<P>
The <TT>BoxLayoutTest</TT> panel itself uses a <TT>BoxLayout</TT>
layout manager to configure the label and slider panel. The <TT>glue</TT>
component added in the constructor will be discussed in the next
section. It is also educational to replace the labels with other
types of components to see their default alignment parameters.
The <TT>BoxLayoutTest</TT> application demonstrates how relatively
complex arrangements can be built by nesting panels.
<P>
<HR>
<P>
<B>Listing 13.2&nbsp;&nbsp;The </B><TT><B>BOXLAYOUTTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.event.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a set of three labels in
 * a panel on the left side of the window. Three sliders
 * are shown on the right. Each sliders controls one of
 * the alignment properties of the corresponding label.
 * If the layout is X or Y oriented determines the property 
 * to control.
 * &lt;p&gt;
 * As the sliders are moved, the label panel is revalidated
 * to show the new layout.
 *
 * @author Mike Foley
 **/
public class BoxLayoutTest extends JPanel 
    implements ChangeListener { 
    
    /**
     * If true, the layout is horizontal, if false, vertical.
     **/
    private boolean horizontal;
    
    /**
     * The sliders that control the alignment property.
     **/
    protected JSlider slider1;
    protected JSlider slider2;
    protected JSlider slider3;
    
    /**
     * The label's who's alignment property is being set.
     **/
    protected JLabel label1;
    protected JLabel label2;
    protected JLabel label3;

    protected JPanel labelPanel;
    
    
    /**
     * Create the component is the display.
     * Use a BoxLayout to arrange the nested panels.
     * This class acts as a mediator between the sliders
     * and the labels.
     **/
    public BoxLayoutTest( boolean horizontal ) { 
        
        this.horizontal = horizontal;
        
        BoxLayout boxLayout = new BoxLayout( this, BoxLayout.X_AXIS );
        setLayout( boxLayout );
        
        labelPanel = createLabelPanel();
        labelPanel.setBorder( BorderFactory.createLoweredBevelBorder() );
        add( new JScrollPane( labelPanel ) );
        
        add( Box.createGlue() );
        
        JPanel sliders = createSliderPanel();
        add( sliders );
    } 
    
    
    /**
     * Create the labels used in this demo.
     **/
    protected JPanel createLabelPanel() { 
        
        JPanel panel = new JPanel();
        BoxLayout boxLayout;
        if( isHorizontal() )
            boxLayout = new BoxLayout( panel, BoxLayout.X_AXIS );
        else
            boxLayout = new BoxLayout( panel, BoxLayout.Y_AXIS );
        panel.setLayout( boxLayout );

        label1 = new JLabel( &quot;Label 1&quot; );
        label1.setOpaque( true );
        label1.setBackground( Color.yellow );
        panel.add( label1 );
        
        label2 = new JLabel( &quot;Label 2&quot; );
        label2.setOpaque( true );
        label2.setBackground( Color.blue );
        panel.add( label2 );
        
        label3 = new JLabel( &quot;Label 3&quot; );
        label3.setOpaque( true );
        label3.setBackground( Color.green );
        panel.add( label3 );
        
        return( panel );
    } 
    

    /**
     * @return True if the alignment is horizontal.
     **/
    public boolean isHorizontal() { 
        return( horizontal );
    } 
    
    
    /**
     * Create the sliders.
     * Each slider contains the range from 0-100 that
     * will be mapped to 0 - 1.0 for the label alignment.
     * &lt;p&gt;
     * This method assumes the labels are already created.
     * Set the slider background to match the label's background
     * that the slider adjust.
     **/
    protected JPanel createSliderPanel() { 
        JPanel panel = new JPanel();
        BoxLayout boxLayout = new BoxLayout( panel, BoxLayout.Y_AXIS );
        panel.setLayout( boxLayout );

        slider1 = new JSlider();
        slider1.setPaintLabels( true );
        slider1.setPaintTicks( true );
        slider1.setMajorTickSpacing( 20 );
        slider1.setMinorTickSpacing( 5 );
        slider1.setBackground( Color.yellow );
        if( isHorizontal() )
            slider1.setValue( ( int )( label1.getAlignmentY() * 100 ) );
        else       
            slider1.setValue( ( int )( label1.getAlignmentX() * 100 ) );
        panel.add( slider1 );
        slider1.addChangeListener( this );
        
        slider2 = new JSlider();
        slider2.setPaintLabels( true );
        slider2.setPaintTicks( true );
        slider2.setMajorTickSpacing( 20 );
        slider2.setMinorTickSpacing( 5 );
        slider2.setBackground( Color.blue );
        slider2.setForeground( Color.white );
        if( isHorizontal() )
            slider2.setValue( ( int )( label1.getAlignmentY() * 100 ) );
        else               
            slider2.setValue( ( int )( label1.getAlignmentX() * 100 ) );
        panel.add( slider2 );
        slider2.addChangeListener( this );
        
        slider3 = new JSlider();
        slider3.setPaintLabels( true );
        slider3.setPaintTicks( true );
        slider3.setMajorTickSpacing( 20 );
        slider3.setMinorTickSpacing( 5 );
        slider3.setBackground( Color.green );
        if( isHorizontal() )
            slider3.setValue( ( int )( label1.getAlignmentY() * 100 ) );
        else
            slider3.setValue( ( int )( label1.getAlignmentX() * 100 ) );
        panel.add( slider3 );
        slider3.addChangeListener( this );
                
        return( panel );
    } 
    
    
    /**
     * One of the sliders has changed. See which
     * one and update the alignment property of
     * the corresponding label.
     **/
    public void stateChanged( ChangeEvent e ) { 
        Object source = e.getSource();
        if( source == slider1 ) { 
            int value = slider1.getValue();
            if( isHorizontal() )
                label1.setAlignmentY( ( float )value / ( float )100.0 );
            else
                label1.setAlignmentX( ( float )value / ( float )100.0 );
        }  else if( source == slider2 ) { 
            int value = slider2.getValue();
            if( isHorizontal() )
                label2.setAlignmentY( ( float )value / ( float )100.0 );
            else            
                label2.setAlignmentX( ( float )value / ( float )100.0 );
        }  else if( source == slider3 ) { 
            int value = slider3.getValue();
            if( isHorizontal() )
                label3.setAlignmentY( ( float )value / ( float )100.0 );
            else       
                label3.setAlignmentX( ( float )value / ( float )100.0 );
        } 
        
        //
        // Force the label panel to layout the labels.
        //
        labelPanel.revalidate();
    } 
    
    
    /**
     * Application entry point.
     * Create the panels and display them.
     * &lt;p&gt;
     * The application takes a single parameter,
     * horizontal. If this is not specified, or no
     * parameter is specified, vertical alignment
     * is used. If more parameters are specified, they
     * are ignored.
     * &lt;p&gt;
     * @param args vertical for vertical alignment.
     **/
    public static void main( String args[] ) { 

        boolean horizontal = false;
        
        //
        // Parse the single possible parameter.
        //
        if( 0 &lt; args.length ) { 
            String param = args[0].toUpperCase();
            if( param.equals( &quot;HORIZONTAL&quot; ) )
                horizontal = true;
        } 
        
        JFrame frame = new ApplicationFrame( &quot; BoxLayoutTest&quot; );
        
        JPanel panel = new BoxLayoutTest( horizontal );
        panel.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( panel, BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // BoxLayoutTest
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="InvisibleComponents">
Invisible Components</A></H3>
<P>
The <TT>BoxLayout</TT> layout manager class places components
next to each other in the container being managed. This often
causes the container to appear cramped. This is shown in Figure
13.3, where the labels are placed right on top of each other.
An empty border could be set on the labels to space the container,
or invisible components could be added to the container. The <TT>Box</TT>
class contains static methods that return invisible components,
which can be used to help arrange the components in a container.
Three types of invisible components are available: <TT>rigid</TT>,
<TT>glue</TT>, and <TT>strut</TT>. However, JavaSoft is discouraging
the use of <TT>strut</TT>s with the <TT>BoxLayout</TT> layout
manager. From the JavaSoft documentation:
<BLOCKQUOTE>
The <TT>Box</TT> class provides another kind of filler for putting
fixed space between components: a vertical or horizontal <TT>strut</TT>.
Unfortunately, <TT>strut</TT>s have unlimited maximum heights
and widths (for horizontal and vertical <TT>strut</TT>s, respectively).
This means that if you use a horizontal box within a vertical
box, the horizontal box can sometimes become too tall. For this
reason, we recommend that you use <TT>rigid</TT> areas instead
of <TT>strut</TT>s.
</BLOCKQUOTE>
<P>
The following two sections give example usage of the <TT>rigid</TT>
and <TT>glue</TT> invisible components. The <TT>strut</TT> component
is not discussed here. The methods that create these components
are static, so they can be used to add invisible components to
any container, not just instances of the <TT>Box</TT> class.
<H4><TT>rigid</TT> Components</H4>
<P>
A <TT>rigid</TT> component takes up a defined amount of space
and is not resizable. The static <TT>createRigidArea</TT> method
in the <TT>Box</TT> class takes a <TT>Dimension</TT> parameter
and returns an AWT component the size of the given dimension.
Space can be added between the labels from the example application,
shown in Figure 13.3, by adding <TT>rigid</TT> components to the
container. The following change to the code, which creates the
labels and adds them to the container, demonstrates this technique:
<BLOCKQUOTE>
<PRE>
//
// Add three labels to the outer panel.
// Give each label a different background color 
// and make it opaque to see the color.
//
// Use rigid areas to add some space between the labels.
//
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        
JLabel label = new JLabel( &quot;Label 1&quot; );
label.setOpaque( true );
label.setBackground( Color.yellow );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );

label = new JLabel( &quot;Label 2&quot; );
label.setOpaque( true );
label.setBackground( Color.blue );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        
label = new JLabel( &quot;Label 3&quot; );
label.setOpaque( true );
label.setBackground( Color.green );
panel.add( label );       

panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
</PRE>
</BLOCKQUOTE>
<P>
The resulting container is shown in Figure 13.5.
<P>
<A HREF="javascript:popUp('f13-5.gif')"><B>Figure 13.5 :</B> <I>rigid components added to a BoxLayout</I>.</A>
<H4><TT>glue</TT> Components</H4>
<P>
The example in the previous section used <TT>rigid</TT> components
to add space between the labels in the container. This added a
fixed area between the labels that did not change. If the container
is resized, this may not produce the desired results. For example,
Figure 13.6 shows the previous example after it has been expanded.
All the extra space from the layout is added to the bottom of
the container, and the labels remain fixed at the top of the container.
<P>
<A HREF="javascript:popUp('f13-6.gif')"><B>Figure 13.6 :</B> <I>Expanded rigid components in the BoxLayout
example</I>.</A>
<P>
An invisible <TT>glue</TT> component will stretch to any size
required by the layout manager. In the previous example, if the
labels were to remain vertically centered in the container, the
first and last <TT>rigid</TT> components could be changed to <TT>glue</TT>.
However, a <TT>glue</TT> component's preferred dimensions are
zero width and height. Replacing the <TT>rigid</TT> component
would remove the space on top of the first label and below the
bottom label. This is shown in Figure 13.7. If the initial space
above and below the labels is desired, the <TT>glue</TT> can be
added along with the <TT>rigid</TT> components. When the container
is resized, the labels remain centered in the container. This
code is shown below, and the resulting container is shown in Figure
13.8.
<P>
<A HREF="javascript:popUp('f13-7.gif')"><B>Figure 13.7 :</B> <I>glue augmenting top and bottom rigid components
in a BoxLayout</I>.</A>
<P>
<A HREF="javascript:popUp('f13-8.gif')"><B>Figure 13.8 :</B><I> Top and bottom glue components in addition
to rigid components in a BoxLayout</I>.</A><BR>
<BLOCKQUOTE>
<PRE>
panel.add( Box.createGlue() );
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );

JLabel label = new JLabel( &quot;Label 1&quot; );
label.setOpaque( true );
label.setBackground( Color.yellow );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        
label = new JLabel( &quot;Label 2&quot; );
label.setOpaque( true );
label.setBackground( Color.blue );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        
label = new JLabel( &quot;Label 3&quot; );
label.setOpaque( true );
label.setBackground( Color.green );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
panel.add( Box.createGlue() );
</PRE>
</BLOCKQUOTE>
<P>
A <TT>glue</TT> component could be placed between each label.
This would force the <TT>BoxLayout</TT> layout manager to evenly
distribute extra space between each label in the container. This
code is shown below, and the resulting container is shown in Figure
13.9, both before and after resizing the frame. As shown in the
figure, the <TT>rigid</TT> components add spacing to the initial
layout, and the <TT>glue</TT> components force the layout manager
to evenly distribute the labels when the panel is larger than
its preferred size.
<P>
<A HREF="javascript:popUp('f13-9.gif')"><B>Figure 13.9 :</B> <I>glue components in addition to rigid components
in a BoxLayout</I>.</A><BR>
<BLOCKQUOTE>
<PRE>
panel.add( Box.createGlue() );
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );

JLabel label = new JLabel( &quot;Label 1&quot; );
label.setOpaque( true );
label.setBackground( Color.yellow );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
panel.add( Box.createGlue() );
        
label = new JLabel( &quot;Label 2&quot; );
label.setOpaque( true );
label.setBackground( Color.blue );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
panel.add( Box.createGlue() );
        
label = new JLabel( &quot;Label 3&quot; );
label.setOpaque( true );
label.setBackground( Color.green );
panel.add( label );
        
panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
panel.add( Box.createGlue() );
</PRE>
</BLOCKQUOTE>
<P>
The methods <TT>createVerticalGlue</TT> and <TT>createHorizontalGlue</TT>
in the <TT>Box</TT> class create invisible <TT>glue</TT> components
that only expand in one direction.
<H3><A NAME="StaticConfigurationMethods">
Static Configuration Methods</A></H3>
<P>
The <TT>Box</TT> class contains two static methods that return
a <TT>Box</TT> configured with a <TT>BoxLayout</TT> along the
implied axis. These methods, <TT>createHorizontalBox</TT> and
<TT>createVerticalBox</TT>, configure the <TT>BoxLayout</TT> layout
manager along the x-axis and y-axis, respectively. Using one of
these methods eliminates the need to call the <TT>Box</TT> constructor
with the axis parameter.
<H2><A NAME="TheTTFONTSIZEJBoxFONTTTFONTSIZEClassFONT">
The <TT>JBox</TT> Class
</A></H2>
<P>
In the previous section, the <TT>Box</TT> class was presented.
It was pointed out that the <TT>Box</TT> class doesn't extend
the <TT>JComponent</TT> class. As such, it does not inherit the
properties or functionality of that class. You also saw how the
<TT>BoxLayout</TT> class provides simple layout management that
is sufficient for many containers. Creating your own <TT>JBox</TT>
class can eliminate the shortcomings of the <TT>Box</TT> class.
<P>
The <TT>JBox</TT> class shown in Listing 13.3 is a replacement
for the <TT>Box</TT> class, which is a descendant of the <TT>JComponent</TT>
class. Because the methods that create invisible components in
the <TT>Box</TT> class are static, they can be used to create
invisible components for the <TT>JBox</TT> class:
<P>
<HR>
<P>
<B>Listing 13.3&nbsp;&nbsp;The </B><TT><B>JBOX</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import javax.swing.*;


/**
 * The JBox class is a Box replacement that
 * is a descendent of the JComponent class.
 * It is a JPanel configured with a BoxLayout
 * layout manager.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class JBox extends JPanel {  
    
    public JBox( int orientation ) { 
        BoxLayout boxLayout = new BoxLayout( this, orientation );
        setLayout( boxLayout );
    } 
    

    /**
     * Create a JBox configured along its X-axis.
     * &lt;p&gt;
     * @return A JBox configured along its X-axis.
     **/
    public static JBox createHorizontalJBox() { 
        return new JBox( BoxLayout.X_AXIS );
    } 

    
    /**
     * Create a JBox configured along its Y-axis.
     * &lt;p&gt;
     * @return A JBox configured along its Y-axis.
     **/
    public static JBox createVerticalJBox() { 
        return new JBox( BoxLayout.X_AXIS );
    } 
    
}  // JBox
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="UsingtheTTFONTSIZEJBoxFONTTTFONTSIZEClassFONT">
Using the <TT>JBox</TT> Class
</A></H3>
<P>
The <TT>JBox</TT> class is an API-compatible replacement for the
<TT>Box</TT> class contained in the JFC. The static, invisible
component-creation methods are not duplicated in the <TT>JBox</TT>
class. These methods are static in the <TT>Box</TT> class, so
they can be used with the <TT>JBox</TT> class, or any other class
for that matter. The primary reason for using the <TT>JBox</TT>
class instead of the <TT>Box</TT> class is to enable the functionality
inherited from the <TT>JComponent</TT> class. For example, a border
can be set on a <TT>JBox</TT> instance, but not on a <TT>Box</TT>
instance.
<P>
Listing 13.4 presents the <TT>JBoxTest</TT> application, which
replaces the <TT>JPanel</TT> instance configured with a <TT>BoxLayout</TT>
layout manager from the previous section with a <TT>JBox</TT>
instance. The static <TT>createVerticalJBox</TT> method in the
<TT>JBox</TT> class is used to create a box configured with a
<TT>BoxLayout</TT> instance aligned along its vertical axis. Notice
how a border is added to the <TT>JBox</TT> instance itself in
the next line. Keystroke management, as shown in <A HREF="..\ch03\ch03.htm" >Chapter 3</A> &quot;HTML
Tools,&quot; could also be added to the <TT>JBox</TT> instance.
The resulting application looks and behaves identically to that
shown in Figure 13.9.
<P>
<HR>
<P>
<B>Listing 13.4&nbsp;&nbsp;The </B><TT><B>JBOXTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that displays a JBox panel.
 * Three labels are added to the panel. They are
 * separated with rigid areas and glue. This spaces
 * the labels in the preferred size of the panel,
 * and evenly spaces the labels in larger sizes.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class JBoxTest extends Object { 
    
    /**
     * Application entry point.
     * Create the JBox and labels. Add the labels
     * to the jBox, and space them using glue
     * and rigid invisible components.
     * &lt;p&gt;
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;JBoxTest&quot; );
        
        JPanel panel = JBox.createVerticalJBox();
        panel.setBorder( BorderFactory.createLoweredBevelBorder() );
                
        panel.add( Box.createGlue() );
        panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );

        JLabel label = new JLabel( &quot;Label 1&quot; );
        label.setOpaque( true );
        label.setBackground( Color.yellow );
        panel.add( label );
        
        panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        panel.add( Box.createGlue() );
        
        label = new JLabel( &quot;Label 2&quot; );
        label.setOpaque( true );
        label.setBackground( Color.blue );
        panel.add( label );
        
        panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        panel.add( Box.createGlue() );
        
        label = new JLabel( &quot;Label 3&quot; );
        label.setOpaque( true );
        label.setBackground( Color.green );
        panel.add( label );
        
        panel.add( Box.createRigidArea( new Dimension( 1, 4 ) ) );
        panel.add( Box.createGlue() );
        
        frame.getContentPane().add( panel, BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // JBoxTest
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter presented <TT>JPanel</TT> and <TT>Box</TT>, two relatively
simple container classes contained in the JFC. The <TT>JPanel</TT>
class provides a lightweight container that can be instantiated.
It inherits the majority of its functionality from the <TT>JComponent</TT>
class and contains very little additional code.
<P>
The <TT>Box</TT> class is an unusual JFC visual component in that
it doesn't inherit from the <TT>JComponent</TT> class. It's a
lightweight extension of the AWT <TT>Container</TT> class that
comes configured with a <TT>BoxLayout</TT> layout manager. This
layout manager is new to the JFC. Its options and usage were also
presented in this chapter. (The <TT>BoxLayout</TT> class can be
used with any container, not just the <TT>Box</TT> class.)
<P>
The <TT>Box</TT> class contains static methods to create invisible
components that can add space in a container. Although these methods
were presented in containers managed by a <TT>BoxLayout</TT> layout
manager, they can be added to any container. The <TT>rigid</TT>
component is of a fixed size that does not change. A <TT>glue</TT>
component has a zero preferred size, but it can be expanded in
one or both directions to fill the component, as required by the
layout manager.
<P>
The <TT>JBox</TT> class was created to fill the void of the <TT>Box</TT>
class. It is a descendant of the <TT>JComponent</TT> class, so
it inherits the features contained in that class. This class is
more consistent with other JFC visual components than the <TT>Box</TT>
class.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch12\ch12.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch14\ch14.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
