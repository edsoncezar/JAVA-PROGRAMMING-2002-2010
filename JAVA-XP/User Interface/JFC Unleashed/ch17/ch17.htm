<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 17 - Internal Frames</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch16\ch16.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch18\ch18.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;17<br>
Internal Frames</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TheTTFONTSIZEJInternalFrameFONTTTFONTSIZEClassFONT">
The <TT>JInternalFrame</TT>
Class</A>
<UL>
<LI><A HREF="#ATopLevelInternalFrame">
A Top-Level Internal Frame?</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJDesktopPaneFONTTTFONTSIZEClassFONT">
The <TT>JDesktopPane</TT>
Class</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEDesktopManagerFONTTTFONTSIZEInterfaceFONT">
The <TT>DesktopManager</TT>
Interface</A>
</UL>
<LI><A HREF="#IntegratingTTFONTSIZEJInternalFrameFONTTTFONTSIZEandFONTTTFONTSIZEJDesktopPaneFONTTTFONTSIZEUsageFONT">
Integrating <TT>JInternalFrame</TT>
and <TT>JDesktopPane</TT>
Usage</A>
<UL>
<LI><A HREF="#CustomizingtheTTFONTSIZEJInternalFrameFONTTTFONTSIZEInstancesFONT">
Customizing the <TT>JInternalFrame</TT>
Instances</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The success of programs like MS Word and Excel popularized the
multiple document interface (MDI). This type of interface contains
many frame windows contained in a single top-level frame. The
internal frames can be sized, dragged, and iconified independently
of the other frames. The single top-level frame groups the internal
frames. If the top-level frame is iconified, the internal frames
are iconified with it. The MDI allows all the views in an application
to be contained in a single frame. This interface model is showing
its age at this time and is being replaced by variants of the
MDI.
<P>
The JFC contains the <TT>JInternalFrame</TT> and <TT>JDesktopPane</TT>
classes that provide a frame and a frame management pane that
can be added to other frames. The internal frames are added to
the desktop pane that interfaces with the desktop manager. The
<TT>DesktopManager</TT> instance is responsible for managing look-and-feel-specific
issues regarding frame decorations, closing, moving, and so on.
These classes allow the application developer to create whatever
interface he or she requires. A complete MDI interface is not
provided in the JFC. Instead, the tools required to build any
type of interface are provided.
<P>
In this chapter, you will learn
<UL>
<LI>How to use the <TT>JInternalFrame</TT> class
<LI>How the <TT>JDesktopPane</TT> is used
<LI>How to use the <TT>JInternalFrame</TT> and <TT>JDesktopPane</TT>
classes together
</UL>
<H2><A NAME="TheTTFONTSIZEJInternalFrameFONTTTFONTSIZEClassFONT">
The <TT>JInternalFrame</TT>
Class</A></H2>
<P>
The <TT>JInternalFrame</TT> class provides a lightweight container
sharing most of the features of the <TT>JFrame</TT> class. The
fundamental difference between the two classes is that you can
add a <TT>JInternalFrame</TT> instance to other frames, and a
<TT>JFrame</TT> instance is a top-level window. The <TT>JInternalFrame</TT>
class extends the <TT>JComponent</TT> class, while the <TT>JFrame</TT>
class extends the AWT <TT>Frame</TT> class.
<P>
The discussion of the <TT>JRootPane</TT> class (and the panes
it creates) being the single child of a <TT>JFrame</TT> instance
presented in <A HREF="..\ch08\ch08.htm" >Chapter 8</A> &quot;Frame Windows,&quot; is valid for
the <TT>JInternalFrame</TT> class and will not be repeated here.
However, it is worth repeating that adding components and setting
layout managers are performed on the content pane, not the internal
frame itself. This technique will be demonstrated throughout this
chapter.
<P>
A <TT>JInternalFrame</TT> instance appears similar to a top-level
frame. It contains a titlebar and a border. The titlebar may contain
a title, an icon, minimize and maximize buttons, and a close button.
The window decoration is only shown if the internal frame supports
the operation. A <TT>JInternalFrame</TT> created with the default
constructor will not contain any of these decorations as the default
state of an internal frame is not iconifiable, not maximizable,
not closable, not resizable, and the title is empty. If the internal
frame is resizable, the user can drag on the border to resize
the frame. Each of these properties can be set individually with
the <TT>setResizable</TT>, <TT>setClosable</TT>, <TT>setIconifiable</TT>,
and <TT>setMaximizable</TT> methods. The current value of each
of these properties can be queried with the <TT>is</TT> version
of each method. For example, the <TT>isMaximizable</TT> method
may be used to query the state of the <TT>maximizable</TT> property.
These are not bound properties of the internal frame. 
<P>
You can specify the title with the <TT>setTitle</TT> method and
query it with the <TT>getTitle</TT> method. The title is a bound
property of the <TT>JInternalFrame</TT> class. The icon for the
internal frame can be set with the <TT>setFrameIcon</TT> method.
The <TT>getFrameIcon</TT> method can be used to query the current
icon associated with the internal frame. The frame icon is also
a bound property of the class. The complete list of bound properties
introduced in the <TT>JInternalFrame</TT> class is shown in Table
17.1. The property names are constants defined in the <TT>JInternalFrame</TT>
class.<BR>
<P>
<CENTER><B>Table 17.1&nbsp;&nbsp;Bound Properties Introduced in
the </B><TT><B>JINTERNALFRAME</B></TT><B>
Class</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=192><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=192><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>MENU_BAR_PROPERTY</TT></TD><TD WIDTH=192><TT>setMenuBar</TT>
</TD><TD WIDTH=192><TT>getMenuBar</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>MENU_BAR_PROPERTY</TT></TD><TD WIDTH=192><TT>setJMenuBar</TT>
</TD><TD WIDTH=192><TT>getJMenuBar</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CONTENT_PANE_PROPERTY</TT></TD><TD WIDTH=192><TT>setContentPane</TT>
</TD><TD WIDTH=192><TT>getContentPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>LAYERED_PANE_PROPERTY</TT></TD><TD WIDTH=192><TT>setLayeredPane</TT>
</TD><TD WIDTH=192><TT>getLayeredPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GLASS_PANE_PROPERTY</TT></TD><TD WIDTH=192><TT>setGlassPane</TT>
</TD><TD WIDTH=192><TT>getGlassPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ROOT_PANE_PROPERTY</TT></TD><TD WIDTH=192><TT>setRootPane</TT>
</TD><TD WIDTH=192><TT>getRootPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>IS_CLOSED_PROPERTY</TT></TD><TD WIDTH=192><TT>setClosed</TT>
</TD><TD WIDTH=192><TT>isClosed</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>IS_ICON_PROPERTY</TT></TD><TD WIDTH=192><TT>setIcon</TT>
</TD><TD WIDTH=192><TT>isIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>TITLE_PROPERTY</TT></TD><TD WIDTH=192><TT>setTitle</TT>
</TD><TD WIDTH=192><TT>getTitle</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>IS_SELECTED_PROPERTY</TT></TD><TD WIDTH=192><TT>setSelected</TT>
</TD><TD WIDTH=192><TT>isSelected</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>FRAME_ICON_PROPERTY</TT></TD><TD WIDTH=192><TT>setFrameIcon</TT>
</TD><TD WIDTH=192><TT>getFrameIcon</TT></TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
It seems odd that pane properties are fired from the <TT>JInternalFrame</TT> class. The setter and getter methods are convenience methods that call the appropriate method of the <TT>JRootPane</TT> class. If the <TT>PropertyChangeEvent</TT> were fired from the <TT>JRootPane</TT> class, it would also be available from the <TT>JWindow</TT>, <TT>Jframe</TT>, and <TT>JDialog</TT> classes that also use the <TT>JRootPane</TT> class but do not fire a <TT>PropertyChangeEvent</TT> when one of the panes is changed.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>InternalFrameTest</TT> application is shown in Listing
17.1. In the <TT>main</TT> method, an <TT>ApplicationFrame</TT>
is created and displayed. A <TT>JInternalFrame</TT> instance is
created and configured to be resizable, closable, iconifiable,
and maximizable. There are also variants of the <TT>JInternalFrame</TT>
class constructor that allow these properties to be specified
at construction time. The internal frame is then added to the
center of the content pane of the application frame. The resulting
windows for the Java and Windows look-and-feel are shown in Figure
17.1. The internal frame class Java look-and-feel is very different
than the Windows look-and-feel. The icons and resize borders are
very unique. The Java look-and-feel also contains the controversial
notch under the controls on the right side of the titlebar. Unfortunately,
the icons and border cannot be set to match those found on the
top-level frame. This is because the Windows window manager defines
the look of those controls, and they cannot be altered by the
application. This fact makes the Java look-and-feel less appealing
for internal frames.
<P>
<A HREF="javascript:popUp('f17-1.gif')"><B>Figure 17.1 :</B> <I>Internal frames in the Java (top) and Windows
(bottom) look-and-feels</I>.</A>
<P>
<HR>
<P>
<B>Listing 17.1&nbsp;&nbsp;The InternalFrameTest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import javax.swing.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a frame that
 * contains internal frames.
 *
 * @author Mike Foley
 **/
public class InternalFrameTest extends Object { 

    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        //
        // Un-comment these lines to enable the Windows LAF.
        //
    //    try { 
    //        UIManager.setLookAndFeel( 
    //            &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
    //    }  catch( Exception ex ) { 
    //        System.err.println( &quot;Exception: &quot; + 
    //            ex.getLocalizedMessage() );
    //    } 
</PRE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
<PRE>
        JFrame frame = new ApplicationFrame( &quot;Internal Frame Test&quot; );

        JInternalFrame internalFrame = 
                       new JInternalFrame( &quot;Internal JLabel&quot; );
        internalFrame.getContentPane().add( new JLabel( &quot;Hello&quot; ) );
        internalFrame.setResizable( true );
        internalFrame.setClosable( true );
        internalFrame.setIconifiable( true );
        internalFrame.setMaximizable( true );
        internalFrame.pack();
        
        frame.getContentPane().add( internalFrame, BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // InternalFrameTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>InternalFrameTest</TT> application shows that <TT>JInternalFrame</TT>
instances can be used like any other component. Although the class
is used primarily in an MDI type mode, it can be used with any
layout manager. However, current bugs in the <TT>JInternalFrame</TT>
class cause <TT>NullPointerException</TT> exceptions to be thrown
when the mouse is clicked over the internal frame.
<P>
The methods to enable an internal frame to be iconifiable, maximizable,
and closable were presented earlier. If these properties are enabled,
there are also methods that allow the application to set and query
the corresponding states. For example, if the internal frame is
closable, the <TT>isClosed</TT> method can be used to determine
if it is currently closed, and the <TT>setClosed</TT> method can
be used to close the internal frame. The <TT>dispose</TT> method
is called when the internal frame is no longer required. The methods
for an iconifiable internal frame are <TT>isIcon</TT>, to determine
if the frame is currently iconified, and <TT>setIcon</TT>, to
iconify and restore the internal frame. For the maximizable property,
the associated methods are <TT>isMaximum</TT> and <TT>setMaximum</TT>.
<H3><A NAME="ATopLevelInternalFrame">
A Top-Level Internal Frame?</A></H3>
<P>
As was pointed out in the previous section, mixing internal frames
by using the Java look-and-feel on the MS Windows platform looks
odd. The native frame contains the Windows titlebar controls and
resize border while the internal frames contain the Java look-and-feel
titlebar controls and resize border. A pseudo top-level frame
can be created by adding an internal frame to a <TT>JWindow</TT>
instance. An example demonstrating this technique is shown in
Listing 17.2. The <TT>WindowFrameTest</TT> application creates
the window shown in Figure 17.2.
<P>
<HR>
<P>
<B>Listing 17.2&nbsp;&nbsp;The </B><TT><B>WINDOWFRAMETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

import com.foley.utility.*;


/**
 * An application that displays an internal frame 
 * in a JWindow instance. This gives a top-level
 * frame that looks like an internal frame. However,
 * it does not interact with a Window Manager
 * properly.
 *
 * @author Mike Foley
 **/
public class WindowFrameTest extends Object { 

    /**
     * Create an internal frame.
     * &lt;p&gt;
     * @return The newly created internal frame.
     **/
    public static JInternalFrame createInternalFrame() { 
        
        final JInternalFrame internalFrame = 
                             new JInternalFrame( &quot;Internal JLabel&quot; );
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        Action exitAction = new ExitAction();
        file.add( exitAction );

        menuBar.add( file );
        internalFrame.setJMenuBar( menuBar );

        JToolBar toolBar = new JToolBar();
        toolBar.add( exitAction );
        
        internalFrame.getContentPane().add( toolBar, 
                                            BorderLayout.NORTH );
        
        JComponent content = new JLabel( &quot;Internal Frame Content&quot;, 
                                         SwingConstants.CENTER );
        content.setBorder( BorderFactory.createLoweredBevelBorder() );
        internalFrame.getContentPane().add( 
                            content, 
                            BorderLayout.CENTER );
        internalFrame.setResizable( true );
        internalFrame.setClosable( true );
        internalFrame.setIconifiable( true );
        internalFrame.setMaximizable( true );
        internalFrame.pack();
		
		return( internalFrame );
    } 


    /**
     * Application entry point.
     * Create the window, add an internal frame
     * and display.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JWindow window = new JWindow();
        JInternalFrame internalFrame = createInternalFrame();
        
        window.getContentPane().add( internalFrame, 
                                     BorderLayout.CENTER );
        window.setLocation( new Point( 200, 100 ) );
        window.setSize( new Dimension( 400, 300 ) );
        window.setVisible( true );
                
    }  // main

}  // WindowFrameTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f17-2.gif')"><B>Figure 17.2 :</B> <I>The WindowFrameTest application</I>.</A>
<P>
As can be seen in Figure 17.2, the window appears to be a top-level
frame that possesses the Java look-and-feel. Unfortunately, the
controls on the internal frame do not interact with the system's
window manager. This means that pressing the iconify button on
the titlebar does not iconify the window. The JFC developers realize
the need for a frame that is entirely drawn by JFC classes. This
will allow top-level frames, similar to the window created by
the WindowFrameTest application, that will interact with the system's
window manager. Once this type of frame is part of the JFC, internal
frames and top-level frames can be drawn with any desired look.
<H2><A NAME="TheTTFONTSIZEJDesktopPaneFONTTTFONTSIZEClassFONT">
The <TT>JDesktopPane</TT>
Class</A></H2>
<P>
The previous section described many of the options available in
the <TT>JInternalFrame</TT> class. An example was presented where
an internal frame was added to the content pane of a <TT>JFrame</TT>
instance. While this is a valid use of an internal frame, the
class was designed to be used in conjunction with the <TT>JDesktopPane</TT>
class. When an internal frame is added to a desktop pane, the
internal frame behaves as an independent frame in the desktop
pane.
<P>
The <TT>JDesktopPane</TT> class extends the <TT>JLayeredPane</TT>
class. It creates a virtual desktop to be used by internal frames.
It manages the potential overlap when multiple children are added
to a desktop pane. The <TT>JDesktopPane</TT> class provides the
link between the internal frames and the <TT>DesktopManager</TT>
instance installed by the current look-and-feel. The desktop manager
is responsible for performing the operations on the internal frame.
For example, when an internal frame is to be iconified, it is
the <TT>DesktopManager</TT> that performs the operation. This
allows a look-and-feel to specify how these operations are performed.
<P>
There are not very many methods in the <TT>JDesktopPane</TT> class
that are typically called by application code. The two that are
of interest are the <TT>getAllFrames</TT> method and the <TT>getAllFramesInLayer</TT>
method. The <TT>getAllFrames</TT> method returns an array of all
<TT>JInternalFrame</TT> instances contained in the desktop pane,
and the <TT>getAllFramesInLayer</TT> returns an array of the internal
frames in a particular layer in the desktop pane. The <TT>getDesktopManager</TT>
method will return a reference to the <TT>DesktopManager</TT>
associated with the desktop pane.
<H3><A NAME="TheTTFONTSIZEDesktopManagerFONTTTFONTSIZEInterfaceFONT">
The <TT>DesktopManager</TT>
Interface</A></H3>
<P>
The <TT>DesktopManager</TT> interface defines the responsibilities
of a desktop manager. A class that implements this interface is
set as the desktop manager in a desktop pane when its user interface
component is set. This allows a look-and-feel to dictate how the
desktop operations are performed. For example, a look-and-feel
can choose to place iconified windows along the right edge of
the desktop instead of the customary location along the bottom.
The <TT>DesktopManager</TT> interface is shown in Listing 17.3.
<P>
<HR>
<P>
<B>Listing 17.3&nbsp;&nbsp;The </B><TT><B>DESKTOPMANAGER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface DesktopManager
{ 
    /** If possible, display this frame in an appropriate location.
      * Normally, this is not called, as the creator of the 
      * JInternalFrame will add the frame to the appropriate parent.
      */
    void openFrame(JInternalFrame f); 

    /** 
     * Generally, this call should remove the frame from its parent. 
     */
    void closeFrame(JInternalFrame f); 

    /**
     * Generally, the frame should be resized to match its 
     * parent's bounds. 
     */
    void maximizeFrame(JInternalFrame f);

    /** Generally, this indicates that the frame should be restored to
      * its size and position prior to a maximizeFrame() call.
      */
    void minimizeFrame(JInternalFrame f);

    /** 
     * Generally, remove this frame from its parent and add an
     * iconic representation. 
     */
    void iconifyFrame(JInternalFrame f);

    /** 
      * Generally, remove any iconic representation that is present
      * and restore the frame to its original size and location.
      */
    void deiconifyFrame(JInternalFrame f);

    /** 
     * Generally, indicate that this frame has focus. This is usually 
     * called after the JInternalFrame's IS_SELECTED_PROPERTY has been
     * set to true.
     */
    void activateFrame(JInternalFrame f);

    /** 
     * Generally, indicate that this frame has lost focus. 
     * This is usually called after the JInternalFrame's IS_
     * SELECTED_PROPERTY has been set to false.
     */
    void deactivateFrame(JInternalFrame f);

    /** This method is normally called when the user has indicated that
      * they will begin dragging a component around. This method should 
      * be called prior to any dragFrame() calls to allow the 
      * DesktopManager to prepare any necessary state. 
      * Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.
      */
    void beginDraggingFrame(JComponent f);

    /** The user has moved the frame. Calls to this method will be 
      * preceded by calls to beginDraggingFrame(). 
      *  Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.
      */
    void dragFrame(JComponent f, int newX, int newY);

    /** This method signals the end of the dragging session. 
      * Any state maintained by the DesktopManager can be removed 
      * here.  Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.
      */
    void endDraggingFrame(JComponent f);

    /** This method is normally called when the user has indicated that
      * they will begin resizing the frame. This method should be called
      * prior to any resizeFrame() calls to allow the DesktopManager to
      * prepare any necessary state.  Normally &lt;b&gt;f&lt;/b&gt; will be a 
      * JInternalFrame.
      */
    void beginResizingFrame(JComponent f, int direction);

    /** The user has resized the component. Calls to this method 
     * will be preceded by calls to beginResizingFrame(). 
     *  Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.
     */
    void resizeFrame(JComponent f, int newX, int newY, 
                     int newWidth, int newHeight);

    /** This method signals the end of the resize session. Any state
     * maintained by the DesktopManager can be removed here.  
     * Normally &lt;b&gt;f&lt;/b&gt; will be a JInternalFrame.
     */
    void endResizingFrame(JComponent f);

    /** This is a primitive reshape method.*/
    void setBoundsForFrame(JComponent f, int newX, int newY, 
                           int newWidth, int newHeight);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="IntegratingTTFONTSIZEJInternalFrameFONTTTFONTSIZEandFONTTTFONTSIZEJDesktopPaneFONTTTFONTSIZEUsageFONT">
Integrating <TT>JInternalFrame</TT>
and <TT>JDesktopPane</TT>
Usage</A></H2>
<P>
For the <TT>JInternalFrame</TT> class to shine, it must be used
in conjunction with the <TT>JDesktopPane</TT> class. When an internal
frame is added to a desktop pane, it behaves as an independent
frame in the desktop pane. It can be dragged, iconified, maximized,
and sized independently of other internal frames contained in
the desktop pane.
<P>
The <TT>MDIFrame</TT> class shown in Listing 17.4 is an example
frame showing how a desktop pane can be added to a <TT>JFrame</TT>
instance. The <TT>MDIFrame</TT> class is a <TT>JFrame</TT> extension
that configures itself with a <TT>JDesktopPane</TT> instance in
the center region of its content pane. An <TT>Action</TT> is added
to the <TT>File</TT> menu and to the toolbar that creates and
adds an internal frame to the desktop pane when invoked. The internal
frame creation method adds a <TT>JLabel</TT> instance to the content
pane of the internal frame. This is for demonstration only. Your
application would add its content to the internal frame instance.
<P>
<HR>
<P>
<B>Listing 17.4&nbsp;&nbsp;The </B><TT><B>MDIFRAME</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;

import java.awt.event.*;

import java.io.Serializable;

import javax.swing.*;

import javax.swing.border.*;

import javax.swing.event.*;


/**
 * A top-level frame. The frame configures itself
 * with a JDesktopPane in its content pane.
 *
 * @author Mike Foley
 **/
public class MDIFrame extends JFrame implements Serializable { 
    
    /**
     * The desktop pane in our content pane.
     **/
    private JDesktopPane desktopPane;
    
    
    /**
     * MDIFrame, null constructor.
     **/
    public MDIFrame() { 
        this( null );
    } 


    /**
     * MDIFrame, constructor.
     *
     * @param title The title for the frame.
     **/
    public MDIFrame( String title ) { 
        super( title );
    } 


    /**
     * Customize the frame for our application.
     **/
    protected void frameInit() { 
        //
        // Let the super create the panes.
        super.frameInit();
        
        JMenuBar menuBar = createMenu();
        setJMenuBar( menuBar );

        JToolBar toolBar = createToolBar();
        Container content = getContentPane();
        content.add( toolBar, BorderLayout.NORTH );

        desktopPane = new JDesktopPane();
        desktopPane.setPreferredSize( new Dimension( 400, 300 ) );
        content.add( desktopPane, BorderLayout.CENTER );
        
    }  // frameInit


    /**
     * Create the menu for the frame.
     * &lt;p&gt;
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenuItem item;
      
        file.add( new NewInternalFrameAction() );
        file.add( new ExitAction() );

        menuBar.add( file );
        return( menuBar );

    }  // createMenuBar


    /**
     * Create the toolbar for this frame.
     * &lt;p&gt;
     * @return The newly created toolbar.
     **/
    protected JToolBar createToolBar() { 
        final JToolBar toolBar = new JToolBar();
        toolBar.setFloatable( false );

        toolBar.add( new NewInternalFrameAction() );
        toolBar.add( new ExitAction() );
        return( toolBar );
    } 


    /**
     * Create an internal frame.
     * A JLabel is added to its content pane for an example
     * of content in the internal frame. However, any
     * JComponent may be used for content.
     * &lt;p&gt;
     * @return The newly created internal frame.
     **/
    public JInternalFrame createInternalFrame() { 
        
        JInternalFrame internalFrame = 
                      new JInternalFrame( &quot;Internal JLabel&quot; );
        internalFrame.getContentPane().add( 
                      new JLabel( &quot;Internal Frame Content&quot; ) );
        internalFrame.setResizable( true );
        internalFrame.setClosable( true );
        internalFrame.setIconifiable( true );
        internalFrame.setMaximizable( true );
        internalFrame.pack();

        return( internalFrame );
    } 


    /**
     * An Action that creates a new internal frame and
     * adds it to this frame's desktop pane.
     **/
    public class NewInternalFrameAction extends AbstractAction { 
        
        /**
         * NewInternalFrameAction, constructor.
         * Set the name and icon for this action.         
         **/
        public NewInternalFrameAction() { 
            super( &quot;New&quot;, new ImageIcon( &quot;new.gif&quot; ) );
        } 
        
        /**
         * Perform the action, create an internal frame and
         * add it to the desktop pane.
         * &lt;p&gt;
         * @param e The event causing us to be called.
         **/
        public void actionPerformed( ActionEvent e ) { 
            JInternalFrame internalFrame = createInternalFrame();
            desktopPane.add( internalFrame, 
                             JLayeredPane.DEFAULT_LAYER );
        } 
            
    }  // NewInternalFrameAction

}  // MDIFrame
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>MDITest</TT> application presented in Listing 17.5 creates
an instance of the <TT>MDIFrame</TT> class and displays it using
the Windows look-and-feel. The resulting frame, after adding a
few internal frames, is shown in Figure 17.3. Notice that iconified
internal frames can be seen at the bottom of the figure. This
demonstrates that the internal frames are in fact internal. Iconified
and maximized internal frames still reside within the enclosing
<TT>JFrame</TT> instance.
<P>
<A HREF="javascript:popUp('f17-3.gif')"><B>Figure 17.3 :</B> <I>The MDITest application's frame</I>.</A>
<P>
<HR>
<P>
<B>Listing 17.5&nbsp;&nbsp;The MDITest Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import javax.swing.*;

import com.foley.utility.MDIFrame;


/**
 * An application that displays a frame that
 * contains internal frames in an MDI type
 * interface.
 *
 * @author Mike Foley
 **/
public class MDITest extends Object { 
       
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        try { 
            UIManager.setLookAndFeel( 
                 &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
        }  catch( Exception ex ) { 
            System.err.println( &quot;Exception: &quot; + 
                       ex.getLocalizedMessage() );
        } 
        
        JFrame frame = new MDIFrame( &quot;MDI Test&quot; );
                    
        frame.pack();
        frame.setVisible( true );
        
    }  // main
    
}  // MDITest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
By default, the contents of the internal frame are drawn as the
frame is dragged. This feature makes dragging frames sluggish
on many computers. To increase responsiveness while dragging frames,
the frame may be dragged in outline mode when the default desktop
manager is being used. Outline mode is enabled by setting the
<TT>dragMode</TT> client property on the desktop pane to <TT>outline</TT>.
Clearing this property, by setting its value to <TT>null</TT>,
will enable the default drag mode. Unfortunately, both the property
name and its one valid value are hard-coded strings in the <TT>DefaultDesktopManager</TT>
class. Setting the <TT>dragMode</TT> property is demonstrated
in the following code fragment.
<P>
<TT>JDesktopPane desktopPane = new JDesktopPane();desktopPane.putClientProperty(
&quot;JDesktopPane.dragMode&quot;, outline&quot; );</FONT></TT>
<P>
The <TT>MDIFrame</TT> class is by no means a complete MDI implementation.
It does provide insight as to the <TT>JInternalFrame</TT> and
<TT>JDesktopPane</TT> usage and how a complete MDI interface could
be developed using these classes.
<H3><A NAME="CustomizingtheTTFONTSIZEJInternalFrameFONTTTFONTSIZEInstancesFONT">
Customizing the <TT>JInternalFrame</TT>
Instances</A></H3>
<P>
As was mentioned earlier in this chapter, the <TT>JInternalFrame</TT>
class can be configured as the <TT>JFrame</TT> class is configured.
This includes adding a toolbar and menu to the frame. These items
take up valuable screen real estate and are not common on internal
frames, but they are supported. The <TT>createInternalFrame</TT>
method in the <TT>MDIFrame</TT> class can be changed to add these
items. The updated method is shown next. It creates a <TT>JMenuBar</TT>
instance and sets it on the internal frame by using the <TT>setJMenuBar</TT>
method. A <TT>JToolBar</TT> is also created and added to the north
region of the internal frame's content pane. These are the same
techniques used with the <TT>JFrame</TT> class. A new <TT>Action</TT>
is created that disposes of the internal frame passed in its constructor.
The action is added to both the menu and toolbar. The <TT>DisposeInternalFrameAction</TT>
 is also shown in Listing 17.6. The new version of the <TT>MDIFrame</TT>
is shown in Figure 17.4.
<P>
<A HREF="javascript:popUp('f17-4.gif')"><B>Figure 17.4 :</B> <I>A menu and tool-bar added to the internal
frame</I>.</A>
<P>
<HR>
<P>
<B>Listing 17.6&nbsp;&nbsp;Modified Methods in the MDIFrame Class
<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Create an internal frame.
 * &lt;p&gt;
 * @return The newly created internal frame.
 **/
public JInternalFrame createInternalFrame() { 
        
final JInternalFrame internalFrame = 
                         new JInternalFrame( &quot;Internal JLabel&quot; );
    JMenuBar menuBar = new JMenuBar();
    JMenu file = new JMenu( &quot;File&quot; );
    file.setMnemonic( KeyEvent.VK_F );
        
    Action disposeAction = 
           new DisposeInternalFrameAction( internalFrame );
    Action exitAction = new ExitAction();
    file.add( disposeAction );
    file.add( exitAction );

    menuBar.add( file );
    internalFrame.setJMenuBar( menuBar );

    JToolBar toolBar = new JToolBar();
    toolBar.add( disposeAction );
    toolBar.add( exitAction );
        
    internalFrame.getContentPane().add( toolBar, BorderLayout.NORTH );
        
    JComponent content = new JLabel( &quot;Internal Frame Content&quot; );
    content.setBorder( BorderFactory.createLoweredBevelBorder() );
    internalFrame.getContentPane().add( 
                            content, 
                            BorderLayout.CENTER );
    internalFrame.setResizable( true );
    internalFrame.setClosable( true );
    internalFrame.setIconifiable( true );
    internalFrame.setMaximizable( true );
    internalFrame.pack();

    return( internalFrame );
} <BR>

/**
 * An Action that disposes of an internal frame.
 **/
public class DisposeInternalFrameAction extends AbstractAction { 
        
    /**
     * The internal pane to close.
     **/
    private JInternalFrame internalFrame;
        
        
    /**
     * CloseInternalFrameAction, constructor.
     * Set the name and icon for this action.       
     * &lt;p&gt;
     * @param internalFrame The internal frame that we dispose of.
     **/
    public DisposeInternalFrameAction( JInternalFrame internalFrame ) { 
        super( &quot;Close&quot;, new ImageIcon( &quot;close.gif&quot; ) );
        this.internalFrame = internalFrame;
    } 
        
    /**
     * Perform the action, dispose of the internal frame.
     * &lt;p&gt;
     * @param e The event causing us to be called.
     **/
    public void actionPerformed( ActionEvent e ) { 
        internalFrame.dispose();
    } 
            
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The JFC provides the <TT>JDesktopPane</TT> and <TT>JInternalFrame</TT>
classes that work together to provide a framework for building
multiple document interface type user interfaces. The <TT>JInternalFrame</TT>
class's API is very similar to that of the <TT>JFrame</TT> class.
The <TT>JFrame</TT> class provides a top-level window, while the
<TT>JInternalFrame</TT> class provides a frame that can be added
to other components. Typical use of the internal frames is for
it to be added to a <TT>JDesktopPane</TT> instance. The <TT>JDesktopPane</TT>
class extends the <TT>JLayeredPane</TT> class. When an internal
frame is added to a desktop pane, it functions as a frame that
can be independently sized, moved, iconified, and maximized from
other internal frames contained in the desktop pane. The complete
reference of the <TT>JInternalFrame</TT> class and the panes it
creates were not presented, as they are the same as the <TT>JFrame</TT>
class presented in <A HREF="..\ch08\ch08.htm" >Chapter 8</A> Once the <TT>JFrame</TT> class and
its use is understood, the <TT>JInternalFrame</TT> class is almost
completely understood as well.
<P>
Sample applications were presented that placed a desktop pane
into the content pane of a <TT>JFrame</TT> instance. Multiple
internal frames were added to the desktop pane. These applications
demonstrated the cooperative nature of the <TT>JDesktopPane</TT>
and <TT>JInternalFrame</TT> classes. These two classes are typically
used together.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch16\ch16.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch18\ch18.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
