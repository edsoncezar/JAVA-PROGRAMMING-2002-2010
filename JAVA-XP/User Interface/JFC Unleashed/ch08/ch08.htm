<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 8 - Frame Windows</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch07\ch07.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch09\ch09.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;8<br>
Frame Windows</H1>
<HR>
<p>

<UL>
<LI><A HREF="#TheTTFONTSIZEJFrameFONTTTFONTSIZEClassFONT">
The <TT>JFrame</TT> Class
</A>
<UL>
<LI><A HREF="#PanelsCreatedbyTTFONTSIZEJFrameFONTTT">
Panels Created by <TT>JFrame</TT></A>
<LI><A HREF="#ExtendingTTFONTSIZEJFrameFONTTTFONTSIZEandOverridingtheFONTTTFONTSIZEframeInitFONTTTFONTSIZEMethodFONT">
Extending <TT>JFrame</TT>
and Overriding the <TT>frameInit</TT>
Method</A>
</UL>
<LI><A HREF="#TTFONTSIZEJAppletFONTTT">
<TT>JApplet</TT></A>
<LI><A HREF="#TheTTFONTSIZEJWindowFONTTTFONTSIZEClassFONT">
The <TT>JWindow</TT> Class
</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
A frame is a top level window that typically contains a title,
various window decorations such as a border, and minimize and
maximize buttons. The JFC provides the <TT>JFrame</TT> class for
use as a top level frame. In this chapter you will learn:
<UL>
<LI>How to use the <TT>JFrame</TT> class
<LI>See the various panels created in a <TT>JFrame</TT> instance
<LI>How to create an applet by using JFC components
<LI>How to create a Splash Window by using the <TT>JWindow</TT>
class
</UL>
<H2><A NAME="TheTTFONTSIZEJFrameFONTTTFONTSIZEClassFONT">
The <TT>JFrame</TT> Class
</A></H2>
<P>
The JFC <TT>JFrame</TT> class is an extension to the AWT <TT>Frame</TT>
class. An instance of the <TT>JFrame</TT> class is a heavyweight
component. It creates a top-level window that can be positioned
and sized independently of other windows. The <TT>JFrame</TT>
instance is managed by the system window manager. The window manager
typically adds window decorations to the frame. The decorations
can allow the user to interactively resize the window, position
the window, and iconify the window.
<P>
Creating and displaying an instance of the <TT>JFrame</TT> class
is a simple matter. The following code snippet creates a frame
with the title of <TT>Frame Test</TT>. The second line sets the
frame's visibility to <TT>true</TT>, which has the effect of displaying
the frame. Passing the <TT>setVisible</TT> method a value of <TT>false</TT>
will hide a currently displayed window. The frame created when
using the Windows look-and-feel is shown in Figure 8.1.
<BLOCKQUOTE>
<PRE>
JFrame frame = new JFrame( &quot;Frame Test&quot; );
frame.setVisible( true );
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f8-1.gif')"><B>Figure 8.1 :</B> <I>Simple frame</I>.</A>
<P>
The simple frame created in Figure 8.1 is resizable. It contains
the default Java icon on the far left of the titlebar, the specified
title in the center of the titlebar, the minimize and maximize
buttons, as well as a close button to the far right of the titlebar.
These are the default window decorations for the Microsoft Windows
look-and-feel. As simple as this frame is, there are many useful
operations available. Most of these are inherited from the AWT
<TT>Frame</TT> and <TT>Window</TT> classes. The most common of
these methods will be presented here, but a complete description
of the AWT classes is beyond the scope of this book.
<P>
The icon can be changed to any image by using the <TT>setIconImage</TT>
method. The current image can be queried with the <TT>getIconImage</TT>
method. The title of the frame can be queried and set after construction
by calling the <TT>setTitle</TT> and <TT>getTitle</TT> methods,
respectively.
<P>
The frame's resizable state can be set with the <TT>setResizable</TT>
method. This method takes a <TT>boolean</TT> parameter that specifies
whether the frame should be resizable or not. The current value
of this property can be queried with the <TT>isResizable</TT>
method.
<P>
It is often desirable to have the cursor set for every component
in a frame. Since the <TT>JFrame</TT> class is a descendent of
the AWT <TT>Component</TT> class, the cursor can be set for an
instance of a <TT>JFrame</TT>. Setting the cursor for the frame
will have the effect of setting the cursor for each component
contained in that frame which has not explicitly set its own cursor.
The <TT>setCursor</TT> method can be used to set the cursor to
any cursor defined in the AWT <TT>Cursor</TT> class. How to create
a custom cursor is described in <A HREF="..\ch27\ch27.htm" >Chapter 27</A>, &quot;Custom Cursors.&quot;
The cursor will be set for the center of the frame. The window
manager sets the cursor for the frame's titlebar and border.
<P>
The following example listing, Listing 8.1, gives a complete application
that creates a frame and configures it by using some of the methods
presented in the previous paragraphs. The resulting frame contains
an image in its titlebar, cannot be resized, and uses the cross-hair
cursor defined in the AWT <TT>Cursor</TT> class. The resulting
active and non-active frames are shown in Figure 8.2. Notice how
setting the resizable property of the frame to <TT>false</TT>
removes the icon and full-screen window decorations from the upper-right
of the titlebar.<p>
<HR>
<P>
<B>Listing 8.1&nbsp;&nbsp;The </B><TT><B>FRAMETEST</B></TT><B>
Application<BR>

</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import javax.swing.*;


/**
 * An application that displays a frame that
 * may not be resized; has an image, and a cross
 * hair cursor.
 *
 * @author Mike Foley
 **/
public class FrameTest extends Object { 

    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        try { 
            UIManager.setLookAndFeel( 
                &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
        }  catch( Exception ex ) { 
            System.err.println( &quot;Exception: &quot; +
                                 ex.getLocalizedMessage() );
        } 

        JFrame frame = new JFrame();

        //
        // Assume .gif is in current directory.
        //
        frame.setIconImage( 
              ( new ImageIcon( &quot;bullseye.gif&quot; ) ).getImage() );

        frame.setTitle( &quot;Test Frame&quot; );
        frame.setResizable( false );
        frame.setSize( 200, 200 );
        frame.setCursor( 
              Cursor.getPredefinedCursor( Cursor.CROSSHAIR_CURSOR ) );
        
        frame.setVisible( true );
        
    }  // main

}  // FrameTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f8-2.gif')"><B>Figure 8.2 :</B> <I>Non-resizable frame</I>.</A>
<P>
The <TT>JFrame</TT> class is a descendant of the AWT <TT>Window</TT>
class. It will generate the <TT>WindowEvents</TT> defined for
that class. The <TT>WindowEvent</TT> class is presented in Listing
8.2. These events are delivered by calling the methods in the
<TT>WindowListener</TT> interface shown in Listing 8.3.<p>
<HR>
<P>
<B>Listing 8.2&nbsp;&nbsp;The </B><TT><B>WINDOWEVENT</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class  WindowEvent
     extends java.awt.event.ComponentEvent
{ 
          // Fields 10
     public static final int WINDOW_ACTIVATED;
     public static final int WINDOW_CLOSED;
     public static final int WINDOW_CLOSING;
     public static final int WINDOW_DEACTIVATED;
     public static final int WINDOW_DEICONIFIED;
     public static final int WINDOW_FIRST;
     public static final int WINDOW_ICONIFIED;
     public static final int WINDOW_LAST;
     public static final int WINDOW_OPENED;
     private static final long serialVersionUID;

          // Constructors 1
     public WindowEvent(Window, int);

          // Methods 2
     public Window getWindow();
     public String paramString();
}
</PRE>
</BLOCKQUOTE>
<HR>
<p>
<HR>
<P>
<B>Listing 8.3&nbsp;&nbsp;The </B><TT><B>WINDOWLISTENER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface  WindowListener
     extends java.util.EventListener
{ 
          // Methods 7
     public abstract void windowActivated(WindowEvent);
     public abstract void windowClosed(WindowEvent);
     public abstract void windowClosing(WindowEvent);
     public abstract void windowDeactivated(WindowEvent);
     public abstract void windowDeiconified(WindowEvent);
     public abstract void windowIconified(WindowEvent);
     public abstract void windowOpened(WindowEvent);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
To demonstrate some of the methods described previously, they
are added to the simple frame created at the beginning of this
section. Listing 8.4 contains a new example <TT>JFrame</TT>. This
time, the default <TT>JFrame</TT> constructor is called. The title
is set in the <TT>WindowListener</TT> instance added to the frame,
so it doesn't need to be specified at construction time. The <TT>setIconImage</TT>
method is called in the <TT>WindowListener</TT> when the frame
is iconified or de-iconified. This method sets the frame's icon
to the given image. The <TT>setIconImage</TT> method is contained
in the AWT <TT>Frame</TT> method and inherited by <TT>JFrame</TT>.
This explains why an image is passed to this method rather than
an icon as in most JFC methods. The desired size of the window
is set to 200<FONT FACE="Symbol">&#180;</FONT>200 pixels. The
cursor is set to the hand cursor, which is one of the predefined
cursors defined in the AWT <TT>Cursor</TT> class. Finally, the
frame is displayed by calling <TT>setVisible</TT> with the parameter
of <TT>true</TT>.<P>
<HR>
<P>
<B>Listing 8.4&nbsp;&nbsp;Adding a </B><TT><B>WINDOWLISTENER</B></TT><B>
to the </B><TT><B>JFRAME<BR>

</B></TT>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


/**
 * An application that displays a frame that
 * may not be resized; has an image, and a cross
 * hair cursor.
 *
 * @author Mike Foley
 **/
public class FrameTest extends Object { 

    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        try { 
            UIManager.setLookAndFeel( 
                  &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
        }  catch( Exception ex ) { 
            System.err.println( &quot;Exception: &quot; + ex.getLocalizedMessage() );
        } 

        //
        // Assume .gif is in current directory.
        //
        final Image bullseye = 
                    ( new ImageIcon( &quot;bullseye.gif&quot; ) ).getImage();
        final Image bullseye2 = 
                    ( new ImageIcon( &quot;bullseye2.gif&quot; ) ).getImage();
        
        final JFrame frame = new JFrame();

        frame.setIconImage( bullseye );

        frame.setSize( 200, 200 );
        frame.setCursor( 
              Cursor.getPredefinedCursor( Cursor.HAND_CURSOR ) );
        
        frame.setVisible( true );

        frame.addWindowListener( new WindowListener() { 
            public void windowActivated( WindowEvent e ) { 
                frame.setTitle( &quot;Active&quot; );
                System.out.println( &quot;windowActivated &quot; + e );
            } 
            public void windowClosed( WindowEvent e ) { 
                System.out.println( &quot;windowClosed &quot; + e );
            } 
            public void windowClosing( WindowEvent e ) { 
                System.out.println( &quot;windowClosing &quot; + e );
            } 
            public void windowDeactivated( WindowEvent e ) { 
                frame.setTitle( &quot;Not Active&quot; );
                System.out.println( &quot;windowDeactivated &quot; + e );
            } 
            public void windowDeiconified( WindowEvent e ) { 
                frame.setIconImage( bullseye );
                System.out.println( &quot;windowDeiconified &quot; + e );
            } 
            public void windowIconified( WindowEvent e ) { 
                frame.setIconImage( bullseye2 );
                System.out.println( &quot;windowIconified &quot; + e );
            } 
            public void windowOpened( WindowEvent e ) {     
                System.out.println( &quot;windowOpened &quot; + e );
            } 
        }  );

    }  // main

}  // FrameTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f8-3.gif')"><B>Figure 8.3 :</B> <I>Enhanced frame</I>.</A>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><BLOCKQUOTE>
<TT><B>
// frame displayed and activated. windowOpened java.awt.event.WindowEvent[WINDOW_OPENED] on frame1 windowActivated java.awt.event.WindowEvent[WINDOW_ACTIVATED] on frame1
// another frame is activated. windowDeactivated java.awt.event.WindowEvent[WINDOW_DEACTIVATED] on frame1
// frame is activated, and iconified windowActivated java.awt.event.WindowEvent[WINDOW_ACTIVATED] on frame1 windowIconified java.awt.event.WindowEvent[WINDOW_ICONIFIED] on frame1 windowDeactivated java.awt.event.WindowEvent[WINDOW_DEACTIVATED] on frame1
// frame is restored windowActivated java.awt.event.WindowEvent[WINDOW_ACTIVATED] on frame1 windowDeiconified java.awt.event.WindowEvent[WINDOW_DEICONIFIED] on frame1 windowActivated java.awt.event.WindowEvent[WINDOW_ACTIVATED] on frame1
// frame closed windowClosing java.awt.event.WindowEvent[WINDOW_CLOSING] on frame1 windowDeactivated java.awt.event.WindowEvent[WINDOW_DEACTIVATED] on frame1</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<CENTER><B>Figure 8.4 :</B> <I>Results from enhanced frame interaction</I>.</CENTER>

<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
This example showed how to catch window events when the frame is iconified and deiconified. An application can set the iconified state of a frame by passing the <TT>Frame.ICONIFIED</TT> or <TT>Frame.NORMAL</TT> constant as the parameter to the <TT>setState</TT> method inherited from the <TT>AWT Frame</TT> class. The current state of this property may be queried by calling the <TT>getState</TT> method.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The previous example demonstrates many features of a frame, but
to this point nothing has been displayed in the frame. The next
section describes how to use the features of the <TT>JFrame</TT>
class to display components in the frame.
<H3><A NAME="PanelsCreatedbyTTFONTSIZEJFrameFONTTT">
Panels Created by <TT>JFrame</TT></A></H3>
<P>
The previous discussion of <TT>JFrame</TT> methods was focused
on the methods inherited from AWT classes. This section is the
first that discusses the enhancements introduced by the <TT>JFrame</TT>
class. Differences from the AWT <TT>Frame</TT> class will also
be presented.
<P>
To add content to an AWT <TT>Frame</TT>, the <TT>add</TT> method
is used. The AWT <TT>Frame</TT> comes configured with a <TT>BorderLayout</TT>.
To add a <TT>JLabel</TT> as the only component in an AWT <TT>Frame</TT>,
the following code snippet would be used.
<BLOCKQUOTE>
<PRE>
Frame f = new Frame();
f.add( new JLabel( &quot;Test Label&quot; ), BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<P>
This is not the technique to use when adding components to an
instance of the <TT>JFrame</TT> class. The <TT>JFrame</TT> instance
comes configured with a single child, an instance of the <TT>JRootPane</TT>
class. The <TT>JRootPane</TT> creates a hierarchy of children,
of which components are added to the <TT>contentPane</TT>. The
<TT>JRootPane</TT> is described in detail in the next section.
When using an instance of the <TT>JFrame</TT> class, the last
example would be changed to the following:
<BLOCKQUOTE>
<PRE>
JFrame f = new JFrame();
f.getContentPane().add( new JLabel( &quot;Test Label&quot; ), BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<P>
As can be seen in the example, the <TT>JLabel</TT> instance is
not added to the frame itself. Rather, the <TT>contentPane</TT>
is obtained by using the <TT>getContentPane</TT> method that returns
an instance of a <TT>Container</TT>. The default <TT>contentPane</TT>
is an instance of the <TT>JPanel</TT> class. It is to this pane
that the label is added. From the example, it is seen that the
<TT>contentPane</TT> comes configured with a <TT>BorderLayout</TT>.
If a different layout manager is called for, it should be set
on the <TT>contentPane</TT>, not the frame itself. Requiring components
to be added to the <TT>contentPane</TT> and layout managers set
on the <TT>contentPane</TT> is incompatible with the AWT <TT>Frame</TT>
class. This incompatibility is a common source of programming
errors. To aid in finding this type of programming bug, the <TT>JFrame</TT>
class throws an error if a component is added to the frame directly
or to a layout manager set for the frame. Extensions of the <TT>JFrame</TT>
class can disable this checking by calling the protected <TT>setRootPaneCheckingEnabled</TT>
method with a parameter of <TT>false</TT>. Similarly, the <TT>isRootPaneCheckingEnabled</TT>
method can be used to query the state of the <TT>rootPaneCheckingEnabled</TT>
property. Both of these methods are protected and cannot be called
from general-purpose frame clients. The default state for this
property is <TT>false</TT>, disabling root pane checking.
<P>
The <TT>JFrame</TT> class allows the program to specify the action
to be taken when the frame is closed via a window decoration or
some other method outside the program's control. The AWT <TT>Frame</TT>
doesn't do anything in this circumstance. Thus, if the program
wants the frame to close, a <TT>WindowListener</TT> has to be
added to the frame, and the appropriate method implemented to
perform this task. The <TT>JFrame</TT> contains the <TT>defaultCloseOperation</TT>
property that specifies what to do when the frame is closed by
using such an operation. The possible values for this property
are <TT>HIDE_ON_CLOSE</TT>, <TT>DISPOSE_ON_CLOSE</TT>, and <TT>DO_NOTHING_ON_CLOSE</TT>.
The default value, <TT>HIDE_ON_CLOSE</TT>, hides the window but
does not dispose of it. This close option allows the frame to
be reused. However, it is the application's responsibility to
dispose of the frame when it is no longer needed. The second possible
value for the <TT>defaultCloseOperation</TT> property is <TT>DISPOSE_ON_CLOSE</TT>.
When this value is specified, the window is not only closed, it
is also disposed of. The final possible value is <TT>DO_NOTHING_ON_CLOSE</TT>.
As the name implies, this option does nothing when the user initiates
a close operation. It is the application's responsibility to perform
the correct action. This option is compatible with the AWT <TT>Frame</TT>
close operation. The <TT>defaultCloseOperation</TT> property is
not a bound property.
<P>
This is an example of where type-safe constants would be a benefit
to the JFC. The parameter to the <TT>setDefaultCloseOperation</TT>
is defined as an <TT>int</TT>, rather than a defined type. This
allows any valid <TT>int</TT> to be passed to this method, even
though there are only three legal values. If a type is defined
for the parameter, the compiler can verify that a valid parameter
is passed to this method. Furthermore, the <TT>JFrame</TT> class
does not validate the <TT>int </TT>passed to the method. At a
bare minimum, an <TT>IllegalArgumentException</TT> should be thrown
by the <TT>setDefaultCloseOperation</TT> method if an integer
other than one of the constants defined for this property is passed
to the method.
<P>
The <TT>setDefaultCloseOperation</TT> method can be used to specify
the <TT>defaultCloseOperation</TT> property. One of the constants
described in the previous paragraph is passed as the lone parameter
to this method. The current <TT>defaultCloseOperation</TT> can
be queried with the <TT>getDefaultCloseOperation</TT> method.
The following code snippet can be added to the previous frame
example to demonstrate the <TT>defaultCloseOperation</TT> property.
Once added, the frame will not be closed if the close button on
the frame's titlebar is pressed.
<BLOCKQUOTE>
<PRE>
frame.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );
System.out.println( frame.getDefaultCloseOperation() );
</PRE>
</BLOCKQUOTE>
<H4>The <TT>JRootPane</TT> Class</H4>
<P>
An instance of the <TT>JFrame</TT> class contains exactly one
child, an instance of the <TT>JRootPane</TT> class. The <TT>JRootPane</TT>
in turn creates and manages multiple children. The hierarchy of
instances created by the <TT>JRootPane</TT> instance is shown
in Figure 8.5.
<P>
<A HREF="javascript:popUp('f8-5.gif')"><B>Figure 8.5 :</B> <I>JRootPane child instances</I>.</A>
<P>
The <TT>glassPane</TT> is a <TT>JPanel</TT> instance that is added
first to the <TT>rootPane</TT>, but is normally not shown. This
allows the <TT>glassPane</TT> to receive all mouse input events
and draw on top of all other children contained in the <TT>rootPane</TT>
when shown. The <TT>layeredPane</TT> is an instance of the <TT>JLayeredPane</TT>
class. This instance manages the <TT>contentPane</TT> and optional
<TT>menuBar</TT>. The default <TT>contentPane</TT> is an instance
of the <TT>JPanel</TT> class. The <TT>menuBar</TT>, if present,
is an instance of the <TT>JMenuBar</TT> class. Both these instances
are placed in the <TT>FRAME_CONTENT_LAYER</TT> of the <TT>layeredPane</TT>.
The <TT>glassPane</TT>, <TT>layeredPane</TT>, and <TT>contentPane</TT>
are guaranteed to be non-<TT>null</TT> for an unmodified <TT>JFrame</TT>
instance.
<P>
The <TT>JRootPane</TT> instance creates a private layout manager
to manage its children. The <TT>glassPane</TT> is expanded to
cover the entire screen space given to the <TT>rootPane</TT>.
When the <TT>glassPane</TT> is visible, all of its children components
are drawn above other components in the <TT>rootPane</TT> and
receive all the mouse events. The <TT>layeredPane</TT> is also
sized to fill the entire viewable area given to the <TT>rootPane</TT>.
If there is a <TT>menuBar</TT>, the <TT>layeredPane</TT> positions
it across the top of its viewable area. The <TT>contentPane</TT>
is given the remainder of the viewable area. If other windows
are added to the <TT>rootPane</TT>, the custom layout manager
ignores them. If an application adds a layout manager to the <TT>rootPane</TT>,
it is the responsibility of that layout manager to position the
<TT>rootPane</TT>'s standard children.
<P>
The <TT>JFrame</TT> class contains methods for querying and setting
each of the panes used in the frame. These methods follow the
JavaBeans naming convention and are listed in Table 8.1.<BR>
<P>
<CENTER><B>Table 8.1&nbsp;&nbsp;</B><TT><B>JFRAME</B></TT><B>
Pane Methods</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=192><CENTER><B>Setter Method</B></CENTER></TD><TD WIDTH=192><CENTER><B>Getter Method</B></CENTER>
</TD><TD WIDTH=192><CENTER><B>Affected Pane</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setContentPane</TT> </TD><TD WIDTH=192><TT>getContentPane</TT>
</TD><TD WIDTH=192><TT>contentPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setGlassPane</TT></TD><TD WIDTH=192><TT>getGlassPane</TT> 
</TD><TD WIDTH=192><TT>glassPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setLayeredPane</TT></TD><TD WIDTH=192><TT>getLayeredPane</TT>
</TD><TD WIDTH=192><TT>layeredPane</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setRootPane</TT></TD><TD WIDTH=192><TT>getRootPane</TT>
</TD><TD WIDTH=192><TT>rootPane</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>layeredPane</TT> is responsible for positioning the menu
bar. However, the <TT>JFrame</TT> class provides convenient methods
for setting and getting the menu bar. These are <TT>setJMenuBar</TT>
and <TT>getJMenuBar</TT>, respectively. Using menus in the JFC
will be covered extensively in the next chapter.
<P>
A common use for the <TT>glassPane</TT> is to block input events
from the components in the <TT>contentPane</TT>. This is typically
accompanied by displaying the predefined wait cursor. Listing
8.5 presents an application that creates a single button in the
frame's <TT>contentPane</TT>. When clicked, the <TT>ActionListener</TT>
registered for the button sets the wait cursor on the frame's
<TT>glassPane</TT> and displays it. An empty <TT>MouseAdapter</TT>
is added to the <TT>glassPane</TT> to receive capture mouse events.
This has the effect of catching all mouse events before the button
receives them. Thus, clicking the button when the wait cursor
is displayed will not have any effect. This simple application
does not contain an action to remove the <TT>glassPane</TT>. However,
passing the <TT>setVisible</TT> method the parameter <TT>false</TT>
does this. This will be presented in the next section. The application,
after pressing the button, is shown in Figure 8.6.<P>
<HR>
<P>
<B>Listing 8.5&nbsp;&nbsp;Using the </B><TT><B>GLASSPANE</B></TT><B>
Contained in the </B><TT><B>JFRAME</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


/**
 * An application that displays a frame.
 * It demonstrates the glassPane in the JFrame class.
 *
 * @author Mike Foley
 **/
public class GlassPaneTest extends Object { 

    private static JComponent createContent() { 
        JPanel content = new JPanel();
        JButton addButton = new JButton( &quot;Add Glass Pane&quot; );
        content.add( addButton );
        addButton.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
Component root = SwingUtilities.getRoot( ( Component )
     e.getSource() );
                if( root instanceof JFrame ) { 
                    JFrame frame = ( JFrame )root;

                    Component glassPane = frame.getGlassPane();
                    glassPane.addMouseListener( new MouseAdapter() { }  );
glassPane.setCursor( Cursor.getPredefinedCursor
    ( Cursor.WAIT_CURSOR ) );
                    glassPane.setVisible( true );
                } 
            } 
        }  );

        return( content );
    } 
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        
        JFrame frame = new JFrame( &quot;Glass Pane Test&quot; );

        frame.getContentPane().add( createContent(), 
                                    BorderLayout.CENTER );

        frame.pack();
                
        frame.setVisible( true );

    }  // main

}  // GlassPaneTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f8-6.gif')"><B>Figure 8.6 :</B> <I>The GlassPaneTest application</I>.</A>
<H3><A NAME="ExtendingTTFONTSIZEJFrameFONTTTFONTSIZEandOverridingtheFONTTTFONTSIZEframeInitFONTTTFONTSIZEMethodFONT">
Extending <TT>JFrame</TT>
and Overriding the <TT>frameInit</TT>
Method</A></H3>
<P>
Many applications define an extension to the <TT>JFrame</TT> class
that is used as a frame by that application. The extended frame
class is customized for the application. The <TT>JFrame</TT> class
provides hooks to be used by extensions to customize the resulting
frame instance. Instead of creating the <TT>JRootPane</TT> instance
in the <TT>JFrame</TT> constructor, the protected <TT>frameInit</TT>
method is called. This method enables window and keyboard events,
sets the background color, and calls the protected <TT>createRootPane</TT>
method. By overriding this method, the <TT>rootPane</TT> can be
modified or entirely replaced. The signatures for these two protected
methods are as follows:
<BLOCKQUOTE>
<PRE>
protected void frameInit();
protected JRootPane createRootPane();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>JRootPane</TT> instance behaves similarly to the <TT>JFrame</TT>
instance. It doesn't simply create its children in the constructor.
Instead, it calls protected <TT>create</TT> methods. This allows
children to alter the behavior of any, or all, of the child panes.
These protected methods are defined as follows:
<BLOCKQUOTE>
<PRE>
protected Component createGlassPane();
protected JLayeredPane createLayeredPane();
protected Container createContentPane();
</PRE>
</BLOCKQUOTE>
<P>
Complete guidelines and examples of extending JFC components are
given in Part V, &quot;Extending JFC Components.&quot;
<P>
The <TT>ApplicationFrame</TT> class, shown in Listing 8.6, presents
an extension of the <TT>JFrame</TT> class. This class overrides
the <TT>frameInit</TT> method to set the application's icon. In
the <TT>frameInit</TT> method, the super <TT>frameInit</TT> is
first called to create the standard <TT>JFrame</TT> panes. Only
after this call has been completed can the extension use the <TT>contentPane</TT>,
or any of the other panes, normally available in a <TT>JFrame</TT>
instance. The <TT>ApplicationFrame</TT> class follows the lead
of the <TT>JFrame</TT> itself by not creating the application
components; instead, it calls a protected method that performs
this task. This allows the <TT>ApplicationFrame</TT> to be extended
to replace the inside of the frame by overriding the <TT>createApplicationContent</TT>
method, but still allows the extension to keep the decorations
established by the <TT>ApplicationFrame</TT> class. In the next
chapter, you will see how to add more interesting menus and a
complete toolbar. The <TT>ApplicationFrame</TT> class contains
the <TT>setWaitCursorVisible</TT> method that will show or hide
the <TT>glassPane</TT>, depending on the <TT>boolean</TT> parameter
passed to the method. The wait cursor is set on the <TT>glassPane</TT>
when it is displayed. This provides an easy way to display the
wait cursor and block mouse events from components in the <TT>contentPane</TT>.
<P>
<HR>
<P>
<B>Listing 8.6&nbsp;&nbsp;The </B><TT><B>APPLICATIONFRAME</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;

import java.awt.event.*;

import java.io.Serializable;

import javax.swing.*;

import javax.swing.border.*;

import javax.swing.event.*;


/**
 * A toplevel frame. The frame customizes the
 * Icon and content in the frameInit method.
 *
 * @author Mike Foley
 **/
public class ApplicationFrame extends JFrame implements Serializable { 

    /**
     * MouserAdapter to consume mouse events on glassPane.
     **/
    private MouseAdapter ourMouseAdapter;
    

    /**
     * ApplicationFrame, null constructor.
     **/
    public ApplicationFrame() { 
        this( null );
    } 


    /**
     * ApplicationFrame, constructor.
     *
     * @param title The title for the frame.
     **/
    public ApplicationFrame( String title ) { 
        super( title );
    } 


    /**
     * Customize the frame for our application.
     **/
    protected void frameInit() { 
        //
        // Let the super create the panes.
        super.frameInit();
        
        ourMouseAdapter = new MouseAdapter() { } ;

        Image bullseye = new ImageIcon( &quot;bullseye.gif&quot; ).getImage();
        setIconImage( bullseye );

        JMenuBar menuBar = createMenu();
        setJMenuBar( menuBar );

        JToolBar toolBar = createToolBar();
        Container content = getContentPane();
        content.add( BorderLayout.NORTH, toolBar );

        createApplicationContent();

    }  // frameInit


    /**
     * Create the content for the application
     **/
    protected void createApplicationContent() { 
    }  // createApplicationContent


    /**
     * Create the menu for the frame.
     *
     * @return the menu for the frame.
     **/
    protected JMenuBar createMenu() { 
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        JMenuItem item;

        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
        item.setAccelerator( KeyStroke.getKeyStroke( 
                             KeyEvent.VK_X, Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );

        menuBar.add( file );
        return( menuBar );

    }  // createMenuBar


    /**
     * Create the mouse listener for the frame.
     *
     * @return the MouseListener for the content in the frame.
     **/
    protected MouseListener createMouseListener() { 
        return new ApplicationMouseListener();
    } 

    protected JToolBar createToolBar() { 
        final JToolBar toolBar = new JToolBar();
        toolBar.setFloatable( false );
        toolBar.add( new ExitAction() );
        return( toolBar );
    } 


    /**
     * Show or hide the wait cursor. The wait cursor
     * is set on the glass pane so input mouse events
     * are blocked from other components.
     * &lt;p&gt;
     * @param waitCursorVisible True to show the wait cursor,
     *                          False to hide the wait cursor.
     **/
    public void setWaitCursorVisible( boolean waitCursorVisible ) { 
        Component glassPane = getGlassPane();
        if( waitCursorVisible ) { 
            //
            // Show the wait cursor.
            //
            glassPane.addMouseListener( ourMouseAdapter );
            glassPane.setCursor( 
                      Cursor.getPredefinedCursor( Cursor.WAIT_CURSOR ) );
            glassPane.setVisible( true );
        }  else { 
            //
            // Hide the wait cursor.
            //
            glassPane.removeMouseListener( ourMouseAdapter );
            glassPane.setCursor( 
                  Cursor.getPredefinedCursor( Cursor.DEFAULT_CURSOR ) );
            glassPane.setVisible( false );
        } 
    } 
    
}  // ApplicationFrame
 
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ApplicationFrame</TT> class can be tested by altering
the <TT>main</TT> method in the <TT>FrameTest</TT> application
given at the start of this chapter. The <TT>main</TT> method can
create an instance of the <TT>ApplicationFrame</TT> class instead
of the <TT>JFrame</TT> class. The following is a possible version
of the new <TT>main</TT> method:
<BLOCKQUOTE>
<PRE>
public static void main( String args[] ) { 

    //
    // Create an ApplicationFrame instead of a JFrame
    // The return type may still be declared as a JFrame, since
    // ApplicationFrame extends JFrame.
    //
    JFrame frame = new ApplicationFrame( &quot;Test ApplicationFrame&quot;);
    frame.setSize( 200, 200 );
    frame.setVisible( true );
        
}  // main
</PRE>
</BLOCKQUOTE>
<P>
The resulting frame as defined in the <TT>ApplicationFrame</TT>
class is shown in Figure 8.7.
<P>
<A HREF="javascript:popUp('f8-7.gif')"><B>Figure 8.7 :</B> <I>An ApplicationFrame instance</I>.</A>
<H2><A NAME="TTFONTSIZEJAppletFONTTT">
<TT>JApplet</TT></A></H2>
<P>
The <TT>JApplet</TT> class is an extension of the AWT <TT>Applet</TT>
class. This class is the preferred entry point when creating applets
that contain JFC components. The structure of the <TT>JApplet</TT>
class is the same as the <TT>JFrame</TT> class. It contains one
child, an instance of the <TT>JRootPane</TT> class. When adding
children or setting the layout manager for the applet, the content
pane is used rather than the instance of the <TT>JApplet</TT>
class itself. The applet can create instances of the <TT>JFrame</TT>
class to be displayed outside the browser if desired.
<P>
The <TT>JApplet</TT> itself is configured similarly to the <TT>JFrame</TT>
class presented in the previous section. It contains a single
child, an instance of the <TT>JRootPane</TT> class. Thus, as with
<TT>JFrame</TT> instances, components are not added directly to
a <TT>JApplet</TT> instance. Instead, they are added to its <TT>contentPane</TT>.
Also, the methods to query the panes in the <TT>JFrame</TT> listed
in Table 8.1 are also available in the <TT>JApplet</TT> class.
<P>
The <TT>JApplet</TT> class extends the AWT <TT>Applet</TT> class,
so the familiar <TT>init</TT>, <TT>destroy</TT>, <TT>start</TT>,
and <TT>stop</TT> methods are used for <TT>JApplet</TT> programming.
The <TT>SimpleApplet</TT> class is presented in Listing 8.7. This
class creates an applet containing the same children components
that create a simple form. The <TT>SimpleApplet</TT> class performs
its initialization in the <TT>init</TT> method that is overridden
from the AWT <TT>Applet</TT> class. This method calls the <TT>createAppletContent</TT>
method to perform the actual work. This allows extensions of the
<TT>SimpleApplet</TT> class to easily modify the content contained
in the applet. In the <TT>createAppletContent</TT> method, the
<TT>contentPane</TT> is obtained from the <TT>JApplet</TT> instance.
This is the pane where applets should add their components.<P>
<HR>
<P>
<B>Listing 8.7&nbsp;&nbsp;</B><TT><B>SIMPLEAPPLET</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import javax.swing.*;

/**
 * A simple Applet that uses JFC Components.
 **/
public class SimpleApplet extends JApplet { 
    
    public SimpleApplet() { 
        super();
    } 

    /**
     * Create components for our applet.
     **/
    public void init() { 
        //
        // Let the super do its work.
        super.init();
                        
        createAppletContent();
        
    }  // init

    /**
     * Create the content for the applet
     **/
    protected void createAppletContent() { 
        
        Container content = getContentPane();
        content.setLayout( new GridLayout( 4, 2 ) );
        content.add( new JLabel( &quot;Name: &quot;, SwingConstants.RIGHT ) );
        content.add( new JTextField() );
        content.add( new JLabel( &quot;Street: &quot;, SwingConstants.RIGHT ) );
        content.add( new JTextField() );
content.add( new JLabel( &quot;City and State: &quot;,
    SwingConstants.RIGHT ) );
        content.add( new JTextField() );
        content.add( new JLabel( &quot;zip Code: &quot;, SwingConstants.RIGHT ) );
        content.add( new JTextField() );
        
    }  // createAppletContent
    
}  // SimpleApplet
</PRE>
</BLOCKQUOTE>
<HR>
<P>
To use the <TT>SimpleApplet</TT> class, an HTML page is required
for use in a Java-enabled browser or in the Appletviewer utility
program contained in the Java Development Kit. The following is
a very simple HTML page for the test applet. The resulting applet
as displayed in the Appletviewer is shown in Figure 8.8.
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; The SimpleApplet Test Page &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

The SimpleApplet:

&lt;APPLET CODE=&quot;com.foley.test.SimpleApplet.class&quot; WIDTH=400 HEIGHT=70&gt;
&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f8-8.gif')"><B>Figure 8.8 : </B><I>A SimpleApplet instance in a browser</I>.</A>
<H2><A NAME="TheTTFONTSIZEJWindowFONTTTFONTSIZEClassFONT">
The <TT>JWindow</TT> Class
</A></H2>
<P>
The <TT>JWindow</TT> class extends the AWT <TT>Window</TT> class.
It provides a window that the caller is responsible for managing.
Unlike instances of the <TT>JFrame</TT> class, instances of the
<TT>JWindow</TT> class do not contain window decorations. The
majority of <TT>Component</TT> instances are bound by the frame
in which they are contained. The <TT>JWindow</TT> doesn't contain
this restriction. The window can be placed anywhere on the display.
Typical uses for <TT>JWindow</TT> instances in the JFC are pop-up
menus and ToolTips.
<P>
The <TT>JWindow</TT> class structure is the same as the <TT>JFrame</TT>
class. It creates a single child that is an instance of the <TT>JRootPane</TT>
class. When adding or enumerating the children of the window,
the content pane must be used. A handle to the content pane is
obtained with the <TT>getContentPane</TT> method. In fact, all
the methods listed in Table 8.1 for the <TT>JFrame</TT> class
are available for use with the <TT>JWindow</TT> class. See the
<TT>JFrame</TT> discussion earlier in this chapter for a complete
description of using the panes created by the <TT>JRootPane</TT>
class.
<P>
A <TT>JWindow</TT> can be used to create a &quot;splash&quot;
window. The splash window is displayed quickly after an application
begins, and is displayed while it is initializing. It often contains
a company logo and copyright notice but not a titlebar, menu,
or other window decorations typically found on a frame. The <TT>SplashWindow</TT>
class shown next implements such a window. It extends the <TT>JWindow</TT>
class, so it will not contain a titlebar or resize borders. This
class will display an icon centered on the screen. The class creates
a <TT>JLabel</TT> instance for displaying the icon and adds this
label to the center of its content pane. The <TT>setVisible</TT>
method is extended to center the window on the screen before its
parent's <TT>setVisible</TT> method is called to create and display
the  window.
<P>
<TT>Icon</TT> in the <TT>SplashWindow</TT> class is a bound property.
Since the <TT>SplashWindow</TT> class is not a descendant of the
<TT>JComponent</TT> class, it can not utilize the <TT>PropertyChangeSupport</TT>
contained in that class. As such, the <TT>SplashWindow</TT> class
manages <TT>PropertyChangeListener</TT>s itself. However, in a
future release of the AWT and JFC, the <TT>PropertyChangeSupport</TT>
is going to be moved from the <TT>JComponent</TT> class to the
AWT <TT>Component</TT> class. At this time, the <TT>PropertyChangeListener</TT>
support contained in the <TT>SplashWindow</TT> class can be removed,
because the functionality will be inherited from the <TT>Component</TT>
class.
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;
import java.beans.*;
import javax.swing.*;


/**
 * A window that contains an image.
 *
 * @author Mike Foley
 **/
public class SplashWindow extends JWindow { 

    /**
     * The icon displayed in the window.
     **/
    private Icon splashIcon;
    
    /**
     * A label used to display the icon.
     **/
    private JLabel iconLabel;
    
    /**
     * Bound property support, and name constants.
     **/
    private PropertyChangeSupport changeSupport;
    public static final String SPLASHICON_PROPERTY = &quot;SplashIcon&quot;;
    
    
    /**
     * SplashWindow, null constructor.
     **/
    public SplashWindow() { 
        this( null );
    } 
 
    
    /**
     * SplashWindow, constructor.
     *
     * @param splashIcon The icon to view in the window.
     **/
    public SplashWindow( Icon splashIcon ) { 
        super();
        iconLabel = new JLabel();
        iconLabel.setBorder( BorderFactory.createRaisedBevelBorder() );
        getContentPane().add( iconLabel, BorderLayout.CENTER );
        setSplashIcon( splashIcon );
    } 


    /**
     * Set the image displayed in the window.
     * This is a bound property named SPLASHICON_PROPERTY.
     * If this property is changed when the window is
     * visible, the window is NOT re-centered on the screen.
     *
     * @param splashIcon The icon to draw in the window.
     **/
    public void setSplashIcon( Icon splashIcon ) { 
        Icon old = this.splashIcon;
        this.splashIcon = splashIcon;
        iconLabel.setIcon( splashIcon );
        pack();
        if( changeSupport != null ) { 
changeSupport.firePropertyChange( SPLASHICON_PROPERTY, 
    old, splashIcon );
        } 
    } 
 
    
    /**
     * Extend the setVisible method to center this window
     * on the screen before being displayed.
     *
     * @param visible True if showing the window, false if hiding.
     **/
    public void setVisible( boolean visible ) { 
        
        if( visible ) { 
            
            //
            // Display the window in the center of the screen.
            //
Dimension screenSize = 
    Toolkit.getDefaultToolkit().getScreenSize();
            Dimension size = getSize();
            int x;
            int y;

            x = screenSize.width / 2 - size.width / 2;
            y = screenSize.height / 2 - size.height / 2;

                setBounds( x, y, size.width, size.height);
        } 
        
        //
        // Let super show or hide the window.
        //
        super.setVisible( visible );
    } 
    
    
    /**
     * Need to handle PropertyChangeListeners here until this
     * type of code is moved from JComponent to Component.
     **/
public synchronized void addPropertyChangeListener(
        PropertyChangeListener listener ) { 
        if (changeSupport == null) { 
            changeSupport = new PropertyChangeSupport(this);
        } 
        changeSupport.addPropertyChangeListener(listener);
    } 
public synchronized void removePropertyChangeListener(
        PropertyChangeListener listener ) { 
        if (changeSupport != null) { 
            changeSupport.removePropertyChangeListener(listener);
        } 
    } 
    
}  // SplashWindow 
</PRE>
</BLOCKQUOTE>
<P>
Listing 8.8 contains a simple application to test the <TT>SplashWindow</TT>
class. It simply loads an icon and then creates and displays the
<TT>SplashWindow</TT>. The resulting window is shown in Figure
 8.9.
<P>
<A HREF="javascript:popUp('f8-9.gif')"><B>Figure 8.9 : </B><I>An example of a SplashWindow</I>.</A><P>
<HR>
<P>
<B>Listing 8.8&nbsp;&nbsp;Application to Test the </B><TT><B>SPLASHWINDOW
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import javax.swing.*;

import com.foley.utility.SplashWindow;
import com.foley.utility.ImageLoader;


/**
 * An application that displays a frame that
 * may not be resized; has an image, and a cross
 * hair cursor.
 *
 * @author Mike Foley
 **/
public class SplashTest extends Object { 

    /**
     * Application entry point.
     * Create the splash window, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        Icon icon = null;
        
        //
        // Assume the .gif file is local.
        //
        icon = new ImageIcon( &quot;logo.gif&quot; );
SplashWindow splashWindow = new SplashWindow( icon );
        splashWindow.setVisible( true );
                
    }  // main
}  // SplashTest
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter presented the top-level display components contained
in the JFC. The <TT>JFrame</TT> class provides an independent
frame for building displays. Instances of the <TT>JFrame</TT>
class contain window decorations provided by the display system's
window manager. The <TT>JApplet</TT> class provides the entry
point for applets developed by using the JFC toolkit. Applets
typically provide the entry point to Java classes loaded into
a browser. The <TT>JWindow</TT> class provides an arbitrary window
for building displays. This class was extended to create a splash
screen. It is similar to the <TT>JFrame</TT> class; however, window
decorations are not displayed on instances of the <TT>JWindow</TT>
class.
<P>
Each of the top-level classes contains one child, an instance
of the <TT>JRootPane</TT> class. This instance creates multiple
panes for program use. Children are not added directly to the
top-level component. Instead, they are added to the content pane.
The <TT>glassPane</TT> can be displayed to catch input events
before they are passed to the components in the <TT>contentPane</TT>.
You saw how this feature can be used to display a wait cursor
in a <TT>JFrame</TT> instance.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch07\ch07.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch09\ch09.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
