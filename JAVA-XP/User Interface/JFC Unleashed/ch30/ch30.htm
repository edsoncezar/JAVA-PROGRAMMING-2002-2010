<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 30 - Pluggable Look-and-Feel</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch29\ch29.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch31\ch31.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;30<br>
Pluggable Look-and-Feel</H1>
<HR>
<p>


<UL>
<LI><A HREF="#OverviewofPluggableLookandFeel">
Overview of Pluggable Look-and-Feel</A>
<UL>
<LI><A HREF="#StandardJFCLookandFeelImplementations">
Standard JFC Look-and-Feel Implementations</A>
<LI><A HREF="#SystemVersusCrossPlatformLookandFeelImplementations">
System Versus Cross-Platform Look-and-Feel Implementations
</A>
<LI><A HREF="#Themes">
Themes</A>
<LI><A HREF="#UIDefaults">
UI Defaults</A>
</UL>
<LI><A HREF="#UsingtheUIManager">
Using the UI Manager</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEUIManagerFONTTTFONTSIZEClassFONT">
The <TT>UIManager</TT> Class
</A>
<LI><A HREF="#ExampleQueryingforLookandFeelInformation">
Example Querying for Look-and-Feel Information</A>
<LI><A HREF="#OverviewoftheTTFONTSIZELAFInfoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>LAFInfoDemo</TT>
Example</A>
<LI><A HREF="#SettingtheLookandFeel">
Setting the Look-and-Feel</A>
<LI><A HREF="#TheTTFONTSIZEUIDefaultsFONTTTFONTSIZEClassFONT">
The <TT>UIDefaults</TT> Class
</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>

<P>
One feature of JFC that distinguishes it from other GUI tool kits
is its pluggable look-and-feel that abstracts a component's look-and-feel
from its implementation. This architecture allows you to dynamically
change the look-and-feel of an application. 
<P>
In this chapter, you will learn:
<UL>
<LI>About the pluggable look-and-feel architecture<BR>
Pluggable look-and-feel is built on JFC's Model View Controller
(MVC) architecture.
<LI>How to use the UI manager<BR>
In addition to allowing you to select a look-and-feel for your
application, the UI manager allows you to query for information
about installed look-and-feels.
<LI>How to use UI defaults<BR>
Many of the attributes describing how to render components are
stored in a hashtable. By changing default attributes such as
fonts, borders, and colors, you can change how all instances of
a component type are rendered, regardless of the current look-and-feel.
<LI>About themes and how to use them<BR>
Themes allow you to specify attributes such as fonts and colors
for a particular look-and-feel.
</UL>
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
This chapter presents pluggable look-and-feel from the perspective of an application. <A HREF="..\ch22\ch22.htm" >Chapter 22</A>, &quot;Extending Existing Components,&quot; describes how you can use the pluggable look-and-feel architecture to extend JFC components. <A HREF="..\ch23\ch23.htm" >Chapter 23</A>, &quot;Creating a Custom Look-and-Feel,&quot; describes how to create a custom look-and-feel to give all of your applica- tions a distinct user interface. <A HREF="..\ch24\ch24.htm" >Chapter 24</A>, &quot;Building a Custom Component,&quot; describes how to implement the pluggable look-and-feel architecture in custom components.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H2><A NAME="OverviewofPluggableLookandFeel">
Overview of Pluggable Look-and-Feel</A></H2>
<P>
Because AWT components are implemented by the use of peers, their
look-and-feel <BR>
is determined by the operating system on which the host application
is running. JFC, however, implements components without the use
of peers so the look-and-feel of its components are not determined
by the underlying operating system. Peerless component implementation
makes it possible to create applications with a look-and-feel
that is consistent across all operating environments. JFC takes
this concept one step further by providing an architecture that
supports multiple look-and-feel implementations and allows applications
to dynamically change their look-and-feel at runtime.
<P>
The pluggable look-and-feel implementation benefits from JFC's
Model View Controller (MVC) component architecture. In the MVC
architecture, a component's visual representation (the view) and
response to user input (the controller) are abstracted from its
implementation (the model). With JFC components, the view and
controller elements of MVC are implemented by the pluggable look-and-feel
modules.
<P>
The term <I>UI</I> and the JFC documentation
to represent the view and controller elements of MVC are used
throughout this chapter. The object that implements the UI is
called the <I>UI delegate</I>.
<H3><A NAME="StandardJFCLookandFeelImplementations">
Standard JFC Look-and-Feel Implementations</A></H3>
<P>
JFC includes the look-and-feels listed in the following table.
In addition to the name of the look-and-feel, Table 30.1 gives
the fully qualified class name corresponding to the implementation
of each look-and-feel.<BR>
<P>
<CENTER><B>Table 30.1&nbsp;&nbsp;Look-and-Feel Class Names</B></CENTER><CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><B>Name</B></CENTER></TD><TD WIDTH=336><CENTER><B>Class Name</B></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>Metal (Java)</TD><TD WIDTH=336><TT>javax.swing.plaf.metal.MetalLookAndFeel</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>CDE/Motif</TD><TD WIDTH=336><TT>com.sun.java.swing.plaf.motif.MotifLookAndFeel</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>Windows</TD><TD WIDTH=336><TT>com.sun.java.swing.plaf.windows.WindowsLookAndFeel</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>Macintosh</TD><TD WIDTH=336><TT>com.sun.java.swing.plaf.mac.MacLookAndFeel</TT>
</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The Metal look-and-feel (also known as the Java look-and-feel)
is the default look-and-feel implementation-applications that
do not explicitly set a specific look-and-feel will run with the
Metal look-and-feel. Metal is included as an integral part of
JFC and will always be available on platforms that support JFC.
The remaining look-and-feel implementations are considered optional
parts of JFC and may or may not be present at runtime. 
<H3><A NAME="SystemVersusCrossPlatformLookandFeelImplementations">
System Versus Cross-Platform Look-and-Feel Implementations
</A></H3>
<P>
There are two types of look-and-feel implementations.
<UL>
<LI><I>System look-and-feels</I> are
designed to mimic the appearance of native components on a given
operating system.
<LI><I>Cross-platform look-and-feels</I>
are not designed to appear like native components-instead they
are designed to provide a unique look-and-feel not associated
with any particular operating system.
</UL>
<P>
The Motif, Windows, and Macintosh look-and-feels are system look-and-feels.
The Metal look-and-feel is a cross-platform look-and-feel.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Because all look-and-feel implementations are based on a common architecture and constructed without the use of peer components, theoretically they can run on any platform. For example, the Windows look-and-feel should be able to run on a Macintosh. However, due to unresolved copyright issues with operating system vendors, certain system look-and- feels may be restricted to running only on their native operating systems.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="Themes">
Themes</A></H3>
<P>
Some look-and-feel implementations support <I>themes</I>,
an easy way to change certain aspects of the look-and-feel without
creating an entirely new look-and-feel implementation. Typically,
themes allow you to specify attributes like fonts and color schemes.
There is no common approach to implementing themes-each look-and-feel
provides its own mechanism for creating and using themes. 
<H3><A NAME="UIDefaults">
UI Defaults</A></H3>
<P>
<I>UI defaults</I> are attributes
that describe certain aspects of how a component UI is rendered.
For example, the defaults for a button UI include the border,
background and foreground colors, focus color, and font. JFC maintains
the following three levels of defaults:
<UL>
<LI><I>User defaults</I> are UI attributes
defined by the application.
<LI><I>Look-and-feel defaults</I>
are UI attributes defined by the current look-and-feel.
<LI><I>System defaults</I> are UI
attributes defined in the abstract <TT>BasicLookAndFeel</TT> class,
the class from which all look-and-feel implementations extend.
</UL>
<P>
Look-and-feel implementations query the UI manager to get the
attributes required to render the UI for components. The preceding
list gives the levels of defaults in order of precedence as maintained
by the UI manager. For example, user defaults take precedence
over look-and-feel defaults, which take precedence over system
defaults. 
<P>
You can use the UI manager to set user defaults that override
the defaults of the current look-and-feel. By setting user defaults,
you can make minor changes to the appearance of an existing look-and-feel
without having to actually create your own look-and-feel implementation.
For example, you can use UI defaults to change the font size of
menus in a JFC application.
<H2><A NAME="UsingtheUIManager">
Using the UI Manager</A></H2>
<P>
The UI manager provides applications with an interface for managing
pluggable look-and-feels. It includes the ability to query for
installed look-and-feels, install and uninstall look-and-feels,
and set and get UI defaults. The UI manager is also used by look-and-feel
implementations to get the UI defaults required to render a component
UI. This section deals mainly with using the UI manager from the
perspective of an application. Chapters 23 and 24 provide additional
information on using the UI manager from the perspectives of a
look-and-feel and a component.
<H3><A NAME="TheTTFONTSIZEUIManagerFONTTTFONTSIZEClassFONT">
The <TT>UIManager</TT> Class
</A></H3>
<P>
Listing 30.1 gives the signature of the <TT>UIManager</TT> class.
<P>
<HR>
<P>
<B>Listing 30.1&nbsp;&nbsp;</B><TT><B>UIMANAGER</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class UIManager extends Object implements Serializable 
{ 
  // Public class methods
    public static void addAuxiliaryLookAndFeel(LookAndFeel laf);
public static synchronized void addPropertyChangeListener(
  PropertyChangeListener listener);
    public static Object get(Object key);
    public static LookAndFeel[] getAuxiliaryLookAndFeels();
    public static Border getBorder(Object key);
    public static Color getColor(Object key);
    public static String getCrossPlatformLookAndFeelClassName();
    public static UIDefaults getDefaults();
    public static Dimension getDimension(Object key);
    public static Font getFont(Object key);
    public static Icon getIcon(Object key);
    public static Insets getInsets(Object key);
    public static UIManager.LookAndFeelInfo[] getInstalledLookAndFeels();
    public static int getInt(Object key);
    public static LookAndFeel getLookAndFeel();
    public static UIDefaults getLookAndFeelDefaults();
    public static String getString(Object key);
    public static String getSystemLookAndFeelClassName();
    public static ComponentUI getUI(JComponent component);
public static void installLookAndFeel(
  UIManager.LookAndFeelInfo info);
    public static void installLookAndFeel(String name, String className);
    public static Object put(Object key, Object value);
    public static boolean removeAuxiliaryLookAndFeel(LookAndFeel laf);
public static synchronized void removePropertyChangeListener(
  PropertyChangeListener listener);
public static void setInstalledLookAndFeels(
  UIManager.LookAndFeelInfo[] infos);
    public static void setLookAndFeel(LookAndFeel laf);
    public static void setLookAndFeel(String className);
  // Public inner classes
    public static class UIManager.LookAndFeelInfo extends Object { 
        public LookAndFeelInfo(String name, String className);
        public String getClassName();
        public String getName();
        public String toString();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
There is no constructor for <TT>UIManager</TT> because all of
its members are static. There are two groups of methods in <TT>UIManager</TT>:
methods for managing look-and-feels and methods for managing UI
defaults.
<H4>Methods to Manage Look-and-Feels</H4>
<P>
The <TT>getInstalledLookAndFeels</TT> method returns an array
of <TT>UIManager.LookAndFeelInfo</TT> objects that contains the
name and class name of all installed look-and-feel implementations,
while the <TT>getLookAndFeel</TT> method returns the current look-and-feel.
<P>
The <TT>getSystemLookAndFeelClassName</TT> returns the class name
of the look-and-feel associated with the system on which the application
is running. For example, if the application is running on Solaris,
this method will return the class name of the Motif look-and-feel.
<TT>getCrossPlatformLookAndFeel</TT> returns the class name of
the cross-platform look-and-feel, which is the Metal look-and-feel.
<P>
<TT>UIManager</TT> includes two versions of the <TT>installLookAndFeel</TT>
method to install a new look-and-feel. One of these methods allows
you to describe the look-and-feel to install by specifying its
name and class name. The other <TT>installLookAndFeel</TT> method
allows you to specify the look-and-feel with a <TT>UIManager.LookAndFeelInfo</TT>
object. Installing a look-and-feel makes it available to the <TT>UIManager</TT>-it
does not set the current look-and-feel for the application. The
<TT>setInstalledLookAndFeels</TT> method installs multiple look-and-feels
with a single method call. The <TT>LookAndFeelInfo</TT> class
is used by several <TT>UIManager</TT> methods to represent a user-presentable
description of a look-and-feel.
<P>
The two <TT>setLookAndFeel</TT> methods are the methods that actually
set the current look-and-feel. One method allows you to specify
the look-and-feel by class name and the other allows you to specify
it with a <TT>LookAndFeel</TT> object. Note that if you set a
new look-and-feel after your components have been realized, you
must call the <TT>updateUI</TT> method on all components before
they can be redrawn with the new look-and-feel. The <TT>SwingUtilities</TT>
class provides the <TT>updateComponentTreeUI</TT> method to update
the UI on an entire component hierarchy.
<P>
There are two methods, <TT>addPropertyChangeListener</TT> and
<TT>removeProperty-ChangeListener</TT>, that add and remove a
property change listener for the UI manager. The UI manager fires
a <TT>propertyChange</TT> event whenever you set a new look-and-feel.
<H4>Methods to Manage UI Defaults</H4>
<P>
The <TT>UIManager</TT> class includes the <TT>getDefaults</TT>
method to return the current UI default settings. This method
takes into account the three levels of defaults and returns the
highest level default with a non-<TT>null</TT> key. <TT>getLookAndFeelDefaults</TT>
returns the defaults from the look-and-feel level of UI defaults.
Both methods return defaults in the form of a <TT>UIDefaults</TT>
object, which is an extension of a hash table.
<P>
The <TT>get</TT> method is a general-purpose method to retrieve
a specific default setting given a key. It returns an object of
type <TT>Object</TT>. The <TT>getBorder</TT>, <TT>getColor</TT>,
<TT>getDimension</TT>, <TT>getFont</TT>, <TT>getIcon</TT>, <TT>getInsets</TT>,
<TT>getInt</TT>, and <TT>getString</TT> methods are special-purpose
default retrieval methods that return objects of the appropriate
type. There are corresponding <TT>put</TT> methods that will change
UI default values.
<P>
The <TT>getUI</TT> method creates a look-and-feel-specific UI
delegate (<TT>ComponentUI</TT>) for a given component. This method
is used by component model implementations to render the visual
representation of the component and to listen for user input gestures.
<H3><A NAME="ExampleQueryingforLookandFeelInformation">
Example Querying for Look-and-Feel Information</A></H3>
<P>
Listing 30.2 is the complete source for <TT>LAFInfoDemo</TT>,
an application that utilizes the UI manager to get and display
information about the available look-and-feels (see Figure 30.1).
<P>
<A HREF="javascript:popUp('f30-1.gif')"><B>Figure 30.1 :</B> <I>LAFInfoDemo example displays information
about available look-and-feels</I>.</A>
<P>
<HR>
<P>
<B>Listing 30.2&nbsp;&nbsp;</B><TT><B>LAFINFODEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* LAFInfoDemo.java
 *
* Illustrates how to query the UI manager
 * to get look and feel information. 
 */

import java.awt.*;
import java.util.*;
import java.awt.event.*;
import javax.swing.*;

/* Application class
 */
public class LAFInfoDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        LAFInfoDemoPanel panel = new LAFInfoDemoPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;LAFInfoDemo&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // Set initial frame size and make visible
        frame.setSize (400, 300);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class LAFInfoDemoPanel extends JPanel { 
    // Constructor
    public LAFInfoDemoPanel () { 
        setLayout(new BorderLayout());

        // create and configure scrollable text area to display info
        JTextArea textArea = new JTextArea();
        textArea.setEditable(false);
        JScrollPane scrollpane = new JScrollPane();
        scrollpane.getViewport().add(textArea);
        add(scrollpane, BorderLayout.CENTER);

        // fill text area with look and feel info
        textArea.setText(getLAFInfo());
    } 

// Private method to get look and feel info,
    // which is returned in a String
    private String getLAFInfo() { 
        String s = &quot;&quot;;

        // Build string from headings and info from UI Manager

        s = s.concat(&quot;Current look and feel:\ n&quot;);
        s = s.concat(UIManager.getLookAndFeel().getName());
        
        s = s.concat(&quot;\ n\ nInstalled look and feels:\ n&quot;);
UIManager.LookAndFeelInfo info[]
            = UIManager.getInstalledLookAndFeels();
        for(int i = 0; i &lt; info.length; i++) { 
            s = s.concat(info[i].getName() + &quot;\ n&quot;);
        } 

        s = s.concat(&quot;\ nAuxiliary look and feels:\ n&quot;);
        LookAndFeel auxinfo[] = UIManager.getAuxiliaryLookAndFeels();
        if (auxinfo != null) { 
            for(int i = 0; i &lt; auxinfo.length; i++) { 
                s = s.concat(auxinfo[i].getName());
            } 
        } 
        else { 
            s = s.concat(&quot;None\ n&quot;);
        } 

        s = s.concat(&quot;\ nCross-platform look and feel class name:\ n&quot;);
        s = s.concat(UIManager.getCrossPlatformLookAndFeelClassName());

        s = s.concat(&quot;\ n\ nSystem look and feel class name:\ n&quot;);
        s = s.concat(UIManager.getSystemLookAndFeelClassName());
        
        return(s);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZELAFInfoDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>LAFInfoDemo</TT>
Example</A></H3>
<P>
The <TT>LAFInfoDemo</TT> example consists of two classes: <TT>LAFInfoDemo</TT>
and <TT>LAFInfoDemoPanel</TT>. The <TT>LAFInfoDemo</TT> class
is a public class containing the <TT>main</TT> entry point method.
The <TT>main</TT> method creates a frame for the application and
adds an instance of the <TT>LAFInfoDemoPanel</TT> class to the
frame. The interesting part of the application is in the <TT>LAFInfoDemoPanel</TT>
class.
<P>
The constructor <TT>LAFInfoDemoPanel</TT> class creates a scrollable
text area to display the information obtained from the UI manager.
It then calls a private method, <TT>getLAFInfo</TT>, to get a
string containing the look-and-feel information. The <TT>getLAFInfo</TT>
method builds a string by concatenating heading strings with strings
obtained by calling static class methods in the <TT>UIManager</TT>
class. For example, the following code fragment concatenates the
name of the current look-and-feel to a string represented by variable
<TT>s</TT>.
<BLOCKQUOTE>
<PRE>
s = s.concat(&quot;Current look and feel:\ n&quot;);
s = s.concat(UIManager.getLookAndFeel().getName());
</PRE>
</BLOCKQUOTE>
<P>
To get a list of all installed look-and-feels, <TT>LAFInfoDemo</TT>
uses the <TT>UIManager</TT> method <TT>getInstalledLookAndFeels</TT>,
as shown in the following code fragment.
<BLOCKQUOTE>
<PRE>
s = s.concat(&quot;\ n\ nInstalled look and feels:\ n&quot;);
UIManager.LookAndFeelInfo info[] = UIManager.getInstalledLookAndFeels();
for(int i = 0; i &lt; info.length; i++) { 
    s = s.concat(info[i].getName() + &quot;\ n&quot;);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>getInstalledLookAndFeels</TT> method returns an array
of <TT>LookAndFeelInfo</TT> objects (<TT>LookAndFeelInfo</TT>
is an inner class of the <TT>UIManager</TT> class). This construction
is useful for presenting a user with a menu of look-and-feels
from which to choose, as illustrated by the next example, <TT>LAFInfoDemo2</TT>.
<H3><A NAME="SettingtheLookandFeel">
Setting the Look-and-Feel</A></H3>
<P>
The default look-and-feel for JFC applications is the Java look-and-feel
(also known as the Metal look-and-feel). If you want to use a
different look-and-feel in your application, you can call the
<TT>UIManager.setLookAndFeel</TT> method to set the look-and-feel
to any look-and-feel that is available on the platform on which
the application is running. 
<P>
To set a look-and-feel with <TT>setLookAndFeel</TT>, you specify
the look-and-feel by its class name. For example, the following
line of code sets the look-and-feel to the CDE/Motif look-and-feel.
<BLOCKQUOTE>
<PRE>
UIManager.setLookAndFeel(
  &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Instead of using a particular look-and-feel, you may want to set
up your application to use the system look-and-feel-the look-and-feel
corresponding to the platform on which the application is running.
The following line of code sets the look-and-feel to the system
look-and-feel.
<P>
<TT>UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());</TT>
<P>
Ideally, you should set the look-and-feel before constructing
any Swing components. If you set the look-and-feel after constructing
Swing components, you must call the components' <TT>updateUI</TT>
method to update the UI delegates to the delegates associated
with the new look-and-feel.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>SwingUtilities</TT> class provides a handy method, <TT>updateComponentTreeUI</TT>, for updating UI delegates on an entire component tree.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H4>Example Setting the Look-and-Feel</H4>
<P>
Listing 30.3 is the complete source for <TT>LAFInfoDemo2</TT>,
an example similar to the previous <TT>LAFInfoDemo</TT> example,
with the addition of a menu that allows you to select a look-and-feel
from a menu of installed look-and-feels (see Figure 30.2).
<P>
<A HREF="javascript:popUp('f30-2.gif')"><B>Figure 30.2 :</B> <I>LAFInfoDemo2 example allows you to select
a look-and-feel</I>.</A>
<P>
<HR>
<P>
<B>Listing 30.3&nbsp;&nbsp;</B><TT><B>LAFINFODEMO2.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* LAFInfoDemo2.java
 *
 * Illustrates how to add a menu to an application 
 * to allow user to select desired look and feel.
 */

import java.awt.*;
import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
   
/* Application class
 */
public class LAFInfoDemo2 { 

    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        final LAFInfoDemo2Panel panel = new LAFInfoDemo2Panel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;LAFInfoDemo2&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // add listener for look and feel property changes
UIManager.addPropertyChangeListener(
  new PropertyChangeListener() { 
            public void propertyChange(PropertyChangeEvent event) { 
                // update UI for all panel components
                SwingUtilities.updateComponentTreeUI(panel);
            } 
        } );

        // Set initial frame size and make visible
        frame.setSize (400, 300);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class LAFInfoDemo2Panel extends JPanel { 
    JTextArea textArea = null;
    
    // Constructor
    public LAFInfoDemo2Panel () { 
        setLayout(new BorderLayout());

// create a menu bar with &quot;Options&quot; menu 
        // and &quot;Look and Feel&quot; submenu
        JMenuBar menubar = new JMenuBar();
        JMenu menuOptions = new JMenu(&quot;Options&quot;);
        JMenu submenuLAF = new JMenu(&quot;Look and Feel&quot;);

        // create group for radio button menu items
        ButtonGroup group = new ButtonGroup();
        
        // construct menu items for each installed laf
        LAFMenuItem itemCurrentLAF = null;
String classnameCurrentLAF
            = UIManager.getLookAndFeel().getClass().getName();
        UIManager.LookAndFeelInfo info[] 
            = UIManager.getInstalledLookAndFeels();
        for(int i = 0; i &lt; info.length; i++) { 
            // create menu item
            LAFMenuItem item = new LAFMenuItem(info[i].getName(),
                                               info[i].getClassName());

            // add to menu and group
            submenuLAF.add(item);
            group.add(item);

            // remember item that represents current look and feel
            if(info[i].getClassName().equals(classnameCurrentLAF)) { 
                itemCurrentLAF = item;
            } 
        } 

// add submenu to menu, menu to menu bar, menu bar to panel
        menuOptions.add(submenuLAF);
        menubar.add(menuOptions);
        add(menubar, BorderLayout.NORTH);

        // create scrollable text area to display look and feel info
        textArea = new JTextArea();
        textArea.setEditable(false);
        JScrollPane scrollpane = new JScrollPane();
        scrollpane.getViewport().add(textArea);
        add(scrollpane, BorderLayout.CENTER);

        // update contents of text area with look and feel info
        updateLAFInfo();

        // select menu item representing current look and feel
        itemCurrentLAF.setSelected(true);
    } 

    // JComponent override to detect look and feel changes
    // This is needed to update displayed look and feel info
    // when change to look and feel is detected.
    public void updateUI() { 
        super.updateUI();

        // update displayed look and feel info
        updateLAFInfo();
    } 

    // Private method to update look and feel info displayed in text area
    private void updateLAFInfo() { 
        if(textArea != null) { 
            // ensure setText is called on event-dispatch thread
            SwingUtilities.invokeLater(new Runnable() { 
                public void run() { 
                    textArea.setText(getLAFInfo());
                } 
            } );
        } 
    } 

// Private method to get look and feel info, 
    // which is returned in a String
    private String getLAFInfo() { 
        String s = &quot;&quot;;

        // Build string from headings and info from UI Manager

        s = s.concat(&quot;Current look and feel:\ n&quot;);
        s = s.concat(UIManager.getLookAndFeel().getName());
        
        s = s.concat(&quot;\ n\ nInstalled look and feels:\ n&quot;);
UIManager.LookAndFeelInfo info[] 
            = UIManager.getInstalledLookAndFeels();
        for(int i = 0; i &lt; info.length; i++) { 
            s = s.concat(info[i].getName() + &quot;\ n&quot;);
        } 

        s = s.concat(&quot;\ nAuxiliary look and feels:\ n&quot;);
        LookAndFeel auxinfo[] = UIManager.getAuxiliaryLookAndFeels();
        if (auxinfo != null) { 
            for(int i = 0; i &lt; auxinfo.length; i++) { 
                s = s.concat(auxinfo[i].getName());
            } 
        } 
        else { 
            s = s.concat(&quot;None\ n&quot;);
        } 

        s = s.concat(&quot;\ nCross-platform look and feel class name:\ n&quot;);
        s = s.concat(UIManager.getCrossPlatformLookAndFeelClassName());

        s = s.concat(&quot;\ n\ nSystem look and feel class name:\ n&quot;);
        s = s.concat(UIManager.getSystemLookAndFeelClassName());
        
        return(s);
    } 
} 

/* Class representing look and feel menu item
 *
 * Constructs a radio button menu item from a given look and feel name.
 * When item is selected, sets given look and feel.
 */
class LAFMenuItem extends JRadioButtonMenuItem { 
    private String lafClassName;

    // Constructor
    public LAFMenuItem(String name, String className) { 
        super(name);

        // save look and feel class name in class data
        lafClassName = className;

        // add listener to detect menu selection
        addItemListener(new ItemListener() { 
            public void itemStateChanged(ItemEvent event) { 
                if(event.getStateChange() == ItemEvent.SELECTED) { 
                    try { 
                        // set look and feel
                        UIManager.setLookAndFeel(lafClassName);
                    } 
                    catch (Exception exc) { 
System.out.println(&quot;Unable to set LAF&quot;);
                    } 
                } 
            } 
        } );
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Overview of the <TT>LAFInfoDemo2</TT> Example</H4>
<P>
The <TT>LAFInfoDemo2</TT> example is structured identically to
the previous <TT>LAFInfoDemo</TT> example with the exception of
an additional class, <TT>LAFMenuItem</TT>, that is used to represent
a look-and-feel menu item. The interesting part of the example
is contained in the <TT>LAFInfoDemo2Panel</TT> and <TT>LAFMenuItem</TT>
classes.
<P>
The following code fragment from the <TT>LAFInfoDemo2Panel</TT>
constructor creates a menu item for each installed look-and-feel
and adds it to the &quot;Look-and-Feel&quot; menu.
<BLOCKQUOTE>
<PRE>
// construct menu items for each installed laf
LAFMenuItem itemCurrentLAF = null;
String classnameCurrentLAF 
    = UIManager.getLookAndFeel().getClass().getName();
UIManager.LookAndFeelInfo info[] = UIManager.getInstalledLookAndFeels();
for(int i = 0; i &lt; info.length; i++) { 
    // create menu item
    LAFMenuItem item = new LAFMenuItem(info[i].getName(),
                                       info[i].getClassName());

    // add to menu and group
    submenuLAF.add(item);
    group.add(item);

    // remember item that represents current look and feel
    if(info[i].getClassName().equals(classnameCurrentLAF)) { 
        itemCurrentLAF = item;
    } 
} 
</PRE>
</BLOCKQUOTE>
<P>
The first thing you do is get and save the class name of the current
look-and-feel. This allows you to determine which menu item represents
the current look-and-feel so you can show that item as selected
when the application is run. Next, you get a list of the installed
look-and-feels by calling the <TT>UIManager</TT> method <TT>getInstalledLookAndFeels</TT>.
This method returns an array of <TT>LookAndFeelInfo</TT> objects.
Then you create a menu item for each <TT>LookAndFeelInfo</TT>
object in the array. 
<P>
Menu items are represented by the <TT>LAFMenuItem</TT> class,
an extension of <TT>JRadioButtonMenuItem</TT>. The following fragment
is the source for the <TT>LAFMenuItem</TT> class.
<BLOCKQUOTE>
<PRE>
class LAFMenuItem extends JRadioButtonMenuItem { 
    private String lafClassName;

    // Constructor
    public LAFMenuItem(String name, String className) { 
        super(name);

        // save look and feel class name in class data
        lafClassName = className;

        // add listener to detect menu selection
        addItemListener(new ItemListener() { 
            public void itemStateChanged(ItemEvent event) { 
                if(event.getStateChange() == ItemEvent.SELECTED) { 
                    try { 
                        // set look and feel
                        UIManager.setLookAndFeel(lafClassName);
                    } 
                    catch (Exception exc) { 
System.out.println(&quot;Unable to set LAF&quot;);
                    } 
                } 
            } 
        } );
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
Note that the class contains a single data member, <TT>lafClassName</TT>.
This member is used to store the class name for the look-and-feel.
This class name is passed to the constructor along with the user-presentable
name of the look-and-feel. The item listener for the menu item
uses this class name to set the look-and-feel when the menu item
is selected.
<P>
If the item listener (implemented in an anonymous inner class)
determines that the menu item has been selected, it calls the
<TT>UIManager</TT> method <TT>setLookAndFeel</TT> to set the look-and-feel.
<H3><A NAME="TheTTFONTSIZEUIDefaultsFONTTTFONTSIZEClassFONT">
The <TT>UIDefaults</TT> Class
</A></H3>
<P>
Listing 30.4 is the signature of the <TT>UIDefaults</TT> class,
a class representing a complete set of UI defaults stored in a
hash table. There can be several hundred entries in a typical
<TT>UIDefaults</TT> hash table returned by the <TT>getDefaults</TT>
method. Note that the <TT>UIManager</TT> class provides much of
the same functionality as this class.
<P>
<HR>
<P>
<B>Listing 30.4&nbsp;&nbsp;</B><TT><B>UIDEFAULTS</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class UIDefaults extends Hashtable 
{ 
  // Public constructors
    public UIDefaults();
    public UIDefaults(Object[] keyValueList);
  // Public class methods
    public Object get(Object key);
    public Object put(Object key, Object value);
    public void putDefaults(Object[] defaults keyValueList);
    public Font getFont(Object key);
    public Color getColor(Object key);
    public Icon getIcon(Object key);
    public Border getBorder(Object key);
    public String getString(Object key);
    public int getInt(Object key);
    public Insets getInsets(Object key);
    public Dimension getDimension(Object key);
    public Class getUIClass(String id, ClassLoader loader);
    public Class getUIClass(String id);
    public ComponentUI getUI(JComponent component);
public synchronized void addPropertyChangeListener(
  PropertyChangeListener listener);
    public synchronized void removePropertyChangeListener(
  PropertyChangeListener listener);
  // Public inner classes
    public abstract class UIDefaults.LazyValue extends Object { 
        public abstract Object createValue(UIDefaults defaults);
    } 
    public abstract class UIDefaults.ActiveValue extends Object { 
        public abstract Object createValue(UIDefaults defaults);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>UIDefaults</TT> has two constructors-one constructor that
creates an empty UI defaults object and another constructor that
creates a UI defaults object with entries created from a given
array of objects.
<P>
The class has the usual hashtable <TT>get</TT> and <TT>put</TT>
methods as well as a host of methods to get specific types of
defaults: <TT>getBorder</TT>, <TT>getColor</TT>, <TT>getFont</TT>,
<TT>getIcon</TT>, and <TT>getString</TT>.
<P>
There is also a <TT>getUI</TT> method to create a look-and-feel-specific
UI delegate (<TT>ComponentUI</TT>) for a given component.
<P>
The <TT>addPropertyChangeListener</TT> and <TT>removePropertyChangeListener</TT>
methods allow you to add and remove a property change listener
for changes to UI default settings.
<H4>Example Getting UI Defaults</H4>
<P>
Listing 30.5 is the complete source for <TT>DumpDefaults</TT>,
an application that displays the current UI defaults settings
in a text area (see Figure 30.3).
<P>
<A HREF="javascript:popUp('f30-3.gif')"><B>Figure 30.3 :</B> <I>DumpDefaults example displays current UI
defaults settings</I>.</A>
<P>
<HR>
<P>
<B>Listing 30.5&nbsp;&nbsp;</B><TT><B>DUMPDEFAULTS.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* DumpDefaults.java
 *
 * Dumps the UI defaults settings to a text area.
 */

import java.awt.*;
import java.util.*;
import java.awt.event.*;
import javax.swing.*;

/* Application class
 */
public class DumpDefaults { 

    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        DumpDefaultsPanel panel = new DumpDefaultsPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;DumpDefaults&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // Set initial frame size and make visible
        frame.setSize (600, 400);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class DumpDefaultsPanel extends JPanel { 
    // Constructor
    public DumpDefaultsPanel () { 
        setLayout(new BorderLayout());

        // create and configure scrollable text area to display info
        JTextArea textArea = new JTextArea();
        textArea.setEditable(false);
        JScrollPane scrollpane = new JScrollPane();
        scrollpane.getViewport().add(textArea);
        add(scrollpane, BorderLayout.CENTER);

        // fill text area with look and feel info
        textArea.setText(getDefaults());
    } 

    // Private method to get current ui defaults,
    // and return them in a String
    private String getDefaults() { 
        String s = &quot;&quot;;

        // get ui defaults
        UIDefaults defaults = UIManager.getDefaults();

        // enumerate contents of defaults, 
        // concatenate to string in format &quot;key: element&quot;
        Enumeration keys = defaults.keys();
        Enumeration elements = defaults.elements();
        while(keys.hasMoreElements() &amp;&amp; elements.hasMoreElements()) { 
s = s.concat(keys.nextElement()
                + &quot;: &quot; + elements.nextElement() + &quot;\ n&quot;);
        } 

        return(s);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DumpDefaults</TT> example creates a text area and calls
a private method, <TT>getDefaults</TT>, to get a string containing
a description of the current UI default settings. The example
then sets the text in the text area to the string containing the
UI default settings. For a complete listing of all UI default
settings, see <TT>UIManager.txt</TT> on the CD-ROM.
<P>
To get the defaults table, the private <TT>getDefaults</TT> method
calls the static class method <TT>UIManager.getDefaults</TT>,
which returns the defaults in a <TT>UIDefaults</TT> object. <TT>getDefaults</TT>
then dumps the contents of the defaults table (which is a hashtable)
to a string by enumerating all of the keys and elements in the
table. It concatenates each key and a string representation of
the associated element object to a single string that it returns
to the caller.
<H4>Example Setting User Defaults</H4>
<P>
Listing 30.6 is the complete source for <TT>ChangeDefaultsDemo</TT>,
an application that uses the UI defaults to change the font size
of menus (see Figure 30.4).
<P>
<A HREF="javascript:popUp('f30-4.gif')"><B>Figure 30.4 :</B> <I>ChangeDefaultsDemo example uses UI defaults
to change menu font sizes</I>.</A>
<P>

<HR>
<P>
<B>Listing 30.6&nbsp;&nbsp;</B><TT><B>CHANGEDEFAULTSDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* ChangeDefaultsDemo.java
 *
 * Illustrates how to change the UI default settings.
 * This example allows the user to change the menu font size
 * independently of the look and feel chosen.
 */

import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.plaf.FontUIResource;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/* Application class
 */
public class ChangeDefaultsDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
final ChangeDefaultsDemoPanel panel
            = new ChangeDefaultsDemoPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;ChangeDefaultsDemo&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // implement listener for UI-releated property changes
PropertyChangeListener lafChangeListener 
  = new PropertyChangeListener() { 
            public void propertyChange(PropertyChangeEvent event) { 
                // update UI for all panel components
                SwingUtilities.updateComponentTreeUI(panel);
            } 
        } ;
        // add listener to UI manager and UI defaults
        UIManager.addPropertyChangeListener(lafChangeListener);
UIManager.getDefaults().addPropertyChangeListener
  zlafChangeListener);
        
        // set initial frame size and make visible
        frame.setSize (400, 300);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class ChangeDefaultsDemoPanel extends JPanel { 
    // Constructor
    public ChangeDefaultsDemoPanel () { 
        setLayout(new BorderLayout());

        // create a menu bar with &quot;Options&quot; menu
        JMenuBar menubar = new JMenuBar();
        JMenu menuOptions = new JMenu(&quot;Options&quot;);

        // create groups for radio button menu items
        ButtonGroup group1 = new ButtonGroup();
        ButtonGroup group2 = new ButtonGroup();

        // to keep track of which radio button menu items
        // should be selected when app is run
        JMenuItem itemSelected1 = null;
        JMenuItem itemSelected2 = null;

// create &quot;Menu Font Size&quot; submenu and 
        // add to Options menu and group
        JMenu submenuFontSize = new JMenu(&quot;Menu Font Size&quot;);
        JRadioButtonMenuItem itemSize10 = new JRadioButtonMenuItem(&quot;10&quot;);
        JRadioButtonMenuItem itemSize12 = new JRadioButtonMenuItem(&quot;12&quot;);
        JRadioButtonMenuItem itemSize14 = new JRadioButtonMenuItem(&quot;14&quot;);
        JRadioButtonMenuItem itemSize16 = new JRadioButtonMenuItem(&quot;16&quot;);
        JRadioButtonMenuItem itemSize18 = new JRadioButtonMenuItem(&quot;18&quot;);
        JRadioButtonMenuItem itemSize20 = new JRadioButtonMenuItem(&quot;20&quot;);
        group1.add(itemSize10);
        group1.add(itemSize12);
        group1.add(itemSize14);
        group1.add(itemSize16);
        group1.add(itemSize18);
        group1.add(itemSize20);
        submenuFontSize.add(itemSize10);
        submenuFontSize.add(itemSize12);
        submenuFontSize.add(itemSize14);
        submenuFontSize.add(itemSize16);
        submenuFontSize.add(itemSize18);
        submenuFontSize.add(itemSize20);
        menuOptions.add(submenuFontSize);

        // implement font size item listener
        class FontSizeItemListener implements ItemListener { 
            public FontSizeItemListener() { 
                super();
            } 
            public void itemStateChanged(ItemEvent event) { 
                if(event.getStateChange() == ItemEvent.SELECTED) { 
                    // get source of event
                    JMenuItem item = (JMenuItem) event.getSource();
                    // get new font size from menu item text 
                    Integer temp = new Integer(item.getText());
                    // set new default 
                    setMenuFontSizeDefault(temp.intValue());
                } 
            } 
        } 

        // construct and add item listener for font size menu items
        FontSizeItemListener sizeListener = new FontSizeItemListener();
        itemSize10.addItemListener(sizeListener);
        itemSize12.addItemListener(sizeListener);
        itemSize14.addItemListener(sizeListener);
        itemSize16.addItemListener(sizeListener);
        itemSize18.addItemListener(sizeListener);
        itemSize20.addItemListener(sizeListener);

// create Look and Feel submenu and construct 
        // menu items for each installed laf
        String classnameCurrentLAF = UIManager.getLookAndFeel().getClass().getName();
        JMenu submenuLAF = new JMenu(&quot;Look and Feel&quot;);
UIManager.LookAndFeelInfo info[] 
            = UIManager.getInstalledLookAndFeels();
        for(int i = 0; i &lt; info.length; i++) { 
            // create menu item
            LAFMenuItem item = new LAFMenuItem(info[i].getName(),
info[i].getClassName(),
                                               this);
            // add to menu and group
            submenuLAF.add(item);
            group2.add(item);

            // remember item that represents current look and feel
            if(info[i].getClassName().equals(classnameCurrentLAF)) { 
                itemSelected2 = item;
            } 
        } 

// add submenu to menu, menu to menu bar, menu bar to panel
        menuOptions.add(submenuLAF);
        menubar.add(menuOptions);
        add(menubar, BorderLayout.NORTH);

        // select menu item representing current font size, look and feel
        if(itemSelected1 != null) 
            itemSelected1.setSelected(true);
        if(itemSelected2 != null) 
            itemSelected2.setSelected(true);
    } 

    // Private method to change default menu font size
    private void setMenuFontSizeDefault(int size) { 
        // get font style and name from current menu font
        Font fontCurrent = UIManager.getFont(&quot;Menu.font&quot;);
        String name = fontCurrent.getName();
        int style = fontCurrent.getStyle();

        // create similar font with the specified size
FontUIResource fontResourceNew
            = new FontUIResource(name, style, size);

        // change UI defaults for all types of menu components
        UIManager.put(&quot;Menu.font&quot;, fontResourceNew);
        UIManager.put(&quot;MenuItem.font&quot;, fontResourceNew);
        UIManager.put(&quot;RadioButtonMenuItem.font&quot;, fontResourceNew);
        UIManager.put(&quot;PopupMenu.font&quot;, fontResourceNew);
    } 
}    

/* Class representing look and feel menu item
 *
 * Constructs a radio button menu item from a given look and feel name.
 * When item is selected, sets given look and feel and updates
 * the component tree beginning at the given root component.
 */
class LAFMenuItem extends JRadioButtonMenuItem { 
    private String lafClassName;
    private Component rootComponent;

    // Constructor
    public LAFMenuItem(String name, String className, Component root) { 
        super(name);

        // save look and feel class name and root component in class data
        lafClassName = className;
        rootComponent = root;

        // add listener to detect menu selection
        addItemListener(new ItemListener() { 
            public void itemStateChanged(ItemEvent event) { 
                if(event.getStateChange() == ItemEvent.SELECTED) { 
                    try { 
                        // set look and feel and update component tree
                        UIManager.setLookAndFeel(lafClassName);
                    } 
                    catch (Exception exc) { 
System.out.println(&quot;Unable to set LAF&quot;);
                    } 
                } 
            } 
        } );
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Overview of the <TT>ChangeDefaultsDemo</TT> Example</H4>
<P>
Although you can also change the font size of menus by calling
the <TT>setFont</TT> method, you would have to call this method
on each and every menu and menu item component. By changing the
menu font in the UI defaults, you automatically change the font
for every menu and menu item in the application.
<P>
Take a look at how <TT>ChangeDefaultsDemo</TT> changes the menu
font size in the UI defaults. The following fragment is the code
for a private method, <TT>setMenuFontSizeDefault</TT>, that sets
the default font size for menu components to a specified size
(specified in points).
<BLOCKQUOTE>
<PRE>
private void setMenuFontSizeDefault(int size) { 
    // get font style and name from current menu font
    Font fontCurrent = UIManager.getFont(&quot;Menu.font&quot;);
    String name = fontCurrent.getName();
    int style = fontCurrent.getStyle();

    // create similar font with the specified size
FontUIResource fontResourceNew
        = new FontUIResource(name, style, size);

    // change UI defaults for all types of menu components
    UIManager.put(&quot;Menu.font&quot;, fontResourceNew);
    UIManager.put(&quot;MenuItem.font&quot;, fontResourceNew);
    UIManager.put(&quot;RadioButtonMenuItem.font&quot;, fontResourceNew);
    UIManager.put(&quot;PopupMenu.font&quot;, fontResourceNew);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setMenuFontSizeDefault</TT> method first gets the current
menu font by calling <TT>UIManager.getFont</TT> to get the <TT>Menu.font</TT>
default setting. It then gets the name and style of the font and
uses this information to create a new font of the specified size.
The code then calls <TT>UIManager.put</TT> to change the default
fonts for menus, menu items, radio button menu items, and pop-up
menus. All instances of these types of components will now be
drawn with the new font.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
JFC's pluggable look-and-feel is made possible by the Model View
Controller architecture used in components. This architecture
abstracts the look-and-feel of components from the model or data
the components represent. A UI manager, essentially a collection
of static class methods, allows you to determine which look-and-feel
implementations are available at runtime and to choose which look-and-feel
to use in your application. The pluggable look-and-feel architecture
also supports the concept of UI defaults-default settings for
various UI-rendering attributes such as font, borders, and colors.
By changing the UI defaults, you can control aspects of how components
are rendered, regardless of which look-and-feel you are using.
In addition to several platform-specific look-and-feels, JFC includes
a cross-platform look-and-feel known as the Metal or Java look-and-feel.
The Metal look-and-feel is the default look-and-feel for JFC applications.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch29\ch29.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch31\ch31.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
