<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 31 -Timers </TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch30\ch30.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch32\ch32.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;31<br>
Timers</H1>
<HR>
<p>

<UL>
<LI><A HREF="#TimerBasics">
Timer Basics</A>
<UL>
<LI><A HREF="#TheTTFONTSIZETimerFONTTTFONTSIZEClassFONT">
The <TT>Timer Class</TT>
</A>
<LI><A HREF="#CreatingandUsingaBasicTimer">
Creating and Using a Basic Timer</A>
</UL>
<LI><A HREF="#ExampleUsingPeriodicandOneShotTimers">
Example Using Periodic and One-Shot Timers</A>
<UL>
<LI><A HREF="#OverviewoftheTTFONTSIZEActivityTimeoutDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>ActivityTimeoutDemo</TT>
Example</A>
</UL>
<LI><A HREF="#ExampleIllustratingTimerResolution">
Example Illustrating Timer Resolution</A>
<UL>
<LI><A HREF="#OverviewofTTFONTSIZETimerResolutionDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>TimerResolutionDemo</TT>
Example</A>
<LI><A HREF="#CreatingthePeriodicTimer">
Creating the Periodic Timer</A>
<LI><A HREF="#StartingtheTimer">
Starting the Timer</A>
<LI><A HREF="#ServicingtheTimer">
Servicing the Timer</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
General-purpose timers are often used in applications to periodically
trigger actions and to monitor the progress of asynchronous operations.
Until JFC, however, Java programmers had to develop their own
timer classes or use timer objects provided with class libraries
that accompany Java IDE products-this support was not previously
available in the JDK.
<P>
In this chapter, you will learn
<UL>
<LI>How to create and use timers<BR>
JFC timers are based on the <TT>Timer</TT> class. You can use
this class to create both periodic and one-shot timers.
<LI>How to ensure your timers are thread safe<BR>
JFC places some restrictions on accessing Swing components from
threads other than the event-dispatch thread. These restrictions
apply to timers.
<LI>About some issues related to timer resolution<BR>
JFC timers are quite useful as general-purpose timers, but their
resolution is not high enough for some demanding applications.
</UL>
<H2><A NAME="TimerBasics">
Timer Basics</A></H2>
<P>
There are two types of timers: <I>periodic</I>
timers and <I>one-shot</I> timers.
Periodic timers cause an action to occur periodically-they continue
to run and cause actions until they are stopped. One-shot timers
cause an action to happen only once, and then they must be restarted
if they are to continue to operate. JFC timers can operate either
as periodic or as one-shot timers. 
<P>
In addition to the normal delay setting, JFC timers have an <I>initial
delay</I> setting. The initial delay specifies the delay
for the first timer period. Subsequent periods will be timed according
the normal delay setting. For example, you can create a periodic
timer with a delay of one second and an initial delay of five
seconds. When started, the timer will generate an action event
after five seconds and every second thereafter.<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
JFC requires that Swing components be accessed by only one thread at a time, the event- dispatch thread. JFC timers are designed to execute on the event- dispatch thread, so there are no special requirements for accessing Swing components from timers.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H3><A NAME="TheTTFONTSIZETimerFONTTTFONTSIZEClassFONT">
The <TT>Timer</TT> Class
</A></H3>
<P>
Take a look at the <TT>Timer</TT> class, the class that provides
JFC's support for timers (see Listing 31.1).
<P>
<HR>
<P>
<B>Listing 31.1&nbsp;&nbsp;</B><TT><B>TIMER</B></TT><B>
Class Signature<BR>
</B>
<BLOCKQUOTE>
<PRE>
public class Timer extends Object implements Serializable 
{ 
  // Protected instance variable
    protected EventListenerList listenerList;
  // Public constructor
    public Timer(int delay, ActionListener listener);
  // Public class methods
    public static boolean getLogTimers();
    public static void setLogTimers(boolean enable);
  // Public instance methods
    public void addActionListener(ActionListener listener);
    public boolean doesCoalesce();
    public int getDelay();
    public int getInitialDelay();
    public boolean isRunning();
    public void removeActionListener(ActionListener listener);
    public boolean repeats();
    public void restart();
    public void setCoalesce(boolean enable);
    public void setDelay(int);
    public void setInitialDelay(int delay);
    public void setRepeats(boolean enable);
    public void start();
    public void stop();
  // Protected instance methods
    protected void fireActionPerformed(ActionEvent event);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
There is a single public constructor for creating <TT>Timer</TT>
objects. Although you must specify a delay value and an action
listener when calling the constructor, you can change these values
later with the <TT>setDelay</TT>, <TT>setInitialDelay</TT>, and
<TT>addActionListener</TT> methods.
<P>
The <TT>getDelay</TT> and <TT>getInitialDelay</TT> methods return
the current delay settings, and <TT>removeActionListener</TT>
removes a specified action listener. Note that you can have multiple
action listeners for a timer.
<P>
The <TT>setRepeats</TT> method determines whether a timer is a
periodic or a one-shot timer. If you specify <TT>true</TT>, the
timer will be a periodic timer. If you specify <TT>false</TT>,
the timer will a one-shot timer. You don't have to call <TT>setRepeats</TT>
if you want a periodic timer-timers are periodic by default. The
<TT>repeats</TT> method queries a timer and returns <TT>true</TT>
if it is set to be a periodic timer.
<P>
A timer won't begin operation until you call its <TT>start</TT>
method. If you call a timer's <TT>stop</TT> method, the timer
will stop operation without triggering an <TT>actionPerformed</TT>
action. Note that calling <TT>stop</TT> and then <TT>start</TT>
does not function like a pause/resume operation. When you start
a timer after stopping it, the timer goes through its full delay
cycle. To determine if a timer is started or stopped, you can
call the <TT>isRunning</TT> method.
<P>
The <TT>restart</TT> method is the equivalent of calling <TT>stop</TT>
and then <TT>start</TT>. This method is useful when you want to
use a timer to detect the absence of some significant event for
a period of time. For example, to detect when a user has not moved
the mouse or pressed a key on the keyboard, you can start a one-shot
timer and restart it each time you receive mouse movement or key
press events. See the &quot;Example Using Periodic and One-Shot
Timers&quot; section, later in this chapter, for an example illustrating
this technique.
<P>
A busy application may not be able to keep up with the action
events generated by a rapidly firing periodic timer. By default,
timers coalesce multiple queued action events into a single event;
this occurs when <TT>setCoalesce</TT> is set to <TT>true</TT>.
You can change this behavior with the <TT>setCoalesce</TT> method.
The <TT>doesCoalesce</TT> method will return <TT>true</TT> if
a timer is coalescing queued events.
<H3><A NAME="CreatingandUsingaBasicTimer">
Creating and Using a Basic Timer</A></H3>
<P>
To create a timer, you call the <TT>Timer</TT> constructor, specify
a delay value in milliseconds, and specify an action listener
to be notified when the timer expires. To start the timer, you
call the <TT>start</TT> method. Upon expiration, the timer will
call the given action listener's <TT>actionPerformed</TT> method.
For example, the following code fragment will create a periodic
timer that will write &quot;Tick&quot; to the standard output
stream every five seconds.
<BLOCKQUOTE>
<PRE>
// Create a periodic timer with a delay of 5000 milliseconds
Timer timer = new Timer(5000, new ActionListener() { 
    // Method called each time timer expires
    public void actionPerformed(ActionEvent event) { 
        System.out.println(&quot;Tick&quot;);
    } 
} );
// Start timer
timer.start();
</PRE>
</BLOCKQUOTE>
<P>
In this example, the timer's action listener is implemented as
an anonymous inner class. Note that the default for a JFC timer
is periodic. For a one-shot timer, you must call the <TT>setRepeats</TT>
method with the <TT>enable</TT> parameter set to <TT>false</TT>
to indicate that the timer should not repeat.<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
When you create a timer, the normal delay <I>and</I> the initial delay are set to the specified delay value. However, if you use <TT>setDelay</TT> to change the delay of a timer, you must also call <TT>setInitialDelay</TT> to change the initial delay value.
</BLOCKQUOTE>
<BLOCKQUOTE>
If a timer is set to be a one-shot timer, the timer uses only the initial delay setting. You must use the <TT>setInitialDelay</TT> method to set the delay of one-shot timers.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H2><A NAME="ExampleUsingPeriodicandOneShotTimers">
Example Using Periodic and One-Shot Timers</A></H2>
<P>
Listing 31.2 is the complete source for <TT>ActivityTimeout</TT>,
an application that automatically shuts down after a period of
30 seconds of user inactivity. See Figure 31.1 for the output
of this code. This example utilizes both periodic and one-shot
timers.
<P>
<A HREF="javascript:popUp('f31-1.gif')"><B>Figure 31.1 :</B> <I>ActivityTimeout-Demo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 31.2&nbsp;&nbsp;</B><TT><B>ACTIVITYTIMEOUTDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* ActivityTimeoutDemo.java
 *
 * Application that shuts down after a 
 * predetermined period of user inactivity.
 *
 * Illustrates the use of JFC timers (periodic and one-shot).
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/* App class
 */
public class ActivityTimeoutDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // Create app panel
        ActivityTimeoutDemoPanel panel = new ActivityTimeoutDemoPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;ActivityTimeoutDemo&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to content pane
        frame.getContentPane().add(panel);

        // Set initial frame size and make visible
        frame.setSize (300, 150);
        frame.setVisible(true);
    } 
} 

/* App panel class
 *
 * All functionality of app resides here.
 */
class ActivityTimeoutDemoPanel extends JPanel { 
    Timer timerActivity,     // input activity timer
          timerCountdown;    // countdown timer
    final int TIMEOUT = 30;                 // timeout period in seconds
    int countdownTicks = TIMEOUT;           // countdown value
    JLabel countdownDisplay;                // countdown display component
    
    // Constructor
    public ActivityTimeoutDemoPanel () { 

        setLayout(new BorderLayout());

        // request focus so that panel will get keyboard events
        // see also: isFocusTraversable override in this class
        requestFocus();

        // create label to display informational text
        String s = &quot;Application will close after &quot;
                 + TIMEOUT + &quot; seconds of inactivity...&quot;;
        add(new JLabel(s), &quot;North&quot;);

        // create label to display countdown value
        add(countdownDisplay = new JLabel(Integer.toString(TIMEOUT)),
                                          &quot;South&quot;);


        // add listeners to detect user activity
        // implement listeners in anonymous inner class
        addKeyListener(new KeyAdapter() { 
            public void keyPressed(KeyEvent event) { 
                handleUserActivity();
            } 
        } );
        addMouseListener(new MouseAdapter() { 
            public void mouseClicked(MouseEvent event) { 
                handleUserActivity();
            } 
        } );
        addMouseMotionListener(new MouseMotionAdapter() { 
            public void mouseMoved(MouseEvent event) { 
                handleUserActivity();
            } 
        } );

        // create periodic timer for countdown
        timerCountdown = new Timer(1000, new ActionListener() { 
            public void actionPerformed(ActionEvent event) { 
                serviceCountdownTimer();
            } 
        } );
        timerCountdown.setRepeats(true);

        // create one-shot timer for activity timeout
        timerActivity = new Timer(TIMEOUT*1000, new ActionListener() { 
            public void actionPerformed(ActionEvent event) { 
                serviceActivityTimer();
            } 
        } );
        timerActivity.setRepeats(false);

        // start both timers
        timerCountdown.start();
        timerActivity.start();
    } 

    // Override so that panel can get input focus to receive keyboard events
    // (by default, a panel will not get 
    // the focus because it's not a UI component)
    public boolean isFocusTraversable () { 
        return true;
    } 

    // helper method called whenever user activity detected
    void handleUserActivity() { 
        // restart activity timeout
        timerActivity.restart();
        // reset countdown value and update display
        countdownTicks = TIMEOUT;
        updateDisplay();
    } 

    // helper method called to service countdown timer
    void serviceCountdownTimer() { 
        // decrement countdown value and update display
        -countdownTicks;
        updateDisplay();
    } 

    // helper method called to update countdown display
    void updateDisplay() { 
        countdownDisplay.setText(Integer.toString(countdownTicks));
    } 

    // helper method to service activity timeout
    void serviceActivityTimer() { 
        // Although this method is run in timer thread, it
        // does not make calls to Swing components. Therefore,
        // it's thread safe without use of invokeLater.
        
        // quit the app
        System.exit(0);
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewoftheTTFONTSIZEActivityTimeoutDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>ActivityTimeoutDemo</TT>
Example</A></H3>
<P>
<TT>ActivityTimeoutDemo</TT> uses a one-shot timer, <TT>timerActivity</TT>,
to measure how much time has elapsed since the last user action.
This timer is restarted whenever the application gets mouse, mouse
movement, or keyboard events. If enough time elapses without activity,
the timer fires and its listener calls the <TT>serviceActivityTimer</TT>
helper method to exit the application. 
<H4>Creating the Timers</H4>
<P>
The following is the code that creates the <TT>timerActivity</TT>
timer. This code also includes the timer's listener that is implemented
in an anonymous inner class.
<BLOCKQUOTE>
<PRE>
// create one-shot timer for activity timeout
timerActivity = new Timer(TIMEOUT*1000, new ActionListener() { 
    public void actionPerformed(ActionEvent event) { 
        serviceActivityTimer();
    } 
} );
timerActivity.setRepeats(false);
</PRE>
</BLOCKQUOTE>
<P>
The listener for this timer calls the <TT>serviceActivityTimer</TT>
helper method that exits the application (because the timer has
expired with no detected user input activity). 
<P>
A second timer, <TT>timerCountdown</TT>, is a periodic timer used
to provide a display of the number of seconds remaining before
the application is shut down. Its delay is set to one second (1000
milliseconds). This timer is not restarted when user activity
is detected-it continues to run until the application is exited.
<BLOCKQUOTE>
<PRE>
// create periodic timer for countdown
timerCountdown = new Timer(1000, new ActionListener() { 
    public void actionPerformed(ActionEvent event) { 
        serviceCountdownTimer();
    } 
} );
timerCountdown.setRepeats(true);
</PRE>
</BLOCKQUOTE>
<P>
The listener for the <TT>timerCountdown</TT> timer (again implemented
in an anonymous inner class) calls the <TT>serviceCountdownTimer</TT>
helper method. This helper method decrements the <TT>countdownTicks</TT>
variable to keep track of the number of seconds that have elapsed
since the most recent user activity. It also updates the countdown
display, the value that appears in the lower-left corner of the
application's window.
<H4>Updating the Countdown Display</H4>
<P>
The following code fragment is the <TT>serviceCountdownTimer</TT>
helper method that is called each time the <TT>timerCountdown</TT>
timer fires.
<BLOCKQUOTE>
<PRE>
// helper method called to service countdown timer
void serviceCountdownTimer() { 
    // decrement countdown value and update display
    --countdownTicks;
    updateDisplay();
} 
</PRE>
</BLOCKQUOTE>
<P>
The purpose of the <TT>timerCountdown</TT> timer is to provide
a display indicating the number of seconds before the application
automatically shuts down.
<H4>Detecting User Activity</H4>
<P>
To detect user activity, the example uses three listeners: a mouse
listener, a mouse movement listener, and a key listener.
<BLOCKQUOTE>
<PRE>
// add listeners to detect user activity
// implement listeners in anonymous inner class
addKeyListener(new KeyAdapter() { 
    public void keyPressed(KeyEvent event) { 
        handleUserActivity();
    } 
} );
addMouseListener(new MouseAdapter() { 
    public void mouseClicked(MouseEvent event) { 
        handleUserActivity();
    } 
} );
addMouseMotionListener(new MouseMotionAdapter() { 
    public void mouseMoved(MouseEvent event) { 
        handleUserActivity();
    } 
} );
</PRE>
</BLOCKQUOTE>
<P>
All of these listeners call the <TT>handleUserActivity</TT> helper
method. This method restarts the one-shot <TT>timerActivity</TT>
timer, resets the <TT>countdownTicks</TT> value, and updates the
countdown display.
<BLOCKQUOTE>
<PRE>
// helper method called whenever user activity detected
void handleUserActivity() { 
    // restart activity timeout
    timerActivity.restart();
    // reset countdown value and update display
    countdownTicks = TIMEOUT;
    updateCountdownDisplay();
} 
</PRE>
</BLOCKQUOTE>
<P>
In order to receive keyboard events, components must have the
current input focus. However, components that are not user-interface
components, like panels, normally do not get the focus. To receive
keyboard events in the <TT>ActivityTimeoutDemoPanel</TT> class,
you must do two things:
<UL>
<LI>Override the <TT>isFocusTraversable</TT> method and return
<TT>true</TT> to inform the focus manager that the component can
get the focus.
<LI>Call the <TT>requestFocus</TT> method to request the focus.
</UL>
<P>
Another approach to detecting user activity (in lieu of using
listeners) would be to override the panel's <TT>processEvent</TT>
method. It's arguable whether this approach offers any advantages
over using listeners-it still requires the same approach to getting
the focus to receive keyboard events.
<H2><A NAME="ExampleIllustratingTimerResolution">
Example Illustrating Timer Resolution</A></H2>
<P>
JFC timers are fine for general-purpose use, but they are not
designed to be used as high-precision timers. Examples of applications
requiring high-precision timers include MIDI sequencers and high-performance
animation engines. JFC timer implementation is based on a platform-dependent
method in the <TT>System</TT> class <TT>currentTimeMillis</TT>.
On the Windows platform, the resolution of <TT>currentTimeMillis</TT>
is 55 milliseconds.
<P>
Listing 31.3 is the complete source for <TT>TimerResolutionDemo</TT>,
an example that illustrates timer resolution. Figure 31.2 shows
the output of this code.
<P>
<A HREF="javascript:popUp('f31-2.gif')"><B>Figure 31.2 :</B> <I>TimerResolution-Demo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 31.3&nbsp;&nbsp;</B><TT><B>TIMERRESOLUTIONDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* TimerResolutionDemo.java
 *
 * Application measures timer periods and keeps 
 * track of maximum, minimum, and average period.
 *
 * Illustrates basic use of JFC timers.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;

/* App class
 */
public class TimerResolutionDemo { 
    
    // Main entry point
    public static void main (String s[]) { 
        // Create app panel
        TimerResolutionDemoPanel panel = new TimerResolutionDemoPanel();

        // Create a frame for app
        JFrame frame = new JFrame(&quot;TimerResolutionDemo&quot;);

        // Add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // Add app panel to frame's content pane
        frame.getContentPane().add(panel);

        // Set size and make visible
        frame.setSize (350, 150);
        frame.setVisible (true);
    } 
} 

/* App panel class
 *
 * All functionality of app resides here.
 */
class TimerResolutionDemoPanel extends JPanel { 
    Timer timer;
    int maxPeriod, minPeriod, avgPeriod, tickCount;
    long timeLastTick, timeStarted;

    // init string for display fields
    String sLabelInit = (&quot;                  &quot;);

    // max, min, avg period display fields
    JLabel labelMax = new JLabel(sLabelInit);
    JLabel labelMin = new JLabel(sLabelInit);
    JLabel labelAvg = new JLabel(sLabelInit);
            
    // constructor
    public TimerResolutionDemoPanel() { 
        // create radio buttons to allow selection of timer period
        JRadioButton rb1 = new JRadioButton(&quot;1 msec&quot;);
        rb1.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                startTimer(1);
            } 
        } );
        JRadioButton rb2 = new JRadioButton(&quot;10 msec&quot;);
        rb2.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                startTimer(10);
            } 
        } );
        JRadioButton rb3 = new JRadioButton(&quot;100 msec&quot;);
        rb3.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                startTimer(100);
            } 
        } );
        JRadioButton rb4 = new JRadioButton(&quot;1000 msec&quot;);
        rb4.addActionListener(new ActionListener() { 
            public void actionPerformed(ActionEvent e) { 
                startTimer(1000);
            } 
        } );

        // create a button group for radio buttons
        ButtonGroup group = new ButtonGroup();
        group.add(rb1);
        group.add(rb2);
        group.add(rb3);
        group.add(rb4);

        // create a horizontal box to contain radio buttons
        MyBox box_h1 = new MyBox(BoxLayout.X_AXIS);
        box_h1.setBorder(new TitledBorder(&quot;Timer Period&quot;));
        box_h1.add(rb1);
        box_h1.add(rb2);
        box_h1.add(rb3);
        box_h1.add(rb4);

        // create a vertical box and add labels for display fields
        MyBox box_v1 = new MyBox(BoxLayout.Y_AXIS);
        box_v1.add(new JLabel(&quot;Maximum Period:      &quot;));
        box_v1.add(new JLabel(&quot;Minimum Period:      &quot;));
        box_v1.add(new JLabel(&quot;Average Period:      &quot;));

        // create a vertical box and add min, max, avg display fields
        MyBox box_v2 = new MyBox(BoxLayout.Y_AXIS);
        box_v2.add(labelMax);
        box_v2.add(labelMin);
        box_v2.add(labelAvg);

        // arrange the 2 vertical boxes side-by-side in a horizontal box
        MyBox box_h2 = new MyBox(BoxLayout.X_AXIS);
        box_h2.add(box_v1);
        box_h2.add(box_v2);

        // add the boxes to panel
        add(box_h1);
        add(box_h2);

        // create a periodic timer, don't coalesce events
        timer = new Timer(0, new TimerListener());
        timer.setRepeats(true);
        timer.setCoalesce(false);
    } 

    // helper function to restart timer with new delay 
    void startTimer(int delay) { 
        // reset min, max, avg values
        maxPeriod = 0;
        minPeriod = 100000;     // very large value
        avgPeriod = 0;
        tickCount = 0;
        
        // ensure timer is stopped
        if (timer.isRunning()) timer.stop();
        
        // change delay
        timer.setInitialDelay(delay);
        timer.setDelay(delay);

        // reset timestamps to current time and start timer
        timeStarted = timeLastTick = System.currentTimeMillis();
        timer.start();
    } 

    // listener for timer
    class TimerListener implements ActionListener { 
        public void actionPerformed(ActionEvent event) { 
            // get current time
            long timeNow = System.currentTimeMillis();

            tickCount++;

            // calculate timer period
            int period = (int)(timeNow - timeLastTick);

            // calculate max, min, average
            if (period &gt; maxPeriod) { 
                maxPeriod = period;
            } 
            if (period &lt; minPeriod) { 
                minPeriod = period;
            } 
            avgPeriod = ((int)(timeNow - timeStarted)) / tickCount;

            // save time of this event to calculate next period
            timeLastTick = timeNow;

            // update display
            labelMax.setText(Integer.toString(maxPeriod));
            labelMin.setText(Integer.toString(minPeriod));
            labelAvg.setText(Integer.toString(avgPeriod));
        } 
    } 
} 

// Workaround for problems with Box class
// Use JPanel with BoxLayout layout manager
class MyBox extends JPanel { 
    public MyBox(int axis) { 
        super();
        setLayout(new BoxLayout(this, axis));
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="OverviewofTTFONTSIZETimerResolutionDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>TimerResolutionDemo</TT>
Example</A></H3>
<P>
A large portion of the <TT>TimerResolutionDemo</TT> example code
is related to the user interface-four radio buttons and six labels.
These components are grouped in boxes to create the desired appearance.
<TT>TimerResolutionDemo</TT> uses the <TT>System.currentTimeMillis</TT>
method to measure the delay of a periodic timer. Because JFC timers
use <TT>currentTimeMillis</TT> as their time source, this may
seem like a dubious approach to measuring timer resolution. However,
<TT>currentTimeMillis</TT> is the only time source that is available,
and this approach actually works quite well to illustrate the
resolution of JFC timers.
<P>
The <TT>TimerResolutionDemoPanel</TT> constructor instantiates
four radio buttons that use anonymous inner classes to implement
action listeners. 
<BLOCKQUOTE>
<PRE>
// create radio buttons to allow selection of timer period
JRadioButton rb1 = new JRadioButton(&quot;1 msec&quot;);
rb1.addActionListener(new ActionListener() { 
	public void actionPerformed(ActionEvent e) { 
		startTimer(1);
	} 
} );
JRadioButton rb2 = new JRadioButton(&quot;10 msec&quot;);
rb2.addActionListener(new ActionListener() { 
	public void actionPerformed(ActionEvent e) { 
		startTimer(10);
	} 
} );
JRadioButton rb3 = new JRadioButton(&quot;100 msec&quot;);
rb3.addActionListener(new ActionListener() { 
	public void actionPerformed(ActionEvent e) { 
		startTimer(100);
	} 
} );
JRadioButton rb4 = new JRadioButton(&quot;1000 msec&quot;);
rb4.addActionListener(new ActionListener() { 
	public void actionPerformed(ActionEvent e) { 
		startTimer(1000);
	} 
} );
</PRE>
</BLOCKQUOTE>
<P>
The radio button listeners all call the <TT>startTimer</TT> helper
method to initialize the timer to the specified delay in milliseconds
and then start the timer.
<H3><A NAME="CreatingthePeriodicTimer">
Creating the Periodic Timer</A></H3>
<P>
After creating the remainder of the user interface, the constructor
creates a periodic timer.
<BLOCKQUOTE>
<PRE>
// create a periodic timer, don't coalesce events
timer = new Timer(0, new TimerListener());
timer.setRepeats(true);
timer.setCoalesce(false);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setCoalesce</TT> method is called to inform the timer
not to coalesce pending timer events. Since one of the tasks of
the application is to calculate the average timer period, any
coalesced events would affect the accuracy of this calculation.
Note that the timer is created with a delay setting of zero. The
proper delay value will be set before the timer is started. 
<H3><A NAME="StartingtheTimer">
Starting the Timer</A></H3>
<P>
The application doesn't begin operation until you select one of
the radio buttons to specify a timer delay setting. The action
listeners for the radio buttons call the <TT>startTimer</TT> helper
method with a parameter specifying the chosen timer delay setting
in milliseconds. 
<BLOCKQUOTE>
<PRE>
// helper function to restart timer with new delay 
void startTimer(int delay) { 
	// reset min, max, avg values
	maxPeriod = 0;
	minPeriod = 100000;     // very large value
	avgPeriod = 0;
	tickCount = 0;

	// ensure timer is stopped
	if (timer.isRunning()) timer.stop();

	// change delay
	timer.setInitialDelay(delay);
	timer.setDelay(delay);

	// reset timestamps to current time and start timer
	timeStarted = timeLastTick = System.currentTimeMillis();
	timer.start();
} 
</PRE>
</BLOCKQUOTE>
<P>
First, <TT>startTimer</TT> resets variables used to store the
maximum, minimum, and average period and the tick count. The tick
count is simply a count of the number of times the timer has fired.
The method then ensures that the timer is stopped by querying
with <TT>isRunning</TT> and, if necessary, calling <TT>stop</TT>.
It then sets both the delay and the initial delay to the specified
delay value. Remember, with periodic timers you must change both
of these values (unless you actually want an initial delay that
is different from the regular delay). After calling <TT>currentTimeMillis</TT>
to get a new value for the <TT>timeStarted</TT> and <TT>timeLastTick</TT>
variables, <TT>startTimer</TT> calls the <TT>start</TT> method
to start the periodic timer.
<H3><A NAME="ServicingtheTimer">
Servicing the Timer</A></H3>
<P>
The listener for the periodic timer is implemented in a class
named <TT>TimerListener</TT>. The following fragment is the source
for <TT>TimerListener</TT>:
<BLOCKQUOTE>
<PRE>
// listener for timer
class TimerListener implements ActionListener { 
    public void actionPerformed(ActionEvent event) { 
        // get current time
        long timeNow = System.currentTimeMillis();

        tickCount++;

        // calculate timer period
        int period = (int)(timeNow - timeLastTick);

        // calculate max, min, average
        if (period &gt; maxPeriod) { 
            maxPeriod = period;
        } 
        if (period &lt; minPeriod) { 
            minPeriod = period;
        } 
        avgPeriod = ((int)(timeNow - timeStarted)) / tickCount;

        // save time of this event to calculate next period
        timeLastTick = timeNow;

        // update display
        labelMax.setText(Integer.toString(maxPeriod));
        labelMin.setText(Integer.toString(minPeriod));
        labelAvg.setText(Integer.toString(avgPeriod));
    } 
}
</PRE>
</BLOCKQUOTE>
<P>
Each time the timer fires, its listener receives an action event
via the <TT>actionPerformed</TT> method. The first thing the timer
listener does is call <TT>currentTimeMillis</TT> to get the current
time in milliseconds. It then increments the tick count and determines
the timer period from the difference in the current time and the
time of the last timer action event (stored in the <TT>timeLastTick</TT>
variable). After calculating the maximum, minimum, and average
timer periods, the timer listener updates <TT>timeLastTick</TT>
with the current time value.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
JFC provides both periodic and one-shot timer services with the
<TT>javax.swing.Timer</TT> class. The <TT>ActivityTimeoutDemo</TT>
example illustrates how to create and use JFC timers by implementing
an application that automatically quits after a certain period
of time elapses with no detectable activity from the user. 
<P>
The resolution of JFC timers depends on the platform that the
application is running on-for the Windows platform, timer resolution
is 55 milliseconds. The <TT>TimerResolutionDemo</TT> example explores
timer resolution by comparing a periodic timer interval to an
elapsed time obtained by using the <TT>System.currentTimeMillis</TT>
method. You can use this example to observe how certain kinds
of system activity affects timer accuracy.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch30\ch30.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch32\ch32.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
