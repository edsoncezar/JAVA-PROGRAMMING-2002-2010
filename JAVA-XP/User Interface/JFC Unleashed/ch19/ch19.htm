<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 19 - Choice Dialog Boxes</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch18\ch18.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch20\ch20.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;19<br>
Choice Dialog Boxes</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TheTTFONTSIZEJFileChooserFONTTTFONTSIZEClassFONT">
The <TT>JFileChooser</TT> Class</A>
<UL>
<LI><A HREF="#SpecifyingFileUUFilters">
Specifying File<U> </U>Filters</A>
<LI><A HREF="#RetrievingtheSelectedFileorDirectory">
Retrieving the Selected File or Directory</A>
<LI><A HREF="#TheAccessoryComponent">
The Accessory Component</A>
<LI><A HREF="#FileViews">
File Views</A>
<LI><A HREF="#CustomizingtheTTFONTSIZEJFileChooserFONTTT">
Customizing the <TT>JFileChooser</TT>
</A>
</UL>
<LI><A HREF="#TheTTFONTSIZEJColorChooserFONTTTFONTSIZEClassFONT">
The <TT>JColorChooser</TT> Class</A>
<UL>
<LI><A HREF="#UsingtheTTFONTSIZEJColorChooserFONTTTFONTSIZEDialogBoxFONT">
Using the <TT>JColorChooser</TT> Dialog Box</A>
<LI><A HREF="#UsingtheTTFONTSIZEJColorChooserFONTTTFONTSIZEasaComponentFONT">
Using the <TT>JColorChooser</TT> as a Component</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Using predefined system dialog boxes for choosing data in an application
allows for a consistent look-and-feel across all applications.
The current version of the JFC contains two such dialog boxes,
the <TT>JFileChooser</TT>, and the <TT>JColorChooser</TT>. 
<P>
In this chapter, you will learn how to
<UL>
<LI>Use the <TT>JFileChooser</TT> to select a file.
<LI>Add FileType filters to<U> </U>a<U> </U>JFileChooser.
<LI>Use the <TT>JColorChooser</TT> to select a color.
</UL>
<P>
There are many situations where a choice is required from the
user. These choices are often presented to the user in a dialog
box. The JFC contains a stock dialog box for choosing a file and
choosing a color. In the future, the set of stock chooser dialog
boxes will be expanded. There are pending versions of components
to choose a date, font, and money. There are also pending versions
of preview classes. These classes can preview an image, an audio
clip, or a file. Hopefully these classes will be supported in
the near future. This chapter provides details and examples of
using the stock dialog boxes.
<H2><A NAME="TheTTFONTSIZEJFileChooserFONTTTFONTSIZEClassFONT">
The <TT> JFileChooser</TT> Class</A></H2>
<P>
There are many situations where you will want to prompt the user
for a filename. The JFC provides a platform-independent <TT>JFileChooser</TT>
class to obtain file information. The class contains a control
to visually select a file. There is a convenient method to open
a modal dialog box containing a file chooser instance. With this
dialog box, your application can interact with the dialog box
by using the same API for any platform on which it is executing.
However, the appearance of the dialog box is dependent on the
current look-and-feel being used. The <TT>JFileChooser</TT> class
contains predefined modes for creating dialog boxes configured
in Save or Open modes. It can also be customized for other file
selection purposes.
<P>
To create an Open mode file choice dialog box, use the following
code fragment.
<BLOCKQUOTE>
<PRE>
JFileChooser fileChooser = new JFileChooser();
fileChooser.showOpenDialog( parentComponent );
</PRE>
</BLOCKQUOTE>
<P>
The code in this example displays the file dialog box shown in
Figure 19.1 for the Microsoft Windows look-and-feel. This is a
dialog box familiar to all users of the MS Windows operating system.
The same dialog box using the Java look-and-feel is shown in Figure
19.2. It is seen that the dialog boxes are basically the same
with different icons. The top of the dialog box allows the user
to choose drives and directories. There are buttons to move up
a directory, go to the user's home directory, or create a new
directory. The last two buttons allow a list or detailed view
to be selected. The center of the dialog box displays a list of
files and subdirectories contained in the current directory. The
bottom of the dialog box displays the currently selected file
and the current file filter.
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The astute reader will notice that the Open file chooser dialog boxes shown in Figures 19.1 and 19.2 have the Details button selected, but the files are shown in List mode. The current implementation of the <TT>JFileChooser</TT> class does not allow these buttons to be chosen, and the clicked button is incorrect. With any luck, this functionality will be added to a future release of the JFC.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<A HREF="javascript:popUp('f19-1.gif')"><B>Figure 19.1 :</B> <I>JFileChooser default Open mode options
MS Windows look-and-feel</I>.</A>
<P>
<A HREF="javascript:popUp('f19-2.gif')"><B>Figure 19.2 :</B> <I>JFileChooser default Open mode options Java look-and-feel</I>.</A>
<P>
The previous example uses default values for the initial path
displayed in the chooser. A string can be given in the JFileChooser's
constructor to specify the initial path that is displayed in the
dialog box. The setCurrentDirectory method can be used to set
the directory after the file chooser has been created. A file
reference can be passed to the setSelectedFile method to specify
the file initially selected in the file chooser component.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The text for the buttons in the file chooser is read from a resource bundle. This may result in the text on the buttons to appear differently than shown in the figures in this chapter if a non-English version of the JDK is being used.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Calling the <TT>showSaveDialog</TT> method instead of the <TT>showOpenDialog</TT>
method will display a Save mode file chooser. The next code demonstrates
this. Notice that the parent parameter in the <TT>showSaveDialog</TT>
method box can be <TT>null</TT>. In this case the dialog box is
centered on the display. A <TT>null</TT> parameter to the <TT>showOpenDialog</TT>
method behaves in the same way.
<P>
The resulting dialog box is shown in Figure 19.3. In the figure,
it is seen that the Save mode changes the title of the dialog
box and the top button's text to Save. The functionality of the
dialog box is identical to the Open mode dialog box.
<P>
<A HREF="javascript:popUp('f19-3.gif')"><B>Figure 19.3 :</B> <I>JFileChooser default Save mode options
MS Windows look-and-feel</I>.</A>
<BLOCKQUOTE>
<PRE>
JFileChooser fileChooser = new JFileChooser();
fileChooser.showSaveDialog( null );
</PRE>
</BLOCKQUOTE>
<P>
The file chooser dialog boxes you've seen display both files and
directories. The dialog box can be configured to display only
directories, files, or the default mode of both files and directories.
The <TT>setFileSelectionMode</TT> method takes a single integer
parameter to specify the mode. Possible values for the parameter
are the constants <TT>FILES_ONLY</TT>, <TT>DIRECTORIES_ONLY</TT>,
and <TT>FILES_AND_DIRECTORIES</TT> defined in the <TT>JFileChooser</TT>
class. The <TT>getFileSelectionMode</TT> returns the current mode
of the file chooser. The selection mode must be set before the
dialog box is displayed to be effective. Hidden files can be shown
or not shown in the file chooser. Passing <TT>true</TT> to the
<TT>setFileHidingEnabled</TT> method will cause the file view
to not show hidden files. The current state of this property may
be queried with the <TT>isFileHidingEnabled</TT> method. The default
value for this property is <TT>true</TT> to not display hidden
files. By default, the file chooser allows one file or directory
to be selected. Passing <TT>true</TT> to the <TT>setMultipleSelectionEnabled</TT>
method will enable more than one file or directory to be selected.
The current state of this property can be queried with the <TT>isMultipleSelectionEnabled</TT>
method.
<H3><A NAME="SpecifyingFileUUFilters">
Specifying File<U> </U>Filters</A></H3>
<P>
By default, the <TT>JFileChooser</TT> dialog box shows all the
files in the current directory. File filters can be added to the
current set of choices, or a new filter can be specified. A file
filter is defined in the <TT>FileFilter</TT> abstract class shown
next. Extensions of this class that are to be used as file filters
must provide implementation of the two methods defined in this
class. The first method, <TT>accept</TT>, returns <TT>true</TT>
or <TT>false</TT> depending on whether the given file matches
the filter criteria. The second method, <TT>getDescription</TT>,
returns the description of the file filter. This is used in the
file filter choice box in the file chooser dialog box. The <TT>FileFilter</TT>
class should not be a class, it should be an interface. This would
give developers more flexibility when creating file filters.
<BLOCKQUOTE>
<PRE>
public abstract class FileFilter { 
    /**
     * Whether the given file is accepted by this filter.
     */
    public abstract boolean accept(File f);

    /**
     * The description of this filter. For example: &quot;JPG and GIF Images&quot;
     * @see FileView#getName
     */
    public abstract String getDescription();
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>addChoosableFileFilter</TT> method adds the given file
filter to the current set of filters. This method can be called
repeatedly to add as many file filters as desired. The <TT>setFileFilter</TT>
method sets the current file filter for the dialog box. If the
<TT>setFileFilter</TT> method is called before any others are
added, the filter passed to the method replaces the default filter
that matches all files. If the <TT>setFileFilter</TT> method is
called after one or more filters have been added, the given filter
is set at the active filter in the dialog box. If the given filter
was not previously added, it is added during the <TT>setFileFilter</TT>
call. The default filter that matches all files is not removed
in this case. The <TT>removeChoosableFileFilter</TT> method can
be used to remove a filter from the dialog box. The current set
of file filters can be queried with the <TT>getChoosableFileFilters</TT>
method. The currently active file filter may be queried with the
<TT>getFileFilter</TT> method. If there are not any file filters
defined in the file chooser, the dialog box matches all files.
<P>
The following example demonstrates adding file filters to a <TT>JFileChooser</TT>
dialog box. The <TT>ExtensionFileFilter</TT> class matches files
whose extensions match one of the extensions registered with the
filter. The extension is registered with the <TT>addExtension</TT>
method and should not contain a '.' in the string passed to this
method. The file extension match is case insensitive. The <TT>ExtensionFileFilter</TT>
class extends the <TT>FileFilter</TT> abstract class so it can
be used with the <TT>JFileChooser</TT> class. In the example,
two <TT>ExtensionFileFilter</TT> instances are created and configured,
one for <TT>.java</TT> files, and the other matches both <TT>.html</TT>
and <TT>.htm</TT> files. The filters are added to the <TT>JFileChooser</TT>
instance before it is displayed. The filters will not be shown
in the dialog box if they are added after any of the <TT>showDialog</TT>
method variants are called. The resulting dialog box is shown
in Figure 19.4.
<P>
<A HREF="javascript:popUp('f19-4.gif')"><B>Figure 19.4 :</B> <I>File filters added to a JFileChooser dialog
box</I>.</A>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.io.File;
import java.util.Hashtable;

import javax.swing.*;
import javax.swing.filechooser.*;


/**
 * An application that displays a JFileChooser dialog box.
 *
 * @author Mike Foley
 **/
public class FileChooserTest extends Object { 

    
    /**
     * Application entry point.
     * Display a dialog box from the JOptionPane class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFileChooser filechooser = new JFileChooser();

        //
        // Create a filter for Java source files.
        //
        ExtensionFileFilter filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;java&quot; );
        filter.setDescription( &quot;Java Source Files&quot; );
        filechooser.addChoosableFileFilter( filter );
        
        //
        // Create a filter for HTML pages.
        // Match both .html and .htm
        //
        filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;html&quot; );
        filter.addExtension( &quot;htm&quot; );
        filter.setDescription( &quot;HTML Pages&quot; );
        filechooser.addChoosableFileFilter( filter );

        //
        // Select the HTML filter.
        //
        filechooser.setFileFilter( filter );
        
        filechooser.showSaveDialog( null );
        System.exit(0);
        
    }  // main

}  // FileChooserTest


/**
 * A file filter that matches file name extensions.
 * These is to be a filter like this in the standard
 * JFC classes, making this obsolete. This filter is
 * based on the ExampleFileFilter in the JDK1.2 example
 * programs.
 * 
 * @author Mike Foley
 **/
class ExtensionFileFilter extends FileFilter { 
    
    /**
     * The description for this file filter.
     **/
    private String description;
    
    /**
     * The extensions that match this filter.
     **/
    private Hashtable filters = null;

    /**
     * ExtensionFileFilter, default Constructor.
     **/
    public ExtensionFileFilter() { 
        filters = new Hashtable();
        setDescription( &quot;undefined&quot; );
    } 
    
    /**
     * Add the given extension to the list of extensions
     * to match. The extension should not have a '.' in
     * it.
     * &lt;p&gt;
* @param extension The extension to add to the list of mathing extensions.
     **/
    public void addExtension( String extension ) { 
         filters.put(extension.toLowerCase(), this);
    } 
    
    /**
     * @return The description of this file filter.
     **/
    public String getDescription() { 
        return( description );
    } 
    
    /**
     * Set the description of the filter. This
     * will be displayed in the file chooser's filter
     * selection box.
     * &lt;p&gt;
     * @param description The file filter's description.
     **/
    public void setDescription( String description ) { 
        this.description = description;
    } 

    /**
     * The file matches if its extension is contianed in our
     * filter hashtable.
     * &lt;p&gt;
     * @param f The File to test for matching the filter criteria.
     * @return True if the given File matches the filter criteria.
     *         False otherwise.
     **/
    public boolean accept(File f) { 
         if( f != null ) { 
             if( f.isDirectory() ) { 
                  return true;
             } 
             String extension = getExtension( f );
             if( extension != null &amp;&amp; filters.get( extension ) != null ) { 
                  return true;
             } 
         } 
         return false;
    } 
    
    /**
     * Determine the extension of the given File.
     * &lt;p&gt;
     * @param f The File whose extension is desired.
     * @return The extension of the given File, in lower case.
     **/
    protected String getExtension( File f ) { 
         if(f != null) { 
             String filename = f.getName();
             int i = filename.lastIndexOf( '.' );
             if(i&gt;0 &amp;&amp; i&lt;filename.length() - 1) { 
                  return filename.substring( i + 1 ).toLowerCase();
             } ;
         } 
         return null;
    } 
    
}
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>ExtensionFileFilter</TT> class shown in the previous example is based on the demonstration applications in the 1.2 JDK. Standard file filters should be included with JFC, making this class obsolete. Until that time, it can be used with the <TT>JFileChooser</TT> class.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="RetrievingtheSelectedFileorDirectory">
Retrieving the Selected File or Directory</A></H3>
<P>
Up to this point, you have seen how to display a file chooser
dialog box. If the file chooser is shown with any of the <TT>showDialog</TT>
methods contained in the <TT>JFileChooser</TT> class, the resulting
dialog box is modal. The <TT>showDialog</TT> method returns an
integer containing the action selected by the user. Possible return
values are the constants <TT>APPROVE_OPTION</TT> and <TT>CANCEL_OPTION</TT>,
defined in the <TT>JFileChooser</TT> class. <TT>APPROVE_OPTION</TT>
return type corresponds to the user choosing the button containing
Open or Save in one of the default configurations. <TT>CANCEL_OPTION</TT>
corresponds to the user choosing the Cancel button. When the file
chooser dialog box is closed by an operation other than choosing
one of the two buttons on the dialog box, the returned value is
<TT>-1</TT>. This is consistent with the dialog boxes in the <TT>JOptionPane</TT>
class seen in the previous chapter. 
<P>
If <TT>APPROVE_OPTION</TT> is returned from the dialog box, the
selected file or directory then needs to be queried from the file
chooser. The <TT>getCurrentDirectory</TT> method returns the directory
where the file chooser is displaying. The <TT>getSelectedFile</TT>
and <TT>getSelectedFiles</TT> methods return the files selected
in the chooser. When the file chooser is configured to display
both files and directories, the <TT>getSelectedFile</TT> method
returns <TT>null</TT> if a directory is selected or nothing is
selected. If the file selection mode is <TT>DIRECTORIES_ONLY</TT>,
the <TT>getSelectedFile</TT> method returns the selected directory.
<P>
The following example demonstrates typical usage of a file chooser
dialog box. The <TT>JFileChooser</TT> instance is created and
configured with the desired file filters. The appropriate <TT>showDialog</TT>
method is called to display the modal dialog box. In this example,
the <TT>showSaveDialog</TT> method is used to display a Save-type
dialog box. After the dialog box is closed, the returned value
is checked and acted upon. The <TT>JFileChooser</TT> class does
not actually save the file. It simply gives the user a component
to select a file. The <TT>ExtensionFileFilter</TT> class in this
example is identical to that presented in the last example.
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.io.File;
import java.util.Hashtable;

import javax.swing.*;
import javax.swing.filechooser.*;


/**
 * An application that displays a JFileChooser dialog box.
 *
 * @author Mike Foley
 **/
public class FileChooserTest extends Object { 

    
    /**
     * Application entry point.
     * Display a dialog box from the JOptionPane class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFileChooser filechooser = new JFileChooser();

        ExtensionFileFilter filter = new ExtensionFileFilter();
        filter.addExtension( &quot;java&quot; );
        filter.setDescription( &quot;Java Source Files&quot; );
        filechooser.addChoosableFileFilter( filter );
        
        filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;html&quot; );
        filter.addExtension( &quot;htm&quot; );
        filter.setDescription( &quot;HTML Pages&quot; );
        filechooser.addChoosableFileFilter( filter );
        filechooser.setFileFilter( filter );

        int selected = filechooser.showSaveDialog(null);

        switch( selected ) { 
            case JFileChooser.APPROVE_OPTION:
                File selectedFile = filechooser.getSelectedFile();
                File directory = filechooser.getCurrentDirectory();
                If( selectedFile != null ) { 
                    // Save the file.
                } 
                break;
            case JFileChooser.CANCEL_OPTION:
                break;
                
            default:
                // catches -1, the user closing the dialog without
                // hitting a button.
                break;            
        } 
        System.exit(0);
        
    }  // main

}  // FileChooserTest
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheAccessoryComponent">
The Accessory Component</A></H3>
<P>
The <TT>JFileChooser</TT> class provides methods to manage an
accessory component. When added to a file chooser instance, the
accessory component is displayed to the right of the file list.
The accessory component must be an extension of the <TT>JComponent</TT>
class and is set with the <TT>setAccessory</TT> method. The current
accessory component can be queried with the <TT>getAccessory</TT>
method.
<P>
The accessory component is often used to display a preview of
the currently selected file. However, this component can be used
for any purpose desired. Additionally, the accessory can be a
complex component containing many child components to create an
arbitrarily complex view.
<P>
The following example adds an image viewing accessory to a <TT>JFileChooser</TT>
instance. The <TT>ImagePreviewer</TT> class extends the <TT>JLabel</TT>
class and is used as an image viewer. The class listens for <TT>PropertyChangeEvents</TT>
from the file chooser with which it is associated. When the <TT>SELECTED_FILE_CHANGED_PROPERTY</TT>
changes, the newly selected file is loaded. If the file contains
an image, that image is set in the viewer. The image is then displayed
in the file chooser dialog box. The resulting file chooser dialog
box is shown in Figure 19.5.
<P>
<A HREF="javascript:popUp('f19-5.gif')"><B>Figure 19.5 :</B> <I>Image viewer accessory added to a JFileChooser
dialog box</I>.</A>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.io.File;
import java.util.Hashtable;
import java.beans.*;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.filechooser.*;


/**
 * An application that displays a JFileChooser dialog box.
 *
 * @author Mike Foley
 **/
public class FileChooserTest extends Object { 

    
    /**
     * Application entry point.
     * Display a dialog box from the JOptionPane class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        try { 
            UIManager.setLookAndFeel( &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
        }  catch( Exception ex ) { 
          System.err.println( &quot;Exception: &quot; + ex.getLocalizedMessage() );
        } 

        
        JFileChooser filechooser = new JFileChooser();

        ExtensionFileFilter filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;gif&quot; );
        filter.setDescription( &quot;GIF Images&quot; );
        filechooser.setFileFilter( filter );
        
        filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;jpeg&quot; );
        filter.setDescription( &quot;JPEG Images&quot; );
        filechooser.addChoosableFileFilter( filter );
        
        ImagePreviewer accessory = new ImagePreviewer( filechooser );
        accessory.setBorder( BorderFactory.createLoweredBevelBorder() );
        accessory.setPreferredSize( new Dimension( 200, 200 ) );
        filechooser.setAccessory( accessory );
        
        int selected = filechooser.showOpenDialog(null);
        switch( selected ) { 
            case JFileChooser.APPROVE_OPTION:
                File selectedFile = filechooser.getSelectedFile();
                File directory = filechooser.getCurrentDirectory();
                // Open the file
                break;
            case JFileChooser.CANCEL_OPTION:
                break;
                
            default:
                // Closed without hitting a button.
                break;            
        } 
        System.exit(0);
        
    }  // main

}  // FileChooserTest


/**
 * A class that gives a priview of gif or jpeg images.
 *
 * @author Mike Foley
 **/
class ImagePreviewer extends JLabel 
   implements PropertyChangeListener { 
             
    /**
     * ImagePreviewer, Constructor.
     * &lt;p&gt;
     * Register as a PropertyChangeListener to the
     * given JFileChooser instance. Center the icon
     * in our view area.
     * &lt;p&gt;
     * @param fileChooser The JFileChooser that we are previewing for.
     **/
    public ImagePreviewer( JFileChooser fileChooser ) { 
        if( fileChooser == null ) { 
            throw new IllegalArgumentException( 
                    &quot;fileChooser must be non-null&quot; );
        } 
        fileChooser.addPropertyChangeListener( this );
        setHorizontalAlignment( SwingConstants.CENTER );
        setVerticalAlignment( SwingConstants.CENTER );
    } 
         
    /**
     * The the image in the given file.
     * &lt;p&gt;
     * @param f The file to load the image from.
     **/
    public void loadImageFromFile( File file ) { 
        Icon icon = null;
        
        if( file != null ) { 
            ImageIcon filesIcon = 
                    new ImageIcon( file.getPath() );

            Dimension size = getSize();
            Insets insets = getInsets();
            if( insets != null ) { 
                size.width -= insets.right + insets.left;
                size.height -= insets.top + insets.bottom;
            } 

            //
            // Scale the image to our size.
            //
            if(filesIcon.getIconWidth() &gt; size.width ) { 
                
                icon = new ImageIcon(
                            filesIcon.getImage().getScaledInstance( size.
                                          width,
                            size.height, Image.SCALE_DEFAULT ) );
            }  else if(filesIcon.getIconWidth() &lt; size.width ) { 
                icon = new ImageIcon(
                            filesIcon.getImage().getScaledInstance( size.
                                          width,
                            size.height, Image.SCALE_DEFAULT ) );
            }  else { 
                icon = filesIcon;
            } 
        } 
        setIcon( icon );
   } 
         
/** 
     * propertyChange, from PropertyChangeListener
     * &lt;p&gt;
     * A property in the JFileChooser we are associated with
     * has changed. If it is the selected file property, try
     * to load the image in the file.
     * &lt;p&gt;
     * @param event The PropertyChangeEvent.
     **/
    public void propertyChange( PropertyChangeEvent event ) {     
        
        String propertyName = event.getPropertyName();
        if( propertyName.equals( JFileChooser.
    SELECTED_FILE_CHANGED_PROPERTY ) ) { 
            File file = ( File )event.getNewValue();
            if(isShowing()) { 
                loadImageFromFile( file );
                repaint();
            } 
        } 
    } 
              
}  // ImagePreviewer
</PRE>
</BLOCKQUOTE>
<H3><A NAME="FileViews">
File Views</A></H3>
<P>
Adding a file view instance to a file chooser allows custom file
user interface information to be displayed. The name, icon, and
description associated with a file can be specified. A file view
must be an extension of the abstract <TT>FileView</TT> class shown
next. As with the <TT>FileFilter</TT> class, developers would
have more options if the <TT>FileView</TT> class was an interface
and a default implementation that returned <TT>null</TT> from
each method was provided. This would allow developers to have
any class implement the interface, rather than being required
to inherit from the <TT>FileView</TT> class. The <TT>setFileView</TT>
method is used to set the file view class. Similarly, the <TT>getFileView</TT>
method returns the file view currently in use, or <TT>null</TT>
if a file view has not been set for the file chooser. There can
be only one user-specified file view for a file chooser. Thus
the <TT>FileView</TT> class must be able to handle all file types
for the file chooser.
<BLOCKQUOTE>
<PRE>
public abstract class FileView { 
    /**
     * The name of the file. Normally this would be simply f.getName()
     */
    public abstract String getName(File f);

    /**
     * A human readable description of the file. For example,
     * a file named jag.jpg might have a description that read:
     * &quot;A JPEG image file of James Gosling's face&quot;
     */
    public abstract String getDescription(File f);

    /**
     * A human readable description of the type of the file. For
     * example, a jpg file might have a type description of:
     * &quot;A JPEG Compressed Image File&quot;
     */
    public abstract String getTypeDescription(File f);

    /**
     * The icon that represents this file in the JFileChooser.
     */
    public abstract Icon getIcon(File f);

    /**
     * Whether the directory is traversable or not. This might be
     * useful, for example, if you want a directory to represent
     * a compound document and don't want the user to descend into it.
     */
    public abstract Boolean isTraversable(File f);

} 
</PRE>
</BLOCKQUOTE>
<P>
When a <TT>FileView</TT> extension is asked for a piece of information,
it can delegate to the system default data by returning <TT>null</TT>
from the query method. For example, if the <TT>getIcon</TT> method
in the <TT>FileView</TT> class returns <TT>null</TT>, the system
default icon will be used for the file or directory.
<P>
The <TT>JavaFileView</TT> class shown next when added to a <TT>JFileChooser</TT>
instance displays the familiar Java coffee cup icon for files
with the extension of <TT>.java</TT>. For methods that the class
returns data for, it tests the given file's extension. If it is
<TT>.java</TT>, the information for the Java source file is returned.
Otherwise, <TT>null</TT> is returned, allowing default processing
for the file or directory.
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.io.File;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.filechooser.FileView;


public class JavaFileView extends FileView { 
    
    /**
     * The icon for Java source files.
     **/
    Icon cupIcon = null;
    
        
    /**
     * Allow default processing.
     * &lt;p&gt;
     * @param file The file whose name is requested.
     * @return The name for the file.
     **/
    public String getName( File file ) { 
        return( null );
    } 
    
    
    /**
     * @param file The file whose description is requested.
     * @return The description for the given file.
     **/
    public String getDescription( File file ) { 
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            return( &quot;A Java source file&quot; );
        }  else { 
            return( null );
        } 
    } 


    /**
     * @param file The file whose type description is requested.
     * @return The type description for the given file.
     **/
    public String getTypeDescription( File file ) { 
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            return( &quot;Java source file&quot; );
        }  else { 
            return( null );
        } 
    } 


    /**
     * @param file The file whose icon is requested.
     * @return The icon for the given file.
     **/
    public Icon getIcon( File file ) { 
        Icon icon = null;
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            
            if( cupIcon == null )
                cupIcon = new ImageIcon( &quot;javacup.gif&quot; );
            
            icon = cupIcon;
        } 
        return( icon );
    } 


    /**
     * Allow default processing.
     * &lt;p&gt;
     * @param file The directory to test.
     * @return null to enable default processing.
     **/
    public Boolean isTraversable( File file ) { 
        return( null );
    } 

    /**
     * Determine the extension of the given file.
     * &lt;p&gt;
     * @param f The File whose extension is desired.
     * @return The extension of the given File, in lower case.
     **/
    protected String getExtension( File f ) { 
         if(f != null) { 
             String filename = f.getName();
             int i = filename.lastIndexOf( '.' );
             if(i&gt;0 &amp;&amp; i&lt;filename.length() - 1) { 
                  return filename.substring( i + 1 ).toLowerCase();
             } ;
         } 
         return null;
    } 

}  // JavaFileView
</PRE>
</BLOCKQUOTE>
<P>
The <TT>FileChooserTest</TT> application was modified as shown
next to use the <TT>JavaFileView</TT> class. The resulting dialog
box is shown in Figure 19.6.
<P>
<A HREF="javascript:popUp('f19-6.gif')"><B>Figure 19.6 :</B> <I>JavaFileView instance added to a JFileChooser
dialog box</I>.</A>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.io.File;

import javax.swing.*;
import javax.swing.filechooser.*;

import com.foley.utility.JavaFileView;


/**
 * An application that displays a JFileChooser dialog box
 * using a JavaFileView file view class.
 *
 * @author Mike Foley
 **/
public class FileChooserTest extends Object { 

    /**
     * Application entry point.
     * Display a JFileChooser class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        try { 
            UIManager.setLookAndFeel( &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot; );
        }  catch( Exception ex ) { 
            System.err.println( &quot;Exception: &quot; + ex.getLocalizedMessage() );
        } 

        
        JFileChooser filechooser = new JFileChooser();

        ExtensionFileFilter filter = new ExtensionFileFilter(); 
        filter.addExtension( &quot;java&quot; );
        filter.setDescription( &quot;Java Source Files&quot; );
        filechooser.addChoosableFileFilter( filter );
        filechooser.setFileFilter( filter );

        filechooser.setFileView( new JavaFileView() );
        
        int selected = filechooser.showOpenDialog(null);
        switch( selected ) { 
            case JFileChooser.APPROVE_OPTION:
                File selectedFile = filechooser.getSelectedFile();
                File directory = filechooser.getCurrentDirectory();
                break;
            case JFileChooser.CANCEL_OPTION:
                break;
                
            default:
                break;            
        } 
        System.exit(0);
        
    }  // main

}  // FileChooserTest
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CustomizingtheTTFONTSIZEJFileChooserFONTTT">
Customizing the <TT>JFileChooser</TT></A></H3>
<P>
The <TT>JFileChooser</TT> dialog box contains predefined configurations
for Save and Open modes. The dialog box can be used in other situations
when a file is required. The text, mnemonic, and ToolTip for the
Approve button can be queried and customized. The methods for
customizing the Approve button are shown in Table 19.1.<BR>
<P>
<CENTER><B>Table 19.1&nbsp;&nbsp;Approve Button Customization
Methods in the </B><TT><B>JFILECHOOSER</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><B>Property</B></CENTER></TD><TD WIDTH=211><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=211><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Mnemonic</TT></TD><TD WIDTH=211><TT>setApproveButtonMnemonic</TT>
</TD><TD WIDTH=211><TT>getApprovebuttonMnemonic</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Text</TT></TD><TD WIDTH=211><TT>setApproveButtonText</TT>
</TD><TD WIDTH=211><TT>getApproveButtonText</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ToolTip</TT></TD><TD WIDTH=211><TT>setApproveButtonToolTip</TT>
</TD><TD WIDTH=211><TT>getApproveButtonToolTip</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
Each of the string values shown in Table 19.1 is a bound property
of the <TT>JFileChooser</TT> class. Listeners will receive notification
when any of these properties are altered. The complete list of
bound properties defined in the <TT>JFileChooser</TT> class is
given in Table 19.2.<BR>
<P>
<CENTER><B>Table 19.2&nbsp;&nbsp;</B><TT><B>JFILECHOOSER</B></TT><B>
Class Bound Properties</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Property</B></CENTER></TD><TD WIDTH=197><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>SELECTED_FILE 
<BR>
CHANGED_PROPERTY</TT>
</TD><TD WIDTH=197><TT>setSelectedFile</TT></TD><TD WIDTH=197><TT>getSelectedFile</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>DIRECTORY_CHANGED <BR>
PROPERTY</TD><TD WIDTH=197><TT>setCurrentDirectory
</TD><TD WIDTH=197><TT>getCurrentDirectory</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>DIALOG_TYPE <BR>
CHANGED_PROPERTY</TD><TD WIDTH=197><TT>setDialogType
</TD><TD WIDTH=197><TT>getDialogType</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>APPROVE_BUTTON <BR>
TOOL_TIP_TEXT <BR>
CHANGED_PROPERTY
</TD><TD WIDTH=197><TT>setApproveButton <BR>
ToolTipText</TD><TD WIDTH=197><TT>getApproveButton <BR>
ToolTipText
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>APPROVE_BUTTON <BR>
MNEMONIC_CHANGED <BR>
PROPERTY
</TD><TD WIDTH=197><TT>setApproveButton <BR>
Mnemonic</TD><TD WIDTH=197><TT>getApproveButton <BR>
Mnemonic
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>APPROVE_BUTTON <BR>
TEXT_CHANGED <BR>
PROPERTY
</TD><TD WIDTH=197><TT>setApproveButtonText</TD><TD WIDTH=197><TT>getApproveButtonText
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>CHOOSABLE_FILE <BR>
FILTER_CHANGED <BR>
PROPERTY
</TD><TD WIDTH=197><TT>addChoosableFile <BR>
Filter/remove <BR>
ChoosableFileFilter
</TD><TD WIDTH=197><TT>resetChoosableFile <BR>
Filters/get <BR>
ChoosableFileFilters
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>ACCESSORY_CHANGED <BR>
PROPERTY</TD><TD WIDTH=197><TT>setAccessory
</TD><TD WIDTH=197><TT>getAccessory</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>FILE_SELECTION <BR>
MODE_CHANGED_PROP<BR>
ERTY
</TD><TD WIDTH=197><TT>setFileSelectionMode</TD><TD WIDTH=197><TT>getFileSelectionMode
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>MULTI_SELECTION <BR>
ENABLED_CHANGED <BR>
PROPERTY
</TD><TD WIDTH=197><TT>setMultiSelection Enabled</TD><TD WIDTH=197><TT>isMultiSelection Enabled
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>FILE_HIDING <BR>
CHANGED_PROPERTY</TD><TD WIDTH=197><TT>setFileHidingEnabled
</TD><TD WIDTH=197><TT>isFileHidingEnabled</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>FILE_FILTER <BR>
CHANGED_PROPERTY</TD><TD WIDTH=197><TT>setFileFilter
</TD><TD WIDTH=197><TT>getFileFilter</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>FILE_VIEW <BR>
CHANGED_PROPERTY</TD><TD WIDTH=197><TT>setFileView
</TD><TD WIDTH=197><TT>getFileView</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT><TT>FILE_SYSTEM_VIEW <BR>
CHANGED_PROPERTY</TT>
</TD><TD WIDTH=197><TT>setFileSystemView</TT></TD><TD WIDTH=197><TT>getFileSystemView</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The title of the customized dialog box can be specified using
the <TT>setDialogTitle</TT> method. The current title can be queried
with the <TT>getDialogTitle</TT> method. The type of the dialog
box can be queried using the <TT>getDialogType</TT> method. Possible
dialog types are <TT>OPEN_DIALOG</TT>, <TT>SAVE_DIALOG</TT>, and
<TT>CUSTOM_DIALOG</TT>. When the <TT>showOpenDialog</TT> or <TT>showSaveDialog</TT>
method is called, the type is set appropriately. If any of the
customization methods are called, the dialog is set to <TT>CUSTOM_DIALOG</TT>.
An existing <TT>JFileChooser</TT> instance can be reset to one
of the default configurations by using the <TT>setDialogType</TT>
method.
<P>
The <TT>CustomFileChooserTest</TT> application shown next displays
a custimized <TT>JFileChooser</TT> dialog box. Notice that the
<TT>showDialog</TT> method is called instead of the <TT>showOpenDialog</TT>
or <TT>showSaveDialog</TT> method. When the <TT>showDialog</TT>
method is called, the current settings for the Approve button
are used. Instead of calling in the <TT>setApproveButtonText</TT>,
the <TT>showDialog</TT> box can be passed the text for the Approve
button as its second parameter. In the example, <TT>null</TT>
is passed as the second parameter, telling the <TT>JFileChooser</TT>
class to use the current value of the Approve button text property.
As with the other <TT>show</TT> methods, the first parameter is
the parent component for the dialog box. The resulting dialog
box is shown in Figure 19.7.
<P>
<A HREF="javascript:popUp('f19-7.gif')"><B>Figure 19.7 :</B> <I>A customized JFileChooser dialog box</I>.</A>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.io.File;

import javax.swing.*;


/**
 * An application that displays a customized
 * JFileChooser dialog box.
 *
 * @author Mike Foley
 **/
public class CustomFileChooserTest extends Object { 

    /**
     * Application entry point.
     * Display a dialog box from the JOptionPane class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        
        JFileChooser filechooser = new JFileChooser();

        filechooser.setApproveButtonText( &quot;Attach&quot; );
        filechooser.setApproveButtonMnemonic( 'A' );
        filechooser.setApproveButtonTool
   TipText( &quot;Attach the selected file&quot; );
        filechooser.setDialogTitle( &quot;Attach File Selection&quot; );
        
        int selected = filechooser.showDialog( null, null );
        switch( selected ) { 
            case JFileChooser.APPROVE_OPTION:
                File selectedFile = filechooser.getSelectedFile();
                File directory = filechooser.getCurrentDirectory();
                break;
            case JFileChooser.CANCEL_OPTION:
                break;
                
            default:
                break;            
        } 
        System.exit(0);
        
    }  // main

}  // CustomFileChooserTest
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TheTTFONTSIZEJColorChooserFONTTTFONTSIZEClassFONT">
The <TT>JColorChooser</TT>
Class</A></H2>
<P>
The <TT>JColorChooser</TT> class provides a control that can be
used to visually select a color. The control can be used directly
like any of the other JFC visual components, but the class also
contains a convenient method that will display a color chooser
in a modal dialog box. A color chooser dialog box is easily displayed.
The following line of code will create and display a modal dialog
box containing a <TT>JColorChooser</TT> instance. The resulting
dialog box is shown in Figure 19.8. Three instances of the color
chooser dialog box are shown in the figure to allow both tabs
to be seen.
<P>
<A HREF="javascript:popUp('f19-8.gif')"><B>Figure 19.8 :</B> <I>Two JColorChooser dialog boxes</I>.</A>
<P>
<TT>JColorChooser.showDialog( null, &quot;Choose
A Color&quot;, Color.red );</TT>
<P>
The <TT>JColorChooser</TT> class specifies the color as an RGB
or HSB value. In the RGB color model three parameters define the
color: the red, green, and blue portions of the color. The &quot;Swatches&quot;
tab allows the user to select a color from a palette of existing
colors. The box of colors on the right of the panel contains the
most recently selected colors from the palette. The &quot;RGB&quot;
tab allows the user to specify the exact red, blue, and green
portions of the color via slider controls. <P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The text for the buttons in the color chooser is read from a resource bundle. This may result in the text on the buttons to appear differently than shown in the figures in this chapter if a non-English version of the JDK is being used.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
In the HSB color model the three parameters that define a color
are hue, saturation, and brightness. The hue varies between 0
and 360 degrees, while the saturation and brightness vary between
0 and 100 percent. The vertical slider in the color chooser varies
the parameter associated with the checked radio button. The range
of the slider depends on the color property being varied. The
color may also be selected by dragging the mouse in the color
region. As the mouse is dragged in this region, the HSB and RGB
values are updated.
<P>
Each panel contains a preview area where the current color in
the chooser is shown in a variety of conditions.
<H3><A NAME="UsingtheTTFONTSIZEJColorChooserFONTTTFONTSIZEDialogBoxFONT">
Using the <TT>JColorChooser</TT> Dialog Box</A></H3>
<P>
The static <TT>showDialog</TT> method contained in the <TT>JColorChooser</TT>
class creates and displays a modal dialog box used for selecting
a color. The <TT>ColorChooserTest</TT> application shown next
presents a simple application that demonstrates how this method
is used. Notice how the code that creates and displays the dialog
box is only one line of code. The resulting dialog box is shown
in Figure 19.8. Once again, the power of the stock JFC dialog
boxes is shown by this example. One line of code produces a very
powerful dialog box for obtaining any color that can be used in
Java.
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.Color;
import javax.swing.*;


/**
 * An application that displays a JColorChooser dialog box.
 *
 * @author Mike Foley
 **/
public class ColorChooserTest extends Object { 

    /**
     * Application entry point.
     * Display a dialog box from the JColorChooser class.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        Color selectedColor = JColorChooser.showDialog( null,
                                           &quot;Choose A Color&quot;, Color.red );
        if( selectedColor != null ) { 
            // selectedColor is the color the user specified.
        }  else { 
            // The user hit Cancel, or closed the dialog.
        } 
        System.exit(0);
    }  // main

}  // ColorChooserTest
</PRE>
</BLOCKQUOTE>
<P>
The first parameter to the <TT>showDialog</TT> method is the parent
component. If the parent is <TT>null</TT>, as in the <TT>ColorChooserTest</TT>
application, the dialog box is centered on the screen. The second
parameter is a string that will be used as the title of the dialog
box. The final parameter is the initial color in the dialog box.
Specifying <TT>null</TT> as the initial color will cause the dialog
to use <TT>Color.white</TT> as the initial color.
<P>
When the OK button is selected, the dialog box is hidden, and
the color defined in the <TT>JColorChooser</TT> is returned. If
the user clicks the Cancel button or dismisses the dialog box
by some other method, <TT>null</TT> is returned.
<P>
The Reset button is provided to allow the user the ability to
restore the initial color that was displayed in the dialog box
after making edits. The initial color is the color specified in
the <TT>showDialog</TT> method call.
<P>
The <TT>JColorChooser</TT> class views the data defined by the
<TT>ColorSelectionModel</TT> interface shown next. The interface
defines methods to set and query the selected color as well as
add and remove listeners. The <TT>ChangeListener</TT> is notified
whenever the <TT>Color</TT> instance in the model changes. The
current model being used by a color chooser can be queried with
the <TT>getSelectionModel</TT> method. Similarly, the model can
be set with the <TT>setSelectionModel</TT> method, or it can be
specified in the <TT>JColorChooser</TT> class' constructor.
<BLOCKQUOTE>
<PRE>
public interface ColorSelectionModel { 
    /**
     * @return  the model's selection.
     * @see     #setSelectedColor
     */
    Color getSelectedColor();

    /**
     * Sets the model's selected color to &lt;I&gt;color&lt;/I&gt;.
     *
     * Notifies any listeners if the model changes
     *
     * @see   #getSelectedColor
     * @see   #addChangeListener
     */
    void setSelectedColor(Color color);

    /**
     * Adds &lt;I&gt;listener&lt;/I&gt; as a listener to changes in the model.
     */
    void addChangeListener(ChangeListener listener);

    /**
     * Removes &lt;I&gt;listener&lt;/I&gt; as a listener to changes in the model.
     */
    void removeChangeListener(ChangeListener listener);
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="UsingtheTTFONTSIZEJColorChooserFONTTTFONTSIZEasaComponentFONT">
Using the <TT>JColorChooser</TT> as a Component</A></H3>
<P>
There are many situations where multiple colors need to be specified.
Opening a separate dialog box for each color may not be convenient.
One such example is a property sheet that allows multiple options
to be specified. A simple example of such a display is shown in
Figure 19.9. In this property sheet, the foreground and background
colors can be specified with the <TT>JColorChooser</TT>. The radio
buttons specify which color is being edited. A label is provided
to show the current color combination. The remainder of this section
will explore how the <TT>JColorChooser</TT> is used in this property
sheet, named <TT>ColorEditor</TT>.
<P>
<A HREF="javascript:popUp('f19-9.gif')"><B>Figure 19.9 :</B> <I>Foreground and background chooser</I>.</A>
<P>
The ColorEditor acts as a mediator between the components on the
panel. The three components are the radio group that specifies
which property is being edited (foreground or background), the
JLabel that shows the current color scheme, and the JColorChooser
that allows the current property to be edited.
<P>
The <TT>ColorEditor</TT> constructor presented in the <TT>ColorEditor</TT>
class's Listing 19.1 shows how the composite components and listeners
are created. First, an <TT>ActionListener</TT> named <TT>radioListener</TT>
is created. This is an anonymous inner class that will be added
to each of the two radio buttons. When an <TT>ActionEvent</TT>
is received, the listener determines which radio button was chosen.
Then the <TT>foreground</TT> attribute, which is used to specify
which property is being edited, is set. The color chooser is updated
to the current value of the new property. The <TT>setColor</TT>
method of <TT>JColorChooser</TT> is used for this purpose. This
method is overloaded. There are also versions taking the RGB color
definition. After this, the actual radio buttons and button group
are created. The <TT>ActionListener</TT> is added to each radio
button. The buttons are placed in a panel. This allows the border
to be set on the panel and have it surround both radio buttons.
<P>
The final component created is the <TT>JColorChooser</TT> itself.
This component is created with the current foreground color of
the Color Editor and placed into the center portion of the panel.
A <TT>ChangeListener</TT> is added to the color chooser's selection
model to receive notification when the selected color changes.
This allows the <TT>ColorEditor</TT> to fire a <TT>PropertyChangeEvent</TT>
to listeners of the Color Editor itself when the color changes.
The foreground color and background color are both bound properties
of the <TT>ColorEditor</TT> class. 
<P>
The <TT>ColorEditor</TT> also provides APIs that allow setting
which property is being edited and setting and querying each property.
See Listing 19.1 for these additional methods.
<P>
<HR>
<P>
<B>Listing 19.1&nbsp;&nbsp;The </B><TT><B>COLOREDITOR</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.*;
import java.awt.event.*;

import java.io.Serializable;

import java.beans.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.colorchooser.*;


/**
 * A panel that allows colors to be specified
 * for a foreground and background.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class ColorEditor extends JPanel
    implements Serializable { 

    /**
     * A radio button group for foreground, background
     * option.
     **/
    private ButtonGroup colorButtonGroup;
    private JRadioButton foregroundRadioButton;
    private JRadioButton backgroundRadioButton;

    /**
     * The color chooser.
     **/
    private JColorChooser colorChooser;

    /**
     * boolean used to decide which color is being changed.
     * true means foreground is being edited, false background.
     **/
    private boolean foregroundEditing = true;

    /**
     * Property change support.
     **/
    protected PropertyChangeSupport changeSupport = new PropertyChange
Support( this );

    /**
     * The current foreground and background Colors.
     **/
    private Color editForegroundColor;
    private Color editBackgroundColor;
    
    /**
     * This component contains two properties, foreground and
     * background color.
     **/
    public static final String EDITED_FOREGROUND_PROPERTY = &quot;ForegroundProperty&quot;;
    public static final String EDITED_BACKGROUND_PROPERTY = &quot;BackgroundProperty&quot;;

    /**
     * The default colors used in the editor.
     **/
    public static final Color DEFAULT_FOREGROUND_COLOR = Color.black;
    public static final Color DEFAULT_BACKGROUND_COLOR = Color.white;


    /**
     * ColorEditor, constructor.
     * &lt;p&gt;
     * Create a ColorEditor with the default foreground and
     * background colors.
     **/
    public ColorEditor() { 
        this( DEFAULT_FOREGROUND_COLOR, DEFAULT_BACKGROUND_COLOR );
    }  // ColorEditor


    /**
     * ColorEditor, constructor.
     * &lt;p&gt;
     * The ColorEditor may be thought of as a mediator between
     * the various components on the panel.  The radio buttons
     * choose which color is being edited.  Valid options are
     * foreground and background.  The JColorChooser allows visual
     * editing of these colors.
     * &lt;p&gt;
     * Create the components contained in the ColorEditor.
     * Create the listeners, and connect them to give the
     * component to component interactions.
     * &lt;p&gt;
     * @param foreground The initial foreground color for the editor.
     * @param background The initial background color for the editor.
     **/
    public ColorEditor( Color foreground, Color background ) { 

        super();

        //
        // If a color is null, use the default color.
        //
        if( foreground == null )
            foreground = DEFAULT_FOREGROUND_COLOR;
        if( background == null )
            background = DEFAULT_BACKGROUND_COLOR;
    
        this.editForegroundColor = foreground;
        this.editBackgroundColor = background;

        setLayout( new BorderLayout() );

        //
        // This action listener received messages when the radio
        // buttons change.  Set which property is being changed,
        // and update the color chooser to the current color
        // in that property.
        // A property change event doesn't need to be thrown here.
        // This only changes which property is being edited, not the
        // value of a property.
        //
        ActionListener radioListener = new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                if( event.getSource() == foregroundRadioButton ) { 
                    foregroundEditing = true;
                    colorChooser.setColor( editForegroundColor );
                }  else { 
                    foregroundEditing = false;
                    colorChooser.setColor( editBackgroundColor );
                } 
                colorChooser.repaint();
            } 
        } ;

        //
        // Create a radio button group containing
        // two buttons, foreground and background color.
        //
        colorButtonGroup = new ButtonGroup();
        foregroundRadioButton = new JRadioButton( &quot;Foreground&quot; );
        foregroundRadioButton.setSelected( true );
        backgroundRadioButton = new JRadioButton( &quot;Background&quot; );
        colorButtonGroup.add( foregroundRadioButton );
        colorButtonGroup.add( backgroundRadioButton );
        foregroundRadioButton.addActionListener( radioListener );
        backgroundRadioButton.addActionListener( radioListener );

        //
        // The options panel contains the radio buttons
        //
        JPanel options = new JPanel();
        options.setLayout( new BorderLayout() );

        //
        // Place the radio buttons.
        //
        JPanel buttons = new JPanel();
        buttons.setLayout( new BoxLayout( buttons, BoxLayout.Y_AXIS ) );
        buttons.add( foregroundRadioButton );
        buttons.add( backgroundRadioButton );
        options.add( BorderLayout.NORTH, buttons );
        buttons.setBorder( BorderFactory.createTitledBorder(
                            BorderFactory.createEtchedBorder(), &quot;Current Color&quot; ) );

        add( BorderLayout.WEST, buttons );

        //
        // Create the JColorChooser.
        //
        colorChooser = new JColorChooser( editForegroundColor );
        colorChooser.setBorder( BorderFactory.createLoweredBevelBorder
() );
        add( BorderLayout.CENTER, colorChooser );
        ColorSelectionModel model = colorChooser.getSelectionModel();
        model.addChangeListener( new ChangeListener() { 
            public void stateChanged( ChangeEvent e ) { 
                Color c = colorChooser.getColor();
                if( isEditingForeground() ) { 
                    setEditedForegoundColor( c );
                }  else { 
                    setEditedBackgoundColor( c );
                } 
            } 
        }  );
        
    }  // ColorEditor


    /**
     * @return The current value of the foreground color.
     **/
    public Color getEditedForegoundColor() { 
        return( editForegroundColor );
    } 


    /**
     * Provide an API to set the foreground color used in the editor.
     * If the foreground color is currently being edited, set the
     * value in the color chooser.  This will fire the property change
     * event, and the other components will update.
     * &lt;p&gt;
     * If the background is being edited, then set the color in the label.
     * The color chooser will update the next time foreground is edited.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param c The new foreground color.
     **/
    public void setEditedForegoundColor( Color c ) { 

        if( foregroundEditing ) { 
            colorChooser.setColor( c );
        }  
        Color old = editForegroundColor;
        editForegroundColor = c;
            changeSupport.firePropertyChange( EDITED_FOREGROUND_PROPERTY,
                                                   old,
                                                   c );

    }  // setEditedForegoundColor


    /**
     * @return The current value of the background color.
     **/
    public Color getEditedBackgoundColor() { 
        return( editBackgroundColor );
    } 


    /**
     * Privide an API to set the background color used in the editor.
     * If the background color is currently being edited, set the
     * value in the color chooser.  This will fire the property change
     * event, and the other components will update.
     * &lt;p&gt;
     * If the foreground is being edited, then set the color in the label.
     * The color chooser will update the next time background is edited.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param c The new background color.
     **/
    public void setEditedBackgoundColor( Color c ) { 

        if( !foregroundEditing ) { 
            colorChooser.setColor( c );
        }  
        Color old = editBackgroundColor;
        editBackgroundColor = c;
            changeSupport.firePropertyChange( EDITED_BACKGROUND_PROPERTY,
                                                   old,
                                                   c );

    }  // setEditedBackgoundColor


    /**
     * Set which property is being edited.  These are in a radio
     * button, so selecting or unselecting the foreground button
     * will do the opposite to the background button.
     * &lt;p&gt;
     * Changing the selected state of the button will cause the proper
     * events to be fired which will update this object's state.
     * &lt;p&gt;
     * @param editForeground The new selected state for the foreground.
     **/
    public void setEditingForeground( boolean editForeground ) { 
        foregroundRadioButton.setSelected( true );
    } 


    /**
     * Query which property is being edited.  Since there are
     * only two, this can be represented as a boolean.  The boolean
     * which was choosen is foreground radion button's selected state.
     * &lt;p&gt;
     * @return True if the foregound color is being edited. False is
       background.
     **/
    public boolean isEditingForeground() { 
        return( foregroundRadioButton.isSelected() );
    } 


    public static Action getShowAction() { 
        return( new ShowColorEditorAction() );
    } 


    /**
      * addPropertyChangeListener
      *
     * The specified PropertyChangeListeners &lt;b&gt;propertyChange&lt;/b&gt; method 
     * will be called each time the value of any bound property is changed.
     * The PropertyListener object is addded to a list of
PropertyChangeListeners
     * managed by this button, it can be removed with
removePropertyChangeListener.
      *
     * Note: the JavaBeans specification does not require
PropertyChangeListeners
     * to run in any particular order.
     *
     * @param l the PropertyChangeListener
     * @see #removePropertyChangeListener
      *
     **/
    public void addPropertyChangeListener( PropertyChangeListener l ) { 
          changeSupport.addPropertyChangeListener( l );
    }  // addPropertyChangeListener


    /**
      * removePropertyChangeListener
      *
     * Remove this PropertyChangeListener from the buttons internal list.
     * If the PropertyChangeListener isn't on the list, silently do nothing.
     *
     * @param l the PropertyChangeListener
     * @see #addPropertyChangeListener
      *
     **/
    public void removePropertyChangeListener( PropertyChangeListener l ) { 
          changeSupport.removePropertyChangeListener( l );
    }  // removePropertyChangeListener

}  // ColorEditor


/**
 * Class ShowColorEditorAction
 * &lt;p&gt;
 * An action which opens the ColorEditor dialog box.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
class ShowColorEditorAction extends AbstractAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Color Editor...&quot;;

    public ShowColorEditorAction() { 
        this( DEFAULT_NAME, null );
    }  // ShowColorEditorAction

    public ShowColorEditorAction( String name ) { 
        this( name, null );
    }  // ShowColorEditorAction

    public ShowColorEditorAction( String name, Icon icon ) { 
        super( name, icon );
    }  // ShowColorEditorAction


    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Perform the action.  Show the ColorEditor dialog box.
     * &lt;p&gt;
     * @param event The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 

        Frame parent = JOptionPane.getFrameForComponent( ( Component
)event.getSource() );
        JDialog dialog = new JDialog( parent );
        ColorEditor editor = new ColorEditor();
        dialog.getContentPane().add( BorderLayout.CENTER, editor );

        dialog.setModal( true );
        dialog.pack();
        dialog.setVisible( true );
        dialog.show();
    }  // actionPerformed

}  // ShowColorEditorAction
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>JColorChooser</TT> class also contains the <TT>getColor</TT>
method, which can be used to query the current color in the chooser.
This method is used to store the current value in the color chooser
when changing from foreground to background, and vice versa.
<H2><A NAME="Summary">Summary</A></H2>
<P>
Canned components that allow the user to make a choice from possible
values for a type are an important feature of any user interface
toolkit. These components ensure that the choice is valid and
provide a consistent look-and-feel between applications by using
the chooser components. The current release of the JFC contains
two such components: one for selecting files, and another for
selecting colors. This chapter demonstrated how to use these classes
in modal dialog boxes. This allows the application to receive
the value entered by the user as the returned value from the method
that displayed the dialog box. However, the chooser classes do
not have to be used in the convenient dialog boxes created by
the class. The components can be used to build displays in the
same manner as any other JFC component. An example of using the
<TT>JColorChooser</TT> class in a custom dialog box was presented.
<P>
In future releases of the JFC, the set of chooser components will
continue to grow. The pending package contains example chooser
components as well as preview components that should find their
way into the JFC in an upcoming release. Choosers for dates and
times, to name but a few, would be a welcome addition to the toolkit.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="ch18.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch20\ch20.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
