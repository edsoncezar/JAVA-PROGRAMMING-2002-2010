<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 34 - Drag and Drop </TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch33\ch33.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\apa\apa.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;34<br>
Drag and Drop</H1>
<HR>
<p>

<UL>
<LI><A HREF="#OverviewofJFCDragandDrop">
Overview of JFC Drag and Drop</A>
<UL>
<LI><A HREF="#TheBasicProtocol">
The Basic Protocol</A>
<LI><A HREF="#JFCDragandDropImplementation">
JFC Drag and Drop Implementation</A>
</UL>
<LI><A HREF="#ImplementingaDropTarget">
Implementing a Drop Target</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEDropTargetFONTTTFONTSIZEClassFONT">
The <TT>DropTarget</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEDropTargetContextFONTTTFONTSIZEClassFONT">
The <TT>DropTargetContext</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEDropTargetListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DropTargetListener</TT>
Interface</A>
<LI><A HREF="#TheTTFONTSIZEDropTargetEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetEvent</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEDropTargetDragEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetDragEvent</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEDropTargetDropEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetDropEvent</TT>
Class</A>
<LI><A HREF="#ExampleofaDropTarget">
Example of a Drop Target</A>
<LI><A HREF="#OverviewoftheTTFONTSIZEDropTargetDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>DropTargetDemo</TT>
Example</A>
</UL>
<LI><A HREF="#ImplementingaDragSource">
Implementing a Drag Source</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEDragSourceFONTTTFONTSIZEClassFONT">
The <TT>DragSource</TT> Class
</A>
<LI><A HREF="#TheTTFONTSIZEDragGestureListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DragGestureListener</TT>
Interface</A>
<LI><A HREF="#TheTTFONTSIZEDragGestureEventFONTTTFONTSIZEClassFONT">
The <TT>DragGestureEvent</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEDragSourceContextFONTTTFONTSIZEClassFONT">
The <TT>DragSourceContext</TT>
Class</A>
<LI><A HREF="#TheTTFONTSIZEDragSourceListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DragSourceListener</TT>
Interface</A>
<LI><A HREF="#ExampleofaDragSource">
Example of a Drag Source</A>
<LI><A HREF="#OverviewofTTFONTSIZEDndObjectsDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>DndObjectsDemo</TT>
Example</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
Drag and Drop is a user interface gesture that allows users to
request a data transfer between a source and a target. Drag and
Drop can be used within an application as well as between applications.
JFC provides a framework to support drag-and-drop gestures and
to facilitate data transfer.
<P>
In this chapter you will learn
<UL>
<LI>About drag sources and drop targets.<BR>
Drag sources and drop targets collaborate to facilitate drag-and-drop
operations.
<LI>How to implement a drag source<BR>
Drag sources initiate drag-and-drop operations and are capable
of transferring data to drop targets.
<LI>How to implement a drop target<BR>
One or more drop targets are required to complete the Drag and
Drop mechanism. Drop targets are consumers of transferable data.
<LI>How to transfer data from a drag source to a drop target<BR>
Data can be MIME-based content such as plain text or serialized
objects. The data transfer mechanism varies with different types
of content.
</UL>
<H2><A NAME="OverviewofJFCDragandDrop">
Overview of JFC Drag and Drop</A></H2>
<P>
A drag-and-drop operation involves a <I>drag
source</I> and multiple <I>drop targets</I>.
The drag source is capable of producing certain types of transferable
data, and the drop target is capable of consuming certain types
of transferable data. 
<P>
Since drag-and-drop operations are driven by user gestures, the
drag source and the drop target are normally associated with components.
For example, consider a user interface that allows the user to
drag text labels and drop them on list boxes. The text label components
would be drag sources and the list box components would be drop
targets.
<P>
<I>Source actions</I> and <I>drop actions</I> describe types of
operations on the content data. Examples of types of actions are
copy, move, and link.
<H3><A NAME="TheBasicProtocol">
The Basic Protocol</A></H3>
<P>
Drag-and-drop operations are a collaborative effort between a
drag source and multiple drop targets. The following sequence
illustrates the basic procedural protocol of a drag-and-drop operation:
<OL>
<LI>A drag source recognizes a user gesture (usually a click and
drag with the mouse) and initiates a drag operation.
<LI>Drag sources and drop targets are notified whenever the cursor
enters, exits, and moves over the target.
<LI>When notified of a drag enter event, the target can query
the drag source to determine the drag action (copy or move) and
the type of data associated with the drag operation and choose
whether to accept or reject the drag.
<LI>When the user releases the mouse with the cursor over a valid
drop target, the target is notified. The target must choose to
either accept or reject the drop operation.
<LI>If the target accepts the drop action, it initiates a data
transfer between the source and the target and then notifies the
system that the drop is complete.
</OL>
<P>
The operational protocol is actually a bit more complicated than
this procedure illustrates. For one, drag sources can provide
user interface feedback by changing cursors and drag images. Also,
drop actions can change in the middle of an operation when the
user presses or releases a key. 
<H3><A NAME="JFCDragandDropImplementation">
JFC Drag and Drop Implementation</A></H3>
<P>
JFC Drag and Drop operations involve two distinct mechanisms:
<UL>
<LI>The drag-and-drop mechanism
<LI>The data transfer mechanism
</UL>
<P>
The drag-and-drop mechanism consists of the GUI elements that
make up the user interface for the drag-and-drop operation as
well as the protocol that binds drag sources to drop targets.
The <TT>java.awt.dnd</TT> package provides support for the drag-and-drop
mechanism with classes for drag sources, drop targets, and various
events to support the basic drag-and-drop protocol. The <TT>java.awt.dnd</TT>
package is new with JDK 1.2.
<P>
The data transfer mechanism is based on the <TT>java.awt.datatransfer</TT>
package. This package includes support for clipboards, data flavors
based on MIME types, and transferable data. The <TT>java.awt.datatransfer</TT>
package first appeared in JDK 1.1.
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
In JDK 1.2, drag-and-drop is implemented by using peers and thus utilizes native platform drag-and-drop services. Drag-and-drop uses peers even when the drag source and drop target objects are owned by the same application.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H2><A NAME="ImplementingaDropTarget">
Implementing a Drop Target</A></H2>
<P>
To implement a component that is a drop target, you must 
<UL>
<LI>Implement a drop target listener (class <TT>DropTargetListener</TT>)
to handle drag-and-drop events.
<LI>Create a <TT>DropTarget</TT> object to manage drag-and-drop
operations.
</UL>
<P>
When you construct a <TT>DropTarget</TT> object, you associate
it with the component that you want to be a drop target and with
the component's drop target listener. You can do this by using
one of the <TT>DropTarget</TT> constructors or after construction
by using <TT>public</TT> instance methods.
<P>
The amount of overhead that you have to add to allow a component
to be a drop target is minimal. The following code fragment illustrates
this by showing what you need to add to a component to make it
a drop target.
<BLOCKQUOTE>
<PRE>
class DroppablePanel extends JPanel implements DropTargetListener { 
    // Constructor
    public DroppablePanel() { 
        super();

        // create a drop target for this component
        DropTarget dt = new DropTarget(this, this);
    } 

    // DropTargetListener interface implementation
    public void dragEnter(DropTargetDragEvent dtde) {  } 
    public void dragExit(DropTargetEvent dte) {  } 
    public void dragOver(DropTargetDragEvent dtde) {  } 
    public void drop(DropTargetDropEvent dtde) {  } 
    public void dropActionChanged(DropTargetDragEvent dtde) {  } 
} 
</PRE>
</BLOCKQUOTE>
<P>
What this fragment does is define a <TT>DroppablePanel</TT> component
that extends <TT>JPanel</TT> with a component that implements
the <TT>DropTargetListener</TT> interface. <TT>DroppablePanel</TT>
also instantiates a <TT>DropTarget</TT> object in the constructor.
Bear in mind that this code doesn't really do very much-you have
to add code to handle the various drop target events to make it
useful. 
<P>
Before getting into a working example, take a look at the classes
that are used by drop targets: <TT>DropTarget</TT>, <TT>DropTargetContext</TT>,
<TT>DropTargetListener</TT>, <TT>DropTargetEvent</TT>, <TT>DropTargetDragEvent</TT>,
and <TT>DropTargetDropEvent</TT>.
<H3><A NAME="TheTTFONTSIZEDropTargetFONTTTFONTSIZEClassFONT">
The <TT>DropTarget</TT> Class
</A></H3>
<P>
The <TT>DropTarget</TT> class represents a drop target. You must
construct a <TT>DropTarget</TT> object for each component that
you want to be a drop target.
<BLOCKQUOTE>
<PRE>
public class DropTarget extends Object 
                        implements DropTargetListener, Serializable 
{ 
  // Public constructors
    public DropTarget();
    public DropTarget(Component component, int actions, 
                      DropTargetListener listener);
    public DropTarget(Component component, int actions, 
                      DropTargetListener listener, boolean active);
    public DropTarget(Component component, DropTargetListener listener);
    public DropTarget(Component component, int actions, 
                      DropTargetListener listener, boolean active,
                      FlavorMap map)
  // Public instance methods
    public synchronized void addDropTargetListener(
           DropTargetListener listener);
    public void addNotify(ComponentPeer peer);
    public synchronized void dragEnter(DropTargetDragEvent event);
    public synchronized void dragExit(DropTargetEvent event);
    public synchronized void dragOver(DropTargetDragEvent event);
    public synchronized void drop(DropTargetDropEvent event);
    public void dropActionChanged(DropTargetDragEvent event);
    public synchronized Component getComponent();
    public synchronized int getDefaultActions();
    public DropTargetContext getDropTargetContext();
    public FlavorMap getFlavorMap();
    public synchronized boolean isActive();
    public synchronized void removeDropTargetListener(
           DropTargetListener listener);
    public void removeNotify(ComponentPeer peer);
    public synchronized void setActive(boolean active);
    public synchronized void setComponent(Component component);
    public synchronized void setDefaultActions(int actions);
    public void setFlavorMap(FlavorMap map)
} 
</PRE>
</BLOCKQUOTE>
<P>
In addition to a default constructor, <TT>DropTarget</TT> has
several constructors that allow you to associate the target with
a component and a drop target event listener. You can also specify
the default drop actions, the data flavors the target supports,
and whether the target is active or not. If you use the default
constructor to instantiate a <TT>DropTarget</TT>, you must use
the <TT>setComponent</TT> and <TT>addDropTargetListener</TT> methods
to associate a component and a drop target event listener with
the drop target.
<H3><A NAME="TheTTFONTSIZEDropTargetContextFONTTTFONTSIZEClassFONT">
The <TT>DropTargetContext</TT>
Class</A></H3>
<P>
The <TT>DropTargetContext</TT> class represents the context of
a drop target operation. JFC creates a drop target context whenever
a drag operation enters the area occupied by a drop target. 
<BLOCKQUOTE>
<PRE>
public class DropTargetContext extends Object 
{ 
  // Public instance methods
    public synchronized void addNotify(DropTargetContextPeer peer);
    public void dropComplete(boolean complete);
    public Component getComponent();
    public DropTarget getDropTarget();
    public synchronized void removeNotify();
} 
</PRE>
</BLOCKQUOTE>
<P>
There is no <TT>public</TT> constructor for the <TT>DropTargetContext</TT>
class. You can obtain a drop target context when processing a
drop target event by calling the event's <TT>getDropTargetContext</TT>
method as shown in the following code fragment.
<BLOCKQUOTE>
<PRE>
public void drop(DropTargetDropEvent dtde) { 
    // get drop target context
    DropTargetContext dtc = dtde.getDropTargetContext();

    .
    .
    .

} 
</PRE>
</BLOCKQUOTE>
<P>
The most important method in this class is <TT>dropComplete</TT>.
If you accept the drop operation while handling a <TT>drop</TT>
event, you must call <TT>dropComplete</TT> after you complete
the data transfer. The <TT>getComponent</TT> and <TT>getDropTarget</TT>
methods get the component and drop target object that are associated
with the drop target context.
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>DropTargetDropEvent</TT> class provides a <TT>dropComplete</TT> method that calls the drop target context's <TT>dropComplete</TT> method. You can implement a simple drop target without directly using the <TT>DropTargetContext</TT> class.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
There are a number of <TT>protected</TT> instance methods that
are not shown in the <TT>DropTargetContext</TT> class signature.
These methods are not normally used by applications and have been
omitted for clarity.
<H3><A NAME="TheTTFONTSIZEDropTargetListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DropTargetListener</TT>
Interface</A></H3>
<P>
The <TT>DropTargetListener</TT> interface represents the event
listener for drop target events. All drop targets must provide
an implementation for <TT>DropTargetListener</TT> to handle drop
target events.
<BLOCKQUOTE>
<PRE>
public abstract interface DropTargetListener extends Object 
                                             implements EventListener { 
  // Abstract public instance methods
    public abstract void dragEnter(DropTargetDragEvent event);
    public abstract void dragExit(DropTargetEvent event);
    public abstract void dragOver(DropTargetDragEvent event);
    public abstract void drop(DropTargetDropEvent event);
    public abstract void dropActionChanged(DropTargetDragEvent event);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>dragEnter</TT> and <TT>dragExit</TT> methods notify a
target when a drag operation enters and exits the area occupied
by their associated components. The <TT>dragOver</TT> method is
generated continually as the cursor is moved over the target.
<P>
The <TT>drop</TT> method notifies the target that the user has
dropped data on the target. The target should then either accept
or reject the drop operation by calling one of the <TT>DropTargetDragEvent</TT>
methods, <TT>acceptDrop</TT> or <TT>rejectDrop</TT>. If the target
accepts the drop, it must get the drop target context and call
<TT>dropComplete</TT> after successfully or unsuccessfully transferring
the drop data.
<P>
The <TT>dropActionChanged</TT> method notifies the target that
the user has pressed or released keys on the keyboard to change
the potential drop action.
<H3><A NAME="TheTTFONTSIZEDropTargetEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetEvent</TT>
Class</A></H3>
<P>
The <TT>DropTargetEvent</TT> class is the base class for the drop
target event classes <TT>DropTargetDragEvent</TT> and <TT>DropTargetDropEvent</TT>.
<BLOCKQUOTE>
<PRE>
public class DropTargetEvent extends EventObject 
{ 
  Public constructor
    public DropTargetEvent(DropTargetContext context);
  Public instance method
    public DropTargetContext getDropTargetContext();
} 
</PRE>
</BLOCKQUOTE>
<P>
The only method in the <TT>DropTargetEvent</TT> class is <TT>getDropTargetContext</TT>,
which retrieves the context for the drop target associated with
the event.
<H3><A NAME="TheTTFONTSIZEDropTargetDragEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetDragEvent</TT>
Class</A></H3>
<P>
The <TT>DropTargetDragEvent</TT> class represents a drag event
on a drop target. You can receive drop target drag events by implementing
the <TT>DropTargetListener</TT> interface.
<BLOCKQUOTE>
<PRE>
public class DropTargetDragEvent extends DropTargetEvent 
{ 
  // Public constructor
    public DropTargetDragEvent(DropTargetContext context, Point location,
                               int dropActions, int sourceActions);
  // Public instance methods
    public void acceptDrag(int action);
    public DataFlavor[] getCurrentDataFlavors();
    public List getCurrentDataFlavorsAsList();
    public int getDropAction();
    public Point getLocation();
    public int getSourceActions();
    public boolean isDataFlavorSupported(DataFlavor flavor);
    public void rejectDrag();
} 
</PRE>
</BLOCKQUOTE>
<P>
Although there is a public constructor for this class, you don't
normally need to construct objects of this type. The <TT>dragEnter</TT>,
<TT>dragOver</TT>, <TT>dragExit</TT>, and <TT>dropActionChanged</TT>
events in the <TT>DropTargetListener</TT> interface all have a
<TT>DropTargetDragEvent</TT> as a parameter.
<P>
When a target receives a <TT>dragEnter</TT> event, the target
should call the <TT>getDropAction</TT> and <TT>getCurrentDataFlavors</TT>
methods to determine the current drop action and the types of
data available. The target can then either accept or reject the
drag operation by calling <TT>acceptDrag</TT> or <TT>rejectDrag</TT>.
The <TT>getSourceActions</TT> method retrieves the types of drop
actions (copy, move, link) that the source is capable of supporting.
<H3><A NAME="TheTTFONTSIZEDropTargetDropEventFONTTTFONTSIZEClassFONT">
The <TT>DropTargetDropEvent</TT>
Class</A></H3>
<P>
The <TT>DropTargetDropEvent</TT> class represents a drop event
on a drop target. You can receive drop target drop events by implementing
the <TT>DropTargetListener</TT> interface.
<BLOCKQUOTE>
<PRE>
public class DropTargetDropEvent extends DropTargetEvent 
{ 
  // Public constructors
    public DropTargetDropEvent(DropTargetContext context, Point location,
                               int dropAction, int sourceActions);
    public DropTargetDropEvent(DropTargetContext context, Point location,
                               int dropAction, int sourceActions,
                               boolean isLocal);
  // Public instance methods
    public void acceptDrop(int action);
    public void dropComplete(boolean);
    public DataFlavor[] getCurrentDataFlavors();
    public List getCurrentDataFlavorsAsList();
    public int getDropAction();
    public Point getLocation();
    public int getSourceActions();
    public Transferable getTransferable();
    public boolean isDataFlavorSupported(DataFlavor flavor);
    public boolean isLocalTransfer();
    public void rejectDrop();
} 
</PRE>
</BLOCKQUOTE>
<P>
Although there are two <TT>public</TT> constructors for this class,
you don't normally need to construct objects of this type. When
data is dropped on a drop target, the target gets a <TT>drop</TT>
event that has a <TT>DropTargetDropEvent</TT> object as a parameter.
The target can use <TT>getDropAction</TT> and <TT>getCurrentDataFlavors</TT>
to determine the current drop action and the types of data available.
The target should then decide whether to accept or reject the
drop operation and call either the <TT>acceptDrop</TT> or <TT>rejectDrop</TT>
method. If the target accepts the drop, it should call <TT>dropComplete</TT>
after completing the data transfer.
<P>
The <TT>getLocation</TT> method returns the coordinates of the
cursor when the drop action occurred. The <TT>getTransferable</TT>
method gets a <TT>Transferable</TT> object that is capable of
transferring the dropped data. 
<H3><A NAME="ExampleofaDropTarget">
Example of a Drop Target</A></H3>
<P>
Listing 34.1 is the complete source for <TT>DropTargetDemo</TT>,
an application containing a drop target that displays information
about drag operations. Figure 34.1 illustrates the appearance
of <TT>DropTargetDemo</TT> when it's displaying information about
a drag operation.
<P>
<A HREF="javascript:popUp('f34-1.gif')"><B>Figure 34.1 :</B> <I>DropTargetDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 34.1&nbsp;&nbsp;</B><TT><B>DROPTARGETDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* DropTargetDemo.java
 *
 * An example of a drop target implementation.
 * Creates an application that displays information
 * about drag operations over the target area.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.dnd.*;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.DataFlavor;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

/* App class
 */
public class DropTargetDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // create app panel
        DropTargetDemoPanel panel = new DropTargetDemoPanel();

        // create a frame for app
        JFrame frame = new JFrame(&quot;DropTargetDemo&quot;);

        // add a window listener for window close events
        frame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // add app panel to content pane
        frame.getContentPane().add(panel);

        // set initial frame size and make visible
        frame.setSize (400, 300);
        frame.setVisible(true);
    } 
} 

/* App panel class
 */
class DropTargetDemoPanel extends JPanel { 
    // Constructor
    public DropTargetDemoPanel () { 

        // use border layout to cause text area to fill window
        setLayout(new BorderLayout());

        // wrap drop target text area in scroll pane and add to panel
        add(new JScrollPane(new DropTargetTextArea()));
    } 
} 

/* DropTargetTextArea class
 *
 * Extends JTextArea class by making the text area a drop target.
 * Whenever a drag operation enters the text area, it changes
 * background color and displays information about the drag.
 */
class DropTargetTextArea extends JTextArea
                         implements DropTargetListener { 
    // background colors for normal and under drag states
    private Color bkgNormal = Color.lightGray;
    private Color bkgUnderDrag = Color.yellow;

    // Constructor
    public DropTargetTextArea() { 
        super();

        // set up text area
        setBackground(bkgNormal);
        setEditable(false);
        setText(&quot;Drag objects over this window!&quot;);

        // create a drop target for this component
        DropTarget dt = new DropTarget(this, this);
    } 

    //
    // DropTargetListener interface implementation
    //
    public void dragEnter(DropTargetDragEvent dtde) { 
        // display information about the drag operation
        setText(dumpDragEventToString(dtde));

        // accept all drags
        dtde.acceptDrag(dtde.getSourceActions());

        // visually indicate that drop target is under drag
        showUnderDrag(true);
    } 

    public void dragExit(DropTargetEvent dte) { 
        showUnderDrag(false);
    } 

    public void dragOver(DropTargetDragEvent dtde) {  } 

    public void drop(DropTargetDropEvent dtde) { 
        // reject all drops in this demo
        dtde.rejectDrop();
        
        // need to indicate that drag operation is done
        showUnderDrag(false);
    } 

    public void dropActionChanged(DropTargetDragEvent dtde) { 
        // drop action has changed, update displayed
        // information about the drag operation
        setText(dumpDragEventToString(dtde));
    } 

    //
    // Private helper methods
    //

    // changes background to indicate that
    // component is under drag operation
    private void showUnderDrag(boolean underDrag) { 
        if(underDrag) setBackground(bkgUnderDrag);
        else setBackground(bkgNormal);

        paintImmediately(0, 0, getWidth(), getHeight());
    } 

    // dumps information about DropTargetDragEvent object to string
    private String dumpDragEventToString(DropTargetDragEvent dtde) { 
        DataFlavor[] flavors = dtde.getCurrentDataFlavors();
       
        String s = &quot;&quot;;
        s += &quot;MIME type(s):&quot;;
        for(int i = 0; i &lt; flavors.length; i++) { 
            s += (&quot;\ n  &quot; + flavors[i].getHumanPresentableName());
            s += (&quot;\ n    Primary type: &quot; + flavors[i].getPrimaryType());
            s += (&quot;\ n    Sub type: &quot; + flavors[i].getSubType());
            if (flavors[i].getPrimaryType().equals(&quot;text&quot;)) { 
                s += (&quot;\ n    Character set: &quot;
                      + flavors[i].getParameter(&quot;charset&quot;));
            } 
            s += (&quot;\ n    Representation class: &quot;
                  + flavors[i].getRepresentationClass().getName());
        } 
        s += (&quot;\ nSource actions: &quot;
              + dumpActionsToString(dtde.getSourceActions()));
        s += (&quot;\ nDrop actions: &quot;
              + dumpActionsToString(dtde.getDropAction()));
        return(s);
    } 

    // takes bit field specifying drag/drop actions and
    // returns string containing corresponding action verbs
    private String dumpActionsToString (int actions) { 
        String s = &quot;&quot;;
        if ((actions &amp; DnDConstants.ACTION_COPY) != 0)
            s += &quot;Copy &quot;;
        if ((actions &amp; DnDConstants.ACTION_MOVE) != 0)
            s += &quot;Move &quot;;
        if ((actions &amp; DnDConstants.ACTION_LINK) != 0)
            s += &quot;Link &quot;;

        return s;
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DropTargetDemo</TT> example does not accept any drop operations
or transfer any data-see &quot;Transferring Data Between the Drag
Source and Drop Target&quot; later in this chapter for details
on those topics.
<H3><A NAME="OverviewoftheTTFONTSIZEDropTargetDemoFONTTTFONTSIZEExampleFONT">
Overview of the <TT>DropTargetDemo</TT>
Example</A></H3>
<P>
<TT>DropTargetDemo</TT> consists of the following three classes:
<UL>
<LI><TT>DropTargetDemo</TT>&nbsp;&nbsp;The application class containing
the <TT>main</TT> entry point
<LI><TT>DropTargetDemoPanel</TT>&nbsp;&nbsp;A panel containing
the user interface for the application
<LI><TT>DropTargetTextArea</TT>&nbsp;&nbsp;An extension of <TT>JTextArea</TT>
modified to be a drop target
</UL>
<P>
All of the interesting code here is in the implementation of the
<TT>DropTargetTextArea</TT> class. The following sections discuss
how you extend the <TT>JTextArea</TT> class to be a drop target.
<H4>Creating a Drop Target Object</H4>
<P>
After setting up the text area to have a normal background and
to be noneditable, the <TT>DropTargetTextArea</TT> constructor
creates a <TT>DropTarget</TT> object for the component.
<P>
<TT>DropTarget dt = new DropTarget(this, this);</TT>
<P>
The arguments for the <TT>DropTarget</TT> constructor specify
the component that you want to be a drop target and a drop target
listener for drop target events. Because the <TT>DropTargetTextArea</TT>
class implements the <TT>DropTargetListener</TT> class, you can
specify this for both arguments.
<H4>Implementing the <TT>DropTargetListener</TT> Interface</H4>
<P>
The <TT>DropTargetListener</TT> interface consists of five methods:
<TT>dragEnter</TT>, <TT>dragExit</TT>, <TT>dragOver</TT>, <TT>drop</TT>,
and <TT>dropActionChanged</TT>. These methods notify the target
when the user performs drag-and-drop operations over the target
area.
<P>
The <TT>dragEnter</TT> method is called whenever a drag operation
enters the drop target area.
<BLOCKQUOTE>
<PRE>
public void dragEnter(DropTargetDragEvent dtde) { 
    // display information about the drag operation
    setText(dumpDragEventToString(dtde));

    // accept all drags
    dtde.acceptDrag(dtde.getSourceActions());

    // visually indicate that drop target is under drag
    showUnderDrag(true);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>DropTargetTextArea</TT> implementation for <TT>dragEnter</TT>
performs the following three operations:
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
A more functional drop target implementation would get the data flavor and source actions before determining whether to accept or reject the drag.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<UL>
<LI>Displays information about the drag event by calling <TT>setText</TT>
to display the string returned by the <TT>dumpDragEventToString</TT>
helper method
<LI>Calls <TT>DropTargetDragEvent.acceptDrag</TT> to accept the
drag operation
<LI>Calls the <TT>showUnderDrag</TT> helper method to visually
indicate (by changing the background color of the target component)
that the drop target is under a drag operation
</UL>
<P>
The <TT>dragExit</TT> method is called whenever a drag operation
exits the target area. 
<BLOCKQUOTE>
<PRE>
public void dragExit(DropTargetEvent dte) { 
    showUnderDrag(false);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>DropTargetTextArea</TT> implementation for <TT>dragExit</TT>
calls the <TT>showUnderDrag</TT> helper method with the <TT>underDrag</TT>
parameter set to <TT>false</TT> to change the background of the
target component back to its original color.
<P>
The <TT>drop</TT> method is called when the user releases the
mouse button during a drag operation over a drop target. The target
should respond by either accepting or rejecting the drop. 
<BLOCKQUOTE>
<PRE>
public void drop(DropTargetDropEvent dtde) { 
    // reject all drops in this demo
    dtde.rejectDrop();
        
    // need to indicate that drag operation is done
    showUnderDrag(false);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>DropTargetTextArea</TT> implementation for <TT>drop</TT>
calls <TT>DropTargetDropEvent.rejectDrop</TT> to reject all drop
operations. A fully functional drop target implementation would
get the available data flavors and drop action before deciding
whether to accept or reject the drop. Note that the <TT>drop</TT>
code also calls <TT>showUnderDrag</TT> to reset the background
color for the component-the <TT>dragExit</TT> method is not called
if a drop operation occurs.
<P>
The <TT>dropActionChanged</TT> method is called whenever the user
changes the drop action when a drag operation is over a target.
An example of changing the drop action would be pressing or releasing
the Alt key to toggle between a copy and a move operation. 
<BLOCKQUOTE>
<PRE>
public void dropActionChanged(DropTargetDragEvent dtde) { 
    // drop action has changed, update displayed
    // information about the drag operation
    setText(dumpDragEventToString(dtde));
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>DropTargetTextArea</TT> implementation of <TT>dropActionChanged</TT>
redisplays information about the drag event by calling <TT>setText</TT>
to display the string returned by the <TT>dumpDragEventToString</TT>
helper method.
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>DataFlavor</TT> class is in the <TT>java.awt.datatransfer</TT> package, not the java.awt.dnd package.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<H4>Getting Information About the Drag Event</H4>
<P>
The <TT>dumpDragEventToString</TT> method is a private helper
method that returns a string containing information about a given
<TT>DropTargetDragEvent</TT> object. The method first gets information
about the data flavors that are available from the source by calling
<TT>getCurrentDataFlavors</TT> on the <TT>DropTargetDragEvent</TT>
object. 
<P>
<TT>DataFlavor[] flavors = dtde.getCurrentDataFlavors();</TT>
<P>
After getting an array of <TT>DataFlavor</TT> objects, <TT>dumpDragEventToString</TT>
dumps information about the data flavors to a local string. It
then gets the source actions and current drop action and uses
a second private helper method, <TT>dumpActionsToString</TT>,
to concatenate information about the drop actions to the local
string before returning it to the caller.
<H2><A NAME="ImplementingaDragSource">
Implementing a Drag Source</A></H2>
<P>
To implement a component that is a drag source, you must do the
following:
<UL>
<LI>Implement a drag source listener (class <TT>DragSourceListener</TT>)
to handle drag source events.
<LI>Implement a drag gesture listener (class <TT>DragGestureListener</TT>)
to handle drag gesture events.
<LI>Provide an implementation for the <TT>Transferable</TT> interface
to handle the data transfer operation.
<LI>Create a <TT>DragSource</TT> object to manage drag-and-drop
operations.
<LI>Create a <TT>DragGestureRecognizer</TT> object to recognize
drag gestures.
</UL>
<P>
The following code fragment illustrates what you need to add to
a component to make it a drag source.
<BLOCKQUOTE>
<PRE>
class DraggableLabel extends JLabel implements DragSourceListener,
                                               DragGestureListener,
                                               Transferable { 
    // Constructor
    public DraggableLabel(String text) { 
        super(text);

        // create a drag source
        DragSource ds = DragSource.getDefaultDragSource();

        // create a drag gesture recognizer
DragGestureRecognizer dgr = ds.createDefaultDragGestureRecognizer(
            this,                               // component
            DnDConstants.ACTION_COPY_OR_MOVE,   // actions
            this);                              // drag gesture listener
    } 

    // DragGestureListener interface implementation
    public void dragGestureRecognized(DragGestureEvent event) { 
        // start drag operation
        event.startDrag(null,       // drag cursor
                        this,       // transferable object
                        this);      // drag source listener
    } 
    
    // Transferable interface implementation
    public Object getTransferData(DataFlavor flavor) { 
        // return object capable of transferring data
    } 

    public DataFlavor[] getTransferDataFlavors() { 
        // return data flavors supported by drag source
    } 

    public boolean isDataFlavorSupported(DataFlavor flavor) { 
        // return boolean indicating if drag source
        // supports the specified data flavor
    } 

    // DragSourceListener interface implementation
    public void dragDropEnd(DragSourceDropEvent dsde) {  } 
    public void dragEnter(DragSourceDragEvent dsde) {  } 
    public void dragExit(DragSourceEvent dse) {  } 
    public void dragOver(DragSourceDragEvent dsde) {  } 
    public void dropActionChanged(DragSourceDragEvent dsde) {  } 
} 
</PRE>
</BLOCKQUOTE>
<P>
What this fragment does is define a <TT>DraggableLabel</TT> component
that extends <TT>JLabel</TT> by implementing the <TT>DragSourceListener</TT>,
<TT>DragGestureListener</TT>, and <TT>Transferable</TT> interfaces.
It also creates <TT>DragSource</TT> and <TT>DragGestureRecognizer</TT>
objects in the constructor. Note that the <TT>dragGestureRecognized</TT>
method, a member of the <TT>DragGestureListener</TT> class, actually
begins the drag operation by calling <TT>DragGestureEvent.startDrag</TT>.
<P>
Remember that like the fragment presented earlier to illustrate
the structure of a drop target, this code doesn't really do very
much-you have to add some code to the methods to make it useful.
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
There are many similar methods implemented in multiple <TT>java.awt.dnd </TT>classes. In general, it's best to use methods on the objects that are closest in scope to the code you are writing. For example, both the <TT>DragSource </TT>and <TT>DragGestureEvent </TT>classes have a <TT>startDrag </TT>method. When a drag gesture listener's <TT>dragGestureRecognized </TT>method is called, you should call the <TT>startDrag </TT>method on the <TT>DragGestureEvent </TT>object passed to <TT>dragGestureRecognized</TT>, rather than getting the associated <TT>DragSource </TT>object and calling its <TT>startDrag </TT>method.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
Before getting into a complete working example, take a look at
the classes that are used by drop targets: <TT>DragSource</TT>,
<TT>DragGestureListener</TT>, <TT>DragGestureEvent</TT>, <TT>DragSourceContext</TT>,
and <TT>DragSourceListener</TT>.
<H3><A NAME="TheTTFONTSIZEDragSourceFONTTTFONTSIZEClassFONT">
The <TT>DragSource</TT> Class
</A></H3>
<P>
The <TT>DragSource</TT> class represents a source of drag-and-drop
operations. Each component that will be a source of drag-and-drop
operations requires a drag source object to manage drag-and-drop
operations.
<BLOCKQUOTE>
<PRE>
public class DragSource extends Object 
{ 
  // Public constants
    public static final Cursor DefaultCopyDrop;
    public static final Cursor DefaultMoveDrop;
    public static final Cursor DefaultLinkDrop;
    public static final Cursor DefaultCopyNoDrop;
    public static final Cursor DefaultMoveNoDrop;
    public static final Cursor DefaultLinkNoDrop;
  // Public constructors
    public DragSource();
  // Public class methods
    public static DragSource getDefaultDragSource();
    public static boolean isDragImageSupported();
  // Public instance methods
    public DragGestureRecognizer createDefaultDragGestureRecognizer(
        Component component, int actions, DragGestureListener dsl);
    public DragGestureRecognizer createDragGestureRecognizer(
        Class recognizerClass, Component component, int actions, 
        DragGestureListener dsl);
    public FlavorMap getFlavorMap();
    public void startDrag(DragGestureEvent trigger, Cursor dragCursor,
        Image dragImage, Point imageOffset, Transferable data, 
        DragSourceListener dsl);
    public void startDrag(DragGestureEvent trigger, Cursor dragCursor,
        Image dragImage, Point imageOffset, Transferable data, 
        DragSourceListener dsl, FlavorMap flavors);
    public void startDrag(DragGestureEvent trigger, Cursor dragCursor,
        Transferable data, DragSourceListener dsl);
    public void startDrag(DragGestureEvent trigger, Cursor dragCursor,
        Transferable data, DragSourceListener dsl, FlavorMap flavors);
} 
</PRE>
</BLOCKQUOTE>
<P>
Although there is a default constructor for <TT>DragSource</TT>,
the recommended way to get a drag source is by calling the static
class method <TT>getDefaultDragSource</TT>.
<P>
The only other <TT>DragSource</TT> method you'll need to use is
<TT>createDefaultDragGestureRecognizer</TT> to create a drag gesture
recognizer. The remaining methods exist mainly to support the
drag and drop infrastructure.
<H3><A NAME="TheTTFONTSIZEDragGestureListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DragGestureListener</TT>
Interface</A></H3>
<P>
The <TT>DragGestureListener</TT> interface represents a listener
for drag gesture events. Drag sources must provide a drag gesture
listener to determine when to start a drag operation.
<BLOCKQUOTE>
<PRE>
public abstract interface DragGestureListener extends Object
                                              implements EventListener { 
    public abstract void dragGestureRecognized(DragGestureEvent event);
} 
</PRE>
</BLOCKQUOTE>
<P>
When a drag gesture listener's <TT>dragGestureRecognized</TT>
event is called, the listener should start a drag operation by
calling the <TT>DragGestureEvent.startDrag</TT> method.
<H3><A NAME="TheTTFONTSIZEDragGestureEventFONTTTFONTSIZEClassFONT">
The <TT>DragGestureEvent</TT>
Class</A></H3>
<P>
The <TT>DragGestureEvent</TT> class represents a drag gesture
event.
<BLOCKQUOTE>
<PRE>
public class DragGestureEvent extends EventObject 
{ 
  // Constructor
    public DragGestureEvent(DragGestureRecognizer dsl, int actions,
                            Point origin, List events);
  // Public instance methods
    public Component getComponent();
    public int getDragAction();
    public Point getDragOrigin();
    public DragSource getDragSource();
    public DragGestureRecognizer getSourceAsDragGestureRecognizer();
    public InputEvent getTriggerEvent();
    public Iterator iterator();
    public void startDrag(Cursor dragCursor, Image dragImage, 
                          Point imageOffset, Transferable data, 
                          DragSourceListener dsl);
    public void startDrag(Cursor dragCursor, Transferable data, 
                          DragSourceListener dsl);
} 
</PRE>
</BLOCKQUOTE>
<P>
Although there is a constructor for <TT>DragGestureEvent</TT>,
applications don't normally create instances of this class. Drag
gesture events are sent to drag gesture listeners when the user
attempts to initiate a drag operation.
<P>
The <TT>DragGestureEvent</TT> class includes two <TT>startDrag</TT>
methods to start a drag-and-drop operation. Each method includes
parameters to specify a cursor to represent the drag operation,
a transferable data object, and a drag source listener. In addition,
one of the <TT>startDrag</TT> methods includes parameters to specify
an image to represent the data being dragged.
<H3><A NAME="TheTTFONTSIZEDragSourceContextFONTTTFONTSIZEClassFONT">
The <TT>DragSourceContext</TT>
Class</A></H3>
<P>
The <TT>DragSourceContext</TT> class represents the context of
a drag operation. JFC creates a drag source context when you start
a drag operation by calling the <TT>startDrag</TT> method in the
<TT>DragSource</TT> or <TT>DragGestureEvent</TT> classes. 
<BLOCKQUOTE>
<PRE>
public class DragSourceContext extends Object 
                               implements DragSourceListener 
{ 
  // Public constructor
    public DragSourceContext(DragSourceContextPeer peer, 
        DragGestureEvent trigger, Cursor dragCursor, Image dragImage,
        Point imageOffset, Transferable data, DragSourceListener dsl);
  // Public instance methods
    public synchronized void addDragSourceListener(
        DragSourceListener listener);
    public void cancelDrag();
    public synchronized void dragDropEnd(DragSourceDropEvent event);
    public synchronized void dragEnter(DragSourceDragEvent event);
    public synchronized void dragExit(DragSourceEvent event);
    public synchronized void dragOver(DragSourceDragEvent event);
public synchronized void dropActionChanged(
        DragSourceDragEvent event);
    public Component getComponent();
    public Cursor getCursor();
    public DragSource getDragSource();
    public int getSourceActions();
    public Transferable getTransferable();
    public DragGestureEvent getTrigger();
    public synchronized void removeDragSourceListener(
        DragSourceListener listener);
    public void setCursor(Cursor);
    public void transferablesFlavorsChanged();
} 
</PRE>
</BLOCKQUOTE>
<P>
Although there is a constructor for the <TT>DragSourceContext</TT>
class, applications don't normally create instances of this class.
You can obtain a drag source context when processing drag source
events by calling the event's <TT>getDragSourceContext</TT> method.
<H3><A NAME="TheTTFONTSIZEDragSourceListenerFONTTTFONTSIZEInterfaceFONT">
The <TT>DragSourceListener</TT>
Interface</A></H3>
<P>
The <TT>DragSourceListener</TT> interface represents a listener
for drag source events. Drag sources must provide an implementation
for this interface to handle drag source events.
<BLOCKQUOTE>
<PRE>
public abstract interface DragSourceListener extends Object 
                                             implements EventListener { 
    public abstract void dragDropEnd(DragSourceDropEvent event);
    public abstract void dragEnter(DragSourceDragEvent event);
    public abstract void dragExit(DragSourceEvent event);
    public abstract void dragOver(DragSourceDragEvent event);
    public abstract void dropActionChanged(DragSourceDragEvent event);
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>dragDropEnd</TT> method is called when a drag-and-drop
operation completes. <TT>dragEnter</TT> and <TT>dragExit</TT>
are called when a drag operation enters and exits the area occupied
by a drop target. The <TT>dragOver</TT> method is called as the
drag operation moves over a drop target. The <TT>dropActionChanged</TT>
method is called to notify the source that the user has changed
the drop action. An example of changing the drop action would
be pressing or releasing the Alt key to toggle between a copy
and a move operation. 
<H3><A NAME="ExampleofaDragSource">
Example of a Drag Source</A></H3>
<P>
Listing 34.2 is the complete source for <TT>DndObjectsDemo</TT>,
an application that provides a window containing several drag
sources and a separate window containing a drop target. Figure
34.2 illustrates the appearance of <TT>DndObjectsDemo</TT>.
<P>
<A HREF="javascript:popUp('f34-2.gif')"><B>Figure 34.2 :</B> <I>DndObjectsDemo example</I>.</A>
<P>
<HR>
<P>
<B>Listing 34.2&nbsp;&nbsp;</B><TT><B>DNDOBJECTSDEMO.JAVA
<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/* DndObjectsDemo.java
 *
 * Illustrates drag and drop of Java object 
 * between two frame windows in same Java VM.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.dnd.*;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.DataFlavor;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

/* App class
 */
public class DndObjectsDemo { 

    // Main entry point
    public static void main(String s[]) { 
        // create two frame windows
        JFrame sourceFrame = new JFrame(&quot;Drag Sources&quot;);
        JFrame targetFrame = new JFrame(&quot;Drop Target&quot;);

        // add window listeners for window close events
        sourceFrame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );
        targetFrame.addWindowListener(new WindowAdapter() { 
             public void windowClosing(WindowEvent e) { System.exit(0);} 
        } );

        // create panels for each window
        JPanel sourcePanel = new SourcePanel();
        JPanel targetPanel = new TargetPanel();
        
        // add panels to content panes
        sourceFrame.getContentPane().add(sourcePanel);
        targetFrame.getContentPane().add(targetPanel);

        // set initial frame size and make visible
        sourceFrame.setSize (300, 200);
        targetFrame.setSize (300, 200);
targetFrame.setLocation(sourceFrame.getX() 
                              + sourceFrame.getWidth(),
                                sourceFrame.getY());
        sourceFrame.setVisible(true);
        targetFrame.setVisible(true);
    } 
} 

/* App panel class for source window
 */
class SourcePanel extends JPanel { 
    // Constructor
    public SourcePanel() { 
        super();
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        // add some drag source components
        add(new DraggableLabel(&quot;Draggable Label 1&quot;));
        add(new DraggableLabel(&quot;Draggable Label 2&quot;));
        add(new DraggableLabel(&quot;Draggable Label 3&quot;));
        add(new DraggableLabel(&quot;Draggable Label 4&quot;));
        add(new DraggableLabel(&quot;Draggable Label 5&quot;));
    } 
} 

/* App panel class for target window
 */
class TargetPanel extends JPanel { 
    public TargetPanel() { 
        super();
        setLayout(new BorderLayout());

        // add a drop target component
        DroppablePanel dropPanel = new DroppablePanel();
        dropPanel.setLayout(new BoxLayout(dropPanel, BoxLayout.Y_AXIS));
        add(dropPanel);
    } 
} 

/* Drag source component implementation
 */
class DraggableLabel extends JLabel implements DragSourceListener,
                                               DragGestureListener,
                                               Transferable { 
    // Constructor
    public DraggableLabel(String text) { 
        super(text);

        // create a drag source
        DragSource ds = DragSource.getDefaultDragSource();
        
        // create a drag gesture recognizer
DragGestureRecognizer dgr = ds.createDefaultDragGestureRecognizer(
            this,                               // component
            DnDConstants.ACTION_COPY_OR_MOVE,   // actions
            this);                              // drag gesture listener
    } 

    // DragGestureListener interface implementation
    public void dragGestureRecognized(DragGestureEvent event) { 
        event.startDrag(null,       // drag cursor
                        this,       // transferable object
                        this);      // drag source listener
    } 
    
    // Transferable interface implementation
    public Object getTransferData(DataFlavor flavor) { 
        // if we support requested data flavor,
        // return this object as transfer data
        if(flavor.equals(MyFlavors.draggableLabelFlavor)) { 
            return(this);
        } 
        else return null;
    } 

    public DataFlavor[] getTransferDataFlavors() { 
        // return suppported data flavors
        DataFlavor[] flavors = {  MyFlavors.draggableLabelFlavor } ;
        return flavors;
    } 

    public boolean isDataFlavorSupported(DataFlavor flavor) { 
        if(flavor.equals(MyFlavors.draggableLabelFlavor))
            return true;
        else
            return false;
    } 

    // DragSourceListener interface implementation
    public void dragDropEnd(DragSourceDropEvent dsde) {  } 
    public void dragEnter(DragSourceDragEvent dsde) {  } 
    public void dragExit(DragSourceEvent dse) {  } 
    public void dragOver(DragSourceDragEvent dsde) {  } 
    public void dropActionChanged(DragSourceDragEvent dsde) {  } 
} 

/* Drop target component implementation
 */
class DroppablePanel extends JPanel implements DropTargetListener { 
    // background colors for normal and under drag states
    private Color bkgNormal = Color.lightGray;
    private Color bkgUnderDrag = Color.yellow;

    // Constructor
    public DroppablePanel() { 
        super();

        // create a drop target for this component
        DropTarget dt = new DropTarget(this, this);
    } 

    //
    // DropTargetListener interface implementation
    //
    public void dragEnter(DropTargetDragEvent dtde) { 
if(isValidDragDrop(dtde.getDropAction(), 
                           dtde.getCurrentDataFlavors())) { 
            // accept drag
            dtde.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);

            // change background color to visually indicate
            // that drop target is under drag
            showUnderDrag(true);
        } 
        else { 
            dtde.rejectDrag();
        } 
    } 

    public void dragExit(DropTargetEvent dte) { 
        // drop target no longer under drag, restore background color
        showUnderDrag(false);
    } 

    public void dragOver(DropTargetDragEvent dtde) {  } 

    public void drop(DropTargetDropEvent dtde) { 
        // validate drop action and data flavors
if(isValidDragDrop(dtde.getDropAction(),
                           dtde.getCurrentDataFlavors())) { 
            dtde.acceptDrop(dtde.getDropAction());

            try { 
                // get transfer data (DraggableLabel object)
                Transferable xfer = dtde.getTransferable();
Object obj = xfer.getTransferData(MyFlavors.draggableLabelFlavor);

                // add object to panel and revalidate
                if(obj instanceof JComponent) { 
                    add((JComponent)obj);
                    revalidate();
                } 
                // notify system that dnd completed successfully
                dtde.dropComplete(true);
            } 
            catch(Exception exc) { 
                System.err.println(exc);
                exc.printStackTrace();
                dtde.dropComplete(false);
            } 
            
        } 
        else { 
            // invalid drop action or data flavor, reject drop
            dtde.rejectDrop();
        } 
        
        // drop operation complete, restore background color
        showUnderDrag(false);
    } 

    public void dropActionChanged(DropTargetDragEvent dtde) {  } 

    //
    // Private helper methods
    //

    // validates given drop action and data flavor
private boolean isValidDragDrop(int dropAction,
                                    DataFlavor flavors []) { 
        if((dropAction &amp; DnDConstants.ACTION_COPY_OR_MOVE) != 0) { 
            for(int i=0; i&lt;flavors.length; i++) { 
                if(flavors[i].getPrimaryType().equals(&quot;application&quot;)
&amp;&amp; flavors[i].getSubType().equals(
                     &quot;x-java-serialized-object&quot;)) { 
                    return true;
                } 
            } 
        } 
        return false;
    } 

    // changes background color to indicate that
    // component is under drag operation
    private void showUnderDrag(boolean underDrag) { 
        if(underDrag) setBackground(bkgUnderDrag);
        else setBackground(bkgNormal);

        paintImmediately(0, 0, getWidth(), getHeight());
    } 
} 

/* Class containing predefined DataFlavor objects
 */
class MyFlavors extends Object { 
    static public DataFlavor draggableLabelFlavor
        = createFlavor(&quot;DraggableLabel&quot;, &quot;draggable Label object&quot;);

    // creates a DataFlavor object from
    // representation class name and description
    static private DataFlavor createFlavor(String className,
                                           String description) { 
        Class cls;
        // create class from class name
        try { 
            cls = Class.forName(className);
        } 
        catch(Exception exc) { 
            System.err.println(exc);
            cls = null;
        } 
        // create and return data flavor
        return new DataFlavor(cls, description);
    } 
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="OverviewofTTFONTSIZEDndObjectsDemoFONTTTFONTSIZEExampleFONT">
Overview of <TT>DndObjectsDemo</TT>
Example</A></H3>
<P>
<TT>DndObjectsDemo</TT> presents two windows. One window, titled
Drag Sources, contains some draggable <TT>JLabel</TT> objects.
The other window, titled Drop Target, contains a droppable <TT>JPanel</TT>.
When you drag-and-drop one of the <TT>JLabel</TT> objects to the
Drop Target window, the object is replicated and added to the
panel in the Drop Target window. Take a look at the code for this
example-you might be surprised at how easy it is to drag-and-drop
Java objects between JFC applications (or within a JFC application).
<TT>DndObjectsDemo</TT> contains six classes:
<UL>
<LI>The <TT>DndObjectsDemo</TT> class is the application class
containing the <TT>main</TT> entry point. 
<LI>The <TT>SourcePanel</TT> class provides a panel for the Drag
Sources window. The panel contains five <TT>DraggableLabel</TT>
objects.
<LI>The <TT>TargetPanel</TT> class provides a panel for the Drop
Target window. The panel contains a single <TT>DroppablePanel</TT>
object.
<LI>The <TT>DraggableLabel</TT> class extends <TT>JLabel</TT>
to be a drag source.
<LI>The <TT>DroppablePanel</TT> class extends <TT>JPanel</TT>
to be a drop target.
<LI>The <TT>MyFlavors</TT> class is a convenience class used to
define data flavors.
</UL>
<H4>Implementation of the Drag Source</H4>
<P>
The <TT>DraggableLabel</TT> class extends <TT>JLabel</TT> by implementing
the <TT>DragSourceListener</TT>, <TT>DragGestureListener</TT>,
and <TT>Transferable</TT> interfaces. Note that although a drag
source must provide implementations for these three interfaces,
they don't all necessarily have to be implemented in the same
class as they are in this example.
<P>
The <TT>DraggableLabel</TT> constructor gets the default platform
drag source by calling a static class method in the <TT>DragSource</TT>
class, <TT>getDefaultDragSource</TT>.
<BLOCKQUOTE>
<PRE>
// Constructor
public DraggableLabel(String text) { 
    super(text);

    // create a drag source
    DragSource ds = DragSource.getDefaultDragSource();
        
    // create a drag gesture recognizer
    DragGestureRecognizer dgr = ds.createDefaultDragGestureRecognizer(
        this,                               // component
        DnDConstants.ACTION_COPY_OR_MOVE,   // actions
        this);                              // drag gesture listener
} 
</PRE>
</BLOCKQUOTE>
<P>
The constructor then uses this drag source object to create a
drag gesture recognizer. The purpose of the drag gesture recognizer
is to detect when the user initiates a drag operation and notify
the drag source via its drag gesture listener.
<P>
The drag gesture listener consists of a single method, <TT>dragGestureRecognized</TT>.
<BLOCKQUOTE>
<PRE>
// DragGestureListener interface implementation
public void dragGestureRecognized(DragGestureEvent event) { 
    event.startDrag(null,       // drag cursor
                    this,       // transferable object
                    this);      // drag source listener
} 
</PRE>
</BLOCKQUOTE>
<P>
When the listener's <TT>dragGestureRecognized</TT> method is called,
the listener starts a drag operation by calling <TT>DragGestureEvent.startDrag</TT>.
<P>
The <TT>Transferable</TT> interface implementation includes three
methods: <TT>getTransferDataFlavors</TT>, <TT>isDataFlavorSupported</TT>,
and <TT>getTransferData</TT>. The <TT>getTransferDataFlavors</TT>
and <TT>isDataFlavorSupported</TT> methods make use of the <TT>draggableLabelFlavor</TT>
object defined in the <TT>MyFlavors</TT> convenience class. 
<BLOCKQUOTE>
<PRE>
public DataFlavor[] getTransferDataFlavors() { 
    // return supported data flavors
    DataFlavor[] flavors = {  MyFlavors.draggableLabelFlavor } ;
    return flavors;
} 

public boolean isDataFlavorSupported(DataFlavor flavor) { 
    if(flavor.equals(MyFlavors.draggableLabelFlavor))
        return true;
    else
        return false;
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>getTransferData</TT> method is where the actual data exchange
takes place. See the &quot;Transferring Data Between the Drag
Source and Drop Target&quot; section later in this chapter for
a complete discussion of how data is transferred from a drag source
to a drop target.
<P>
The remaining interface implementation, <TT>DragSourceListener</TT>,
consists of five methods: <TT>dragEnter</TT>, <TT>dragOver</TT>,
<TT>dragExit</TT>, <TT>dropActionChanged</TT>, and <TT>dragDropEnd</TT>.
You'll notice that all of these methods in the <TT>DndObjectsDemo</TT>
example are empty. Although you must provide an implementation
for <TT>DragSourceListener</TT>, none of the methods in this interface
are essential to the nuts and bolts of drag-and-drop.
<p>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Although the <TT>DndObjectsDemo</TT> example supports both copy and move actions, for rea- sons of simplicity both types of actions are implemented as copy operations. A good exer- cise would be to modify <TT>DndObjectsDemo</TT> to differentiate between copy and move oper- ations and behave appropriately.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<H4>Implementation of the Drop Target</H4>
<P>
The <TT>DroppablePanel</TT> class extends <TT>JPanel</TT> by implementing
the <TT>DropTargetListener</TT> class. Much of the implementation
is taken from the previous <TT>DropTargetDemo</TT> example. One
difference is that the <TT>DroppablePanel</TT> class in <TT>DndObjectsDemo</TT>
provides a complete implementation for the <TT>DropTargetListener.drop</TT>
method.
<BLOCKQUOTE>
<PRE>
public void drop(DropTargetDropEvent dtde) { 
    // validate drop action and data flavors
if(isValidDragDrop(dtde.getDropAction(),
                       dtde.getCurrentDataFlavors())) { 
        dtde.acceptDrop(dtde.getDropAction());

        try { 
            // get transfer data (DraggableLabel object)
            Transferable xfer = dtde.getTransferable();
Object obj = xfer.getTransferData(MyFlavors.draggableLabelFlavor);

            // add object to panel and revalidate
            if(obj instanceof JComponent) { 
                add((JComponent)obj);
                revalidate();
            } 
            // notify system that dnd completed successfully
            dtde.dropComplete(true);
        } 
        catch(Exception exc) { 
            System.err.println(exc);
            exc.printStackTrace();
            dtde.dropComplete(false);
        } 
    } 
    else { 
        // invalid drop action or data flavor, reject drop
        dtde.rejectDrop();
    } 
        
    // drop operation complete, restore background color
    showUnderDrag(false);
} 
</PRE>
</BLOCKQUOTE>
<P>
The first thing the <TT>drop</TT> method does is call a private
helper method, <TT>isValidDragDrop</TT>, to validate the given
drop action and available data flavors. 
<BLOCKQUOTE>
<PRE>
private boolean isValidDragDrop(int dropAction, DataFlavor flavors []) { 
    if((dropAction &amp; DnDConstants.ACTION_COPY_OR_MOVE) != 0) { 
        for(int i=0; i&lt;flavors.length; i++) { 
            if(flavors[i].getPrimaryType().equals(&quot;application&quot;)
&amp;&amp; flavors[i].getSubType().equals(
                 &quot;x-java-serialized-object&quot;)) { 
                return true;
            } 
        } 
    } 
    return false;
} 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>isValidDragDrop</TT> method verifies that the drop action
is a copy or move action and checks the primary type and the subtype
of the data flavor. Note that this implementation is written to
accept any data flavor that represents a Java class. You could
use the following code to validate only the <TT>draggableLabelFlavor</TT>
data flavor:
<BLOCKQUOTE>
<PRE>
if(flavors[i].equals(MyFlavors.draggableLabelFlavor)) { 
    return true;
} 
</PRE>
</BLOCKQUOTE>
<P>
If the drop action and data flavor are valid for the drop target,
the <TT>drop</TT> method calls <TT>DropTargetDropEvent.acceptDrop</TT>
to accept the drop operation. It then gets the transferable data
and, if the transferred object is a <TT>JComponent</TT>, it adds
the component to the panel and revalidates the layout. Finally,
the drop method completes the drop operation by calling <TT>DropTargetDropEvent.dropComplete</TT>.
The following section discusses the details of getting the transferable
data.
<H4>Transferring Data Between the Drag Source and Drop Target
</H4>
<P>
Transferring data is a cooperative effort between a drag source
and a drop target. In this example, the code required to transfer
data from the drag source is quite simple. The following is the
drag source's <TT>getTransferData</TT> method (from the <TT>Transferable</TT>
interface).
<BLOCKQUOTE>
<PRE>
public Object getTransferData(DataFlavor flavor) { 
    // if we support requested data flavor,
    // return this object as transfer data
    if(flavor.equals(MyFlavors.draggableLabelFlavor)) { 
        return(this);
    } 
    else return null;
} <BR>
</PRE>
</BLOCKQUOTE>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
To transfer types of data other than Java objects, you pass an instance of the representation class for the data type. For example, the representation class for transferring plain text is the <TT>InputStream</TT> class.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
Note that the drag source object simply returns itself as the
transfer data. The drag-and-drop system passes a serialized copy
of this object to the drop target.
<P>
Now take a look at the code the drop target uses to get the data.
Remember, this code is executed in the drop target listener's
<TT>drop</TT> method after the drop action and data flavor are
determined to be valid for the drop target.
<BLOCKQUOTE>
<PRE>
// get transfer data (DraggableLabel object)
Transferable xfer = dtde.getTransferable();
Object obj = xfer.getTransferData(MyFlavors.draggableLabelFlavor);

// add object to panel and revalidate
if(obj instanceof JComponent) { 
    add((JComponent)obj);
    revalidate();
} 
</PRE>
</BLOCKQUOTE>
<P>
The code first calls <TT>DropTargetDropEvent.getTransferable</TT>
to get a transferable object. It then calls the transferable object's
<TT>getTransferData</TT> method to get the data. In this example,
the object returned by <TT>getTransferData</TT> should be a Java
object (specifically, a <TT>DraggableLabel</TT> object). For most
other types of transferable data, <TT>getTransferData</TT> will
return an <TT>InputStream</TT> object capable of rendering the
data.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
JFC's Drag and Drop system is built on services provided by the
native platform running the Java VM that hosts Java applications.
This architecture allows you to drag-and-drop MIME-based content
within a single JFC application, between two JFC applications,
and between JFC applications and native applications. Drag-and-drop
is a cooperative effort between a drag source and a drop target.
Both the source and the target components must provide an implementation
for certain drag-and-drop interfaces and follow the basic drag-and-drop
protocol. This chapter gives two examples illustrating how to
implement Drag and Drop. The first example, <TT>DropTargetDemo</TT>,
implements a drop target that identifies drag sources when they
are moved over the target. The second example, <TT>DndObjectsDemo</TT>,
is a complete drag-and-drop implementation that allows Java objects
to be copied between two frame windows.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch33\ch33.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\apa\apa.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
