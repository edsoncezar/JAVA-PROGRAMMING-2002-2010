<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 24 - Building a Custom Component </TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch23\ch23.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch25\ch25.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;24<br>
Building a Custom Component</H1>
<HR>
<p>


<UL>
<LI><A HREF="#CreatingaCustomComponent">
Creating a Custom Component</A>
<UL>
<LI><A HREF="#ASwingCompatibleChartClass">
A Swing-Compatible Chart Class</A>
<LI><A HREF="#UsingtheTTFONTSIZEFChartFONTTTFONTSIZEClassFONT">
Using the <TT>FChart</TT>
Class</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
In the previous chapters, you learned how to customize existing
Swing components via setting user interface properties, replacing
the user interface object, and creating and installing a complete
look-and-feel. What you have not seen is how to handle the situation
when an existing Swing component doesn't meet your needs. 
<P>
In this chapter, you will learn
<UL>
<LI>How to create a custom component
<LI>How to implement the pluggable look-and-feel architecture
for your component
</UL>
<H2><A NAME="CreatingaCustomComponent">
Creating a Custom Component</A></H2>
<P>
There are many situations where an existing Swing component doesn't
meet your needs. When this situation arises, you have many options:
You can customize an existing Swing component; you can extend
an existing Swing component's user interface object; or you can
develop a new component. The previous chapters have discussed
customizing existing Swing components. The level of customization
ranges from setting UI properties to change the look of a component
to replacing the user interface object for a component to change
its feel. In this chapter, you will learn how to create a new
component.
<P>
When developing any Java class, one of the first decisions to
be made is where it fits into the existing class hierarchy. For
a new component that is to coexist with Swing components, it is
best that the component be a lightweight one. A new lightweight
component must extend the AWT <TT>Component</TT> or <TT>Container</TT>
class. However, as you saw in <A HREF="..\ch22\ch22.htm" >Chapter 22</A>, &quot;Extending Existing
Components,&quot; the <TT>JComponent</TT> class is the foundation
for the pluggable look-and-feel architecture on which the JFC
is built. If your new component is to have a pluggable look-and-feel,
it must be a descendant of the <TT>JComponent</TT> class. Where
the new component fits into the Swing hierarchy depends on the
nature of the component.
<P>
The other major architectural aspect of Swing components is the
MVC separation of views and data. When creating a new component,
the MVC architecture should be followed. This allows the new component
to share data with other components and fit with the core Swing
components. Thus, part of the design of a JFC-compliant component
is the data model the component will view. This was not a concern
when developing an AWT component. The model requirements for a
new component is dependent on the data to be displayed in the
view. However, if an existing Swing model can be used for the
new component, it will be more interoperable with other components.
The MVC architecture was discussed in <A HREF="..\ch02\ch02.htm" >Chapter 2</A> &quot;MVC Architecture.&quot;
<P>
The existing library of Swing components is text based. There
is a complete lack of graphical components. Many classes of graphical
components can be created by extending the <TT>JComponent</TT>
class and providing a custom <TT>paintComponent</TT> method to
render the graphics for the component. This type of component
tends to be very application/domain-specific and will not be addressed
in this chapter. However, a general-purpose graphical component
that is missing from the Swing component set is a chart component.
In this chapter, a general-purpose charting component that displays
numerical data contained in a <TT>TableModel</TT> will be developed.
<H3><A NAME="ASwingCompatibleChartClass">
A Swing-Compatible Chart Class</A></H3>
<P>
The Swing classes provide a rich set of textual components that
can be used to build a user interface. However, there are not
any graphical components. To help address this omission, the <TT>FChart</TT>
class was developed. This class displays the numerical data contained
in a <TT>TableModel</TT>. The first column in the model is defined
to be the x coordinate data, and each subsequent column specifies
the y coordinate for a single trace in the chart. The data in
the model must be a descendant of the <TT>Number</TT> class. When
an editable model is used with the <TT>FChart</TT> class, the
points in the plot can be dragged to change the model's data.
An example of the <TT>FChart</TT> class is shown in Figure 24.1.
<P>
<A HREF="javascript:popUp('f24-1.gif')"><B>Figure 24.1 :</B> <I>The Fchart component</I>.</A>
<P>
The <TT>FChart</TT> class supports the pluggable look-and-feel architecture on which the Swing components are built. A user interface implementation is provided for the Java and Windows look-and-feels, as well as a default implementation for other look-and-feel implementations. The component defines many user interface properties that an application can set to customize the component.
<H4><TT>FChart</TT> Data Model</H4>
<P>
When designing the <TT>FChart</TT> class, one of the first decisions
was what the data model should look like. If feasible, your component
will be adaptable to more situations if its data model can be
an existing JFC data model or an extension of an existing data
model. To meet this requirement for a chart left two options.
The data model could be an array of <TT>ListModel</TT> instances,
where each <TT>ListModel</TT> instance represents one trace in
the chart, or the model could be a <TT>TableModel</TT> instance.
Using an array of <TT>ListModel</TT> instances is more flexible
than using a <TT>TableModel</TT> instance. The <TT>ListModel</TT>
approach allows for traces of different lengths to easily be added
to the chart. However, this approach was not taken. The benefit
of using a <TT>TableModel</TT> was too great to pass up. This
approach allows a <TT>JTable</TT> instance to display the same
data as the chart. Changes to the data made in the table will
be reflected in the chart and vice versa.
<P>
<TT>TableModel</TT> allows the data to be written back to the
data model. The model defines the <TT>isCellEditable</TT> method
that returns <TT>true</TT> if a cell is editable. Using this method,
the <TT>FChart</TT> instance can determine if a data point is
editable and, if so, allows the user to drag the data point to
edit the data model.
<H4><TT>FChart</TT> Class</H4>
<P>
The <TT>FChart</TT> class is the component class that is instantiated
to create a chart. It extends the <TT>JComponent</TT> class and
works within the pluggable look-and-feel architecture on which
the core Swing components are built. This class provides the API
available to users of the component.
<P>
The <TT>FChart</TT> class, shown in Listing 24.1, manages two
axes: the x and the y axes. These are instances of the <TT>FAxis</TT>
class, which is described later in this section. A custom layout
manager, the <TT>FChartLayoutManager</TT> class, is used to size
and position the axes on the chart. This class will also be presented
later in this section.
<P>
The <TT>FChart</TT> class defines constants for its UI class and
for bound property names. The <TT>uiClassID</TT> contains the
name of the user interface class key to be used by the <TT>UIManager</TT>
to create the UI object for the chart. This process was described
in the previous chapter. This <TT>String</TT> is returned from
the <TT>getUIClassID</TT> method. The <TT>uiClassID</TT> constant
could be named anything, but the Swing class's convention is to
use this name. Using the same name in your classes allows developers
to easily identify the purpose of the constant.
<P>
The <TT>FChart</TT> contains two constructors: the default constructor
and one taking a <TT>TableModel</TT> parameter. The default constructor
is required to be JavaBean compliant and simply calls the second
constructor with a <TT>null</TT> <TT>TableModel</TT> parameter.
The second constructor is where the real work is performed. In
this constructor, the layout manager and axis are created and
set for the chart. The final method called in the constructor
is very important. The <TT>updateUI</TT> method updates its UI
by asking the <TT>UIManager</TT> to create the proper UI object
for the chart. If this method is not called in the constructor,
the UI object for the chart will not be created and the chart
will not be drawn.
<P>
The missing piece in implementing the pluggable look-and-feel
architecture is where the <TT>FChart</TT> UI object class keys
are registered with the <TT>UIManager</TT>. In the previous chapter,
you saw how the <TT>LookAndFeel</TT> implementations register
the class keys for the core Swing components. However, the JFC
look-and-feel implementations do not know about your custom components.
When the <TT>updateUI</TT> method asks the <TT>UIManager</TT>
to create its UI object by calling the <TT>getUI</TT> method,
if the key returned from the <TT>getUIClassID</TT> method is not
in the <TT>UIDefaults</TT> table, exceptions are thrown and your
component is not created. The <TT>FChart</TT> class provides a
<TT>static</TT> <TT>initialize</TT> method that registers the
class keys for the <TT>FChart</TT> and <TT>FAxis</TT> classes
with the <TT>UIManager</TT>. The process is further complicated
by the fact that the class keys need to be updated when the <TT>LookAndFeel</TT>
for the application changes. Once again, the keys for core Swing
components are registered by the new <TT>LookAndFeel</TT> when
it is activated. The <TT>FChart</TT> class's <TT>initialize</TT>
method creates and registers a <TT>PropertyChangeListener</TT>
to receive notifications from the <TT>UIManager</TT> when the
look-and-feel changes. At that time, the class keys can be updated
in the <TT>UIManager</TT>. In the <TT>FChart</TT> class, the keys
are registered in the <TT>setLookAndFeelProperties</TT> method.
This method checks for known look-and-feel class IDs and registers
the proper class. If the look-and-feel is not known, the default
UI object class is registered. The UI classes registered by <TT>setLookAndFeelProperties</TT>
are presented later in this chapter.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
When creating a library of custom components, having a single <TT>initialize</TT> method that registers the UI objects for each component in the library will reduce the burden on users of the library. Also, isolating the properties in a single location will ease the maintenance of the library.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<P>
The <TT>updateUI</TT>, <TT>getUI</TT>, <TT>setUI</TT>, and <TT>getUIClassID</TT>
methods are boilerplate methods required in a component to exist
in the pluggable look-and-feel architecture. The methods must
be implemented, rather than inherited, to provide methods taking
and returning the proper types. In the <TT>getUIClassID</TT> method's
case, the proper class ID <TT>String</TT> must be returned.
<P>
The <TT>writeObject</TT> method is required to conform to the
Swing serialization policy. Before a <TT>JComponent</TT> class
is written to the output stream, its UI object is temporarily
removed. The test of the <TT>uiClassID</TT> being equal to the
<TT>String</TT> returned from the <TT>getUIClassID</TT> method
must be performed in the class where the <TT>uiClassID</TT> constant
is defined. Thus, this method must be replicated in every class
that conforms to the pluggable look-and-feel architecture and
wants to be serialized.
<P>
The remaining methods in the <TT>FChart</TT> class are getter
and setter methods that follow the JavaBean naming convention
for manipulating the properties contained in the class. The setter
methods fire <TT>PropertyChangeEvent</TT>s for bound properties.
<P>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Note that the method and property names for the model and grid properties are the same as those defined in the <TT>JTable</TT> class. Using the same API as core Swing classes that convey the same meaning makes your class easier to learn for developers familiar with the Swing classes.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>

<HR>
<P>
<B>Listing 24.1&nbsp;&nbsp;The </B><TT><B>FCHART</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.chart;

import java.awt.*;
import java.beans.*;
import java.io.*;

import javax.swing.*;

import javax.swing.table.TableModel;


/**
 * Class FChart
 * A class that displays a chart containing
 * numerical data in a TableModel.
 * &lt;p&gt;
 * @beaninfo
 *      attribute: isContainer false
 *    description: A chart component
 * @author Mike Foley
 * @version 1.2
 **/
public class FChart extends JComponent
    implements Serializable { 

    /**
     * @see #getUIClassID
     **/
    private static final String uiClassID = &quot;FChartUI&quot;;

    /**
     * The X and Y Axis.
     **/
    private FAxis xAxis;
    private FAxis yAxis;

    /**
     * The color of the grid
     **/
    protected Color gridColor;

    /**
     * The table draws horizontal lines between cells 
     * if showHorizontalLines is true
     **/
    protected boolean showHorizontalLines;

    /**
     * The table draws vertical lines between cells if 
     * showVerticalLines is true
     **/
    protected boolean showVerticalLines;

    private TableModel model;

    /**
     * Bound property names.
     **/
    public static final String MODEL_PROPERTY = &quot;model&quot;;
    public static final String XAXIS_PROPERTY = &quot;XAxis&quot;;
    public static final String YAXIS_PROPERTY = &quot;YAxis&quot;;
    public static final String GRIDCOLOR_PROPERTY = &quot;GridColor&quot;;
    public static final String SHOWHORIZONTALLINES_PROPERTY = 
                  &quot;ShowHorizontalLines&quot;;
    public static final String SHOWVERTICALLINES_PROPERTY = 
                  &quot;ShowVerticalLines&quot;;


    /**
     * FChart, default constructor.
     **/
    public FChart() { 
        this( null );
    } 


    /**
     * FChart, constructor.
     * &lt;p&gt;
     * Create a chart viewing the given model.
* &lt;p&gt;
     * @param model The model for the chart to view.
     **/
    public FChart( TableModel model ) { 

        setLayout( new FChartLayoutManager() );
        setXAxis( new FAxis( SwingConstants.HORIZONTAL ) );
        setYAxis( new FAxis( SwingConstants.VERTICAL ) );
        setModel( model );

        updateUI();

    }  // FChart


    /**
     * Initialize this class with the UIManager.
     **/
    public static void initialize() { 

        setLookAndFeelProperties( UIManager.getLookAndFeel() );

        UIManager.addPropertyChangeListener( 
            new PropertyChangeListener() { 
            public void propertyChange( PropertyChangeEvent event ) { 
                if( &quot;lookAndFeel&quot;.equals( event.getPropertyName() ) ) { 
                    setLookAndFeelProperties( 
                 ( LookAndFeel )event.getNewValue() );
                } 
            } 
        }  );

    } 


    /**
     * Set the UI class properties for the given LookAndFeel class.
     *
     * @param lookAndFeel The look-and-feel to register ui classes for.
     **/
    public static void setLookAndFeelProperties( 
                 LookAndFeel lookAndFeel ) { 

        if( lookAndFeel == null )
            return;

        if( lookAndFeel.getID().equals( &quot;Metal&quot; ) ) { 
            //
            // Metal, or Metal-compliant look-and-feel
            //
            UIManager.put( &quot;FChartUI&quot;, &quot;com.foley.chart.MetalFChartUI&quot; );
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.MetalFAxisUI&quot; );
            UIManager.put( &quot;FChart.gridColor&quot;, 
                            new ColorUIResource( Color.lightGray ) );
        }  else if( lookAndFeel.getID().equals( &quot;Windows&quot; ) ) { 
            //
            // Windows, or Windows-compliant look-and-feel
            //
            UIManager.put(&quot;FChartUI&quot;, &quot;com.foley.chart.WindowsFChartUI&quot;);
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.WindowsFAxisUI&quot; );
            UIManager.put( &quot;FChart.gridColor&quot;, 
                            new ColorUIResource( Color.darkGray ) );
        }  else { 
            //
            // Unsupported look-and-feel, use default
            //
            UIManager.put( &quot;FChartUI&quot;, &quot;com.foley.chart.FChartUI&quot; );
            UIManager.put( &quot;FAxisUI&quot;, &quot;com.foley.chart.FAxisUI&quot; );
            UIManager.put( &quot;FChart.gridColor&quot;, 
                            new ColorUIResource( Color.lightGray ) );
         } 

    }  // setLookAndFeelProperties


    /**
     * Returns the L&amp;F object that renders this component.
     *
     * @return the FChartUI object that renders this component
     **/
    public FChartUI getUI() { 
        return( FChartUI )ui;
    } 


    /**
     * Sets the L&amp;F object that renders this component.
     *
     * @param ui  the FChartUI L&amp;F object
     * @see UIDefaults#getUI
     **/
    public void setUI( FChartUI ui ) { 
        super.setUI( ui );
    } 


    /**
     * Notification from the UIManager that the L&amp;F has changed.
     * Replaces the current UI object with the latest version from the
     * UIManager.
     *
     * @see JComponent#updateUI
     **/
    public void updateUI() { 
        setUI( ( FChartUI )UIManager.getUI( this ) );
        invalidate();
    } 


    /**
     * Returns the name of the L&amp;F class that
     * renders this component.
     *
     * @return &quot;FChartUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     **/
    public String getUIClassID() { 
        return uiClassID;
    } 


    /**
     * See readObject() and writeObject() in JComponent for more
     * information about serialization in Swing.
     * &lt;p&gt;
     * @exception IOException If the write can not be performed.
     **/
    private void writeObject( ObjectOutputStream s )
        throws IOException { 

        s.defaultWriteObject();
  if( ( ui != null ) &amp;&amp; ( getUIClassID().equals( uiClassID ) ) ) { 
              ui.installUI( this );
          } 
    } 


    /**
     * Set the X Axis for the chart.
     * This is a bound property.
     * &lt;p&gt;
     * @param xAxis the new X Axis for the chart.
     * @see #getXAxis
     * @beaninfo
     *       bound: true
     * description: The X Axis for the chart.
     **/
    public void setXAxis( FAxis xAxis ) { 

        FAxis old = this.xAxis;

        if( this.xAxis != null )
            remove( this.xAxis );
        this.xAxis = xAxis;
        if( this.xAxis != null ) { 
            add( xAxis );
            xAxis.setSize( xAxis.getPreferredSize() );
        } 
        firePropertyChange( XAXIS_PROPERTY, old, xAxis );

    } 


    /**
     * @return The current X Axis for the chart.
     * @see #setXAxis
     **/
    public FAxis getXAxis() { 
        return( this.xAxis );
    } 


    /**
     * Set the Y Axis for the chart.
     * This is a bound property.
     * &lt;p&gt;
     * @param yAxis the new Y Axis for the chart.
     * @see #getYAxis
     * @beaninfo
     *       bound: true
     * description: The Y Axis for the chart.
     **/
    public void setYAxis( FAxis yAxis ) { 
        if( this.yAxis != null )
            remove( this.yAxis );
        this.yAxis = yAxis;
        if( this.yAxis != null ) { 
            add( yAxis );
            yAxis.setSize( yAxis.getPreferredSize() );
        } 
    } 


    /**
     * @return The current Y Axis for the chart.
     * @see #setYAxis
     **/
    public FAxis getYAxis() { 
        return( this.yAxis );
    } 


    /**
     * Set the model that the chart views.
     * The first column in the model specifies X
     * coordinate values. The remaining columns
     * specify y coordinates for each trace. This
     * implies that a model with four columns has
     * three traces in the chart.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param model The new TableModel for the chart.
     * @see #getModel
     * @beaninfo
     *       bound: true
     * description: The data the chart contains.
     **/
    public void setModel( TableModel model ) { 
        TableModel old = this.model;
        this.model = model;
        firePropertyChange( MODEL_PROPERTY, old, model );
    } 


    /**
     * @return The current data model for the chart.
     * @see #setModel
     **/
    public TableModel getModel() { 
        return( this.model );
    } 


    /**
     * Sets the color used to draw grid lines to &lt;I&gt;color&lt;/I&gt; and 
     * redisplays the receiver. The default color is gray.
     *
     * @param gridColor The Color of the grid
     * @exception IllegalArgumentException if &lt;I&gt;color&lt;/I&gt; is null
     * @see #getGridColor()
     * @beaninfo
     *       bound: true
     * description: The color for the grid in the chart.
     **/
    public void setGridColor( Color gridColor ) { 
        if( gridColor == null ) { 
            throw new IllegalArgumentException( 
                &quot;The grid color may not be null.&quot; );
        } 
        Color old = this.gridColor;
        this.gridColor = gridColor;

        firePropertyChange( GRIDCOLOR_PROPERTY, old, gridColor );

        repaint();

    }  // setGridColor


    /**
     * Returns the color used to draw grid lines.
     * The default color is look-and-feel dependant.
     * &lt;p&gt;
     * @return  the color used to draw grid lines
     * @see     #setGridColor()
     **/
    public Color getGridColor() { 
        return gridColor;
    } 


    /**
     * If true, the chart displays grid lines corresponding
     * to the major tick marks on the axis.
     * &lt;p&gt;
     * This is not a bound property. Instead the two component
     * lines are bound. I.e. horizontal lines and vertical lines
     * are bound properties.
     * &lt;p&gt;
     * @param showGrid If true draw grid lines, if false don't.
     * @see #setShowHorizontalLines
     * @see #setShowVerticalLines
     * @beaninfo
     *       bound: false
     * description: True to draw grid lines in the chart.
     **/
    public void setShowGrid( boolean showGrid ) { 
setShowHorizontalLines( showGrid );
        setShowVerticalLines( showGrid );

        repaint();
    } 


    /**
     * If true, draw horizontal lines on the chart that correspond
     * to the Y axis major tick marks.
     *
     * @param showHorizontalLines If chart should draw horizontal lines.
     * @see #getShowHorizontalLines
     * @see #setShowGrid
     * @see #setShowVerticalLines
     * @beaninfo
     *       bound: true
     * description: If horizontal lines should be drawn on the chart.
     **/
    public void setShowHorizontalLines( boolean showHorizontalLines ) { 

        boolean old = this.showHorizontalLines;
        this.showHorizontalLines = showHorizontalLines;

        firePropertyChange( SHOWHORIZONTALLINES_PROPERTY, old, 
                      showHorizontalLines );

        repaint();
    } 


    /**
     * Returns true if the chart draws horizontal lines on
     * the chart, and false if it doesn't.
     * &lt;p&gt;
     * @return true if the chart draws horizontal lines, false otherwise
     * @see #setShowHorizontalLines
     **/
    public boolean isShowHorizontalLines() { 
        return( showHorizontalLines );
    } 


    /**
     * Sets whether the chart draws vertical lines that correspond
     * to the major ticks on the X axis.
     * &lt;p&gt;
     * @param showVerticalLines If the chart should draw vertical lines.
     * @see #getShowVerticalLines
     * @see #setShowGrid
     * @see #setShowHorizontalLines
     * @beaninfo
     * description: If vertical lines should be drawn on the chart.
     **/
    public void setShowVerticalLines( boolean showVerticalLines ) { 
        boolean old = this.showVerticalLines;
        this.showVerticalLines = showVerticalLines;

        firePropertyChange( SHOWVERTICALLINES_PROPERTY, old, 
                      showVerticalLines );

        repaint();
    } 


    /**
     * Returns true if the chart draws vertical lines on
     * the chart, and false if it doesn't.
     * &lt;p&gt;
     * @return true if the chart draws vertical lines, false otherwise
     * @see #setShowVerticalLines
     **/
    public boolean isShowVerticalLines() { 
        return( showVerticalLines );
    } 

    public Color getTraceColor( int trace ) { 
        Color[] color = new Color[4];
        color[0] = java.awt.Color.yellow;
        color[1] = java.awt.Color.blue;
        color[2] = java.awt.Color.red;
        color[3] = java.awt.Color.black;
        return( color[ trace ] );
    } 

}  // FChart
</PRE>
</BLOCKQUOTE>
<HR>
<H4><TT>FAxis</TT> Class</H4>
<P>
An instance of the <TT>FAxis</TT> class is used for the both the
x and y axes contained in an <TT>FChart</TT> instance. The <TT>orientation</TT>
property of the class specifies whether the axis should be rendered
vertically or horizontally. The class uses a bounded range model
to manage its minimum and maximum values. The current value in
the model is not used by this class.
<P>
Like the <TT>FChart</TT> class, the <TT>FAxis</TT> class extends
the <TT>JComponent</TT> class and implements the methods required
to exist in the JFC pluggable look-and-feel architecture. The
<TT>FAxis</TT> class keys are registered in the <TT>static</TT>
<TT>initialize</TT> method contained in the <TT>FChart</TT> class.
<P>
The <TT>FAxis</TT> class's API is very similar to the <TT>JSlider</TT>
class. Just as in the <TT>JSlider</TT> class, a label dictionary
is used to specify the labels for the axis. If the user does not
provide a dictionary, the class creates one. The major and minor
tick properties are the same in these two classes. The <TT>FAxis</TT>
class contains convenience methods for setting the minimum and
maximum values in its model. Once again, the technique of using
as many familiar property and API names makes the <TT>FAxis</TT>
class very recognizable to developers familiar with the <TT>JSlider</TT>
class.
<P>
The complete source listing for the <TT>FAxis</TT> class is not
presented here but can be found in Appendix B, &quot;<TT>com.foley.chart</TT>
Package Source Code.&quot;
<H4><TT>FChartLayoutManager</TT> Class</H4>
<P>
The <TT>FChartLayoutManager</TT> class is a layout manager dedicated
to <TT>FChart</TT> instances. It implements the AWT <TT>LayoutManager</TT>
interface to allow it to be used as a layout manager. A single
instance of the class can be shared by all <TT>FChart</TT> instances.
This is because the class does not maintain a reference to a single
chart. The <TT>addLayoutComponent</TT> and <TT>removeLayoutComponent</TT>
methods are not used. Instead, when the size for the layout is
requested or the layout is to occur, the axes are queried from
the given chart.
<P>
The algorithm used in the <TT>FChartLayoutManager</TT> is very
simple. The preferred width of the layout is the sum of the preferred
widths of the two axes and the left and right insets. Similarly,
the preferred height is the sum of the preferred heights of the
two axes and the top and bottom insets. The layout places the
y-axis at the chart's origin and the x-axis at the point specified
by (width, height) of the y-axis. (The proper insets are added
to the placements.) This leaves the center of the chart for the
traces to be drawn.
<P>
The complete listing for the <TT>FChartLayoutManager</TT> class
is shown in Listing 24.2.
<P>
<HR>
<P>
<B>Listing 24.2&nbsp;&nbsp;The </B><TT><B>FCHARTLAYOUTMANAGER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.chart;

import java.awt.*;


/**
 * A layout manager for the FChart Class.
 * &lt;p&gt;
 * The class lays out an X and a Y axis. The X axis
 * is along the bottom of the component, and the Y
 * along the left edge.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class FChartLayoutManager extends Object 
    implements LayoutManager { 
    
    /**
     * Adds the specified component with the specified name to
     * the layout.
     * @param name the component name
     * @param comp the component to be added
     */
    public void addLayoutComponent( String name, Component comp ) { 
        // Not used.
    } 
    

    /**
     * Removes the specified component from the layout.
     * @param comp the component to be removed
     */
    public void removeLayoutComponent( Component comp ) { 
        // Not used.
    } 


    /**
     * Calculates the preferred size dimensions for the specified 
     * panel given the components in the specified parent container.
     * @param parent the component to be laid out
     *  
     * @see #minimumLayoutSize
     */
    public Dimension preferredLayoutSize( Container parent ) { 
        
        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );
            
        FChart chart = ( FChart )parent;
        Insets insets = chart.getInsets();
        
        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        
        Dimension xAxisSize = xAxis.getPreferredSize();
        Dimension yAxisSize = yAxis.getPreferredSize();
        
        Dimension ourSize = new Dimension();
        ourSize.width = insets.right + insets.left + 
                        xAxisSize.width + yAxisSize.width + 10;
        ourSize.height = insets.top + insets.bottom + 
xAxisSize.height + yAxisSize.height + 10;
        
        return( ourSize );
        
    }  // preferredLayoutSize


    /** 
     * Calculates the minimum size dimensions for the specified 
     * panel given the components in the specified parent container.
     * @param parent the component to be laid out
     * @see #preferredLayoutSize
     */
    public Dimension minimumLayoutSize( Container parent ) { 
        
        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );
            
        FChart chart = ( FChart )parent;
        Insets insets = chart.getInsets();
        
        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        
        Dimension xAxisSize = xAxis.getMinimumSize();
        Dimension yAxisSize = yAxis.getMinimumSize();
        
        Dimension ourSize = new Dimension();
        ourSize.width = insets.right + insets.left + 
                        xAxisSize.width + yAxisSize.width;
        ourSize.height = insets.top + insets.bottom + 
                         xAxisSize.height + yAxisSize.height;
        
        return( ourSize );
        
    }  // minimumLayoutSize
    

    /** 
     * Lays out the container in the specified panel.
     * @param parent the component which needs to be laid out 
     */
    public void layoutContainer( Container parent ) { 
        
        if( !( parent instanceof FChart ) )
            throw new RuntimeException( 
                &quot;FChartLayoutManager only valid for FChart instances&quot; );
            
        FChart chart = ( FChart )parent;
        Dimension ourSize = chart.getSize();
        Insets insets = chart.getInsets();
        
        FAxis xAxis = chart.getXAxis();
        FAxis yAxis = chart.getYAxis();
        Dimension xAxisSize = xAxis.getPreferredSize();
        Dimension yAxisSize = yAxis.getPreferredSize();

        xAxis.setBounds( yAxisSize.width + insets.left - 1, 
                       ourSize.height - xAxisSize.height - insets.bottom,
                       ourSize.width - yAxisSize.width &ntilde; 
                                 insets.right - insets.left, 
                       xAxisSize.height );
        yAxis.setBounds( insets.top, 
                       insets.left, 
                       yAxisSize.width, 
                       ourSize.height - xAxisSize.height &ntilde; 
                                 insets.top - insets.bottom );
                        
    }  // layoutContainer
    
}  // FChartLayoutManager
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Pluggable Look-and-Feel Support</H4>
<P>
In the previous section, you saw the methods required by a component
to exist in the pluggable look-and-feel architecture that the
core Swing components implement. You saw how the component defines
a UI object class key that the <TT>UIManager</TT> uses to create
an instance of the UI class corresponding to the key. What you
have not seen is a UI class itself. In this section, the UI classes
for the <TT>FChart</TT> and <TT>FAxis</TT> classes will be presented.
<P>
As you saw in <A HREF="..\ch22\ch22.htm" >Chapter 22</A>, a component's UI object is a descendant
of the <TT>ComponentUI</TT> abstract class defined in the <TT>.plaf</TT>
package. The complete listing for this class was presented in
Listing 22.1. It is in this class that the responsibilities of
a UI object are defined. The methods in this class will be familiar
to those who have written AWT components. The <TT>ComponentUI</TT>
class is <TT>abstract</TT>; however, it does not contain any <TT>abstract</TT>
methods. This allows extensions to selectively choose which methods
to implement. The most commonly implemented methods by extensions
are the various size methods and the <TT>paint</TT> method. The
<TT>installUI</TT> method will need to be implemented if the UI
class is bound to a single component.
<P>
The <TT>static</TT> <TT>createUI</TT> method must be implemented
by all concrete <TT>ComponentUI</TT> extensions. This method is
called by the <TT>UIDefaults</TT> instance when the UI object
is being set on a component. This method must return an instance
of the class that is appropriate for the given <TT>JComponent</TT>
instance. This is typically an instance of the UI class itself.
If the UI object cannot be shared, this method generally creates
a new instance of the class and returns that instance. If the
UI object can be shared, the singleton instance of the class is
returned from this method. The <TT>FChartUI</TT> class is bound
to a single chart and cannot be shared. The <TT>FAxis</TT> class
is not bound to a single axis and can be shared by any number
of <TT>FAxis</TT> instances.
<P>
<B>FChartUI Classes</B>
<BLOCKQUOTE>
The <TT>FChartUI</TT> class provides the basic UI functionality
for the <TT>FChart</TT> class. There are look-and-feel-specific
extensions available for the Windows and Metal look-and-feels.
For any other look-and-feel being used, the <TT>FChartUI</TT>
class itself is used as the UI object. The class is bound to the
chart that it is the UI for, so a new instance of the <TT>FChartUI</TT>
class is created for each <TT>FChart</TT> instance. The <TT>FChart</TT>
component is shown in Figure 24.2 when the Windows look-and-feel
is being used for the application. An <TT>FChart</TT> instance
with the Metal look-and-feel was shown earlier in Figure 24.1.
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f24-2.gif')"><B>Figure 24.2 :</B> <I>The FChart component with the WindowsLookAnd-Feel</I>.</A>
<BLOCKQUOTE>
The <TT>FChartUI</TT> class is presented in Listing 24.3. As was
mentioned earlier, <TT>FChartUI</TT> instances are not shared,
so the <TT>createUI</TT> method creates a new instance each time
it is called. In the <TT>installUI</TT> method, the <TT>FChartUI</TT>
class adds itself as a <TT>propertyChangeListener</TT> for the
chart in which it is being installed as the UI object. It also
queries the model from the chart and, if the model is non-<TT>null</TT>,
the UI object adds itself as a <TT>TableModelListener</TT> to
the model. This allows for changes in the model to be detected.
When a change is received, the chart is repainted, forcing the
chart to be drawn with the new data. In the <TT>uninstallUI</TT>
method, the UI object removes itself as a <TT>PropertyChangeListener</TT>
from the chart and from being a <TT>TableModelListener</TT> to
the model. When a <TT>PropertyChangeEvent</TT> is received in
the <TT>propertyChange</TT> method, if the model has changed the
UI object stops listening for changes from the old model and starts
listening for changes in the new model.
<P>
</BLOCKQUOTE>
<CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>installUI</TT> and <TT>uninstallUI</TT> methods are inverses of each other. Listeners, defaults, and keyboard actions that are added in the <TT>installUI</TT> method must be removed in the <TT>uninstallUI</TT> method. Many of the core Swing UI classes divide the <TT>installUI</TT> and <TT>uninstallUI</TT> methods into multiple methods, one for each specific task. These two methods from the <TT>BasicLabelUI</TT> class are shown next.
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 public void installUI(JComponent c) {  
     installDefaults((JLabel)c);
     installComponents((JLabel)c);
     installListeners((JLabel)c);
     installKeyboardActions((JLabel)c);
 } 
 
     
 public void uninstallUI(JComponent c) {  
     uninstallDefaults((JLabel)c);
     uninstallComponents((JLabel)c);
     uninstallListeners((JLabel)c);
     uninstallKeyboardActions((JLabel)c);
 } </PRE>
</BLOCKQUOTE>
<BLOCKQUOTE>
The separation allows the code to be structured better by grouping related install and uninstall code together.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
</CENTER>
<P>
<BLOCKQUOTE>
The remaining methods in the <TT>FChartUI</TT> class are the familiar
<TT>getPreferredSize</TT> and <TT>paint</TT> methods. The preferred
size is the summation of the widths and heights of the axes in
the chart plus the insets of the component. The class inherits
the <TT>getMinimumSize</TT> and <TT>getMaximumSize</TT> methods
from the <TT>ComponentUI</TT> class, each of which calls the <TT>getPreferredSize</TT>
method and returns the <TT>Dimension</TT> returned from that method.
The <TT>paint</TT> method renders the chart's traces. Notice that
the axes are not drawn here. Each axis is a component and, as
such, it paints itself. Column 0 in the data model is considered
the x coordinate for every other column. The other columns are
the y coordinates, one trace per column. Thus, a data model with
three columns will produce a chart with two traces. The <TT>paint</TT>
method iterates through the data model and paints each trace.
The <TT>getLocationValue</TT> method contained in the <TT>FAxis</TT>
class is used to determine the coordinate in that direction. Simple
lines are drawn between each point in the model.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 24.3&nbsp;&nbsp;The </B><TT><B>FCHARTUI</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.chart;

import java.awt.*;
import java.beans.*;

import javax.swing.JComponent;
import javax.swing.table.TableModel;
import javax.swing.event.*;

import javax.swing.plaf.ComponentUI;


/**
 * Class FChartUI
 * &lt;p&gt;
 * The user-interface class for rendering FChart
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class FChartUI extends ComponentUI 
    implements PropertyChangeListener, TableModelListener { 

    /**
     * The FChart we are rendering.
     **/
    private FChart chart;
    
    
    /**
     * FChartUI, null constructor.
     **/
    public FChartUI() { 
        chart = null;
    } 
    
    
    /**
     * This UI may not be shared. Create a new
     * instance for each component.
     * &lt;p&gt;
     * @param c The component needing a UI.
     **/
    public static ComponentUI createUI(JComponent c) { 
        return( new FChartUI() );
    } 


    /**
     * Install ourselves as the UI for the given component.
* We need to get property changes from the chart.
     * This way we can keep in sync with the chart's values.
     * &lt;p&gt;
     * @param c The component we are the UI for.
     **/
    public void installUI( JComponent c ) { 
        chart = ( FChart )c;
        TableModel model = chart.getModel();
        if( model != null ) 
            model.addTableModelListener( this );
        chart.addPropertyChangeListener( this );
    } 
    
    
    /**
     * Uninstall ourselves as the UI for the given component.
* Remove ourself as a PropertyChangeListener.
     * &lt;p&gt;
     * @param c The component we are uninstalling.     
     **/
    public void uninstallUI(JComponent c) { 
        if( chart != c )
            throw new IllegalComponentStateException(
                          this + &quot; was asked to uninstallUI for &quot; 
                          + c + &quot; that is not my chart &quot; + chart + &quot;.&quot; );
        
        chart.removePropertyChangeListener( this );
        TableModel model = chart.getModel();
        if( model != null ) 
            model.removeTableModelListener( this );
    } 

    
    /**
     * tableChanged, from TableModelListener
     * &lt;p&gt;
     * The data in the table changed, repaint the chart.
     * &lt;p&gt;
     * @param event The change in the model.
     **/
    public void tableChanged( TableModelEvent event ) { 
        chart.repaint();
    } 
    
    
    /**
* propertyChange, from PropertyChangeListener
     * &lt;p&gt;
     * If the change is a table model change start listening
     * to the new model.
     * &lt;p&gt;
     * @param event The change.
     **/
    public void propertyChange( PropertyChangeEvent event ) { 
        if( event.getPropertyName().equals( FChart.MODEL_PROPERTY ) ) { 
            TableModel model = ( TableModel )event.getOldValue();
            if( model != null )
                model.removeTableModelListener( this );
            
            model = ( TableModel )event.getNewValue();
            if( model != null ) { 
                model.addTableModelListener( this );
            } 
        } 
    } 
    
    
    /**
     * @return The preferred size of this component.
     **/
    public Dimension getPreferredSize( JComponent c ) { 
        
        Insets insets = chart.getInsets();
        
        FAxis axis = chart.getXAxis();
        Dimension ourSize = new Dimension();
        Dimension x = axis.getPreferredSize();        
        
        axis = chart.getYAxis();
        Dimension y = axis.getPreferredSize(); 
        
        ourSize.width = x.width + y.width + insets.right + insets.left;
        ourSize.height = x.height + y.height + 
                           insets.top + insets.bottom;
        
        return( ourSize );
    } 
    
    
    /** 
     * Paint a representation of the &lt;code&gt;chart&lt;/code&gt; instance
     * that was set in installUI().
     * &lt;p&gt;
     * @param g The graphics to paint with.
     * @param c The component to paint.
     **/
    public void paint( Graphics g, JComponent c ) { 

        if( !( c instanceof FChart ) )
            return;
        
        TableModel model = chart.getModel();
        //
        // No data, no paint.
        //
        if( model == null )
            return;
            
        Dimension ourSize = c.getSize();            
        
        FAxis xAxis = chart.getXAxis();        
        FAxis yAxis = chart.getYAxis();
Insets insets = chart.getInsets();
Dimension yAxisSize = yAxis.getSize();
        
        g.translate( yAxisSize.width, insets.top + yAxisSize.height -1 );
        
        if( chart.isShowHorizontalLines() ) { 
            paintHorizontalLines( g, xAxis, yAxis );
        } 
                    
        if( chart.isShowVerticalLines() ) { 
            paintVerticalLines( g, xAxis, yAxis );
        } 

        //
        // Now paint the traces.
        //
        for( int j = 1; j &lt; model.getColumnCount(); j++ ) { 

            g.setColor( chart.getTraceColor( j-1 ) );
            
            Number o0 = ( Number )model.getValueAt( 0, 0 );
            Number o1 = ( Number )model.getValueAt( 0, j );
            int x0 = xAxis.getLocationValue( o0.doubleValue() );
            int y0 = yAxis.getLocationValue( o1.doubleValue() );
        
            for( int i = 1; i &lt; model.getRowCount(); i++ ) { 
                
                o0 = ( Number )model.getValueAt( i, 0 );
                o1 = ( Number )model.getValueAt( i, j );
                int x1 = xAxis.getLocationValue( o0.doubleValue() );
                int y1 = yAxis.getLocationValue( o1.doubleValue() );

                g.drawLine( x0, y0, x1, y1 );
                x0 = x1;
                y0 = y1;
            } 
        } 
        
        g.translate( -yAxisSize.width, 
               -( insets.top + yAxisSize.height - 1 ) );
        
    }  // paint
   
    
    /**
     * Paint the vertical grid lines in the chart.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param xAxis The chart's X axis.
     * @param yAxis The chart's Y axis.
     **/
    protected void paintVerticalLines( Graphics g, FAxis xAxis, 
                                         FAxis yAxis ) { 
        
        g.setColor( chart.getGridColor() );
        
        int minimum = xAxis.getMinimum();
        int maximum = xAxis.getMaximum();
        int spacing = xAxis.getMajorTickSpacing();
        
        Insets insets = yAxis.getInsets();
        Dimension size = yAxis.getSize();
        int yAxisLength = size.height - 
                      ( insets.top + insets.bottom ) - 2;
        
        for( int i = minimum + spacing; i &lt;= maximum; i += spacing ) { 
            int position = xAxis.getLocationValue( ( double )i );           
            g.drawLine( position, 0, position, -yAxisLength );
        } 
                        
    } 

    
    /**
     * Paint the horizontal grid lines in the chart.
     * &lt;p&gt;
     * @param g The Graphics to paint with.
     * @param xAxis The chart's X axis.
     * @param yAxis The chart's Y axis.
     **/
    protected void paintHorizontalLines( Graphics g, 
                                   FAxis xAxis, FAxis yAxis ) { 
        
        g.setColor( chart.getGridColor() );
        
        int minimum = yAxis.getMinimum();
        int maximum = yAxis.getMaximum();
        int spacing = yAxis.getMajorTickSpacing();
        
        Insets insets = xAxis.getInsets();
        Dimension size = xAxis.getSize();
        int xAxisLength = size.width - (insets.left + insets.right) - 2;
        
        for( int i = minimum + spacing; i &lt;= maximum; i += spacing ) { 
            int position = yAxis.getLocationValue( ( double )i );
            g.drawLine( 0, position, xAxisLength, position );
        } 
                        
    } 
    
}  // FChartUI
</PRE>
</BLOCKQUOTE>
<BLOCKQUOTE>
The implementation of the <TT>FChartUI</TT> class is easy to understand,
but not very efficient. Since an instance of the class is created
for each chart, the property listener could be used more advantageously.
For example, the preferred size is calculated each time it is
requested. This value could be cached and updated when a change
event is received from an axis in the chart. A bigger optimization
would be to cache the translated coordinates returned from the
<TT>getLocationValue</TT> method. Then when a <TT>tableChanged</TT>
event is received, the altered cells in the model could be updated.
At the least, the x coordinates should only be calculated once,
rather then for each trace in the <TT>paint</TT> method.
</BLOCKQUOTE>
<P>
<I><B>Look-and-Feel Subclasses</B></I>
<BLOCKQUOTE>
The <TT>FChartUI</TT> class is the default UI object for the <TT>FChart</TT>
class. However, there are two subclasses, <TT>WindowsFChartUI</TT>
and <TT>MetalFChartUI</TT>, that are used with the Windows and
Metal look-and-feels, respectively. These classes extend the <TT>FChartUI</TT>
class and override the <TT>paint</TT> method. In this method,
you attempt to make the look resemble other components in the
corresponding look-and-feel implementation.
</BLOCKQUOTE>
<BLOCKQUOTE>
The complete source listings for these two classes are presented
in Appendix C.
</BLOCKQUOTE>
<P>
<B>FAxisUI Class</B>
<BLOCKQUOTE>
The <TT>FAxisUI</TT> class provides the basic UI functionality
for the <TT>FAxis</TT> class. There are look-and-feel-specific
extensions available for the Windows and Metal look-and-feels.
For any other look-and-feel being used, the <TT>FAxisUI</TT> class
itself is used as the UI object. A single <TT>FAxisUI</TT> instance
can be used as the UI object for all <TT>FAxis</TT> instances
in an application. To implement the singleton pattern, a <TT>static</TT>
reference is made to the one instance of the class. In the <TT>createUI</TT>
method, a reference to this instance is returned. This technique
is shown in Listing 24.4. The <TT>FAxisUI</TT> class does not
need to perform any processing in the <TT>installUI</TT> or <TT>uninstallUI</TT>
method, so these methods can be inherited from the <TT>ComponentUI</TT>
class. Listing 24.4 presents only the UI-specific portion of the
<TT>FAxisUI</TT> class. The complete source listing is presented
in Appendix C.
</BLOCKQUOTE>
<P>
<HR>
<P>
<B>Listing 24.4&nbsp;&nbsp;Partial </B><TT><B>FAXISUI</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Class FAxisUI
 * &lt;p&gt;
 * The user-interface class for rendering FAxis
 * instances.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class FAxisUI extends ComponentUI { 

    /**
     * The singleton instance of this class.
     **/
    private static FAxisUI shared = new FAxisUI();
       
    /**
     * FAxis, default Constructor.
     **/
    public FAxisUI() { 
        super();
    } 
    
    
    /**
     * Create the UI object for the given component.
     * This class may share the same UI object for
     * all FAxis that are created.
     * &lt;p&gt;
     * @param c The component that needs a UI.
     * @return The singleton UI Object.
     **/
    public static ComponentUI createUI( JComponent c ) { 
        return( shared );
    } 
// Remainder of listing in Appendix C
</PRE>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
The <TT>FAxisUI</TT> class calculates the preferred size each
time this property is requested. It also performs many computations
in its <TT>paint</TT> method. If the class was changed from a
singleton to one UI object per component, many of these values
can be cached and updated when a <TT>PropertyChangeEvent</TT>
is received from the UI object's corresponding axes. This is a
classic time versus space consideration. In this example, time
was sacrificed for a less complex implementation that requires
less memory.
</BLOCKQUOTE>
<P>
<I><B>Look-and-Feel Subclasses</B></I>
<BLOCKQUOTE>
The <TT>FAxisUI</TT> class is the default UI object for the <TT>FAxis</TT>
class. However, there are two subclasses, <TT>WindowsFAxisUI</TT>
and <TT>MetalFAxisUI</TT>, that are used with the Windows and
Metal look-and-feels, respectively. These classes extend the <TT>FAxisUI</TT>
class and override the <TT>paint</TT> method. In this method,
you attempt to make the look resemble other components in the
corresponding look-and-feel implementation.
</BLOCKQUOTE>
<BLOCKQUOTE>
The complete source listings for these two classes are presented
in Appendix C.
</BLOCKQUOTE>
<H3><A NAME="UsingtheTTFONTSIZEFChartFONTTTFONTSIZEClassFONT">
Using the <TT>FChart</TT>
Class</A></H3>
<P>
In the previous section, the <TT>FChart</TT> class and its support
classes were presented. This class provides a chart view of the
numerical data contained in a <TT>TableModel</TT> instance. The
<TT>ChartTest</TT> application creates a chart and table that
share the same data model. When a value is edited in the table,
the chart will reflect the change. The two components are placed
into a split pane to allow their sizes to be altered. The <TT>TestDataModel</TT>
class, shown in Listing 24.5, is the shared data model. The model
defines five columns resulting in four traces in the chart. The
initial data contains linear, constant, sinusoidal, and random
columns. The linear and constant data can be edited to alter the
chart. When any value in the constant column is edited, all rows
are changed to the new value. This ensures that the trace will
always be constant. The resulting application is shown in Figure
24.3.
<P>
<HR>
<P>
<B>Listing 24.5&nbsp;&nbsp;The </B><TT><B>CHARTTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.beans.*;

import javax.swing.*;
import javax.swing.table.AbstractTableModel ;

import com.foley.chart.FChart;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays an FChart instance
 * and a JTable in a splitPane. The two components
 * share the same data model, so editing the table
 * will alter the chart.
 *
 * @author Mike Foley
 **/
public class ChartTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the components, and display them.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
        
        final JFrame frame = new ApplicationFrame( &quot;Chart Test&quot; );
        
        FChart.initialize();

        UIManager.addPropertyChangeListener( 
                  new PropertyChangeListener() { 
            public void propertyChange( PropertyChangeEvent event ) { 
                if( &quot;lookAndFeel&quot;.equals( event.getPropertyName() ) ) { 
                    SwingUtilities.updateComponentTreeUI( frame );
                } 
            } 
        }  );

        //
        // Place the chart and table in a split pane.
        // The chart is on top.
        //
        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        splitPane.setOneTouchExpandable( true );
        
        TestTableModel model = new TestTableModel();
        
        FChart chart = new FChart( model );
        JTable table = new JTable( model );
        
        splitPane.setTopComponent( chart );
        splitPane.setBottomComponent( new JScrollPane( table ) );
        splitPane.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( splitPane, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main
    
}  // ChartTest


/**
 * A simple model to test the FChart component.
 * The model has five column, resulting in four traces
 * being painted in the chart. 
 * &lt;p&gt;
 * The first column defines the x coordinates for the data.
 * The second is a linear trace.
 * The third is a constant trace.
 * The four is a sine wave.
 * The fifth is random numbers.
 * &lt;p&gt;
 * Only two columns are editable. The linear may be changed to anything.
 * When any row in column three, the constant trace, is changed, all
 * values in that column are changed to the new value.
 * &lt;p&gt;
 * @author Mike Foley
 **/
class TestTableModel extends AbstractTableModel { 
    
    double[] c0 = {  0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                    50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100 } ;
    double[] c1 = {  0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 
                    50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100 } ;
    double[] c2;
    Double[] c4;
    String[] columnNames = {  &quot;X-Value&quot;, &quot;Y1&quot;, &quot;Constant&quot;, 
                             &quot;Sin&quot;, &quot;Random&quot; } ;
 
 
    /**
     * TestTableModel, constructor.
     * &lt;p&gt;
     * Initialize the table model data.
     **/
    public TestTableModel() { 
        c2 = new double[ c1.length ];
        c4 = new Double[ c1.length ];
        for( int i = 0; i &lt; c2.length; i++ ) { 
            c2[i] = 23.0;
c4[i] = new Double( 100 * Math.random() );
        } 
    } 
            
        
    /**
     * @return The number of rows in the model.
     **/
    public int getRowCount() { 
        return( c1.length );
    } 
    
    
    /**
     * @return The number of columns in the model.
     **/
    public int getColumnCount() { 
        return( columnNames.length );
    } 
    
    
    /**
     * @param column The column who's name is desired.
     * @return The column name of the given column.
     **/
    public String getColumnName(int column ) { 
        return( columnNames[ column ] );
    } 
        
        
    /**
     * Only columns 1 and 2 are editable.
     * The rows don't matter.
     * &lt;p&gt;
     * @param row The row of the cell in question.
     * @param column The column of the cell in question.
     * @return True if the cell is editable.
     **/
    public boolean isCellEditable( int row, int column ) { 
        if( column == 1 || column == 2 )
            return( true );
        else
            return( false );                
    } 

        
    /**
     * The new value is assumed to be a string that can be
     * parsed by the Double class. If this is not the case,
     * there will be trouble.
     * &lt;p&gt;
     * @param value The new data.
     * @param row The row for the new data item.
     * @param column The column for the new data item.
     * @see #getValueAt
     **/
    public void setValueAt( Object value, int row, int column ) { 
        
        Double newValue = new Double( ( String )value );

        switch( column ) { 
            case 1:
                c1[ row ] = newValue.doubleValue();
                fireTableCellUpdated( row, column );
                break;
            case 2:
                for( int i = 0; i &lt; getRowCount(); i++ )
                    c2[ i ] = newValue.doubleValue();
                fireTableRowsUpdated( 0, getRowCount() - 1 );
                break;
            default:
                throw new RuntimeException( 
                      &quot;Unknown column in table model setValueAt&quot; );
        } 
    } 


    /**
     * @param row The row of the requested data item.
     * @param column The column of the requested data item.
     * @return The value at the given row and column in the model.
     * @see #setValueAt
     **/
    public Object getValueAt(int row, int column) { 
        Object out;
            
        switch( column ) { 
            case 0:
                out = new Double( c0[ row ] );
                break;
            case 1:
                out = new Double( c1[ row ] );
                break;
            case 2:
                out = new Double( c2[ row ] );
                break;
            case 3:
out = new Double( 50 +  50 * Math.sin( 0.1 * c0[row] ) );
                break;
            case 4:
                out = c4[ row ];
                break;
            default:
                out = null;
        } 
        return( out );
        
    }  // getValueAt
    
}  // TestTableModel
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f24-3.gif')"><B>Figure 24.3 :</B> <I>The ChartTest application</I>.</A>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
In this chapter, you created a custom Swing component extension.
A component that is to work within the pluggable look-and-feel
architecture is not a single class. Instead, it is a component
class that defines the API for application interactions with the
component and one or more user interface classes. A single UI
class can be used with all look-and-feel implementations, or a
class can be developed for each look-and-feel, or any combination
in between.
<P>
Before the UI object can be used in the pluggable look-and-feel
architecture, its class must be registered with the <TT>UIManager</TT>.
The <TT>uiClassID</TT> key queried from the component class is
used by the <TT>UIManager</TT> to determine the class to use for
its UI object. There are no hooks in the JFC that allow the custom
class to perform this initialization work. This forces the component
to provide an initialization method or forces the user of the
component to do this work. In this chapter's example, a <TT>static</TT>
<TT>initialization</TT> method was provided that was called by
the application before the first instance of the class was created.
If the component supports different UI objects for different look-and-feel
implementations, the component must also listen for <TT>LookAndFeel</TT>
change messages from the <TT>UIManager</TT> so that the values
in the <TT>UIManager</TT> can be kept current.
<P>
The <TT>FChart</TT> class and its helper class, <TT>FAxis</TT>,
are two custom components that work together to display a chart.
There are multiple UI classes for each component class. There
are specific versions for the Windows and Metal look-and-feels
and a generic version for any other look-and-feel that may be
encountered. The component class is responsible for defining the
API and properties available for the component. The UI class is
responsible for interacting with the user. This includes calculating
the size for the component, registering keystroke actions, responding
to mouse gestures, and painting the component. The methods required
by both the component class and the UI class to exist in the JFC's
pluggable look-and-feel architecture were presented in these classes.
<P>
The <TT>FChart</TT> class displays numerical data contained in
a <TT>TableModel</TT> instance. The <TT>FAxis</TT> class stores
its range data in a <TT>BoundedRangeModel</TT> instance. Both
the <TT>FChart</TT> and <TT>FAxis</TT> classes contain bound properties
that are defined in other JFC components that represent similar
properties. Leveraging existing models and properties from the
core Swing components will make your custom components easier
to use by experienced Swing developers. A developer who is familiar
with the <TT>TableModel</TT> interface and the <TT>JSlider</TT>
class will be familiar with the API defined by the <TT>FChart</TT>
and <TT>FAxis</TT> classes. This will enable the developer to
use the components with little expended effort.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch23\ch23.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch25\ch25.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
