<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 5 - Basic Components </TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch04\ch04.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch06\ch06.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;5<br>
Basic Components </H1>
<HR>
<p>

<UL>
<LI><A HREF="#Separator">
Separator</A>
<LI><A HREF="#Borders">
Borders</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEBorderFONTTTFONTSIZEInterfaceFONT">
The <TT>Border</TT> Interface
</A>
<LI><A HREF="#TheBorderPackage">
The Border Package</A>
<LI><A HREF="#AddingaBordertoanyTTFONTSIZEJComponentFONTTT">
Adding a Border to any <TT>JComponent</TT>
</A>
<LI><A HREF="#TheTTFONTSIZEBorderFactoryFONTTT">
The <TT>BorderFactory</TT></A>
<LI><A HREF="#CreatingYourOwnBorder">
Creating Your Own Border</A>
<LI><A HREF="#ACompletebutGaudyBorderExample">
A Complete but Gaudy Border Example</A>
</UL>
<LI><A HREF="#Icons">
Icons</A>
<UL>
<LI><A HREF="#TTFONTSIZEIconFONTTTFONTSIZEInterfaceFONT">
<TT>Icon</TT> Interface
</A>
<LI><A HREF="#TTFONTSIZEImageIconFONTTTFONTSIZEClassFONT">
<TT>ImageIcon</TT> Class
</A>
<LI><A HREF="#TTFONTSIZEGrayFilterFONTTTFONTSIZEClassFONT">
<TT>GrayFilter</TT> Class
</A>
</UL>
<LI><A HREF="#LabelComponents">
Label Components</A>
<UL>
<LI><A HREF="#TheTTFONTSIZEJLabelFONTTTFONTSIZEClassFONT">
The <TT>JLabel</TT> Class
</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
When building a user interface, there is a need for basic user
interface components. This chapter presents the basic components
supplied with the JFC.
<P>
In this chapter you will learn how to use:
<UL>
<LI>Separators
<LI>Borders
<LI>Icons
<LI>Labels
</UL>
<H2><A NAME="Separator">
Separator</A></H2>
<P>
Perhaps the simplest component in the JFC is the <TT>JSeparator</TT>
class. The <TT>JSeparator</TT> displays an etched line that is
typically used to divide areas in a panel (see Figure 5.1). This
class is commonly used in menus but can be used in any container.
<P>
Creating a separator is a simple task. Simply call the constructor
of the class-it doesn't take any parameters. This is shown in
the following code fragment. The separator can then be added to
a container. Many of the examples in the remainder of this book
will show the <TT>JSeparator</TT> class in action.
<P>
<TT>JSeparator separator = new JSeparator();</TT>
<P>
<A HREF="javascript:popUp('f5-1.gif')"><B>Figure 5.1 :</B> A <I>JSeparator</I>.</A>
<H2><A NAME="Borders">
Borders</A></H2>
<P>
Borders are often used to group components that perform a related
function. The JFC makes this particularly easy because the <TT>JComponent</TT>
class provides a property for a border. This means that any <TT>JComponent</TT>,
both simple components and complex containers, can have a border.
Also, borders can be nested to create any visual appearance desired.
<H3><A NAME="TheTTFONTSIZEBorderFONTTTFONTSIZEInterfaceFONT">
The <TT>Border</TT> Interface
</A></H3>
<P>
The methods that define a JFC border are contained in the <TT>Border</TT>
interface. These methods are shown in the next code example. Any
component can implement this interface and be used as a border
for a <TT>JComponent</TT>. However, as you will see in the remainder
of this section, the JFC provides a rich set of standard borders.
Due to the stock borders, implementing the <TT>Border</TT> interface
is rarely required.
<BLOCKQUOTE>
<PRE>
public interface Border
{ 
    /**
     * Paints the border for the specified component with the specified 
     * position and size.
     * @param c the component for which this border is being painted
     * @param g the paint graphics
     * @param x the x position of the painted border
     * @param y the y position of the painted border
     * @param width the width of the painted border
     * @param height the height of the painted border
     */
void paintBorder( Component c, Graphics g, 
                      int x, int y, int width, int height );

    /**
     * Returns the insets of the border.  
     * @param c the component for which this border insets value applies
     */
    Insets getBorderInsets(Component c);

    /**
     * Returns whether or not the border is opaque.  If the border
     * is opaque, it is responsible for filling in it's own
     * background when painting.
     */
    boolean isBorderOpaque();
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheBorderPackage">
The Border Package</A></H3>
<P>
The borders that are part of the JFC are contained in the <TT>javax.swing.border</TT>
package. This package consists of the <TT>Border</TT> interface
itself, an abstract border class that serves as the parent to
the eight concrete borders, and the concrete border classes. The
border class hierarchy is shown in Figure 5.2.
<P>
<A HREF="javascript:popUp('f5-2.gif')"><B>Figure 5.2 :</B> <I>The Border package class hierarchy</I>.</A>
<P>
An instance of a concrete border can be created and set for any
<TT>JComponent</TT>. The following code shows how to create a
<TT>SoftBevelBorder</TT> instance. The remaining borders will
be presented in the <TT>BorderFactory</TT> section later in this
chapter. The next section shows how to add the border to a <TT>JComponent</TT>.
<P>
<TT>Border border = new SoftBevelBorder( BevelBorder.LOWERED
);</TT>
<H3><A NAME="AddingaBordertoanyTTFONTSIZEJComponentFONTTT">
Adding a Border to any <TT>JComponent</TT>
</A></H3>
<P>
The <TT>setBorder</TT> method in <TT>JComponent</TT> is provided
for setting the border. Because this method is in <TT>JComponent</TT>,
any JFC component, or any component derived from a JFC component,
can contain a border. This means that both simple components,
such as <TT>JLabel</TT> instances, and container components, such
as <TT>JPanel</TT> instances, can contain a border. This makes
it extremely easy to add borders to group-related components in
a panel. This is a powerful feature of the JFC. An example of
the <TT>setBorder</TT> method will be shown in the next section.
<P>
The <TT>getBorder</TT> method can be used to query the current
border surrounding a <TT>JComponent</TT>. The returned border
can then be altered for the current situation. This method will
return <TT>null</TT> if the component doesn't currently have a
border.
<H3><A NAME="TheTTFONTSIZEBorderFactoryFONTTT">
The <TT>BorderFactory</TT></A></H3>
<P>
Instances of the borders in the Border package can be instantiated
directly, as shown in a previous section. However, the JFC borders
are designed to be shared among components. To facilitate sharing
borders, a factory has been built to retrieve borders. The <TT>BorderFactory</TT>
consists of a collection of static methods used to obtain a handle
to a border. The <TT>BorderFactor</TT> lives in the <TT>javax.swing</TT>
package, even though the borders themselves live in the <TT>javax.swing.border</TT>
package. These methods follow the naming pattern <TT>create <I>Type</I> Border</TT>,
where <TT><I>Type</I></TT> is one of the
border classes in the <TT>javax.swing.border</TT> package. There
is a <TT>create</TT> method that corresponds to each <TT>public</TT>
constructor in the border classes. Each of the borders that can
be retrieved via the <TT>BorderFactory</TT> is discussed in the
following sections.
<H4><TT>LineBorder</TT></H4>
<P>
The static <TT>BorderFactory</TT> method <TT>createLineBorder</TT>
will return an instance of a <TT>LineBorder</TT>. As its name
implies, a simple line represents a line border. The color of
the border must be specified. Optionally, a thickness for the
border can be specified. If the thickness is omitted, a border
with a thickness of one pixel is returned. The following application
demonstrates how to obtain a blue <TT>LineBorder</TT> with a thickness
of five pixels and set it for a <TT>JLabel</TT> component.  This
label and its border are shown in Figure 5.3.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
This first example gives the complete listing for an application that creates the desired border and displays it in an ApplicationFrame. The <TT>ApplicationFrame </TT>class is presented in <A HREF="..\ch08\ch08.htm" >Chapter 8</A> &quot;Frame Windows.&quot; The remaining examples in this section only present the code to create the label and set its border to the desired type. However, the application listed here can be used as the framework for testing the other borders.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<A HREF="javascript:popUp('f5-3.gif')"><B>Figure 5.3 :</B> <I>A simple LineBorder around a JLabel</I>.</A>
<BR>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a border
 * around a label in a frame.
 *
 * @author Mike Foley
 **/
public class SimpleBorderTest extends JFrame { 
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

ApplicationFrame frame = 
                         new ApplicationFrame( &quot;Simple Border Test&quot; );

        //
        // Create a label and add the border around the label.
        //
        JLabel label = new JLabel( &quot;Line Border&quot; );
        Border border = BorderFactory.createLineBorder( Color.blue, 5 );
        label.setBorder( border );
        
        frame.getContentPane().add( label, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // SimpleBorderTest
</PRE>
</BLOCKQUOTE>
<H4><TT>BevelBorder</TT></H4>
<P>
The static <TT>BorderFactory</TT> method <TT>createBevelBorder</TT>
returns an instance of the <TT>BevelBorder</TT> class. A <TT>BevelBorder</TT>
can be used to give a component a raised or sunken look. The next
code fragment shows how to obtain a reference to a <TT>BevelBorder</TT>.
As the example shows, the <TT>RAISED</TT> or <TT>LOWERED</TT>
constant defined in the <TT>BevelBorder</TT> class is used to
set the border type. These borders are then added to instances
of the <TT>JLabel</TT> class. The resulting components are shown
in Figure 5.4.<BR>
<P>
<A HREF="javascript:popUp('f5-4.gif')"><B>Figure 5.4 :</B> <I>Beveled borders</I>.</A><BR>
<BLOCKQUOTE>
<PRE>
JLabel label = new JLabel( &quot;Lowered Bevel Border&quot; );
Border border = BorderFactory.createBevelBorder( BevelBorder.LOWERED );
label.setBorder( border );

JLabel label = new JLabel( &quot;Raised Bevel Border&quot; );
Border border = BorderFactory.createBevelBorder( BevelBorder.RAISED );
label.setBorder( border );
</PRE>
</BLOCKQUOTE>
<P>
The convenience methods <TT>createRaisedBevelBorder</TT> and <TT>createLoweredBevelBorder</TT>
are provided in <TT>BorderFactory</TT> to create a raised or lowered
bevel border without requiring a parameter. By using these method,
the previous code could be expressed as follows:
<BLOCKQUOTE>
<PRE>
JLabel label = new JLabel( &quot;Lowered Bevel Border&quot; );
Border border = BorderFactory.createLoweredBevelBorder();
label.setBorder( border );

JLabel label = new JLabel( &quot;Raised Bevel Border&quot; );
Border border = BorderFactory.createRaisedBevelBorder();
label.setBorder( border );
</PRE>
</BLOCKQUOTE>
<P>
These bevel borders use the colors specified by the look-and-feel
currently in use. The colors contained in the <TT>BevelBorder</TT>
can be specified in the <TT>createBevelBorderMethod</TT>. You
have two options when specifying colors. You can specify the highlight
and shadow colors and let the border determine the inner and outer
shades for each border. Or you can specify all four colors that
the border uses to paint itself. These colors are the <TT>highlightOuter</TT>,
<TT>highlightInner</TT>, <TT>shadowOuter</TT>, and <TT>shadowInner</TT>.
An example of using the methods in the <TT>BorderFactory</TT>
to obtain a <TT>BevelBorder</TT> with an arbitrary color scheme
is presented next. Care should be taken when using these methods
because it is very easy to create unattractive borders. The various
look-and-feels have different color schemes, making this task
even more difficult.
<BLOCKQUOTE>
<PRE>
Border border = BorderFactory.createBevelBorder( 
                      BevelBorder.RAISED, Color.blue, Color.red );
Border border = BorderFactory.createBevelBorder( 
                      BevelBorder.LOWERED, Color.blue, Color.red,
                      Color.yellow, Color.gray );
</PRE>
</BLOCKQUOTE>
<H4><TT>EtchedBorder</TT></H4>
<P>
The static <TT>BorderFactory</TT> method <TT>createEtchedBorder</TT>
returns an instance of the <TT>EtchedBorder</TT> class. Obtaining
an etched border from the <TT>BorderFactory</TT> is demonstrated
in the following code. This border, after being added to a <TT>JLabel</TT>,
is shown in Figure 5.5.<BR>
<P>
<A HREF="javascript:popUp('f5-5.gif')"><B>Figure 5.5 :</B> <I>EtchedBorder around a JLabel</I>.</A><BR>
<BLOCKQUOTE>
<PRE>
JLabel label = new JLabel( &quot;Etched Border&quot; );
Border border = BorderFactory.createEtchedBorder();
label.setBorder( border );
</PRE>
</BLOCKQUOTE>
<P>
The highlight and shadow color used in the etched border can be
specified while obtaining an etched border from the <TT>BorderFactory</TT>,
as in the following:
<BLOCKQUOTE>
<PRE>
Border border = BorderFactory.createEtchedBorder(
                       highlightColor, shadowColor )
</PRE>
</BLOCKQUOTE>
<H4><TT>EmptyBorder</TT></H4>
<P>
The static <TT>BorderFactory</TT> method <TT>createEmptyBorder</TT>
returns an instance of the <TT>EtchedBorder</TT> class. As the
name implies, and empty border is a border that is not painted.
The first question that comes to mind is, why would such a border
be desired? The answer is that empty borders have replaced <TT>Insets</TT>
from the AWT as the desired mechanism for adding space around
a component. 
<P>
The <TT>BorderFactory</TT> contains two static overloaded methods
to obtain a handle on an <TT>EmptyBorder</TT>. The more interesting
of the two <TT>createEmptyBorder</TT> methods is the version that
takes parameters. The amount of space taken by the border on each
side of the bordered component can be specified by using this
method. Notice that the space on each side is individually specified
in the same order as when creating an <TT>Insets</TT> instance.
This allows a non-symmetric border, if desired. A picture of an
<TT>EmptyBorder</TT> is not presented, because it is difficult
to see.
<BLOCKQUOTE>
<PRE>
Border border = BorderFactory.createEmptyBorder();
Border iBorder = BorderFactory.createEmptyBorder( 
                       top, left, bottom, right );
</PRE>
</BLOCKQUOTE>
<H4><TT>MatteBorder</TT></H4>
<P>
The static <TT>BorderFactory</TT> method <TT>createMatteBorder</TT>
returns an instance of the <TT>MatteBorder</TT> class. The method
to obtain a matte border is similar to the method to obtain an
empty border. This is because the matte border extends the <TT>EmptyBorder</TT>
class. In addition to the border size parameters, a color or icon
can be specified when creating a matte border. 
<P>
When a color is specified, the border looks suspiciously like
a line border. The fundamental difference between the two borders
is that the line border is the same thickness on each side of
the bordered component. The matte border can be a different size
on each side of the component. The following line of code retrieves
a blue matte border with a thickness of five pixels from the <TT>BorderFactory</TT>
(see Figure 5.6).<BR>
<P>
<A HREF="javascript:popUp('f5-6.gif')"><B>Figure 5.6 :</B> <I>A matte border</I>.</A><BR>
<BLOCKQUOTE>
<PRE>
JLabel label = new JLabel( &quot;Matte Border&quot; );
Border border = BorderFactory.createMatteBorder( 
                      5, 5, 5, 5, Color.blue );
label.setBorder( border );
</PRE>
</BLOCKQUOTE>
<P>
When given an <TT>Icon</TT>, the matte border paints the <TT>Icon</TT>
in the border. The <TT>Icon</TT> is repeated as often as necessary
to fill the border. The following line of code creates a matte
border by using the <TT>Icon</TT> named <TT>checker</TT>. A simple
red and white checked pattern icon was used to create the checkered
matte border in Figure 5.7. From these figures, it can be seen
how the icon image is repeated over and over to fill the border.
<BLOCKQUOTE>
<PRE>
//
// Assume the checker.gif image is in the current directory.
//
ImageIcon checker = new ImageIcon( &quot;checker.gif&quot; );
JLabel label = new JLabel( &quot;Matte Border&quot; );
Border border = BorderFactory.createMatteBorder( 4, 4, 4, 4, checker );
label.setBorder( border );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f5-7.gif')"><B>Figure 5.7 :</B> <I>A checkered matte border created by repeating
a checker icon</I>.</A><BR>
<H4><TT>CompoundBorder</TT></H4>
<P>
In the previous sections, you looked at the simple borders contained
in the JFC. Borders can be combined to create an endless variety
of compound borders. The <TT>BorderFactory</TT> static method
<TT>createCompoundBorder</TT> returns an instance of a compound
border. A compound border consists of two borders, one nested
inside the other. A typical use of a compound border is to add
space between a decorative border and the component.
<P>
In the examples given in the previous sections, you saw that the
label's text approaches the border. This is awkward in appearance.
Using a compound border can alleviate this problem. An empty border
with the desired margin can be placed inside the decorative border.
The following line of code creates such a border. The first parameter
is the outer border, and the second is the inner border (see Figure
5.8). In the figure it is easy to see how the empty border provides
a margin between the label's text and the matte border.
<BLOCKQUOTE>
<PRE>
//
// Assume the checker.gif image is in the current
// directory.
//
ImageIcon checker = new ImageIcon( &quot;checker.gif&quot; );
JLabel label = new JLabel( &quot;Matte Border&quot; );
Border border = BorderFactory.createCompoundBorder( 
            BorderFactory.createMatteBorder( 4, 4, 4, 4, checker ),
            BorderFactory.createEmptyBorder( 4, 4, 4, 4 ) );
label.setBorder( border );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f5-8.gif')"><B>Figure 5.8 :</B> <I>A compound matte and empty border</I>.</A><BR>
<P>
Compound borders can be nested to add additional visual appeal.
This is accomplished by creating a <TT>CompoundBorder</TT> as
shown earlier, and then using this border as the outside border
in another <TT>CompoundBorder</TT>. This nesting can be performed
to an arbitrary depth. The following code fragment creates a border
consisting of a matte border surrounded by bevel borders. This
creates a sunken matte border (see Figure 5.9). 
<BLOCKQUOTE>
<PRE>
//
// Assume the checker.gif image is in the current
// directory.
//
ImageIcon checker = new ImageIcon( &quot;checker.gif&quot; );
JLabel label = new JLabel( &quot;Sunken Matte Border&quot; );
Border border = BorderFactory.createCompoundBorder( 
            BorderFactory.createBevelBorder( BevelBorder.LOWERED ),
            BorderFactory.createMatteBorder( 4, 4, 4, 4, checker ) );
border = BorderFactory.createCompoundBorder( 
            border,
            BorderFactory.createBevelBorder( BevelBorder.RAISED ) );
border = BorderFactory.createCompoundBorder( 
            border,
            BorderFactory.createEmptyBorder( 2, 2, 2, 2 ) );
label.setBorder( border );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f5-9.gif')"><B>Figure 5.9 :</B> <I>Double nested CompoundBorder</I>.</A><BR>
<P>
Restraint must be shown when using multiple compound borders.
It's easy to get carried away and create unattractive ones.
<P>
A nice use of the compound border is when a matte border is not
desired on each side of the component. The matte border and an
empty border can be combined to provide this functionality, while
keeping the border symmetric around the component.
<H4>Adding a Title to a Border</H4>
<P>
It is often desirable to add a title to the border surrounding
the components when grouping components. The <TT>BorderFactory</TT>
method <TT>createTitledBorder</TT> returns an instance of a <TT>TitledBorder</TT>.
 This type of border can be used to add a title to any border.
The text, font, position, and color of the border can be specified
while obtaining the border or altered later by calling methods
contained in the <TT>TitledBorder</TT> class.
<P>
The title can be placed above or below the bordered component.
It can also be placed above, below, or through the border. The
positioning of the border is determined by two parameters that
can be specified when obtaining the titled border, or through
methods in the <TT>TitledBorder</TT> class. The properties for
positioning the border are <TT>titlePosition</TT> and <TT>titleJustification</TT>.
These constants are defined in the <TT>TitledBorder</TT> class,
not in the <TT>SwingConstants</TT> class. The JFC is somewhat
inconsistent about which constants are defined where. It is unfortunate
that these constants weren't shared with others that convey the
same meaning in the <TT>SwingConstants</TT> class. Figure 5.10
demonstrates the available constants and how the title is positioned
for each combination of the positioning constants.
<P>
The following code fragment obtains the handle to a <TT>TitledBorder</TT>
from the <TT>BorderFactory</TT>. The word  &quot;Title&quot; will
be centered above the border. Figure 5.10 shows all the possible
combinations of title positioning around a <TT>JLabel</TT>. Notice
how the <TT>TitledBorder</TT> class requires a reference to the
border that is getting the title, an etched border in the example
below.
<BLOCKQUOTE>
<PRE>
Border etched = BorderFactory.createEtchedBorder();Border border =
BorderFactory.createTitledBorder( 
                            etched, &quot;Title&quot;,
                            TitledBorder.CENTER,
                            TitledBorder.ABOVE_TOP ); <BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f5-10.gif')"><B>Figure 5.10:</B> <I>Positions for a border's title</I>.</A><BR>
<H3><A NAME="CreatingYourOwnBorder">
Creating Your Own Border</A></H3>
<P>
As was described earlier in this chapter, <TT>Border</TT> is an
interface. This allows any class to implement this interface and
be set as the border to any instance of a <TT>JComponent</TT>
extension.
<P>
This section presents three classes, two of which can be used
as borders. The third class is an abstract base class for the
two concrete <TT>Border</TT> classes. These borders use the Java
threading mechanism to create an animated border. The first class
is an abstract class named <TT>AnimatedBorder</TT>. This class
extends the JFC <TT>EmptyBorder</TT> class. The <TT>EmptyBorder</TT>
class manages the real estate where the border paints. This is
done with the <TT>Insets</TT> for the border. <TT>EmptyBorder</TT>
extends the <TT>AbstractBorder</TT> class. Many borders that you
will create will extend <TT>AbstractBorder</TT>, as do most of
the JFC borders.
<P>
The <TT>AnimatedBorder</TT> class is presented in Listing 5.1.
Its primary duty is to manage the thread used to create the animation.
It contains one bound property that determines how often the animation
occurs. To support the bound property, the class contains the
required methods for managing <TT>PropertyChangeListeners</TT>.
<P>
The run method is very simple. It sleeps the amount of time specified
by the <TT>sleepTime</TT> property and then forces the border
to be painted. Classes that extend <TT>AnimatedBorder</TT> perform
the actual animation in their <TT>paintBorder</TT> method. Recall
that <TT>paintBorder</TT> is one of the methods defined in the
<TT>Border</TT> interface. This ensures that all borders will
contain the <TT>paintBorder</TT> method.<BR>
<HR>
<P>
<B>Listing 5.1&nbsp;&nbsp;The </B><TT><B>ANIMATEDBORDER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.borders;

import java.awt.Insets;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Color;

import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;

import javax.swing.JComponent;

import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;


/**
 * AnimatedBorder is an abstract class that can be
 * extended to create animated borders.  This class
 * manages the animation thread.  It forces the border
 * to be redrawn each animation cycle.  It is the
 * responsibility of the child class to track
 * which animation cycle they are drawing.
 *
 * @author Mike Foley
 * @see Border
 **/
public abstract class AnimatedBorder extends EmptyBorder 
    implements Runnable { 
    
    /**
     * The component this Border borders.
     **/
    private JComponent c;
    
    /**
     * The delay between border paints.
     **/
    private int sleepTime = 250;
    
    /**
     * Support for property change listeners, and bound
     * property names.
     **/
protected PropertyChangeSupport changes = 
                                    new PropertyChangeSupport(this);
    public static final String SLEEP_TIME_PROPERTY = &quot;SleepTimeProperty&quot;;
    
    
    /**
     * Constructor
     * Create an Insets structure and call our working constructor.
     *
     * @param c The component we border.
     * @param top The top border width.
     * @param left The left border width.
     * @param bottom The bottom border width.
     * @param right The right border width.
     **/
    public AnimatedBorder( JComponent c, int top, int left,
                           int bottom, int right ) { 
        this( c, new Insets( top, left, bottom, right ) );
    } 
    
    
    /**
     * Constructor.
     * Store a reference to the component we border.
     * Create, and start, the thread which performs
     * the animation.
     *
     * @param c The component we border.
     * @param insets The border size.
     **/    
    public AnimatedBorder( JComponent c, Insets insets ) { 
        super( insets );
        this.c = c;
        Thread animator = new Thread( this );
        animator.start();
    } 
    
    
    /**
     * Set the sleep time.  This is the cycle time
     * between animations.
     * This is a bound property.
     *
     * @param sleepTime The new animation cycle time.
     **/
    public void setSleepTime( int sleepTime ) { 
        
        Integer old = new Integer( this.sleepTime );
        this.sleepTime = sleepTime;

        changes.firePropertyChange( SLEEP_TIME_PROPERTY,
                        old, new Integer( this.sleepTime ) );
        
    }  // setSleepTime
    
    
    /**
     * @return The current cycle time.
     **/
    public int getSleepTime() { 
        return( this.sleepTime );
    } 
    
    
    /**
     * @return The component we border.
     **/
    public JComponent getBorderedComponent() { 
        return( c );
    } 
    
    
    /**
     * The animation thread.
     * Sleep the specified amount of time, then
     * repaint the bordered component.  This is an
     * expensive way to force the border to redraw.
     * If the animated borders are placed around
     * complex components, this can be an issue.
     **/
    public void run() { 
        
        while( true ) { 
            
            try { 
                Thread.sleep( sleepTime );

                //
                // Repaint is thread safe for Swing components.
                c.repaint();
            }  catch( InterruptedException ie ) { 
                // Don't care if interrupted.
            }             
        } 
    }  // run
    
    
    /**
     * Add the given listener to those receiving property change
     * notifications.
     *
     * @param l the PropertyChangeListener
     * @see #removePropertyChangeListener
     **/      
    public void addPropertyChangeListener( PropertyChangeListener l ) { 
        changes.addPropertyChangeListener( l );
    }  // addPropertyChangeListener


    /** 
     * Remove the given listener from those receiving property change
     * notifications.
     *
     * @param l the PropertyChangeListener
     * @see #addPropertyChangeListener
     **/      
public void removePropertyChangeListener(PropertyChangeListener l) { 
        changes.removePropertyChangeListener( l );
    }  // removePropertyChangeListener    
    
}  // AnimatedBorder
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first concrete extension of the <TT>AnimatedBorder</TT> class
is the <TT>ColorAnimatedBorder</TT>. This class paints a matte
type border in a different color each animation cycle. This can
be used to smoothly fade in or out a border color, or to grab
attention by starkly varying the border color. The array of colors
is created in the constructor. Each time the border is painted,
the next color in the array is used for the color of the border.
<P>
The constructor calls the <TT>makeColors</TT> method, which creates
the array of colors cycled through during the animation. This
class could be extended, and overriding the <TT>makeColors</TT>
method to create a different array of colors gives any color effect
desired. The complete source listing for the <TT>ColorAnimatedBorder</TT>
is given in Listing 5.2.<P>
<HR>
<P>
<B>Listing 5.2&nbsp;&nbsp;The </B><TT><B>COLORANIMATEDBORDER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.borders;

import java.awt.Insets;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Color;

import javax.swing.JComponent;

import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;


/**
 * ColorAnimatedBorder is a concrete AnimatedBorder.  It
 * paints the border a different color each animation cycle.
 *
 * @see AnimatedBorder
 * @see Border
 * @author Mike Foley
 **/
public class ColorAnimatedBorder extends AnimatedBorder { 
    
    /**
     * The colors used for the border.  The elements in this
     * array are stepped through, and drawn each cycle.
     **/
    protected Color[] colors = null;
    
    /**
     * The index of the next color to use when drawing the border.
     **/
    private int currentColorIndex = 0;
    
    
    /**
     * Constructor.
     * Create insets from the raw parameter and call our 
     * constructor taking Insets to do the work.
     *
     * @param c The component we border.
     * @param top The top border width.
     * @param left The left border width.
     * @param bottom The bottom border width.
     * @param right The right border width.
     **/
    public ColorAnimatedBorder( JComponent c, int top, int left,
                           int bottom, int right ) { 
        this( c, new Insets( top, left, bottom, right ) );
    } 
    
    
    /**
     * Constructor.
     * Make the colors used to paint the border.
     *
     * @param c The component we border.
     * @param insets The border size.
     **/    
    public ColorAnimatedBorder( JComponent c, Insets insets ) { 
        super( c, insets );
        colors = makeColors();
    } 
    
    
    /**
     * Make an array of colors that are stepped through during
     * the paintBorder methods.
     * If a great number of colors (thousands) are to be animated, 
     * it may better to create one color each paint cycle, and let the
     * GC free the colors when no longer needed.
     **/
    protected void makeColors() { 
        Color[] colors = new Color[ 20 ];
        int step = 12;
        
        for( int i = 0; i &lt; colors.length; i++ ) { 
            colors[ i ] = new Color( 100, 100, i * step );
        } 

        return( colors );

    }  // makeColors
    
    
    /**
     * Paint the border.
     * Get the color at the current color index.  Then update the index.
     * The index is wrapped, so that the array of colors repeat every
     * length of the array.
     *
     * @param c The bordered component.
* @param g The graphics to paint with.
     * @param x The X location of the bordered component.
     * @param y The Y location of the bordered component.
     * @param width The width of the bordered component.
     * @param height The height of the bordered component.
     **/
    public void paintBorder( Component c, Graphics g, int x,
                             int y, int width, int height ) { 
                             
        //
        // Save the current color so we can restore at end of method.
        //
        Color oldColor = g.getColor();
        
        g.translate( x, y );
        
        //
        // Set the color to paint with.  Increment the color index.
        // Wrap if needed.
        //
        Color color = colors[ currentColorIndex++ ];
        currentColorIndex %= colors.length;
        
        //
        // Get our size.
        //
        Insets insets = getBorderInsets( c );
   
        //
        // Paint the border.
        //
        g.setColor( color );
        g.fillRect( 0, 0, width - insets.right, insets.top );
        g.fillRect( 0, insets.top, insets.left, height - insets.top );
g.fillRect( insets.left, height - insets.bottom, 
                    width - insets.left, insets.bottom );
g.fillRect( width - insets.right, 0, 
                    insets.right, height - insets.bottom );
        
        //
        // Restore the Graphics object's state.
        //
        g.translate( -x, -y );
        g.setColor( oldColor );
        
    }  // paintBorder
    
}  // ColorAnimatedBorder
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The second child of the <TT>AnimatedBorder</TT> class is the <TT>ChaserLightsBorder</TT>
class. This class provides a border that mimics chaser lights.
The lights are drawn as simple circles whose diameters are the
border width. A single pixel is placed between each light. By
changing the direction property, the chasing direction can be
altered. The on and off color of the lights can be specified by
setting bound properties. The number of &quot;on&quot; lights
between the &quot;off&quot; chaser light is also a bound property.
Setting this property to <TT>2</TT> turns every other light on.
The complete source listing for the <TT>ChaserLightsBorder</TT>
class is given in Listing 5.3.<P>
<HR>
<P>
<B>Listing 5.3&nbsp;&nbsp;The </B><TT><B>CHASERLIGHTSBORDER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.borders;

import java.awt.Insets;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Color;

import javax.swing.JComponent;

import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;


/**
 * ChaserLightsBorder is a concrete AnimatedBorder.  It
 * paints the border as a chase light.
 *
 * @see AnimatedBorder
 * @see Border
 * @author Mike Foley
 **/
public class ChaserLightsBorder extends AnimatedBorder { 
        
    /**
     * The index of the next 'light' to be out
     * when drawing the border.
     **/
    private int currentLightIndex = 0;
    
    /**
     * The number of 'lights' to be on in a row
     **/
    private int onLightCount = 5;
    
    /**
     * The first off light index for this cycle.
     **/
    private int firstOffLightIndex = 0;
    
    /**
     * The color to draw on 'lights'
     **/
    private Color onLightColor = Color.yellow;
    
    /**
     * The color to draw off 'lights'
     **/
    private Color offLightColor = Color.white;
    
    /**
     * The direction of light travel.  True = forward.
     **/
    private boolean direction = true;
    
    /**
     * Bound property names.
     **/
    public static final String DIRECTION_PROPERTY = &quot;DirectionProperty&quot;;
public static final String ONLIGHTCOLOR_PROPERTY = 
                                                &quot;OnLightColorProperty&quot;;
    public static final String OFFLIGHTCOLOR_PROPERTY = 
                                                &quot;OffLightColorProperty&quot;;
    
    
    /**
     * Constructor.
     * Create insets from the raw parameter and call our 
     * constructor taking Insets to do the work.
     *
     * @param c The component we border.
     * @param top The top border width.
     * @param left The left border width.
     * @param bottom The bottom border width.
     * @param right The right border width.
     **/
    public ChaserLightsBorder( JComponent c, int top, int left,
                           int bottom, int right ) { 
        this( c, new Insets( top, left, bottom, right ) );
    } 
    
    
    /**
     * Constructor.
     * Call our super.  We don't do any additional processing.
     *
     * @param c The component we border.
     * @param insets The border size.
     **/    
    public ChaserLightsBorder( JComponent c, Insets insets ) { 
        super( c, insets );
    } 
    
    /**
     * Set the on light count of the chaser lights.  
     * This value is one greater than the number of lights 
     * on before the off light.  A value of two will give
     * every other light being off.  A value of one will give
     * all lights on, not very good.
     *
     * This is a bound property.
     *
     * @param onLightCount The new on light count.
     **/
    public void setOnLightCount( int onLightCount ) { 
        
        if( onLightCount &lt; 1 )
throw new IllegalArgumentException( 
                      &quot;Negative or zero onLightCount given&quot; );
            
        Integer old = new Integer( this.onLightCount );
        this.onLightCount = onLightCount;
        
        changes.firePropertyChange( ONLIGHTCOUNT_PROPERTY,
                            old, new Integer( this.onLightCount ) );
    }  // setOnLightCount
    
    
    /**
* @return The number of lights - 1 in a row between the off light.
     **/
    public int getOnLightCount() { 
        return( this.onLightCount );
    } 

                
    /**
     * Set the direction of the chaser lights.  True means
     * forward.
     * This is a bound property.
     *
     * @param direction The new direction of the chaser lights.
     **/
    public void setDirection( boolean direction ) { 
        
        Boolean old = new Boolean( this.direction );
        this.direction = direction;
        
        changes.firePropertyChange( DIRECTION_PROPERTY,
                            old, new Boolean( this.direction ) );
    }  // setDirection
    
    
    /**
     * @return The direction the chaser lights are going.
     **/
    public boolean getDirection() { 
        return( this.direction );
    } 
    
    
    /**
     * Set the color for 'on' lights.
     * This is a bound property.
     *
     * @param onLightColor The new color for 'on' lights.
     **/
    public void setOnLightColor( Color onLightColor ) { 
        
        Color old = this.onLightColor;
        this.onLightColor = onLightColor;
        
        changes.firePropertyChange( ONLIGHTCOLOR_PROPERTY,
                            old, this.onLightColor );

    }  // setOnLightColor
    
    
    /**
     * @return The color for 'on' lights.
     **/
    public Color getOnLightColor() { 
        return( this.onLightColor );
    } 
    

    /**
     * Set the color for 'off' lights.
     * This is a bound property.
     *
     * @param offLightColor The new color for 'off' lights.
     **/
    public void setOffLightColor( Color offLightColor ) { 
        
        Color old = this.offLightColor;
        this.offLightColor = offLightColor;
        
        changes.firePropertyChange( OFFLIGHTCOLOR_PROPERTY,
                            old, this.offLightColor );

    }  // setOffLightColor
    
    
    /**
     * @return The color for 'off' lights.
     **/
    public Color getOffLightColor() { 
        return( this.offLightColor );
    } 
    
    
    /**
     * Paint the border.
     * Get the color at the current color index.  Then update the index.
     * The index is wrapped, so that the array of colors repeat every
     * length of the array.
     *
     * @param c The bordered component.
     * @param g The graphics to paint with.
     * @param x The X location of the bordered component.
     * @param y The Y location of the bordered component.
     * @param width The width of the bordered component.
     * @param height The height of the bordered component.
     **/
    public void paintBorder( Component c, Graphics g, int x,
                             int y, int width, int height ) { 
                             
        //
        // Save the current color so we can restore at end of method.
        //
        Color oldColor = g.getColor();
        
        g.translate( x, y );
                
        //
        // Get our size.
        //
        Insets insets = getBorderInsets( c );
   
        //
        // Paint the border.
        // Set the current light index.  Start at 0.
        //
        currentLightIndex = 0;
        
        //
        // Top
        int xpos = 0;
        int ypos = 0;
        if( 0 &lt; insets.top ) { 
            do { 
                setGraphicsColor( g );
                g.fillOval( xpos, ypos, insets.top, insets.top );
                xpos += insets.top + 1;
            }  while( xpos &lt; width );
        } 
        
        //
        // Right
        xpos = width - insets.right;
        ypos = insets.top;
        if( 0 &lt; insets.right ) { 
            do { 
                setGraphicsColor( g );
                g.fillOval( xpos, ypos, insets.right, insets.right );
                ypos += insets.right + 1;            
            }  while( ypos &lt; height - 2 * insets.bottom );
        } 
        
        //
        // Bottom
        xpos = width - insets.right;
        ypos = height - insets.bottom;
        if( 0 &lt; insets.bottom ) { 
            do { 
                setGraphicsColor( g );
                g.fillOval( xpos, ypos, insets.bottom, insets.bottom );
                xpos -= insets.bottom + 1;            
            }  while( 0 &lt; xpos );
        } 
        
        //
        // Left
        xpos = 0;
        ypos = height - 2 * insets.bottom;
        if( 0 &lt; insets.left ) { 
            do { 
                setGraphicsColor( g );
                g.fillOval( xpos, ypos, insets.left, insets.left );
                ypos -= insets.left + 1;            
            }  while( 0 &lt; ypos - insets.top );
        } 

        //
        // Update the light off index.  If going forward, increment
        // else decrement.  Wrap the index as required.
        //
        if( direction ) { 
            firstOffLightIndex += 1;
            firstOffLightIndex %= onLightCount;
        }  else { 
            firstOffLightIndex -= 1;
            if( firstOffLightIndex &lt; 0 )
                firstOffLightIndex = onLightCount - 1;
        } 
        
        //
        // Restore the Graphics object's state.
        //
        g.translate( -x, -y );
        g.setColor( oldColor );
        
    }  // paintBorder


    /**
     * Set the color to draw the next light with.
     * We update the currentLight Index.  This index
     * must be reset each cycle.
     *
     * @param g The graphics used to paint.
     **/
    private void setGraphicsColor( Graphics g ) { 
        
        if( currentLightIndex % onLightCount == firstOffLightIndex ) { 
            g.setColor( offLightColor );
        }  else { 
            g.setColor( onLightColor );
        } 
        
        //
        // Update the currentLightIndex, wrap if required
        //
        currentLightIndex += 1;
        
    } 
    
}  // ChaserLightsBorder
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Very interesting visual effects can be created by using animated
borders. However, creating a thread for each border makes the
cost of these borders rather high. If multiple animated borders
are to be used in an application or applet, a single thread should
be used to control the animation in all of the animated borders.
<H3><A NAME="ACompletebutGaudyBorderExample">
A Complete but Gaudy Border Example</A></H3>
<P>
The previous sections provided code fragments demonstrating how
to create the various types of borders contained in the JFC. This
section applies those ideas in a complete example application.
The application is a somewhat silly <TT>JFrame</TT> extension
that displays many types of bordered components in its display
area. Listing 5.4 is the complete listing for the <TT>BorderTest</TT>
application. The results of running the application are shown
in Figure 5.11. The <TT>ImageLoader</TT> class, used to load <TT>Icons</TT>
for the borders, is presented in the next section. <TT>ExitAction</TT>,
used in the frame's menu, was presented in <A HREF="..\ch04\ch04.htm" >Chapter 4</A> &quot;JFC
Programming Techniques.&quot;<BR>
<P>
<A HREF="javascript:popUp('f5-11.gif')"><B>Figure 5.11:</B> <I>The complete BorderTest application</I>.</A>
<P>
<HR>
<P>
<B>Listing 5.4&nbsp;&nbsp;</B><TT><B>BORDERTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.borders.*;
import com.foley.utility.ExitAction;
import com.foley.utility.ImageLoader;


/**
 * An application that displays many borders
 * in its frame.
 *
 * @author Mike Foley
 **/
public class BorderTest extends JFrame { 

    public static BorderTest frame;

    private Icon checker;
    private Icon abbey;
    private Icon stop;
    public static Image bullseye;
    public static Image bullseye2;

    /**
     * BorderTest, null constructor.
     **/
    public BorderTest() { 
        this( null );
    }  // BorderTest


    /**
     * BorderTest, constructor.
     *
     * @param title The title for the frame.
     **/
    public BorderTest( String title ) { 
        super( title );
    }  // BorderTest


    /**
     * frameInit, from JFrame
     *
     * Create the contrent for this frame.
     **/
    protected void frameInit() { 
        
        //
        // Let our super create the content and associated panes.
        //
        super.frameInit();
        
        try { 
            //
            // Load the images used.
            //
            checker = ImageLoader.loadIcon( &quot;checker.gif&quot; );
            abbey = ImageLoader.loadIcon( &quot;abbey.gif&quot; );
            stop = ImageLoader.loadIcon( &quot;stop.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Could not load images&quot; );
            System.exit( -1 );
        } 
        
        JMenuBar menubar = createMenu();
        setJMenuBar( menubar );

        Container content = getContentPane();
        
        JPanel borders = createBorderPanel();
        JPanel animatedPanel = createAnimatedBorderPanel();
                          
        //
        // Add the border panels to the content.
        // 
        borders.setBorder( BorderFactory.createTitledBorder(
BorderFactory.createBevelBorder( BevelBorder.LOWERED ),
                            &quot;Simple Borders&quot; ) );
        content.add( borders, BorderLayout.EAST );
        
        animatedPanel.setBorder( BorderFactory.createTitledBorder(
                                BorderFactory.createLoweredBevelBorder(),
                                &quot;Animated Borders&quot; ) );
        content.add( animatedPanel, BorderLayout.WEST );
        
    }  // frameInit


    /**
     * Create the menu for the frame.
     *
     * @return The menu for the frame.
     **/
    protected JMenuBar createMenu() { 

        JMenuBar menubar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.add( new ExitAction() );
        menubar.add( file );

        return( menubar );

    }  // createMenu


    /**
     * Create a panel containing many 'simple' borders.
     *
     * @return A panel containing many borders around labels.
     **/
    protected JPanel createBorderPanel() { 
        
        JPanel simpleBorders = new JPanel();
        simpleBorders.setLayout( new BoxLayout(
simpleBorders, BoxLayout.Y_AXIS ) );

        int strutHeight = 10;
        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel lineBorder = new JLabel( &quot;Line Border&quot; );
        Border border = BorderFactory.createLineBorder( Color.blue, 5 );
        lineBorder.setBorder( border );
        simpleBorders.add( lineBorder );
        
        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel lowBevelBorder = new JLabel( &quot;Lowered Bevel Border&quot; );
        border = BorderFactory.createBevelBorder( BevelBorder.LOWERED );
        lowBevelBorder.setBorder( border );
        simpleBorders.add( lowBevelBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel raisedBevelBorder = new JLabel( &quot;Raised Bevel Border&quot; );
        border = BorderFactory.createBevelBorder( BevelBorder.RAISED );
        raisedBevelBorder.setBorder( border );
        simpleBorders.add( raisedBevelBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel softBevelBorder = new JLabel( &quot;Soft Bevel Border&quot; );
        border = new SoftBevelBorder( BevelBorder.RAISED );
        softBevelBorder.setBorder( border );
        simpleBorders.add( softBevelBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        softBevelBorder = new JLabel( &quot;Soft Bevel Border&quot; );
        border = new SoftBevelBorder( BevelBorder.LOWERED );
        softBevelBorder.setBorder( border );
        simpleBorders.add( softBevelBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );

        JLabel ourcolorBevelBorder = new JLabel( &quot;Color Bevel Border&quot; );
        border = BorderFactory.createBevelBorder( BevelBorder.LOWERED, 
                                Color.blue, Color.red, 
                                Color.yellow, Color.gray );
        ourcolorBevelBorder.setBorder( border );
        simpleBorders.add( ourcolorBevelBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );

        JLabel etchedBorder = new JLabel( &quot;Etched Border&quot; );
        border = BorderFactory.createEtchedBorder();
        etchedBorder.setBorder( border );
        simpleBorders.add( etchedBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel emptyBorder = new JLabel( &quot;Empty Border&quot; );       
        border = BorderFactory.createEmptyBorder();        
        emptyBorder.setBorder( border );
        simpleBorders.add( emptyBorder );
        
        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        JLabel matteBorder = new JLabel( &quot;Matte Border&quot; );       
        border = BorderFactory.createMatteBorder(5, 5, 5, 5, Color.blue);
        matteBorder.setBorder( border );
        simpleBorders.add( matteBorder );
        
        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );

        JLabel checkerBorder = new JLabel( &quot;Matte Border&quot; );
        border = BorderFactory.createMatteBorder( 4, 4, 4, 4, checker );
        checkerBorder.setBorder( border );
        simpleBorders.add( checkerBorder );
        
        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
        
        simpleBorders.add( new JSeparator() );

        JLabel compondBorder = new JLabel( &quot;Compound Matte Border&quot; );
        border = BorderFactory.createCompoundBorder( 
            BorderFactory.createMatteBorder( 4, 4, 4, 4, checker ),
            BorderFactory.createEmptyBorder( 4, 4, 4, 4 ) );
        compondBorder.setBorder( border );
        simpleBorders.add( compondBorder );

        JLabel abbeyBorder = new JLabel( &quot;Abbey Road Border&quot; );
        border = BorderFactory.createCompoundBorder( 
            BorderFactory.createMatteBorder( 4, 6, 4, 6, abbey ),
            BorderFactory.createEmptyBorder( 4, 4, 5, 4 ) );
        abbeyBorder.setBorder( border );
        simpleBorders.add( abbeyBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );

        compondBorder = new JLabel( &quot;Compound Bevel Border&quot; );
        border = BorderFactory.createCompoundBorder( 
            BorderFactory.createBevelBorder( BevelBorder.LOWERED ),
            BorderFactory.createMatteBorder( 4, 4, 4, 4, checker ) );
        border = BorderFactory.createCompoundBorder( 
            border,
            BorderFactory.createBevelBorder( BevelBorder.RAISED ) );
        border = BorderFactory.createCompoundBorder( 
            border,
            BorderFactory.createEmptyBorder( 2, 2, 2, 2 ) );
            
        compondBorder.setBorder( border );
        simpleBorders.add( compondBorder );

        simpleBorders.add( Box.createVerticalStrut( strutHeight ) );
    
          return( simpleBorders );
    } 

    /**
     * Create a panel containing many animated borders.
     *
     * @return A panel containing many animated borders.
     **/
    protected JPanel createAnimatedBorderPanel() { 
        
        JPanel animatedPanel = new JPanel();
        animatedPanel.add( new JLabel( &quot;Animated&quot; ) );
        animatedPanel.setLayout( 
                 new BoxLayout( animatedPanel, BoxLayout.Y_AXIS ) );
        JLabel animated = new JLabel( &quot;Color Animator&quot; );
        animated.setBorder( 
                 new ColorAnimatedBorder( animated, 6, 6, 6, 6 ) );
        animatedPanel.add( animated );
        animatedPanel.add( new JSeparator() );
        animated = new JLabel( &quot;Chaser Animator&quot; );
        animated.setBorder( 
                 new ChaserLightsBorder( animated, 6, 6, 6, 6 ) );
        animatedPanel.add( animated );

        return( animatedPanel );
        
    } 
        
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String[] args ) { 

        JFrame frame = new BorderTest( &quot;Border Test&quot; );
        frame.pack();
        frame.setVisible( true );
    }  // main

}  // BorderTest
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Icons">
Icons</A></H2>
<P>
In the AWT, bitmap graphics were drawn by using the <TT>Image</TT>
class. In the JFC, components that use bitmap graphics require
a class that implements the <TT>Icon</TT> interface. Thus, in
the JFC, icons replace images for component decorations. However,
the methods typically used to load or create a bitmap are the
<TT>Toolkit</TT> image methods, which still return an image. To
aid in this conversion, the JFC provides the <TT>ImageIcon</TT>
class.
<H3><A NAME="TTFONTSIZEIconFONTTTFONTSIZEInterfaceFONT">
<TT>Icon</TT> Interface
</A></H3>
<P>
The <TT>Icon</TT> interface defines the methods that define an
icon. Any class can implement this interface and be used wherever
an icon is wanted.
<P>
The methods defined in the <TT>Icon</TT> interface are used to
query the size of the icon and to do the actual icon rendering.
The following shows these methods in the <TT>Icon</TT> interface.
<BLOCKQUOTE>
<PRE>
public interface Icon 
{ 
    public abstract void paintIcon(Component c, Graphics g, int x, int y)
    public abstract int getIconWidth();
    public abstract int getIconHeight();
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TTFONTSIZEImageIconFONTTTFONTSIZEClassFONT">
<TT>ImageIcon</TT> Class
</A></H3>
<P>
The <TT>ImageIcon</TT> class is the <TT>Icon</TT> workhorse class
in the JFC. This class contains constructors to create an icon
from a file, URL, byte array, or an <TT>Image</TT>. The image
can be set after creation to a new <TT>Image</TT> instance. The
class also contains a method to obtain the image from the class.
This provides a conversion between images and icons. A description
can be specified with the image.
<P>
Listing 5.5 presents a utility class that can be used to load
images and create icons. Since the <TT>ImageIcon</TT> class implements
the <TT>Icon</TT> interface, it can be used for creating icons.
The <TT>ImageLoader</TT> class extends <TT>Component</TT>. This
allows it to be an <TT>ImageObserver</TT> during image loading.
The class contains two static methods for image manipulation.
The first, <TT>loadImage</TT>, attempts to load an image contained
in the named resource. The method tries to get a URL to the resource.
This allows the method to find images in JAR files as well as
from a file system. If the resource is found, a <TT>MediaTracker</TT>
is used to load the image. The method waits for the image to load,
so the calling code can use the image immediately. The <TT>loadImage</TT>
method returns an image. 
<P>
The second static method, <TT>loadIcon</TT>, returns an icon.
This method is used more in JFC programming. The <TT>loadIcon</TT>
method calls the <TT>loadImage</TT> method to load the requested
image. If the image is successfully loaded, an <TT>ImageIcon</TT>
is created from the image. Because <TT>ImageIcon</TT> implements
<TT>Icon</TT>, returning the <TT>ImageIcon</TT> is, in effect,
returning an icon. The <TT>ImageLoader</TT> class is used in the
border example application presented in the last section and shown
in Listing 5.4. 
<P>
If the image is stored in a file and loaded from an application,
or if the URL pointing to the image data is already created, the
<TT>ImageIcon</TT> class itself can be used to load the image.
This is done by passing the filename or URL to the constructor
of the <TT>ImageIcon</TT> class. During construction, the <TT>ImageIcon</TT>
class will load the image by using a <TT>MediaTracker</TT>. This
ensures that the image is available after the constructor has
completed.<P>
<HR>
<P>
<B>Listing 5.5&nbsp;&nbsp;</B><TT><B>IMAGELOADER</B></TT><B>
Class for Loading Images and Creating Icons<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * A class containing static methods which can
 * be used to load Images and Icons. This class will
 * find the named resource in the local file system,
 * or a jar file, specified in the CLASSPATH.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class ImageLoader extends Component { 
    private static ImageLoader imageLoader;
    
    /**
     * ImageLoader, constructor.
     * &lt;p&gt;
     * There should not be any instances of this
     * class created outside the private one used
     * in the class.
     **/
    private ImageLoader() { 
        super();
    } 
    
    
    /**
     * loadImage
     * &lt;p&gt;
     * Load the image with the given name.
     * &lt;p&gt;
     * @param imageName The name of the image to load.
     * @return The Image for the image with the given name.
     * @see #loadIcon
     **/
    public static Image loadImage( String imageName ) 
        throws java.lang.InterruptedException { 
        
        //
        // get the image, and wait for it to be loaded.
        //
        URL url = Object.class.getResource( imageName );
        
        //
             // If the URL could not be located above, try
              // prepending a '/' to the image's ResourceName. This
              // will cause the search to begin at the top of the
              // CLASSPATH.
              //
          if( url == null )
                  url = Object.class.getResource( &quot;/&quot; + imageName );
        if( url == null ) { 
RuntimeException e = new RuntimeException( 
                                   &quot;Image &quot; + imageName + &quot; not found&quot; );
            e.printStackTrace();
            throw e;
        } 
        
           //
           // get the image, and wait for it to be loaded.
        //
        Image image = Toolkit.getDefaultToolkit().getImage( url );
        MediaTracker tracker = new MediaTracker( imageLoader );
        tracker.addImage( image, 0 );
        tracker.waitForID( 0 );

        return( image );
        
    }  // loadImage

    
    /**
     * loadIcon
     * &lt;p&gt;
     * Load the Icon with the given name.
     * &lt;p&gt;
     * @param imageName The name of the image to load.
     * @return The Icon for the image with the given name.
     * @see #loadImage
     **/
    public static Icon loadIcon( String imageName ) 
        throws java.lang.InterruptedException { 
        
        Image image = loadImage( imageName );
        return( new ImageIcon( image ) );
        
    }  // loadIcon


    /**
     * static initialization.
     * &lt;p&gt;
     * Create an instance of this class that can be
     * used as the parameter to the MediaTracker while
     * loading images.
     **/
    static { 
        imageLoader = new ImageLoader();
    }  // static
    
}  // ImageLoader
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TTFONTSIZEGrayFilterFONTTTFONTSIZEClassFONT">
<TT>GrayFilter</TT> Class
</A></H3>
<P>
The <TT>GrayFilter</TT> class is a utility class used to create
grayed out versions of images. This class is an extension of the
AWT class <TT>RGBImageFilter</TT>.
<P>
In the JFC, the <TT>GrayFilter</TT> class is used in components
containing icons. If a disabled image is not specified, the component
creates an image from the normal image to use when the component
is disabled. Calling the static <TT>createDisabledImage</TT> method
contained in this class performs this function.
<P>
The following code fragment creates a disabled icon from an image.
Notice that the <TT>createDisabledImage</TT> takes an image and
returns an image. As in the previous section, an <TT>ImageIcon</TT>
is created from the image and used wherever an icon is required.
The <TT>createDisabledImage</TT> method is used internally by
Swing components, but can also be used by any class to create
grayed out images.
<BLOCKQUOTE>
<PRE>
Icon disabledIcon = new ImageIcon( 
                        GrayFilter.createDisabledImage( myImage ) );
</PRE>
</BLOCKQUOTE>
<H2><A NAME="LabelComponents">
Label Components</A></H2>
<P>
The JFC contains many components that contain a label. This section
presents the simple labeled components. You will learn how to
do the following:
<UL>
<LI>Create labels
<LI>Position the text in labels
<LI>Add images to labels
<LI>Position the text relative to the image
</UL>
<H3><A NAME="TheTTFONTSIZEJLabelFONTTTFONTSIZEClassFONT">
The <TT>JLabel</TT> Class
</A></H3>
<P>
The <TT>JLabel</TT> class extends <TT>JComponent</TT>. It provides
a display area for text, an icon, or both. The <TT>JLabel</TT>
class does not respond to input events and cannot obtain the input
focus.
<P>
The most common use for the <TT>JLabel</TT> class is to display
a single line of text. A <TT>JLabel</TT> can be created with a
<TT>String</TT> parameter for this purpose as shown in the following:
<P>
<TT>JLabel label = new JLabel( &quot;Text
on label&quot; );</TT>
<P>
This label will be left aligned and horizontally centered in its
display area. The horizontal alignment can be specified at construction
time as shown in the following line of code:
<P>
<TT>JLabel label = new JLabel( &quot;Text
on label&quot;, SwingConstants.CENTER );</TT>
<P>
This will create a horizontally centered label. Other possible
horizontal alignments are <TT>SwingConstants.LEFT</TT>, <TT>SwingConstants.LEADING</TT>,
<TT>SwingConstants.RIGHT</TT>, and <TT>SwingConstants.TRAILING</TT>.
The horizontal alignment can be set after creation with the <TT>setHorizontalAlignment</TT>
method and passing it the desired alignment. The horizontal alignment
is a bound property named <TT>horizontalAlignment</TT>. Notice
how the <TT>JLabel</TT> class takes advantages of the constants
in the <TT>SwingConstants</TT> interface rather than defining
the constants in the <TT>JLabel</TT> class itself. This is inconsistent
with what you saw in the <TT>TitledBorder</TT> class presented
in the previous section. The horizontal alignment can be queried
with the <TT>getHorizontalAlignment</TT> method. It is also unfortunate
that the property names in <TT>JLabel</TT> are not class constants.
Instead, they are hard coded into the source code.
<P>
The vertical alignment can be set with <TT>setVerticalAlignment</TT>.
Possible alignments are <TT>SwingConstants.TOP</TT>, <TT>SwingConstants.BOTTOM</TT>,
and the default, <TT>SwingConstants.CENTER</TT>. The vertical
alignment can only be set after the label is created. There is
not a version of the constructor with a vertical alignment parameter.
The vertical alignment is a bound property named <TT>verticalAlignment</TT>.
The vertical alignment can be queried using the <TT>getVerticalAlignment</TT>
method.
<P>
The application presented in Listing 5.6 creates a panel containing
<TT>JLabel</TT> instances with the possible combinations for vertical
and horizontal text positions. The application simply creates
the <TT>JLabel</TT> instances and sets the appropriate properties.
The labels are arranged in a 4 <FONT FACE="Symbol">&#180;</FONT>
4 grid where the first column and top rows are labels for the
position of the text. An AWT <TT>GridLayout</TT> layout manager
is used for creating the grid. This ensures that each cell is
the same size. A strut is used for the 0,0 position in the grid
that does not contain a label. The resulting frame is presented
in Figure 5.12. As can be seen from the figure, the <TT>JLabel</TT>
is very flexible with the text alignment.
<P>
<A HREF="javascript:popUp('f5-12.gif')"><B>Figure 5.12:</B> <I>The LabelTest application results</I>.</A>
<P>
<HR>
<P>
<B>Listing 5.6&nbsp;&nbsp;</B><TT><B>LABELTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays possible label placement
 * in a frame.
 *
 * @author Mike Foley
 **/
public class LabelTest extends Object { 

    /**
     * Create a panel containing possible label positions.
     *
     * @return A panel containing many titled borders.
     **/
    protected static JPanel createLabelPanel() { 
        
        //
        // Labels
        //
        int strutHeight = 10;
        JPanel labelPanel = new JPanel();
        labelPanel.setLayout( new GridLayout( 4, 4 ) );

        labelPanel.add( Box.createVerticalStrut( strutHeight ) );
        JLabel title = new JLabel( &quot;TOP&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelPanel.add( title );
        title = new JLabel( &quot;CENTER&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelPanel.add( title );
        title = new JLabel( &quot;BOTTOM&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelPanel.add( title );
        
        title = new JLabel( &quot;RIGHT&quot;, SwingConstants.RIGHT );
        labelPanel.add( title );
        title = new JLabel( &quot;Top Right&quot;, SwingConstants.RIGHT );
        title.setVerticalAlignment( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Center Right&quot;, SwingConstants.RIGHT );
        title.setVerticalAlignment( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Bottom Right&quot;, SwingConstants.RIGHT );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelPanel.add( title );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        
        
        title = new JLabel( &quot;CENTER&quot;, SwingConstants.RIGHT );
        labelPanel.add( title );
        title = new JLabel( &quot;Top Center&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Center Center&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Bottom Center&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        
        
        title = new JLabel( &quot;LEFT&quot;, SwingConstants.RIGHT );
        labelPanel.add( title );
        title = new JLabel( &quot;Top Left&quot;, SwingConstants.LEFT );
        title.setVerticalAlignment( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Center Left&quot;, SwingConstants.LEFT );
        title.setVerticalAlignment( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
        title = new JLabel( &quot;Bottom Left&quot;, SwingConstants.LEFT );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelPanel.add( title );
                  
        return( labelPanel );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;Label Position Test&quot; );
        
        JPanel labels = createLabelPanel();                 
        
        //
        // Add the border panels to the content.
        // 
        labels.setBorder( BorderFactory.createTitledBorder(
                    BorderFactory.createBevelBorder(BevelBorder.LOWERED),
                    &quot;Label Positions&quot; ) );
                            
        frame.getContentPane().add( labels, BorderLayout.CENTER );
                
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // LabelTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The text displayed in the <TT>JLabel</TT> can be altered after
construction using the <TT>setText</TT> method. The <TT>JLabel</TT>
text is the bound property named <TT>text</TT>. The text can be
queried with the <TT>getText</TT> method.
<P>
The <TT>JLabel</TT> class is a descendant of the AWT <TT>Component</TT>
class. <TT>JLabel</TT> inherits methods for setting the foreground
and background colors and the font with which to display the label.
However, <TT>JLabel</TT>, as with all the JFC components, inherits
from <TT>JComponent</TT>. As described in the <TT>JComponent</TT>
chapter, these are lightweight components. Thus, the default behavior
of <TT>JLabel</TT> is to not draw its background. The background
of its container is used instead. The side effect of this is that
setting the background color of a label has no effect. To force
the <TT>JLabel</TT> class to paint with the background color specified,
the label must be made opaque. Calling the <TT>setOpaque</TT>
method with a parameter of <TT>true</TT> does this. The current
opaque setting can be queried with the <TT>isOpaque</TT> method.
The opaque setting for the <TT>JLabel</TT> is a bound property
named <TT>opaque</TT>. The <TT>setFont</TT> method is overridden
to force the label to be repainted after the font changes. This
allows setting the font to behave consistently with setting other
label properties that repaint the label after their value changes.
<H4>Adding an Image</H4>
<P>
As was mentioned in the introduction to this section, a <TT>JLabel</TT>
can display an icon as well as a string. The icon can be specified
in the <TT>JLabel</TT> constructor or set later using the <TT>setIcon</TT>
method. The icon is the bound property named <TT>icon</TT>.
<P>
The following code demonstrates creating a <TT>JLabel</TT> with
an icon.
<P>

<TT>JLabel iconLabel = new JLabel( myIcon
);</TT>
<P>
As with a <TT>JLabel</TT> containing a string, the icon's alignment
can be specified. The default alignment for the icon-only <TT>JLabel</TT>
is to center the icon both horizontally and vertically in its
display space. The same alignment methods presented in the previous
section for string-only labels apply to icon labels. For example,
the following code fragment will create a <TT>JLabel</TT> containing
an icon in the bottom-right portion of the <TT>JLabel</TT>'s display
area.
<BLOCKQUOTE>
<PRE>
JLabel iconLabel = new JLabel( myIcon, SwingConstants.RIGHT );
iconLabel.setVerticalAlignment( SwingConstants.BOTTOM );
</PRE>
</BLOCKQUOTE>
<P>
A single <TT>JLabel</TT> can contain both an icon and a string.
Both the icon and string can be specified at construction, as
shown in the following code fragment. Either the string or icon
can be specified after creation with the <TT>setIcon</TT> or <TT>setText</TT>
method, respectively.
<P>
<TT>JLabel label = new JLabel( &quot;Test&quot;,
myIcon, SwingConstants.RIGHT );</TT>
<P>
This label will use the default string-to-icon placement, which
is to place the string to the right of the icon. A default gap
of four pixels is placed between the text and the image. However,
the positioning property can be altered with the <TT>setHorizontalTextPosition</TT>
method. The possible values-<TT>RIGHT</TT>, <TT>CENTER</TT>, <TT>LEFT</TT>,
<TT>LEADING</TT>, and <TT>TRAILING</TT>-are defined in the <TT>SwingConstants</TT>
interface. This is a bound property name-<TT>horizontalTextPosition</TT>.
The current value of this property can be queried with the <TT>getHorizontalTextPosition</TT>
method.
<P>
Similarly, the vertical position of the text relative to the icon
can be specified with the <TT>setVerticalTextPosition</TT> method.
Possible values for this property-<TT>TOP</TT>, <TT>CENTER</TT>,
and <TT>BOTTOM</TT>-are defined in the <TT>SwingConstants</TT>
interface. The vertical text position is a bound property named
<TT>verticalTextPosition</TT>. The current value of this property
can be queried with the <TT>getVerticalTextPosition</TT> method.
<P>
The gap between the icon and string can be specified with the
<TT>setIconTextGap</TT> method. This method will set the distance
between the icon and the string to the given number of pixels.
The distance between the icon and the string is a bound property
named <TT>iconTextGap</TT>. As previously mentioned, the default
value for this property is four pixels.
<P>
The alignment properties, previously described for a label containing
text, move the text and icon as a unit. Setting the <TT>horizontalAlignment</TT>
and <TT>verticalAlignment</TT> properties allows the text and
icon to be positioned in the label. 
<P>
The application presented in Listing 5.7 creates a panel containing
<TT>JLabel</TT> instances with the various text-to-icon placements
specified. This application follows the same general structure
as the application in the previous section. The difference is
that icons are added to each label, and the text-to-icon placement
is specified. The resulting display is shown in Figure 5.13. In
this example, the horizontal alignment for each label is <TT>CENTER</TT>.
<BR>
<P>
<A HREF="javascript:popUp('f5-13.gif')"><B>Figure 5.13:</B> <I>The LabelAndIconTest application result</I>.</A>
<P>
<HR>
<P>
<B>Listing 5.7&nbsp;&nbsp;</B><TT><B>LABELANDICONTEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;
import com.foley.utility.ImageLoader;


/**
 * An application that displays possible label placement
 * in its frame.
 *
 * @author Mike Foley
 **/
public class LabelAndIconTest extends Object { 

    private static Icon stop;
    
    
    /**
     * Create a panel containing possible label positions.
     *
     * @return A panel containing many titled borders.
     **/
    private static JPanel createLabelAndIconPanel() { 
        
        //
        // Labels and icons.
        //
        int strutHeight = 3;
        strutHeight = 10;
        JPanel labelAndIcon = new JPanel();
        labelAndIcon.setLayout( new GridLayout( 4, 4 ) );

        labelAndIcon.add( Box.createVerticalStrut( strutHeight ) );
        JLabel title = new JLabel( &quot;TOP&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelAndIcon.add( title );
        title = new JLabel( &quot;CENTER&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelAndIcon.add( title );
        title = new JLabel( &quot;BOTTOM&quot;, SwingConstants.CENTER );
        title.setVerticalAlignment( SwingConstants.BOTTOM );
        labelAndIcon.add( title );
        
        title = new JLabel( &quot;RIGHT&quot;, SwingConstants.RIGHT );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Top Right&quot;, stop, SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.RIGHT );
        title.setVerticalTextPosition( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Center Right&quot;, stop, 
                            SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.RIGHT );
        title.setVerticalTextPosition( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Bottom Right&quot;, stop, 
                            SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.RIGHT );
        title.setVerticalTextPosition( SwingConstants.BOTTOM );
        labelAndIcon.add( title );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        
        
        title = new JLabel( &quot;CENTER&quot;, SwingConstants.RIGHT );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Top Center&quot;, stop, SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.CENTER );
        title.setVerticalTextPosition( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Center Center&quot;, stop, 
                            SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.CENTER );
        title.setVerticalTextPosition( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Bottom Center&quot;, stop, 
                            SwingConstants.CENTER );
        title.setHorizontalTextPosition( SwingConstants.CENTER );
        title.setVerticalTextPosition( SwingConstants.BOTTOM );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        
        
        title = new JLabel( &quot;LEFT&quot;, SwingConstants.RIGHT );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Top Left&quot;, stop, SwingConstants.LEFT );
        title.setHorizontalTextPosition( SwingConstants.LEFT );
        title.setVerticalTextPosition( SwingConstants.TOP );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Center Left&quot;, stop, SwingConstants.LEFT );
        title.setHorizontalTextPosition( SwingConstants.LEFT );
        title.setVerticalTextPosition( SwingConstants.CENTER );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
        title = new JLabel( &quot;Bottom Left&quot;, stop, SwingConstants.LEFT );
        title.setHorizontalTextPosition( SwingConstants.LEFT );
        title.setVerticalTextPosition( SwingConstants.BOTTOM );
        title.setBorder( BorderFactory.createLineBorder( Color.black ) );
        labelAndIcon.add( title );
                  
        return( labelAndIcon );
        
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, label panel,
     * and display them.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 
       
        try { 
            //
            // Load the images used.
            //
            stop = ImageLoader.loadIcon( &quot;stop.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            System.exit( -1 );
        } 
                
        JFrame frame = new ApplicationFrame( 
                           &quot;Label to Icon Position Test&quot; );
        
        JPanel labels = createLabelAndIconPanel();
          
        //
        // Add the border panels to the content.
        // 
        labels.setBorder( BorderFactory.createTitledBorder(
                            BorderFactory.createBevelBorder( 
                                          BevelBorder.LOWERED ),
                            &quot;Label to Icon Positions&quot; ) );
        frame.getContentPane().add( labels, BorderLayout.CENTER );

        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // LabelAndIconTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
A separate icon can be specified for use when the label is disabled.
Because an instance of the <TT>JLabel</TT> class cannot acquire
input focus, the exact definition of a disabled label is somewhat
vague. However, the <TT>JLabel</TT> class is a descendant from
the AWT <TT>Component</TT> class, so it can be enabled and disabled
with the <TT>setEnabled</TT> method. If an icon has been specified
by using the <TT>setDisabledIcon</TT> method, this icon will be
drawn when the label is disabled. If a disabled icon has not been
specified and an icon has been specified, a disabled icon will
be created with the <TT>GrayFilter</TT> class previously described.
<P>
When creating user interfaces, a label is often used in conjunction
with another component. For example, a label is used to describe
the data to be entered into a text field in a form display. The
<TT>JLabel</TT> class contains two methods that work in tandem
and specify a mnemonic and an associated component for the label.
When the mnemonic is activated, the input focus is requested for
the associated component. The <TT>setDisplayedMnemonic</TT> method
is used to set the mnemonic for the label. A character or keycode
can be passed to this method. The <TT>setLabelFor</TT> method
specifies the component that is to receive focus when the mnemonic
is activated. Both properties must be set with non-<TT>null</TT>
values for this behavior to be active. These are both bound properties,
named <TT>labelFor</TT> and <TT>displayedMnemonic</TT>, respectively.
The current value for the properties can be queried with the <TT>getLabelFor</TT>
and <TT>getDisplayedMnemonic</TT> methods. In the <TT>setLabelFor</TT>
method, if the associated component is a descendant of the <TT>JComponent</TT>
class, the label sets itself as the <TT>labeledBy</TT> client
property of the component. This allows the component to check
if a label has been set for it.
<P>
The previous paragraphs presented the bound properties contained
in the <TT>JLabel</TT> class. Table 5.1 summarizes these properties.
The Swing visual components are JavaBean-compliant, and the property
setter and getter methods conform to the Bean property naming
convention. There are not constants defined for the property names
at the current time. The property names are hard coded in the
JFC source code. If you find that a listener is not receiving
a property notification when you think it should, make sure you
do not have a typo in the property name. The compiler could perform
this type of check for you if the names were defined as constants.
This is an unfortunate situation that hopefully will be rectified
in the future. As you will see in the next chapter, these properties
are also available for the buttons contained in the JFC.<BR>
<P>
<CENTER><B>Table 5.1&nbsp;&nbsp;</B><TT><B>JLABEL</B></TT><B>
Class Bound Properties</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=148><B>Property Name</B></TD><TD WIDTH=148><B>Setter Method</B>
</TD><TD WIDTH=148><B>Getter Method</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>Text</TT></TD><TD WIDTH=148><TT>setText</TT>
</TD><TD WIDTH=148><TT>getText</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>Icon</TT></TD><TD WIDTH=148><TT>setIcon</TT>
</TD><TD WIDTH=148><TT>getIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>DisabledIcon</TT></TD><TD WIDTH=148><TT>setDisabledIcon</TT>
</TD><TD WIDTH=148><TT>getDisabledIcon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>DisplayedMnemonic</TT></TD><TD WIDTH=148><TT>setDisplayedMnemonic</TT>
</TD><TD WIDTH=148><TT>getDisplayedMnemonic</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>Opaque</TT></TD><TD WIDTH=148><TT>setOpaque</TT>
</TD><TD WIDTH=148>&nbsp;</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>IconTextGap</TT></TD><TD WIDTH=148><TT>setIconTextGap</TT>
</TD><TD WIDTH=148><TT>getIconTextGap</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>VerticalAlignment</TT></TD><TD WIDTH=148><TT>setVerticalAlignment</TT>
</TD><TD WIDTH=148><TT>getVerticalAlignment</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>HorizontalAlignment</TT></TD><TD WIDTH=148><TT>setHorizontalAlignment</TT>
</TD><TD WIDTH=148><TT>getHorizontalAlignment</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>HorizontalTextPosition</TT></TD><TD WIDTH=148><TT>setHorizontalTextPosition</TT>
</TD><TD WIDTH=148><TT>getHorizontalTextPosition</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>VerticalTextPosition</TT></TD><TD WIDTH=148><TT>setVerticalTextPosition</TT>
</TD><TD WIDTH=148><TT>getVerticalTextPosition</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT>LabelFor</TT></TD><TD WIDTH=148><TT>setLabelFor</TT>
</TD><TD WIDTH=148><TT>getLabelFor</TT></TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
This chapter presented the basic components contained in the JFC.
Borders provide a means of grouping other components and adding
interesting visuals. The JFC contains the <TT>BorderFactory</TT>
class that is used to create a border. The <TT>Icon</TT> interface
and <TT>ImageIcon</TT> class were presented for bitmap graphic
manipulation. Labels are used in many user interface situations.
The <TT>JLabel</TT> class addressed one of the limitations of
the AWT, an easy component with which to display images. Instances
of the <TT>JLabel</TT> class can contain text and an icon. The
methods for placing the text and icon were presented. A label
can have a mnemonic and a component associated with it. When the
mnemonic is activated, the label will request the input focus
for the associated component.

<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch04\ch04.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch06\ch06.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
