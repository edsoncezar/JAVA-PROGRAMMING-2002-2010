<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Thu, Mar 11, 1999 12:16 PM-->
<HTML>
<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">
	<META NAME="Author" Content="Steph Mineart">
	<TITLE>JFC -- Appendix C - com.foley. utility Source Code</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">
<H1 ALIGN="CENTER"><IMG SRC="..\button\sams.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0"></H1>
<H1 ALIGN="CENTER">JFC Unleashed</H1>
<H1 ALIGN="CENTER"><A HREF="..\apb\apb.htm"><IMG SRC="..\button\previous.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\index.htm"><IMG SRC="..\button\contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A></H1>
<CENTER>
<P>
<HR>
</CENTER>
<H1 ALIGN="CENTER">Appendix&nbsp;C<BR>
com.foley. utility Source Code</H1>
<P>
<UL>
	<LI><A HREF="#TTFONTSIZEAButtonjavaFONTTT"><TT>AButton.java</TT></A>
	<LI><A HREF="#TTFONTSIZEActionFocusListenerjavaFONTTT"><TT>ActionFocusListener.java</TT></A>
	<LI><A HREF="#TTFONTSIZEAlbumCollectionItemjavaFONTTT"><TT>AlbumCollectionItem.java</TT></A>
	<LI><A HREF="#TTFONTSIZEAlbumTreeRendererjavaFONTTT"><TT>AlbumTreeRenderer.java</TT></A>
	<LI><A HREF="#TTFONTSIZEAlbumTypesjavaFONTTT"><TT>AlbumTypes.java</TT></A>
	<LI><A HREF="#TTFONTSIZEApplicationFramejavaFONTTT"><TT>ApplicationFrame.java</TT></A>
	<LI><A HREF="#TTFONTSIZEApplicationMouseListenerjavaFONTTT"><TT>ApplicationMouseListener.java</TT></A>
	<LI><A HREF="#TTFONTSIZEColorEditorjavaFONTTT"><TT>ColorEditor.java</TT></A>
	<LI><A HREF="#TTFONTSIZEExitActionjavaFONTTT"><TT>ExitAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZEFPartialEtchedBorderjavaFONTTT"><TT>FPartialEtchedBorder.java</TT></A>
	<LI><A HREF="#TTFONTSIZEImageLoaderjavaFONTTT"><TT>ImageLoader.java</TT></A>
	<LI><A HREF="#TTFONTSIZEJavaFileViewjavaFONTTT"><TT>JavaFileView.java</TT></A>
	<LI><A HREF="#TTFONTSIZEJBoxjavaFONTTT"><TT>JBox.java</TT></A>
	<LI><A HREF="#TTFONTSIZEMDIFramejavaFONTTT"><TT>MDIFrame.java</TT></A>
	<LI><A HREF="#TTFONTSIZEMetalNonExpandingTreeUIjavaFONTTT"><TT>MetalNonExpandingTreeUI.java</TT></A>
	<LI><A HREF="#TTFONTSIZENonExpandingTreeUIjavaFONTTT"><TT>NonExpandingTreeUI.java</TT></A>
	<LI><A HREF="#TTFONTSIZENoOpActionjavaFONTTT"><TT>NoOpAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZEOutlandishThemejavaFONTTT"><TT>OutlandishTheme.java</TT></A>
	<LI><A HREF="#TTFONTSIZEPercentSliderjavaFONTTT"><TT>PercentSlider.java</TT></A>
	<LI><A HREF="#TTFONTSIZEPrintActionjavaFONTTT"><TT>PrintAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZESetJavaLookAndFeelActionjavaFONTTT"><TT>SetJavaLookAndFeelAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZESetLookAndFeelActionjavaFONTTT"><TT>SetLookAndFeelAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZESetMotifLookAndFeelActionjavaFONTTT"><TT>SetMotifLookAndFeelAction.java</TT></A>
	<LI><A HREF="#TTFONTSIZESetWindowsLookAndFeeljavaFONTTT"><TT>SetWindowsLookAndFeel.java</TT></A>
	<LI><A HREF="#TTFONTSIZESimpleListCellRendererjavaFONTTT"><TT>SimpleListCellRenderer.java</TT></A>
	<LI><A HREF="#TTFONTSIZESliderValuePaneljavaFONTTT"><TT>SliderValuePanel.java</TT></A>
	<LI><A HREF="#TTFONTSIZESplashWindowjavaFONTTT"><TT>SplashWindow.java</TT></A>
	<LI><A HREF="#TTFONTSIZETableMapjavaFONTTT"><TT>TableMap.java</TT></A>
	<LI><A HREF="#TTFONTSIZETableSorterjavaFONTTT"><TT>TableSorter.java</TT></A>
	<LI><A HREF="#TTFONTSIZETextFilterDocumentjavaFONTTT"><TT>TextFilterDocument.java</TT></A>
	<LI><A HREF="#TTFONTSIZETreeLeafEditorjavaFONTTT"><TT>TreeLeafEditor.java</TT></A>
	<LI><A HREF="#TTFONTSIZETwoStateInterfacejavaFONTTT"><TT>TwoStateInterface.java</TT></A>
	<LI><A HREF="#TTFONTSIZEWindowsNonExpandingTreeUIjavaFONTTT"><TT>WindowsNonExpandingTreeUI.java</TT></A>
</UL>
<P>
<HR>
</P>
<P>Throughout this book, classes are developed for the <TT>com.foley.utility</TT>
package. These are presented in context when they are introduced, and they are presented
here for completeness.
<H2><A NAME="TTFONTSIZEAButtonjavaFONTTT"></A><TT>AButton.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.beans.*;

import javax.swing.*;


/**
 * The AButton class is an Action aware button.
 * The button will configure itself to the Action set using
 * the setAction method.
 *
 * The class can be configured for only one Action at
 * a time. If a second Action is set using the setAction
 * method, the first Action will be removed. However, other
 * ActionListeners can be added as normal by using the
 * addActionListener method.
 *
 * @author Mike Foley
 **/
public class AButton extends JButton 
    implements PropertyChangeListener { 

    /**
     * The Action for which this button is configured.
     **/
    private Action action;
    
    /**
     * Bound property names.
     **/
    public static final String ACTION_PROPERTY = &quot;action&quot;;
    
    
    /**
     * AButton, default constructor.
     * Creates a button with no set text or icon. 
     **/
    public AButton() { 
        this( null );
    } 
        
    /**
     * AButton, constructor
     * Creates a button from the given Action. 
     *
     * @see setAction
     * @param action-The Action to which to configure this button.
     **/
    public AButton( Action action ) { 
        
        super();
        
        //
        // The default placement is to set 
        // the text below the Icon.
        //
        setHorizontalTextPosition( JButton.CENTER );
        setVerticalTextPosition( JButton.BOTTOM );
        
        setAction( action );
    } 
    
    
    /**
     * Configure the button for the given Action.
     * If the button was already configured for
     * an Action, remove that Action from being
     * a listener to this button.
     * The Action is a bound property.
     *
     * @param action-The Action to which to configure this button.
     **/
    public void setAction( Action action ) { 
        
        Action oldAction = this.action;
        if( oldAction != null ) { 
            //
            // Remove the bind between the button and the
            // old action.
            //
            oldAction.removePropertyChangeListener( this );
            removeActionListener( oldAction );
        } 
        
        this.action = action;
        
        if( action != null ) { 
            
            //
            // Update our appearance to that of the new action.
            //
            setText( ( String )action.getValue( Action.NAME ) );
            setIcon( ( Icon )action.getValue( Action.SMALL_ICON ) );
        
            setEnabled( action.isEnabled() );
        
            //
            // Bind ourself to the new Action.
            //
            action.addPropertyChangeListener( this );
            addActionListener( action );
      
        }  else {
            
            //
            // null Action, set the button's view to 'empty'
            setText( &quot;&quot; );
            setIcon( null );
            
        }  // else
        
        //
        // The Action is a bound property.
        //
        firePropertyChange( ACTION_PROPERTY, oldAction, this.action );
        
    }  // setAction
    

    /**
     * propertyChange, from PropertyChangeListener.
     * Only handle changes from the Action for which we are configured.
     *
     * @param event-Property change event causing this method call.
     **/
    public void propertyChange( PropertyChangeEvent event ) { 
        if( event.getSource() == action ) { 
            
            //
            // Get the name of the changed property, and
            // update ourself accordingly.
            //
            String propertyName = event.getPropertyName();
            
            if( propertyName.equals( Action.NAME ) ) { 
                setText( ( String )event.getNewValue() );
            }  else if( propertyName.equals(Action.SMALL_ICON)) { 
                setIcon( ( Icon )event.getNewValue() );
                invalidate();
            }  else if( propertyName.equals( &quot;enabled&quot; ) ) { 
                Boolean enabled = ( Boolean )event.getNewValue();
                setEnabled( enabled.booleanValue() );
            }  
            
            //
            // Update our display.
            //
            repaint();
        } 
        
    }  // propertyChange
    
}  // AButton
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEActionFocusListenerjavaFONTTT"></A><TT>ActionFocusListener.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.FocusListener;
import java.awt.event.FocusEvent;


/**
 * ActionFocusListener
 *
 * An action that takes an ActionListener.  When
 * the component that this action is listening on
 * loses focus, an ActionEvent is created and sent
 * to the action listener.
 *
 * @author Mike Foley
 * @version 1.1
 *
 **/
public class ActionFocusListener extends Object
     implements FocusListener
{ 
     private ActionListener actionListener;

     /**
      * ActionFocusListener
      *
      * Construction.  Takes the ActionListener who will
      * be notified when the focus is lost.
      *
      * @param actionListener Where actions are sent.
      *
      **/
     public ActionFocusListener( ActionListener actionListener ) { 
          this.actionListener = actionListener;
     }  // ActionFocusListener


     public void focusGained( FocusEvent e ) { 
     }  // focusGained

     public void focusLost( FocusEvent e ) { 

          ActionEvent actionEvent = new ActionEvent(
                         e.getSource(), 0, &quot;Focus&quot;, 0 );

          actionListener.actionPerformed( actionEvent );
     }  // focusLost

}  // ActionFocusListener
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEAlbumCollectionItemjavaFONTTT"></A><TT>AlbumCollectionItem.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import javax.swing.*;


/**
 * The AlbumCollectionItem class binds a name
 * and icon together.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class AlbumCollectionItem { 
    String name;
    Icon icon;
    
    /**
     * AlbumCollectionItem, Constructor
     * &lt;p&gt;
     * @param name-The name of this item.
     * @param icon-The icon for this item.
     **/
    public AlbumCollectionItem( String name, Icon icon ) { 
        this.name = name;
        this.icon = icon;
    } 
    
    /**
     * @return-The name of this item.
     **/
    public String getName() { 
        return( name );
    } 
    
    /**
     * @return-The icon associated with this item.
     **/
    public Icon getIcon() { 
        return( icon );
    } 
    
    /**
     * @return-The String representation of this item.
     **/
    public String toString() { 
        return( name );
    } 
    
}  // AlbumCollectionItem
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEAlbumTreeRendererjavaFONTTT"></A><TT>AlbumTreeRenderer.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Component;

import javax.swing.*;
import javax.swing.tree.*;
    

/**
 * A tree renderer that knows about the record
 * collection tree.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class AlbumTreeRenderer extends JLabel
    implements TreeCellRenderer, AlbumTypes { 

    Icon albumIcon = new ImageIcon( &quot;album.gif&quot; );
    Icon albumsIcon = new ImageIcon( &quot;albums.gif&quot; );
    Icon cdsIcon = new ImageIcon( &quot;cds.gif&quot; );
    Icon tapesIcon = new ImageIcon( &quot;tapes.gif&quot; );


    /**
     * AlbumTreeRenderer, Constructor.
     * &lt;p&gt;
     * The renderer must be opaque so the background
     * color is painted.
     **/
    public AlbumTreeRenderer() { 
        setFont( UIManager.getFont( &quot;Tree.font&quot; ) ) ;
        setOpaque( true );
    } 
    
    
    /**
     * Configures the renderer based on the passed in components.
     * Text for the cell is obtained from the toString() method of 
     * the value parameter.
     * &lt;p&gt;
     * Foreground and background colors are obtained from the
     * UIManager.
     * &lt;p&gt;
     * If the value is a DefaultMutableTreeNode, and its user object
     * is an AlbumCollectionItem, the icon is obtained from the item
     * and set for the cell.
     **/
    public Component getTreeCellRendererComponent( JTree tree,
                            Object value,
                            boolean selected,
                            boolean expanded,
                            boolean leaf, 
                            int row,
                            boolean hasFocus ) { 
     
         //
         // Set the text for the cell.
         //
        if( value != null )                                          
            setText( value.toString() );
        else
            setText( &quot;&quot; );

        //
        // Set the colors for the cell.
        //
        if( selected ) { 
            setBackground( UIManager.getColor( 
                           &quot;Tree.selectionBackground&quot; ) );
            setForeground( UIManager.getColor( 
                           &quot;Tree.selectionForeground&quot; ) );
        }  else { 
            setBackground( UIManager.getColor( &quot;Tree.textBackground&quot; ) );
            setForeground( UIManager.getColor( &quot;Tree.textForeground&quot; ) );
        }  // else

        //
        // The type of the node is stored in the user object
        // in the mutable tree node.
        //
        setIcon( null );
        if( value instanceof DefaultMutableTreeNode ) { 
            DefaultMutableTreeNode node = ( DefaultMutableTreeNode )value;
            Object o = node.getUserObject();
            if( o instanceof AlbumCollectionItem ) { 
                AlbumCollectionItem albumItem = ( AlbumCollectionItem )o;
                setIcon( albumItem.getIcon() );
            } 
        } 
        
         return( this );
    } 
        
}  // AlbumTreeRenderer
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEAlbumTypesjavaFONTTT"></A><TT>AlbumTypes.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;


public interface AlbumTypes { 
    public static final int ALBUM = 1;
    public static final int ALBUMS = 2;
    public static final int CDS = 3;
    public static final int TAPES = 4;
} 
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEApplicationFramejavaFONTTT"></A><TT>ApplicationFrame.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import java.io.Serializable;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;


/**
 * A toplevel frame. The frame customizes the
 * Icon and content in the frameInit method.
 *
 * @author Mike Foley
 **/
public class ApplicationFrame extends JFrame implements Serializable { 
    private MouseAdapter ourMouseAdapter;
    
    private static Icon exitIcon;
    private static Icon closeIcon;
    private static Icon saveIcon;
    private static Icon saveasIcon;
    private static Icon openIcon;
    private static Icon newIcon;
    private static Icon printIcon;
    private static Icon printsetupIcon;
    private static Icon logIcon;
    private static Icon echoIcon;
    private static Icon whiteIcon;
    private static Icon blackIcon;
    private static Icon redIcon;
    private static Icon blueIcon;

    /**
     * The MouseListener for content components. This will
     * pop up a menu and the popupTrigger is received.
     **/
    private MouseListener mouseListener;


    /**
     * Load images used in the frame.
     **/
    static { 
        try { 
            closeIcon = ImageLoader.loadIcon( &quot;close.gif&quot; );
            exitIcon = ImageLoader.loadIcon( &quot;exit.gif&quot; );
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            openIcon = ImageLoader.loadIcon( &quot;open.gif&quot; );
            newIcon = ImageLoader.loadIcon( &quot;new.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
            logIcon = ImageLoader.loadIcon( &quot;log.gif&quot; );
            echoIcon = ImageLoader.loadIcon( &quot;echo.gif&quot; );
            whiteIcon = ImageLoader.loadIcon( &quot;white.gif&quot; );
            blackIcon = ImageLoader.loadIcon( &quot;black.gif&quot; );
            redIcon = ImageLoader.loadIcon( &quot;red.gif&quot; );
            blueIcon = ImageLoader.loadIcon( &quot;blue.gif&quot; );
        }  catch( InterruptedException ie ) {
        } 

    } 


    /**
     * ApplicationFrame, null constructor.
     **/
    public ApplicationFrame() { 
        this( null );
    } 


    /**
     * ApplicationFrame, constructor.
     *
     * @param title-The title for the frame.
     **/
    public ApplicationFrame( String title ) { 
        super( title );
    } 


    /**
     * Customize the frame for our application.
     **/
    protected void frameInit() { 
        //
        // Let the super create the panes.
        super.frameInit();
        
        ourMouseAdapter = new MouseAdapter() { } ;

        Image bullseye = new ImageIcon( &quot;bullseye.gif&quot; ).getImage();
        setIconImage( bullseye );

        JMenuBar menuBar = createMenu();
        setJMenuBar( menuBar );

        JToolBar toolBar = createToolBar();
        Container content = getContentPane();
        content.add( BorderLayout.NORTH, toolBar );

        createApplicationContent();

    }  // frameInit


    /**
     * Create the content for the applictaion
     **/
    protected void createApplicationContent() { 
    }  // createApplicationContent


    /**
     * Create the menu for the frame.
     *
     * @return-The menu for the frame.
     **/
    protected JMenuBar createMenu() { 
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( K eyEvent.VK_F );
        
        JMenuItem item;

        item = new JMenuItem( &quot;Exit&quot;, exitIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_X );
        item.setAccelerator( KeyStroke.getKeyStroke( KeyEvent.VK_X,
        Event.CTRL_MASK ) );
        item.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent e ) { 
                System.exit( 0 );
            } 
        }  );
        file.add( item );

        menuBar.add( file );
        


        return( menuBar );

    }  // createMenuBar


    /**
     * Create the mouse listener for the frame.
     *
     * @return-The MouseListener for the content in the frame.
     **/
    protected MouseListener createMouseListener() { 
        return new ApplicationMouseListener();
    }

    protected JToolBar createToolBar() { 
        final JToolBar toolBar = new JToolBar();

        toolBar.add( new ExitAction() );
        return( toolBar );
    } 


    /**
     * Show or hide the wait cursor. The wait cursor
     * is set on the glass pane so input mouse events
     * are blocked from other componenets.
     * &lt;p&gt;
     * @param waitCursorVisible True to show the wait cursor,
     *                          False to hide the wait cursor.
     **/
    public void setWaitCursorVisible( boolean waitCursorVisible ) { 
        Component glassPane = getGlassPane();
        if( waitCursorVisible ) { 
            //
            // Show the wiat cursor.
            //
            glassPane.addMouseListener( ourMouseAdapter );
            glassPane.setCursor( Cursor.getPredefinedCursor( 
                                 Cursor.WAIT_CURSOR ) );
            glassPane.setVisible( true );
        }  else { 
            //
            // Hide the wait cursor.
            //
            glassPane.removeMouseListener( ourMouseAdapter );
            glassPane.setCursor( Cursor.getPredefinedCursor( 
                                 Cursor.DEFAULT_CURSOR ) );
            glassPane.setVisible( false );
        } 
    } 
    
    
    /**
     * Application entry point.
     * Create the frame, and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String[] args ) { 

        ApplicationFrame frame = new ApplicationFrame( &quot;ApplicationFrame&quot; );
        frame.pack();
        frame.setVisible( true );

    } 

}  // ApplicationFrame
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEApplicationMouseListenerjavaFONTTT"></A><TT>ApplicationMouseListener.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.awt.event.*;

import javax.swing.*;


/**
 * Pop up the context sensitive menu when the pop-up
 * trigger event is delivered.
 **/
class ApplicationMouseListener extends MouseAdapter
    implements MouseListener { 

    /**
     * See if the mouse event is the pop-up trigger. If so,
     * display the pop-up menu.
     *
     * @param e The mouse event causing this call.
     **/
    public void mouseReleased( MouseEvent e ) { 
        if( e.isPopupTrigger() ) { 
            showPopupMenu( ( Component )e.getSource(), 
                           e.getX(), e.getY() );
        } 
    } 


    /**
     * See if the mouse event is the pop-up trigger. If so,
     * display the pop-up menu.
     *
     * @param e[em]The mouse event causing this call.
     **/
    public void mousePressed( MouseEvent e ) { 
        if( e.isPopupTrigger() ) { 
            showPopupMenu( ( Component )e.getSource(), 
                           e.getX(), e.getY() );
        } 
    }


    /**
     * Display the pop-up menu using the given invoker, and at the
     * specified location.
     *
     * @param invoker The component used as the menu's invoker.
     * @param x-The X coordinate for the pop-up menu.
     * @param y-The Y coordinate for the pop-up menu.
     **/
    private void showPopupMenu( Component invoker, int x, int y ) { 
        Icon saveIcon = null;
        Icon saveasIcon = null;
        Icon printIcon = null;
        Icon printsetupIcon = null;

        try { 
            //
            // Load the images used.
            //
            saveIcon = ImageLoader.loadIcon( &quot;save.gif&quot; );
            saveasIcon = ImageLoader.loadIcon( &quot;saveas.gif&quot; );
            printIcon = ImageLoader.loadIcon( &quot;print.gif&quot; );
            printsetupIcon = ImageLoader.loadIcon( &quot;printsetup.gif&quot; );
        }  catch( InterruptedException ie ) { 
            System.err.println( &quot;Error loading images&quot; );
            return;
        }

        JPopupMenu popup = new JPopupMenu( &quot;Title&quot; );

        JMenuItem item = new JMenuItem( &quot;Save&quot;, saveIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_S );
        popup.add( item );

        item = new JMenuItem( &quot;Save As...&quot;, saveasIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_A );
        popup.add( item );

        popup.addSeparator();

        item = new JMenuItem( &quot;Print Setup...&quot;, printsetupIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_U );
        popup.add( item );

        item = new JMenuItem( &quot;Print&quot;, printIcon );
        item.setHorizontalTextPosition( SwingConstants.RIGHT );
        item.setMnemonic( KeyEvent.VK_P );
        popup.add( item );

        popup.show( invoker, x, y );

    }

}  // ApplicationMouseListener
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEColorEditorjavaFONTTT"></A><TT>ColorEditor.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.awt.event.*;

import java.io.Serializable;

import java.beans.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.colorchooser.*;


/**
 * A panel that allows colors to be specified
 * for a foreground and background.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class ColorEditor extends JPanel
    implements Serializable { 

    /**
     * A radio button group for foreground/background
     * option.
     **/
    private ButtonGroup colorButtonGroup;
    private JRadioButton foregroundRadioButton;
    private JRadioButton backgroundRadioButton;

    /**
     * The color chooser.
     **/
    private JColorChooser colorChooser;

    /**
     * boolean used to decide which color is being changed.
     * true means foreground is being edited, false background.
     **/
    private boolean foregroundEditing = true;

    /**
     * Property change support.
     **/
    protected PropertyChangeSupport changeSupport = 
              new PropertyChangeSupport( this );

    /**
     * The current foreground and background Colors.
     **/
    private Color editForegroundColor;
    private Color editBackgroundColor;
    
    /**
     * This component contains two properties: foreground and
     * background color.
     **/
    public static final String EDITED_FOREGROUND_PROPERTY = 
                               &quot;ForegroundProperty&quot;;
    public static final String EDITED_BACKGROUND_PROPERTY = 
                               &quot;BackgroundProperty&quot;;

    /**
     * The default colors used in the editor.
     **/
    public static final Color DEFAULT_FOREGROUND_COLOR = Color.black;
    public static final Color DEFAULT_BACKGROUND_COLOR = Color.white;


    /**
     * ColorEditor, constructor.
     * &lt;p&gt;
     * Create a ColorEditor with the default foreground and
     * background colors.
     **/
    public ColorEditor() { 
        this( DEFAULT_FOREGROUND_COLOR, DEFAULT_BACKGROUND_COLOR );
    }  // ColorEditor


    /**
     * ColorEditor, constructor.
     * &lt;p&gt;
     * The ColorEditor can be thought of as a mediator between
     * the various components on the panel. The radio buttons
     * choose which color is being edited. Valid options are
     * foreground and background. The JColorChooser allows visual
     * editing of these colors.
     * &lt;p&gt;
     * Create the components contained in the ColorEditor.
     * Create the listeners and connects them to give the
     * component-to-component interactions.
     * &lt;p&gt;
     * @param foreground-The initial foreground color for the editor.
     * @param background-The initial background color for the editor.
     **/
    public ColorEditor( Color foreground, Color background ) { 

        super();

        //
        // If a color is null, use the default color.
        //
        if( foreground == null )
            foreground = DEFAULT_FOREGROUND_COLOR;
        if( background == null )
            background = DEFAULT_BACKGROUND_COLOR;
    
        this.editForegroundColor = foreground;
        this.editBackgroundColor = background;

        setLayout( new BorderLayout() );

        //
        // This action listener receives messages when the radio
        // buttons change. Set which property is being changed,
        // and update the color chooser to the current color
        // in that property.
        // A property change event doesn't need to be thrown here.
        // This only changes which property is being edited, not the
        // value of a property.
        //
        ActionListener radioListener = new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                if( event.getSource() == foregroundRadioButton ) { 
                    foregroundEditing = true;
                    colorChooser.setColor( editForegroundColor );
                }  else { 
                    foregroundEditing = false;
                    colorChooser.setColor( editBackgroundColor );
                } 
                colorChooser.repaint();
            } 
        } ;

        //
        // Create a radio button group containing
        // two buttons: foreground and background color.
        //
        colorButtonGroup = new ButtonGroup();
        foregroundRadioButton = new JRadioButton( &quot;Foreground&quot; );
        foregroundRadioButton.setSelected( true );
        backgroundRadioButton = new JRadioButton( &quot;Background&quot; );
        colorButtonGroup.add( foregroundRadioButton );
        colorButtonGroup.add( backgroundRadioButton );
        foregroundRadioButton.addActionListener( radioListener );
        backgroundRadioButton.addActionListener( radioListener );

        //
        // The options panel contains the radio buttons.
        //
        JPanel options = new JPanel();
        options.setLayout( new BorderLayout() );

        //
        // Place the radio buttons.
        //
        JPanel buttons = new JPanel();
        buttons.setLayout( new BoxLayout( buttons, BoxLayout.Y_AXIS ) );
        buttons.add( foregroundRadioButton );
        buttons.add( backgroundRadioButton );
        options.add( BorderLayout.NORTH, buttons );
        buttons.setBorder( BorderFactory.createTitledBorder(
                           BorderFactory.createEtchedBorder(), 
                          &quot;Current Color&quot; ) );

        add( BorderLayout.WEST, buttons );

        //
        // Create the JColorChooser.
        //
        colorChooser = new JColorChooser( editForegroundColor );
        colorChooser.setBorder( BorderFactory.createLoweredBevelBorder() );
        add( BorderLayout.CENTER, colorChooser );
        ColorSelectionModel model = colorChooser.getSelectionModel();
        model.addChangeListener( new ChangeListener() { 
            public void stateChanged( ChangeEvent e ) { 
                Color c = colorChooser.getColor();
                if( isEditingForeground() ) { 
                    setEditedForegoundColor( c );
                }  else { 
                    setEditedBackgoundColor( c );
                } 
            } 
        }  );
        
    }  // ColorEditor


    /**
     * @return The current value of the foreground color.
     **/
    public Color getEditedForegoundColor() { 
        return( editForegroundColor );
    } 


    /**
     * Provide an API to set the foreground color used in the editor.
     * If the foreground color is currently being edited, set the
     * value in the color chooser. This will fire the property change
     * event, and the other components will update.
     * &lt;p&gt;
     * If the background is being edited, set the color in the label.
     * The color chooser will update the next time foreground is edited.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param c The new foreground color.
     **/
    public void setEditedForegoundColor( Color c ) { 

        if( foregroundEditing ) { 
            colorChooser.setColor( c );
        }  
        Color old = editForegroundColor;
        editForegroundColor = c;
            changeSupport.firePropertyChange( EDITED_FOREGROUND_PROPERTY,
                                          old,
                                          c );

    }  // setEditedForegoundColor


    /**
     * @return The current value of the background color.
     **/
    public Color getEditedBackgoundColor() { 
        return( editBackgroundColor );
    } 


    /**
     * Provide an API to set the background color used in the editor.
     * If the background color is currently being edited, set the
     * value in the color chooser. This will fire the property change
     * event, and the other components will update.
     * &lt;p&gt;
     * If the foreground is being edited, set the color in the label.
     * The color chooser will update the next time background is edited.
     * &lt;p&gt;
     * This is a bound property.
     * &lt;p&gt;
     * @param c The new background color.
     **/
    public void setEditedBackgoundColor( Color c ) { 

        if( !foregroundEditing ) { 
            colorChooser.setColor( c );
        }  
        Color old = editBackgroundColor;
        editBackgroundColor = c;
            changeSupport.firePropertyChange( EDITED_BACKGROUND_PROPERTY,
                                         old,
                                          c );

    }  // setEditedBackgoundColor


    /**
     * Set which property is being edited. These are in a radio
     * button, so selecting or unselecting the foreground button
     * will do the opposite to the background button.
     * &lt;p&gt;
     * Changing the selected state of the button will cause the proper
     * events to be fired, which will update this object's state.
     * &lt;p&gt;
     * @param editForeground-The new state for the foreground.
     **/
    public void setEditingForeground( boolean editForeground ) { 
        foregroundRadioButton.setSelected( true );
    } 


    /**
     * Query which property is being edited. Because there are
     * only two, this can be represented as a Boolean. The Boolean
     * that was choosen is the foreground radio button's selected state.
     * &lt;p&gt;
     * @return true if the foregound color is being edited; false is background.
     **/
    public boolean isEditingForeground() { 
        return( foregroundRadioButton.isSelected() );
    } 


    public static Action getShowAction() { 
        return( new ShowColorEditorAction() );
    } 


    /**
     * addPropertyChangeListener
     *
     * The specified PropertyChangeListeners &lt;b&gt;propertyChange&lt;/b&gt; method
     * will be called each time the value of any bound property is
     * changed. The PropertyListener object is addded to a list of 
     * PropertyChangeListener managed by this button, it can be removed
     * with removePropertyChangeListener.
     *
     * Note: the JavaBeans specification does not require 
     * PropertyChangeListeners to run in any particular order.

     *
     * @param l-The PropertyChangeListener
     * @see #removePropertyChangeListener
      *
     **/
    public void addPropertyChangeListener( PropertyChangeListener l ) { 
          changeSupport.addPropertyChangeListener( l );
    }  // addPropertyChangeListener


    /**
     * removePropertyChangeListener
     *
     * Remove this PropertyChangeListener from the buttons internal list.
     * If the PropertyChangeListener isn't on the list, silently do nothing.
     *
     * @param l the PropertyChangeListener
     * @see #addPropertyChangeListener
     *
     **/
    public void removePropertyChangeListener( PropertyChangeListener l ) { 
          changeSupport.removePropertyChangeListener( l );
    }  // removePropertyChangeListener

}  // ColorEditor


/**
 * Class ShowColorEditorAction
 * &lt;p&gt;
 * An action that opens the ColorEditor dialog box.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
class ShowColorEditorAction extends AbstractAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Color Editor...&quot;;

    public ShowColorEditorAction() { 
        this( DEFAULT_NAME, null );
    }  // ShowColorEditorAction

    public ShowColorEditorAction( String name ) { 
        this( name, null );
    }  // ShowColorEditorAction

    public ShowColorEditorAction( String name, Icon icon ) { 
        super( name, icon );
    }  // ShowColorEditorAction


    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Perform the action. Show the ColorEditor dialog box.
     * &lt;p&gt;
     * @param event-The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 

        Frame parent = JOptionPane.getFrameForComponent( 
                                   ( Component )event.getSource() );
        JDialog dialog = new JDialog( parent );
        ColorEditor editor = new ColorEditor();
        dialog.getContentPane().add( BorderLayout.CENTER, editor );

        dialog.setModal( true );
        dialog.pack();
        dialog.setVisible( true );
        dialog.show();
    }  // actionPerformed

}  // ShowColorEditorAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEExitActionjavaFONTTT"></A><TT>ExitAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import javax.swing.AbstractAction;
import javax.swing.Icon;
 

/**
 * Class ExitAction
 * &lt;p&gt;
 * An action that shuts down the java virtual machine.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class ExitAction extends AbstractAction { 

    /**
     * The default name and Icon for the Action.
     **/
    private static final String DEFAULT_NAME = &quot;Exit&quot;;
    private static final String DEFAULT_ICON_NAME = &quot;exit.gif&quot;;
    private static Icon DEFAULT_ICON;
    
    /**
     * ExitAction, default constructor.
     * Create the Action with the default name and Icon.
     **/
    public ExitAction() { 
        this( DEFAULT_NAME, DEFAULT_ICON );
    }  // ExitAction
    
    /**
     * ExitAction, constructor.
     * Create the Action with the given name and 
     * default Icon.
     *
     * @param name The name for the Action.
     **/
    public ExitAction( String name ) { 
        this( name, DEFAULT_ICON );
    }  // ExitAction
    
    /**
     * ExitAction, constructor.
     * Create the Action with the given name and 
     * Icon.
     *
     * @param name-The name for the Action.
     * @param icon-The small icon for the Action.
     **/
    public ExitAction( String name, Icon icon ) { 
            super( name, icon );
    }  // ExitAction
    
    /**
     * putValue, overriden from AbstractAction.
     * Guard against null values being added to the Action.
     *
     * @param key-The key for the value.
     * @param value-The value to be added to the Action.
     **/
    public void putValue( String key, Object value ) { 
        if( value != null )
            super.putValue( key, value );
    } 
    
    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Perform the action. Exit the JVM.
     * &lt;p&gt;
     * @param event-The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 
        System.exit(0);        
    }  // actionPerformed

    /**
     * static initialization. Load the default Icon.
     **/
    static { 
        try { 
            DEFAULT_ICON = ImageLoader.loadIcon( DEFAULT_ICON_NAME );
        }  catch( InterruptedException ie ) { 
            System.err.println(&quot;Could not load ExitAction default Icon&quot;);
        } 
    }         

}  // ExitAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFPartialEtchedBorderjavaFONTTT"></A><TT>FPartialEtchedBorder.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Color;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import javax.swing.border.AbstractBorder; 

/**
 * Class FPartialEtchedBorder
 * &lt;p&gt;
 * A partial etched border.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class FPartialEtchedBorder extends AbstractBorder { 

    Color highlight;
    Color shadow;

    public FPartialEtchedBorder() { 
        super();
    }  // FPartialEtchedBorder


    public FPartialEtchedBorder( Color highlight, Color shadow ) { 
        super();
        this.highlight = highlight;
        this.shadow = shadow;
        
    }  // FPartialEtchedBorder


    /**
     * @param c-The component for which this border is being painted
     * @param g-The paint graphics
     * @param x the x-Position of the painted border
     * @param y the y-Position of the painted border
     * @param width-The width of the painted border
     * @param height-The height of the painted border
     **/
    public void paintBorder( Component c, Graphics g,
                         int x, int y,
                         int width, int height ) { 
        
        //
        // Save the graphics context. This will be
        // restored at the end of the method.
        // The original color and origin are what we change.
         // Translate to the corner of this component.
         // This way we can draw in a 0-width-1, 0-height-1 space.
        //
         Color oldColor = g.getColor();
         g.translate( x, y );

         int w = width;
         int h = height;
     
         g.setColor(shadow != null? shadow : c.getBackground().darker());
         g.drawLine( 0, 0, w-1, 0 );
     
         g.setColor( highlight != null ? 
                    highlight : c.getBackground().brighter() );
         
         g.drawLine(1, 1, w-1, 1);
          
         //
         // Restore the graphic context.
         //
         g.translate( -x, -y );
         g.setColor( oldColor );
                            
    }  // paintBorder
    
}  // FPartialEtchedBorder
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEImageLoaderjavaFONTTT"></A><TT>ImageLoader.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Component;
import java.awt.Toolkit;
import java.awt.Image;
import java.awt.MediaTracker;

import java.io.IOException;

import java.net.URL;

import javax.swing.Icon;
import javax.swing.ImageIcon;


/**
 * A class containing static methods that can
 * be used to load Images and Icons.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class ImageLoader extends Component { 
    private static ImageLoader imageLoader;

    /**
     * ImageLoader, constructor.
     * &lt;p&gt;
     * There should not be any instances of this
     * class created outside the private one used
     * in the class.
     **/
    private ImageLoader() { 
        super();
    } 


    /**
     * loadImage
     * &lt;p&gt;
     * Load the image with the given name.
     * &lt;p&gt;
     * @param imageName-The name of the image to load.
     * @return-The Image for the image with the given name.
     * @see #loadIcon
     **/
    public static Image loadImage( String imageName )
        throws java.lang.InterruptedException { 

        //
        // get the image, and wait for it to be loaded.
        //
        URL url = Object.class.getResource( imageName );

        //
               // If the URL could not be located above, try
                // prepending a '/' to the image's ResourceName. This
                // will cause the search to begin at the top of the
                // CLASSPATH.
                //
           if( url == null )
                     url = Object.class.getResource( &quot;/&quot; + imageName );
        if( url == null ) {
            RuntimeException e = new RuntimeException( &quot;Image &quot; + 
                                     imageName + &quot; not found&quot; );
            e.printStackTrace();
            throw e;
        } 

            //
            // Get the image and wait for it to be loaded.
        //
        Image image = Toolkit.getDefaultToolkit().getImage( url );
        MediaTracker tracker = new MediaTracker( imageLoader );
        tracker.addImage( image, 0 );
        tracker.waitForID( 0 );

        return( image );

    }  // loadImage


    /**
     * loadIcon
     * &lt;p&gt;
     * Load the Icon with the given name.
     * &lt;p&gt;
     * @param imageName-The name of the image to load.
     * @return-The Icon for the image with the given name.
     * @see #loadImage
     **/
    public static Icon loadIcon( String imageName )
        throws java.lang.InterruptedException { 

        Image image = loadImage( imageName );
        return( new ImageIcon( image ) );

    }  // loadIcon


    /**
     * static initialization.
     * &lt;p&gt;
     * Create an instance of this class that can be
     * used as the parameter to the MediaTracker while
     * loading images.
     **/
    static { 
        imageLoader = new ImageLoader();
    }  // static

}  // ImageLoader
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEJavaFileViewjavaFONTTT"></A><TT>JavaFileView.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.io.File;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.filechooser.FileView;


public class JavaFileView extends FileView { 
    
    /**
     * The icon for Java source files.
     **/
    Icon cupIcon = null;
    
        
    /**
     * Allow default processing.
     * &lt;p&gt;
     * @param file-The file who's name is reqested.
     * @return-The name for the file.
     **/
    public String getName( File file ) { 
        return( null );
    }
    
    
    /**
     * @param file-The file who's description is reqested.
     * @return-The description for the given file.
     **/
    public String getDescription( File file ) { 
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            return( &quot;A Java source file&quot; );
        }  else { 
            return( null );
        } 
    } 
    

    /**
     * @param file-The file who's type description is reqested.
     * @return-The type description for the given file.
     **/
    public String getTypeDescription( File file ) { 
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            return( &quot;Java source file&quot; );
        }  else { 
            return( null );
        }
    } 
    

    /**
     * @param file-The file who's icon is reqested.
     * @return-The icon for the given file.
     **/
    public Icon getIcon( File file ) { 
        Icon icon = null;
        String extension = getExtension( file );
        if( extension != null &amp;&amp; extension.equals( &quot;java&quot; ) ) { 
            
            if( cupIcon == null )
                cupIcon = new ImageIcon( &quot;javacup.gif&quot; );
            
            icon = cupIcon;
        } 
        return( icon );
    } 


    /**
     * Allow default processing.
     * &lt;p&gt;
     * @param file-The directory to test.
     * @return null to enable default processing.
     **/
    public Boolean isTraversable( File file ) { 
        return( null );
    } 

    /**
     * Determine the extension of the given File.
     * &lt;p&gt;
     * @param f-The File whose extension is desired.
     * @return-The extension of the given File, in lower case.
     **/
    protected String getExtension( File f ) { 
         if(f != null) { 
             String filename = f.getName();
             int i = filename.lastIndexOf( '.' );
             if(i&gt;0 &amp;&amp; i&lt;filename.length() - 1) { 
                  return filename.substring( i + 1 ).toLowerCase();
             } ;
         } 
         return null;
    } 

}  // JavaFileView
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEJBoxjavaFONTTT"></A><TT>JBox.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import javax.swing.*;


/**
 * The JBox class is a Box replacement that
 * is a descendent of the JComponent class.
 * It is a JPanel configured with a BoxLayout
 * layout manager.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class JBox extends JPanel {  
    
    public JBox( int orientation ) { 
        BoxLayout boxLayout = new BoxLayout( this, orientation );
        setLayout( boxLayout );
    } 
    

    /**
     * Create a JBox configured along its X-axis.
     * &lt;p&gt;
     * @return-A JBox configured along its X-axis.
     **/
    public static JBox createHorizontalJBox() { 
         return new JBox( BoxLayout.X_AXIS );
    } 

    
    /**
     * Create a JBox configured along its Y-axis.
     * &lt;p&gt;
     * @return-A JBox configured along its Y-axis.
     **/
    public static JBox createVerticalJBox() { 
         return new JBox( BoxLayout.Y_AXIS );
    } 
    
}  // JBox
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEMDIFramejavaFONTTT"></A><TT>MDIFrame.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;

import java.awt.event.*;
import java.io.Serializable;
import java.util.Vector;

import javax.swing.*;

import javax.swing.border.*;

import javax.swing.event.*;


/**
 * A toplevel frame. The frame configures itself
 * with a JDesktopPane in its content pane.
 *
 * @author Mike Foley
 **/
public class MDIFrame extends JFrame implements Serializable { 
    
    /**
     * The desktop pane in our content pane.
     **/
    private JDesktopPane desktopPane;
    
    
    /**
     * MDIFrame, null constructor.
     **/
    public MDIFrame() { 
        this( null );
    } 


    /**
     * MDIFrame, constructor.
     *
     * @param title-The title for the frame.
     **/
    public MDIFrame( String title ) { 
        super( title );
    } 


    /**
     * Customize the frame for our application.
     **/
    protected void frameInit() { 
        //
        // Let the super create the panes.
        super.frameInit();
        
        JMenuBar menuBar = createMenu();
        setJMenuBar( menuBar );

        JToolBar toolBar = createToolBar();
        Container content = getContentPane();
        content.add( toolBar, BorderLayout.NORTH );

        desktopPane = new JDesktopPane();
        desktopPane.setPreferredSize( new Dimension( 400, 300 ) );
        content.add( desktopPane, BorderLayout.CENTER );
        
    }  // frameInit


    /**
     * Create the menu for the frame.
     * &lt;p&gt;
     * @return-The menu for the frame.
     **/
    protected JMenuBar createMenu() { 
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
              
        file.add( new NewInternalFrameAction() );
        file.add( new ExitAction() );

        menuBar.add( file );
        
        JMenu options = new JMenu( &quot;Options&quot; );
        options.setMnemonic( KeyEvent.VK_O );
        Vector frames = new Vector();
        frames.add( this );
        options.add( new SetJavaLookAndFeelAction( frames ) );
        options.add( new SetWindowsLookAndFeelAction( frames ) );
        options.add( new SetMotifLookAndFeelAction( frames ) );
        menuBar.add( options );

        ( ( JComponent )getContentPane() ).registerKeyboardAction( 
                    new SetJavaLookAndFeelAction(),
                    KeyStroke.getKeyStroke( 'm' ),
                    JComponent.WHEN_IN_FOCUSED_WINDOW );
        ( ( JComponent )getContentPane() ).registerKeyboardAction( 
                    new SetMotifLookAndFeelAction(),
                    KeyStroke.getKeyStroke( 'u' ),
                    JComponent.WHEN_IN_FOCUSED_WINDOW );
        ( ( JComponent )getContentPane() ).registerKeyboardAction( 
                    new SetWindowsLookAndFeelAction(),
                    KeyStroke.getKeyStroke( 'w' ),
                    JComponent.WHEN_IN_FOCUSED_WINDOW );
        return( menuBar );

    }  // createMenuBar


    /**
     * Create the toolbar for this frame.
     * &lt;p&gt;
     * @return-The newly created toolbar.
     **/
    protected JToolBar createToolBar() { 
        final JToolBar toolBar = new JToolBar();
        toolBar.setFloatable( false );

        toolBar.add( new NewInternalFrameAction() );
        toolBar.add( new ExitAction() );
        return( toolBar );
    } 


    /**
     * Create an internal frame.
     * &lt;p&gt;
     * @return-The newly created internal frame.
     **/
    public JInternalFrame createInternalFrame() { 
        
        final JInternalFrame internalFrame = 
              new JInternalFrame( &quot;Internal JLabel&quot; );
        JMenuBar menuBar = new JMenuBar();

        JMenu file = new JMenu( &quot;File&quot; );
        file.setMnemonic( KeyEvent.VK_F );
        
        Action disposeAction = 
               new DisposeInternalFrameAction( internalFrame );
        Action exitAction = new ExitAction();
        file.add( disposeAction );
        file.add( exitAction );

        menuBar.add( file );
        internalFrame.setJMenuBar( menuBar );

        JToolBar toolBar = new JToolBar();
        toolBar.add( disposeAction );
        toolBar.add( exitAction );
        
        internalFrame.getContentPane().add(toolBar, BorderLayout.NORTH);
        
        JComponent content = new JLabel( &quot;Internal Frame Content&quot; );
        content.setBorder( BorderFactory.createLoweredBevelBorder() );
        internalFrame.getContentPane().add( 
                            content, 
                            BorderLayout.CENTER );
        internalFrame.setResizable( true );
        internalFrame.setClosable( true );
        internalFrame.setIconifiable( true );
        internalFrame.setMaximizable( true );
        internalFrame.pack();
          
          return( internalFrame );
    } 

    /**
     * Create an internal frame.
     * &lt;p&gt;
     * @return-The newly created internal frame.
     **/
     /*
    public JInternalFrame createInternalFrame() { 
        
        JInternalFrame internalFrame = 
                      new JInternalFrame( &quot;Internal JLabel&quot; );
        internalFrame.getContentPane().add( 
                      new JLabel( &quot;Internal Frame Content&quot; ) );
        internalFrame.setResizable( true );
        internalFrame.setClosable( true );
        internalFrame.setIconifiable( true );
        internalFrame.setMaximizable( true );
        internalFrame.pack();
          
          return( internalFrame );
    } 
    */

    /**
     * An Action that creates a new internal frame and
     * adds it to this frame's desktop pane.
     **/
    public class NewInternalFrameAction extends AbstractAction { 
        
        /**
         * NewInternalFrameAction, constructor.
         * Set the name and icon for this action.         
         **/
        public NewInternalFrameAction() { 
            super( &quot;New&quot;, new ImageIcon( &quot;new.gif&quot; ) );
        } 
        
        /**
         * Perform the action, create an internal frame and
         * add it to the desktop pane.
         * &lt;p&gt;
         * @param e-The event causing us to be called.
         **/
        public void actionPerformed( ActionEvent e ) { 
            JInternalFrame internalFrame = createInternalFrame();
            desktopPane.add( internalFrame, JLayeredPane.DEFAULT_LAYER );
        } 
            
    } 


    /**
     * An Action that disposes of an internal frame.
     **/
    public class DisposeInternalFrameAction extends AbstractAction { 
        
        /**
         * The internal pane to close.
         **/
        private JInternalFrame internalFrame;
        
        
        /**
         * CloseInternalFrameAction, constructor.
         * Set the name and icon for this action.       
         * &lt;p&gt;
         * @param internalFrame-The internal frame that we dispose of.
         **/
        public DisposeInternalFrameAction(JInternalFrame internalFrame) { 
            super( &quot;Close&quot;, new ImageIcon( &quot;close.gif&quot; ) );
            this.internalFrame = internalFrame;
        } 
        
        /**
         * Perform the action, dispose of the internal frame.
         * &lt;p&gt;
         * @param e-The event causing us to be called.
         **/
        public void actionPerformed( ActionEvent e ) { 
            internalFrame.dispose();
        } 
            
    }

}  // MDIFrame
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEMetalNonExpandingTreeUIjavaFONTTT"></A><TT>MetalNonExpandingTreeUI.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.MouseEvent;

import javax.swing.JComponent;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicTreeUI;


/**
 * A TreeUI that does not automatically expand or
 * collapse the tree on a double-click event.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class MetalNonExpandingTreeUI extends BasicTreeUI
{ 

    /**
     * Create the UI object for the given tree. This
     * is a new instance of this class.
     **/
    public static ComponentUI createUI( JComponent tree ) { 
         return( new MetalNonExpandingTreeUI() );
    } 


    /**
     * MetalNonExpandingTreeUI, constructor
     **/
    public MetalNonExpandingTreeUI() { 
         super();
    } 


    /**
     * Returning true indicates the row under the mouse should be toggled
     * based on the event. This is invoked after 
     * checkForClickInExpandControl, implying the location is not in
     * the expand (toggle) control
     * &lt;p&gt;
     * This is the behavior we want to squish, so always return false.
     * &lt;p&gt;
     * @return false
     **/
    protected boolean isToggleEvent( MouseEvent event ) { 
         return( false );
    } 

}  // MetalNonExpandingTreeUI
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZENonExpandingTreeUIjavaFONTTT"></A><TT>NonExpandingTreeUI.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.MouseEvent;

import javax.swing.JComponent;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicTreeUI;


/**
 * A TreeUI that does not automatically expand or
 * collapse the tree on a double click event.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class NonExpandingTreeUI extends BasicTreeUI
{ 

    /**
     * Create the UI object for the given tree. This
     * is a new instance of this class.
     **/
    public static ComponentUI createUI( JComponent tree ) { 
         return( new NonExpandingTreeUI() );
    } 


    /**
     * NonExpandingTreeUI, constructor
     **/
    public NonExpandingTreeUI() { 
         super();
    } 


    /**
     * Returning true indicates the row under the mouse should be toggled
     * based on the event. This is invoked after 
     * checkForClickInExpandControl, implying the location is not in 
     * the expand (toggle) control
     * &lt;p&gt;
     * This is the behavior we want to squish, so always return false.
     * &lt;p&gt;
     * @return false
     **/
    protected boolean isToggleEvent( MouseEvent event ) { 
         return( false );
    } 

}  // NonExpandingTreeUI
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZENoOpActionjavaFONTTT"></A><TT>NoOpAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.*;

import javax.swing.*;
 

/**
 * Class NoOpAction
 * &lt;p&gt;
 * An action that does nothing.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class NoOpAction extends AbstractAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;NoOp&quot;;
    
    
    /**
     * NoOpAction, default constructor.
     * &lt;p&gt;
     * Create the action with the default name.
     **/
    public NoOpAction() { 
        this( DEFAULT_NAME );
    }  // NoOpAction
    
    
    /**
     * NoOpAction, constructor.
     * &lt;p&gt;
     * Create the action with the given name.
     * &lt;p&gt;
     * @param name The name for the Action.
     **/
    public NoOpAction( String name ) { 
        super( name );
    }  // NoOpAction
    
    
    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Do nothing.
     * &lt;p&gt;
     * @param event-The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 
    }  // actionPerformed

}  // NoOpAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEOutlandishThemejavaFONTTT"></A><TT>OutlandishTheme.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Font;

import javax.swing.plaf.ColorUIResource;
import javax.swing.plaf.FontUIResource;

import javax.swing.plaf.metal.DefaultMetalTheme;


/**
 * This class provides an outlandish color theme.
 * The primary and secondary colors are overriden.
 * The fonts and other theme properties are left unaltered.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class OutlandishTheme extends DefaultMetalTheme { 

    public String getName() {  return &quot;OutlandishTheme&quot;; } 

    //
    // Primary Colors.
    //
    private final ColorUIResource primary1 = 
                  new ColorUIResource( 255, 0, 0 );
    private final ColorUIResource primary2 = 
                  new ColorUIResource(200, 25, 25);
    private final ColorUIResource primary3 = 
                  new ColorUIResource(150, 150, 150); 

    protected ColorUIResource getPrimary1() {  return primary1; }   
    protected ColorUIResource getPrimary2() {  return primary2; }  
    protected ColorUIResource getPrimary3() {  return primary3; }  

    //
    // Secondary Colors.
    //
    private final ColorUIResource secondary1 = 
                  new ColorUIResource( 0,  255,  0);
    private final ColorUIResource secondary2 = 
                  new ColorUIResource(25, 200, 25);
    private final ColorUIResource secondary3 = 
                  new ColorUIResource(40, 180, 40);

    protected ColorUIResource getSecondary1() {  return secondary1; } 
    protected ColorUIResource getSecondary2() {  return secondary2; } 
    protected ColorUIResource getSecondary3() {  return secondary3; } 

    //
    // Fonts.
    //
    private final FontUIResource font = 
                  new FontUIResource(&quot;SansSerif&quot;, Font.BOLD, 18);
    public FontUIResource getControlTextFont() {  return font;} 
    public FontUIResource getSystemTextFont() {  return font;} 
    public FontUIResource getUserTextFont() {  return font;} 
    public FontUIResource getMenuTextFont() {  return font;} 
    public FontUIResource getWindowTitleFont() {  return font;} 
    public FontUIResource getSubTextFont() {  return font;} 

}  // OutlandishTheme
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEPercentSliderjavaFONTTT"></A><TT>PercentSlider.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.text.NumberFormat;
import java.util.Hashtable;

import javax.swing.*;


/**
 * The PercentSlider class is a slider that formats its
 * labels using the % sign.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class PercentSlider extends JSlider 
{ 
    /**
     * PercentSlider, constructor
     * &lt;p&gt;
     * Configure the slider for normal percent range,
     * 0-100 and a current value of 0. The default major
     * tick spacing is set to 25 and minor tick spacing
     * to 5. Both labels and ticks are painted.
     * &lt;p&gt;
     * These values can be changed by the client using the 
     * public API.
     *
     * @see JSlider
     **/
    public PercentSlider() { 
        setMinimum( 0 );
        setMaximum( 100 );
        setValue( 0 );
        setMajorTickSpacing( 25 );
        setMinorTickSpacing( 5 );
        setPaintTicks( true );
        setPaintLabels( true );
        
    } 
    
    
    /**
     * Create labels for the slider. Format each label
     * to contain a percent sign. A label is created
     * for each value from:
     * &lt;p&gt;
     *     start + x * increment
     * &lt;p&gt;
     * until the maximum value is reached.
     * &lt;p&gt;
     * @param increment-The delta between labels.
     * @param start-The value of the first label.
     * @return-The table of labels for the slider.
     **/
    public Hashtable createStandardLabels( int increment, int start ) { 
        if ( start &gt; getMaximum() || start &lt; getMinimum() ) { 
            throw new IllegalArgumentException( 
                  &quot;Slider label start point out of range.&quot; );
        } 
        
        NumberFormat percent = NumberFormat.getPercentInstance();

        Hashtable table = new Hashtable();

        for ( int i = start; i &lt;= getMaximum(); i += increment ) { 
            JLabel l = new JLabel( percent.format( ( double )i / 100.0 ) );
            table.put( new Integer( i ), l );
        } 

        return table;
    } 


    /**
     * The label table is created by this class. Do not
     * allow it to be set from the outside.
     * &lt;p&gt;
     * @exception-RuntimeException If this method is called.
     **/
    public void setLabelTable() { 
        throw new RuntimeException( 
              &quot;Can not set the label table for the PercentSlider&quot; );
    } 
    
    
    /**
     * setMajorTickSpacing
     * &lt;p&gt;
     * This method in the JSlider class does not create
     * labels if the label table has been created once.
     * This may cause the labels to be drawn in areas that
     * do not correspond to the major ticks. This is fixed
     * here by creating the label table whenever a new
     * major tick spacing is specified.
     * &lt;p&gt;
     * @param n-The new major tick spacing.
     **/
    public void setMajorTickSpacing( int n ) { 
        if( getMajorTickSpacing() != n )
            setLabelTable( createStandardLabels( n ) );
        super.setMajorTickSpacing( n );
    } 

}  // PercentSlider
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEPrintActionjavaFONTTT"></A><TT>PrintAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Component;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import javax.swing.AbstractAction;
import javax.swing.Icon;


/**
 * Class PrintAction
 * &lt;p&gt;
 * An action that prints the source view.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class PrintAction extends AbstractAction { 

    /**
     * The default name and Icon for the Action.
     **/
    private static final String DEFAULT_NAME = &quot;Print&quot;;
    private static final String DEFAULT_ICON_NAME = &quot;print.gif&quot;;
    private static Icon DEFAULT_ICON;


    /**
     * PrintAction, constructor
     **/
    public PrintAction() { 
        super( DEFAULT_NAME, DEFAULT_ICON );
    }  // PrintAction


    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Perform the action. Print the view showing in the
     * tabbed panel in the frame where the event originated.
     * &lt;p&gt;
     * @param event-The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 
    }  // actionPerformed


    /**
     * static initialization. Load the default Icon.
     **/
    static { 
        try {
            DEFAULT_ICON = ImageLoader.loadIcon( DEFAULT_ICON_NAME );
        }  catch( InterruptedException ie ) { 
            System.err.println( 
                   &quot;Could not load PrintAction default Icon&quot; );
        } 
    } 

}  // PrintAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESetJavaLookAndFeelActionjavaFONTTT"></A><TT>SetJavaLookAndFeelAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.util.Vector;

import javax.swing.Icon;
 

/**
 * Class SetJavaLookAndFeelAction
 * &lt;p&gt;
 * A convenience look-and-feel action that sets the Java look-and-feel.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class SetJavaLookAndFeelAction extends SetLookAndFeelAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Java&quot;;
    
    /**
     * The Java look-and-feel name.
     **/
    private static final String LOOKANDFEEL = 
            &quot;com.sun.java.swing.plaf.metal.MetalLookAndFeel&quot;;
    
    
    public SetJavaLookAndFeelAction() { 
        this( null, null );
    }  // SetJavaLookAndFeelAction
        
    public SetJavaLookAndFeelAction( Icon icon ) { 
        this( icon, null );
    }  // SetJavaLookAndFeelAction
    
    public SetJavaLookAndFeelAction( Vector frames ) { 
        this( null, frames );
    }  // SetJavaLookAndFeelAction
    
    public SetJavaLookAndFeelAction( Icon icon, Vector frames ) { 
        super( DEFAULT_NAME, icon, LOOKANDFEEL, frames );
    }  // SetJavaLookAndFeelAction
    
    public SetJavaLookAndFeelAction( String name, 
                                     Icon icon, 
                                     Vector frames ) { 
        super( name, icon, LOOKANDFEEL, frames );
    }  // SetJavaLookAndFeelAction
    
    
    public String toString() { 
        return( &quot;Java&quot; );
    } 
    
}  // SetJavaLookAndFeelAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESetLookAndFeelActionjavaFONTTT"></A><TT>SetLookAndFeelAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;
 

/**
 * Class SetLookAndFeelAction
 * &lt;p&gt;
 * An action that sets the look-and-feel to the given
 * look-and-feel class name.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class SetLookAndFeelAction extends AbstractAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Set Look and Feel&quot;;
    
    /**
     * The key into our property table of the name of the class 
     * containing the look-and-feel.
     **/
    private static final String LOOKANDFEELNAME_KEY = 
                                &quot;LookAndFeelNameKey&quot;;
        
    /**
     * The key into our property table for the collection of Frames 
     * to update when this action is invoked.
     **/
    private static final String FRAMESTOUPDAT_KEY = &quot;FramesToUpdateKey&quot;;
    
    
    /**
     * Initialize the Action with the given name and look-and-feel name.
     * &lt;p&gt;
     * @param name-The name for the Action.
     * @param lookAndFeelName-The look-and-feel class name.
     **/
    public SetLookAndFeelAction( String name, String lookAndFeelName ) { 
        this( name, null, lookAndFeelName, null );
    }  // SetLookAndFeelAction

    
    /**
     * Initialize the Action with the given name and look-and-feel name.
     * &lt;p&gt;
     * @param name-The name for the Action.
     * @param icon-The Icon for the Action.
     * @param lookAndFeelName-The look and feel class name.
     * @param framesToUpdate-Each Component in this array will have
     *        its component tree udpated when this action is invoked.
     **/
    public SetLookAndFeelAction( String name, 
                                 Icon icon, 
                                 String lookAndFeelName, 
                                 Vector framesToUpdate ) { 
        super( name );
        
        if( lookAndFeelName == null )
            throw new RuntimeException( 
                      &quot;Look-and-feel name may not be null.&quot; );
            
        if( icon != null )
            putValue( SMALL_ICON, icon );
        putValue( LOOKANDFEELNAME_KEY, lookAndFeelName );            
        if( framesToUpdate != null )
            putValue( FRAMESTOUPDAT_KEY, framesToUpdate );
        
    }  // SetLookAndFeelAction

    
    /**
     * actionPerformed, from ActionListener
     * &lt;p&gt;
     * Perform the action. Set the look-and-feel
     * to that defined by the look-and-feel attribute.
     * Update the source frame and frames in the
     * frames Vector.
     * &lt;p&gt;
     * @param event-The event causing the action to fire.
     **/
    public void actionPerformed( ActionEvent event ) { 

        try { 
            String lookAndFeelName = ( String )getValue( 
                                     LOOKANDFEELNAME_KEY );            
            UIManager.setLookAndFeel( lookAndFeelName );        
            
            //
            // Update component tree for the source of the event.
            //
            Object o = event.getSource();
            if( o instanceof Component ) { 
                Frame frame = JOptionPane.getFrameForComponent( 
                                          ( Component )o );
                SwingUtilities.updateComponentTreeUI( frame );                
            } 
            
            //
            // See if there are any registered frames to update.
            //
            Vector framesToUpdate = (Vector)getValue(FRAMESTOUPDAT_KEY);
            if( framesToUpdate != null ) { 
                for( Enumeration e = framesToUpdate.elements(); 
                     e.hasMoreElements(); ) { 
                    Object f = e.nextElement();
                    if( f instanceof Component ) { 
                        Frame frame = JOptionPane.getFrameForComponent( 
                                                  ( Component )f );
                        SwingUtilities.updateComponentTreeUI( frame );                
                    } 
                } 
            } 
        }  catch( ClassNotFoundException cnf ) { 
            throw new RuntimeException( cnf.getLocalizedMessage() );
        }  catch( InstantiationException ie ) { 
            throw new RuntimeException( ie.getLocalizedMessage() );
        }  catch( UnsupportedLookAndFeelException ulf ) { 
            throw new RuntimeException( ulf.getLocalizedMessage() );
        }  catch( IllegalAccessException ia ) { 
            throw new RuntimeException( ia.getLocalizedMessage() );
        }  // catch
        
    }  // actionPerformed

}  // SetLookAndFeelAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESetMotifLookAndFeelActionjavaFONTTT"></A><TT>SetMotifLookAndFeelAction.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.util.Vector;

import javax.swing.Icon;
 

/**
 * Class SetMotifLookAndFeelAction
 * &lt;p&gt;
 * A convenience look-and-feel action that sets the motif look-and-feel.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class SetMotifLookAndFeelAction extends SetLookAndFeelAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Motif&quot;;
    
    /**
     * The motif look-and-feel name.
     **/
    private static final String LOOKANDFEEL = 
                   &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;;
    
    
    public SetMotifLookAndFeelAction() { 
        this( null, null );
    }  // SetMotifLookAndFeelAction
        
    public SetMotifLookAndFeelAction( Icon icon ) { 
        this( icon, null );
    }  // SetMotifLookAndFeelAction
    
    public SetMotifLookAndFeelAction( Vector frames ) { 
        this( null, frames );
    }  // SetJavaLookAndFeelAction
    
    public SetMotifLookAndFeelAction( Icon icon, Vector frames ) { 
        super( DEFAULT_NAME, icon, LOOKANDFEEL, frames );
    }  // SetMotifLookAndFeelAction
    
    public SetMotifLookAndFeelAction( String name, 
                                      Icon icon, 
                                      Vector frames ) { 
        super( name, icon, LOOKANDFEEL, frames );
    }  // SetMotifLookAndFeelAction
    
    
    public String toString() { 
        return( &quot;Motif&quot; );
    } 
    
}  // SetMotifLookAndFeelAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESetWindowsLookAndFeeljavaFONTTT"></A><TT>SetWindowsLookAndFeel.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.util.Vector;

import javax.swing.Icon;
 

/**
 * Class SetWindowsLookAndFeelAction
 * &lt;p&gt;
 * A convenience look-and-feel action that sets the MS Windows look-and-feel.
 * &lt;p&gt;
 * @author Mike Foley
 * @version 1.2
 **/
public class SetWindowsLookAndFeelAction extends SetLookAndFeelAction { 

    /**
     * The default name used in a menu.
     **/
    private static final String DEFAULT_NAME = &quot;Windows&quot;;
    
    /**
     * The Windows look-and-feel name.
     **/
    private static final String LOOKANDFEEL = 
            &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;;
    
    
    public SetWindowsLookAndFeelAction() { 
        this( null, null );
    }  // SetWindowsLookAndFeelAction
    
    public SetWindowsLookAndFeelAction( Icon icon ) { 
        this( icon, null );
    }  // SetWindowsLookAndFeelAction
    
    public SetWindowsLookAndFeelAction( Vector frames ) { 
        this( null, frames );
    }  // SetJavaLookAndFeelAction
        
    public SetWindowsLookAndFeelAction( Icon icon, Vector frames ) { 
        super( DEFAULT_NAME, icon, LOOKANDFEEL, frames );
    }  // SetWindowsLookAndFeelAction
    
    public SetWindowsLookAndFeelAction( String name, 
                                        Icon icon, 
                                        Vector frames ) { 
        super( name, icon, LOOKANDFEEL, frames );
    }  // SetWindowsLookAndFeelAction
    
    
    public String toString() { 
        return( &quot;Windows&quot; );
    } 
    
}  // SetWindowsLookAndFeelAction
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESimpleListCellRendererjavaFONTTT"></A><TT>SimpleListCellRenderer.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.io.*;

import javax.swing.*;
import javax.swing.border.*;


public class SimpleListCellRenderer extends JLabel
    implements ListCellRenderer, Serializable
{ 

    protected static Border emptyBorder;

    public SimpleListCellRenderer() { 
         super();
         
            emptyBorder = BorderFactory.createEmptyBorder( 2, 2, 2, 2 );
            
            //
            // We change the background color, so need to be opaque.
            //
         setOpaque(true);
    } 


    public Component getListCellRendererComponent(
        JList list,
         Object value,
        int index,
        boolean isSelected,
        boolean cellHasFocus)
    { 

         if( isSelected ) { 
             //
             // Draw like any other list when selected.
             //
             setBackground( list.getSelectionBackground() );
             setForeground( list.getSelectionForeground() );
         }  else { 
            //
            // Paint in the list's normal foreground and background 
               colors.
            //
            setBackground( list.getBackground() );
            setForeground( list.getForeground() );
         }  // else

         if( value instanceof Icon ) { 
            setIcon( ( Icon )value);
            setText( &quot;&quot; );
         }  else {
            setIcon( null );
            setText( (value == null ) ? &quot;&quot; : value.toString() );
         }  // else

        setFont( list.getFont() );
        setBorder( ( cellHasFocus ) ? 
                 UIManager.getBorder( &quot;List.focusCellHighlightBorder&quot; ) :
                 emptyBorder );

         return this;
    } 
    
}  // SimpleListRenderer
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESliderValuePaneljavaFONTTT"></A><TT>SliderValuePanel.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;

import javax.swing.*;
import javax.swing.event.*;


/**
 * The SliderValuePanel class is a panel that contains a
 * slider and a label to dipslay the current value in the slider.
 * &lt;p&gt;
 * The current implementation requires the user to get the slider
 * to configure it. Wrapper methods for the BoundedRangeModel 
 * method should be provided.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class SliderValuePanel extends JPanel 
    implements ChangeListener { 
        
    /**
     * Components in the panel.
     **/
    private JSlider slider;
    private JLabel label;
    
    /**
     * The String to which the current value is appended.
     **/
    private static final String labelBase = &quot;Current Value: &quot;;
    
    
    /**
     * SliderValuePanel, constructor
     * &lt;p&gt;
     * Create the JSlider instance and JLabel instance
     * and arrange them in the panel.
     **/
    public SliderValuePanel() { 
        super();
        
        setLayout( new BorderLayout() );
        
        slider = new JSlider();
        slider.setMajorTickSpacing( 20 );
        slider.setMinorTickSpacing( 5 );
        slider.setPaintTicks( true );
        slider.setPaintLabels( true );
        
        label = new JLabel( labelBase + slider.getValue() );
        
        add( slider, BorderLayout.CENTER );
        add( label, BorderLayout.SOUTH );
        
        slider.addChangeListener( this );
    } 
    
    
    /**
     * Return the slider in this panel. This allows
     * clients to get a handle to the slider and configure
     * it is required.
     * &lt;p&gt;
     * @return-The slider in this panel.
     **/
    public JSlider getSlider() { 
        return( slider );
    } 
    
    
    /**
     * stateChanged, from ChangeListener
     * &lt;p&gt;
     * The slider in the panel value has changed.
     * Update the label's text.
     * &lt;p&gt;
     * @param ChangeEvent event-The event causing this method to be 
     *                              called.
     **/
    public void stateChanged( ChangeEvent event ) { 
        label.setText( labelBase + slider.getValue() );
    } 
    
}  // SliderValuePanel
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZESplashWindowjavaFONTTT"></A><TT>SplashWindow.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.*;
import java.beans.*;
import javax.swing.*;


/**
 * A window that contains an image.
 *
 * @author Mike Foley
 **/
public class SplashWindow extends JWindow { 

    /**
     * The Icon displayed in the window.
     **/
    private Icon splashIcon;
    
    /**
     * A label used to display the Icon.
     **/
    private JLabel iconLabel;
    
    /**
     * Bound property support and name constants.
     **/
    private PropertyChangeSupport changeSupport;
    public static final String SPLASHICON_PROPERTY = &quot;SplashIcon&quot;;
    
    
    /**
     * SplashWindow, null constructor.
     **/
    public SplashWindow() { 
        this( null );
    } 

    
    /**
     * SplashWindow, constructor.
     *
     * @param splashIcon-The Icon to view in the window.
     **/
    public SplashWindow( Icon splashIcon ) { 
        super();
        iconLabel = new JLabel();
        iconLabel.setBorder( BorderFactory.createRaisedBevelBorder() );
        getContentPane().add( iconLabel, BorderLayout.CENTER );
        setSplashIcon( splashIcon );
    } 


    /**
     * Set the image displayed in the window.
     * This is a bound property named SPLASHICON_PROPERTY.
     * If this property is changed when the window is
     * visible, the window is NOT re-centered on the screen.
     *
     * @param splashIcon-The icon to draw in the window.
     **/
    public void setSplashIcon( Icon splashIcon ) { 
        Icon old = this.splashIcon;
        this.splashIcon = splashIcon;
        iconLabel.setIcon( splashIcon );
        pack();
        if( changeSupport != null ) { 
            changeSupport.firePropertyChange( SPLASHICON_PROPERTY, 
                                              old, splashIcon );
        } 
    } 

    
    /**
     * Extend the setVisible method to center this window
     * on the screen before being displayed.
     *
     * @param visible-True if showing the window, false if hiding.
     **/
    public void setVisible( boolean visible ) { 
        
        if( visible ) { 
            
            //
            // Display the window in the center of the screen.
            //
            Dimension screenSize = 
                Toolkit.getDefaultToolkit().getScreenSize();
            Dimension size = getSize();
            int x;
            int y;

            x = screenSize.width / 2 - size.width / 2;
            y = screenSize.height / 2 - size.height / 2;
                                    
                setBounds( x, y, size.width, size.height);
        } 
        
        //
        // Let super show or hide the window.
        //
        super.setVisible( visible );
    } 
    
    
    /**
     * Need to handle PropertyChangeListeners here until this
     * type of code is moved from JComponent to Component.
     **/
    public synchronized void addPropertyChangeListener(
                             PropertyChangeListener listener) { 
        if (changeSupport == null) { 
            changeSupport = new PropertyChangeSupport(this);
        } 
        changeSupport.addPropertyChangeListener(listener);
    } 
    public synchronized void removePropertyChangeListener(
                             PropertyChangeListener listener) { 
        if (changeSupport != null) { 
            changeSupport.removePropertyChangeListener(listener);
        } 
    } 
    
}  // SplashWindow
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZETableMapjavaFONTTT"></A><TT>TableMap.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;


import javax.swing.table.*;
import javax.swing.event.TableModelListener;
import javax.swing.event.TableModelEvent;


/**
 * Based on the example that comes with the Swing download.
 **/
public class TableMap extends AbstractTableModel 
    implements TableModelListener { 

    /**
     * The downstream model.
     **/
    protected TableModel model;

    /**
     * @return-Our table model.
     **/
    public TableModel  getModel() { 
        return model;
    } 

    /**
     * Set our downstream table model.
     * If we already have a table model, stop listening
     * to that model and start listening to the new
     * model.
     * &lt;p&gt;
     * 2param The new model.
     **/
    public void  setModel(TableModel model) { 
        if( this.model != null )
            this.model.removeTableModelListener(this);
        this.model = model;
        if( this.model != null )
            this.model.addTableModelListener(this);
    } 

    public Object getValueAt(int aRow, int aColumn) { 
        return model.getValueAt(aRow, aColumn);
    } 

    public void setValueAt(Object aValue, int aRow, int aColumn) { 
        model.setValueAt(aValue, aRow, aColumn);
    } 

    public int getRowCount() { 
        return (model == null) ? 0 : model.getRowCount();
    }

    public int getColumnCount() { 
        return (model == null) ? 0 : model.getColumnCount();
    } 

    public String getColumnName(int aColumn) { 
        return model.getColumnName(aColumn);
    } 

    public Class getColumnClass(int aColumn) { 
        return model.getColumnClass(aColumn);
    } 

    public boolean isCellEditable(int row, int column) { 
         return model.isCellEditable(row, column);
    } 

    public void tableChanged(TableModelEvent e) { 
        fireTableChanged(e);
    } 

}  // TableMap
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZETableSorterjavaFONTTT"></A><TT>TableSorter.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.util.*;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.InputEvent;

import javax.swing.JTable;

import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

import javax.swing.event.TableModelEvent;


/**
 * Based on the demo class that comes with the Swing package.
 **/
public class TableSorter extends TableMap
{ 
    int             indexes[];
    Vector          sortingColumns = new Vector();
    boolean         ascending = true;
    int compares;

    public TableSorter()
    { 
        indexes = new int[0]; // For consistency.
    } 

    public TableSorter(TableModel model)
    { 
        setModel(model);
    } 

    public void setModel(TableModel model) { 
        super.setModel(model);
        reallocateIndexes();
    } 

    public int compareRowsByColumn(int row1, int row2, int column)
    { 
        Class type = model.getColumnClass(column);
        TableModel data = model;

        // Check for nulls

        Object o1 = data.getValueAt(row1, column);
        Object o2 = data.getValueAt(row2, column);

        // If both values are null return 0
        if (o1 == null &amp;&amp; o2 == null) { 
            return 0;
        } 
        else if (o1 == null) {  // Define null less than everything.
            return -1;
        } 
        else if (o2 == null) { 
            return 1;
        } 

        if (type.getSuperclass() == java.lang.Number.class)
            { 
                Number n1 = (Number)data.getValueAt(row1, column);
                double d1 = n1.doubleValue();
                Number n2 = (Number)data.getValueAt(row2, column);
                double d2 = n2.doubleValue();

                if (d1 &lt; d2)
                    return -1;
                else if (d1 &gt; d2)
                    return 1;
                else
                    return 0;
            } 
        else if (type == java.util.Date.class)
            {
                Date d1 = (Date)data.getValueAt(row1, column);
                long n1 = d1.getTime();
                Date d2 = (Date)data.getValueAt(row2, column);
                long n2 = d2.getTime();

                if (n1 &lt; n2)
                    return -1;
                else if (n1 &gt; n2)
                    return 1;
                else return 0;
            } 
        else if (type == String.class)
            { 
                String s1 = ( (String)data.getValueAt(
                            row1, column) ).toUpperCase();
                String s2    = ( (String)data.getValueAt(
                            row2, column) ).toUpperCase();
                int result = s1.compareTo(s2);

                if (result &lt; 0)
                    return -1;
                else if (result &gt; 0)
                    return 1;
                else return 0;
            }
        else if (type == Boolean.class)
            { 
                Boolean bool1 = (Boolean)data.getValueAt(row1, column);
                boolean b1 = bool1.booleanValue();
                Boolean bool2 = (Boolean)data.getValueAt(row2, column);
                boolean b2 = bool2.booleanValue();

                if (b1 == b2)
                    return 0;
                else if (b1) // Define false &lt; true
                    return 1;
                else
                    return -1;
            } 
        else
            { 
                Object v1 = data.getValueAt(row1, column);
                String s1 = v1.toString();
                Object v2 = data.getValueAt(row2, column);
                String s2 = v2.toString();
                int result = s1.compareTo(s2);

                if (result &lt; 0)
                    return -1;
                else if (result &gt; 0)
                    return 1;
                else return 0;
            }
    } 

    public int compare(int row1, int row2)
    { 
        compares++;
        for(int level = 0; level &lt; sortingColumns.size(); level++)
            { 
                Integer column = 
                        (Integer)sortingColumns.elementAt(level);
                int result = compareRowsByColumn(row1, row2, 
                        column.intValue());
                if (result != 0)
                    return ascending ? result : -result;
            } 
        return 0;
    } 

    public void  reallocateIndexes()
    { 
        int rowCount = model.getRowCount();

        // Set up a new array of indexes with the right number of 
        // elements for the new data model.
        //
        indexes = new int[rowCount];

        // Initialise with the identity mapping.
        for(int row = 0; row &lt; rowCount; row++)
            indexes[row] = row;
    } 

    public void tableChanged(TableModelEvent e)
    { 
        reallocateIndexes();
        sortByColumn(0);
        fireTableStructureChanged();
    } 

    public void checkModel()
    { 
        if (indexes.length != model.getRowCount()) { 
            System.err.println(
                   &quot;Sorter not informed of a change in model.&quot;);
        } 
    } 

    public void  sort(Object sender)
    { 
        checkModel();

        compares = 0;
        shuttlesort((int[])indexes.clone(), indexes, 0, indexes.length);
    }


    public void shuttlesort(int from[], int to[], int low, int high) { 
        if (high - low &lt; 2) { 
            return;
        } 
        int middle = (low + high)/2;
        shuttlesort(to, from, low, middle);
        shuttlesort(to, from, middle, high);

        int p = low;
        int q = middle;

        if (high - low &gt;= 4 &amp;&amp; 
            compare(from[middle-1], from[middle]) &lt;= 0) { 
            for (int i = low; i &lt; high; i++) { 
                to[i] = from[i];
            } 
            return;
        } 

        for(int i = low; i &lt; high; i++) { 
            if (q &gt;= high || 
               (p &lt; middle &amp;&amp; compare(from[p], from[q]) &lt;= 0)) { 
                to[i] = from[p++];
            } 
            else { 
                to[i] = from[q++];
            } 
        } 
    } 

    public void swap(int i, int j) { 
        int tmp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = tmp;
    } 

    public Object getValueAt(int aRow, int aColumn)
    { 
        checkModel();
        return model.getValueAt(indexes[aRow], aColumn);
    } 

    public void setValueAt(Object aValue, int aRow, int aColumn)
    { 
        checkModel();
        model.setValueAt(aValue, indexes[aRow], aColumn);
    } 

    public void sortByColumn(int column) { 
        sortByColumn(column, true);
    } 

    public void sortByColumn(int column, boolean ascending) { 
        this.ascending = ascending;
        sortingColumns.removeAllElements();
        sortingColumns.addElement(new Integer(column));
        sort(this);
        super.tableChanged(new TableModelEvent(this));
    } 

}  // TableSorter
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZETextFilterDocumentjavaFONTTT"></A><TT>TextFilterDocument.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.Toolkit;

import javax.swing.text.*;


/**
 * Document to only allow numbers.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class TextFilterDocument extends PlainDocument { 

    /**
     * Valid number strings.
     **/
    public static final String NUMBERS = &quot;0123456789&quot;;
    
    
    /**
     * TextFilterDocument, constructor
     **/
    public TextFilterDocument()
    { 
        super();
    } 


    /**
     * A String is being inserted into the document.
     * Ensure that all characters are in NUMBERS.
     *
     * @param offset-Where the new string goes.
     * @param string-The String to be inserted after check.
     * @param attributeSet-Attributes for the new string.
     **/
    public void insertString( int offset, String string, 
                              AttributeSet attributeSet )
        throws BadLocationException { 
  
        //
        // If nothing to insert, do nothing.
        //
        if( string == null )
            return;

        //
        // Ensure each character in the string is a number.
        //
        for( int i = 0; i &lt; string.length(); i++ ) { 
            if( NUMBERS.indexOf( string.valueOf( 
                string.charAt(i) ) ) == -1 ) { 
                    
                //
                // Not a number, don't insert the string.
                // Beep to let the user know something is wrong.
                //
                Toolkit.getDefaultToolkit().beep();
                return;
            } 
        } 
        
        //
        // Let our parent do the real work.
        //
        super.insertString( offset, string, attributeSet );
        
    }  // insertString

}  // TextFilterDocument
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZETreeLeafEditorjavaFONTTT"></A><TT>TreeLeafEditor.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.*;
import java.util.*;

import javax.swing.*;
import javax.swing.tree.*;
    

/**
 * A tree editor that only allows editing of leaf nodes.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class TreeLeafEditor extends DefaultCellEditor { 
    
    /**
     * The tree we are editing.
     **/
    JTree tree;
    
    public TreeLeafEditor( JTree tree ) { 
        super( new JTextField() );
        this.tree = tree;
    } 
    

    /**
     * The cell is only editable if it is a leaf node and
     * the number of mouse clicks is equal to the value
     * returned from the getClickCountToStart method.
     * &lt;p&gt;
     * @param event-The event to test for cell editablity.
     * @return-True if the cell is editable given the current event.
     * @see-getClickCountToStart
     **/
    public boolean isCellEditable( EventObject event ) { 

        if( event instanceof MouseEvent ) { 
            MouseEvent mouseEvent = ( MouseEvent )event;
            if( mouseEvent.getClickCount() == getClickCountToStart() ) { 
                TreePath hitPath = tree.getPathForLocation( 
                                          mouseEvent.getX(), 
                                          mouseEvent.getY() );
                Object hitObject = hitPath.getLastPathComponent();
                if( hitObject instanceof TreeNode )
                    return( ( ( TreeNode )hitObject ).isLeaf() );
            } 
        } 
        return( false );
    } 
    
}  // TreeLeafEditor
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZETwoStateInterfacejavaFONTTT"></A><TT>TwoStateInterface.java</TT></H2>

<BLOCKQUOTE>
	<PRE>//Title:      Utility Beans
//Version:    1.1
//Copyright:  Copyright (c) 1997
//Author:     Mike Foley
//Company:    Foley, Inc.
//Description:A collection of usefull beans.

package com.foley.utility;

import java.awt.AWTEvent;


/**
 * TwoStateInterface
 *
 * An interface for components that have two states.
 *
 * @author Mike Foley
 * @version 1.1
 *
 **/
public interface TwoStateInterface { 
     public abstract boolean queryState();
     public abstract void stateOn();
     public abstract void stateOff();
}  // TwoStateInterface
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEWindowsNonExpandingTreeUIjavaFONTTT"></A><TT>WindowsNonExpandingTreeUI.java</TT></H2>

<BLOCKQUOTE>
	<PRE>package com.foley.utility;

import java.awt.event.MouseEvent;

import javax.swing.JComponent;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicTreeUI;


/**
 * A TreeUI that does not automatically expand or
 * collapse the tree on a double-click event.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class WindowsNonExpandingTreeUI extends BasicTreeUI
{ 

    /**
     * Create the UI object for the given tree. This
     * is a new instance of this class.
     **/
    public static ComponentUI createUI( JComponent tree ) { 
         return( new WindowsNonExpandingTreeUI() );
    } 


    /**
     * WindowsNonExpandingTreeUI, constructor
     **/
    public WindowsNonExpandingTreeUI() { 
         super();
    } 


    /**
     * Returning true indicates the row under the mouse should be toggled
     * based on the event. This is invoked after 
     * checkForClickInExpandControl, implying the location is not in the
     * expand (toggle) control
     * &lt;p&gt;
     * This is the behavior we want to squish, so always return false.
     * &lt;p&gt;
     * @return false
     **/
    protected boolean isToggleEvent( MouseEvent event ) { 
         return( false );
    } 

}  // WindowsNonExpandingTreeUI
</PRE>
</BLOCKQUOTE>
<CENTER>
<P>
<HR SIZE="4">
<A HREF="..\apb\apb.htm"><IMG SRC="..\button\previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" BORDER="0"></A> <A HREF="..\index.htm"><IMG SRC="..\button\contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A></P>
<P>&copy; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>
</BODY>
</HTML>
