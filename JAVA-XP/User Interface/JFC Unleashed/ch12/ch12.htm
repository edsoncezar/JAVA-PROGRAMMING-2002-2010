<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 12 - Table Component</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch11\ch11.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch13\ch13.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;12<br>
Table Component</H1>
<HR>
<p>


<UL>
<LI><A HREF="#TableElements">
Table Elements</A>
<LI><A HREF="#ASimpleTable">
A Simple Table</A>
<LI><A HREF="#TableSelectionModels">
Table Selection Models</A>
<LI><A HREF="#ColumnCreationandResizingModes">
Column Creation and Resizing Modes</A>
<LI><A HREF="#ModelsandSupportClassesUsedbytheTTFONTSIZEJTableFONTTTFONTSIZEClassFONT">
Models and Support Classes Used by the <TT>JTable</TT>
Class</A>
<UL>
<LI><A HREF="#TheTTFONTSIZETableModelFONTTTFONTSIZEInterfaceandSupportClassesFONT">
The <TT>TableModel</TT> Interface
and Support Classes</A>
<LI><A HREF="#TheTTFONTSIZETableColumnModelFONTTTFONTSIZEInterfaceandAssociatedClassesFONT">
The <TT>TableColumnModel</TT>
Interface and Associated Classes</FONT></A>
<LI><A HREF="#PullingItAllTogetherATTFONTSIZEJTableFONTTTFONTSIZEExampleFONT">
Pulling It All Together: A <TT>JTable</TT>
Example</A>
<LI><A HREF="#EntireSourceListingoftheTTFONTSIZETableTestFONTTTFONTSIZEApplicationFONT">
Entire Source Listing of the <TT>TableTest</TT>
Application</A>
</UL>
<LI><A HREF="#ScrollingaTable">
Scrolling a Table</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The <TT>JTable</TT> <TT>component</TT> is the <TT>most</TT> <TT>complex</TT>
<TT>visual</TT> component in the JFC toolkit. During the review
phases of the toolkit, the <TT>JTable</TT> class underwent the
most API changes before they were stabilized to those contained
in the current <TT>JTable</TT> class. To effectively use the <TT>JTable</TT>
class in your applications, you must understand what the component
is and is not designed to do. First, it is not a spreadsheet.
However, you could have it view a spreadsheet data model. The
<TT>JTable</TT> class is designed to be a high performance view
of tabular data. The data is contained in a data model separate
from the view. The columns in the table can be in a different
order than they are in the data model. Not all columns in the
data model need be displayed in the table. The table can be configured
to allow selection of rows, columns, both rows and columns, or
single cells.
<P>
This chapter will lead you through the complexities of using the
<TT>JTable</TT> class. You will start with simply displaying tabular
data in a table and continue to highly customize the table's appearance.
<P>
You will learn how to
<UL>
<LI>Display tabular data in a table
<LI>Use the <TT>TableModel</TT> interface and other support classes
and interfaces in the Table package
<LI>Control selection in a table
<LI>Add renderers and editors to a table
<LI>Customize the table's headers
</UL>
<H2><A NAME="TableElements">
Table Elements</A></H2>
<P>
The <TT>JTable</TT> class delegates a great deal of functionality
to support classes located in the <TT>swing.table</TT> package.
A typical table is shown in Figure 12.1. In this figure, the various
delegates are shown. The headers are displayed in an instance
of the <TT>JTableHeader</TT> class. Each column is an instance
of the <TT>TableColumn</TT> class that is managed by an instance
of the <TT>TableColumnModel</TT> class. Selection is delegated
to one or more <TT>ListSelectionModel</TT> instances. Finally,
the data displayed in the table is encapsulated in a <TT>TableModel</TT>.
A <TT>TableCellEditor</TT> is shown editing color values in the
figure. A <TT>TableCellRenderer</TT> is used to paint the cells
that are not being edited. Using and customizing these classes
are the subjects of the remainder of this chapter.
<P>
<A HREF="javascript:popUp('f12-1.gif')"><B>Figure 12.1 :</B> <I>The JTable class delegates</I>.</A>
<H2><A NAME="ASimpleTable">
A Simple Table</A></H2>
<P>
The <TT>JTable</TT> and its associated classes and interfaces
provide a wealth of features and customization possibilities.
However, sometimes you just want to present tabular data in a
table. The <TT>JTable</TT> class contains methods for easily performing
simple tasks as well as the complex issues covered later in this
chapter.
<P>
The <TT>JTable</TT> class contains a pair of constructors for
creating a table from simple Java collections. The first takes
a two-dimensional array as its first parameter, the second takes
a <TT>Vector</TT> of <TT>Vectors</TT>. As its second parameter,
each method requires that the column names for the table be stored
in the same class of collection as the data. The <TT>SimpleTableTest</TT>
application shown in Listing 12.1 creates a table by passing a
<TT>Vector</TT> containing the data for the table and another
<TT>Vector</TT> containing the column names to the <TT>JTable</TT>
constructor. The table created by the application is shown in
Figure 12.2.
<P>
<A HREF="javascript:popUp('f12-2.gif')"><B>Figure 12.2 :</B> <I>The SimpleTableTest application</I>.</A>
<P>
The <TT>Vector</TT> containing the data is a <TT>Vector</TT> of
<TT>Vectors</TT>. Each <TT>Vector</TT> contained by the wrapping
vector represents one row in the table. The default technique
to view each object in the table is to call its <TT>toString</TT>
method. This is appropriate for many types of objects, but not
all. For example, columns two and three in this table could be
better represented by using the actual color for column two and
a check box for column three. Later in this chapter you will see
how this can be accomplished by setting renderers for the table.
<p>
<HR>
<P>
<B>Listing 12.1&nbsp;&nbsp;The </B><TT><B>SIMPLETABLETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import java.util.Vector;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTable instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class SimpleTableTest extends Object { 

    /**
     * Application entry point.
     * Create a frame, the table and display it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;SimpleTableTest Vector&quot; );
        Vector data = new Vector();        
        Vector row = new Vector();
        row.addElement( &quot;Mike&quot; );
        row.addElement( Color.blue );
        row.addElement( new Boolean( true ) );
        data.addElement( row );
        
        row = new Vector();
        row.addElement( &quot;Mari&quot; );
        row.addElement( Color.red );
        row.addElement( new Boolean( true ) );
        data.addElement( row );
        
        row = new Vector();
        row.addElement( &quot;Molly&quot; );
        row.addElement( Color.yellow );
        row.addElement( new Boolean( false ) );
        data.addElement( row );
        
        Vector columnNames = new Vector();
        columnNames.addElement( &quot;Name&quot; );
        columnNames.addElement( &quot;Color&quot; );
        columnNames.addElement( &quot;Boolean&quot; );        
        JTable table = new JTable( data, columnNames );

        table.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( table, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // SimpleTableTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>SimpleTableTest</TT> application creates a bare-bones
table. It doesn't display the column names, and the column width
is too small for the second column. To create a more pleasing
table, more than just the constructor needs to be called.
<P>
The table header can be queried from the table by calling the
<TT>getTableHeader</TT> method and arranged anywhere you want.
Typically, the header is shown above the data. The following code
creates the table and displays its header above the table. The
resulting table is shown in Figure 12.3.
<P>
<A HREF="javascript:popUp('f12-3.gif')"><B>Figure 12.3 :</B> <I>A table with the header displayed</I>.</A>
<BLOCKQUOTE>
<PRE>
JTable table = new JTable( data, columnNames );
JTableHeader tableHeader = table.getTableHeader();
                
JPanel tablePanel = new JPanel();
tablePanel.setBorder( BorderFactory.createLoweredBevelBorder() );
tablePanel.setLayout( new BorderLayout() );
tablePanel.add( tableHeader, BorderLayout.NORTH );
tablePanel.add( table, BorderLayout.CENTER );

frame.getContentPane().add( tablePanel, BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<P>
The header is an instance of the <TT>JTableHeader</TT> class contained
in the <TT>java.awt.swing.table</TT> package. It allows the area
between two columns to be dragged to resize the columns. The column
name itself can be dragged to change the order of the columns
in the table. (This is the default behavior of the <TT>JTableHeader</TT>
class; later you will see how to change this.)
<P>
If this code seems like a lot of work to display the columns for
a table, you are correct; it is. The <TT>JTable</TT> class contains
specialized code for handling the typical configuration of a table,
that being the table placed in a scroll pane. (The <TT>JScrollPane</TT>
class is discussed in <A HREF="..\ch15\ch15.htm" >Chapter 15</A>, &quot;Scrolling Components.&quot;)
The <TT>JTable</TT> class detects when it is added to a <TT>JScrollPane</TT>
and configures itself appropriately. The configuration is performed
in the protected <TT>configureEnclosingScrollPane</TT> method.
This protected method allows extensions to the <TT>JTable</TT>
class to alter a table's configuration when it is added to a <TT>JScrollPane</TT>
instance. The earlier example can be simplified to the following
code that creates the table shown in Figure 12.4.
<P>
<A HREF="javascript:popUp('f12-4.gif')"><B>Figure 12.4 :</B> <I>Simplified JTable construction</I>.</A>
<BLOCKQUOTE>
<PRE>
JTable table = new JTable( data, columnNames );
frame.getContentPane().add( new JScrollPane( table ), 
                            BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<P>
After the table has been placed in a <TT>JScrollPane</TT>, its
scrolling behavior is specified in the <TT>JTable</TT> class.
The <TT>JTable</TT> class implements the <TT>Scrollable</TT> interface.
This interface is discussed in <A HREF="..\ch15\ch15.htm" >Chapter 15</A>. The <TT>JTable</TT>
class returns <TT>false</TT> from the <TT>getScrollableTracksViewportWidth</TT>
and <TT>getScrollableTracksViewportHeight</TT> methods to signify
that the table width and height are not determined by the scroll
pane's viewport size. The <TT>JTable</TT> class returns the height
of a row for the vertical unit scrolling increment and one pixel
for the horizontal unit scroll increment. It would be an improvement
if the horizontal scrolling increment could be set to the width
of the column being scrolled out of view. The block scrolling
size is set to both the horizontal and vertical viewport size.
This enables one &quot;page&quot; of the table to be scrolled
in block mode. The preferred size for the viewport can be set
by using the <TT>setPreferredScrollableViewportSize</TT> method.
This value is used by the viewport to set its size.
<P>
Passing <TT>false</TT> to the <TT>setShowGrid</TT> method will
hide the grid displayed in the table. Also, you can show only
the vertical or horizontal portion of the grid with the <TT>setShow-HorizontalLines</TT>
and <TT>setShowVerticalLines</TT> methods. Passing <TT>true</TT>
or <TT>false</TT> to these methods will show or hide the lines
in the table. If the table in the <TT>SimpleTableTest</TT> application
is created as follows, only the horizontal lines in the table
will be displayed. This is seen in Figure 12.5. The color of the
grid can be set with the <TT>setGridColor</TT> method. The <TT>getGridColor</TT>
method returns the current value of the grid. Neither the display
state or color of the grid are bound properties in the <TT>JTable</TT>
class.
<P>
<A HREF="javascript:popUp('f12-5.gif')"><B>Figure 12.5 :</B> <I>A table with blue horizontal grid-lines</I>.</A>
<BLOCKQUOTE>
<PRE>
JTable table = new JTable( data, columnNames );
table.setShowGrid( false );
table.setShowHorizontalLines( true );
table.setGridColor( Color.blue );
frame.getContentPane().add( new JScrollPane( table ), 
                            BorderLayout.CENTER );
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TableSelectionModels">
Table Selection Models</A></H2>
<P>
The <TT>SimpleTableTest</TT> application was presented in the
previous section. This application created a <TT>JTable</TT> instance
that used the default table selection model row selection. However,
the <TT>JTable</TT> class supports many selection modes. The table
delegates both column and row selection to a class that implements
the <TT>ListSelectionModel</TT> interface. Internally, this class
is the <TT>DefaultListSelectionModel</TT> class that was presented
in <A HREF="..\ch10\ch10.htm" >Chapter 10</A>, &quot;<TT>JList</TT>, <TT>JComboBox</TT>, and Bound
Controls.&quot; Thus, the selection modes for rows and columns
in a table are the same as rows in a list. These are single selection
mode, contiguous selection mode, and non-contiguous selection
mode. The table can also be configured to allow only cells to
be selected instead of entire rows or columns.
<P>
The selection mode can be set by querying the selection model
from the table and setting the desired mode directly, or by calling
convenience methods provided by the <TT>JTable</TT> class that
update the selection models themselves.
<P>
You'll start by looking at the convenience functions provided
by the <TT>JTable</TT> class. The easiest methods to use for configuring
selection are <TT>setRowSelectionAllowed</TT> and <TT>setColumnSelectionAllowed</TT>.
Passing <TT>true</TT> to either of these methods enables the selection,
and <TT>false</TT> disables it. Passing <TT>false</TT> to both
these methods will enable cell selection. The <TT>setSelectionMode</TT>
method is used to set the type of selection allowed. The selection
mode is defined in the <TT>ListSelectionModel</TT> interface described
in <A HREF="..\ch10\ch10.htm" >Chapter 10</A>. Possible modes that can be passed to this method
are <TT>ListSelectionModel.SINGLE_SELECTION</TT>, <TT>ListSelectionModel.SINGLE_INTERVAL_SELECTION</TT>,
and <TT>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION</TT>. For
a complete description of these modes, see <A HREF="..\ch10\ch10.htm" >Chapter 10</A>. 
<P>
Calling the <TT>setSelectionMode</TT> method contained in the
<TT>JTable</TT> class sets the new mode for both the row and column
selection model. If you require a different selection mode for
rows and columns, the mode must be set on the selection model
itself. The row selection model can be obtained by calling the
<TT>getSelectionModel</TT> method contained in the <TT>JTable</TT>
class. To obtain a handle to the column selection model, you must
go through the column model. The column model is obtained via
the <TT>getColumnModel</TT> method. With the column model in hand,
its <TT>getSelectionModel</TT> method can be called to obtain
the column selection model. Then the <TT>setSelectionMode</TT>
method of the model can be called. 
<P>
The foreground and background colors of selected cells can be
specified by using the <TT>setSelectionForeground</TT> and <TT>setSelectionBackground</TT>
methods, respectfully. There are corresponding &quot;get&quot;
versions of these methods to obtain the current value of the property.
The <TT>selectionForeground</TT> and <TT>selectionBackground</TT>
properties are the only bound properties contained in the <TT>JTable</TT>
class. At first glance this may seem odd for such a large class.
However, as you will see later in this chapter, the <TT>JTable</TT>
class delegates much of its functionality to support classes that
contain bound properties or defines dedicated listener interfaces
and events to notify observers of changes. 
<P>
With that said, there are properties in the <TT>JTable</TT> class
that should be bound but are not. The <TT>gridColor</TT> property
immediately comes to mind. The bound properties for the <TT>JTable</TT>
class are shown in Table 12.1. Notice that the property names
are hard-coded strings in the <TT>JTable</TT> class. Use caution
when testing for these property names in your source code.<BR>
<P>
<CENTER><B>Table 12.1&nbsp;&nbsp;Bound Properties of the </B><TT><B>JTABLE</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=155><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=155><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=155><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=155><TT>selectionBackground</TT></TD><TD WIDTH=155><TT>setSelection
<BR>
Background</TT>
</TD><TD WIDTH=155><TT>getselection<BR>
Background</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=155><TT>selectionForeground</TT></TD><TD WIDTH=155><TT>setSelection<BR>
Foreground</TT>
</TD><TD WIDTH=155><TT>getselection<BR>
Foreground</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The previous paragraph explained how to set the selection mode
for a <TT>JTable</TT> instance. After the mode is set, it may
be necessary to set or query the selection set in the table. The
methods presented in <A HREF="..\ch10\ch10.htm" >Chapter 10</A> for the <TT>ListSelectionModel</TT>
can be used for setting and getting the set of selected rows or
columns from the row or column list selection model. The <TT>JTable</TT>
class also provides convenience functions for many of these methods.
This allows the selected rows and columns to be queried directly
from the table. 
<P>
The <TT>setRowSelectionInterval</TT> can be used to select rows
in an inclusive range defined by the two integer parameters passed
to the method. Rows can be inserted into the selection set by
using <TT>addRowSelectionInterval</TT>. This method also takes
two parameters to define the inclusive range of rows to add to
the selected row set. The selection mode must support the rows
added to the set or all rows cannot be selected. 
<P>
The <TT>setColumnSelectionInterval</TT> and <TT>addColumnSelectionInterval</TT>
methods provide analogous functionality for columns. Rows or columns
can be removed from the selection set with the <TT>removeRowSelectionInterval</TT>
and the <TT>removeColumnSelectionInterval</TT> methods. Both these
methods also take two integer parameters that define the inclusive
range of rows or columns to be removed from the selection set.
To remove a single row from the selected set, both parameters
would be the same: the row to be deselected.
<P>
The <TT>clearSelection</TT> method clears both the row and column
selection set. The <TT>selectAll</TT> method checks the current
selection, and, if a row is selected, all rows are selected. Also,
if a column is selected, all columns are selected. If both are
selected when this method is called, all rows and columns are
selected.
<P>
The number of selected rows can be determined with the <TT>getSelectedRowCount
method</TT>. The <TT>getSelectedRows</TT> method returns an array
of the indices of all selected rows or an empty array if there
are not any selected rows. The <TT>getSelectedRow</TT> method
returns the index of the last selected row, or <TT>-1</TT> if
no rows are selected. The equivalent methods for querying column
selection status are <TT>getSelectedColumnCount</TT>, <TT>getSelectedColumns</TT>,
and <TT>getSelectedColumn</TT>. The table provides the <TT>isRowSelected</TT>,
<TT>isColumnSelected</TT>, and <TT>isCellSelected</TT> method
to easily test if a row, column, or cell is selected.
<P>
The <TT>ListSelectionModel</TT> for rows or columns can be set
directly. This allows for custom selection models, or, as was
shown in <A HREF="..\ch10\ch10.htm" >Chapter 10</A> for the <TT>JList</TT> class, for sharing
selection models. A <TT>ListSelectionModel</TT> can be shared
between lists and tables. For rows, the <TT>ListSelectionModel</TT>
is set by using the <TT>setSelectionModel</TT> method. To set
the selection model for columns, the column model must first be
obtained from the table, and then the selection model set on the
column model. This can be done with the following code fragment:
<BLOCKQUOTE>
<PRE>
ListSelectionModel mySelectionModel;
// mySelectionModel created and initialized.
table.getColumnModel().setSelectionModel( mySelectionModel );
</PRE>
</BLOCKQUOTE>
<H2><A NAME="ColumnCreationandResizingModes">
Column Creation and Resizing Modes</A></H2>
<P>
You can configure <TT>JTable</TT> instances to automatically create
columns whenever its data model is set or changes structure. Passing
<TT>true</TT> to the <TT>setAutoCreateColumnsFromModel</TT> method
enables this capability. The columns are created in the <TT>createDefault
ColumnsFromModel</TT> method. This method creates an instance
of the <TT>TableColumn</TT> class for each column in the model
and adds it to the table. The <TT>TableColumn</TT> class is discussed
further in the next section. The current value of this property
can be queried by using the <TT>getAutoCreateColumnsFromModel</TT>
method. If this property is <TT>false</TT>, it is the table's
client's responsibility to create and add columns to the table.
<TT>createDefaultColumnsFromModel</TT> is a public method that
can be called by clients.
<P>
Column headers allow columns to be resized by dragging on the
border between two columns. (Columns can be configured to not
be resizable, or have minimum and maximum sizes. This will be
shown in the next section.) As the user drags to set a column's
width, the behavior of other columns is defined by the <TT>autoResizeMode</TT>
property. The <TT>setAutoResizeMode</TT> sets the property to
one of the three legal values shown in Table 12.2. These values
are integer constants defined in the <TT>JTable</TT> class.<BR>
<P>
<CENTER><B>Table 12.2&nbsp;&nbsp;Column Resize Modes</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=250><CENTER><B>Mode Constant</B></CENTER></TD><TD WIDTH=250><CENTER><B>Behavior</B></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=250><TT>AUTO_RESIZE_OFF</TT></TD><TD WIDTH=250>Do nothing
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=250><TT>AUTO_RESIZE_LAST_COLUMN</TT></TD><TD WIDTH=250>Space goes to last column
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=250><TT>AUTO_RESIZE_ALL_COLUMNS</TT></TD><TD WIDTH=250>Space distributed between all columns
</TD></TR>
</TABLE></CENTER>
<P>
<P>
When the <TT>autoResizeMode</TT> property is set to <TT>AUTO_RESIZE_OFF</TT>
when a column is resized, the other columns move to allow the
column to expand or contract, but do not change size. In this
mode, the width of the table changes as the column size changes.
When the mode is <TT>AUTO_RESIZE_LAST_COLUMN</TT>, the last column
expands or contracts an amount equal to the space removed or added
to the column being resized. When the mode is <TT>AUTO_RESIZE_ALL_COLUMNS</TT>,
space given or taken from the column being resized is evenly distributed
to all other columns in the table. The last two modes do not change
the width of the table as a column is resized. The default mode
for this property is <TT>AUTO_RESIZE_ALL_COLUMNS</TT>.
<P>
You can specify the space between rows and columns with the <TT>setIntercellSpacing</TT>
method. This method takes a <TT>Dimension</TT> as its single parameter.
As such, the row spacing can be specified using the <TT>Dimension</TT>'s
<TT>width</TT> property and the column spacing with its <TT>height</TT>
property. The current spacing can be queried by using the <TT>getInterCellSpacing</TT>.
The width and height of the returned dimension are set to the
row and column spacing, respectively.
<H2><A NAME="ModelsandSupportClassesUsedbytheTTFONTSIZEJTableFONTTTFONTSIZEClassFONT">
Models and Support Classes Used by the <TT>JTable</TT>
Class</A></H2>
<P>
The previous section described how to create tables from Java
data types. These data types may not be the best representation
for the data contained in your application. To allow data stored
in any representation, the <TT>TableModel</TT> interface is defined.
Classes containing data that you want to display in a table can
implement this interface and then be used as the data model for
one or more tables. The order of the columns in the table need
not match the order of the columns in the data model. Moreover,
the table need not display all the columns in the data model.
To enable this type of functionality, the table model interface
and table support classes must be understood. These are contained
in the <TT>javax.swing.table</TT> package.
<H3><A NAME="TheTTFONTSIZETableModelFONTTTFONTSIZEInterfaceandSupportClassesFONT">
The <TT>TableModel</TT> Interface
and Support Classes</A></H3>
<P>
The <TT>TableModel</TT> interface, shown in Listing 12.2, defines
the methods that a class must implement to be used as the data
source for a table. The methods <TT>getRowCount</TT> and <TT>getColumnCount</TT>
define the size of the data structure. The data querying and setting
methods, <TT>getValueAt</TT> and <TT>setValueAt</TT>, take integer
parameters for the row and column of the data. These methods return
and take an <TT>Object</TT> parameter, allowing any class of data
to be stored in the data model. Moreover, each column in the model
can contain a different class of <TT>Object</TT>. The <TT>getColumnName</TT>
method returns the <TT>String</TT> name for the column. This is
used in the table header, if displayed.
<P>
The <TT>getColumnClass</TT> method returns the class of object
stored in that column of data. The <TT>JTable</TT> class uses
this information to select appropriate editors and renderers for
the table. The model must return <TT>true</TT> from the <TT>isCellEditable</TT>
method for editing to be allowed. Finally, the class that implements
the <TT>TableModel</TT> interface must manage <TT>TableModelListeners</TT>.
As with all JFC models, it is the model's responsibility to fire
the appropriate event if the data in the model changes. For the
<TT>TableModel</TT>, this is a <TT>TableModelEvent</TT>.<p>
<HR>
<P>
<B>Listing 12.2&nbsp;&nbsp;The </B><TT><B>TABLEMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TableModel
{ 
    /**
     * Returns the number of records managed by the data source object. A
     * &lt;B&gt;JTable&lt;/B&gt; uses this method to determine how many rows it
     * should create and display.  This method should be quick, as it
     * is called by &lt;B&gt;JTable&lt;/B&gt; quite frequently.
     *
     * @return the number or rows in the model
     * @see #getColumnCount()
     */
    public int getRowCount();

    /**
     * Returns the number of columns managed by the data source object. A
     * &lt;B&gt;JTable&lt;/B&gt; uses this method to determine how many columns it
     * should create and display on initialization.
     *
     * @return the number or columns in the model
     * @see #getRowCount()
     */
    public int getColumnCount();

    /**
     * Returns the name of the column at &lt;i&gt;columnIndex&lt;/i&gt;.  This is 
     * used to initialize the table's column header name.  Note, this 
     * name does not need to be unique.  Two columns on a table can have
     * the same name.
     *
     * @param	columnIndex	the index of column
     * @return  the name of the column
     */
    public String getColumnName(int columnIndex);

    /**
     * Returns the lowest common denominator Class in the column.  This
     * is used by the table to set up a default renderer and editor for
     * the column.
     *
     * @return the common ancestor class of the object values in 
     *         the model.
     */
    public Class getColumnClass(int columnIndex);

    /**
     * Returns true if the cell at &lt;I&gt;rowIndex&lt;/I&gt; and &lt;I&gt;columnIndex&lt;/I&gt;
     * is editable.  Otherwise, setValueAt() on the cell will not change
     * the value of that cell.
     *
     * @param rowIndex the row whose value is to be looked up
     * @param columnIndex the column whose value is to be looked up
     * @return true if the cell is editable.
     * @see #setValueAt()
     */
    public boolean isCellEditable(int rowIndex, int columnIndex);

    /**
     * Returns an attribute value for the cell at &lt;I&gt;columnIndex&lt;/I&gt;
     * and &lt;I&gt;rowIndex&lt;/I&gt;.
     *
     * @param rowIndex the row whose value is to be looked up
     * @param columnIndex the column whose value is to be looked up
     * @return the value Object at the specified cell
     */
    public Object getValueAt(int rowIndex, int columnIndex);

    /**
     * Sets an attribute value for the record in the cell at
     * &lt;I&gt;columnIndex&lt;/I&gt; and &lt;I&gt;rowIndex&lt;/I&gt;.  &lt;I&gt;aValue&lt;/I&gt; is
     * the new value.
     *
     * @param aValue the new value
     * @param rowIndex the row whose value is to be changed
     * @param columnIndex the column whose value is to be changed
     * @see #getValueAt()
     * @see #isCellEditable()
     */
    public void setValueAt(Object aValue, int rowIndex, int columnIndex);

    /**
     * Add a listener to the list that's notified each time a change
     * to the data model occurs.
     *
     * @param l the TableModelListener
     */
    public void addTableModelListener(TableModelListener l);

    /**
     * Remove a listener from the list that's notified each time a
     * change to the data model occurs.
     *
     * @param l the TableModelListener
     */
    public void removeTableModelListener(TableModelListener l);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
To aid developers creating classes that implement the <TT>TableModel</TT>
interface, the <TT>javax.swing.table</TT> package contains the
<TT>AbstractTableModel</TT> class. This abstract class manages
<TT>TableModelListener</TT> instances and contains convenience
methods for firing <TT>TableModelEvents</TT>. Classes that extend
the <TT>AbstractTableModel</TT> class must provide implementations
for the <TT>getRowCount</TT>, <TT>getColumnCount</TT>, and <TT>getValueAt</TT>
methods. This provides the view with a read-only view of the data
in the model. The <TT>AbstractTableModel</TT> class provides default
implementation for the <TT>isCellEditable</TT> and <TT>setValueAt</TT>
methods. The <TT>isCellEditable</TT> method returns <TT>false</TT>
for all row and column values passed to it. This creates a read-only
table allowing the <TT>setValueAt</TT> method to be empty. The
<TT>getColumnClass</TT> method simply returns the <TT>Object</TT>
class. The <TT>getColumnName</TT> method labels columns similar
to a spreadsheet. Column names are A, B, and so on.
<P>
To provide an editable <TT>TableModel</TT> implementation, the
<TT>isCellEditable</TT> and <TT>setValueAt</TT> methods must also
be overridden. To allow different editors and renderers for different
classes of data, the <TT>getColumnClass</TT> method must be overridden
as well. At this point, the extension to <TT>AbstractTableModel</TT>
has nearly implemented the <TT>TableModel</TT> interface, so it
may be asked, &quot;Why extend <TT>AbstractTableModel</TT> at
all?&quot; The extension inherits the <TT>TableModelListener</TT>
management functions, but more significantly, it inherits the
fire methods provided by the <TT>AbstractTableModel</TT> class.
These methods allow the model to easily fire <TT>TableModelEvents</TT>
to listeners. The fire methods are shown in Table 12.3.<BR>
<P>
<CENTER><B>Table 12.3&nbsp;&nbsp;</B><TT><B>ABSTRACTTABLEMODEL</B></TT><B>
Classes Fire Methods</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=295><CENTER><B>Method Name</B></CENTER></TD><TD WIDTH=295><CENTER><B>Purpose of Event</B></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>FireTableCellUpdated (int row, int column)</TT>
</TD><TD WIDTH=295>Notify all listeners that the value of the cell at (row, column) has been updated.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableChanged(TableModel Event e)</TT>
</TD><TD WIDTH=295>Forward the given notification event to all <TT>TableModel Listeners</TT> that registered themselves as listeners for this table model.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableDataChanged()</TT></TD><TD WIDTH=295>Notify all listeners that all cell values in the table's rows may have changed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableRowsDeleted(int</TT></TD><TD WIDTH=295>Notify all listeners that rows in the (inclusive) range
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>firstRow, int lastRow)</TT></TD><TD WIDTH=295>[<TT>firstRow, lastRow</TT>] have been deleted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableRowsInserted(int</TT></TD><TD WIDTH=295>Notify all listeners that rows in the (inclusive) range
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>firstRow, int lastRow)</TT></TD><TD WIDTH=295>[<TT>firstRow, lastRow</TT>] have been inserted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableRowsUpdated(int</TT></TD><TD WIDTH=295>Notify all listeners that rows in the (inclusive) range
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>firstRow, int lastRow)</TT></TD><TD WIDTH=295>[<TT>firstRow, lastRow</TT>] have been updated.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>fireTableStructureChanged()</TT></TD><TD WIDTH=295>Notify all listeners that the table's structure has changed.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>TableModelListener</TT> interface, shown in Listing 12.3,
must be implemented to receive events from the table model. As
can be seen from the listing, this is a simple interface. It defines
one method, <TT>tableChanged</TT>. This is called when the table
model being listened to changes. The <TT>TableModelEvent</TT>
instance passed as the parameter to this method contains the information
as to what type of change occurred. The <TT>TableModelEvent</TT>
class is also shown in Listing 12.3. This class defines constants
that define the type of change that occur in the model. Possible
types for the event are <TT>INSERT</TT>, <TT>DELETE</TT>, and
<TT>UPDATE</TT>. After the type of event has been determined by
using the <TT>getType</TT> method, the range of effected rows
can be obtained with the <TT>getFirstRow</TT> and <TT>getLastRow</TT>
methods. The affected column can be obtained from the <TT>getColumn</TT>
method. The constant <TT>ALL_COLUMNS</TT> is defined to signify
that all columns in the table are involved with the event.
<P>
The <TT>TableModelEvent</TT> also contains special case conditions.
If an <TT>ALL_COLUMNS</TT> <TT>UPDATE</TT> event is received with
a last row of <TT>Integer.MAX_VALUE</TT>, this means that the
entire table's row data has changed and the view should reread
this information from the model. If an <TT>ALL_COLUMNS</TT> <TT>UPDATE</TT>
event is received for the <TT>HEADER_ROW</TT>, the structure of
the table has changed. The view must reinitialize its columns
and refresh the view. These magic event types add a level of complexity
to the <TT>TableModelEvent</TT> that in this author's opinion
was unnecessary. Adding a couple of additional event types, or
extending the <TT>TableModelListener</TT> interface for these
special cases, would have made the event flow between the <TT>TableModel</TT>
and its listeners much more clear and alleviated a significant
amount of special case code in the listener.<P>
<HR>
<P>
<B>Listing 12.3&nbsp;&nbsp;The </B><TT><B>TABLEMODELLISTENER</B></TT><B>
Interface and </B><TT><B>TABLEMODELEVENT</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TableModelListener extends java.util.EventListener
{ 
    /**
     * This fine grain notification tells listeners the exact range
     * of cells, rows, or columns that changed.
     */
    public void tableChanged(TableModelEvent e);
} 


public class TableModelEvent extends java.util.EventObject
{ 
    public static final int INSERT =  1;
    public static final int UPDATE =  0;
    public static final int DELETE = -1;
    
    public static final int HEADER_ROW = -1;

    public static final int ALL_COLUMNS = -1;
    
//
//  Instance Variables
//

    protected int       type;
    protected int	firstRow;
    protected int	lastRow;
    protected int	column;

//
// Constructors
//

    /** 
     * All row data in the table has changed. Listeners should discard 
     * any state that was based on the rows and requery the TableModel 
     * to get the new row count and all the appropriate values.
     * The JTable will repaint the entire visible region on receiving
     * this event, querying the model for the cell values that are 
     * visible. The structure of the table i.e. the column names, types, 
     * and order have not changed.  
     */
    public TableModelEvent(TableModel source) { 
        // Use Integer.MAX_VALUE instead of getRowCount() in 
        // case rows were deleted. 
	this(source, 0, Integer.MAX_VALUE, ALL_COLUMNS, UPDATE);
    } 
    
    /**
     * This row of data has been updated. 
     * To denote the arrival of a completely new table with a different 
     * structure use &lt;code&gt;HEADER_ROW&lt;/code&gt; as the value for the 
     * &lt;I&gt;row&lt;/I&gt;. When the JTable receives this event and its
     * &lt;I&gt;autoCreateColumnsFromModel&lt;/I&gt; flag is set it discards any 
     * TableColumns that it had and reallocates default ones in the 
     * order they appear in the model. This is the same as calling 
     * &lt;code&gt;setModel(TableModel)&lt;/code&gt; on the JTable. 
     */
    public TableModelEvent(TableModel source, int row) { 
        this(source, row, row, ALL_COLUMNS, UPDATE);
    } 
    
    /**
     * The data in rows [&lt;I&gt;firstRow&lt;/I&gt;, &lt;I&gt;lastRow&lt;/I&gt;] have been 
     * updated. 
     */
    public TableModelEvent(TableModel source, int firstRow, int lastRow) { 
        this(source, firstRow, lastRow, ALL_COLUMNS, UPDATE);
    } 
    
    /**
     * The cells in column &lt;I&gt;column&lt;/I&gt; in the range 
     * [&lt;I&gt;firstRow&lt;/I&gt;, &lt;I&gt;lastRow&lt;/I&gt;] have been updated. 
     */
    public TableModelEvent( TableModel source, int firstRow, 
                            int lastRow, int column ) { 
        this(source, firstRow, lastRow, column, UPDATE);
    } 
    
    /**
     * The cells from (firstRow, column) to (lastRow, column) have been 
     * changed. The &lt;I&gt;column&lt;/I&gt; refers to the column index of the cell 
     * in the model's coordinate system. When &lt;I&gt;column&lt;/I&gt; is ALL_ 
     * COLUMNS, all cells in the specified range of rows are 
     * considered changed. 
     *  &lt;p&gt;
     *  The &lt;I&gt;type&lt;/I&gt; should be one of: INSERT, UPDATE, and DELETE. 
     */
    public TableModelEvent( TableModel source, int firstRow, int lastRow,
                            int column, int type) { 
        super(source);
        this.firstRow = firstRow;
        this.lastRow = lastRow;
        this.column = column;
        this.type = type;
    } 

//
// Querying Methods
//

   /** Returns the first row that changed.  HEADER_ROW means the meta 
     * data, i.e. names, types, and order of the columns. 
     */
    public int getFirstRow() {  return firstRow; } ;

    /** Returns the last row that changed. */
    public int getLastRow() {  return lastRow; } ;
    
    /**
     *  Returns the column for the event.  If the return
     *  value is ALL_COLUMNS; it means every column in the specified
     *  rows changed.
     */
    public int getColumn() {  return column; } ; 
    
    /**
     *  Returns the type of event - one of: INSERT, UPDATE, and DELETE.
     */
    public int getType() {  return type; } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheTTFONTSIZETableColumnModelFONTTTFONTSIZEInterfaceandAssociatedClassesFONT">
The <TT>TableColumnModel</TT>
Interface and Associated Classes</A></H3>
<P>
The <TT>JTable</TT> class delegates column information to a column
model. The required methods for a column model class are defined
in the <TT>TableColumnModel</TT> interface shown in Listing 12.4.
The <TT>TableColumnModel</TT> interface is another long interface
that typically will not be implemented by developers. The <TT>DefaultTableColumnModel</TT>
class is provided for use in <TT>JTable</TT> instances. However,
the flexibility to replace the <TT>DefaultTableColumnModel</TT>
is available, if required, as long as the replacement column model
class implements this interface. This is a good design pattern
for Java development. The view class interfaces to model classes
through interfaces, and a default implementation of that class
is provided. This allows for the view to be easily used with default
behavior and still allow that behavior to be overridden or extended
by providing custom classes that implement the model interface.
<P>
<HR>
<P>
<B>Listing 12.4&nbsp;&nbsp;The </B><TT><B>TABLECOLUMNMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TableColumnModel
{ 
//
// Modifying the model
//

    /**
     * Appends &lt;I&gt;aColumn&lt;/I&gt; to the end of the receiver's tableColumns
     * array. This method also posts the columnAdded() event to its 
     * listeners.
     *
     * @param   aColumn         The &lt;B&gt;TableColumn&lt;/B&gt; to be added
     * @see     #removeColumn()
     */
    public void addColumn(TableColumn aColumn);

    /**
     * Deletes the &lt;B&gt;TableColumn&lt;/B&gt; &lt;I&gt;column&lt;/I&gt; from the 
     * receiver's table column's array.  This method will do nothing if 
     * &lt;I&gt;column&lt;/I&gt; is not in the table's column's list.
     * This method also posts the columnRemoved() event to its 
     * listeners.
     *
     * @param   column          The &lt;B&gt;TableColumn&lt;/B&gt; to be removed
     * @see     #addColumn()
     */
    public void removeColumn(TableColumn column);
    
    /**
     * Moves the column and heading at &lt;I&gt;columnIndex&lt;/I&gt; to 
     * &lt;I&gt;newIndex&lt;/I&gt;. The old column at &lt;I&gt;columnIndex&lt;/I&gt; will now be
     * found at &lt;I&gt;newIndex&lt;/I&gt;. The column that used to be at 
     * &lt;I&gt;newIndex&lt;/I&gt; is shifted left or right to make room.
     * This will not move any columns if &lt;I&gt;columnIndex&lt;/I&gt; equals
     * &lt;I&gt;newIndex&lt;/I&gt;. This method also posts the columnMoved() 
     * event to its listeners.
     *
     * @param columnIndex the index of column to be moved
     * @param newIndex New index to move the column
     * @exception IllegalArgumentException if &lt;I&gt;column&lt;/I&gt; or 
     *                                     &lt;I&gt;newIndex&lt;/I&gt;
     *                                     are not in the valid range
     */
    public void moveColumn(int columnIndex, int newIndex);

    /**
     * Sets the &lt;B&gt;TableColumn's&lt;/B&gt; column margin to &lt;I&gt;newMargin&lt;/I&gt;.
     * This method also posts the columnMarginChanged() event to its
     * listeners.
     *
     * @param   newMargin               the width margin of the column
     * @see     #getColumnMargin()
     */
    public void setColumnMargin(int newMargin);
    
//
// Querying the model
//

    /** Returns the number of columns in the model */
    public int getColumnCount();
    
    /** Returns an Enumeration of all the columns in the model */
    public Enumeration getColumns();

    /**
     * Returns the index of the first column in the receiver's
     * column's array whose identifier is equal to &lt;I&gt;identifier&lt;/I&gt;,
     * when compared using &lt;I&gt;equals()&lt;/I&gt;.
     *
     * @return the index of the first table column in the receiver's
     *         tableColumns array whose identifier is equal to
     *         &lt;I&gt;identifier&lt;/I&gt;, when compared using equals().
     * @param  identifier  the identifier object
     * @exception IllegalArgumentException if &lt;I&gt;identifier&lt;/I&gt; 
     *            is null or no TableColumn has this identifier
     * @see #getColumn()
     */
    public int getColumnIndex(Object columnIdentifier);

    /**
     * Returns the &lt;B&gt;TableColumn&lt;/B&gt; object for the column at 
     * &lt;I&gt;columnIndex&lt;/I&gt;
     *
     * @return the TableColumn object for the column at 
     *         &lt;I&gt;columnIndex&lt;/I&gt;
     * @param  columnIndex     the index of the column desired
     */
    public TableColumn getColumn(int columnIndex);

    /** Returns the width margin between each column */
    public int getColumnMargin();
    
    /**
     * Returns the index of the column that lies on the &lt;I&gt;xPosition&lt;/I&gt;,
     * or -1 if it lies outside the any of the column's bounds.
     *
     * @return  the index of the column or -1 if no column is found
     */
    public int getColumnIndexAtX(int xPosition);
    
    /** Returns the total width of all the columns. */
    public int getTotalColumnWidth();

//
// Selection
//

    /**
     * Sets whether the columns in this model can be selected.
     * @see #getColumnSelectionAllowed()
     */
    public void setColumnSelectionAllowed(boolean flag);

    /**
     * @return true if columns can be selected.
     * @see #setColumnSelectionAllowed()
     */
    public boolean getColumnSelectionAllowed();

    /**
     * @return the indices of all selected columns, or an empty int array
     *         if no column is selected.
     */
    public int[] getSelectedColumns();

    /**
     * @return the number of selected columns.  0 if no columns are 
     *         selected.
     */
    public int getSelectedColumnCount();

    public void setSelectionModel(ListSelectionModel newModel); 
    
    public ListSelectionModel getSelectionModel(); 
    
//
// Listener
//

    public void addColumnModelListener(TableColumnModelListener x);
    public void removeColumnModelListener(TableColumnModelListener x);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Looking at the <TT>TableColumnModel</TT> interface, you can see
that methods are provided to query the state of the column model.
This includes the number of columns in the model, the margin for
each column, the total column width, the index of a column, the
column at an index, and an <TT>Enumeration</TT> of all columns.
The table's column structure can be changed dynamically. Methods
are provided to add and remove columns as well as to move columns.
<P>
As you saw earlier in this chapter, the <TT>TableColumnModel</TT>
contains a <TT>ListSelectionListener</TT> to manage column selection.
The model defines methods for setting and getting the selection
model, as well as convenience methods for manipulating column
selection status and querying the selection set.
<P>
Finally, you see that <TT>TableColumnModelListeners</TT> can be
registered with the model. This allows views or other interested
classes to be notified when the column model changes. Calling
one of the methods defined in the <TT>TableColumnModelListener</TT>
interface shown in Listing 12.5 performs the notification. Each
method in the interface delivers an instance of the <TT>TableColumnModelEvent</TT>,
also shown in the listing. It is interesting to note the different
styles of listener interfaces and events between the <TT>TableModelListener</TT>/<TT>TableModelEvent</TT>
pair presented earlier in this section and the <TT>TableColumnModelListener</TT>/<TT>TableColumnModelEvent</TT>
pair shown here. The <TT>TableModelListener</TT> defines a single
method, and the event delivered provides the type information.
The <TT>TableColumnModelListener</TT> interface defines multiple
methods, one for each type of change in the column model, and
the event simply provides the index of effected column. The first
style makes implementing the interface easier, but requires a
more complex method to decode and handle the event. The second
style requires more work to implement the interface, but the purpose
of each method is clearly defined. Both styles of listener/event
pairs are valid, but one would expect the same style to be used
with such closely related models.<P>
<HR>
<P>
<B>Listing 12.5&nbsp;&nbsp;The </B><TT><B>TABLECOLUMNMODELLISTENER</B></TT><B>
and </B><TT><B>TABLECOLUMNMODELEVENT</B></TT><B>
Classes<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TableColumnModelListener extends java.util.EventListener
{ 
    /** Tells listeners that a column was added to the model. */
    public void columnAdded(TableColumnModelEvent e);

    /** Tells listeners that a column was removed from the model. */
    public void columnRemoved(TableColumnModelEvent e);

    /** Tells listeners that a column was repositioned. */
    public void columnMoved(TableColumnModelEvent e);

    /** Tells listeners that a column was moved due to a margin change.*/
    public void columnMarginChanged(ChangeEvent e);

    /**
     * Tells listeners that the selection model of the
     * TableColumnModel changed.
     */
    public void columnSelectionChanged(ListSelectionEvent e);
} 


public class TableColumnModelEvent extends java.util.EventObject
{ 
//
//  Instance Variables
//

    /** The index of the column from where it was moved or removed */
    protected int	fromIndex;

    /** The index of the column to where it was moved or added from */
    protected int	toIndex;

//
// Constructors
//

    public TableColumnModelEvent(TableColumnModel source, 
        int from, int to) { 
        super(source);
        fromIndex = from;
        toIndex = to;
    } 
    
//
// Querying Methods
//

    /** Returns the fromIndex.  Valid for removed or moved events */
    public int getFromIndex() {  return fromIndex; } ;

    /** Returns the toIndex.  Valid for add and moved events */
    public int getToIndex() {  return toIndex; } ;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>TableColumnModel</TT> consists of a set of <TT>TableColumn</TT>
instances. When a column is retrieved from the model, it is an
instance of the <TT>TableColumn</TT> class. This class encapsulates
the information about the appearance of a column in the table.
It contains attributes for the column width, minimum and maximum
width, and whether it is resizable or not. The minimum and maximum
values are enforced when the user is resizing the column by dragging
its border. This class also can contain a renderer and editor.
This allows each column in the table to use its own renderer and
editor. Later in this chapter, you will see how it is possible
to set a renderer and editor for a given type for the entire table.
Setting the value on the column overrides the value set for the
table. This gives the developer total control over how the data
in a column is displayed and edited. The column header's renderer
can also be set. A <TT>PropertyChangeListener</TT> can be registered
with the <TT>TableColumn</TT> instance to be notified of changes
to these properties. Table 12.4 contains a complete list of bound
properties contained in the <TT>TableColumn</TT> class. The constants
used for the property names are defined in the <TT>TableColumn</TT>
class.<BR>
<P>
<CENTER><B>Table 12.4&nbsp;&nbsp;Bound Properties of the </B><TT><B>TABLECOLUMN</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=150><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=150><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=150><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>HEADER_RENDERER_PROPERTY</TT></TD><TD WIDTH=150><TT>setHeaderRenderer</TT>
</TD><TD WIDTH=150><TT>getHeaderRenderer</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>HEADER_VALUE_PROPERTY</TT></TD><TD WIDTH=150><TT>setHeaderValue</TT>
</TD><TD WIDTH=150><TT>getHeaderValue</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>CELL_RENDERER_PROPERTY</TT></TD><TD WIDTH=150><TT>setCellRenderer</TT>
</TD><TD WIDTH=150><TT>getCellRenderer</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>COLUMN_WIDTH_PROPERTY</TT></TD><TD WIDTH=150><TT>setWidth</TT>
</TD><TD WIDTH=150><TT>getWidth</TT></TD></TR>
</TABLE></CENTER>
<P>
The order of the columns in the <TT>TableColumnModel</TT> does
not have to coincide with the order in the data model. This allows
different tables to view the same model data in different orders
or different sets of columns from the data model. The methods
<TT>convertColumnIndexToModel</TT> and <TT>covertColumnIndexToView</TT>
in the <TT>JTable</TT> class can be used to map from the view's
coordinate space to the models, and vice versa.
<P>
The <TT>columnAtPoint</TT> method can be used to determine which
column lies below a point. This is often used for hit detection
in mouse listeners added to the table.
<P>
The <TT>TableColumn</TT> class goes against the general design
of the <TT>JTable</TT> class, that being that the interaction
between the various table components is defined in an interface
and a default implementation for the interface is provided. However,
<TT>TableColumn</TT> is a class. This makes it more difficult
to replace with a custom implementation than if <TT>TableColumn</TT>
were an interface and the implementation contained in a <TT>DefaultTableColumn</TT>
class, as was seen earlier in this chapter for the <TT>TableColumnModel</TT>
interface and its default implementation, the <TT>DefaultTableColumnModel</TT>
class.
<H3><A NAME="PullingItAllTogetherATTFONTSIZEJTableFONTTTFONTSIZEExampleFONT">
Pulling It All Together: A <TT>JTable</TT>
Example</A></H3>
<P>
The table presented by the <TT>SimpleTableTest</TT> application
did, in fact, present the data passed to the constructor. However,
with a little extra effort, the <TT>JTable</TT> component can
yield a much nicer display. This section will present a custom
data model, renderers, and editors that combine to make a complete
table. The example code for each portion of the table will be
given as it is presented. The source listing that can be compiled
and executed for the example will be presented in its entirety
at the end of the section.
<P>
The default renderer for the table calls the <TT>toString</TT>
method of the <TT>Object</TT> being rendered. For the second and
third columns in the <TT>SimpleTableTest</TT> application, a more
appropriate rendering would be color coded for column two and
a check box for column three. There are multiple ways to accomplish
this goal. You can add a custom renderer to the <TT>TableColumn</TT>
instance that represents columns two and three in the <TT>ColumnModel</TT>.
However, that is not the approach taken here. Instead, a renderer
will be registered with the table for each class that requires
custom rendering. This allows the same renderer to be shared by
multiple columns in a table if they each contain the same class
of data.
<P>
The first step is to define an extension to the <TT>AbstractTableModel</TT>
class that has a more intimate understanding of the data it contains
than results from passing a <TT>Vector</TT> or array to the <TT>JTable</TT>
class's constructor. The <TT>TableTestModel</TT> class shown in
Listing 12.6 is such a class (Figure 12.6 shows the output from
this listing). Internally, this class stores its data in a two-dimensional
array. The design of the data model is such that the name column
is not editable, but the other columns are. This information is
obtained by clients of the model via the <TT>isCellEditable</TT>
method. If the column index passed to this function is <TT>0</TT>,
<TT>false</TT> is returned. <TT>true</TT> is returned for all
other columns. The row parameter is not used in this method. The
model also protects against the name being set in the <TT>setValueAt</TT>
method. If a column index of <TT>0</TT> is passed to this method,
a <TT>RuntimeException</TT> is thrown, and the data in the model
is not altered. The model returns the proper <TT>Class</TT> for
the data stored in each column from the <TT>getColumnClass</TT>
method. This is possible for this data model, because the data
in every cell in a column is of the same type. If this is not
the case, the <TT>getColumnClass</TT> method must return a common
ancestor of the classes contained in the column. This can be the
<TT>Object</TT> class itself.
<P>
<A HREF="javascript:popUp('f12-6.gif')"><B>Figure 12.6 :</B> <I>The TestTableModel used as a JTable data
model</I>.</A>
<P>
The structure of the <TT>TableTestModel</TT> is static. Thus,
the only time the data in the model changes is in the <TT>setValueAt</TT>
method. This method calls the <TT>fireTableCellUpdated</TT> method
inherited from the <TT>AbstractTableModel</TT> class to notify
listeners when a value changes. If this model is shared between
multiple tables, edits in one table are displayed in the other
tables after the update event is received. The data model can
use the other convenience methods inherited from the <TT>AbstractTableModel</TT>
class if rows are added or deleted from the model or other structure
changes in the model are allowed. <P>
<HR>
<P>
<B>Listing 12.6&nbsp;&nbsp;The </B><TT><B>TABLETESTMODEL</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * Table model that returns the Class of the data in
 * a particular column. This allows the table to set
 * renderers for the data.
 **/
class TableTestModel extends AbstractTableModel { 

    /**
     * The data in the model.
     **/
     Object[][] data = { 
        {  &quot;Mike&quot;, Color.blue, new Boolean( true ), new Integer(9) } ,
        {  &quot;Mari&quot;, Color.red, new Boolean( true ), new Integer(6) } ,
        {  &quot;Molly&quot;, Color.yellow, new Boolean( false ), new Integer(1) } ,
        {  &quot;Betsy&quot;, Color.orange, new Boolean( false ), new Integer(8) } ,
        {  &quot;Bobby&quot;, Color.lightGray, new Boolean( true ), new Integer(7) } 
        } ;

    /**
     * The column names for the model.
     **/
    String[] columnNames = {  &quot;Name&quot;, &quot;Color&quot;, &quot;Enabled&quot;, &quot;Size&quot; } ;
    
    
    /**
     * TableTestModel, constructor.
     **/
    TableTestModel() { 
        super();    
    } 
        
        
    /**
     * getRowCount, from TableModel.
     *
     * @return The number of rows in the data.
     **/
    public int getRowCount() { 
        return( data.length );
    } 

    
    /**
     * getColumnCount, from TableModel.
     *
     * @return The number of columns in the data.
     **/
    public int getColumnCount() { 
        return( data[0].length );
    } 
    
    /**
     * getValueAt, from TableModel.
     *
     * @param row The row of the requested data object.
     * @param column The column of the requested data object.
     * @return The object at the specified cell.
     **/
    public Object getValueAt( int row, int column ) { 
        return( data[ row ][ column ] );
    } 

    /**
     * setValueAt, from TableModel.
     *
     * Set the data value in the given location to the
     * given object.
     *
     * @param value The new data object.
     * @param row The row of the new data object.
     * @param column The column of the new data object.
     **/
    public void setValueAt( Object value, int row, int column ) { 
        if( column == 0 )
            throw new RuntimeException(
                      &quot;The Name column is not editable&quot; );

        data[ row ][ column ] = value;
    } 


    /**
     * getColumnName, from TableModel.
     *
     * @param column The column index whose name is desired.
     * @return The name of the column with the given index.
     **/
    public String getColumnName( int column ) { 
        return( columnNames[ column ] );
    } 
    
    /**
     * getColumnClass, from TableModel.
     *
     * @param column The column index whose Class is desired.
     * @return The Class of the data for the column with the given index.
     **/
    public Class getColumnClass( int column ) { 
        return( data[0][ column ].getClass() );
    } 
    
    
    /**
     * isCellEditable, from TableModel.
     *
     * All columns except the first are editable in this model.
     *
     * @param row The row of the cell whose editability is requested.
     * @param column The column of the cell whose editability 
     *               is requested.
     * @return true if the cell is editable, false otherwise.
     **/
    public boolean isCellEditable( int row, int column ) { 
        if( column == 0 ) { 
            return( false );
        }  else { 
            return( true );
        } 
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The table created when using an instance of the <TT>TestTableModel</TT>
as the data model for an instance of the <TT>JTable</TT> class
is shown in Figure 12.6. The model can be set for the table by
calling the <TT>setModel</TT> method or by specifying the model
in the <TT>JTable</TT> class's constructor. This is shown in the
following line of code. 
<P>
<TT>JTable table = new JTable( new TableTestModel()
);</TT>
<P>
This model can be added to the <TT>SimpleTableTest</TT> application,
and it is the model used for the <TT>TableTest</TT> application
developed in this section.
<P>
You will immediately notice the change in this table shown in
Figure 12.6 to those shown earlier in this chapter. When the <TT>Boolean</TT>
class is returned from the <TT>getColumnClass</TT> method in the
<TT>TestTableModel</TT> method, the <TT>JTable</TT> class uses
a <TT>JCheckBox</TT> for the cell renderer, and when a <TT>Number</TT>
is returned, the text is right aligned. This magic is enabled
in the protected <TT>createDefaultRenderers</TT> method in the
<TT>JTable</TT> class. This method creates and registers renders
for known classes by using the <TT>setDefaultRenderer</TT> method.
The set of renderers registered is shown in Table 12.5. 
<P>
Extensions of the <TT>JTable</TT> class can override the <TT>createDefaultRenderers</TT>
method to establish a different set of renderers. Also, the <TT>setDefaultRenderer</TT>
method is <TT>public</TT>. This allows clients of the <TT>JTable</TT>
class to change the default renderer or add renderers for additional
classes of objects. When a renderer is registered for a class,
it is used to render all columns in the model that contain that
class of data. Thus, registering a renderer for a class is a global
setting, while setting the renderer for a <TT>TableColumn</TT>
instance is only valid for that column, even if multiple columns
contain that class of data.
<P>
If set, the ToolTip for the table is retrieved from the renderer.
If the renderer does not have a ToolTip, the tip is retrieved
from the table. This allows custom renderers to contain ToolTips
specific for the class of data that they render. ToolTips are
enabled for <TT>JTable</TT> instances by default. However, calling
the <TT>setToolTipText</TT> method with a <TT>null</TT> parameter
will cause the table to remove itself from the <TT>ToolTipManager</TT>.
<BR>
<P>
<CENTER><B>Table 12.5&nbsp;&nbsp;Default Renderers for the </B><TT><B>JTABLE</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><B>Class</B></TD><TD WIDTH=197><B>Renderer</B>
</TD><TD WIDTH=197><B>Positioning</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Object</TT></TD><TD WIDTH=197><TT>DefaultTableCellRenderer</TT>
</TD><TD WIDTH=197>Left-aligned text</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Number</TT></TD><TD WIDTH=197><TT>DefaultTableCellRenderer</TT>
</TD><TD WIDTH=197>Right-aligned text</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>ImageIcon</TT></TD><TD WIDTH=197><TT>DefaultTableCellRenderer</TT>
</TD><TD WIDTH=197>Centered <TT>Icon</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Boolean</TT></TD><TD WIDTH=197><TT>CheckBoxRenderer</TT>
</TD><TD WIDTH=197>Centered <TT>JCheckBox</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
The default rendering of the <TT>JTable</TT> class presents the
<TT>Boolean</TT> instances in the table appropriately. However,
as you can see in Figure 12.6, the cell containing the <TT>JCheckBox</TT>
isn't rendered the same as other cells in its row. Also, the <TT>Color</TT>
data still leaves room for improvement. Registering your own renderer
for the <TT>Color</TT> class makes this improvement. A new renderer
for the <TT>Boolean</TT> class that paints the same color as the
other cells is also registered. This has the effect of replacing
the default <TT>Boolean</TT> renderer. Listing 12.7 contains the
code for the new renderers and registers them with the table.
The <TT>Boolean</TT> renderer is a complete class that extends
the <TT>JCheckBox</TT> class and implements the <TT>TableCellRenderer</TT>
interface. The majority of the class's work is performed in the
<TT>getTableCellRendererComponent</TT> method. In this method,
the check box is configured for the current state of the cell
that will be rendered. The selected state for the check box is
set based on the value passed to the method. If the cell is selected,
the selected foreground and background colors are queried from
the table and set on the check box. Similar processing occurs
for an unselected cell. Finally, the check box is returned as
the rendering component. 
<P>
The color renderer is made by creating an anonymous class that
extends the <TT>DefaultTableCellRenderer</TT> class and sets its
background color in the <TT>setValue</TT> method. The renderer
must be made opaque so that it paints its background. This makes
the color renderer very simple. However, if you wish to use this
technique in multiple tables, it should be made into a standalone
class.
<P>
The table created using the enhanced renderers is shown in Figure
12.7.
<P>
<A HREF="javascript:popUp('f12-7.gif')"><B>Figure 12.7 :</B> <I>Enhanced renderers in the JTable</I>.</A>
<P>
<HR>
<P>
<B>Listing 12.7&nbsp;&nbsp;Enhanced </B><TT><B>BOOLEAN</B></TT><B>
and </B><TT><B>COLOR</B></TT><B>
Class </B><TT><B>TABLECELLRENDERERS<BR>
</B></TT>
<BLOCKQUOTE>
<PRE>
/**
 * The SelectedCheckBoxRenderer class is almost the same as the
 * default check box renderer in the JTable class. However, it
 * paints the cell in the normal table selected colors when it is
 * selected. This avoids the white areas in the table for Boolean
 * columns. Also, if all columns in the table are Boolean, you
 * wouldn't be able to see the selected row using the default renderer!
 *
 * @author Mike Foley
 **/
class SelectedCheckBoxRenderer extends JCheckBox 
    implements TableCellRenderer { 

    private Border noFocusBorder;
    private Color unselectedForeground; 
    private Color unselectedBackground; 

    
    /**
     * SelectedCheckBoxRenderer, default constructor.
     *
     * We need to be opaque so our background color is painted.
     * Create our border. Keep a reference around so it can be
     * reset when we are not selected.
     * Center the check box to match the position of the Boolean editor.
     **/
    public SelectedCheckBoxRenderer() { 
        super();
    	setOpaque( true );
    	
        noFocusBorder = new EmptyBorder( 1, 2, 1, 2 );
        setBorder( noFocusBorder );
        
        setHorizontalAlignment( JLabel.CENTER );
    } 


    /**
     * Set the foreground color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new foreground color.
     **/
    public void setForeground(Color c) { 
        super.setForeground(c); 
        unselectedForeground = c; 
    } 
    
    
    /**
     * Set the background color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new background color.
     **/
    public void setBackground(Color c) { 
        super.setBackground(c); 
        unselectedBackground = c; 
    } 


    /**
     * Clear the foreground and background colors after
     * updating the UI. This will cause the colors to be
     * read from the table property portion of the UI.
     **/
    public void updateUI() { 
        super.updateUI(); 
        setForeground( null );
        setBackground( null );
    } 
    

    /**
     * getTableCellRendererComponent, from TableCellRenderer
     *
     * Configure the check box for the given state.
     *
     **/
    public Component getTableCellRendererComponent( JTable table, 
                         Object value, boolean isSelected,
 boolean hasFocus, int row, int column ) { 
            
        //
        // Check or uncheck the JCheckBox.
        //
        setSelected((value != null &amp;&amp; ((Boolean)value).booleanValue()));

        //
        // If we are selected, paint in the table's selection colors.
        //
        if( isSelected ) { 
            super.setForeground( table.getSelectionForeground() );
            super.setBackground( table.getSelectionBackground() );
        }  else { 
            super.setForeground( ( unselectedForeground != null ) ?  
                          unselectedForeground : table.getForeground() );
            super.setBackground( ( unselectedBackground != null ) ?  
                          unselectedBackground : table.getBackground() );
        }  // else
       
        //
        // If we have the focus, paint in the focus color for the table
        // and set the focus border.
        // If not, set the no focus border.
        //
        if( hasFocus ) { 
            setBorder( UIManager.getBorder( 
                    &quot;Table.focusCellHighlightBorder&quot; ) );
            if (table.isCellEditable(row, column)) { 
                super.setForeground( UIManager.getColor( 
                              &quot;Table.focusCellForeground&quot; ) );
                super.setBackground( UIManager.getColor( 
                              &quot;Table.focusCellBackground&quot; ) );
            }
        }  else { 
            setBorder( noFocusBorder );
        } 
        
        return( this );
    } 
    
}  // SelectedCheckBoxRenderer


        //
        // Create and register a Color class renderer.
        //
        DefaultTableCellRenderer colorRenderer = 
            new DefaultTableCellRenderer() { 
            public void setValue( Object value ) { 
                setBackground( ( Color )value );
            } 
        } ;
        
        colorRenderer.setOpaque( true );
        table.setDefaultRenderer( Color.class, colorRenderer );

        table.setDefaultRenderer( Boolean.class, 
                                  new SelectedCheckBoxRenderer() );
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
The <TT>SelectedCheckBoxRenderer </TT>class shown in Listing 12.7 assumes that the value passed to the <TT>getTableCellRendererComponent </TT>method is a <TT>Boolean</TT>. This means that if this class is registered as a renderer in a table for a class that is not a <TT>Boolean </TT>or a descendent of <TT>Boolean</TT>, the renderer will throw a <TT>ClassCastException </TT>when used. Similarly, the color renderer assumes that a <TT>Color </TT>is passed in its <TT>setValue </TT>method. If the renderer were used to renderer values other than colors, a <TT>ClassCastException </TT>would be thrown.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Figure 12.7 also shows the cell containing the color red being
edited. You can see that the editor is a <TT>JTextField</TT> with
the text set to the <TT>String</TT> returned from the <TT>toString</TT>
method of the <TT>Color</TT> instance. This is obviously undesirable
behavior. The solution is to create a cell editor and set it for
the <TT>Color</TT> class.
<P>
Similar to what you saw previously for renderers, the <TT>JTable</TT>
class calls the protected <TT>createDefaultEditors</TT> method
to create and register default editors for the table. Table 12.6
lists the classes for which default editors are registered. Extensions
to the <TT>JTable</TT> class can override this method to register
a different set of editors for the table. Clients can also register
editors by using the <TT>public</TT> <TT>setDefaultEditor</TT>
method.<BR>
<P>
<CENTER><B>Table 12.6&nbsp;&nbsp;Default Editors for the </B><TT><B>JTABLE</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=197><CENTER><B>Class</B></CENTER></TD><TD WIDTH=197><CENTER><B>Renderer</B></CENTER>
</TD><TD WIDTH=197><CENTER><B>Positioning</B></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Object</TT></TD><TD WIDTH=197><TT>DefaultCellEditor</TT>
</TD><TD WIDTH=197><TT>JTextField</TT> with left-aligned text
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Number</TT></TD><TD WIDTH=197><TT>DefaultCellEditor</TT>
</TD><TD WIDTH=197><TT>JTextField</TT> with right-aligned text
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=197><TT>Boolean</TT></TD><TD WIDTH=197><TT>DefaultCellEditor</TT>
</TD><TD WIDTH=197>Centered <TT>JCheckBox</TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
The code shown next shows an editor that allows the colors to
be chosen in the table. The editor is a <TT>DefaultCellEditor</TT>
containing a <TT>JComboBox</TT> that has been configured for the
valid colors for the data model. If any color is allowed in the
data model, an editor could be created from the <TT>JColorChooser</TT>
class. This class is presented in <A HREF="..\ch19\ch19.htm" >Chapter 19</A>, &quot;Choice Dialog
Boxes.&quot; The <TT>JComboBox</TT> is also configured with the
renderer shown in Listing 12.8. This renderer displays colors
similarly to the renderer in the table. The resulting editor is
shown in Figure 12.8.
<P>
<A HREF="javascript:popUp('f12-8.gif')"><B>Figure 12.8 :</B> <I>The custom Color class renderer</I>.</A>
<BLOCKQUOTE>
<PRE>
JComboBox comboBox = new JComboBox();
comboBox.addItem( Color.black );
comboBox.addItem( Color.gray );
comboBox.addItem( Color.red );
comboBox.addItem( Color.pink );
comboBox.addItem( Color.orange );
comboBox.addItem( Color.yellow );
comboBox.addItem( Color.green );
comboBox.addItem( Color.blue );
comboBox.addItem( Color.cyan );
comboBox.addItem( Color.white );
comboBox.addItem( Color.lightGray );
comboBox.setRenderer( new ColorCellRenderer() );
         
table.setDefaultEditor( Color.class, new DefaultCellEditor( comboBox ) );
<BR>
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<B>Listing 12.8&nbsp;&nbsp;The </B><TT><B>COLORCELLRENDERER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
/**
 * ColorCellRenderer is a rendering class that expects
 * Color values. When this is the case, it paints the color
 * as the background of the label. If not, show the String
 * returned from the toString method of the value Object.
 *
 * @author Mike Foley
 **/
class ColorCellRenderer extends JLabel implements ListCellRenderer { 

    Border selectedWhiteBorder;
    Border selectedBlackBorder;
    
    /**
     * ColorCellRenderer, default constructor.
     * We must be opaque so the background is painted.
     **/
    public ColorCellRenderer() { 
        setOpaque( true );
        selectedWhiteBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.white );
        selectedBlackBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.black );
    } 


    /**
     * Configure yourself for the state passed.
     * If the value is a Color, set the background to that
     * color. If not use the toString method of the value
     *
     **/
    public Component getListCellRendererComponent(
        JList list, 
        Object value, 
        int index, 
        boolean isSelected, 
        boolean cellHasFocus) 
    { 
        
        if( value instanceof Color ) { 
            setText( &quot;      &quot; );
            setBackground( ( Color )value );
            if( isSelected ) { 
                if( value.equals( Color.white ) )
                    setBorder( selectedBlackBorder );
                else
                    setBorder( selectedWhiteBorder );
            }  else { 
                setBorder( null );
            }
        }  else {            
            setText( value.toString() );
            if( isSelected ) { 
                setBackground( list.getSelectionBackground() );
                setForeground( list.getSelectionForeground() );
            }  else { 
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            } 
        } 
        
        
        return this;
    } 
    
}  // ColorCellRenderer
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The user gesture to begin editing a cell is look-and-feel specific.
It also depends on the editor. For example, an editor built on
a <TT>JTextField</TT> requires a double-click to commence editing,
while the editor built on the <TT>JCheckBox</TT> for <TT>Boolean</TT>
data requires only a single click to edit the cell. This type
of inconsistency is annoying to the user and gives editing the
table a bad feel. The <TT>editCellAt</TT> method is used to start
a cell editing if the cell allows editing.
<P>
The default cell editor for <TT>Number</TT> and <TT>Object</TT>
instances doesn't have a way to cancel editing. Editing is stopped
by pressing the Enter key or selecting a different cell in the
table. However, if the cell had been edited, the change is set
in the data model. It is desirable to give the user a way to cancel
editing without changing the data model. The following cell editor
provides this functionality. When the escape key is pressed, editing
is canceled without changing the data model. The editor is then
registered as the editor for the <TT>Number</TT> class. A similar
editor that contains left-aligned text should be registered for
the <TT>Object</TT> class if your tables contain any columns that
use the <TT>Object</TT> editor. If this editor is going to be
used in multiple tables, it should be encapsulated in its own
class that can be used as the editor for each table. 
<BLOCKQUOTE>
<PRE>
JTextField textField = new JTextField();
final DefaultCellEditor cancelCellEditor = 
                        new DefaultCellEditor( textField );
textField.setHorizontalAlignment( SwingConstants.RIGHT );
textField.addKeyListener( new KeyAdapter() { 
    public void keyReleased( KeyEvent event ) { 
        if( event.getKeyCode() == KeyEvent.VK_ESCAPE )
            cancelCellEditor.cancelCellEditing();
        } 
    }  );
table.setDefaultEditor( Number.class, cancelCellEditor );
</PRE>
</BLOCKQUOTE>
<P>
The renderer for the column's header can be specified also. A
common need for this is for multiline headers. The <TT>MutliLineHeaderRenderer</TT>
class shown in Listing 12.9 implements a multiline column header
renderer. This class extends the <TT>JTextArea</TT> class to provide
a multiline textual display region. In the <TT>getTableCellRendererComponent</TT>
method, the color and border are set to those defined in the current
<TT>JTableHeader</TT> contained in the table. The proper border
is obtained from the <TT>UIManager</TT>. This ensures that the
multiline header will look the same as default renderers used
on other tables. A complete description of obtaining component
properties from the <TT>UIManager</TT> is presented in Part V,
&quot;Extending JFC Components,&quot; and in <A HREF="..\ch30\ch30.htm" >Chapter 30</A>, &quot;Pluggable
Look-and-Feel.&quot;
<P>
The problem with the current implementation of the <TT>MultiLineHeaderRenderer</TT>
class is that it doesn't dynamically obtain multiline data from
the header or data model. The current table package is designed
for single-line headers. Using multiple line headers requires
overriding methods in one of the standard classes or using &quot;known&quot;
models. For example, a custom data model can return <TT>String</TT>
instances with embedded line-feed characters from its <TT>getColumnName</TT>
method. However, if this is done, the header will not display
properly using the default column header renderer. 
<P>
A single instance of the <TT>MultiLineHeaderRenderer</TT> can
be shared among all <TT>TableColumn</TT> instances in the <TT>TableColumnModel</TT>.
The code fragment to query the columns from the table and set
the renderer is shown next. If columns can be dynamically added
to the table, a <TT>TableColumnModelListener</TT> would need to
be added to the <TT>TableColumnModel</TT> to set the renderer
for new columns. The table using the <TT>MultiLineHeaderRenderer</TT>
is shown in Figure 12.9.
<P>
<A HREF="javascript:popUp('f12-9.gif')"><B>Figure 12.9 :</B> <I>Multiline table headers</I>.</A><P>
<HR>
<P>
<B>Listing 12.9&nbsp;&nbsp;The </B><TT><B>MULTILINEHEADERRENDERER</B></TT><B>
Class, and Adding It to a Table<BR>
</B>
<BLOCKQUOTE>
<PRE>
//
// Create a multiline renderer, and set it for each column in
// the table.
//
MultiLineHeaderRenderer headerRenderer = new MultiLineHeaderRenderer();
TableColumnModel columnModel = table.getColumnModel();
for( Enumeration e = columnModel.getColumns(); e.hasMoreElements(); ) { 
    TableColumn column = ( TableColumn )e.nextElement();
    column.setHeaderRenderer( headerRenderer );
} 


/**
 * An example of a multiline table header.
 * To be used effectively, known header value types
 * would need to be specified in an interface that
 * could be tested for here. This would allow useful
 * data to be queried for the additional rows in the header.
 * This could be done by a specialized table model that
 * returns column headers with breaks in the returned
 * String from the getColumnName method that could be 
 * interpreted here.
 **/
class MultiLineHeaderRenderer extends JTextArea 
    implements TableCellRenderer, Serializable { 
        
    /**
     * MultiLineHeaderRenderer, default Constructor.
     * Set the number of rows to two. For a production
     * header renderer, the number of rows would probably
     * be determined dynamically depending on the header value.
     **/
    public MultiLineHeaderRenderer() { 
        super( 2, 20 );
        setOpaque( true );
    } 
    
    
    /**
     * Configure in the standard table header colors and border.
     * The multiline string is a bit contrived here. Would need
     * to get a real multiline header from the table model, or
     * values of known types, i.e. interfaces.
     **/
    public Component getTableCellRendererComponent(JTable table,
                         Object value, boolean isSelected, 
                         boolean hasFocus, int row, int column) { 
                            
        if (table != null) { 
            JTableHeader header = table.getTableHeader();
            if (header != null) { 
                setForeground(header.getForeground());
                setBackground(header.getBackground());
                setFont(header.getFont());
            } 
        } 

        setText( (value == null) ? &quot;Column &quot; + column : 
                &quot;Column &quot; + column + &quot;\ n&quot; + value.toString() );
        setBorder( UIManager.getBorder(&quot;TableHeader.cellBorder&quot;) );
        return this;
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="EntireSourceListingoftheTTFONTSIZETableTestFONTTTFONTSIZEApplicationFONT">
Entire Source Listing of the <TT>TableTest</TT>
Application</A></H3>
<P>
The previous portion of this section presented the functional
components of the <TT>TableTest</TT> application. For completeness,
the entire source listing is given in Listing 12.10. This includes
the renderers, editors, and the data model. The code is contained
in a single source file. To allow the renderers or editors to
be used in multiple tables, they need to be moved into their own
source file.<P>
<HR>
<P>
<B>Listing 12.10&nbsp;&nbsp;The </B><TT><B>TABLETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.io.Serializable;

import java.util.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.table.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTable instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class TableTest extends Object { 

    /**
     * Application entry point.
     * Create a frame and the table and display them.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;TableTest&quot; );

        JTable table = new JTable( new TableTestModel() );
        
        //
        // Create and register a Color class renderer.
        //
        DefaultTableCellRenderer colorRenderer = 
            new DefaultTableCellRenderer() { 
            public void setValue( Object value ) { 
                setBackground( ( Color )value );
            } 
        } ;
        
        colorRenderer.setOpaque( true );
        table.setDefaultRenderer( Color.class, colorRenderer );

        //
// Create a combo box with colors available in the table.
// The combo box will be used for the Color cell editor.
// The combo box itself has a custom list renderer.
        //
        JComboBox comboBox = new JComboBox();
        comboBox.addItem( Color.black );
        comboBox.addItem( Color.gray );
        comboBox.addItem( Color.red );
        comboBox.addItem( Color.pink );
        comboBox.addItem( Color.orange );
        comboBox.addItem( Color.yellow );
        comboBox.addItem( Color.green );
        comboBox.addItem( Color.blue );
        comboBox.addItem( Color.cyan );
        comboBox.addItem( Color.white );
        comboBox.addItem( Color.lightGray );
        comboBox.setRenderer( new ColorCellRenderer() );
         
        table.setDefaultEditor( Color.class, 
                                new DefaultCellEditor( comboBox ) );
        
        table.setDefaultRenderer( Boolean.class, 
                                  new SelectedCheckBoxRenderer() );
   
        //
        // Add an editor for the Number class that aborts the edit 
        // without changing the data model when the escape key is
        // entered during the edit.
        //
        JTextField textField = new JTextField();
        final DefaultCellEditor cancelCellEditor = 
                                new DefaultCellEditor( textField );
        textField.setHorizontalAlignment( SwingConstants.RIGHT );
        textField.addKeyListener( new KeyAdapter() { 
            public void keyReleased( KeyEvent event ) { 
                if( event.getKeyCode() == KeyEvent.VK_ESCAPE )
                    cancelCellEditor.cancelCellEditing();
            } 
        }  );
        table.setDefaultEditor( Number.class, cancelCellEditor );

        //
        // A single multiline renderer may be shared between all
        // columns in the table. Set the renderer for each column.
        // 
        MutliLineHeaderRenderer headerRenderer = 
                                new MutliLineHeaderRenderer();
        TableColumnModel columnModel = table.getColumnModel();
        for( Enumeration e = columnModel.getColumns(); 
            e.hasMoreElements(); ) { 
            TableColumn column = ( TableColumn )e.nextElement();
            column.setHeaderRenderer( headerRenderer );
        } 

        //
        // Only allow row selection.
        //
        table.setRowSelectionAllowed( true );
        table.setColumnSelectionAllowed( false );
        
        //
        // Add the table to a scroll pane and add to the content
        // pane of the frame.
        //
        frame.getContentPane().add( new JScrollPane( table ), 
                                    BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // TableTest


/**
 * An example of a multiline table header.
 * To be used effectively, known header value types
 * would need to be specified in an interface that
 * could be tested for here. This would allow useful
 * data to be queried for the additional rows in the header.
 * This could be done by a specialized table model that
 * returns column headers with breaks in the returned
 * String from the getColumnName method that could be 
 * interpreted here.
 **/
class MutliLineHeaderRenderer extends JTextArea 
    implements TableCellRenderer, Serializable { 
        
    /**
     * MutliLineHeaderRenderer, default Constructor.
     * Set the number of rows to two. For a production
     * header renderer, the number of rows would probably
     * be determined dynamically depending on the header value.
     **/
    public MutliLineHeaderRenderer() { 
        super( 2, 20 );
        setOpaque( true );
    } 
    
    
    /**
     * Configure in the standard table header colors and border.
     * The multiline string is a bit contrived here. Would need
     * to get a real multiline header from the table model, or
     * values of known types, i.e. interfaces.
     **/
    public Component getTableCellRendererComponent(JTable table,
                         Object value, boolean isSelected, 
                         boolean hasFocus, int row, int column) { 
                            
        if (table != null) { 
            JTableHeader header = table.getTableHeader();
            if (header != null) { 
                setForeground(header.getForeground());
                setBackground(header.getBackground());
                setFont(header.getFont());
            } 
        } 

        //
        // Add a second line that is the column number.
        //
        setText( (value == null) ? &quot;Column &quot; + column : 
                &quot;Column &quot; + column + &quot;\ n&quot; + value.toString() );
      	setBorder( UIManager.getBorder(&quot;TableHeader.cellBorder&quot;) );
        return this;
    } 
} 


/**
 * ColorCellRenderer is a rendering class that expects
 * Color values. When this is the case, it paints the color
 * as the background of the label. If not, show the String
 * returned from the toString method of the value Object.
 *
 * @author Mike Foley
 **/
class ColorCellRenderer extends JLabel 
    implements ListCellRenderer, Serializable { 

    Border selectedWhiteBorder;
    Border selectedBlackBorder;
    
    /**
     * ColorCellRenderer, default constructor.
     * We must be opaque so the background is painted.
     **/
    public ColorCellRenderer() { 
        setOpaque( true );
        selectedWhiteBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.white );
        selectedBlackBorder = BorderFactory.createMatteBorder( 
                                            3, 5, 3, 5, Color.black );
    } 


    /**
     * Configure yourself for the state passed.
     * If the value is a Color, set the background to that
     * color. If not, use the toString method of the value
     *
     **/
    public Component getListCellRendererComponent(
        JList list, 
        Object value, 
        int index, 
        boolean isSelected, 
        boolean cellHasFocus) 
    { 
        
        if( value instanceof Color ) { 
            setText( &quot;      &quot; );
            setBackground( ( Color )value );
            if( isSelected ) { 
                if( value.equals( Color.white ) )
                    setBorder( selectedBlackBorder );
                else
                    setBorder( selectedWhiteBorder );
            }  else { 
                setBorder( null );
            } 
        }  else {            
            setText( value.toString() );
            if( isSelected ) { 
                setBackground( list.getSelectionBackground() );
                setForeground( list.getSelectionForeground() );
            }  else { 
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            } 
        }
       
        
        return this;
    } 
    
}  // ColorCellRenderer


/**
 * The SelectedCheckBoxRenderer class is almost the same as the
 * default check box renderer in the JTable class. However, it
 * paints the cell in the normal table selected colors when it is
 * selected. This avoids the white areas in the table for Boolean
 * columns. Also, if all columns in the table are Boolean, you
 * wouldn't be able to see the selected row using the default renderer!
 *
 * @author Mike Foley
 **/
class SelectedCheckBoxRenderer extends JCheckBox 
    implements TableCellRenderer, Serializable { 
        
    private Border noFocusBorder;
    private Color unselectedForeground; 
    private Color unselectedBackground; 

    
    /**
     * SelectedCheckBoxRenderer, default constructor.
     *
     * We need to be opaque so our background color is painted.
     * Create our border. Keep a reference around so it can be
     * reset when we are not selected.
     * Center the check box to match the position of the Boolean editor.
     **/
    public SelectedCheckBoxRenderer() { 
        super();
    	setOpaque( true );
    	
        noFocusBorder = BorderFactory.createEmptyBorder( 1, 2, 1, 2 );
        setBorder( noFocusBorder );
        
        setHorizontalAlignment( JLabel.CENTER );
    } 


    /**
     * Set the foreground color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new foreground color.
     **/
    public void setForeground(Color c) { 
        super.setForeground(c); 
        unselectedForeground = c; 
    } 
    
    
    /**
     * Set the background color. Remember the color, so
     * we can reset it when we are not selected.
     *
     * @param c The new background color.
     **/
    public void setBackground(Color c) { 
        super.setBackground(c); 
        unselectedBackground = c; 
    } 


    /**
     * Clear the foreground and background colors after
     * updating the UI. This will cause the colors to be
     * read from the table property portion of the UI.
     **/
    public void updateUI() { 
        super.updateUI(); 
        setForeground( null );
    	setBackground( null );
    } 
    

    /**
     * getTableCellRendererComponent, from TableCellRenderer
     *
     * Configure the check box for the given state.
     *
     **/
    public Component getTableCellRendererComponent(JTable table,
                         Object value, boolean isSelected, 
                         boolean hasFocus, int row, int column) { 
            
        //
        // Check or uncheck the JCheckBox.
        //
        setSelected((value != null &amp;&amp; ((Boolean)value).booleanValue()));

        //
        // If we are selected, paint in the table's selection colors.
        //
        if( isSelected ) { 
            super.setForeground( table.getSelectionForeground() );
            super.setBackground( table.getSelectionBackground() );
        }  else { 
            super.setForeground( ( unselectedForeground != null ) ?  
                             unselectedForeground : table.getForeground() );
            super.setBackground( ( unselectedBackground != null ) ? unselectedBackground 
                              unselectedBackground : table.getBackground() );
        }  // else
       
        //
        // If we have the focus, paint in the focus color for the table.
        // and set the focus border.
        // If not, set the no focus border.
        //
        if( hasFocus ) { 
            setBorder( UIManager.getBorder( 
                           &quot;Table.focusCellHighlightBorder&quot; ) );
            if (table.isCellEditable(row, column)) { 
                super.setForeground( UIManager.getColor( 
                                        &quot;Table.focusCellForeground&quot; ) );
                super.setBackground( UIManager.getColor( 
                                    &quot;Table.focusCellBackground&quot; ) );
            }
        }  else { 
            setBorder( noFocusBorder );
        } 
        
        return( this );
    } 
    
}  // SelectedCheckBoxRenderer


/**
 * Table model that returns the Class of the data in
 * a particular column. This allows the table to set
 * renderers for the data.
 **/
class TableTestModel extends AbstractTableModel 
    implements Serializable { 

    /**
     * The data in the model.
     **/
     Object[][] data = { 
        {  &quot;Mike&quot;, Color.blue, new Boolean( true ), new Integer(9) } ,
        {  &quot;Mari&quot;, Color.red, new Boolean( true ), new Integer(6) } ,
        {  &quot;Molly&quot;, Color.yellow, new Boolean( false ), new Integer(1) } ,
        {  &quot;Betsy&quot;, Color.orange, new Boolean( false ), new Integer(8) } ,
        {  &quot;Bobby&quot;, Color.lightGray, new Boolean( true ), new Integer(7) } 
        } ;

    /**
     * The column names for the model.
     **/
    String[] columnNames = {  &quot;Name\ nFirst&quot;, &quot;Color&quot;, &quot;Enabled&quot;, &quot;Size&quot; } ;
    
    
    /**
     * TableTestModel, constructor.
     **/
    TableTestModel() { 
        super();    
    } 
        
        
    /**
     * getRowCount, from TableModel.
     *
     * @return The number of rows in the data.
     **/
    public int getRowCount() { 
        return( data.length );
    } 

    
    /**
     * getColumnCount, from TableModel.
     *
     * @return The number of columns in the data.
     **/
    public int getColumnCount() { 
        return( data[0].length );
    } 
    
    /**
     * getValueAt, from TableModel.
     *
     * @param row The row of the requested data object.
     * @param column The column of the requested data object.
     * @return The object at the specified cell.
     **/
    public Object getValueAt( int row, int column ) { 
        return( data[ row ][ column ] );
    } 

    /**
     * setValueAt, from TableModel.
     *
     * Set the data value in the given location to the
     * given object.
     *
     * @param value The new data object.
     * @param row The row of the new data object.
     * @param column The column of the new data object.
     **/
    public void setValueAt( Object value, int row, int column ) { 
        if( column == 0 )
            throw new RuntimeException( 
                      &quot;The Name column is not editable&quot; );
            
        data[ row ][ column ] = value;
        fireTableCellUpdated( row, column );
    } 


    /**
     * getColumnName, from TableModel.
     *
     * @param column The column index whose name is desired.
     * @return The name of the column with the given index.
     **/
    public String getColumnName( int column ) { 
        return( columnNames[ column ] );
    } 
    
    /**
     * getColumnClass, from TableModel.
     *
     * @param column The column index whose Class is desired.
     * @return The Class of the data for the column with the given index.
     **/
    public Class getColumnClass( int column ) { 
        return( data[0][ column ].getClass() );
    } 
    
    
    /**
     * isCellEditable, from TableModel.
     *
     * All columns except the first are editable in this model.
     *
     * @param row The row of the cell whose editability is requested.
     * @param column The column of the cell whose editability is 
     *               requested.
     * @return true if the cell is editable, false otherwise.
     **/
    public boolean isCellEditable( int row, int column ) { 
        if( column == 0 ) { 
            return( false );
        }  else { 
            return( true );
        } 
    } 
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="ScrollingaTable">
Scrolling a Table</A></H2>
<P>
As was seen in <A HREF="..\ch03\ch03.htm" >Chapter 3</A> &quot;<TT>JComponent</TT>,&quot; the
<TT>JComponent</TT> class defines the <TT>autoscrolls</TT> property.
In the <TT>JComponent</TT> class, the default value for this property
is defined to be <TT>false</TT>. However, the <TT>JTable</TT>
class overrides the value for this property and sets it to <TT>true</TT>.
This allows large tables contained in a <TT>JScrollPane</TT> instance
to be scrolled both horizontally and vertically by dragging the
mouse in the desired direction. The scrollbars do not need to
be used. Currently in the JFC, the <TT>JList</TT> and <TT>JTable</TT>
classes are the only two classes that take advantage of this functionality.
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The <TT>JTable</TT> class uses a complex collection of interfaces
and classes by delegating much of its functionality to support
classes. This requires understanding how interfaces and classes
work and how they interact with one another to fully understand
how the table component works. The immaturity of these interfaces
and classes is apparent in the inconsistency of implementation
of interrelated classes and the small number of bound properties
in the <TT>JTable</TT> class. These inconsistencies raise the
bar on the learning curve for effectively using the <TT>Table</TT>
package.
<P>
This chapter doesn't present every method contained in the <TT>JTable</TT>
class or the classes in the table package. However, the most common
methods, and those required for customization, are presented here.
The complete API for all these classes is given in the reference
section.
<P>
The current set of default renderers and editors for the <TT>JTable</TT>
class is very limited. This chapter showed how to create a renderer
and an editor for the <TT>Color</TT> class, as well as enhancing
the existing renderers for the <TT>Boolean</TT>, <TT>Number</TT>,
<TT>String</TT>, and <TT>Object</TT> classes. As the JFC matures,
you can remain hopeful that a rich collection of renderers and
editors will be provided from the toolkit. Obvious omissions other
than the <TT>Color</TT> class are the <TT>Date</TT> class and
editors that verify <TT>Numbers</TT>.
<P>
A complex example was presented that contained a custom data model,
custom data renderers, and editors. After understanding this example,
you should be equipped with the tools required to create tables
of arbitrary complexity.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch11\ch11.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch13\ch13.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
