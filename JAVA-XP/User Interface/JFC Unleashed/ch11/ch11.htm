<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">


<!--

function popUp(pPage) {
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="/includes/stylesheets/ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 figDoc.write(zhtm);
 figDoc.close();
 popUpWin.focus();
 }

//-->


</SCRIPT>
<link rel="stylesheet" href="http://www.szptt.net.cn/includes/stylesheets/ebooks.css">

        <META NAME="GENERATOR" Content="Symantec Visual Page 1.0.1">
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
        <TITLE>JFC -- Chapter 11 - Tree Component</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="..\button\sams.gif" BORDER="0"></H1>

<P><A HREF="..\ch10\ch10.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch12\ch12.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 


<H1>JFC Unleashed</H1></CENTER>
<HR>


<H1>Chapter&nbsp;11<br>
Tree Component</H1>
<HR>
<p>


<UL>
<LI><A HREF="#UsingtheTTFONTSIZEJTreeFONTTTFONTSIZEComponentFONT">
Using the <TT>JTree</TT>
Component</A>
<LI><A HREF="#TheTTFONTSIZEswingtreeFONTTTFONTSIZEPackageFONT">
The <TT>swing.tree</TT> Package
</A>
<UL>
<LI><A HREF="#TreeNodes">
Tree Nodes</A>
<LI><A HREF="#TreePaths">
Tree Paths</A>
<LI><A HREF="#TreeSelectionModel">
Tree Selection Model</A>
<LI><A HREF="#RenderingandEditing">
Rendering and Editing</A>
<LI><A HREF="#PullingItAllTogetherACompleteTTFONTSIZEJTreeFONTTTFONTSIZEExampleFONT">
Pulling It All Together: A Complete <TT>JTree</TT>
Example</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>

<HR>
<P>
The <TT>JTree</TT> <TT>class</TT> is an <TT>implementation</TT>
of a control that allows you to view data in a hierarchical structure.
The AWT did not have a component comparable to the <TT>JTree</TT>
class. Perhaps the most familiar example of a tree component in
use is in a file manager type application. The file system's directory
structure is organized as a tree, so the view is a natural fit.
<P>
The <TT>JTree</TT> class provides convenience methods for easy
tree configuration. A tree can be configured to allow editing
of the nodes in the tree. The <TT>TreeModel</TT> interface is
available for creating custom data models to be viewed in the
tree component. By using these techniques, the <TT>JTree</TT>
class can be configured to meet almost any need for a tree component.
<P>
In this chapter, you will learn
<UL>
<LI>How to create and use the <TT>JTree</TT> class
<LI>About the <TT>TreeModel</TT> interface
<LI>About the <TT>TreeNode</TT> and <TT>MutableTreeNode</TT> interfaces
<LI>How to create and use a renderer for a tree
<LI>How to use an editor with a tree
</UL>
<H2><A NAME="UsingtheTTFONTSIZEJTreeFONTTTFONTSIZEComponentFONT">
Using the <TT>JTree</TT>
Component</A></H2>
<P>
The visual control in the JFC for displaying hierarchical data
structures is the <TT>JTree</TT> class. The tree consists of multiple
nodes that can be expanded and collapsed to display more or less
detail of the underlying data model. The top node in the tree
is known as the root node. A node that does not contain any children
nodes is known as a leaf node.
<P>
The simplest example of a <TT>JTree</TT> instance is presented
in Listing 11.1. The default <TT>JTree</TT> constructor is called,
and the tree is displayed. An instance of the <TT>ApplicationFrame</TT>
class, presented in <A HREF="..\ch08\ch08.htm" >Chapter 8</A> &quot;Frame Windows,&quot; is used
to display the tree. The resulting tree after being expanded is
shown in Figure 11.1.<P>
<HR>
<P>
<B>Listing 11.1&nbsp;&nbsp;The </B><TT><B>SIMPLETREETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;

import javax.swing.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTree instance
 * in its frame.
 *
 * @author Mike Foley
 **/
public class SimpleTreeTest extends Object { 

    /**
     * Application entry point.
     * Create a frame and the tree and display them.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        JFrame frame = new ApplicationFrame( &quot;SimpleTreeTest Test&quot; );

        JTree tree = new JTree();
        tree.setBorder( BorderFactory.createLoweredBevelBorder() );
        
        frame.getContentPane().add( tree, BorderLayout.CENTER );
        
        frame.pack();
        frame.setVisible( true );
        
    }  // main

}  // SimpleTreeTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>

<A HREF="javascript:popUp('f11-1.gif')"><B>Figure11.1:</B><I> The default JTree instance</I>.</A>
<P>
The tree shown in Figure 11.1 uses the default tree model contained
in the <TT>JTree</TT> class. The model is created in the protected
<TT>getDefaultTreeModel</TT> method. <TT>JTree</TT> extensions
can override this method to contain a different default model.
It is seen in the figure that the root node of the tree is shown
by default. Icons are associated with each node in the tree. The
default icons are look-and-feel specific but tend to be of the
file management type like those shown for the Metal look-and-feel
in Figure 11.1. Notice that the leaf icon is different than that
of non-leaf nodes. The control to the left of the icon, a dot
in this figure, can be used to expand and collapse the node. This
application also demonstrates that the default tree needs some
data to display.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=600><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=600>
<BLOCKQUOTE>
Figure 11.1 shows a <TT>JTree </TT>instance when the Metal look-and-feel is being used. The hor- izontal lines above each node that is a child of the root node is specific to this look-and- feel. In fact, Metal defines a client property for the <TT>JTree </TT>class. When the <TT>JTree.lineStyle </TT>property is set to one of the three known values-<TT>Angled</TT>, <TT>None</TT>, and the default <TT>Horizontal</TT>-the look-and-feel draws the lines appropriately. The property strings are case sensitive. This property is ignored in the other standard look-and-feel implementations. The <TT>Angled </TT>option, shown in Figure 11.2, is the line style familiar with most tree users.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<A HREF="javascript:popUp('f11-2.gif')"><B>Figure 11.2 :</B> <I>Angled lines in the default JTree instance</I>.</A>
<P>
The <TT>JTree</TT> class contains versions of the constructor
that take an instance of an array, <TT>Hashtable</TT>, or <TT>Vector</TT>
as a parameter. You can modify the <TT>SimpleTreeTest</TT> application
to create a tree instance from one of these collection classes
by instantiating the <TT>JTree</TT> instance with one of the following
blocks of code shown in Listing 11.2. (For the <TT>Vector</TT>
and <TT>Hashtable</TT> initialization, the <TT>java.util.Vector</TT>
or <TT>java.util.Hashtable</TT> package must be imported at the
top of the application.) The resulting trees are shown in Figure
11.3.<P>
<HR>
<P>
<B>Listing 11.2&nbsp;&nbsp;Initializing a Tree from a Collection
<BR>
</B>
<BLOCKQUOTE>
<PRE>
// Test using an array.
String[] data = {  &quot;Mike&quot;, &quot;Mari&quot;, &quot;Molly&quot; } ;        
JTree tree = new JTree( data );

// Test using a Vector.
Vector data = new Vector();        
data.addElement( &quot;Mike&quot; );
data.addElement( &quot;Mari&quot; );
data.addElement( &quot;Molly&quot; );
JTree tree = new JTree( data );

// Test using a Hashtable.
Hashtable data = new Hashtable();        
data.put( &quot;Mike&quot;, new Integer(0) );
data.put( &quot;Mari&quot;, new Integer(1) );
data.put( &quot;Molly&quot;, new Integer(2) );
JTree tree = new JTree( data );
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="javascript:popUp('f11-3.gif')"><B>Figure 11.3 :</B> <I>JTree initialization from the standard
JDK 1.1 collections</I>.</A>
<P>
Figure 11.3 shows that the tree does not show the root node when
initialized from a collection. You can force the root node to
be displayed by passing <TT>true</TT> to the <TT>setRootVisible</TT>
method. The root visibility status is a bound property in the
<TT>JTree</TT> class. The complete list of bound properties introduced
in the <TT>JTree</TT> class is presented in Table 11.1. The nodes
in the tree created from the <TT>Hashtable</TT> are in a different
order than the other two trees, and the data is not in a tree
hierarchy. This is because the collection passed to the constructor
does not contain hierarchical information. Having the collection
contain other collections as members can rectify this situation.
The following code shows this for the <TT>Vector</TT> class (see
Figure 11.4), but a similar approach can be used for other collection
types. The type of collection can be mixed also. For example,
a vector can contain hashtables as its elements.
<BLOCKQUOTE>
<PRE>
Vector data = new Vector();        
Vector names = new Vector();
names.addElement( &quot;Mike&quot; );
names.addElement( &quot;Mari&quot; );
names.addElement( &quot;Molly&quot; );
        
data.addElement( names );
JTree tree = new JTree( data );<BR>
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="javascript:popUp('f11-4.gif')"><B>Figure 11.4 :</B> <I>Vector-created tree</I>.</A>
<P>
In Figure 11.4, you can see that the data is displayed as a tree,
but somewhat clumsily. The default tree implementation calls the
<TT>toString</TT> method of the <TT>Object</TT> class for each
node. This probably is not the desired string for a <TT>Vector</TT>,
<TT>Hashtable</TT>, or array. The <TT>toString</TT> method in
the <TT>Vector</TT> class is final, so an anonymous extension
to the <TT>Vector</TT> class that overrides the <TT>toString</TT>
method cannot be used. Later in this chapter you will see how
the <TT>JTree</TT> class can be extended and how a custom rendering
class can be used to overcome this situation. Even though the
basic collections can be used to populate the tree, simply put,
they are the wrong data structure for a tree. Fortunately, the
JFC defines the <TT>TreeModel</TT> and <TT>TreeNode</TT> interfaces
that are the correct data structure for a tree. When a collection
is used to initialize a tree, a tree model is created by traversing
the collection and creating parent nodes for each collection found
and leaf nodes for other types of objects. These interfaces and
the classes that implement them in the JFC are the subject of
the next section.<BR>
<P>
<CENTER><B>Table 11.1&nbsp;&nbsp;Bound Properties Introduced in
the </B><TT><B>JTREE</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=144><CENTER><B>Setter Method</B></CENTER>
</TD><TD WIDTH=144><CENTER><B>Getter Method</B></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>CELL_RENDERER_PROP+ERTY</TT></TD><TD WIDTH=144><TT>setCellRenderer</TT>
</TD><TD WIDTH=144><TT>getCellRenderer</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>EDITABLE_PROPERTY</TT></TD><TD WIDTH=144><TT>setEditable</TT>
</TD><TD WIDTH=144><TT>isEditable</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>TREE_MODEL_PROPERTY</TT></TD><TD WIDTH=144><TT>setModel</TT>
</TD><TD WIDTH=144><TT>getModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ROOT_VISIBLE_PROPERTY</TT></TD><TD WIDTH=144><TT>setRootVisible</TT>
</TD><TD WIDTH=144><TT>isRootVisible</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>SHOWS_ROOT_HANDLES_PROPERTY</TT></TD><TD WIDTH=144><TT>setShowsRoot
<BR>
Handles</TT>
</TD><TD WIDTH=144><TT>getShowsRoot<BR>
Handles</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ROW_HEIGHT_PROPERTY</TT></TD><TD WIDTH=144><TT>setRowHeight</TT>
</TD><TD WIDTH=144><TT>getRowHeight</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>LARGE_MODEL_PROPERTY</TT></TD><TD WIDTH=144><TT>setLargeModel</TT>
</TD><TD WIDTH=144><TT>isLargeModel</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>INVOKES_STOP_CELL</TT></TD><TD WIDTH=144><TT>setInvokesStop</TT>
</TD><TD WIDTH=144><TT>getInvokesStop</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>_EDITING_PROPERTY</TT></TD><TD WIDTH=144><TT>CellEditing</TT>
</TD><TD WIDTH=144><TT>CellEditing</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>SCROLLS_ON_EXPAND_PROPERTY</TT></TD><TD WIDTH=144><TT>setScrollsOn
<BR>
Expand</TT>
</TD><TD WIDTH=144><TT>getScrollsOn<BR>
Expand</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>SELECTION_MODEL_PROPERTY</TT></TD><TD WIDTH=144><TT>setSelection<BR>
Model</TT>
</TD><TD WIDTH=144><TT>getSelection<BR>
Model</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>VISIBLE_ROW_COUNT_PROPERTY</TT></TD><TD WIDTH=144><TT>setVisibleRow<BR>
Count</TT>
</TD><TD WIDTH=144><TT>getVisibleRow<BR>
Count</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>JTree</TT> class defines three selection modes. <TT>SINGLE_TREE_SELECTION</TT>
mode allows the selection of only one path at a given time. The
<TT>CONTIGUOUS_TREE_SELECTION</TT> mode allows multiple contiguous
paths to be simultaneously selected. The <TT>DISCONTIGUOUS_TREE_SELECTION</TT>
mode allows any paths to be simultaneously selected. The <TT>DISCONTIGUOUS_TREE_SELECTION</TT>
mode is the default selection mode for a <TT>JTree</TT> instance.
The selection mode is defined and enforced by the tree's selection
model discussed in the next section.
<H2><A NAME="TheTTFONTSIZEswingtreeFONTTTFONTSIZEPackageFONT">
The <TT>swing.tree</TT> Package
</A></H2>
<P>
The interfaces that define the tree's data model and the nodes
contained in that model are defined in the <TT>javax.swing.tree</TT>
package. The classes that implement these interfaces and are used
internally by the JFC are located in this package also. The classes
and interfaces are available for you to use in your applications
as well. This section describes the interfaces and classes that
are typically encountered when building tree views in the JFC.
<H3><TT>TreeModel</TT> Interface
</H3>
<P>
The <TT>TreeModel</TT> interface contained in the <TT>swing.tree</TT>
package defines the data model used by the <TT>JTree</TT> class
(see Listing 11.3). By examining the interface, you can see that
the model consists primarily as a reference to the tree's root
node. The other methods are convenience methods to hide implementation
details from the view. For example, the number of children can
be determined for any node in the tree by passing the <TT>getChildCount</TT>
method to the node whose child count is desired. How to find the
node in the tree data structure is hidden from the caller.<P>
<HR>
<P>
<B>Listing 11.3&nbsp;&nbsp;The </B><TT><B>TREEMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TreeModel
{ 

    /**
     * Returns the root of the tree. Returns null only if the tree has
     * no nodes.
     *
     * @return  the root of the tree
     */
    public Object getRoot();


    /**
     * Returns the child of &lt;I&gt;parent&lt;/I&gt; at index &lt;I&gt;index&lt;/I&gt; in the 
     * parent's child array.  &lt;I&gt;parent&lt;/I&gt; must be a node previously
     * obtained from this data source.
     *
     * @param   parent a node in the tree, obtained from this data source
     * @return  the child of &lt;I&gt;parent&lt;/I&gt; at index &lt;I&gt;index&lt;/I&gt;
     */
    public Object getChild(Object parent, int index);


    /**
     * Returns the number of children of &lt;I&gt;parent&lt;/I&gt;.  Returns 0 if the
     * node is a leaf or if it has no children.  &lt;I&gt;parent&lt;/I&gt; must be a
     * node previously obtained from this data source.
     *
* @param  parent  a node in the tree, obtained from this data source
     * @return the number of children of the node &lt;I&gt;parent&lt;/I&gt;
     */
    public int getChildCount(Object parent);


    /**
     * Returns true if &lt;I&gt;node&lt;/I&gt; is a leaf.  It is possible for this
     * method to return false even if &lt;I&gt;node&lt;/I&gt; has no children.  A 
     * directory in a file system, for example, may contain no files; 
     * the node representing the directory is not a leaf, but it also 
     * has no children.
     *
     * @param   node a node in the tree, obtained from this data source
     * @return  true if &lt;I&gt;node&lt;/I&gt; is a leaf
     */
    public boolean isLeaf(Object node);

    /**
      * Messaged when the user has altered the value for the item 
      * identified by &lt;I&gt;path&lt;/I&gt; to &lt;I&gt;newValue&lt;/I&gt;. If &lt;I&gt;newValue&lt;/I&gt; 
      * signifies a truly new value the model should post a 
      * treeNodesChanged event.
      *
      * @param path path to the node that the user has altered.
      * @param newValue the new value from the TreeCellEditor.
      */
    public void valueForPathChanged(TreePath path, Object newValue);

    /**
     * Returns the index of child in parent.
     */
    public int getIndexOfChild(Object parent, Object child);

    /**
     * Adds a listener for the TreeModelEvent posted after the tree 
     * changes.
     *
     * @see     #removeTreeModelListener
     * @param   l       the listener to add
     */
    void addTreeModelListener(TreeModelListener l);

    /**
     * Removes a listener previously added with 
     * &lt;B&gt;addTreeModelListener()&lt;/B&gt;.
     *
     * @see     #addTreeModelListener
     * @param   l       the listener to remove
     */  
    void removeTreeModelListener(TreeModelListener l);

}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DefaultTreeModel</TT> class is a complete implementation
of the <TT>TreeModel</TT> interface. It is used internally by
the <TT>JTree</TT> class as the <TT>TreeModel</TT> when a <TT>TreeModel</TT>
is not explicitly set. The <TT>DefaultTreeModel</TT> class requires
a <TT>TreeNode</TT> in its constructor. This node is used as the
root of the tree. The <TT>swing.tree</TT> package defines interfaces
for two types of tree nodes, a mutable and immutable variant.
These interfaces are described in the next section.
<H3><A NAME="TreeNodes">
Tree Nodes</A></H3>
<P>
The JFC tree data structure defines two interfaces for tree nodes.
The first, <TT>TreeNode</TT>, defines a static node. Once constructed
and placed into a tree, this type of node cannot change its position
in the tree or its children structure. The second interface is
the <TT>MutableTreeNode</TT> interface. This type of node can
be relocated in a tree, moved from one tree to another, and have
its children structure change dynamically. These two interfaces
are shown in Listing 11.4.<P>
<HR>
<P>
<B>Listing 11.4&nbsp;&nbsp;The </B><TT><B>TREENODE</B></TT><B>
and </B><TT><B>MUTABLETREENODE</B></TT><B>
Interfaces<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TreeNode
{ 
    /**
     * Returns the child &lt;code&gt;TreeNode&lt;/code&gt; at index 
     * &lt;code&gt;childIndex&lt;/code&gt;.
     */
    TreeNode getChildAt(int childIndex);

    /**
     * Returns the number of children &lt;code&gt;TreeNode&lt;/code&gt;s the receiver
     * contains.
     */
    int getChildCount();

    /**
     * Returns the parent &lt;code&gt;TreeNode&lt;/code&gt; of the receiver.
     */
    TreeNode getParent();

    /**
     * Returns the index of &lt;code&gt;node&lt;/code&gt; in the receiver's children.
     * If the receiver does not contain &lt;code&gt;node&lt;/code&gt;, -1 will be
     * returned.
     */
    int getIndex(TreeNode node);

    /**
     * Returns true if the receiver allows children.
     */
    boolean getAllowsChildren();

    /**
     * Returns true if the receiver is a leaf.
     */
    boolean isLeaf();

    /**
     * Returns the children of the receiver as an Enumeration.
     */
    Enumeration children();
} 

public interface MutableTreeNode extends TreeNode
{ 
    /**
     * Adds &lt;code&gt;child&lt;/code&gt; to the receiver at &lt;code&gt;index&lt;/code&gt;.
     * &lt;code&gt;child&lt;/code&gt; will be messaged with &lt;code&gt;setParent&lt;/code&gt;.
     */
    void insert(MutableTreeNode child, int index);

    /**
     * Removes the child at &lt;code&gt;index&lt;/code&gt; from the receiver.
     */
    void remove(int index);

    /**
     * Removes &lt;code&gt;node&lt;/code&gt; from the receiver. 
     * &lt;code&gt;setParent&lt;/code&gt; will be messaged on &lt;code&gt;node&lt;/code&gt;.

     */
    void remove(MutableTreeNode node);

    /**
     * Resets the user object of the receiver to &lt;code&gt;object&lt;/code&gt;.
     */
    void setUserObject(Object object);

    /**
     * Removes the receiver from its parent.
     */
    void removeFromParent();

    /**
     * Sets the parent of the receiver to &lt;code&gt;newParent&lt;/code&gt;.
     */
    void setParent(MutableTreeNode newParent);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>TreeNode</TT> interface defines a node that does not change
its structure, or its location in the tree, for its lifetime.
This type of node can still have children; it simply cannot dynamically
add or remove children. The <TT>TreeNode</TT> class must be capable
of returning its parent node in tree from the <TT>getParent</TT>
method. However, the interface does not define a method for setting
the parent. Thus, a class that implements <TT>TreeNode</TT> should
take a reference to its parent in its constructor. The remainder
of the methods defined in the <TT>TreeNode</TT> interface manages
the node's children. However, the interface doesn't contain methods
to create the children's structure. Like the parent reference,
the children can be specified in an implementation class's constructor.
<P>
The <TT>MutableTreeNode</TT> interface extends the <TT>TreeNode</TT>
interface. It adds methods to allow the node to change its location
in the tree and the number of children it contains. The <TT>removeFromParent</TT>
and <TT>setParent</TT> methods allow the node to be moved in the
tree while leaving the node's children unaltered. The <TT>insert</TT>
and <TT>remove</TT> methods allow the children of the node to
be dynamically added and removed. The final method defined in
the <TT>MutableTreeNode</TT> interface, <TT>setUserObject</TT>,
is a bit strange. The user object concept is sound; it allows
the node to contain a reference to one object that is not interpreted
by the node and that the application can use as it sees fit without
having to keep another data structure mapping the user objects
to the tree nodes. However, there is not a method to get the user
object, so the application is out of luck trying to query the
user object from the node. 
<P>
Classes that implement the <TT>TreeNode</TT> interface can benefit
from the user object reference just as much as those that implement
the <TT>MutableTreeNode</TT> interface. To keep the <TT>TreeNode</TT>
interface non-mutable, it should contain the <TT>getUserObject</TT>
method and require the binding to be done at construction time.
This would be similar to what is done with the parent reference
at this time.
<P>
This apparent oddity can be explained by the fact that the JFC
contains only one class that implements the node interfaces, the
<TT>DefaultMutableTreeNode</TT> class. As its name implies, it
implements the <TT>MutableTreeNode</TT> interface. This class
defines a <TT>getUserObject</TT> method. It looks as though not
containing this method in the <TT>TreeNode</TT> interface was
an oversight by the JFC development team. It is unfortunate, though,
because it forces a great deal of code to assume an implementation
of the <TT>MutableTreeNode</TT> class, rather than the much more
desirable condition of working at the interface level.
<P>
Internally, the <TT>DefaultMutableTreeNode</TT> class is the workhorse
node class in the JFC. It is the lone tree node implementation
in the tree package. It implements the <TT>MutableTreeNode</TT>
interface. As such, it serves as a general-purpose tree node that
can be dynamically altered in any way desired. Looking at the
documentation for the <TT>DefaultMutableTreeNode</TT> class shows
that its public API is far richer than that found in the <TT>MutableTreeNode</TT>
interface. However, using the extra methods not defined in the
interface ties your code to that implementation of the <TT>MutableTreeNode</TT>
interface and makes it more difficult to incorporate new tree
node implementations later.
<P>
When a <TT>DefaultMutableTreeNode</TT> instance has a non-<TT>null</TT>
user object, its <TT>toString</TT> method is called when the <TT>toString</TT>
method is called for the node. This allows the text in the tree
to display the user object's <TT>toString</TT> text. This class
contains the <TT>getUserObject</TT> method that is not defined
in either of the tree node interfaces.
<P>
The <TT>DefaultMutableTreeNode</TT> class contains many methods
for querying the children and structure of the node. Many of these
methods are generally applicable to a tree node and rely on the
fact that the node is mutable. For example, the <TT>getLeafCount</TT>
method returns the number of leaf instances that are descendants
from the current node. This method is valid for non-mutable nodes
as well as mutable nodes. It would have been desirable to split
the rich API contained in the <TT>DefaultMutableTreeNode</TT>
into two classes: a non-mutable version containing the static
structure methods, and a mutable node that contains the mutation
methods.
<H3><A NAME="TreePaths">
Tree Paths</A></H3>
<P>
A path in the tree data structure defines a linear path from the
root of the tree to a node. The node may or may not be a leaf
in the tree. Perhaps the easiest way to think of a path is to
start at a node and keep following its parent, its parent's parent,
and so on until the root of the tree is reached. Reversing this
lineage defines a tree path.
<P>
The <TT>swing.tree</TT> package contains the <TT>TreePath</TT>
class that defines the path from the root of the tree to a node
in the tree. The <TT>TreePath</TT> class's constructor takes an
array of node objects that define the path. The class does not
validate the path passed to the method. You will see the <TT>TreePath</TT>
class used in <TT>JTree</TT> methods for expanding the tree. Paths
are used extensively in the tree's selection model, which is the
subject of the next section.
<H3><A NAME="TreeSelectionModel">
Tree Selection Model</A></H3>
<P>
As you have seen earlier with the <TT>ListModel</TT> interface
and <TT>JList</TT> class, the <TT>TreeModel</TT> interface and
<TT>JTree</TT> class delegate selection management to a separate
selection model, the <TT>TreeSelectionModel</TT>. The <TT>TreeSelectionModel</TT>
is an interface that defines the selection model for a JFC tree.
Looking at the interface that is shown in Listing 11.5, you see
that it contains 27 method signatures, making it one of the biggest
interfaces in the JFC.
<P>
The <TT>TreeSelectionModel</TT> defines three selection modes
for a tree. The <TT>SINGLE_TREE_SELECTION</TT> mode allows only
one path to be selected at a given time. The <TT>CONTIGUOUS_TREE_SELECTION</TT>
mode allows multiple contiguous paths to be simultaneously selected.
The <TT>DISCONTIGUOUS_TREE_SELECTION</TT> mode allows any paths
to be simultaneously selected. The <TT>setSelectionMode</TT> and
<TT>getSelectionMode</TT> methods are used to alter and query
the selection mode property. The remainder of the methods contained
in the interface are used to alter the selected path set. The
semantics of each selection method are not defined for each selection
mode. For example, the <TT>setSelectionPaths</TT> method takes
an array of <TT>TreePath</TT> instances as its lone parameter.
If the selection mode is single selection and this array contains
more than one path, which path is selected is not defined in the
<TT>TreeSelectionModel</TT> interface. It is up to the class that
implements the interface to decide the behavior. The <TT>DefaultTreeSelectionModel</TT>
class that is provided in the JFC only selects the first path
in this case. However, an application should not assume this behavior
from other classes that implement the <TT>TreeSelectionModel</TT>
interface. For instance, another implementation can select the
last path in the array.<P>
<HR>
<P>
<B>Listing 11.5&nbsp;&nbsp;The </B><TT><B>TREESELECTIONMODEL</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TreeSelectionModel
{ 
    /** Selection can only contain one path at a time. */
    public static int               SINGLE_TREE_SELECTION = 1;

    /** Selection can only be contiguous. This will only be enforced if
     * a RowMapper instance is provided. */
    public static int               CONTIGUOUS_TREE_SELECTION = 2;

/** Selection can contain any number of items that are not 
     * necessarily contiguous. */
    public static int               DISCONTIGUOUS_TREE_SELECTION = 4;

    /**
* Sets the selection model, which must be one of 
     * SINGLE_TREE_SELECTION, CONTIGUOUS_TREE_SELECTION or 
     * DISCONTIGUOUS_TREE_SELECTION.
     */
    void setSelectionMode(int mode);

    /**
     * Returns the selection mode.
     */
    int getSelectionMode();

    /**
      * Sets the selection to path.  If this represents a change, then
      * the TreeSelectionListeners are notified.
      *
      * @param path new path to select
      */
    void setSelectionPath(TreePath path);

    /**
      * Sets the selection to the paths.  If this represents a
      * change the TreeSelectionListeners are notified.
      *
      * @param paths new selection.
      */
    void setSelectionPaths(TreePath[] paths);

    /**
      * Adds path to the current selection.  If path is not currently
      * in the selection the TreeSelectionListeners are notified.
      *
      * @param path the new path to add to the current selection.
      */
    void addSelectionPath(TreePath path);

    /**
      * Adds paths to the current selection.  If any of the paths in 
* paths are not currently in the selection the 
      * TreeSelectionListeners are notified.
      *
      * @param path the new path to add to the current selection.
      */
    void addSelectionPaths(TreePath[] paths);

    /**
      * Removes path from the selection.  If path is in the selection
      * The TreeSelectionListeners are notified.
      *
      * @param path the path to remove from the selection.
      */
    void removeSelectionPath(TreePath path);

    /**
      * Removes paths from the selection.  If any of the paths in paths
      * are in the selection the TreeSelectionListeners are notified.
      *
      * @param path the path to remove from the selection.
      */
    void removeSelectionPaths(TreePath[] paths);

    /**
      * Returns the first path in the selection.
      */
    TreePath getSelectionPath();

    /**
      * Returns the paths in the selection.
      */
    TreePath[] getSelectionPaths();

    /**
     * Returns the number of paths that are selected.
     */
    int getSelectionCount();

    /**
      * Returns true if the path, path, is in the current selection.
      */
    boolean isPathSelected(TreePath path);

    /**
      * Returns true if the selection is currently empty.
      */
    boolean isSelectionEmpty();

    /**
      * Empties the current selection.  If this represents a change in
      * the current selection, the selection listeners are notified.
      */
    void clearSelection();

    /**
     * Sets the RowMapper instance.  This instance is used to determine
     * what row corresponds to what path.
     */
    void setRowMapper(RowMapper newMapper);

    /**
     * Returns the RowMapper instance that is able to map a path to a
     * row.
     */
    RowMapper getRowMapper();

    /**
      * Returns all of the currently selected rows.
      */
    int[] getSelectionRows();

    /**
      * Gets the first selected row.
      */
    int getMinSelectionRow();

    /**
      * Gets the last selected row.
      */
    int getMaxSelectionRow();

    /**
      * Returns true if the row identified by row is selected.
      */
    boolean isRowSelected(int row);

    /**
     * Updates what rows are selected.  This can be externally called in
     * case the location of the paths change, but not the actual paths.
     * You do not normally need to call this.
     */
    void resetRowSelection();

    /**
     * Returns the lead selection index. That is the last index that was
     * added.
     */
    int getLeadSelectionRow();

    /**
     * Returns the last path that was added.
     */
    TreePath getLeadSelectionPath();

    /**
     * Add a PropertyChangeListener to the listener list.
     * The listener is registered for all properties.
     * &lt;p&gt;
     * A PropertyChangeEvent will get fired in response to an
     * explicit setFont, setBackground, or SetForeground on the
     * current component.  Note that if the current component is
     * inheriting its foreground, background, or font from its
     * container, then no event will be fired in response to a
     * change in the inherited property.
     *
     * @param listener  The PropertyChangeListener to be added
     */
    void addPropertyChangeListener(PropertyChangeListener listener);

    /**
     * Remove a PropertyChangeListener from the listener list.
     * This removes a PropertyChangeListener that was registered
     * for all properties.
     *
     * @param listener  The PropertyChangeListener to be removed
     */
    void removePropertyChangeListener(PropertyChangeListener listener);

    /**
      * Adds x to the list of listeners that are notified each time the
      * selection changes.
      *
      * @param x the new listener to be added.
      */
    void addTreeSelectionListener(TreeSelectionListener x);

    /**
      * Removes x from the list of listeners that are notified each time
      * the selection changes.
      *
      * @param x the listener to remove.
      */
    void removeTreeSelectionListener(TreeSelectionListener x);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DefaultTreeSelectionModel</TT> class in the <TT>swing.tree</TT>
package implements the <TT>TreeSelectionModel</TT> interface and
is used by instances of the <TT>JTree</TT> class for selection
management unless the selection model is explicitly set to a different
class. The class contains one bound property, the <TT>SELECTION_MODE_PROPERTY</TT>.
(The <TT>SELECTION_MODE_PROPERTY</TT> constant is defined in the
<TT>DefaultTreeSelectionModel</TT> class.) This property change
event is fired when the selection mode changes in the model.
<H3><A NAME="RenderingandEditing">
Rendering and Editing</A></H3>
<P>
You saw in <A HREF="..\ch10\ch10.htm" >Chapter 10</A>, &quot;<TT>JList</TT>, <TT>JComboBox</TT>,
and Bound Controls,&quot; how the <TT>JList</TT> class delegates
drawing of its elements to a rendering object. The <TT>JTree</TT>
class employs the same strategy. The <TT>TreeCellRenderer</TT>
interface defines the methods that must be implemented by a renderer
that can be used with a <TT>JTree</TT> instance. This interface
contains a single method, <TT>getTreeCellRendererComponent</TT>.
When called, the implementing class must return a <TT>Component</TT>
configured properly for rendering the value passed to the method.
Listing 11.6 shows the <TT>TreeCellRenderer</TT> interface.<P>
<HR>
<P>
<B>Listing 11.6&nbsp;&nbsp;The </B><TT><B>TREECELLRENDERER</B></TT><B>
Interface<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface TreeCellRenderer { 

    /**
     * Sets the value of the current tree cell to &lt;code&gt;value&lt;/code&gt;.
     * If &lt;code&gt;selected&lt;/code&gt; is true, the cell will be drawn as if
     * selected. If &lt;code&gt;expanded&lt;/code&gt; is true the node is currently
     * expanded and if &lt;code&gt;leaf&lt;/code&gt; is true the node represents a
     * leaf and if &lt;code&gt;hasFocus&lt;/code&gt; is true the node currently has
     * focus. &lt;code&gt;tree&lt;/code&gt; is the JTree the receiver is being
     * configured for.
     * Returns the Component that the renderer uses to draw the value.
     *
* @return	Component that the renderer uses to draw the value.
     */
    Component getTreeCellRendererComponent(JTree tree, Object value,
                        boolean selected, boolean expanded,
                        boolean leaf, int row, boolean hasFocus);

}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>JTree</TT> instance also allows editing in place. The
gesture that begins editing is look-and-feel specific, but a single
click will start editing for the standard look-and-feel implementations
contained in the JFC. The strategy for editing is analogous to
that used for rendering. One cell editor is used for the entire
tree. It is moved to the proper location and sized to the required
size when editing begins. The editor manages the editing process.
When the editing is complete, the data in the editor is copied
to the data model.
<P>
The <TT>TreeCellEditor</TT> interface defines a single method:
<TT>getTreeCellEditorComponent</TT>. However, the interface extends
the <TT>CellEditor</TT> interface. This interface is contained
in the <TT>java.awt.swing</TT> package. The <TT>CellEditor</TT>
interface defines the methods used to mediate the editing and
data transfer between the model and the editor. You will see this
interface again in the next <A HREF="..\ch12\ch12.htm" >Chapter 12</A>, &quot;Table Component.&quot;
The interface that defines the editor for the table component
also extends the <TT>CellEditor</TT> interface. Listing 11.7 shows
the <TT>CellEditor</TT> and <TT>TreeCellEditor</TT> interfaces.
<P>
<HR>
<P>
<B>Listing 11.7&nbsp;&nbsp;The </B><TT><B>CELLEDITOR</B></TT><B>
and </B><TT><B>TREECELLEDITOR</B></TT><B>
Interfaces<BR>
</B>
<BLOCKQUOTE>
<PRE>
public interface CellEditor { 

    /** Returns the value contained in the editor**/
    public Object getCellEditorValue();

    /**
     * Ask the editor if it can start editing using &lt;I&gt;anEvent&lt;/I&gt;.
     * &lt;I&gt;anEvent&lt;/I&gt; is in the invoking component coordinate system.
     * The editor cannot assume the Component returned by
     * getCellEditorComponent() is installed.  This method is intended
     * for the use of client to avoid the cost of setting up and 
     * installing the editor component if editing is not possible.
     * If editing can be started this method returns true.
     * 
* @param anEvent	the event the editor should use to consider
     *	               whether to begin editing or not.
     * @return true if editing can be started.
     * @see #shouldSelectCell()
     */
    public boolean isCellEditable(EventObject anEvent);

    /**
     * Tell the editor to start editing using &lt;I&gt;anEvent&lt;/I&gt;.  It is
     * up to the editor if it wants to start editing in different states
     * depending on the exact type of &lt;I&gt;anEvent&lt;/I&gt;.  For example, with
     * a text field editor, if the event is a mouse event the editor
     * might start editing with the cursor at the clicked point.  If
     * the event is a keyboard event, it might want to replace the value
     * of the text field with that first key, etc.  &lt;I&gt;anEvent&lt;/I&gt;
     * is in the invoking component's coordinate system.  A null value
     * is a valid parameter for &lt;I&gt;anEvent&lt;/I&gt;, and it is up to the 
     * editor to determine what is the default starting state.  For 
     * example, a text field editor might want to select all the text and
     * start editing if &lt;I&gt;anEvent&lt;/I&gt; is null.  The editor can assume
     * the Component returned by getCellEditorComponent() is properly
     * installed in the client's Component hierarchy before this method is
     * called. &lt;p&gt;
     *
     * The return value of shouldSelectCell() is a boolean indicating
     * whether the editing cell should be selected or not.  Typically, 
     * the return value is true, because is most cases the editing cell 
     * should be selected.  However, it is useful to return false to keep
     * the selection from changing for some types of edits.  eg. A table
     * that contains a column of check boxes, the user might want 
     * to change those check boxes without altering the selection.  
     * (See Netscape Communicator for just such an example.)  Of course, 
     * it is up to the client of the editor to use the return value, but
     * it doesn't need to if it doesn't want to.
     *
* @param anEvent the event the editor should use to start
     *                  editing.
     * @return true if the editor would like the editing cell to be 
     *              selected
     * @see #isCellEditable()
     */
    public boolean shouldSelectCell(EventObject anEvent);

    /**
     * Tell the editor to stop editing and accept any partially edited
     * value as the value of the editor.  The editor returns false if
     * editing was not stopped, useful for editors that validate and
     * cannot accept invalid entries.
     *
* @return	true if editing was stopped
     */
    public boolean stopCellEditing();

    /**
     * Tell the editor to cancel editing and not accept any partially
     * edited value.
     */
    public void cancelCellEditing();

    /**
     * Add a listener to the list that's notified when the editor starts,
     * stops, or cancels editing.
     *
* @param l the CellEditorListener
     */  
    public void addCellEditorListener(CellEditorListener l);

    /**
     * Remove a listener from the list that's notified
     *
     * @param	l		the CellEditorListener
     */  
    public void removeCellEditorListener(CellEditorListener l);
} 


public interface TreeCellEditor extends CellEditor
{
    /**
     * Sets an initial &lt;I&gt;value&lt;/I&gt; for the editor.  This will cause
* the editor to stop editing and lose any partially edited value
     * if the editor is editing when this method is called. &lt;p&gt;
     *
     * Returns the component that should be added to the client's
     * Component hierarchy.  Once installed in the client's hierarchy
     * this component will then be able to draw and receive user input.
     *
* @param table the JTree that is asking the editor to edit
     *                This parameter can be null.
     * @param value the value of the cell to be edited.
     * @param isSelected true is the cell to be rendered with
     *				selection highlighting
     * @param expanded true if the node is expanded
     * @param leaf true if the node is a leaf node
     * @param row the row index of the node being edited
     * @return the component for editing
     */
    Component getTreeCellEditorComponent(JTree tree, Object value,
                        boolean isSelected, booleanexpanded,
                       boolean leaf, int row);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="PullingItAllTogetherACompleteTTFONTSIZEJTreeFONTTTFONTSIZEExampleFONT">
Pulling It All Together: A Complete <TT>JTree</TT>
Example</A></H3>
<P>
The previous sections have presented the interfaces and classes
that are required to take full advantage of the <TT>JTree</TT>
class. This section will present an example that uses these classes
to create a complete tree example application.
<P>
The <TT>TreeTest</TT> application in Listing 11.8 creates a <TT>JTree</TT>
instance and displays it in an <TT>ApplicationFrame</TT>. The
resulting application is shown in Figure 11.5. The tree's data
model is created in the <TT>createTreeModel</TT> method. An instance
of the <TT>DefaultMutableTreeNode</TT> class is created for each
node in the tree. The user object for the node is passed to the
constructor. In this example, the user object is the <TT>String</TT>
that represents the name of the node. However, any <TT>Object</TT>
can be used as the user object. By default, the <TT>toString</TT>
method on the user object is called to query the <TT>String</TT>
that represents the node in the tree.
<P>
<A HREF="javascript:popUp('f11-5.gif')"><B>Figure 11.5 :</B> <I>The TreeTest application</I>.</A>
<P>
The structure of the tree is determined by calling the <TT>add</TT>
method on the parent node and passing the child node as the parameter
to this method. The child node must be an instance that implements
the <TT>MutableTreeNode</TT> interface. The <TT>add</TT> method
works similarly to the <TT>add</TT> methods you saw for menus
in <A HREF="..\ch09\ch09.htm" >Chapter 9</A> &quot;Menus and Toolbars.&quot; The new node is
placed as the last child of the parent node. When the parent is
expanded, the children are shown in the order they were added
to the node. The <TT>add</TT> method it is not defined in the
<TT>MutableTreeNode</TT> interface, but is part of the <TT>DefaultMutableTreeNode</TT>
class's public API. 
<P>
The placement of a node added to its parent can be specified if
added by using the <TT>insert</TT> method. This method requires
the index where the child is added into the parent node. The <TT>createTreeModel</TT>
method finishes by creating an instance of the <TT>DefaultTreeModel</TT>
class. The root node for the tree is passed to the constructor
to bind the model to the tree nodes.
<P>
The visual components are instantiated and arranged in the <TT>createTreePanel</TT>
method. A split pane is created for the center of the application.
The <TT>JSplitPane</TT> class is presented in <A HREF="..\ch16\ch16.htm" >Chapter 16</A>, &quot;Split
Pane.&quot; An instance of the <TT>JTree</TT> class is created
by using the model returned from the <TT>createTreeModel</TT>
method as its data model. This tree is added as the left component
in the split pane. A <TT>JTextArea</TT> is created and added to
the right region of the split pane. The selected nodes in the
tree will be displayed in this area. A panel with a <TT>BorderLayout</TT>
is created, and the split pane is added as the center region of
this panel. A panel containing buttons is placed in the south
region of this panel. One button expands the selected node in
the tree and all its children. The other button clears the text
in the <TT>JTextArea</TT> instance. Finally, a <TT>TreeSelectionListener</TT>
is added to the tree. This will enable the <TT>valueChanged</TT>
method to be called whenever the selection in the tree changes.
The panel containing the split pane and button panel is returned
from the <TT>createTreePanel</TT> method and set as the content
pane of the <TT>ApplicationFrame</TT> instance.<P>
<HR>
<P>
<B>Listing 11.8&nbsp;&nbsp;The </B><TT><B>TREETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.test;

import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.border.*;

import com.foley.utility.ApplicationFrame;


/**
 * An application that displays a JTree.
 *
 * @author Mike Foley
 **/
public class TreeTest 
    implements ActionListener, TreeSelectionListener { 

    /**
     * The tree used in the center of the display.
     **/
    JTree tree;    
    
    /**
     * The component where the selected path is displayed.
     **/
    JTextArea textArea;

    /**
     * The text contained in the JTextArea initially and after a clear.
     **/
    private static final String INITIAL_TEXT = &quot;Selected Path Events\ n&quot;;
    
    /**
     * Create the tree test component.
     * The display is a tree in the center of a BorderLayout.
     * The EAST region contains a JTextArea where selected
     * paths are displayed.
     * The bottom region contains buttons.
     * &lt;p&gt;
     * @return The component containing the tree.
     **/
    public JComponent createTreePanel() { 

        JSplitPane treePanel = new JSplitPane();

        tree = new JTree( createTreeModel() );
        tree.setEditable( true );
        tree.setCellEditor( new TreeLeafEditor( tree ) );
        tree.addTreeSelectionListener( this );
        tree.setBorder( BorderFactory.createLoweredBevelBorder() );

        treePanel.setLeftComponent( new JScrollPane( tree ) );

        JPanel buttonPanel = new JPanel();
        JButton expand = new JButton( &quot;Expand Selected&quot; );
        expand.addActionListener( this );
        JButton clear = new JButton( &quot;Clear Path Display&quot; );
        clear.addActionListener( new ActionListener() { 
            public void actionPerformed( ActionEvent event ) { 
                textArea.setText( INITIAL_TEXT );
            } 
        }  );
        buttonPanel.add( expand );
        buttonPanel.add( clear );

        textArea = new JTextArea( INITIAL_TEXT, 16, 50 );
        textArea.setBackground( expand.getBackground() );
        textArea.setBorder( null );
textArea.setBorder( BorderFactory.createEmptyBorder(4,4,4,4) );
        treePanel.setRightComponent( new JScrollPane( textArea ) );

        JPanel totalPanel = new JPanel();
        totalPanel.setLayout( new BorderLayout() );
        totalPanel.add( treePanel, BorderLayout.CENTER );
        totalPanel.add( buttonPanel, BorderLayout.SOUTH );
        totalPanel.setBorder( BorderFactory.createLoweredBevelBorder() );

        return( totalPanel );

    } 


    /**
     * Create the data model used in the tree contained
     * in the application.
     * &lt;p&gt;
     * @return The data model for the tree.
     **/
    protected TreeModel createTreeModel() { 
        DefaultMutableTreeNode root = 
                    new DefaultMutableTreeNode( &quot;Music Collection&quot; );
        
        DefaultMutableTreeNode albums = 
                    new DefaultMutableTreeNode( &quot;Albums&quot; );
        DefaultMutableTreeNode cds = new DefaultMutableTreeNode( &quot;CDs&quot; );
        DefaultMutableTreeNode tapes = 
                    new DefaultMutableTreeNode( &quot;Tapes&quot; );

        root.add( albums );
        root.add( cds );
        root.add( tapes );

        DefaultMutableTreeNode stonesAlbums = 
                new DefaultMutableTreeNode( &quot;Rolling Stones&quot; );
        albums.add( stonesAlbums );

        stonesAlbums.add( new DefaultMutableTreeNode( &quot;Hot Rocks&quot; ) );
        stonesAlbums.add( 
            new DefaultMutableTreeNode( &quot;Black and Blue&quot; ) );
        stonesAlbums.add( 
            new DefaultMutableTreeNode( &quot;Sticky Finger&quot; ) );
        
        DefaultMutableTreeNode c1 = 
              new DefaultMutableTreeNode( &quot;Classical&quot; );
        DefaultMutableTreeNode c2 = 
              new DefaultMutableTreeNode( &quot;Best Rock of the 60s&quot; );
        DefaultMutableTreeNode c3 = 
              new DefaultMutableTreeNode( &quot;70s Disco Favorites&quot; );
        DefaultMutableTreeNode c4 = 
               new DefaultMutableTreeNode( &quot;Broadway Hits&quot; );
        DefaultMutableTreeNode c5 = 
               new DefaultMutableTreeNode( &quot;Country's Best?&quot; );

        cds.add( c1 );
        cds.add( c2 );
        cds.add( c3 );
        cds.add( c4 );
        cds.add( c5 );
        
        DefaultMutableTreeNode s1 = 
          new DefaultMutableTreeNode( &quot;Rolling Stones&quot; );
        DefaultMutableTreeNode s2 = 
          new DefaultMutableTreeNode( &quot;Beatles&quot; );
        DefaultMutableTreeNode s3 = 
          new DefaultMutableTreeNode( &quot;The Who&quot; );
        
        c1.add( new DefaultMutableTreeNode( &quot;Beethoven's Fifth&quot; ) );

        c2.add( s1 );
        c2.add( s2 );
        c2.add( s3 );

        s1.add( new DefaultMutableTreeNode( &quot;Gimmie Shelter&quot; ) );
        s1.add( new DefaultMutableTreeNode( &quot;Some Girls&quot; ) );
        s1.add( new DefaultMutableTreeNode( &quot;Emotional Rescue&quot; ) );
s2.add( new DefaultMutableTreeNode( &quot;White Album&quot; ) );
        s2.add( new DefaultMutableTreeNode( &quot;Abby Road&quot; ) );
        s2.add( new DefaultMutableTreeNode( &quot;Let it be&quot; ) );

        s3.add( new DefaultMutableTreeNode( &quot;Tommy&quot; ) );
        s3.add( new DefaultMutableTreeNode( &quot;The Who&quot; ) );
        
        c3.add( new DefaultMutableTreeNode( &quot;Saturday Night Fever&quot; ) );
        c3.add( new DefaultMutableTreeNode( &quot;Earth Wind and Fire&quot; ) );
        
        c4.add( new DefaultMutableTreeNode( &quot;Cats Soundtrack&quot; ) );
        
        c5.add( new DefaultMutableTreeNode( &quot;Unknown&quot; ) );
        
        return( new DefaultTreeModel( root ) );
        
    }  // createTreeModel

    
    /**
     * actionEvent, from ActionListener.
     * &lt;p&gt;
     * The expand button was pressed. Expand the selected paths
     * in the tree.
     * &lt;p&gt;
     * @param event The actionEvent causing this method call.
     **/
    public void actionPerformed( ActionEvent event ) { 
        TreePath[] paths = tree.getSelectionPaths();
        if( paths != null ) { 
            for( int i = 0; i &lt; paths.length; i++ ) { 
                expandPath( paths[i] );
            } 
        } 
    } 
    
    
    /**
     * valueChanged, from TreeSelectionListener.
     * &lt;p&gt;
     * The selected state in the tree changed. Show the
     * selected path in the text area.
     * &lt;p&gt;
     * @param event The event causing this method to be called.
     **/
    public void valueChanged( TreeSelectionEvent event ) { 
        
        TreePath[] paths = event.getPaths();
        
        for( int i = 0; i &lt; paths.length; i++ ) { 
            //
            // Display the path and state.
            //
            Object[] path = paths[i].getPath();
            textArea.append( event.isAddedPath( paths[i] ) ?
                                &quot;ADDED: &quot; : &quot;REMOVED: &quot; );
            textArea.append( paths[i] + &quot;\ n&quot; );
            for( int j = 0; j &lt; path.length; j++ ) { 
                textArea.append( &quot;\ t&quot; + path[j] + &quot;\ n&quot; );
            }
            if( event.isAddedPath( paths[i] ) ) { 
                Object pathObject = paths[i].getLastPathComponent();
                
                //
                // This test is unfortunate. The MutableTreeNode
                // interface does not have a getUserObject method, so
                // we must test for a specific implementation.
                //
                if( pathObject instanceof DefaultMutableTreeNode ) { 
                    Object userObject = 
             ( ( DefaultMutableTreeNode )pathObject ).getUserObject();
                    textArea.append(&quot;User Object: &quot; + userObject + &quot;\ n&quot;);
                } 
            } 
        } 
        textArea.append( &quot;-------------------------------------\ n&quot; );
        
    } 


    /**
     * Expand the node at the end of the given path.
     * This requires expanding all children nodes of the
     * path recursively until the entire subtree has been
     * expanded.
     **/
    private void expandPath( TreePath path ) { 
        Object o = path.getLastPathComponent();
        if( o instanceof TreeNode ) { 
            for( Enumeration e = ( ( TreeNode )o ).children(); 
         e.hasMoreElements(); ) { 
                TreeNode node = ( TreeNode )e.nextElement();
                expandChildren( node );
            } 
        } 
    } 


    /**
     * Expand all the children of the given node.
     * &lt;p&gt;
     * @param expandNode The root of the subtree to expand.
     **/
    private void expandChildren( TreeNode expandNode ) { 

        if( expandNode.isLeaf() ) { 
            
            Stack nodes = new Stack();
        
            //
            // Push the parents of the current node
            // until the root of the tree is reached.
            //
            TreeNode node = expandNode;
            nodes.push( node );
            while( ( node = node.getParent() ) != null )
                nodes.push( node );
        
            //
            // Create a path to the node passed into this
            // method by popping each element from the stack.
            //
            TreeNode[] path = new TreeNode[ nodes.size() ];
            for( int i = 0; i &lt; path.length; i++ )
                path[i] = ( TreeNode )nodes.pop();            
            TreePath treePath = new TreePath( path );
        
            //
            // Expand the path.
            //
            tree.makeVisible( treePath );
        
        }  else { 
            
            //
            // Expand the children of the 
            // node passed to the method.
            //
            for( Enumeration e = expandNode.children(); 
         e.hasMoreElements(); ) { 
                expandChildren( 
        ( DefaultMutableTreeNode )e.nextElement() );
            } 
            
        }  // else
        
    }  // expandChildren

    
    /**
     * Application entry point.
     * Create the frame, and place a tree into it.
     *
     * @param args Command line parameter. Not used.
     **/
    public static void main( String args[] ) { 

        TreeTest treeTest = new TreeTest();
        JFrame frame = new ApplicationFrame( &quot;Tree Test&quot; );
        frame.getContentPane().add( treeTest.createTreePanel(), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );

    }  // main

}  // TreeTest
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>TreeTest</TT> class implements the <TT>TreeSelectionListener</TT>
interface and is added as a listener to the tree contained in
the center of the application. This enables the <TT>valueChanged</TT>
method to be called whenever the selection in the tree changes.
Unlike some of the other events in the JFC, the <TT>TreeSelectionEvent</TT>
instance delivered to this method contains the information about
the change in the selected path set for the tree. In this application,
the paths contained in the event are written to the <TT>JTextArea</TT>
instance in the right region of the display. The array of changed
<TT>TreePath</TT>s is queried from the event with the <TT>getPaths</TT>
method. For each path, the <TT>isAddedPath</TT> method can be
called to determine if the path was added or removed from the
tree's selection set. The method returns <TT>true</TT> for new
paths and <TT>false</TT> for paths that were selected but are
no longer selected. Each path is written to the text area. The
final piece of information obtained in the <TT>valueChanged</TT>
method is the user object for the node. This points to an unfortunate
flaw in the <TT>MutableTreeNode</TT> interface. It does not contain
a <TT>getUserObject</TT> method. This forces the <TT>valueChanged</TT>
method to test for the <TT>DefaultMutableTreeNode</TT> class,
making this code unusable for other classes that implement the
<TT>MutableTreeNode</TT> interface. This is a serious flaw in
the JFC tree and greatly reduces the ability to write reusable
code.
<P>
A <TT>setEditable</TT> method is passed a parameter of <TT>true</TT>
to allow the tree to be edited in place. When a tree is made editable,
any node in the tree can be edited. The gesture that starts the
edit is look-and-feel specific. However, the single-click gesture
is used in the current JFC look-and-feel implementations. For
the <TT>TestTree</TT>, it is desirable to allow only leaf nodes
to be editable. A custom cell editor provides this functionality
for the tree. The <TT>setCellEditor</TT> method specifies an instance
of the <TT>TreeLeafEditor</TT> class shown in Listing 11.9. This
will be used as the editor for the tree. This class is an extension
of the <TT>DefaultCellEditor</TT> class. It overrides the <TT>isCellEditable</TT>
method. This method demonstrates how a <TT>TreePath</TT> to a
node can be queried from a tree for given x and y coordinates.
By using the <TT>isLeaf</TT> method, the cell editor then checks
if the hit node is a leaf node and only returns <TT>true</TT>
if it is. The tree with the <TT>TreeLeafEditor</TT> activated
is shown in Figure 11.6.
<P>
<A HREF="javascript:popUp('f11-6.gif')"><B>Figure 11.6 :</B> <I>Node being edited in the TreeTest application</I>.</A>
<P>
<HR>
<P>
<B>Listing 11.9&nbsp;&nbsp;The </B><TT><B>TREELEAFEDITOR</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.event.*;
import java.util.*;

import javax.swing.*;
import javax.swing.tree.*;
    

/**
 * A tree editor that only allows editing of leaf nodes.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class TreeLeafEditor extends DefaultCellEditor { 
    
    /**
     * The tree we are editing.
     **/
    JTree tree;
    
    public TreeLeafEditor( JTree tree ) { 
        super( new JTextField() );
        this.tree = tree;
    } 
    

    /**
     * The cell is only editable if it is a leaf node and
     * the number of mouse clicks is equal to the value
     * returned from the getClickCountToStart method.
     * &lt;p&gt;
     * @param event The event to test for cell editablity.
     * @return True if the cell is editable given the current event.
     * @see getClickCountToStart
     **/
    public boolean isCellEditable( EventObject event ) { 

        if( event instanceof MouseEvent ) { 
            MouseEvent mouseEvent = ( MouseEvent )event;
            if( mouseEvent.getClickCount() == getClickCountToStart() ) { 
TreePath hitPath = tree.getPathForLocation( 
                                                    mouseEvent.getX(), 
                                                    mouseEvent.getY() );
                Object hitObject = hitPath.getLastPathComponent();
                if( hitObject instanceof TreeNode )
                    return( ( ( TreeNode )hitObject ).isLeaf() );
            } 
        } 
        return( false );
    } 
    
}  // TreeLeafEditor
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The application creates a button that causes a selected node in
the tree to totally expand the sub-tree for which it serves as
the root. Thus, if this button is hit when the root of the tree
is selected, the entire tree is expanded displaying all the leaf
nodes contained in the tree. The expansion is performed in the
<TT>expandChildren</TT> method that requires a <TT>TreeNode</TT>
parameter. The <TT>TreeNode</TT> passed to the method serves as
the root node of the sub-tree that is expanded. The method works
by checking to see if the node passed to it is a leaf. If so,
a path to the node is created and expanded in the tree. If the
node is not a leaf, the <TT>makeVisible</TT> method found in the
<TT>JTree</TT> class is called for each child of the node. This
logic is repeated for each child of the original node, and its
children, and so on, until the entire sub-tree data structure
has been traversed. It is important to understand that only the
leaf nodes need to be expanded. This is because the path to the
leaf contains its parent. Thus, if all leaves are expanded, the
entire sub-tree has been expanded. You will find yourself writing
many recursive methods, such as the <TT>expandChild</TT> method,
when traversing the nodes in a tree.
<H4>Setting Global Icons</H4>
<P>
The <TT>TreeTest</TT> application presented in the previous section
displayed a tree containing information about a music library.
The tree structure presented the data in a nicely structured visual.
However, the file system icons used in the tree make the component
somewhat less than ideal. Fortunately, the JFC provides a couple
of techniques that can be used to specify the icons that are used
in the tree. If the icons are to be changed for each tree that
is going to be used in the application, changing the user interface
properties for the tree icons is most appropriate. If you need
each tree in your application to have custom icons, or the icon
is based on the node's contents rather than its position in the
tree, a custom <TT>TreeCellRenderer</TT> is appropriate. This
section demonstrates the former technique. A custom cell renderer
will be shown in the next section.
<P>
The current look-and-feel determines the default icons used in
the tree. However, the application can override the default values
by changing properties in the <TT>UIManager</TT>. A complete description
of the <TT>UIManager</TT> is presented in <A HREF="..\ch30\ch30.htm" >Chapter 30</A>, &quot;Pluggable
Look-and-Feel.&quot; For this discussion, it is sufficient to
understand that the <TT>UIManager</TT> contains a <TT>Dictionary</TT>
that maps user interface properties to their value. These values
are queried by the component and used in its display. For the
<TT>JTree</TT> component, there are properties for the various
icons displayed in the tree. The list of properties is presented
in Table 11.2.<BR>
<P>
<CENTER><B>Table 11.2&nbsp;&nbsp;Icon Properties for the </B><TT><B>JTREE</B></TT><B>
Class</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1>
<TR VALIGN=TOP><TD WIDTH=295><CENTER><B>Property Name</B></CENTER></TD><TD WIDTH=295><CENTER><B>Usage</B></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>Tree.openIcon</TT></TD><TD WIDTH=295>When a non-leaf node is expanded
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>Tree.closedIcon</TT></TD><TD WIDTH=295>When a non-leaf node is collapsed
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>Tree.leafIcon</TT></TD><TD WIDTH=295>For a leaf node
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>Tree.expandedIcon</TT></TD><TD WIDTH=295>Icon for the expanded control
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>Tree.collapsedIcon</TT></TD><TD WIDTH=295>Icon for the collapsed control
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The main method for the <TT>TreeTest</TT> application can be modified,
as shown in Listing 11.10, to register the icons desired for your
application with the <TT>UIManager</TT>. Then any <TT>JTree</TT>
instance created in the application will use the new icons. The
modified tree containing the custom images is shown in Figure
11.7.
<P>
<A HREF="javascript:popUp('f11-7.gif')"><B>Figure 11.7 :</B> <I>Custom icons in the TreeTest application</I>.</A>
<P>
<HR>
<P>
<B>Listing 11.10&nbsp;&nbsp;Registering Custom Images in the </B><TT><B>TREETEST</B></TT><B>
Application<BR>
</B>
<BLOCKQUOTE>
<PRE>
public static void main( String args[] ) { 

        Icon albumIcon = new ImageIcon( &quot;album.gif&quot; );
        Icon albumsIcon = new ImageIcon( &quot;albums.gif&quot; );
        Icon expandedIcon = new ImageIcon( &quot;TreeExpanded.gif&quot; );
        Icon collapsedIcon = new ImageIcon( &quot;TreeCollapsed.gif&quot; );
        UIDefaults defaults = UIManager.getDefaults();
        defaults.put( &quot;Tree.openIcon&quot;, openIcon );
        defaults.put( &quot;Tree.closedIcon&quot;, closedIcon );
        defaults.put( &quot;Tree.leafIcon&quot;, leafIcon );
        defaults.put( &quot;Tree.expandedIcon&quot;, expandedIcon );
        defaults.put( &quot;Tree.collapsedIcon&quot;, collapsedIcon );
        
        TreeTest treeTest = new TreeTest();
        JFrame frame = new ApplicationFrame( &quot;Tree Test&quot; );
        frame.getContentPane().add( treeTest.createTreePanel(), 
                                    BorderLayout.CENTER );
        frame.pack();
        frame.setVisible( true );

    }  // main
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Using a Custom Tree Renderer</H4>
<P>
The example in the previous section showed how to globally replace
a tree's icon in an application. This technique will suffice for
many applications; but when complete control over a tree's icons
is required, a custom renderer for the tree must be provided.
If the granularity for specifying icons in a tree described in
the previous section suffices, a <TT>DefaultTreeCellRenderer</TT>
instance can be customized and set for the tree. The <TT>DefaultTreeCellRenderer</TT>
class contains methods for setting the opened, closed, and leaf
icons, as well as methods for setting the text color and font.
If this level of customization meets your requirements, there
is no need to create your own renderer class.
<P>
When you need different icons for nodes that are at the same level
in the hierarchy, a custom renderer class will have to be written.
You saw earlier in this chapter that a renderer for a <TT>JTree</TT>
instance must implement the <TT>TreeCellRenderer</TT> interface.
The <TT>AlbumTreeRenderer</TT> class, shown in Listing 11.11,
extends the <TT>JLabel</TT> class and implements the <TT>TreeCellRenderer</TT>
interface. In the class's constructor, it sets its <TT>opaque</TT>
property to <TT>true</TT>. This is required in renderers that
paint the background color of the cell. The <TT>AlbumTreeRenderer</TT>
needs to paint the background color to show selected items in
the tree. The renderer is bound to the tree by adding the following
line of code in the <TT>createTreePanel</TT> method of the <TT>TreeTest</TT>
application after the tree has been created:
<P>
<TT>tree.setCellRenderer( new AlbumTreeRenderer()
);</TT>
<P>
For a renderer to display different icons for different nodes,
it requires information about the nodes. This can be achieved
by using many techniques. The method presented here is if the
user object in a node is an instance of the <TT>AlbumCollectionItem</TT>
class, its <TT>getIcon</TT> method is called to obtain the icon
for the node. To make the renderer a bit more generic, an interface
can define the <TT>getIcon</TT> method, and this would be checked
for instead of the <TT>AlbumCollectionItem</TT> class in the renderer.
<P>
<HR>
<P>
<B>Listing 11.11&nbsp;&nbsp;The </B><TT><B>ALBUMTREERENDERER</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import java.awt.Component;

import javax.swing.*;
import javax.swing.tree.*;
    

/**
 * A tree renderer that knows about the record
 * collection tree.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class AlbumTreeRenderer extends JLabel
    implements TreeCellRenderer, AlbumTypes { 

    /**
     * AlbumTreeRenderer, Constructor.
     * &lt;p&gt;
     * The renderer must be opaque so the background
     * color is painted.
     **/
    public AlbumTreeRenderer() { 
        setFont( UIManager.getFont( &quot;Tree.font&quot; ) ) ;
        setOpaque( true );
    } 
    
    
    /**
     * Configures the renderer based on the passed in components.
     * Text for the cell is obtained from the toString() method of 
     * the value parameter.
     * &lt;p&gt;
     * Foreground and background colors are obtained from the
     * UIManager.
     * &lt;p&gt;
     * If the value is a DefaultMutableTreeNode, and its user object
     * is an AlbumCollectionItem, the icon is obtained from the item
     * and set for the cell.
     **/
    public Component getTreeCellRendererComponent( JTree tree,
                            Object value,
                            boolean selected,
                            boolean expanded,
                            boolean leaf, 
                            int row,
                            boolean hasFocus ) { 

            //
            // Set the text for the cell.
            //
        if( value != null )	    	
            setText( value.toString() );
        else
            setText( &quot;&quot; );

        //
        // Set the colors for the cell.
        //
        if( selected ) { 
setBackground( UIManager.getColor( 
                   &quot;Tree.selectionBackground&quot; ) );
            setForeground( UIManager.getColor( 
                   &quot;Tree.selectionForeground&quot; ) );
        }  else { 
            setBackground( UIManager.getColor( &quot;Tree.textBackground&quot; ) );
            setForeground( UIManager.getColor( &quot;Tree.textForeground&quot; ) );
        }  // else

        //
        // The type of the node is stored in the user object
        // in the mutable tree node.
        //
        setIcon( null );
        if( value instanceof DefaultMutableTreeNode ) { 
DefaultMutableTreeNode node = ( DefaultMutableTreeNode )value;
            Object o = node.getUserObject();
            if( o instanceof AlbumCollectionItem ) { 
                AlbumCollectionItem albumItem = ( AlbumCollectionItem )o;
                setIcon( albumItem.getIcon() );
            } 
        } 
        
    	return( this );
    } 
        
}  // AlbumTreeRenderer
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>createTreeModel</TT> method in the <TT>TreeTest</TT> application
must be updated to specify <TT>AlbumCollectionItem</TT> instances
as the user object for each node in the tree where an icon is
desired. In the original tree model, the user object for each
node was a <TT>String</TT> containing the name of the node. This
is changed to an <TT>AlbumCollectionItem</TT> instance with the
same name and an appropriate icon. Examples of this change for
the top of the tree are shown in the following code fragment:
<BLOCKQUOTE>
<PRE>
DefaultMutableTreeNode albums = new DefaultMutableTreeNode( 
                       new AlbumCollectionItem( &quot;Albums&quot;, albumsIcon ) );
DefaultMutableTreeNode cds = new DefaultMutableTreeNode( 
                       new AlbumCollectionItem( &quot;CDs&quot;, cdsIcon ) );
DefaultMutableTreeNode tapes = new DefaultMutableTreeNode( 
                       new AlbumCollectionItem( &quot;Tapes&quot;, tapesIcon ) );
</PRE>
</BLOCKQUOTE>
<P>
The <TT>AlbumCollectionItem</TT> class is very simple. It binds
the <TT>String</TT> name and icon together. Since the <TT>DefaultMutableTreeNode</TT>
class calls the <TT>toString</TT> method of its user object when
its <TT>toString</TT> method is called, the <TT>AlbumCollectionItem</TT>
class returns its name in its <TT>toString</TT> method. This will
ensure that the name is displayed properly in the tree. The icon
specified in the constructor is returned from the <TT>getIcon</TT>
method. The complete class is shown in Listing 11.12.<P>
<HR>
<P>
<B>Listing 11.12&nbsp;&nbsp;The </B><TT><B>ALBUMCOLLECTIONITEM</B></TT><B>
Class<BR>
</B>
<BLOCKQUOTE>
<PRE>
package com.foley.utility;

import javax.swing.*;


/**
 * The AlbumCollectionItem class binds a name
 * and icon together.
 * &lt;p&gt;
 * @author Mike Foley
 **/
public class AlbumCollectionItem { 
    String name;
    Icon icon;
    
    /**
     * AlbumCollectionItem, Constructor
     * &lt;p&gt;
     * @param name The name of this item.
     * @param icon The icon for this item.
     **/
    public AlbumCollectionItem( String name, Icon icon ) { 
        this.name = name;
        this.icon = icon;
    } 
    
    /**
     * @return The name of this item.
     **/
    public String getName() { 
        return( name );
    } 
    
    /**
     * @return The icon associated with this item.
     **/
    public Icon getIcon() { 
        return( icon );
    } 
    
    /**
     * @return The String representation of this item.
     **/
    public String toString() { 
        return( name );
    } 
    
}  // AlbumCollectionItem
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The new tree created with the custom renderer is shown in Figure
11.8. Notice how different icons are used for siblings in the
tree. To achieve this effect, a custom renderer is required. The
renderer could further customize the tree by changing fonts and
colors for each node.
<P>
<A HREF="javascript:popUp('f11-8.gif')"><B>Figure 11.8 :</B> <I>A custom cell renderer in the TreeTest
application</I>.</A>
<H2><A NAME="Summary">
Summary</A></H2>
<P>
The <TT>JTree</TT> component is a complex control that provides
tremendous capabilities. To take full advantage of these capabilities,
a substantial number of classes and interfaces must be understood.
This chapter presented the convenience methods in the <TT>JTree</TT>
class that allow a tree to be constructed by using standard JDK
collection classes such as <TT>Vectors</TT> and <TT>Hashtables</TT>.
You saw that using these data structures does not take full advantage
of the <TT>JTree</TT> class. To fully utilize the power of the
<TT>JTree</TT> class, the <TT>TreeModel</TT> and <TT>TreeNode</TT>
interfaces must be understood and incorporated into the tree's
design. The JFC contains implementations of these interfaces,
as well as the <TT>MutableTreeNode</TT> interface, that allow
building of a complex tree data structure and displaying it with
relative ease.
<P>
An example application containing a tree component was presented.
The icons used in the tree were customized to icons supplied by
the application. You also saw how the <TT>JTree</TT> class allows
for customization of renderers and editors. The renderer can be
used to customize the display of a node for the tree.
<P>
<CENTER>
<HR SIZE=4>

<A HREF="..\ch10\ch10.htm"><IMG SRC="..\button\previous.gif" BORDER="0"></A>
<A HREF="..\index.htm"><IMG SRC="..\button\contents.gif" BORDER="0"></A> 
<A HREF="..\ch12\ch12.htm"><IMG SRC="..\button\next.gif" BORDER="0"></A> 
</p>

<p>&#169; <A HREF="..\copy.htm">Copyright</A>, Macmillan Computer Publishing. All rights reserved.
</CENTER>
</BODY>
</HTML>
