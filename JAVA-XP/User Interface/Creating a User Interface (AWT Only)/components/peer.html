










<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Details of the Component Architecture</title>
</head>
<body BGCOLOR="#ffffff">








<table width="100%">
<tr>
<td align=left>
<a href="windowlistener.html"><img src="http://docs.rinet.ru/OLDui/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="problems.html"><img src="http://docs.rinet.ru/OLDui/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="http://docs.rinet.ru:8080/OLDui/trailmap.html"><img src="http://docs.rinet.ru/OLDui/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/OLDui/images/uiHeader.gif" width=26 height=26 align=bottom border=0 alt="Creating a User Interface (AWT Only) | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Components, the GUI Building Blocks</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/OLDui/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/OLDui/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Details of the Component Architecture
</h2>
<p>
<blockquote>

The AWT was designed from the start
to have a platform-independent API
and yet to preserve each platform's look and feel.
For example, the AWT has just one API for buttons 
(provided by the Button class),
but a button looks different on a Macintosh
than on a PC running Windows 95.

<p>

The AWT achieves its seemingly contradictory goals 
by providing classes (<em>components</em>) 
that provide a platform-independent API
but that make use of platform-specific implementations (<em>peers</em>).
To be specific,
every AWT component class 
(Component, MenuComponent, and their subclasses)
has an equivalent peer class,
and every component object has a peer object
that controls the object's look and feel.

<p>

Below is a figure that illustrates how a typical AWT component (a Button)
is mapped to a peer.
Button peers are implemented in
platform-specific classes
that implement the java.awt.peer ButtonPeer interface.
The java.awt Toolkit class 
defines methods that choose exactly which class
to use for the peer implementation.

<blockquote><IMG SRC="http://docs.rinet.ru/OLDui/figures/ui/13ui22a.gif" WIDTH="411" HEIGHT="177" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote><p>


<h4>How Peers Are Created</h4>
<blockquote>

Peers are created lazily,
just before their corresponding component object is drawn for the first time.
You might have noticed one side effect of this:
the size of a component isn't valid
until after the component has been shown for the first time.

<p>

When you add a component to a non-visible container
(a container with no peer),
then just before the container is shown for the first time,
its peer -- and the peers of all components it contains --
is created.

<p>

However, if you add a component to a <em>visible</em> container,
you need to explicitly tell the AWT to create a peer for the component.
You do this by calling the <code>validate()</code> method.
Although you can invoke <code>validate()</code> 
directly on the component you're adding,
it's usually invoked on the container, instead.
The reason is that invoking <code>validate()</code>
on a container causes a chain reaction --
every component under the container gets validated, as well.
For example, after you add components to an Applet object,
you call <code>validate()</code> on the Applet,
which creates peers for all the components in the Applet.


</blockquote>
<h4>How Peers Handle Events</h4>
<blockquote>

Peers implement the feel (and, indirectly, the look) of UI components 
by reacting to user input events.
For example, when the user clicks a button,
the peer reacts to the mouse down and mouse up events 
by causing the button's appearance to change 
and by forwarding an action event to the appropriate Button object.

<p>

In theory, peers are at the end of the event chain.
When a raw event (such as a key press) occurs,
the Component for which the event is intended 
gets to handle the event first,
and then (if the Component's event handler returns false)
the Component's Container sees the event, and so on.
After all the Components in the hierarchy
have had an opportunity to handle the event
(and all their event handling methods have returned false),
the peer gets to see and react to the event.

<p>

In the current implementation,
the above scenario is true for key presses
but not for mouse events.
For mouse events, 
the peer is the first to see the event,
and it doesn't necessarily pass all events on to the Component.
We plan to make mouse events work like keyboard events in a future release.

<p>

From raw events such as key presses and mouse clicks,
peers sometimes generate higher level events --
actions, focus changes, window iconifications, and so on.
These higher level events are passed on
to the relevant Component for handling.

</blockquote>
</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="windowlistener.html"><img src="http://docs.rinet.ru/OLDui/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="problems.html"><img src="http://docs.rinet.ru/OLDui/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="http://docs.rinet.ru:8080/OLDui/trailmap.html"><img src="http://docs.rinet.ru/OLDui/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/OLDui/images/uiHeader.gif" width=26 height=26 align=top border=0 alt="Creating a User Interface (AWT Only) | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Components, the GUI Building Blocks</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
