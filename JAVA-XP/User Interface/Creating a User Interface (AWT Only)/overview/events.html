










<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Event Handling</title>
</head>
<body BGCOLOR="#ffffff">








<table width="100%">
<tr>
<td align=left>
<a href="drawing.html"><img src="http://docs.rinet.ru/OLDui/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="..\components\index.html"><img src="http://docs.rinet.ru/OLDui/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="http://docs.rinet.ru:8080/OLDui/trailmap.html"><img src="http://docs.rinet.ru/OLDui/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/OLDui/images/uiHeader.gif" width=26 height=26 align=bottom border=0 alt="Creating a User Interface (AWT Only) | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Overview of the Java UI</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/OLDui/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/OLDui/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Event Handling
</h2>
<p>
<blockquote>

This section describes the 1.0 event scheme.
See 
<a target="_top" href="..\components\eventintro.html">Introduction to the 1.1 AWT Event Model</a><a target="_top" href="..\components\eventintro.html"><img src="http://docs.rinet.ru/OLDui/images/uiIcon.gif" width=20 height=20 border=0 alt="(in the Creating a User Interface trail)"></a> for a description of the 1.1 model.

<blockquote>
<hr>
<strong>Note:</strong>
You should use the 
<a href="..\components\eventintro.html">1.1 event model</a>
whenever possible.
It is intended to replace
the event model described on this page.
<hr>
</blockquote>

<p>

In 1.0, when the user acts on a Component -- 
clicking it or pressing the Return key, for example --
an Event object is created.
The AWT event-handling system
passes the Event up the Component hierarchy,
giving each Component a chance to react to the event
before the platform-dependent code 
that implements the Component fully processes it.

<p>

Each Component's event handler can react to an event
in any of the following ways:
<ul>
<li> By ignoring the event
     and allowing it to be passed up the Component hierarchy.
     This is what the default Component implementation does.
     For example, since the TextField class and its TextComponent superclass
     implement no event handlers,
     TextFields get the default Component implementation.
     So when a TextField receives an Event, 
     it ignores it and allows its container to handle it.
<li> By modifying the Event instance before it goes further up the hierarchy.
     For example, a TextField subclass that displays all letters in uppercase
     might react to the keypress of a lowercase letter 
     by changing the Event to contain the uppercase version of the letter.
<li> By reacting in some other way to the event.
     For example, a TextField subclass (or a TextField's container)
     could react to a Return keypress
     by calling a method that processes the text field's contents.
<li> By intercepting the event,
     stopping it from being processed further.
     For example, if an invalid character is entered in a text field,
     an event handler could simply stop the resulting Event 
     from propagating upward.
     As a result, the platform-dependent implementation of the text field
     would never see the event.
</ul>
<p>

From a Component's view, the AWT event-handling system is 
more like an event-<em>filtering</em> system.
Platform-dependent code generates an event,
but Components get a chance
to modify, react to, or intercept the event
before the platform-dependent code fully processes the event.
The following figure shows the chain of event handling
for a TextField event in the 
<a href=http://docs.rinet.ru/OLDui/OLDui/overview/example/Converter.java>example program</a>.

<blockquote><IMG SRC="http://docs.rinet.ru/OLDui/figures/ui/eventflow.gif" WIDTH="320" HEIGHT="337" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
<strong>Note:</strong>
In 1.0, 
mouse events are forwarded to Components
<em>after</em> the platform-dependent code has fully processed the event.
So although Components can intercept all <em>keyboard</em> events,
they can't currently intercept <em>mouse</em> events.

<p>

Although the AWT defines a wide variety of Event types,
the AWT doesn't see every event that occurs.
Thus, not every user action becomes an Event.
The AWT can see only those events that the
platform-dependent code lets it see.
For example, Motif text fields don't forward mouse move events
to the AWT.
For this reason, 
TextField subclasses or containers can't rely on getting mouse move events --
on Solaris, at least, 
they simply have no way of knowing that the event has occurred,
since they don't receive an Event when the mouse moves.
If you want access to
a wide range of event types,
you might need to implement a Canvas subclass,
since the platform-dependent implementation of Canvas
forwards all events.


<h4>The Event Object</h4>
<blockquote>

Each event results in the creation of an 
<a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.awt.Event.html">Event</a><a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.awt.Event.html"><img src="http://docs.rinet.ru/OLDui/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> object.
An Event object includes the following information:
<ul>
<li> The type of the event -- for example,
     a key press or mouse click, 
     or a more abstract event such as an "action" or window iconification.
     
<li> The object that was the "target" of the event -- for example,
     the Button corresponding to the onscreen button the user clicked,
     or the TextField corresponding to the field that user just typed in.

<li> A timestamp indicating when the event occurred.

<li> The (x,y) location where the event occurred.
     This location is relative to the origin 
     of the Component whose event handler
     this Event is passed into.

<li> The key that was pressed (for keyboard events).

<li> An arbitrary argument (such as the string displayed on the Component)
     associated with the Event.

<li> The state of modifier keys,
     such as Shift and Control,
     when the event occurred.
</ul>

</blockquote>
<h4>How to Implement an Event Handler</h4>
<blockquote>

The Component class defines many event-handling methods,
and you can override any of them.
Except for one all-purpose method (<code>handleEvent()</code>),
each event-handling method can be used
for only one particular type of event.
We recommend that you avoid the all-purpose method, if possible,
and instead override the event-handling method
that's specific to the type of event you need to handle.
This approach tends to have fewer unintended side effects.

<p>

The Component class defines the following methods
for responding to events
(the event type each handles is listed after the method name):
<ul>
<li> <code>action()</code> (Event.ACTION_EVENT)
<li> <code>mouseEnter()</code> (Event.MOUSE_ENTER)
<li> <code>mouseExit()</code> (Event.MOUSE_EXIT)
<li> <code>mouseMove()</code> (Event.MOUSE_MOVE)
<li> <code>mouseDown()</code> (Event.MOUSE_DOWN)
<li> <code>mouseDrag()</code> (Event.MOUSE_DRAG)
<li> <code>mouseUp()</code> (Event.MOUSE_UP)
<li> <code>keyDown()</code> (Event.KEY_PRESS or Event.KEY_ACTION)
<li> <code>keyUp()</code> (Event.KEY_RELEASE or Event.KEY_ACTION_RELEASE)
<li> <code>gotFocus()</code> (Event.GOT_FOCUS)
<li> <code>lostFocus()</code> (Event.LOST_FOCUS)
<li> <code>handleEvent()</code> (all event types)
</ul>
<p>

When an event occurs,
the event-handling method that matches the event type is called.
Specifically, the Event is first passed
to the <code>handleEvent()</code> method,
which (in the default implementation of <code>handleEvent()</code>)
calls the appropriate method for the event type.

<p>

The <code>action()</code> method 
is an especially important event-handling method.
Only basic control components --
Button, Checkbox, Choice, List, MenuItem, and TextField objects --
produce action events.
They do so when the user indicates somehow
that the control should perform an action.
For example, when the user clicks a button,
an action event is generated.
By implementing the <code>action()</code> method,
you can react to user actions on controls
without worrying about the low-level events,
such as key presses and mouse clicks,
that caused the action.

<p>

All the event-handling methods
have at least one argument (the Event)
and return a boolean value.
The return value indicates
whether the method completely handled the event.
By returning <code>false</code>,
the event handler indicates
that the event should continue
to be passed up the component hierarchy.
By returning <code>true</code>,
the event handler indicates
that the event should not be forwarded any further.
The <code>handleEvent()</code> method
should almost always return <code>super.handleEvent()</code>,
to ensure that all events are forwarded to the appropriate
event-handling method.

<p>

<strong>Important:</strong>
Like drawing methods, 
all event handler methods must execute quickly!
Otherwise, they'll destroy the perceived performance of your program.
If you need to perform some lengthy operation as the result of
an event,
do it by starting up another thread 
(or sending a request to another thread)
to perform the operation.
For help on using threads,
see
<a target="_top" href="http://docs.rinet.ru:8080/OLDui/essential/threads/index.html">Threads of Control</a><a href="http://docs.rinet.ru:8080/OLDui/essential/threads/index.html"><img src="http://docs.rinet.ru/OLDui/images/javaIcon.gif" width=20 height=20 border=0 alt="(in the Learning the Java Language trail)"></a>.

<p>

In the example program,
all the event handling is performed by ConversionPanels.
They use the <code>action()</code> method
to catch events resulting from user actions
on the text field (TextField),
and pop-up list (Choice).
To catch events resulting from user actions
on the slider (Scrollbar),
they must use the
<code>handleEvent()</code> method,
since Scrollbars don't produce action events 
and Component doesn't define any methods specific to Scrollbar events.

<p>

Here is the ConversionPanel implementation of the 
<code>action()</code> and
<code>handleEvent()</code> methods:

<blockquote>
<pre>
/** Respond to user actions on controls. */
public boolean action(Event e, Object arg) {
    if (e.target instanceof TextField) {
        setSliderValue(getValue());
        controller.convert(this);
        return true;
    }
    if (e.target instanceof Choice) {
        controller.convert(this);
        return true;
    } 
    return false;
}

/** Respond to the slider. */
public boolean handleEvent(Event e) {
    if (e.target instanceof Scrollbar) {
        textField.setText(String.valueOf(slider.getValue()));
        controller.convert(this);
    } 
    return super.handleEvent(e);
}
</pre>
</blockquote>
<p>

The methods simply make sure
that the ConversionPanel's slider and text field both show the same value,
and then ask the Converter object to update the other ConversionPanel.
The <code>action()</code> method returns <code>true</code>
if it handled the event.
This stops the event from unnecessarily traveling
further up the component hierarchy.
If the <code>action()</code> method can't handle the event,
it returns false,
so its higher ups in the component hierarchy 
can have a look at the event.
The <code>handleEvent()</code> method always returns
<code>super.handleEvent()</code>
so that every event will be fully processed.

<p>

<strong>A Note about the <code>action()</code> Method:</strong>
Action events are high-level events.
They're caused by one or more low-level events such as key and mouse presses.
For this reason,
it's OK to return <code>true</code>
to stop action events from travelling up the component hierarchy
after you've handled them --
the platform-specific code has already
handled the key or mouse events that triggered the action,
so it doesn't need to see the action event.

<p>

<strong>Note:</strong>
If <code>handleEvent()</code> returned
<code>true</code> or
<code>false</code>
(instead of calling its superclass's implementation),
the <code>action()</code> method would <em>never</em> be called.
Risks like this are part of the reason
why we advise you to avoid implementing <code>handleEvent()</code>
unless it's absolutely necessary.

</blockquote>
<h4>The Keyboard Focus</h4>
<blockquote>

Many components --
even those primarily operated with the mouse, such as buttons --
can be operated by the keyboard.
For a key press to affect a component,
the component must have the <em>keyboard focus</em>.

<p>

At any given time, at most one window
and one component in that window
can have the keyboard focus.
How windows get the keyboard focus is system dependent.
But once a window has the focus,
you can use the Component <code>requestFocus()</code> method
to request that a component get the focus.

<p>

When a component gets the focus,
its <code>gotFocus()</code> method is called.
When a component loses the focus,
its <code>lostFocus()</code> method is called.

</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="drawing.html"><img src="http://docs.rinet.ru/OLDui/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="..\components\index.html"><img src="http://docs.rinet.ru/OLDui/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="http://docs.rinet.ru:8080/OLDui/trailmap.html"><img src="http://docs.rinet.ru/OLDui/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/OLDui/images/uiHeader.gif" width=26 height=26 align=top border=0 alt="Creating a User Interface (AWT Only) | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Overview of the Java UI</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
