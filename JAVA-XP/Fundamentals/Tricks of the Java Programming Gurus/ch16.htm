<HTML>

<HEAD>
   <TITLE>Chapter 16 -- Building Stand-Alone Applications</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 16</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Building Stand-Alone Applications</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#WritingandRunningaJavaProgram" >Writing and Running a Java Program</A>
<LI><A HREF="#Properties" >Properties</A>
<LI><A HREF="#ApplicationInstances" >Application Instances</A>
<LI><A HREF="#TheBloatFinderApplication" >The BloatFinder Application</A>
<LI><A HREF="#UsingJavasSpecialFeatures" >Using Java's Special Features</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Although much of the initial excitement about Java has centered
on applets, Java is also a good language for writing stand-alone
applications. Java and its library make it relatively simple for
applications to perform tasks that require much more effort in
other languages. Java also has the same kinds of  &quot;programming-in-the-large&quot;
features that have helped to make C++ popular, but in a simpler
framework. Currently, Java is implemented as an interpreter, which
makes it too slow for some purposes. But as native-code compilers
become available, easing performance concerns, Java will probably
become the language of choice for writing many kinds of stand-alone
programs.
<P>
This chapter is an introduction to using Java for your applications.
It explains how to write a stand-alone program in Java and introduces
Java's special capabilities, which you can use to make better
applications.
<H2><A NAME="WritingandRunningaJavaProgram"><FONT SIZE=5 COLOR=#FF0000>Writing
and Running a Java Program</FONT></A></H2>
<P>
To write a Java program that can be run on its own, you create
a class with a method called <TT>main</TT>.
This procedure may feel familiar but also a little strange to
C and C++ programmers: because all methods in Java are a part
of classes, you can't simply write a <I>function</I> called <TT>main</TT>.
You must put it in the context of a class.
<P>
Furthermore, to be recognized by the Java virtual machine as the
starting point of a program, the <TT>main</TT>
method must have certain other characteristics. Books on programming
languages often contain an example of the simplest possible program,
and such an example is useful because it makes clear what is essential
and what is not. Here's the simplest possible Java program, which
does nothing at all. It's the only program I have ever written
that I'm absolutely certain has no bugs:
<BLOCKQUOTE>
<TT>class Minimal {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void<BR>
&nbsp;&nbsp;&nbsp;&nbsp;main (String argv[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Unlike applets, an application class doesn't have to extend to
any particular other class. But the <TT>main</TT>
method has to be just right:
<OL>
<LI>It must be <TT>public</TT> <TT>static</TT>.
<LI>It must be named main.
<LI>Its type must be void.
<LI>It must take one parameter: an array of <TT>String</TT>
objects.
</OL>
<P>
This list contains some interesting details.
<P>
Declaring the method <TT>static</TT>
indicates that <TT>main</TT> is a
class method, and that it doesn't execute in the context of an
instance. When the application starts, the class has been initialized
(so static variables already have been initialized, and static
initializer blocks have been executed), but normal instance variables
don't exist; no instance of the class is created. The <TT>main</TT>
method doesn't have access to any nonstatic fields of the class.
<P>
C and C++ programmers might be wondering why the type of the <TT>main</TT>
method can't be <TT>int</TT>. In those
languages, the exit status of a program can be set in two different
ways: either by a call to <TT>exit</TT>
or by the <TT>main</TT> function returning
an integer. But in Java, you have only one way to set the exit
status: you must call <TT>System.exit</TT>.
<P>
The single parameter contains the command-line arguments, one
per element of the array. To find out how many arguments you have,
check <TT>array.length</TT>. Unlike
C or C++, however, only the actual arguments to the command are
included-<TT>argv[0]</TT> contains
the first argument, not the name by which the command was invoked.
Currently, the Java library doesn't provide a way to learn that
information.
<P>
To run a Java application, invoke the Java virtual machine with
the name of the application class as the first argument and application
arguments after. The class file must be in Java's class search
path (defined by the <TT>CLASSPATH</TT>
environment variable), and you specify the name of the class,
not the name of the file. To invoke our minimal application with
three arguments, for example, do the following:
<BLOCKQUOTE>
<TT>java Minimal one two three</TT>
</BLOCKQUOTE>
<P>
(Of course, the <TT>Minimal</TT> class
doesn't do anything with command line arguments it receives.)
If the application class is in a package, you must specify the
entire name of the class, package and all.
<P>
For command-line environments, this way of invoking programs is
a bit clumsy. You can write a shell script or batch file wrapper
to permit executing the application just by the command name.
I anticipate that future releases of the Java development kit
may include a tool to build such scripts or to generate a special
version of the Java virtual machine that runs an application automatically.
<H2><A NAME="Properties"><FONT SIZE=5 COLOR=#FF0000>Properties</FONT></A>
</H2>
<P>
The Java runtime system makes use of an idea called <I>system
properties</I> to provide programs with a way of learning about
the execution environment. Using properties, your code can learn
about the Java environment and the machine and operating system
on which it is running. Properties can also provide information
about the user who is running the program, including the user's
login name, home directory, current directory, and preferences.
<P>
You can think of properties as a restricted form of <TT>Hashtable</TT>,
where the keys and values must be strings. The Java virtual machine
initializes the properties table with a set of useful properties,
as shown in the following table:<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=195><B>Property Name</B></TD><TD WIDTH=294><B>Explanation</B>
</TD></TR>
<TR><TD WIDTH=195><TT>java.version</TT>
</TD><TD WIDTH=294>Java version number</TD></TR>
<TR><TD WIDTH=195><TT>java.vendor</TT>
</TD><TD WIDTH=294>Java vendor identification string</TD></TR>
<TR><TD WIDTH=195><TT>java.vendor.url</TT>
</TD><TD WIDTH=294>Java vendor URL</TD></TR>
<TR><TD WIDTH=195><TT>java.home</TT>
</TD><TD WIDTH=294>Java installation directory</TD></TR>
<TR><TD WIDTH=195><TT>java.class.version</TT>
</TD><TD WIDTH=294>Java class version number</TD></TR>
<TR><TD WIDTH=195><TT>java.class.path</TT>
</TD><TD WIDTH=294>Java classpath</TD></TR>
<TR><TD WIDTH=195><TT>os.name</TT>
</TD><TD WIDTH=294>Operating system name</TD></TR>
<TR><TD WIDTH=195><TT>os.arch</TT>
</TD><TD WIDTH=294>Operating system architecture</TD></TR>
<TR><TD WIDTH=195><TT>os.version</TT>
</TD><TD WIDTH=294>Operating system version</TD></TR>
<TR><TD WIDTH=195><TT>file.separator</TT>
</TD><TD WIDTH=294>File separator (<TT>&quot;\&quot;</TT> under Windows)
</TD></TR>
<TR><TD WIDTH=195><TT>path.separator</TT>
</TD><TD WIDTH=294>Path separator (<TT>&quot;;&quot;</TT> under Windows)
</TD></TR>
<TR><TD WIDTH=195><TT>line separator</TT>
</TD><TD WIDTH=294>Line separator (<TT>&quot;\r\n&quot;</TT> under Windows)
</TD></TR>
<TR><TD WIDTH=195><TT>user.name</TT>
</TD><TD WIDTH=294>User account name</TD></TR>
<TR><TD WIDTH=195><TT>user.home</TT>
</TD><TD WIDTH=294>User home directory</TD></TR>
<TR><TD WIDTH=195><TT>user.dir</TT>
</TD><TD WIDTH=294>User's current working directory</TD></TR>
</TABLE></CENTER>
<P>
<P>
These properties are always guaranteed to be present in a Java
virtual machine. (Properties are considered sensitive resources,
and some properties are not visible to applets.)
<P>
The <TT>System</TT> class provides
three static methods that can be used to access properties. The
<TT>getProperty(String</TT> <TT>key)</TT>
method returns a string that is the value of the property named
by the <TT>key</TT> parameter. If
the property is one that might not be available, you can use <TT>getProperty(String
key,</TT> <TT>String def)</TT>.
The <TT>def</TT> parameter represents
a string to use as a default value-the method returns the property
value if it has been set, the <TT>def</TT>
parameter if otherwise. The <TT>getProperties()</TT>
method returns all the system properties as an instance of <TT>java.util.Properties</TT>
(a subclass of <TT>Hashtable</TT>).
<P>
You also can set properties explicitly, but only as a group. The
<TT>setProperties(Properties</TT>
<TT>prop)</TT> method takes a <TT>Properties</TT>
object as a parameter and completely replaces the system properties
with the new list. A method for setting individual properties
would have made it too tempting to use the system properties as
makeshift global variables.
<H3>Properties and Environment Variables</H3>
<P>
UNIX and Microsoft Windows utilize the concept of <I>environment
variables</I>, which are variables maintained by the operating
system to which all programs have access. Each user has a separate
set of environment variables, so users can set the variables as
a way of supplying useful information to applications.
<P>
That capability is useful, but it's not portable: not all systems
have environment variables, and the ones that do sometimes have
different conventions about how they are used. UNIX programs,
for example, can rely on an environment variable called <TT>PAGER</TT>,
which contains the name of a command that the user likes to use
to view output in screen-sized chunks, and applications that generate
a lot of output can make use of that variable to present the information
to the user in a useful way. Other systems don't use an environment
variable for storing that piece of information or (more commonly)
don't cater to such a thing at all.
<P>
The Java designers decided that system properties could be used
to provide a portable, uniform way for applications to learn about
the execution environment, including the kind of information that
would ordinarily be found in environment variables on systems
that support them. This section explains how to make environment
variable information available to your Java application.
<P>
The direct way to run a Java application is by invoking the Java
interpreter directly from the command line. Suppose that you write
a Java program called <TT>Resolve</TT>,
which searches the user's execution path for a command with a
particular name. To run the <TT>Resolve</TT>
program, you might type the following:
<BLOCKQUOTE>
<TT>java COM.MCP.Samsnet.tjg.Resolve lostapp</TT>
</BLOCKQUOTE>
<P>
This command is not very friendly. You may want to provide a wrapper
script or command file to make the process easier. On UNIX, for
example, your script might look like this:
<BLOCKQUOTE>
<TT>#!/bin/sh<BR>
java COM.MCP.Samsnet.tjg.Resolve $*</TT>
</BLOCKQUOTE>
<P>
If you call that file <TT>resolve</TT>
and place it in a directory that is in the execution path, running
the program is much easier:
<BLOCKQUOTE>
<TT>resolve lostapp</TT>
</BLOCKQUOTE>
<P>
Under Windows, you may simply provide a shortcut that contains
the appropriate Java command line. In either case, the point is
that you arrange for the messy invocation of the Java interpreter
to be hidden from users.
<P>
The problem is that the <TT>resolve</TT>
program needs access to the <TT>PATH</TT>
environment variable to do its job, and the way you've done things
so far, the program doesn't have that access. You do have a way
to solve the problem, though. The Java interpreter enables you
to set system properties on the command line. Using the <TT>-D</TT>
option, you can supply the name and value for a property, and
you can supply multiple definitions on the command line. So you
can change the <TT>resolve</TT> wrapper
script to look like the following:
<BLOCKQUOTE>
<TT>#!/bin/sh<BR>
java -Denv.PATH=&quot;$PATH&quot; COM.MCP.Samsnet.tjg.Resolve
$*</TT>
</BLOCKQUOTE>
<P>
Now when you invoke the program, the virtual machine defines a
property called <TT>env.PATH</TT>
based on the value of the <TT>PATH</TT>
environment variable before the <TT>main</TT>
method ever begins execution, and the program can access that
property to get the information it needs.
<H2><A NAME="ApplicationInstances"><FONT SIZE=5 COLOR=#FF0000>Application
Instances</FONT></A></H2>
<P>
Although Java applications are invoked as class methods, independent
of any instances, it is often a good idea to build your applications
so that they do run as objects. Such a strategy can yield useful
flexibility. If you are writing a document editor of some sort,
opening a new document could simply involve creating a new instance
of your application. An application built that way might also
be easily adapted to run as a component of some other, more inclusive
application or framework, or even as an applet.
<P>
If you decide to build your application that way, then the <TT>main</TT>
method becomes a sort of gateway or entry point. It parses and
validates the arguments, converting them in some cases to more
useful Java objects rather than simple strings. It might also
verify that certain necessary resources are available, or load
libraries that are used by the application proper. If the application
supports network extensibility, the <TT>main</TT>
method should probably also initialize the security manager, ensuring
that security restrictions are in place at the earliest possible
moment. Ultimately, however, the goal of the <TT>main</TT>
method is to create a new instance of the application class, which
does the real work.
<H2><A NAME="TheBloatFinderApplication"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >BloatFinder</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Application</FONT></A></H2>
<P>
As an example of how to write a stand-alone application, I've
written the <TT>BloatFinder</TT> class,
a simple disk space analysis program. The example illustrates
the basics of writing stand-alone Java applications, and it also
follows the design suggestions I've made. After it validates arguments,
the <TT>main</TT> method creates an
<I>instance</I> of <TT>BloatFinder</TT>
to do the actual work; this means that other applications can
use <TT>BloatFinder</TT> as a utility
class, not just a self-contained program. Also, although I don't
make use of system properties directly, I do make careful use
of the <TT>File.separator</TT> static
variable to learn the system-dependent directory separator character.
I could have learned the same information from the system properties;
in fact, the <TT>File</TT> class initializes
the variable that way:
<BLOCKQUOTE>
<TT>public static final String separator
=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.getProperty(&quot;file.separator&quot;);</TT>
</BLOCKQUOTE>
<P>
Most disk space analysis programs are not too helpful when you're
trying to find large batches of wasted space that can be reclaimed.
Most tell you only the size of files directly in a directory instead
of recursively totaling files in subdirectories. Others, such
as the &quot;du&quot; program on UNIX systems, give you the full
total for a directory and all subdirectories, but they provide
little help in narrowing down the real source of the bloat. You
may not be surprised, for example, to find that most of the space
on your disk is taken up by files in the &quot;software&quot;
directory; what you really want to know is whether one or two
subdirectories, possibly hidden several levels deep under &quot;software,&quot;
contain a significant percentage of the total. In short, typical
disk space analysis programs either provide too much information
or too little.
<P>
<TT>BloatFinder</TT> tries to do a
little better. It recursively calculates directory sizes like
du does, but it reports only directories that are larger than
a certain threshold size.
<H3>The <TT><FONT SIZE=4 >BloatFinder</FONT></TT><FONT SIZE=4>
Class</FONT></H3>
<P>
The program is too long to include in one listing. The BloatFinder.java
file itself contains the <TT>BloatFinder</TT>
class and a utility class called <TT>DirEnum</TT>.
Another class required by the application, <TT>DirNode</TT>,
is in a separate file. Listing 16.1 shows an overview of BloatFinder.java,
with comments taking the place of the methods and the <TT>DirEnum</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 16.1. </B><TT><B></TT>BloatFinder</FONT></B></TT><B>
overview (BloatFinder.java, part 1).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*<BR>
&nbsp;* BloatFinder.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0
96/04/27 Glenn Vanderburg<BR>
&nbsp;*/<BR>
<BR>
package COM.MCP.Samsnet.tjg;<BR>
<BR>
import java.io.*;<BR>
import java.util.*;<BR>
<BR>
/**<BR>
&nbsp;* An application which finds the largest directories in
a directory tree.<BR>
&nbsp;*<BR>
&nbsp;* Usage:<BR>
&nbsp;* &lt;pre&gt;<BR>
&nbsp;* BloatFinder -t threshold -d search-depth directory-name
<BR>
&nbsp;* &lt;/pre&gt;<BR>
&nbsp;* where threshold is the smallest size of directory to report
(default<BR>
&nbsp;* 5 megabytes), and search-depth is the maximum directory
depth to report<BR>
&nbsp;* (default 5).&nbsp;&nbsp;The directory named on the command
line is level 0.<BR>
&nbsp;*<BR>
&nbsp;* BloatFinder can also be used as a utility class by other
applications.<BR>
&nbsp;* It can supply an enumeration of all of the identified
directories and<BR>
&nbsp;* their sizes.<BR>
&nbsp;*<BR>
&nbsp;* This program traverses a directory hierarchy, calculates
total space<BR>
&nbsp;* used by each directory, and reports directories which
seem to be using<BR>
&nbsp;* &quot;more than their fair share&quot; according to a
heuristic criterion which<BR>
&nbsp;* I just made up. :-)<BR>
&nbsp;*<BR>
&nbsp;* Essentially, a directory is reported if its size (calculated
as the size<BR>
&nbsp;* of the directory itself, plus the size of files it contains,
plus the<BR>
&nbsp;* recursively calculated size of all of its subdirectories)
is greater<BR>
&nbsp;* than the &lt;em&gt;working&lt;/em&gt; threshold at the
current depth.&nbsp;&nbsp;The working<BR>
&nbsp;* threshold is calculated by the following formula:<BR>
&nbsp;*<BR>
&nbsp;* &lt;pre&gt;<BR>
&nbsp;* wt = threshold - (((threshold/2) / (searchDepth-1)) *
(depth-1));<BR>
&nbsp;* &lt;/pre&gt;<BR>
&nbsp;*<BR>
&nbsp;* that is to say, it begins as the specified threshold at
the top of the<BR>
&nbsp;* hierarchy, and is reduced by increments at each level
until, at the<BR>
&nbsp;* deepest level, it is half the level at the top of the
tree.<BR>
&nbsp;*<BR>
&nbsp;* @version&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 27 Apr 1996<BR>
&nbsp;* @author Glenn Vanderburg<BR>
&nbsp;*/<BR>
<BR>
public <BR>
class BloatFinder <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int threshold;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int searchDepth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String dirname;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DirNode top;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public static<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>main(String
args[])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.2<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public BloatFinder(String
dirname)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing 16.3<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public BloatFinder(String
dirname,<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>int
threshold,<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>int
searchDepth)&nbsp;&nbsp;&nbsp;&nbsp; Listing 16.3<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public execute()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.4<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public elements()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Listing 16.4<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: public report(PrintStream
out)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.4<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: static usage()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.2<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: static usage(String
errmessage)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.2<BR>
</I>}<BR>
<BR>
// <I>Class: DirEnum extends Vector<BR>
</I>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements
Enumeration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.5</TT>
</BLOCKQUOTE>
<HR>
<P>
The program was designed from the start as a stand-alone application,
but the needs of other programs that might want to use <TT>BloatFinder</TT>
as a utility class were considered at every point. The <TT>main</TT>
method parses and validates the command-line arguments, and when
that work is done, it creates an instance and calls methods that
direct the instance to do the work. The <TT>main</TT>
method doesn't even supply the default values for command-line
options; the constructors do that job so that the defaults can
be supplied even when <TT>BloatFinder</TT>
is used by another application.
<P>
Listing 16.2 shows the three static methods: <TT>main</TT>
and the two <TT>usage</TT> methods
(some of the repetitious argument parsing has been replaced by
a comment).
<HR>
<BLOCKQUOTE>
<B>Listing 16.2. </B><TT><B></TT>BloatFinder</FONT></B></TT><B>
static methods (BloatFinder.java, part 2).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* The main method for standalone application use.<BR>
&nbsp;*<BR>
&nbsp;* @param args the command line parameters<BR>
&nbsp;*/<BR>
public static void<BR>
main (String args[]) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// The constructor supplies a default
value if -1 is passed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// for these two.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int threshold = -1;&nbsp;&nbsp;&nbsp;&nbsp;
// No value specified yet.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int searchDepth = -1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// explicit initialization to avoid compiler
warnings:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String dirname = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DirNode top;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// I guess you can tell by the argument
syntax that I'm a Unix guy ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i&lt;args.length; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (&quot;-?&quot;.equals(args[i]))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (&quot;-t&quot;.equals(args[i]))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(++i &lt; args.length) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold
= Integer.parseInt(args[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(threshold &lt;= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(&quot;Threshold
can't be negative: &quot; + threshold);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(NumberFormatException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(&quot;Threshold
must be an integer: &quot; + args[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (&quot;-d&quot;.equals(args[i]))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
<I>Essentially the same as for &quot;-t&quot; ...<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(args[i].startsWith(&quot;-&quot;)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(&quot;Unrecognized
option: &quot; + args[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dirname
= args[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(++i &lt; args.length) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(&quot;Too
many arguments.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (dirname == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(&quot;Directory
name not specified.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Now that the command line processing
is done, we actually<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// create an instance to do the work.&nbsp;&nbsp;If
someone wants to write<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a larger application which includes
the BloatFinder functionality,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// they can just create an instance with
the appropriate parameters.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;BloatFinder app = new BloatFinder(dirname,
threshold, searchDepth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;app.execute();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;app.report(System.out);<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Prints a generic usage message to System.err.<BR>
&nbsp;*/<BR>
static void<BR>
usage ()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.print(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Usage: BloatFinder
[-t threshold] [-d search-depth] &quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;directory-name\n\n&quot;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;where
threshold is the smallest size of directory to report,\n&quot;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;&nbsp;&nbsp;and
search-depth is the maximum directory depth to report\n&quot;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default
5).\n&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ &quot;The directory
named on the command line is level 0.\n&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;);<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Prints an error message, followed by a usage message,
to System.err.<BR>
&nbsp;* @param errmessage the error message to print.<BR>
&nbsp;*/<BR>
static void<BR>
usage (String errmessage) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(errmessage);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;usage();<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
As mentioned previously, the constructors supply the default values
for the options. Having one simple constructor is handy when you
want all the defaults, but to avoid having four separate constructors,
I use values of <TT>-1</TT> to indicate
unspecified values, instead of overloading the constructor for
each possible combination of supplied options. Listing 16.3 contains
the code for the constructors.
<HR>
<BLOCKQUOTE>
<B>Listing 16.3. </B><TT><B></TT>BloatFinder</FONT></B></TT><B>
constructors (BloatFinder.java, part 3).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Constructs a new BloatFinder with default parameters.
<BR>
&nbsp;* @param dirname the topmost directory in the hierarchy
<BR>
&nbsp;*/<BR>
public<BR>
BloatFinder (String dirname) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Use the defaults<BR>
&nbsp;&nbsp;&nbsp;&nbsp;this(dirname, -1, -1);<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Constructs a new BloatFinder.<BR>
&nbsp;* @param dirname the topmost directory in the hierarchy
<BR>
&nbsp;* @param threshold the initial reporting threshold (-1 means
<BR>
&nbsp;* use the default value)<BR>
&nbsp;* @param searchDepth the depth in the hierarchy to search
<BR>
&nbsp;* (-1 means use the default value)<BR>
&nbsp;*/<BR>
public<BR>
BloatFinder (String dirname, int threshold, int searchDepth)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;this.dirname = dirname;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// If the values are -1, supply a default.&nbsp;&nbsp;Doing
it this way<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// saves us from having to have four separate
constructors for<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// the different permutations of initialization
parameters, and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// also saves the main method from having
to call all four of them.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (threshold == -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.threshold
= 1024*1024*5; // 5 megabytes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.threshold
= threshold;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (searchDepth == -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchDepth
= 5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.searchDepth
= searchDepth;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 16.4 contains the meat of the <TT>BloatFinder</TT>
class (although most of the real work is done in the <TT>DirNode</TT>
class, which is shown next). The <TT>execute</TT>
method scans the directory hierarchy looking for large directories.
After that task is complete, the <TT>elements</TT>
method can be used to get a list of those directories, or the
<TT>report</TT> method can be used
to print a formatted report of the list. The <TT>main</TT>
method uses <TT>report</TT>; other
applications might do the same, or they may prefer to get the
list and present it in their own manner (such as displaying it
in a listbox so that a user could select directories for deletion
or closer inspection).
<HR>
<BLOCKQUOTE>
<B>Listing 16.4. </B><TT><B></TT>BloatFinder</FONT></B></TT><B>
public methods (BloatFinder.java, part 4).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Searches the directory hierarchy, calculating sizes and
<BR>
&nbsp;* collecting directories which exceed the threshold (or
which<BR>
&nbsp;* have children which do).<BR>
&nbsp;*/<BR>
public void<BR>
execute ()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;top = new DirNode(dirname);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;top.getSize(0, threshold, searchDepth);
<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Builds an enumeration of the directories collected by
execute.<BR>
&nbsp;* The enumeration will consist solely of DirNode objects.
<BR>
&nbsp;* @return an Enumeration of DirNode objects.&nbsp;&nbsp;Only
directories which<BR>
&nbsp;* exceed the threshold (or that have children which do)
are included.<BR>
&nbsp;* The enumeration is ordered as for a preorder tree traversal.
<BR>
&nbsp;* @see #execute<BR>
&nbsp;*/<BR>
public Enumeration<BR>
elements () <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (top == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return top.elements();<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Prints a report about large directories.<BR>
&nbsp;* @param out a PrintStream to accept the output (for example,
System.out)<BR>
&nbsp;*/<BR>
public void<BR>
report (PrintStream out) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (top == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (&nbsp;&nbsp;&nbsp;&nbsp;Enumeration
e = elements();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
e.hasMoreElements();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirNode
d = (DirNode) e.nextElement();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.println(d.size
+ &quot;\t&quot; + d.pathname);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (ClassCastException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This won't
happen unless someone introduces a bug<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// into DirNode,
so we'll ignore it.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3>The <TT><FONT SIZE=4 >DirEnum</FONT></TT><FONT SIZE=4>
Class</FONT></H3>
<P>
The BloatFinder.java file also contains a simple utility class,
<TT>DirEnum</TT>, which is used by
<TT>DirNode</TT> to provide an enumeration
of the results of its directory hierarchy scan. <TT>DirEnum</TT>
implements the <TT>Enumeration</TT>
interface so that it can be used successfully by other classes,
but it also extends <TT>Vector</TT>
to make it easy for <TT>DirNode</TT>
to build the enumeration piece by piece. Listing 16.5 contains
the code for <TT>DirEnum</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 16.5. </B><TT><B></TT>DirEnum</FONT></B></TT><B>
class (BloatFinder.java, part 5).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class DirEnum extends Vector implements
Enumeration <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int curIndex = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hasMoreElements ()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return curIndex
&lt; elementCount;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;nextElement ()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (curIndex &gt;=
elementCount) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new NoSuchElementException();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return elementAt(curIndex++);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3>The <TT><FONT SIZE=4 >DirNode</FONT></TT><FONT SIZE=4>
Class</FONT></H3>
<P>
The real logic of scanning the directory hierarchy, calculating
sizes, and deciding whether a directory exceeds the specified
threshold is performed by the <TT>DirNode</TT>
class. It is a subclass of <TT>File</TT>,
so it has ready access to methods for finding the size of a file
and learning about a directory's files and subdirectories. An
overview of the DirNode.java file is shown in Listing 16.6.
<HR>
<BLOCKQUOTE>
<B>Listing 16.6. </B><TT><B></TT>DirNode</FONT></B></TT><B>
overview (DirNode.java, part 1).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*<BR>
&nbsp;* DirNode.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0 96/04/27
Glenn Vanderburg<BR>
&nbsp;*/<BR>
<BR>
package COM.MCP.Samsnet.tjg;<BR>
<BR>
import java.io.*;<BR>
import java.util.*;<BR>
<BR>
/**<BR>
&nbsp;* An extension of File which scans subdirectories looking
for<BR>
&nbsp;* directories which exceed a certain size threshold.&nbsp;&nbsp;It
is<BR>
&nbsp;* primarily a utility class for BloatFinder, but code which
uses<BR>
&nbsp;* that class sometimes needs direct access to DirNode objects.
<BR>
&nbsp;*<BR>
&nbsp;* @see BloatFinder<BR>
&nbsp;*<BR>
&nbsp;* @version&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 27 Apr 1996<BR>
&nbsp;* @author Glenn Vanderburg<BR>
&nbsp;*/<BR>
<BR>
public <BR>
class DirNode extends File<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * The total size of this directory.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int size = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * The name of this directory relative
to the top of the<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * specified hierarchy.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String pathname;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean sizeCalculated = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean qualifies = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Vector subdirs;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Constructs a new DirNode.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param name the name of the file to
represent.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DirNode (String name) <BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathname = name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Constructs a new DirNode for a file
within a directory.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param dir the directory<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param name the name of the file within
dir<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;DirNode (DirNode dir, String name)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(dir, name);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathname = dir.pathname
+ File.separator + name;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSize(int
depth,<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<I>int threshold,<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<I>int searchDepth)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.7<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
16.8<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;// <I>Method: private elements(String
prefix,<BR>
</I>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>DirEnum
vec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Listing 16.8<BR>
</I>}</TT>
</BLOCKQUOTE>
<HR>
<P>
The complicated part of <TT>DirNode</TT>
involves calculating the size and deciding whether the directory
exceeds the threshold. The threshold decreases slightly at each
level. Directories must remember subdirectories that exceed the
threshold. The <TT>getSize</TT> method,
which does all that work, is shown in Listing 16.7.
<HR>
<BLOCKQUOTE>
<B>Listing 16.7. </B><TT><B></TT>DirNode</FONT></B></TT><B>
</B><TT><B></TT>getSize</FONT></B></TT><B> method
(DirNode.java, part 2).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Calculates the size of this DirNode.&nbsp;&nbsp;If it
is a file,<BR>
&nbsp;* returns length(); otherwise, the total size of all contained
<BR>
&nbsp;* files and subdirectories is calculated.&nbsp;&nbsp;Along
the way, the<BR>
&nbsp;* method determines whether the directory is worth reporting
<BR>
&nbsp;* based on threshold and searchDepth.<BR>
&nbsp;* @param depth the depth of this directory<BR>
&nbsp;* @param threshold the size threshold of interest<BR>
&nbsp;* @param searchDepth the maximum depth of interest<BR>
&nbsp;* @return the size of this file or directory<BR>
&nbsp;*/<BR>
int<BR>
getSize (int depth, int threshold, int searchDepth) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (!sizeCalculated) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size += length();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!isDirectory())
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeCalculated
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
size;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Collect data
about all files and subdirectories<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String files[]
= list();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirs = new
Vector();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0;
i&lt;files.length; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirNode
cur = new DirNode(this, files[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(cur.isDirectory()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
size = cur.getSize(depth+1, threshold, searchDepth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size
+= size;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(cur.qualifies) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If any of our subdirectories show up in<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
the results, then we should, too.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirs.addElement(cur);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qualifies
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size
+= cur.length();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!qualifies
|| (depth &gt;= searchDepth)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If none of our children have to report, then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
we can discard our vector of subdirectories.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirs
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirs.trimToSize();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeCalculated
= true;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate working
threshold<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int wt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (threshold
== 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Always report the topmost level ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wt
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wt
= threshold - (((threshold/2) / (searchDepth-1))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
(depth-1));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size &gt;=
wt) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qualifies
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return size;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
After the size is calculated, the only other responsibility of
<TT>DirNode</TT> is providing an <TT>Enumeration</TT>
of the results upon request. Listing 16.8 shows the two methods
that perform this task; they also make use of the <TT>DirEnum</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 16.8. </B><TT><B></TT>DirNode</FONT></B></TT><B>
</B><TT><B></TT>elements</FONT></B></TT><B> methods
(DirNode.java, part 3).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Builds an Enumeration of large directories beneath this
directory.<BR>
&nbsp;* @return an Enumeration of DirNode objects.<BR>
&nbsp;* @see BloatFinder#elements<BR>
&nbsp;*/<BR>
Enumeration<BR>
elements ()<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return elements(new DirEnum());<BR>
}<BR>
<BR>
/**<BR>
&nbsp;* Adds to a DirEnum all large directories beneath this directory.
<BR>
&nbsp;* @param vec the Vector being built<BR>
&nbsp;*/<BR>
private Enumeration<BR>
elements (DirEnum vec) <BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;vec.addElement(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (qualifies &amp;&amp; subdirs != null)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0;
i&lt;subdirs.size(); i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirNode
cur = (DirNode) subdirs.elementAt(i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur.elements(vec);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(ClassCastException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return vec;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="UsingJavasSpecialFeatures"><FONT SIZE=5 COLOR=#FF0000>Using
Java's Special Features</FONT></A></H2>
<P>
This chapter provides an introduction to the basics of building
Java stand-alone applications, but it certainly doesn't cover
everything you need to know. Most stand-alone programs make heavy
use of many parts of the Java library. If you are interested in
building Java applications, you might have turned to this chapter
first, but you will also find many other chapters in this book
to be useful. This section describes some of the Java library
features that are important to application developers, with references
to other chapters that can help you make use of them. Reading
it, you might also learn some reasons why you would want to write
your next application in Java.
<H3>Using the Network</H3>
<P>
One of Java's most compelling and important features is its easy,
uniform, built-in network capabilities.  The network will be important
for many Java applications, whether for applets and dynamic extensions,
communicating and collaborating with applications on other computers,
or simply storage and retrieval of data.
<P>
Several other chapters deal with Java and networking. <A HREF="ch3.htm" >Chapter 3</A>,
&quot;Exploiting the Network,&quot; deals primarily with applets
rather than applications, but it provides an introduction to Java's
network classes. <A HREF="ch35.htm" >Chapter 35</A>, &quot;Taking
Advantage of the Internet in Development,&quot; talks specifically
about the ways that the network can be used to make applications
more useful and versatile. Finally, you can read <A HREF="ch34.htm" >Chapter 34</A>,
&quot;Client/Server programming,&quot; to learn about building
distributed applications that make serious use of the network
to accomplish their core tasks.
<H3>Cross-Platform GUIs</H3>
<P>
Most modern applications go beyond a textual, command-oriented
interface. Graphical interfaces with menus, dialog boxes, and
other graphical features have been important for a while, and
there's no going back.
<P>
Java comes with a graphical user interface toolkit called the
Abstract Window Toolkit (AWT). The AWT is notable because it's
a <I>cross-platform</I> toolkit: Java programs that use it can
provide graphical user interfaces on Windows, the Macintosh, UNIX
systems, OS/2-any platform that Java has been ported to.
<P>
With the rise of the Internet and the current interest in inexpensive,
portable computing, this sort of flexibility will be important.
What the common computer platform of the future will be is not
certain, and whether one dominant standard will exist is not even
clear. AWT interfaces will be able to adapt to multiple platforms.
In its current state, the AWT has some rough edges and is one
of Java's weak points. But it has a good foundation, and it will
certainly improve.
<P>
To learn more about using the AWT classes, see Part 3, &quot;The
Core Classes: AWT Tricks,&quot; and Part 4, &quot;The Core Classes:
Graphics Tricks.&quot;
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Dynamically loaded extensions are probably the most exciting prospect
for Java applications. Applets are only a part of the story. The
original Java-based Web browser, HotJava, can locate and download
Java classes to handle new URL protocols and new document, image,
and audio formats.
<P>
Such features are useful for other programs besides just Web browsers.
Spreadsheet or database programs could support dynamic addition
of new datatypes. Editors or word processors could download handlers
for specialized notations (such as mathematical equations or chemical
diagrams) that might not be needed by casual users. Image processing
programs could download modules for generating special effects.
Many possibilities exist.
<P>
With such dynamic extensions, other people can add new functionality
to your application for you. As with operating systems that become
successful partly due to the efforts of application vendors whose
offerings add value to the operating systems, you can use the
enthusiasm and contributions of your user base to make your application
more attractive to new users.
<P>
If you want to learn more about writing network-extensible applications,
a good place to start is <A HREF="ch17.htm" >Chapter 17</A>, &quot;Network-Extensible
Applications with Factory Objects.&quot; Because code loaded dynamically
from the network can't be trusted completely, you should also
read the chapters in Part 6, &quot;Security,&quot; to learn how
to design and build an effective security policy for your application.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch15.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch17.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

