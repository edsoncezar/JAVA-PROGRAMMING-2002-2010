<HTML>

<HEAD>
   <TITLE>Chapter 34 -- Client/Server Programming</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 34</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Client/Server Programming</B>
</font></H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#JavasSuitabilityforClientServerPro" >Java's Suitability for Client/Server Programming</A>
<LI><A HREF="#ClientandServers" >Client and Servers</A>
<LI><A HREF="#MergingtheClientandServer" >Merging the Client and Server</A>
<LI><A HREF="#JavasDeployableCodeAdvantage" >Java's Deployable Code Advantage</A>
<LI><A HREF="#JavaTCPIPSockets" >Java TCP/IP Sockets</A>
<LI><A HREF="#UsingDatagramforUDPSockets" >Using Datagram for UDP Sockets</A>
<LI><A HREF="#UsingSocketandServerSocketforTCPSo" >Using Socket and ServerSocket for TCP Sockets</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
The client/server model is an application development architecture
designed to separate the presentation of data from its internal
processing and storage. This paradigm is based on the theory that
the rules which operate on data do not change no matter how many
applications are accessing that data. An airline might want to
allow customers to purchase tickets on the Web, through a travel
agent, or even through ATM-like machines located in airports and
malls. No matter which interface the customer uses, the number
of seats available does not change, nor does the fact that you
cannot sell a 21-day advance fare ten days before the flight.
The client/server model would enable the airline to build the
application so that each interface accesses the same seat availability
data and calls the exact same rules to validate the sale of a
ticket.
<P>
With the rapid rise of the World Wide Web, the power of the client/server
paradigm now serves the masses. In feeding the same exact data
to multiple client browsers across the Internet, even the most
basic HTML page fits the client/server model in its simplest form.
Tools like CGI, and now Java, enhance the Web's use of the client/server
model by consolidating application rules on the Web server.
<H2><A NAME="JavasSuitabilityforClientServerPro"><B><FONT SIZE=5 COLOR=#FF0000>Java's
Suitability for Client/Server Programming</FONT></B></A></H2>
<P>
The Web provides an excellent example of the most basic reason
for separating the presentation of data from its storage and processing.
As a Web developer, you have absolutely no control over the platforms
and software with which users are accessing your data. You might
consider writing your application for each potential platform
that you are targeting. For the airline ticketing system discussed
in the previous example, this approach forces you to recode the
rule for a 21-day advance fare three times if that rule changes.
Obviously, writing the application for each possible platform
is a recipe for a maintenance nightmare.
<P>
In addition to having little control over the systems being used
for the presentation of your data, a complex application often
has different needs, which are often best met by different hardware
or operating systems. An ATM-like machine in a mall designed specifically
for selling airline tickets has no need for the hardware required
by home computers to provide a graphical user interface. Similarly,
the user's home computer is generally not well-suited for acting
as a massive data storage device on the level required by such
an application.
<P>
The primary selling point of Java as a programming language, the
Java virtual machine, also provides its primary selling point
as a tool in client/server development. With code portability
difficult to deliver in any other programming language, Java instead
enables developers to write the user interface code once, distribute
it to the client machine, and have the client machine interpret
that presentation in a manner that makes sense for that system.
<P>
Beyond architecture independence, Java provides a rich library
of network enabled classes that allow applications ready access
to network resources in the form of traditional TCP/IP addressing
and URL referencing. New tools, such as JavaSoft's Remote Method
Invocation (RMI), promise only to extend Java's network usability.
<P>
The final beauty of Java in client/server development involves
deployment strategies. In traditional client/server systems, deployment
of an application requires users to physically install the client
portion of the application on their machine. A Java client system,
on the other hand, can be executed from across the network. As
a result, client machines are always running the most current
version of the application.
<H2><A NAME="ClientandServers"><B><FONT SIZE=5 COLOR=#FF0000>Client
and Servers</FONT></B></A></H2>
<P>
Client systems generally have a clear separation from the servers
with which they work. The underlying mechanics of the system are
hidden from users who generally only need a portion of the functionality
provided by the server system. The client application serves a
particular problem domain, such as order entry, accounting, game
playing, or ticket purchasing, and talks to the server through
a narrow, well-defined network interface.
<P>
The server portion of a client/server application manages resources
shared among multiple users, often accessing the server through
multiple client front-ends. A Web server, for example, delivers
the same HTML pages across the Internet to Web users. More complex
applications, such as business database applications, enable clients
to make query requests through the server and receive the results.
<H2><A NAME="MergingtheClientandServer"><B><FONT SIZE=5 COLOR=#FF0000>Merging
the Client and Server</FONT></B></A></H2>
<P>
Developers commonly use one of two client/server architectures
in system design:
<UL>
<LI>Two-tier architecture
<LI><FONT COLOR=#000000>Three-tier architecture</FONT>
</UL>
<P>
The simple retrieval and display of information part of serving
HTML pages is an example of a two-tier client/server. On one end,
or tier, data is stored and served to clients. On the other end,
that data is displayed in a format that fits the situation.
<P>
On many systems, however, the retrieval and display of data forms
only a fraction of the system. A complex business system generally
involves the processing of data before it can be displayed or
saved back into storage. In a two-tier system, the client handles
a majority of this extra processing. This heavily loaded client
is often referred to as a &quot;fat client.&quot;
<P>
A two-tier design using a fat client provides a quick and dirty
architecture for building small, non-critical systems. The fat
client architecture shows its dirty side in maintenance and scalability.
With data processing so tightly coupled to the GUI presentation,
user interface changes necessitate working around the more complex
business rules. In addition, the two-tier system ties the client
and server together so tightly that distributing the data across
databases becomes difficult.
<P>
Three-tier client/server design mandates that data processing
should be separated from the user interface and data storage layers.
Stored procedures provide the most common method of intervening
between user interface and data storage in a third tier. A stored
procedure performs complex database queries and updates, returning
the results to the client.
<P>
While two-tier development simply separates data storage from
presentation, the three-tier system consists of the following
layers:
<UL>
<LI>user interface
<LI>data processing, or business rules
<LI><FONT COLOR=#000000>data storage</FONT>
</UL>
<P>
In isolating application functionality in three-tier development,
the system becomes easier to maintain and modify. The user interface,
for example, no longer cares where or how the system stores its
data. Changes in data storage, such as distributing the data across
multiple databases, ends up having a much smaller impact on the
system as a whole.
<H2><A NAME="JavasDeployableCodeAdvantage"><B><FONT SIZE=5 COLOR=#FF0000>Java's
Deployable Code Advantage</FONT></B></A></H2>
<P>
The Web provides developers with an ideal application deployment
infrastructure, especially when Java is part of the picture. Unlike
other client/server development tools, Java is distributed at
runtime across the Internet to client machines. By storing the
application on a central server and downloading it at runtime,
the user is always using the latest release of the software. Consider
the following URL:
<BLOCKQUOTE>
<TT>appletviewer http://www.strongsoft.com/Java/test.html</TT>
</BLOCKQUOTE>
<H2><A NAME="JavaTCPIPSockets"><B><FONT SIZE=5 COLOR=#FF0000>Java
TCP/IP Sockets</FONT></B></A></H2>
<P>
TCP/IP sockets form the basic mode of data communication on the
Internet. The Java Development Kit addresses TCP/IP programming
requirements through a high level suite of APIs and TCP/IP streams.
An application can use these streams to enable network input and
output to be manipulated in a variety of ways. The <TT>java.io</TT>
package from the standard Java release defines these forms, which
include <TT>DataInputStream</TT>s,
<TT>DataOutputStream</TT>s, and <TT>PrintStream</TT>s.
<P>
The package <TT>java.net</TT> has
the backbone TCP/IP classes provided by Java. From these classes,
the application can create the data I/O streams from <TT>java.io</TT>
that it needs for network communication. Java provides these network
classes in <TT>java.net</TT> for its
socket support:
<UL>
<LI><TT>DatagramSocket</TT>
<LI><TT>Socket</TT>
<LI><TT>SocketImplFactory</TT>
<LI><TT>SocketImpl</TT>
<LI><TT>ServerSocket</TT>
</UL>
<P>
Platform-specific implementations extend the abstract class <TT>SocketImpl</TT>
to perform the low-level network interfacing, which varies from
system to system. The high level <TT>Socket</TT>
and <TT>ServerSocket</TT> classes
in turn reference the system's particular <TT>SocketImpl</TT>
class for network access. Because the default implementations
of the basic JDK classes are not firewall-aware, it is possible
to extend the <TT>SocketImplFactory</TT>
and <TT>SocketImpl</TT> classes to
provide firewall functionality.
<H2><A NAME="UsingDatagramforUDPSockets"><B><FONT SIZE=5 COLOR=#FF0000>Using
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 >Datagram</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
for UDP Sockets</FONT></B></A></H2>
<P>
Starting with a ticker tape applet, <TT>TickerTape</TT>,
the following listing features a facility for subscribing to a
broadcast ticker tape server. The server is designed to broadcast
messages to a list of connected clients. Because the reception
of particular messages in a ticker tape system is unimportant,
this example uses the simplest form of sockets, the <TT>DatagramSocket</TT>.
A datagram uses UDP, or Unreliable Datagram Protocol. UDP is a
broadcast protocol that does not guarantee the reception of its
messages. Because they do no reception checking, however, UDPs
have a lower resource overhead than protocols which perform error
checking. If you are sending out roughly the same information
repeatedly (as is being done in Listing 34.1) then the resource
savings outweigh any problems related to losing a packet every
now and then.
<HR>
<BLOCKQUOTE>
<B>Listing 34.1. The client applet, TickerTape.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.Color;<BR>
import java.awt.Graphics;<BR>
import java.net.*;<BR>
import java.io.InputStream;<BR>
import java.util.Date;<BR>
<BR>
/**<BR>
Scrolls a line of text read from a UDP server<BR>
g<BR>
@version 0.1, 28 Apr 1996<BR>
</TT>&nbsp;<TT>*/<BR>
<BR>
public class TickerTape extends java.applet.Applet implements
Runnable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String message_error = &quot;Error - No
Message&#133;&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;String
message;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;/**
The width of the string in pixels.&nbsp;&nbsp;No need to know
this since<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we can reset the
string */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
messageWidth;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;/**
keep track of where we are printing the current string */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int position;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/** Thread */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;Thread
ticker = null;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;/**
Just a way to check if the thread is suspended or not.&nbsp;&nbsp;If
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;through some bug
this gets set wrong it just prints<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrong
commands */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean suspend = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* The amount of time to rest between
redrawing line */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
rest = 100;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;/**
amount of space to jump.&nbsp;&nbsp;Hopefully negative numbers
will<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move it in the
other direction */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
jump = 5;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String tmpParam;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpParam = getParameter(&quot;jump&quot;);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
tmpParam != null ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jump
= new Integer(tmpParam).intValue();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
jump == 0 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jump
= 5;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Zero
value for jump: using 5&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpParam = getParameter(&quot;rest&quot;);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
tmpParam != null ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest
= new Integer(tmpParam).intValue();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
rest &lt; 0 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest
= 100;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Negative
rest value: using 100&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = getMessage();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
message == null ) message = message_error;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageWidth
= getFontMetrics(getFont()).stringWidth(message);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position = (jump
&lt; 0) ? -messageWidth : size().width;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setForeground(Color.red);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(Color.white);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( ticker ==
null ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ticker
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ticker.start();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ticker
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(
ticker != null ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
((jump &lt; 0) &amp;&amp; (position &gt; size().width)) ||<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(position
&lt; -messageWidth) )<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position
= (jump &lt; 0) ? -messageWidth : size().width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
Thread.sleep(rest);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
InterruptedException e ) ticker = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position
-= jump;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(message,
position, getFont().getSize());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String getMessage() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
port;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetAddress address;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramSocket
socket;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
packet;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
sendBuf = new byte[256];<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= new DatagramSocket();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port
= 1111;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address
= InetAddress.getByName(&quot;StrongSun&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet
= new DatagramPacket(sendBuf, 256, address, port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(packet);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet
= new DatagramPacket(sendBuf, 256);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(packet);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message
= new String(packet.getData(), 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( Exception
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Exception:
&quot; + e);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return message;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The HTML code for this applet's Web page follows:
<BLOCKQUOTE>
<TT>&lt;TITLE&gt;Ticker Tape Applet Using
UDP&lt;/TITLE&gt;<BR>
&lt;H1&gt;Test of the TickerTape Datagram Applet&lt;/H1&gt;<BR>
<BR>
&lt;HR&gt;<BR>
<BR>
&lt;APPLET CODE=&quot;TickerTape&quot; WIDTH=400 HEIGHT=25&gt;
<BR>
&lt;PARAM NAME=jump VALUE=&quot;7&quot;&gt;<BR>
TickerTape applet not loaded!<BR>
&lt;/APPLET&gt;<BR>
&lt;HR&gt;</TT>
</BLOCKQUOTE>
<P>
The <TT>TickerTape</TT> applet uses
a loop in a second thread which repeatedly calls the <TT>getMessage()</TT>
method. This method returns a <TT>String</TT>
to use as the scrolling text from the ticker tape server. It does
this first by instantiating a new <TT>DatagramSocket</TT>
and sending a request to the server. The server responds with
a <TT>String</TT> to be painted for
the user. Listing 34.2 provides the server code.
<HR>
<BLOCKQUOTE>
<B>Listing 34.2. The </B><TT><B></TT>TickerTapeServer</FONT></B></TT><B>
application, TickerTapeServer.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.net.*;<BR>
import java.util.*;<BR>
<BR>
class TickerTapeServer extends Thread{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private DatagramSocket socket = null;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
String broadcastMessage = &quot;TickerTapeServer Messages Here!&quot;;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;TickerTapeServer()
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(&quot;TickerTapeServer&quot;);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket
= new DatagramSocket(1111);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;TickerTapeServer
listening on port: &quot; +&nbsp;&nbsp;&nbsp;&nbsp;<BR>
</TT><FONT FACE="ZapfDingbats">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&Acirc;</FONT><TT>socket.getLocalPort());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (java.net.SocketException
e) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Could
not create datagram socket.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
static void main(String[] args) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (args.length
!= 1) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Usage:
java TickerTapeServer &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;'your
text here in quotes' &quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TickerTapeServer
tts = new TickerTapeServer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tts.start();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tts.setBroadcastMessage
(args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(socket == null) return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
buf = new byte[256];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DatagramPacket
packet;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetAddress
address;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
port;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
dString = null;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet
= new DatagramPacket(buf, 256);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.receive(packet);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address
= packet.getAddress();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port
= packet.getPort();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dString
= getBroadcastMessage();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dString.getBytes(0,
dString.length(), buf, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet
= new DatagramPacket(buf, buf.length, address, port);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(packet);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch (Exception e) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Exception:&nbsp;&nbsp;&quot;
+ e);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
String getBroadcastMessage () {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return broadcastMessage;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void setBroadcastMessage (String s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broadcastMessage
= s;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Naturally, before any client can connect, you need to start the
server application. To start it, you simply issue the following
command:
<BLOCKQUOTE>
<TT>java TickerTapeServer 'My broadcast message'</TT>
</BLOCKQUOTE>
<P>
Client applications see whatever message you specify on the command
line. In a second thread, the server application waits for clients
to connect before sending them the broadcast message. Once it
receives the client request, the server application grabs the
client's address and sends the broadcast message back to the client.
<H2><A NAME="UsingSocketandServerSocketforTCPSo"><B><FONT SIZE=5 COLOR=#FF0000>Using
</FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 >Socket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 >ServerSocket</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
for TCP Sockets</FONT></B></A></H2>
<P>
TCP is a more reliable form of communication than UDP. Unlike
UDP, TCP sockets perform error-checking to ensure the packets
are delivered to their destination. TCP sockets are connection-based
sockets, meaning that a TCP socket is a two-way form of communication
maintained until one side or the other breaks it off. This contrasts
with the connectionless broadcast essence of UDP.
<P>
In order to create a TCP-based client/server example, you first
need to build a framework for network access.
<H3><B>A Simple Connection</B></H3>
<P>
Creating a TCP connection to a server involves only the following
code fragment:
<BLOCKQUOTE>
<TT>java.net.Socket connection;<BR>
<BR>
try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;connection = new java.net.Socket(&quot;athens.imaginary.com&quot;,
1701)<BR>
} catch( Exception e ) {<BR>
}</TT>
</BLOCKQUOTE>
<P>
The constructor for the <TT>Socket</TT>
class requires a host with which to connect, in this case &quot;<TT>athens.imaginary.com</TT>&quot;,
and a port number, which is the port of a mud server. If the server
is up and running, the code creates a new <TT>Socket</TT>
instance and continues running. If the code encounters a problem
with connecting, it catches the problem in the form of an exception.
To disconnect from the server, the application should call:
<BLOCKQUOTE>
<TT>connection.disconnect();</TT>
</BLOCKQUOTE>
<P>
A simple socket client looks like the following:
<BLOCKQUOTE>
<TT>public class BasicClient {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean active;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;java.net.Socket
connection;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
BasicClient(String address, int port) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection
= new java.net.Socket(address, port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active
= true;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( java.io.IOException
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void done() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( !active )
return;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active = false;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<P>
Socket I/O is blocking in nature, meaning that when an application
tries to read from a socket, all processing in that thread comes
to a halt until something is read from that socket. Fortunately,
Java is very friendly to multithreaded programming. Socket programmers
can use Java threads to read from a socket in one thread and write
to it in another, and perhaps perform additional processing in
another. This extended version of our basic client implements
it with a multi-threaded structure:
<BLOCKQUOTE>
<TT>public class BasicClient implements Runnable{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean active = false;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
java.net.Socket connection = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Thread thread = null;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
String address;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int port;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public BasicClient(String addr, int p)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address
= addr;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = p;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( thread ==
null ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.start();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
thread != null ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.stop();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread
= null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
active ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
connection != null ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.close();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection
= null;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
java.io.IOException e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
active = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection
= new java.net.Socket(address, port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active
= true;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( java.io.IOException
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;active
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Failed
to connect to server.&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean isActive() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
active;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<H3><B>A Music Store for the Web</B></H3>
<P>
Retail applications are simple client/server uses of the Internet
that provide a perfect example of how to structure such a program
in Java.  Any retail application first requires a server program
that provides data to customers and takes their orders; then it
needs a client program that provides the interface that allows
them to view a product line and enter purchase requests.
<P>
Of course, any system involving the exchange of money over the
Internet has some hefty security requirements. For the sake of
simplicity, however, we will ignore security requirements and
deal with the basic building blocks of socket-based client/server
programming. Our application, a music store for the Web, should
therefore have the following functionality:
<OL>
<LI>Start the server with the name of a JDBC driver and the JDBC
URL for accessing it.
<LI>Wait for connections from client systems.
<LI>For each client request, provide a list of available titles
and wait for purchase requests.
<LI>Enter any purchase requests into the database to be processed
later.
<LI>Shut down the server.
</OL>
<P>
Though most of the time it is simply listening for incoming client
connections, the server is responsible for quite a bit of work.
Listing 34.3 provides the server portion of the application.
<HR>
<BLOCKQUOTE>
<B>Listing 34.3. The Web music store server.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.net.Socket;<BR>
import java.net.ServerSocket;<BR>
import java.sql.Connection;<BR>
import java.sql.ResultSet;<BR>
import java.sql.Statement;<BR>
<BR>
public class Server extends Thread {<BR>
&nbsp;&nbsp;private Connection connection;<BR>
</TT>&nbsp;<TT>&nbsp;private Socket
socket;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public Server(Socket
sock, Connection conn) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;socket = sock;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;connection
= conn;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void run() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;java.io.DataInputStream
input;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;java.io.PrintStream output;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
tmp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.StringTokenizer
tokens;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.Vector
albums = new java.util.Vector();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean transacting = true;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statement
statement;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet result_set;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input = new java.io.DataInputStream(socket.getInputStream());
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output
= new java.io.PrintStream(socket.getOutputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement = connection.createStatement();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_set
= statement.executeQuery(&quot;SELECT album_id, artist, title,
&quot;+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quo
t;price
&quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&
nbsp;&quot;FROM
album &quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while( result_set.next() )
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
id, artist, title, price;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id
= result_set.getString(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;artist = result_set.getString(2);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title
= result_set.getString(3);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price = result_set.getString(4);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;albums.addElement(id
+ &quot;:&quot; + artist + &quot;:&quot; + title + &quot;:&quot;
+ price);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.println(albums.size());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i&lt;albums.size();
i++)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.println((String)albums.elementAt(i));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while( transacting ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp
= input.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens = new java.util.StringTokenizer(tmp);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp
= tokens.nextToken();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
tmp.equals(&quot;exit&quot;) ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transacting
= false;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if( tmp.equals(&quot;purchase&quot;)
) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
credit_card;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
id;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
tokens.countTokens() != 2 ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.println(&quot;error
Invalid command&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id
= tokens.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credit_card
= tokens.nextToken();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement
= connection.createStatement();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.executeUpdate(&quot;INSERT
INTO purchase (&quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;credit_card,
album) &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES('&quot;
+ credit_card + &quot;', '&quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id
+ &quot;')&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.println(&quot;ok&quot;);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( Exception e );<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;finally
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
java.io.IOException e );<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;static public
void main(String args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket port_socket;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;String
driver;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String url;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
port;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if(
args.length != 3 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Syntax:
java Server &lt;JDBC driver&gt; &lt;JDBC URL&gt; &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;&lt;port&gt;&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;driver
= args[0];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;url = args[1];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = Integer.parseInt(args[2]);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( NumberFormatException e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Invalid
port number: &quot; + args[2]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port_socket = new ServerSocket(port);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( java.io.IOException e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Failed
to listen to port: &quot; + e.getMessage());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(-1);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;while(
true ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection
conn;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Server server;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket
client_sock = port_socket.accept();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn
= java.sql.DriverManager.getConnection(url, &quot;user&quot;,
&quot;pass&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server = new Server(client_sock,
conn);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
java.io.IOException e ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Connection
failed.&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( java.sql.SQLException
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;Failed
to connect to database.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The application uses the main thread of the server simply to listen
to the network for connections. Each time it accepts a connection,
it creates a new instance of itself to handle the client/server
communication in a separate thread.
<P>
The most tedious and most difficult aspect of client/server programming
with sockets involves the actual protocol you create for the communication.
 The music store server uses a very simple protocol for communicating
with a client. It simply sends it a full list of all titles in
stock, then waits for either a purchase request or an end processing
notification. Even with this simplistic protocol, however, we
have to handle the parsing of each string sent by the client.
 
<P>
The core Java libraries do help simplify protocol management through
the <TT>StringTokenizer</TT> utility.
This class breaks up a string into individual tokens based on
a delimiter. By default, the delimiter is a space.  With purchase
requests, we expect a string in the form <TT>&quot;purchase
&lt;album id&gt; &lt;credit card number&gt;&quot;</TT>.
The first token thus is the purchase command, the second token
the album ID, and the third token the credit card number used
to purchase the album.
<P>
Listing 34.4 provides the socket code for the client end of the
application. It assumes that some sort of user interface is built
on top of it.
<HR>
<BLOCKQUOTE>
<B>Listing 34.4. The music store client socket code.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.DataInputStream;<BR>
import java.io.PrintStream;<BR>
import java.net.Socket;<BR>
<BR>
public class Client {<BR>
&nbsp;&nbsp;private Socket socket;<BR>
</TT>&nbsp;<TT>&nbsp;private String
host;<BR>
&nbsp;&nbsp;private int port;<BR>
</TT>&nbsp;<TT>&nbsp;private java.util.Vector
albums = new java.util.Vector();<BR>
&nbsp;&nbsp;private DataInputStream input;<BR>
</TT>&nbsp;<TT>&nbsp;private PrintStream
output;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public Client(String
h, int p) throws java.io.IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String data[] = new String[4];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;java.util.StringTokenizer
tokens;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String tmp;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
x;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;host
= h;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;port = p;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;socket
= new Socket(host, port);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;input = new DataInputStream(socket.getInputStream());
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;output
= new PrintStream(socket.getOutputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp = input.readLine();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = Integer.parseInt(tmp);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( NumberFormatException e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new java.io.IOException(&quot;Communication error, invalid &quot;
+<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;number
of albums.&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while( x-- &gt; 0 ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp
= input.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens = new java.util.StringTokenizer(tmp,
&quot;:&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
tokens.countTokens() != 4 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new java.io.IOException(&quot;Invalid
album format.&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=1; i&lt;=4; i++)
data[i] = tokens.nextToken();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;albums.addElement(data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public synchronized
void close() throws java.io.IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;output.println(&quot;exit&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;socket.close();
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public String[][] getAlbums() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;String
album_data[][];<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;synchronized(albums)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;album_data = new String[albums.size()][];
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;albums.copyInto(album_data);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return album_data;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public synchronized void purchaseAlbum(String id,
String cc)<BR>
</TT>&nbsp;<TT>&nbsp;throws java.io.IOException
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String tmp;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;output.println(&quot;purchase &quot; +
id + &quot; &quot; + cc.trim());<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;tmp
= input.readLine();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if( tmp.equals(&quot;ok&quot;) ) return;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
throw new java.io.IOException(tmp);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Again, protocol negotiation differentiates this code from the
basic client code shown earlier in the chapter.  When the applet
or application creates this <TT>Client</TT>
object, it connects to the Server program and gets a list of all
albums.  Upon receiving an album, it uses the <TT>StringTokenizer</TT>
in a slightly different fashion to break up the string into its
components.  As you saw in the Server code, information about
an album is packed into a single string separated by a &quot;<TT>:</TT>&quot;.
 By default, the <TT>StringTokenizer</TT>
splits the string on a space.  To change the delimiter, it needs
a second argument to its constructor, the string to serve as the
delimiter. In this case, we passed a &quot;<TT>:</TT>&quot;.
<P>
The rest of this client code simply provides methods for the user
interface to communicate with the server.  Specifically, it allows
the user interface to close the connection, get the list of albums,
and purchase an album.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
The basic building blocks for client/server programming are the
IP sockets that form the communication layer of the Internet.
While socket programming can be very tedious and time consuming,
Java has provided classes designed to minimize this tedium to
enable developers to harness the power of client/server programming.
The <TT>DatagramSocket</TT>, <TT>ServerSocket</TT>,
and <TT>Socket</TT> classes all provide
access to the IP protocols themselves. The <TT>DataInputStream</TT>,
<TT>DataOutputStream</TT>, and <TT>PrintStream</TT>
classes provide access to the data.  Finally, the <TT>StringTokenizer</TT>
class provides simple data manipulation.
<P>
The most important factor in creating a socket communication layer
is understanding exactly what your application should communicate.
 You cannot create the necessary communication protocol if you
do not fully understand what the client and server need to be
saying to each other.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch33.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch35.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

