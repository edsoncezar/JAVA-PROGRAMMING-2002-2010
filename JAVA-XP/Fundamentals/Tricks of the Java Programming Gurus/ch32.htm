<HTML>

<HEAD>
   <TITLE>Chapter 32 -- Interfacing to Existing C and
C++ Libraries</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 32</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Interfacing to Existing C and
C++ Libraries</B>
</FONT></H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>


<UL>
<LI><A HREF="#InterfacingtoLegacyCLibraries" >Interfacing to Legacy C Libraries</A>
<LI><A HREF="#DevelopingJavaInterfaceClassLibrarie" >Developing Java Interface Class Libraries with Legacy C++ Libraries</A>
<LI><A HREF="#SpecialConcernsandTips" >Special Concerns and Tips</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Having explored the basics of the native method interface, let's
shift to one of the most common uses of native methods-as an interface
to existing C and C++ libraries. First, you learn two methods
(static and object-oriented) of building interface classes to
existing C libraries using a very simple signal processing library
as an example.
<P>
Next, you investigate interfacing to C++ libraries, developing
a wrapper system for overcoming Java's C-only native method interface
by using a very simple 3D library as an example. As you go along,
you examine all the problems in interfacing to this library.
<P>
Finally, in the third section of this chapter, you look at some
common interfacing problems and tips on how to solve them. You
first learn how to handle a missing native library when running
an applet in a browser. Then you look at how to overcome some
of Java's object-oriented shortcomings when interfacing to a legacy
C++ library. You learn how to interface to C++ libraries using
templates, multiple inheritance, and operator overloading.
<H2><A NAME="InterfacingtoLegacyCLibraries"><B><FONT SIZE=5 COLOR=#FF0000>Interfacing
to Legacy C Libraries</FONT></B></A></H2>
<P>
Due mostly to C's popularity, a tremendous number of C libraries
exist in the development world today. Because of either the development
time necessary to develop these legacy libraries, the sheer performance
required, or the difficultly in porting the library, it may be
very difficult to port the library entirely to Java. Instead,
it may be necessary to develop a Java interface to the library.
<P>
This interfacing of C with Java is made difficult largely for
one reason: Java is entirely object-oriented. Unlike C++, Java
does not enable you to use procedural functions within the context
of an object-oriented program. Every construct must involve an
object of some sort.
<P>
There are two general methods of working around this. First, you
could sit down with the list of functions in the C library and
carve it up into functionally related blocks. For each block of
the library, you could then develop a class that contains each
function as a static Java method within the class. The class is,
of course, then titled with some moniker that indicates the relation
of all the functions it contains.
<P>
Although this is probably the fastest way to convert your library
over to Java, it may not be the smartest. Although your current
C library users will have no difficulties getting used to the
Java interface, your new Java users may because it isn't object-oriented.
As a solution to this dilemma, you should consider the feasibility
of developing an object-oriented interface to your library <I>in
addition to</I> the static member class interface. This way, both
sets of users are happy-those used to your C interface and those
used to your C++ interface.
<H3><B>Building a Static Interface to a C FFT Library</B></H3>
<P>
As a simple example of the first alternative, assume that you
have the very simple C library represented by the prototype shown
in Listing 32.1. This library implements three useful signal processing
functions: a real numbered fast Fourier transform (<TT>realFFT</TT>),
a sine Fourier transform (<TT>sinft</TT>),
and a cosine Fourier transform (<TT>cosft</TT>).
For each of these C functions, the variable <TT>samples</TT>
contains the signal samples, and <TT>n</TT>
is the number of samples. The result is returned in place through
the <TT>ft</TT> parameter.
<HR>
<BLOCKQUOTE>
<B>Listing 32.1. A simple C FFT library.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>void realFFT(float samples[], long n,
float ft[]);<BR>
void sinft(float samples[], long n, float ft[]);<BR>
void cosft(float samples[], long n, float ft[]);</TT>
</BLOCKQUOTE>
<HR>
<P>
The static Java implementation is shown in Listing 32.2.
<HR>
<BLOCKQUOTE>
<B>Listing 32.2. The static Java implementation.</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class FFTlibrary {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public native
static void realFFT(float samples[], int n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
FFTresult[]);<BR>
</TT>&nbsp;<TT>&nbsp;public native
static void sinft(float samples[], int n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
FFTresult[]);<BR>
</TT>&nbsp;<TT>&nbsp;public native
static void costft(float samples[], int n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
float FFTresult[]);<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
This library would then have an interface C file that contains
a map to the C library function, just like the native interface
files you considered in the last chapter. This interface file
is shown in Listing 32.3.
<HR>
<BLOCKQUOTE>
<B>Listing 32.3. The interface file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#include &lt;native.h&gt;<BR>
#include &lt;FFT.h&gt;<BR>
<BR>
void FFTlibrary_realFFT(float samples[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long
n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
FFTresult[]) {<BR>
<BR>
&nbsp;&nbsp;realFFT(samples, n, FFTresult);<BR>
<BR>
}<BR>
<BR>
void FFTlibrary_cosft(float samples[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long
n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
FFTresult[]) {<BR>
<BR>
&nbsp;&nbsp;cosft(samples, n, FFTresult);<BR>
<BR>
}<BR>
<BR>
void FFTlibrary_sinft(float samples[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long
n,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
FFTresult[]) {<BR>
<BR>
&nbsp;&nbsp;sinft(samples, n, FFTresult);<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><B>Building an Object-Oriented Wrapper Around the C Library</B>
</H3>
<P>
Instead of a static class interface, you could instead develop
a set of Java classes that uses the underlying C library to perform
the complex operations but gives the Java library an object-oriented
feel. For example, shown in Listing 32.4 is the <TT>DataSample</TT>
object, which implements storage for a set of signal samples and
provides methods to calculate the real FFT, the cosine FT, and
the sine FT.
<HR>
<BLOCKQUOTE>
<B>Listing 32.4. The </B><TT><B></TT>DataSample</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package mySigProcLib;<BR>
<BR>
class DataSample {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public
void AddSample(float sample) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
...Some signal management logic here...<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public
void DeleteSample(int I) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
...Some signal management logic here...<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public
native void realFFT(float FFTresult[]);<BR>
&nbsp;&nbsp;&nbsp;public native void cosFFT(float FFTresult[]);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public
native void sinFFT(float FFTresult[]);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;int nSamples;
<BR>
&nbsp;&nbsp;&nbsp;float fSamples[];<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The implementation of the <TT>DataSample</TT>
class is shown in Listing 32.5. There's nothing new from the last
chapter in this implementation, but it does show how to structure
your C implementation to achieve the feel of an object-oriented
library in your Java interface object.
<HR>
<BLOCKQUOTE>
<B>Listing 32.5. Implementation of the </B><TT><B></TT>DataSample</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#include &lt;native.h&gt;<BR>
#include &lt;FFT.h&gt;<BR>
<BR>
void mySigProcLib_DataSample_realFFT(<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct mySigProcLib_DataSample* hthis,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HArrayOfFloat* FFTresult<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;realFFT(unhand(unhand(hthis)-&gt;fSamples)-&gt;body,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(hthis)-&gt;nSamples,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(FFTresult)-&gt;body);
<BR>
<BR>
}<BR>
<BR>
void mySigProcLib_DataSample_cosFFT(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct mySigProcLib_DataSample* hthis,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HArrayOfFloat* FFTresult<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
{<BR>
<BR>
&nbsp;&nbsp;cosFFT(unhand(unhand(hthis)-&gt;fSamples)-&gt;body,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(hthis)-&gt;nSamples,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(FFTresult)-&gt;body);
<BR>
<BR>
}<BR>
<BR>
void mySigProcLib_DataSample_sinFFT(<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct mySigProcLib_DataSample* hthis,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HArrayOfFloat* FFTresult<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
{<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;realFFT(unhand(unhand(hthis)-&gt;fSamples)-&gt;body,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(hthis)-&gt;nSamples,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unhand(FFTresult)-&gt;body);
<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="DevelopingJavaInterfaceClassLibrarie"><B><FONT SIZE=5 COLOR=#FF0000>Developing
Java Interface Class Libraries with Legacy C++ Libraries</FONT></B></A>
</H2>
<P>
With the explosion in interest in object-oriented design has come
an explosion in the number of available C++ class libraries. This
section extends the discussion of interfacing from the last section
to developing an interface to existing C++ libraries. To make
the description of this design process more concrete, you walk
through an example of taking an existing C++ class library and
developing a parallel set of Java classes that transparently provide
the same look and feel as the C++ classes.
<H3><B>The My3D C++ Graphics Class Library</B></H3>
<P>
To demonstrate an interface between Java objects and C++ objects,
let's use a few components of a very primitive 3D graphics class
library, My3D.
<P>
Let's assume that the My3D C++ library is either too performance-sensitive
to be converted to Java or redevelopment of the Java library would
involve so much time that developing a Java interface to the C++
class is a better investment. Before diving in with the implementation
of your interface class, you should read through the steps involved
in the implementation of the My3D class to get an idea of how
much development is involved. If it looks like developing the
interface will take longer than porting your library from C++
to Java, port your library instead of developing an interface.
This seems like an obvious point, but several developers have
taken the hard road instead of the easy one.
<H4><B>The My3D </B><TT><B></TT>World</FONT></B></TT><B>
Object</B></H4>
<P>
Listing 32.6 contains the <TT>World</TT>
object, the first C++ object you will consider in your simple
3D library. The <TT>World</TT> object
is responsible for handling the details of attaching and detaching
objects from a 3D scene. The method <TT>AttachNode</TT>,
as you may have guessed, is responsible for taking a pointer to
a <TT>Node</TT> object and attaching
this <TT>Node</TT> to the scene graph.
Likewise, <TT>DetachNode</TT> is responsible
for detaching <TT>Node</TT>s from
the scene graph, either from the end of the graph or the <TT>Node</TT>
specified by <TT>RemoveNode</TT>.
<P>
The <TT>World</TT> class also contains
a list of pointers to <TT>Node</TT>
objects in the private section of the definition, which is used
to store the scene graph. However, as you'll see when you implement
the <TT>World</TT> class, this information
isn't necessary to interface the class with Java-you really have
to know only the publicly available methods and variables for
the class.
<HR>
<BLOCKQUOTE>
<B>Listing 32.6. </B><TT><B></TT>World</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class World {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
AttachNode (Node* theNode);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Node* DetachNode (Node* RemoveNode);<BR>
<BR>
&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Node** NodeList;<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<H4><B>The My3D </B><TT><B></TT>Node</FONT></B></TT><B>
Object</B></H4>
<P>
The next class in the My3D C++ class library is the <TT>Node</TT>
class, shown in Listing 32.7. This class contains the mechanisms
necessary to give an object in your <TT>World</TT>
a location. This superclass is the base class for all objects
that appear in the rendered 3D scenes. The class contains only
two accessor methods, <TT>SetLocation</TT>
and <TT>GetLocation</TT>, which are
used to set and retrieve the position of the node in space. The
data structure <TT>PointFW_t</TT>
is used to encapsulate these points (see List-ing 32.8).
<HR>
<BLOCKQUOTE>
<B>Listing 32.7. </B><TT><B></TT>Node</FONT></B></TT><B>
C++ class definition.</B>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<TT>class Node {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public:
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
void SetLocation (PointFW_t&amp; loc);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; PointFW_t GetLocation();<BR>
<BR>
&nbsp;&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; PointFW_t theLocation;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 32.8. </B><TT><B></TT>PointFW_t</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>typedef struct PointFW_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float x;<BR>
&nbsp;&nbsp;float y;<BR>
</TT>&nbsp;<TT>&nbsp;float z;<BR>
&nbsp;&nbsp;float w;<BR>
<BR>
} PointFW_t;</TT>
</BLOCKQUOTE>
<HR>
<H4><B>The My3D </B><TT><B></TT>Light</FONT></B></TT><B>
Object</B></H4>
<P>
The <TT>Light</TT> class is a subclass
of <TT>Node</TT>, which makes it attachable
within your <TT>World</TT> scenes
(see Listing 32.9). Because it is a subclass of <TT>Node</TT>,
it has position. The <TT>Light</TT>
object models a light in the scene by adding a direction and color
to the subclass with the associated accessors, <BR>
<TT>Set/GetDirection()</TT> and <TT>Set/GetColor()</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 32.9. </B><TT><B></TT>Light</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Light : public Node {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
void SetDirection (PointF_t&amp; dir);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; PointF_t&amp; GetDirection();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; void SetColor (ColorF_t&amp; theColor);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
ColorF_t&amp; GetColor();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;private:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
PointF_t&nbsp;&nbsp;TheDirection;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ColorF_t&nbsp;&nbsp;TheColor;<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<H4><B>The My3D </B><TT><B></TT>PointF_t</FONT></B></TT><B>
and </B><TT><B></TT>ColorF_t</FONT></B></TT><B>
Objects</B></H4>
<P>
This class also introduces two new data structures, <TT>PointF_t</TT>
and <TT>ColorF_t</TT>, as shown in
Listings 32.10 and 32.11. The <TT>PointF_t</TT>
data structure encapsulates a vector that points in the direction
<TT>&lt;x,y,z&gt;</TT>. The <TT>ColorF_t</TT>
type represents a color with the red, green, and blue components
<TT>&lt;r,g,b&gt;</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 32.10. </B><TT><B></TT>PointF_t</FONT></B></TT><B>
C++ </B><TT><B></TT>struct</FONT></B></TT><B>
definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>typedef struct PointF_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float x;<BR>
&nbsp;&nbsp;float y;<BR>
</TT>&nbsp;<TT>&nbsp;float z;<BR>
<BR>
} PointF_t;</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 32.11. </B><TT><B></TT>ColorF_t</FONT></B></TT><B>
C++ </B><TT><B></TT>struct</FONT></B></TT><B>
definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>typedef struct ColorF_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float r;<BR>
&nbsp;&nbsp;float g;<BR>
</TT>&nbsp;<TT>&nbsp;float b;<BR>
<BR>
} ColorF_t;</TT>
</BLOCKQUOTE>
<HR>
<H4><B>The My3D </B><TT><B></TT>Geometry</FONT></B></TT><B>
Object</B></H4>
<P>
The final class in your My3D graphics library (if only real 3D
graphics class libraries could be so simple!) is the <TT>Geometry</TT>
class. This class is also a subclass of <TT>Node</TT>,
which enables the class library user to specify a geometric object
in the graphics scene. The constructor for the <TT>Geometry</TT>
class takes all the information necessary to specify the object
in space: the number of polygons and vertices, the points in space
for all the vertices and the vertex normals, and the ordering
of which points go with which polygon.
<P>
There are also two methods to control rotations and scaling around
its central location specified with <TT>SetLocation()</TT>
from the <TT>Node</TT> class: <TT>RotateObject()</TT>
and <TT>ScaleObject()</TT>. The <TT>Geometry</TT>
class is shown in Listing 32.12.
<HR>
<BLOCKQUOTE>
<B>Listing 32.12. </B><TT><B></TT>Geometry</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Geometry : public Node {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;public:
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
Geometry(long INnPolygons, long INnVertices,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointF_t*
INpVertices, PointF_t* INpNormals,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long*
INVerOrder);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
void RotateObject(double theta, PointF_t* RotationAxis);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; void ScaleObject(PointF_t* ScaleFactors);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; long nPolygons;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
long nVertices;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; PointF_t* pVertices;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
PointF_t* pNormals;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; PointF_t* pFacets;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
PointF_t* pTexture;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ColorFA_t* pColors;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
long* VerOrder;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><B>The </B><TT><B><FONT SIZE=4 >InterfaceObject</FONT></B></TT><B><FONT SIZE=4>
Base Class</FONT></B></H3>
<P>
With that definition finished, you can move on to the real task
of building Java objects that interface with these C++ classes.
Before you can start developing interface classes that correspond
one-to-one with C++ classes, however, you first need a class that
encapsulates all the interface information that you need about
your C++ class, the <TT>InterfaceObject</TT>
class (see Listing 32.13).
<HR>
<BLOCKQUOTE>
<B>Listing 32.13. Java </B><TT><B></TT>InterfaceObject</FONT></B></TT><B>
definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package My3D;<BR>
<BR>
public class InterfaceObject {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Returns an
ordinal number that uniquely identifies the object.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public int KindOf()
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (ObjKindOf);<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Returns True
if the object type passed to IsOf matches this<BR>
&nbsp;&nbsp;// object's type.<BR>
<BR>
&nbsp;&nbsp;public boolean IsOf(int k) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (k == ObjKindOf) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(true);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public int hCPPObj;<BR>
</TT>&nbsp;<TT>&nbsp;public int ObjKindOf;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;static {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.load(&quot;my3d.dll&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>InterfaceObject</TT> class
will be the base for all your object classes. It contains two
methods to help with object identification (you'll see where this
is useful in a few sections): <TT>KindOf()</TT>
and <TT>IsOf()</TT>. <TT>KindOf()</TT>
is used to access the object type. This object type is a constant
that uniquely identifies the object's type. The <TT>IsOf()</TT>
method tests the object type passed to it, to see whether it is
the same as this object's type, by using the internal constant
as a check.
<P>
The <TT>InterfaceObject</TT> class
also encapsulates two variables: <TT>hCPPObj</TT>
and <TT>ObjKindOf</TT>. <TT>ObjKindOf</TT>
contains the ordinal type of the object. <TT>hCPPObj</TT>
contains a handle to the parallel C++ instantiation of this object.
You'll see how both these variables are set in the next section.
<H3><B>The My3D </B><TT><B><FONT SIZE=4 >World</FONT></B></TT><B><FONT SIZE=4>
Java Object Definition</FONT></B></H3>
<P>
Let's start interfacing your library to Java with the <TT>World</TT>
class; the implementation of the Java class is shown in Listing
32.14.
<HR>
<BLOCKQUOTE>
<B>Listing 32.14. </B><TT><B></TT>World</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package My3D;<BR>
<BR>
public class World extends InterfaceObject {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public native
void constructor();<BR>
&nbsp;&nbsp;public World() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;constructor();
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public native void finalize();<BR>
<BR>
&nbsp;&nbsp;public native void AttachNode (Node theNode);<BR>
</TT>&nbsp;<TT>&nbsp;public native
Node DetachNode (Node afterNode);<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Your first impression of this class should be that it looks very
similar to the C++ one. This is good! However, you have to learn
a few more things about native implementation before this illusion
can become a reality for your Java class library users.
<H3><B>The My3D </B><TT><B><FONT SIZE=4 >World</FONT></B></TT><B><FONT SIZE=4>
Constructor Interface</FONT></B></H3>
<P>
Let's start at the beginning, with the Java <TT>World</TT>
class constructor. As you saw in Listing 32.14, the <TT>World</TT>
Java implementation class calls a native constructor in its constructor.
You want your native constructor to accomplish the following tasks:
<OL>
<LI>Instantiate the parallel C++ object-in this case, a C++ World
object.
<LI>Store the pointer to this instantiated class and store an
integer reference to the array position of this pointer in the
Java interface object (which is referred to as the handle in the
rest of this section).
<LI>Initialize the reference counter for this pointer to 1, to
indicate that only one Java object is using it.
<LI>Remember what kind of object it is by saving the class type
as a constant in the Java object.
</OL>
<P>
The native constructor implementation for the <TT>World</TT>
class is shown in Listing 32.15.
<HR>
<BLOCKQUOTE>
<B>Listing 32.15. </B><TT><B></TT>World</FONT></B></TT><B>
interface constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;
My3D_World_AllocLength = 0;<BR>
&nbsp;&nbsp;#define&nbsp;&nbsp;INITIAL_My3D_World_ALLOC 2<BR>
<BR>
&nbsp;&nbsp;World**&nbsp;&nbsp;My3D_World_ObjPtr = NULL;<BR>
</TT>&nbsp;<TT>&nbsp;long*&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_ObjRef
= NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; constructor()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Instantiates
the C++ World class and sets the handle<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in
the Java object.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void My3D_World_constructor(struct
HMy3D_World *jthis) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Check to see if the initial allocation for the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// World class has been done yet.&nbsp;&nbsp;If
not, allocate<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
the necessary data structures.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(My3D_World_AllocLength == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_AllocLength =<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_Resize(INITIAL_My3D_World_ALLOC);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Search for an empty position (empty
position == NULL).<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long pos;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( pos=0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pos
!= My3D_World_AllocLength) &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(My3D_World_ObjPtr[pos]
!= NULL);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos++
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (pos == My3D_World_AllocLength) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All allocated positions
are full.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
So use exponential allocation to create some more.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_AllocLength
=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_Resize(My3D_World_AllocLength*2);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_World_ObjPtr[pos]
= new World();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Stub for handling out of memory condition.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle as desired in your implementation.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;assert (My3D_World_ObjPtr[pos] != NULL);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Increment Reference counter.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_IncRefCntr(pos);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Store handle (== position in array)
for this<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
object.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(jthis)-&gt;hCPPObj
= pos;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H4><B>The My3D </B><TT><B></TT>World Resize</FONT></B></TT><B>
Function</B></H4>
<P>
In every instantiable class that you consider in this chapter,
your interface functions maintain a list of pointers to all the
C++ objects you have instantiated indirectly by instantiating
their Java interface class. In the previous constructor, the first
statement checks to see whether this list needs to be initialized:
<BLOCKQUOTE>
<TT>if (My3D_World_AllocLength == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_AllocLength =<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_Resize(INITIAL_My3D_World_ALLOC);
<BR>
}</TT>
</BLOCKQUOTE>
<P>
<TT>My3D_World_Resize</TT> is a helper
function that is responsible for increasing and decreasing the
amount of allocation for the pointer list to <TT>World</TT>
objects. There is a similar function for each of the interface
files you consider in this chapter. The code for the <TT>My3D_World</TT>_<TT>Resize</TT>
function is shown in Listing 32.16.
<HR>
<BLOCKQUOTE>
<B>Listing 32.16. </B><TT><B></TT>My3D_World_Resize</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; Resize()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Resizes
the array of World pointers.<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frequent
callers should use a<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exponential
size increase (ie. 2x or 4x) to<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduce
memory thrashing.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;long My3D_World_Resize(long
newsize) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;World**
NewObjPtr = new World* [newsize];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long*&nbsp;&nbsp;&nbsp;NewRefPtr = new
long[newsize];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long i;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i != My3D_World_AllocLength;
i++) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NewObjPtr[i] = My3D_World_ObjPtr[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewRefPtr[i] = My3D_World_ObjRef[i];
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
(; i != newsize; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewObjPtr[i] = NULL;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NewRefPtr[i] = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;delete My3D_World_ObjPtr;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;delete
My3D_World_ObjRef;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_World_ObjPtr
= NewObjPtr;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_ObjRef = NewRefPtr;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (newsize);<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Unused pointers in the C++ object array are set to <TT>NULL</TT>
in the <TT>My3D_World_Resize</TT>
function. After checking in the interface constructor code to
see whether the pointer list has been initialized, the constructor
next tries to find an empty slot in the pointer list:
<BLOCKQUOTE>
<TT>long pos;<BR>
<BR>
for ( pos=0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (pos != My3D_World_AllocLength) &amp;&amp;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
(My3D_World_ObjPtr[pos] != NULL);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos++ )<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;;</TT>
</BLOCKQUOTE>
<P>
The loop quits before it reaches <TT>My3D_World_AllocLength</TT>
if it does find an empty slot. If it doesn't, the constructor
allocates new pointer space:
<BLOCKQUOTE>
<TT>if (pos == My3D_World_AllocLength) {
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// All allocated
positions are full.<BR>
&nbsp;&nbsp;// So use exponential allocation to create some more.
<BR>
<BR>
&nbsp;&nbsp;My3D_World_AllocLength =<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_Resize(My3D_World_AllocLength*2);
<BR>
}</TT>
</BLOCKQUOTE>
<P>
Notice that it allocates pointer space exponentially-every time
the constructor is forced to resize the pointer list, it does
so to twice the size of the last pointer list size. This helps
reduce the number of times that memory allocation is needed for
large object databases, without wasting memory for small object
databases. Because memory allocation is such an expensive event,
you should implement this or an equivalent scheme in your interface
code, unless the size of the pointer array is known beforehand
or the number of objects typically needed is very small (less
than 8).
<P>
With an empty spot on the list found for the instantiated pointer,
the constructor allocates a <TT>World</TT>
object and stores it in the list:
<BLOCKQUOTE>
<TT>My3D_World_ObjPtr[pos] = new World();</TT>
</BLOCKQUOTE>
<P>
The <TT>World</TT> object's constructor
doesn't take any arguments, and for that reason, none are passed
into the <TT>World</TT> constructor.
If your constructor does take arguments, this is where you should
change your routines to pass them in. If your class contains multiple
constructors, you have to create multiple constructor interfaces
in your implementation file to handle each variant-ugly, but because
C does not have any functionality such as overloading in C++,
it is the only way to accomplish this.
<P>
Directly following this allocation is an <TT>assert</TT>
function call that checks to make sure that the memory allocation
occurred safely. If it didn't, the library will fail with the
assertion. For your library, you should replace this assertion
statement so that your program can handle this problem in a graceful
manner.
<H4><B>The Reference Counter Functions</B></H4>
<P>
As you'll see in later sections, the underlying C++ library can
sometimes return pointers to objects during calls to C++ methods.
 To mimic this operation in your Java library, you will want to
add functionality to translate this pointer to one of our Java
objects. Because of this, multiple Java interface objects can
refer to a single C++ pointer, so you need to maintain a reference
counter to keep track of how many objects have a copy:
<BLOCKQUOTE>
<TT>My3D_World_IncRefCntr(pos);</TT>
</BLOCKQUOTE>
<P>
This reference counter is implemented as an array of integers
called <TT>My3D_World_ObjRef.</TT>
The reference count for an object is stored in the same position
in the array as its pointer is in <TT>My3D_World_ObjPtr</TT>,
or equivalently, at the <TT>hCPPObj</TT>
position stored in the Java interface object. The implementation
of the <TT>IncRefCntr</TT> function
is shown in Listing 32.17.
<HR>
<BLOCKQUOTE>
<B>Listing 32.17. </B><TT><B></TT>IncRefCntr</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; IncRefCntr()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Performs
automatic memory management.<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increments
the reference counter<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
the World object.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;void My3D_World_IncRefCntr(long ThehCPPObj) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_ObjRef[ThehCPPObj]++;<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DecRefCntr</TT> function,
used when a Java interface object using a pointer moves out of
scope, decrements the reference counter. It then checks to see
whether any other Java objects are still using this pointer, indicated
by the reference count being greater than <TT>0</TT>.
If not, <TT>DecRefCntr</TT> deletes
the underlying object. The implementation of <TT>DecRefCntr</TT>
is shown in Listing 32.18.
<HR>
<BLOCKQUOTE>
<B>Listing 32.18. </B><TT><B></TT>DecRefCntr</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; DecRefCntr()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Performs
automatic memory management.<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When
the number of objects referencing<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the
object equals zero, the object is<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deallocated.
<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void My3D_World_DecRefCntr(long
ThehCPPObj) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_World_ObjRef[ThehCPPObj]--;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(My3D_World_ObjRef[ThehCPPObj] == 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_ObjPtr[ThehCPPObj]-&gt;Destroy();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The final statement in the <TT>World</TT>
constructor assigns the position in the pointer list to the Java
interface object's <TT>hCPPObj</TT>
variable so that when a C++ object pointer is needed, it is available
by lookup in the pointer table. This completes all the tasks that
you set out to do in your <TT>World</TT>
constructor.
<H3><B>Passing a Call from Java to C++</B></H3>
<P>
Next, let's focus on how you implement the methods within the
Java <TT>World</TT> Interface. This
task really boils down to translating a call to one of these Java
methods to an equivalent call with the same data (but possibly
in a differing C++ format) to the C++ version of the class.
<P>
Shown in Listing 32.19 is the implementation for the <TT>AttachNode</TT>
method.
<HR>
<BLOCKQUOTE>
<B>Listing 32.19. </B><TT><B></TT>AttachNode</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_World_AttachNode()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Routes
the Java call from the Java class method<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AttachNode
to the C++ class method AttachNode for the<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiation
handle passed in hthis.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;void My3D_World_AttachNode (<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HMy3D_World&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*hthis,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HMy3D_Node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *hNode)
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_World_ResolvePtr(hthis)-&gt;AttachNode(
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Node_ResolvePtr(hNode)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;);
<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>AttachNode</TT> function prototype
should look very familiar to you from the last chapter. This function
is passed the Java <TT>World</TT>
object handle as the first parameter and a handle to the <TT>Node</TT>
to be attached as the second. You haven't explored the interface
constructor of the <TT>Node</TT> object
yet, but you really don't need to-it is completely analogous to
the one you saw for the <TT>World</TT>
object. Literally, only the names have been changed.
<P>
The body of the <TT>AttachNode</TT>
native method contains only one statement. This call to <TT>My3D_World_ResolvePtr</TT>
looks up the <TT>World</TT> C++ pointer
referenced by statement and calls this <TT>World</TT>
object's <TT>AttachNode</TT> method
with the <TT>Node</TT> object referenced
by the <TT>hNode</TT> and resolved
by using <TT>My3D_Node_ResolvePtr</TT>.
<H4><B>Using </B><TT><B></TT>My3D_xxxx_ResolvePtr</FONT></B></TT>
</H4>
<P>
The functions <TT>My3D_World_ResolvePtr</TT>
and <TT>My3D_Node_ResolvePtr</TT>
referenced earlier are used to find the C++ pointers to the <TT>Node</TT>
and <TT>World</TT> objects. These
functions take a handle to an <TT>InterfaceObject</TT>
and return the C++ pointer to the Java interface object. They
do this translation using the <TT>hCPPObj</TT>
handle for the <TT>World</TT> class.
The implementation looks as shown in Listing 32.20.
<HR>
<BLOCKQUOTE>
<B>Listing 32.20. </B><TT><B></TT>ResolvePtr</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; ResolvePtr()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Takes
a handle to the Java World class<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and
resolves it to the associated 3DW<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++
pointer.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;World* My3D_World_ResolvePtr(struct HMy3D_World *jthis)
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; return( My3D_World_ObjPtr[unhand(jthis)-&gt;hCPPObj]
);<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
This is a very simple function. It retrieves the object handle
stored in <TT>hCPPObj</TT> and returns
the <TT>World</TT> object pointer
referenced by it. You'll see a more complicated example of this
function when you consider the implementation of this function
for an abstract class such as the <TT>Node</TT>
class.
<P>
The <TT>DetachNode</TT> method object
is the final explicit method needed for the <TT>World</TT>
object. Its implementation is shown in Listing 32.21.
<HR>
<BLOCKQUOTE>
<B>Listing 32.21. </B><TT><B></TT>DetachNode</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_World_DetachNode()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Routes
the Java call from the Java class method<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AttachNode
to the C++ class method DetachNode for the<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiation
handle passed in hthis.&nbsp;&nbsp;It takes the<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returned
CPPNode and translates it back into a Java<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle.
<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;struct HMy3D_Node* My3D_World_DetachNode(<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HMy3D_World *hthis,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HMy3D_Node *hNode) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Node* CPPNode;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPNode = My3D_World_ResolvePtr(hthis)-&gt;DetachNode(
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
My3D_Node_ResolvePtr(hNode)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct HMy3D_Node *hNode;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ClassClass
*ccNode = NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ccNode
= FindClass(NULL, &quot;My3D/Node\0&quot;, TRUE);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(ccNode
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;hNode
= (struct HMy3D_Node*)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute_java_constructor(NULL,&quot;My3D/Node\0&quot;,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccNode,&quot;()&quot;);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(hNode
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_Node_PtrEmul(CPPNode,
hNode);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return(hNode);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
There are a lot of new things in the implementation of the <TT>My3D_World_DetachNode</TT>
function. First, it returns a class that isn't one of the standard
set of objects available in Java. This is the main reason that
the function is so complicated. In the last chapter, you learned
how to return a <TT>java.lang.String</TT>
class. However, the <TT>String</TT>
class has a Java interpreter call, <TT>makeJavaString</TT>,
that enables you to instantiate a <TT>String</TT>
for the return. Because <TT>Node</TT>
is a developer-defined class and is not from the Java class library,
there is no equivalent call for <TT>Node</TT>
in the Java interpreter API. Instead, you need to learn how to
use the interpreter calls to instantiate and return arbitrary
Java objects.
<P>
The first two lines of the function are pretty straightforward.
The function resolves the pointer for the <TT>World</TT>
object and the passed <TT>Node</TT>
object and calls the <TT>DetachNode</TT>
method. The <TT>DetachNode</TT> method
returns a pointer to the <TT>Node</TT>
detached, which it stores in <TT>CPPNode</TT>.
<P>
Now, you want to find the handle of the Java object that corresponds
to the returned C++ pointer of the detached <TT>Node</TT>
and create a <TT>Node</TT> handle
that incapsulates this handle to return.
<P>
Before you instantiate a Java <TT>Node</TT>
class, you need to fill out a <TT>ClassClass</TT>
structure (discussed in <A HREF="ch31.htm" >Chapter 31</A>, &quot;The
Native Method Interface&quot;). You did this in <TT>My3D_World_DetachNode</TT>
using the following statement:
<BLOCKQUOTE>
<TT>ccNode = FindClass(NULL, &quot;My3D/Node\0&quot;,
TRUE);</TT>
</BLOCKQUOTE>
<P>
This statement tells the Java interpreter to look up the class
information for the <TT>My3D.Node</TT>
Java class. The first parameter, for which you passed <TT>NULL</TT>,
enables you to specify an interpreter to service this request
through an <TT>ExecEnv*</TT> (the
type <TT>ExecEnv</TT> is defined in
<TT>interpreter.h</TT>, but an understanding
of its contents is not necessary for this discussion). Passing
<TT>NULL</TT> indicates that you want
to use the default interpreter to look up this information. Unless
you are writing native programs that use multiple interpreters
(you know if you are-it's a painful experience), you can ignore
this parameter and pass <TT>NULL</TT>.
<P>
The third parameter tells the interpreter whether to resolve the
name passed into <TT>FindClass</TT>.
You should always pass <TT>TRUE</TT>
for this parameter. Sun hasn't documented exactly what this function
does if you don't, so as of this writing, there is no definitive
reason.
<P>
Next, you want to instantiate a Java <TT>Node</TT>
that you can use to return the C++ <TT>Node</TT>
returned <BR>
from the <TT>DetachNode</TT> method.
To do this, you use the Java interpreter function <TT>execute_java_constructor</TT>:
<BLOCKQUOTE>
<TT>hNode = (struct HMy3D_Node*)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute_java_constructor(NULL,&quot;My3D/Node\0&quot;,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccNode,
&quot;()&quot;);</TT>
</BLOCKQUOTE>
<P>
The <TT>execute_java_constructor</TT>
function takes an <TT>ExecEnv*</TT>
as the first parameter and the name of the class as the second,
just as the <TT>FindClass</TT> function
call did. For the third parameter, you should pass the <TT>ClassClass</TT>
structure returned by <TT>FindClass</TT>
in the last step.
<P>
The final parameter specifies the signature of the <TT>Node</TT>
constructor you wish to call. This signature indicates the types
that you wish to pass and receive from the invoked Java method.
The previous passed signature (<TT>&quot;()&quot;</TT>)
is the simplest-a constructor that accepts no parameters and returns
nothing. All constructors do not have a return type, but if you
had a constructor in the <TT>Node</TT>
class that accepted an <TT>int</TT>
as a parameter for the constructor, its constructor would have
been <TT>&quot;(I)&quot;</TT>. The
return type is specified after the closing parenthesis for methods
that return values. For this hypothetical constructor that accepts
an integer, you pass the integer parameter for the constructor
as the fifth parameter. This parameter list is unbounded, like
the parameter list for <TT>printf</TT>
in the C language, so to pass in additional parameters, you merely
keep adding them to the list. For example, the following passes
a <TT>4</TT> to a hypothetical <TT>Node</TT>
constructor that accepts an integer.
<BLOCKQUOTE>
<TT>hNode = (struct HSolidCoffee_PointFW_t*)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute_java_constructor(NULL,&quot;My3D/Node\0&quot;,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccNode,&quot;(I)&quot;,
4);</TT>
</BLOCKQUOTE>
<P>
Now that you have a Java <TT>Node</TT>
instantiated, you want to do the following:
<OL>
<LI>Find the Java <TT>Node</TT> handle
that corresponds to the C++ <TT>Node</TT>
pointer returned by <TT>DetachNode</TT>
and set <TT>hNode</TT>'s <TT>hCPPObj</TT>
to it.
<LI>Increment the reference counters to the C++ pointer and decrement
the reference counter for the current <TT>hNode</TT>
pointer.
<LI>Copy the handle into the <TT>hNode</TT>
object so that it points to the correct object.
</OL>
<P>
All of this is done by the function <TT>PtrEmul</TT>,
as used in the <TT>My3D_World_DetachNode</TT>
function:
<BLOCKQUOTE>
<TT>My3D_Node_PtrEmul(CPPNode, hNode);</TT>
</BLOCKQUOTE>
<P>
The <TT>My3D_Node_PtrEmul</TT> implementation
is shown in Listing 32.22. It emulates a pointer reference system
for your interface code.
<HR>
<BLOCKQUOTE>
<B>Listing 32.22. </B><TT><B></TT>Node PtrEmul</FONT></B></TT><B>
function definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_Node_PtrEmul()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Takes
the passed Node*, uses My3D_Node_FindHandle<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to
find its handle and assigns this to the passed<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hWorld
handle. In doing so, it adjusts the reference<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counters
so that the system can keep track of the<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number
of outstanding pointers.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;void My3D_Node_PtrEmul(Node*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pNode,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
struct HMy3D_Node* hNode) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;long
hRetNode;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;hRetNode
= My3D_Node_FindHandle(pNode);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_Node_IncRefCntr(hRetNode);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_Node_DecRefCntr(unhand(hNode)-&gt;hCPPObj);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(hNode)-&gt;hCPPObj
= hRetNode;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>My3D_Node_PtrEmul</TT> function
is relatively straightforward (you learn the internals later in
this chapter). For now, all you need to know is that <TT>My3D_Node_FindHandle</TT>
returns the handle to the <TT>Node</TT>
object (or any of its subclasses) to which the C++ pointer refers.
<P>
After finding the corresponding handle for the <TT>Node</TT>
C++ object, the function increments its reference count, because
another Java <TT>Node</TT> object
will now be using this pointer. Then, the function decrements
the reference count for the target's current <TT>Node</TT>
C++ object, because it will no longer be referenced by this Java
<TT>Node</TT>. Finally, the function
copies the handle into the target, completing the copy.
<P>
With that done, you now have a handle to a Java <TT>Node</TT>
object that refers to the <TT>Node</TT>
returned by <TT>DetachNode</TT>. To
complete the interface function, you merely return this handle
to the caller, which is done with the last statement of the function.
<H3><B>The World's </B><TT><B><FONT SIZE=4 >FindHandle</FONT></B></TT><B><FONT SIZE=4>
Function</FONT></B></H3>
<P>
To complete the discussion of the Java <TT>World</TT>
interface object, let's look at its <TT>My3d_World_FindHandle</TT>
implementation. The <TT>My3D_World_FindHandle</TT>
function is responsible for taking a pointer to a <TT>World</TT>
object and translating it back into a handle that can be used
to reference the <TT>World</TT>'s
<TT>My3D_World_ObjPtr</TT> array.
The implementation for this is shown in Listing 32.23.
<HR>
<BLOCKQUOTE>
<B>Listing 32.23. </B><TT><B></TT>World FindHandle</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; FindHandle()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Takes
a pointer to a World class instantiation and<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;looks
up the associated Java handle to the object.<BR>
</TT>&nbsp;<TT>&nbsp;**<BR>
&nbsp;&nbsp;** IMPORTANT NOTE:&nbsp;&nbsp;To keep this code concise,
a linear search<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;algorithm
was used.&nbsp;&nbsp;For class libraries that<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have
methods that return many pointers per unit<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of
execution time, this routine should be<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated
with a searching algorithm that resolves<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in
much less time than O(n).&nbsp;&nbsp;We would suggest a<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashing
algorithm.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;long My3D_World_FindHandle(World
*FindWorld) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;long
pos;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
( pos=0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pos !=
My3D_World_AllocLength) &amp;&amp;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(My3D_World_ObjPtr[pos]
!= FindWorld); pos++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Stub for appropriate handling of pointer
not<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
found errors.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert
(pos != My3D_World_AllocLength);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
(pos);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Because in the 3D graphics library you expect there will be only
a small number of pointer lookups using the <TT>FindHandle</TT>
function, this lookup function is written using a simple linear
search function. If a large number of lookups are anticipated,
this function should be rewritten with a hashing search method
to reduce its performance impact.
<H3><B>The </B><TT><B><FONT SIZE=4 >World's Finalize</FONT></B></TT><B><FONT SIZE=4>
Method</FONT></B></H3>
<P>
The final interface function for the <TT>World</TT>
class is the interface for the <TT>My3d_World_finalize</TT>
method. If you are not familiar with this method, it is called
when the Java garbage collector needs to dispose of an object
because it has moved out of scope. This method enables the object
to clean up after itself and perform any last minute maintenance
tasks before the allocation for its data is freed. For your Java
interface objects, you use this function to decrement the reference
counter for the indicated object to keep your reference count
coherent. The implementation of <TT>My3D_World_finalize</TT>
is shown in Listing 32.24.
<HR>
<BLOCKQUOTE>
<B>Listing 32.24. </B><TT><B></TT>World finalize</FONT></B></TT><B>
implementation definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; finalize()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Performs
automatic memory management.<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When
the number of objects referencing<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the
object equals zero, the object is<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deallocated.
<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void My3D_World_finalize(struct
HMy3D_World *jthis) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_World_DecRefCntr(unhand(jthis)-&gt;hCPPObj);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><B>The </B><TT><B><FONT SIZE=4 >Node</FONT></B></TT><B><FONT SIZE=4>
Java Interface Object</FONT></B></H3>
<P>
The next interface implementation is the interface to the <TT>Node</TT>
object. Listing 32.25 shows the Java object definition. It doesn't
look much different from its C++ counterpart, which is helpful
for any converts you might have from your C++ product.
<HR>
<BLOCKQUOTE>
<B>Listing 32.25. </B><TT><B></TT>Node</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Node extends InterfaceObject{
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public native
void SetLocation (PointFW_t loc);<BR>
&nbsp;&nbsp;public native PointFW_t GetLocation();<BR>
<BR>
&nbsp;&nbsp;public native finalize();<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
You need to define the Java version of the C++ <TT>PointFW_t</TT>
structure so that you can present the implementation of the <TT>SetLocation</TT>
and <TT>GetLocation</TT> methods.
The Java version is very similiar to the C++ version, and its
implementation is shown in Listing 32.26.
<HR>
<BLOCKQUOTE>
<B>Listing 32.26. </B><TT><B></TT>PointFW_t</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class PointFW_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float x;<BR>
&nbsp;&nbsp;float y;<BR>
</TT>&nbsp;<TT>&nbsp;float z;<BR>
&nbsp;&nbsp;float w;<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
The native implementation of the <TT>SetLocation</TT>
method is shown in Listing 32.27.
<HR>
<BLOCKQUOTE>
<B>Listing 32.27. </B><TT><B></TT>SetLocation</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_Node_SetLocation()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Routes
the Java call from the Java class method<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetLocation
to the C++ class method SetLocation for<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the
instantiation handle passed in hthis.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;void My3D_Node_SetLocation (struct HMy3D_Node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*hthis,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HMy3D_PointFW_t *hLocation) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointFW_t
CPPLocation;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;CPPLocation.x
= unhand(hLocation)-&gt;x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPLocation.y = unhand(hLocation)-&gt;y;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;CPPLocation.z
= unhand(hLocation)-&gt;z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPLocation.w = unhand(hLocation)-&gt;w;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_Node_ResolvePtr(hthis)-&gt;SetLocation(CPPLocation);
<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This implementation is very similiar to the <TT>AttachNode</TT>
interface function of the last chapter, but because the <TT>PointFW_t</TT>
class is a simple C++ object, you create a C++ <TT>PointFW_t</TT>
structure with each invocation of <TT>SetLocation</TT>
to pass the location into the C++ method instead of maintaining
a list of <TT>PointFW_t</TT> pointers.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You explicitly copy the members of the structure instead of dereferencing the pointer because there exists the chance of a mismatch between Java's representation of the <TT>PointFW_t</TT> class and C++'s representation. Specifically, the order of the 
elements of C++'s representation may be the reverse of the Java implementation, yielding <TT>SetLocation (&lt;w,z,y,x&gt;)</TT> when C++'s implementation may be <TT>SetLocation (&lt;x,y,z,w&gt;)</TT>. Although the correlation is one-to-one with Visual C++ 
4.0 and JDK 1.0, this isn't set in stone, and the safe programming practice is to assume no correlation and copy them one by one. In any case, compared to the overhead of calling the native method, the performance impact of these four copies is neglible.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The native implementation of the <TT>GetLocation</TT>
method is shown in Listing 32.28.
<HR>
<BLOCKQUOTE>
<B>Listing 32.28. </B><TT><B></TT>GetLocation</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_Node_GetLocation()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Returns
the current location of this node.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;struct HMy3D_PointFW_t* My3D_Node_GetLocation() {
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointFW_t CPPLocation;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPLocation = My3D_Node_ResolvePtr(hthis)-&gt;GetLocation();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct HMy3D_PointFW_t *hLocation;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ClassClass
*ccNode = NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ccNode
= FindClass(NULL, &quot;My3D/PointFW_t\0&quot;, TRUE);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(ccNode
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;hLocation
= (struct HSolidCoffee_PointFW_t*)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
execute_java_constructor(NULL, &quot;My3D/PointFW_t\0&quot;,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccNode,&quot;()&quot;);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(hLocation
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(hLocation)-&gt;x
= CPPLocation.x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(hLocation)-&gt;y = CPPLocation.y;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(hLocation)-&gt;z
= CPPLocation.z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(hLocation)-&gt;w = CPPLocation.w;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return(hLocation);<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The implementation of <TT>GetLocation</TT>
is very similiar to the <TT>DetachNode</TT>
implementation. The only difference is the deletion of the <TT>PtrEmul</TT>
call and its replacement with a straight element-by-element copy
of the returned <TT>PointFW_t</TT>
location.
<P>
Before you leave the <TT>Node</TT>
object, notice that the <TT>Node</TT>
Java object doesn't have a constructor. This is important, because
it means that no C++ <TT>Node</TT>
objects can be instantiated. This was intended in the C++ design,
because only the <TT>Light</TT> and
<TT>Geometry</TT> objects were designed
to be instantiated. You'll see how this works into the design
when you consider the implementation of the <TT>My3D_World_PtrEmul</TT>
function later in this chapter. Before you do that, let's lay
the groundwork by discussing the two subclasses of <TT>Node</TT>:
<TT>Light</TT> and <TT>Geometry</TT>.
<H3><B>The </B><TT><B><FONT SIZE=4 >Light</FONT></B></TT><B><FONT SIZE=4>
Java Interface Object</FONT></B></H3>
<P>
Shown in Listing 32.29 is the Java implementation for the interface
class to the <TT>Light</TT> object.
Because <TT>Light</TT> is a subclass
of <TT>Node</TT> in the C++ definition,
it is also a subclass in the Java version. Whenever possible,
you should always strive to keep your object hierarchies the same
between your Java and C++ versions to prevent difficulties in
interfacing the two libraries and preserve the same hierarchy
with which your C++ users are familiar.
<P>
Because it can be instantiated, <TT>Light</TT>
does have a constructor. The implementation of this constructor
follows nearly exactly the same format as the <TT>World</TT>
constructor.
<P>
The <TT>SetDirection</TT> and <TT>GetDirection</TT>
methods also introduce a new class, <TT>PointF_t</TT>.
The definition of this class is very similar to the <TT>PointFW_t</TT>
class and is shown in Listing 32.30.
<HR>
<BLOCKQUOTE>
<B>Listing 32.29. </B><TT><B></TT>Light</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Light extends Node {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;private native
void constructor();<BR>
&nbsp;&nbsp;public Light() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;constructor();
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public native void finalize();<BR>
<BR>
&nbsp;&nbsp;public void SetDirection(PointF_t dir);<BR>
</TT>&nbsp;<TT>&nbsp;public void PointF_t
GetDirection();<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 32.30. </B><TT><B></TT>PointF_t</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class PointF_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float x;<BR>
&nbsp;&nbsp;float y;<BR>
</TT>&nbsp;<TT>&nbsp;float z;<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
The native implementation of the <TT>SetDirection</TT>
and <TT>GetDirection</TT> interfaces
for the <TT>Light</TT> class are shown
in Listing 32.31.
<HR>
<BLOCKQUOTE>
<B>Listing 32.31. </B><TT><B></TT>SetDirection</FONT></B></TT><B>
and </B><TT><B></TT>GetDirection</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; My3D_Light_SetDirection()
<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Routes
the Java call from the Java class method<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetDirection
to the C++ class method SetDirection for<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the
instantiation handle passed in hthis.<BR>
&nbsp;&nbsp;*/<BR>
<BR>
&nbsp;&nbsp;void My3D_Light_SetDirection (struct HMy3D_Light&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*hthis,
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HMy3D_PointF_t *hDirection) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointF_t
CPPDirection;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;CPPDirection.x
= unhand(hDirection)-&gt;x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPDirection.y = unhand(hDirection)-&gt;y;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;CPPDirection.z
= unhand(hDirection)-&gt;z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CPPDirection.w = unhand(hDirection)-&gt;w;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_Light_ResolvePtr(hthis)-&gt;SetDirection(CPPDirection);
<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;/*<BR>
</TT>&nbsp;<TT>&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp;
My3D_Light_GetDirection()<BR>
&nbsp;&nbsp;** Function:&nbsp;&nbsp;Returns the current Direction
of this Light.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;struct HMy3D_PointF_t*
My3D_Light_GetDirection() {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointF_t
CPPDirection;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;CPPDirection
= My3D_Light_ResolvePtr(hthis)-&gt;GetDirection();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;struct
HMy3D_PointF_t *hDirection;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ClassClass
*ccLight = NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;ccLight
= FindClass(NULL, &quot;My3D/PointF_t\0&quot;, TRUE);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(ccLight
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;hDirection
= (struct HSolidCoffee_PointF_t*)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
execute_java_constructor(NULL, &quot;My3D/PointF_t\0&quot;,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccLight,&quot;()&quot;);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert(hDirection
!= NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(hDirection)-&gt;x
= CPPDirection.x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(hDirection)-&gt;y = CPPDirection.y;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(hDirection)-&gt;z
= CPPDirection.z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(hDirection)-&gt;w = CPPDirection.w;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return(hDirection);<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
As you can see, the implementation of the <TT>SetDirection</TT>
and <TT>GetDirection</TT> classes
is very similiar to that of the <TT>SetLocation</TT>
and <TT>GetLocation</TT> methods in
the <TT>Node</TT> class.
<H3><B>The </B><TT><B><FONT SIZE=4 >Geometry</FONT></B></TT><B><FONT SIZE=4>
Java Interface Object</FONT></B></H3>
<P>
The final interface class that you need to know is the <TT>Geometry</TT>
class. The Java interface class for the <TT>Geometry</TT>
object is shown in Listing 32.32 and consists of the constructor
and finalize methods for the <TT>Geometry</TT>
class. The rest of the functionality for the <TT>Geometry</TT>
class is provided by the <TT>Node</TT>
class that it extends. Don't worry if you don't understand how
the <TT>Geometry</TT> object specifies
a polygon-it really isn't important to the discussion that follows.
Instead, focus on how the interface between the Java and the C++
class works.
<HR>
<BLOCKQUOTE>
<B>Listing 32.32. </B><TT><B></TT>Geometry</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Geometry extends Node {
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;private native
void constructor(int nPolygons, int nVertices,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointF_t
pVertices[], PointF_t pNormals[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointF_t
pFacets[], PointF_t pTexture[],<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ColorFA_t
pColors[], int VerOrder[]);<BR>
<BR>
&nbsp;&nbsp;public Geometry(int nPolygons, int nVertices, PointF_t
pVertices[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointF_t
pNormals[], PointF_t pFacets[],<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointF_t
pTexture[], ColorFA_t pColors[],<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
VerOrder[]) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;constructor();
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public native
void finalize();<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>Geometry</TT> class introduces
one final class to your expanding library, the <TT>ColorFA_t</TT>
class, which is responsible for specifying the colors of all the
vertices in the object. Listing 32.33 shows the implementation
of the <TT>ColorFA_t</TT> class.
<HR>
<BLOCKQUOTE>
<B>Listing 32.33. </B><TT><B></TT>ColorFA_t</FONT></B></TT><B>
Java </B><TT><B></TT>struct</FONT></B></TT><B>
definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class ColorFA_t {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;float r;<BR>
&nbsp;&nbsp;float g;<BR>
</TT>&nbsp;<TT>&nbsp;float b;<BR>
&nbsp;&nbsp;float a;<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
The implementation for the <TT>Geometry</TT>
class constructor is shown in Listing 32.34. This constructor
demonstrates how to handle arrays of passed objects in your interface
code, which is a common source of confusion for native method
users.
<HR>
<BLOCKQUOTE>
<B>Listing 32.34. </B><TT><B></TT>Geometry</FONT></B></TT><B>
constructor implemention.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;
My3D_Geometry_AllocLength = 0;<BR>
&nbsp;&nbsp;#define&nbsp;&nbsp;INITIAL_My3D_Geometry_ALLOC 2<BR>
<BR>
&nbsp;&nbsp;Geometry**&nbsp;&nbsp;My3D_Geometry_ObjPtr = NULL;
<BR>
</TT>&nbsp;<TT>&nbsp;long*&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_ObjRef
= NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; constructor()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Instantiates
the C++ Geometry class and sets the<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle
in the Java object.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void My3D_Geometry_constructorb(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct HMy3D_Geometry
*jthis,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short
cNP, short cNV, HArrayOfObject* pAP,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HArrayOfObject*
pAN, HArrayOfObject* pFN,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HArrayOfObject*
pAT, HArrayOfObject* pAC,<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Check to see if the initial allocation for the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Geometry class has been done yet.&nbsp;&nbsp;If
not, allocate<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
the necessary data structures.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(My3D_Geometry_AllocLength == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_AllocLength
=<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_Resize(INITIAL_My3D_Geometry_ALLOC);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Search for an empty position (empty
position == NULL).<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long pos;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( pos=0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pos
!= My3D_Geometry_AllocLength) &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(My3D_Geometry_ObjPtr[pos]
!= NULL);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos++
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (pos == My3D_Geometry_AllocLength)
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All allocated positions
are full.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
So use exponential allocation to create some more.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_AllocLength
=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_Resize(My3D_Geometry_AllocLength*2);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;Fixed16_t
PassNP = cNP;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Fixed16_t PassNV = cNV;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Copy the Vertex points from the Java
Array into a C++ array<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int len = obj_length(pAP);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointF_t*
PassAP = new PointF_t[len];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct HMy3D_PointF_t* hAP;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i != len; i++) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
hAP = (struct HMy3D_PointF_t *) (unhand(pAP)-&gt;body)[i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PointF_t* PtrAP = (PointF_t
*) unhand(hAP);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PassAP[i] = *PtrAP;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Copy the Normals from the Java Array
into a C++ array<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;len = obj_length(pAN);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointF_t*
PassAN = new PointF_t[len];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct HMy3D_PointF_t* hAN;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i != len; i++) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
hAN&nbsp;&nbsp;&nbsp;&nbsp; = (struct HMy3D_PointF_t *) (unhand(pAN)-&gt;body)[i];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PointF_t* PtrAN = (PointF_t
*) unhand(hAN);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PassAN[i] = *PtrAN;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Copy the Facet Normals from the Java Array into a C++ array.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;len
= obj_length(pFN);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointF_t* PassFN = new PointF_t[len];
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;struct
HMy3D_PointF_t* hFN;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
(i=0; i != len; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFN = (struct HMy3D_PointF_t
*) (unhand(pFN)-&gt;body)[i];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PointF_t* PtrFN = (PointF_t *) unhand(hFN);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PassFN[i] = *PtrFN;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Copy the Texture points from the Java Array into a C++ array.
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;len
= obj_length(pAT);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointF_t* PassAT = new PointF_t[len];
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;struct
HMy3D_PointF_t* hAT;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
(i=0; i != len; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hAT = (struct HMy3D_PointF_t
*) (unhand(pAT)-&gt;body)[i];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PointF_t* PtrAT = (PointF_t *) unhand(hAT);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PassAT[i] = *PtrAT;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Copy the Color points from the Java Array into a C++ array.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;len
= obj_length(pAC);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ColorFA_t* PassAC = new ColorFA_t[len];
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;struct
HMy3D_ColorFA_t* hAC;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
(i=0; i != len; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hAC = (struct HMy3D_ColorFA_t
*) (unhand(pAC)-&gt;body)[i];<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ColorFA_t* PtrAC = (ColorFA_t *) unhand(hAC);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PassAC[i] = *PtrAC;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Make a pointer to the vertex orders.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;len
= obj_length(pAV);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Fixed16_t* PassAV = (Fixed16_t *)(unhand(pAV)-&gt;body);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_ObjPtr[pos]
= new Geometry(PassNP, PassNV,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PassAP,
PassAN, PassFN, PassAT, PassAC, PassAV);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Stub for handling out of memory condition.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle as desired in your implementation.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;assert (My3D_Geometry_ObjPtr[pos] != NULL);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Increment Reference counter.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_IncRefCntr(pos);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Store handle (== position in array)
for this<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
object.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;unhand(jthis)-&gt;hCPPObj
= pos;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Delete all the temporary variables.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;delete
PassAP;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;delete PassAN;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;delete
PassFN;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;delete PassAT;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;delete
PassAC;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Take, for example, the <TT>pAP</TT>
array, which contains a handle <TT>HArrayOfObject</TT>.
When <TT>unhand</TT> is applied to
it, it contains an array of handles to <TT>PointF_t</TT>
objects for each of the points in its body element. By iterating
down this array of handles, you can translate these Java <TT>PointF_t</TT>
objects into C++ <TT>PointF_t</TT>
objects.
<P>
Listing 32.35 shows the implementation of the <TT>My3D_Node_ResolvePtr</TT>
function.
<HR>
<BLOCKQUOTE>
<B>Listing 32.35. </B><TT><B></TT>Node</FONT></B></TT><B>
C++ </B><TT><B></TT>ResolvePtr</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Node* My3D_Node_ResolvePtr(struct HMy3D_Node
*hNode) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;switch
(unhand(jthis)-&gt;ObjKindOf) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
LIGHT:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
( ((Node*) My3D_Light_ResolvePtr(hNode));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case GEOMETRY:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (
((Node*) My3D_Geometry_ResolvePtr(hNode));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (NULL);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Obviously, this is much different from the implementations of
<TT>My3D_xxxx_ResolvePtr</TT> for
other interface classes-none of the other classes you have considered
have subclasses.
<P>
Because you want your Java subclasses of Node to be able to stand
in for methods requiring a <TT>Node</TT>,
just like when <TT>Node</TT> was used
in your C++ library, special mechanisms need to be built in your
superclass interface implementation to handle this.
<P>
For instance, when you attach a <TT>Light</TT>
object to the <TT>World</TT> using
the method <TT>AttachNode(Node)</TT>,
you use the properties of <TT>Light</TT>
as a subclass of <TT>Node</TT> to
enable it to stand in as a <TT>Node</TT>
to be <BR>
attached. If you remember the implementation of the <TT>My3D_World_AttachNode</TT>
for the <TT>World</TT> interface,
you used the following statement to call <TT>AttachNode</TT>:
<BLOCKQUOTE>
<TT>My3D_World_ResolvePtr(hthis)-&gt;AttachNode(My3D_Node_ResolvePtr(hNode));</TT>
</BLOCKQUOTE>
<P>
Because there are two subclasses of <TT>Node</TT>-<TT>Light</TT>
and <TT>Geometry</TT>-the <TT>hNode</TT>
handle passed to <TT>My3D_Node_ResolvePtr</TT>
could be either a <TT>Light</TT> or
a <TT>Geometry</TT> object. This is
the reason for the <TT>switch</TT>
statement in the <TT>My3D_xxxx_ResolvePtr</TT>
function implementation-you need to know to which object this
handle refers. With the object determined, you can then call the
<TT>My3D_xxxx_ResolvePtr</TT> function
for the appropriate object to retrieve the pointer.
<P>
With this in mind, case statements were added for both the <TT>Light</TT>
and <TT>Geometry</TT> objects in the
<TT>ResolvePtr</TT> function. The
<TT>LIGHT</TT> and <TT>GEOMETRY</TT>
constants can be anything, but they must be different. This Java
interface defines them in a global header file (see Listing 32.36),
which also contains all the public interface functions for each
of the objects for linking.
<HR>
<BLOCKQUOTE>
<B>Listing 32.36. Global header file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#define WORLD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1<BR>
#define GEOMETRY&nbsp;&nbsp;&nbsp;&nbsp;2<BR>
#define LIGHT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3<BR>
<BR>
Node* My3D_Node_ResolvePtr(struct HMy3D_Node *hNode);<BR>
Node* My3D_Node_FindHandle (Node* CPPNode);<BR>
void&nbsp;&nbsp;My3D_Node_DecRefCntr(struct HMy3D_Node *hNode);
<BR>
void&nbsp;&nbsp;My3D_Node_IncRefCntr(struct HMy3D_Node *hNode);</TT>
</BLOCKQUOTE>
<HR>
<P>
Unfortunately, to do the inverse and find a Java <TT>Node</TT>
handle given a <TT>Node*</TT> requires
that you modify the C++ subclass to tell you what class it represents.
To do this in your graphics library, you add to the C++ class
a method <TT>int KindOf()</TT> that
returns the object type as defined in the global header file in
Listing 32.36. With this information, the class can chain the
request of <TT>My3D_xxxx_FindHandle</TT>
down to the correct class interface code, as shown in Listing
32.37.
<HR>
<BLOCKQUOTE>
<B>Listing 32.37. </B><TT><B></TT>Node</FONT></B></TT><B>
C++ </B><TT><B></TT>FindHandle</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; FindHandle()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Takes
a pointer to a World class instantiation<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and
looks up the associated Java handle to the<BR>
</TT>&nbsp;<TT>&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object.
<BR>
&nbsp;</TT>&nbsp;<TT>*/<BR>
<BR>
&nbsp;&nbsp;struct HMy3D_Node* My3D_Node_FindHandle (Node* CPPNode)
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch (CPPNode-&gt;KindOf()) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case LIGHT:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
(My3D_Light_FindHandle(CPPNode));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
GEOMETRY:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
(My3D_Geometry_FindHandle(CPPNode));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(0);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
(NULL);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
In the same manner, the <TT>My3D_Node_IncRefCntr</TT>
and <TT>My3D_Node_DecRefCntr</TT>
interface functions also need this mechanism. Their implementation
is shown in Listing 32.38.
<HR>
<BLOCKQUOTE>
<B>Listing 32.38. </B><TT><B></TT>Node</FONT></B></TT><B>
C++ </B><TT><B></TT>IncRefCntr</FONT></B></TT><B>
and </B><TT><B></TT>DecRefCntr</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*<BR>
** Title:&nbsp;&nbsp;&nbsp;&nbsp; IncRefCntr()<BR>
** Function:&nbsp;&nbsp;Performs automatic memory management.&nbsp;&nbsp;Passes
the call<BR>
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from
this function to wrappers for the subclass of<BR>
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node.
<BR>
*/<BR>
<BR>
void My3D_Node_IncRefCntr (struct HMy3D_Node* hNode) {<BR>
<BR>
&nbsp;&nbsp;long hNode;<BR>
<BR>
&nbsp;&nbsp;switch (unhand(hNode)-&gt;ObjKindOf) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case LIGHT:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Light_IncRefCntr(hNode);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;case
GEOMETRY:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_IncRefCntr(hNode);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(0);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;};<BR>
<BR>
}<BR>
<BR>
/*<BR>
** Title:&nbsp;&nbsp;&nbsp;&nbsp; DecRefCntr()<BR>
** Function:&nbsp;&nbsp;Performs automatic memory management.&nbsp;&nbsp;Passes
the call<BR>
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from
this function to wrappers for the subclass of<BR>
**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node.
<BR>
*/<BR>
<BR>
void My3D_Node_DecRefCntr (struct HMy3D_Node* hNode) {<BR>
<BR>
&nbsp;&nbsp;long hNode;<BR>
<BR>
&nbsp;&nbsp;switch (unhand(hNode)-&gt;ObjKindOf) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case LIGHT:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Light_DecRefCntr(hNode);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;case
GEOMETRY:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_Geometry_DecRefCntr(hNode);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(0);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;};<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The one final component that you need to integrate into your interface
is automatic handling of Java objects that move out of scope.
When a Java object moves out of scope, the method <TT>finalize</TT>
is called, so the behavior you want in your interface code is
to adjust the reference counters appropriately. You accomplish
this by simply linking the call to <TT>My3D_xxxx_finalize</TT>
with a call to <TT>My3D_xxxx_DecRefCntr()</TT>,
as shown in Listing 32.39 for the <TT>World</TT>
class. All Java classes that link to C++ classes that can be instantiated
should include interface code for <TT>finalize</TT>
like this (that is, the <TT>Node</TT>
class should be the only class that doesn't include code like
this in the ones that you have examined).
<HR>
<BLOCKQUOTE>
<B>Listing 32.39. Linking the call to </B><TT><B></TT>My3D_World_finalize</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>void My3D_World_finalize(struct HMy3D_World*
hthis) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;My3D_World_DecRefCntr(unhand(hthis)-&gt;hCPPObj);
<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H3><B>A Sample Program</B></H3>
<P>
This covers most of what you need to know to build a Java interface
to a C++ library! A sample program using the My3D interface library
is shown in Listing 32.40. Because this simple 3D library doesn't
have enough functionality to render the scene, you can't run the
program; but note how the program has the look and feel of a normal
Java program, meeting the design goals at the beginning of the
section.
<HR>
<BLOCKQUOTE>
<B>Listing 32.40. </B><TT><B></TT>Sample3DProg</FONT></B></TT><B>
implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import My3D;<BR>
<BR>
class Sample3DProg {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void main(String
argv[]) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;World
theWorld = new World();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;PointF_t
LightDir = new PointF_t();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;LightDir.x = 0.0f;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;LightDir.y
= 0.0f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;LightDir.z = 1.0f;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointF_t LightLoc = new PointFW_t();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;LightDir.x
= 0.0f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;LightDir.y = 0.0f;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;LightDir.z
= 10.0f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;LightDir.w = 1.0f;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Light theLight = new Light();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;theLight.SetLocation(LightLoc);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theLight.SetDirection(LightDir);<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="SpecialConcernsandTips"><B><FONT SIZE=5 COLOR=#FF0000>Special
Concerns and Tips</FONT></B></A></H2>
<P>
In this section, you cover some miscellaneous tricks and tips
that can be used to make your native library implementations more
robust. First, you deal with the problem of a missing native library
on your target machine and how to handle this event gracefully.
Then, you deal with interfacing to C++ libraries that include
templates, multiple inheritance, and operator overloading-features
that are not supported in the Java implementation.
<H3><B>Handling Missing Components in Your Native Library</B>
</H3>
<P>
As you may have already found out in developing a native library
for an applet, any native shared library needed must be installed
on the target system by the user manually (without the help of
the browser) before an applet can run on that system. Unfortunately,
the absence of your native library may not be detected until an
unfortunate user tries to read a Web page that requires it. Without
special functionality, when this happens, the applet displays
an error message in the status line of Netscape and dies-not the
ideal reaction. Worse yet, the user has no idea of where to look
for your native library.
<P>
Wouldn't it be great if you could develop some prologue code that
checked to see whether your native library existed before starting
the applet that used it? If the library did exist, the applet
could begin execution without delay. If it didn't, the prologue
code would display an informative error message and offer to point
the browser to the URL where the native library could be downloaded.
<P>
In this section, you learn how to develop the applet prologue
code necessary to do just this. Developed as a subclass of applet,
it would ideally be given to the developer using your native library
to use in place of the <TT>java.awt.Applet</TT>
class. Because all applet code is sent over the network when the
WWW page containing it is accessed, it isn't necessary to have
your library installed to run the prologue code.
<P>
This applet prologue code, NativeApplet, is designed as a subclass
of <TT>Applet</TT> (see Listing 32.41).
This subclass detects a missing <TT>SHARED
LIBRARY</TT> by trapping the <TT>UnsatisfiedLinkError</TT>
error thrown by the <TT>loadLibrary</TT>
command in the <TT>InterfaceObject</TT>
you considered earlier. It also tries to detect missing class
files by trying to instantiate a test <TT>InterfaceObject</TT>
object in its constructor. You use this extension to retrofit
the My3D graphics library and the sample My3D applet to show how
this code can be used to provide the needed functionality.
<HR>
<BLOCKQUOTE>
<B>Listing 32.41. NativeApplet implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package My3D;<BR>
<BR>
import My3D.*;<BR>
import java.applet.*;<BR>
import java.util.*;<BR>
import java.lang.*;<BR>
import java.io.*;<BR>
import java.awt.*;<BR>
<BR>
public class NativeApplet extends Applet {<BR>
<BR>
&nbsp;&nbsp;SendOk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TxfrOkDlg;
<BR>
</TT>&nbsp;<TT>&nbsp;Frame&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NativeFrame;
<BR>
&nbsp;&nbsp;AppletContext AC;<BR>
<BR>
&nbsp;&nbsp;public NativeApplet() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;LibNotFound = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InterfaceObject TrapDLLMissing
= new InterfaceObject();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;} catch (NoClassDefFoundError e) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LibNotFound = 1;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (LibNotFound == 0) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (InterfaceObject.DLLLoaded
== 0) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LibNotFound
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void NativeInit() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (LibNotFound == 1) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NativeFrame&nbsp;&nbsp;&nbsp;=
new Frame();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TxfrOkDlg
= new SendOk(NativeFrame, getAppletContext());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TxfrOkDlg.show();&nbsp;&nbsp;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void NativeStop() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (LibNotFound == 1) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
TxfrOkDlg.hide();<BR>
&nbsp;&nbsp;&nbsp;&nbsp; TxfrOkDlg.dispose();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;protected int
LibNotFound;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>NativeApplet</TT> class works
by trying to instantiate an <TT>InterfaceObject</TT>
within its constructor. If the class <TT>InterfaceObject</TT>
can't be found, the attempt to instantiate it will throw a <TT>NoClassDefFoundError</TT>
exception, which is trapped by the <TT>NativeApplet</TT>
constructor, flagging the variable <TT>LibNotFound</TT>.
<P>
You have to change the <TT>InterfaceObject</TT>
class in order to handle a missing native library shared library
file. The necessary changes are shown in Listing 32.42. A missing
native library shared library throws an <TT>UnsatisfiedLinkError</TT>
exception, which your new <TT>InterfaceObject</TT>
handler traps and uses to set the static variable <TT>DLLLoaded</TT>.
This is used by the <TT>NativeApplet</TT>
class to check for a &quot;shared library not loaded&quot; error.
<HR>
<BLOCKQUOTE>
<B>Listing 32.42. Changes to </B><TT><B></TT>InterfaceObject</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>static {<BR>
<BR>
</TT>&nbsp;<TT>try {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;System.load(&quot;/java/classes/SolidCoffee/java3dw.dll&quot;);
<BR>
&nbsp;&nbsp;&nbsp;DLLLoaded = 1;<BR>
<BR>
}&nbsp;&nbsp;catch (UnsatisfiedLinkError e) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;DLLLoaded = 0;<BR>
<BR>
}<BR>
<BR>
static public int&nbsp;&nbsp;DLLLoaded;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
To handle the case when either the native library shared library
file is missing or the class files for the library are missing,
you write a class called <TT>SendOk</TT>
that pops up a dialog to inform the user that at least one of
the components is missing. The class then gives the user the option
of pointing the browser to the Web site containing the installation
package for your library. The implementation of the <TT>SendOk</TT>
class is shown in Listing 32.43.
<HR>
<BLOCKQUOTE>
<B>Listing 32.43. </B><TT><B></TT>SendOK</FONT></B></TT><B>
class implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.applet.*;<BR>
import java.io.*;<BR>
import java.net.*;<BR>
<BR>
public class SendOk extends Dialog {<BR>
<BR>
&nbsp;&nbsp;AppletContext AC;<BR>
</TT>&nbsp;<TT>&nbsp;public SendOk(Frame
parent, AppletContext InAC) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;super(parent,
true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;AC = InAC;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setBackground(Color.gray);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setTitle(&quot;My3D package not found!&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Panel p = new Panel();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;p.add(new Button(&quot;Yes!&quot;));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;p.add(new
Button(&quot;No.&quot;));<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,
p);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;resize(250,150);<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public boolean action(Event evt, Object arg) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URL home;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg.toString().compareTo(&quot;Yes!&quot;)
== 0) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;home = new
URL(&quot;http://www.mystartup.com&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC.showDocument(home);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hide();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (MalformedURLException
e) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;SendOk::action():
malformed URL&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException e) {
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;SendOk::action():
io exception&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;SendOk::action():
other exception:&quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
e.toString());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (arg.toString().compareTo(&quot;No.&quot;)
== 0) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hide();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispose();
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
false;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.white);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;g.drawString(&quot;Your
computer doesn't have the My3D library&quot;, 20, 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;installed, which is
needed for this applet.&quot;, 20, 35);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;g.drawString(&quot;Should
I point your browser to the&quot;, 20, 55);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;My3D home page for
you?&quot;, 20, 70);<BR>
<BR>
&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
That's all there is to it! This mechanism makes it easier for
end users to find and install your native library package.  This
is important!  With the influx of less experienced users to the
Internet, only a small percentage of them will have the expertise
to interpret the always-cryptic error messages that display in
the status line of their browser screen.
<H3><B>Handling Missing C++ Features in Java</B></H3>
<P>
You may have already noticed that Java doesn't implement the full
set of object-oriented features that C++ does. This can be problematic
when you are trying to interface with a C++ library, because it
will make providing the look and feel with your set of parallel
Java libraries the same as your C++ libraries much more difficult.
In this subsection, you tackle the problems of interfacing your
library with C++ classes that contain such features.
<H4><B>Handling Templates</B></H4>
<P>
The first shortcoming that Java has is the absence of templates.
Templates are a C++ feature that enable you to substitute any
type or class for designator labels defined within the definition
of the class. Unfortunately, there really isn't any ideal solution
for this shortcoming. As a workaround, you can simply create a
Java class for all the types that might reasonably be expected
to be used with the native class. Consider Listing 32.44, a C++
collection template class.
<HR>
<BLOCKQUOTE>
<B>Listing 32.44. The C++ collection template class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>template &lt;class T&gt;<BR>
class Collection&lt;T&gt; {<BR>
<BR>
&nbsp;&nbsp;public:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Collection(int initialLength = 0, int
allocLength);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;Collection(const
Collection&lt;T&gt;&amp; src);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;~Collection(void);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int GetLength(void) const;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void Resize (int NewSize);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void AddElem (const T&amp; elem);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
DelElem (const int elemNum);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;private:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;T*&nbsp;&nbsp;&nbsp;CollArray;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;CurrLength;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;AllocLength;
<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
To interface a Java class to this <TT>Collection</TT>
class for the Java <TT>String</TT>
type, you create a Java interface class whose implementation constructor
includes the C++ class template filled with a <TT>char
*</TT> to hold the <TT>String</TT>'s
contents. To make the translation more mnemonic, you also suffix
the name of the Java interface class to represent this. The Java
interface class for <TT>String</TT>s
is shown in Listing 32.45.
<HR>
<BLOCKQUOTE>
<B>Listing 32.45. A Java interface class for </B><TT><B></TT>CollectionStrings</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class CollectionString {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
native void constructorA(int initialLength,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
allocLength);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public CollectionString(int initialLength,
int allocLength) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructorA(initialLength,
allocLength);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private native void constructorB(CollectionString
src);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public CollectionString(CollectionString
src) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructorB(src);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int GetLength(void) const;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void Resize (int NewSize);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void AddElem (String elem);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void DelElem (int elemNum);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetElem (int elemNum);<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 32.46 shows the C++ implementation of the constructor
for this class. The two important points that you should notice
in this constructor is that you link this implementation of the
<TT>CollectionString</TT> object to
a constructor that constructs a <TT>Collection&lt;char
*&gt;</TT> object, and that other than this the C++ implementation
of the constructor is the same as the constructors you considered
in interfacing to the My3D class.<BR>
<BLOCKQUOTE>
<B>Listing 32.46. </B><TT><B></TT>Collection&lt;char*&gt;</FONT></B></TT><B>
interface constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;
My3D_CollectionString_AllocLength = 0;<BR>
&nbsp;&nbsp;#define&nbsp;&nbsp;INITIAL_My3D_CollectionString_ALLOC
2<BR>
<BR>
&nbsp;&nbsp;Collection&lt;char*&gt;**&nbsp;&nbsp;My3D_CollectionString_ObjPtr
= NULL;<BR>
</TT>&nbsp;<TT>&nbsp;long*&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_ObjRef
= NULL;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;/*<BR>
&nbsp;&nbsp;** Title:&nbsp;&nbsp;&nbsp;&nbsp; constructor()<BR>
</TT>&nbsp;<TT>&nbsp;** Function:&nbsp;&nbsp;Instantiates
the C++ Collection&lt;char*&gt; class<BR>
&nbsp;&nbsp;**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and
sets the handle in the Java object.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;void My3D_CollectionString_constructor(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct
HMy3D_CollectionString *jthis) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Check to see if the initial allocation
for the<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Collection&lt;char*&gt; class has been done yet.&nbsp;&nbsp;If
not, allocate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// the necessary data structures.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (My3D_CollectionString_AllocLength
== 0) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_AllocLength
=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_Resize(INITIAL_My3D_CollectionString_ALLOC);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Search for an empty position (empty
position == NULL).<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long pos;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for ( pos=0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pos
!= My3D_CollectionString_AllocLength) &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(My3D_CollectionString_ObjPtr[pos]
!= NULL);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos++
)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (pos == My3D_CollectionString_AllocLength)
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All allocated positions
are full.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
So use exponential allocation to create some more.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_AllocLength
=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_Resize(My3D_CollectionString_AllocLength*2);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;My3D_CollectionString_ObjPtr[pos] = new
Collection&lt;char*&gt;();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Stub for handling out of memory condition.
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Handle as desired in your implementation.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;assert
(My3D_CollectionString_ObjPtr[pos] != NULL);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Increment Reference counter.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;My3D_CollectionString_IncRefCntr(pos);
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
Store handle (== position in array) for this<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// object.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(jthis)-&gt;hCPPObj = pos;<BR>
<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
With the constructor built, the rest of the implementation of
the <TT>Collection</TT> class for
<TT>String</TT>s is straightforward.
It follows exactly the development you followed in the previous
section on interfacing to C++ libraries. Once the <TT>Collection</TT>
class interface has been developed around the <TT>String</TT>
object, you can make <TT>Collection</TT>
classes for any type by simply searching and replacing <TT>String</TT>
with the desired type.
<H4><B>Interfacing with C++ Classes that Use Operator Overloading</B>
</H4>
<P>
What happens if the <TT>Collection</TT>
class didn't include the <TT>GetElem</TT>
accessor, but instead overloaded the <TT>[]</TT>
operator to provide access? Java doesn't include operator overloading,
so the only course of action to you is to add a <TT>GetElem</TT>
type accessor to your Java <TT>Collection
</TT>class that maps to a call to the <TT>[]</TT>
operator in your C++ implementation.
<H4><B>Interfacing with C++ Classes that Use Multiple Inheritance</B>
</H4>
<P>
The final object-oriented shortcoming to handle in Java is the
lack of multiple inheritance. You've already worked with C++ class
libraries in this chapter that deal with single inheritance, where
the subclass derives its functionality from only one superclass.
You haven't seen how to handle multiple inheritance derived subclasses,
however. In this section, you see how to handle multiple inheritance
by using interfaces.
<P>
Because you've been considering an interface with a 3D graphics
library in this chapter, let's consider a 3D library implementation
that uses multiple inheritance. Shown in Listing 32.47 is the
C++ class <TT>Location</TT>, which
contains all the data and accessors for managing a positional
object for a hypothetical 3D graphics library.
<HR>
<BLOCKQUOTE>
<B>Listing 32.47. </B><TT><B></TT>Location</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Location {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
SetLocation (PointFW_t theLoc) {Location = theLoc};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointFW_t GetLocation () {return(Location)};
<BR>
<BR>
&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointFW_t Location;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 32.48 defines a <TT>Direction</TT>
mix-in that adds <TT>Direction</TT>
to any object it is applied to using inheritance.
<HR>
<BLOCKQUOTE>
<B>Listing 32.48. </B><TT><B></TT>Direction</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Direction {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
SetDirection (PointF_t theDir) {Direction = theDir};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointF_t GetDirection () {return(Direction)};
<BR>
<BR>
&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;PointF_t Direction;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Finally, Listing 32.49 defines a <TT>Color</TT>
mix-in that adds a color property to any object.
<HR>
<BLOCKQUOTE>
<B>Listing 32.49. </B><TT><B></TT>Color</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Color {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
SetColor (ColorF_t theColor) {Color = theColor};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ColorF_t GetColor () {return(Color)};
<BR>
<BR>
&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ColorF_t Color;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Tying these classes together is the <TT>Light</TT>
class, shown in Listing 32.50, which uses all three of the mix-ins
to provide <TT>Location</TT>, <TT>Direction</TT>,
and <TT>Color</TT> information.
<HR>
<BLOCKQUOTE>
<B>Listing 32.50. </B><TT><B></TT>Light</FONT></B></TT><B>
C++ class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Light: public Direction, Location,
Color {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public:<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;void
SetAttenuation (float a);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float GetAttenuation ();<BR>
<BR>
&nbsp;&nbsp;private:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float Atten;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Unfortunately, as with templates in the previous chapter, there
is really no good solution to the multiple inheritance problem.
If at least all but one of the superclasses being inherited by
the class are abstract, you can use a Java interface to simulate
multiple inheritance.
<P>
Shown in Listings 32.51, 32.52, and 32.53 are Java interfaces
that do just this for the <TT>Location</TT>,
<TT>Direction</TT>, and <TT>Color</TT>
classes, respectively. These classes cannot be instantiated by
themselves, but they can be mixed in with other interface classes
to provide structure for the subclass.
<HR>
<BLOCKQUOTE>
<B>Listing 32.51. </B><TT><B></TT>Location</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public interface Location {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public void SetLocation
(PointFW_t theLocation);<BR>
&nbsp;&nbsp;public PointFW_t GetLocation();<BR>
<BR>
&nbsp;&nbsp;public PointFW_t Location=null;<BR>
<BR>
}<BR>
</TT>Listing 32.52. <TT>Direction</TT>
Java class definition.<BR>
<TT>public interface Direction {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public void SetDirection
(PointF_t theDir);<BR>
&nbsp;&nbsp;public PointF_t GetDirection();<BR>
<BR>
&nbsp;&nbsp;public PointF_t Direction=null;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 32.53. </B><TT><B></TT>Color</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public interface Color {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public void SetColor
(ColorF_t theColor);<BR>
&nbsp;&nbsp;public ColorF_t GetColor();<BR>
<BR>
&nbsp;&nbsp;public ColorF_t Color=null;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Shown in Listing 32.54 is the Java implementation of the <TT>Light</TT>
class. Note that all the methods defined in the <TT>Direction</TT>,
<TT>Location</TT>, and <TT>Color</TT>
must be implemented in the <TT>Light</TT>
class, but the interface still enforces the common interface between
all the objects that contain one or more of the interface classes.
<HR>
<BLOCKQUOTE>
<B>Listing 32.54. </B><TT><B></TT>Light</FONT></B></TT><B>
Java class definition.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Light implements Direction,
Location, Color {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public native
void SetDirection(PointF_t theDir);<BR>
&nbsp;&nbsp;public native PointF_t GetDirection();<BR>
<BR>
&nbsp;&nbsp;public void SetLocation(PointFW_t theLoc);<BR>
</TT>&nbsp;<TT>&nbsp;public PointFW_t
GetLocation();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;public void SetColor(ColorF_t
theColor);<BR>
&nbsp;&nbsp;public ColorF_t GetColor();<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
You've covered a lot of ground in this chapter! Take some time
to let it soak in before you continue. You learned how to interface
to legacy C and C++ libraries, and you considered the trade-offs
in the dif