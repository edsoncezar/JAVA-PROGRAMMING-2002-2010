<HTML>

<HEAD>
   <TITLE>Chapter 25 -- Class Organization and Documentation Tools</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 25</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Class Organization and Documentation Tools</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#JavaPackages" >Java Packages</A>
<LI><A HREF="#DocumentationGenerationUsingjavadoc" >Documentation Generation Using javadoc</A>
<LI><A HREF="#ClassDissassemblyUsingjavap" >Class Dissassembly Using javap</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Sun Microsystems has some useful tools that aid in the organization
and documentation of your Java classes. These tools enable you
to logically group your classes and interfaces into <I>packages</I>,
to generate documentation from properly commented source code,
and to disassemble existing Java classes. These tools-the Java
compiler <TT>javac</TT>, the Java
documentation generation tool <TT>javadoc</TT><I>,</I>
and the Java disassembler <TT>javap</TT>-are
included in the Java Developer's Kit (JDK). They are available
on most supported platforms. This chapter describes how to use
these tools to create packages of classes, to generate documentation
from your Java source, and to disassemble compiled class files.
<H2><A NAME="JavaPackages"><B><FONT SIZE=5 COLOR=#FF0000>Java
Packages</FONT></B></A></H2>
<P>
A Java package provides the means of organizing your classes and
interfaces. Initially you can choose to develop your Java applet
or application with all sources and classes residing in one directory.
Because of the Java specification that every class be placed into
a separate file, however, you can quickly become overwhelmed with
class files. You can use packages to group together related classes
and interfaces. In addition to the improved organization of classes,
the packages also give member classes special access to other
classes within the same package. This special <I>default package</I>
access allows classes within the package to have public access
to other members of the package. At the same time it excludes
access by all classes external to the package. In this section,
the steps involved in creating and using Java packages will be
demonstrated.
<P>
To place a class in a user-defined <TT>Package</TT>,
place a <TT>Package</TT> statement
as the first non-comment, non-whitespace line in the source file:
<BLOCKQUOTE>
<TT>package tools;<BR>
public class ToolA {<BR>
}<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
All Java classes belong to a package. If there is no <TT>package</TT> statement in the source file for a class, the Java compiler places that class into a default unnamed package.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Compile class <TT>ToolA</TT> with
the Java compiler command:
<BLOCKQUOTE>
<TT>javac ToolA.java</TT>
</BLOCKQUOTE>
<P>
The class <TT>ToolA</TT> now resides
in the package <TT>tools</TT>. The
result of the compile is the creation of a single class file <TT>ToolA.class</TT>.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You may wonder why you see nothing different when you compile a class with a <TT>package</TT> statement than when you compile a class without a <TT>package</TT> statement. Nothing appears different because the knowledge that class <TT>ToolA</TT> belongs in 
package <TT>tools</TT> is stored within the class file.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
All classes in a package are accessible by all other classes in
the same package. A class is accessible to another class if it
can be instantiated or extended by that class. Packaged classes
can refer to classes from within the same package by their class
name alone (not by their package name). For example, class <TT>ToolA,</TT>
defined above, is visible to all other classes within the <TT>tools</TT>
package. Any class within the <TT>tools</TT>
package can instantiate or extend class <TT>ToolA</TT>
without having to reference it by its package name. See the following
example:
<BLOCKQUOTE>
<TT>package tools;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
ToolB is also in the tools package<BR>
public class ToolB {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
ToolA t = new ToolA();&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;classes
in same package can<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;be
referenced by class name only<BR>
}</TT>
</BLOCKQUOTE>
<P>
A class can belong to only one package at a time. For example,
you can't have <TT>ClassA</TT> belonging
to package <TT>tools</TT> and package
<TT>util</TT> without duplicating
the class and physically placing it in both packages. You don't
want to have to maintain duplicate classes. So instead of this,
you can simply import the class from its package into the class
that needs it.
<H3><B>Importing Packaged Classes</B></H3>
<P>
If a class outside of a package requires a class from a package,
the packaged class must be <I>imported</I>, that is, brought into
the class. Placing a class in a package forces classes outside
of the package to reference it differently than before because
it essentially has a different name than before. Liken this to
the area code changing on your telephone number: your neighbors
can still call you by the same seven-digit number, but your long
distance relatives won't be able to reach you until they use the
correct area code. The package name is like the area code for
the class. <I>Local</I> classes within the same package are still
able to access each other as normal, but <I>long distance</I>
classes from outside of the package must use the full packaged
class name. Packaged classes are imported using an <TT>import</TT>
statement.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
All <TT>import</TT> statements must be placed at the top of the source file after the <TT>package</TT> statement (if any) and before your class definitions.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>tools</TT> package example,
shown previously, is used to illustrate the three ways in which
packaged classes can be imported:
<UL>
<LI>An <TT>import</TT> statement can
be placed at the top of the source file to identify the packaged
class to be imported:
</UL>
<BLOCKQUOTE>
<TT>import tools.ToolA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
import packaged class ToolA<BR>
</TT>public class ToolBox {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ToolA t = new ToolA();&nbsp;&nbsp;&nbsp;&nbsp;
// ToolA class can now be referenced<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
without its package name<BR>
<TT>}</TT>
</BLOCKQUOTE>
<UL>
<LI>An <TT>import</TT> statement can
be placed at the top of the source file to bring in every public
class in a package:
</UL>
<BLOCKQUOTE>
<TT>import tools.*;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
import all classes within package tools<BR>
</TT>public class ToolBox2 {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ToolA t = new ToolA();// ToolA class
can now be referenced<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
without its package name<BR>
<TT>}</TT>
</BLOCKQUOTE>
<UL>
<LI>No <TT>import</TT> statement is
used. The fully qualified packaged class can be named anywhere
within the source file:
</UL>
<BLOCKQUOTE>
<TT>public class ToolBox3 {<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp; tools.ToolA t = new tools.ToolA();&nbsp;&nbsp;&nbsp;&nbsp;
// direct import<BR>
<TT>}<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
It is a good idea not to import an entire package when you are using only one or two classes from that package. Importing all classes from a package increases the chances of namespace conflict, which means having more than one class by the same name. As 
you add new classes to the package over time, you increase the likelihood of having two or more classes with the same name if you import every class from a package. If you import only the classes that you need, duplication is less likely. </BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Be prepared for compilation time to increase whenever you import one or more classes from a package. </BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Importing an entire package into a class does not increase the
size of your class file because imported classes are not loaded
at compile time; they are loaded when instantiated at run time.
Also, using the asterisk wild card (<TT>*</TT>)
to import all classes from a package does not import any subpackages
of that package. For instance, the import statement
<BLOCKQUOTE>
<TT>import java.awt.*<BR>
</TT>imports only the classes from the <TT>java.awt</TT>
package. The subpackages <TT>java.awt.image</TT>
and <TT>java.awt.peer</TT> are not
imported. To import all classes from these packages, you must
use two additional import statements:<BR>
<TT>import java.awt.image.*<BR>
import java.awt.peer.*<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD >
<BLOCKQUOTE>
After you place your classes that are applets into a named package, you must change your HTML file to reference it by its packaged name. You must also set your <TT>CODEBASE</TT> to the directory located above the beginning of the package hierarchy (see the 
&quot;<TT>CODEBASE</TT> Attribute&quot; section later in this chapter for details on <TT>CODEBASE</TT>).
</BLOCKQUOTE>
<BLOCKQUOTE>
The following example of the packaged class, <TT>mypackage.DigClock</TT>, shows the applet tags within the HTML files before and after the class is placed in the package. &quot;&#133;&quot; means the current working directory.
</BLOCKQUOTE>
<BLOCKQUOTE>
<B>Before</B>: <TT>DigClock.class</TT> (in directory <TT>.../home</TT>) is not in a user-defined package
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;!-- HTML file : DigClock is not in a package--&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;APPLET CODE=DigClock.class CODEBASE=&quot;home/&quot;&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<B>After</B>: <TT>DigClock.class</TT> <I>is</I> in package <TT>mypackage</TT> in directory <TT>&#133;/home/classes/mypackage</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;!-- HTML file : ToolA is in the tools package--&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;APPLET CODE=mypackage.DigClock.class CODEBASE=&quot;home/classes&quot;&gt;</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The package <TT>java.lang</TT> is a standard Java package and is automatically imported into every class for you by the compiler. Because of this you can access classes from this package (such as <TT>Integer</TT> and <TT>Object</TT>) without placing an 
<TT>import</TT> statement in your source code.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now you have seen how to import a packaged class into a class
outside of its package. The procedure seems straightforward, but
this is where the problems can start. Often developers place their
classes into packages with ease (just a <TT>package</TT>
statement and a <TT>compile</TT> command
places a class into a package), but when the developers attempt
to import their classes into other classes, things become complicated.
In fact, if you try to compile any of the previous examples of
the class <TT>ToolBox,</TT> you may
see the following error:
<P>
<B>Type</B>
<BLOCKQUOTE>
<TT>javac ToolBox.java</TT>
</BLOCKQUOTE>
<P>
<B>Output</B>
<BLOCKQUOTE>
<TT>ToolBox.jav:1: Class tools.ToolA not
found in import<BR>
import tools.ToolA;<BR>
^</TT>
</BLOCKQUOTE>
<P>
Class <TT>ToolA</TT> is in the same
directory as the <TT>ToolBox</TT>
class, so why can't the compiler find it? The compiler can't find
the packaged class <TT>ToolA</TT>
because the compiler expects the class to reside in a directory
with the same name as the package. This brings us to the relationship
between package names and directory structure.
<H3><B>Package Names and Directory Structure</B></H3>
<P>
The directory structure in which packaged classes reside must
match the name of the package. If it does not, the packaged classes
are unusable until they are placed in a directory structure that
does match its name. The class may be in your current directory,
but the class loader will never recognize it. For example, the
packaged class
<BLOCKQUOTE>
<TT>tools.subtools.ToolA</TT>
</BLOCKQUOTE>
<P>
must reside in the directory structure
<BLOCKQUOTE>
<TT>&#133;/tools/subtools/ToolA.class</TT>
</BLOCKQUOTE>
<P>
If you attempt to access a packaged class that is not in a directory
structure matching its name, the compiler generates an error similar
to the following:
<BLOCKQUOTE>
<TT>ToolBox.jav:1: Class subtools.ToolA not
found in import<BR>
import subtools.ToolA;<BR>
^<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
All classes belonging to a package must be in the same directory; they cannot be scattered in different directories. Even if two packages have the same name but their classes are in different directories, they are considered separate packages. The 
following shows the directory structure for two packages with the same name:</BLOCKQUOTE>
<BLOCKQUOTE>
<B>Package </B><TT><B></TT>tools.subtools</FONT></B></TT>:<BR>
<TT>.../home/tools/subtools/*.class<BR>
</TT><B>Different Package </B><TT><B></TT>tools.subtools</FONT></B></TT>:
<BR>
<TT>.../usr/tool/subtools/*.class</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Both packages have classes that belong to a package named <TT>tools.subtools</TT>, but the classes in these two directories are not accessible to each other because importing a package with the same name as the current package is considered by the compiler 
to be ambiguous.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now is a good time to set up a directory structure for your packaged
classes. Figure 25.1 depicts a standard directory structure for
two Java packages. Notice that there are separate directories
for your source, classes, and documentation. This reduces the
confusion of having files with different suffixes all in one directory.
Notice how the package name is mirrored beneath both the source
and the classes directory structure.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f25-1.gif" ><B>Figure 25.1 : </B><I>A sample Java development directory structure.</I></A>
<P>
The package names, <TT>packageA</TT>
and <TT>packageB</TT>, represent the
fully qualified package name. Unlike a package with only one level
to its name (such as <TT>packageA</TT>),
some packages have more than one level to their names, such as
<TT>pkg1.subpkg1.util</TT>. The directory
structure would be as shown in Figure 25.2.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f25-2.gif" ><B>Figure 25.2 : </B><I>Multi-level package name directory structure.</I></A>
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Sun Microsystems has introduced a standard for making package names unique throughout the Internet. The standard calls for you to use the reverse of your domain name as the first part of the package name. For example, if my domain name were 
<TT>myCompanyName.COM</TT>, the first components in my package name would be <TT>COM.myCompanyName</TT>. The remaining components of your package name identify your unique organization and project within your company and the contents of the package, for 
example:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>COM.myCompanyName.myOrg.myProject.myPackage</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
A unique packaged class name immediately associates ownership of a class to the company and division where it was written. This does make for a lengthy directory structure, however,</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/java/classes/COM/myCompanyName/myOrg/myProject/myPackage/*.class</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
and need only be used if you are publishing a commercial class library on the Internet.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Once your packages of classes are created and are placed in separate
directories, you must be able to inform the compiler and class
loader where to find them in order for other classes to use them.
This is done using the <TT>CLASSPATH</TT>
environment variable.
<H3><TT><B><FONT SIZE=4 >CLASSPATH</FONT></B></TT><B><FONT SIZE=4>
Environment Variable</FONT></B></H3>
<P>
<TT>CLASSPATH</TT> is an environment
variable used by the compiler and the class loader to find Java
class files. The <TT>CLASSPATH</TT>
is set by the user and is simply a list of directories (separated
by colons on UNIX platforms and semicolons on pc platforms) that
will be searched to find Java classes.
<P>
If your <TT>CLASSPATH</TT> was not
set before now, the compiler and class loader can see only the
classes in your current directory. In order for you to do any
Java programming, your <TT>CLASSPATH</TT>
must be set to the directory containing Sun's Java Class Library
of standard Java packages, as well as your current directory.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If the JDK top-level directory is listed in your <TT>PATH</TT> environment variable, the Java compiler is automatically able to determine the location of the standard Java classes. You do not need to set the <TT>CLASSPATH</TT>. For the remainder of this 
chapter, it is assumed that the standard Java packages are known by the compiler without explicit modifications to the <TT>CLASSPATH</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Being able to use classes in only the current directory definitely
limits reuse of classes. Naturally you want to be able to use
another class (or package of classes) without having to copy it
into your own directory. Setting the <TT>CLASSPATH</TT>
to point to the directory where the desired class or package resides
enables you to reference classes as if they were in your own directory.
<P>
The classes from the example <TT>tools</TT>
package are in directory <TT>/home/tools/</TT>.
Set the <TT>CLASSPATH</TT> in the
following way so the compiler can find the classes in the <TT>tools</TT>
package:
<BLOCKQUOTE>
<TT>set CLASSPATH=C:\home&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
pc method of setting CLASSPATH<BR>
setenv CLASSPATH /home&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
UNIX method of setting CLASSPATH<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Caution</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Remember in the <TT>CLASSPATH</TT> to put the path name up to but not including your package name. If you do not specify the path name up to but not including your package name, your class will not be found because the compiler and class loader look for 
the directory matching the first word in your package name. Take, for example, the package named <TT>java.awt</TT>, whose classes are in directory <TT>/usr/classes/java/awt</TT>. The correct <TT>CLASSPATH</TT> to access this package is the following:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>set CLASSPATH=.;C:\usr\classes    // pc method of setting CLASSPATH</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>setenv CLASSPATH=.:/usr/classes   // UNIX method of setting CLASSPATH</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The dot (<TT>.</TT>) in the <TT>CLASSPATH</TT>
stands for current directory. Usually you want the compiler to
find the classes in your current directory as well as those in
the package from which you are importing.
<P>
The order of the directories in the <TT>CLASSPATH</TT>
is important. The directories are searched in left-to-right order.
If the <TT>CLASSPATH</TT> is set as
follows,
<P>
<B>pc method of setting CLASSPATH:</B>
<BLOCKQUOTE>
<TT>set CLASSPATH=.;C:\usr\SUN;C:\home\java\classes
 <BR>
</TT>
</BLOCKQUOTE>
<P>
<B>UNIX method of setting CLASSPATH:</B>
<BLOCKQUOTE>
<TT>setenv CLASSPATH=.:/usr/SUN:/home/java/classes
 </TT>
</BLOCKQUOTE>
<P>
the current directory (.)  is searched first, then <TT>/usr/SUN</TT>,
and finally <TT>/home/java/classes</TT>.
If a class with the same name is in each of these three directories,
the class in the current directory is the one the compiler selects.
<P>
Instead of changing the <TT>CLASSPATH</TT>
variable, you can  specify a path in which to search for classes
directly on the command line of the <TT>javac</TT>
command by using the -classpath option. For example, the following
command,
<BLOCKQUOTE>
<TT>javac -classpath .:/usr/SUN:/home/java/classes
*.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// UNIX<BR>
javac -classpath .;C:\usr\SUN;C:\home\java\classes *.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
pc</TT>
</BLOCKQUOTE>
<P>
compiles all Java files in the current directory and searches
for any referenced classes first in the current directory, then
in <TT>/usr/SUN</TT>, and finally
in <TT>/home/java/classes</TT>. The
path specified on the command line using the -classpath option
overrides the path specified in the <TT>CLASSPATH</TT>
environment variable.
<P>
In order for you to publish your applets on the Web, you must
be able to reveal where your class files are.To inform the Class
Loader where to search for your applet classes, you must use the
<TT>CODEBASE</TT> attribute in the
<TT>&lt;APPLET&gt;</TT> tag of your
HTML file.
<H3><TT><B><FONT SIZE=4 >CODEBASE</FONT></B></TT><B><FONT SIZE=4>
Attribute</FONT></B></H3>
<P>
Use an <TT>&lt;APPLET&gt;</TT> tag
to reference the applet class when the applet is embedded within
an HTML page. The <TT>&lt;APPLET&gt;</TT>
tag provides the class name of the applet to be displayed on the
HTML page within the browser. The Java Class Loader looks for
the applet's classes only in the same directory as the HTML file
itself unless you specify a different directory using the <TT>CODEBASE</TT>
attribute.
<P>
The <TT>CODEBASE</TT> attribute of
the <TT>&lt;APPLET&gt;</TT> tag is
the name of one directory (not a list of directories as with <TT>CLASSPATH</TT>)
in which to search for your applet class files. An example <TT>&lt;APPLET&gt;</TT>
tag containing a <TT>CODEBASE</TT>
follows:
<BLOCKQUOTE>
<TT>&lt;APPLET CODE=&quot;DigClock.class&quot;
CODEBASE=&quot;home&quot;&gt;</TT>
</BLOCKQUOTE>
<P>
You do not need to provide a full path name for the <TT>CODEBASE</TT>.
Instead, you can give an offset from the directory where the HTML
file resides. For example, if the HTML file is in directory <TT>.../temp/html</TT>
and the applet class files are in <TT>.../temp/classes</TT>,
set the <TT>CODEBASE</TT> as shown
here:
<BLOCKQUOTE>
<TT>&lt;APPLET CODE=&quot;DigClock.class&quot;
CODEBASE=&quot;../classes&quot;&gt;<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The <TT>CODEBASE</TT> can also be assigned a URL:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><B></TT>&lt;</FONT></B></TT>APPLET CODE=&quot;DigClock.class&quot;<BR>
CODEBASE=&quot;http://a.b.com/digclock&quot;&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This is especially useful if you want to reference another person's applet from your HTML page, but you do not want to or you cannot copy their applet class files.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Only one directory can be specified in the <TT>CODEBASE</TT>.
Because of this, all associated class files for your applet must
be in one directory in order for the applet to be embedded in
an HTML page.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
On UNIX platforms you can circumvent the limitation of having to place all class files for your applet into one directory. To do this, place the classes you want to access in packages and provide filesystem links from the <TT>CODEBASE</TT> directory to the 
package path.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The directory specified in the <TT>CODEBASE</TT>
for packaged classes must follow the same convention as does <TT>CLASSPATH</TT>.
The path name up to but not including the package name must be
given. If the packaged applet class <TT>tools.AppletTool</TT>
residing in directory <TT>.../home/tools/</TT>
were to be embedded in an HTML file, the <TT>&lt;APPLET&gt;</TT>
tag would look as follows:
<BLOCKQUOTE>
<TT>&lt;APPLET CODE=&quot;tools.AppletTool.class&quot;
CODEBASE=&quot;home&quot;&gt;</TT>
</BLOCKQUOTE>
<P>
The <TT>CODEBASE</TT> attribute in
an HTML file and the <TT>CLASSPATH</TT>
environment variable provide a path to be searched for classes.
Once a class is found on the path, it is evaluated for accessibility
to see if it can be subclassed or instantiated. Class accessibility
is set by the programmer of a class with access modifiers. The
relationship between access modifiers and packaged classes is
discussed in the following section.
<H3><B>Class Accesses and Packages</B></H3>
<P>
Java enables programmers to <I>hide</I> certain aspects of the
implementation of their classes from other classes. This is in
keeping with the object-oriented philosophy that objects should
reveal only the minimum amount of information required to use
that object and no more. Hiding in Java is done using access modifiers
to control which classes have access to other classes and their
variables and methods. When a class is placed in a package, special
access privileges are granted to the members of that package.
This section explains class accessibility and its relationship
to packages.
<P>
There are four access modifiers-<I>public</I>, <I>protected</I>,
<I>private protected,</I> and <I>private</I>. When you place one
of these four access modifiers before the declaration of a class,
variable, or method, you define which other classes are able to
access the declared item. Accessibility ranges from all other
classes having access to no other classes having access. If none
of the access modifiers are used in a declaration, the access
defaults to a <I>package, </I>known as<I> friendly</I> access.
<P>
To have access to a class means to have the ability to subclass
or instantiate that class. There are only two different types
of access for a class:
<UL>
<LI><B>Public.</B> A public class can be subclassed or instantiated
by all classes in all packages (including the default unnamed
package).
<LI><B>Default Package</B> (also known as friendly access). A
class without any access modifiers in its declaration has default
package access. This means that all classes within the same package
as that class can subclass or instantiate this class. This also
means that the class is not accessible by any classes outside
of its package.
</UL>
<P>
To have access to a variable means to have the ability to change
or examine the value of the variable. To have access to a method
means to have the ability to execute or override that method.
There are five different types of access for a variable or method:
<UL>
<LI><B>Public.</B> A public variable or method is accessible by
all classes in all packages (including the default unnamed package).
<LI><B>Protected.</B> A protected variable or method is only accessible
to the class in which it is contained, to all subclasses of the
class, and to all classes within the same package as that class.
<LI><B>Private Protected.</B> A private protected variable or
method is only accessible to the class in which it is contained
and to all subclasses of the class in which it is contained.
<LI><B>Private.</B> A private variable or method is only accessible
to the class in which it is contained.
<LI><B>Default Package</B> (also known as friendly access). A
variable or method without any access modifiers in its declaration
has default package access. A default package access variable
or method is only accessible to the class in which it is contained
and to all classes within the same package as the class. It is
not accessible by any classes outside of its package, even by
those classes in other packages which subclass the class containing
the default package variable or method.
</UL>
<P>
The default package access gives the programmer freedom within
a package to access other classes of that package without having
to deal with access restrictions. At the same time, the default
package access of a packaged class excludes access by any class
outside of the package, promoting implementation hiding.
<P>
If you get compilation errors when you attempt to group your classes
into separate packages, verify that your <TT>CLASSPATH</TT>
is properly set and your classes are in the correct directory
structure for their package name.  If they are, then the access
type of a class, variable, or method is the probable cause of
the problem.
<P>
Many programmers unintentionally leave off access modifiers, and
this means that their constructors, methods, variables, and classes
have the default package type access. This would go unnoticed
if all classes were in one package together or were not in a user-defined
package. But once the programmer attempts to divide classes into
different packages, then classes no longer have access to methods
and variables that they did before.
<P>
An example of cross-package errors is illustrated in the following
two listings, with two classes in separate packages: <TT>tools.ToolC</TT>
and <TT>util.ClassA</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 25. 1. Importing </B><TT><B></TT>ClassA</FONT></B></TT><B>
from package </B><TT><B></TT>util</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package tools;<BR>
import util.*;<BR>
<BR>
public class ToolC {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
ClassA a = new ClassA(this);&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;attempting
to instantiate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;class
from another package<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 25. 2. Importing class </B><TT><B></TT>ToolC</FONT></B></TT><B>
from package </B><TT><B></TT>tools</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>package util;<BR>
import tools.*;<BR>
<BR>
public class ClassA {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
ClassA (ToolC tc) {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;constructor
has default package access<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The error that follows is the result of compiling the above two
classes. Both classes have the correct <TT>import</TT>
statements to import each other. But class <TT>tools.ToolC</TT>
attempts to access a constructor from class <TT>util.ClassA</TT>
and the constructor for <TT>util.ClassA</TT>
has the default package access, which makes it inaccessible to
classes outside of its package.
<BLOCKQUOTE>
<TT>./tools/ToolC.java:6: No constructor
matching <BR>
ClassA(tools.ToolC) found in class util.ClassA<BR>
ClassA a = new ClassA(this);<BR>
1 error&nbsp;&nbsp;&nbsp;&nbsp;^</TT>
</BLOCKQUOTE>
<P>
If the access modifier <TT>public</TT>
is placed before the constructor for class <TT>util.ClassA</TT>,
it  compiles without errors.
<P>
The accessibility type of a variable or method determines whether
or not it will be visible in the API documentation generated by
the Sun tool <TT>javadoc</TT>. The
API document generation tool is described in the following section.
<H2><A NAME="DocumentationGenerationUsingjavadoc"><B><FONT SIZE=5 COLOR=#FF0000>Documentation
Generation Using </FONT><FONT SIZE=5 COLOR=#FF0000 FACE="MCPdigital">javadoc</FONT></B></A>
</H2>
<P>
Documenting applets and applications is not a favorite task for
most programmers, but the Sun JDK includes an API documentation
generation tool, named <TT>javadoc</TT><I>,</I>
which makes it less painful. <TT>javadoc</TT>
generates documentation from your properly commented Java source.
With this tool you can produce polished HTML file documentation
similar to the Sun Java API. Because the documentation is generated
from the source, there is no longer a problem with outdated documentation.
The documentation always reflects the current state of the source.
Also, because the documentation is in HTML format, users can breeze
from one associated class to another with a press of the mouse
button on a hyperlink.
<P>
The <TT>javadoc</TT> tool is capable
of generating HTML files containing the following:
<UL>
<LI>A hyperlinked index of all of your packages
<LI>A hyperlinked index of all packaged classes, interfaces, and
exceptions within each package
<LI>Class hierarchy diagrams and method and variable descriptions
for every class
<LI><FONT COLOR=#000000>Alphabetized hyperlinked index of all
fields and methods for all classes</FONT>
</UL>
<P>
The class <TT>NotDocumentedClass</TT>
looks as follows:
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
public class NotDocumentedClass extends Panel {<BR>
public NotDocumentedClass ()&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Color currentcolor = getBackground();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
public void addButton(String label){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (label == null) label
= &quot;EmptyButton&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
add(new Button (label));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD >
<BLOCKQUOTE>
<TT>javadoc</TT>  generates documentation only for variables and methods with public, protected, or private protected access. Any comments relating to private or default package variables and methods are not  translated to the output documentation. This is 
in keeping with object-oriented methodology where only what is accessible to others should be revealed.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
To generate documentation for the <TT>NotDocumentedClass</TT>
class (which is in the default unnamed package), execute the <TT>javadoc</TT>
command with the class source file name as an argument. Remember,
the documentation is generated off of the source file, so you
must inform <TT>javadoc</TT> where
your source is. You can do this in one of three ways: you can
change into the same directory as the source file, you can fully
qualify the directory name of the source file, or you can use
the <TT>-classpath</TT> option of
the <TT>javadoc</TT> command.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=590><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The <TT>-classpath</TT> option enables you to specify a list of directories where the search for your Java source files is to occur. Take, for example, the class named <TT>NotDocumentedClass,</TT> whose source is in directory <TT>.../source/</TT>. The 
correct usage of the <TT>-classpath</TT> option in the <TT>javadoc</TT> command to access this source would be:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>javadoc -classpath /usr/source NotDocumentedClass.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // UNIX
<BR>
javadoc -classpath C:\usr\source NotDocumentedClass.java&nbsp;&nbsp;&nbsp;&nbsp; // pc</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
As discussed in the &quot;Package Names and Directory Structure&quot;
section, it is a good idea to place your documentation in a separate
directory. This keeps it separate from your source and classes
and allows for hyperlinks to associated classes and interfaces.
Currently all documentation must be in a single directory in order
for related classes to link to each other. The <TT>-d</TT>
option of the <TT>javadoc</TT> command
enables you to specify in which directory your output is to be
placed. To generate documentation for the class <TT>NotDocumentedClass</TT>,
type the following:
<BLOCKQUOTE>
<TT>mkdir doc<BR>
javadoc -d doc NotDocumentedClass.java</TT>
</BLOCKQUOTE>
<P>
You should get the following output:
<BLOCKQUOTE>
<TT>Loading source files for NotDocumentedClass
<BR>
Generating packages.html<BR>
Generating index<BR>
Generating tree</TT>
</BLOCKQUOTE>
<P>
Table 25.1 lists all of the HTML files generated by <TT>javadoc</TT>
for a class (<TT>ex.</TT> <TT>NotDocumentedClass</TT>)
and placed in the <TT>doc</TT> directory.
<BR>
<P>
<CENTER><B>Table 25.1. Generated documentation files for </B><TT><B></TT>NotDocumentedClass</FONT></B></TT><B>.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=254>Filename</TD><TD WIDTH=313>Description</TD>
</TR>
<TR><TD WIDTH=254>AllNames.html</TD><TD WIDTH=313>Hyperlinked alphabetized list of all fields and methods
</TD></TR>
<TR><TD WIDTH=254>NotDocumentedClass.html</TD><TD WIDTH=313>Class hierarchy and description for NotDocumentedClass
</TD></TR>
<TR><TD WIDTH=254>packages.html</TD><TD WIDTH=313>Hyperlinked list of all packages (empty, <TT>NotDocumentedClass</TT> is in default unnamed package)
</TD></TR>
<TR><TD WIDTH=254>Package-NotDocumentedClass.html</TD><TD WIDTH=313>Package description and hyperlinked contents (empty)
</TD></TR>
<TR><TD WIDTH=254>tree.html</TD><TD WIDTH=313>Hyperlinked list of all classes
</TD></TR>
</TABLE></CENTER>
<P>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
SUN's JDK contains an <TT>apidocs</TT> directory (for example,<TT>.../Java/apidocs/</TT>), which contains the HTML files and a subdirectory of gif images that make up the Java API documentation. These directories contain the HTML documentation for all Java 
standard classes as well as all associated gif images (such as color coded bullets). To make your documentation appear as polished as the Java API and to permit links to Java standard classes from your HTML documentation, you can do one of two things: copy 
the contents of the apidocs directory to your local documentation directory, or place your documentation HTML files in the JDK apidocs directory.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Use your Web browser to view the HTML files generated by <TT>javadoc</TT>.
At this point, the HTML files for the class <TT>NotDocumentedClass</TT>
do not contain much information about the class. To produce more
substantial documentation, you have to comment the source according
to the <TT>javadoc</TT> specifications.
The following sections demonstrate how to properly comment your
source and relate which <TT>javadoc</TT>
options to use in generating HTML documentation. Generating documentation
for one or more packages is also described.
<H3><B>Comments and Documentation Tags</B></H3>
<P>
Within your Java source, any text between the comment delimiters
<TT>/**</TT> and <TT>*/</TT>
can be placed into the output API documentation by <TT>javadoc</TT>.
With this capability you can document the source of your classes,
interfaces, variables, and methods in great detail. Your effort
will not be wasted because <TT>javadoc</TT>
will transfer it into the output documentation. The comments you
provide must immediately precede the class, variable, or method
which they describe. Any comments placed incorrectly are silently
ignored by <TT>javadoc</TT>. For example,
see the placement of comments for class <TT>DocumentedClass</TT>:
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
/**<BR>
</TT>&nbsp;<TT>&nbsp;* Class comment:
DocumentedClass is a container for buttons<BR>
&nbsp;&nbsp;*/<BR>
public class DocumentedClass extends Panel {<BR>
<BR>
/**<BR>
&nbsp;&nbsp;* Variable comment: numbuttons is a counter of buttons
<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int numbuttons = 0;
<BR>
<BR>
/**<BR>
</TT>&nbsp;<TT>&nbsp;* Constructor
comment: Constructs the DocumentedClass.<BR>
&nbsp;&nbsp;*/<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
DocumentedClass () {<BR>
/** This comment will not be placed in the API documentation */
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
super();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color currentcolor = getBackground();
<BR>
}<BR>
<BR>
/**<BR>
&nbsp;&nbsp;* Method comment: Add a button with specified label.
<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void addButton(String label){<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (label == null) label = &quot;EmptyButton&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(new Button (label));
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
++numbuttons;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Executing <TT>javadoc</TT> on the
preceding file
<BLOCKQUOTE>
<TT>javadoc -d doc DocumentedClass.java</TT>
</BLOCKQUOTE>
<P>
results in the generation of HTML files, in which comments are
placed with their associated class, variable, or method. Notice
the comment within the constructor does not precede any class,
variable, or method, so it is ignored by <TT>javadoc</TT>.
<P>
Within the comment delimiters, you can also use documentation
tags (keywords that begin with <TT>@</TT>),
which are treated specially by <TT>javadoc</TT>.
Table 25.2 lists the documentation tags recognized by <TT>javadoc</TT>
and the resulting output of these tags.<BR>
<P>
<CENTER><B>Table 25.2. Javadoc documentation tags.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=150>Documentation Tag</TD><TD WIDTH=220>Parameters
</TD><TD WIDTH=220>Description</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=3>Class Tags</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@author 1</TT>
</TD><TD WIDTH=220><TT>author_name</TT>
</TD><TD WIDTH=220>Adds field for author of class (must use <TT>-author</TT> option of <TT>javadoc</TT> command).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@see 1</TT>
</TD><TD WIDTH=220><TT>class_name</TT> or <TT>method_name</TT>
</TD><TD WIDTH=220>Adds hyperlinked field labeled See Also to specified class or method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@version</TT>
</TD><TD WIDTH=220><TT>version_name_number</TT>
</TD><TD WIDTH=220>Adds field for version of class (must use <TT>--version</TT> option of <TT>javadoc</TT> command).
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=3>Method Tags</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@exception</TT> 
</TD><TD WIDTH=220><TT>class_name</TT> description
</TD><TD WIDTH=220>Adds hyperlinked field labeled Throws with name of exception thrown by method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@param 1</TT>
</TD><TD WIDTH=220><TT>parameter_name</TT> description
</TD><TD WIDTH=220>Adds field for method parameter.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@return</TT>
</TD><TD WIDTH=220><TT>return_name</TT> description
</TD><TD WIDTH=220>Adds field for value returned by method.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@see 1</TT>
</TD><TD WIDTH=220><TT>class_name</TT> or <TT>method_name</TT>
</TD><TD WIDTH=220>Adds hyperlinked field labeled See Also to specified class or method.
</TD></TR>
<TR VALIGN=TOP><TD COLSPAN=3 WIDTH=590>Variable Tags</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>@see 1</TT>
</TD><TD WIDTH=220><TT>class_name</TT> or <TT>method_name</TT>
</TD><TD WIDTH=220>Adds hyperlinked field labeled See Also to specified class or method.
</TD></TR>
</TABLE></CENTER>
<P>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>You can specify more than one of these tags on separate lines between one set of comment delimiters. For instance, use multiple <TT>@author</TT> tags for a list of authors separated by commas to be shown in the output documentation. Keep same name 
tags together in your source or they will be ignored.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The tags that are used within comment delimiters for a class are
different from the tags used within comment delimiters for a method
or variable. In fact, if you attempt to place a documentation
tag that is meant only for the class comments such as <TT>@author</TT>
in the method comment section of the source, <TT>javadoc</TT>
will silently ignore it.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Caution</B></TD></TR>
<TR><TD>After a comment asterisk and before the documentation tag, there can be up to one space. If you place any more spaces between the comment asterisk and the documentation tag, the tag is either silently ignored or appended to the previous tag.
</TD></TR>
</TABLE></CENTER>
<P>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* @author Ben Taylor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Valid<BR>
&nbsp;*@author Ben Taylor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Valid<BR>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@author
Ben Taylor&nbsp;&nbsp;&nbsp;&nbsp; // 2Invalid<BR>
&nbsp;**/<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You may go to a lot of trouble placing the <TT>@author</TT> and <TT>@version</TT> documentation tags in your source with the correct number of spaces, but you won't be able to see the tags in your output documentation unless you specify the related option 
on the command line, for example
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>javadoc -author -version *.java</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
A list of all <TT>javadoc</TT> command
line options is given in Table 25.3. Some of these options are
not documented in the Java Language Specification, but if you
do not use them on the command line, your output API will not
be what you expected.<BR>
<P>
<CENTER><B>Table 25.3. Javadoc command line options.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=278>Command Line Option</TD><TD WIDTH=312>Description
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-author</TT>
</TD><TD WIDTH=312>Process any <TT>@author</TT> tags within source files
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-authors</TT>
</TD><TD WIDTH=312>Same results as <TT>-author</TT> option
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-classpath</TT> path
</TD><TD WIDTH=312>List of directories (separated by '<TT>:</TT>') containing java source
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-d</TT> directory
</TD><TD WIDTH=312>Output directory for API documentation</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-depend package1 package2</TT> ...
</TD><TD WIDTH=312>Allow dependencies of API documentation between packages
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-version</TT>
</TD><TD WIDTH=312>Process any <TT>@version</TT> tags within source files
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=278><TT>-verbose</TT>
</TD><TD WIDTH=312>Print messages to screen about source being processed
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Thus far you have placed standard comments and documentation tags
in your comment delimiters. <TT>javadoc</TT>
also enables you to embed HTML tags within your comments. The
following section describes this in detail.
<H3><B>Embedded HTML</B></H3>
<P>
<TT>javadoc</TT> enables you to embed
 HTML tags within your comment delimiters. This is a powerful
feature of <TT>javadoc</TT> and opens
up your documentation to nearly all of the special publishing
capabilities of HTML. Your API documentation is in an HTML file
and can be configured by you. You can add hyperlinks to other
HTML files, load images, color text, and do almost anything else
you can do with a regular HTML file. HTML is especially useful
within your API documentation to provide hyperlinks to related
classes or source listing, or to provide examples of how to use
your class. Listing 25.3 demonstrates the many uses of HTML within
a Java class:
<HR>
<BLOCKQUOTE>
<B>Listing 25.3 Example of embedded HTML within Java commented
source.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.applet.*;<BR>
import java.util.Vector;<BR>
<BR>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CLASS:&nbsp;&nbsp;EmbeddedHTMLClass
<BR>
/**<BR>
</TT>&nbsp;<TT>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This
applet displays the text specified in the &lt;i&gt;title&lt;/i&gt;
<BR>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter. The initial
background color of the applet is<BR>
</TT>&nbsp;<TT>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specified
in the &lt;i&gt; bgcolor &lt;/i&gt; parameter.<BR>
&nbsp;*&lt;p&gt;<BR>
</TT>&nbsp;<TT>* Following is an example
APPLET tag for the EmbeddedHTMLClass class.<BR>
&nbsp;* &lt;pre&gt;<BR>
</TT>&nbsp;<TT>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Usage:<BR>
&nbsp;* &lt; APPLET CODE=&quot;EmbeddedHTMLClass.class&quot; WIDTH=100
HEIGHT=100&gt;<BR>
</TT>&nbsp;<TT>* &lt; PARAM NAME=bgcolor
VALUE=&quot;red&quot; &gt;<BR>
&nbsp;* &lt; PARAM NAME=title&nbsp;&nbsp;&nbsp;VALUE=&quot;Test
Title&quot; &gt;<BR>
</TT>&nbsp;<TT>* &lt; /APPLET &gt;
<BR>
&nbsp;* &lt;/pre&gt;<BR>
</TT>&nbsp;<TT>* &lt;p&gt;&lt;b&gt;Sample
background colors for the &lt;i&gt; bgcolor &lt;/i&gt; parameter
follow:&lt;/b&gt;<BR>
&nbsp;* &lt;p&gt;&lt;li&gt;&quot;red&quot;<BR>
</TT>&nbsp;<TT>* &lt;li&gt;&quot;blue&quot;
<BR>
&nbsp;* &lt;li&gt;&quot;green&quot;<BR>
</TT>&nbsp;<TT>* &lt;li&gt;&quot;yellow&quot;
<BR>
&nbsp;*<BR>
</TT>&nbsp;<TT>* @see Color<BR>
&nbsp;* @see Button<BR>
</TT>&nbsp;<TT>* @version 1.0 27 June
1996<BR>
&nbsp;* @author &lt;A HREF=&quot;http://mydomain.name.com/Home.html&quot;&gt;Greg
Mitchel&lt;/A&gt;<BR>
</TT>&nbsp;<TT>*/<BR>
public class&nbsp;&nbsp;&nbsp;EmbeddedHTMLClass extends Applet
{<BR>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EmbeddedHTMLClass Class
Data<BR>
<BR>
/** Title to Display */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title
= null;<BR>
<BR>
/** Background color&nbsp;&nbsp;*/<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected
Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bgcolor;<BR>
<BR>
/** Changing colors&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int red&nbsp;&nbsp;&nbsp;=
0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private
int blue&nbsp;&nbsp;= 50;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int green
= 50;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private
Color currentcolor = null;<BR>
<BR>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor: EmbeddedHTMLClass
<BR>
&nbsp;&nbsp;&nbsp;/**<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;Constructs the EmbeddedHTMLClass.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
EmbeddedHTMLClass ()&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgcolor
= getBackground();<BR>
}<BR>
<BR>
<BR>
/**<BR>
&nbsp;&nbsp;* Initialize EmbeddedHTMLClass Applet.<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init(){<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String param =
getParameter( &quot;BGCOLOR&quot;&nbsp;&nbsp;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( param != null ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(param.equals(&quot;red&quot;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bgcolor
= Color.red;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if (param.equals(&quot;blue&quot;))&nbsp;&nbsp;&nbsp;bgcolor =
Color.blue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if (param.equals(&quot;green&quot;))&nbsp;&nbsp;bgcolor = Color.green;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
if (param.equals(&quot;yellow&quot;)) bgcolor = Color.yellow;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
bgcolor = Color.blue;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else bgcolor =
Color.blue;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(bgcolor);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title = getParameter(
&quot;TITLE&quot;&nbsp;&nbsp;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( title == null )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title
= &quot;Default Title&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button b = new
Button(&quot;Change Color&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,
b);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
/**<BR>
&nbsp;&nbsp;* Change color of background at button press.<BR>
</TT>&nbsp;<TT>&nbsp;* @param event
The action event to be handled.<BR>
&nbsp;&nbsp;* @param obj Target object of the event to be handled.
<BR>
</TT>&nbsp;<TT>&nbsp;* @return Handled
event flag.<BR>
&nbsp;&nbsp;*/<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
boolean action(Event event, Object obj) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (event.target instanceof Button) {<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red&nbsp;&nbsp;&nbsp;+=
20;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue&nbsp;&nbsp;+=
20;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green
+= 20;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(red&nbsp;&nbsp;&nbsp;&gt; 255) red&nbsp;&nbsp;&nbsp;= 0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(blue&nbsp;&nbsp;&gt; 255) blue&nbsp;&nbsp;= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(green &gt; 255) green = 0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentcolor
= new Color(red, green, blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(currentcolor);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update(getGraphics());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
</TT>&nbsp;<TT>/**<BR>
&nbsp;&nbsp;* paint()<BR>
</TT>&nbsp;<TT>&nbsp;* Set background
color, display title.<BR>
&nbsp;&nbsp;* @param g The graphics context on which to paint.
<BR>
</TT>&nbsp;<TT>&nbsp;*/<BR>
&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(currentcolor != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
setBackground(currentcolor);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(title,
10, 30);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Figure 25.3 illustrates a portion of the output
API documentation with embedded HTML generated by the <TT>javadoc</TT>
command
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f25-3.gif" ><B>Figure 25.3 : </B><I>Sample Java API with embedded HTML.</I></A>
<BLOCKQUOTE>
<TT>javadoc -d doc -version -author EmbeddedHTMLClass.java</TT>
</BLOCKQUOTE>
<P>
for class <TT>EmbeddedHTMLClass</TT>.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
<TT>javadoc</TT> specifications warn users not to embed the following HTML heading tags in their API documentation because they interfere with document formatting:
</BLOCKQUOTE>
<BLOCKQUOTE>
The horizontal line tag: <TT>&lt;HR&gt;<BR>
</TT>The six heading level tags: <TT>&lt;H1&gt;</TT>-<TT>&lt;H6&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
However, <TT>javadoc</TT> does not generate any errors when these tags are encountered.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><B>Documentation Generation and Packages</B></H3>
<P>
You have learned how to generate API documentation for your unpackaged
classes. This section demonstrates how to generate documentation
for one or more packages of classes. Like unpackaged class documentation,
<TT>javadoc</TT> can produce class
hierarchy diagrams, and it can do so for each class in a package.
In addition to this, it can generate a hyperlinked listing of
all of your packages and lists of classes within these packages.
This hyperlinked representation of your packages and classes is
a valuable reference resource for users of your classes. It facilitates
reuse of classes by providing clear definitions of accessible
variables and methods within the class and in any superclasses.
<P>
In this example, API documentation is generated for the package
<TT>acct.util</TT> which contains
four classes: <TT>ClassA</TT>, <TT>ClassB</TT>,
<TT>ClassC</TT> and <TT>ClassD</TT>.
To do this, you must execute the <TT>javadoc</TT>
command with the fully packaged class name as an argument. Once
again, the documentation is generated off of the class source
files, so change into the directory just <I>above</I> the first
directory in the package name (for example, the directory above
<TT>acct</TT>), or use the <TT>-classpath</TT>
option of the javadoc command.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Caution</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The <TT>-classpath</TT> option of the <TT>javadoc</TT> command enables you to specify a list of directories in which the search for your Java source files is to occur. When you generate documentation for a package, you must give the path name up to, but 
not including, the first directory of the package name. If you do not, your source file can not be found because <TT>javadoc</TT> looks for the directory matching the first word in your package name. Take for example the package named <TT>acct.util,</TT> 
whose source files are in directory <TT>.../usr/source/acct/util</TT>. The correct classpath to access this package would be
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>javadoc -classpath /usr/source acct.util</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>-d</TT> option of the <TT>javadoc</TT>
command enables you to specify the directory name in which the
output documentation is to be placed. The source files for the
<TT>acct.util</TT> package are in
directory <TT>.../usr/source/acct/util</TT>.
To generate documentation for the entire <TT>acct.util</TT>
package, type the following:
<BLOCKQUOTE>
<TT>cd source<BR>
javadoc -d doc acct.util</TT>
</BLOCKQUOTE>
<P>
You should get this output:
<BLOCKQUOTE>
<TT>Loading source files for acct.util<BR>
Generating packages.html<BR>
generating documentation for class acct.util.ClassA<BR>
generating documentation for class acct.util.ClassB<BR>
generating documentation for class acct.util.ClassC<BR>
generating documentation for class acct.util.ClassD<BR>
Generating index<BR>
Sorting 4 items . . . done<BR>
Generating tree</TT>
</BLOCKQUOTE>
<P>
Often there are class dependencies between packages. A class from
one package will instantiate or extend a class from another package.
You want your documentation to show these dependencies through
hyperlinks (example: have the ability to jump from extended class
definition to superclass definition). This can be done using the
<TT>javadoc</TT> tool with its <TT>-depend</TT>
option.
<P>
In the next example, API documentation is generated for the three
packages: <TT>pkgA.util</TT>, <TT>pkgB.tool</TT>,
and, <TT>pkgC.awt</TT>. Again, the
documentation is generated off of the class source files. Change
into the directory just <I>above</I> the first directory in the
package name (for example, the directory above <TT>pkgA)</TT>
or use the <TT>-classpath</TT> option
of the <TT>javadoc</TT> command. The
source files and the directory in which they reside are shown
in Table 25.4.<BR>
<P>
<CENTER><B>Table 25.4. Packages </B><TT><B></TT>pkgA.util</FONT></B></TT><B>,
</B><TT><B></TT>pkgB.tool</FONT></B></TT><B>,
and </B><TT><B></TT>pkgC.awt</FONT></B></TT><B>
and associated directories.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=117>Package Name</TD><TD WIDTH=253>Directory</TD>
</TR>
<TR><TD WIDTH=117><TT>pkgA.util</TT>
</TD><TD WIDTH=253><TT>.../usr/source/pkgA/util</TT>
</TD></TR>
<TR><TD WIDTH=117><TT>pkgB.tool</TT>
</TD><TD WIDTH=253><TT>.../usr/source/pkgB/tool</TT>
</TD></TR>
<TR><TD WIDTH=117><TT>pkgC.awt</TT>
</TD><TD WIDTH=253><TT>.../usr/source/pkgC/awt</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
To generate interdependent documentation for the three packages
at once, type the following:
<BLOCKQUOTE>
<TT>javadoc -d doc -classpath /usr/source
-depend pkgA.util pkgB.tool pkgC.awt</TT>
</BLOCKQUOTE>
<P>
This is the output:
<BLOCKQUOTE>
<TT>Loading source files for pkgA.util<BR>
Loading source files for pkgB.tool<BR>
Loading source files for pkgC.awt<BR>
Generating packages.html<BR>
generating documentation for class pkgA.util.ClassA<BR>
generating documentation for class pkgA.util.ClassB<BR>
generating documentation for class pkgA.util.ClassC<BR>
generating documentation for class pkgB.tool.ClassA<BR>
generating documentation for class pkgB.tool.ClassB<BR>
generating documentation for class pkgB.tool.ClassC<BR>
generating documentation for class pkgC.awt.ClassA<BR>
generating documentation for class pkgC.awt.ClassB<BR>
generating documentation for class pkgC.awt.ClassC<BR>
Generating index<BR>
Sorting 9 items . . . done<BR>
Generating tree</TT>
</BLOCKQUOTE>
<P>
This provides a hyperlinked index of all three packages (<TT>packages.html</TT>),
a hyperlinked index of classes for each package, class hierarchy
diagrams, and a merged alphabetical index of all methods and variables
(<TT>AllNames.html</TT>).
<H2><A NAME="ClassDissassemblyUsingjavap"><B><FONT SIZE=5 COLOR=#FF0000>Class
Dissassembly Using </FONT><FONT SIZE=5 COLOR=#FF0000 FACE="MCPdigital">javap</FONT></B></A>
</H2>
<P>
Another useful tool that is included in the Sun JDK is a class
disassembler tool named <TT>javap</TT>
which disassembles class files. This tool can be used to determine
whether your path environment variables are correctly set. Try
and disassemble a standard Java class like <TT>java.awt.Button.class</TT>.
Type the following:
<BLOCKQUOTE>
<TT>javap java.awt.Button</TT>
</BLOCKQUOTE>
<P>
Here is the output:
<BLOCKQUOTE>
<TT>Compiled from Button.java<BR>
public class java.awt.Button extends java.awt.Component {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;java.lang.String
label;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public java.awt.Button();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
java.awt.Button(java.lang.String);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void addNotify();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
java.lang.String getLabel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void setLabel(java.lang.String);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;protected
java.lang.String paramString();<BR>
}</TT>
</BLOCKQUOTE>
<P>
If, instead of printing the output above, <TT>javap</TT>
prints an error message that says the class <TT>java.awt.Button</TT>
cannot be found, your <TT>PATH </TT>or
<TT>CLASSPATH</TT> environment variables
are incorrectly set. See the section &quot;<TT>CLASSPATH</TT>
Environment Variable&quot; for details.
<P>
To disassemble a nonstandard class such as <TT>MyClass.class,</TT>
which is not in a user-defined package, you must fully qualify
the class name (without the <TT>.class</TT>
suffix), or change into the directory in which the class file
resides (example: <TT>.../Java/classes</TT>)
and type the following:
<BLOCKQUOTE>
<TT>javap MyClass</TT>
</BLOCKQUOTE>
<P>
Here is the output:
<BLOCKQUOTE>
<TT>Compiled from MyClass.java<BR>
public class MyClass extends java.lang.Object {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
int x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public MyClass();<BR>
}</TT>
</BLOCKQUOTE>
<P>
To disassemble the packaged class <TT>tools.ToolA.class</TT>,
which resides in directory <TT>.../Java/classes/tools</TT>,
change into that directory and type the following:
<BLOCKQUOTE>
<TT>javap tools.ToolA</TT>
</BLOCKQUOTE>
<P>
The disassembled class will be printed to the command line. This
tool is useful if you do not have access to the source of a class,
or if you do have API documentation but want to see the private
variables or methods of a class. Table 25.5 lists the command
line options of interest to the Java class disassembler.<BR>
<P>
<CENTER><B>Table 25.5. Javap command line options.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=170>Command Line Option</TD><TD WIDTH=420>Description
</TD></TR>
<TR><TD WIDTH=170><TT>-c</TT> </TD>
<TD WIDTH=420>Disassembles the code of the Java class (not private fields and methods)
</TD></TR>
<TR><TD WIDTH=170><TT>-classpath</TT> 
</TD><TD WIDTH=420>The path of directories in which to search for classes (for example, <TT>.:Java/classes:new/classes</TT>)
</TD></TR>
<TR><TD WIDTH=170><TT>-h</TT> </TD>
<TD WIDTH=420>Creates information that can be put into a C header file
</TD></TR>
<TR><TD WIDTH=170><TT>-l</TT> </TD>
<TD WIDTH=420>Provides line numbers in output</TD></TR>
<TR><TD WIDTH=170><TT>-p</TT> </TD>
<TD WIDTH=420>Disassembles private variables and methods</TD>
</TR>
<TR><TD WIDTH=170><TT>-v</TT> </TD>
<TD WIDTH=420>Verifies options, prints out debugging information
</TD></TR>
<TR><TD WIDTH=170><TT>-version</TT> 
</TD><TD WIDTH=420>Prints out the version number of javap (for example, <TT>&quot;version 1.0.1&quot;)</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter, several useful tools that are a part of the Sun
JDK were discussed. The Java compiler <TT>javac</TT>
was used to show how to create packages of Java classes and how
to import packaged classes into other classes. There are two major
benefits to placing Java classes into user-defined packages. First,
class organization is greatly improved because classes are logically
grouped together. Second, members of packages can take advantage
of package class access privileges that are not available to classes
outside of a package. The environment variable <TT>CLASSPATH</TT>
and the HTML Applet tag <TT>CODEBASE</TT>
were introduced. Usage of the API documentation generation tool
<TT>javadoc</TT> was demonstrated.
This tool generates professional looking API documentation from
properly commented Java source code. And finally, the Java class
disassembler tool <TT>javap</TT> was
discussed.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch24.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch26.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

