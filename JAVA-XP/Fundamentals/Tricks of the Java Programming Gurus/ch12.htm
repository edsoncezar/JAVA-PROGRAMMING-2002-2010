<HTML>

<HEAD>
   <TITLE>Chapter 12 -- Image Filters and Color Models</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 12</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Image Filters and Color Models</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#UnderstandingColor" >Understanding Color</A>
<LI><A HREF="#ColorImagesinJava" >Color Images in Java</A>
<LI><A HREF="#ColorModels" >Color Models</A>
<LI><A HREF="#TheColorModelClasses" >The Color Model Classes</A>
<LI><A HREF="#WorkingwithColorModels" >Working with Color Models</A>
<LI><A HREF="#ImageFilters" >Image Filters</A>
<LI><A HREF="#TheImageFilterClasses" >The Image Filter Classes</A>
<LI><A HREF="#WritingYourOwnImageFilters" >Writing Your Own Image Filters</A>
<LI><A HREF="#UsingImageFilters" >Using Image Filters</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
One of the most compelling features of Java is its wide support
for the presentation of graphical information. Along with providing
a simple means of displaying static images, Java enables developers
to manipulate and animate images in ways previously impossible
in Web content. At the heart of Java graphics and imaging are
Java color models. This chapter takes a close look at what a color
model is, along with how color models impact image handling and
Java graphics in general.
<P>
In this chapter, you also learn about Java image filters and how
they are used to manipulate graphical images. Image filtering
is a powerful feature of Java that is tightly linked to color
models. Java provides a variety of image filter classes that interact
together to form a framework for easily filtering graphical images.
You can extend the standard Java image filtering classes and build
your own image filters to perform just about any type of image
processing you can imagine. You learn how to implement your own
image filters near the end of this chapter.
<P>
Together, color models and image filters form an integral part
of the advanced Java graphics API. By the end of this chapter,
you will be well on your way to becoming a Java graphics wizard!
<H2><A NAME="UnderstandingColor"><FONT SIZE=5 COLOR=#FF0000>Understanding
Color</FONT></A></H2>
<P>
Before jumping into the specifics of what a color model is and
how it works in Java, it's important to understand how color is
represented on a computer in general. Although most operating
systems have some degree of platform-dependent handling of color,
they all share a common approach to the general representation
of colors. Knowing that all data in a computer is ultimately stored
in a binary form, it stands to reason that physical colors are
somehow mapped to binary values (numbers) in the computer domain.
The question is, how are colors mapped to numbers?
<P>
One way to come up with numeric representations of colors would
be to start at one end of the color spectrum and assign numbers
to each color until you reach the other end. This approach solves
the problem of representing a color as a number, but it doesn't
provide any way to handle the mixing of colors. As anyone who
has experienced the joy of Play-Doh<FONT FACE="Symbol">&#137;</FONT>
can tell you, colors react in different ways when combined with
each other. The way colors mix to form other colors goes back
to physics, which is a little beyond this discussion. A computer
color system needs to be able to handle mixing colors with accurate,
predictable results.
<P>
The best place to look for a solution to the color problem is
a color computer monitor. A color monitor has three electron guns:
red, green, and blue. The output from these three guns converge
on each pixel of the screen, exciting phosphors to produce the
appropriate color (see Figure 12.1). The combined intensities
of each gun determine the resulting pixel color. This convergence
of different colors from the monitor guns is very similar to the
convergence of different colored Play-Doh The primary difference
is that monitors use only these three colors (red, green, and
blue) to come up with every possible color that can be represented
on a computer. (Actually, the biggest difference is that Play-Doh
can't display high-resolution computer graphics, but that's another
discussion.)
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-1.gif" ><B>Figure 12.1 : </B><I>Electron guns in a color monitor converging to create a unique color.</I></A>
<P>
Knowing that monitors form unique colors by using varying intensities
of the colors red, green, and blue, you might be thinking that
a good solution to the color problem would be to provide an intensity
value for each of these primary colors. This is exactly how computers
model color. Computers represent different colors by combining
the numeric intensities of the primary colors red, green, and
blue. This color system is known as RGB (Red Green Blue) and is
fully supported by Java.
<P>
Although RGB is the most popular computer color system in use,
there are others. Another popular color system is HSB, which stands
for Hue Saturation Brightness. In this system, colors are defined
by varying degrees of hue, saturation, and brightness. The HSB
color system is also supported by Java.
<H2><A NAME="ColorImagesinJava"><FONT SIZE=5 COLOR=#FF0000>Color
Images in Java</FONT></A></H2>
<P>
Bitmapped computer images are composed of pixels that describe
the colors at each location of an image. Each pixel in an image
has a unique color that is usually described using the RGB color
system. Java provides support for working with 32-bit images,
which means that each pixel in an image is described as using
32 bits. The red, green, and blue components of a pixel's color
are stored in these 32 bits, along with an alpha component. The
alpha component of a pixel refers to the transparency or opaqueness
of the pixel.
<P>
A 32-bit Java image pixel is therefore composed of red, green,
blue, and alpha components. By default, these four components
are packed into a 32-bit pixel value, as shown in Figure 12.2.
Notice that each component is described by 8 bits, yielding possible
values between 0 and 255 for each. These components are packed
into the 32-bit pixel value from high-order bits to low-order
bits in the following order: alpha, red, green, and blue. It is
possible for the pixel components to be packed differently, but
this is the default pixel storage method used in Java.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-2.gif" ><B>Figure 12.2 : </B><I>The four components of a pixel in a 32-bit Java image.</I></A>
<P>
A color component value of 0 means the component is absent, and
a value of 255 means it is maxed out. If all three color components
are 0, the resulting pixel color is black. Likewise, if all three
components are 255, the color is white. If the red component is
255 and the others are 0, the resulting color is pure red.
<P>
The alpha component describes the transparency of a pixel, independent
of the color components. An alpha value of 0 means a pixel is
completely transparent (invisible), and an alpha value of 255
means a pixel is completely opaque. Values between 0 and 255 enable
the background color to show through a pixel in varying degrees.
<P>
The color components of a Java image are encapsulated in a simple
class called <TT>Color</TT>. The <TT>Color</TT>
class is a member of the AWT package and represents the three
primary color components: red, green, and blue. This class is
useful because it provides a clean abstraction for representing
color, along with useful methods for extracting and modifying
the primary components. The <TT>Color</TT>
class also contains predefined constant members representing many
popular colors.
<H2><A NAME="ColorModels"><FONT SIZE=5 COLOR=#FF0000>Color Models</FONT></A>
</H2>
<P>
In Java, pixel colors are managed through color models. Java color
models provide an important abstraction that enables Java to work
with images of different formats in a similar fashion. More specifically,
a color model is a Java object that provides methods for translating
from pixel values to the corresponding red, green, and blue color
components of an image. At first, this may seem like a trivial
chore, knowing that pixel color components are packed neatly into
a 32-bit value. However, there are different types of color models
reflecting different methods of maintaining pixel colors. The
two types of color models supported by Java are direct color models
and index color models.
<H3>Direct Color Models</H3>
<P>
Direct color models are based on the earlier description of pixels,
where each pixel contains specific color and alpha components.
Direct color models provide methods for translating these types
of pixels into their corresponding color and alpha components.
Typically, direct color models extract the appropriate components
from the 32-bit pixel value using bit masks.
<H3>Index Color Models</H3>
<P>
Index color models work differently from direct color models.
In fact, index color models work with pixels containing completely
different information than you've learned thus far. Pixels in
an image using an index color model don't contain the alpha and
RGB components like the pixels used in a direct color model. An
index color model pixel contains an index into an array of fixed
colors (see Figure 12.3). This array of colors is called a <I>color
map</I>.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-3.gif" ><B>Figure 12.3 : </B><I>An index color model pixel and its associated color map.</I></A>
<P>
An example of an image that uses an index color model is a 256-color
image. 256-color images use 8 bits to describe each pixel, which
doesn't leave much room for RGB components. Rather than try to
cram these components into 8 bits, 256-color pixels store an 8-bit
index in a color map. The color map has 256 color entries that
each contain RGB and alpha values describing a particular color.
<P>
Index color models provide methods for resolving pixels containing
color map indices into alpha, red, green, and blue components.
Index color models handle looking up the index of a pixel in the
color map and extracting the appropriate components from the color
entry.
<P>
Index color models provide an additional feature not available
in direct color models: support for a transparent pixel color.
Using an index color model, you can specify a color in the color
map as the transparent color for the image. When the image is
drawn, pixels having the transparent color are left out. The background
shows through these pixels, effectively resulting in the pixels
being completely transparent.
<P>
The transparency feature is very useful when working with images
that have an irregular shape. All images are stored as rectangles
and typically are drawn in a rectangular region. By using a transparent
color to define the region around the irregular shape, the image
can be drawn on a background without erasing a rectangular area
of the background. Figure 12.4 shows the difference between images
drawn with and without a transparent color.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-4.gif" ><B>Figure 12.4 : </B><I>The effects of using a transparency color to draw an image.</I></A>
<H2><A NAME="TheColorModelClasses"><FONT SIZE=5 COLOR=#FF0000>The
Color Model Classes</FONT></A></H2>
<P>
Java provides standard classes for working with color models.
At the top of the hierarchy is the <TT>ColorModel</TT>
class, which defines the core functionality required of all color
models. Two other classes are derived from <TT>ColorModel</TT>,
representing the two types of color models supported by Java:
<TT>DirectColorModel</TT> and <TT>IndexColorModel</TT>.
<H3><TT><FONT SIZE=4 >ColorModel</FONT></TT></H3>
<P>
The <TT>ColorModel</TT> class is an
abstract class containing the basic support required to translate
pixel values into alpha and color components. <TT>ColorModel</TT>
contains the following methods:
<UL>
<LI><TT>ColorModel(int bits)</TT>
<LI><TT>static ColorModel getRGBdefault()</TT>
<LI><TT>int getPixelSize()</TT>
<LI><TT>abstract int getRed(int pixel)</TT>
<LI><TT>abstract int getGreen(int pixel)</TT>
<LI><TT>abstract int getBlue(int pixel)</TT>
<LI><TT>abstract int getAlpha(int pixel)</TT>
<LI><TT>int getRGB(int pixel)</TT>
</UL>
<P>
The <TT>ColorModel</TT> method is
the only creation method defined for the <TT>ColorModel</TT>
class. It takes a single integer parameter that specifies the
pixel width of the color model in bits.
<P>
The <TT>getRGBdefault</TT> method
is a class method that returns a <TT>ColorModel</TT>
object based on the default RGB pixel component storage, as described
earlier in this chapter (<TT>0xAARRGGBB</TT>).
<P>
The <TT>getPixelSize</TT> method returns
the current pixel width of the color model. For example, the default
color model would return <TT>32</TT>
as the number of bits used to represent each pixel. The following
piece of code shows how you can check this yourself:
<BLOCKQUOTE>
<TT>System.out.println(ColorModel.getRGBdefault().getPixelSize());</TT>
</BLOCKQUOTE>
<P>
The four methods that get each different pixel component are all
defined as abstract. This means that a derived color model class
must provide the specific implementation for these methods. The
reason for this goes back to the issue of supporting different
types of color models. Getting the color components of a pixel
is completely dependent on how each pixel represents colors in
an image, which is determined by the color model. For direct color
models, you can extract the components by simply masking out the
correct 8-bit values. For an index color model, however, you have
to use each pixel's value as an index into a color map and then
retrieve the components from there. In keeping with the object-oriented
structure of Java, the <TT>ColorModel</TT>
class provides the method descriptions but leaves the specific
implementations to more specific color model classes.
<P>
The last method in the <TT>ColorModel</TT>
class is <TT>getRGB</TT>, which returns
the color of a pixel using the default color model. You can use
this method to get a pixel value in the default RGB color model
format.
<H3><TT><FONT SIZE=4 >DirectColorModel</FONT></TT>
</H3>
<P>
The <TT>DirectColorModel</TT> class
is derived from <TT>ColorModel</TT>
and provides specific support for direct color models. If you
recall, pixels in a direct color model directly contain the alpha
and color components in each pixel value. <TT>DirectColorModel</TT>
provides the following methods:
<UL>
<LI><TT>DirectColorModel(int bits, int rmask,
int gmask, int bmask)</TT>
<LI><TT>DirectColorModel(int bits, int rmask,
int gmask, int bmask, int</TT> <TT>amask)</TT>
<LI><TT>final int getRedMask()</TT>
<LI><TT>final int getGreenMask()</TT>
<LI><TT>final int getBlueMask()</TT>
<LI><TT>final int getAlphaMask()</TT>
<LI><TT>final int getRed(int pixel)</TT>
<LI><TT>final int getGreen(int pixel)</TT>
<LI><TT>final int getBlue(int pixel)</TT>
<LI><TT>final int getAlpha(int pixel)</TT>
<LI><TT>final int getRGB(int pixel)</TT>
</UL>
<P>
The first two methods are the creation methods for <TT>DirectColorModel</TT>.
The first creation method takes the pixel width of the color model,
along with the masks used to specify how each color component
is packed into the pixel bits. You may have noticed that there
is no mask parameter for the alpha component. Using this creation
method, the alpha component is forced to a value of 255, or fully
opaque. This is useful if you don't want any alpha information
to be represented. The second creation method is just like the
first, with the exception that it lets you specify an alpha mask.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A mask is used to extract specific bits out of an integer value. The bits are extracted by bitwise <TT>AND</TT>ing the mask with the value. Masks themselves are integers and are typically specified in hexadecimal. For example, to mask out the high-order 
word of a 32-bit value, you use the mask <TT>0xFFFF0000</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
If you're a little shaky with masks, think about the masks for
the default pixel component packing. Remember, the components
are packed from high-order to low-order in the following order:
alpha, red, green, and blue. Each component is eight bits, so
the mask for each component extracts the appropriate byte out
of the 32-bit pixel value. Table 12.1 shows the default RGB pixel
component masks.<BR>
<P>
<CENTER><B>Table 12.1. The default pixel component masks.</B></CENTER>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR><TD WIDTH=50%><CENTER><B>Pixel Component</B></TD><TD WIDTH=50%><CENTER><B>Mask</B></CENTER>
</TD></TR>
<TR><TD WIDTH=50%><CENTER>Alpha</TD><TD WIDTH=50%><CENTER><TT>0xFF000000</TT></CENTER>
</TD></TR>
<TR><TD WIDTH=50%><CENTER>Red</TD><TD WIDTH=50%><CENTER><TT>0x00FF0000</TT></CENTER>
</TD></TR>
<TR><TD WIDTH=50%><CENTER>Green</TD><TD WIDTH=50%><CENTER><TT>0x0000FF00</TT></CENTER>
</TD></TR>
<TR><TD WIDTH=50%><CENTER>Blue</TD><TD WIDTH=50%><CENTER><TT>0x000000FF</TT></CENTER>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
With <TT>DirectColorModel</TT>, there
are four methods that simply return the pixel component masks:
<TT>getRedMask</TT>, <TT>getGreenMask</TT>,
<TT>getBlueMask</TT>, and <TT>getAlphaMask</TT>.
Notice that these methods are defined as final, meaning that they
cannot be overridden in a derived class. The reason for this is
that the underlying native Java graphics code is dependent on
this specific implementation of these methods. You'll notice that
this is a common theme in the color model classes.
<P>
The four abstract methods defined in <TT>ColorModel</TT>
are implemented in <TT>DirectColorModel</TT>:
<TT>getRed</TT>, <TT>getGreen</TT>,
<TT>getBlue</TT>, and <TT>getAlpha</TT>.
These methods return the appropriate component values of a pixel
in the range 0 to 255. Like the mask methods, these methods are
also defined as final, so that no derived classes can override
their behavior.
<P>
The <TT>getRGB</TT> method returns
the color of a pixel in the default color model format. This method
is no different than the one implemented in <TT>ColorModel</TT>.
<H3><TT><FONT SIZE=4 >IndexColorModel</FONT></TT>
</H3>
<P>
The <TT>IndexColorModel</TT> class
is also derived from <TT>ColorModel</TT>
and provides support for index color models. Recall from the earlier
discussion of color models that pixels in an index color model
contain indices into a fixed array of colors known as a color
map. The <TT>IndexColorModel</TT>
class provides the following methods:
<UL>
<LI><TT>IndexColorModel(int bits, int size,
byte r[], byte g[], byte</TT> <TT>b[])</TT>
<LI><TT>IndexColorModel(int bits, int size,
byte r[], byte g[], byte</TT> <TT>b[],
int trans)</TT>
<LI><TT>IndexColorModel(int bits, int size,
byte r[], byte g[], byte</TT> <TT>b[],
byte a[])</TT>
<LI><TT>IndexColorModel(int bits, int size,
byte cmap[], int start, boolean hasalpha)</TT>
<LI><TT>IndexColorModel(int bits, int size,
byte cmap[], int start, boolean hasalpha, int trans)</TT>
<LI><TT>final int getMapSize()</TT>
<LI><TT>final int getTransparentPixel()</TT>
<LI><TT>final void getReds(byte r[])</TT>
<LI><TT>final void getGreens(byte g[])</TT>
<LI><TT>final void getBlues(byte b[])</TT>
<LI><TT>final void getAlphas(byte a[])</TT>
<LI><TT>final int getRed(int pixel)</TT>
<LI><TT>final int getGreen(int pixel)</TT>
<LI><TT>final int getBlue(int pixel)</TT>
<LI><TT>final int getAlpha(int pixel)</TT>
<LI><TT>final int getRGB(int pixel)</TT>
</UL>
<P>
The first five methods are the creation methods for the <TT>IndexColorModel</TT>
class. They look kind of messy with all those parameters, but
they really aren't that bad. First, all the creation methods take
as their first parameter the width of each pixel in bits. They
all also take as their second parameter the size of the color
map array to be used by the color model.
<P>
In addition to the pixel width and color map array size, the first
three creation methods also take three byte arrays containing
the red, green, and blue components of each entry in the color
map. These arrays should all be the same length, which should
match the color map size passed in as the second parameter. The
second creation method enables you to specify the array index
of the transparent color. The third creation method enables you
to specify an array of alpha values to go along with the color
component arrays.
<P>
Rather than using parallel arrays of individual component values,
the last two creation methods take a single array of &quot;packed&quot;
pixel component values-the color components are stored sequentially
in a single array instead of in separate parallel arrays. The
<TT>start</TT> parameter specifies
the index to begin including colors from the array. The <TT>hasalpha</TT>
parameter specifies whether the colors in the array include alpha
information. The only difference between these two methods is
that the second version enables you to specify the array index
for the transparent color.
<P>
The <TT>getMapSize</TT> method returns
the size of the color map used by the color model.
<P>
The <TT>getTransparentPixel</TT> method
returns the array index of the transparent pixel color, if it
is defined. Otherwise, <TT>getTransparentPixel</TT>
returns <TT>-1</TT>.
<P>
There are four methods for getting the color values from the color
map: <TT>getReds</TT>, <TT>getGreens</TT>,
<TT>getBlues</TT>, and <TT>getAlphas</TT>.
Each method takes an array of bytes as the only parameter and
fills it with the color map values for the appropriate pixel component.
These methods are final, so you can't override them in a derived
class.
<P>
<TT>IndexColorModel</TT> provides
implementations for the four abstract methods defined in <TT>ColorModel</TT>:
<TT>getRed</TT>, <TT>getGreen</TT>,
<TT>getBlue</TT>, and <TT>getAlpha</TT>.
These methods return the appropriate component values of a pixel
in the range 0-255. These methods are also defined as final, so
derived classes aren't allowed to modify their behavior.
<P>
The <TT>getRGB</TT> method returns
the color of a pixel in the default RGB color model format. Because
the default color model is a direct color model, this method effectively
converts an index color to a direct color.
<H2><A NAME="WorkingwithColorModels"><FONT SIZE=5 COLOR=#FF0000>Working
with Color Models</FONT></A></H2>
<P>
Okay, so you know all about color models and the Java classes
that bring them to life. Now what? Most of the time they act behind
the scenes. It is fairly rare that you will need to create or
manipulate a color model directly.
<P>
Color models are used extensively in the internal implementations
of the various image processing classes, however. What does this
mean to you, the ever-practical Java programmer? It means that
you now know a great deal about the internal workings of color
in the Java graphics system. Without fully understanding color
models and how they work, you would no doubt run into difficulties
when trying to work with the advanced graphics and image processing
classes provided by Java.
<P>
Take a look at the Gradient sample program in Figure 12.5. The
Gradient sample program uses an <TT>IndexColorModel</TT>
object with 32 varying shades of green. It creates an image based
on this color model and sets the image pixels to a horizontal
gradient pattern. The complete source code for this program is
shown in Listing 12.1. It is also included on the CD-ROM in the
file Gradient.java.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-5.gif" ><B>Figure 12.5 : </B><I>The Gradient sample program.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 12.1. The Gradient sample program.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Gradient Class<BR>
// Gradient.java<BR>
<BR>
// Imports<BR>
import java.applet.Applet;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
public class Gradient extends Applet {<BR>
&nbsp;&nbsp;final int colors = 32;<BR>
&nbsp;&nbsp;final int width = 200;<BR>
&nbsp;&nbsp;final int height = 200;<BR>
&nbsp;&nbsp;Image img;<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the color map<BR>
&nbsp;&nbsp;&nbsp;&nbsp;byte[] rbmap = new byte[colors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;byte[] gmap = new byte[colors];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; colors; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gmap[i] = (byte)((i * 255)
/ (colors - 1));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the color model<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int bits = (int)Math.ceil(Math.log(colors)
/ Math.log(2));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;IndexColorModel model = new IndexColorModel(bits,
colors,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rbmap, gmap, rbmap);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the pixels<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int pixels[] = new int[width * height];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int index = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int y = 0; y &lt; height; y++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int x = 0; x &lt; width;
x++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels[index++]
= (x * colors) / width;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;img = createImage(new MemoryImageSource(width,
height, model,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixels, 0, width));<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(img, 0, 0, this);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The Gradient program starts off by declaring a few final member
variables for determining the number of colors used in the index
color model, along with the size of the image.
<P>
It then creates a color map by building two arrays for the color
components. The first array, <TT>rbmap</TT>,
is used for both the red and blue color components. The second
array, <TT>gmap</TT>, is used for
the green color component. The <TT>rbmap</TT>
array is left in its initial state. Remember, Java automatically
initializes all member variables to zero. The <TT>gmap</TT>
array is initialized to equally spaced values between 0 and 255,
dependent on the number of colors in the color map (as specified
by <TT>colors</TT>). The arrays are
set up this way because you want the color map to contain shades
of green. This is accomplished by specifying non-zero values for
the green component of the color map and leaving the red and blue
components set to 0.
<P>
With the color map created, you are ready to create the index
color model. The creation method for <TT>IndexColorModel</TT>
requires you to specify the pixel width of the color model. The
pixel width is simply how many bits are required for a pixel to
store an index in the color map. Calculating the pixel width is
a matter of determining how many bits <I>(b)</I> are necessary
to index an array of (<I>n</I>) colors. I won't go into the details
of where the equation comes from, but the following equation yields
the desired result:
<BLOCKQUOTE>
<TT>b = log(n) / log(2)</TT>
</BLOCKQUOTE>
<P>
To understand the implications of this equation, think about the
number of colors used in the program. The final member variable
<TT>colors</TT> is set to 32, meaning
that the color model contains 32 color entries. Each pixel needs
to be able to distinguish between (or index) these 32 different
entries. Using the previous equation, you'll find that 5 bits
per pixel are enough to index an array of 32 colors. Likewise,
8 bits per pixel are required to index an array of 256 colors.
<P>
You may notice that the equation used in Gradient is a little
different; it calls the <TT>ceil</TT>
method as well as the <TT>log</TT>
method, like this:
<BLOCKQUOTE>
<TT>int bits = (int)Math.ceil(Math.log(colors)
/ Math.log(2));</TT>
</BLOCKQUOTE>
<P>
The call to <TT>ceil</TT> is there
to make sure there are enough bits in case the number of colors
is set to a value that is not a power of 2. For example, what
if you change <TT>colors</TT> to 45
instead of 32? The result of the original equation would be 5.49,
but the .49 would be lost in the cast to a byte. The resulting
5 would not be enough bits per pixel to keep up with 45 colors.
The trick is always to use the smallest whole number greater than
or equal to the floating-point result before casting. This is
exactly what the <TT>ceil</TT> method
does.
<P>
With the <TT>IndexColorModel</TT>
creation method, you pass in the newly calculated pixel width,
the number of colors, and the three color component arrays. The
zero-filled <TT>rbmap</TT> array is
used for both the red and blue component arrays.
<P>
Now the color model is created and ready to go, but there is still
some work to be done. A bitmap image based on an index color model
is composed of pixels that reference the colors in the color map.
To create an image, you simply build up an array of pixels with
the length equal to the width times the height of the image. The
pixel array for the new image is created and each pixel initialized
using nested <TT>for</TT> loops. Each
pixel is initialized using the following equation:
<BLOCKQUOTE>
<TT>pixels[index++] = (x * colors) / width;</TT>
</BLOCKQUOTE>
<P>
This equation results in an equal distribution of colors (gradient)
horizontally across the image.
<P>
The image is actually created with a call to the <TT>createImage</TT>
method. This method takes a <TT>MemoryImageSource</TT>
object as its only parameter. The <TT>MemoryImageSource</TT>
class uses an array of pixel values to build an image in memory.
The creation method for <TT>MemoryImageSource</TT>
takes the width, height, color model, pixel array, pixel array
offset, and scan line width for the image. It's simply a matter
of plugging in the information you've already created.
<P>
At this point, you have an image made up of gradient pixels that
contain indices into a color model with 32 shades of green. Now
the fun part-drawing the image! A simple call to <TT>drawImage</TT>
in the <TT>paint</TT> method is all
it takes.
<H2><A NAME="ImageFilters"><FONT SIZE=5 COLOR=#FF0000>Image Filters</FONT></A>
</H2>
<P>
A thriving area of software research and development is image
processing. Most popular paint programs contain image processing
features, such as sharpening or softening an image. Typically,
image processing developers have to build complex libraries of
routines for manipulating images. Java provides a simple, yet
powerful framework for manipulating images. In Java, image processing
objects are called image filters, and they serve as a way to abstract
the filtering of an image without worrying about the details associated
with the source or destination of the image data.
<P>
A Java image filter can be thought of quite literally as a filter
into which all the data for an image must enter and exit on its
way from a source to a destination. Take a look at Figure 12.6
to see how image data passes through an image filter.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-6.gif" ><B>Figure 12.6 : </B><I>Image data passing through an image filter.</I></A>
<P>
While passing through a filter, the individual pixels of an image
can be altered in any way as determined by that filter. By design,
image filters are structured to be self-contained components.
The image filter model supported by Java is based on three logical
components: an image producer, an image filter, and an image consumer.
The image producer makes the raw pixel data for an image available.
The image filter in turn filters this data. The resulting filtered
image data is then passed on to the image consumer where it has
usually been requested. Figure 12.7 shows how these three components
interact with each other.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-7.gif" ><B>Figure 12.7 : </B><I>The relationship between an image producer, an image filter, and an image consumer.</I></A>
<P>
Breaking down the process of filtering images into these three
components provides a very powerful object-oriented solution to
a complex problem. Different types of image producers can be derived
that are able to retrieve image data from a variety of sources.
Likewise, filters can ignore the complexities associated with
different image sources and focus on the details of manipulating
the individual pixels of an image.
<H2><A NAME="TheImageFilterClasses"><FONT SIZE=5 COLOR=#FF0000>The
Image Filter Classes</FONT></A></H2>
<P>
Java support for image filters is scattered across several classes
and interfaces. You don't necessarily have to understand all these
classes in detail to work with image filters, but it is important
that you understand what functionality they provide and where
they fit into the scheme of things. Here are the Java classes
and interfaces that provide support for image filtering:
<UL>
<LI><TT>ImageProducer</TT>
<LI><TT>FilteredImageSource</TT>
<LI><TT>MemoryImageSource</TT>
<LI><TT>ImageConsumer</TT>
<LI><TT>PixelGrabber</TT>
<LI><TT>ImageFilter</TT>
<LI><TT>RGBImageFilter</TT>
<LI><TT>CropImageFilter</TT>
</UL>
<H3><TT><FONT SIZE=4 >ImageProducer</FONT></TT>
</H3>
<P>
The <TT>ImageProducer</TT> interface
provides the method descriptions necessary to extract image pixel
data from <TT>Image</TT> objects.
Classes implementing the <TT>ImageProducer</TT>
interface provide implementations for these methods specific to
the image sources they represent. For example, the <TT>MemoryImageSource</TT>
class implements the <TT>ImageProducer</TT>
interface and produces image pixels from an array of pixel values
in memory.
<H3><TT><FONT SIZE=4 >FilteredImageSource</FONT></TT>
</H3>
<P>
The <TT>FilteredImageSource</TT> class
implements the <TT>ImageProducer</TT>
interface and produces filtered image data. The filtered image
data produced is based on the image and the filter object passed
in <TT>FilteredImageSource</TT>'s
creation method. <TT>FilteredImageSource</TT>
provides a very easy way to apply image filters to <TT>Image</TT>
objects.
<H3><TT><FONT SIZE=4 >MemoryImageSource</FONT></TT>
</H3>
<P>
The <TT>MemoryImageSource</TT> class
implements the <TT>ImageProducer</TT>
interface and produces image data based on an array of pixels
in memory. This is very useful in cases where you need to build
an <TT>Image</TT> object directly
from data in memory. You used the <TT>MemoryImageSource</TT>
class earlier in this chapter in the Gradient sample program.
<H3><TT><FONT SIZE=4 >ImageConsumer</FONT></TT>
</H3>
<P>
The <TT>ImageConsumer</TT> interface
provides method prototypes necessary for an object to retrieve
image data from an image producer. Instantiated classes implementing
the <TT>ImageConsumer</TT> interface
are attached to an image producer object when they are interested
in its image data. The image producer object delivers the image
data by calling methods defined by the <TT>ImageConsumer</TT>
interface.
<H3><TT><FONT SIZE=4 >PixelGrabber</FONT></TT></H3>
<P>
The <TT>PixelGrabber</TT> class implements
the <TT>ImageConsumer</TT> interface
and provides a way of retrieving a subset of the pixels in an
image. A <TT>PixelGrabber</TT> object
can be created based on either an <TT>Image</TT>
object or an object implementing the <TT>ImageProducer</TT>
interface. The creation method for <TT>PixelGrabber</TT>
enables you to specify a rectangular section of the image data
to be grabbed. This image data is then delivered by the image
producer to the <TT>PixelGrabber</TT>
object.
<H3><TT><FONT SIZE=4 >ImageFilter</FONT></TT></H3>
<P>
The <TT>ImageFilter</TT> class provides
the basic functionality of an image filter that operates on image
data being delivered from an image producer to an image consumer.
<TT>ImageFilter</TT> objects are specifically
designed to be used in conjunction with <TT>FilteredImageSource</TT>
objects.
<P>
The <TT>FilterImage</TT> class is
implemented as a null filter, which means that it passes image
data through unmodified. Nevertheless, it implements the overhead
for processing the data in an image. The only thing missing is
the actual modification of the pixel data, which is left up to
derived filter classes. This is actually a very nice design, because
it enables you to create new image filters by deriving from <TT>ImageFilter</TT>
and overriding a few methods.
<H3><TT><FONT SIZE=4 >RGBImageFilter</FONT></TT>
</H3>
<P>
The <TT>ImageFilter</TT> class operates
on an image using the color model defined by the image producer.
The <TT>RGBImageFilter</TT> class,
on the other hand, derives from <TT>ImageFilter</TT>
and implements an image filter specific to the default RGB color
model. <TT>RGBImageFilter</TT> provides
the overhead necessary to process image data in a single method
that converts pixels one at a time in the default RGB color model.
This processing takes place in the default RGB color model regardless
of the color model used by the image producer. Like <TT>ImageFilter</TT>,
<TT>RGBImageFilter</TT> is meant to
be used in conjunction with the <TT>FilteredImageSource</TT>
image producer.
<P>
The seemingly strange thing about <TT>RGBImageFilter</TT>
is that it is an abstract class, so you can't instantiate objects
from it. It is abstract because of a single abstract method, <TT>filterRGB</TT>.
The <TT>filterRGB</TT> method is used
to convert a single input pixel to a single output pixel in the
default RGB color model. <TT>filterRGB</TT>
is the workhorse method that handles filtering the image data;
each pixel in the image is sent through this method for processing.
To create your own RGB image filters, all you must do is derive
from <TT>RGBImageFilter</TT> and implement
the <TT>filterRGB</TT> method. This
is the technique you use later in this chapter to implement your
own image filters.
<P>
The <TT>RGBImageFilter</TT> class
contains a member variable that is very important in determining
how it processes image data: <TT>canFilterIndexColorModel</TT>.
The <TT>canFilterIndexColorModel</TT>
member variable is a boolean that specifies whether the <TT>filterRGB</TT>
method can be used to filter the color map entries of an image
using an index color model. If this member variable is <TT>false</TT>,
each pixel in the image is processed.
<H3><TT><FONT SIZE=4 >CropImageFilter</FONT></TT>
</H3>
<P>
The <TT>CropImageFilter</TT> class
is derived from <TT>ImageFilter</TT>
and provides a means of extracting a rectangular region within
an image. Like <TT>ImageFilter</TT>,
the <TT>CropImageFilter</TT> class
is designed to be used with the <TT>FilteredImageSource</TT>
image producer.
<P>
You may be a little confused by <TT>CropImageFilter</TT>,
because the <TT>PixelGrabber</TT>
class mentioned earlier sounds very similar. It is important to
understand the differences between these two classes because they
perform very different functions. First, remember that <TT>PixelGrabber</TT>
implements the <TT>ImageConsumer</TT>
interface, so it functions as an image consumer. <TT>
CropImageFilter</TT>, on the other hand, is an image filter.
This means that <TT>PixelGrabber</TT>
is used as a destination for image data, where <TT>CropImageFilter</TT>
is applied to image data in transit. You use <TT>PixelGrabber</TT>
to extract a region of an image to store in an array of pixels
(the destination). You use <TT>CropImageFilter</TT>
to extract a region of an image that is sent along to its destination
(usually another <TT>Image</TT> object).
<H2><A NAME="WritingYourOwnImageFilters"><FONT SIZE=5 COLOR=#FF0000>Writing
Your Own Image Filters</FONT></A></H2>
<P>
Although the standard Java image filter classes are powerful as
a framework, they aren't that exciting to work with by themselves.
Image filters don't really get interesting until you start implementing
your own. Fortunately, the Java classes make it painfully simple
to write your own image filters.
<P>
All the image filters you develop in this chapter are derived
from <TT>RGBImageFilter</TT>, which
enables you to filter images through a single method, <TT>filterRGB</TT>.
It really is as easy as deriving your class from <TT>RGBImageFilter</TT>
and implementing the <TT>filterRGB</TT>
method.
<H3>A Color Image Filter</H3>
<P>
Probably the simplest image filter imaginable is one that filters
out the individual color components (red, green, and blue) of
an image. The <TT>ColorFilter</TT>
class does exactly that. Listing 12.2 contains the source code
for the <TT>ColorFilter</TT> class.
It is located on the CD-ROM in the file ColorFilter.java.
<HR>
<BLOCKQUOTE>
<B>Listing 12.2. The </B><TT><B></TT>ColorFilter</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Color Filter Class<BR>
// ColorFilter.java<BR>
<BR>
// Imports<BR>
import java.awt.image.*;<BR>
<BR>
class ColorFilter extends RGBImageFilter {<BR>
&nbsp;&nbsp;boolean red, green, blue;<BR>
<BR>
&nbsp;&nbsp;public ColorFilter(boolean r, boolean g, boolean b)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;red = r;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;green = g;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;blue = b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;canFilterIndexColorModel = true;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public int filterRGB(int x, int y, int rgb) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Filter the colors<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int r = red ? 0 : ((rgb &gt;&gt; 16) &amp;
0xff);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int g = green ? 0 : ((rgb &gt;&gt; 8)
&amp; 0xff);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int b = blue ? 0 : ((rgb &gt;&gt; 0) &amp;
0xff);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Return the result<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (rgb &amp; 0xff000000) | (r &lt;&lt;
16) | (g &lt;&lt; 8) | (b &lt;&lt; 0);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ColorFilter</TT> class is
derived from <TT>RGBImageFilter</TT>
and contains three boolean member variables that determine which
colors are to be filtered out of the image. These member variables
are set by the parameters passed into the creation method. The
member variable inherited from <TT>RGBImageFilter</TT>,
<TT>canFilterIndexColorModel</TT>,
is set to <TT>true</TT> to indicate
that the color map entries can be filtered using <TT>filterRGB</TT>
if the incoming image is using an index color model.
<P>
Beyond the creation method, <TT>ColorFilter</TT>
implements only one method, <TT>filterRGB</TT>,
which is the abstract method inherited from <TT>RGBImageFilter</TT>.
<TT>filterRGB</TT> takes three parameters:
the x and y position of the pixel within the image, and the 32-bit
(integer) color value. The only parameter you are concerned with
is the color value (<TT>rgb</TT>).
<P>
Recalling that the default RGB color model places the red, green,
and blue components in the lower 24 bits of the 32-bit color value,
it is easy to extract each one by shifting out of the <TT>rgb</TT>
parameter. These individual components are stored in the local
variables <TT>r</TT>, <TT>g</TT>,
and <TT>b</TT>. Notice, however, that
each color component is shifted only if it is not being filtered.
For filtered colors, the color component is set to zero.
<P>
The new color components are shifted back into a 32-bit color
value and returned from <TT>filterRGB</TT>.
Notice that care is taken to ensure that the alpha component of
the color value is not altered. The <TT>0xff000000</TT>
mask takes care of this, because the alpha component resides in
the upper byte of the color value.
<P>
Congratulations, you've written your first image filter! You have
two more to go before you plug them all into a test program.
<H3>An Alpha Image Filter</H3>
<P>
It isn't always apparent to programmers how the alpha value stored
in the color value for each pixel impacts an image. Remember,
the alpha component specifies the transparency or opaqueness of
a pixel. By altering the alpha values for an entire image, you
can make it appear to fade in and out. This works because the
alpha values range from totally transparent (invisible) to totally
opaque.
<P>
The <TT>AlphaFilter</TT> class filters
the alpha components of an image based on the alpha level you
supply in its creation method. Listing 12.3 contains the source
code for the <TT>AlphaFilter</TT>
class. It is located on the CD-ROM in the file AlphaFilter.java.
<HR>
<BLOCKQUOTE>
<B>Listing 12.3. The </B><TT><B></TT>AlphaFilter</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Alpha Filter Class<BR>
// AlphaFilter.java<BR>
<BR>
// Imports<BR>
import java.awt.image.*;<BR>
<BR>
class AlphaFilter extends RGBImageFilter {<BR>
&nbsp;&nbsp;int alphaLevel;<BR>
<BR>
&nbsp;&nbsp;public AlphaFilter(int alpha) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;alphaLevel = alpha;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;canFilterIndexColorModel = true;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public int filterRGB(int x, int y, int rgb) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Adjust the alpha value<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int alpha = (rgb &gt;&gt; 24) &amp; 0xff;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;alpha = (alpha * alphaLevel) / 255;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Return the result<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return ((rgb &amp; 0x00ffffff) | (alpha
&lt;&lt; 24));<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>AlphaFilter</TT> class contains
a single member variable, <TT>alphaLevel</TT>,
that keeps up with the alpha level to be applied to the image.
This member variable is initialized in the creation method, as
is the <TT>canFilterIndexModel</TT>
member variable.
<P>
Similar to the <TT>ColorFilter</TT>
class, the <TT>filterRGB</TT> method
is the only other method implemented by <TT>AlphaFilter</TT>.
The alpha component of the pixel is first extracted by shifting
it into a local variable, <TT>alpha</TT>.
This value is then scaled according to the <TT>alphaLevel</TT>
member variable initialized in the creation method. The purpose
of the scaling is to alter the alpha value based on its current
value. If you were just to set the alpha component to the alpha
level, you wouldn't be taking into account the original alpha
component value.
<P>
The new alpha component is shifted back into the pixel color value
and the result returned from <TT>filterRGB</TT>.
Notice that the red, green, and blue components are preserved
by using the <TT>0x00ffffff</TT> mask.
<H3>A Brightness Image Filter</H3>
<P>
So far, the image filters you've seen have been pretty simple.
The last one you create is a little more complex, but it acts
as a more interesting filter. The <TT>BrightnessFilter</TT>
class implements an image filter that brightens or darkens an
image based on a brightness percentage you provide in the creation
method. Listing 12.4 contains the source code for the <TT>BrightnessFilter</TT>
class. It is located on the CD-ROM in the file BrightnessFilter.java.
<HR>
<BLOCKQUOTE>
<B>Listing 12.4. The </B><TT><B></TT>BrightnessFilter</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Brightness Filter Class<BR>
// BrightnessFilter.java<BR>
<BR>
// Imports<BR>
import java.awt.image.*;<BR>
<BR>
class BrightnessFilter extends RGBImageFilter {<BR>
&nbsp;&nbsp;int brightness;<BR>
<BR>
&nbsp;&nbsp;public BrightnessFilter(int b) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;brightness = b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;canFilterIndexColorModel = true;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public int filterRGB(int x, int y, int rgb) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Get the individual colors<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int r = (rgb &gt;&gt; 16) &amp; 0xff;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int g = (rgb &gt;&gt; 8) &amp; 0xff;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int b = (rgb &gt;&gt; 0) &amp; 0xff;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Calculate the brightness<BR>
&nbsp;&nbsp;&nbsp;&nbsp;r += (brightness * r) / 100;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g += (brightness * g) / 100;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;b += (brightness * b) / 100;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Check the boundaries<BR>
&nbsp;&nbsp;&nbsp;&nbsp;r = Math.min(Math.max(0, r), 255);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g = Math.min(Math.max(0, g), 255);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;b = Math.min(Math.max(0, b), 255);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Return the result<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (rgb &amp; 0xff000000) | (r &lt;&lt;
16) | (g &lt;&lt; 8) | (b &lt;&lt; 0);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>BrightnessFilter</TT> class
contains one member variable, <TT>brightness</TT>,
that keeps track of the percentage to alter the brightness of
the image. This member variable is set via the creation method,
along with the <TT>canFilterIndexModel</TT>
member variable. The <TT>brightness</TT>
member variable can contain values in the range -100 to 100. A
value of -100 means the image is darkened by 100 percent, and
a value of 100 means the image is brightened by 100 percent. A
value of 0 doesn't modify the image at all.
<P>
It should come as no surprise by now that <TT>filterRGB</TT>
is the only other method implemented by <TT>BrightnessFilter</TT>.
In <TT>filterRGB</TT>, the individual
color components are first extracted into the local variables
<TT>r</TT>, <TT>g</TT>,
and <TT>b</TT>. The brightness effects
are then calculated based on the <TT>brightness</TT>
member variable. The new color components are then checked against
the 0 and 255 boundaries and modified if necessary.
<P>
Finally, the new color components are shifted back into the pixel
color value and returned from <TT>filterRGB</TT>.
Hey, it's not that complicated after all!
<H2><A NAME="UsingImageFilters"><FONT SIZE=5 COLOR=#FF0000>Using
Image Filters</FONT></A></H2>
<P>
You put in the time writing some of your own image filters, but
you have yet to enjoy the fruit of your labors. It's time to plug
the filters into a real Java applet and see how they work. Figure
12.8 shows the FilterTest applet busily at work filtering an image
of a train.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f12-8.gif" ><B>Figure 12.8 : </B><I>The Filter Test applet.</I></A>
<P>
The FilterTest applet uses all three filters you've written to
enable you to filter an image of a train. The R, G, and B keys
on the keyboard change the different colors filtered by the color
filter. The left and right arrow keys modify the alpha level for
the alpha filter. The up and down arrow keys alter the brightness
percentage used by the brightness filter. Finally, the Home key
restores the image to its unfiltered state.
<P>
Listing 12.5 contains the source code for the FilterTest applet.
The source code is located on the CD-ROM in the file FilterTest.java,
along with an HTML file containing a link to the applet, Example1.html.
<HR>
<BLOCKQUOTE>
<B>Listing 12.5. The FilterTest applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Filter Test Class<BR>
// FilterTest.java<BR>
<BR>
// Imports<BR>
import java.applet.Applet;<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
public class FilterTest extends Applet {<BR>
&nbsp;&nbsp;Image&nbsp;&nbsp;&nbsp;&nbsp; src, dst;<BR>
&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;red, green, blue;<BR>
&nbsp;&nbsp;final int alphaMax = 9;<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alphaLevel
= alphaMax;<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brightness;
<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;src = getImage(getDocumentBase(), &quot;Res/ChooChoo.gif&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dst = src;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(dst, 0, 0, this);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public boolean keyDown(Event evt, int key) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch (key) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case Event.HOME:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alphaLevel = alphaMax;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brightness = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case Event.LEFT:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (--alphaLevel &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alphaLevel = 0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case Event.RIGHT:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (++alphaLevel &gt; alphaMax)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alphaLevel = alphaMax;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case Event.UP:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brightness = Math.min(brightness
+ 10, 100);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case Event.DOWN:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brightness = Math.max(-100,
brightness - 10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'r':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'R':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;red = !red;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'g':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'G':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;green = !green;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'b':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case (int)'B':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blue = !blue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;filterImage();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void filterImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dst = src;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Apply the color filter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dst = createImage(new FilteredImageSource(dst.getSource(),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ColorFilter(red, green,
blue)));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Apply the alpha filter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dst = createImage(new FilteredImageSource(dst.getSource(),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new AlphaFilter((alphaLevel
* 255) / alphaMax)));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Apply the brightness filter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dst = createImage(new FilteredImageSource(dst.getSource(),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new BrightnessFilter(brightness)));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Redraw the image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>FilterTest</TT> applet class
contains member variables for keeping up with the source and destination
images, along with member variables for maintaining the various
filter parameters.
<P>
The first method implemented by <TT>FilterTest</TT>
is <TT>init</TT>, which loads the
image ChooChoo.gif into the <TT>src</TT>
member variable. It also initializes the <TT>dst</TT>
member variable to the same image.
<P>
The <TT>paint</TT> method is implemented
next, and it simply consists of one call to the <TT>drawImage</TT>
method, which draws the destination (filtered) <TT>Image</TT>
object.
<P>
The <TT>keyDown</TT> method is implemented
to handle keyboard events generated by the user. In this case,
the keys used to control the image filters are handled in the
<TT>switch</TT> statement. The corresponding
member variables are altered according to the keys pressed. Notice
the call to the <TT>filterImage</TT>
method at the bottom of <TT>keyDown</TT>.
<P>
The <TT>filterImage</TT> method is
where the actual filtering takes place; it applies each image
filter to the image. The <TT>dst</TT>
member variable is first initialized with the <TT>src</TT>
member variable to restore the destination image to its original
state. Each filter is then applied using a messy looking call
to <TT>createImage</TT>. The only
parameter to <TT>createImage</TT>
is an <TT>ImageProducer</TT> object.
In this case, you create a <TT>FilteredImageSource</TT>
object to pass into <TT>createImage</TT>.
The creation method for <TT>FilteredImageSource</TT>
takes two parameters: an image producer and an image filter. The
first parameter is an <TT>ImageProducer</TT>
object for the source image, which is obtained using the <TT>getSource</TT>
method for the image. The second parameter is an <TT>ImageFilter</TT>-derived
object.
<P>
The color filter is first applied to the image by creating a <TT>ColorFilter</TT>
object using the three boolean color value member variables. The
alpha filter is applied by creating an <TT>AlphaFilter</TT>
object using the <TT>alphaLevel</TT>
member variable. Rather than allowing 255 different alpha levels,
the alpha level is normalized to provide only 10 different alpha
levels. This is evident in the equation using <TT>alphaMax</TT>,
which is set to 9. Finally, the brightness filter is applied by
creating a <TT>BrightnessFilter</TT>
object and passing in the <TT>brightness</TT>
member variable.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
You covered a lot of territory in this chapter. You first learned
about colors in general and then about the heart of advanced Java
graphics, color models. After taking a good dose of color model
theory, you saw color models in action in the Gradient sample
program.
<P>
With color models under your belt, you moved on to image filters.
The Java image filter classes provide a powerful framework for
working with images without worrying about unnecessary details.
You learned about the different classes that comprise Java's support
for image filters. You then topped it off by writing three of
your own image filters, along with an applet that put them to
the test.
<P>
Above all, you learned in this chapter that Java is no slouch
when it comes to advanced graphics and image processing. You also
saw first hand how Java's support for color models and image filters
is very useful and easy to work with. In the next chapter, you
continue building your portfolio of Java graphics tricks by learning
about the Java media tracker.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch11.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch13.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

