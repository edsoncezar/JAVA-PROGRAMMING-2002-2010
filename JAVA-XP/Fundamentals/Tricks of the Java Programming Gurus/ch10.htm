<HTML>

<HEAD>
   <TITLE>Chapter 10 -- Combining AWT Components</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 10</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Combining AWT Components</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ComponentContainerPanel" >Component, Container, Panel</A>
<LI><A HREF="#EPluribusUnumOutofManyOne" >E Pluribus Unum: Out of Many-One</A>
<LI><A HREF="#PanelsAreComponentsToo" >Panels Are Components Too</A>
<LI><A HREF="#Layouts" >Layouts</A>
<LI><A HREF="#WhoseEventIsItAnyway" >Whose Event Is It Anyway?</A>
<LI><A HREF="#ThePanelasaComponentManager" >The Panel as a Component Manager</A>
<LI><A HREF="#AScrollingPictureWindowExample" >A Scrolling Picture Window Example</A>
<LI><A HREF="#Overview" >Overview</A>
<LI><A HREF="#ClassConstruction" >Class Construction</A>
<LI><A HREF="#EventHandling" >Event Handling</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
If you have ever served on a committee, you know how hard it is
for a group of people to work together to reach a common goal.
Without leadership, everyone seems to go their own way. Without
well-coordinated communication, duplication of effort can occur.
Likewise, if you try to put together a Java applet with several
AWT controls, it may seem like you have a big committee-lots of
activity but no leadership and no communication.
<P>
In this chapter, you learn how to combine AWT components. Unlike
forming a committee, this text establishes leadership, communication,
and division of labor. This cooperative effort produces a whole
that is much greater than the sum of the parts. Once you have
formed the <I>composite controls</I>, they will act like all the
rest of the AWT controls. You can use these new controls anywhere
that you use regular AWT controls.
<P>
To demonstrate composite controls, you create a scrolling picture
window control. This control takes an image and makes it scrollable.
All of the interaction between the AWT components that make up
the control gets handled internally. To use one, all you have
to do is create one and add it to your layout.
<H2><A NAME="ComponentContainerPanel"><TT><FONT SIZE=5 COLOR=#FF0000 >Component</FONT></TT><FONT SIZE=5 COLOR=#FF0000>,
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >Container</FONT></TT><FONT SIZE=5 COLOR=#FF0000>,
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >Panel</FONT></TT></A>
</H2>
<P>
Before you look at combining controls, you need to look at some
key AWT classes. These three classes-<TT>Component</TT>,
<TT>Container</TT>, and <TT>Panel</TT>-are
illustrated in Figure 10.1.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-1.gif" ><B>Figure 10.1 : </B><I>The core AWT classes.</I></A>
<P>
First, you examine the <TT>Component</TT>
class. <TT>Component</TT> is the base
class from which all AWT components are derived. Java does not
allow you to instantiate <TT>Component</TT>
or to directly subclass <TT>Component</TT>.
<P>
The <TT>Component</TT> class also
implements the <TT>ImageObserver</TT>
interface. <TT>ImageObserver</TT>
provides a means of keeping track of image properties as they
are loaded.
<P>
<TT>Container</TT> is a class derived
from <TT>Component</TT>. <TT>Containers</TT>
are objects that may contain other AWT <TT>Component</TT>s.
When a <TT>Container</TT> paint method
is called, all the embedded <TT>Component</TT>s'
<TT>paint</TT> methods are called
as well. <TT>Container</TT> provides
functions to manage embedded <TT>Component</TT>s.
Like <TT>Component</TT>s, you do not
actually instantiate <TT>Container</TT>
objects.
<P>
The last of the key classes is <TT>Panel</TT>.
<TT>Panel</TT> is derived from <TT>Container</TT>
and may be instantiated or subclassed. <TT>Panel</TT>s
are Java's multi-purpose <TT>Container</TT>s
and do not provide any special functionality, except the capability
to embed other GUI objects. <TT>Panel</TT>s
form the foundation of the composite controls you build.
<H2><A NAME="EPluribusUnumOutofManyOne"><FONT SIZE=5 COLOR=#FF0000>E
Pluribus Unum: Out of Many-One</FONT></A></H2>
<P>
Encapsulation is the technique used in object-oriented programming
to combine data and methods into classes. This principle is the
idea of grouping similar things. You also use encapsulation to
combine classes into composite classes. In <A HREF="ch9.htm" >Chapter 9</A>,
&quot;Extending AWT Components,&quot; you used subclassing to
extend controls.
<P>
In this chapter, you use <I>containment</I> to extend controls,
which means that you instance variables in your classes that are
themselves AWT classes.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
In Object-Oriented Programming (OOP), the containment relationship is called <I>hasa</I>. (For example, class <TT>Foo</TT> <I>hasa</I> member of type class <TT>Bar</TT>.) The subclassing relationship is called <I>isa</I>. (For example, class 
<TT>SubFoo</TT> <I>isa</I> derived class of class <TT>Foo</TT>.)
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3>Using <TT><FONT SIZE=4 >Panel</FONT></TT><FONT SIZE=4>s
to Combine UI Elements</FONT></H3>
<P>
The base class for all of the composite controls is <TT>Panel</TT>.
The <TT>Panel</TT> class allows you
to embed other AWT components. This class is derived from <TT>Container</TT>
so it can contain UI components. The <TT>Panel</TT>
class contains functions for <I>managing</I> embedded components.
<P>
Some functions can retrieve references to the embedded components.
These functions allow the class to iteratively call methods in
the embedded components. Other functions handle layout issues.
<H2><A NAME="PanelsAreComponentsToo"><TT><FONT SIZE=5 COLOR=#FF0000 >Panel</FONT></TT><FONT SIZE=5 COLOR=#FF0000>s
Are </FONT><TT><FONT SIZE=5 COLOR=#FF0000 >Component</FONT></TT><FONT SIZE=5 COLOR=#FF0000>s
Too</FONT></A></H2>
<P>
The primary advantage of using <TT>Panel</TT>
as your composite component base class is that it is a <TT>Component</TT>
itself. You can use your composite components like any other AWT
components. You can take these new components and combine them
to form composite components from other composite components and
so on.
<P>
The new components can be added to layouts; they can generate
existing <TT>Events</TT> or create
new ones. They are full-fledged UI components and may be used
anywhere that the AWT components are used.
<H2><A NAME="Layouts"><FONT SIZE=5 COLOR=#FF0000>Layouts</FONT></A>
</H2>
<P>
The composite controls will be more versatile if you implement
them with the appropriate layout manager. Because you would like
the controls to be self-contained, they should be able to lay
themselves out properly no matter what size they are. <A HREF="ch8.htm" >Chapter 8</A>,
&quot;All About <TT>GridBagLayout</TT>
and Other Layout Managers,&quot; discusses the use of layout managers,
including the versatile <TT>GridBagLayout</TT>
and designing your own layout.
<H2><A NAME="WhoseEventIsItAnyway"><FONT SIZE=5 COLOR=#FF0000>Whose
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >Event</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Is It Anyway?</FONT></A></H2>
<P>
When you build user interfaces, you will use components that generate
and respond to events. One of the critical decisions to make is
who should handle a given event. In the case of your composite
controls, you have three choices: (1)the <TT>Component</TT>,
(2)the <TT>Panel</TT>, or (3)the Applet.
<P>
Some components handle their own events. The <TT>SelfValidatingTextField</TT>
from <A HREF="ch9.htm" >Chapter 9</A> is an example of such a
component. Your composite components will also handle many of
their own events.
<P>
Some <TT>Events</TT> you will want
the <TT>Panel</TT> to handle. Because
the <TT>Panel</TT> has information
about all of the embedded components, it has the option of handling
the events they develop.
<P>
The <TT>Applet</TT> class is derived
from <TT>Panel</TT>, which means that
the applets can contain embedded controls. Applets may also handle
the events generated by these controls.
<H2><A NAME="ThePanelasaComponentManager"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >Panel</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
as a Component Manager</FONT></A></H2>
<P>
Your composite components will use the <TT>Panel</TT>
class as a component manager. The <TT>Panel</TT>
will handle any <TT>Events</TT> that
are not handled in the components and will maintain information
about its embedded components.
<P>
You use the panel's LayoutManager to size the embedded controls.
When an event occurs in a control, the panel will respond. An
animation control might have a panel and some VCR style buttons.
When a user presses the <I>start</I> button, the animation begins.
Clicking on the <I>stop</I> button ends the animation. While the
animation plays, you disable the <I>play</I> button and enable
the <I>stop</I> button.
<H2><A NAME="AScrollingPictureWindowExample"><FONT SIZE=5 COLOR=#FF0000>A
Scrolling Picture Window Example</FONT></A></H2>
<P>
In this example, you create a scrolling picture window. You derive
a class from <TT>Panel</TT> called
<TT>ScrollingPictureWindow</TT>. The
class will contain three member objects, a <TT>Canvas</TT>
to hold the picture, and two scrollbars.
<P>
This composite control will provide a self-contained way of displaying
a picture. A user simply needs to pass an <TT>Image</TT>
object to the control, and it does the rest. The control handles
scrolling and updating the image. When the LayoutManager resizes
the control, the scrollbars and image location automatically get
adjusted.
<H2><A NAME="Overview"><FONT SIZE=5 COLOR=#FF0000>Overview</FONT></A>
</H2>
<P>
Unlike some committees, each member of the <TT>ScrollingPictureWindow</TT>
class has well-defined responsibilities. You will define specific
roles for each component. You also design a means of handling
communication between member components.
<P>
All committees need leadership. This <I>committee</I> needs a
leader as well. The chairman of your committee is the <TT>ScrollingPictureWindow</TT>
object. This class is derived from <TT>Panel</TT>
and contains the two scrollbars and the <TT>Canvas</TT>
object. The relationship of these classes is shown in the <I>organizational
chart</I> of Figure 10.2.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-2.gif" ><B>Figure 10.2 : </B><I>The organization of your committee.</I></A>
<P>
The first member of the committee is the <TT>ImageCanvas</TT>
object. <TT>ImageCanvas</TT> is a
class derived from <TT>Canvas</TT>.
This object actually displays the image. The <TT>ScrollingPictureWindow</TT>
object will tell the <TT>ImageCanvas</TT>
how to display the image.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The <TT>Canvas</TT> class is an AWT component and serves as a generic UI component. It is meant to be subclassed to provide application (or applet) specific behavior. It is often used to display images. <TT>Canvas</TT> generates all of the key and mouse 
events so that it can be used to create powerful new UI classes.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The last two members of the committee are the scrollbars. These
scrollbars do not handle any of their own events, but simply report
them to the <TT>ScrollingPictureWindow</TT>
object. The <TT>ScrollingPictureWindow</TT>
class will also inform the scrollbars when they need to reposition
themselves.
<H3>The <TT><FONT SIZE=4 >ImageCanvas</FONT></TT><FONT SIZE=4>
Class</FONT></H3>
<P>
The <TT>ImageCanvas</TT> class is
derived from <TT>Canvas</TT>. You
use this class to display your image. The class defined contains
one instance variable:
<BLOCKQUOTE>
<TT>Image canvasImg ;</TT>
</BLOCKQUOTE>
<P>
The <TT>ImageCanvas</TT> constructor
takes an <TT>Image</TT> object as
a parameter. Because parameters of class type are passed by reference,
this makes a local reference to the <TT>Image</TT>
object in the class.
<BLOCKQUOTE>
<TT>public ImageCanvas( Image img ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;canvasImg = img ;<BR>
}<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Java uses <I>pass-by-value</I> for parameters of simple types. Pass-by-value means that these variables are copied into the local space for a function. This is the normal passing paradigm of C++ and the only passing paradigm of C. Parameters of class type 
use <I>pass-by-reference</I>. This is like the C++ implementation. Pass-by-reference creates a local reference to a parameter in the function space.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The only other method provided in the <TT>ImageCanvas</TT>
class is <TT>paint()</TT>. The <TT>paint</TT>
method will actually draw the image. Because the picture scrolls,
the class will need to know where to draw it.
<P>
The location of the image depends on the position of the scrollbars.
In your scheme, the <TT>ScrollingPictureWindow</TT>
object handles communication between the member objects. You need
to query the <TT>ScrollingPictureWindow</TT>
object to determine where to draw the image.
<BLOCKQUOTE>
<TT>public void paint(Graphics g) {<BR>
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>g.drawImage(
canvasImg,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1 * ((ScrollingPictureWindow)getParent()).imgX,
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1
* ((ScrollingPictureWindow)getParent()).imgY,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this
) ;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
To get the information, use the <TT>getParent()</TT>
method. The <TT>getParent()</TT> method
is a member of the <TT>Component</TT>
class. This method returns a reference to the <TT>Container</TT>
object that holds the <TT>Component</TT>.
<P>
When you call <TT>getParent()</TT>,
you get a reference to the <TT>ScrollingPictureWindow</TT>
object. Because this reference is the <TT>Container</TT>
type, you need to <I>cast</I> it to a <TT>ScrollingPictureWindow</TT>
reference. Now you can access the public instance variables in
the <TT>ScrollingPictureWindow</TT>
object.
<P>
If you feel uncomfortable with directly accessing the members
of the parent class, an alternative method would be to provide
public methods or access functions. These functions would return
the x and y values at which to draw the image.
<P>
The <TT>imgX</TT> and <TT>imgY</TT>
members contain the x and y coordinates of the point (in terms
of the image) that will be displayed in the upper left corner.
If you want the point (10,5) to be displayed in the upper left
corner, you pass -10 and -5 to <TT>drawImage()</TT>.
As the example in Figure 10.3 shows, the <TT>Canvas</TT>
class clips the image to fit within its boundaries.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-3.gif" ><B>Figure 10.3 : </B><I>Drawing and clipping the image.</I></A>
<P>
<TT>ImageCanvas</TT> provides the
basic drawing for the <TT>ScrollingPictureWindow</TT>
class. This class shows a typical usage of the <TT>Canvas</TT>
class.
<H3>Instance Variables</H3>
<P>
The <TT>ScrollingPictureWindow</TT>
class contains several instance variables. These variables include
the embedded controls and state variables. The embedded controls
will be stored as:
<BLOCKQUOTE>
<TT>ImageCanvas imageCanvas ;<BR>
Scrollbar&nbsp;&nbsp;&nbsp;vertBar ;<BR>
Scrollbar&nbsp;&nbsp;&nbsp;horzBar ;<BR>
Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image ;</TT>
</BLOCKQUOTE>
<P>
The last instance variable in this list is a reference to an <TT>Image</TT>
object, which gets passed in by the <I>owner</I> of your class
object.
<P>
The remaining instance variables all contain state information.
The first two contain the size in pixels of the entire image:
<BLOCKQUOTE>
<TT>int imgWidth ;<BR>
int imgHeight ;</TT>
</BLOCKQUOTE>
<P>
The next two instance variables contain the current position of
the image. These variables also reflect the current position of
the scrollbars. Because the scrollbars and the image are tied
together, both classes use these variables. The scrollbars will
set their value, and the <TT>ImageCanvas</TT>
uses the value to place the image.
<BLOCKQUOTE>
<TT>int imgX ;<BR>
int imgY ;</TT>
</BLOCKQUOTE>
<P>
The last variable is used by the scrollbars. This value specifies
the amount that the scrollbar moves when you request a pageup
or pagedown.
<BLOCKQUOTE>
<TT>int page ;</TT>
</BLOCKQUOTE>
<H2><A NAME="ClassConstruction"><FONT SIZE=5 COLOR=#FF0000>Class
Construction</FONT></A></H2>
<P>
The class constructor performs all of the initialization for your
class. The constructor must
<UL>
<LI>Initialize the state variables
<LI>Determine the size of the image
<LI>Instantiate the member controls
<LI>Set up the <TT>GridBagLayout</TT>
<LI><FONT COLOR=#000000>Set the constraints for each control</FONT>
</UL>
<H3>State Variables</H3>
<P>
Begin construction by setting the local <TT>Image</TT>
reference to the <TT>Image</TT> argument:
<BLOCKQUOTE>
<TT>public ScrollingPictureWindow ( Image
img ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;image = img ;</TT>
</BLOCKQUOTE>
<P>
The next step in the construction process is simple. You need
to initialize <TT>imgX</TT> and <TT>imgY</TT>
to 0. What this really does is set the initial position of the
image and scrollbars. These two instance variables contain the
x and y offsets at which to display the image:
<BLOCKQUOTE>
<TT>imgX = 0 ;<BR>
imgY = 0 ;</TT>
</BLOCKQUOTE>
<P>
The <TT>ImageCanvas</TT> class will
need these variables to determine how to place the image. The
<TT>ImageCanvas</TT> <TT>paint()</TT>
method accesses these instance variables directly and uses them
in its call to <TT>drawImage()</TT>.
<H3>Image Size</H3>
<P>
Your composite control needs to know how large its image is. Once
you have this information, it will remain constant. Unfortunately,
determining the image size is not as straightforward as you might
think. You have this difficulty <I>by design</I>.
<P>
Your class has been designed to take an <TT>Image</TT>
object as a parameter, giving the users of the class a great deal
of flexibility. They may load the image anyway they want. The
image you receive may be one of many in an array. It may be in
use by other objects in the applet. It may also have been just
recently loaded by the calling applet. It is this last case that
causes problems.
<P>
The sample applet used to test the class is very simple. It loads
an image, creates a <TT>ScrollingPictureWindow</TT>
object, and adds it to the layout. The Applet code follows:
<BLOCKQUOTE>
<TT>package COM.MCP.Samsnet.tjg ;<BR>
<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import ScrollingPictureWindow ;<BR>
<BR>
public class Test extends Applet {<BR>
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>ScrollingPictureWindow
pictureWindow ;<BR>
<BR>
public void init() {<BR>
<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>Image
img = getImage( getCodeBase(), &quot;picture.gif&quot; ) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pictureWindow = new ScrollingPictureWindow(
img ) ;<BR>
</TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT>setLayout(
new BorderLayout() );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add( &quot;Center&quot;, pictureWindow
) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
};</TT>
</BLOCKQUOTE>
<P>
The first line of the <TT>init()</TT>
method calls <TT>getImage()</TT>.
The <TT>getImage()</TT> method loads
a specified image file. The problem is that <TT>getImage()</TT>
returns immediately before the image actually loads. The image
is not really loaded (i.e., its bits read into memory) until it
is needed. Therefore, when you pass an image to the <TT>ScrollingPictureWindow</TT>
constructor, it may not be fully loaded.
<P>
Thus in your class constructor, it is possible that the reference
you receive is to an image that is not yet fully loaded. To get
the image size, you make a call to <TT>Image.getHeight()</TT>.
If the image is not fully loaded, however, <TT>getHeight()</TT>
returns -1. To get the size of the image, you will loop until
<TT>getHeight()</TT> returns a value
other than -1. Both <TT>while</TT>
loops below have <I>null</I> bodies:
<BLOCKQUOTE>
<TT>while ((imgHeight = image.getHeight(this))
== -1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// loop until image loaded<BR>
}<BR>
<BR>
while ((imgWidth&nbsp;&nbsp;= image.getWidth(this)) == -1 ) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// loop until image loaded<BR>
}</TT>
</BLOCKQUOTE>
<H3>Member Controls</H3>
<P>
Next, you need to create the embedded member objects. The <TT>ImageCanvas</TT>
takes the <TT>Image</TT> as a parameter.
Each scrollbar constructor takes a constant that determines whether
the scrollbar is vertical or horizontal.
<BLOCKQUOTE>
<TT>imageCanvas = new ImageCanvas( image
) ;<BR>
<BR>
vertBar = new Scrollbar( Scrollbar.VERTICAL ) ;<BR>
horzBar = new Scrollbar( Scrollbar.HORIZONTAL ) ;</TT>
</BLOCKQUOTE>
<H3><TT><FONT SIZE=4 >GridBagLayout</FONT></TT>
</H3>
<P>
You use a <TT>GridBagLayout</TT> to
lay out the embedded control. <TT>GridBagLayout</TT>
is the most versatile LayoutManager in the AWT, which provides
precisely the control you need to arrange the components. While
<TT>GridBagLayout</TT> is the most
powerful LayoutManager, many Java programmers have been slow to
accept it.
<P>
Why is <TT>GridBagLayout</TT> so mysterious?
<A HREF="ch8.htm" >Chapter 8</A> hopefully helped to de-mystify
the topic. The Java phenomenon has developed so quickly that it
seems almost comical to talk about the <I>history</I> of Java.
Early Java books and even the beta versions of the online documentation
from Sun omitted <TT>GridBagLayout</TT>.
Many people who were doing Java in the <I>early days</I> still
hesitate to use <TT>GridBagLayout</TT>.
<P>
You may be wondering why this control does not use a <TT>BorderLayout</TT>.
<TT>BorderLayout</TT> is simple to
use and a good choice in many situations. Figure 10.4 shows the
control using a <TT>BorderLayout</TT>.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-4.gif" ><B>Figure 10.4 : </B><I>A </I>ScrollingPicture-Windows <I>with a</I> BorderLayout.</A>
<P>
What's wrong with this picture? Take a look at the lower-right-hand
corner of Figure 10.4. Do you see how the horizontal scrollbar
is wider than the image area? Look for Java applets on the Internet;
many have scrollbars arranged just like these. Nothing is intrinsically
wrong with this layout. Compare it, however, to the <TT>TextField</TT>
applet in Figure 10.5.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-5.gif" ><B>Figure 10.5 : </B><I>A </I>TextField<I> with scrollbars</I></A><I>.</I>
<P>
This applet simply creates and displays a multiline <TT>TextArea</TT>.
The scrollbars are part of the <TT>TextArea</TT>.
Look at how they are arranged. In the built-in AWT component the
scrollbars do not overlap. This is the suggested look for the
<TT>ScrollingPictureWindow</TT> control.
The best way to achieve this layout is to use <TT>GridBagLayout</TT>.
<P>
First, you create a <TT>GridBagLayout</TT>
object. Then, you call <TT>setLayout()</TT>
to make it the current layout manager.
<BLOCKQUOTE>
<TT>GridBagLayout gridbag = new GridBagLayout();
<BR>
<BR>
setLayout( gridbag ) ;</TT>
</BLOCKQUOTE>
<H3>Constraints</H3>
<P>
The <TT>GridBagLayout</TT> class uses
the <TT>GridBagConstraints</TT> class
to specify how the controls get laid out. First, you create a
<TT>GridBagConstraints</TT> object.
You will then use the <TT>GridBagConstraints</TT>
object to determine how to layout your individual components.
<BLOCKQUOTE>
<TT>GridBagConstraints c = new GridBagConstraints();</TT>
</BLOCKQUOTE>
<P>
You add the <TT>ImageCanvas</TT> object
to your panel first. Because the <TT>ScrollingPictureWindow</TT>
control is supposed to act like the native AWT controls, it may
be resizeable. Therefore, you need to specify that it can grow
in both x and y directions. So you set the fill member to <TT>BOTH</TT>.
<BLOCKQUOTE>
<TT>c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
GridBagConstraints.BOTH ;</TT>
</BLOCKQUOTE>
<P>
You want the image to fill all the available space with no padding,
so set the weight parameters to 1.0.
<BLOCKQUOTE>
<TT>c.weightx&nbsp;&nbsp;&nbsp;&nbsp;= 1.0;
<BR>
c.weighty&nbsp;&nbsp;&nbsp;&nbsp;= 1.0;</TT>
</BLOCKQUOTE>
<P>
You finish laying out the image by calling <TT>setConstraints()</TT>
to associate the <TT>ImageCanvas</TT>
object with the <TT>GridBagConstraints</TT>
object. Then, you add the image to the layout.
<BLOCKQUOTE>
<TT>gridbag.setConstraints(imageCanvas, c);
<BR>
add( imageCanvas ) ;</TT>
</BLOCKQUOTE>
<P>
Next, you layout the scrollbars. Start with the vertical scrollbar.
The vertical scrollbar should shrink or grow vertically when the
control is resized, so you set the fill member to <TT>VERTICAL</TT>.
<BLOCKQUOTE>
<TT>c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
GridBagConstraints.VERTICAL ;</TT>
</BLOCKQUOTE>
<P>
Look at your layout in terms of rows. You see that the first row
contains two controls: the <TT>ImageCanvas</TT>
and the vertical scrollbar. You indicate that the scrollbar is
the last control in the row by setting the gridwidth member to
<TT>REMAINDER</TT>.
<BLOCKQUOTE>
<TT>c.gridwidth&nbsp;&nbsp;= GridBagConstraints.REMAINDER
;</TT>
</BLOCKQUOTE>
<P>
You complete the vertical scrollbar layout by associating it with
the constraint object and then adding it to the layout.
<BLOCKQUOTE>
<TT>gridbag.setConstraints(vertBar, c);<BR>
add( vertBar ) ;</TT>
</BLOCKQUOTE>
<P>
Finally, you layout the horizontal scrollbar. Because this scrollbar
should be horizontally resizeable, set the fill member to <TT>HORIZONTAL</TT>.
<BLOCKQUOTE>
<TT>c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
GridBagConstraints.HORIZONTAL ;</TT>
</BLOCKQUOTE>
<P>
The reason for using a <TT>GridBagLayout</TT>
is to prevent the horizontal scrollbar from filling the entire
width of the control. You need to guarantee that the horizontal
scrollbar remains the same width as the <TT>ImageCanvas</TT>
object. Fortunately, the <TT>GridBagConstraint</TT>
class provides a means of tying the width of one object to the
width of another.
<P>
You use the <TT>gridWidth</TT> member
of the <TT>GridBagConstraint</TT>
class to specify the width of the scrollbar in terms of grid <I>cells.</I>
Set this member to 1 so that the horizontal scrollbar takes up
the same width as the <TT>ImageCanvas</TT>
object (they are both one cell wide). It is the <TT>ImageCanvas</TT>
object that sets the cell size.
<BLOCKQUOTE>
<TT>c.gridwidth&nbsp;&nbsp;= 1 ;</TT>
</BLOCKQUOTE>
<P>
The last thing you need to do is add the horizontal scrollbar.
First associate it with the constraints object; then add it to
the layout.
<BLOCKQUOTE>
<TT>gridbag.setConstraints(horzBar, c);<BR>
add( horzBar ) ;</TT>
</BLOCKQUOTE>
<H3>Sizing and Resizing</H3>
<P>
One of the most important features of the composite control is
that it is resizeable. When you resize the control, you expect
it to: resize its components, reposition the image, and adjust
the scrollbars. You also need to update the class's status variables.
<P>
Start by examining what happens when you resize the control. First,
size the control so that the control is smaller than the image
it displays. You should be able to use the scrollbar to see all
of the image. Figure 10.6 shows the control.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-6.gif" ><B>Figure 10.6 : </B><I>The ScrollingPicture-Window.</I></A>
<P>
Next, you make the control wider until it is wider than the image.
The control now shows the entire width of the image. The horizontal
scrollbar is no longer necessary, so you disable it. By making
the control taller than the image, you disable the vertical scrollbar.
If you make the control both wider and taller than the image,
you disable both scrollbars. Figure 10.7 displays the control
enlarged so that both scrollbars are disabled.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-7.gif" ><B>Figure 10.7 : </B><I>The </I>ScrollingPictureWindow<I> resized, with scrollbars disabled.</I></A>
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f10-8.gif" ><B>Figure 10.8 : </B><I>The </I>ScrollingPictureWindow<I> resized, with scrollbars enabled.</I></A>
<P>

When you shrink the control, you enable the scrollbars again.
<P>
You will handle all of the resizing by overriding the <TT>Component.reshape()</TT>
method. This function is called every time a control gets resized.
The first thing that your function does is call the superclass
(baseclass) reshape method. The superclass method does the real
work of sizing. Because you are using a <TT>GridBagLayout</TT>,
the LayoutManager resizes the individual components.
<BLOCKQUOTE>
<TT>public synchronized void reshape(int
x,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
y,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
width,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
height) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;super.reshape( x, y, width, height ) ;</TT>
</BLOCKQUOTE>
<P>
You let the superclass do the resizing, so now you must update
the image and scrollbars. First, determine whether the width of
the control is greater than the image width plus the width of
the vertical scrollbar. If the control width is greater, then
you disable the horizontal scrollbar.
<BLOCKQUOTE>
<TT>if ( width &gt; imgWidth +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
vertBar.preferredSize().width ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;horzBar.disable() ;<BR>
If the control width is not greater, then you enable the horizontal
scrollbar.<BR>
} else {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar.enable()
;</TT>
</BLOCKQUOTE>
<P>
Next, you determine how to reposition the horizontal scrollbar.
Start by getting the size of the entire control and the width
of the vertical scrollbar.
<BLOCKQUOTE>
<TT>lllll Rectangle bndRect = bounds() ;
<BR>
int barWidth = vertBar.preferredSize().width ;<BR>
</TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
When working with scrollbars, you have to set several values: (1)the <I>thumb</I> position, (2)the maximum and minimum values, (3)the size of the viewable page, and (4)the page increment.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now you can calculate the maximum value for the scrollbar. You
always set the minimum of the scrollbar to 0. The maximum value
will be the image width minus the width of the <TT>ImageCanvas</TT>.
You set the page size and page increment to one-tenth of the maximum
size.
<BLOCKQUOTE>
<TT>int max = imgWidth - (bndRect.width -
barWidth);<BR>
page = max/10 ;</TT>
</BLOCKQUOTE>
<P>
Before setting the new values, you have to determine how to translate
the old position to the new scale. Start by getting the old maximum
value. If the old value is 0, you make the position 0.
<BLOCKQUOTE>
<TT>int oldMax = horzBar.getMaximum() ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( oldMax == 0) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX
= 0 ;</TT>
</BLOCKQUOTE>
<P>
If the old maximum is not 0, you calculate the new position. First,
express the old position as a fraction of the old maximum. Then,
multiply the fraction by the new maximum. The resulting value
gives you the new position.
<BLOCKQUOTE>
<TT>} else {<BR>
<BR>
imgX = (int)(((float)imgX/(float)oldMax) *<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(float)max) ;<BR>
<BR>
}<BR>
The last thing you need to do is set the scrollbar parameters.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;horzBar.setValues( imgX, page, 0, max
) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;horzBar.setPageIncrement( page ) ;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
You use the same algorithm for setting the vertical scrollbar.
<H2><A NAME="EventHandling"><TT><FONT SIZE=5 COLOR=#FF0000 >Event</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Handling</FONT></A></H2>
<P>
Whenever the user interacts with your control, the system generates
an <TT>Event</TT> (<A HREF="ch11.htm" >see Chapter 11</A>,
&quot;Advanced Event Handling&quot;). This program is especially
concerned about scrollbar <TT>Events</TT>.
All other types of <TT>Events</TT>
get passed on and handled outside your program.
<P>
You start by overriding the <TT>Component.handleEvent()</TT>
method. In this method, you look for <TT>Events</TT>
generated by the horizontal scrollbar. If the <TT>Event</TT>
is one of the seven scrollbar <TT>Events</TT>,
you reset the <TT>imgX</TT> variable
and call <TT>repaint()</TT>. You return
<TT>true</TT> if you can handle the
<TT>Event</TT>.
<BLOCKQUOTE>
<TT>public boolean handleEvent(Event e) {
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( e.target
== horzBar ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(
e.id ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_UP:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_UP:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_ABSOLUTE:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_DOWN:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_DOWN:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX
= horzBar.getValue() ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageCanvas.repaint();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The code for handling the vertical scrollbar is the same as for
the horizontal scrollbar. If you do not handle the <TT>Event</TT>,
call the superclass <TT>handleEvent</TT>
method and return.
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;return super.handleEvent(e)
;<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<H3>Putting It Together</H3>
<P>
You now have a composite control that can become a drop-in replacement
for other AWT controls. It handles its own events, and it responds
to external resizing. The complete <TT>ScrollingPictureWindow</TT>
class is as follows:
<BLOCKQUOTE>
<TT>package COM.MCP.Samsnet.tjg ;<BR>
<BR>
import java.awt.*;<BR>
<BR>
public class ScrollingPictureWindow extends Panel {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ImageCanvas imageCanvas ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Scrollbar&nbsp;&nbsp;&nbsp;vertBar ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Scrollbar&nbsp;&nbsp;&nbsp;horzBar ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
image ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int imgWidth ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int imgHeight ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int imgX ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int imgY ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int page ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ScrollingPictureWindow ( Image
img ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image = img ;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX = 0 ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgY = 0 ;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((imgHeight
= image.getHeight(this)) == -1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop until
image loaded<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((imgWidth&nbsp;&nbsp;=
image.getWidth(this)) == -1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop until
image loaded<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageCanvas =
new ImageCanvas( image ) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertBar = new
Scrollbar( Scrollbar.VERTICAL ) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar = new
Scrollbar( Scrollbar.HORIZONTAL ) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout
gridbag = new GridBagLayout();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout( gridbag
) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints
c = new GridBagConstraints();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= GridBagConstraints.BOTH ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx&nbsp;&nbsp;&nbsp;&nbsp;=
1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weighty&nbsp;&nbsp;&nbsp;&nbsp;=
1.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridbag.setConstraints(imageCanvas,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add( imageCanvas
) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= GridBagConstraints.VERTICAL ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth&nbsp;&nbsp;=
GridBagConstraints.REMAINDER ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridbag.setConstraints(vertBar,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add( vertBar )
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.fill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= GridBagConstraints.HORIZONTAL ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.gridwidth&nbsp;&nbsp;=
1 ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridbag.setConstraints(horzBar,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add( horzBar )
;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
public synchronized void reshape(int x,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
y,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
width,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
height) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.reshape(
x, y, width, height ) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( width &gt;
imgWidth + vertBar.bounds().width ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar.disable()
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar.enable()
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle
bndRect = bounds() ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
barWidth = vertBar.preferredSize().width ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
max = imgWidth - (bndRect.width - barWidth);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page
= max/10 ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
oldMax = horzBar.getMaximum() ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( oldMax == 0) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX
= 0 ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX
= (int)(((float)imgX/(float)oldMax) *<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(float)max) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar.setValues(
imgX, page, 0, max ) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;horzBar.setPageIncrement(
page ) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (height &gt;
imgHeight + horzBar.bounds().height) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertBar.disable()
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertBar.enable()
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle
bndRect = bounds() ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
barHeight = horzBar.preferredSize().height ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
max = imgHeight - (bndRect.height -<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;barHeight)
;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page
= max/10 ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
oldMax = vertBar.getMaximum() ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
( oldMax == 0) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgY
= 0 ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgY
= (int)(((float)imgY/(float)oldMax) *<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(float)max) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertBar.setValues(
imgY, page, 0, max ) ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertBar.setPageIncrement(
page ) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( e.target
== horzBar ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(
e.id ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_UP:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_UP:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_ABSOLUTE:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_DOWN:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_DOWN:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgX
= horzBar.getValue() ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageCanvas.repaint();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ( e.target
== vertBar ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(
e.id ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_UP:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_UP:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_ABSOLUTE:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_LINE_DOWN:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
Event.SCROLL_PAGE_DOWN:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgY
= vertBar.getValue() ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageCanvas.repaint();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.handleEvent(e)
;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
};<BR>
<BR>
class ImageCanvas extends Canvas {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Image canvasImg ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ImageCanvas( Image img ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvasImg = img
;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage( canvasImg,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1
* ((ScrollingPictureWindow)getParent()).imgX,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1
* ((ScrollingPictureWindow)getParent()).imgY,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this
) ;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
The <TT>ScrollingPictureWindow</TT>
class you created in this chapter is a good example of a composite
control. This class combines the techniques of subclassing and
encapsulation. It also is a subclass of <TT>Panel</TT>
and serves to encapsulate the <TT>Canvas</TT>
and the two scrollbars. 
<P>
The goal in developing composite controls is to provide plug-in
replacements for the existing AWT controls. Because the <TT>ScrollingPictureWindow</TT>
is a subclass of <TT>Panel</TT>, it
inherits all the properties of the <TT>Panel</TT>
class. Therefore, you can use a <TT>ScrollingPictureWindow</TT>
object anywhere that you would use a <TT>Panel</TT>.
<P>
When you create a composite control, you need to provide a mechanism
for encapsulating the embedded controls. In this chapter you used
the AWT <TT>Panel</TT> class to contain
the other controls. 
<P>
The embedded controls must also communicate with each other. The
<TT>handleEvent()</TT> method handles
scrollbar events and enables the <TT>Canvas</TT>
class to determine how to draw the image.
<P>
When you design an applet or application in Java, you have at
your disposal the basic AWT controls. Now you can create composite
controls like the <TT>ScrollingPictureWindow</TT>.
Common tasks (like scrolling an image) are good candidates for
combined controls. These new controls will become part of your
personal Java toolbox, and you can use them in all of your future
Java programming.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch11.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

