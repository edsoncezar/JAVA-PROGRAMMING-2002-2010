<HTML>
<HEAD>

<TITLE>Java 1.2 In Record Time:More Graphics Animation Power</TITLE>




<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="467-470.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="473-479.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>At this point, you are ready to erase the figure itself, and you can do that simply by drawing over it now that you have set the XOR mode correctly:
</P>
<PRE>
 public void paint (Graphics g) &#123;
          int loop_index;
          int figureWidth, figureHeight;
          Point topLeft;

          if(bDrawFlag)&#123;
               for(loop_index = 0; loop_index &lt; ptindex - 1; &#8658;
 loop_index&#43;&#43;)&#123;
               g.drawLine(pts[loop_index].x, pts[loop_index].y, &#8658;
 pts[loop_index &#43; 1].x, pts[loop_index &#43; 1].y);
               &#125;
               return;
          &#125;
          g.setColor(new Color(0, 0, 0));
          g.setXORMode(getBackground());

          topLeft = new Point(Math.min(ptAnchor.x, ptOldDrawTo.x),
 Math.min(ptAnchor.y, ptOldDrawTo.y));
          figureWidth = Math.abs(ptOldDrawTo.x - ptAnchor.x);
          figureHeight = Math.abs(ptOldDrawTo.y - ptAnchor.y);

&#8594;         if(bLineFlag)&#123;
&#8594;               g.drawLine(ptAnchor.x, ptAnchor.y,
 ptOldDrawTo.x, &#8658; ptOldDrawTo.y);
&#8594;          &#125;
&#8594;          if(bOvalFlag)&#123;
&#8594;              g.drawOval(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight);
&#8594;          &#125;
&#8594;          if(bRectFlag)&#123;
&#8594;              g.drawRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight);
&#8594;          &#125;
&#8594;          if(b3DRectFlag)&#123;
&#8594;              g.draw3DRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight, true);
&#8594;          &#125;
&#8594;          if(bRoundedFlag)&#123;
&#8594;              g.drawRoundRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight, 10, 10);
&#8594;         &#125;    .
               .
               .
</PRE>
<P>This erases the old graphics figure, which is obsolete now that the user has moved the mouse. You&#146;ve made considerable progress.
</P>
<P>The next step is to draw the new figure, which stretches from <TT>ptAnchor</TT> to <TT>ptDrawTo</TT>. To do that, now that the XOR mode is set, simply set the drawing color to the background color itself. In this way, you&#146;ll end up drawing in the current drawing color. Now that you are not drawing to <TT>ptOldDrawTo</TT> anymore, but to <TT>ptDrawTo</TT> instead, you have to recalculate the width and height as well, and you do that this way:</P>
<PRE>
 public void paint (Graphics g) &#123;
          int loop_index;
          int figureWidth, figureHeight;
          Point topLeft;

          if(bDrawFlag)&#123;
               for(loop_index = 0; loop_index &lt; ptindex - 1; &#8658;
 loop_index&#43;&#43;)&#123;
               g.drawLine(pts[loop_index].x, pts[loop_index].y, &#8658;
 pts[loop_index &#43; 1].x, pts[loop_index &#43; 1].y);
               &#125;
               return;
          &#125;

          g.setColor(new Color(0, 0, 0));
          g.setXORMode(getBackground());
                    .
                    .
                    .
          if(bRoundedFlag)&#123;
               g.drawRoundRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight, 10, 10);
          &#125;
&#8594;         g.setColor(getBackground());
&#8594;         topLeft = new Point(Math.min(ptAnchor.x, ptDrawTo.x), &#8658;
 Math.min(ptAnchor.y, ptDrawTo.y));

&#8594;         figureWidth = Math.abs(ptDrawTo.x - ptAnchor.x);
&#8594;         figureHeight = Math.abs(ptDrawTo.y - ptAnchor.y);
               .
               .
               .
</PRE>
<P>Finally, draw the new figure, making it appear on the screen:
</P>
<PRE>
public void paint (Graphics g) &#123;
          int loop_index;
          int figureWidth, figureHeight;
          Point topLeft;

          if(bDrawFlag)&#123;
               for(loop_index = 0; loop_index &lt; ptindex - 1; &#8658;
 loop_index&#43;&#43;)&#123;
               g.drawLine(pts[loop_index].x, pts[loop_index].y, &#8658;
 pts[loop_index &#43; 1].x, pts[loop_index &#43; 1].y);
               &#125;
               return;
          &#125;

          g.setColor(new Color(0, 0, 0));
          g.setXORMode(getBackground());
               .
               .
               .
          if(bRoundedFlag)&#123;
               g.drawRoundRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight, 10, 10);
          &#125;

          g.setColor(getBackground());
          topLeft = new Point(Math.min(ptAnchor.x, ptDrawTo.x), &#8658;
 Math.min(ptAnchor.y, ptDrawTo.y));

          figureWidth = Math.abs(ptDrawTo.x - ptAnchor.x);
          figureHeight = Math.abs(ptDrawTo.y - ptAnchor.y);

&#8594;         if(bLineFlag)&#123;
&#8594;              g.drawLine(ptAnchor.x, ptAnchor.y, ptDrawTo.x,
 ptDrawTo.y);
&#8594;         &#125;
&#8594;         if(bOvalFlag)&#123;
&#8594;              g.drawOval(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight);
&#8594;         &#125;
&#8594;         if(bRectFlag)&#123;
&#8594;              g.drawRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight);
&#8594;         &#125;
&#8594;         if(b3DRectFlag)&#123;
&#8594;              g.draw3DRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight true);
&#8594;         &#125;
&#8594;         if(bRoundedFlag)&#123;
&#8594;              g.drawRoundRect(topLeft.x, topLeft.y, figureWidth, &#8658;
 figureHeight, 10, 10);
&#8594;         &#125;
&#8594;     &#125;
</PRE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="467-470.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="473-479.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

