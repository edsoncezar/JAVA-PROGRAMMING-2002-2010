<HTML>
<HEAD>

<TITLE>Java 1.2 In Record Time:More Graphics Animation Power</TITLE>




<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="462-467.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="470-473.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>Next, update the drawto point itself to the current location of the mouse, and call <TT>repaint()</TT>:</P>
<PRE>
     public void mouseDragged(MouseEvent e)&#123;
          if(bDrawFlag)&#123;
               pts[ptindex] = new Point(e.getX(), e.getY());
               ptindex&#43;&#43;;
          &#125;
          else&#123;
               ptOldDrawTo = ptDrawTo;
               ptDrawTo = new Point(e.getX(), e.getY());
          &#125;
&#8594;          repaint();
     &#125;
</PRE>
<P>In the<TT> paint()</TT> method, erase the old figure (stretching from <TT>ptAnchor</TT> to <TT>ptOldDrawTo</TT>) and draw the new figure (stretching from <TT>ptAnchor</TT> to <TT>ptDrawTo</TT>).</P>
<P>In addition, when the user releases the mouse button, do the same thing so the screen is updated one last time and the figure is drawn in its final state:</P>
<PRE>
 public void mouseReleased(MouseEvent e)&#123;
          bMouseDownFlag = false;
          bMouseUpFlag = true;
&#8594;         ptOldDrawTo = ptDrawTo;
&#8594;         ptDrawTo = new Point(e.getX(), e.getY());
          if(!bLineFlag)&#123;
               ptDrawTo = new Point(Math.max(ptAnchor.x, ptDrawTo.x), &#8658;
 Math.max(ptAnchor.y, ptDrawTo.y));
               ptAnchor = new Point(Math.min(ptDrawTo.x, ptAnchor.x), &#8658;
 Math.min(ptDrawTo.y, ptAnchor.y));
          &#125;
          repaint();
     &#125;
</PRE>
<P>Now you will update the <TT>paint()</TT> method to make use of these changes.</P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">Updating the Dauber <I>paint()</I> Method
</FONT></H4>
<P>Here, in the <TT>paint()</TT> method, you want to erase the current graphics figure, which stretches from <TT>ptAnchor</TT> to <TT>ptOldDrawTo</TT>, and draw the new graphics figure, which stretches from <TT>ptAnchor</TT> to <TT>ptDrawTo</TT>.</P>
<P>You&#146;ll use XOR drawing to do this. The XOR exclusive OR operator is a unique one. It operates much like the OR operator. The OR operator takes binary values like 0 and 1, and it combines them. In all cases but 0 ORed with 0, the result is 1:</P>
<P ALIGN="CENTER"><IMG SRC="images\15-01d.jpg"></P>
<P>The XOR operator is a little different. Here, when you XOR 1 and 1, you do not get 1, but 0. For all other cases, XOR works just like OR.
</P>
<P ALIGN="CENTER"><IMG SRC="images\15-02d.jpg"></P>
<P>What this means in practice is that when you XOR a number with itself, you get 0. The interesting thing is that when you XOR number A with number B, you get a certain result, number C. However, when you XOR C with B again, you get A back. This property is useful for, among other things, placing mouse cursors on the screen. When you place the mouse cursor on the screen, you can XOR the pixels in the cursor&#146;s image with the pixels on the screen, pixel by pixel. The cursor appears. When you want to get rid of it, you just repeat the same process again&#151;XORing the cursor with the screen at the same location again&#151;and the screen is restored. There is no need to store the screen before placing the mouse cursor on the screen.
</P>
<P>Let&#146;s put XOR to work. Your first task will be to erase the old figure, stretching from <TT>ptAnchor</TT> to <TT>ptOldDrawTo</TT>. Your drawing color is black, so install that now in your <TT>Graphics</TT> object:</P>
<PRE>
     public void paint (Graphics g) &#123;
          int loop_index;
          int figureWidth, figureHeight;
          Point topLeft;

          if(bDrawFlag)&#123;
               for(loop_index = 0; loop_index &lt; ptindex - 1;&#8658;
 loop_index&#43;&#43;)&#123;
               g.drawLine(pts[loop_index].x, pts[loop_index].y,&#8658;
 pts[loop_index &#43; 1].x, pts[loop_index &#43; 1].y);
               &#125;
               return;
          &#125;

&#8594;         g.setColor(new Color(0, 0, 0));
               .
               .
               .
</PRE>
<P>Next, set the XOR drawing mode with the Graphics <TT>setXORMode()</TT> method.</P>
<H4 ALIGN="LEFT"><A NAME="Heading7"></A><FONT COLOR="#000077">Setting the XOR Mode</FONT></H4>
<P>Here, you&#146;ll set the XOR drawing mode with the background color. This means that when you draw over black pixels (black is the current drawing color) on the screen, they will be changed to the background color:
</P>
<PRE>
 public void paint (Graphics g) &#123;
          int loop_index;

          if(bDrawFlag)&#123;
               for(loop_index = 0; loop_index &lt; ptindex - 1;&#8658;
 loop_index&#43;&#43;)&#123;
               g.drawLine(pts[loop_index].x, pts[loop_index].y,&#8658;
                 pts[loop_index &#43; 1].x, pts[loop_index &#43; 1].y);
               &#125;
               return;
          &#125;

          g.setColor(new Color(0, 0, 0));
&#8594;         g.setXORMode(getBackground());
                    .
                    .
                    .
</PRE>
<P>Now the XOR mode is set. Next, find the top left point of the graphics figure you want to erase, as well as its width and height:
</P>
<PRE>
 public void paint (Graphics g) &#123;
       int loop_index;
&#8594;      int figureWidth, figureHeight;
&#8594;      Point topLeft;

       if(bDrawFlag)&#123;
            for(loop_index = 0; loop_index &lt; ptindex - 1;
 loop_index&#43;&#43;)&#123;
            g.drawLine(pts[loop_index].x, pts[loop_index].y,
 pts[loop_index &#43; 1].x,
            pts[loop_index &#43; 1].y);
            &#125;
            return;
       &#125;

       g.setColor(new Color(0, 0, 0));
       g.setXORMode(getBackground());

&#8594;      topLeft = new Point(Math.min(ptAnchor.x, ptOldDrawTo.x), &#8658;
       Math.min(ptAnchor.y, ptOldDrawTo.y));
       figureWidth = Math.abs(ptOldDrawTo.x - ptAnchor.x);
       figureHeight = Math.abs(ptOldDrawTo.y - ptAnchor.y);
                    .
                    .
                    .
</PRE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="462-467.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="470-473.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

