<HTML>
<HEAD>

<TITLE>Java 1.2 In Record Time:More Graphics Animation Power</TITLE>




<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="..\ch14\450-452.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="458-461.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">SKILL 15<BR>More Graphics Animation Power
</FONT></H2>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;Using double buffering for faster animation updating
<DD><B>&#149;</B>&nbsp;&nbsp;Using the card layout to animate panels of controls
<DD><B>&#149;</B>&nbsp;&nbsp;Updating the dauber applet to include animation
<DD><B>&#149;</B>&nbsp;&nbsp;Creating graphic images in memory
</DL>
<P><BIG><BIG>I</BIG></BIG>n Skill 14, you got your start in animation. Here, we&#146;re going to continue that work by examining some popular animation techniques. One of those is <I>double-buffering</I>, which is a method that allows you to construct complicated graphics images in memory and then flash them on the screen, rather than having to construct them on the screen as the user watches. We&#146;ll also see how to update the dauber painting program in this skill. Finally, we&#146;ll look at one more Java layout: the <I>card</I> layout, which lets you flash panels of controls or images onto the screen as you like, animating them. We&#146;ll start at once with the double-buffering technique now.</P>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Working with Double Buffering</FONT></H3>
<P>Double buffering allows you to develop complex graphics images off-screen and then flash them on the screen when they are complete. You wouldn&#146;t want to create the graphics you want to animate on the screen, in front of the user, frame by frame, as the user watches. It is far better to create each image in memory first and display it only when ready. This technique, double buffering, is a powerful Java technique that you&#146;ll learn how to use now.
</P>
<P>For this example, the graphics images won&#146;t be all that complex. You&#146;ll develop just a series of white boxes, as shown in Figure 15.1. In succeeding frames, the innermost rectangle becomes larger, so as you work through all 20 images in an animation example, it looks as though the rectangle is growing from upper left to the lower right, as shown in Figure 15.2. None of these images will exist on disk. You&#146;ll create them in memory and then display them on the screen.</P>
<P><A NAME="Fig1"></A><A HREF="images\15-01.jpg"><IMG SRC="images\15-01t.jpg"></A>
<BR><A HREF="images\15-01.jpg"><FONT COLOR="#000077"><B>FIGURE 15.1</B></FONT></A>&nbsp;&nbsp;You&#146;ll develop simple graphics images for this example.</P>
<P><A NAME="Fig2"></A><A HREF="images\15-02.jpg"><IMG SRC="images\15-02t.jpg"></A>
<BR><A HREF="images\15-02.jpg"><FONT COLOR="#000077"><B>FIGURE 15.2</B></FONT></A>&nbsp;&nbsp;Over the course of our example, the innermost rectangle will get larger.</P>
<P>Create a new file named <TT>doublebuffer.java</TT>. You will need an image object in memory that you can draw in&#151;this will be your &#147;buffer&#148; image. Create this image object as an object of the <TT>Image</TT> class, calling it <TT>memoryimage</TT>:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

 public class doublebuffer extends Applet &#123;

&#8594;    Image memoryimage;
          .
          .
          .
</PRE>
<P>The <TT>Image</TT> class methods appear in Table 15.1.</P>
<TABLE WIDTH="100%"><CAPTION ALIGN=LEFT><B>Table 15.1:</B> The Java <TT>Image</TT> class methods
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TH WIDTH="45%" ALIGN="LEFT">Method
<TH WIDTH="55%" ALIGN="LEFT">Does This
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD><TT>Image()</TT>
<TD>Creates a new <TT>Image</TT> object
<TR>
<TD><TT>createScaledImage(int, int, int)</TT>
<TD>Creates a scaled version of this image
<TR>
<TD VALIGN="TOP"><TT>flush()</TT>
<TD>Flushes all resources being used by this <TT>Image</TT> object
<TR>
<TD><TT>getGraphics()</TT>
<TD>Gets a graphics object to draw into this image
<TR>
<TD><TT>getHeight(ImageObserver)</TT>
<TD>Gets the actual height of the image
<TR>
<TD><TT>getProperty(String, ImageObserver)</TT>
<TD>Gets a property of the image by name
<TR>
<TD VALIGN="TOP"><TT>getSource()</TT>
<TD>Gets the object that produces the pixels for the image
<TR>
<TD><TT>getWidth(ImageObserver)</TT>
<TD>Gets the actual width of the image
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<P>You can create that new object in the <TT>init()</TT> method as follows, giving your image a size (in pixels) of 100 x 100:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

 public class doublebuffer extends Applet &#123;

      Image memoryimage;

      public void init() &#123;
&#8594;          memoryimage = createImage(100, 100);
      &#125;        .
               .
               .
</PRE>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A><FONT COLOR="#000077">Drawing in Images Stored in Memory</FONT></H4>
<P>To actually draw in your image in memory, you will need a <TT>Graphics</TT> object. You can get a <TT>Graphics</TT> object for your memory image, naming that object <TT>memorygraphics</TT>:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

 public class doublebuffer extends Applet &#123;

      Image memoryimage;
&#8594;     Graphics memorygraphics;

      public void init() &#123;
           memoryimage = createImage(100, 100);
&#8594;          memorygraphics = memoryimage.getGraphics();
      &#125;        .
               .
               .
 &#125;
</PRE>
<P>Now you can start your new thread, which will perform the actual animation. In this case, give the new thread the name <TT>doublebufferthread</TT>:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

 public class doublebuffer extends Applet &#123;

      Image memoryimage;
      Graphics memorygraphics;
&#8594;     Thread doublebufferthread;

      public void init() &#123;
           memoryimage = createImage(100, 100);
           memorygraphics = memoryimage.getGraphics();
      &#125;         .
                .
                .
</PRE>
<P>Now create and start that new thread in the <TT>start()</TT> method and implement the Runnable interface as well:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

&#8594;public class doublebuffer extends Applet implements Runnable&#123;

     Image memoryimage;
     Graphics memorygraphics;
     Thread doublebufferthread;

     public void init() &#123;
          memoryimage = createImage(100, 100);
          memorygraphics = memoryimage.getGraphics();
     &#125;

&#8594;    public void start() &#123;
&#8594;         doublebufferthread = new Thread(this);
&#8594;         doublebufferthread.start();
&#8594;    &#125;         .
               .
               .
 &#125;
</PRE>
<P>In addition, add code to stop the new thread in the <TT>stop()</TT> method, as follows:</P>
<PRE>
 import java.awt.*;
 import java.applet.Applet;

 public class doublebuffer extends Applet implements Runnable&#123;

     Image memoryimage;
     Graphics memorygraphics;
     Thread doublebufferthread;
&#8594;    boolean animateFlag = true;

     public void init() &#123;
          memoryimage = createImage(100, 100);
          memorygraphics = memoryimage.getGraphics();
     &#125;

     public void start() &#123;
          doublebufferthread = new Thread(this);
          doublebufferthread.start();
     &#125;

&#8594;     public void stop() &#123;
&#8594;          animateFlag = false;
&#8594;     &#125;         .
                .
                .
 &#125;
</PRE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="..\ch14\450-452.html">Previous</A></TD>
<TD><A HREF="..\ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="458-461.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>





</BODY>
</HTML>

