<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 7 - Multithreading

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="threaded.doc1.html">PREV</a>
 | <a href="threaded.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="1222"><i>	7.2	</i> Integrated Thread Synchronization
</a></h2>

<blockquote>
<a name="1223"><!-- --></a>
Java supports multithreading at the language (syntactic) level and via support from its run-time system and thread objects. At the language level, methods within a class that are declared <kbd>synchronized</kbd> do not run concurrently. Such methods run under control of <em>monitors</em> to ensure that variables remain in a consistent state. Every class and instantiated object has its own monitor that comes into play if required.<p>
<a name="1224"><!-- --></a>
Here are a couple of code fragments from the sorting demonstration in the HotJava web browser. The main points of interest are the two methods <kbd>stop</kbd> and <kbd>startSort</kbd>, which share a common variable called <kbd>kicker</kbd> (it kicks off the sort thread):<p>
</blockquote><a name="1225"><!-- --></a>
<blockquote><pre>public synchronized void stop() {<br>    if (kicker != null) {<br>        kicker.stop();<br>        kicker = null;<br>    }<br>}</pre></blockquote><a name="1226"><!-- --></a>
<blockquote><pre>private synchronized void startSort() { <br>    if (kicker == null || !kicker.isAlive()) {<br>        kicker = new Thread(this);<br>        kicker.start();<br>    }<br>}</pre></blockquote><blockquote>
<a name="1227"><!-- --></a>
The <kbd>stop</kbd> and <kbd>startSort</kbd> methods are declared to be <kbd>synchronized</kbd>&#45;&#45;they can&#39;t run concurrently, enabling them to maintain consistent state in the shared <kbd>kicker</kbd> variable. When a <kbd>synchronized</kbd> method is entered, it acquires a monitor on the current object. The monitor precludes any other <kbd>synchronized</kbd> methods in that object from running. When a <kbd>synchronized</kbd> method returns by any means, its monitor is released. Other <kbd>synchronized</kbd> methods within the same object are now free to run.<p>
<a name="1228"><!-- --></a>
If you&#39;re writing Java applications, you should take care to implement your classes and methods so they&#39;re thread-safe, in the same way that Java run-time libraries are thread-safe. If you wish your objects to be thread-safe, any methods that may change the values of instance variables should be declared <kbd>synchronized</kbd>. This ensures that only one method can change the state of an object at any time. Java monitors are <em>re-entrant</em>: a method can acquire the same monitor more than once, and everything will still work.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="threaded.doc1.html">PREV</a>
 | <a href="threaded.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
