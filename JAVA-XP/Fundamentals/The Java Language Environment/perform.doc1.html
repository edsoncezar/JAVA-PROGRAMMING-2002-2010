<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 8 - Performance and Comparisons

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="perform.doc.html">PREV</a>
 | <a href="perform.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="2489"><i>	8.1	</i> Performance
</a></h2>

<blockquote>
<a name="2490"><!-- --></a>
Java has been ported to and run on a variety of hardware platforms executing a variety of operating system software. Test measurement of some simple Java programs on current high-end computer systems such as workstations and high-performance personal computers show results roughly as follows:<p>
<a name="2512"><!-- --></a>
<table border=0>
<tr>
<td><kbd>new Object</kbd></td>
<td>119,000 per second<br></td>
</tr>
<tr>
<td><kbd>new C()</kbd> (class with several methods)</td>
<td>89,000 per second<br></td>
</tr>
<tr>
<td><kbd>o.f()</kbd> (method <kbd>f</kbd> invoked on object <kbd>o</kbd>)</td>
<td>590,000 per second<br></td>
</tr>
<tr>
<td><kbd>o.sf()</kbd> (synchronized method <kbd>sf</kbd> invoked on object <kbd>o</kbd>)</td>
<td>61,500 per second<br></td>
</tr>
</table>
<p>
<a name="2513"><!-- --></a>
Thus, we see that creating a new object requires approximately 8.4 &#181;sec, creating a new class containing several methods consumes about 11 &#181;sec, and invoking a method on an object requires roughly 1.7 &#181;sec. <p>
<a name="2538"><!-- --></a>
While these performance numbers for interpreted bytecodes are usually more than adequate to run interactive graphical end-user applications, situations may arise where higher performance is required. In such cases, Java bytecodes can be translated on the fly (at run time) into machine code for the particular CPU on which the application is executing. This process is performed by the Just In Time (JIT) compiler. For those accustomed to the normal design of a compiler and dynamic loader, the Just In Time compiler  is somewhat like putting the final machine code generator in the dynamic loader.<p>
<a name="1656"><!-- --></a>
The bytecode format was designed with generating machine codes in mind, so the actual process of generating machine code is generally simple. Reasonably good code is produced: it does automatic register allocation and the compiler does some optimization when it produces the bytecodes. Performance of bytecodes converted to machine code is roughly the same as native C or C++. <p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="perform.doc.html">PREV</a>
 | <a href="perform.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
