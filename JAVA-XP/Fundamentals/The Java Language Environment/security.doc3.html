<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 6 - Security in Java

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="security.doc2.html">PREV</a>
 | <a href="security.doc4.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="1056"><i>	6.3	</i> The Byte Code Verification Process
</a></h2>

<blockquote>
<a name="1379"><!-- --></a>
What about the concept of a &#34;hostile compiler&#34;? Although the Java compiler ensures that Java source code doesn&#39;t violate the safety rules, when an application such as the HotJava Browser imports a code fragment from anywhere, it doesn&#39;t actually know if code fragments follow Java language rules for safety: the code may not have been produced by a known-to-be trustworthy Java compiler. In such a case, how is the Java run-time system on your machine to trust the incoming bytecode stream? The answer is simple: the Java run-time system doesn&#39;t trust the incoming code, but subjects it to <em>bytecode verification</em>.<p>
<a name="1058"><!-- --></a>
The tests range from simple verification that the format of a code fragment is correct, to passing each code fragment through a simple theorem prover to establish that it plays by the rules:<p>
</blockquote>
<blockquote>
<ul><li>
<a name="2438"><!-- --></a>
it doesn&#39;t forge pointers,
</li>
<li>
<a name="2439"><!-- --></a>
it doesn&#39;t violate access restrictions,
</li>
<li>
<a name="2440"><!-- --></a>
it accesses objects as what they are (for example, <kbd>InputStream</kbd> objects are always used as <kbd>InputStream</kbd>s and never as anything else).
</li>
</ul>
</blockquote>
<blockquote>
<a name="2441"><!-- --></a>
A language that is safe, plus run-time verification of generated code, establishes a base set of guarantees that interfaces cannot be violated.<p>
</blockquote>
<br>
<h3>
<a name="1063"><!-- --></a>
<i>	6.3.1	</i> The Byte Code Verifier
</h3>

<blockquote>
<a name="1064"><!-- --></a>
The <em>bytecode</em> <em>verifier</em> traverses the bytecodes, constructs the type state information, and verifies the types of the parameters to all the bytecode instructions.<p><img src="security.doc.anc.gif"><p>
<a name="1409"><!-- --></a>
The illustration shows the flow of data and control from Java language source code through the Java compiler, to the class loader and bytecode verifier and hence on to the Java virtual machine, which contains the interpreter and runtime system. The important issue is that the Java class loader and the bytecode verifier make no assumptions about the primary source of the bytecode stream&#45;&#45;the code may have come from the local system, or it may have travelled halfway around the planet. The bytecode verifier acts as a sort of gatekeeper: it ensures that code passed to the Java interpreter is in a fit state to be executed and can run without fear of breaking the Java interpreter. Imported code is not allowed to execute by any means until after it has passed the verifier&#39;s tests. Once the verifier is done, a number of important properties are known:<p>
</blockquote>
<blockquote>
<ul><li>
<a name="1091"><!-- --></a>
There are no operand stack overflows or underflows
</li>
<li>
<a name="1092"><!-- --></a>
The types of the parameters of all bytecode instructions are known to always be correct
</li>
<li>
<a name="1094"><!-- --></a>
Object field accesses are known to be legal&#45;&#45;private, public, or protected
</li>
</ul>
</blockquote>
<blockquote>
<a name="1454"><!-- --></a>
While all this checking appears excruciatingly detailed, by the time the bytecode verifier has done its work, the Java interpreter can proceed, knowing that the code will run securely. Knowing these properties makes the Java interpreter much faster, because it doesn&#39;t have to check anything. There are no operand type checks and no stack overflow checks. The interpreter can thus function at full speed without compromising reliability.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="security.doc2.html">PREV</a>
 | <a href="security.doc4.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
