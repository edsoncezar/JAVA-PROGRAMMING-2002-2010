<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 2 - Java&#45;&#45;Simple and Familiar

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="simple.doc1.html">PREV</a>
 | <a href="simple.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="4076"><i>	2.2	</i> Features Removed from C and C++
</a></h2>

<blockquote>
<a name="4077"><!-- --></a>
The earlier part of this chapter concentrated on the principal features of Java. This section discusses features removed from C and C++ in the evolution of Java. <p>
<a name="4125"><!-- --></a>
The first step was to <em>eliminate redundancy</em> from C and C++. In many ways, the C language evolved into a collection of overlapping features, providing too many ways to say the same thing, while in many cases not providing needed features. C++, in an attempt to add &#34;classes in C&#34;, merely added more redundancy while retaining many of the inherent problems of C.<p>
</blockquote>
<br>
<h3>
<a name="4078"><!-- --></a>
<i>	2.2.1	</i> No More Typedefs, Defines, or Preprocessor
</h3>

<blockquote>
<a name="4079"><!-- --></a>
Source code written in Java is <em>simple</em>. There is no <em>preprocessor</em>, no <kbd>#define</kbd> and related capabilities, no <kbd>typedef</kbd>, and absent those features, no longer any need for <em>header files</em>. Instead of header files, Java language source files provide the declarations of other classes and their methods. <p>
<a name="4080"><!-- --></a>
A major problem with C and C++ is the amount of context you need to understand another programmer&#39;s code: you have to read all related header files, all related <kbd>#define</kbd>s, and all related <kbd>typedef</kbd>s before you can even begin to analyze a program. In essence, programming with <kbd>#defines</kbd> and <kbd>typedef</kbd>s results in every programmer inventing a new programming language that&#39;s incomprehensible to anybody other than its creator, thus defeating the goals of good programming practices.<p>
<a name="4081"><!-- --></a>
In Java, you obtain the effects of <kbd>#define</kbd> by using constants. You obtain the effects of <kbd>typedef</kbd> by declaring classes&#45;&#45;after all, a class effectively declares a new type. You don&#39;t need header files because the Java compiler compiles class definitions into a binary form that retains all the type information through to link time. <p>
<a name="4082"><!-- --></a>
By removing all this baggage, Java becomes remarkably <em>context-free</em>. Programmers can read and understand code and, more importantly, modify and reuse code much faster and easier. <p>
</blockquote>
<br>
<h3>
<a name="4083"><!-- --></a>
<i>	2.2.2	</i> No More Structures or Unions
</h3>

<blockquote>
<a name="4084"><!-- --></a>
Java has no structures or unions as complex data types. You don&#39;t need structures and unions when you have classes; you can achieve the same effect simply by declaring a class with the appropriate instance variables. <p>
<a name="4085"><!-- --></a>
The code fragment below declares a class called <kbd>Point</kbd>. <p>
</blockquote><a name="4086"><!-- --></a>
<blockquote><pre>    class Point extends Object { <br>        double  x;<br>        double  y;<br>                //  <em>methods to access the instance variables<br></em>    }</pre></blockquote><blockquote>
<a name="4342"><!-- --></a>
The following code fragment declares a class called <kbd>Rectangle</kbd> that uses objects of the <kbd>Point</kbd> class as instance variables.<p>
</blockquote><a name="4087"><!-- --></a>
<blockquote><pre>    class Rectangle extends Object {<br>        Point  lowerLeft;<br>        Point  upperRight;<br>                //  <em>methods to access the instance variables<br></em>    }</pre></blockquote><blockquote>
<a name="4335"><!-- --></a>
In C you&#39;d define these classes as structures. In Java, you simply declare classes. You can make the instance variables as private or as public as you wish, depending on how much you wish to hide the details of the implementation from other objects. <p>
</blockquote><a name="4333"><!-- --></a>
<blockquote><pre></pre></blockquote>
<br>
<h3>
<a name="5627"><!-- --></a>
<i>	2.2.3	</i> No Enums
</h3>

<blockquote>
<a name="5628"><!-- --></a>
Java has no <em>enum </em>types. You can obtain something similar to <kbd>enum</kbd> by declaring a class whose only <em>raison d&#39;etre</em> is to hold constants. You could use this feature something like this:<p>
</blockquote><a name="5647"><!-- --></a>
<blockquote><pre>    class Direction extends Object {<br>        public static final int North = 1;<br>        public static final int South = 2;<br>        public static final int East  = 3;<br>        public static final int West  = 4;<br>    }</pre></blockquote><blockquote>
<a name="5645"><!-- --></a>
You can now refer to, say, the <kbd>South</kbd> constant using the notation <kbd>Direction.South</kbd>.<p>
<a name="5680"><!-- --></a>
Using classes to contain constants in this way provides a major advantage over C&#39;s <kbd>enum</kbd> types. In C (and C++), names defined in <kbd>enum</kbd>s must be unique: if you have an <kbd>enum</kbd> called <kbd>HotColors</kbd> containing names <kbd>Red</kbd> and <kbd>Yellow</kbd>, you can&#39;t use those names in any other <kbd>enum</kbd>. You couldn&#39;t, for instance, define another <kbd>Enum</kbd> called <kbd>TrafficLightColors</kbd> also containing <kbd>Red</kbd> and <kbd>Yellow</kbd>.<p>
<a name="5687"><!-- --></a>
Using the class-to-contain-constants technique in Java, you can use the same names in different classes, because those names are qualified by the name of the containing class. From our example just above, you might wish to create another class called <kbd>CompassRose</kbd>:<p>
</blockquote><a name="5692"><!-- --></a>
<blockquote><pre>    class CompassRose extends Object {<br>        public static final int North     = 1;<br>        public static final int NorthEast = 2;<br>        public static final int East      = 3;<br>        public static final int SouthEast = 4;<br>        public static final int South     = 5;<br>        public static final int SouthWest = 6;<br>        public static final int West      = 7;<br>        public static final int NorthWest = 8;<br>    }</pre></blockquote><blockquote>
<a name="5690"><!-- --></a>
There is no ambiguity because the name of the containing class acts as a qualifier for the constants. In the second example, you would use the notation <kbd>CompassRose.NorthWest</kbd> to access the corresponding value. Java effectively provides you the concept of qualified <kbd>enum</kbd>s, all within the existing class mechanisms.<p>
</blockquote>
<br>
<h3>
<a name="5642"><!-- --></a>
<i>	2.2.4	</i> No More Functions
</h3>

<blockquote>
<a name="5635"><!-- --></a>
Java has no <em>functions</em>. Object-oriented programming supersedes functional and procedural styles. Mixing the two styles just leads to confusion and dilutes the purity of an object-oriented language. Anything you can do with a function you can do just as well by defining a class and creating methods for that class. Consider the <kbd>Point</kbd> class from above. We&#39;ve added public methods to set and access the instance variables:<p>
</blockquote><a name="4355"><!-- --></a>
<blockquote><pre>    class Point extends Object { <br>        double  x;<br>        double  y;<br>        </pre></blockquote><a name="4360"><!-- --></a>
<blockquote><pre>        public void setX(double x) {<br>            this.x = x;<br>        }<br>        public void setY(double y) {<br>            this.y = y;<br>        }<br>        public double x() {<br>            return x;<br>        }<br>        public double y() {<br>            return y;<br>        }<br>    }</pre></blockquote><blockquote>
<a name="4353"><!-- --></a>
If the <kbd>x</kbd> and <kbd>y</kbd> instance variables are private to this class, the only means to access them is via the public methods of the class. Here&#39;s how you&#39;d use objects of the <kbd>Point</kbd> class from within, say, an object of the <kbd>Rectangle</kbd> class:<p>
</blockquote><a name="4405"><!-- --></a>
<blockquote><pre>    class Rectangle extends Object { <br>        Point  lowerLeft;<br>        Point  upperRight;<br>        </pre></blockquote><a name="4406"><!-- --></a>
<blockquote><pre>        public void setEmptyRect() {<br>            lowerLeft.setX(0.0);<br>            lowerLeft.setY(0.0);<br>            upperRight.setX(0.0);<br>            upperRight.setY(0.0);<br>        }<br>    }</pre></blockquote><blockquote>
<a name="4402"><!-- --></a>
It&#39;s not to say that functions and procedures are inherently wrong. But given classes and methods, we&#39;re now down to only one way to express a given task. By eliminating functions, your job as a programmer is immensely simplified: you work <em>only</em> with classes and their methods.<p>
</blockquote>
<br>
<h3>
<a name="4090"><!-- --></a>
<i>	2.2.5	</i> No More Multiple Inheritance
</h3>

<blockquote>
<a name="4091"><!-- --></a>
<em>Multiple inheritance</em>&#45;&#45;and all the problems it generates&#45;&#45;was discarded from Java. The desirable features of multiple inheritance are provided by <em>interfaces</em>&#45;&#45;conceptually similar to Objective C protocols.<p>
<a name="4092"><!-- --></a>
An interface is not a definition of a class. Rather, it&#39;s a definition of a set of methods that one or more classes will implement. An important issue of interfaces is that they declare only methods and constants. Variables may not be defined in interfaces.<p>
</blockquote>
<br>
<h3>
<a name="4093"><!-- --></a>
<i>	2.2.6	</i> No More Goto Statements 
</h3>

<blockquote>
<a name="4097"><!-- --></a>
Java has no <kbd>goto</kbd> statement<a href="#5551"><sup>1</sup></a>. Studies illustrated that <kbd>goto</kbd> is (mis)used more often than not simply &#34;because it&#39;s there&#34;. Eliminating <kbd>goto</kbd> led to a simplification of the language&#45;&#45;there are no rules about the effects of a <kbd>goto</kbd> into the middle of a <kbd>for</kbd> statement, for example. Studies on approximately 100,000 lines of C code determined that roughly 90 percent of the <kbd>goto</kbd> statements were used purely to obtain the effect of breaking out of nested loops. As mentioned above, multi-level <kbd>break</kbd> and <kbd>continue</kbd> remove most of the need for <kbd>goto</kbd> statements.<p>
</blockquote>
<br>
<h3>
<a name="4098"><!-- --></a>
<i>	2.2.7	</i> No More Operator Overloading
</h3>

<blockquote>
<a name="4099"><!-- --></a>
There are no means provided by which programmers can overload the standard arithmetic operators. Once again, the effects of operator overloading can be just as easily achieved by declaring a class, appropriate instance variables, and appropriate methods to manipulate those variables. Eliminating operator overloading leads to great simplification of code.<p>
</blockquote>
<br>
<h3>
<a name="4100"><!-- --></a>
<i>	2.2.8	</i> No More Automatic Coercions
</h3>

<blockquote>
<a name="4101"><!-- --></a>
Java prohibits C and C++ style <em>automatic coercions. </em>If you wish to coerce a data element of one type to a data type that would result in loss of precision, you must do so explicitly by using a cast. Consider this code fragment:<p>
</blockquote><a name="4102"><!-- --></a>
<blockquote><pre><br>    int  myInt;<br>    double  myFloat = 3.14159;</pre></blockquote><a name="4103"><!-- --></a>
<blockquote><pre>    myInt = myFloat;</pre></blockquote><blockquote>
<a name="4104"><!-- --></a>
The assignment of <kbd>myFloat</kbd> to <kbd>myInt</kbd> would result in a compiler error indicating a possible loss of precision and that you must use an explicit cast. Thus, you should re-write the code fragments as:<p>
</blockquote><a name="4105"><!-- --></a>
<blockquote><pre>    int  myInt;<br>    double  myFloat = 3.14159;</pre></blockquote><a name="4106"><!-- --></a>
<blockquote><pre>    myInt = (int)myFloat;<br></pre></blockquote>
<br>
<h3>
<a name="4107"><!-- --></a>
<i>	2.2.9	</i> No More Pointers
</h3>

<blockquote>
<a name="4108"><!-- --></a>
Most studies agree that <em>pointers</em> are one of the primary features that enable programmers to inject bugs into their code. Given that structures are gone, and arrays and strings are objects, the need for pointers to these constructs goes away. Thus, Java has no pointer data types. Any task that would require arrays, structures, and pointers in C can be more easily and reliably performed by declaring objects and arrays of objects. Instead of complex pointer manipulation on array pointers, you access arrays by their arithmetic indices. The Java run-time system checks all array indexing to ensure indices are within the bounds of the array. <p>
<a name="5179"><!-- --></a>
You no longer have dangling pointers and trashing of memory because of incorrect pointers, because there are no pointers in Java.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="simple.doc1.html">PREV</a>
 | <a href="simple.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
