<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>The Java(TM) Language Environment: 2 - Java -- Simple and Familiar

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="simple.doc.html">PREV</a>
 | <a href="simple.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java<SUP><FONT SIZE="-2">TM</FONT></SUP> Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="1225"><i>	2.1	</i> Main Features of the Java<SUP><FONT SIZE="-2">TM</FONT></SUP> Programming Language
</a></h2>

<blockquote>
<a name="4479"><!-- --></a>
The Java<SUP><FONT SIZE="-2">TM</FONT></SUP> programming language follows C++ to some degree, which carries the benefit of it being familiar to many programmers. This section describes the essential features of the Java programming language and points out where the language diverges from its ancestors C and C++.<p>
</blockquote>
<br>
<h3>
<a name="376"><!-- --></a>
<i>	2.1.1	</i> Primitive Data Types
</h3>

<blockquote>
<a name="378"><!-- --></a>
Other than the primitive data types discussed here, everything in the Java programming language is an object. Even the primitive data types can be encapsulated inside library-supplied objects if required. The Java programming language follows C and C++ fairly closely in its set of basic data types, with a couple of minor exceptions. There are only three groups of primitive data types, namely, <em>numeric</em> types, <em>character</em> types, and <em>Boolean</em> types.<p>
</blockquote>

<blockquote>
<a name="382"><!-- --></a>
<i><b> Numeric Data Types
</b></i>
</blockquote>
<blockquote>
<a name="4071"><!-- --></a>
<em>Integer</em> numeric types are 8-bit <kbd>byte</kbd>, 16-bit <kbd>short</kbd>, 32-bit <kbd>int</kbd>, and 64-bit <kbd>long</kbd>. The 8-bit <kbd>byte</kbd> data type in Java has replaced the old C and C++ <kbd>char</kbd> data type. Java places a different interpretation on the <kbd>char</kbd> data type, as discussed below.<p>
<a name="4482"><!-- --></a>
There is no <kbd>unsigned</kbd> type specifier for integer data types in Java.<p>
<a name="386"><!-- --></a>
<em>Real</em> numeric types are 32-bit <kbd>float</kbd> and 64-bit <kbd>double</kbd>. Real numeric types and their arithmetic operations are as defined by the IEEE 754 specification. A floating point <em>literal</em> value, like <kbd>23.79</kbd>, is considered <kbd>double</kbd> by default; you must explicitly cast it to <kbd>float</kbd> if you wish to assign it to a <kbd>float</kbd> variable.<p>
</blockquote>

<blockquote>
<a name="390"><!-- --></a>
<i><b> Character Data Types
</b></i>
</blockquote>
<blockquote>
<a name="4072"><!-- --></a>
Java language<em> character</em> data is a departure from traditional C. Java&#39;s <kbd>char</kbd> data type defines a sixteen-bit <em>Unicode</em> character. Unicode characters are unsigned 16-bit values that define character codes in the range 0 through 65,535. If you write a declaration such as<p>
</blockquote><a name="392"><!-- --></a>
<blockquote><pre>    char  myChar = `Q&#39;;</pre></blockquote><blockquote>
<a name="394"><!-- --></a>
you get a Unicode (16-bit unsigned value) type initialized to the Unicode value of the character Q. By adopting the Unicode character set standard for its character data type, Java language applications are amenable to internationalization and localization, greatly expanding the market for world-wide applications.<p>
</blockquote>

<blockquote>
<a name="398"><!-- --></a>
<i><b> Boolean Data Types
</b></i>
</blockquote>
<blockquote>
<a name="4073"><!-- --></a>
Java added a Boolean data type as a primitive type, tacitly ratifying existing C and C++ programming practice, where developers define keywords for TRUE and FALSE or YES and NO or similar constructs. A Java <kbd>boolean</kbd> variable assumes the value <kbd>true</kbd> or <kbd>false</kbd>. A Java programming language <kbd>boolean</kbd> is a distinct data type; unlike common C practice, a Java programming language <kbd>boolean</kbd> type can&#39;t be converted to any numeric type.<p>
</blockquote>
<br>
<h3>
<a name="406"><!-- --></a>
<i>	2.1.2	</i> Arithmetic and Relational Operators
</h3>

<blockquote>
<a name="408"><!-- --></a>
All the familiar C and C++ operators apply. The Java programming language has no <kbd>unsigned</kbd> data types, so the <kbd><b>&gt;&gt;&gt;</b></kbd> operator has been added to the language to indicate an unsigned (logical) right shift. Java also uses the <kbd><b>+</b></kbd> operator for string concatenation; concatenation is covered below in the discussion on strings. <p>
</blockquote>
<br>
<h3>
<a name="410"><!-- --></a>
<i>	2.1.3	</i> Arrays
</h3>

<blockquote>
<a name="412"><!-- --></a>
In contrast to C and C++, the Java programming language <em>arrays</em> are first-class language objects. An array in the Java programming language is a real object with a run-time representation. You can declare and allocate arrays of any type, and you can allocate arrays of arrays to obtain multi-dimensional arrays. <p>
<a name="3794"><!-- --></a>
You declare an array of, say, <kbd>Point</kbd>s (a class you&#39;ve declared elsewhere) with a declaration like this:<p>
</blockquote><a name="1269"><!-- --></a>
<blockquote><pre>    Point  myPoints[];</pre></blockquote><blockquote>
<a name="1270"><!-- --></a>
This code states that <kbd>myPoints</kbd> is an uninitialized array of <kbd>Point</kbd>s. At this time, the only storage allocated for <kbd>myPoints</kbd> is a reference handle. At some future time you must allocate the amount of storage you need, as in:<p>
</blockquote><a name="1271"><!-- --></a>
<blockquote><pre>    myPoints = new Point[10];</pre></blockquote><blockquote>
<a name="1272"><!-- --></a>
to allocate an array of ten references to <kbd>Point</kbd>s that are initialized to the null reference. Notice that this allocation of an array doesn&#39;t actually allocate any objects of the <kbd>Point</kbd> class for you; you will have to also allocate the <kbd>Point</kbd> objects, something like this:<p>
</blockquote><a name="4536"><!-- --></a>
<blockquote><pre>    int  i;<br>    <br>    for (i = 0;  i &lt; 10;  i++) {<br>        myPoints<kbd>[i] = new Point();<br></kbd>    }</pre></blockquote><blockquote>
<a name="4550"><!-- --></a>
Access to elements of <kbd>myPoints</kbd> can be performed via normal C-style indexing, but all array accesses are checked to ensure that their indices are within the range of the array. An <em>exception</em> is generated if the index is outside the bounds of the array.<p>
<a name="4552"><!-- --></a>
The length of an array is stored in the <kbd>length</kbd> instance variable of the specific array: <kbd>myPoints.length</kbd> contains the number of elements in <kbd>myPoints</kbd>. For instance, the code fragment:<p>
</blockquote><a name="4562"><!-- --></a>
<blockquote><pre>    howMany = myPoints<kbd>.length;</kbd></pre></blockquote><blockquote>
<a name="1249"><!-- --></a>
would assign the value 10 to the <kbd>howMany</kbd> variable.<p>
<a name="4575"><!-- --></a>
The C notion of a pointer to an array of memory elements is gone, and with it, the arbitrary pointer arithmetic that leads to unreliable code in C. No longer can you walk off the end of an array, possibly trashing memory and leading to the famous &#34;delayed-crash&#34; syndrome, where a memory-access violation today manifests itself hours or days later. Programmers can be confident that array checking in Java will lead to more robust and reliable code.<p>
</blockquote>
<br>
<h3>
<a name="414"><!-- --></a>
<i>	2.1.4	</i> Strings
</h3>

<blockquote>
<a name="417"><!-- --></a>
<em>Strings</em> are Java programming language objects, not pseudo-arrays of characters as in C. There are actually two kinds of string objects: the <kbd>String</kbd> class is for read-only (immutable) objects. The <kbd>StringBuffer</kbd> class is for string objects you wish to modify (mutable string objects).<p>
<a name="5078"><!-- --></a>
Although strings are Java programming language objects, Java compiler follows the C tradition of providing a syntactic convenience that C programmers have enjoyed with C-style strings, namely, the Java compiler understands that a string of characters enclosed in double quote signs is to be instantiated as a <kbd>String</kbd> object. Thus, the declaration:<p>
</blockquote><a name="419"><!-- --></a>
<blockquote><pre>    String hello = "Hello world!";</pre></blockquote><blockquote>
<a name="421"><!-- --></a>
instantiates an object of the String class behind the scenes and initializes it with a character string containing the Unicode character representation of "Hello world!". <p>
<a name="423"><!-- --></a>
Java technology has extended the meaning of the + operator to indicate <em>string concatenation</em>. Thus you can write statements like:<p>
</blockquote><a name="425"><!-- --></a>
<blockquote><pre>System.out.println("There are " + num + " characters in the file.");</pre></blockquote><blockquote>
<a name="427"><!-- --></a>
This code fragment concatenates the string <kbd>"There are "</kbd> with the result of converting the numeric value <kbd>num</kbd> to a string, and concatenates that with the string<kbd> " characters in the file."</kbd>. Then it prints the result of those concatenations on the standard output.<p>
<a name="1281"><!-- --></a>
<kbd>String</kbd> objects provide a <kbd>length()</kbd> <em>accessor method</em> to obtain the number of characters in the string.<p>
</blockquote>
<br>
<h3>
<a name="429"><!-- --></a>
<i>	2.1.5	</i> Multi-Level Break
</h3>

<blockquote>
<a name="431"><!-- --></a>
The Java programming language has no <kbd>goto</kbd> statement. To <kbd>break</kbd> or <kbd>continue</kbd> multiple-nested loop or switch constructs, you can place labels on loop and <kbd>switch</kbd> constructs, and then <kbd>break</kbd> out of or <kbd>continue</kbd> to the block named by the label. Here&#39;s a small fragment of code from the Java programming language  built-in <kbd>String</kbd> class:<p>
</blockquote><a name="1299"><!-- --></a>
<blockquote><pre><br>test:  for (int i = fromIndex; i + max1 &lt;= max2; i++) {<br>           if (charAt(i) == c0) {<br>               for (int k = 1; k&lt;max1; k++) {<br>                   if (charAt(i+k) != str.charAt(k)) {<br>                       continue test;<br>                   }<br>               }     /*  end of inner for loop  */<br>           }<br>       }             /*  end of outer for loop  */</pre></blockquote><blockquote>
<a name="1296"><!-- --></a>
<br>The <kbd>continue</kbd> <kbd>test</kbd> statement is inside a <kbd>for</kbd> loop nested inside another <kbd>for</kbd> loop. By referencing the label <kbd>test</kbd>, the <kbd>continue</kbd> statement passes control to the outer <kbd>for</kbd> statement. In traditional C, <kbd>continue</kbd> statements can only continue the immediately enclosing block; to continue or exit outer blocks, programmers have traditionally either used auxiliary Boolean variables whose only purpose is to determine if the outer block is to be continued or exited; alternatively, programmers have (mis)used the <kbd>goto</kbd> statement to exit out of nested blocks. Use of labelled blocks in the Java programming language leads to considerable simplification in programming effort and a major reduction in maintenance.<p>
<a name="3998"><!-- --></a>
The notion of labelled blocks dates back to the mid-1970s, but it hasn&#39;t caught on to any large extent in modern programming languages. Perl is another modern programming language that implements the concept of labelled blocks. Perl&#39;s <kbd>next</kbd> <em>label</em> and <kbd>last</kbd> <em>label</em> are equivalent to <kbd>continue</kbd> <em>label</em> and <kbd>break</kbd> <em>label</em> statements in Java.<p>
</blockquote>
<br>
<h3>
<a name="2333"><!-- --></a>
<i>	2.1.6	</i> Memory Management and Garbage Collection
</h3>

<blockquote>
<a name="2338"><!-- --></a>
C and C++ programmers are by now accustomed to the problems of explicitly managing memory: allocating memory, freeing memory, and keeping track of what memory can be freed when. Explicit memory management has proved to be a fruitful source of bugs, crashes, memory leaks, and poor performance.<p>
<a name="2334"><!-- --></a>
Java technology completely removes the memory management load from the programmer. C-style pointers, pointer arithmetic, <kbd>malloc,</kbd> and <kbd>free</kbd> do not exist. <em>Automatic</em> <em>garbage collection</em> is an integral part of Java and its run-time system. While Java technology has a <kbd>new</kbd> operator to allocate memory for objects, there is no explicit <kbd>free</kbd> function. Once you have allocated an object, the run-time system keeps track of the object&#39;s status and automatically reclaims memory when objects are no longer in use, freeing memory for future use. <p>
<a name="1509"><!-- --></a>
Java technology's memory management model is based on <em>objects</em> and <em>references</em> to objects. Java technology has no pointers. Instead, all references to allocated storage, which in practice means all references to an object, are through symbolic &#34;handles&#34;. The Java technology memory manager keeps track of references to objects. When an object has no more references, the object is a candidate for garbage collection.<p>
<a name="1510"><!-- --></a>
Java technology's memory allocation model and automatic garbage collection make your programming task easier, eliminate entire classes of bugs, and in general provide better performance than you&#39;d obtain through explicit memory management. Here&#39;s a code fragment that illustrates when garbage collection happens:<p>
</blockquote><a name="947"><!-- --></a>
<blockquote><pre>class ReverseString {<br>    public static String reverseIt(String source) {<br>        int i, len = source.length();<br>        StringBuffer dest = new StringBuffer(len);<br><br>        for (i = (len - 1); i &gt;= 0; i--) {<br>            dest.appendChar(source.charAt(i));<br>        }<br>        return dest.toString();<br>    }<br>}</pre></blockquote><blockquote>
<a name="536"><!-- --></a>
The variable <kbd>dest</kbd> is used as a temporary object reference during execution of the <kbd>reverseIt</kbd> method. When <kbd>dest</kbd> goes out of scope (the <kbd>reverseIt</kbd> method returns), the reference to that object has gone away and it&#39;s then a candidate for garbage collection.<p>
</blockquote>
<br>
<h3>
<a name="455"><!-- --></a>
<i>	2.1.7	</i> The Background Garbage Collector
</h3>

<blockquote>
<a name="832"><!-- --></a>
The Java technology garbage collector achieves high performance by taking advantage of the nature of a user&#39;s behavior when interacting with software applications such as the HotJava<SUP><FONT SIZE="-2">TM</FONT></SUP> browser. The typical user of the typical interactive application has many natural pauses where they&#39;re contemplating the scene in front of them or thinking of what to do next. The Java run-time system takes advantage of these idle periods and runs the garbage collector in a low priority thread when no other threads are competing for CPU cycles. The garbage collector gathers and compacts unused memory, increasing the probability that adequate memory resources are available when needed during periods of heavy interactive use. <p>
<a name="3839"><!-- --></a>
This use of a thread to run the garbage collector is just one of many examples of the synergy one obtains from Java technology's integrated multithreading capabilities&#45;&#45;an otherwise intractable problem is solved in a simple and elegant fashion.<p>
</blockquote>
<br>
<h3>
<a name="457"><!-- --></a>
<i>	2.1.8	</i> Integrated Thread Synchronization
</h3>

<blockquote>
<a name="3564"><!-- --></a>
Java technology supports multithreading, both at the language (syntactic) level and via support from its run-time system and thread objects. While other systems have provided facilities for multithreading (usually via &#34;lightweight process&#34; libraries), building multithreading support into the language itself provides the programmer with a much easier and more powerful tool for easily creating thread-safe multithreaded classes. Multithreading is discussed in more detail in Chapter 7.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="simple.doc.html">PREV</a>
 | <a href="simple.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
