<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 4 - Architecture Neutral, Portable, <br>
and Robust

</title>
</head>
<body bgcolor="#ffffff">
 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="neutral.doc1.html">PREV</a>
 | <a href="neutral.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="269"><i>	4.2	</i> Portable
</a></h2>

<blockquote>
<a name="272"><!-- --></a>
The primary benefit of the interpreted byte code approach is that compiled Java language programs are <em>portable</em> to any system on which the Java interpreter and run-time system have been implemented.<p>
<a name="273"><!-- --></a>
The architecture-neutral aspect discussed above is one major step towards being portable, but there&#39;s more to it than that. C and C++ both suffer from the defect of designating many fundamental data types as &#34;implementation dependent&#34;. Programmers labor to ensure that programs are portable across architectures by programming to a lowest common denominator.<p>
<a name="274"><!-- --></a>
Java eliminates this issue by defining standard behavior that will apply to the data types across all platforms. Java specifies the sizes of all its primitive data types and the behavior of arithmetic on them. Here are the data types:

<br><br>
<Table Border="1" Cellpadding="5">
<caption><blockquote>
<a name="1259"><!-- --></a>
<p>
</blockquote></caption>

<tr><td><a name="1263"><!-- --></a>
<br> byte

<a name="1290"><!-- --></a>
<br> short

<a name="1291"><!-- --></a>
<br> int

<a name="1292"><!-- --></a>
<br> long

</td><td><a name="1265"><!-- --></a>
<br> 8-bit two&#39;s complement

<a name="1302"><!-- --></a>
<br>16-bit two&#39;s complement<br>32-bit two&#39;s complement<br>64-bit two&#39;s complement

</td></tr>
<tr><td><a name="1267"><!-- --></a>
<br> float

<a name="1305"><!-- --></a>
<br> double

</td><td><a name="1269"><!-- --></a>
<br>32-bit IEEE 754 floating point<br>64-bit IEEE 754 floating point

</td></tr>
<tr><td><a name="1271"><!-- --></a>
<br> char

</td><td><a name="1273"><!-- --></a>
<br>16-bit Unicode character

</td></tr>

</Table>
 
<Table>
<tr><td></td>
</tr>
</Table><p>
<p>
<a name="279"><!-- --></a>
The data types and sizes described above are standard across all implementations of Java. These choices are reasonable given current microprocessor architectures because essentially all central processor architectures in use today share these characteristics. That is, most modern processors can support two&#39;s-complement arithmetic in 8-bit to 64-bit integer formats, and most modern processors support single- and double-precision floating point.<p>
<a name="881"><!-- --></a>
The Java environment itself is readily portable to new architectures and operating systems. The Java compiler is written in Java. The Java run-time system is written in ANSI C with a clean portability boundary which is essentially POSIX-compliant. There are no &#34;implementation-dependent&#34; notes in the Java language specification.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="neutral.doc1.html">PREV</a>
 | <a href="neutral.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://java.sun.com/docs/white/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
