<HTML>

<HEAD>
   <TITLE>Chapter 10 -- java :
The Java Interpreter</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 10</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000><TT>java </FONT></TT><FONT SIZE=5 COLOR=#FF0000>:
The Java Interpreter</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#Overview" >Overview</A>
<LI><A HREF="#Usage" >Usage</A>
<LI><A HREF="#Options" >Options</A>
<LI><A HREF="#TheNonOptimizedInterpreter" >The Non-Optimized Interpreter</A>
<LI><A HREF="#Bugs" >Bugs</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
The Java runtime interpreter (<TT><FONT FACE="Courier">java</FONT></TT>)
is the component of the Java Developer's Kit used to run executable
Java bytecode classes. The Java interpreter provides a means to
run Java programs outside of a conventional Web browser. In this
chapter, you learn about the Java interpreter, including how to
use it and what options it provides for executing Java classes.
<H2><A NAME="Overview"><FONT SIZE=5 COLOR=#FF0000>Overview</FONT></A>
</H2>
<P>
The Java runtime interpreter is a stand-alone version of the Java
interpreter built into Java-compatible Web browsers, such as Netscape
Navigator. The runtime interpreter provides the support to run
Java executable programs in the compiled bytecode class format.
Because the interpreter doesn't directly provide any means to
view graphical output, you are limited to using it to execute
purely textual Java programs and applications that manage their
own graphics. If you want to run graphical Java applets, you need
to use either the Java applet viewer or a Java-compatible Web
browser. The Java applet viewer is covered in the next chapter,
&quot;Using the Applet Viewer.&quot;
<P>
You can think of the runtime interpreter as exposing the bare
essentials of the Java runtime system. Even though I use the term
&quot;bare essentials,&quot; the interpreter actually lets you
do quite a lot. Essentially, you can run any Java programs that
don't rely on the <TT><FONT FACE="Courier">Applet</FONT></TT>
class. In fact, the statement earlier about not being able to
run graphical programs isn't entirely true; you can run graphical
Java applications-you just can't run Java applets. The difference
between a Java application and a Java applet is that an application
is responsible for creating and maintaining its own window if
it requires the need for graphical output, whereas an applet relies
on a Web browser to provide a window on which to display graphics.
So, the Java interpreter is capable of executing both textual
Java programs and graphical Java applications.
<H2><A NAME="Usage"><FONT SIZE=5 COLOR=#FF0000>Usage</FONT></A>
</H2>
<P>
The runtime interpreter is a command-line tool for running Java
programs and applications; Java applets require the graphics and
display support of a Web browser. The syntax for using the Java
runtime interpreter follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java <I>Options Classname Arguments</I></FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><I><FONT FACE="Courier">Classname</FONT></I></TT> argument
specifies the name of the class you want to execute. If the class
resides in a package, you must fully qualify the name. For example,
if you want to run a class called <TT><FONT FACE="Courier">SolveIt</FONT></TT>
that is located in a package called <TT><FONT FACE="Courier">Equations</FONT></TT>,
you would execute it in the interpreter like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java Equations.SolveIt</FONT></TT>
</BLOCKQUOTE>
<P>
When the Java interpreter executes a class, what it is really
doing is executing the <TT><FONT FACE="Courier">main</FONT></TT>
method of the class. The interpreter exits when the <TT><FONT FACE="Courier">main</FONT></TT>
method and any threads created by it are finished executing. The
<TT><FONT FACE="Courier">main</FONT></TT> method accepts a list
of arguments that can be used to control the program. Following
is the definition of the <TT><FONT FACE="Courier">main</FONT></TT>
method as specified by the Java language:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class DoIt {<BR>
&nbsp;&nbsp;public static void main(String argv[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that <TT><FONT FACE="Courier">main</FONT></TT> has a single
parameter, <TT><FONT FACE="Courier">argv</FONT></TT>, which is
an array of <TT><FONT FACE="Courier">String</FONT></TT> objects.
This brings us to the <TT><I><FONT FACE="Courier">Arguments </FONT></I></TT>argument
for the runtime interpreter, which specifies the arguments passed
into the <TT><FONT FACE="Courier">main</FONT></TT> method. Any
arguments passed to the runtime interpreter by <TT><I><FONT FACE="Courier">Arguments</FONT></I></TT>
are accessible from the <TT><FONT FACE="Courier">argv</FONT></TT>
parameter in <TT><FONT FACE="Courier">main</FONT></TT>. The following
interpreter call passes two numeric arguments to the <TT><FONT FACE="Courier">main</FONT></TT>
method in the <TT><FONT FACE="Courier">DoIt</FONT></TT> class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java DoIt 8 24</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Options"><FONT SIZE=5 COLOR=#FF0000>Options</FONT></A>
</H2>
<P>
The <TT><I><FONT FACE="Courier">Options</FONT></I></TT> argument
specifies options related to how the runtime interpreter executes
the Java program. Following is a list of the most important runtime
interpreter options:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">-debug<BR>
-checksource or -cs<BR>
-classpath <I>Path<BR>
</I>-mx <I>x<BR>
</I>-ms <I>x<BR>
</I>-noasyncgc<BR>
-noverify<BR>
-ss <I>x<BR>
</I>-oss <I>x<BR>
</I>-t<BR>
-verbose or -v<BR>
-verbosegc<BR>
-verify<BR>
-verifyremote<BR>
-D<I>PropertyName=NewValue</I></FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">-debug</FONT></TT> option starts
the interpreter in debugging mode, which enables you to use the
Java debugger (<TT><FONT FACE="Courier">jdb</FONT></TT>) in conjunction
with the interpreter. To learn more about using the Java debugger,
check out <A HREF="ch15.htm" >Chapter 15</A>, &quot;jdb: The Java
Debugger.&quot;
<P>
The <TT><FONT FACE="Courier">-checksource</FONT></TT> option causes
the interpreter to compare the modification dates of the source
code files and executable class files. If the source file is more
recent, the class is automatically recompiled and the new bytecode
executable is loaded.
<P>
The Java interpreter uses an environment variable, <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>,
to determine where to look for user-defined classes. The <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
variable contains a semicolon-delimited list of system paths to
user-defined Java classes. Actually, most of the Java tools use
the <TT><FONT FACE="Courier">CLASSPATH</FONT></TT> variable to
know where to find user-defined classes. The <TT><FONT FACE="Courier">-classpath</FONT></TT>
option informs the runtime interpreter to override <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
with the path specified by <TT><I><FONT FACE="Courier">Path</FONT></I></TT>.
<P>
The <TT><FONT FACE="Courier">-mx</FONT></TT> option enables you
to modify the maximum size of the memory allocation pool, or garbage
collection heap, used by the interpreter. By default, the pool
has a maximum size of 16 megabytes (<TT><FONT FACE="Courier">-mx
16m</FONT></TT>). <TT><FONT FACE="Courier">x</FONT></TT> specifies
the new maximum size of the pool, and it is measured in bytes
by default. You also can specify <TT><FONT FACE="Courier">x </FONT></TT>in
either kilobytes or megabytes by appending the letter <TT><FONT FACE="Courier">k</FONT></TT>
or <TT><FONT FACE="Courier">m</FONT></TT> respectively onto the
value. Also, <TT><FONT FACE="Courier">x</FONT></TT> must be greater
than 1,000 bytes, meaning that the pool must have a maximum size
of at least 1,000 bytes.
<P>
The <TT><FONT FACE="Courier">-ms</FONT></TT> option is similar
to the <TT><FONT FACE="Courier">-mx</FONT></TT> option, except
that it enables you to modify the initial size of the memory allocation
pool rather than the maximum size. By default, the size of the
pool is initially set to 1 megabyte (<TT><FONT FACE="Courier">-ms
1m</FONT></TT>). <TT><FONT FACE="Courier">x</FONT></TT> specifies
the new initial pool size and is measured in bytes by default.
As with the <TT><FONT FACE="Courier">-mx</FONT></TT> option, you
also can specify <TT><FONT FACE="Courier">x</FONT></TT> in either
kilobytes or megabytes by appending the letter <TT><FONT FACE="Courier">k</FONT></TT>
or <TT><FONT FACE="Courier">m</FONT></TT> respectively onto the
value. Additionally, <TT><FONT FACE="Courier">x</FONT></TT> must
be greater than 1,000 bytes.
<P>
The Java runtime system typically performs garbage collection
automatically to make sure unneeded memory stays freed up. This
takes place in an asynchronous thread that runs alongside other
threads in the runtime system. The <TT><FONT FACE="Courier">-noasyncgc</FONT></TT>
option alters this behavior by turning off asynchronous garbage
collection. The result is that no garbage collection takes place
unless it is explicitly called upon or the Java program runs out
of memory. Incidentally, an explicit garbage collection can be
forced by calling the <TT><FONT FACE="Courier">gc</FONT></TT>
method in the <TT><FONT FACE="Courier">System</FONT></TT> class.
<P>
The <TT><FONT FACE="Courier">-noverify</FONT></TT> option turns
all code verification off, meaning that no bytecodes are processed
by the bytecode verifier. Typically, the verifier verifies code
loaded into the system using a class loader.
<P>
Every thread in the Java runtime system is given two stacks, one
for Java code and one for C/C++ code. The presence of two stacks
reflects the native code support in Java. The <TT><FONT FACE="Courier">-ss</FONT></TT>
option enables you to alter the maximum stack size used by C code
in a thread. The default C stack size is 128 kilobytes (<TT><FONT FACE="Courier">-ss
128k</FONT></TT>). The <TT><FONT FACE="Courier">x</FONT></TT>
parameter specifies the new maximum size in bytes of the C stack,
which must be greater than 1,000 bytes. You also can specify <TT><FONT FACE="Courier">x</FONT></TT>
in either kilobytes or megabytes by appending the letter <TT><FONT FACE="Courier">k</FONT></TT>
or <TT><FONT FACE="Courier">m</FONT></TT> onto the value, respectively.
Keep in mind that this option applies to all threads created during
program execution.
<P>
Similar to the <TT><FONT FACE="Courier">-ss</FONT></TT> option,
the <TT><FONT FACE="Courier">-oss</FONT></TT> option enables you
to set the maximum stack size that can be used by the Java code
in a thread. The default Java code stack size is 400 kilobytes
(<TT><FONT FACE="Courier">-oss 400k</FONT></TT>). The <TT><FONT FACE="Courier">x</FONT></TT>
parameter specifies the new maximum size in bytes of the Java
stack, which must be greater than 1,000 bytes.
<P>
The <TT><FONT FACE="Courier">-t</FONT></TT> option prints a trace
of the bytecode instructions executed. This option works only
with the non-optimized version of the Java interpreter, <TT><FONT FACE="Courier">java_g</FONT></TT>.
You learn about the non-optimized interpreter in a moment. The
<TT><FONT FACE="Courier">-t</FONT></TT> option generates a great
deal of information that can give you a lot of insight into what
is happening within a program. Of course, it would help if you
had some understanding of Java bytecodes.
<P>
The <TT><FONT FACE="Courier">-verbose</FONT></TT> option causes
the interpreter to print a message to standard output each time
a Java class is loaded. Similarly, the <TT><FONT FACE="Courier">-verbosegc</FONT></TT>
option causes the interpreter to print a message each time a garbage
collection is performed. A garbage collection is performed by
the runtime system to clean up unneeded objects and to free memory.
<P>
The opposite of the <TT><FONT FACE="Courier">-noverify</FONT></TT>
option, the <TT><FONT FACE="Courier">-verify</FONT></TT> option
causes the interpreter to run the bytecode verifier on all code
loaded into the runtime environment. The default function of the
verifier is to only verify code loaded into the system using a
class loader. This default behavior also can be explicitly specified
using the <TT><FONT FACE="Courier">-verifyremote</FONT></TT> option.
<P>
The <TT><FONT FACE="Courier">-D</FONT></TT> option enables you
to redefine property values. <TT><I><FONT FACE="Courier">PropertyName</FONT></I></TT>
specifies the name of the property you want to change, and <TT><I><FONT FACE="Courier">NewValue</FONT></I></TT>
specifies the new value you want to assign to it.
<H2><A NAME="TheNonOptimizedInterpreter"><FONT SIZE=5 COLOR=#FF0000>The
Non-Optimized Interpreter</FONT></A></H2>
<P>
Some distributions of the Java Developer's Kit include an alternate
Java interpreter called <TT><FONT FACE="Courier">java_g</FONT></TT>.
This is a non-optimized version of the Java interpreter that executes
Java bytecodes in a manner more suitable for debugging. If this
interpreter is in your JDK distribution, be sure to use it when
you are executing code within the Java debugger.
<H2><A NAME="Bugs"><FONT SIZE=5 COLOR=#FF0000>Bugs</FONT></A>
</H2>
<P>
The latest release of the Java Developer's Kit, which as of this
writing is 1.02, contains some known bugs. More specifically,
the following Java runtime interpreter bugs, which apply only
to the Windows 95/NT platform, have been documented and acknowledged
by the JavaSoft development team:
<UL>
<LI><FONT COLOR=#000000>Programs using multiple threads never
exit.</FONT>
<LI><FONT COLOR=#000000>Ordered comparisons with </FONT><TT><FONT FACE="Courier">NaN</FONT></TT>
don't return <TT><FONT FACE="Courier">false</FONT></TT>.
<LI><FONT COLOR=#000000>Conversion from </FONT><TT><FONT FACE="Courier">Double.MAX_VALUE</FONT></TT>
to an integer doesn't produce <TT><FONT FACE="Courier">Integer.MAX_VALUE</FONT></TT>.
<LI><FONT COLOR=#000000>Conversion from </FONT><TT><FONT FACE="Courier">Double.MAX_VALUE</FONT></TT>
to a long doesn't produce <TT><FONT FACE="Courier">Long.MAX_VALUE</FONT></TT>.
</UL>
<P>
The first bug is a pretty big problem and occurs whenever a program
starts or creates multiple threads; any program that starts multiple
threads will not exit. Fortunately, there is a workaround for
this bug: either call <TT><FONT FACE="Courier">System.exit</FONT></TT>
when the last running thread is finished, or monitor the threads
by calling <TT><FONT FACE="Courier">Thread.join</FONT></TT> and
force an exit yourself. Keep in mind that this problem, along
with all the interpreter bugs, is apparent only on the Windows
95/NT platform.
<P>
The <TT><FONT FACE="Courier">NaN</FONT></TT> constant defined
in the <TT><FONT FACE="Courier">Float</FONT></TT> and <TT><FONT FACE="Courier">Double</FONT></TT>
classes represents a result that isn't a number. Because <TT><FONT FACE="Courier">NaN</FONT></TT>
isn't a number, any numeric comparisons made with it should always
return <TT><FONT FACE="Courier">false</FONT></TT>. However, the
second bug causes the runtime interpreter to evaluate <TT><FONT FACE="Courier">NaN</FONT></TT>
as less than <TT><FONT FACE="Courier">NEGATIVE_INFINITY</FONT></TT>,
which allows for comparisons with it to return <TT><FONT FACE="Courier">true</FONT></TT>.
<P>
The last two bugs listed deal with converting doubles to integer
numbers. More specifically, <TT><FONT FACE="Courier">Double.MAX_VALUE</FONT></TT>
doesn't result in <TT><FONT FACE="Courier">Integer.MAX_VALUE</FONT></TT>
or <TT><FONT FACE="Courier">Long.MAX_VALUE</FONT></TT> when converted
to an integer or long, respectively.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you found out what the Java runtime interpreter
is used for, along with what kind of Java programs can be executed
with it. You learned about the <TT><FONT FACE="Courier">main</FONT></TT>
function, which is where execution begins in a Java program. You
then learned how to use the interpreter and how to specify different
options to custom-tailor the execution of Java programs to fit
your needs. The chapter finished up by taking a look at some of
the bugs present in the current release of the Java interpreter,
and how you can get around them.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch11.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>


<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
