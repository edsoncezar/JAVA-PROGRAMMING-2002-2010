<HTML>

<HEAD>
   <TITLE>Chapter 15 -- jdb :
The Java Debugger</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 15</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>jdb</FONT></TT><FONT SIZE=6 COLOR=#FF0000>:
The Java Debugger</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheJavaDebuggerAPI" >The Java Debugger API</A>
<UL>
<LI><A HREF="#SecurityPrecautions" >Security Precautions</A>
</UL>
<LI><A HREF="#Debuggingwithjdb" >Debugging with jdb</A>
<UL>
<LI><A HREF="#UsingtheInterpreterThroughtheComman" >Using the Interpreter through the Command Line</A>
<LI><A HREF="#AttachingtoaRunningInterpreter" >Attaching to a Running Interpreter</A>
<LI><A HREF="#DebuggingJavaApplets" >Debugging Java Applets</A>
</UL>
<LI><A HREF="#jdbOptions" >jdb Options</A>
<LI><A HREF="#OtherDebuggers" >Other Debuggers</A>
<UL>
<LI><A HREF="#VisualBreakpoints" >Visual Breakpoints</A>
<LI><A HREF="#StepIntoorOver" >Step Into or Over</A>
<LI><A HREF="#EvaluateandModifyatRuntime" >Evaluate and Modify at Runtime</A>
<LI><A HREF="#ViewCallStack" >View Call Stack</A>
<LI><A HREF="#AddingWatches" >Adding Watches</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Debugging is one of the necessary &quot;evils&quot; of software
development. Very few developers on earth can routinely write
large segments of error-free code on the first try. What often
separates good developers from great developers is their skill
at debugging complex code. To be considered truly masterful in
a programming environment or language, a programmer must first
master that environment's complete debugging capabilities. Modern
programming environments allow the developer to set breakpoints,
view function call stacks, and watch variables as program code
is stepped through. This chapter will address using the JDK's
debugger, jdb, so that you can take advantage of its debugging
capabilities. If you are not already familiar with jdb, be sure
to thoroughly cover the material in this chapter and work through
the examples.
<H2><A NAME="TheJavaDebuggerAPI"><FONT SIZE=5 COLOR=#FF0000>The
Java Debugger API</FONT></A></H2>
<P>
jdb is the name of the debugger supplied by Sun in the Java Developer's
Kit (JDK). It is a command-line tool (like the interpreter, compiler,
and applet viewer) that you can use to step through Java code
and study the code's behavior at runtime.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=543><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=543>
<BLOCKQUOTE>
At an early stage, avoid the temptation to ignore the jdb debugging tool! Although average developers are relying on <TT><FONT FACE="Courier">print</FONT></TT> statements to the screen to examine the contents of variables, jdb allows the above-average 
developer to step through code line by line and examine that code's operation. This is an invaluable resource that you should not bypass.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
jdb was designed to have some special capabilities not found in
many other language debuggers. These include:
<UL>
<LI><FONT COLOR=#000000>An object-oriented interface similar to
that of the Java language</FONT>
<LI><FONT COLOR=#000000>Java language runtime features such as
threads and monitors</FONT>
<LI><FONT COLOR=#000000>Support for remote debugging (see the
&quot;Security Precautions&quot; section later in this chapter)</FONT>
</UL>
<P>
The debugger was implemented using the Java Debugger API. This
API was provided by Sun in order to fulfill these requirements
for a full-featured Java language debugger. A key feature of the
Debugger API is the capability of remote debugging. This means
that a remote viewer can see into a Java Language Runtime if the
security precautions have been taken care of.
<P>
The Sun documentation stresses that jdb was implemented as a &quot;proof-of-concept&quot;
tool for the Java Debugger API. In other words, they viewed the
<I>real</I> product as the API itself. (Tool developers were strongly
encouraged to produce a more user-friendly tool.) More user-friendly
debuggers currently exist in the form of the Symantec Caf&eacute;
debugger and in the forthcoming Borland Latte IDE's debugger.
<H3><A NAME="SecurityPrecautions">Security Precautions</A></H3>
<P>
The ability for programmers to debug Java applications and applets
from remote locations is an exciting concept. Experienced developers
realize that just because an application may run fine on their
development platform, that does not mean it will run without flaws
on other users' machines. In the Windows environment, common distribution
problems include conflicting DLLs, VBXs, and OCXs, as well as
an extremely large assortment of software packages that may conflict
with changes being made to the system. The ability to remotely
debug applications on users' machines is extremely powerful; however,
it also introduces a variety of potential security problems.
<P>
One potential security &quot;hole&quot; could occur in the following
situation. User A could be running a Java application locally
on his machine. Using this application, he is entering confidential
data into several edit fields before posting the data to a database.
Meanwhile, across the Internet, a wily hacker sits with his Java
debugger patiently viewing the contents of these edit fields'
values.
<P>
The designers of the Java Debugger API (and in turn, jdb) foresaw
this security problem and included mechanisms in the API to prevent
security problems. Communication between the debugger and the
runtime interpreter occurs using a socket-based, proprietary protocol.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The communication protocol between the debugger and interpreter is neither public nor modifiable. Because it uses sockets for communication, however, developers will need a TCP/IP connection in order to use the debugger to debug Java code. Keep this in 
mind when developing on machines with no network connection.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
When the Java Language Runtime is started in <TT><FONT FACE="Courier">-debug</FONT></TT>
mode, the interpreter prints out a password to be used by the
debugger. At this time, the runtime also begins to monitor a dynamically
chosen port for communications from the debugger. On the debugger
side, a correct <I>hostname</I> and <I>password</I> must be specified
to connect to the interpreter. Programmers also should  be aware
that only one debugger instance can connect to an interpreter
at a time.
<H2><A NAME="Debuggingwithjdb"><FONT SIZE=5 COLOR=#FF0000>Debugging
with jdb</FONT></A></H2>
<P>
jdb is similar in operation and functionality to the UNIX dbx-style
debugger (another Sun tool, by the way). The debugger is used
to debug a currently running application. jdb<B> </B>can be used
in two different ways for debugging Java applications.
<H3><A NAME="UsingtheInterpreterThroughtheComman">Using the Interpreter
Through the Command Line</A></H3>
<P>
At its simplest, jdb essentially works through the Java interpreter
and loads the Java class indicated on the command line. This can
be done by using the following command (exactly like invoking
the Java interpreter):
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% jdb <I>classname </I>&lt;<I>arguments</I>&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
Listing 15.1 uses the jdb debugger to load a copy of the Java
interpreter. The class specified on the command line is then run
using the specified arguments.
<P>
This example creates a simple Java application that displays a
screen with the text on it. This text depends on what the user
gives as an argument. If no argument is given, then the text &quot;Give
argument!&quot; is printed on the screen. The Button is added
so that the application will be able to exit gracefully.
<HR>
<BLOCKQUOTE>
<B>Listing 15.1. Using jdb to debug a simple Java application.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
<BR>
/* The following class prints the text &quot;Hello World!&quot;
to the screen */<BR>
class HelloWorldApp<BR>
{<BR>
&nbsp;&nbsp;public static void main(String args[])<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ExitButton button;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lbl;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;button = new ExitButton(&quot;Exit!&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (args.length == 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lbl = &quot;Give argument!&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lbl = args[0];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Frame mainFrame = new Frame(&quot;HelloWorldApp&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Label HelloWorldlbl = new Label(lbl, Label.CENTER);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mainFrame.add(&quot;Center&quot;, HelloWorldlbl);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mainFrame.add(&quot;South&quot;, button);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mainFrame.resize(450, 450);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mainFrame.show();<BR>
&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class ExitButton extends Button<BR>
{<BR>
<BR>
&nbsp;&nbsp;public ExitButton(String buttonLbl)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLabel(buttonLbl);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public boolean action(Event evt, Object arg)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.exit(0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Figure 15.1 shows the screen output with the following input:
<P>
<A HREF="http://docs.rinet.ru/JavDev/f15-1.gif" ><B>Figure 15.1 : </B><I>Application displaying the command-line argument.</I></A>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">c:\&gt; java HelloWorldApp Howdy!</FONT></TT>
</BLOCKQUOTE>
<P>
Figure 15.2 shows the screen output with no arguments given.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f15-2.gif" ><B>Figure 15.2 : </B><I>Application display with no command-line argument.</I></A>
<P>
Now that this application is apparently running, this is as good
a time as any to try out the debugger for the first time.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To examine local (stack) variables, the class must have been compiled using the <TT><FONT FACE="Courier">-g</FONT></TT> option (<TT><FONT FACE="Courier">javac -g classname</FONT></TT>).
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Enter the following to begin:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% jdb HelloWorldApp Howdy!</FONT></TT>
</BLOCKQUOTE>
<P>
The following output (or something similar) should appear on the
debugger screen:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% Initializing jdb...<BR>
0x139fdf0:class(HelloWorldApp)</FONT></TT>
</BLOCKQUOTE>
<P>
If this does appear, the debugger and interpreter have been initialized
and are awaiting commands. The entire list of commands will be
studied later in this chapter. For now, test out jdb's breakpoint
capabilities by entering the following to set a breakpoint:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% stop in HelloWorldApp.main</FONT></TT>
</BLOCKQUOTE>
<P>
The debugger should have responded with this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Breakpoint set in HelloWorldApp.main</FONT></TT>
</BLOCKQUOTE>
<P>
The next step should be to actually run the application. The <TT><FONT FACE="Courier">run</FONT></TT><B>
</B>command is used to do this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% run</FONT></TT>
</BLOCKQUOTE>
<P>
Here is the debugger output:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">run HelloWorldApp Howdy!<BR>
Breakpoint hit: running ...<BR>
HelloWorldApp.main (HelloWorldApp:11)</FONT></TT>
</BLOCKQUOTE>
<P>
At this time, the breakpoint already has been hit. The actual
syntax used here means that the breakpoint was hit in the <TT><FONT FACE="Courier">HelloWorldApp.main</FONT></TT>
method (or, alternatively, in the<TT><FONT FACE="Courier"> HelloWorldApp</FONT></TT>
class, Line 11). Finally, to make sure that the command-line argument
was processed properly, do a quick check of the <TT><FONT FACE="Courier">args</FONT></TT>
variable.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% print args</FONT></TT>
</BLOCKQUOTE>
<P>
The value should be printed to the screen correctly if all went
according to plan.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">args = { Howdy! }</FONT></TT>
</BLOCKQUOTE>
<P>
The final step in this debugging process is to send the application
on its way using the <TT><FONT FACE="Courier">cont</FONT></TT>
command.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% cont</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="AttachingtoaRunningInterpreter">Attaching to a Running
Interpreter</A></H3>
<P>
The second method available for debugging with jdb is to attach
it to an interpreter that is currently running. To do this, that
interpreter must have been started using the <TT><FONT FACE="Courier">-debug</FONT></TT>
option. At startup time, this interpreter should have generated
a password to be used by jdb. To attach to a currently running
interpreter, use the following syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% jdb - host <I>&lt;hostname&gt; </I>-password
<I>&lt;password&gt;</I></FONT></TT>
</BLOCKQUOTE>
<P>
To debug an application using this method when the application
resides on your local machine, it is necessary to create two separate
debug windows. This example repeats the steps necessary to re-create
the example in the previous section. However, here we use a Java
interpreter that is already running for the debugging connection.
<P>
This example reuses the <TT><FONT FACE="Courier">HelloWorldApp</FONT></TT>
class created in Listing 15.1. However, this time the application
will be run using the Java interpreter and a separate jdb process.
<P>
The first step is to run the application using the Java interpreter
and the <TT><FONT FACE="Courier">-debug</FONT></TT> option.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% java -debug HelloWorldClass Howdy!</FONT></TT>
</BLOCKQUOTE>
<P>
The Java interpreter responded with the following password message:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Agent password=k56pn</FONT></TT>
</BLOCKQUOTE>
<P>
This password will be different each time the interpreter is run
in debug mode and it is randomly generated internal to the Java
interpreter. Before continuing, notice that the <TT><FONT FACE="Courier">HelloWorldApp
</FONT></TT>frame window is already showing. This is the drawback
to using this method. When the debugger is actually started, the
application is already running, so it is difficult to check startup
initialization information. However, to track events (such as
the button-click), this method still allows the powerful capability
of remote debugging!
<P>
At this time, in another window, run the jdb debugger using the
<TT><FONT FACE="Courier">-password</FONT></TT> argument (and the
<TT><FONT FACE="Courier">-host</FONT></TT><I> </I><TT><I><FONT FACE="Courier">&lt;hostname&gt;</FONT></I></TT>
argument if you are currently debugging a remote application):
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% jdb -password k56pn</FONT></TT>
</BLOCKQUOTE>
<P>
Now that the debugger has been started and has initialized its
link with the Java interpreter, you are free to examine all classes
currently loaded into memory. For instructional purposes, type
in the <TT><FONT FACE="Courier">classes</FONT></TT> command at
the jdb prompt.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">% classes<BR>
.<BR>
.<BR>
.<BR>
0x13994a8:class(java.awt.Rectangle)<BR>
0x13994c0:class(java.awt.Insets)<BR>
0x13994d8:class(java.awt.Font)<BR>
0x1399548:class(java.awt.Color)<BR>
0x13995c8:class(sun.awt.win32.MLabelPeer)<BR>
0x13995e8:class(sun.awt.win32.MButtonPeer)<BR>
0x1399608:interface(java.awt.peer.ContainerPeer)<BR>
0x1399618:interface(java.awt.peer.FramePeer)<BR>
0x1399628:interface(java.awt.peer.WindowPeer)<BR>
0x1399638:class(sun.awt.win32.Win32FontMetrics)<BR>
0x1399648:class(java.awt.FontMetrics)<BR>
0x1399680:class(java.awt.Dimension)<BR>
0x13996a0:class(sun.awt.ScreenUpdater)<BR>
0x13996d8:class(sun.awt.ScreenUpdaterEntry)<BR>
0x13996f0:class(sun.awt.win32.Win32Graphics)<BR>
0x1399700:class(java.awt.Graphics)<BR>
0x13998b0:class(java.io.DataInputStream)<BR>
0x13998d0:class(java.net.SocketInputStream)<BR>
0x13998f8:class(sun.tools.debug.ResponseStream)<BR>
0x1399910:class(java.net.SocketOutputStream)<BR>
0x1399938:class(java.io.DataOutputStream)<BR>
0x13999a8:class(sun.tools.debug.AgentOutputStream)<BR>
0x1399a70:class(java.util.HashtableEnumerator)<BR>
0x1399a98:class(java.util.VectorEnumerator)</FONT></TT>
</BLOCKQUOTE>
<P>
The preceding listing represents a small portion of the total
amount of class information generated. Notice the extremely large
number of classes that are listed. These are all of the classes
currently in use by either the Java runtime environment, debugger,
or the <TT><FONT FACE="Courier">HelloWorldApp</FONT></TT> application.
To explore the environment, type <TT><B><FONT FACE="Courier">help</FONT></B></TT>
and a list of all commands available will be shown. This same
list (with descriptions of each command) appears later in this
chapter.
<H3><A NAME="DebuggingJavaApplets">Debugging Java Applets</A>
</H3>
<P>
The information presented so far dealt with using jdb in combination
with the Java interpreter to debug Java applications. However,
Java applets run within a container application such as appletviewer.
As mentioned in <A HREF="ch11.htm" >Chapter 11</A>, &quot;Using
the Applet Viewer,&quot; the applet viewer tool can be run in
<TT><FONT FACE="Courier">-debug</FONT></TT> mode.
<P>
This example proceeds through the steps required to properly debug
a Java applet. The Java applet created takes in user-entered text
and retrieves the URL entered. If this applet is being run inside
a Web browser such as Netscape Navigator, the URL will be retrieved
and shown. Figure 15.3 shows this applet actually being run in
Netscape.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f15-3.gif" ><B>Figure 15.3 : </B><I>The GetURL applet running in Netscape Navigator.</I></A>
<P>
The source code used to build the GetURL applet is shown in Listing
15.2.
<HR>
<BLOCKQUOTE>
<B>Listing 15.2. GetURL source code (</B><TT><B><FONT FACE="Courier">Example3.html</FONT></B></TT><B>).
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.net.URL;<BR>
import java.net.MalformedURLException;<BR>
import java.applet.Applet;<BR>
<BR>
/* The following class will load a URL using the URL entered by
the user */<BR>
/* It also accepts a default URL as input and enters the text
<BR>
&Acirc; into the TextField */<BR>
<BR>
public class GetURL extends java.applet.Applet<BR>
{<BR>
&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempString;
<BR>
&nbsp;&nbsp;TextField&nbsp;&nbsp;&nbsp;&nbsp;URLText;<BR>
&nbsp;&nbsp;GetURLButton URLbutton;<BR>
<BR>
&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* First, retrieve the default URL from
the HTML file */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tempString = getParameter(&quot;DEFAULT_URL&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Now set up the applet's appearance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;, new Label(&quot;Enter
a URL to visit:&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URLText = new TextField();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URLText.setText(tempString);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;, URLText);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;URLbutton = new GetURLButton(this, &quot;Retrieve
URL&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;, URLbutton);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void GetURLDocument()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Use the MalformedURLException to catch
incorrect entries */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL tempURL = new URL(URLText.getText());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getAppletContext().showDocument(tempURL);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch(MalformedURLException e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URLText.setText(&quot;Bad
URL!!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}<BR>
<BR>
//This button will trigger the retrieval of the URL<BR>
class GetURLButton extends Button<BR>
{<BR>
&nbsp;&nbsp;private GetURL appHandle;<BR>
<BR>
&nbsp;&nbsp;public GetURLButton(GetURL app, String label)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;appHandle = app;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLabel(label);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public boolean action(Event evt, Object arg)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;appHandle.GetURLDocument();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Proceed through the following steps to use the applet viewer to
debug this applet:
<OL>
<LI>Compile the applet with the <TT><FONT FACE="Courier">-g</FONT></TT>
option so that the debugger can be used to examine local variables.
Once again, this is done by invoking the following command: <TT><FONT FACE="Courier">%javac
-g GetURL.java</FONT></TT>.
<LI>Run the file <TT><FONT FACE="Courier">Example3.html</FONT></TT>
in a Web browser to test out its capabilities. By default, simply
clicking the button will retrieve the JavaSoft home page.
<LI>Prepare to debug the applet in the applet viewer. Enter the
following command to start the applet viewer in debug mode: <TT><FONT FACE="Courier">%appletviewer
-debug Example3.html</FONT></TT>.
<LI>Once jdb is initialized, type <TT><B><FONT FACE="Courier">run</FONT></B></TT>
to start the applet viewer with <TT><FONT FACE="Courier">Example3.html</FONT></TT>.
<LI>Enter <TT><B><FONT FACE="Courier">classes</FONT></B></TT>
to see a list of all of the currently loaded classes. The class
<TT><FONT FACE="Courier">GetURL</FONT></TT> should appear somewhere
in that list.
<LI>Notice that the prompt changed from &quot;<TT><FONT FACE="Courier">&gt;</FONT></TT>&quot;
to &quot;<TT><FONT FACE="Courier">main[1]</FONT></TT>&quot;. This
means that the <I>main</I> thread (thread #1) is currently selected.
Enter the <TT><FONT FACE="Courier">threads</FONT></TT> command
and look for one that designates the <TT><FONT FACE="Courier">GetURL</FONT></TT>
class with the following text: <TT><FONT FACE="Courier">Group
group applet-GetURL.class</FONT></TT>. Select this thread by entering:
<TT><B><FONT FACE="Courier">thread</FONT></B></TT><B> # (</B>where
<I>#</I><TT><FONT FACE="Courier"> </FONT></TT>is the number of
the <TT><FONT FACE="Courier">GetURL</FONT></TT> thread). Now that
this has been selected, enter <TT><B><FONT FACE="Courier">print
GetURL</FONT></B></TT> to reassure yourself that the <TT><FONT FACE="Courier">GetURL</FONT></TT>
class was loaded and is accessible.
<LI>Now dump the contents of the <TT><FONT FACE="Courier">GetURL</FONT></TT>
class. Remember that each object in Java can be printed (or dumped).
Its contents should look something like this:<BR>
<TT><FONT FACE="Courier">GetURL = 0x13a5338:class(GetURL) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;superclass = 0x13a5370:class(java.applet.Applet)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;loader = (sun.applet.AppletClassLoader)0x13a51a0
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;static final LayoutManager panelLayout
= (java.awt.FlowLayout)0x13a4898  }</FONT></TT>
<LI>To view the actual contents of the thread that is running
this class, dump that thread using the &quot;<TT><FONT FACE="Courier">dump
t@#</FONT></TT>&quot; syntax (where <TT><FONT FACE="Courier">#</FONT></TT>
is the thread number). Your output might appear like the following:
<BR>
<TT><FONT FACE="Courier">t@4 = (java.lang.Thread)0x13a4a70 {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private char name[] = &quot;thread applet-GetURL.class&quot;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int priority = 6<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Thread threadQ = null<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int PrivateInfo = 7217156<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int eetop = 85851928<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean single_step = false<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean daemon = false<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean stillborn = false<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Runnable target = (sun.applet.AppletViewerPanel)0x13a48c8
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private boolean interruptRequested = false
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private ThreadGroup group = (sun.applet.AppletThreadGroup)0x13a4a88
<BR>
}</FONT></TT>
</OL>
<P>
As mentioned earlier, jdb is a command-line tool that accepts
a number of options. The following section details these options
and their meanings.
<H2><A NAME="jdbOptions"><FONT SIZE=5 COLOR=#FF0000>jdb Options</FONT></A>
</H2>
<P>
The jdb debugger enables the developer to perform a variety of
options while the Java class is being run. These options range
from printing the class's contents to stepping through the class
one line at a time. The following table explains each option briefly:
<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=282><I>Option Name</I></TD><TD WIDTH=309><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">threads [threadgroup]</FONT></TT>
</TD><TD WIDTH=309>List threads</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">thread &lt;thread id&gt;</FONT></TT>
</TD><TD WIDTH=309>Set default thread</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">suspend [thread id(s)]</FONT></TT>
</TD><TD WIDTH=309>Suspend threads (default: all)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">resume [thread id(s)]</FONT></TT>
</TD><TD WIDTH=309>Resume threads (default: all)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">where [thread id] | all</FONT></TT>
</TD><TD WIDTH=309>Dump a thread's stack</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">threadgroups</FONT></TT>
</TD><TD WIDTH=309>List threadgroups</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">threadgroup &lt;name&gt;</FONT></TT>
</TD><TD WIDTH=309>Set current threadgroup</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">print &lt;id&gt; [id(s)]</FONT></TT>
</TD><TD WIDTH=309>Print object or field</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">dump &lt;id&gt; [id(s)]</FONT></TT>
</TD><TD WIDTH=309>Print all object information</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">locals</FONT></TT>
</TD><TD WIDTH=309>Print all local variables in current stack frame
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">classes</FONT></TT>
</TD><TD WIDTH=309>List currently known classes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">methods &lt;class id&gt;</FONT></TT>
</TD><TD WIDTH=309>List a class's methods</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">stop in &lt;class id&gt;.&lt;method&gt;</FONT></TT>
</TD><TD WIDTH=309>Set a breakpoint in a method</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">stop at &lt;class id&gt;:&lt;line&gt;</FONT></TT>
</TD><TD WIDTH=309>Set a breakpoint at a line</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">up [n frames]</FONT></TT>
</TD><TD WIDTH=309>Move up a thread's stack</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">down [n frames]</FONT></TT>
</TD><TD WIDTH=309>Move down a thread's stack</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">clear &lt;class id&gt;:&lt;line&gt;</FONT></TT>
</TD><TD WIDTH=309>Clear a breakpoint</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">step</FONT></TT></TD>
<TD WIDTH=309>Execute current line</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">cont</FONT></TT></TD>
<TD WIDTH=309>Continue execution from breakpoint</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">catch &lt;class id&gt;</FONT></TT>
</TD><TD WIDTH=309>Break for the specified exception</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">ignore &lt;class id&gt;</FONT></TT>
</TD><TD WIDTH=309>Ignore the specified exception</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">list [line number|method]</FONT></TT>
</TD><TD WIDTH=309>Print source code</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">use [source file path]</FONT></TT>
</TD><TD WIDTH=309>Display or change the source path</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">memory</FONT></TT>
</TD><TD WIDTH=309>Report memory usage</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">gc</FONT></TT></TD>
<TD WIDTH=309>Free unused objects</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">load classname</FONT></TT>
</TD><TD WIDTH=309>Load Java class to be debugged</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">run &lt;class&gt; [args]</FONT></TT>
</TD><TD WIDTH=309>Start execution of a loaded Java class</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">!!</FONT></TT></TD>
<TD WIDTH=309>Repeat last command</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">help (or ?)</FONT></TT>
</TD><TD WIDTH=309>List commands</TD></TR>
<TR VALIGN=TOP><TD WIDTH=282><TT><FONT FACE="Courier">exit (or quit)</FONT></TT>
</TD><TD WIDTH=309>Exit debugger</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="OtherDebuggers"><FONT SIZE=5 COLOR=#FF0000>Other
Debuggers</FONT></A></H2>
<P>
jdb provides the Java programmer with a rudimentary tool that
you can use to examine threads, classes, and events. For some
developers, all of the capability they could ever want is provided
by the jdb tool. However, for many other programmers accustomed
to graphical debugging tools such as those found in many C++ environments,
Delphi, and Visual Basic, this tool is severely lacking. Because
of Java's surge in popularity, tools for Java are on the way that
will compare favorably with the best tools of any language. This
section will examine common features of modern debuggers with
the assumption that Java programmers will soon have these at their
disposal. These features also can be used to evaluate new tools
as they are released.
<H3><A NAME="VisualBreakpoints">Visual Breakpoints</A></H3>
<P>
Nearly all GUI development environments currently allow programmers
to set breakpoints using some graphical construct (a popular method
is to highlight the breakpoint line in red or some other color).
This allows the developer to actually see where breakpoints have
been set instead of having to store these locations in their own
memory. Another convenient feature is the ability to set breakpoints
and have the development environment remember where these breakpoints
are between sessions. As you have seen, jdb only allows the programmer
to set a breakpoint while the program is being debugged. The next
time the application is run, these breakpoints will need to be
reset. The Symantec Visual Caf&eacute; toolkit includes a debugger
that supports this option.
<H3><A NAME="StepIntoorOver">Step Into or Over</A></H3>
<P>
Once the breakpoint has been set, most debuggers will allow the
programmer to then execute code line by line. If the source code
is available for a function call, some debuggers will actually
allow the developer to step &quot;down&quot; into the function,
all the while monitoring program variables and conditions that
may be critical to fixing a problem.
<H3><A NAME="EvaluateandModifyatRuntime">Evaluate and Modify at
Runtime</A></H3>
<P>
Like jdb, nearly all debuggers allow the developer some mechanism
for examining program variables and states while the application
is executing. This can be done (like jdb) using <TT><FONT FACE="Courier">print</FONT></TT>
or <TT><FONT FACE="Courier">dump</FONT></TT> commands, or it may
be done using GUI tools.
<P>
One exciting feature of many newer environments such as Borland
Delphi (perhaps Latte?) and the new Asymetric Java/C++ development
tools is the ability to actually modify code and variables <I>at
runtime</I> without stopping the application to recompile. This
can save huge amounts of wasted development time, particularly
in situations where the programmer knows that something is going
to crash but would like to step past that point. By modifying
program values, you can avoid the known crash in order to explore
the unknown bug lurking around the corner.
<H3><A NAME="ViewCallStack">View Call Stack</A></H3>
<P>
Debuggers that allow the call stack to be viewed also provide
an extremely useful service, particularly in event-driven programming
environments. Many times, methods can be triggered by several
sources. At times such as this, it is extremely helpful to be
able to see <I>which</I> method called your method. Knowing this
can help you to track down otherwise untraceable method calls.
<H3><A NAME="AddingWatches">Adding Watches</A></H3>
<P>
The use of watches has become extremely popular since the advent
of GUI debuggers. When an application is being debugged, development
environments that support watches will allow the developer to
open a Watch window off to the side. Within this window, any number
of objects or properties can be added. As the program is stepped
through, the debugger continually updates these values so that
the developer can see at all times what is actually happening
among several objects or variables.
<P>
All of these tools are considered absolute &quot;must-haves&quot;
by most professional software developers today. Obviously, jdb
falls short in some of these areas. However, it is important to
remember that jdb is implemented using the Java Debugger API.
Many third-party Java debuggers will be implemented using this
same API, so any skills and terminologies learned by using jdb
will not be wasted. Instead, these newer tools will simply empower
developers to do more with less manual effort.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
jdb is an extremely useful tool, particularly for beginning Java
developers. Just as the UNIX dbx debugger remains popular today
(many developers use nothing else), there will probably always
be a command-line debugger like jdb supplied with the JDK. In
many environments where GUI systems are not available (but the
Java Virtual Machine is), jdb may be the only option available.
<P>
At the current time, no matter what the platform, jdb is probably
the most widely used Java debugger. However, as time goes by and
more advanced GUI tools are provided, its usage will wane somewhat.
However, for beginning software developers, it is imperative that
the concepts of debugging introduced here with jdb be understood.
Weaker developers may feel that debugging is a necessary evil
and can be avoided (by printing to the screen, and so on). The
best software developers, however, know that excellent code simply
cannot be developed without it.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch14.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch16.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

