<HTML>

<HEAD>
   <TITLE>Chapter 7 -- Developing Java Applets</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 7</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Developing Java Applets</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#WhatIsanApplet" >What Is an Applet?</A>
<LI><A HREF="#WhatIsRequiredtoRunanApplet" >What Is Required to Run an Applet?</A>
<LI><A HREF="#CapabilitiesandLimitationsofApplets" >Capabilities and Limitations of Applets</A>
<UL>
<LI><A HREF="#BytecodeVerification" >Bytecode Verification</A>
<LI><A HREF="#ClientSidePrecautions" >Client-Side Precautions</A>
<LI><A HREF="#AreJavaAppletsSafe" >Are Java Applets Safe?</A>
</UL>
<LI><A HREF="#BuildingaJavaApplet" >Building a Java Applet</A>
<LI><A HREF="#HTMLandJavaApplets" >HTML and Java Applets</A>
<UL>
<LI><A HREF="#PassingParameterstoJavaApplets" >Passing Parameters to Java Applets</A>
</UL>
<LI><A HREF="#SimpleGraphicsandGUITechniques" >Simple Graphics and GUI Techniques</A>
<UL>
<LI><A HREF="#LayingOutComponentsontheScreen" >Laying Out Components on the Screen</A>
<LI><A HREF="#HandlingEvents" >Handling Events</A>
</UL>
<LI><A HREF="#InterAppletCommunication" >Inter-Applet Communication</A>
<UL>
<LI><A HREF="#JavaBeans" >Java Beans</A>
<LI><A HREF="#PossibilitiesofInterAppletCommunicat" >Possibilities of Inter-Applet Communication</A>
<LI><A HREF="#SomeInterAppletCommunicationMethods" >Some Inter-Applet Communication Methods</A>
<LI><A HREF="#UsingaWebServer" >Using a Web Server</A>
<LI><A HREF="#UsingJavaScript" >Using JavaScript</A>
<LI><A HREF="#UsingStaticVariables" >Using Static Variables</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter focuses on the development of a type of Java program
known as an <I>applet</I>. <A HREF="ch8.htm" >Chapter 8</A>, &quot;Developing
Java Applications,&quot; discusses the development of Java <I>applications</I>.
Although there are some inherent differences between an applet
and an application, many beginning developers are unaware of these
differences. After explaining exactly what an applet is, this
chapter will present the Java applet in more detail. By the end
of the chapter, the Java developer should have a good knowledge
of the Java applet security model, the Java applet life cycle,
and basic applet capabilities such as multithreading and I/O.
<H2><A NAME="WhatIsanApplet"><FONT SIZE=5 COLOR=#FF0000>What Is
an Applet?</FONT></A></H2>
<P>
Java applets are actually compiled Java class files that are run
on a page within a Web browser. Because the Web browser supplies
the framework for retrieving and loading an applet and also supplies
the main window holding the applet, Java applets are somewhat
simpler than a true Java application. A Java application does
not require any additional software, such as a Web browser, other
than the typical Java runtime files included in the Java Developer's
Kit. Java applications are designed to be run in stand-alone mode
on a client machine and therefore can be thought of as a known
entity. Java applets, meanwhile, can be loaded from anywhere on
the Internet, and therefore are subject to severe security restrictions.
These security restrictions will be discussed in greater detail
later on in this chapter.
<P>
Almost every person's first exposure to Java was in the form of
a Java applet running within a Web page. Java applets currently
are being used for advertising purposes because they provide the
capability to include simple animation and sound in a Web advertisement.
Many client/server developers currently are looking at the company
intranet as an excellent platform on which to finally deliver
true cross-platform corporate applications. Because of this, Java
applets are certain to quickly progress from &quot;neat&quot;
status to true business use status.
<H2><A NAME="WhatIsRequiredtoRunanApplet"><FONT SIZE=5 COLOR=#FF0000>What
Is Required to Run an Applet?</FONT></A></H2>
<P>
Java applets are typically run within a Web browser. As of July
1996, most of the popular Web browsers on the market support embedded
Java applets in HTML pages. These browsers include:
<UL>
<LI><FONT COLOR=#000000>Sun HotJava 1.0</FONT>
<LI><FONT COLOR=#000000>Netscape Navigator 2.0 (or greater)</FONT>
<LI><FONT COLOR=#000000>Microsoft Internet Explorer 3.0</FONT>
<LI><FONT COLOR=#000000>Oracle PowerBrowser 1.5</FONT>
</UL>
<P>
Of course, the <I>Applet Viewer</I> tool included with the Java
Developer's Kit can be used to test and run Java applets as well.
However, it will not be included on all client machines; therefore,
it is not really an option to applet developers. Many beginning
Java developers wonder how an applet can run within a browser
if the Java runtime libraries are not installed on the client
system. To run a simple Java applet, as explained in <A HREF="ch2.htm" >Chapter 2</A>,
&quot;Installing Java,&quot; it was first necessary to download
the JDK from the JavaSoft Web site. After installing the JDK on
the system, the reader could then run any sample Java applet included
with the JDK. However, someone installing the Netscape Navigator,
for instance, has not downloaded the JDK, right? In fact, they
partially have. Take a look at the actual Navigator installation
to find out what was actually placed on your system.
<P>
After installing Navigator 3.0 in the <TT><FONT FACE="Courier">C:\Program
Files\Netscape\Navigator</FONT></TT> directory, examine the contents
of that directory under Windows 95. Under the <TT><FONT FACE="Courier">.\Program\java</FONT></TT>
directory, you will find a set of directories and files that look
suspiciously like the JDK installation. This is how Web browsers
are able to run Java applets. They basically install a customized
version of the JDK in their runtime directories so that they can
load Java applets and their own set of customized Java classes.
This results in somewhat of a Catch-22 situation. Because Netscape,
for instance, provides a customized version of the JDK, subtle
changes in the underlying code could result in an applet running
differently in the Navigator browser than, say, the Internet Explorer
browser. Be sure to test completed Java applets in a wide variety
of browsers on a variety of operating systems, if possible, in
order to ensure that the applet you will be displaying to the
world does what you think it should.
<H2><A NAME="CapabilitiesandLimitationsofApplets"><FONT SIZE=5 COLOR=#FF0000>Capabilities
and Limitations of Applets</FONT></A></H2>
<P>
Java applets obviously have many potential capabilities. Many
things can be done using these applets that, until now, were impossible
to implement on such a broad scale. Java applets can be used to
build full-featured graphical user interfaces, communicate over
the Internet to a host server, and even communicate with other
applets on a form. All of this can be done in an operating-environment-neutral
manner, which is what makes this such a great technology. For
Java to be truly successful, however, the client security has
to be completely assured. Because of this, security measures place
some limitations on Java applets. By default, applets cannot communicate
with any server other than the originating server. Applets also
cannot read or write files to the local file system. The following
section discusses the Java security model and focuses on how this
applies to Java applets.
<P>
The growth of technologies such as Web-based client/server application
development and electronic commerce has been severely limited
by the lack of &quot;industrial-strength&quot; security. Because
the underlying Internet was never designed to handle secure transactions
(the Department of Defense has a separate net for this purpose),
the entire infrastructure of the Internet was somewhat unprepared
for the phenomenal growth of the World Wide Web over the last
few years. The concept of applets (or related technologies such
as software agents) has been discussed in academic circles for
years, yet most theoreticians realized the security shortcomings
of the current programming languages such as C and C++.
<P>
Programming languages that allow manipulation of pointers (memory
addresses) allow programmers to overrun memory boundaries and
find &quot;trap doors&quot; into unsuspecting users' systems.
Operating systems such as UNIX have continually struggled to patch
well-documented security holes. Because the designers of Java
were well aware of these problems, security measures were designed
into Java at nearly every layer. The Java language's lack of support
for pointers also leads to simpler, easier-to-read code. (Many
programming errors by C programmers can be traced to improper
manipulation of pointers to memory.)
<P>
The basic security model for Java treats all Java applets and
applications as unknown, unsecured objects running within a secure
environment. What this means is that a clever developer can produce
subversive code to his heart's content, but the underlying Java
runtime environment is designed to trap any problems. When the
media publicizes a Java security &quot;bug,&quot; this generally
means that a team of researchers isolated a security flaw in the
underlying runtime environment that hackers could capitalize on.
An example of an early Java bug allowed a Web server to track
all Web sites a user visits after the Web server itself has been
visited. Although Java applets will never be used in the near
future to implement truly secret applications, the Java security
model makes security exceedingly difficult to circumvent.
<P>
The Java designers handled security at three levels:
<UL>
<LI><FONT COLOR=#000000>The </FONT><I>elimination of pointers</I>
from the language eliminates an entire class of security problems.
Programmers in C, for instance, can fake objects in memory because
it is loosely typed and allows pointers.
<LI><FONT COLOR=#000000>The </FONT><I>bytecode verification</I>
process forces uploaded Java applets to undergo a rigorous set
of checks in order to run on the local system. In other words,
this will foil &quot;bad&quot; users who decided to write a hostile
compiler. Keep in mind that no matter what features are built
into the language, a rogue compiler could still produce Java applets
capable of circumventing the Java security model. Bytecode verification
will be explained later in the chapter.
<LI><I>Client-side precautions</I> add another layer of security.
Most Web browsers (more on this later) preclude Java applets from
doing file access or communicating with any computer on the Internet
other than the computer that the applet was uploaded from. The
Java class loader assists in this process.
</UL>
<H3><A NAME="BytecodeVerification">Bytecode Verification</A></H3>
<P>
Language security features are simply not enough to prevent an
applet from reformatting your hard drive or some other unspeakable
act. (Keep in mind that file I/O is allowed and even provided
using the JDK class libraries.) Features needed to be built into
the entire runtime system to prevent specially compiled applets
from invading remote systems. Java is an interpreted language.
This means that actual memory management for the application is
put off until runtime (it is not built into the compiled Java
classes). This feature allows Java to run on many different platforms
thanks to the installed Java Virtual Machine. However, it also
allows the Java runtime engine to verify that the bytecodes being
loaded are, in fact, good bytecodes. This is done using a part
of the Virtual Machine known as the <I>verifier</I>. The verifier
has the unenviable task of checking each bytecode before it is
executed (interpreted) to make sure that it is not going to perform
an illegal operation. After the bytecode has been verified, the
applet is guaranteed to do the following:
<UL>
<LI><FONT COLOR=#000000>Obey access restrictions </FONT>such as
public, protected, private, and friendly. No class will be allowed
to access data that goes against these restrictions.
<LI><FONT COLOR=#000000>Never perform illegal data </FONT>conversions.
Because Java is a strongly typed language, automatic conversions
from arrays to pointers, for instance, are not allowed.
<LI><FONT COLOR=#000000>Conform to all return, parameter, and
argument types when calling methods.</FONT>
<LI><FONT COLOR=#000000>Live within its </FONT>allocated stack.
An applet that overruns its memory will not be loaded.
</UL>
<P>
The verification process checks many of the things that a good
Java compiler will check, but it is important to recognize that
the verification process takes place on the <I>client's</I> computer.
Security on the server side is virtually meaningless to Internet
clients because of the unknown nature of most servers.
<H3><A NAME="ClientSidePrecautions">Client-Side Precautions</A>
</H3>
<P>
The set of precautions enforced by the client Web browser (or
other applet loader) is done by a part of the Java runtime engine
known as the <I>class loader</I>. The class loader does what its
name says: it loads classes.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The class loader can vary from browser to browser. Security features in the HotJava web browser allow the user to control security restrictions and even remove them altogether. The Netscape Navigator browser, however, offers no user-controlled security 
measures. Instead, applets are forced into a very rigid set of rules. Therefore, it is probably wise if applets are written to conform to the most restrictive case because then they will run on every user's computer.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Three possible worlds are recognized by the class loader:
<UL>
<LI><FONT COLOR=#000000>The local system (highest level)</FONT>
<LI><FONT COLOR=#000000>The local network within a firewall (middle
level)</FONT>
<LI><FONT COLOR=#000000>The Internet at large (lowest level)</FONT>
</UL>
<P>
The class loader implements defined rules that allow it to intelligently
prevent an applet from wreaking havoc on your system. It does
this by never allowing a class loaded from a lower level to replace
a class existing on a higher level. The following example illustrates
what this means.
<P>
An applet located on a Web server across the Internet imports
the <TT><FONT FACE="Courier">java.awt.Button</FONT></TT> class
so that it can display a button on the screen. The developer on
the remote machine changed some of the button's internal functionality
but kept the class interface without changing anything. Fortunately
for you (and unfortunately for the developer across the Internet),
the <TT><FONT FACE="Courier">java.awt.Button</FONT></TT> class
is included with the Java Virtual Machine installed on your system.
Therefore, when the applet is uploaded to your machine, the class
loader will always retrieve your local <TT><FONT FACE="Courier">Button.class</FONT></TT>
file.
<P>
In addition to this, classes cannot call methods from other classes
in other security levels unless those methods are explicitly declared
to be public. This means that Java applets loaded from a remote
machine cannot call file system I/O methods. If those methods
were called, the class loader would catch the error, and the applet
load would fail.
<H4>Java Class Loading Rules <TT><FONT FACE="Courier">(Example1.html)</FONT></TT>
</H4>
<P>
Although much of the information presented on Java has stated
that applets cannot write to a local hard drive or connect to
remote computers other than the originating host, this is in fact
not necessarily correct. The HotJava Web browser allows users
to configure these security restrictions (see Figure 7.1).
<P>
<A HREF="http://docs.rinet.ru/JavDev/f7-1.gif" ><B>Figure 7.1 : </B><I>The Java applet security screen in HotJava 1.0.</I></A>
<P>
Figure 7.1 shows how the HotJava user can loosen or even drop
all security restrictions so that applets can do whatever they
want when uploaded to his or her machine. This may be useful in
an intranet setting where machines are never connected directly
to the Internet, but be very careful otherwise. Undoubtedly, devious
applets will be written to do damage to unsuspecting systems.
This is why the Netscape Navigator developers left configurable
security features completely out of their product.
<H3><A NAME="AreJavaAppletsSafe">Are Java Applets Safe?</A></H3>
<P>
Java handles security at several different levels. The language
is designed in a manner that removes many security holes because
it does not allow pointer manipulation. The bytecode verifier
is used to verify each uploaded Java class to ensure that it obeys
all Java language rules. The class loader enforces security on
another level by controlling applet operations at runtime. It
is important to realize that the bytecode verifier and class loader
both exist on the local system and are part of the Java Virtual
Machine. Because these two components are critical to the success
of the Java security model, the user must rely on these components
to ensure that Java applets are secure. At the current time, Sun,
Netscape, Microsoft, IBM, and others are all working on implementations
of the Java Virtual Machine for a host of operating platforms.
As the number of &quot;third-party&quot; virtual machines increases,
it is critical that these virtual machines be verified by some
independent source to ensure that they operate according to the
JVM specification. Sun is currently working on a test suite to
do just this. In short: Yes, the Java environment is safe and
secure. Vendor-specific implementations, however, must be validated
to ensure that they comply with the Java specifications.
<H2><A NAME="BuildingaJavaApplet"><FONT SIZE=5 COLOR=#FF0000>Building
a Java Applet</FONT></A></H2>
<P>
This section focuses on the construction of Java applets. The
previous section discussed in some detail the process required
to load an applet over the Internet to the local machine, and
this section will explain what is necessary for the applet to
actually run on that local machine.
<P>
Java applets are subclassed from the <TT><FONT FACE="Courier">Applet</FONT></TT>
class in the <TT><FONT FACE="Courier">java.applet</FONT></TT>
package.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
For more information on subclassing, <A HREF="ch3.htm" >see Chapter 3</A>, &quot;The Java Language.&quot; For more information on the <TT><FONT FACE="Courier">java.applet</FONT></TT> package, <A HREF="ch27.htm" >see Chapter 27</A>, &quot;Package <TT><FONT 
FACE="Courier">java.applet</FONT></TT>.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Each applet has four major events in its lifetime:
<UL>
<LI><FONT COLOR=#000000>Initialization</FONT>
<LI><FONT COLOR=#000000>Starting</FONT>
<LI><FONT COLOR=#000000>Stopping</FONT>
<LI><FONT COLOR=#000000>Destroying</FONT>
</UL>
<P>
These four events correspond directly to four methods within the
<TT><FONT FACE="Courier">Applet</FONT></TT> class: <TT><FONT FACE="Courier">init()</FONT></TT>,
<TT><FONT FACE="Courier">start()</FONT></TT>, <TT><FONT FACE="Courier">stop()</FONT></TT>,
and <TT><FONT FACE="Courier">destroy()</FONT></TT>. The following
discussion provides some information on each of these methods.
<H5>public void init()</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">init()</FONT></TT> method is called
when the applet is initially loaded. This method is used to do
one-time setup features such as add components to the layout manager,
set screen colors, and connect to a host database.
</BLOCKQUOTE>
<H5>public void start()</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">start()</FONT></TT> method is called
after the applet has been initialized, and also each time the
applet is restarted after being stopped. Applets can be stopped
when the user changes to another Web page. If the user returns
at a later time to the page with the applet on it, the applet
will be restarted by the browser. Therefore, the <TT><FONT FACE="Courier">start()</FONT></TT>
method can be called many times during an applet's life cycle.
Common operations that occur during an applet's <TT><FONT FACE="Courier">start()</FONT></TT>
method are the initialization of threads within the applet and
the updating of the screen display.
</BLOCKQUOTE>
<H5>public void stop()</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">stop()</FONT></TT> method is called
whenever the user leaves the current page. Note that by default
when the user leaves a page, the applet will continue to run.
This can result in an enormous consumption of system resources
if many applets have been loaded and these applets are performing
some resource-intensive task such as animation. (In fact, it is
quite common to see poorly written applets loaded from the Internet
that obviously did not implement this method. They never stop
running!) The <TT><FONT FACE="Courier">stop()</FONT></TT> method
is used to temporarily suspend the execution of the applet until
the <TT><FONT FACE="Courier">start()</FONT></TT> method is called
again.
</BLOCKQUOTE>
<H5>public void destroy()</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">destroy()</FONT></TT> method is called
whenever it is time to completely finish the applet's execution.
This method is generally called when the browser is exiting or
the applet is being reloaded from the host server. The <TT><FONT FACE="Courier">destroy()</FONT></TT>
method is used to free up allocated resources such as threads
or database connections.
</BLOCKQUOTE>
<P>
Listing 7.1 shows a simple applet that implements all four life
cycle methods: <TT><FONT FACE="Courier">init()</FONT></TT>, <TT><FONT FACE="Courier">start()</FONT></TT>,
<TT><FONT FACE="Courier">stop()</FONT></TT>, and <TT><FONT FACE="Courier">destroy()</FONT></TT>.
This applet updates the screen as well as the browser status bar
with some information indicating which method is being called.
<HR>
<BLOCKQUOTE>
<B>Listing 7.1. An applet illustrating the life cycle methods.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.Graphics;<BR>
import java.awt.Font;<BR>
import java.awt.Color;<BR>
<BR>
public class LifeCycleApplet extends java.applet.Applet<BR>
{<BR>
&nbsp;&nbsp;Font theFont = new Font(&quot;Helvetica&quot;, Font.BOLD,
20);<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;i;<BR>
&nbsp;&nbsp;String String1, String2;<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(theFont);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(String1 + String2, 5, 30);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String1 = &quot;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String2 = &quot;The applet is initializing!&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;The applet is initializing!&quot;);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void start()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String1 = String2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String2 = &quot;The applet is starting!&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;The applet is starting!&quot;);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void stop()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i = 2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String1 = String2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String2 = &quot;The applet is stopping!&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;The applet is stopping!&quot;);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void destroy()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i = 3;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String1 = String2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String2 = &quot;The applet is being destroyed!&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;showStatus(&quot;The applet is being destroyed!&quot;);
<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The previous example will always show the last two life cycle
events on the screen. Because of the speed at which Java executes,
you were probably unable to see the <TT><FONT FACE="Courier">init()</FONT></TT>
method's results all by themselves. We could have added a counter
loop just to stall the applet, so feel free to do so if you're
interested. Using threads, we also could have called a <TT><FONT FACE="Courier">wait()</FONT></TT>
method to stop program execution for a specified amount of time.
However, threads are a topic for a later time (<A HREF="ch20.htm" >see Chapter 20</A>,
&quot;Working with Threads&quot;). Figure 7.2 shows the LifeCycleApplet
loaded into a Web browser using the <TT><FONT FACE="Courier">Example2.html</FONT></TT>
file.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f7-2.gif" ><B>Figure 7.2 : </B>Example2.html<I> containing the LifeCycle applet.</I></A>
<H2><A NAME="HTMLandJavaApplets"><FONT SIZE=5 COLOR=#FF0000>HTML
and Java Applets</FONT></A></H2>
<P>
The last example took advantage of a file named <TT><FONT FACE="Courier">Example2.html</FONT></TT>
to display the applet within a Web browser. The actual Java code
used to display the applet was examined in the last section, but
you may be wondering where the additional text on the screen came
from. Currently, Java applets can only be displayed within a Web
browser by being embedded in a standard HTML page. This does not
mean that the actual bytecode or source code of the applet is
included within the HTML file. Instead, the HTML text contains
a reference to the Java applet known as a <I>tag</I>. Each element
within an HTML file to be displayed by a Web browser is referenced
using different types of these tags. Listing 7.2 shows the contents
of the HTML file used to load the LifeCycleApplet applet.
<HR>
<BLOCKQUOTE>
<B>Listing 7.2. The </B><TT><B><FONT FACE="Courier">Example2.html</FONT></B></TT><B>
file contents.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;HTML&gt;<BR>
&lt;HEAD&gt;<BR>
&lt;TITLE&gt;This is the LifeCycle applet!&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;H1&gt;Prepare to be amazed!&lt;/H1&gt;<BR>
&lt;BR&gt;<BR>
&lt;APPLET CODE=&quot;LifeCycleApplet.class&quot; WIDTH=600 HEIGHT=50&gt;
<BR>
If you can see this, your browser does not support Java applets.
<BR>
&lt;/APPLET&gt;<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This chapter is not intended to be an HTML tutorial. For much more information on HTML and Java, <A HREF="ch12.htm" >see Chapter 12</A>, &quot;HTML for Java Programmers.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
A quick examination of Listing 7.2 shows three primary elements:
<UL>
<LI><FONT COLOR=#000000>The</FONT> <TT><FONT FACE="Courier">&lt;TITLE&gt;</FONT></TT>
tag-Used to display the title caption for this page.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">&lt;H1&gt;</FONT></TT>
tag-Used to represent the main heading for the page.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">&lt;APPLET&gt;</FONT></TT>
tag-Used to represent a Java applet to be loaded.
</UL>
<P>
If you are new to HTML, the most important point to realize is
that nothing in this file specifies actual screen layout. The
<TT><FONT FACE="Courier">TITLE</FONT></TT> tag, for instance,
does not specify that the title appear at (x,y) coordinates (150,
200) and that it should be set apart from the heading by <FONT FACE="ASCII Font">&#168;</FONT>&quot;.
HTML only specifies the markup that tells browsers <I>what</I>
information to display. The page designer is somewhat at the mercy
of Web browser developers, although keep in mind that it is in
the best interest of browser developers to provide a standardized
&quot;look-and-feel&quot; to most Web pages. It is still common,
however, to load pages side by side in Netscape Navigator and
Microsoft Internet Explorer and notice slight layout differences.
Fortunately, for the Java developer, the actual screen layout
<I>within the applet</I> is completely controllable down to the
pixel level. Graphics and Java are discussed briefly later in
this chapter, and then in detail in <A HREF="ch17.htm" >Chapter 17</A>,
&quot;Programming the User Interface.&quot; The remainder of this
section presents the <TT><FONT FACE="Courier">&lt;APPLET&gt;</FONT></TT>
tag.
<H5>The <FONT FACE="Courier">&lt;APPLET&gt;</FONT><FONT SIZE=2>
Tag</FONT></H5>
<BLOCKQUOTE>
The syntax for using the <TT><FONT FACE="Courier">&lt;APPLET&gt;</FONT></TT>
tag is the following:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;APPLET attributes&gt;<BR>
<I>applet_parameters<BR>
alternate_content<BR>
</I>&lt;/APPLET&gt;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">APPLET</FONT></TT> attributes are
standard values that all applets accept and are a standard part
of HTML. The <TT><FONT FACE="Courier">applet_parameters</FONT></TT>
are applet-specific parameters that are read by the applet at
runtime. This is a handy way of passing arguments to an applet
to allow the applet to be more generic.
</BLOCKQUOTE>
<H5><FONT FACE="Courier">&lt;APPLET&gt;</FONT><FONT SIZE=2>
Tag Attributes</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ALT</FONT></TT>-Alternate text that can
be displayed by text-only browsers.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ALIGN</FONT></TT>-The <TT><FONT FACE="Courier">ALIGN</FONT></TT>
attribute designates the alignment of the applet within the browser
page.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">CODE</FONT></TT>-(Required) The <TT><FONT FACE="Courier">CODE</FONT></TT>
attribute is used to indicate the <TT><FONT FACE="Courier">.class</FONT></TT>
file that loads the applet.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">CODEBASE</FONT></TT>-The <TT><FONT FACE="Courier">CODEBASE</FONT></TT>
attribute is used to indicate the location of the <TT><FONT FACE="Courier">.class</FONT></TT>
file that loads the applet.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">HEIGHT</FONT></TT>-(Required) The <TT><FONT FACE="Courier">HEIGHT</FONT></TT>
attribute is used to set the applet's bounding rectangle height.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">HSPACE</FONT></TT>-The <TT><FONT FACE="Courier">HSPACE</FONT></TT>
attribute sets the amount of horizontal space to set off around
the applet.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NAME</FONT></TT>-The <TT><FONT FACE="Courier">NAME</FONT></TT>
attribute sets the symbolic name of the applet.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">VSPACE</FONT></TT>-The <TT><FONT FACE="Courier">VSPACE</FONT></TT>
attribute sets the amount of vertical space to set off around
the applet.
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">WIDTH</FONT></TT>-(Required) The <TT><FONT FACE="Courier">WIDTH</FONT></TT>
attribute is used to set the applet's box width.
</BLOCKQUOTE>
<H3><A NAME="PassingParameterstoJavaApplets">Passing Parameters
to Java Applets</A></H3>
<P>
Parameters are an easy way to configure Java applets without actually
changing the source file. In the previous applet example, the
text drawn on the screen was drawn using the blue color. This
was &quot;hardwired&quot; into the applet's code. However, just
as easily, we could have passed a parameter to the applet specifying
that it use the blue tag. Listing 7.3 shows the <TT><FONT FACE="Courier">Example2.html</FONT></TT>
file modified to do just this.
<HR>
<BLOCKQUOTE>
<B>Listing 7.3. Passing parameters to the applet using HTML parameters.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;HTML&gt;<BR>
&lt;HEAD&gt;<BR>
&lt;TITLE&gt;This is the LifeCycle applet!&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;H1&gt;Prepare to be amazed!&lt;/H1&gt;<BR>
&lt;BR&gt;<BR>
&lt;APPLET CODE=&quot;LifeCycleApplet.class&quot; WIDTH=600 HEIGHT=50&gt;
<BR>
&lt;PARAM NAME=color VALUE=&quot;blue&quot;&gt;<BR>
If you can see this, your browser does not support Java applets.
<BR>
&lt;/APPLET&gt;<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The only question left to be answered is this: how does the Java
applet determine the value of the parameters? (Excellent question!)
The answer is that the applet has to call the <TT><FONT FACE="Courier">getParameter()</FONT></TT>
method supplied by the <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>
parent class. Calling <TT><FONT FACE="Courier">getParameter(&quot;color&quot;)</FONT></TT>
using the previous Java applet example would return a <TT><FONT FACE="Courier">String</FONT></TT>
value containing the text &quot;<TT><FONT FACE="Courier">blue</FONT></TT>&quot;.
It is then left up to the applet to take advantage of this information
and actually paint the text blue on the screen.
<P>
Here are three methods commonly used by applets:
<UL>
<LI><TT><FONT FACE="Courier">String getParameter(String name)</FONT></TT>-Returns
the value for the specified parameter string
<LI><TT><FONT FACE="Courier">URL getCodeBase()</FONT></TT>-Returns
the URL of the applet
<LI><TT><FONT FACE="Courier">URL getDocumentBase()</FONT></TT>-Returns
the URL of the document containing the applet
</UL>
<P>
Listing 12.9 in <A HREF="ch12.htm" >Chapter 12 </A>shows a detailed
example (with Java code) of using parameters to pass values to
an applet using HTML parameters. For more detailed information
on parameters and the <TT><FONT FACE="Courier">&lt;APPLET&gt;</FONT></TT>
tag, <A HREF="ch12.htm" >see Chapter 12</A>.
<H2><A NAME="SimpleGraphicsandGUITechniques"><FONT SIZE=5 COLOR=#FF0000>Simple
Graphics and GUI Techniques</FONT></A></H2>
<P>
This section presents an introduction to the graphical user interface
capabilities provided in the Java Abstract Windowing Toolkit (AWT).
The AWT is actually a package named <TT><FONT FACE="Courier">java.awt</FONT></TT>
included with the JDK. (For a complete documentation of the <TT><FONT FACE="Courier">java.awt</FONT></TT>
package, <A HREF="ch28.htm" >see Chapter 28</A>.) Although there
are many user interface classes contained in package <TT><FONT FACE="Courier">java.awt</FONT></TT>,
Table 7.1 lists the most commonly used classes with a brief description
of each class.<BR>
<P>
<CENTER><B>Table 7.1. Commonly used user interface classes in
package </B><TT><B><FONT FACE="Courier">java.awt</FONT></B></TT><B>.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Class Name</I></TD><TD WIDTH=414><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Button</FONT></TT>
</TD><TD WIDTH=414>A standard pushbutton user interface component
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Canvas</FONT></TT>
</TD><TD WIDTH=414>A canvas that is used as a graphics drawing context
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Checkbox</FONT></TT>
</TD><TD WIDTH=414>A standard checkbox user interface component
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">CheckboxGroup</FONT></TT>
</TD><TD WIDTH=414>A user interface component used to group checkboxes
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">CheckboxMenuItem</FONT></TT>
</TD><TD WIDTH=414>A checkbox that is displayed as a menu item
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Choice</FONT></TT>
</TD><TD WIDTH=414>A menu component that displays the currently selected choice
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Color</FONT></TT></TD>
<TD WIDTH=414>A class used to encapsulate colors in Java</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Component</FONT></TT>
</TD><TD WIDTH=414>The base class of all user interface components
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Container</FONT></TT>
</TD><TD WIDTH=414>A base class for all container/grouping components
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Dialog</FONT></TT>
</TD><TD WIDTH=414>A standard dialog screen that can be either modal or nonmodal
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">FileDialog</FONT></TT>
</TD><TD WIDTH=414>A standard file selection dialog that is OS-dependent
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Font</FONT></TT></TD>
<TD WIDTH=414>A class used to encapsulate fonts in Java</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Frame</FONT></TT></TD>
<TD WIDTH=414>A frame that can contain window objects</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Graphics</FONT></TT>
</TD><TD WIDTH=414>The base class used for all graphics and drawing operations
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Image</FONT></TT></TD>
<TD WIDTH=414>A class used to encapsulate images in Java</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Label</FONT></TT></TD>
<TD WIDTH=414>A standard label user interface component</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">List</FONT></TT></TD>
<TD WIDTH=414>A standard list box user interface component</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Menu</FONT></TT></TD>
<TD WIDTH=414>A menu component that resides on a menubar</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">MenuBar</FONT></TT>
</TD><TD WIDTH=414>The menubar that contains menus and menu items
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">MenuItem</FONT></TT>
</TD><TD WIDTH=414>Menu selection items that trigger program events
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Panel</FONT></TT></TD>
<TD WIDTH=414>A user interface component used to surround other components
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Scrollbar</FONT></TT>
</TD><TD WIDTH=414>A standard scrollbar user interface component
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">TextArea</FONT></TT>
</TD><TD WIDTH=414>A multiline text editing window</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">TextField</FONT></TT>
</TD><TD WIDTH=414>A single-line text editing window</TD></TR>
<TR VALIGN=TOP><TD WIDTH=176><TT><FONT FACE="Courier">Window</FONT></TT>
</TD><TD WIDTH=414>A window inside a frame that contains multiple objects
</TD></TR>
</TABLE></CENTER>
<P>
<P>
By examining this table, you can see that three primary classes
of components exist within the AWT: drawing objects, containers,
and user interface components. If you have ever done any type
of GUI programming before, you are probably familiar with all
of the components listed here.
<H3><A NAME="LayingOutComponentsontheScreen">Laying Out Components
on the Screen</A></H3>
<P>
Before you dive into GUI programming with Java, there is one type
of class contained in the AWT (not listed in Table 7.1) that may
be new even to experienced programmers. This type of class is
known as a <I>layout manager</I>. Layout managers allow components
to be added onscreen without specifying exact coordinate locations
for the components. This type of class makes working with onscreen
components much easier. Because advanced &quot;drag-and-drop&quot;
Java Developer's environments are not currently available, Java
developers currently must either use layout managers or give specific
screen coordinates to locate components onscreen. This will remain
true in the future for developers coding on platforms that do
not support advanced development environments. Here are some examples
of layout managers:
<UL>
<LI><FONT COLOR=#000000>FlowLayout-The </FONT>default layout manager.
This class lays out components from left to right, wrapping onto
the next row when necessary.
<LI><FONT COLOR=#000000>GridLayout-Breaks</FONT> the screen up
into a rectangular grid and then places a component within each
grid element.
<LI><FONT COLOR=#000000>BorderLayout-Adds </FONT>components to
the screen using some specified geographic direction (north, south,
east, west, and center).
<LI><FONT COLOR=#000000>CardLayout-Adds </FONT>components onto
a stack of cards, where only one card is visible at a time. Specific
methods need to be called to switch cards and show a different
set of components.
</UL>
<P>
Although the FlowLayout is the default layout manager used in
the applet class, the following example (Listing 7.4) illustrates
the use of the BorderLayout class. All this simple applet does
at the current time is add a text box, a list, and a push button.
Don't worry about the actual functionality now. This will be added
when we discuss events in the next section.
<HR>
<BLOCKQUOTE>
<B>Listing 7.4. The contents of </B><TT><B><FONT FACE="Courier">EditList1.java</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.TextField;<BR>
import java.awt.List;<BR>
import java.awt.Button;<BR>
import java.awt.BorderLayout;<BR>
import java.applet.Applet;<BR>
<BR>
public class EditList1 extends java.applet.Applet<BR>
{<BR>
&nbsp;&nbsp;TextField theText;<BR>
&nbsp;&nbsp;List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theList;<BR>
&nbsp;&nbsp;Button&nbsp;&nbsp;&nbsp;&nbsp;theButton;<BR>
<BR>
<BR>
&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new BorderLayout()); // sets
the layout manager to be a<BR>
&Acirc; BorderLayout<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theText = new TextField();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theList = new List();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theButton&nbsp;&nbsp;= new Button(&quot;Add
text to list!&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;, theText);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;, theList);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;, theButton);<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The EditList1 applet uses the BorderLayout Manager to automatically
lay out a <TT><FONT FACE="Courier">TextField</FONT></TT>, <TT><FONT FACE="Courier">List</FONT></TT>,
and <TT><FONT FACE="Courier">Button</FONT></TT>. Figure 7.3 shows
the EditList1 applet running within a Web browser using the Example3.html
file.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f7-3.gif" ><B>Figure 7.3 : </B><I>The EditList applet running within Netscape Navigator.</I></A>
<P>
This is an exciting step, but this applet would be incomplete
without some sort of functionality. We can use Java events to
force some work to be done when the user clicks on a button, double-clicks
the list, or edits the text. The next section will briefly discuss
event handling. At the end of the section, the EditList1 applet
will be modified so that when a user clicks the button, whatever
text has been typed into the text field gets added to the list.
<H3><A NAME="HandlingEvents">Handling Events</A></H3>
<P>
Event handling is one of the primary features of graphical user
interface programming. It is so important that this type of interface
is also commonly called an <I>event-driven interface</I>. If you
stop to think about it, there are many events going on constantly
within a standard user interface. Key presses, button clicks,
and even voice activation can cause processing to occur on your
computer. (In addition to common user events, the operating system
itself commonly sends events to applications such as when a window
is dragged over another window, or when the system itself is preparing
to shut down.) To take advantage of this rich model, it is necessary
to be able to &quot;handle&quot; or respond to these events in
some way. Of course, Java provides this functionality, but it
is up to the programmer to implement it. In the previous example,
<TT><FONT FACE="Courier">EditList1.java</FONT></TT>, the user
can click on the button continuously, yet no text will ever be
added to the list. This is because the default button-click event
for the <TT><FONT FACE="Courier">Button</FONT></TT> class does
nothing except change the look of the button while the user is
actually clicking it. It is up to the user to provide some type
of functionality.
<P>
To trap an event sent from any user interface component, the programmer
must define an <TT><FONT FACE="Courier">action()</FONT></TT> method.
By examining the documentation in <A HREF="ch28.htm" >Chapter 28 </A>for
the <TT><FONT FACE="Courier">java.awt.Component</FONT></TT> class,
you can see that this method is part of the Component class, which
is the base class for all onscreen elements.<BR>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There are two ways to trap events:</BLOCKQUOTE>
<UL>
<LI>Override the applet's <TT><FONT FACE="Courier">action()</FONT></TT> method and trap the events for all components within the applet. If this is done, the <TT><FONT FACE="Courier">action()</FONT></TT> method's <TT><FONT FACE="Courier">Event</FONT></TT> 
object will need to be examined so that the object that sent the event can be determined.
<LI>Create a new class for each component on the screen that needs to have its events handled. Then override the individual component's action methods.
</UL>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 7.5 (<TT><FONT FACE="Courier">EditList2.java</FONT></TT>)
uses the <TT><FONT FACE="Courier">Applet</FONT></TT> class's <TT><FONT FACE="Courier">action()</FONT></TT>
method to trap the button-click event. When this event has been
trapped, the contents of the edit control are added to the list
box.
<HR>
<BLOCKQUOTE>
<B>Listing 7.5. The contents of </B><TT><B><FONT FACE="Courier">EditList2.java</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.TextField;<BR>
import java.awt.List;<BR>
import java.awt.Button;<BR>
import java.awt.BorderLayout;<BR>
import java.applet.Applet;<BR>
import java.awt.Event;<BR>
<BR>
public class EditList2 extends java.applet.Applet<BR>
{<BR>
&nbsp;&nbsp;TextField theText;<BR>
&nbsp;&nbsp;List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theList;<BR>
&nbsp;&nbsp;Button&nbsp;&nbsp;&nbsp;&nbsp;theButton;<BR>
<BR>
<BR>
&nbsp;&nbsp;public void init()<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new BorderLayout()); // sets
the layout manager to be a<BR>
&Acirc; BorderLayout<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theText = new TextField();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theList = new List();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;theButton&nbsp;&nbsp;= new Button(&quot;Add
text to list!&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;, theText);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;, theList);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;, theButton);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public boolean action(Event evt, Object arg)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (evt.target instanceof Button)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theList.addItem(theText.getText());
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Running the <TT><FONT FACE="Courier">Example4.html</FONT></TT>
file within a Web browser will show that the event handling implemented
above actually works. Figure 7.4 shows <TT><FONT FACE="Courier">Example4.html</FONT></TT>
running within the Netscape Navigator browser.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f7-4.gif" ><B>Figure 7.4 : </B><I>The EditList2 applet running within Netscape Navigator.</I></A>
<H2><A NAME="InterAppletCommunication"><FONT SIZE=5 COLOR=#FF0000>Inter-Applet
Communication</FONT></A></H2>
<P>
In the previous example, the button component was used to add
items to the list component. All of these operations occurred
inside a single applet. However, imagine a case where a button-click
in one applet could update a database and trigger update messages
to another applet running within the same Web page or even running
on a remote computer. This type of communication is known as <I>inter-applet
communication</I>. Since the early days of Java, this feature
has been requested by developers wanting to push the envelope
of Java's capabilities. This section briefly discusses several
methods for communicating between applets, but you should note
that these methods are browser-dependent and are subject to change.
<H3><A NAME="JavaBeans">Java Beans</A></H3>
<P>
Recently, a technology known as Java Beans has been introduced
by JavaSoft. Java Beans is a component object model that will
allow Java applets to be integrated with other applets and applications
using multiple component architectures, including COM, OpenDoc,
LiveConnect, and CORBA. This component model is supposed to compete
heavily with Microsoft's Component Object Model (COM, which is
the basis of ActiveX) and should be released in late 1996. Until
then, however, developers who want to provide inter-applet communication
must resort to other methods.
<H3><A NAME="PossibilitiesofInterAppletCommunicat">Possibilities
of Inter-Applet Communication</A></H3>
<P>
There are several interesting possibilities that will be available
when applets are truly enabled to communicate among themselves.
Here are possible types of communication:
<UL>
<LI><FONT COLOR=#000000>Applets that share the same </FONT>Web
page within the same browser
<LI><FONT COLOR=#000000>Applets loaded in completely different
browser windows</FONT>
<LI><FONT COLOR=#000000>Applets loaded on different client's browsers</FONT>
<LI><FONT COLOR=#000000>Applets loaded from different servers</FONT>
</UL>
<P>
Using a technology such as Java Beans or ActiveX will also allow
developers to &quot;wrap&quot; their applets with code that will
expose an applet's methods and properties in some standardized
way. Using the component model, the applet could potentially be
dropped onto a Visual Basic form or used to communicate with applications
written in other programming languages.
<H3><A NAME="SomeInterAppletCommunicationMethods">Some Inter-Applet
Communication Methods</A></H3>
<P>
Once again, keep in mind that currently, the only way to implement
this type of communication is to take advantage of specific browser
features. The following examples focus on capabilities using the
Netscape Navigator browser.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Throughout this book, there has been and will be little mention of operating system-specific problems. This is because Java is truly a cross-platform development tool. However, it is interesting to note that there are many <I>browser</I>-specific 
tendencies. Perhaps those who say the Web browser is an operating system are somewhat correct. This is certainly true in the case of Java programming.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Using the AppletContext</H4>
<P>
Calling the <TT><FONT FACE="Courier">getApplets()</FONT></TT>
or <TT><FONT FACE="Courier">getApplet()</FONT></TT> method is
the easiest way to reach applets running within the same Web page.
Although this feature appears to be relatively foolproof, there
are some gotchas to watch out for. By examining the documentation
on the <TT><FONT FACE="Courier">getApplets()</FONT></TT> method
in <A HREF="ch27.htm" >Chapter 27</A>, you can see that this method
returns an <TT><FONT FACE="Courier">Enumeration</FONT></TT> containing
all applets located within the current AppletContext. This works
fine on browsers that treat a single Web page as an AppletContext;
however, some browsers (including an earlier version of Sun's
HotJava) break each applet up into a separate AppletContext. Be
careful to really check out the browser your users will be using
(in the intranet case) to make sure you really understand how
this method actually works.
<H3><A NAME="UsingaWebServer">Using a Web Server</A></H3>
<P>
A somewhat more difficult, and less reliable, method of inter-applet
communication is the use of socket-based communication between
applets using the originating Web server. At the current time,
any desired type of messaging service can be set up on the server,
although it has been mentioned that Sun may discontinue this feature
and limit communications to the server's HTTP port only.
<H3><A NAME="UsingJavaScript">Using JavaScript</A></H3>
<P>
The Netscape Navigator 3.0 browser implements a technology known
as LiveConnect to allow an applet to expose its methods and data
to the outside world. Using the scripting language known as JavaScript,
the Web page developer can access and change an applet's internal
data.
<P>
Netscape Navigator 3.0 will also allow the use of <I>cookies</I>.
Cookies are basically text files that can contain messages. At
the current time, only JavaScript can actually access cookies,
but this feature could be useful to script together applets that
were loaded at different times.
<P>
These features are truly browser-dependent. HTML files containing
these features can only be displayed correctly using the Netscape
Navigator 3.0 browser.
<H3><A NAME="UsingStaticVariables">Using Static Variables</A>
</H3>
<P>
If both applets doing the communication share the same class,
a common inter-applet communication mechanism is the use of static
variables. Static variables can be thought of as global variables
that apply to all instances of the class within an applet. However,
the Netscape implementation of this feature allows static variables
to be shared within an AppletContext's boundaries. This, then,
is yet another method for &quot;passing&quot; data between applets
within the same AppletContext.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
The widespread use of Java applets is one of the most exciting
software development technologies in recent memory. Applets offer
the promise of truly platform-independent software that will allow
developers to add interesting interactive content to their Web
pages. Although the Java language itself is platform-independent,
developers should be warned that vendor-specific additions such
as Microsoft's ActiveX extensions could render Java applets unusable
on non-Windows platforms. Before pursuing technologies such as
this or inter-applet communication, be sure that the needs of
users are clearly understood so that your applet development project
will not be hindered in the future.
<P>
The next chapter discusses Java application development. At the
current time, much of the development world has focused solely
on Java applets, but Java applications are sure to see widespread
growth in the near future as development tools become more powerful.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch6.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch8.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>