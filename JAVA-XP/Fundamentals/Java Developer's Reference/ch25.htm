<HTML>

<HEAD>
   <TITLE>Chapter 25 -- Working with Databases</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 25</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Working with Databases</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#ABriefTutorialonSQLandRelationalD" >A Brief Tutorial on SQL and Relational Databases</A>
<UL>
<LI><A HREF="#WhatIsaDatabaseServer" >What Is a Database Server?</A>
<LI><A HREF="#TheRelationalDatabase" >The Relational Database</A>
<LI><A HREF="#StructuredQueryLanguageSQL" >Structured Query Language (SQL)</A>
</UL>
<LI><A HREF="#UsingJavawithDatabases" >Using Java with Databases</A>
<UL>
<LI><A HREF="#JavaandCGICalls" >Java and CGI Calls</A>
<LI><A HREF="#TheJDBCAPI" >The JDBC API</A>
<LI><A HREF="#ServerSideDatabaseAccess" >Server-Side Database Access</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
It can be argued that, due to the widespread use of computing
technology throughout corporate America, no new tool or language
can be considered &quot;industrial strength&quot; until support
for relational databases is provided. In fact, during the first
year of Java's growth, very few large-scale applications have
been attempted using the language because of this shortcoming.
Fortunately, Sun Microsystems and database tool makers such as
Oracle, Sybase, and Microsoft  realize the power of the Java environment,
and they are currently rushing to fill the Java/database void.
<P>
This chapter will introduce the use of relational databases with
Java to the reader. Following a preliminary section covering the
basics of SQL (Structured Query Language) and relational databases,
the remainder of the chapter will focus on three possible ways
of building database-aware Java applications. Here are these three
methods:
<UL>
<LI><FONT COLOR=#000000>Standard CGI scripts used to query databases
and return information to the browser</FONT>
<LI><FONT COLOR=#000000>The JDBC (Java Database Connectivity)
Applications Programming Interface that will be used to provide
a Java interface to SQL-based relational databases</FONT>
<LI><FONT COLOR=#000000>Database-aware server code that allows
all database code to reside and execute on a Web server for communication
with a separate database server</FONT>
</UL>
<H2><A NAME="ABriefTutorialonSQLandRelationalD"><FONT SIZE=5 COLOR=#FF0000>A
Brief Tutorial on SQL and Relational Databases</FONT></A></H2>
<P>
Before discussing how Java can be used to actually connect to
relational databases, retrieve information, and return it to a
Web browser, this section will briefly introduce the reader to
the Structured Query Language and the world of relational databases.
<H3><A NAME="WhatIsaDatabaseServer">What Is a Database Server?</A>
</H3>
<P>
Programmers who have never worked with relational databases may
be somewhat confused by the term &quot;database server.&quot;
Fear not, however, because as a Web developer, you already have
a great deal of experience with the client/server model of application
development. A database server is simply a powerful piece of software
running on a machine that is located on a network. This software
monitors a port (just as a Web server typically monitors port
80 on a machine) and handles all incoming requests for the underlying
database data. In the case of relational databases, this incoming
request is presented to the server using SQL (Structured Query
Language). The database server processes the SQL statement(s)
and takes some action based on the contents of the SQL statement(s).
This action could be a data retrieval operation, a data insertion
or deletion, or even a security modification request sent by the
database administrator (DBA).
<P>
Please take note here of what is meant by the word <I>database</I>.
Many programmers accustomed to writing single-user file-based
applications call these files <I>databases</I>, and this is fine.
However, this chapter will focus on <I>relational databases,</I>
which separate all data into related tables of information and
are managed by a software product known as an RDBMS (relational
database management system). Here are some of the most popular
RDBMSs:
<UL>
<LI><FONT COLOR=#000000>Oracle</FONT>
<LI><FONT COLOR=#000000>Sybase SQL Server</FONT>
<LI><FONT COLOR=#000000>Microsoft SQL Server</FONT>
<LI><FONT COLOR=#000000>Informix</FONT>
<LI><FONT COLOR=#000000>IBM DB2</FONT>
</UL>
<P>
All of these database servers can run on a wide variety of platforms
and can handle a great number of users simultaneously. Several
features set these rather expensive systems apart from simple
file-based databases such as Microsoft Access or dBASE. Among
the valuable features are the following:
<UL>
<LI><FONT COLOR=#000000>Security. The </FONT>database administrator
(DBA) is allowed to completely control access to all tables, stored
procedures, and triggers based on the user ID passed to the database
when logging in.
<LI><FONT COLOR=#000000>Data locking. With a </FONT>large number
of users running an application simultaneously, it is inevitable
that at some point two users will try to modify the same data
at the same time. Modern RDBMSs handle this using a wide variety
of locking schemes that allow only one person at a time to modify
a record within the database.
<LI><FONT COLOR=#000000>Support for network protocols. Popular
</FONT>RDBMSs, such as Oracle7, support a wide variety of networking
protocols for communications to and from the database server and
client.
<LI><FONT COLOR=#000000>Scalability. Many RDBMSs run on a wide
variety of platforms and can be scaled to fit the user's needs.</FONT>
<LI><FONT COLOR=#000000>Replication. With the </FONT>purchase
of add-on products, many RDBMSs support real-time data replication
among various sites. This allows corporate databases to copy data
to remote sites as the data is updated.
</UL>
<P>
As you can see, a huge amount of effort already has gone into
the creation of extremely powerful database management systems.
Many computing professionals make their living by administering
large databases. Most professional developers within business
environments today  probably have worked on at least one relational
database-aware application. No matter what language their application
was written in (C, C++, Object Pascal, Visual Basic, and so on),
at some point SQL commands had to be written and passed to the
database in order to retrieve data. Because of its ubiquity, SQL
will be the topic of the next section.
<H3><A NAME="TheRelationalDatabase">The Relational Database</A>
</H3>
<P>
Relational databases store all of their information in groups
known as <I>tables</I>. Each database can contain one or more
of these tables. (Keep in mind that an RDBMS can manage many individual
underlying databases, with each one of these databases containing
many tables.) These tables are <I>related</I> to each other using
some type of common element. A table can be thought of as containing
a number of rows and columns. Each individual element stored in
the table is known as a <I>column</I>. Each set of data within
the table is known as a <I>row</I>. The following example illustrates
a simple database containing address information.
<P>
Using the Sybase SQL Server RDBMS, assume that we have created
a database named <TT><I><FONT FACE="Courier"> </FONT></I><FONT FACE="Courier">ADDRESSES</FONT></TT>.
Because this is a simple example, this database will contain only
one table: <TT><FONT FACE="Courier">ADDRESS</FONT></TT>. Here
are the individual columns (and their datatypes) contained in
the <TT><FONT FACE="Courier">ADDRESS</FONT></TT> table:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">STRUCTURE OF TABLE ADDRESS<BR>
LAST_NAME String(30)<BR>
FIRST_NAME String(30)<BR>
STREET STRING(50)<BR>
CITY STRING(50)<BR>
STATE STRING(2)<BR>
ZIP INTEGER</FONT></TT>
</BLOCKQUOTE>
<P>
Therefore, it can be said that the <TT><FONT FACE="Courier">ADDRESS</FONT></TT>
table has six columns: <TT><FONT FACE="Courier">LAST_NAME</FONT></TT>,
<TT><FONT FACE="Courier">FIRST_NAME</FONT></TT>, <TT><FONT FACE="Courier">STREET</FONT></TT>,
<TT><FONT FACE="Courier">CITY</FONT></TT>, <TT><FONT FACE="Courier">STATE</FONT></TT>,
and <TT><FONT FACE="Courier">ZIP</FONT></TT>. Note that these
columns specify only the format of the table, not the actual information
stored in the table. Some individual rows, or records as they
are often called, could be the following:<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=109><CENTER><TT><FONT FACE="Courier">LAST_NAME</FONT></TT></CENTER>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">FIRST_NAME</FONT></TT></CENTER>
</TD><TD WIDTH=162><CENTER><TT><FONT FACE="Courier">STREET</FONT></TT></CENTER>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">CITY</FONT></TT></CENTER>
</TD><TD WIDTH=69><CENTER><TT><FONT FACE="Courier">STATE</FONT></TT></CENTER>
</TD><TD WIDTH=81><CENTER><TT><FONT FACE="Courier">ZIP</FONT></TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">BERRY</FONT></TT></TD>
<TD WIDTH=120><CENTER><TT><FONT FACE="Courier">KATIE</FONT></TT></CENTER>
</TD><TD WIDTH=162><TT><FONT FACE="Courier">123 Forest St.</FONT></TT>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">Huntsville</FONT></TT></CENTER>
</TD><TD WIDTH=69><CENTER><TT><FONT FACE="Courier">AL</FONT></TT></CENTER>
</TD><TD WIDTH=81><CENTER><TT><FONT FACE="Courier">36507</FONT></TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">LITTLE</FONT></TT>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">PARKER</FONT></TT></CENTER>
</TD><TD WIDTH=162><TT><FONT FACE="Courier">456 Wetwood Dr.</FONT></TT>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">Pensacola</FONT></TT></CENTER>
</TD><TD WIDTH=69><CENTER><TT><FONT FACE="Courier">FL</FONT></TT></CENTER>
</TD><TD WIDTH=81><CENTER><TT><FONT FACE="Courier">32537</FONT></TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">HOFFMAN</FONT></TT>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">LINDA</FONT></TT></CENTER>
</TD><TD WIDTH=162><TT><FONT FACE="Courier">709 Avenida</FONT></TT>
</TD><TD WIDTH=120><CENTER><TT><FONT FACE="Courier">San Diego</FONT></TT></CENTER>
</TD><TD WIDTH=69><CENTER><TT><FONT FACE="Courier">CA</FONT></TT></CENTER>
</TD><TD WIDTH=81><CENTER><TT><FONT FACE="Courier">93426</FONT></TT></CENTER>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
This database works very well if this is all the designer intended
it to do. However, a primary goal of the relational database architecture
is to reduce redundant information. Looking at the previous example,
you can quickly see how information could be repeated if one person
has several addresses. Let's assume in the previous example that
Linda Hoffman moves every few months to an entirely new part of
the country. Because we want to keep track of her migrant lifestyle,
we will design this table to store her address each time she moves
without deleting the old one. As she continues to move, our table
looks like the following:<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=109><CENTER><TT><FONT FACE="Courier">LAST_NAME</FONT></TT></CENTER>
</TD><TD WIDTH=122><CENTER><FONT FACE="Courier">FIRST_NAME</FONT></CENTER>
</TD><TD WIDTH=160><CENTER><FONT FACE="Courier">STREET</FONT></CENTER>
</TD><TD WIDTH=114><CENTER><FONT FACE="Courier">CITY</FONT></CENTER>
</TD><TD WIDTH=72><CENTER><FONT FACE="Courier">STATE</FONT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">ZIP</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">BERRY</FONT></TT></TD>
<TD WIDTH=122><CENTER><TT><FONT FACE="Courier">KATIE</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">123 Forest St.</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">Huntsville</FONT></TD>
<TD WIDTH=72><CENTER><TT><FONT FACE="Courier">AL</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">36507</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">LITTLE</FONT></TT>
</TD><TD WIDTH=122><CENTER><TT><FONT FACE="Courier">PARKER</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">456 Wetwood Dr.</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">Pensacola</FONT></TD>
<TD WIDTH=72><CENTER><TT><FONT FACE="Courier">FL</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">32537</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">HOFFMAN</FONT></TT>
</TD><TD WIDTH=122><CENTER><TT><FONT FACE="Courier">LINDA</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">709 Avenida</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">San Diego</FONT></TD>
<TD WIDTH=72><CENTER><TT><FONT FACE="Courier">CA</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">93426</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">HOFFMAN</FONT></TT>
</TD><TD WIDTH=122><CENTER><TT><FONT FACE="Courier">LINDA</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">347 Rivers St.</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">Frankfort</FONT></TD>
<TD WIDTH=72><CENTER><TT><FONT FACE="Courier">KY</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">49682</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">HOFFMAN</FONT></TT>
</TD><TD WIDTH=122><CENTER><TT><FONT FACE="Courier">LINDA</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">902 Woods Ave.</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">Alexandria</FONT></TD>
<TD WIDTH=72><CENTER><TT><FONT FACE="Courier">VA</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">23734</FONT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">HOFFMAN</FONT></TT>
</TD><TD WIDTH=122><CENTER><TT><FONT FACE="Courier">LINDA</FONT></TT></CENTER>
</TD><TD WIDTH=160><TT><FONT FACE="Courier">920 Tiger Ln.</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">Clemson</FONT></TD><TD WIDTH=72><CENTER><TT><FONT FACE="Courier">SC</FONT></TT></CENTER>
</TD><TD WIDTH=78><CENTER><FONT FACE="Courier">29632</FONT></CENTER>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Although the data is stored correctly, Linda Hoffman's name is
stored repeatedly, resulting in the duplication of data stored
in the table. Designers of relational databases often design using
a process known as <I>normalization</I>. Although it is beyond
the scope of this book, the normalization process essentially
attempts to break data down into its smallest segments so that
no data is duplicated throughout the database. Using the previous
example, to reduce data duplication, the <TT><FONT FACE="Courier">ADDRESS</FONT></TT>
table would be broken up into two separate tables: <TT><FONT FACE="Courier">NAME</FONT></TT>
and <TT><FONT FACE="Courier">ADDRESS</FONT></TT>.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">STRUCTURE OF TABLE NAME<BR>
LAST_NAME String(30)<BR>
FIRST_NAME String(30)<BR>
ID INTEGER<BR>
STRUCTURE OF TABLE ADDRESS<BR>
ID INTEGER<BR>
STREET STRING(50)<BR>
CITY STRING(50)<BR>
STATE STRING(2)<BR>
ZIP INTEGER</FONT></TT>
</BLOCKQUOTE>
<P>
Using this structure, or database <I>schema</I> as it is often
called, the individuals' names will only be entered into the database
one time. The ID field will be used to link, or relate, the two
tables together. This linkage between tables is known as <I>referential
integrity</I>. It is the responsibility of the database developer
to strive to maintain the database's referential integrity so
that data does not become corrupt. Corrupt data could occur in
this example if a record was deleted from the <TT><FONT FACE="Courier">NAME</FONT></TT>
table without ever deleting the corresponding address information
in the <TT><FONT FACE="Courier">ADDRESS</FONT></TT> table. Because
of this oversight, this information would remain unused in the
<TT><FONT FACE="Courier">ADDRESS</FONT></TT> table and could potentially
result in problems if another user was assigned the deleted record's
ID value.
<P>
This covers the basics of how relational databases are used to
store information. The following topic examines SQL in more detail
and explains how SQL is used to query relational databases to
retrieve or modify the database contents.
<H3><A NAME="StructuredQueryLanguageSQL">Structured Query Language
(SQL)</A></H3>
<P>
Structured Query Language (SQL) is an ANSI standard computer programming
language used to query relational databases.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
SQL and the relational database were invented and introduced in 1970 by Dr. E. F. Codd of IBM. Dr. Codd's original paper titled &quot;A Relational Model of Data for Large Shared Data Banks&quot; was a revolutionary paper that has truly changed the face of 
modern computing.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The ANSI standard for SQL (the latest standard is commonly referred
to as SQL-92 because it was voted on in 1992) specifies a core
syntax for the language itself. The reader should be aware that
many relational database management systems advertise themselves
to be SQL-92 compliant, but that all of these RDBMSs have added
vendor-specific extensions to the language to support advanced
features such as security, stored procedures, and triggers. There
is nothing wrong with these extensions as long as the vendor has
at least standardized on the extensions across its own product
line. Simply be aware that these extensions exist, and try to
note the differences when porting from one RDBMS to another.
<H4>Basic SQL Syntax</H4>
<P>
SQL is most commonly used to retrieve or modify data in a relational
database. The four most commonly used statements are <TT><FONT FACE="Courier">SELECT</FONT></TT>,
<TT><FONT FACE="Courier">INSERT</FONT></TT>, <TT><FONT FACE="Courier">DELETE</FONT></TT>,
and <TT><FONT FACE="Courier">UPDATE</FONT></TT>. This section
will briefly discuss these statements, and then explain database
programming constructs such as triggers and stored procedures.
<H5>The SELECT Statement</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">SELECT</FONT></TT> statement is used
to <I>select</I> data from a database. At its simplest, the <TT><FONT FACE="Courier">SELECT</FONT></TT>
statement retrieves data from a specified table using the <TT><FONT FACE="Courier">FROM</FONT></TT>
clause. To retrieve all of the addresses from the <TT><FONT FACE="Courier">ADDRESSES</FONT></TT>
database (see the previous section titled &quot;The Relational
Database&quot;), the user would issue the following SQL statement
to the RDBMS:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT * FROM ADDRESS</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Upon execution, the RDBMS would return all of the rows in the
<TT><FONT FACE="Courier">ADDRESS</FONT></TT> table to the user.
This request also could have been worded using the following syntax
in order to retrieve all of the data:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT ID, STREET, CITY, STATE, ZIP FROM
ADDRESS</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This data retrieval also can be filtered using the <TT><FONT FACE="Courier">WHERE</FONT></TT>
clause. The <TT><FONT FACE="Courier">WHERE</FONT></TT> clause
is used to specify some condition that each row must meet in order
to be returned to the user. The following statement returns all
records to the user where the address is located in the state
of Florida:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT * FROM ADDRESS WHERE STATE = 'FL'</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">ORDER BY</FONT></TT> clause can be
used to order data in some default order (determined by the data
type of the ordering field). To return all rows to the user ordered
by the <TT><FONT FACE="Courier">LAST_NAME</FONT></TT> field, exe-cute
the following statement:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT * FROM ADDRESS ORDER BY LAST_NAME</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">SELECT</FONT></TT> statement also
can be used to <I>join</I> multiple tables together in order to
retrieve a combination of each table's data. For example, to retrieve
all records from the <TT><FONT FACE="Courier">NAME</FONT></TT>
and <TT><FONT FACE="Courier"> ADDRESS</FONT></TT> table that are
related, issue the following <TT><FONT FACE="Courier">join</FONT></TT>
command:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT * FROM NAME, ADDRESS where NAME.ID
= ADDRESS.ID<BR>
</FONT></TT>
</BLOCKQUOTE>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Many different types of joins can be used to return different subsets of data. For more information on joins, consult a bona fide book about SQL such as <I>Teach Yourself SQL In 14 Days</I>, by Sams Publishing.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<BLOCKQUOTE>
In short, here is the basic syntax for the <TT><FONT FACE="Courier">SELECT</FONT></TT>
statement:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SELECT &lt;FIELDNAME1, FIELDNAME2, &#133;
FIELDNAMEn | *&gt;<BR>
FROM &lt;TABLE1, TABLE2, TABLE3,...&gt;<BR>
WHERE &lt;CONDITION&gt;</FONT></TT>
</BLOCKQUOTE>
<H5>The INSERT Statement</H5>
<BLOCKQUOTE>
At this point, you may be wondering how data actually gets put
into the tables in the first place. There are actually two methods:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>Using the SQL </FONT><TT><FONT FACE="Courier">INSERT</FONT></TT>
statement
<LI><FONT COLOR=#000000>Using a vendor-supplied data import tool
such as Oracle's SQL-Loader or Sybase's bcp</FONT>
</UL>
<BLOCKQUOTE>
This discussion will focus on the use of the SQL <TT><FONT FACE="Courier">INSERT</FONT></TT>
statement to insert data into a table.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">INSERT</FONT></TT> statement syntax,
at its simplest, looks like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">INSERT INTO &lt;TABLE_NAME&gt;<BR>
(COLUMN1, COLUMN2, COLUMN3, ...)<BR>
VALUES (VALUE1, VALUE2, VALUE3, ...)</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
When inserting data, you must follow three rules:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>The values used must be the exact same
data type as the fields to which they are being added.</FONT>
<LI><FONT COLOR=#000000>The data's size must be within the column's
size. For instance, an 80-character string cannot be added to
a 40-character column.</FONT>
<LI><FONT COLOR=#000000>The data's location in the </FONT><TT><FONT FACE="Courier">VALUES</FONT></TT>
list must correspond to the location in the column list of the
column it is being added to. (That is, the first value must be
entered into the first column, the second value into the second
column, and so on.)
</UL>
<BLOCKQUOTE>
As a quick example, the following statement inserts a record into
the final <TT><FONT FACE="Courier">ADDRESS</FONT></TT> table mentioned
in the section titled &quot;The Relational Database&quot;:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">INSERT INTO ADDRESS(ID, STREET, CITY,
STATE, ZIP)<BR>
VALUES (1, '123 Forest St.', 'Huntsville', 'AL', 36507)</FONT></TT>
</BLOCKQUOTE>
<H5>The UPDATE Statement</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">UPDATE</FONT></TT> statement is used
to update existing information within a database table. For instance,
to modify the zip code value of an existing <TT><FONT FACE="Courier">ADDRESS</FONT></TT>
row, the <TT><FONT FACE="Courier">UPDATE</FONT></TT> statement
would be used. Here's the format of the <TT><FONT FACE="Courier">UPDATE</FONT></TT>
statement:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">UPDATE &lt;TABLE_NAME&gt;<BR>
SET &lt;COLUMNNAME1 = VALUE1, COLUMNNAME2 = VALUE2, ...&gt;<BR>
WHERE &lt;CONDITION&gt;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
As you can see, the <TT><FONT FACE="Courier">UPDATE</FONT></TT>
statement makes use of the <TT><FONT FACE="Courier">WHERE</FONT></TT>
clause originally introduced in the previous <TT><FONT FACE="Courier">SELECT</FONT></TT>
statement discussion. As an example, the following statement could
be used to correct an entry error where someone entered &quot;Pensacola&quot;
instead of &quot;Miami&quot; for the <TT><FONT FACE="Courier">CITY</FONT></TT>
field in the <TT><FONT FACE="Courier">ADDRESS</FONT></TT> table:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">UPDATE ADDRESS<BR>
SET CITY = 'Miami'<BR>
WHERE CITY = 'Pensacola'</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Take note here that if the <TT><FONT FACE="Courier">WHERE</FONT></TT>
clause is omitted from the <TT><FONT FACE="Courier">UPDATE</FONT></TT>
statement, all records in the specified table will be updated!
Therefore, make sure that the records being updated are always
specified.
</BLOCKQUOTE>
<H5>The DELETE Statement</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">DELETE</FONT></TT> statement is used
to remove rows from a relational table. The <TT><FONT FACE="Courier">DELETE</FONT></TT>
statement makes use of the <TT><FONT FACE="Courier">WHERE</FONT></TT>
clause introduced in the previous <TT><FONT FACE="Courier">SELECT</FONT></TT>
statement discussion. Depending on how the <TT><FONT FACE="Courier">WHERE</FONT></TT>
clause is used, the <TT><FONT FACE="Courier">DELETE</FONT></TT>
statement can do the following:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>Delete single rows</FONT>
<LI><FONT COLOR=#000000>Delete multiple rows</FONT>
<LI><FONT COLOR=#000000>Delete all rows</FONT>
<LI><FONT COLOR=#000000>Delete no rows</FONT>
</UL>
<BLOCKQUOTE>
When using the <TT><FONT FACE="Courier">DELETE</FONT></TT> statement,
you should remember several things:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">DELETE</FONT></TT>
statement cannot be used to delete an individual field's (or column's)
values (see <TT><FONT FACE="Courier">UPDATE</FONT></TT> for this).
The <TT><FONT FACE="Courier">DELETE</FONT></TT> statement deletes
entire records from a table.
<LI><FONT COLOR=#000000>Like </FONT><TT><FONT FACE="Courier">INSERT</FONT></TT>
and <TT><FONT FACE="Courier">UPDATE</FONT></TT>, deleting records
from one table can cause referential integrity problems within
other tables. This should be kept in mind when modifying data
within a database.
<LI><FONT COLOR=#000000>Using the </FONT><TT><FONT FACE="Courier">DELETE</FONT></TT>
statement deletes only records, not the table itself.
</UL>
<BLOCKQUOTE>
Here's the basic syntax of the <TT><FONT FACE="Courier">DELETE</FONT></TT>
statement:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DELETE FROM &lt;TABLE_NAME&gt; WHERE
&lt;CONDITION&gt;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The following example statement shows the syntax used to delete
all addresses located in the state of California:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DELETE FROM ADDRESS WHERE STATE = 'CA'</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="UsingJavawithDatabases"><FONT SIZE=5 COLOR=#FF0000>Using
Java with Databases</FONT></A></H2>
<P>
The first portion of this chapter introduced Java programmers
to the world of relational databases. By now, you should have
a decent understanding of what a database server is, what SQL
is, and some knowledge of how to query a set of tables within
a database. Of course, all of the information presented up to
this point has been focused on executing SQL statements directly.
The remainder of this chapter will discuss different methods for
passing queries to a database server from within a Java applet
or application. Currently, there are three primary methodologies
for Java database access:
<UL>
<LI><FONT COLOR=#000000>CGI scripts called from Java.</FONT>
<LI><FONT COLOR=#000000>The JDBC API that provides a structured
interface to relational databases from Java.</FONT>
<LI><FONT COLOR=#000000>Server-side code that can be written in
Java and used to access a database. This method, in general, ties
the developer to a specific software manufacturer's toolset.</FONT>
</UL>
<P>
The following sections examine each of these topics briefly so
that the reader will have a basic understanding of what is required
to do database operations using Java code. Each section will point
the reader in the direction of much more detailed sources that
can be used if more information is required.
<H3><A NAME="JavaandCGICalls">Java and CGI Calls</A></H3>
<P>
Before the advent of powerful Java database connectivity tools,
the Common Gateway Interface (CGI) was the database querying method
used by the vast majority of Web developers. This interface defines
a methodology for HTTP-based Web servers to talk to programs.
CGI programs provide a way for clients to issue a procedure call,
have that procedure execute on the server, and then return data
to the client. CGI applications were the first &quot;dynamic&quot;
elements on the Web, and they continue to be extremely popular
because of the momentum behind the technology. A beginning Web
developer may wonder, &quot;Why use Java then if CGI is dynamic
and platform-independent?&quot; The answer is that a CGI application
is simply a program residing on a server that understands how
to &quot;speak&quot; HTTP. CGI applications can only return data
to the client using a format that the client understands. At the
current time (and in the foreseeable future), this data consists
of HTML code. Therefore, unlike Java, CGI can only return basic
form elements (some of which could be Java applets!). In other
words, CGI programs are used to <I>provide</I> information; they
are not the actual information themselves.
<P>
Where does CGI fit in for Java developers? CGI's primary strength
(for Java developers) is its support for scripts written in any
language. At the current time, there are no open Java packages
available that allow applets to connect directly to SQL databases
without the addition of special software drivers on each client
machine. Therefore, CGI is an excellent candidate for simple database
access. A CGI script could be written in C++ to query an Oracle
database based on a number of input parameters. The result set
returned from the query could then be formatted in HTML and returned
(through the Common Gateway Interface) to the client that requested
the information. Of course, this information could be displayed
on the client using a Java applet.
<H4>Passing Data from the Client to the Gateway Program</H4>
<P>
There are two primary ways for a client (an HTML page, or in the
Java programmer's case, perhaps a Java applet) to pass input parameters
to a CGI program residing on a Web server:
<UL>
<LI><FONT COLOR=#000000>Use environment variables</FONT>
<LI><FONT COLOR=#000000>Use standard input (stdin) to the CGI
program</FONT>
</UL>
<P>
CGI-compliant Web servers use the <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
and <TT><FONT FACE="Courier">PATH_INFO</FONT></TT> environment
variables to pass data to CGI scripts.
<P>
To pass information to the <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
environment variable, include the arguments to be passed after
a question mark (<TT><FONT FACE="Courier">?</FONT></TT>) character
on the command line. For instance, to call the <TT><FONT FACE="Courier">query.pl</FONT></TT>
script with the &quot;<TT><FONT FACE="Courier">address</FONT></TT>&quot;
argument using the <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
variable, use the following syntax:
<BLOCKQUOTE>
<TT>http://www.someserver.com/query.pl?address</TT>
</BLOCKQUOTE>
<P>
To pass information to the <TT><FONT FACE="Courier">PATH_INFO</FONT></TT>
environment variable, include the arguments to be passed after
a slash (<TT><FONT FACE="Courier">/</FONT></TT>) followed by an
equals sign and the parameters value. For instance, to call the
<TT><FONT FACE="Courier">query.pl</FONT></TT> script with the
&quot;<TT><FONT FACE="Courier">address</FONT></TT>&quot; argument
using the <TT><FONT FACE="Courier">PATH_INFO</FONT></TT> variable,
use the following syntax:
<BLOCKQUOTE>
<TT>http://www.someserver.com/query.pl/address=Miami</TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">query.pl</FONT></TT> CGI script then
can extract this string from the environment variable, parse it,
and do whatever needs to be done. Using environment variables
to pass information is a risky undertaking, however, due to the
memory or string size limitations of some environments.
<P>
Although somewhat out of the scope of this book, HTML forms also
can be used to &quot;post&quot; data to the standard input (stdin)
of CGI scripts. A brief example of this type of input will be
supplied so that readers will have some idea how to call CGI scripts
directly from Java. There are many online and textual sources
that describe CGI and HTML in great detail. Consult these sources
if you need in-depth information on developing CGI applications.
<P>
The following snippet of code (see Listing 25.1) can be used to
post information to a CGI script. Note that this code monitors
an input stream continuously in a loop. Therefore, if you do nothing
else, make sure that this code is broken off and running in its
own thread.
<HR>
<BLOCKQUOTE>
<B>Listing 25.1. Sample Java code used to call the </B><TT><B><FONT FACE="Courier">query.pl</FONT></B></TT><B>
CGI script.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Socket theSocket = new Socket(&quot;http://www.someserver.com&quot;,
80);<BR>
DataOutputStream theOut = new DataOutputStream(theSocket.getOutputStream());
<BR>
DataInputStream theIn = new DataInputStream(theSocket.getInputStream());
<BR>
<BR>
String theScript = &quot;query.pl&quot;;<BR>
String theParameter = &quot;Address&quot;;<BR>
<BR>
theOut.writeBytes(&quot;POST &quot; + theScript + &quot; HTTP/1.0\r\n&quot;
+ &quot;Content-type:<BR>
</TT><TT>
application/octet-stream\r\n&quot;<BR>
&nbsp;&nbsp;+ &quot;Content-length: &quot; + theParameter.length()
+ &quot;\r\n\r\n&quot; + theParameter;<BR>
<BR>
String theReturn;<BR>
String loopdeloop;<BR>
while ((theReturn = theIn.readLine()) != null)<BR>
&nbsp;</TT>&nbsp;<TT>loopdeloop +=
theReturn + &quot;\n&quot;;<BR>
theIn.close();<BR>
theOut.close;</TT>
</BLOCKQUOTE>
<HR>
<P>
The code in Listing 25.1 opens a connection to the Web server
<TT>http://www.someserver.com</TT>
on port 80. After this connection has been made, the code opens
a new output and input stream for communication with the server.
The script is called using the output stream and then the code
reads the server's reply using the input stream. At this point,
it is the Java code's responsibility to parse through the reply
and do something with it (display to user, perform calculations,
and so on).
<P>
CGI applications represented an important first step toward a
truly dynamic World Wide Web, but CGI has definite shortcomings.
Most notably, CGI programs return what looks like Romulan to unsuspecting
clients, and therefore these programs can become difficult to
maintain, particularly for anyone other than the original programmer.
CGI programs also suffer from notoriously poor performance as
servers become bogged down. Developers also are forced to segment
their application into distinct pieces. One side of the application
passes a query through a very thin pipe, and then the other side
of the application retrieves the query information from the pipe
and talks to the database. When the required information is retrieved,
the information is parsed and sent back to the requesting side
of the application through the thin pipe. The next section (&quot;The
JDBC API&quot;) discusses a way for developers to make database
queries directly within Java code and retrieve the query results
directly. This will result in much cleaner (and faster) application
development, as well as provide a more generic database API for
applications if database servers ever need to be switched.
<H3><A NAME="TheJDBCAPI">The JDBC API</A></H3>
<P>
The Java Database Connectivity Application Programming Interface
(API) is an API currently being designed by Sun Microsystems that
provides a Java language interface to the X/Open SQL Call Level
Interface standard. This standard provides a DBMS-independent
interface to relational databases that defines a generic SQL database
access framework. The most visible implementation of the X/Open
SQL CLI is Microsoft's ODBC (Open Database Connectivity). This
API defines a common SQL syntax and function calls that can be
used by developers to send SQL commands to and retrieve data from
SQL databases. ODBC-enabled applications make use of database
drivers (similar in concept to other device drivers) installed
on the system that allow applications to talk to a vendor's database.
Using this methodology, all of the DBMS-specific code is placed
inside the ODBC driver and the application developer is shielded
from implementation-specific problems in theory. Practically speaking,
it is sometimes difficult to completely remove vendor-specific
syntax from all ODBC operations, but in most cases, it is a relatively
simple task to port ODBC to run on a new database server.
<P>
For Java developers, ODBC's primary drawback is that it is written
in C. Because of the limitations inherent in the use of native
methods, the JDBC designers have designed the JDBC specification
to most easily use ODBC in the short term, but they have provided
the capability long-term for JDBC to be implemented in other ways.
<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B> </TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
JDBC, like ODBC, is designed to be a call-level SQL interface. Because many of its low-level operations can be combined into a higher-level, object-oriented interface, expect to see Java class libraries released in the future that provide a mapping to the 
underlying JDBC calls. This happened with ODBC almost immediately, and the majority of ODBC developers currently use other interfaces rather than using the ODBC API directly.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The JDBC API is expressed as a series of abstract Java interfaces
within the <TT><FONT FACE="Courier">java.sql</FONT></TT> package
that will be provided as part of the JDK 1.1 release. Here are
the most commonly used  interfaces:
<UL>
<LI><TT><FONT FACE="Courier">java.sql.DriverManager</FONT></TT>-Manages
the loading and unloading of database drivers from the underlying
system.
<LI><TT><FONT FACE="Courier">java.sql.Connection</FONT></TT>-Handles
the connection to a specific database.
<LI><TT><FONT FACE="Courier">java.sql.Statement</FONT></TT>-Contains
an SQL statement to be passed to the database; two subtypes in
this interface are the <TT><FONT FACE="Courier">PreparedStatement</FONT></TT>
(for executing a precompiled SQL statement) and the <TT><FONT FACE="Courier">CallableStatement</FONT></TT>
(for executing a database stored procedure).
<LI><TT><FONT FACE="Courier">java.sql.ResultSet</FONT></TT>-Contains
the record result set from the SQL statement passed to the database.
</UL>
<P>
JDBC-enabled applets and applications make use of database drivers
to connect to remote databases. What sets JDBC apart from ODBC
is that these drivers can actually be applets themselves that
get uploaded to the client system at runtime. Therefore, the overall
Java model of a &quot;thin client&quot; querying a powerful database
remains.
<P>
There are several different configurations in which JDBC can be
used to access a database. Among the possible configurations are
the following:
<UL>
<LI><FONT COLOR=#000000>An untrusted applet </FONT>uploaded over
the Internet to a client. This applet will connect directly to
a server database across the Internet. Because the client machine
will have no configuration information installed on it, the applet
will have to be aware of the database to connect to (unlike in
ODBC, where database configuration information is stored in the
Windows registry).
<LI><FONT COLOR=#000000>A trusted applet</FONT> (trusted either
because of an encryption key or because the user has decided to
trust the source of the applet) uploaded over the Internet to
a client. Although this applet is trusted and can connect to machines
other than the one that it was uploaded from, JDBC configuration
information will still have to be loaded because it is not located
on the client machine.
<LI><FONT COLOR=#000000>An intranet Java </FONT>application. As
a stand-alone application, this instance will not be subject to
the security restrictions placed upon Java applets. Typical methodologies
for connecting to the database consist of traditional two-tier
client/server applications and also three-tier applications that
use Remote Procedure Calls (Rpcs) or an Object Request Broker
(ORB) to connect to objects on a middle tier. This provides a
middle tier of services and allows the application to be partitioned
for performance improvements.
</UL>
<H4>Steps Required to Access a JDBC Database</H4>
<P>
For programmers familiar with ODBC or other call-level interfaces
to databases, the steps required to access a JDBC database should
be familiar. JDBC uses the concept of a &quot;connection&quot;
handle to manage a program's connection to a database.
<H5>Acquiring a Connection</H5>
<BLOCKQUOTE>
When a Java JDBC-enabled applet or application initially starts,
it must first acquire a connection to the JDBC database. It does
this by calling the <TT><FONT FACE="Courier">java.sql.DriverManager.getConnection()</FONT></TT>
method. The syntax for this method is
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static synchronized Connection
getConnection(String url,<BR>
&Acirc; java.util.Properties info) throws SQLException;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
As you can see, the <TT><FONT FACE="Courier">getConnection()</FONT></TT>
method takes as arguments a URL (to determine the database server
location) and a Properties list (usually containing at least a
user name and password). The format for the JDBC URL is still
being debated, but at the present time it appears that it will
look something like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">jdbc:&lt;subprotocol&gt;:&lt;subname&gt;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
As an example, if the connection is to use an ODBC bridge to connect
to the <TT><FONT FACE="Courier">EMPLOYEES</FONT></TT> database,
the URL would be
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">jdbc:odbc:EMPLOYEES.</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If the Oracle SQLNet protocol was being used to connect to an
Oracle listener on <TT><FONT FACE="Courier">www.someserver.com</FONT></TT>
at port 2025, the URL would be
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">jdbc:sqlnet://www.someserver.com:2025/EMPLOYEES</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Like ODBC, JDBC needs to know which database drivers are available
for use. It can load drivers using two methods:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>The JDBC Driver Manager can look for an
</FONT><TT><FONT FACE="Courier">sql.drivers</FONT></TT> system
property and load all listed drivers.
<LI><FONT COLOR=#000000>The Java programmer can load a driver
class by calling the </FONT><TT><FONT FACE="Courier">Class.forName()</FONT></TT>method.
</UL>
<H5>Creating a Statement</H5>
<BLOCKQUOTE>
Now that the connection has been required, a statement needs to
be created so that it can be passed to the database for processing.
This is done by calling the <TT><FONT FACE="Courier">connection</FONT></TT>
class's <TT><FONT FACE="Courier">createStatement()</FONT></TT>
method. Here's an example of this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java.sql.Statement statement = connection.createStatement();</FONT></TT>
</BLOCKQUOTE>
<H5>Executing a Query</H5>
<BLOCKQUOTE>
Using the statement you created, an SQL query can be executed
by using the statement's <TT><FONT FACE="Courier">executeQuery()</FONT></TT>
method. This method returns a <TT><FONT FACE="Courier">ResultSet</FONT></TT>
object so that the query's results can be examined. Here's a simple
example:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ResultSet result = statement.executeQuery(&quot;select
NAME, SALARY,<BR>
&Acirc; EMPLOYEE_ID from EMPLOYEES&quot;);</FONT></TT>
</BLOCKQUOTE>
<H5>Examining the Result Set</H5>
<BLOCKQUOTE>
Use the <TT><FONT FACE="Courier">ResultSet</FONT></TT> object
returned from the <TT><FONT FACE="Courier">executeQuery()</FONT></TT>
method call to examine the returned data. The <TT><FONT FACE="Courier">ResultSet</FONT></TT>
class has member methods to scroll the <TT><FONT FACE="Courier">ResultSet</FONT></TT>
lists, such as <TT><FONT FACE="Courier">first()</FONT></TT>, <TT><FONT FACE="Courier">last()</FONT></TT>,
<TT><FONT FACE="Courier">next()</FONT></TT>, and <TT><FONT FACE="Courier">prev()</FONT></TT>,
as well as individual data member methods for examining returned
data such as <TT><FONT FACE="Courier">getInteger()</FONT></TT>,
<TT><FONT FACE="Courier">getVarChar()</FONT></TT>, <TT><FONT FACE="Courier">getVarBinary()</FONT></TT>,
and so on. To examine the returned data, methods such as <TT><FONT FACE="Courier">getInteger()</FONT></TT>
can be called in one of two ways:
</BLOCKQUOTE>
<UL>
<LI><FONT COLOR=#000000>By passing in an integer index value that
will return the column index value of the data returned (0 for
the first item, 1 for the second item, &#133;). This method will
result in better performance, but poor readability.</FONT>
<LI><FONT COLOR=#000000>By passing in a column name string identifying
the column to be examined (for example, </FONT><TT><FONT FACE="Courier">getInteger(&quot;SALARY&quot;)</FONT></TT>).
</UL>
<BLOCKQUOTE>
JDBC also can be used to modify data using common insert, delete,
and update method calls.
</BLOCKQUOTE>
<H4>Other JDBC Operations</H4>
<P>
JDBC supports a wide range of common database functions as well.
Here are some examples:
<UL>
<LI><FONT COLOR=#000000>Transaction management</FONT>
<LI><FONT COLOR=#000000>Basic cursors</FONT>
<LI><FONT COLOR=#000000>Stored procedure execution</FONT>
<LI><FONT COLOR=#000000>Scalar functions such as numeric, string,
system, and time/date functions</FONT>
</UL>
<P>
In short, JDBC promises to be a tremendous tool for Java programmers
interested in connecting to remote SQL databases. At the current
time, many major database manufacturers are preparing JDBC drivers
so that application programmers will be able to access databases
from Java applets. The biggest change for developers might be
the performance change, particularly when using untrusted JDBC
applets communicating with databases across the Internet. In the
Intranet case, however, the appearance of native Java compilers
should make high-performance, cross-platform JDBC application
development a reality in the near future.
<H3><A NAME="ServerSideDatabaseAccess">Server-Side Database Access</A>
</H3>
<P>
The final Java/database access method to be discussed has been
termed Server-Side Database Access. This functionality is similar
to that of Java applets/applications calling CGI scripts, except
that in this case, the CGI scripts have been replaced by &quot;intelligent&quot;
Web servers designed for database access such as the Oracle WebServer
and the Microsoft Internet Information Server. Both of these products
allow code to be executed on the server that connects directly
to a database (possibly on yet another server). This code can
be called directly or indirectly from a remote Java applet, but
unlike CGI, it is loaded in the Web server's process.
<H4>Oracle WebServer 2.0</H4>
<P>
Currently, the Oracle WebServer 2.0 supports the creation of server
code using a number of languages including Oracle PL/SQL, Java,
and C/C++. The Oracle WebServer is built around the Oracle Web
Request Broker. This process bypasses the CGI interface and uses
a high- performance native connection to the Oracle7 server. Unfortunately
(for non-Oracle  developers) at the current time, only the Oracle7
database server can be connected to using this product. This server
supports end-to-end encryption using SSL 2.0 (Secure Sockets Layer)
and is available for a variety of operating platforms including
Windows NT and SPARC Solaris. For situations in which the database
to be used is definitely going to be an Oracle7 database, the
Oracle WebServer allows developers to write more advanced, better
performing server code that can be used by Java applets to query
databases and return information.
<H4>Microsoft Internet Information Server</H4>
<P>
The Microsoft Internet Information Server (IIS) promises to be
one of the more widely used Web servers in the near future due
to Microsoft's decision to include it for free as part of its
Windows NT 4.0 product. This product is currently freely downloadable
from the Microsoft Web site (<TT><A HREF="http://www.microsoft.com/">http://www.microsoft.com</A></TT>).
IIS uses ODBC by default to connect to any database that has an
available ODBC driver. (Although this makes IIS a more open product,
there is a performance penalty to be paid for using ODBC in most
cases.) For developers not wanting to use ODBC or who want a cleaner
interface than the default <TT><FONT FACE="Courier">HTTPODBC.DLL</FONT></TT>
implementation, Microsoft's ISAPI (Internet Services API) can
be used using the <TT><FONT FACE="Courier">OLEISAPI.DLL.</FONT></TT>
OLEISAPI allows the developer to start a server application, pass
it some parameters, and retrieve its return values to return to
the Web client. To do this, the server application must be an
in-process OLE DLL, which can be created using Microsoft Visual
C++ or Visual Basic. In the near future, IIS will be able to run
code written in a number of other languages including VBScript,
Microsoft's scripting language, which bears a syntactical resemblance
to Visual Basic. Unlike Visual Basic, however, VBScript will be
thread-scalable and should offer better performance.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter was supplied to give Java developers some insight
into Java's database access capabilities. During Java's first
year of growth (1995-1996), much of the framework was laid to
make the Java environment available on virtually every popular
operating system. In addition to this, a great deal of effort
has gone into producing new tools specifically tailored for Java
developers. The second year of Java's growth should see the introduction
of a host of database-access related products that will open the
business enterprise up to Java applet and application developers.
(Java will no longer be used only to scroll text across Web pages!)
Following the widespread acceptance of Java as a full-fledged,
industrial-strength programming language, the following year should
see the introduction of component models such as Java Beans that
will allow Java developers to access other object model objects
(such as CORBA and COM).
<P>
The JDBC API appears to be a unifying API that many database tool
manufacturers will standardize on, much as Microsoft's ODBC API
helped standardize Windows-platform database access. As more and
more products begin to emerge and the marketplace grows even more
competitive, Java developers should make every effort possible
to refrain from adding platform-specific extensions to their Java
code, particularly in environments where users of other operating
systems could access your code (such as the Internet).
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch24.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch26.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

