<HTML>

<HEAD>
   <TITLE>Chapter 4 -- Java for C++ Programmers</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 4</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Java for C++ Programmers</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#DataTypes" >Data Types</A>
<UL>
<LI><A HREF="#PrimitiveTypes" >Primitive Types</A>
<LI><A HREF="#Casting" >Casting</A>
<LI><A HREF="#Operators" >Operators</A>
<LI><A HREF="#Pointers" >Pointers</A>
<LI><A HREF="#StructuresandUnions" >Structures and Unions</A>
<LI><A HREF="#Arrays" >Arrays</A>
</UL>
<LI><A HREF="#AutomaticMemoryManagement" >Automatic Memory Management</A>
<LI><A HREF="#Classes" >Classes</A>
<UL>
<LI><A HREF="#MemberMethods" >Member Methods</A>
<LI><A HREF="#SettingDefaultValues" >Setting Default Values</A>
<LI><A HREF="#StaticMembers" >Static Members</A>
<LI><A HREF="#ConstructorsandDestructors" >Constructors and Destructors</A>
<LI><A HREF="#Inheritance" >Inheritance</A>
</UL>
<LI><A HREF="#ThePreprocessor" >The Preprocessor</A>
<LI><A HREF="#OtherChanges" >Other Changes</A>
<UL>
<LI><A HREF="#Comments" >Comments</A>
<LI><A HREF="#CommandLineArguments" >Command-Line Arguments</A>
<LI><A HREF="#CharacterArraysandStrings" >Character Arrays and Strings</A>
<LI><A HREF="#gotobreakandcontinue" >goto, break, and continue</A>
<LI><A HREF="#RuntimeTypeIdentification" >Runtime Type Identification</A>
<LI><A HREF="#MissingFeatures" >Missing Features</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
If you are coming to Java from a C++ background, you are off to
a great head start. In fact, you already know most of the Java
syntax. This chapter will take you through a whirlwind tour of
Java, pointing out the key differences between Java and C++. You'll
read about C++ features that were left out of Java and about features
that were added to Java to take it beyond C++. You'll see how
Java has done away with the C++ preprocessor and multiple inheritance
but makes up for those through a cleaner object model and interface
inheritance. This chapter doesn't attempt to teach you everything
you need to know to be a Java programmer, but it will help you
put Java in perspective relative to your knowledge as a C++ programmer.
<H2><A NAME="DataTypes"><FONT SIZE=5 COLOR=#FF0000>Data Types</FONT></A>
</H2>
<P>
Because Java was based on C and C++, the data types supported
by Java are very similar to those of C and C++. This section describes
the key differences between Java types and C++ types.
<H3><A NAME="PrimitiveTypes">Primitive Types</A></H3>
<P>
A language's primitive types are the building blocks from which
more complicated types (such as classes) are built. Java supports
a set of eight primitive types, which are shown in Table 4.1.
<BR>
<P>
<CENTER><B>Table 4.1. Java primitive types.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Type</I></TD><TD WIDTH=206><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=206>8-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=206>16-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=206>32-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=206>64-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">float</FONT></TT></TD>
<TD WIDTH=206>32-bit floating-point number</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">double</FONT></TT></TD>
<TD WIDTH=206>64-bit floating-point number</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">char</FONT></TT></TD>
<TD WIDTH=206>16-bit Unicode characters</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">boolean</FONT></TT>
</TD><TD WIDTH=206>Can hold <TT><FONT FACE="Courier">true</FONT></TT> or <TT><FONT FACE="Courier">false</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
From this list, you can tell that Java adds both the <TT><FONT FACE="Courier">byte</FONT></TT>
and <TT><FONT FACE="Courier">boolean</FONT></TT> types. Some recent
C++ compilers have added support for the new C++ <TT><FONT FACE="Courier">boolean</FONT></TT>
type, so you may already be using it in your code. Because Java
provides Unicode support, you should notice that its <TT><FONT FACE="Courier">char</FONT></TT>
type is 16 bits wide. This is also why the 8-bit <TT><FONT FACE="Courier">byte</FONT></TT>
type is included as a primitive type. In C++, you probably have
been emulating a <TT><FONT FACE="Courier">byte</FONT></TT> type
with something similar to the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">type unsigned char byte;</FONT></TT>
</BLOCKQUOTE>
<P>
There are a couple of other extremely important differences between
the Java and C++ primitive types. The Java primitives are each
of a known and guaranteed size. This is critical to Java because
of its goal of portability across hardware and operating systems.
If an <TT><FONT FACE="Courier">int</FONT></TT> is 16 bits on one
platform and 32 bits on another platform, a program is asking
for trouble if it expects to be run on both platforms. C++ guarantees
certain relationships among its primitive types. For example,
a C++ <TT><FONT FACE="Courier">long</FONT></TT> is guaranteed
to be at least as big as a C++ <TT><FONT FACE="Courier">int</FONT></TT>.
Java takes this further and prescribes an exact size for each
primitive.
<P>
Because most of the machines that will run Java programs will
do so in a 32-bit environment, the sizes of the primitive types
have been defined with 32-bit optimization in mind. This means
that some Java primitives may use more storage space than you
are accustomed to with their C++ equivalents. In particular, you
should notice that a Java <TT><FONT FACE="Courier">int</FONT></TT>
is 32 bits and a Java <TT><FONT FACE="Courier">long</FONT></TT>
is 64 bits.
<P>
A final difference worth pointing out is that all Java primitive
types are signed. This means that C++ declarations like the following
are not allowed in Java:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">unsigned long bigLong;&nbsp;&nbsp;&nbsp;&nbsp;
// not legal in Java<BR>
unsigned double salary;&nbsp;&nbsp;&nbsp;&nbsp;// not legal in
Java</FONT></TT>
</BLOCKQUOTE>
<P>
The Java <TT><FONT FACE="Courier">boolean</FONT></TT> primitive
can be set to a value of <TT><FONT FACE="Courier">true</FONT></TT>
or <TT><FONT FACE="Courier">false</FONT></TT>. In traditional
C and C++ programming, <TT><FONT FACE="Courier">true</FONT></TT>
and <TT><FONT FACE="Courier">false</FONT></TT> were defined by
using the preprocessor to be equal to 1 and 0, respectively.
<H3><A NAME="Casting">Casting</A></H3>
<P>
In both Java and C++, it is possible to cast a variable from one
type to another. However, because Java is a more strongly typed
language than is C++, Java protects you and prevents you from
making some casts. For example, because Java's <TT><FONT FACE="Courier">boolean</FONT></TT>
type is not a disguised <TT><FONT FACE="Courier">int</FONT></TT>
in Boolean clothing, you cannot cast between a Boolean and a numeric
type. This means that you cannot do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean aBool = false;&nbsp;&nbsp;&nbsp;&nbsp;//
not legal in Java<BR>
int anInt = (int)aBool;&nbsp;&nbsp;&nbsp;// not legal in Java</FONT></TT>
</BLOCKQUOTE>
<P>
Because Java doesn't rely on programming conventions that indicate
<TT><FONT FACE="Courier">false</FONT></TT> equals zero, Java cannot
cast <TT><FONT FACE="Courier">aBool</FONT></TT> to <TT><FONT FACE="Courier">anInt</FONT></TT>
in this example.
<H4>Automatic Coercions</H4>
<P>
Related to casting is the concept of <I>automatic coercion</I>.
Automatic coercion occurs when a compiler <I>coerces</I>, or casts,
a variable of one type into another automatically. For example,
consider the following C++ code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">long aLong = 65536L;<BR>
unsigned int justAnInt;<BR>
justAnInt = aLong;<BR>
printf(&quot;%d&quot;, justAnInt);</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the 65,536 stored in <TT><FONT FACE="Courier">aLong</FONT></TT>
is also placed into <TT><FONT FACE="Courier">justAnInt</FONT></TT>.
Because no explicit cast is performed, an automatic coercion from
a <TT><FONT FACE="Courier">long</FONT></TT> to an <TT><FONT FACE="Courier">unsigned
int</FONT></TT> is performed. Unfortunately, on a 16-bit platform,
this will result in an error because the value in <TT><FONT FACE="Courier">aLong</FONT></TT>
is too large to fit in <TT><FONT FACE="Courier">justAnInt</FONT></TT>.
The automatic coercion will place 0 into <TT><FONT FACE="Courier">justAnInt</FONT></TT>
instead of the desired 65,536.
<P>
Because Java does not perform automatic coercions, you may need
to slightly alter your thinking about some of your C++ programming
habits. For example, in C++ you could write the following loop:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count=10;<BR>
while (count) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// use count to do something<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count-;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In C++, the <TT><FONT FACE="Courier">while</FONT></TT> loop will
execute as long as <TT><FONT FACE="Courier">count</FONT></TT>
is non-zero. However, a Java <TT><FONT FACE="Courier">while</FONT></TT>
loop must be formed according to the following syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while (booleanExpression)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;statement</FONT></TT>
</BLOCKQUOTE>
<P>
What this means is that statements like <TT><FONT FACE="Courier">while(count)</FONT></TT>
do not work in Java because there is no automatic coercion of
an integer (such as <TT><FONT FACE="Courier">count</FONT></TT>)
to the <TT><FONT FACE="Courier">boolean</FONT></TT> that a Java
<TT><FONT FACE="Courier">while</FONT></TT> loop expects. You need
to rewrite the C++ code fragment to work in Java as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count=10;<BR>
while (count &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// use count to do something<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count-;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This creates a Boolean expression that is evaluated on each pass
through the loop. You will need to make similar adjustments with
the Java <TT><FONT FACE="Courier">for</FONT></TT> and <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loops, as well.
<H3><A NAME="Operators">Operators</A></H3>
<P>
The set of operators supported by Java is nearly identical to
the set supported by C++. Although the operators perform nearly
identical operations in the two languages, there are several relevant
differences. Table 4.2 shows the Java operators on Boolean values.
The contents of this table should be instantly recognizable because
each operator is also available in C++.<BR>
<P>
<CENTER><B>Table 4.2. Operators on Boolean values.</B></CENTER>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Operator</I></TD><TD WIDTH=130><I>Operation</I>
</TD><TD WIDTH=186><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!</FONT></TT></TD><TD WIDTH=130>Negation
</TD><TD WIDTH=186><TT><FONT FACE="Courier">!a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;&amp;</FONT></TT>
</TD><TD WIDTH=130>Conditional <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &amp;&amp; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">||</FONT></TT></TD>
<TD WIDTH=130>Conditional <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a || b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">?:</FONT></TT></TD>
<TD WIDTH=130>Conditional</TD><TD WIDTH=186><TT><FONT FACE="Courier">a ? expr1 : expr2</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
These operators are worth singling out because they operate only
on Java <TT><FONT FACE="Courier">boolean</FONT></TT> types. For
example, consider the following C++ fragment:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int x = 1;<BR>
int y = 7;<BR>
if (x &amp;&amp; y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This same statement is illegal in Java. Because the <TT><FONT FACE="Courier">&amp;&amp;</FONT></TT>
operator expects two <TT><FONT FACE="Courier">boolean</FONT></TT>
operands and there is no automatic coercion from an integer, the
Java compiler does not know how to interpret this statement. In
Java, it needs to be rewritten as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int x = 1;<BR>
int y = 7;<BR>
if (x != 0 &amp;&amp; y != 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the two integer values have been converted into
explicit tests. Because these tests are Boolean expressions, the
code can now be compiled.
<P>
Java also introduces two new operators, <TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT>
and <TT><FONT FACE="Courier">&gt;&gt;&gt;=</FONT></TT>. Each of
these performs a right shift with zero fill. The latter also will
perform an assignment after the shift.
<P>
Another difference between operators in Java and C++ is that Java
operators cannot be overloaded. Initially, operator overloading
was an exciting feature of C++ that promised to allow programmers
to treat all data types, whether primitive or not, equivalently.
The reasoning went that if there was a logically intuitive action
that should be performed by an operator, then the language should
support overloading the operator to perform that action. Unfortunately,
reality intervened, and many uses of operator overloading in C++
have led to unnecessary bugs. Because of the potential for introducing
bugs through operator overloading, the developers of Java wisely
chose to leave it out.
<H3><A NAME="Pointers">Pointers</A></H3>
<P>
If you've been programming in C or C++ for any significant amount
of time, you probably mastered pointers a long time ago. You know
how to use pointers to characters, integers, structures, classes,
and probably even functions. Mastering the concept of pointers
has long been a rite of passage in C and C++ programming. Pointers
are behind much of the power and flexibility of C++. Unfortunately,
pointers are also behind much of the complexity and bugs in C++
programs. So, with both regret and rejoicing, you can say farewell
to pointers.
<P>
Java does not have a pointer type of any sort. When an object
or array is passed to a method, it is passed by reference, rather
than by value. However, a Java program still cannot access it
as a pointer or memory location.
<P>
By removing pointers from Java, the language has been greatly
simplified over C and C++. However, an additional benefit is that
removing pointers is consistent with the design goals of Java
that it be a secure environment. By removing the ability to create
a pointer directly into a system's memory, a language goes a long
way toward preventing the use of the language for writing deviant
programs such as viruses.
<H3><A NAME="StructuresandUnions">Structures and Unions</A></H3>
<P>
One of the unfortunate problems with C++ has been its support
for compiling legacy, or pre-existing, C code. Of course, this
probably also has been the key reason that C++ has gained the
widespread acceptance that it has. The drawback to continuing
to provide support for pre-existing code is that it muddies the
language, allowing and sometimes forcing programmers to create
new code that is more difficult to understand than would otherwise
be necessary.
<P>
Because C++ added to C the ability to define classes, it made
superfluous the need to define structures and unions. Because
Java is a new language with no requirement to support an existing
base of code, its object model is much cleaner. In Java, you define
classes. The C concepts of <TT><FONT FACE="Courier">struct</FONT></TT>
and <TT><FONT FACE="Courier">union</FONT></TT> have been removed.
<H3><A NAME="Arrays">Arrays</A></H3>
<P>
Like C and C++, Java uses square brackets (<TT><FONT FACE="Courier">[]</FONT></TT>)
to declare and access arrays. However, when declaring an array
in Java, there are two important differences from declaring an
array in C or C++, as follows:
<UL>
<LI><FONT COLOR=#000000>The square brackets (</FONT><TT><FONT FACE="Courier">[]</FONT></TT>)
can be placed either before or after the variable name.
<LI><FONT COLOR=#000000>The size of the array is not specified
within the square brackets at the time the array is declared.</FONT>
</UL>
<P>
To see the effect of these differences, consider the following
array declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[];<BR>
float floatArray[];<BR>
double [] doubleArray;<BR>
char charArray[];</FONT></TT>
</BLOCKQUOTE>
<P>
In these examples, there is no difference between these arrays
based on where the brackets are located. As a C++ programmer,
you may be inclined to continue placing them after the variable
name. However, there is an advantage to changing your habits and
placing the brackets <I>before</I> the variable name. Placing
the brackets in front of the variable name allows you to more
easily declare multiple arrays. For example, consider the following
declaration:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int [] firstArray, secondArray;</FONT></TT>
</BLOCKQUOTE>
<P>
This statement will declare two arrays of integers. Depending
on your perspective, you may find it more intuitive and readable
than the following more C-like version:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int firstArray[], secondArray[];</FONT></TT>
</BLOCKQUOTE>
<H4>Allocation</H4>
<P>
Of course, in C++ you must specify the size or dimension of the
array. In Java, this is not necessary (or even allowed) because
Java requires that all arrays be allocated with <TT><FONT FACE="Courier">new</FONT></TT>.
It is not possible in Java to allocate the equivalent of a C automatic
array. To allocate an array using <TT><FONT FACE="Courier">new</FONT></TT>,
you would use code similar to that shown in the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = new int[100];<BR>
float floatArray[];<BR>
floatArray = new float[100];<BR>
long [] longArray = new long[100];<BR>
double [][] doubleArray = new double[10][10];</FONT></TT>
</BLOCKQUOTE>
<P>
From these examples, you can see that memory can be allocated
on the same line on which the array is declared, as was done with
<TT><FONT FACE="Courier">intArray</FONT></TT>. Or, the array can
be declared and allocated on two separate lines, as with <TT><FONT FACE="Courier">floatArray</FONT></TT>.
The variable <TT><FONT FACE="Courier">doubleArray</FONT></TT>
shows how to declare and allocate a multidimensional array in
Java. In this case, a two-dimensional array is allocated. This
is really an array of arrays in which each of 10 first dimension
arrays contains its own array of 10 items.
<P>
An alternative way of allocating a Java array is to specify a
list of element initializers when the array is declared. This
is done as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = {1,2,3,4,5};<BR>
char [] charArray = {'a', 'b', 'c'};<BR>
String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;,
&quot;Array&quot;};</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, <TT><FONT FACE="Courier">intArray</FONT></TT> will
be a five-element array holding the values <TT><FONT FACE="Courier">1</FONT></TT>
through <TT><FONT FACE="Courier">5</FONT></TT>. The three-element
array <TT><FONT FACE="Courier">charArray</FONT></TT> will hold
the characters <TT><FONT FACE="Courier">'a'</FONT></TT>, <TT><FONT FACE="Courier">'b'</FONT></TT>,
and <TT><FONT FACE="Courier">'c'</FONT></TT>. Finally, <TT><FONT FACE="Courier">stringArray</FONT></TT>
will hold the four strings shown.
<H4>Array Access</H4>
<P>
You can access items in an array in the same way you would do
in C++, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int ages[] = {16, 18, 21, 65};<BR>
<BR>
int canDrive = intArray[0];&nbsp;&nbsp;&nbsp;&nbsp;// can drive
at 16<BR>
int canVote = intArray[1];&nbsp;&nbsp;&nbsp;&nbsp; // can vote
at 18<BR>
int canDrink = intArray[2];&nbsp;&nbsp;&nbsp;&nbsp;// can drink
at 21<BR>
int canRetire = intArray[3];&nbsp;&nbsp;&nbsp;// can retire at
65</FONT></TT>
</BLOCKQUOTE>
<P>
In C++, you could even take this further and access elements outside
the bounds of the array. Most of the time when you did this, however,
it was accidental and caused unexpected program behavior like
crashes and rebooting. Fortunately, Java protects you against
this by only allowing access to allocated array elements. Java
will throw the <TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>
exception if you try to access an element beyond the bounds of
the array.
<H2><A NAME="AutomaticMemoryManagement"><FONT SIZE=5 COLOR=#FF0000>Automatic
Memory Management</FONT></A></H2>
<P>
Unless you're the manufacturer of one of the many debugging aids
targeted at helping programmers find memory leaks, you have to
be excited at the prospect of automatic memory management. Java's
automatic memory management features mean that you no longer have
to keep track of allocated memory and then explicitly free that
memory.
<P>
Although memory for an object is still allocated with <TT><FONT FACE="Courier">new</FONT></TT>,
there is no corresponding <TT><FONT FACE="Courier">delete</FONT></TT>
that must be used to release memory. What happens instead is that
the Java memory manager keeps track of which memory is in use,
and once there are no objects referencing a particular area of
memory, that memory is automatically released and available for
reuse. This is very similar to the way C++ automatic variables
are released once they go out of scope.
<P>
With automatic memory management (usually known as <I>garbage
collection</I>), you will find yourself able to write programs
more quickly and with fewer bugs.
<H2><A NAME="Classes"><FONT SIZE=5 COLOR=#FF0000>Classes</FONT></A>
</H2>
<P>
The design of Java's object model and its support for classes
was certainly influenced by C++. However, Java classes borrow
less from C++ than do many other aspects of Java and its syntax.
Although classes are undeniably important in C++, classes are
mandatory and central to all that you will do in Java. In Java,
there are no free-standing variables or functions. Everything
must be encapsulated within a class. Further, every class in Java
can trace back through its inheritance hierarchy and find itself
a descendant of the <TT><FONT FACE="Courier">Object</FONT></TT>
class. In order to understand Java classes, consider the following
class definition:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanVote() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanDrink(int legalAge)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
legalAge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
You'll notice from the definition of <TT><FONT FACE="Courier">Employee</FONT></TT>
that Java classes support the familiar concepts of <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">protected</FONT></TT>, and <TT><FONT FACE="Courier">public</FONT></TT>
members. However, in Java, members are not grouped into <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">public</FONT></TT>, or <TT><FONT FACE="Courier">protected</FONT></TT>
sections as they typically are in C++. In the <TT><FONT FACE="Courier">Employee</FONT></TT>
class, each member had its access control modifier specified right
with the type and name of the member. Although you may consider
this a little more typing, it definitely makes the code more readable,
and therefore easier to maintain, if you don't have to read backwards
through the file to find out if a class member is accessible.
<P>
Each of the familiar <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">protected</FONT></TT>, and <TT><FONT FACE="Courier">public</FONT></TT>
access control modifiers has the same meaning in Java that it
has in C++. Additionally, however, Java has a fourth level of
access control that is used as the default. If no access control
modifier is specified for a member, that member is accessible
throughout the package in which it is defined, but nowhere else.
<P>
A Java package shares attributes of a C++ library, a C++ source
file, and a C++ header file. Java code is shared at the package
level and a package contains the definitions and source code implementations
of one or more classes.
<H3><A NAME="MemberMethods">Member Methods</A></H3>
<P>
Returning to the definition of the <TT><FONT FACE="Courier">Employee</FONT></TT>
class, you can also see that both the <TT><FONT FACE="Courier">CanVote</FONT></TT>
and <TT><FONT FACE="Courier">CanDrink</FONT></TT> methods were
written directly in the class definition without using the C++
<TT><FONT FACE="Courier">inline</FONT></TT> keyword. In Java,
there is no concept that is analogous to the C++ header file.
Each class is defined, and its methods are written in the same
place. Because of this, Java does not need an <TT><FONT FACE="Courier">inline</FONT></TT>
keyword, yet all methods are written as you would write a C++
inline function.
<H3><A NAME="SettingDefaultValues">Setting Default Values</A>
</H3>
<P>
It's always the little things that make a difference. One little
thing that makes a tremendous convenience improvement in Java
over C++ is the ability to set a default value for a member variable
at the time it is declared. For example, consider the following
definition of the <TT><FONT FACE="Courier">Employee</FONT></TT>
class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age = 21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the member variable age is declared and is given
a default value of 21. In C++, this would have been done in the
constructor. There are two advantages to setting a default value
at the point where the variable is declared:
<UL>
<LI><FONT COLOR=#000000>The code becomes more readable because
the default value cannot be missed when reading the code.</FONT>
<LI><FONT COLOR=#000000>If the class uses more than one constructor
that would have set the variable to its default, these constructors
are simplified by not having to set the default</FONT> value.
</UL>
<H3><A NAME="StaticMembers">Static Members</A></H3>
<P>
In addition to class methods and variables that are associated
with each instance of a class, a Java class can contain members
that are associated with the class itself. Just as in C++, these
are known as static members and are identified with the <TT><FONT FACE="Courier">static</FONT></TT>
keyword as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;static double maxSalary = 1000000D;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the member variable <TT><FONT FACE="Courier">maxSalary</FONT></TT>
will exist once in the entire program, as opposed to once per
instance of the class. Additionally, <TT><FONT FACE="Courier">maxSalary</FONT></TT>
has been set to an initial value of $1,000,000.
<H3><A NAME="ConstructorsandDestructors">Constructors and Destructors</A>
</H3>
<P>
Each Java class you define may include one or more constructors.
Just as in C++, the constructor is given the same name as the
class. Java class constructors have no return value and are declared
in the same manner as any other class method. This can be seen
in the following <BR>
example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Employee(String fName, String lName)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = fName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = lName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanVote() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanDrink(int legalAge)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
legalAge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Because Java includes a garbage collection feature for the automatic
release of unreferenced memory, the role of destructors is much
smaller than it is in C++. In C++, a destructor is necessary so
that it can free any memory allocated by the object. Because of
Java's automatic memory management, destructors are no longer
needed to perform this job.
<P>
For these reasons, Java classes do not include C++ style destructors.
Instead, each Java class can include a <TT><FONT FACE="Courier">finalize</FONT></TT>
method that can be used to perform any object cleanup. The <TT><FONT FACE="Courier">finalize</FONT></TT>
method is declared in the <TT><FONT FACE="Courier">Object</FONT></TT>
class, but because <TT><FONT FACE="Courier">Object</FONT></TT>
is the ultimate base class of all Java classes, <TT><FONT FACE="Courier">finalize</FONT></TT>
is available to every Java class. There is one danger, however,
to consider when using <TT><FONT FACE="Courier">finalize</FONT></TT>.
It is possible for a Java program to terminate without this method
being invoked on every object. If a program terminates with objects
that are still referenced, the garbage collection process will
never be used to release those objects, and <TT><FONT FACE="Courier">finalize</FONT></TT>
will never be called.
<H3><A NAME="Inheritance">Inheritance</A></H3>
<P>
Inheritance in Java is indicated by the use of the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword, as shown in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Employee extends Person
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}<BR>
If a class is derived directly from Object, then the extends keyword
is optional. The following two class declarations are equivalent:
<BR>
public class Person extends Object {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}<BR>
<BR>
public class Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Like C++, Java includes a <TT><FONT FACE="Courier">this</FONT></TT>
keyword that can be used by an object to reference itself. Additionally,
Java includes a <TT><FONT FACE="Courier">super</FONT></TT> keyword
that an object can use to reference its parent, or superclass.
The use of <TT><FONT FACE="Courier">super</FONT></TT> is frequently
seen in the constructor of a subclass, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Person() {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Person(String fName, String lName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = fName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = lName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class Employee extends Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Employee(float sal, String fName, String
lName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(fName, lName);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salary = sal;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">Person</FONT></TT>
class includes a constructor that is passed a first name and a
last name. The <TT><FONT FACE="Courier">Employee</FONT></TT> class
is derived from <TT><FONT FACE="Courier">Person</FONT></TT> and
includes a constructor that is passed salary, first name, and
last name. The constructor for <TT><FONT FACE="Courier">Employee</FONT></TT>
first sets the internal <TT><FONT FACE="Courier">salary</FONT></TT>
member and then uses <TT><FONT FACE="Courier">super</FONT></TT>
to invoke the constructor for Person.
<H4>Abstract Classes</H4>
<P>
The Java version of a pure, virtual class is an abstract class.
Instances of Java abstract classes cannot be created with <TT><FONT FACE="Courier">new</FONT></TT>.
An abstract class is identified by the use of the <TT><FONT FACE="Courier">abstract</FONT></TT>
keyword, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract class Species {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;abstract void GiveBirth();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
A class is considered abstract if it has one or more methods that
are abstract. In the case of the <TT><FONT FACE="Courier">Species</FONT></TT>
class, the method <TT><FONT FACE="Courier">GiveBirth</FONT></TT>
is specified as <TT><FONT FACE="Courier">abstract</FONT></TT>
because some species have live births and others lay eggs. Because
the method is abstract, no method body is given.
<H4>Interfaces and Multiple Inheritance</H4>
<P>
If you design a class that is entirely abstract, then that class
is what Java refers to as an <I>interface</I>. A Java interface
is similar to a class in that it defines a new type that contains
both methods and variables. However, because an interface is completely
abstract, its methods are not implemented within the interface.
Instead, classes that are derived from an interface implement
the methods of the interface.
<P>
An interface is declared in the same manner as a class except
that instead of <TT><FONT FACE="Courier">class</FONT></TT>, the
keyword <TT><FONT FACE="Courier">interface</FONT></TT> is used.
For example, the following code will declare an interface named
<TT><FONT FACE="Courier">Clock</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">interface Clock {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
To derive a class from an interface, use the keyword <TT><FONT FACE="Courier">implements</FONT></TT>
(similar to how <TT><FONT FACE="Courier">extends</FONT></TT> is
used when a class is derived from another class). To derive the
classes <TT><FONT FACE="Courier">Cuckoo</FONT></TT> and <TT><FONT FACE="Courier">Watch</FONT></TT>
from the <TT><FONT FACE="Courier">Clock</FONT></TT> interface,
you would do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Cuckoo implements Clock&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer str
= new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0;
i &lt; hour; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str.append(&quot;Cuckoo
&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return str.toString();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class Watch implements Clock&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new String(&quot;It
is &quot; + hour + &quot;:00&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Java does not support multiple class inheritance. In other words,
a class may have only one immediate superclass because only a
single class name can follow <TT><FONT FACE="Courier">extends</FONT></TT>
in a Java class declaration. Fortunately, class inheritance and
interface inheritance can be combined when deriving a new Java
class. And, a subclass can implement more than one interface.
For example, you can do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class MySubClass extends MySuperClass
implements FirstInterface,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecondInterface
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// class implementation<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ThePreprocessor"><FONT SIZE=5 COLOR=#FF0000>The Preprocessor</FONT></A>
</H2>
<P>
The Java language does not include a preprocessor. Much of the
complexity of C and C++ can be traced back to the preprocessor.
How many times have you read a C++ function and then needed to
trace a defined value or macro back through a hierarchy of headers
in order to understand the function? The preprocessor brought
a lot of flexibility to C and C++, but it also added artificial
complexity.
<P>
Java's removal of the preprocessor means that you will need to
unlearn a couple of old habits. For example, you will no longer
be able to use <TT><FONT FACE="Courier">typedef</FONT></TT> and
<TT><FONT FACE="Courier">#define</FONT></TT>. In Java, you would
instead use classes and constants.
<H2><A NAME="OtherChanges"><FONT SIZE=5 COLOR=#FF0000>Other Changes</FONT></A>
</H2>
<P>
There are a number of additional differences between Java and
C++ beyond those already mentioned in this chapter. This section
will briefly describe some additional differences.
<H3><A NAME="Comments">Comments</A></H3>
<P>
In addition to the <TT><FONT FACE="Courier">//</FONT></TT> and
<TT><FONT FACE="Courier">/*&#133;*/</FONT></TT> comments of C++,
Java introduces a new comment delimiter. Java's new comment delimiter
begins with <TT><FONT FACE="Courier">/**</FONT></TT> and ends
with <TT><FONT FACE="Courier">*/</FONT></TT>. A comment that is
enclosed within these delimiters can be extracted from the source
code and used to create documentation for the class with the JavaDoc
utility. JavaDoc is fully described in <A HREF="ch16.htm" >Chapter 16</A>,
&quot;Using JavaDoc to Document Your Program.&quot;
<H3><A NAME="CommandLineArguments">Command-Line Arguments</A>
</H3>
<P>
In a C or C++ program, the program is passed command-line arguments
in the familiar <TT><FONT FACE="Courier">argc</FONT></TT> and
<TT><FONT FACE="Courier">argv</FONT></TT> parameters to the program's
<TT><FONT FACE="Courier">main</FONT></TT> function. These parameters
represent a count of the number of parameters and an array of
parameter values, respectively. There will always be at least
one parameter passed to a C or C++ program because the first parameter
is the program name.
<P>
In a Java application, the command-line arguments are based in
an array of <TT><FONT FACE="Courier">String</FONT></TT> objects.
The signature for <TT><FONT FACE="Courier">main</FONT></TT> is
as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static void main(String args[]);</FONT></TT>
</BLOCKQUOTE>
<P>
Each component of the array <TT><FONT FACE="Courier">args</FONT></TT>
is one of the command-line arguments. A difference between C++
and Java is that the program name is not passed to the program
as the first command-line argument in Java. Consider two programs
that are invoked in the following manner:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">For C++: program 100 200<BR>
For Java: java program 100 200</FONT></TT>
</BLOCKQUOTE>
<P>
The command lines of these two programs will be interpreted by
C++ and Java as shown in Table 4.3.<BR>
<P>
<CENTER><B>Table 4.3. Command-line arguments in C++ and Java.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=86><I>Argument</I></TD><TD WIDTH=90><I>C++</I></TD>
<TD WIDTH=90><I>Java</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=86>program</TD><TD WIDTH=90><TT><FONT FACE="Courier">argv[0]</FONT></TT>
</TD><TD WIDTH=90>(none)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=86>100</TD><TD WIDTH=90><TT><FONT FACE="Courier">argv[1]</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">args[0]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=86>200</TD><TD WIDTH=90><TT><FONT FACE="Courier">argv[2]</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">args[1]</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="CharacterArraysandStrings">Character Arrays and Strings</A>
</H3>
<P>
Because Java does not allow direct manipulation of pointers, it
does not support C-style, null-terminated strings. For its string
support, Java utilizes a <TT><FONT FACE="Courier">String</FONT></TT>
class. Although it is possible to allocate an array of type <TT><FONT FACE="Courier">char</FONT></TT>
to emulate a C++ string, the two types are not the same.
<H3><A NAME="gotobreakandcontinue"><TT><FONT SIZE=4 FACE="Courier">goto,
break</FONT></TT><FONT SIZE=4>, and </FONT><TT><FONT SIZE=4 FACE="Courier">continue</FONT></TT></A>
</H3>
<P>
You probably won't shed any tears, but the <TT><FONT FACE="Courier">goto</FONT></TT>
statement is not part of Java. On the other hand, it is still
part of the reserved word list so it may come back at any time.
Java does replace <TT><FONT FACE="Courier">goto</FONT></TT>, however,
with the ability to use <TT><FONT FACE="Courier">break</FONT></TT>
and <TT><FONT FACE="Courier">continue</FONT></TT> with labels.
You can still use <TT><FONT FACE="Courier">break</FONT></TT> and
<TT><FONT FACE="Courier">continue</FONT></TT> as you are used
to from C++, but you can now use them to pass control flow in
other ways. For example, consider the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int line=1;<BR>
<BR>
outsideLoop:<BR>
for(int out=0; out&lt;3; out++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(int inner=0;inner &lt; 5; inner++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (foo(inner)
&lt; 10))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (foo(inner)
&gt; 100)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, if the <TT><FONT FACE="Courier">foo</FONT></TT>
method returns a value less than 10, the code <TT><FONT FACE="Courier">break
outsideLoop</FONT></TT> will execute. A normal <TT><FONT FACE="Courier">break</FONT></TT>
here would break out of the inner loop. However, because this
is a named <TT><FONT FACE="Courier">break</FONT></TT> statement,
it will break out of the named outer loop. This example also demonstrates
the use of <TT><FONT FACE="Courier">continue</FONT></TT> with
a label.
<H3><A NAME="RuntimeTypeIdentification">Runtime Type Identification</A>
</H3>
<P>
Runtime Type Identification (RTTI) is a relatively new feature
to C++, or at least to many C++ compilers. A form of RTTI is included
in Java through its <TT><FONT FACE="Courier">instanceof</FONT></TT>
keyword.
<H3><A NAME="MissingFeatures">Missing Features</A></H3>
<P>
As you begin programming in Java, you will notice that it is missing
a couple of other aspects of C++ that you may use. In most cases,
there is either no need for the feature in Java, due to its simplified
model for object-oriented programming, or there is an alternative
way of accomplishing the goal.
<P>
Features left out of Java that you may rely on in C++ include
templates, name spaces, friend functions, and default parameters.
In many cases, you will find that these old friends are no longer
necessary in Java, or, at least, that their removal is justified
by how much doing so simplifies the rest of your code.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covered quite a lot of territory. Building on your
background in C++, you learned how Java differs from C++ in regard
to data types, operators, memory management, and classes. You
learned how Java simplifies programming by removing those features
of C++ that are likely to introduce bugs. You also learned how
Java enables you to continue creating the powerful programs you
are used to in C++.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch5.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>


<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
