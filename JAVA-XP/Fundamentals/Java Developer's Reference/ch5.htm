<HTML>

<HEAD>
   <TITLE>Chapter 5 -- Java for Delphi Programmers</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 5</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Java for Delphi Programmers</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#Comments" >Comments</A>
<LI><A HREF="#TheEndofbeginandend" >The End of begin and end</A>
<LI><A HREF="#DataTypes" >Data Types</A>
<UL>
<LI><A HREF="#DeclaringVariables" >Declaring Variables</A>
<LI><A HREF="#PrimitiveTypes" >Primitive Types</A>
<LI><A HREF="#Casting" >Casting</A>
<LI><A HREF="#Operators" >Operators</A>
<LI><A HREF="#Pointers" >Pointers</A>
<LI><A HREF="#Records" >Records</A>
<LI><A HREF="#Arrays" >Arrays</A>
</UL>
<LI><A HREF="#MemoryManagement" >Memory Management</A>
<UL>
<LI><A HREF="#GarbageCollection" >Garbage Collection</A>
</UL>
<LI><A HREF="#Classes" >Classes</A>
<UL>
<LI><A HREF="#MemberMethods" >Member Methods</A>
<LI><A HREF="#SettingDefaultValues" >Setting Default Values</A>
<LI><A HREF="#StaticMembers" >Static Members</A>
<LI><A HREF="#ConstructorsandDestructors" >Constructors and Destructors</A>
<LI><A HREF="#Inheritance" >Inheritance</A>
</UL>
<LI><A HREF="#OtherChanges" >Other Changes</A>
<UL>
<LI><A HREF="#CommandLineArguments" >Command-Line Arguments</A>
<LI><A HREF="#ParenthesesAreRequired" >Parentheses Are Required</A>
<LI><A HREF="#TheJavaforStatement" >The Java for Statement</A>
<LI><A HREF="#gotobreakandcontinue" >goto, break, and continue</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
In many ways, a background in Delphi programming is ideal for
making the move to Java. Although Java is based on C++ and borrows
much of its syntax from C++, in some respects Java is more similar
to the Object Pascal language of Delphi. Although you will have
to adjust to some new syntactic conventions (such as using curly
braces instead of <TT><FONT FACE="Courier">begin</FONT></TT> and
<TT><FONT FACE="Courier">end</FONT></TT>), the object-oriented
programming model of Delphi has a great deal in common with Java.
This chapter will take you through a whirlwind tour of Java, pointing
out the key differences between Java and Object Pascal. On the
way, you'll learn how to translate your Delphi knowledge to Java.
You'll also be exposed to new concepts such as <I>multiple inheritance</I>.
This chapter doesn't attempt to teach you everything you need
to know to be a Java programmer, but it will help you use your
Delphi experience as a first step toward Java.
<H2><A NAME="Comments"><FONT SIZE=5 COLOR=#FF0000>Comments</FONT></A>
</H2>
<P>
In order to make the code samples in this chapter as understandable
as possible, it is useful to include comments. So, this chapter
starts right off with an overview of Java comments. Java supports
three comment delimiters, as shown in Table 5.1.<BR>
<P>
<CENTER><B>Table 5.1. Java comment delimiters.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=52><I>Start</I></TD><TD WIDTH=64><I>End</I></TD>
<TD WIDTH=474><I>Purpose</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">/*</FONT></TT></TD>
<TD WIDTH=64><TT><FONT FACE="Courier">*/</FONT></TT></TD><TD WIDTH=474>The enclosed text is treated as a comment.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">//</FONT></TT></TD>
<TD WIDTH=64>(none)</TD><TD WIDTH=474>The rest of the line is treated as a comment.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">/**</FONT></TT></TD>
<TD WIDTH=64><TT><FONT FACE="Courier">*/</FONT></TT></TD><TD WIDTH=474>The enclosed text is treated as a comment by the compiler but is used by JavaDoc to automatically generate documentation.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
If you've been exposed to C or C++ at all, you may already be
familiar with the first two comment styles. The third is new to
Java. The <TT><FONT FACE="Courier">//</FONT></TT> comment delimiter
is very useful when placed to the right of a line of code. The
<TT><FONT FACE="Courier">/*</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT>
delimiters are most frequently used to indicate that a block of
lines is a comment. As examples of how these comment delimiters
can be used, consider the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print(&quot;hello&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//
this is a comment to the end of the line<BR>
/* this is a comment also */<BR>
/* this is a comment that<BR>
takes up multiple lines */<BR>
/** this is a comment that generates documentation.<BR>
It can be as many lines as desired. */</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheEndofbeginandend"><FONT SIZE=5 COLOR=#FF0000>The
End of </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">begin</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
and </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">end</FONT></TT></A>
</H2>
<P>
With Java, you will say good-bye to your old friend keywords <TT><FONT FACE="Courier">begin</FONT></TT>
and <TT><FONT FACE="Courier">end</FONT></TT>. They are replaced
by the more C-like curly braces, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (x == y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something else<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
As with Object Pascal, if a block is comprised of only a single
line, then the curly braces are optional, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (x == y)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
<BR>
if (x == y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// do something<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="DataTypes"><FONT SIZE=5 COLOR=#FF0000>Data Types</FONT></A>
</H2>
<P>
Built into Delphi's Object Pascal language is a very broad set
of data types. Many of Delphi's data types exist to provide compatibility
with either prior versions of Borland's Turbo Pascal predecessor
to Delphi or with Microsoft Windows. This section describes the
Java primitive types and discusses the differences between them
and their Delphi equivalents.
<H3><A NAME="DeclaringVariables">Declaring Variables</A></H3>
<P>
Variable declarations in Java are the complete opposite of what
you are used to in Delphi. A Java declaration consists of the
variable type followed by its name. For example, consider the
following declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int anInt;<BR>
int anotherInt = 42;<BR>
long thisIsALong = 100, secondLong;<BR>
float myFloat = 3.49f;<BR>
double myDouble = 3.1416D;</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see from these examples, more than one variable can
be declared on a line. Additionally, an initial value can be assigned
to a variable as was done, for example, by assigning <TT><FONT FACE="Courier">42</FONT></TT>
to <TT><FONT FACE="Courier">anotherInt</FONT></TT>. In the case
of <TT><FONT FACE="Courier">float</FONT></TT> or <TT><FONT FACE="Courier">double</FONT></TT>
variables, the type of the variable can be specified by appending
an upper- or lowercase F (for <TT><FONT FACE="Courier">float</FONT></TT>)
or D (for <TT><FONT FACE="Courier">double</FONT></TT>) to the
initial value.
<P>
The best news about declaring a variable in Java is that it does
not need to be done in a special <TT><FONT FACE="Courier">var</FONT></TT>
section. Anywhere you need a new variable, you simply declare
it. It can be at the start of a method or even in the middle of
a method.
<H3><A NAME="PrimitiveTypes">Primitive Types</A></H3>
<P>
A language's primitive types are the building blocks from which
more complicated types (such as classes) are built. Java supports
a set of eight primitive types, which are shown in Table 5.2.
<BR>
<P>
<CENTER><B>Table 5.2. Java primitive types.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=90><I>Type</I></TD><TD WIDTH=206><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=206>8-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=206>16-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=206>32-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=206>64-bit signed integer</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">float</FONT></TT></TD>
<TD WIDTH=206>32-bit floating-point number</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">double</FONT></TT></TD>
<TD WIDTH=206>64-bit floating-point number</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">char</FONT></TT></TD>
<TD WIDTH=206>16-bit Unicode characters</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">boolean</FONT></TT>
</TD><TD WIDTH=206>Can hold <TT><FONT FACE="Courier">true</FONT></TT> or <TT><FONT FACE="Courier">false</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
From Table 5.2, you can see that Java uses a shorter version of
the type names than does Delphi. For example, Delphi has <TT><FONT FACE="Courier">shortint</FONT></TT>
and <TT><FONT FACE="Courier">longint</FONT></TT>, whereas Java
has <TT><FONT FACE="Courier">short</FONT></TT> and <TT><FONT FACE="Courier">long</FONT></TT>.
However, behind these cosmetic changes are some substantive changes.
For example, each of the similarly named integer types in Delphi
is bigger in Java. A Delphi <TT><FONT FACE="Courier">Integer</FONT></TT>
is a 16-bit signed value and corresponds to a Java <TT><FONT FACE="Courier">short</FONT></TT>.
Table 5.3 is useful for converting between Delphi and Java integer
variables.<BR>
<P>
<CENTER><B>Table 5.3. Delphi primitive types and their Java equivalents.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=99><I>Delphi</I></TD><TD WIDTH=70><I>Java</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">ShortInt</FONT></TT>
</TD><TD WIDTH=70><TT><FONT FACE="Courier">byte</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Integer</FONT></TT>
</TD><TD WIDTH=70><TT><FONT FACE="Courier">short</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">LongInt</FONT></TT>
</TD><TD WIDTH=70><TT><FONT FACE="Courier">int</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Byte</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">byte</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=99><TT><FONT FACE="Courier">Word</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">int</FONT></TT></TD></TR>
</TABLE></CENTER>
<P>
<P>
All variables in Java are signed. Because of this, the Delphi
unsigned types (<TT><FONT FACE="Courier">Word</FONT></TT> and
<TT><FONT FACE="Courier">Byte</FONT></TT>) are replaced with Java
signed types large enough to hold their largest values. Because
Java provides Unicode support, you should notice that its <TT><FONT FACE="Courier">char</FONT></TT>
type is 16 bits wide. This is also why the 8-bit <TT><FONT FACE="Courier">byte</FONT></TT>
type is included as a primitive.
<P>
The Java and Delphi <TT><FONT FACE="Courier">boolean</FONT></TT>
types are similar. However, with Delphi it is possible to perform
some operations on Boolean values that are not possible in Java.
For example, in Delphi the following comparison will evaluate
to true, but will be a compile error in Java:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">false &lt; true</FONT></TT>
</BLOCKQUOTE>
<P>
The Object Pascal language of Delphi also includes a <TT><FONT FACE="Courier">String</FONT></TT>
primitive type. Although Java does not include a <TT><FONT FACE="Courier">String</FONT></TT>
primitive, it does include a full-featured <TT><FONT FACE="Courier">String</FONT></TT>
class that will provide many of the same capabilities you are
used to from Delphi's <TT><FONT FACE="Courier">String</FONT></TT>
primitive. An important difference between strings in Java and
Delphi is that Java strings are enclosed in double quotes (<TT><FONT FACE="Courier">&quot;</FONT></TT>),
not single quotes (<TT><FONT FACE="Courier">'</FONT></TT>). In
Java, a single character is enclosed within single quotes. For
example, consider the following valid Java declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String str = &quot;This is a string&quot;;
<BR>
char ch = 'a';</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="Casting">Casting</A></H3>
<P>
In both Java and Delphi, it is possible to cast a variable from
one type to another. Both languages are strongly typed, but Java
is more restrictive and doesn't allow some casts that Delphi does.
For example, in Java you cannot cast between a <TT><FONT FACE="Courier">boolean</FONT></TT>
and a <TT><FONT FACE="Courier">numeric</FONT></TT> type. This
means you cannot do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean aBool = false;&nbsp;&nbsp;&nbsp;&nbsp;//
not legal in Java<BR>
int anInt = (int)aBool;&nbsp;&nbsp;&nbsp;// not legal in Java</FONT></TT>
</BLOCKQUOTE>
<P>
Delphi assumes that a Boolean value <TT><FONT FACE="Courier">false</FONT></TT>
can be translated to zero and <TT><FONT FACE="Courier">true</FONT></TT>
can be translated to one. This is not true in Java. In Java, a
Boolean is a Boolean and it cannot be cast into an integer value.
<H4>Automatic Coercions</H4>
<P>
Related to casting is the concept of <I>automatic coercion</I>.
Automatic coercion occurs when a compiler <I>coerces</I>, or casts,
a variable of one type into another automatically. For example,
consider the following Delphi code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">var<BR>
&nbsp;&nbsp;&nbsp;&nbsp;anInt : integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;aLong : longint;<BR>
begin<BR>
&nbsp;&nbsp;&nbsp;&nbsp;aLong := 65536;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;anInt := aLong;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;MessageDlg('anInt is ' + IntToStr(anInt),
mtInformation, [mbYes, mbNo], 0);<BR>
end;</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">65536</FONT></TT>
stored in <TT><FONT FACE="Courier">aLong</FONT></TT> is also placed
into <TT><FONT FACE="Courier">anInt</FONT></TT>. Because no explicit
cast is performed, an automatic coercion from a <TT><FONT FACE="Courier">longint</FONT></TT>
to an <TT><FONT FACE="Courier">integer</FONT></TT> is performed.
Unfortunately, this will result in an error because the value
in <TT><FONT FACE="Courier">aLong</FONT></TT> is too large to
fit in <TT><FONT FACE="Courier">anInt</FONT></TT>. The automatic
coercion will place <TT><FONT FACE="Courier">0</FONT></TT> into
<TT><FONT FACE="Courier">anInt</FONT></TT> instead of the desired
<TT><FONT FACE="Courier">65536</FONT></TT>. Java avoids the problems
caused by automatic coercion by not allowing it.
<H3><A NAME="Operators">Operators</A></H3>
<P>
The Java language contains a richer set of operators than does
Delphi. Fortunately, many of the Java operators correspond to
similar operators in Delphi. Table 5.4 shows each of the Java
operators, the operation it performs, and an example of its use.
<BR>
<P>
<CENTER><B>Table 5.4. Operators on Boolean values.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=278><I>Operation</I>
</TD><TD WIDTH=186><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=278>Assignment
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a = b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=278>Greater than</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=278>Less than</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &lt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=278>Less than or equal to</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &lt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=278>Greater than or equal to</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=278>Equal to</TD><TD WIDTH=186><TT><FONT FACE="Courier">a == b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=278>Not equal to</TD><TD WIDTH=186><TT><FONT FACE="Courier">a != b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!</FONT></TT></TD><TD WIDTH=278>Boolean negation
</TD><TD WIDTH=186><TT><FONT FACE="Courier">!a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=278>Bitwise logical negation
</TD><TD WIDTH=186><TT><FONT FACE="Courier">~a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">?:</FONT></TT></TD>
<TD WIDTH=278>Conditional operators</TD><TD WIDTH=186><TT><FONT FACE="Courier">a ? expr1 : expr2</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;&amp;</FONT></TT>
</TD><TD WIDTH=278>Conditional <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &amp;&amp; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">||</FONT></TT></TD>
<TD WIDTH=278>Conditional <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a || b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=278>Increment</TD><TD WIDTH=186><TT><FONT FACE="Courier">a++</FONT></TT> or <TT><FONT FACE="Courier">++a</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=278>Decrement</TD><TD WIDTH=186><TT><FONT FACE="Courier">a--</FONT></TT> or <TT><FONT FACE="Courier">--a</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=278>Addition
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a + b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=278>Subtraction
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a - b</FONT></TT> or <TT><FONT FACE="Courier">-b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=278>Multiplication
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a * b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=278>Division
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a / b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=278>Modulus
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a % b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;</FONT></TT></TD>
<TD WIDTH=278>Bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &amp; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">|</FONT></TT></TD><TD WIDTH=278>Bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a | b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">^</FONT></TT></TD><TD WIDTH=278>Bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a ^ b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;&lt;</FONT></TT>
</TD><TD WIDTH=278>Left shift</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &lt;&lt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;</FONT></TT>
</TD><TD WIDTH=278>Right shift</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt;&gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT>
</TD><TD WIDTH=278>Right shift with zero fill</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt;&gt;&gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+=</FONT></TT></TD>
<TD WIDTH=278>Assign result of addition</TD><TD WIDTH=186><TT><FONT FACE="Courier">a += b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-=</FONT></TT></TD>
<TD WIDTH=278>Assign result of subtraction</TD><TD WIDTH=186><TT><FONT FACE="Courier">a -= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*=</FONT></TT></TD>
<TD WIDTH=278>Assign result of multiplication</TD><TD WIDTH=186><TT><FONT FACE="Courier">a *= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/=</FONT></TT></TD>
<TD WIDTH=278>Assign result of division</TD><TD WIDTH=186><TT><FONT FACE="Courier">a /= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;=</FONT></TT></TD>
<TD WIDTH=278>Assign result of bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &amp;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">|=</FONT></TT></TD>
<TD WIDTH=278>Assign result of bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a |= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">^=</FONT></TT></TD>
<TD WIDTH=278>Assign result of bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a ^= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%=</FONT></TT></TD>
<TD WIDTH=278>Assign result of modulus</TD><TD WIDTH=186><TT><FONT FACE="Courier">a %= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;&lt;=</FONT></TT>
</TD><TD WIDTH=278>Assign result of left shift</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &lt;&lt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;=</FONT></TT>
</TD><TD WIDTH=278>Assign result of right shift</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt;&gt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;=</FONT></TT>
</TD><TD WIDTH=278>Assign result of right shift with zero fill
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &gt;&gt;&gt;= b</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
One of the biggest adjustments you'll need to make will be getting
used to using a lone equal sign for assignment instead of the
<TT><FONT FACE="Courier">:=</FONT></TT> of Delphi. Because <TT><FONT FACE="Courier">=</FONT></TT>
is used for assignment, two equal signs (<TT><FONT FACE="Courier">==</FONT></TT>)
are used for testing equality in Java. You can see this in the
following Java example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int x, y;&nbsp;&nbsp;&nbsp;&nbsp;// declare
two integer variables<BR>
x = 43;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// assign a value to
x<BR>
y = 42;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// assign a different
value to y<BR>
if (x == y)&nbsp;&nbsp;// do something</FONT></TT>
</BLOCKQUOTE>
<P>
In Delphi, the four keywords <TT><FONT FACE="Courier">not</FONT></TT>,
<TT><FONT FACE="Courier">and</FONT></TT>, <TT><FONT FACE="Courier">or</FONT></TT>,
and <TT><FONT FACE="Courier">xor</FONT></TT> each had two meanings.
Each could function as a bitwise operator as well as a Boolean
operator. This had a tendency to make code more difficult to read
and maintain than it needed to be. Java simplifies this by having
each operator perform a unique operation. To find the Java equivalent
for the Delphi <TT><FONT FACE="Courier">not</FONT></TT>, <TT><FONT FACE="Courier">and</FONT></TT>,
<TT><FONT FACE="Courier">or</FONT></TT>, and <TT><FONT FACE="Courier">xor</FONT></TT>
operators, see Table 5.5.<BR>
<P>
<CENTER><B>Table 5.5. The Java equivalents of Delphi's </B><TT><B><FONT FACE="Courier">not</FONT></B></TT><B>,
</B><TT><B><FONT FACE="Courier">and</FONT></B></TT><B>, </B><TT><B><FONT FACE="Courier">or</FONT></B></TT><B>,
and </B><TT><B><FONT FACE="Courier">xor</FONT></B></TT><B> operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=66><I>Delphi</I></TD><TD WIDTH=51><I>Java</I></TD>
<TD WIDTH=134><I>Operation</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">and</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">&amp;</FONT></TT></TD><TD WIDTH=134>Bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">or</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">|</FONT></TT></TD><TD WIDTH=134>Bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">xor</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">^</FONT></TT></TD><TD WIDTH=134>Bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">not</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=134>Bitwise negation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">and</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">&amp;&amp;</FONT></TT></TD>
<TD WIDTH=134>Conditional <TT><FONT FACE="Courier">AND</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">or</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">||</FONT></TT></TD><TD WIDTH=134>Conditional <TT><FONT FACE="Courier">OR</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=66><TT><FONT FACE="Courier">not</FONT></TT></TD>
<TD WIDTH=51><TT><FONT FACE="Courier">!</FONT></TT></TD><TD WIDTH=134>Boolean negation
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Java includes increment and decrement operators that are extremely
useful. In order to increment a variable, use the <TT><FONT FACE="Courier">++</FONT></TT>
operator. In order to decrement a variable, use the <TT><FONT FACE="Courier">--</FONT></TT>
operator. These operators can be used in either prefix or postfix
mode, as shown in the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x++;<BR>
--y;<BR>
int z = 100;<BR>
MyMethod(z++);</FONT></TT>
</BLOCKQUOTE>
<P>
In the case of <TT><FONT FACE="Courier">x</FONT></TT>, the code
<TT><FONT FACE="Courier">x++</FONT></TT> is equivalent to the
more verbose Delphi <TT><FONT FACE="Courier">x := x+1</FONT></TT>
or <TT><FONT FACE="Courier">Inc(x)</FONT></TT>. The example of
the call to <TT><FONT FACE="Courier">MyMethod</FONT></TT> is illustrative
because it shows a unique aspect of the increment and decrement
operators. The increment of <TT><FONT FACE="Courier">z</FONT></TT>
will happen after the call to <TT><FONT FACE="Courier">MyMethod</FONT></TT>.
This means that <TT><FONT FACE="Courier">z</FONT></TT> will be
passed with a value of <TT><FONT FACE="Courier">100</FONT></TT>.
Once <TT><FONT FACE="Courier">MyMethod</FONT></TT> returns, <TT><FONT FACE="Courier">z</FONT></TT>
will be incremented. If you want to increment <TT><FONT FACE="Courier">z</FONT></TT>
prior to calling <TT><FONT FACE="Courier">MyMethod</FONT></TT>,
the method should have been invoked as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int z = 100;<BR>
MyMethod(++z);</FONT></TT>
</BLOCKQUOTE>
<H4>Special Assignment Operators</H4>
<P>
A special assignment operator sounds like something out of a 1960s
spy movie. Unfortunately, a Java special assignment operator isn't
anything that glamorous. However, special assignment operators
are extremely useful.
<P>
In addition to the usual operators, Java includes a set of operators
that perform an operation and then assign the result of that operation
to one of the operands. Each of these operators is listed in Table
5.4 where you'll notice that each is composed of a different operator
token with an equal sign (<TT><FONT FACE="Courier">=</FONT></TT>)
appended. Most likely, you will use the <TT><FONT FACE="Courier">+=</FONT></TT>,
<TT><FONT FACE="Courier">-=</FONT></TT>, <TT><FONT FACE="Courier">*=</FONT></TT>,
and <TT><FONT FACE="Courier">/=</FONT></TT> operators more frequently
than the others, so consider the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int a, b, c, d;<BR>
a = 5;<BR>
b = 2;<BR>
a += 3;&nbsp;&nbsp;&nbsp;&nbsp;// a now equals 8<BR>
a *= b;&nbsp;&nbsp;&nbsp;&nbsp;// a now equals 16<BR>
a -= 4;&nbsp;&nbsp;&nbsp;&nbsp;// a now equals 12<BR>
a /= b;&nbsp;&nbsp;&nbsp;&nbsp;// a now equals 6</FONT></TT>
</BLOCKQUOTE>
<P>
From this example, you can see that <TT><FONT FACE="Courier">a
+= 3</FONT></TT> is shorthand for the Delphi statement <TT><FONT FACE="Courier">a
:= a + 3</FONT></TT>.
<H3><A NAME="Pointers">Pointers</A></H3>
<P>
Just your luck. You've finally mastered pointers and then you
decide to learn Java-a language that doesn't use pointers. Pointers
can be a very powerful aspect of a language. Unfortunately, pointers
are also frequently behind much of the complexity of the languages
that use them.
<P>
The Object Pascal language of Delphi took a big step toward removing
the complexity of pointers by hiding them in many cases. However,
Java goes even further by not having a pointer type at all. When
an object or array is passed to a method, it is passed by reference,
rather than by value. However, a Java program still cannot access
it as a pointer or memory location.
<P>
By removing pointers from Java, the developers have greatly simplified
the language. However, an additional benefit is that removing
pointers is consistent with the design goal of keeping Java a
secure environment. By removing the ability to create a pointer
directly into a system's memory, a language goes a long way toward
preventing the use of the language for writing deviant programs
such as viruses.
<H3><A NAME="Records">Records</A></H3>
<P>
Although the Object Pascal language of Delphi is undeniably object-oriented,
it just as undeniably shows its lineage as a non-object-oriented
language. Because Object Pascal is a descendant of the Pascal
language, it includes support for all of the traditional Pascal
constructs, including <TT><FONT FACE="Courier">record</FONT></TT>
types. However, because Object Pascal allows for the definition
of classes, records are superfluous but remain in the language
to provide backward compatibility. Because Java is a new language
with no need for backward compatibility, its object model is much
cleaner. In Java, you define classes. There is no concept of a
separate but similar <TT><FONT FACE="Courier">record</FONT></TT>
type.
<H3><A NAME="Arrays">Arrays</A></H3>
<P>
Like Delphi, Java uses square brackets (<TT><FONT FACE="Courier">[]</FONT></TT>)
to declare and access arrays. However, when declaring an array
in Java, there are three important differences from declaring
an array in Delphi, as follows:
<UL>
<LI><FONT COLOR=#000000>The syntax to declare an array is less
verbose and does not include the use of an </FONT><TT><FONT FACE="Courier">array</FONT></TT>
keyword.
<LI><FONT COLOR=#000000>All Java arrays begin with element zero,
unlike Delphi in which the range can be specified.</FONT>
<LI><FONT COLOR=#000000>The size of the array is not specified
within the square brackets at the time the array is declared.</FONT>
</UL>
<P>
To see the effect of these differences, consider the following
array declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[];<BR>
float floatArray[];<BR>
double [] doubleArray;<BR>
char charArray[];</FONT></TT>
</BLOCKQUOTE>
<P>
As you'll notice from these examples, the square brackets (<TT><FONT FACE="Courier">[]</FONT></TT>)
can be placed either before or after the variable name. There
is no difference based on where the brackets are placed. It is
largely a matter of personal preference whether you place brackets
before or after a variable name. However, as you settle on a personal
preference, you should be aware of the difference that bracket
placement can make when declaring more than one array in a single
statement. For example, consider the following array declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int [] firstArray, secondArray;<BR>
int thirdArray[], fourthArray[];</FONT></TT>
</BLOCKQUOTE>
<P>
Each of these lines declares two arrays. In the first case, the
brackets are required only once because they follow the type name.
In the second case, the brackets are required after each variable
name. Some programmers prefer the explicitness of such declarations,
and others prefer the succinctness of the first case.
<H4>Allocation</H4>
<P>
Of course, in Delphi you must specify the dimension of the array
by specifying low and high index values into the array. In Java,
this is not necessary (or even allowed) because Java requires
that all arrays be allocated with <TT><FONT FACE="Courier">new</FONT></TT>.
To allocate an array using <TT><FONT FACE="Courier">new</FONT></TT>,
you would use code similar to that shown in the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = new int[100];<BR>
float floatArray[];<BR>
floatArray = new float[100];<BR>
long [] longArray = new long[100];<BR>
double [][] doubleArray = new double[10][10];</FONT></TT>
</BLOCKQUOTE>
<P>
From these examples, you can see that memory can be allocated
on the same line on which the array is declared, as was done with
<TT><FONT FACE="Courier">intArray</FONT></TT>, or the array can
be declared and allocated on two separate lines as with <TT><FONT FACE="Courier">floatArray</FONT></TT>.
The variable <TT><FONT FACE="Courier">doubleArray</FONT></TT>
shows how to declare and allocate a multidimensional array in
Java. In this case, a two-dimensional array is allocated. This
is really an array of arrays in which each of 10 first-dimension
arrays contains its own array of ten items.
<P>
An alternative way of allocating a Java array is to specify a
list of element initializers when the array is declared. This
is done as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = {1,2,3,4,5};<BR>
char [] charArray = {'a', 'b', 'c'};<BR>
String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;,
&quot;Array&quot;};</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, <TT><FONT FACE="Courier">intArray</FONT></TT> will
be a five-element array holding the values <TT><FONT FACE="Courier">1</FONT></TT>
through <TT><FONT FACE="Courier">5</FONT></TT>. The three-element
array <TT><FONT FACE="Courier">charArray</FONT></TT> will hold
the characters <TT><FONT FACE="Courier">'a'</FONT></TT>, <TT><FONT FACE="Courier">'b'</FONT></TT>,
and <TT><FONT FACE="Courier">'c'</FONT></TT>. Finally, <TT><FONT FACE="Courier">stringArray</FONT></TT>
will hold the four strings shown.
<H4>Array Access</H4>
<P>
The initial element in a Java array is stored in index zero. Therefore,
a Java array consists of elements 0 through one less than the
number of items in the array. You can access items in an array
in the same way you do in Delphi, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int ages[] = {16, 18, 21, 65};<BR>
<BR>
int canDrive = ages[0];&nbsp;&nbsp;&nbsp;&nbsp;// can drive at
16<BR>
int canVote = ages[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// can vote
at 18<BR>
int canDrink = ages[2];&nbsp;&nbsp;&nbsp;&nbsp;// can drink at
21<BR>
int canRetire = ages[3];&nbsp;&nbsp;&nbsp;// can retire at 65</FONT></TT>
</BLOCKQUOTE>
<P>
Like Delphi, Java protects you against attempting to access an
element outside the bounds of the array. Java will throw the <TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>
exception if you try to access an element beyond the bounds of
the array.
<H2><A NAME="MemoryManagement"><FONT SIZE=5 COLOR=#FF0000>Memory
Management</FONT></A></H2>
<P>
Like in Delphi, an instance of a Java class is allocated with
the keyword <TT><FONT FACE="Courier">new</FONT></TT>, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Label myLabel = new Label(&quot;This
is a label.&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Although there is a Delphi function called <TT><FONT FACE="Courier">new</FONT></TT>,
the Java version of <TT><FONT FACE="Courier">new</FONT></TT> is
more similar to the <TT><FONT FACE="Courier">Create</FONT></TT>
method (the constructor) that can exist for a Delphi class. In
Delphi, <TT><FONT FACE="Courier">new</FONT></TT> is used to allocate
a block of memory and set a pointer to it. In Java, <TT><FONT FACE="Courier">new</FONT></TT>
is used to create an instance of a class.
<P>
In Delphi, an instance that has been allocated with the <TT><FONT FACE="Courier">Create</FONT></TT>
method must eventually be released by a call to the <TT><FONT FACE="Courier">Free</FONT></TT>
method. For some instances in a Delphi program, the call to <TT><FONT FACE="Courier">Free</FONT></TT>
is performed automatically when the owner of an object is freed.
<H3><A NAME="GarbageCollection">Garbage Collection</A></H3>
<P>
Although memory for an object is still allocated with <TT><FONT FACE="Courier">new</FONT></TT>,
there is no corresponding <TT><FONT FACE="Courier">free</FONT></TT>
method that must be used to release memory. What happens instead
is that the Java memory manager keeps track of which memory is
in use, and once there are no objects referencing a particular
area of memory, that memory is automatically released and available
for reuse.
<P>
With automatic memory management (usually known as <I>garbage
collection</I>), you will find that you can write programs more
quickly and with fewer bugs.
<H2><A NAME="Classes"><FONT SIZE=5 COLOR=#FF0000>Classes</FONT></A>
</H2>
<P>
Java's support for classes has a great deal in common with Delphi.
Although classes are undeniably important in Delphi, they are
mandatory and central to all that you will do in Java. In Java
there are no freestanding variables or functions. Everything must
be encapsulated within a class. Further, every class in Java can
trace back through its inheritance hierarchy and find itself a
descendant of the <TT><FONT FACE="Courier">Object</FONT></TT>
class, similar to the way every Delphi object is derived from<TT><FONT FACE="Courier">
TObject</FONT></TT>. In order to understand Java classes, consider
the following class definition:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanVote() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanDrink(int legalAge)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
legalAge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
You'll notice from the definition of <TT><FONT FACE="Courier">Employee</FONT></TT>
that Java classes support the familiar concepts of <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">protected</FONT></TT>, and <TT><FONT FACE="Courier">public</FONT></TT>
members. However, in Java, members are not grouped into <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">public</FONT></TT>, or <TT><FONT FACE="Courier">protected</FONT></TT>
sections as they are in Delphi. In the <TT><FONT FACE="Courier">Employee</FONT></TT>
class, each member has its access control modifier specified right
with the type and name of the member. Although you may consider
this a little more typing, it definitely makes the code more readable,
and therefore easier to maintain, because you don't have to read
backwards through a file to find out if a class member is accessible.
<P>
Each of the familiar <TT><FONT FACE="Courier">private</FONT></TT>,
<TT><FONT FACE="Courier">protected</FONT></TT>, and <TT><FONT FACE="Courier">public</FONT></TT>
access control modifiers has the same meaning in Java that it
has in Delphi. Because Java does not have a concept analogous
to Delphi's Visual Component Library (VCL), there is no <TT><FONT FACE="Courier">published</FONT></TT>
access control modifier in Java. However, Java does have a fourth
level of access control that is used as the default. If no access
control modifier is specified for a member, that member is accessible
throughout the package in which it is defined, but nowhere else.
<P>
A Java package is similar to a Delphi unit but without the structure
of interface, implementation, and initialization sections. Java
code is shared at the package level, and a package contains the
definitions and source code implementations of one or more classes.
<H3><A NAME="MemberMethods">Member Methods</A></H3>
<P>
Returning to the definition of the <TT><FONT FACE="Courier">Employee</FONT></TT>
class, you can also see that both the <TT><FONT FACE="Courier">CanVote</FONT></TT>
and <TT><FONT FACE="Courier">CanDrink</FONT></TT> methods were
written directly in the class definition. This is different from
Delphi where the method prototype is given in the interface section,
and the code for the method is actually written in the implementation
section. The Java approach of combining a method's interface and
its implementation simplifies maintenance because there is no
need to duplicate method prototypes between implementation and
interface sections.
<H3><A NAME="SettingDefaultValues">Setting Default Values</A>
</H3>
<P>
It's always the little things that make a big difference. One
little thing that makes a tremendous convenience improvement in
Java over Delphi is the ability to set a default value for a member
variable at the time it is declared. For example, consider the
following definition of the <TT><FONT FACE="Courier">Employee</FONT></TT>
class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age = 21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the member variable <TT><FONT FACE="Courier">age</FONT></TT>
is declared and is given a default value of <TT><FONT FACE="Courier">21</FONT></TT>.
In Delphi, this would have been done in the constructor. There
are two advantages to setting a default value at the point where
the variable is declared:
<UL>
<LI><FONT COLOR=#000000>The code becomes more readable because
the default value cannot be missed when reading the code.</FONT>
<LI><FONT COLOR=#000000>If the class uses more than one constructor
that would have set the variable to its default, these constructors
are simplified by not having to set the </FONT>default value.
</UL>
<H3><A NAME="StaticMembers">Static Members</A></H3>
<P>
In addition to class methods and variables that are associated
with each instance of a class, a Java class can contain members
that are associated with the class itself. These are known as
static members and are identified with the <TT><FONT FACE="Courier">static</FONT></TT>
keyword, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;static double maxSalary = 1000000D;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the member variable <TT><FONT FACE="Courier">maxSalary</FONT></TT>
will exist once in the entire program, as opposed to once per
instance of the class. Additionally, <TT><FONT FACE="Courier">maxSalary</FONT></TT>
has been set to an initial value of $<TT><FONT FACE="Courier">1000000</FONT></TT>.
<H3><A NAME="ConstructorsandDestructors">Constructors and Destructors</A>
</H3>
<P>
Each Java class you define may include one or more constructors.
In Delphi, the constructor for a class is named <TT><FONT FACE="Courier">Create</FONT></TT>
and is identified by the <TT><FONT FACE="Courier">constructor</FONT></TT>
keyword, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">constructor Create(Owner: TComponent);
override;</FONT></TT>
</BLOCKQUOTE>
<P>
In Java, a constructor is given the same name as the class. It
is also not necessary to specify <TT><FONT FACE="Courier">constructor</FONT></TT>
and <TT><FONT FACE="Courier">override</FONT></TT> as is done in
Delphi. This can be seen in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Employee {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected int age;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Employee(String fName, String lName)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = fName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = lName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanVote() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
21;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean CanDrink(int legalAge)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return age &gt;=
legalAge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the constructor is named <TT><FONT FACE="Courier">Employee</FONT></TT>
and is passed two <TT><FONT FACE="Courier">String</FONT></TT>
parameters-one for the employee's first name and one for his last
name.
<P>
In Delphi, each class can have a destructor named <TT><FONT FACE="Courier">Destroy</FONT></TT>.
You call <TT><FONT FACE="Courier">Destroy</FONT></TT> when you
are done with an object and want to free memory or any other resources
the instance allocated. Because Java includes a garbage collection
feature for the automatic release of unreferenced memory, the
role of destructors is much smaller than it is in Delphi. In Delphi,
a destructor is necessary so that it can free any memory allocated
by the object. Because of Java's automatic memory management,
destructors are no longer needed to perform this job.
<P>
For these reasons, Java classes do not include Delphi-style destructors.
Instead, each Java class can include a <TT><FONT FACE="Courier">finalize</FONT></TT>
method that can be used to perform any object cleanup. The <TT><FONT FACE="Courier">finalize</FONT></TT>
method is declared in the <TT><FONT FACE="Courier">Object</FONT></TT>
class, but because <TT><FONT FACE="Courier">Object</FONT></TT>
is the ultimate base class of all Java classes, <TT><FONT FACE="Courier">finalize</FONT></TT>
is available to every Java class. There is one danger, however,
to consider when using <TT><FONT FACE="Courier">finalize</FONT></TT>.
It is possible for a Java program to terminate without this method
being invoked on every object. If a program terminates with objects
that are still referenced, the garbage collection process will
never be used to release those objects, and <TT><FONT FACE="Courier">finalize</FONT></TT>
will never be called.
<H3><A NAME="Inheritance">Inheritance</A></H3>
<P>
Inheritance in Java is indicated by the use of the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword, as shown in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Employee extends Person
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This is the equivalent of the Delphi statement <TT><FONT FACE="Courier">Employee
= class(Person)</FONT></TT>. If a class is derived directly from
<TT><FONT FACE="Courier">Object</FONT></TT>, then the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword is optional. The following two class declarations are
equivalent:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Person extends Object {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}<BR>
<BR>
public class Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Where Delphi uses <TT><FONT FACE="Courier">self</FONT></TT> to
allow an object to reference itself, Java uses <TT><FONT FACE="Courier">this</FONT></TT>
for the same purpose. Similarly, Delphi uses <TT><FONT FACE="Courier">inherited</FONT></TT>
to reference the immediate superclass of an object, but Java uses
<TT><FONT FACE="Courier">super</FONT></TT>. The use of <TT><FONT FACE="Courier">super</FONT></TT>
is frequently seen in the constructor of a subclass, as shown
in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String firstName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String lastName;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Person() {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Person(String fName, String lName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName = fName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName = lName;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class Employee extends Person {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float salary;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Employee(float sal, String fName, String
lName) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(fName, lName);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salary = sal;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">Person</FONT></TT>
class includes a constructor that is passed a first name and a
last name. The <TT><FONT FACE="Courier">Employee</FONT></TT> class
is derived from <TT><FONT FACE="Courier">Person</FONT></TT> and
includes a constructor that is passed salary, first name, and
last name. The constructor for <TT><FONT FACE="Courier">Employee</FONT></TT>
first uses <TT><FONT FACE="Courier">super</FONT></TT> to invoke
the constructor for <TT><FONT FACE="Courier">Person</FONT></TT>
and then sets the internal <TT><FONT FACE="Courier">salary</FONT></TT>
member.
<H4>Abstract Methods and Classes</H4>
<P>
Exactly like Delphi, Java supports the declaration of abstract
methods. Additionally, Java takes this a step further and introduces
the concept of an abstract class. Instances of Java abstract classes
cannot be created with <TT><FONT FACE="Courier">new</FONT></TT>.
Abstract members and classes are identified by the use of the
<TT><FONT FACE="Courier">abstract</FONT></TT> keyword, as shown
in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract class Species {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;abstract void GiveBirth();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
A class is considered abstract if it has one or more methods that
are abstract. In the case of the <TT><FONT FACE="Courier">Species</FONT></TT>
class, the method <TT><FONT FACE="Courier">GiveBirth</FONT></TT>
is specified as <TT><FONT FACE="Courier">abstract</FONT></TT>
because some species have live births and others lay eggs. Because
the method is abstract, no method body is given.
<H4>Interfaces and Multiple Inheritance</H4>
<P>
If you design a class that is entirely abstract, then that class
is what Java refers to as an <I>interface</I>. A Java interface
is similar to a class in that it defines a new type that contains
both methods and variables. However, because an interface is completely
abstract, its methods are not implemented within the interface.
Instead, classes that are derived from an interface implement
the methods of the interface.
<P>
An interface is declared in the same manner as a class except
that instead of <TT><FONT FACE="Courier">class</FONT></TT>, the
keyword <TT><FONT FACE="Courier">interface</FONT></TT> is used.
For example, the following code will declare an interface named
<TT><FONT FACE="Courier">Clock</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">interface Clock {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
To derive a class from an interface, use the keyword <TT><FONT FACE="Courier">implements</FONT></TT>,
similar to the way <TT><FONT FACE="Courier">extends</FONT></TT>
is used when a class is derived from another class. To derive
the classes <TT><FONT FACE="Courier">Cuckoo</FONT></TT> and <TT><FONT FACE="Courier">Watch</FONT></TT>
from the <TT><FONT FACE="Courier">Clock</FONT></TT> interface,
you would do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Cuckoo implements Clock&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer str
= new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i &lt; hour)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str.append(&quot;Cuckoo
&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return str.toString();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class Watch implements Clock&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new String(&quot;It
is &quot; + hour + &quot;:00&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Java, like Delphi, does not support multiple class inheritance.
In other words, a class may have only one immediate superclass
because only a single class name can follow <TT><FONT FACE="Courier">extends</FONT></TT>
in a Java class declaration. Fortunately, class inheritance and
interface inheritance can be combined when deriving a new Java
class, and a subclass can implement more than one interface. For
example, you can do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class MySubClass extends MySuperClass
implements FirstInterface,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecondInterface
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// class implementation<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="OtherChanges"><FONT SIZE=5 COLOR=#FF0000>Other Changes</FONT></A>
</H2>
<P>
There are a number of additional differences between Java and
Delphi beyond those already mentioned in this chapter. This section
will briefly describe some additional differences.
<H3><A NAME="CommandLineArguments">Command-Line Arguments</A>
</H3>
<P>
In Delphi, the program's command-line arguments are accessed through
the functions <TT><FONT FACE="Courier">ParamCount</FONT></TT>
and <TT><FONT FACE="Courier">ParamStr</FONT></TT>. These functions
can be used to retrieve the number of command-line arguments and
the text of each argument, respectively. The value returned by
<TT><FONT FACE="Courier">ParamCount</FONT></TT> will always be
at least <TT><FONT FACE="Courier">1</FONT></TT> because the first
argument on the command line to a Delphi program is the name of
the program. In a Java application, the command-line arguments
are based in an array of <TT><FONT FACE="Courier">String</FONT></TT>
objects. The signature for <TT><FONT FACE="Courier">main</FONT></TT>
is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static void main(String args[]);</FONT></TT>
</BLOCKQUOTE>
<P>
Each component of the array <TT><FONT FACE="Courier">args</FONT></TT>
is one of the command-line arguments. A difference <BR>
between Delphi and Java is that the program name is not passed
to the program as the first command-line argument in Java. Consider
two programs that are invoked in the following <BR>
manner:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">For Delphi: program 100 200<BR>
For Java: java program 100 200</FONT></TT>
</BLOCKQUOTE>
<P>
The command lines of these two programs will be interpreted by
Delphi and Java, as shown in Table 5.6.<BR>
<P>
<CENTER><B>Table 5.6. Command-line arguments in Delphi and Java.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=90><I>Argument</I></TD><TD WIDTH=128><I>Delphi</I>
</TD><TD WIDTH=90><I>Java</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">program</FONT></TT>
</TD><TD WIDTH=128><TT><FONT FACE="Courier">ParamStr(0)</FONT></TT>
</TD><TD WIDTH=90>(none)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">100</FONT></TT></TD>
<TD WIDTH=128><TT><FONT FACE="Courier">ParamStr(1)</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">args[0]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=90><TT><FONT FACE="Courier">200</FONT></TT></TD>
<TD WIDTH=128><TT><FONT FACE="Courier">ParamStr(2)</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">args[1]</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="ParenthesesAreRequired">Parentheses Are Required</A>
</H3>
<P>
Delphi allows you to use a shorthand notation and invoke a procedure
or function that received no parameters by leaving off the parentheses.
For example, in Delphi you can invoke a parameterless procedure
as <TT><FONT FACE="Courier">myFunc</FONT></TT>. In Java, however,
the parentheses are required and you need to use <TT><FONT FACE="Courier">myFunc()</FONT></TT>.
<H3><A NAME="TheJavaforStatement">The Java <TT><FONT SIZE=4 FACE="Courier">for</FONT></TT><FONT SIZE=4>
Statement</FONT></A></H3>
<P>
Java shows its C++ influence with its <TT><FONT FACE="Courier">for</FONT></TT>
statement. Fortunately, the C++ and now Java <TT><FONT FACE="Courier">for</FONT></TT>
statements are very powerful and easy to use. The first line of
a <TT><FONT FACE="Courier">for</FONT></TT> loop allows you to
specify a starting value for a loop counter, specify the test
condition that will exit the loop, and indicate how the loop counter
should be incremented after each pass through the loop. The syntax
of a Java <TT><FONT FACE="Courier">for</FONT></TT> statement is
as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (initialization; testExpression;
incremement)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;statement</FONT></TT>
</BLOCKQUOTE>
<P>
For example, a sample <TT><FONT FACE="Courier">for</FONT></TT>
loop may appear as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count;<BR>
for (count=0; count&lt;100; count++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the initialization statement of the <TT><FONT FACE="Courier">for</FONT></TT>
loop sets <TT><FONT FACE="Courier">count</FONT></TT> to <TT><FONT FACE="Courier">0</FONT></TT>.
The test expression, <TT><FONT FACE="Courier">count &lt; 100</FONT></TT>
indicates that the loop should continue as long as <TT><FONT FACE="Courier">count</FONT></TT>
is less than 100. Finally, the increment statement increments
the value of <TT><FONT FACE="Courier">count</FONT></TT> by one.
As long as the test expression is true, the statement enclosed
in the loop will be executed.
<H3><A NAME="gotobreakandcontinue"><TT><FONT SIZE=4 FACE="Courier">goto</FONT></TT><FONT SIZE=4>,
</FONT><TT><FONT SIZE=4 FACE="Courier">break</FONT></TT><FONT SIZE=4>,
and </FONT><TT><FONT SIZE=4 FACE="Courier">continue</FONT></TT></A>
</H3>
<P>
You probably won't shed any tears, but the <TT><FONT FACE="Courier">goto</FONT></TT>
statement is not part of Java. On the other hand, it is still
part of the reserved word list, so it may come back at any time.
Java does replace <TT><FONT FACE="Courier">goto</FONT></TT>, however,
with the ability to use <TT><FONT FACE="Courier">break</FONT></TT>
and <TT><FONT FACE="Courier">continue</FONT></TT> with labels.
You can still use <TT><FONT FACE="Courier">break</FONT></TT> and
<TT><FONT FACE="Courier">continue</FONT></TT> as you are used
to in Delphi, but you can now use them to pass control flow in
other ways. For example, consider the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int line=1;<BR>
<BR>
outsideLoop:<BR>
for(int out=0; out&lt;3; out++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(int inner=0;inner &lt; 5; inner++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (foo(inner)
&lt; 10))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (foo(inner)
&gt; 100)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, if the <TT><FONT FACE="Courier">foo</FONT></TT>
method returns a value less than 10, the code <TT><FONT FACE="Courier">break
outsideLoop</FONT></TT> will execute. A normal <TT><FONT FACE="Courier">break</FONT></TT>
here would break out of the inner loop. However, because this
is a named <TT><FONT FACE="Courier">break</FONT></TT> statement,
it will break out of the named outer loop. This example also demonstrates
the use of <TT><FONT FACE="Courier">continue</FONT></TT> with
a label.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covered quite a lot of territory. Building on your
background in Delphi, you learned how Java differs from Delphi
in regards to data types, operators, memory management, and classes.
You've been introduced to some new operators that don't exist
in Delphi, and you've learned how to use Java to create new classes.
You learned that Java, like Delphi, supports only single class
inheritance, but that Java's introduction of interfaces takes
Java well beyond Delphi in supporting multiple interface inheritance.
Finally, you learned that by removing pointers and incorporating
automatic memory management in the form of garbage collection,
Java programming is greatly simplified.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch4.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch6.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
