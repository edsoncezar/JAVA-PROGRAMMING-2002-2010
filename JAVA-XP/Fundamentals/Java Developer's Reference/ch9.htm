<HTML>

<HEAD>
   <TITLE>Chapter 9 -- javac : The Java Compiler</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 9</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>javac : The Java Compiler</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#Overview" >Overview</A>
<LI><A HREF="#Usage" >Usage</A>
<LI><A HREF="#Options" >Options</A>
<LI><A HREF="#TheNonOptimizingCompiler" >The Non-Optimizing Compiler</A>
<LI><A HREF="#Bugs" >Bugs</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
The Java compiler (<TT><FONT FACE="Courier">javac</FONT></TT>)
is the component of the Java Developer's Kit used to transform
Java source code files into bytecode executables that can be run
in the Java runtime system. In this chapter, you learn all about
the Java compiler and how it is used, including the different
compilation options it supports. You also learn about an alternate
version of the compiler that ships with some versions of the JDK.
Toward the end of the chapter, you get a glimpse of a few of the
bugs in the current version of the Java compiler.
<H2><A NAME="Overview"><FONT SIZE=5 COLOR=#FF0000>Overview</FONT></A>
</H2>
<P>
In Java, source code files have the extension <TT><FONT FACE="Courier">.java</FONT></TT>.
Java source code files are standard ASCII text files, much like
the source code files for other popular programming languages
like C++. It is the job of the Java compiler to process Java source
code files and create executable Java bytecode classes from them.
Executable bytecode class files have the extension <TT><FONT FACE="Courier">.class</FONT></TT>,
and they represent a Java class in its useable form.
<P>
Java class files are generated on a one-to-one basis with the
classes defined in the source code. In other words, the Java compiler
generates exactly one <TT><FONT FACE="Courier">.class</FONT></TT>
file for each class you create. Technically, it is possible to
define more than one class in a single source file; it is therefore
possible for the compiler to generate multiple class files from
a single source file. When this happens, it means that the source
file contains multiple class definitions.
<P>
You may have heard something about <FONT FACE="AGaramond Italic">just-in-time
compilers</FONT> in reference to Java. It's important not to get
these compilers confused with the Java compiler and the role it
plays. The Java compiler is responsible for turning Java source
code into Java bytecodes that can be executed within the Java
runtime system. The Java Virtual Machine, which is a component
of the runtime system, is responsible for interpreting the bytecodes
and making the appropriate system-level calls to the native platform.
It is at this point where platform independence is achieved by
Java; the bytecodes are in a generic form that is only converted
to a native form when processed by the Virtual Machine. Figure
9.1 shows how the Java compiler and runtime system relate to each
other.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f9-1.gif" ><B>Figure 9.1 : </B><I>The relationship between the Java compiler and runtime system.</I></A>
<P>
Just-in-time compilers remove the role of the runtime interpreter
by converting Java bytecodes to native code on the fly before
executing a Java program. In this way, just-in-time Java compilers
work more like the back end of traditional language compilers
in that they generate code for a native platform. Similarly, the
Java compiler works more like the front end of a traditional compiler
in that it parses Java source code and generates internally useful
bytecode classes. Figure 9.2 shows the relationship between the
Java compiler and just-in-time compilers.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f9-2.gif" ><B>Figure 9.2 : </B><I>The difference between the Java compiler and java-in-time compilers.</I></A>
<P>
Keep in mind that Java executables are still centered around the
bytecode class format. Even with just-in-time compilers in the
picture, all you must be concerned with as a developer is generating
the appropriate bytecode classes using the Java compiler. If no
just-in-time compiler is present on a user's system, the bytecode
classes will be processed and executed by the runtime interpreter.
On the other hand, if a just-in-time compiler happens to exist
on the system, the bytecode classes will be converted to native
code and then executed. Either way, the key to executing Java
programs is the bytecode classes, which are created by the Java
compiler.
<H2><A NAME="Usage"><FONT SIZE=5 COLOR=#FF0000>Usage</FONT></A>
</H2>
<P>
The Java compiler is a command-line tool, meaning that it is invoked
from a command prompt, such as the MS-DOS shell in Windows 95.
The syntax for the Java compiler follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac <I>Options Filename</I></FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><I><FONT FACE="Courier">Filename</FONT></I></TT> argument
specifies the name of the source code file you want to compile.
The compiler will generate bytecode classes for all classes defined
in this file. Likewise, the compiler also will generate bytecode
classes for any dependent classes that haven't been compiled yet.
In other words, if you are compiling class <TT><FONT FACE="Courier">A</FONT></TT>,
which is derived from class <TT><FONT FACE="Courier">B</FONT></TT>,
and class <TT><FONT FACE="Courier">B</FONT></TT> has not yet been
compiled, the compiler will go ahead and compile both classes.
<H2><A NAME="Options"><FONT SIZE=5 COLOR=#FF0000>Options</FONT></A>
</H2>
<P>
The <TT><I><FONT FACE="Courier">Options</FONT></I></TT> compiler
argument specifies options related to how the compiler creates
the executable Java classes. Following is a list of the compiler
options:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">-classpath <I>Path<BR>
</I>-d <I>Dir<BR>
</I>-g<BR>
-nowarn<BR>
-O<BR>
-verbose</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">-classpath</FONT></TT> option tells
the compiler to override the <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
environment variable with the path specified by <TT><I><FONT FACE="Courier">Path</FONT></I></TT>.
This causes the compiler to look for user-defined classes in the
path specified by <TT><I><FONT FACE="Courier">Path</FONT></I></TT>.
<TT><I><FONT FACE="Courier">Path</FONT></I></TT> is a semicolon-delimited
list of directory paths taking the following form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">.;&lt;<I>your_path</I>&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
An example of a specific usage of <TT><FONT FACE="Courier">-classpath</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac -classpath .;\dev\animate\classes;\dev\render\classes
A.java</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the compiler is using a user-defined class path
to access any classes it needs while compiling the source code
file <TT><FONT FACE="Courier">A.java</FONT></TT>. The <TT><FONT FACE="Courier">-classpath</FONT></TT>
option is sometimes useful when you want to try compiling something
without taking the trouble to modify the <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
environment variable.
<P>
The <TT><FONT FACE="Courier">-d</FONT></TT> option determines
the root directory where compiled classes are stored. This is
important because many times classes are organized in a hierarchical
directory structure. With the <TT><FONT FACE="Courier">-d</FONT></TT>
option, the directory structure will be created beneath the directory
specified by <TT><I><FONT FACE="Courier">Dir</FONT></I></TT>.
<P>
The <TT><FONT FACE="Courier">-g</FONT></TT> compiler option causes
the compiler to generate debugging tables for the Java classes.
Debugging tables are used by the Java debugger, and they contain
information such as local variables and line numbers. The default
action of the compiler is to only generate line numbers. If you
are going to be using the Java debugger, you must use the <TT><FONT FACE="Courier">-g</FONT></TT>
option. Additionally, for debugging, make sure you don't use the
<TT><FONT FACE="Courier">-O</FONT></TT> option, which optimizes
the code.
<P>
The <TT><FONT FACE="Courier">-nowarn</FONT></TT> option turns
off compiler warnings. Warnings are printed to standard output
during compilation to inform you of potential problems with the
source code. It is generally a good idea to keep warnings enabled,
because they often signal problem areas in your code. However,
you may run into a situation where warnings are getting in the
way, in which case the <TT><FONT FACE="Courier">-nowarn</FONT></TT>
option might be useful.
<P>
The <TT><FONT FACE="Courier">-O</FONT></TT> option causes the
compiler to optimize the compiled code. In this case, optimization
simply means that static, final, and private methods are compiled
inline. When a method is compiled inline, it means that the entire
body of the method is included in place of each call to the method.
This speeds up execution because it eliminates the method call
overhead. Optimized classes are usually larger in size, to accommodate
the duplicate code. The <TT><FONT FACE="Courier">-O</FONT></TT>
optimization option also suppresses the default creation of line
numbers by the compiler. Keep in mind that the <TT><FONT FACE="Courier">-O</FONT></TT>
option should not be used when you plan on debugging the compiled
code using the Java debugger.
<P>
The <TT><FONT FACE="Courier">-verbose</FONT></TT> option has somewhat
of an opposite effect as the <TT><FONT FACE="Courier">-nowarn</FONT></TT>
option-it prints out extra information about the compilation process.
You can use <TT><FONT FACE="Courier">-verbose</FONT></TT> to see
exactly what source files are being compiled and what class files
are being loaded.
<H2><A NAME="TheNonOptimizingCompiler"><FONT SIZE=5 COLOR=#FF0000>The
Non-Optimizing Compiler</FONT></A></H2>
<P>
Some distributions of the Java Developer's Kit include an alternate
Java compiler called <TT><FONT FACE="Courier">javac_g</FONT></TT>.
This version of the Java compiler generates code without some
of the internal optimizations performed by the standard <TT><FONT FACE="Courier">javac</FONT></TT>
compiler. If this compiler is in your JDK distribution, be sure
to use it when you are compiling code for debugging. Otherwise,
stick with the <TT><FONT FACE="Courier">javac</FONT></TT> compiler
for all release code.
<H2><A NAME="Bugs"><FONT SIZE=5 COLOR=#FF0000>Bugs</FONT></A>
</H2>
<P>
As of this writing, the latest release of the Java Developer's
Kit is 1.02, which contains some known bugs. More specifically,
the following Java compiler bugs have been documented and acknowledged
by the JavaSoft development team:
<UL>
<LI><FONT COLOR=#000000>The compiler doesn't distinguish between
the same class names in different packages.</FONT>
<LI><FONT COLOR=#000000>The compiler doesn't distinguish between
class names that are only differing by case (Windows 95/NT version
only).</FONT>
<LI><FONT COLOR=#000000>The compiler will not compile a method
with more than 63 local variables.</FONT>
</UL>
<P>
The first bug is only a problem if you are using different packages
containing classes with the same name. Generally speaking, most
programmers probably won't develop two packages with same-named
classes in each. However, the problem can easily arise without
your even realizing it; suppose you are using someone else's package
that has a bunch of classes already defined, and a class name
conflicts with one of your own. Or, for example, suppose you had
your own package including the following source code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">package stuff;<BR>
import java.util.*;<BR>
<BR>
public class Hashtable<BR>
{<BR>
&nbsp;&nbsp;public Hashtable() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// initialize the hashtable<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
A class called <TT><FONT FACE="Courier">Hashtable</FONT></TT>
already exists in the <TT><FONT FACE="Courier">java.util</FONT></TT>
package, so your <TT><FONT FACE="Courier">Hashtable</FONT></TT>
class would conflict with it upon compilation thanks to the compiler
bug.
<P>
The second compiler bug also is related to class names, and this
bug rears its head whenever you have two classes with names that
differ only by case, as shown in the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">// File EncryptIt.java<BR>
class EncryptIt<BR>
{<BR>
&nbsp;&nbsp;// encrypt something<BR>
}<BR>
<BR>
// File encryptit.java<BR>
class encryptit<BR>
{<BR>
&nbsp;&nbsp;// encrypt something else<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that the second class, which is defined in a different
source code file, has the same name as the first class, with the
exception of the case on two of the characters. The Java compiler
will give an error while attempting to compile this code, although
technically the class naming is legal. Keep in mind that this
bug exists only on the Windows 95/NT platform.
<P>
Finally, the last bug deals with the number of local variables
defined in a method. If a method defines more than 63 local variables,
the Java compiler will not be able to compile the method. The
Java language specification has yet to set a specific upper limit
on the number of local variables allowed, so you can think of
the number 63 as the working limit until a formal decision has
been made.
<P>
Admittedly, none of these bugs are all that likely to occur, simply
because most programmers give their classes unique names and typically
use less than 63 local variables in each method! However, just
in case you ever find yourself pulling your hair out over a strange
compiler problem, these bugs might be good to keep in mind.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned all about the standard Java compiler
that ships with the Java Developer's Kit. You learned its role
in generating executable Java code, along with how it differs
from just-in-time Java compilers. You then learned how to use
the compiler and what options are available for generating executable
Java classes. You finished up with a quick look at an alternate
non-optimizing Java compiler that ships with some versions of
the JDK, along with a few bugs that made their way into the compiler.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch8.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch10.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>