<HTML>

<HEAD>
   <TITLE>Chapter 3 -- The Java Language</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 3</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>The Java Language</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Comments" >Comments</A>
<LI><A HREF="#JavaKeywords" >Java Keywords</A>
<LI><A HREF="#PrimitiveTypes" >Primitive Types</A>
<UL>
<LI><A HREF="#IntegerTypes" >Integer Types</A>
<LI><A HREF="#FloatingPointTypes" >Floating-Point Types</A>
<LI><A HREF="#OtherPrimitiveTypes" >Other Primitive Types</A>
<LI><A HREF="#DefaultValues" >Default Values</A>
<LI><A HREF="#CastingBetweenPrimitiveTypes" >Casting Between Primitive Types</A>
</UL>
<LI><A HREF="#Literals" >Literals</A>
<UL>
<LI><A HREF="#IntegerLiterals" >Integer Literals</A>
<LI><A HREF="#FloatingPointLiterals" >Floating-Point Literals</A>
<LI><A HREF="#BooleanLiterals" >Boolean Literals</A>
<LI><A HREF="#CharacterLiterals" >Character Literals</A>
<LI><A HREF="#StringLiterals" >String Literals</A>
</UL>
<LI><A HREF="#Arrays" >Arrays</A>
<UL>
<LI><A HREF="#Allocation" >Allocation</A>
<LI><A HREF="#Initialization" >Initialization</A>
<LI><A HREF="#ArrayAccess" >Array Access</A>
</UL>
<LI><A HREF="#Operators" >Operators</A>
<UL>
<LI><A HREF="#OperatorsonIntegers" >Operators on Integers</A>
<LI><A HREF="#OperatorsonFloatingPointValues" >Operators on Floating-Point Values</A>
<LI><A HREF="#OperatorsonBooleanValues" >Operators on Boolean Values</A>
</UL>
<LI><A HREF="#ControllingYourProgram" >Controlling Your Program</A>
<UL>
<LI><A HREF="#Selection" >Selection</A>
<LI><A HREF="#Iteration" >Iteration</A>
<LI><A HREF="#Jumping" >Jumping</A>
</UL>
<LI><A HREF="#JavaClasses" >Java Classes</A>
<UL>
<LI><A HREF="#FieldDeclarations" >Field Declarations</A>
</UL>
<LI><A HREF="#ClassInheritance" >Class Inheritance</A>
<UL>
<LI><A HREF="#OverridingMemberMethods" >Overriding Member Methods</A>
<LI><A HREF="#ThesuperVariable" >The super Variable</A>
<LI><A HREF="#ClassModifiers" >Class Modifiers</A>
<LI><A HREF="#ImplementingInterfaces" >Implementing Interfaces</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter outlines the core syntax and constructs of the Java
language. You will learn how to declare Java variables and write
Java functions. You will see how Java's minimal set of primitive
types can be combined with its rich object model to fulfill the
goals of object-oriented programming. If you are an experienced
C++ programmer, you will find many similarities between Java and
C++. As you read this chapter, you will see many areas in which
C++ has been improved upon and which will influence how you program,
both in C++ and in Java.
<H2><A NAME="Comments"><FONT SIZE=5 COLOR=#FF0000>Comments</FONT></A>
</H2>
<P>
Undoubtedly, you want to start your Java career off on the right
foot, so let's dive right in and start with the important stuff-comments.
Java supports three types of comment delimiters-the traditional
<TT><FONT FACE="Courier">/*</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT>
of C, the <TT><FONT FACE="Courier">//</FONT></TT> of C++, and
a new variant that starts with <TT><FONT FACE="Courier">/**</FONT></TT>
and ends with <TT><FONT FACE="Courier">*/</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">/*</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT>
delimiters are used to enclose text that is to be treated as a
comment by the compiler. These delimiters are useful when you
want to designate a lengthy piece of code as a comment, as shown
in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* This is a comment that will span multiple
<BR>
source code lines. */</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">//</FONT></TT> comment delimiter
is borrowed from C++ and is used to indicate that the rest of
the line is to be treated as a comment by the Java compiler. This
type of comment delimiter is particularly useful for adding comments
adjacent to lines of code, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Date today = new Date();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
create an object with today's date<BR>
System.out.println(today);&nbsp;&nbsp;&nbsp;&nbsp;// display the
date</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the <TT><FONT FACE="Courier">/**</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT>
delimiters are new to Java and are used to indicate that the enclosed
text is to be treated as a comment by the compiler, but that the
text is also part of the automatic class documentation that can
be generated using JavaDoc. JavaDoc is fully described in <A HREF="ch16.htm" >Chapter 16</A>,
&quot;Using JavaDoc to Document Your Program.&quot; These delimiters
can be used to enclose multiple lines of text, identically to
how <TT><FONT FACE="Courier">/*</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT>
behave, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/** The NeuralNetwork class implements
a back-propagation<BR>
network and ... */</FONT></TT>
</BLOCKQUOTE>
<P>
The Java comment delimiters are summarized in Table 3.1.<BR>
<P>

<CENTER><B>Table 3.1. Java comment delimiters.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=52><CENTER><I>Start</I></CENTER></TD><TD WIDTH=64><CENTER><I>End</I></CENTER>
</TD><TD WIDTH=474><CENTER><I>Purpose</I></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">/*</FONT></TT></TD>
<TD WIDTH=64><TT><FONT FACE="Courier">*/</FONT></TT></TD><TD WIDTH=474>The enclosed text is treated as a comment.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">//</FONT></TT></TD>
<TD WIDTH=64>(none)</TD><TD WIDTH=474>The rest of the line is treated as a comment.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=52><TT><FONT FACE="Courier">/**</FONT></TT></TD>
<TD WIDTH=64><TT><FONT FACE="Courier">*/</FONT></TT></TD><TD WIDTH=474>The enclosed text is treated as a comment by the compiler but is used by JavaDoc to automatically generate documentation.
</TD></TR>
</TABLE></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You cannot nest comments in Java source code. Therefore, <TT><FONT FACE="Courier">/*</FONT></TT> and <TT><FONT FACE="Courier">*/</FONT></TT> appearing within a <TT><FONT FACE="Courier">//</FONT></TT> comment are ignored as is the pattern // appearing 
within <TT><FONT FACE="Courier">/*</FONT></TT> or <TT><FONT FACE="Courier">/**</FONT></TT> comments. Comments cannot be placed within quoted strings, and if comment delimiters occur within a quoted string, they will be considered part of the quoted string.

</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="JavaKeywords"><FONT SIZE=5 COLOR=#FF0000>Java Keywords</FONT></A>
</H2>
<P>
The following is a list of Java keywords:<BR>
<P>
<CENTER><B>Java Keywords</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">abstract</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">float</FONT></TD><TD WIDTH=138><FONT FACE="Courier">public</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">boolean</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">for</FONT></TD><TD WIDTH=138><FONT FACE="Courier">return</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">break</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">if</FONT></TD><TD WIDTH=138><FONT FACE="Courier">short</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">implements</FONT></TD><TD WIDTH=138><FONT FACE="Courier">static</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">case</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">import</FONT></TD><TD WIDTH=138><FONT FACE="Courier">super</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">catch</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">instanceof</FONT></TD><TD WIDTH=138><FONT FACE="Courier">switch</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">char</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">int</FONT></TD><TD WIDTH=138><FONT FACE="Courier">synchronized</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">class</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">interface</FONT></TD><TD WIDTH=138><FONT FACE="Courier">this</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">continue</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">long</FONT></TD><TD WIDTH=138><FONT FACE="Courier">throw</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">default</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">native</FONT></TD><TD WIDTH=138><FONT FACE="Courier">throws</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">do</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">new</FONT></TD><TD WIDTH=138><FONT FACE="Courier">transient</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">double</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">null</FONT></TD><TD WIDTH=138><FONT FACE="Courier">try</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">else</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">operator</FONT></TD><TD WIDTH=138><FONT FACE="Courier">void</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">extends</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">package</FONT></TD><TD WIDTH=138><FONT FACE="Courier">volatile</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">final</FONT></TT></TD>
<TD WIDTH=114><FONT FACE="Courier">private</FONT></TD><TD WIDTH=138><FONT FACE="Courier">while</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=103><TT><FONT FACE="Courier">finally</FONT></TT>
</TD><TD WIDTH=114><FONT FACE="Courier">protected</FONT></TD>
<TD WIDTH=138><FONT FACE="Courier">&nbsp;</FONT></TD></TR>
</TABLE></CENTER>
<P>
<P>
Additionally, the Java specification reserves additional keywords
that will be used in the future but are not part of Java 1.0.
The following is a list of reserved Java keywords that are not
currently used:<BR>
<P>
<CENTER><B>Reserved Java Keywords</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=85><TT><FONT FACE="Courier">byvalue</FONT></TT>
</TD><TD WIDTH=96><FONT FACE="Courier">generic</FONT></TD><TD WIDTH=90><FONT FACE="Courier">outer</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=85><TT><FONT FACE="Courier">cast</FONT></TT></TD>
<TD WIDTH=96><FONT FACE="Courier">goto</FONT></TD><TD WIDTH=90><FONT FACE="Courier">rest</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=85><TT><FONT FACE="Courier">const</FONT></TT></TD>
<TD WIDTH=96><FONT FACE="Courier">inner</FONT></TD><TD WIDTH=90><FONT FACE="Courier">var</FONT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=85><TT><FONT FACE="Courier">future</FONT></TT></TD>
<TD WIDTH=96><FONT FACE="Courier">operator</FONT></TD><TD WIDTH=90><FONT FACE="Courier">&nbsp;</FONT>
</TD></TR>
</TABLE></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You may have noticed that true and false are missing from the list of Java keywords. These are actually Boolean literals but can be thought of as keywords.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="PrimitiveTypes"><FONT SIZE=5 COLOR=#FF0000>Primitive
Types</FONT></A></H2>
<P>
Primitive types are the building blocks of the data portion of
a language. Just as matter is composed of atoms clinging together,
more complex data types can be made by combining a language's
primitive data types. The Java language contains only a small
set of primitive types: integer, floating-point, character, and
Boolean.
<P>
In Java, as in C and C++, you declare a variable by giving its
type followed by its name, as in the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int x;<BR>
float LifeRaft;<BR>
short people;<BR>
long TimeNoSee;<BR>
double amountDue, amountPaid;</FONT></TT>
</BLOCKQUOTE>
<P>
In the preceding code, <TT><FONT FACE="Courier">x</FONT></TT>
is declared as an int (integer), <TT><FONT FACE="Courier">LifeRaft</FONT></TT>
is declared as a floating-point variable, <TT><FONT FACE="Courier">people</FONT></TT>
is declared as a short integer, <TT><FONT FACE="Courier">TimeNoSee</FONT></TT>
is declared as a long integer, and <TT><FONT FACE="Courier">amountDue</FONT></TT>
and <TT><FONT FACE="Courier">amountPaid</FONT></TT> are declared
as double-precision, floating-point values.
<H3><A NAME="IntegerTypes">Integer Types</A></H3>
<P>
Java consists of four integer types: <TT><FONT FACE="Courier">byte</FONT></TT>,
<TT><FONT FACE="Courier">short</FONT></TT>, <TT><FONT FACE="Courier">int</FONT></TT>,
and <TT><FONT FACE="Courier">long</FONT></TT>, which are defined
as 8-, 16-, 32-, and 64-bit signed values as summarized in Table
3.2.<BR>
<P>
<CENTER><B>Table 3.2. The Java integer primitive types.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=70><I>Type</I></TD><TD WIDTH=73><I>Bit Size</I>
</TD><TD WIDTH=204><I>Minimum Value</I></TD><TD WIDTH=198><I>Maximum Value</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=73>8</TD><TD WIDTH=204>-256</TD><TD WIDTH=198>255</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=73>16</TD><TD WIDTH=204>-32,768</TD><TD WIDTH=198>32,767
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=73>32</TD><TD WIDTH=204>-2,147,483,648</TD><TD WIDTH=198>2,147,483,647
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=73>64</TD><TD WIDTH=204>-9,223,372,036,854,775,808</TD>
<TD WIDTH=198>9,223,372,036,854,775,807</TD></TR>
</TABLE></CENTER>
<P>
<P>
The operations that may be performed on integer primitives are
shown in Table 3.3. A more detailed discussion of the Java operators
is deferred until later in this chapter.<BR>
<P>
<CENTER><B>Table 3.3. Operators on integer primitives.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=178><I>Operation</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=178>Equality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=178>Inequality</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=178>Greater than</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=178>Less than</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=178>Greater than or equal to</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=178>Less than or equal to</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=178>Addition
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=178>Subtraction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=178>Multiplication
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=178>Division
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=178>Modulus
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=178>Increment</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=178>Decrement</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=178>Bitwise logical negation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;</FONT></TT></TD>
<TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">|</FONT></TT></TD><TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">^</FONT></TT></TD><TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;&lt;</FONT></TT>
</TD><TD WIDTH=178>Left shift</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;</FONT></TT>
</TD><TD WIDTH=178>Right shift</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT>
</TD><TD WIDTH=178>Right shift with zero fill</TD></TR>
</TABLE></CENTER>
<P>
<P>
If either or both of the operands is of type <TT><FONT FACE="Courier">long</FONT></TT>,
then the result of the operation will be a 64-bit <TT><FONT FACE="Courier">long</FONT></TT>.
If either operand is not a <TT><FONT FACE="Courier">long</FONT></TT>,
it will be cast to a <TT><FONT FACE="Courier">long</FONT></TT>
prior to the operation. If neither operand is a <TT><FONT FACE="Courier">long</FONT></TT>,
then the operation will be performed with the 32-bit precision
of an <TT><FONT FACE="Courier">int</FONT></TT>. Any <TT><FONT FACE="Courier">byte</FONT></TT>
or <TT><FONT FACE="Courier">short</FONT></TT> operands will be
cast to <TT><FONT FACE="Courier">int</FONT></TT> prior to the
operation.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In Java, you cannot cast between an integer type and a Boolean type.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="FloatingPointTypes">Floating-Point Types</A></H3>
<P>
Support for floating-point numbers in Java is provided through
two primitive types-<TT><FONT FACE="Courier">float</FONT></TT>
and <TT><FONT FACE="Courier">double</FONT></TT>, which are 32-
and 64-bit values, respectively. The operators available for use
on these primitives types are shown in Table 3.4.<BR>
<P>
<CENTER><B>Table 3.4. Operators on floating-point primitives.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=174><CENTER><I>Operation</I></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=174>Equality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=174>Inequality</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=174>Greater than</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=174>Less than</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=174>Greater than or equal to</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=174>Less than or equal to</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=174>Addition
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=174>Subtraction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=174>Multiplication
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=174>Division
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=174>Modulus
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=174>Increment</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=174>Decrement</TD></TR>
</TABLE></CENTER>
<P>
<P>
Java floating-point numbers will behave as specified in IEEE Standard
754. Java variables of type <TT><FONT FACE="Courier">float</FONT></TT>
and <TT><FONT FACE="Courier">double</FONT></TT> can be cast to
other numeric types but cannot be cast to be of the <TT><FONT FACE="Courier">boolean</FONT></TT>
type.
<P>
If either or both of the operands is a floating-point type, the
operation is considered to be a floating-point operation. If either
of the operands is a <TT><FONT FACE="Courier">double</FONT></TT>,
then each will be treated as a <TT><FONT FACE="Courier">double</FONT></TT>
with the necessary casts being performed. If neither operand is
a <TT><FONT FACE="Courier">double</FONT></TT>, then each operand
will be treated as a <TT><FONT FACE="Courier">float</FONT></TT>
and cast as necessary.
<P>
Floating-point numbers can take on any of the following values:
<UL>
<LI><FONT COLOR=#000000>Negative infinity</FONT>
<LI><FONT COLOR=#000000>Negative, finite values</FONT>
<LI><FONT COLOR=#000000>Negative zero</FONT>
<LI><FONT COLOR=#000000>Positive </FONT>zero
<LI><FONT COLOR=#000000>Positive, finite values</FONT>
<LI><FONT COLOR=#000000>Positive infinity</FONT>
<LI><FONT COLOR=#000000>NaN, or &quot;not a number&quot;</FONT>
</UL>
<P>
This last value, NaN, is used to indicate values that do not fit
within the scale of negative infinity to positive infinity. For
example, the following will produce a value of NaN:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">0.0f / 0.0f</FONT></TT>
</BLOCKQUOTE>
<P>
The inclusion of NaN as a floating-point value can cause some
unusual effects when floating-point values are compared with the
relational operators. Because NaN does not fit within the scale
of negative infinity through positive infinity, comparing against
it will always result in <TT><FONT FACE="Courier">false</FONT></TT>.
For example, both<TT><FONT FACE="Courier"> 5.3f &gt; NaN</FONT></TT>
and <TT><FONT FACE="Courier">5.3f &lt; NaN</FONT></TT> are <TT><FONT FACE="Courier">false</FONT></TT>.
In fact, when NaN is compared to itself with <TT><FONT FACE="Courier">==</FONT></TT>,
the result is <TT><FONT FACE="Courier">false</FONT></TT>.
<P>
On the other hand, although negative and positive zero may sound
like different values, comparing them with <TT><FONT FACE="Courier">==</FONT></TT>
will result in <TT><FONT FACE="Courier">true</FONT></TT>.
<H3><A NAME="OtherPrimitiveTypes">Other Primitive Types</A></H3>
<P>
In addition to the integer and floating-point primitive types,
Java includes two additional primitive types-Boolean and character.
Variables of type <TT><FONT FACE="Courier">boolean</FONT></TT>
can hold either <TT><FONT FACE="Courier">true</FONT></TT> or <TT><FONT FACE="Courier">false</FONT></TT>,
while variables of type <TT><FONT FACE="Courier">char</FONT></TT>
can hold a single Unicode character.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Remember, a Java Boolean variable is not a 1 or 0 in disguise as it is in other languages, in particular C and C++. Because of this, you cannot cast between Boolean and numeric types.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="DefaultValues">Default Values</A></H3>
<P>
One common source of programming errors is the use of an uninitialized
variable. Frequently, this type of bug shows itself in a program
that behaves erratically. Sometimes the program does what it's
supposed to; other times it reformats your hard drive, overwrites
your CMOS, declares war on a foreign country, or manifests some
other undesirable side effect. It does this because an uninitialized
variable may take on the value of whatever random garbage is in
its memory location when the program runs. Java circumvents this
problem, and possibly prevents World War III, by assigning a default
value to any uninitialized variables. Default values are assigned
based on the type of the variable, as shown in Table 3.5.<BR>
<P>
<CENTER><B>Table 3.5. Standard default values for Java primitive
types.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=109><I>Primitive</I></TD><TD WIDTH=70><I>Default</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">0</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">0</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">0</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">0L</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">float</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">0.0f</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">double</FONT></TT>
</TD><TD WIDTH=70><TT><FONT FACE="Courier">0.0d</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">char</FONT></TT></TD>
<TD WIDTH=70><TT><FONT FACE="Courier">null</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">boolean</FONT></TT>
</TD><TD WIDTH=70><TT><FONT FACE="Courier">false</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=109>all references</TD><TD WIDTH=70><TT><FONT FACE="Courier">null</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
It's certainly convenient and beneficial that Java will take care of assigning default values to uninitialized variables, but it is not wise to rely on this. Good programming practice suggests that you should initialize every variable you declare, without 
relying on default values. Although it is very unlikely that the default values would change (for example, the Boolean default of <TT><FONT FACE="Courier">false</FONT></TT> is unlikely to change to <TT><FONT FACE="Courier">true</FONT></TT>), other side 
effects are possible.
</BLOCKQUOTE>
<BLOCKQUOTE>
In a C program, I once spent hours tracking down a bug that was caused by my reliance on the compiler defaulting a global integer to 0. The compiler did its job correctly; unfortunately, another programmer saw my bad practice of using an uninitialized 
global and corrected it by initializing it for me-to 1. When I was reassigned to the maintenance of the program, I had no idea the change had been made.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="CastingBetweenPrimitiveTypes">Casting Between Primitive
Types</A></H3>
<P>
Sometimes you have a variable that is of one type, and you want
to use it as another. For example, one of the first programs I
wrote was used to predict the final scores in baseball games based
on a huge number of input statistics. It would come up with results
like the Chicago Cubs beating the San Diego Padres with scores
like 3.2 to 2.7. Since it was clearly impossible in real life
to score a partial run, the results needed to be converted from
floating-point to integer values. This is known as <I>casting</I>
a variable. In Java, you can cast a variable of one type to another
as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">float fRunsScored = 3.2f;<BR>
int iRunsScored = (int)fRunsScored;</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the floating-point value 3.2 that is stored in <TT><FONT FACE="Courier">fRunsScored</FONT></TT>
will be cast into an integer and placed in <TT><FONT FACE="Courier">iRunsScored</FONT></TT>.
When cast into an integer, the non-whole portion of the <TT><FONT FACE="Courier">fRunsScored</FONT></TT>
will be truncated so that <TT><FONT FACE="Courier">iRunsScored</FONT></TT>
will equal 3.
<P>
This is an example of what is known as a <I>narrowing conversion</I>.
A narrowing conversion may lose information about the overall
magnitude or precision of a numeric value, as you saw in this
case. You should always be careful when writing a narrowing conversion
because of this potential for data loss.
<P>
The other type of conversion is called a <I>widening conversion</I>.
A widening conversion may lose information about precision in
the least significant bits of the value, but it will not lose
information about the magnitude of the value. In general, widening
conversions are much safer. Table 3.6 shows the widening conversions
that are possible between Java primitive types.<BR>
<P>
<CENTER><B>Table 3.6. Available widening conversions among Java
primitive types.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=70><I>From</I></TD><TD WIDTH=294><I>To</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">short</FONT></TT>, <TT><FONT FACE="Courier">int</FONT></TT>, <TT><FONT FACE="Courier">long</FONT></TT>, <TT><FONT FACE="Courier">float</FONT></TT>, or <TT><FONT FACE="Courier">double</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">int</FONT></TT>, <TT><FONT FACE="Courier">long</FONT></TT>, <TT><FONT FACE="Courier">float</FONT></TT>, or <TT><FONT FACE="Courier">double</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">char</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">int</FONT></TT>, <TT><FONT FACE="Courier">long</FONT></TT>, <TT><FONT FACE="Courier">float</FONT></TT>, or <TT><FONT FACE="Courier">double</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">long</FONT></TT>, <TT><FONT FACE="Courier">float</FONT></TT>, or <TT><FONT FACE="Courier">double</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">float</FONT></TT> or <TT><FONT FACE="Courier">double</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=70><TT><FONT FACE="Courier">float</FONT></TT></TD>
<TD WIDTH=294><TT><FONT FACE="Courier">double</FONT></TT></TD>
</TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Literals"><FONT SIZE=5 COLOR=#FF0000>Literals</FONT></A>
</H2>
<P>
A literal is an explicit value that is used by a program. For
example, your program may include a literal value of 3.1415 that
is used whenever the value of <I>pi</I> is necessary, or it may
include 65 as the mandatory retirement age. These values, 3.1415
and 65, are both literals.
<H3><A NAME="IntegerLiterals">Integer Literals</A></H3>
<P>
Integer literals can be specified in decimal, hexadecimal, or
octal notation. To specify a decimal value, simply use the number
as normal. To indicate that a literal value is a long, you can
append either &quot;<TT><FONT FACE="Courier">L</FONT></TT>&quot;
or &quot;<TT><FONT FACE="Courier">l</FONT></TT>&quot; to the end
of the number. Hexadecimal values are given in base 16 and include
the digits 0-9 and the letters A-F. To specify a hexadecimal value,
use 0x followed by the digits and letters that comprise the value.
Similarly, an octal value is identified by a leading 0 symbol.
<P>
For examples of specifying integer literals, see Table 3.7.<BR>
<P>
<CENTER><B>Table 3.7. Examples of integer literals.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=67><I>Integer</I></TD><TD WIDTH=61><I>Long</I></TD>
<TD WIDTH=61><I>Octal</I></TD><TD WIDTH=106><I>Hexadecimal</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">0</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">0L</FONT></TT>
</TD><TD WIDTH=61><TT><FONT FACE="Courier">0</FONT></TT></TD>
<TD WIDTH=106><TT><FONT FACE="Courier">0x0</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">1</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">1L</FONT></TT>
</TD><TD WIDTH=61><TT><FONT FACE="Courier">01</FONT></TT></TD>
<TD WIDTH=106><TT><FONT FACE="Courier">0x1</FONT></TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">10</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">10L</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">012</FONT></TT>
</TD><TD WIDTH=106><TT><FONT FACE="Courier">0xA</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">15</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">15L</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">017</FONT></TT>
</TD><TD WIDTH=106><TT><FONT FACE="Courier">0XF</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">16</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">16L</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">020</FONT></TT>
</TD><TD WIDTH=106><TT><FONT FACE="Courier">0x10</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=67><TT><FONT FACE="Courier">100</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">100L</FONT></TT></TD><TD WIDTH=61><TT><FONT FACE="Courier">0144</FONT></TT>
</TD><TD WIDTH=106><TT><FONT FACE="Courier">0x64</FONT></TT></TD>
</TR>
</TABLE></CENTER>
<P>
<H3><A NAME="FloatingPointLiterals">Floating-Point Literals</A>
</H3>
<P>
Similar to integer literals are Java's floating-point literals.
Floating-point literals can be specified in either the familiar
decimal notation (for example, <TT><FONT FACE="Courier">3.1415</FONT></TT>)
or exponential notation (for example, <TT><FONT FACE="Courier">6.02e23</FONT></TT>).
To indicate that a literal is to be treated as a single precision
float, append either &quot;<TT><FONT FACE="Courier">f</FONT></TT>&quot;
or &quot;<TT><FONT FACE="Courier">F</FONT></TT>&quot;. To indicate
that it is to be treated as a double precision value, append either
&quot;<TT><FONT FACE="Courier">d</FONT></TT>&quot; or &quot;<TT><FONT FACE="Courier">D</FONT></TT>&quot;.
<P>
Java includes predefined constants, <TT><FONT FACE="Courier">POSITIVE_INFINITY</FONT></TT>,
<TT><FONT FACE="Courier">NEGATIVE_INFINITY</FONT></TT>, and <TT><FONT FACE="Courier">NaN</FONT></TT>,
to represent the infinity and not-a-number values.
<P>
The following list shows some valid floating-point literals:
<P><BLOCKQUOTE>
<TT><FONT FACE="Courier">43.3F<BR>
3.1415d<BR>
-12.123f<BR>
6.02e+23f<BR>
6.02e23d<BR>
6.02e-23f<BR>
6.02e23d</FONT></TT></BLOCKQUOTE>
<H3><A NAME="BooleanLiterals">Boolean Literals</A></H3>
<P>
Java supports two Boolean literals-<TT><FONT FACE="Courier">true</FONT></TT>
and <TT><FONT FACE="Courier">false</FONT></TT>.
<H3><A NAME="CharacterLiterals">Character Literals</A></H3>
<P>
A character literal is a single character or an escape sequence
enclosed in single quotes, for example, <TT><FONT FACE="Courier">'b'</FONT></TT>.
Escape sequences are used to indicate special characters or actions,
such as line feed, form feed, or carriage return. The available
escape sequences are shown in Table 3.8. For examples of character
literals, consider the following:
<P><BLOCKQUOTE>
<TT><FONT FACE="Courier">'b'<BR>
'\n'<BR>
\u15e'<BR>
'\t'<BR>
</FONT></TT></BLOCKQUOTE>
<P>
<CENTER><B>Table 3.8. Escape sequences.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=83><I>Sequence</I></TD><TD WIDTH=139><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\b</FONT></TT></TD>
<TD WIDTH=139>Backspace</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\t</FONT></TT></TD>
<TD WIDTH=139>Horizontal tab</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\n</FONT></TT></TD>
<TD WIDTH=139>Line feed</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\f</FONT></TT></TD>
<TD WIDTH=139>Form feed</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\r</FONT></TT></TD>
<TD WIDTH=139>Carriage return</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\&quot;</FONT></TT>
</TD><TD WIDTH=139>Double quote</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\'</FONT></TT></TD>
<TD WIDTH=139>Single quote</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\\</FONT></TT></TD>
<TD WIDTH=139>Backslash</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\uxxxx</FONT></TT></TD>
<TD WIDTH=139>Unicode character</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="StringLiterals">String Literals</A></H3>
<P>
Although there is no string primitive type in Java, you can include
string literals in your programs. Most applications and applets
will make use of some form of string literal, probably at least
for error messages. A string literal consists of zero or more
characters (including the escape sequences shown in Table 3.8)
enclosed in double quotes. As examples of string literals, consider
the following:
<P>
<TT><FONT FACE="Courier">&quot;A String&quot;<BR>
&quot;Column 1\tColumn 2&quot;<BR>
&quot;First Line\r\nSecond Line&quot;<BR>
&quot;First Page\fSecond Page&quot;<BR>
&quot;&quot;</FONT></TT>
<P>
Because Java does not have a string primitive type, each use of
a string literal causes an object of the <TT><FONT FACE="Courier">String</FONT></TT>
class to be created behind the scenes. However, because of Java's
automatic memory management, your program doesn't need to do anything
special to free or release the memory used by the literal or string
once you are finished with it.
<H2><A NAME="Arrays"><FONT SIZE=5 COLOR=#FF0000>Arrays</FONT></A>
</H2>
<P>
In Java you declare an array using enclosing square bracket symbols
(<TT><FONT FACE="Courier">[]</FONT></TT>). For example, consider
the following array declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[];<BR>
float floatArray[];<BR>
double [] doubleArray;<BR>
char charArray[];</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that the brackets can be placed before or after the variable
name. Placing the <TT><FONT FACE="Courier">[]</FONT></TT> after
the variable name follows the conventions of C, and if you are
coming to Java from C or C++, you may want to continue that tradition.
However, there is an advantage to placing the brackets before
the variable name. By placing the brackets in front of the variable
name, you can more easily declare multiple arrays. For example,
consider the following declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int [] firstArray, secondArray;<BR>
int thirdArray[], justAnInt;</FONT></TT>
</BLOCKQUOTE>
<P>
On the first line both <TT><FONT FACE="Courier">firstArray</FONT></TT>
and <TT><FONT FACE="Courier">secondArray</FONT></TT> are arrays.
On the second line, <TT><FONT FACE="Courier">thirdArray</FONT></TT>
is an array but <TT><FONT FACE="Courier">justAnInt</FONT></TT>
is, as its name implies, a lone integer. The ability to declare
singleton variables and arrays in the same statement, as on the
second line in the preceding example, is the source of many problems
in other programming languages. Java helps prevent this type of
problem by providing an easy, alternative syntax for declaring
arrays.
<H3><A NAME="Allocation">Allocation</A></H3>
<P>
Once an array is declared, it must be allocated. You probably
noticed that the size of the arrays has not been specified in
the examples so far. This is because, in Java, all arrays must
be allocated with <TT><FONT FACE="Courier">new</FONT></TT>. Declaring
the following array would have resulted in a compile-time error:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[10];&nbsp;&nbsp;&nbsp;//
this is an error</FONT></TT>
</BLOCKQUOTE>
<P>
To allocate an array you use <TT><FONT FACE="Courier">new</FONT></TT>,
as shown in the following examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = new int[100];<BR>
float floatArray[];<BR>
floatArray = new float[100];<BR>
long [] longArray = new long[100];<BR>
double [][] doubleArray = new double[10][10];</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="Initialization">Initialization</A></H3>
<P>
An alternative way of allocating a Java array is to specify a
list of element initializers when the array is declared. This
is done as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = {1,2,3,4,5};<BR>
char [] charArray = {'a', 'b', 'c'};<BR>
String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;,
&quot;Array&quot;};</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, <TT><FONT FACE="Courier">intArray</FONT></TT> will
be a five-element array holding the values 1 through 5. The three-element
array <TT><FONT FACE="Courier">charArray</FONT></TT> will hold
the characters <TT><FONT FACE="Courier">'a'</FONT></TT>, <TT><FONT FACE="Courier">'b'</FONT></TT>,
and <TT><FONT FACE="Courier">'c'</FONT></TT>. Finally, <TT><FONT FACE="Courier">stringArray</FONT></TT>
will hold the strings shown.
<H3><A NAME="ArrayAccess">Array Access</A></H3>
<P>
Items in a Java array are known as the components of the array.
You can access a component at runtime by enclosing the component
number you want to access with brackets as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int intArray[] = {100, 200, 300, 400,
500};<BR>
<BR>
int a = intArray[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
a will be equal to 100<BR>
int b = intArray[1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
b will be equal to 200<BR>
int c = intArray[2];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
c will be equal to 300<BR>
int d = intArray[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
d will be equal to 400<BR>
int e = intArray[4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
e will be equal to 500</FONT></TT>
</BLOCKQUOTE>
<P>
Java arrays are numbered from 0 to one less than the number of
components in the array. Attempting to access an array beyond
the bounds of the array (for example, <TT><FONT FACE="Courier">intArray[42]</FONT></TT>
in the preceding example) will result in a runtime exception,
<TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>.
Exception handling is discussed in detail in <A HREF="ch22.htm" >Chapter 22</A>,
&quot;Exception Handling.&quot;<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In many languages, especially C and C++, a string is really just an array of characters. This is not the case in Java. When working with Java strings, you should remind yourself that Java strings are instances of the Java <TT><FONT 
FACE="Courier">String</FONT></TT> class and are not simply arrays of characters.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="Operators"><FONT SIZE=5 COLOR=#FF0000>Operators</FONT></A>
</H2>
<P>
A language's operators can be used to combine or alter a program's
values. Java contains a very rich set of operators. The complete
list of Java operators is as follows:<BR>
<P>
<CENTER><B>A Complete List of Java Operators</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=61>=</TD><TD WIDTH=72>&gt;</TD><TD WIDTH=54>&lt;
</TD><TD WIDTH=54>!</TD><TD WIDTH=60>~</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>?</TD><TD WIDTH=72>:</TD><TD WIDTH=54>==</TD>
<TD WIDTH=54>&lt;=</TD><TD WIDTH=60>&gt;=</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>|=</TD><TD WIDTH=72>&amp;&amp;</TD><TD WIDTH=54>||
</TD><TD WIDTH=54>++</TD><TD WIDTH=60>--</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>+</TD><TD WIDTH=72>-</TD><TD WIDTH=54>*</TD>
<TD WIDTH=54>/</TD><TD WIDTH=60>&amp;</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>|</TD><TD WIDTH=72>^</TD><TD WIDTH=54>%</TD>
<TD WIDTH=54>&lt;&lt;</TD><TD WIDTH=60>&gt;&gt;</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>&gt;&gt;&gt;</TD><TD WIDTH=72>+=</TD><TD WIDTH=54>-=
</TD><TD WIDTH=54>*=</TD><TD WIDTH=60>/=</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>&amp;=</TD><TD WIDTH=72>|=</TD><TD WIDTH=54>^=
</TD><TD WIDTH=54>%=</TD><TD WIDTH=60>&lt;&lt;=</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61>&gt;&gt;=</TD><TD WIDTH=72>&gt;&gt;&gt;=</TD>
<TD WIDTH=54></TD><TD WIDTH=54></TD><TD WIDTH=60></TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="OperatorsonIntegers">Operators on Integers</A></H3>
<P>
The bulk of the Java operators work on integer values. The binary
operators (those that require two operands) are shown in Table
3.9. The unary operators (those that require a single operand)
are shown in Table 3.10. Each table gives an example of the use
of each operator.<BR>
<P>
<CENTER><B>Table 3.9. Binary operators on integers.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=178><I>Operation</I>
</TD><TD WIDTH=90><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=178>Assignment
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a = b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=178>Equality</TD><TD WIDTH=90><TT><FONT FACE="Courier">a == b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=178>Inequality</TD><TD WIDTH=90><TT><FONT FACE="Courier">a != b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=178>Less than</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &lt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=178>Less than or equal to</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &lt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=178>Greater than or equal to</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &gt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=178>Greater than</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=178>Addition
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a + b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=178>Subtraction
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a - b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=178>Multiplication
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a * b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=178>Division
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a / b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=178>Modulus
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a % b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;&lt;</FONT></TT>
</TD><TD WIDTH=178>Left shift</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &lt;&lt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;</FONT></TT>
</TD><TD WIDTH=178>Right shift</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &gt;&gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT>
</TD><TD WIDTH=178>Right shift with zero fill</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &gt;&gt;&gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;</FONT></TT></TD>
<TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a &amp; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">|</FONT></TT></TD><TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a | b</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">^</FONT></TT></TD><TD WIDTH=178>Bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD><TD WIDTH=90><TT><FONT FACE="Courier">a ^ b</FONT></TT></TD>
</TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 3.10. Unary operators on integers.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=177><I>Operation</I>
</TD><TD WIDTH=102><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=177>Unary negation
</TD><TD WIDTH=102><TT><FONT FACE="Courier">-a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=177>Bitwise logical negation
</TD><TD WIDTH=102><TT><FONT FACE="Courier">~a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=177>Increment</TD><TD WIDTH=102><TT><FONT FACE="Courier">a++</FONT></TT> or <TT><FONT FACE="Courier">++a</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=177>Decrement</TD><TD WIDTH=102><TT><FONT FACE="Courier">a--</FONT></TT> or <TT><FONT FACE="Courier">--a</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
In addition to the operators shown in Tables 3.9 and 3.10, Java
also includes an assortment of assignment operators that are based
on the other operators. These operators will operate on an operand
and store the resulting value back in the same operand. For example,
to increase the value of a variable x, you could do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">x += 3;</FONT></TT>
</BLOCKQUOTE>
<P>
This is equal to the more verbose <TT><FONT FACE="Courier">x =
x + 3</FONT></TT>. Each of the specialized Java assignment operators
performs its normal function on the operand and then stores the
value in the operand. The following assignment operators are available:
<BR>
<P>
<CENTER><B>Integer Assignment Operators</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=55>+=</TD><TD WIDTH=60>-=</TD><TD WIDTH=66>*=</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=55>/=</TD><TD WIDTH=60>&amp;=</TD><TD WIDTH=66>|=
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=55>^=</TD><TD WIDTH=60>%=</TD><TD WIDTH=66>&lt;&lt;=
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=55>&gt;&gt;=</TD><TD WIDTH=60>&gt;&gt;&gt;=</TD>
<TD WIDTH=66>&nbsp;</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="OperatorsonFloatingPointValues">Operators on Floating-Point
Values</A></H3>
<P>
The Java operators on floating-point values are a subset of those
available to Java integer types. The operators that may operate
on operands of type float and double are shown in Table 3.11,
which also gives examples of their uses.<BR>
<P>
<CENTER><B>Table 3.11. Binary operators on integers.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=174><I>Operation</I>
</TD><TD WIDTH=107><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=174>Assignment
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a = b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=174>Equality</TD><TD WIDTH=107><TT><FONT FACE="Courier">a == b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=174>Inequality</TD><TD WIDTH=107><TT><FONT FACE="Courier">a != b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=174>Less than</TD><TD WIDTH=107><TT><FONT FACE="Courier">a &lt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=174>Less than or equal to</TD><TD WIDTH=107><TT><FONT FACE="Courier">a &lt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=174>Greater than or equal to</TD><TD WIDTH=107><TT><FONT FACE="Courier">a &gt;= b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=174>Greater than</TD><TD WIDTH=107><TT><FONT FACE="Courier">a &gt; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=174>Addition
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a + b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=174>Subtraction
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a - b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=174>Multiplication
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a * b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=174>Division
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a / b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=174>Modulus
</TD><TD WIDTH=107><TT><FONT FACE="Courier">a % b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=174>Unary negation
</TD><TD WIDTH=107><TT><FONT FACE="Courier">-a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=174>Increment</TD><TD WIDTH=107><TT><FONT FACE="Courier">a++</FONT></TT> or <TT><FONT FACE="Courier">++a</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=174>Decrement</TD><TD WIDTH=107><TT><FONT FACE="Courier">a-- </FONT></TT>or <TT><FONT FACE="Courier">--a</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="OperatorsonBooleanValues">Operators on Boolean Values</A>
</H3>
<P>
The Java Boolean operators are summarized in Table 3.12. If you
are coming to Java from a C or C++ background, you are probably
already familiar with these. If not, however, the conditional
operator will be a new experience.<BR>
<P>
<CENTER><B>Table 3.12. Operators on Boolean values.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=79><I>Operator</I></TD><TD WIDTH=130><I>Operation</I>
</TD><TD WIDTH=186><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!</FONT></TT></TD><TD WIDTH=130>Negation
</TD><TD WIDTH=186><TT><FONT FACE="Courier">!a</FONT></TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">&amp;&amp;</FONT></TT>
</TD><TD WIDTH=130>Conditional <TT><FONT FACE="Courier">AND</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a &amp;&amp; b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">||</FONT></TT></TD>
<TD WIDTH=130>Conditional <TT><FONT FACE="Courier">OR</FONT></TT>
</TD><TD WIDTH=186><TT><FONT FACE="Courier">a || b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=130>Equality</TD><TD WIDTH=186><TT><FONT FACE="Courier">a == b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=130>Inequality</TD><TD WIDTH=186><TT><FONT FACE="Courier">a != b</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=79><TT><FONT FACE="Courier">?:</FONT></TT></TD>
<TD WIDTH=130>Conditional</TD><TD WIDTH=186><TT><FONT FACE="Courier">a ? expr1 : expr2</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The conditional operator is Java's only ternary (three-operand)
operator and has the following syntactic form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">booleanExpr ? expr1 : expr2</FONT></TT>
</BLOCKQUOTE>
<P>
The value of <TT><FONT FACE="Courier">booleanExpr</FONT></TT>
is evaluated and if <TT><FONT FACE="Courier">true</FONT></TT>,
the expression <TT><FONT FACE="Courier">expr1</FONT></TT> is executed;
if <TT><FONT FACE="Courier">false</FONT></TT>, expression <TT><FONT FACE="Courier">expr2</FONT></TT>
is executed. This makes the conditional operator a convenient
shorthand for the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if(booleanExpression)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;expr1<BR>
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;expr2</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ControllingYourProgram"><FONT SIZE=5 COLOR=#FF0000>Controlling
Your Program</FONT></A></H2>
<P>
The Java keywords for controlling program flow are nearly identical
to C and C++. This is one of the most obvious ways in which Java
shows its legacy as a derivative of these two languages. In this
section, you will see how to use Java's control flow commands
to write methods.
<H3><A NAME="Selection">Selection</A></H3>
<P>
The Java language provides two alternative structures-<TT><FONT FACE="Courier">if</FONT></TT>
statements and <TT><FONT FACE="Courier">switch</FONT></TT> statements-for
selecting among alternatives. Although it would be possible to
spend your entire Java programming career using only one of these
at the expense of the other, each has its definite advantages.
<H4>The <TT><FONT FACE="Courier">if</FONT></TT> Statement</H4>
<P>
A Java <TT><FONT FACE="Courier">if</FONT></TT> statement is a
test of any Boolean expression. If the Boolean expression evaluates
to <TT><FONT FACE="Courier">true</FONT></TT>, the statement following
the <TT><FONT FACE="Courier">if</FONT></TT> is executed. On the
other hand, if the Boolean expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>,
the statement following the <TT><FONT FACE="Courier">if</FONT></TT>
is not executed. For example, consider the following code fragment:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
if (today.getDay == 0) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Sunday.&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
This code uses the <TT><FONT FACE="Courier">java.Util.Date</FONT></TT>
package and creates a variable named <TT><FONT FACE="Courier">today</FONT></TT>
that will hold the current date. The <TT><FONT FACE="Courier">getDay</FONT></TT>
member method is then applied to <TT><FONT FACE="Courier">today</FONT></TT>
and the result compared to <TT><FONT FACE="Courier">0</FONT></TT>.
A return value of <TT><FONT FACE="Courier">0</FONT></TT> for <TT><FONT FACE="Courier">getDay</FONT></TT>
indicates that the day is Sunday, so if the Boolean expression
<TT><FONT FACE="Courier">today.getDay == 0</FONT></TT> is <TT><FONT FACE="Courier">true</FONT></TT>,
a message is displayed. If today isn't Sunday, no action occurs.
<P>
If you are coming to Java from a C or C++ background, you may
have been tempted to rewrite the preceding example as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
if (!today.getDay) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Sunday.&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
In C and C++, the expression <TT><FONT FACE="Courier">!today.getDay</FONT></TT>
would evaluate to <TT><FONT FACE="Courier">1</FONT></TT> whenever
<TT><FONT FACE="Courier">today.getDay</FONT></TT> evaluated to
<TT><FONT FACE="Courier">0</FONT></TT> (indicating Sunday). In
Java, the expression used within an <TT><FONT FACE="Courier">if</FONT></TT>
statement must evaluate to a Boolean. Therefore, this code doesn't
work because <TT><FONT FACE="Courier">!today.getDay</FONT></TT>
will evaluate to <TT><FONT FACE="Courier">0</FONT></TT> or <TT><FONT FACE="Courier">1</FONT></TT>,
depending on which day of the week it is. And, as you learned
earlier in this chapter, integer values cannot be cast to Boolean
values. This is, of course, an example where Java's nuances may
take a little getting used to for C and C++ programmers. Once
you're accustomed to the change, however, you will find your code
more readable, reliable, and maintainable.
<P>
Of course, an <TT><FONT FACE="Courier">if</FONT></TT> statement
without an <TT><FONT FACE="Courier">else</FONT></TT> is as incomplete
as a Labrador Retriever without a bandanna around his neck. Not
wanting to be accused of cruelty to animals or programmers, the
Java developers included an <TT><FONT FACE="Courier">else</FONT></TT>
statement that can be executed whenever an <TT><FONT FACE="Courier">if</FONT></TT>
statement evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
This can be seen in the following sample code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
if (today.getDay == 0) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Sunday.&quot;);
<BR>
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is NOT Sunday.&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the same message will be displayed whenever it is
Sunday, but a different message will be displayed whenever it
is not Sunday. Both examples so far have only shown the execution
of a single statement within the <TT><FONT FACE="Courier">if</FONT></TT>
or the <TT><FONT FACE="Courier">else </FONT></TT>cases. By enclosing
the statements within curly braces, you can execute as many lines
of code as you'd like. This can be seen in the following example
that makes some suggestions about how to spend each day of the
week:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
if (today.getDay == 0) then {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Sunday.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;And a good day
for golf.&quot;);<BR>
}<BR>
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is NOT Sunday.&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;But still a good
day for golf.&quot;);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Because it's possible to execute whatever code you desire in the
<TT><FONT FACE="Courier">else</FONT></TT> portion of an <TT><FONT FACE="Courier">if&#133;else</FONT></TT>
block, you may have already reasoned that it is possible to execute
another <TT><FONT FACE="Courier">if</FONT></TT> statement inside
the <TT><FONT FACE="Courier">else</FONT></TT> statement of the
first <TT><FONT FACE="Courier">if</FONT></TT> statement. This
is commonly known as an <TT><FONT FACE="Courier">if&#133;else
if&#133;else</FONT></TT> block, an example of which follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
if (today.getDay == 0) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Sunday.&quot;);
<BR>
else if (today.getDay == 1) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Monday.&quot;);
<BR>
else if (today.getDay == 2) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Tuesday.&quot;);
<BR>
else if (today.getDay == 3) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Wednesday.&quot;);
<BR>
else if (today.getDay == 4) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Thursday.&quot;);
<BR>
else if (today.getDay == 5) then<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It is Friday.&quot;);
<BR>
else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It must be Saturday.&quot;);</FONT></TT>
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">switch</FONT></TT> Statement
</H4>
<P>
As you can see from the previous code sample, a lengthy series
of <TT><FONT FACE="Courier">if&#133;else if&#133;else</FONT></TT>
statements can get convoluted and hard to read as the number of
cases increases. Fortunately, you can avoid this problem by using
Java's <TT><FONT FACE="Courier">switch</FONT></TT> statement.
Like its C and C++ cousins, the Java <TT><FONT FACE="Courier">switch</FONT></TT>
statement is ideal for testing a single expression against a series
of possible values and executing the code associated with the
matching <TT><FONT FACE="Courier">case</FONT></TT> statement,
as shown in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
switch (today.getDay) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 0:&nbsp;&nbsp;&nbsp;&nbsp;// Sunday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Sunday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 1:&nbsp;&nbsp;&nbsp;&nbsp;// Monday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Monday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 2:&nbsp;&nbsp;&nbsp;&nbsp;// Tuesday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Tuesday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 3:&nbsp;&nbsp;&nbsp;&nbsp;// Wednesday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Wednesday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 4:&nbsp;&nbsp;&nbsp;&nbsp;// Thursday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Thursday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 5:&nbsp;&nbsp;&nbsp;&nbsp;// Friday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
is Friday.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Have
a nice weekend!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;// Saturday
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It
must be Saturday.&quot;);<BR>
}<BR>
System.out.println(&quot;All done!&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
You should have noticed that each day has its own <TT><FONT FACE="Courier">case</FONT></TT>
within the <TT><FONT FACE="Courier">switch</FONT></TT>. The Saturday
case (where <TT><FONT FACE="Courier">today.getDay</FONT></TT>
= <TT><FONT FACE="Courier">6</FONT></TT>) is not explicitly given
but is instead handled by the <TT><FONT FACE="Courier">default</FONT></TT>
case. Any switch block may include an optional <TT><FONT FACE="Courier">default</FONT></TT>
case that will handle any values not caught by an explicit <TT><FONT FACE="Courier">case</FONT></TT>.
<P>
Within each <TT><FONT FACE="Courier">case</FONT></TT>, there can
be multiple lines of code. The block of code that will execute
for the Friday <TT><FONT FACE="Courier">case</FONT></TT>, for
example, contains three lines. The first two lines will simply
display informational messages, but the third is a <TT><FONT FACE="Courier">break</FONT></TT>
statement. The keyword <TT><FONT FACE="Courier">break</FONT></TT>
is used within a <TT><FONT FACE="Courier">case</FONT></TT> statement
to indicate that the flow of the program should move to the first
line following the <TT><FONT FACE="Courier">switch</FONT></TT>
block. In this example, <TT><FONT FACE="Courier">break</FONT></TT>
appears as the last statement in each case except the default
and will cause program execution to move to the line that prints
&quot;All done!&quot; The <TT><FONT FACE="Courier">break</FONT></TT>
statement was left out of the default block because by that point
in the code, the <TT><FONT FACE="Courier">switch</FONT></TT> block
was ending, and there was no point in using an explicit command
to exit the <TT><FONT FACE="Courier">switch</FONT></TT>.
<P>
If, as the previous example seems to imply, you always need to
include a <TT><FONT FACE="Courier">break</FONT></TT> statement
at the end of each block, why not just leave <TT><FONT FACE="Courier">break</FONT></TT>
out and have Java assume that after a block executes, control
should move outside the <TT><FONT FACE="Courier">switch</FONT></TT>
block? The answer is that there are times when you do not want
to break out of the <TT><FONT FACE="Courier">switch</FONT></TT>
statement after executing the code for a specific case value.
For example, consider the following code that could be used as
a scheduling system for physicians:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.util.Date;<BR>
Date today = new Date();<BR>
switch (today.getDay) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Sunday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Wednesday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Saturday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It's
Golf Day!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Tuesday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Tennis
at 8:00 am&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Monday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Thursday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Friday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Office
Hours: 10:00 - 5:00&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
}<BR>
System.out.println(&quot;All done!&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
This example illustrates a couple of key concepts about <TT><FONT FACE="Courier">switch</FONT></TT>
statements. First, you'll notice that it is possible to have multiple
cases execute the same block of code, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">case 0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Sunday<BR>
case 3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wednesday<BR>
case 6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Saturday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It's Golf Day!&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;</FONT></TT>
</BLOCKQUOTE>
<P>
This code will result in the message &quot;It's Golf Day&quot;
being displayed if the current day is Wednesday, Saturday, or
Sunday. If you collect the three cases together without any intervening
<TT><FONT FACE="Courier">break</FONT></TT> statements, each will
execute the same code. But consider what happens on Tuesday when
the following code executes:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">case 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Tuesday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Tennis at 8:00
am&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Certainly a reminder about the message match will be displayed,
but this case doesn't end with a <TT><FONT FACE="Courier">break</FONT></TT>
statement. Because Tuesday's code doesn't end with a <TT><FONT FACE="Courier">break</FONT></TT>
statement, the program will continue executing the code in the
following cases until a <TT><FONT FACE="Courier">break</FONT></TT>
is encountered. This means that Tuesday's code flows into the
code used for Monday, Thursday, and Friday as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">case 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Tuesday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Tennis at 8:00
am&quot;);<BR>
case 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Monday<BR>
case 4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Thursday<BR>
case 5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Friday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Office Hours:
10:00 - 5:00&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;break;</FONT></TT>
</BLOCKQUOTE>
<P>
This will result in the following messages being displayed every
Tuesday:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Tennis at 8:00 am<BR>
Office Hours: 10:00 - 5:00</FONT></TT>
</BLOCKQUOTE>
<P>
On Monday, Thursday, and Friday, only the latter message will
display.
<P>
In addition to writing <TT><FONT FACE="Courier">switch</FONT></TT>
statements that use integer cases, you can use character values
as shown in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">switch (aChar) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 'a':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 'e':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 'i':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 'o':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case 'u':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It's
a vowel!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;It's
a consonant!&quot;);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="Iteration">Iteration</A></H3>
<P>
Iteration is an important concept in any computer language. Without
the ability to loop or iterate through a set of values, our ability
to solve real-world problems would be severely limited. Java's
iteration statements are nearly identical to those found in C
and C++ and include <TT><FONT FACE="Courier">for</FONT></TT> loops,
<TT><FONT FACE="Courier">while</FONT></TT> loops, and <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loops.
<H4>The <TT><FONT FACE="Courier">for</FONT></TT> Statement</H4>
<P>
If Java programmers turn out to be anything like C or C++ programmers,
many of them will be partial to the <TT><FONT FACE="Courier">for</FONT></TT>
statement because of its syntactic elegance. The first line of
a <TT><FONT FACE="Courier">for</FONT></TT> loop enables you to
specify a starting value for a loop counter, specify the test
condition that will exit the loop, and indicate how the loop counter
should be incremented after each pass through the loop. This is
definitely a statement that offers a lot of bang for the buck.
The syntax of a Java <TT><FONT FACE="Courier">for</FONT></TT>
statement is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (initialization; testExpression;
incremement)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;statement</FONT></TT>
</BLOCKQUOTE>
<P>
For example, a sample <TT><FONT FACE="Courier">for</FONT></TT>
loop may appear as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count;<BR>
for (count=0; count&lt;100; count++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the initialization statement of the <TT><FONT FACE="Courier">for</FONT></TT>
loop sets count to <TT><FONT FACE="Courier">0</FONT></TT>. The
test expression, <TT><FONT FACE="Courier">count &lt; 100</FONT></TT>,
indicates that the loop should continue as long as <TT><FONT FACE="Courier">count</FONT></TT>
is less than <TT><FONT FACE="Courier">100</FONT></TT>. Finally,
the increment statement increments the value of <TT><FONT FACE="Courier">count</FONT></TT>
by one. As long as the test expression is true, the statement
following the <TT><FONT FACE="Courier">for</FONT></TT> loop setup
will be executed, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.println(&quot;Count = &quot;
+ count);</FONT></TT>
</BLOCKQUOTE>
<P>
Of course, you probably need to do more than one thing inside
the loop. This is as easy to do as using curly braces to indicate
the scope of the <TT><FONT FACE="Courier">for</FONT></TT> loop,
as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count;<BR>
for (count=0; count&lt;100; count++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;YourMethod(count);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
One nice shortcut that can be taken with a Java <TT><FONT FACE="Courier">for</FONT></TT>
loop is to declare and initialize the variable used in the loop.
For example, in the following code, the variable <TT><FONT FACE="Courier">count</FONT></TT>
is declared directly within the <TT><FONT FACE="Courier">for</FONT></TT>
loop:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (int count=0; count&lt;100; count++)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);</FONT></TT>
</BLOCKQUOTE>
<P>
It may look like an inconsequential difference whether you declare
a variable before a <TT><FONT FACE="Courier">for</FONT></TT> loop
or within the loop. However, there are advantages to declaring
the variable within the loop. First, it makes your intention to
use the variable within the loop clear. If the variable is declared
above the <TT><FONT FACE="Courier">for</FONT></TT> loop, how will
you remember (and how will future programmers know) that the variable
was intended for use only <I>within</I> the loop? Second, a variable
declared within the <TT><FONT FACE="Courier">for</FONT></TT> loop
will go out of scope at the end of the loop. This means you could
not write the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (int count=0; count&lt;100; count++)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);<BR>
System.out.println(&quot;Loop exited with count = &quot; + count);</FONT></TT>
</BLOCKQUOTE>
<P>
The last line cannot find a variable named <TT><FONT FACE="Courier">count</FONT></TT>
because <TT><FONT FACE="Courier">count</FONT></TT> goes out of
scope when the <TT><FONT FACE="Courier">for</FONT></TT> loop terminates.
This means that, in addition to making the intended purpose of
the variable more clear, it is also impossible to accidentally
bypass that intent and use the variable outside the loop.
<P>
You can also leave out portions of the first line of a <TT><FONT FACE="Courier">for</FONT></TT>
loop. In the following example, the increment statement has been
left out:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (int count=0; count&lt;100; ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count += 2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Of course, leaving the increment statement out of the <TT><FONT FACE="Courier">for</FONT></TT>
loop declaration in this example doesn't achieve any useful purpose
since <TT><FONT FACE="Courier">count</FONT></TT> is incremented
inside the loop.
<P>
It is possible to get even fancier with a Java <TT><FONT FACE="Courier">for</FONT></TT>
loop by including multiple statements or conditions. For example,
consider the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (int up=0, down = 20; up &lt; down;
up++, down -= 2 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Up = &quot; +
up + &quot;\tDown = &quot; + down);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This loop starts the variable <TT><FONT FACE="Courier">up</FONT></TT>
at <TT><FONT FACE="Courier">0</FONT></TT> and increments it by
<TT><FONT FACE="Courier">1</FONT></TT>. It also starts the variable
<TT><FONT FACE="Courier">down</FONT></TT> at <TT><FONT FACE="Courier">20</FONT></TT>
and decrements it by <TT><FONT FACE="Courier">2</FONT></TT> for
each pass through the loop. The loop continues until <TT><FONT FACE="Courier">up</FONT></TT>
has been incremented enough that it is equal to or greater than
the variable <TT><FONT FACE="Courier">down</FONT></TT>.
<P>
The test expression portion of a Java <TT><FONT FACE="Courier">for</FONT></TT>
loop can be any Boolean expression. Because of this, it does not
need to be a simple test (<TT><FONT FACE="Courier">x &lt; 10</FONT></TT>),
as shown in the preceding examples. The test expression can be
a method call, a method call combined with a value test, or anything
 that can be phrased as a Boolean expression. For example, suppose
you want to write a method that will display a message indicating
the first year since World War II that the Chicago Cubs appeared
in the World Series. You could do this as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public boolean DidCubsPlayInWorldSeries(int
year) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boolean retval;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch(year) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1907:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// these are years the Cubs won<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1908:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1906:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// these are years the Cubs lost<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1910:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1918:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1929:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1932:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1935:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1938:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1945:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval
= false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return retval;<BR>
}<BR>
<BR>
public void FindFirstAfterWWII() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int year=1946; DidCubsPlayInWorldSeries(year)==false;
year++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;The
Cubs didn't play in &quot; + year);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The method <TT><FONT FACE="Courier">DidCubsPlayInWorldSeries</FONT></TT>
is passed an integer value indicating the year and returns a Boolean
value that indicates whether or not the Cubs made it to the World
Series in that year. This method is an example of the <TT><FONT FACE="Courier">switch</FONT></TT>
statement shown earlier in this chapter.
<P>
The method <TT><FONT FACE="Courier">FindFirstAfterWWII</FONT></TT>
uses a <TT><FONT FACE="Courier">for</FONT></TT> loop to find a
year in which the Cubs played in the World Series. The loop starts
<TT><FONT FACE="Courier">year</FONT></TT> with 1946 and increments
<TT><FONT FACE="Courier">year</FONT></TT> by one for each pass
through the loop. The test expression for the loop will allow
the loop to continue as long as the method <TT><FONT FACE="Courier">DidCubsPlayInWorldSeries</FONT></TT>
returns <TT><FONT FACE="Courier">false</FONT></TT>. This is a
useful example because it shows that a method can be called within
the test expression of a <TT><FONT FACE="Courier">for</FONT></TT>
loop. Unfortunately, it is a bad example in that the Cubs haven't
won the World Series since the goose step was popular in Berlin,
and there is no sign of that changing in the near future. In other
words, a loop that looks for a Cubs World Series appearance after
1945 is an infinite loop.
<H4>The <TT><FONT FACE="Courier">while</FONT></TT> Statement</H4>
<P>
Related to the <TT><FONT FACE="Courier">for</FONT></TT> loop is
the <TT><FONT FACE="Courier">while</FONT></TT> loop. The syntax
for a <TT><FONT FACE="Courier">while</FONT></TT> loop is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while (booleanExpression)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;statement</FONT></TT>
</BLOCKQUOTE>
<P>
As you can tell from the simplicity of this, the Java <TT><FONT FACE="Courier">while</FONT></TT>
loop does not have the built-in support for initializing and incrementing
variables that its <TT><FONT FACE="Courier">for</FONT></TT> loop
does. Because of this, you need to be careful to initialize loop
counters prior to the loop and increment them within the body
of the <TT><FONT FACE="Courier">while</FONT></TT> loop. For example,
the following code fragment will display a message five times:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int count = 0;<BR>
while (count &lt; 5) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Count = &quot;
+ count);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count++;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">do&#133;while</FONT></TT> Statement
</H4>
<P>
The final looping construct in Java is the <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loop. The syntax for a <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loop is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">do {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;statement<BR>
} while (booleanExpression);</FONT></TT>
</BLOCKQUOTE>
<P>
This is similar to a <TT><FONT FACE="Courier">while</FONT></TT>
loop except that a <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loop is guaranteed to execute at least once. It is possible that
a <TT><FONT FACE="Courier">while</FONT></TT> loop may not execute
at all depending on the test expression used in the loop. For
example, consider the following method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void ShowYears(int year) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (year &lt; 2000) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Year
is &quot; + year);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method is passed a year value, then loops over the year displaying
a message as long as the year is less than 2000. If <TT><FONT FACE="Courier">year</FONT></TT>
starts at 1996, then messages will be displayed for the years
1996, 1997, 1998, and 1999. However, what happens if <TT><FONT FACE="Courier">year</FONT></TT>
starts at 2010? Because the initial test, <TT><FONT FACE="Courier">year
&lt; 2000</FONT></TT>, will be <TT><FONT FACE="Courier">false</FONT></TT>,
the <TT><FONT FACE="Courier">while</FONT></TT> loop will never
be entered. Fortunately, a <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loop can solve this problem. Because a <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loop performs its expression testing after the body of the loop
has executed for each pass, it will always be executed at least
once. This is a very valid distinction between the two types of
loop, but it can also be a source of potential errors. Whenever
you use a <TT><FONT FACE="Courier">do&#133;while</FONT></TT> loop,
you should be careful to consider the first pass through the body
of the loop.
<H3><A NAME="Jumping">Jumping</A></H3>
<P>
Of course, it is not always easy to write all of your <TT><FONT FACE="Courier">for</FONT></TT>,
<TT><FONT FACE="Courier">while</FONT></TT> and <TT><FONT FACE="Courier">do&#133;while</FONT></TT>
loops so that they are easy to read and yet the loops terminate
on exactly the right pass through the loop. Java makes it easier
to jump out of loops and to control other areas of program flow
with its <TT><FONT FACE="Courier">break</FONT></TT> and <TT><FONT FACE="Courier">continue</FONT></TT>
statements.
<H4>The <TT><FONT FACE="Courier">break</FONT></TT> Statement</H4>
<P>
Earlier in this chapter, you saw how the <TT><FONT FACE="Courier">break</FONT></TT>
statement is used to exit a <TT><FONT FACE="Courier">switch</FONT></TT>
statement. In a similar manner, <TT><FONT FACE="Courier">break</FONT></TT>
can be used to exit a loop. This can be seen in Figure 3.1.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f3-1.gif" ><B>Figure 3.1 : </B><I>Flow of control with a break statement.</I></A>
<P>
As Figure 3.1 illustrates, if the <TT><FONT FACE="Courier">break</FONT></TT>
statement is encountered, execution will continue with <TT><I><FONT FACE="Courier">statement4</FONT></I></TT>.
As an example of this, consider the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int year = 1909;<BR>
while (DidCubsWinTheWorldSeries(year) == false) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Didn't win in
&quot; + year);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (year &gt;= 3000) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Time
to give up. Go White Sox!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
System.out.println(&quot;Loop exited on year &quot; + year);</FONT></TT>
</BLOCKQUOTE>
<P>
This example shows a <TT><FONT FACE="Courier">while</FONT></TT>
loop that will continue to execute until it finds a year that
the Chicago Cubs won the World Series. Because they haven't won
since 1908 and the loop counter <TT><FONT FACE="Courier">year</FONT></TT>
starts with 1909, it has a lot of looping to do. For each year
they didn't win, a message is displayed. However, even die-hard
Cubs fans will eventually give up and change allegiances to the
Chicago White Sox. In this example, if the year is 3000 or later,
a message is displayed and then a <TT><FONT FACE="Courier">break</FONT></TT>
is encountered. The <TT><FONT FACE="Courier">break</FONT></TT>
statement will cause program control to move to the first statement
after the end of the <TT><FONT FACE="Courier">while</FONT></TT>
loop. In this case, that will be the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.println(&quot;Loop exited
on year &quot; + year);</FONT></TT>
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">continue</FONT></TT> Statement
</H4>
<P>
Just as a <TT><FONT FACE="Courier">break</FONT></TT> statement
can be used to move program control to immediately after the end
of a loop, the <TT><FONT FACE="Courier">continue</FONT></TT> statement
can be used to force program control back to the top of a loop.
This can be seen in Figure 3.2.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f3-2.gif" ><B>Figure 3.2 : </B><I>Flow of control with a continue statement.</I></A>
<P>
Suppose you want to write a method that will count and display
the number of times the Cubs have won the World Series this century.
One way to do this would be to first see if the Cubs played in
the World Series and then see if they won. This could be done
as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int timesWon = 0;<BR>
for (int year=1900; year &lt;= 2000; year++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (DidCubsPlayInWorldSeries(year) = false)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (DidCubsWinWorldSeries(year)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Cubbies
won in &quot; + year + &quot;!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timesWon++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
System.out.println(&quot;The Cubs won &quot; + timesWon + &quot;
times.&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, a <TT><FONT FACE="Courier">for</FONT></TT> loop
is used to iterate through the years from 1900 to 2000. The first
line within the loop tests to see if the Cubs played in the World
Series. If they didn't, the <TT><FONT FACE="Courier">continue</FONT></TT>
statement is executed. This moves program control back to the
<TT><FONT FACE="Courier">for</FONT></TT> loop. At that point,
<TT><FONT FACE="Courier">year</FONT></TT> is incremented and the
expression <TT><FONT FACE="Courier">year &lt;= 2000</FONT></TT>
is retested. If <TT><FONT FACE="Courier">year</FONT></TT> is less
than or equal to 2000, the loop continues. If, however, <TT><FONT FACE="Courier">DidCubsPlayInWorldSeries</FONT></TT>
equals <TT><FONT FACE="Courier">true</FONT></TT>, then the <TT><FONT FACE="Courier">continue</FONT></TT>
statement is skipped, and the next test is performed to see if
the Cubs won that year.
<H4>Using Labels</H4>
<P>
Java does not include a <TT><FONT FACE="Courier">goto</FONT></TT>
statement. However, the fact that <TT><FONT FACE="Courier">goto</FONT></TT>
is a reserved word indicates that it may be added in a future
version. Instead of <TT><FONT FACE="Courier">goto</FONT></TT>,
Java allows you to combine <TT><FONT FACE="Courier">break</FONT></TT>
and <TT><FONT FACE="Courier">continue</FONT></TT> with a label.
This has an effect similar to a <TT><FONT FACE="Courier">goto</FONT></TT>
in that it allows a program to reposition control. In order to
understand the use of labels with <TT><FONT FACE="Courier">break</FONT></TT>
and <TT><FONT FACE="Courier">continue</FONT></TT>, consider the
following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int line=1;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;outsideLoop:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(int out=0; out&lt;3; out++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;out
= &quot; + out, 5, line * 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line++;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int inner=0;inner
&lt; 5; inner++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double
randNum = Math.random();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(Double.toString(randNum),
15, line * 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(randNum &lt; .10) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;break
to outsideLoop&quot;, 25, line * 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(randNum &lt; .60) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;continue
to outsideLoop&quot;, 25, line * 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
outsideLoop;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;all done&quot;, 50,
line * 20);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This example includes two loops. The first loops on the variable
<TT><FONT FACE="Courier">out</FONT></TT>, and the second loops
on the variable <TT><FONT FACE="Courier">inner</FONT></TT>. The
outer loop has been labeled by the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">outsideLoop:</FONT></TT>
</BLOCKQUOTE>
<P>
This statement will serve as a placeholder and as a name for the
outer loop. A random number between 0 and 1 is generated for each
iteration through the inner loop. This number is displayed on
the screen. If the random number is less than 0.10, the statement
<TT><FONT FACE="Courier">break outsideLoop</FONT></TT> is executed.
A normal <TT><FONT FACE="Courier">break</FONT></TT> statement
in this position would break out of the inner loop. However, since
this is a labeled <TT><FONT FACE="Courier">break</FONT></TT> statement,
it has the effect of breaking out of the loop identified by the
name. In this case, program control passes to the line that displays
&quot;all done&quot; since that is the first line after <TT><FONT FACE="Courier">outsideLoop</FONT></TT>.
<P>
On the other hand, if the random number is not less than 0.10,
the number is compared to 0.60. If it is less than this, the statement
<TT><FONT FACE="Courier">continue outsideLoop</FONT></TT> is executed.
A normal, unlabeled <TT><FONT FACE="Courier">continue</FONT></TT>
statement at this point would have the effect of transferring
program control back to the top of the inner loop. Because this
is a labeled <TT><FONT FACE="Courier">continue</FONT></TT> statement,
program control is transferred to the start of the named loop.
A sample run of this method, as captured in the Java Applet Viewer,
is shown in Figure 3.3.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f3-3.gif" ><B>Figure 3.3 : </B><I>Sample results demonstrating the use of labels.</I></A>
<P>
As you can see in Figure 3.3, the first pass through the outer
loop resulted in four passes through the inner loop. When the
value 0.518478 was generated, it caused the <TT><FONT FACE="Courier">continue
outsideLoop</FONT></TT> to execute because the number is less
than 0.60. The next pass through the outer loop was similar except
that it did a <TT><FONT FACE="Courier">continue</FONT></TT> of
the outer loop after only one iteration through the inner loop.
Finally, on the third pass through the outer loop, the program
generated a value lower than 0.10, which caused the program to
break to the outer loop. You can see that, at this point, the
next line of code to be executed was the first line of code after
the outer loop (the line that prints the message &quot;all done&quot;).
<H2><A NAME="JavaClasses"><FONT SIZE=5 COLOR=#FF0000>Java Classes</FONT></A>
</H2>
<P>
Now that you've seen most of the low-level details of the Java
language, it's time to turn your attention to Java classes and
see how Java is able to live up to its claim of being an object-oriented
language. A Java class is a compile-time concept that represents
a runtime object. In other words, a class is a definition or template
for an object that will exist within the program. For example,
if you have a class called <TT><FONT FACE="Courier">Car</FONT></TT>,
you may have a particular instance of that class that is a 1966
Volkswagen Beetle. The instances (1966 Volkswagen Beetle) of a
class (<TT><FONT FACE="Courier">Car</FONT></TT>) are known as
objects. In order to define a class in Java, you would do something
similar to the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member variables<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="FieldDeclarations">Field Declarations</A></H3>
<P>
<TT><FONT FACE="Courier">Car</FONT></TT> is now an empty class.
In order to make it usable and useful, you need to add some fields
to the class. A field can be either a member variable or a member
method. To declare member variables, all you need to do is identify
the variable by type and name in the class definition, as shown
in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// these are member variables<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int passengers;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">Car</FONT></TT> has
been extended to include <TT><FONT FACE="Courier">String</FONT></TT>
variables for manufacturer and model, and integer variables for
the year it was built and the number of passengers it can hold.
From this class definition, it is then possible to create instances,
or objects, at runtime, as shown in Figure 3.4.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f3-4.gif" ><B>Figure 3.4 : </B><I>The Car class and objects.</I></A>
<H4>Field Access</H4>
<P>
One of the principal advantages of object-oriented programming
is <I>encapsulation</I>. Encapsulation is the ability to define
classes that hide their implementation details from other classes,
exposing only their public interfaces to those other classes.
Support for encapsulation in Java comes from three keywords: <TT><FONT FACE="Courier">public</FONT></TT>,
<TT><FONT FACE="Courier">private</FONT></TT>, and <TT><FONT FACE="Courier">protected</FONT></TT>.
When you are defining a class, these field access modifiers are
used to control who has access to each field in the class. By
declaring a field as <TT><FONT FACE="Courier">public</FONT></TT>,
you are indicating that it is entirely accessible to all other
classes. Continuing with the <TT><FONT FACE="Courier">Car</FONT></TT>
example, to declare all of the fields as <TT><FONT FACE="Courier">public</FONT></TT>,
do the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int passengers;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Of course, declaring everything as public doesn't exactly achieve
the goal of encapsulation because it lets other classes directly
access variables in the <TT><FONT FACE="Courier">Car</FONT></TT>
class. Consider what would happen if you needed to create an instance
of this class for a 1964-and-a-half Mustang. Because <TT><FONT FACE="Courier">year</FONT></TT>
only holds integer values, it would have to be changed to a <TT><FONT FACE="Courier">float</FONT></TT>
so that it could hold 1964.5. If code in other classes directly
accessed <TT><FONT FACE="Courier">year</FONT></TT>, that code
could conceivably break.
<P>
To restrict access to a field, use the keyword <TT><FONT FACE="Courier">private</FONT></TT>.
A class cannot access the private fields of another class. Suppose
the <TT><FONT FACE="Courier">Car</FONT></TT> class is intended
for use in a used car sales application. In this case, you may
want to define <TT><FONT FACE="Courier">Car</FONT></TT> as follows
in order to hide your cost for a car from potential buyers:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int passengers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float cost;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the keyword <TT><FONT FACE="Courier">protected</FONT></TT>
is used to indicate that fields are accessible within the current
class and all classes derived from the class, but not to other
classes. The ability to derive a class from another class will
be discussed later in this chapter.
<H4>Setting Initial Values</H4>
<P>
One extremely nice aspect of Java class declarations that is a
deviation from C++ is the ability to specify initial values for
member variables in the variable declaration. For example, because
most cars will hold four passengers, it may be reasonable to default
the <TT><FONT FACE="Courier">passengers</FONT></TT> member variable
to 4, as shown in the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int passengers = 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float cost;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4>Static Members</H4>
<P>
In addition to <TT><FONT FACE="Courier">private</FONT></TT>, <TT><FONT FACE="Courier">protected</FONT></TT>,
and <TT><FONT FACE="Courier">public</FONT></TT> members, a Java
class can also have static members. A <I>static member</I> is
one that belongs to the class itself, not to the instances of
the class. Regardless of how many instances of a class have been
created by a program at runtime, there will exist exactly one
instance of each static member. Declaring a static member is done
by adding the keyword <TT><FONT FACE="Courier">static</FONT></TT>
to any of the other field access modifiers, as shown in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int passengers = 4;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float cost;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static int tireQty = 4;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the variable <TT><FONT FACE="Courier">tireQty</FONT></TT>
has been added and is set to <TT><FONT FACE="Courier">4</FONT></TT>.
Because every car will have four tires, <TT><FONT FACE="Courier">tireQty</FONT></TT>
was declared as <TT><FONT FACE="Courier">static</FONT></TT>. Also,
because we want <TT><FONT FACE="Courier">tireQty</FONT></TT> to
be accessible to other classes, it has been declared <TT><FONT FACE="Courier">public</FONT></TT>.
<P>
It is also possible to declare member methods as <TT><FONT FACE="Courier">static</FONT></TT>,
as will be shown later in this chapter.
<H4>Member Methods</H4>
<P>
In addition to member variables, most classes will also have member
methods. Because member methods, like member variables, are fields,
access to them can be controlled with the <TT><FONT FACE="Courier">public</FONT></TT>,
<TT><FONT FACE="Courier">protected</FONT></TT>, and <TT><FONT FACE="Courier">private</FONT></TT>
modifiers. A member method is declared according to the following
syntax, in which elements enclosed in square brackets &quot;[&#133;]&quot;
are optional:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">[methodModifiers] resultType methodName
[throws exceptionList] {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// method body<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">methodModifiers</FONT></TT> are the
familiar <TT><FONT FACE="Courier">public</FONT></TT>, <TT><FONT FACE="Courier">protected</FONT></TT>,
and <TT><FONT FACE="Courier">private</FONT></TT> keywords you've
already seen as well as some additional modifiers. The method
modifiers are described in Table 3.13.<BR>
<P>
<CENTER><B>Table 3.13. Method modifiers.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=138><I>Modifier</I></TD><TD WIDTH=453><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">public</FONT></TT>
</TD><TD WIDTH=453>Accessible outside the class in which it is declared.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Protected</FONT></TT>
</TD><TD WIDTH=453>Accessible by the class in which it is declared and by subclasses of that class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Private</FONT></TT>
</TD><TD WIDTH=453>Accessible only by the class in which it is declared.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Static</FONT></TT>
</TD><TD WIDTH=453>A method of the class rather than of a particular instance of the class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Abstract</FONT></TT>
</TD><TD WIDTH=453>Not implemented in this class.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Final</FONT></TT></TD>
<TD WIDTH=453>Cannot be overridden in subclasses.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Native</FONT></TT>
</TD><TD WIDTH=453>A platform-dependent implementation of the method in another language, typically C or assembly.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Synchronized</FONT></TT>
</TD><TD WIDTH=453>Used to indicate a critical method that will lock the object to prevent execution of other methods while the synchronized method executes.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT><FONT FACE="Courier">resultType</FONT></TT> of a method
declaration can be one of the primitive types (for example, <TT><FONT FACE="Courier">int</FONT></TT>,
<TT><FONT FACE="Courier">float</FONT></TT>, <TT><FONT FACE="Courier">char</FONT></TT>),
another class, or <TT><FONT FACE="Courier">void</FONT></TT>. A
<TT><FONT FACE="Courier">resultType</FONT></TT> of <TT><FONT FACE="Courier">void</FONT></TT>
indicates that no result is passed back to the caller of the method.
After the method name is given, a list of exceptions throwable
by the method is given. If no exceptions are thrown by the method,
this list is not necessary. Exception handling is discussed in
full in <A HREF="ch22.htm" >Chapter 22</A>.
<P>
As an example of adding a method to the <TT><FONT FACE="Courier">Car</FONT></TT>
class, consider the following sample code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int passengers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public float CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cost *
1.5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float cost;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the <TT><FONT FACE="Courier">Car</FONT></TT> class
has had a public member method, <TT><FONT FACE="Courier">CalculateSalePrice</FONT></TT>,
added. The method returns a <TT><FONT FACE="Courier">float</FONT></TT>,
and the body of the method calculates this return value. To calculate
the sale price of a car, the private member variable <TT><FONT FACE="Courier">cost</FONT></TT>
is multiplied by 1.5, reflecting a markup of 50% over the amount
the car was purchased for.
<H4>Overloaded Methods</H4>
<P>
The ability to overload methods is one of the biggest advantages
to working in an object oriented language, and Java certainly
doesn't disappoint. Overloading a method means to use the same
method name for more than one method. For example, the <TT><FONT FACE="Courier">Car</FONT></TT>
class can include two <TT><FONT FACE="Courier">CalculateSalePrice</FONT></TT>
methods, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public float CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return cost * 1.5;<BR>
}<BR>
<BR>
public float CalculateSalePrice(double margin) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return cost * (1 + margin);<BR>
}<BR>
private float cost;</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the first version of <TT><FONT FACE="Courier">CalculateSalePrice</FONT></TT>
is not passed any parameters and bases the sale price on the cost
plus 50% (<TT><FONT FACE="Courier">cost * 1.5</FONT></TT>). The
second version is passed a margin by which the car should be marked
up in determining the car's sale price.
<P>
At runtime, Java is able to distinguish between these methods
by the parameters passed to each. Because of this you can overload
a method as many times as you want as long as the parameter lists
of each version are unique. In other words, you could not do the
following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public float CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return cost * 1.5;<BR>
}<BR>
<BR>
public float CalculateSalePrice(double margin) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return cost * (1 + margin);<BR>
}<BR>
<BR>
// this method declaration conflicts with the preceding method
<BR>
public float CalculateSalePrice(double multiplier) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return cost * margin;<BR>
}<BR>
private float cost;</FONT></TT>
</BLOCKQUOTE>
<P>
In this situation, the last two declarations are in conflict because
each is passed a <TT><FONT FACE="Courier">double</FONT></TT>.
Different parameter names are insufficient to distinguish between
two versions of the same overloaded function. They must differ
by at least one parameter type.
<H4>Constructors</H4>
<P>
A special type of member method is known as a <I>constructor</I>.
A constructor is used to create new instances of a class. You
can identify a constructor because it will have the same name
as the class. Like any other method, a constructor can be overloaded
as long as the versions are distinguishable by the parameter types
passed to each. Typically, a constructor will set the member variables
of an object to values appropriate for that instance. As an example,
consider the following variation on the <TT><FONT FACE="Courier">Car</FONT></TT>
class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int passengers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float cost;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the sale price of a car based
on its cost<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public double CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cost *
1.5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a public constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Car(String madeBy, String name,
int yr, int pass,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
cst) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer =
madeBy;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model = name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year = yr;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;passengers = pass;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cost = cst;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// create and return a string with the
basic details about<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// this particular car<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetStats() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new String(year
+ &quot; &quot; + manufacturer + &quot; &quot; + model);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
A constructor, <TT><FONT FACE="Courier">Car</FONT></TT>, has been
added to this version of the <TT><FONT FACE="Courier">Car</FONT></TT>
class. The constructor is passed five parameters that will be
used as initial values for the instance variables <TT><FONT FACE="Courier">manufacturer</FONT></TT>,
<TT><FONT FACE="Courier">model</FONT></TT>, <TT><FONT FACE="Courier">year</FONT></TT>,
<TT><FONT FACE="Courier">passengers</FONT></TT>, and <TT><FONT FACE="Courier">cost</FONT></TT>.
The code for the constructor simply sets the five instance variables.
The <TT><FONT FACE="Courier">Car</FONT></TT> class has also received
a new public member, <TT><FONT FACE="Courier">GetStats</FONT></TT>,
that creates a string that contains the basic facts about the
car. By using the constructor and the new <TT><FONT FACE="Courier">GetStats</FONT></TT>
method, you can now display some information about a car. For
example, the following code will display &quot;1967 VW Bug&quot;:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Car myCar = new Car(&quot;VW&quot;, &quot;Bug&quot;,
1967, 4, 3000);<BR>
String str = myCar.GetStats();<BR>
System.out.println(str);</FONT></TT>
</BLOCKQUOTE>
<P>
The new instance of the class <TT><FONT FACE="Courier">Car</FONT></TT>
was created with the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Car myCar = new Car(&quot;VW&quot;, &quot;Bug&quot;,
1967, 4, 3000);</FONT></TT>
</BLOCKQUOTE>
<P>
The use of the Java keyword <TT><FONT FACE="Courier">new</FONT></TT>
instructs Java to create a new object of type <TT><FONT FACE="Courier">Car</FONT></TT>
by allocating memory for it and to invoke the constructor for
<TT><FONT FACE="Courier">Car</FONT></TT> whose signature matches
the parameter list. In this case, <TT><FONT FACE="Courier">Car</FONT></TT>
has only one constructor, so it is invoked and will set the instance
variables to the values of the parameters. Once the variable <TT><FONT FACE="Courier">myCar</FONT></TT>
goes out of scope at the end of the function in which it is declared,
the automatic memory management features of Java will detect that
the memory that was allocated by <TT><FONT FACE="Courier">new</FONT></TT>
is no longer referenced and it will be released.<BR>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If a class does not specifically include a constructor, Java will provide a default constructor that takes no parameters. This constructor will allow you to create new instances of a class and will set all member variables to their Java system default 
values. However, it is a dangerous and unwise practice to rely on the existence of a Java default constructor. In general, you should always provide at least one constructor for each class you define.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>The <TT><FONT FACE="Courier">this</FONT></TT> Variable</H4>
<P>
All Java classes contain a hidden member variable named <TT><FONT FACE="Courier">this</FONT></TT>.
The <TT><FONT FACE="Courier">this</FONT></TT> member can be used
at runtime to reference the object itself. One excellent use of
<TT><FONT FACE="Courier">this</FONT></TT> is in constructors.
It is very common to have a set of instance variables in a class
that must be set to values that are passed to a constructor. When
you are doing this, it would be nice to have code that was similar
to the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">year = year;</FONT></TT>
</BLOCKQUOTE>
<P>
Ideally the variable on the left could be the instance variable,
and the variable on the right could be the parameter passed to
the constructor. Unfortunately, I don't know of any languages
that would be able to make this distinction. The typical solution
most programmers have settled on is similar to the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int passengers;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a public constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Car(String madeBy, String name,
int yr, int pass,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
cst) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;manufacturer =
madeBy;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model = name;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year = yr;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;passengers = pass;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cost = cst;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Here, we've had to come up with two names for each concept: the
best variable names (manufacturer, model, and so on) are used
as the instance variables in the class declaration. The less satisfactory
names are passed as parameters so as to distinguish them from
the instance variables. The assignment statements are then very
readable by Java but seem a little contrived to human readers.
Java's <TT><FONT FACE="Courier">this</FONT></TT> keyword provides
a very effective solution to this problem in that the constructor
can be written as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String model;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int passengers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float cost;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the sale price of a car based
on its cost<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public double CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cost *
1.5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a public constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Car(String manufacturer, String
model, int year,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
passengers, float cost) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.manufacturer
= manufacturer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.model = model;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.year = year;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.passengers
= passengers;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cost = cost;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this case, the variables like <TT><FONT FACE="Courier">this.year</FONT></TT>
refer to the instance variables, whereas the unqualified variables
like <TT><FONT FACE="Courier">year</FONT></TT> refer to the constructor's
parameters.
<P>
Of course, this is only one example of how you can use <TT><FONT FACE="Courier">this</FONT></TT>.
It is also frequently used as a parameter to other functions from
within member methods.
<H2><A NAME="ClassInheritance"><FONT SIZE=5 COLOR=#FF0000>Class
Inheritance</FONT></A></H2>
<P>
In Java, every class you declare will be derived from another
class. You can specify the class to derive from by using the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ClassicCar extends Car {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
As you probably noticed, <TT><FONT FACE="Courier">extends</FONT></TT>
was left out of all the prior examples in this chapter. This is
because if a class is not declared as being derived from a specific
class, then it is assumed to be derived from the Java base class,
<TT><FONT FACE="Courier">Object</FONT></TT>. This means that the
following two class declarations are equivalent:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}<BR>
<BR>
public class Car extends Object {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// member methods and variables<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Because <TT><FONT FACE="Courier">Object</FONT></TT> is the class
from which all other Java classes are ultimately derived, this
provides a common set of functionality among all Java classes.
Most notably, garbage collection is possible because all classes
will ultimately trace their lineage back to <TT><FONT FACE="Courier">Object</FONT></TT>
as shown in Figure 3.5.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f3-5.gif" ><B>Figure 3.5 : </B><I>Everything is (eventually) derived from object.</I></A>
<P>
A derived class is commonly referred to as a <I>subclass</I>,
while the class it is derived from is commonly referred to as
a <I>superclass</I>. The term <I>immediate superclass</I> is used
to describe the class from which a subclass is directly derived.
In Figure 3.5, for example, <TT><FONT FACE="Courier">ClassicCar</FONT></TT>
is a subclass of both <TT><FONT FACE="Courier">Car</FONT></TT>
and <TT><FONT FACE="Courier">Object</FONT></TT>. <TT><FONT FACE="Courier">Car</FONT></TT>
and <TT><FONT FACE="Courier">Object</FONT></TT> are both superclasses
of <TT><FONT FACE="Courier">ClassicCar</FONT></TT>, but only <TT><FONT FACE="Courier">Car</FONT></TT>
is the immediate superclass of <TT><FONT FACE="Courier">ClassicCar</FONT></TT>.
<H3><A NAME="OverridingMemberMethods">Overriding Member Methods</A>
</H3>
<P>
When you create a subclass, you inherit all of the functionality
of its superclass, and then you can add or change this functionality
as desired. As an example of this, consider the altered declaration
of a <TT><FONT FACE="Courier">Car</FONT></TT> class in the following
code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Car {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private int year;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private float originalPrice;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the sale price of a car based
on its cost<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public double CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double salePrice;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (year &gt;
1994)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salePrice
= originalPrice * 0.75;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (year
&gt; 1990)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salePrice
= originalPrice * 0.50;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salePrice
= originalPrice * 0.25;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return salePrice;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a public constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Car(int year, float originalPrice)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.year = year;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.originalPrice
= originalPrice;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This version of the <TT><FONT FACE="Courier">Car</FONT></TT> class
holds information about the year and the original purchase price
of the car. It has a member method, <TT><FONT FACE="Courier">CalculateSalePrice</FONT></TT>,
that determines the price for which to sell the car based on its
age. Depending upon the age of the car, it can sell for either
75%, 50%, or 25% of its original price.
<P>
Although very simplistic, this is a good start for most cars.
However, it is completely inadequate for classic, old cars. This
algorithm would indicate that a 1920 Model T would be worth only
25% of its original 1920 price. A slight improvement on this would
be to assume that every <TT><FONT FACE="Courier">ClassicCar</FONT></TT>
is worth $10,000. To do this, <TT><FONT FACE="Courier">ClassicCar</FONT></TT>
is derived from <TT><FONT FACE="Courier">Car</FONT></TT>, as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class ClassicCar extends Car {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// calculate the sale price of a car based
on its cost<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public double CalculateSalePrice() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 10000;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// a public constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public ClassicCar(int year, float originalPrice)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(year, originalPrice);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Because <TT><FONT FACE="Courier">ClassicCar</FONT></TT> is derived
from <TT><FONT FACE="Courier">Car</FONT></TT>, it inherits all
of the functionality of <TT><FONT FACE="Courier">Car</FONT></TT>,
including its member variables <TT><FONT FACE="Courier">year</FONT></TT>
and <TT><FONT FACE="Courier">originalPrice</FONT></TT>. The function
<TT><FONT FACE="Courier">CalculateSalePrice</FONT></TT> appears
in both class declarations. This means that the occurrence of
this function in <TT><FONT FACE="Courier">ClassicCar</FONT></TT>
overrides the occurrence of it in <TT><FONT FACE="Courier">Car</FONT></TT>
for object instances of <TT><FONT FACE="Courier">ClassicCar</FONT></TT>.
As an example of how this works, consider the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ClassicCar myClassic = new ClassicCar(1920,
1400);<BR>
double classicPrice = myClassic.CalculateSalePrice();<BR>
<BR>
Car myCar = new Car(1990, 12000);<BR>
double price = myCar.CalculateSalePrice();</FONT></TT>
</BLOCKQUOTE>
<P>
The variable <TT><FONT FACE="Courier">myClassic</FONT></TT> is
of type <TT><FONT FACE="Courier">ClassicCar</FONT></TT> and is
constructed using that class's constructor, which is passed an
original price for the car of $1,400. The sale price of this car
is calculated and stored in <TT><FONT FACE="Courier">classicPrice</FONT></TT>.
Because <TT><FONT FACE="Courier">myClassic</FONT></TT> is a <TT><FONT FACE="Courier">ClassicCar</FONT></TT>,
the sale price will be $10,000. Next, <TT><FONT FACE="Courier">myCar</FONT></TT>
is constructed as a new object of type <TT><FONT FACE="Courier">Car</FONT></TT>
with an original cost of $12,000. Its sale price is determined
and stored in <TT><FONT FACE="Courier">price</FONT></TT>. Because
<TT><FONT FACE="Courier">myCar</FONT></TT> is a <TT><FONT FACE="Courier">Car</FONT></TT>,
its sale price will be based on the year it was made (1990) and
will be 25% of $12,000, or $3,000.
<H3><A NAME="ThesuperVariable">The <TT><FONT SIZE=4 FACE="Courier">super</FONT></TT><FONT SIZE=4>
Variable</FONT></A></H3>
<P>
In the preceding declaration for <TT><FONT FACE="Courier">ClassicCar</FONT></TT>,
you may have noticed that the constructor made use of a variable
named <TT><FONT FACE="Courier">super</FONT></TT>. Just as each
object has a <TT><FONT FACE="Courier">this</FONT></TT> variable
that references itself, each object (other than those of type
<TT><FONT FACE="Courier">Object</FONT></TT> itself) has a <TT><FONT FACE="Courier">super</FONT></TT>
variable that represents the parent class. In this case, <TT><FONT FACE="Courier">super(year,
originalPrice)</FONT></TT> invokes the constructor of the superclass
<TT><FONT FACE="Courier">Car</FONT></TT>.
<H3><A NAME="ClassModifiers">Class Modifiers</A></H3>
<P>
Classes that are created in Java can be modified by any of three
class modifiers. The Java class modifiers are <TT><FONT FACE="Courier">public</FONT></TT>,
<TT><FONT FACE="Courier">final</FONT></TT>, and <TT><FONT FACE="Courier">abstract</FONT></TT>.
If no class modifier is used, then the class may only be used
within the package in which it is declared. A <TT><FONT FACE="Courier">public</FONT></TT>
class is a class that can be accessed from other packages. A class
that is declared as <TT><FONT FACE="Courier">final</FONT></TT>
cannot be derived from, meaning it cannot have subclasses.
<H4>Abstract Classes</H4>
<P>
Sometimes you may want to declare a class and yet not know how
to define all of the methods that belong to that class. For example,
you may want to declare a class called <TT><FONT FACE="Courier">Mammal</FONT></TT>
and include in it a member method called <TT><FONT FACE="Courier">MarkTerritory</FONT></TT>.
However, you don't know how to write <TT><FONT FACE="Courier">MarkTerritory</FONT></TT>
because it is different for each type of <TT><FONT FACE="Courier">Mammal</FONT></TT>.
Of course, you plan to handle this by deriving subclasses of <TT><FONT FACE="Courier">Mammal</FONT></TT>,
such as <TT><FONT FACE="Courier">Dog</FONT></TT> and <TT><FONT FACE="Courier">Human</FONT></TT>.
But what code do you put in the <TT><FONT FACE="Courier">MarkTerritory</FONT></TT>
function of <TT><FONT FACE="Courier">Mammal</FONT></TT> itself?
<P>
In Java you can declare the <TT><FONT FACE="Courier">MarkTerritory</FONT></TT>
function of <TT><FONT FACE="Courier">Mammal</FONT></TT> as an
<TT><FONT FACE="Courier">abstract</FONT></TT> method. Doing so
allows you to declare the method without writing any code for
it in that class. However, you can write code for the method in
the subclass. If a method is declared <TT><FONT FACE="Courier">abstract</FONT></TT>,
then the class must also be declared as <TT><FONT FACE="Courier">abstract</FONT></TT>.
For <TT><FONT FACE="Courier">Mammal</FONT></TT> and its subclasses,
this means they would appear as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract class Mammal {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;abstract void MarkTerritory();<BR>
}<BR>
<BR>
public class Human extends Mammal {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void MarkTerritory() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mark territory
by building a fence<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class GangMember extends Mammal {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void MarkTerritory() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mark territory
with graffiti<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public class Dog extends Mammal {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void MarkTerritory() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mark territory
by doing what dogs do<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
With the preceding declarations, the <TT><FONT FACE="Courier">Mammal</FONT></TT>
class contains no code for <TT><FONT FACE="Courier">MarkTerritory</FONT></TT>.
The <TT><FONT FACE="Courier">Human</FONT></TT> class could contain
code that would mark territory by building a fence around it,
while the <TT><FONT FACE="Courier">GangMember</FONT></TT> class
could contain code that would mark territory by spray-painting
graffiti. The <TT><FONT FACE="Courier">Dog</FONT></TT> class would
mark territory by raising the dog's leg and doing what dogs do
to mark territory.<BR>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A method that is private or static cannot also be declared abstract. Because a private method cannot be overridden in a subclass, a private abstract method would not be usable. Similarly, because all static methods are implicitly final, static methods 
cannot be overridden.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="ImplementingInterfaces">Implementing Interfaces</A>
</H3>
<P>
Typically, an abstract class will have some methods that are declared
as <TT><FONT FACE="Courier">abstract</FONT></TT> and some that
are not. If you find yourself declaring a class that is entirely
abstract, you are probably declaring what is known in Java as
an <I>interface</I>. An interface is an entirely abstract class.
You can derive subclasses from an interface in a manner completely
analogous to deriving a subclass from another class.
<P>
As an example, suppose you are building an application that must
display the hour of the day. Users will have two options for getting
this information. They can get it from either a watch or a cuckoo
clock. This could be implemented as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">interface Clock {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour);<BR>
}<BR>
<BR>
class Cuckoo implements Clock&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer str
= new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0;
i &lt; hour; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str.append(&quot;Cuckoo
&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return str.toString();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class Watch implements Clock&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public String GetTime(int hour) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new String(&quot;It
is &quot; + hour + &quot;:00&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">Clock</FONT></TT> is
an interface that provides a single function, <TT><FONT FACE="Courier">GetTime</FONT></TT>.
What this means is that any class that is derived from (or, in
other words, <I>implements</I> the <TT><FONT FACE="Courier">Clock</FONT></TT>
interface) must provide a <TT><FONT FACE="Courier">GetTime</FONT></TT>
function. <TT><FONT FACE="Courier">Cuckoo</FONT></TT> is an example
of a class that implements <TT><FONT FACE="Courier">Clock</FONT></TT>,
and you'll notice that instead of the <TT><FONT FACE="Courier">class
Cuckoo extends Clock</FONT></TT> syntax that would have been used
if <TT><FONT FACE="Courier">Clock</FONT></TT> were an abstract
class, it is instead declared with class <TT><FONT FACE="Courier">Cuckoo
implements Clock</FONT></TT>.
<P>
Because <TT><FONT FACE="Courier">Cuckoo</FONT></TT> implements
the <TT><FONT FACE="Courier">Clock</FONT></TT> interface, it provides
a <TT><FONT FACE="Courier">GetTime</FONT></TT> function. In this
case, a string is created that will hold as many <TT><FONT FACE="Courier">Cuckoo</FONT></TT>s
as specified by the <TT><FONT FACE="Courier">hour</FONT></TT>
parameter. The class <TT><FONT FACE="Courier">Watch</FONT></TT>
also implements <TT><FONT FACE="Courier">Clock</FONT></TT> and
provides a <TT><FONT FACE="Courier">GetTime</FONT></TT> function.
Its version is a simple message stating the hour.
<P>
Interfaces and superclasses are not mutually exclusive. A new
class can be derived from a superclass and one or more interfaces.
This could be done as follows for a class that implements two
interfaces and has one superclass:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class MySubClass extends MySuperClass
implements FirstInterface,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecondInterface
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// class implementation<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Because it is possible for one class to implement more than one
interface, interfaces are a very convenient method for implementing
a form of multiple inheritance.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter covered a great deal of information. You were introduced
to Java's primitive types and the operators that are available
for these types. Next, you learned how to control the flow of
a Java program through selection statements (<TT><FONT FACE="Courier">if</FONT></TT>,
<TT><FONT FACE="Courier">switch</FONT></TT>, and <TT><FONT FACE="Courier">case</FONT></TT>),
iteration statements (<TT><FONT FACE="Courier">for</FONT></TT>,
<TT><FONT FACE="Courier">while</FONT></TT>, and <TT><FONT FACE="Courier">do&#133;while</FONT></TT>),
and jumping (<TT><FONT FACE="Courier">break</FONT></TT> and <TT><FONT FACE="Courier">continue</FONT></TT>).
Finally, you learned how to put all of this together and create
new classes by deriving them from existing classes or interfaces.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch2.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch4.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
