<HTML>

<HEAD>
   <TITLE>Chapter 22 -- Exception Handling</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 22</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Exception Handling</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#WhatIsExceptionHandling" >What Is Exception Handling?</A>
<LI><A HREF="#WhyIsExceptionHandlingImportant" >Why Is Exception Handling Important?</A>
<LI><A HREF="#TypesofExceptions" >Types of Exceptions</A>
<LI><A HREF="#ThrowingExceptions" >Throwing Exceptions</A>
<LI><A HREF="#CatchingNormalExceptions" >Catching Normal Exceptions</A>
<LI><A HREF="#CatchingRuntimeExceptions" >Catching Runtime Exceptions</A>
<LI><A HREF="#ForcedExecution" >Forced Execution</A>
<LI><A HREF="#WhentoUseExceptionHandling" >When to Use Exception Handling</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
A sad reality associated with being human is that we are all error
prone. Because software is a human creation, it often suffers
from this same weakness. As nice as the Java programming language
is, software written with it will inevitably contain errors. The
Java architects realized this and built a complete error-handling
mechanism into the Java language and runtime environment. Runtime
errors in Java are collectively known as exceptions, and the act
of detecting and dealing with these errors is known as exception
handling. The focus of this chapter is on understanding exceptions
and how to effectively deal with them in Java programs.
<H2><A NAME="WhatIsExceptionHandling"><FONT SIZE=5 COLOR=#FF0000>What
Is Exception Handling?</FONT></A></H2>
<P>
Although most programs include a certain degree of error-handling
overhead, few programmers have the time or resources to fully
cover their tracks when it comes to handling every possible type
of error that can occur in a running program. For example, is
it really the responsibility of the programmer to detect when
a user's hard drive fills up, or when the system runs out of memory?
If so, what exactly should a program do when something like this
occurs? Although Java doesn't completely provide an answer to
the latter question, it does address the first one head on.
<P>
The Java programming environment borrows a very powerful error-handling
technique from C++ known as exception handling. An <I>exception</I>
is defined as an abnormal event that disrupts the normal flow
of a program. <I>Exception handling</I>, therefore, is the process
of detecting and responding to exceptions in a consistent and
reliable manner. The term &quot;exception&quot; is used instead
of &quot;error&quot; because exceptions represent exceptional,
or abnormal, conditions that aren't necessarily errors. In this
way, an exception is a very general concept, meaning that any
number of abnormal events could be interpreted as an exception.
<P>
So, how do you decide what constitutes an abnormal enough condition
to warrant an exception? Most of the time you don't-you let Java
decide! The Java API defines practically every type of exception
you'll ever need. For a detailed look at exactly what exceptions
are defined by the Java API, refer to <A HREF="ch27.htm" >Chapters 27</A>
through <A HREF="ch35.htm" >35</A> in Part III, &quot;Package,
Class, and Interface Reference,&quot; which contain information
about the different API packages and the exceptions defined in
each.
<P>
Getting back to exception handling, Java provides a mechanism
for detecting and handling exceptions as they occur. More specifically,
any method that is at risk of causing an exceptional event is
defined as potentially generating an exception. Generating an
exception at runtime is also known as <I>throwing</I> an exception.
Any code that calls this method is aware that the method can potentially
throw a particular exception and can include special code to handle
the exception should it be thrown. This process is known as <I>catching</I>
an exception. In this way, you can think of an exception as an
object that is thrown containing information about an abnormal
event; the exception-handling code catches the exception object
and uses any information it provides to help deal with the abnormal
event. This actually describes the exact way exceptions work in
Java.
<P>
To get a better understanding of the practical usage of exception
handling, consider the exceptional condition of the system running
out of memory. An exception is thrown indicating that the system
is out of memory. The exception-handling code catches the exception
and in return tries to run the Java garbage collector to free
up memory.
<H2><A NAME="WhyIsExceptionHandlingImportant"><FONT SIZE=5 COLOR=#FF0000>Why
Is Exception Handling Important?</FONT></A></H2>
<P>
Obviously, programmers have been dealing with errors for a long
time, so you may be wondering why exceptions are such a big deal.
This curiosity is reasonable, as there is a lot of code out there
working fine without ever using exception-handling facilities.
However, like many recent advances in software design, exception
handling is meant more as a tool for improving the management
of errors by providing a better approach to attacking the problem.
The problem isn't so much that programmers don't know how to deal
with errors or exceptional conditions; it's that every programmer
has his or her own notion of how to go about doing it. Exception
handling provides a very standardized approach to something that
has been home-brewed for many years now: the handling of errors.
<P>
More specifically, exception handling provides the Java programmer
with three distinct advantages over traditional error-handling
techniques:
<UL>
<LI><FONT COLOR=#000000>It provides a means to separate error-handling
code from functioning program code.</FONT>
<LI><FONT COLOR=#000000>It provides a mechanism for propagating
errors up the method call stack, meaning that methods higher up
the call chain can be allowed to handle problems originating lower
in the chain.</FONT>
<LI><FONT COLOR=#000000>It provides a way to organize and differentiate
between different types of abnormal conditions.</FONT>
</UL>
<P>
The first point is significant because, all too often, error-handling
code is mixed in with code that actually performs a function.
This may not seem like a big deal, but if you carry this approach
into a huge project, complexities abound brought on by trying
to differentiate between legitimate code that is necessary versus
code that is trying to handle some obscure problem condition.
<P>
The second advantage of exception handling has to do with making
errors accessible to other parts of a program. Typically, you
only get a chance to deal with an error at the immediate point
where the error occurs. Using exception handling, the error condition
itself can be passed up the method call stack so that other objects
get a chance to take action based on the problem.
<P>
Finally, the last major advantage to using exception handling
is that of providing a clean way to organize and differentiate
between different types of exceptional conditions. Because exceptions
are implemented in Java as actual objects, they are open to the
same design benefits of object-oriented programming, such as inheritance.
You can define general types of exceptions that deal with a particular
set of problems, and then define more specific types that are
derived from the general one. In fact, the Java API makes great
use of inheritance in the design of its standard exception classes.
<P>
Along with the organization benefit at the design stage, you also
gain from being able to respond to exceptions based on their type.
For example, you may want to handle a whole class of exceptions,
such as exceptions relating to indexes being out of bounds. In
this case, you wouldn't care if the culprit was a string index
or an array index, because the general exception type handles
both.
<H2><A NAME="TypesofExceptions"><FONT SIZE=5 COLOR=#FF0000>Types
of Exceptions</FONT></A></H2>
<P>
In the discussion thus far, I've been using the terms &quot;exception&quot;
and &quot;error&quot; pretty much interchangeably. Although they
are the same in a general programming sense, Java does distinguish
between the two. In Java, an <I>exception</I> is simply defined
as an abnormal event that interrupts the normal flow of a program.
Most programs are designed to handle any exceptions that may arise
during the life of the program. An <I>error</I> is a specific
type of exception that a program isn't expected to be able to
handle. In other words, errors are a more serious strain of exceptions,
which are a superset of errors. Check out Figure 22.1, which shows
a simple diagram relating exceptions and errors.
<P>
<A HREF="http://docs.rinet.ru/JavDev/f22-1.gif" ><B>Figure 22.1:</B> <I>The relationship between exceptions and errors.</I></A>
<P>
Understanding that errors are a more serious type of exception
doesn't really tell the whole story in regard to exceptions. Including
errors, there are three different categories of exceptions common
to Java programming:
<UL>
<LI><FONT COLOR=#000000>Normal exceptions</FONT>
<LI><FONT COLOR=#000000>Runtime exceptions</FONT>
<LI><FONT COLOR=#000000>Errors</FONT>
</UL>
<P>
<I>Normal exceptions</I> are exceptions that occur based on a
specific piece of code. In other words, the location where a normal
exception can occur is predictable, even if the exception itself
is not. An example of a normal exception is a <I>file not found</I>
exception, which occurs at a very specific location in a program
when a file access is attempted but the file isn't found.
<P>
Unlike normal exceptions, <I>runtime exceptions</I> are exceptions
whose location is much harder to nail down. For example, a <I>null
pointer</I> exception can occur any time a null object is referenced,
which basically includes any part of a Java program. Because this
type of exception is much more general and hard to handle, it
is considered a runtime exception. In actuality, all exceptions
are thrown at runtime; it's just that runtime exceptions are a
specialized type of exception that address problems in programs
that have typically been considered runtime problems. Another
example of a runtime exception is a <I>divide by zero</I> exception,
which can occur in practically any mathematical calculation involving
a division.
<P>
The third type of exception is <I>errors</I>, which are more serious
exceptions that are aimed at handling catastrophic conditions.
No, I don't mean catastrophic as in your monitor bursting into
flames; I mean situations where it is very unlikely that a program
could handle the problem. This brings up the big distinction between
errors and the two prior types of exceptions: Java programs aren't
expected to be able to handle errors. Errors are assumed to be
beyond the control of a program and are used primarily within
the Java system itself to deal with major problems such as running
out of system memory or the runtime interpreter crashing.
<H2><A NAME="ThrowingExceptions"><FONT SIZE=5 COLOR=#FF0000>Throwing
Exceptions</FONT></A></H2>
<P>
You've already learned that the basic gist of exceptions is that
an exception is thrown when an abnormal problem arises, and your
program is responsible for catching the exception and somehow
dealing with it. You'll learn the details of catching exceptions
in the next section of this chapter. For now, let's focus on how
exceptions are thrown to begin with.
<P>
Any code that is capable of throwing an exception must specifically
be designed to do so. In other words, exceptions aren't just something
that magically appear whenever a problem occurs; code that has
the potential of causing problems must be designed to notify a
program of these problems accordingly. The Java <TT><FONT FACE="Courier">throws</FONT></TT>
keyword provides the necessary mechanism to wire exception information
into code that is potentially dangerous. The <TT><FONT FACE="Courier">throws</FONT></TT>
keyword is used at the method level, meaning that you declare
a particular method capable of throwing a certain exception or
set of exceptions, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void thisIsTrouble() throws anException
{<BR>
&nbsp;&nbsp;// method body<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">throws</FONT></TT>
keyword is used to specify that the <TT><FONT FACE="Courier">thisIsTrouble</FONT></TT>
method can generate an exception of type <TT><FONT FACE="Courier">anException</FONT></TT>.
Any code that calls this method knows immediately that the risk
is there for the method to generate an <TT><FONT FACE="Courier">anException</FONT></TT>
exception. If you have a method that is capable of causing even
more problems, you can define it as potentially throwing multiple
exceptions, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void thisIsRealTrouble() throws
anException, anotherException {<BR>
&nbsp;&nbsp;// method body<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">thisIsRealTrouble</FONT></TT>
method can throw two different types of exceptions: <TT><FONT FACE="Courier">anException</FONT></TT>
and <TT><FONT FACE="Courier">anotherException</FONT></TT>.
<P>
The whole point of throwing an exception is not to try to deal
with a problem at the point where it occurs, but rather to try
to allow other code to deal with the problem. In other words,
a method that is declared as throwing a particular type of exception
is notifying all code that calls it that it might have a problem
that it needs help solving. The calling code is responsible for
helping out the method by catching the exception and dealing with
it as smoothly as possible. If the method itself were capable
of handling the problem, it would do so quietly and never mention
the problem to the calling code.
<P>
The Java programming language is pretty strict about handling
exceptions. In fact, the Java compiler will generate warnings
if you make calls to methods that throw exceptions without providing
the necessary exception-handling code. In some cases, ignoring
these warnings may be acceptable programming practice, but in
general you should try to address exceptions that can be thrown
at your code. Remember, whoever designed the method must have
realized there was a potential for trouble, or they wouldn't have
declared it as throwing an exception in the first place.
<H2><A NAME="CatchingNormalExceptions"><FONT SIZE=5 COLOR=#FF0000>Catching
Normal Exceptions</FONT></A></H2>
<P>
Let's look at exactly how the exception handling is carried out.
You've already learned that exceptions are typically thrown relative
to a particular method, so you should be able to isolate where
an exception is coming from. The trick then is to look for an
exception to occur right at the point where you call the method
in question. Actually, the technique for handling exceptions involves
both looking for the exception and providing code to deal with
the exception. You carry out this technique using the <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> keywords, like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;thisIsTrouble();<BR>
}<BR>
catch(anException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This code makes a call to the <TT><FONT FACE="Courier">thisIsTrouble</FONT></TT>
method inside a <TT><FONT FACE="Courier">try</FONT></TT> block.
A <TT><FONT FACE="Courier">try</FONT></TT> block is used to hold
code that is at risk of throwing an exception. Any code executing
in a <TT><FONT FACE="Courier">try</FONT></TT> block is considered
at risk of throwing an exception. If an exception occurs in the
<TT><FONT FACE="Courier">try</FONT></TT> block, the runtime system
looks to the <TT><FONT FACE="Courier">catch</FONT></TT> clause
to see if the exception type matches the one that was thrown.
If so, the code in the <TT><FONT FACE="Courier">catch</FONT></TT>
block is executed; this is the code that actually deals with,
or handles, the exception. From this discussion, you may have
guessed that there can be multiple <TT><FONT FACE="Courier">catch</FONT></TT>
clauses that respond to different types of exceptions. If so,
you guessed right!
<P>
Take a look at the following code, which demonstrates how to handle
multiple exceptions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;thisIsRealTrouble();<BR>
}<BR>
catch(anException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}<BR>
catch(anotherException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">thisIsRealTrouble</FONT></TT>
method is called, which is capable of generating two different
types of exceptions. Each of these exception types is handled
in a separate <TT><FONT FACE="Courier">catch</FONT></TT> clause,
which provides a means to handle each type of exception in a unique
manner.
<P>
As you just learned, the Java system matches up exception types
with <TT><FONT FACE="Courier">catch</FONT></TT> clauses when there
is an exact match. However, it can also match exception types
based on a superclass of an exception. It works like this: when
an exception occurs in a <TT><FONT FACE="Courier">try</FONT></TT>
block, the <TT><FONT FACE="Courier">catch</FONT></TT> clauses
are examined by comparing the exception type to the type in each
clause. If the exception type is either the same as the one in
a <TT><FONT FACE="Courier">catch</FONT></TT> clause or a subclass
of the one in a <TT><FONT FACE="Courier">catch</FONT></TT> clause,
a match will occur. This allows you to sometimes provide multilevel
catch handlers based on more derived exception types. If you happen
to implement an exception-handling arrangement involving derived
types, remember to list the more specific types first and the
more general types last.
<P>
Keep in mind that the Java API defines a wide variety of exceptions
that are used a great deal throughout the Java system. So, even
though the discussion has been somewhat general thus far, remember
that all the exception-handling techniques of trying and catching
exceptions apply to standard Java exceptions as well. Check out
the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;FileInputStream in = new FileInputStream(&quot;Data.txt&quot;);
<BR>
}<BR>
&nbsp;&nbsp;catch (FileNotFoundException e) {<BR>
&nbsp;&nbsp;System.out.println(&quot;File not found : &quot; +
e.getMessage());<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, a file input stream is created using a constructor
that takes a filename representing the file to read from. This
constructor is defined as throwing a <TT><FONT FACE="Courier">FileNotFoundException</FONT></TT>
if the input file cannot be found. Because the constructor is
capable of throwing this exception, the sample code creates the
object within a <TT><FONT FACE="Courier">try</FONT></TT> block
and handles the exception <TT><FONT FACE="Courier">FileNotFoundException</FONT></TT>
in a <TT><FONT FACE="Courier">catch</FONT></TT> block. Notice
that this example code merely prints information about the exception
to standard output. In a practical program, you would probably
want to provide a more robust exception handler rather than just
one that printed a message to standard output.
<H2><A NAME="CatchingRuntimeExceptions"><FONT SIZE=5 COLOR=#FF0000>Catching
Runtime Exceptions</FONT></A></H2>
<P>
So far you've focused your attention on handling exceptions that
are generated by methods. If you recall from the earlier discussion
on exception types, these exceptions are referred to as normal
exceptions. Another strain of exception you learned about is runtime
exceptions, which involve problems that aren't so easy to track
down. The following code demonstrates a runtime exception and
how it is handled:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;int x = 100;<BR>
&nbsp;&nbsp;for (int i = 10; i &gt;= 0; i--)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x / i);<BR>
}<BR>
catch(ArithmeticException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Although it is a little subtle, this code contains a pretty big
problem that results in a runtime exception: the <TT><FONT FACE="Courier">for</FONT></TT>
loop results in a divide by zero exception in its last iteration.
The exception is handled by encasing the problem calculation within
a <TT><FONT FACE="Courier">try</FONT></TT> block and providing
a corresponding handler by means of a <TT><FONT FACE="Courier">catch</FONT></TT>
clause. If you hadn't handled this exception, the runtime system
would have bailed out and exited the program with an error message.
You provided a cleaner outlet by catching the exception yourself.
Again, a more robust solution would probably be in order in a
full-blown program, such as notifying the user of an infinite
result.
<P>
The drawback to this whole approach of handling runtime exceptions
is that it requires you to wrap any questionable code inside a
<TT><FONT FACE="Courier">try</FONT></TT> block, which can get
pretty messy. The solution is to try to balance your handling
of exceptions and only go after problems that are significant
enough to really cause you trouble. Exceptions are only useful
when used in moderation; they aren't meant as an easy out for
every little problem you encounter.
<H2><A NAME="ForcedExecution"><FONT SIZE=5 COLOR=#FF0000>Forced
Execution</FONT></A></H2>
<P>
The structure of exception handling tends to cause parts of a
program to conditionally execute based on an exception occurring.
For this reason, there is a problem of code not getting called
when it really should be, based on an exception occurring. For
example, consider a program that needs to perform some type of
cleanup, regardless of the outcome of a risky piece of code. The
very nature of the <TT><FONT FACE="Courier">try-catch</FONT></TT>
technique of exception handling makes it difficult to ensure that
a particular piece of code is always executed.
<P>
Enter the <TT><FONT FACE="Courier">finally</FONT></TT> keyword.
The <TT><FONT FACE="Courier">finally</FONT></TT> keyword provides
a means of executing a piece of code regardless of what happens
within a <TT><FONT FACE="Courier">try</FONT></TT> block. To use
<TT><FONT FACE="Courier">finally</FONT></TT>, you declare a <TT><FONT FACE="Courier">finally</FONT></TT>
block and place it after the <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> blocks; any code
inside the <TT><FONT FACE="Courier">finally</FONT></TT> block
is always executed no matter what happens in the <TT><FONT FACE="Courier">try</FONT></TT>
block. You use the <TT><FONT FACE="Courier">finally</FONT></TT>
keyword like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
&nbsp;&nbsp;int x = 100;<BR>
&nbsp;&nbsp;for (int i = 10; i &gt;= 0; i--)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x / i);<BR>
}<BR>
catch(ArithmeticException e) {<BR>
&nbsp;&nbsp;System.out.println(e.getMessage());<BR>
}<BR>
finally {<BR>
&nbsp;&nbsp;System.out.println(&quot;Can't get around me!&quot;);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, no matter what happens in the <TT><FONT FACE="Courier">try</FONT></TT>
block, the code inside the <TT><FONT FACE="Courier">finally</FONT></TT>
block is always executed. It turns out that the <TT><FONT FACE="Courier">try</FONT></TT>
block generates an exception that results in the <TT><FONT FACE="Courier">catch</FONT></TT>
block being executed. Nevertheless, as soon as the <TT><FONT FACE="Courier">catch</FONT></TT>
block finishes, the <TT><FONT FACE="Courier">finally</FONT></TT>
block is executed, even if the <TT><FONT FACE="Courier">try</FONT></TT>
or <TT><FONT FACE="Courier">catch</FONT></TT> blocks had code
that resulted in a return from the method. Even though this example
doesn't really demonstrate the <TT><FONT FACE="Courier">finally</FONT></TT>
keyword in complete context, the most common usage of it is to
provide cleanup for objects that must be performed no matter what
happens. Using <TT><FONT FACE="Courier">finally</FONT></TT>, you
can feel safe that a certain piece of code will always get called.
<P>
Please don't confuse the name or the usage of the <TT><FONT FACE="Courier">finally</FONT></TT>
keyword with the <TT><FONT FACE="Courier">finalize</FONT></TT>
method. Granted, in some ways they are used to perform a similar
function, but <TT><FONT FACE="Courier">finally</FONT></TT> is
a keyword related to exception handling, whereas <TT><FONT FACE="Courier">finalize</FONT></TT>
is a specific method related to object de- struction.
<H2><A NAME="WhentoUseExceptionHandling"><FONT SIZE=5 COLOR=#FF0000>When
to Use Exception Handling</FONT></A></H2>
<P>
Even though exception handling is a very powerful and useful facility
of the Java programming and runtime environment, it doesn't aim
to solve all problems relating to abnormal program execution.
You will no doubt encounter many situations where an exception
could be in order but where it may be more simple to just handle
the problem with an <TT><FONT FACE="Courier">if</FONT></TT> statement.
This thinking doesn't apply to exceptions that are already defined
in Java; you can already count on them being important enough
to worry about.
<P>
The point here is that exception handling should be reserved for
legitimate problems where you don't mind taking more time to define
a problem and build in the necessary overhead to deal with it.
Notice the usage of the term &quot;overhead,&quot; which implies
that exceptions carry with them a certain amount of baggage. Exceptions
do in fact cost more to implement and work with, which is an issue
you must weigh when you start thinking about exceptionizing your
code.
<P>
My suggestion is to handle all the standard Java exceptions accordingly
and then assess the needs of your own code carefully. Studying
the use of exceptions in the Java API is a very good way to learn
about when and where to use exceptions. The Java architects made
a lot of tradeoffs in their usage of exceptions, which is a good
indicator of how much of a judgment issue  exception handling
is. Ultimately, experience will be your guide as you work with
exceptions in practical programs.
<P>
The best approach when designing your own code is to look at how
a potential problem impacts the code around it. In other words,
does the problem exist only within the confines of a particular
method, or can it cause larger problems to the program at large?
If the problem can be reasonably dealt with locally, there is
probably no need to worry about defining or throwing an exception.
However, if there is a chance that the problem can reach beyond
the immediate method or object, then by all means toss that exception
so other code will know about the risks.
<P>
The only other issue to consider is how often the risky code will
potentially get called. Because exception handling involves more
overhead than most other types of error handling, you don't want
to have a bunch of exception-handling code in the middle of a
routine that needs to be very efficient, such as a loop that performs
some repetitive function. One solution to this problem is to throw
an exception the first time a problem occurs, rather than over
and over in a piece of code that gets called a lot.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned about imperfections in programming.
More importantly, you learned about how Java eases the pain and
allows us to be imperfect and still develop robust programs through
the use of exception handling. You learned what exception handling
is and why it is important in Java development. You then covered
the basic kinds of exceptions, which include normal exceptions,
runtime exceptions, and errors. You then progressed to how exceptions
are thrown and caught, along with how to force the execution of
code regardless of exceptional conditions. You finished up the
chapter with a practical look at how exceptions can be leveraged
alongside more traditional error-handling techniques.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch21.htm"><IMG SRC="http://docs.rinet.ru/JavDev/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JavDev/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JavDev/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch23.htm"><IMG 
SRC="http://docs.rinet.ru/JavDev/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

