<HTML>
<HEAD>


<TITLE>Inside Java:The New, Improved AWT: GUI Compo- nents, Containers, and Layout Manag- ers:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0532-0535.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0540-0543.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-536"><P>Page 536</P></A>


<P><B>Table 13.12
</P></B>
<P>Commonly Used Methods in the Container Class
</P>
<TABLE>

<TR><TD>
Constructor/Method
</TD><TD>
Description
</TD></TR><TR><TD>
add(Component)
add(Component, int)
add(String, Component)     
</TD><TD>
Adds the specified component to this Container.<BR>
The component is positioned      according to the<BR>
rules of the layout manager, if one has been set.
</TD></TR><TR><TD>
int getComponentCount()
</TD><TD>
Returns the number of components in this
container. (Note that countComponents() has been
deprecated.)
</TD></TR><TR><TD>
Component[] getComponents()
</TD><TD>
Returns an array of components that are in
this container.
</TD></TR><TR><TD>
Insets getInsets()
</TD><TD>
Returns an Insets that describes the non-usable <BR>
border area of the Container. (Note that insets()
has been deprecated.)
</TD></TR><TR><TD>
void setLayout(LayoutManager)
</TD><TD>
Sets the layout manager to the one specified.
</TD></TR><TR><TD>
void validate()
</TD><TD>
Forces the container and its components to be
laid out according to the current layout manager.
(Usually called after adding or resizing a component.)
</TD></TR><TR><TD>
Dimension getPreferredSize()
</TD><TD>
Returns the preferred size of this container.
(Note that preferredSize() has been <BR>
deprecated.)
</TD></TR></TABLE>


<P>Now that you are familiar with a container and some of its methods, let's discuss each
of the containers individually.
</P>

<H4><A NAME="ch13_ 12">
Panel Class
</A></H4>

<P>The Panel class is the simplest of the Container classes. This class usually is used
inside another container to sub-organize components. The ScrollbarSlider example
(illustrated earlier in this chapter) used a Panel in this manner. Lines 39_46 of listing 13.2 depict
a Panel that is created to hold a text field component. Because of the way
the BorderLayout layout manager works, adding the text field directly to the applet
would cause the text field to expand and fill most of the applet's display area. Instead,
an instance of a Panel is added to the applet, and the text field is then added to the
Panel. The default layout manager for a Panel is FlowLayout, so the text field is placed
accordingly&#151;at the top, center of the panel. Later sections in this chapter will
discuss FlowLayout in more detail.
</P>
<A NAME="PAGENUM-537"><P>Page 537</P></A>



<P>For more information on the Panel class, refer to the following Web page:
</P>
<PRE>

http://java.sun.com/products/JDK/1.1/docs/api/java.awt.Panel.html
</PRE>

<P>Figure 13.1 illustrates that the Applet class is derived from the Panel class. The
Applet class is the base class for all applets. Chapter 8, &quot;Creating Java Applets,&quot; discusses
the Applet class in more detail. For more information on the Applet class, refer to
the following Web page:
</P>
<PRE>

http://java.sun.com/products/JDK/1.1/docs/api/java.applet.Applet.html
</PRE>

<P>Now that we have examined the simplest container, let's explore the ScrollPane class.
</P>

<H4><A NAME="ch13_ 13">
ScrollPane Class
</A></H4>

<P>Prior to Java 1.1, users writing a program that contained scrolling areas associated
with scrollbars had to manage the scrolling of these areas themselves. This new
ScrollPane class, however, handles much of the work for you.
</P>

<P>Listing 13.3, which is the program NoScrollPain.java on the CD-ROM accompanying
this book, depicts an applet that serves as an example of how you can use the
ScrollPane class. Figure 13.7 displays this applet's user interface. As you operate the scrollbars,
the street map scrolls within the viewing area. Figure 13.6 diagrams the
behind-the-scenes information&#151;or, behind-the-Viewport information, to be more precise.
</P>

<P>Listing 13.3
</P>
<PRE>
Line==================Java Source=================
01   //////////
02   // NoScrollPain.java  Example of using a ScrollPane
03   // to easily implement scrolling.
04   //
05   // Author: James L. Weaver  JDK 1.1 beta1
06   //////////
07   import java.awt.*;
08   import java.applet.*;
09   import java.awt.event.*;
10
11   public class NoScrollPain extends Applet {
12
13       // Declare a ScrollPane
14       ScrollPane viewer;
</PRE>
<PRE>
<I>
                                           continues
</I>
</PRE>


<A NAME="PAGENUM-538"><P>Page 538</P></A>


<P>
Listing 13.3, Continued
</P>
<PRE>

15
16       // Declare a component to scroll within the ScrollPane
17       Map map;
18
19       public void init() {
20
21           // Construct the viewer
22           viewer = new ScrollPane(ScrollPane.SCROLLBARS_AS_NEEDED);
23
24           // Set the Unit Increment of the horizontal
25           // scrollbar to 5, and the Block Increment to 50
26           viewer.getHAdjustable().setUnitIncrement(5);
27           viewer.getHAdjustable().setBlockIncrement(50);
28
29           // Set the Unit Increment of the vertical
30           // scrollbar to 5, and the Block Increment to 50
31           viewer.getVAdjustable().setUnitIncrement(5);
32           viewer.getVAdjustable().setBlockIncrement(50);
33
34           // Set the layout to BorderLayout
35           setLayout(new BorderLayout());
36
37           // Place the viewer in the &quot;Center&quot; region of
38           // the BorderLayout
39           add(&quot;Center&quot;, viewer);
40
41           map = new Map();
42           viewer.add(map);
43       }
44   }
45
46   class Map extends Canvas
47   {
48       Map() {
49           setSize(300, 200);
50       }
51
52       public void paint(Graphics g) {
</PRE>

<A NAME="PAGENUM-539"><P>Page 539</P></A>



<PRE>
53           g.setColor(Color.white);
54           g.fillRect(0, 0, 300, 200);
55           g.setColor(Color.red);
56           g.drawLine(0, 100, 100, 100);
57           g.drawLine(100, 100, 100, 0);
58           g.drawLine(125, 0, 125, 100);
59           g.drawLine(125, 100, 300, 100);
60           g.drawLine(0, 125, 200, 125);
61           g.drawLine(200, 125, 200, 200);
62           g.drawLine(225, 200, 225, 125);
63           g.drawLine(225, 125, 300, 125);
64           g.drawString(&quot;Main street&quot;, 100, 120);
65       }
66   }
</PRE>

<P>This is the associated HTML:
</P>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; NoScrollPain &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;APPLET CODE=&quot;NoScrollPain.class&quot; WIDTH=100 HEIGHT=100&gt;&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>Before diving into the listing, take a look at figure 13.6, which illustrates both a
viewport in which the street map can be viewed and a child component that contains the
street map. Different sections of the child component appear within the viewport,
depending on the positions of the scrollbars.
</P>

<P>Line 14 in listing 13.3 declares a ScrollPane, which encapsulates the viewport
and scrollbars depicted in the diagram.
</P>

<P>Line 17 declares the child component to be viewed. In this case, the child component is
a subclass of Canvas, named Map. (This class is defined in lines 46_66.) Note that in
the Map constructor (line 49), the size of the child component is set to 300 pixels wide
and 200 pixels high. Notice also that the Map class can draw a map on itself, as seen in
the paint() method in lines 52_65.
</P>
<P>
The init() method of the applet (line 22) constructs the viewer. This version of
the
</P>

<P><CENTER>
<a href="0532-0535.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0540-0543.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

