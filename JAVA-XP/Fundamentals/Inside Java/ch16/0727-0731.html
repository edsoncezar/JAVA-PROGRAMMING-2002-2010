<HTML>
<HEAD>


<TITLE>Inside Java:Remote Method Invocation and Object Serialization:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0723-0726.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0732-0737.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-727"><P>Page 727</P></A>


<OL START="5">
error occurred) onto a marshal stream and then sends the value back to the stub.<BR>
<LI>          The stub unmarshals the return value and returns it to the original caller.
</OL>

<P>As you can see, the semantics of calling the stub are similar to those of calling a
local object because the stub acts as a proxy for the remote object.
</P>

<P><B>The Three Layers of the RMI System
</B></P>

<P>As figure 16.2 illustrates, RMI uses three conceptual layers to support the flow
just described:
</P>

<UL>
<LI>          The Stubs/Skeletons Layer
<LI>          The Remote Reference Layer
<LI>          The Transport Layer
</UL>

<P>Each layer provides services to the layer above it, and the application code that
uses RMI sits above the top layer.
</P>

<P>When a client invokes a remote method, the call flows down through the layers and
is </P>

<P><a href="images\ch16fg02.jpg"><img src="images\tn_ch16fg02.jpg"></a><BR>
Figure 16.2
RMI system layers.
</P>

<P>transformed as it goes to create a data stream that travels across the transport. The
call then is reconstituted as it moves up through the layers on the server-side, where
it emerges as a call to the remote method. The results of the invocation make the
reverse journey, and control finally returns to the calling code in the client. Each layer
has different responsibilities:
</P>
<A NAME="PAGENUM-728"><P>Page 728</P></A>



<UL>
<LI>          The Stubs/Skeletons Layer consists of the stubs and skeletons described in
the previous section. Stubs and skeletons perform complementary functions and
form the interface between the RMI services and the code that calls and
implements remote objects. Both objects are responsible for marshaling the arguments
and unmarshaling return values. Stubs and skeletons are generated by the
rmic compiler, which stands for remote method interface
compiler, and will be used later in this chapter.
<LI>          The Remote Reference Layer provides a consistent interface to the stubs and
skeletons above. This layer also hides the details of the specific remote
refer-
ence semantics. The remote server object, for example, may actually be a set
of replicated objects. In this case, the Remote Reference Layer is responsible
for communicating with each of the replicated objects. The Remote Reference Layer
also provides the marshal stream, into which the stub marshals the arguments.
<LI>         The Transport Layer handles the connectivity and provides a channel between
the Java Virtual Machines (VMs), which contain the clients and remote objects.
Each remote object can be referenced by the combination of an
endpoint and an object identifier. This combination is called a
live reference. The endpoint refers to a specific Java VM, and the object identifier refers to a specific remote object
within that VM. The transport layer maintains a table of the remote objects in a Java VM.
</UL>

<P>The following section builds on the previous explanation of the RMI application
flow and system layers, and provides a practical, hands-on example using RMI.
</P>

<H3><A NAME="ch16_ 6">
Developing with Java RMI
</A></H3>

<P>Now that you have a basic understanding of RMI, you will create a simple applet
based upon the HelloGuiWorld applet from Chapter 13, &quot;The New, Improved AWT:
GUI Components, Containers, and Layout Managers,&quot; to demonstrate how you can
develop Java programs that use RMI. The first version of this new applet (HelloApplet1)
accesses a local object. This applet will be transformed step-by-step into an applet
that accesses the object remotely.
</P>

<H4><A NAME="ch16_ 7">
The HelloApplet1 Applet
</A></H4>

<P>Listing 16.1 (HelloApplet1) also can be found on the CD accompanying this book.
</P>

<P>Listing 16.1 illustrates the code of the HelloApplet1 applet, which is based upon
the HelloGuiWorld applet in Chapter 13. Recall that when the button is pressed in
this applet, the label toggles between displaying &quot;Hello GUI World!&quot; and &quot; Goodbye!&quot;.
</P>


<A NAME="PAGENUM-729"><P>Page 729</P></A>


<P>
The main difference between the HelloGuiWorld and this HelloApplet1 applet is that
the code that toggles the greeting back and forth from &quot;Hello GUI World!&quot; to
&quot;Goodbye!&quot; has been moved into a separate class. This was done so that the class can be
transferred to a different Java VM to demonstrate RMI. This class, named GreetingGen, is defined
in lines 45_69. Figure 16.3 depicts the applet's display.
</P>

<P>Listing 16.1
</P>
<PRE>
Line==================Java Source=================
01   //////////
02   // HelloApplet1.java Example of transforming an applet
03   // into the RMI model.
04   //
05   // Author: James L. Weaver  JDK 1.1 beta
06   //////////
07   package chapter16.code.hello_remote1;
08
09   import java.awt.*;
10   import java.applet.*;
11   import java.awt.event.*;
12
13   public class HelloApplet1 extends Applet
14                              implements ActionListener{
15
16       Button pushButton;
17       Label greetingLabel;
18       GreetingGen gener;
19
20       public void init() {
21
22           pushButton = new Button(&quot;Push&quot;);
23           add(pushButton);
24
25           // Add an event &quot;listener&quot; for when an action
26           // event happens to this button. The
27           // actionPerformed method of the listener will
28           // be called.
29           pushButton.addActionListener(this);
30
31           greetingLabel = new Label(&quot;Hello GUI World!&quot;);
</PRE>
<PRE>
                              								<I>continues</I>
</PRE>


<A NAME="PAGENUM-730"><P>Page 730</P></A>


<P>Listing 16.1, Continued
</P>
<PRE>
32           add(greetingLabel);
33
34           gener = new GreetingGen();
35       }
36
37   // This method is called when the Button is clicked.
38     public void actionPerformed(ActionEvent e) {
39       greetingLabel.setText(gener.makeGreeting(greetingLabel.getText()));
40        // Take next line out when bug in JDK 1.1 beta is fixed
41             greetingLabel.repaint();
42   }
43 }
44
45   class GreetingGen {
46       // This class is responsible for generating a greeting.
47       // It will later be converted to a class that can
48       // be instanced to function as a remote object.
49
50       String helloString;
51       String goodbyeString;
52
53       public GreetingGen() {
54           // Set up the two greeting possibilities
55           helloString = new String(&quot;Hello GUI World!&quot;);
56           goodbyeString = new String(&quot;Goodbye!&quot;);
57       }
58
59       String makeGreeting(String lastGreeting) {
60           String newGreeting;
61
62           // Toggle between the two greetings
63           if (lastGreeting.equals(helloString))
64                        newGreeting = goodbyeString;
65                 else
66                        newGreeting = helloString;
67           return newGreeting;
68       }
69   }
</PRE>

<A NAME="PAGENUM-731"><P>Page 731</P></A>



<P>This is the associated HTML:
</P>

<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Hello Remote World &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;APPLET CODEBASE=&quot;../../..&quot;
        CODE=&quot;chapter16.code.hello_remote1.HelloApplet1.class&quot;
        WIDTH=300 HEIGHT=100&gt;
&lt;/applet&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>As a quick review of this applet, a button and a label are created and placed on
the applet in lines 22_32. Line 29 associates an event listener with the pushButton. Here,
the event listener is the actionPerformed() method in line 38.
</P>

<P>In line 34, an object is created from the GreetingGen class, which is defined in lines
45_69. This class contains one method, named
makeGreeting(), which takes a String argument that contains the current greeting being shown. The
makeGreeting() method returns a String that contains the new greeting to be shown.
</P>

<P><a href="images\ch16fg03.jpg"><img src="images\tn_ch16fg03.jpg"></a><BR>
Figure 16.3
HelloApplet1 applet display.
</P>

<P>The applet now will be split apart and transformed into a distributed application
that uses RMI.
</P>

<H4><A NAME="ch16_ 8">
Transforming HelloApplet1 to Use RMI
</A></H4>

<P>Figure 16.4 shows the following classes, which will be created to change
the HelloApplet1 applet into the distributed HelloApplet2:
</P>

<UL>
<LI>          GreetingGen is an implementation class that defines the interface for the
remote object.
<LI>          GreetingGenImpl is the class from which the remote object is created.
</UL>


<P><CENTER>
<a href="0723-0726.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0732-0737.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

