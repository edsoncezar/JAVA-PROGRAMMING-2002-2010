<HTML>
<HEAD>


<TITLE>Inside Java:Remote Method Invocation and Object Serialization:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0756-0762.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0767-0768.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-763"><P>Page 763</P></A>


<P>
interface.
</P>

<P><b>Reading Objects from an ObjectInputStream</b>
</P>

<P>In the read() method, lines 48 and 49 (listing 16.11) create an
ObjectInputStream from a FileInputStream. The FileInputStream specifies the name of the file from which the
object is to be read.
</P>

<PRE>
048               FileInputStream in = new FileInputStream(filename);
049               ObjectInputStream s = new ObjectInputStream(in);
</PRE>

<P>If the file is found, the readObject() method of the ObjectInputStream reads the
Vector object that contains references to all the planets. The method then reads all the
referenced planet objects.
</P>

<PRE>
050               planets = (Vector)s.readObject();
</PRE>

<P>Note this change made to the PlanetsImpl class: The Planet objects are contained by
a Vector, not an array. This change was made because
readObject() returns a reference to an object, not an array. Although it is possible to treat an array like an object,
demonstrating this process would unnecessarily complicate this example.
</P>

<P>Because the return type of readObject() is an Object, it must be cast to the proper
class, which in this case is Vector.
</P>

<P>If the file containing the Vector of planet references isn't found, the exception
handling code in lines 52_67 (listing 16.11) are executed to create a Vector and populate it
with planets.
</P>

<PRE>
052           catch (FileNotFoundException e){
053               planets = new Vector();
054               System.out.println(&quot;No input file found; Creating one.&quot;);
055
056               // Populate the planets Vector
057               planets.addElement(new Planet(&quot;Mercury&quot;,0, false));
058               planets.addElement(new Planet(&quot;Venus&quot;,0, false));
059               planets.addElement(new Planet(&quot;Earth&quot;,1, false));
060               planets.addElement(new Planet(&quot;Mars&quot;,2, false));
061               planets.addElement(new Planet(&quot;Jupiter&quot;,16, true));
062               planets.addElement(new Planet(&quot;Saturn&quot;,18, true));
063               planets.addElement(new Planet(&quot;Uranus&quot;,15, true));
064               planets.addElement(new Planet(&quot;Neptune&quot;,8, true));
065               planets.addElement(new Planet(&quot;Pluto&quot;,1, false));
</PRE>


<A NAME="PAGENUM-764"><P>Page 764</P></A>


<PRE>
066               return;
067           }
</PRE>

<P>Lines 68_75 (listing 16.11) catch other possible exceptions to the operations attempted
in lines 48_50.
</P>

<PRE>
068           catch (IOException e){
069               System.out.println(&quot;Exception while Reading&quot;);
070               return;
071           }
072           catch (ClassNotFoundException e){
073               System.out.println(&quot;ClassNotFoundException while Reading&quot;);
074               return;
075           }
</PRE>

<P>The readObject() method, the most useful method of the ObjectInputStream class, is used
to read an object from the stream. This method can be overridden in a serializable class
to provide a non-default way of reading the object.
</P>

<P>You can use the methods defined by the DataInput interface (covered in Chapter
12, &quot;Networking with Java&quot;) to read primitive types from the stream as well. For
more information on the methods of the ObjectInputStream class, refer to the following
Web page:
</P>

<PRE>

http://java.sun.com/products/JDK/1.1/docs/api/java.io.ObjectInputStream.html
</PRE>

<P>To read objects from a stream, the objects first must be written. The next section
covers this process.
</P>

<P><b>Writing Objects to an ObjectOutputStream</b>
</P>

<P>In the write() method, lines 80 and 81 (listing 16.11) create an
ObjectOutputStream from a FileOutputStream. The FileOutputStream specifies the name of the file to which
the object will be written.
</P>

<PRE>
080               FileOutputStream   f = new FileOutputStream(filename);
081               ObjectOutputStream s = new ObjectOutputStream(f);
</PRE>

<P>The writeObject() call in line 82 (listing 16.11) writes the Vector object to the stream.
Because this Vector object references nine Planet objects, and because the Planet objects
are serializable, the Planet objects are written to the stream as well. Line 83 closes the
stream, writing any buffered information to the file.
</P>

<PRE>
082               s.writeObject(planets);
</PRE>


<A NAME="PAGENUM-765"><P>Page 765</P></A>


<PRE>
083               s.close();
</PRE>

<P>The writeObject() is the most useful method of the ObjectOutputStream class. This
method is used to write an object to the stream, and it can be overridden in a serializable class
to provide a non-default way of writing the object.
</P>

<P>The fields that are not written by
writeObject() are static and transient fields, as well
as references to non-serializable objects.
</P>

<P>You can use the methods defined by the DataOutput interface (covered in Chapter 12)
to write primitive types to the stream as well. For more information on the methods of
the ObjectOutputStream class, refer to the following Web page:
</P>

<PRE>

http://java.sun.com/products/JDK/1.1/docs/api/java.io.ObjectOutputStream.html
</PRE>

<P>Now that we have covered reading and writing serializable objects, let's examine the
rest of the changes to the application.
</P>

<P><b>Other Changes to the Planets Application</b>
</P>

<P>When the PlanetsImpl (listing 16.11) remote server starts up, line 25 in the
constructor calls the read() method, examined previously.
</P>

<PRE>
025           read(file);
</PRE>

<P>This creates the Vector and the Planet instances, either deserialized from a file or
created from scratch, if the file isn't found.
</P>

<P>In lines 31 and 36 the getNumPlanets() and
getPlanet() methods are changed to reflect the use of a Vector instead of an array.
</P>

<PRE>
031           return planets.size();

036           return (Planet)planets.elementAt(num);
</PRE>

<P>Lines 39_43 contain a new method, named
setPlanet(), which the client calls after incrementing the number of moons in a Planet by clicking the Bump button.
</P>

<PRE>
039       public void setPlanet(int num, Planet pl) throws RemoteException
040       {
041           planets.setElementAt(pl, num);
042           write(file);
043       }
</PRE>

<P>The updated Planet is passed from the client to this remote method, and the Planet
object is placed into the Vector at the specified index in line 41. The
write() method, examined
</P>
<A NAME="PAGENUM-766"><P>Page 766</P></A>


<P>
previously, is called in line 42 to save the states of the Vector and Planet objects.
Note that in a &quot;real&quot; application, you probably wouldn't want to save an entire file of
data each time one portion of it changes.
</P>

<P>The setPlanet() method must be added to the PlanetsInfo interface as well, because
the client must invoke it remotely. This is shown in lines 12 and 13 of listing 16.10.
</P>

<PRE>
12       void setPlanet(int num, Planet pl)
13               throws java.rmi.RemoteException;
</PRE>

<P>In the Planet class (listing 16.12), the
bumpMoons() method was added to increase the number of moons.
</P>

<PRE>
33       public void bumpMoons() {
34           moons++;
35       }
</PRE>

<P>In the client applet (listing 16.9), note the portion of code that handles a
bumpButton click:
</P>

<PRE>
095           if (evt.getSource() == bumpButton) {
096               if (planet != null) {
097                   planet.bumpMoons();
098                   try {
099                       obj.setPlanet(pnum_1, planet);
100                   }
101                   catch (java.rmi.RemoteException e) {
102                       System.out.println(&quot;Error calling remote method&quot;);
103                       e.printStackTrace();
104                   }
105                   EventQueue.getEventQueue().postEvent(new ActionEvent)
&Acirc;infoButton,
106                           ActionEvent.ACTION_PERFORMED, null));
107               }
108           }
</PRE>

<P>Line 97 calls the bumpMoons() method of the Planet object that was received from
the remote object. Line 99 calls the setPlanet() method of the remote object, passing
the updated Planet object.
</P>

<P>To cause the display to reflect the updated number of moons, lines 105 and 106
simulate the user clicking on the Info button. This is achieved by posting an ActionEvent for
the infoButton to the EventQueue. The EventQueue is part of the new Delegation
Event
</P>


<P><CENTER>
<a href="0756-0762.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0767-0768.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

