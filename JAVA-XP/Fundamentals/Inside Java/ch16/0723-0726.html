<HTML>
<HEAD>


<TITLE>Inside Java:Remote Method Invocation and Object Serialization:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="..\ch15\0720-0722.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0727-0731.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-723"><P>Page 723</P></A>



<H3><A NAME="ch16_ 1">
CHAPTER 16
</A></H3>

<H2>

Remote Method <BR>
Invocation and Object <BR>
Serialization

</H2>

<P><b>A</b> distributed application is one whose functionality is dispersed 
over more than one execution platform. Several approaches 
exist to enable you to develop distributed applications with 
Java. Included among these approaches are JDBC, Java IDL, and
Java RMI:
</P>

<UL>
<LI>          JDBC (Java Database Connectivity) is a standard SQL
database access API. Chapter 17, &quot;JDBC,&quot; covers JDBC in more detail.
<LI>          Java IDL enables Java to access network servers by using
the Interface Definition Language defined by the Object
Management Group. The Java IDL API did not make it into the JDK 1.1
release, and is beyond the scope of this book. Look for it in future
JDK releases.
<LI>          Java RMI (Remote Method Invocation) is an API that enables
a Java program running on one platform to invoke the methods of
a Java program running on a different platform.
</UL>


<A NAME="PAGENUM-724"><P>Page 724</P></A>


<P>This chapter explores the design goals and capabilities of RMI and discusses how
to develop Java programs that use RMI. You also will learn about a technology
called Object Serialization that both helps enable RMI and provides a way to make Java
objects persistent. A persistent object is one whose state can be saved to persistent
storage, such as a magnetic disk.
</P>

<H3><A NAME="ch16_ 2">
Understanding Java RMI
</A></H3>

<P>Java RMI enables you to develop applications that consist of Java objects
distributed over more than one platform. RMI enables objects in one Java Virtual Machine (VM)
to call methods on objects residing in other Java VMs. Java primitive data types,
objects that come with the JDK, and objects that you create all can be both passed as
parameters and returned from these methods. Because RMI is included in the JDK 1.1 as a
core library, you can count on it being supported on any JDK 1.1 compliant implementation
of the Java Platform.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The Java Platform is an implementation of the Java VM and Java APIs on a
given hardware or software platform. Currently, the JDK 1.0.2 implementation of the
Java Platform is available for virtually every major operating system and browser, so
any Java program that uses the JDK 1.0.2 API should work properly on any of these
1.0.2 compliant implementations. A JDK 1.1-compliant implementation of the Java
Platform is becoming ported to virtually all the major hardware and software platforms.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<H4><A NAME="ch16_ 3">
Purpose for RMI
</A></H4>

<P>Java RMI was created as a pure Java solution for applications that have a
distributed objects design, in which objects can communicate with each other by invoking
each other's methods. Java applications have always had the capability to communicate
with each other through the sockets protocol, which is a  widely used
communication protocol. By using sockets, applications can implement distributed functionality
by sending requests and data back and forth. This approach is very low-level, however,
and requires an application-level communication protocol that each application
understands. An application-level communication
protocol is an agreed-upon format for communicating data between two processes in a distributed application.
</P>

<P>RMI's essential purpose is to provide an abstraction that enables an
application designer to invoke methods on remote objects instead of having to communicate at
a lower level. As a result, distributed applications written in Java can be completely
object-oriented and thus can be designed with object-oriented tools and methods. This
means that objects can be placed on the network in the most practical location rather than
in 
</P>

<A NAME="PAGENUM-725"><P>Page 725</P></A>


<P>
one Java VM address space. An object, for example, could reside on the same node as
a relational database and provide services that make use of the under-
lying database.
</P>

<H4><A NAME="ch16_ 4">
RMI Design Goals
</A></H4>

<P>The RMI designers at the JavaSoft business unit of Sun Microsystems developed
the following design objectives for RMI:
</P>

<UL>
<LI>          To make the process of invoking remote objects as similar as possible to that
of invoking local objects.
<LI>          To avoid completely disguising the locality of objects, and to enable client code
to treat objects differently, where appropriate.
<LI>          To maintain the type safety and security of the native Java environment.
<LI>          To be extensible, so that later enhancements, such as replicated objects, would
fit neatly into the overall architecture.
<LI>          To enable callbacks from servers to applets.
<LI>          To make the task of developing distributed applications as simple as possible.
</UL>

<P>The RMI implementation of JDK 1.1 has basically achieved these goals. How well
these features can be implemented in actuality, however, will only become apparent as the
Java development community gains more experience with them.
</P>

<H4><A NAME="ch16_ 5">
Overview of RMI Architecture
</A></H4>

<P>Two models will offer an overview of the RMI architecture. The first model, illustrated
in figure 16.1, shows the flow of a remote method invocation. The second model, shown
in figure 16.2, displays a block diagram of the RMI architecture.
</P>

<P><B>Remote Method Invocation Flow
</B></P>

<P>Figure 16.1 illustrates an overview of the process that occurs when a Java program
calls a method located in a remote object.
</P>

<P>The following steps provide a behind-the-scenes look at how this process works:
</P>
<A NAME="PAGENUM-726"><P>Page 726</P></A>



<P><a href="images\ch16fg01.jpg"><img src="images\tn_ch16fg01.jpg"></a><BR>
Figure 16.1
<I>RMI application flow.
</I></P>

<OL>
<LI>     The Java program calls a method of an object that represents the remote
object, which is called a stub. The stub contains a method for each of the methods (that
are allowed to be remotely invoked) in the remote object. These methods have the
same name, parameters and return value as their counterparts.
</OL>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The stub is sometimes referred to as the proxy, because it accepts method calls
on behalf of the remote object.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<OL START="2">
<LI>          The stub packages the arguments of the method into a stream that can be
communicated through the network. This process is called
marshaling and uses a marshal stream. During this process, the Java Object Serialization services serialize
primitive data types and objects passed as arguments to the method. Object Serialization
will be covered later in this chapter.
<LI>          The skeleton is an object that resides in the remote VM and is the counterpart to
the stub. Each remote object has a stub/skeleton pair. This skeleton unmarshals
the arguments from the marshal stream and calls the method in the remote object
with those arguments.
</OL>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Three architectural layers (see fig. 16.2) are involved in creating, sending, and
receiving the marshal stream, which is discussed in the next section.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<OL START="4">
<LI>          When the method returns, the skeleton marshals the return value (or exception, if
an 
</OL>


<P><CENTER>
<a href="..\ch15\0720-0722.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0727-0731.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

