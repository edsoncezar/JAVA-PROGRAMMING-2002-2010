<HTML>
<HEAD>


<TITLE>Inside Java:Animating Applets with Java Graphics, Images, Colors, and Sound:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0343-0347.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0353-0356.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-348"><P>Page 348</P></A>



<P>Specifically, this means that you must define your applet class as implementing
the Runnable interface and then defining the method
run() in the your applet class:
</P>

<PRE>
class MyApplet extends java.applet.Applet
         implements Runnable
{
      public void run()
      {
         // Thread logic.

      } // end run

} // end MyApplet
</PRE>

<P>For applets, you must use the Runnable interface. For other types of classes, you
can extend the Thread class as discussed in the previous section, or you can also
implement the class by using the Runnable interface. You, for example, could implement
the MyThreadClass discussed in the previous section as follows:
</P>

<PRE>
class MyThreadClass extends Object
         implements Runnable
{

      // Implement the run() method
      public void run()
      {
         // Thread logic

      } // end run

} // end MyThreadClass
</PRE>

<P>To create the thread, you need to first instantiate the MyThreadClass and then pass
the instance as an argument to the Thread constructor:
</P>

<PRE>
// Instantiate the class first.
MyThreadClass myc1 = new MyThreadClass();
MyThreadClass myc2 = new MyThreadClass();

// Create the threads
</PRE>


<A NAME="PAGENUM-349"><P>Page 349</P></A>



<PRE>
Thread thd1 = new Thread(myc1);
Thread thd2 = new Thread(myc2);

// Start the threads.
thd1.start();
thd2.start();
</PRE>

<P>Listing 9.4 (file MyThreadClass1.java on the CD-ROM accompanying this book)
shows an alternative way of implementing the Thread class example of listing 9.3 by using
the Runnable interface. Most of the listing differences are on lines 9 and 10 for defining
the class and in the main() method (lines 48_60). The nature of these differences has
been discussed earlier in this section.
</P>

<P>Listing 9.4
</P>
<PRE>
Line==================Java Source=================
01 /**
02  * MyThreadClass1: Demonstrates creation of
03  * threads by using the Runnable interface.
04  *
05  * Author: Karanjit S. G. S. Siyan
06  *
07  */
08
09 class MyThreadClass1 extends Object
10  implements Runnable
11 {
12       // Method start() inherited
13
14      private int ax2; // First term in series.
15      private int ax1; // Second term in series.
16
17      // Constructor for class to initialize
18      // start of series.
19      public MyThreadClass1(int ax2, int ax1)
20      {
21            this.ax2 = ax2;
22            this.ax1 = ax1;
23
24      } // end MyThreadClass1
</PRE>
<PRE>
                                                       <I>continues</I>
</PRE>

<A NAME="PAGENUM-350"><P>Page 350</P></A>



<P>Listing 9.4, Continued
</P>

<PRE>
25
26      // Overrides run() in Thread
27      public void run()
28      throws InterruptedException
29      {
30      //Loop forever!
31      for(;;)
32      {
33            int ax;
34
35            ax = ax1 + ax2;
36            System.out.println(ax);
37
38            // Get ready for the next iteration,
39            ax2 = ax1;
40            ax1 = ax;
41            Thread.sleep(2000);  // Sleep for 2 seconds
42
43       } // end for
44
45      } // end run
46
47      // main entry point
48      public static void main(String[] args)
49      {
50
51            MyThreadClass1 myc1 = new MyThreadClass1(1,1);
52            MyThreadClass1 myc2 = new MyThreadClass1(_1,_1);
53
54            Thread thd1 = new Thread(myc1);
55            Thread thd2 = new Thread(myc2);
56
57            thd1.start();  // Fibonacci series
58            thd2.start();  // Negative Fibonacci series
59
</PRE>


<A NAME="PAGENUM-351"><P>Page 351</P></A>



<PRE>
60      }  // end main
61
62      } // end MyThreadClass1
</PRE>


<H4><A NAME="ch09_ 19">
Examining Thread Methods
</A></H4>

<P>Suppose that you want to create threads but define some threads with a higher
priority than others. Threads with a higher priority are expected to run more often than
threads with lower priorities. You can control the thread priority by using the
setPriority() method and passing it an integer priority
value. The integer priority value ranges from a value
of Thread.MIN_PRIORITY to Thread.MAX_PRIORITY. The Thread class defines
the following static class constants:
</P>

<PRE>
// The minimum priority that a Thread can have.
// The most minimal priority is currently defined as 1.
public final static int MIN_PRIORITY = 1;

// The default priority that is assigned to a Thread.
// The default priority is currently set to 5.
public final static int NORM_PRIORITY = 5;

// The maximum priority that a Thread can have.
// The maximal priority value a Thread
// is currently set to 10.
public final static int MAX_PRIORITY = 10;
</PRE>

<P>To change the priority of a Thread object, thd1, to the maximum value, you can use
the following:
</P>

<PRE>
thd1.setPriority(Thread.MAX_PRIORITY);
</PRE>

<P>You can name threads at the time you create them by passing them string names:
</P>

<PRE>
MyThreadClass myc3 = new MyThreadClass();
MyThreadClass myc4 = new MyThreadClass();

// Create the named threads
Thread thd3 = new Thread(myc3, &quot;I am thread 3&quot;);
Thread thd4 = new Thread(myc2, &quot;I am thread 4&quot;);
</PRE>

<P>You can get a thread's name by using getName(), and you can change a thread's name
by using setName():
</P>

<A NAME="PAGENUM-352"><P>Page 352</P></A>


<PRE>
// Change the thread's names
thd3.setName(&quot;Thread 3&quot;);
thd4.setName(&quot;Thread 4&quot;);
String thd3Name = thd3.getName(); // Returns &quot;Thread 3&quot;
String thd4Name = thd4.getName(); // Returns &quot;Thread 4&quot;
</PRE>

<P>You can use the sleep() method and pass it the number of milliseconds or
nanoseconds you would like the thread to be suspended. The definitions of these methods are
shown here:
</P>

<PRE>
public static native void sleep(long millis)
         throws InterruptedException;

public static void sleep(long millis, int nanos)
          throws InterruptedException;
</PRE>

<P>You can suspend a thread by calling suspend(),
and continue again from where it left off, by calling
resume(). These methods are marked as final so that you cannot override
them and change their behavior:
</P>

<PRE>
public final void suspend();

public final void resume();
</PRE>

<P>If you think that the currently executing thread is using up quite a few of the
system resources, you can occasionally have it yield to other threads voluntarily by calling
the method yield(). Other threads that are waiting to run will be scheduled to run next.
</P>

<PRE>
public static void yield();
</PRE>

<P>To obtain the currently executing thread, you can call
currentThread():
</P>

<PRE>
public static Thread currentThread();
</PRE>

<P>To check if a thread is alive (or terminated), you can call the
isAlive() method for the thread. It will return a
true if the thread is alive and a false otherwise. Note that
this method is marked as final so that you cannot override and change it.
</P>

<PRE>
public final boolean isAlive();
</PRE>

<H4><A NAME="ch09_ 20">
Implementing Critical Regions
</A></H4>

<P>Because threads can be running simultaneously, they have access to the same
global data such as class instance variables or static data. One of the sources of subtle
errors
</P>

<P><CENTER>
<a href="0343-0347.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0353-0356.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

