<HTML>
<HEAD>


<TITLE>Inside Java:Animating Applets with Java Graphics, Images, Colors, and Sound:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0348-0352.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0357-0359.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-353"><P>Page 353</P></A>



<P>that can occur is when threads try to modify the same data in such a way that
the modification interferes with the logic of the thread. If, for example, one thread is trying
to increment a variable, but gets preempted in the middle of the increment step, and
a second thread runs and changes that variable, then when the first thread runs, it
will wipe out any changes made by the second thread. These types of problems are
called <I>race conditions</I>.
</P>

<P>A simple way to help the Java compiler handle such variables is to specify the
variable as being volatile. This tells the Java compiler not to make any assumptions about
the value of that variable, and that it can be changed uncontrollably from external
sources such as another running thread. Here is an example of an int variable declared as
being volatile:
</P>

<PRE>
volatile int change;
</PRE>

<P>If the variable is set to a constant such as 10:
</P>

<PRE>
change = 10;
</PRE>

<P>and the compiler does not see a reference to directly change this variable, it may as
part of its optimization, replace all references to
change by 10. This would be erroneous if another thread is expecting to change the variable.
</P>

<P>The use of the volatile does not avoid the race condition that may result because
of simultaneous updates to a variable. You should use it when your program logic
does work correctly in spite of simultaneous updates, or because you have another way
to synchronize access.
</P>

<P>A better way to synchronize simultaneous access to a section of Java code, so that
two threads are not simultaneously executing within that region of code, is to use
the synchronized qualifier. Consider the following method:
</P>

<PRE>
private synchronized void incr()
{
      ++p;
      System.out.println(p);

}
</PRE>

<P>The use of the synchronized qualifier ensures that the method
incr() will only be executed by one thread at a time. Another thread can only begin executing this thread if there
is no other thread currently executing the method. If there is another thread
currently executing the method, then the thread will have to wait until the currently
executing thread exits from the method. The thread that has to wait becomes
<I>blocked</I>. Blocked threads are put on a wait list of threads and do not actively consume system resources.
</P>

<A NAME="PAGENUM-354"><P>Page 354</P></A>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The Java compilers enable either of the following syntax to be used for synchronized:
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<PRE>
          public synchronized void method() {}

          synchronized public void method() {}
</PRE>

<P>The region of code protected by the
synchronized qualifier is called a critical
region. When the synchronized qualifier is used, a lock is associated with the critical
region. This lock is an internal flag that is set to indicate if a thread is executing the
critical region. Before executing a critical region, a thread checks the lock to see if a thread
is already in the critical region. If the lock indicates that there is no other thread in
the critical region, a thread can enter the critical region after setting the lock. When a
thread exits the critical region, it unlocks it by setting an appropriate value for the lock variable.
</P>

<P>The following is an example of class Score that contains a score variable that needs to
be protected against unsynchronized access:
</P>

<PRE>
public class Score
{
      private     int score;
      public Score(int score)
      {
         this.score = score;

      } // end Score

      public synchronized int setScore(int newScore)
      {
         score = newScore;

      } // end setScore

      public synchronized int addScore(int delta)
      {
         score += delta;

      } // end addScore

      public synchronized int getScore()
      {
         return score;

</PRE>

<A NAME="PAGENUM-355"><P>Page 355</P></A>



<PRE>

      } // end getScore

} // end Score

</PRE>


<P>The constructor for Score is not synchronized because it is executed only when the
object is instantiated, and this can occur only in one thread for an object that is being
created. All the other methods that are reading or updating the value of Score are
synchronized. The Score variable is declared as private, which means that it cannot be
accessed directly outside the class&#151;it can only be accessed by the accessor methods
setScore(), addScore(), and getScore().
</P>

<P>In addition to making the code in a method a critical region, you can declare any
statement in Java to be a critical region. The following is the general syntax of declaring
a statement to be synchronized:
</P>

<PRE>
      synchronized(expr)
         statement
</PRE>

<P>The <I>statement</I> is any Java statement including a block statement. The
<I>expr </I>must evaluate to an object to be locked; this is usually an object reference. A lock is associated
with this object. Only when a lock is obtained on the object, the
<I>statement</I> can be executed. The lock is released when the
<I>statement</I> finishes executing. Here is an example of
a synchronized block to reverse the elements of an array passed as a parameter to
a method:
</P>

<PRE>
public synchronized void reverse(int[] xa)
{
      synchronized(xa)
      {
         int  midpt = xa.length/2;
         for (int x = 0; x &lt; midpt; x++)
         {
         int     temp = xa[x];
         int     y = xa.length _ x _ 1;

         temp = xa[x];
         xa[x] = xa[y];
         xa[y] = temp;

         } // end for

      } // end synchronized

} // end reverse
</PRE>


<A NAME="PAGENUM-356"><P>Page 356</P></A>

<P>In the method reverse(), the xa array is being modified. While the array is being
modified, you do not want another thread to be accessing the elements of the array. You
can prevent this by locking the array reference.
</P>


<H4><A NAME="ch09_ 21">
Animating a Line in an Applet
</A></H4>

<P>
<a href="images\ch09fg17.jpg"><img src="images\tn_ch09fg17.jpg"></a><BR>
Figure 9.17 <I>Output of LineDraw in AppletViewer.</I>
</P>

<P>Listing 9.5 (program LineDraw.java on the CD-ROM accompanying this book)
shows an applet animated by a thread. The applet draws a rotating line whose colors
change randomly when the line rotates. Figure 9.17 shows a sample output of the display of
this program by using AppletViewer. The rest of this section contains a detailed analysis
on the workings of this applet.
</P>

<P>Lines 11_94 contain the definition of two classes Angle and Line. The
class Angle (lines 11_37) defines static methods
normalize() and radians() for normalizing an angle and
converting an angle from degrees to radians needed for the trigonometric functions.
</P>

<P>The class Line (lines 60_71) defines a class to represent a line.
The constructor for the line is called with the parameters
xc and yc that define the point at which a line will
be rotated within the applet, and a maximum size of the line
maxsize. Within this constructor, a random function is used to draw a line of random length, which is between zero
and maxsize pixels long. Other variables that are set in the constructor are for
bookkeeping purposes. The method rotate() (lines 74_92) in the class Line rotates the line by
the specified angle. The start and end of the rotated coordinates of the line are kept in
the points &lt;rotX[0], rotY[0]&gt; and &lt;rotX[1], rotY[1]&gt;, respectively.
</P>

<P>Lines 96_218 define the class LineDraw that is used to implement the
applet. This class extends the Applet definition and implements the Runnable interface. Line 100 defines
a label that is used to draw a label of text in the applet. You can paste text labels,
buttons, menus, and other objects in an Applet. The
dimX and dimY variables (see lines 103 and
</P>


<P><CENTER>
<a href="0348-0352.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0357-0359.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

