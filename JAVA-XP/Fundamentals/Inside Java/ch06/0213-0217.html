<HTML>
<HEAD>


<TITLE>Inside Java:Defining Java Classes:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0208-0212.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0218-0218.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-213"><P>Page 213</P></A>



<P>about the effect of these qualifiers in detail in Chapter 7. For now all that needs to be
said about them is that public makes the constructor callable from any Java code outside
the class. The use of private prohibits the call of the constructor, and hence the
instantiation of the class, from outside the class.
</P>

<P>An important difference that you may note between constructors and other
class methods is the absence of the return type. You may think that because constructors
do not have a return type, you can use a return type of
void. But this is not allowed by the language.
</P>

<P>Java constructor methods are always invoked with the use of the
new operator:
</P>
<PRE>
new  classname(parameters);
</PRE>

<P>The <I>parameters</I> must match, in number and type, one of the constructors defined for
the class.
</P>

<P>You can overload Java constructor methods. This means that you can define
several constructor methods for a class that differ in the parameter number and type. In fact, it
is typical to define several constructors for a method. Consider the following
modified example of the class Car that was discussed in listing 6.4:
</P>
<PRE>
class Car
{
      String name = &quot;no name&quot;;
      String color = &quot;no color&quot;;
      int nCylinders;

      Car ()
      {
         this.name = &quot;Ford&quot;;
         this.color = &quot;yellow&quot;;
         this.nCylinders = 6;

      }  // end Car

      // Car constructor
      Car (String name, String color, int nCylinders)
      {
         this.name = name;
         this.color = color;
         this.nCylinders = nCylinders;
</PRE>

<A NAME="PAGENUM-214"><P>Page 214</P></A>



<PRE>
      }  // end Car
      // toString: Needed by System.out.println
      // to print string value of car.
      // toString: Needed by System.out.println
      // to print string value of car.
      public String toString()
      {
         String descr = &quot;{name = &quot;+name+
            &quot;, color = &quot;+color+
            &quot;, engine = &quot;+nCylinders+&quot; cyl}&quot;;

         return descr;

      }  // end toString

}  // end Car
</PRE>

<P>Notice the definition of a constructor Car() with no arguments. Calling this
constructor defaults to a car object being created that is a Ford car, with yellow color, and a
six-cylinder engine. You may also note that the code in the second constructor for Car
(with parameters) is similar to the first constructor. You can simplify the code by having
the first constructor call the second constructor:
</P>



<PRE>
Car ()
{
      Car(&quot;Ford&quot;, &quot;yellow&quot;, 6);

}  // end Car

// Car constructor
Car (String name, String color, int nCylinders)
{
      this.name = name;
      this.color = color;
      this.nCylinders = nCylinders;

}  // end Car
</PRE>

<A NAME="PAGENUM-215"><P>Page 215</P></A>

<P>Another interesting aspect of class constructors is the use of
this within a constructor. In a class instance method, the use of this refers to the object for which the method
was called. Inside a constructor method, this means the name of the class. So you
could actually write the preceding code for the constructors as follows:
</P>

<PRE>
Car ()
{
      this(&quot;Ford&quot;, &quot;yellow&quot;, 6);

}  // end Car

// Car constructor
Car (String name, String color, int nCylinders)
{
      this.name = name;
      this.color = color;
      this.nCylinders = nCylinders;

}  // end Car
</PRE>

<H4><A NAME="ch06_ 17">
Static Blocks
</A></H4>

<P>You have seen the use of static variables in a class definition. These variables are
called class variables because they are defined for all instances of the class and they have
a common data space.
</P>

<P>Java permits the use of static initialization blocks that can perform a number of
complex initializations before the main Java code is executed. The syntax of static
initialization block is described next:
</P>

<PRE>
class classname
{

   static
   {

         // Static initialization code
 
</PRE>


<A NAME="PAGENUM-216"><P>Page 216</P></A>


<PRE>
  }


}
</PRE>

<P>Consider a situation where you want to initialize an array of integers with numbers
based on a certain algorithm or formula:
</P>
<PRE>
class Fibonacci
{
      static int[] series = new int[100];

      static
      {
         series[0] = series[1] = 1;
         for (int f = 2; f &lt; 100; f++)
         {
            series[f] = series[f_1] + series[f_2];

         } // end for

      }

} // end Fibonacci
</PRE>

<P>Note that the static initialization code does a fairly complex initialization of an array
of 100 integers by using a for loop within the static initialization block.
</P>

<P>The static initialization code is executed when the class is loaded. The static
initialization code is executed left-to-right and top-to-bottom. In the previous example, this order
of execution ensures that the array will have been defined before the static
initialization code is executed.
</P>

<P>It is possible for static initialization code in a class A to invoke a method in class
B, which then invokes a method in class A. When the method in class A is invoked in
this manner, it may access static fields in class A that have yet to be properly
initialized because the static initialization for A has not been completed. Static fields that do
not have their initializers executed are set to a default value, which is
false for Booleans, 0 for numbers, null for object references, and
`\u0000' for characters.
</P>

<H4><A NAME="ch06_ 18">
Building Modular Methods
</A></H4>

<A NAME="PAGENUM-217"><P>Page 217</P></A>





<P>Part of the process of creating an easy-to-understand yet powerful class is deciding
on which methods you are going to define, what kind of parameters are going to be
passed to the method, and how the methods are going to interact with each other. It is
important to partition the functionality of methods in such a way that their use is intuitive.
</P>

<P>The following steps are general guidelines that you can use for defining classes:
</P>

<OL>
<LI>          It is better to write several simple methods to accomplish a task rather than
one super method that can handle different logic functions depending on the
parameters passed to that function.
<LI>          Try to restrict the size of a method to about three pages of text code (75 lines). In
my opinion, this is the level of complexity that an average programmer can
comprehend quickly.
<LI>          Logic functions that are
<I>orthogonal</I> should be in their own methods.
Orthogonal functions are those that are logically quite different from each other, and have
a high degree of independence between them.
<LI>          If several methods in the class perform similar logic, you may want to define
a separate &quot;helper&quot; method that is called by other methods. You may also want
to restrict access to the helper method from outside the class.
</OL>

<H3><A NAME="ch06_ 19">
Summary
</A></H3>

<P>In this chapter you learned the structure of Java classes and the new inner
classes defined in Java 1.1. Java classes typically consist of class variables, class
instance variables, and methods. You were presented with several examples that showed
how classes can be defined. You learned about the issues of overloading Java methods
and constructors, method signatures, the scope or class variables versus local variables,
how parameters are passed to methods, and static initialization blocks for classes. Finally,
you were presented with some useful guidelines for writing classes.
</P>

<P><CENTER>
<a href="0208-0212.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0218-0218.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

