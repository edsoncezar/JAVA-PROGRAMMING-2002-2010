<HTML>
<HEAD>


<TITLE>Inside Java:Defining Java Classes:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0187-0190.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0198-0202.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-191"><P>Page 191</P></A>



<PRE>
030         else if (args[0].equalsIgnoreCase(&quot;descending&quot;))
031         {
032             sortAscending = false;
033
034         }
035         else
036         {
037             System.out.println(&quot;Illegal parameter to program.&quot;);
038             System.exit(1);
039
040         }  // end if
041
042         // Make a copy of the array so that the original
043         // is not modified.
044
045         int[] ya = new int[xa.length];
046         System.arraycopy(xa, 0, ya, 0, xa.length);
047         ArraySort2.sort(sortAscending, ya);
048         ArraySort2.print(sortAscending ?
049                 &quot;Ascending order&quot;:
050                 &quot;Descending order&quot;, ya);
051
052
053     } // end main
054
055 } // end MethodCalls
056
057 class ArraySort2
058 {
059
060    /*
061     * sort: This is the sort procedure that sorts
062     * the specified array in an ascending or
063     * descending order. This procedure implements
064     * the shell sort algorithm.
065     *
066     */
067     static void sort(boolean sortAsc, int st[])
068     {
</PRE>
<PRE>
								<I>continues</I>
</PRE>

<A NAME="PAGENUM-192"><P>Page 192</P></A>



<P>Listing 6.1, Continued
</P>
<PRE>
069
070         for (int gap = st.length/2; gap &gt; 0; gap /= 2)
071         {
072             for (int x = gap; x &lt; st.length; x++)
073             {
074                 for (int y = x _ gap; y &gt;= 0; y _= gap)
075                 {
076                     int temp;
077
078                     if (orderOK(sortAsc, st[y], st[y+gap]))
079                     {
080                         break;
081
082                     }  // end if
083
084                     // Exchange
085                     temp = st[y];
086                     st[y] = st[y+gap];
087                     st[y+gap] = temp;
088
089                 }  // end for
090
091             }  // end for
092
093         } // end for
094
095     }  // end sort
096
097    /*
098     * orderOK: This determines if the existing order of the
099     * two elements in the array is OK.
100     *
101     */
102     static boolean orderOK(boolean sortAsc, int xe, int ye)
103     {
104         boolean result = false;
105
106         if (sortAsc)
107         {
</PRE>


<A NAME="PAGENUM-193"><P>Page 193</P></A>


<PRE>
108             if (xe &lt;= ye)
109             {
110                 result = true;
111
112             }  // end if
113         }
114         else
115         {
116
117             if (xe &gt; ye)
118             {
119                 result = true;
120
121             }  // end if
122
123         }  // end if
124
125         return result;
126
127     }  // end orderOK
128
129    /*
130     * print: This is used to print the
131     * values of the array.
132     */
133     static void print(String msg, int[] xa)
134     {
135         System.out.println(msg+&quot;\n&quot;);
136
137         for (int x = 0; x &lt; xa.length; x++)
138         {
139
140             System.out.println(xa[x]);
141
142         }  // end for
143
144     }  // end print
145
146 }  // end ArraySort2
</PRE>


<A NAME="PAGENUM-194"><P>Page 194</P></A>



<H4><A NAME="ch06_ 12">
Method Signatures and Method Overloading
</A></H4>

<P>The method name must have a unique
<I>signature</I> within the class. The signature of
the method consists of the name of the method and the number and type of its
parameters. Consider, for example, the following class method definition with several methods
all named sampleReadings:
</P>
<PRE>
class OverLoad
{
      int sampleReadings()
      {
         ...
      }

      int sampleReadings(int x)
      {
         ...
      }

      int sampleReadings(float x)
      {
         ...
      }

      int sampleReadings(int x, int y)
      {
         ...
      }

      int sampleReadings(int x, float y)
      {
         ...
      }

      int sampleReadings(float x, int y)
      {
         ...
      }

      int sampleReadings(float x, float y)
      {
</PRE>


<A NAME="PAGENUM-195"><P>Page 195</P></A>


<PRE>

         ...
      }

}
</PRE>

<P>Each of the methods has an unique signature because even though the method name
is the same, there is a difference between each method in the combination of the number
of arguments and the types of arguments. When several methods with the same name
but with unique signatures are used in a class, the method name is said to be
<I>overloaded</I>.
</P>

<P>The method signature does not include the return type. Consider the example program
in listing 6.2 (file OverLoadedError.java on the CD-ROM accompanying this book).
The class OverLoadedError contains four overloaded functions
factor(). The methods on lines 18 and 25 differ only in their return types&#151;one returns an
int and the other returns a float:
</P>
<PRE>
int factor(int x, int y) { ... }

float factor(int x, int y) { ... }
</PRE>

<P>If you compile this program, you will receive the following error message (see fig.
6.7) that the two methods differ only in their return type.<BR>

</P>

<P>
<a href="images\ch06fg07.jpg"><img src="images\tn_ch06fg07.jpg"></a><BR>
<B>Figure 6.7</B>
<I>Compile error on overloading by return types.</I>
</P>

<A NAME="PAGENUM-196"><P>Page 196</P></A>



<P>Listing 6.2
</P>
<PRE>
Line==================Java Source=================
01 /**
02  * OverLoadedError: This shows that you cannot
03  * overload methods based upon differences in
04  * return type.
05  *
06  * Author: Karanjit S.G.S. Siyan
07  *
08  */
09 class OverLoadedError
10 {
11     int factor()
12     {
13         System.out.println(&quot;factor() called&quot;);
14         return 1;
15
16     }  // end factor
17
18     int factor(int x, int y)
19     {
20         System.out.println(&quot;int factor(int, int) called&quot;);
21         return 1;
22
23     }  // end factor
24
25     float factor(int x, int y)
26     {
27         System.out.println(&quot;float factor(int, int) called&quot;);
28         return 1.0f;
29
30     }  // end factor
31
32     int factor(int x, float y)
33     {
34         System.out.println(&quot;int factor(int, float) called&quot;);
35         return 1;
36
37     }  // end factor
</PRE>


<A NAME="PAGENUM-197"><P>Page 197</P></A>


<PRE>
38
39
40 }  // end OverLoadedError
</PRE>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You cannot overload class methods with differences only in their return type.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<H4><A NAME="ch06_ 13">
Understanding Parameter Passing in Methods
</A></H4>

<P>Parameter passing in Java is accomplished by a technique called
<I>call by value</I>. It's called this because a copy of the value of the parameter, stored in separate memory from
the original parameter value, is passed. When a method is executed, it works with copies
of the parameter values. Any changes that the method makes are made to the copy of
the parameter value only. These changes will not affect the original parameter value that
was passed.
</P>


<P>

<B>On the
CD</B><BR>
The program in listing 6.3 (file CallByValue.java in the CD-ROM accompanying
this book) demonstrates the call by value nature of Java parameter passing. Figure 6.8
shows the output of this program. Before calling
multBy3() on line 15, the value of x is printed
out; it is 10. Within the method multBy3(), the value of
x is printed out on entry to the method and after it is multiplied by 3&#151;these values are 10 and 30, respectively. On line 17,
the value of x is printed out after the call to
multBy3(). Figure 6.8 shows that while the value
of x was modified in multBy3(), there was no change in the value on return from
multBy3(). This is because a copy of the value of
x was passed to multBy3(). Changes to x inside
multBy3() were done on this copy, and not the original value, so the value of
x in line 17 is unchanged.
</P>



<P>
<a href="images\ch06fg08.jpg"><img src="images\tn_ch06fg08.jpg"></a><BR>
<B>Figure 6.8</B>
<I>Output of CallByValue.</I>



<P><CENTER>
<a href="0187-0190.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0198-0202.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

