<HTML>
<HEAD>


<TITLE>Inside Java:Experimenting with Java Data Types and Variables:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0036-0039.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0044-0048.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-40"><P>Page 40</P></A>




<PRE>
a = g * f;
</PRE>

<P>The variable g is of type byte with an initial value of _45. The compiler converts
this internally to an int and multiplies it with the value of the int value 2314 in variable f.
The result is an int of value _104130 that is within the range for an int data type.
</P>

<P>Consider the next assignment statement in listing 3.1 (line 21):
</P>

<PRE>
b = g * f;
</PRE>

<P>As before, the g * f expression will evaluate to an int of value _104130. This
value, however, is being assigned to a short data type, and it is outside the range of the
short data type. This statement will therefore produce an error message on compilation.
</P>

<P>Next, consider the definitions on lines 25 and 26:
</P>

<PRE>
long    i, j;
         int     k = 10000000000, el = 3;
</PRE>

<P>Line 25 defines long variables i and j, and line 26 defines int variables k and el
initialized to 10000000000 and 3. Now consider the following assignment statement on line 29:
</P>

<PRE>
a = k * 4L;
</PRE>

<P>The constant 4L causes the entire right-hand side expression to evaluate to long.
The left-hand side of the assignment is an int, which is smaller in size than a long;
therefore, the compiler produces an error message.
</P>

<P>Consider the same expression (k * 4L) assigned to variable i which is of type long on
line 32:
</P>

<PRE>
i = k * 4L;
</PRE>

<P>The above assignment statement as the right-hand side and left-hand side of
the assignments are both of type long.
</P>

<P>Figure 3.6 shows the result of compiling IntEval.java with
JavaC.
</P>

<P>Notice that the two error messages that are produced are on lines 21 and 29:
</P>



<A NAME="PAGENUM-41"><P>Page 41</P></A>



<P>
<a href="images\ch03fg06.jpg"><img src="images\tn_ch03fg06.jpg"></a><BR>
Figure 3.6
Compiling IntEval.java with JavaC.
</P>

<PRE>
IntEval.java(21): Incompatible type for =. Explicit cast needed to convert int
to short.
        b = g * f;
          ^
IntEval.java(29): Incompatible type for =. Explicit cast needed to convert long
to int.
        a = k * 4L;
          ^
2 errors
</PRE>

<P>Besides the standard division, multiplication, addition, and subtraction operations
that can be performed on integers, a number of other operations exist. These operators
apply to all the integer data types such as byte, short, int, and long. These are explained next.
</P>

<P>The increment (++) and decrement operators (_ _)
are unary operators and apply to single integer values. The ++ operator increases the value of its operand by one, and
the _ _ operator decreases the value by one.
</P>

<P>When the ++ operator is placed after the operand, it increments the operand
after its value has been used. When the ++ operator is placed
before the operand, it increments the operand before using its value. When the ++ operator is placed after the operand,
it is called postfix increment, and when it is placed before the operand it is called
prefix increment.
</P>

<P>Similarly, when the _ _ operator is placed after the operand, it decrements the
operand after its value has been used. When the _ _ operator is placed
before the operand, it
</P>



<A NAME="PAGENUM-42"><P>Page 42</P></A>



<P>decrements the operand before using its value. When the _ _ operator is placed after
the operand, it is called postfix decrement, and when it is placed before the operand it
is called prefix decrement.
</P>

<P>Consider the following example:
</P>

<PRE>
int     ival1 = 10;
int     ival2 = 20;
int     ival3;
ival3 = ival1++;     // Postfix increment
ival3 = ++ival1;     // Prefix increment
ival3 = ival2--;     // Postfix decrement
ival3 = --ival2;     // Prefix decrement
</PRE>

<P>After evaluating the first assignment statement, the value of ival3 is 10 and the value
of ival1 is 11.
</P>

<P>After the second assignment statement, the value of ival3 and ival1 are both 12.
</P>

<P>After evaluating the third assignment statement, the value of ival3 is 20 and the value
of ival2 is 19.
</P>

<P>After the fourth assignment statement, the value of ival3 and ival2 are both 18.
</P>

<P>The complement operator (~) is also an unary operator and performs a bitwise
complement of the bits in the integer value. It converts each 1-bit into a 0-bit, and each 0-bit to
a 1-bit.
</P>

<P>Consider the following example:
</P>

<PRE>
byte     bval1 = 5;
byte     bval2;
bval2 = ~ bval1;
</PRE>

<P>The bit representation of the byte value 3 is the following:
</P>

<P>00000101
</P>

<P>The assignment statement performs a complement of each of the bits. This results in
the following value:
</P>

<P>11111010
</P>

<P>Remember, that integers are signed numbers in Java. Therefore, this number is in
two's complement notation, and evaluates to the value of _6.
</P>



<A NAME="PAGENUM-43"><P>Page 43</P></A>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
For an n bit number in two's complement, whose individual bits are
bn, bn_1, <BR>
...b2, b1 with bn as the most significant bit, the value is represented by the following:

_bn* 2**(n_1) + bn_1* 2**(n_2) + ... + b2 * 2 + b1
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>Other bitwise operators for integers are the bitwise
OR (|) , bitwise AND (&amp;), bitwise XOR (^). These operators operate on the corresponding bits on each of its operands.
</P>

<P>The OR operator produces a 1, unless each of its bit operands is a 0, in which case
the result is a 0. The AND operator produces a 0, unless each of its bit operands is a 1,
in which case the result is a 1. The XOR operator produces a 0, if each of its operands
has the same value; otherwise, it produces a 1.
</P>

<P>Consider the following example:
</P>

<PRE>
byte     bval1 = 6;
byte     bval2 = 14;
byte     bval3;
bval3 = bval1 | bval2;
bval3 = bval1 &amp; bval2;
bval3 = bval1 ^ bval2;
</PRE>

<P>The bit representation of the value in bval1 and bval2 are the following:
</P>

<PRE>
bval1     =     00000101
bval2     =     00001110
</PRE>

<P>The value of bval3 in the first assignment statement that uses the bitwise OR (|) can
be calculated as shown:
</P>

<PRE>
bval1     =     00000101
bval2     =     00001110
--------------------------------------
bval3     =     00001111     = 15 decimal
</PRE>

<P>The value of bval3 in the second assignment statement that uses the bitwise
AND(&amp;) can be calculated as shown:
</P>




<P><CENTER>
<a href="0036-0039.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0044-0048.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

