<HTML>
<HEAD>


<TITLE>Inside Java:Experimenting with Java Data Types and Variables:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0040-0043.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0049-0052.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-44"><P>Page 44</P></A>



<PRE>
bval1     =     00000101
bval2     =     00001110
--------------------------------------
bval3     =     00000100     = 4 decimal
</PRE>


<P>The value of bval3 in the third assignment statement that uses the bitwise XOR(^) can
be calculated as shown:
</P>

<PRE>
bval1     =     00000101
bval2     =     00001110
--------------------------------------
bval3     =     00001011     = 11 decimal
</PRE>

<P>There are a number of shift operators for integers.
These are the left shift (&lt;&lt;), right sign
shift (&gt;&gt;), and right zero fill shift (&gt;&gt;&gt;) operators. These operators have the
following general syntax:
</P>

<P>operand op bitsToShift
</P>

<P>Here op is one of the &lt;&lt;, &gt;&gt;, &gt;&gt;&gt; operators.
</P>

<P>Consider the following example:
</P>

<PRE>
byte     bval1 = _6;
byte     bval2;
byte     bval3;
bval2 = bval1 &lt;&lt; 2;
bval3 = bval2 &gt;&gt; 2;
bval3 = bval2 &gt;&gt;&gt; 2;
</PRE>

<P>The bit representation of bval1, which has a value of _6, in two's complement
notations is the following:
</P>

<P>11111010
</P>

<P>The first assignment statement shifts this value of bval1 by 2 bits. The resulting
value assigned to bval2, is therefore _24:
</P>

<P>11101000
</P>

<P>Notice, that each left shift by 1 bit is equivalent to multiplying the original value by 2.
</P>

<P>In the second assignment statement, the value of bval2 is shifted to the right by 2.
Bit positions in the high order bit are filled with the sign bit, which in this case is 1.
So shifting the value of bval2 (11101000) by 2 bits gives the following:
</P>

<P>11111010
</P>

<P>This value is _6. Notice, that each signed right shift by 1 bit is equivalent to dividing
the original value by 2.
</P>



<A NAME="PAGENUM-45"><P>Page 45</P></A>



<P>Now consider the last assignment statement where the value of bval2 is shifted to
the right by 2, but bit positions in the high order bit are filled with zeros. So shifting
the value of bval2 (11101000) by 2 bits gives the following:
</P>

<P>00111010
</P>

<P>This value of bval3 is 58.
</P>

<P>Another operator for integers is the modulus (%) operator. The modulus operator
gives the remainder of a division operation. The following is the general syntax for using
the modulus operand:
</P>

<P>operand1 % operand2
</P>

<P>operand1 is divided by operand2. The result is the remainder of the division.
</P>

<P>Consider the following examples:
</P>

<PRE>
int     ival1 = 33;
int     ival2 = 5;
int     ival3;
ival3 = ival1 % 4;
ival3 = ival1 % ival2;
</PRE>

<P>In the first assignment statement ival3 evaluates to the remainder of 1, and in the
second assignment statement ival3 evaluates to the remainder of 3.
</P>

<H4><A NAME="ch03_ 7">
Examining the Floating Point Data Type
</A></H4>

<P>The floating point data type consists of two data types of different sizes and ranges
(see fig. 3.7). The floating point data type float is 32-bits wide long, and the floating
point data type double, as the name suggests has twice as many bits&#151;64 bits. All
floating point data types are represented by the IEEE
(Institute of Electronic and Electrical Engineers) floating point standard&#151;the IEEE
754_1975 standard.
</P>

<P>The reason for defining two floating point data types is to give the programmer
flexibility in dealing with floating point values of varying ranges and memory
requirements. Floating point numbers are used to represent fractional numbers. They can be used
to represent the set of real numbers with a varying degree of precision. Figure 3.8
shows
</P>



<A NAME="PAGENUM-46"><P>Page 46</P></A>



<P>
<a href="images\ch03fg07.jpg"><img src="images\tn_ch03fg07.jpg"></a><BR>
Figure 3.7
Floating point data types.
</P>

<P>the set of real numbers on a real number line. Because of the finite size of the
floating point size representation, the floating point number cannot model all points on the
real number line. The actual points that are represented accurately are shown as notches
on the real number line. The set of numbers that can be represented accurately are
crowded around zero (0) on the real number line. As you go further away from the zero point
on the real number line, the numbers that can be represented accurately are further
spread apart.
</P>

<P>The difference between a number of float type and a double type is that the double
type number has twice as many bits, and therefore twice as much precision. If the float
and double numbers were represented on the real number line, the numbers with double
will
</P>

<P>
<a href="images\ch03fg08.jpg"><img src="images\tn_ch03fg08.jpg"></a><BR>
Figure 3.8
The real number line.
</P>

<P>have more numbers that can be represented accurately (see fig. 3.9). The smallest
non-zero and maximum floating point representations for float and double values are
the following:
</P>

<P>Float MIN_VALUE = 1.4013e_045
</P>

<P>MAX_VALUE = 3.40282e+038
</P>

<P>Double MIN_VALUE  = 2.22507e_308
</P>



<A NAME="PAGENUM-47"><P>Page 47</P></A>



<P>MAX_VALUE = 1.79769e+308
</P>

<P>What if the result of a floating point number calculation results in a number that is
not </P>

<P>
<a href="images\ch03fg09.jpg"><img src="images\tn_ch03fg09.jpg"></a><BR>
Figure 3.9
Float and double number types on the real number line.
</P>

<P>accurately represented? Conceptually, such a number would fall between two
numbers that can be represented accurately. In this case, the math routines used by the
Java language will round to the nearest accurate number. As you can see, for a large
number of complex calculations, such errors can lead to some uncertainty in the accuracy
of results. The use of a larger precision such as double can help in reducing this
uncertainty.
</P>

<P>Floating point literals are written as a sequence of decimal digits with an optional
decimal point, optionally followed by an exponent. The exponent values are to the base 10,
and are written as the letter e or E, followed by the exponent value. The exponent notation
is also called the scientific notation for representing floating point numbers. Here are
some examples of floating point numbers:
</P>

<P>333.  3.33e2   33.3E1    .333e3     0.333E3
</P>

<P>These numbers denote the same floating point value of 333.0. Floating point
numbers such as those just described are automatically of type double, unless they have a
trailing f or F. Similarly, a trailing d or D can be explicitly used to specify a double floating
point literal. The following are examples of the number 333.0 as float literals:
</P>

<P>333.f  3.33e2F  33.3E1f   .333e3f    0.333E3F
</P>



<A NAME="PAGENUM-48"><P>Page 48</P></A>



<P>A zero value in floating point representation can be a positive 0.0 or a negative
_0.0. The actual sign often depends on the sign of the overall expression that may evaluate to
zero. In terms of numerical values, a positive zero or a negative zero are equal, but they
can produce slightly different results in computations. Division by zero for floating
point numbers, for example, is defined as Inf (infinity). Division by positive zero or
negative zero will produce different results. For example, 1d/0d is +Inf, whereas 1d/_0d is _Inf.
</P>

<P>Arithmetic operations involving a double floating point number will produce a
double result. A double floating point number cannot be assigned to a float variable, even if
the double value is within the precision of a float variable. The double result can be
explicitly converted to a floating point by using a cast before it can be assigned to a float.
</P>

<P>Java defines another representation of a floating point number to describe those
cases where the floating point number is not a number. The symbol NaN means &quot;not a
number.&quot; The NaN value can be produced as a result of calculations that result in
meaningless values. An example of this is if you divide Inf by Inf, which produces a NaN
result. Any comparison involving NaN will yield a false value, except for the not equal
operator (!=) comparison, which will always yield a true value.
</P>

<P>Consider some examples of defining floating point variables that are in the
FloatEval.java file on the CD-ROM. This program is reproduced in listing 3.2.
</P>

<P>Listing 3.2
</P>

<PRE>
Line==================Java Source=================
01 /**
02  * FloatEval: Test program to examine
03  * syntax errors for floating point
04  * evaluation.
05  *
06  * Author: Karanjit S.G.S. Siyan
07  */
08 class FloatEval
09 {
10     public static void main(String args[])
11     {
12            float   f1 = 12.0;
13            float   f2 = 24f;
14            float   f3;
15            float   f4;
16            float   f5;
17            float   f6;
</PRE>


</P>



<P><CENTER>
<a href="0040-0043.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0049-0052.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

