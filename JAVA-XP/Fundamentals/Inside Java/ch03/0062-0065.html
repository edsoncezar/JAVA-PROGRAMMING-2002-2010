<HTML>
<HEAD>


<TITLE>Inside Java:Experimenting with Java Data Types and Variables:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0058-0061.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0066-0069.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-62"><P>Page 62</P></A>



<PRE>
// Example 3
b3 = (x3 _ 2*x2 &lt; 0) || ((x3 = 400) &lt; 2*x2);
System.out.println(&quot;b3 = &quot;+b3+&quot;\t x3 =&quot;+x3);
</PRE>

<P>Consider the Example 4 on lines 36_38 in listing 3.4. In line 37 the expression <BR>
(x3 _2*x2 &gt; 0) is evaluated first. Because x3 _2*x2 is _100, this expression evaluates<BR>
 to false. The overall expression will now be determined by the value of the
second expression (x3 = 400) &lt; 2*x2. Therefore, the second expression is evaluated. Because
of the assignment operator in x3 = 400, x3 is assigned a value of 400, and this is compared
to see if it is less than 2*x2. 2*x2 evaluates to 400 also, and, therefore, the overall
expression and b3 evaluates to false.
</P>

<PRE>
// Example 4
b3 = (x3 _2*x2 &gt; 0) || ((x3 = 400) &lt; 2*x2);
System.out.println(&quot;b3 = &quot;+b3+&quot;\t x3 =&quot;+x3);
</PRE>

<P>When comparing Examples 3 and 4, notice that in one case the second expression
is skipped, and, in the other case, it is evaluated. Evaluation of the second expression
has the side-effect of changing the value of x3.
</P>

<P>Consider Example 5 on lines 40_49 in listing 3.4. The double variables d2 and d3 are
set to an expression that involves division by zero, and they are therefore both set to Inf.
A comparison check of equality (==) on the two Inf values will show that the result is true.
</P>

<PRE>
double   d1 = 0D;
double   d2, d3, d4;
boolean      b4, b5;

// Example 5
d2 = 2.0/d1;
d3 = 3.0/d1;
System.out.println(&quot;d2 = &quot;+d2+&quot;\t d3 =&quot;+d3);
b4 = (d2 == d3);
System.out.println(&quot;b4 = &quot;+b4);
</PRE>

<P>Consider Example 6 on lines 51_54 in listing 3.4. The double variable d4 involves
division of two double numbers whose value is Inf. Therefore, d4 is set to a NaN (Not a
Number) value. When a NaN != anynumber is evaluated, it always returns true. Therefore,
the value of b5 should be set to true.
</P>



<A NAME="PAGENUM-63"><P>Page 63</P></A>


<PRE>
// Example 6
d4 = d2/d3;
b5 = d4 != 100000000.0;
System.out.println(&quot;d4 = &quot;+d4+&quot;\t b5 =&quot;+b5);
</PRE>

<P>You can load the program BoolEval.java, which can be found in the CD-ROM at the
back of this book, and compile and run it. Figures 3.11 and 3.12 show the results of
compilation and execution with javac. The output values of this program have been discussed
in the previous paragraphs.
</P>


<P>
<a href="images\ch03fg11.jpg"><img src="images\tn_ch03fg11.jpg"></a><BR>
Figure 3.11
Compiling BoolEval with javac.
</P>

<BR>
<P>
<a href="images\ch03fg12.jpg"><img src="images\tn_ch03fg12.jpg"></a><BR>
Figure 3.12
Output of the BoolEval program.
</P>




<A NAME="PAGENUM-64"><P>Page 64</P></A>



<H3><A NAME="ch03_ 10">
Understanding Expression Evaluation
</A></H3>

<P>In the examples that have been discussed in this chapter you saw several examples
of arithmetic and Boolean expressions. The Java language defines the order in
which operators must be evaluated in case of expressions consisting of several operators.
In the expression x * y + z, for example, should you multiply x with y first and then add z;
or should you add y and z first, and then multiply the result by x? Most of you would
select the first order of evaluation because these are the rules of algebra. The Java
language contains rules on which operators must be evaluated. These rules are described
by operator precedence.
</P>

<H4><A NAME="ch03_ 11">
Understanding Operator Precedence
</A></H4>

<P>Table 3.8 shows the operator precedence order. The operators that are described at
the top of the table earlier have a higher precedence than those at the bottom. Operators
at the same entry in the table have the same precedence. The general evaluation order
for operators in an expression that has the same precedence is from left to right, with
the exception of the assignment operator that evaluates from right to left. Operators
that evaluate from left to right are called left
associative, and operators that evaluate from right to left are called
right associative. As an example of the left associative
rule consider the following expression:
</P>

<P>
x + y + z + 1
</P>

<P>The Java compiler will evaluate this expression starting with the leftmost &quot;+&quot;
operator and then the next one on the left, and so on. Therefore, the previous expression
is equivalent to the following:
</P>

<P>((x + y) + z) + 1
</P>

<P>In the example of BoolEval program in listing 3.4, you noticed that an
assignment statement in Java can be treated as an expression. The following is an example of the
use of several assignment operators in an expression:
</P>

<P>x = y = z = 1;
</P>

<P>The meaning of this assignment statement is that 1 is assigned to z, then z is assigned
to y, and finally y is assigned to x. The value of the expression is the value of x.
</P>

<P>If the left associative rule is used to evaluate this expression, the expression would
have to be evaluated as the following:
</P>



<A NAME="PAGENUM-65"><P>Page 65</P></A>



<P>((x = y) = z) = 1;
</P>

<P>The problem with the previous expression is how should y be assigned to x, when
the value of y is not known, as yet? Therefore, for assignment statements it makes
sense that the order of evaluation of the assignment operator (=) should be with the
rightmost. That is, the previous assignment statement should be evaluated as the following:
</P>

<P>
x = (y = (z = 1));
</P>

<P>Table 3.8<BR>
Operator Precedence
</P>

<TABLE>

<TR><TD>
Level
</TD><TD>
Operator Type
</TD><TD>
Operator
</TD></TR><TR><TD>
1
</TD><TD>
Parenthesis
</TD><TD>
()
</TD></TR><TR><TD>
2
</TD><TD>
Postfix operators
</TD><TD>
[] . (params) expr++
expr_ _
</TD></TR><TR><TD>
3
</TD><TD>
Prefix unary operators
</TD><TD>
+expr -expr<BR>
~expr  !expr  <BR>
          ++expr  _ _expr
</TD></TR><TR><TD>
4
</TD><TD>
Creation or cast
</TD><TD>
new(type)expr
</TD></TR><TR><TD>
5
</TD><TD>
Multiplicative
</TD><TD>
* / %
</TD></TR><TR><TD>
6
</TD><TD>
Additive
</TD><TD>
+ _
</TD></TR><TR><TD>
7
</TD><TD>
Shift
</TD><TD>
&lt;&lt;
&gt;&gt;    &gt;&gt;&gt;
</TD></TR><TR><TD>
8
</TD><TD>
Relational
</TD><TD>
&lt;  &gt;  &gt;=  &lt;=  instanceof
</TD></TR><TR><TD>
9
</TD><TD>
Equality
</TD><TD>
==   !=
</TD></TR><TR><TD>
10
</TD><TD>
Bitwise AND
</TD><TD>
&amp;
</TD></TR><TR><TD>
11
</TD><TD>
Bitwise XOR
</TD><TD>
^
</TD></TR><TR><TD>
12
</TD><TD>
Bitwise OR
</TD><TD>
|
</TD></TR><TR><TD>
13
</TD><TD>
Logical AND
</TD><TD>
&amp;&amp;
</TD></TR><TR><TD>
14
</TD><TD>
Logical OR
</TD><TD>
||
</TD></TR><TR><TD>
15
</TD><TD>
Conditional
</TD><TD>
?:
</TD></TR><TR><TD>
16
</TD><TD>
Assignment
</TD><TD>
= +=  _= *= /= %= &gt;&gt;= &lt;&lt;= &lt;&lt;&lt;= <BR>
&amp;= ^= |=
</TD></TR></TABLE>



<P><CENTER>
<a href="0058-0061.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0066-0069.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

