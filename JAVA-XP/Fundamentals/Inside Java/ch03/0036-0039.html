<HTML>
<HEAD>


<TITLE>Inside Java:Experimenting with Java Data Types and Variables:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0031-0035.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0040-0043.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-36"><P>Page 36</P></A>



<H3><A NAME="ch03_ 5">
Examining the Java Language Built-In Data Types
</A></H3>

<P>As mentioned in the previous section, Java has four categories of built-in data
types. Built-in data types are also called Java primitive data
types or basic data types. This section will discuss the built-in Java data types in greater detail.
</P>

<H4><A NAME="ch03_ 6">
Examining the Integer Data Type
</A></H4>

<P>The integer data type consists of four data types of different sizes and ranges (see
fig. 3.4). All integer data types are signed integers and are expressed by using two's
complement notation. This means that if the number of bits that make up the integer are
n, the most significant bit is used for the sign bit and the remaining
n_1 bits are used to represent the value (see fig. 3.5). Therefore, the minimum negative value of such
a number is _2**(n_1), and the maximum positive value is
2**(n_1) _1.
</P>

<P>
<a href="images\ch03fg04.jpg"><img src="images\tn_ch03fg04.jpg"></a><BR>
Figure 3.4
Integer data types.
</P>

<P>
<a href="images\ch03fg05.jpg"><img src="images\tn_ch03fg05.jpg"></a><BR>
Figure 3.5
Integer range values.<BR>
</P>

<P>Table 3.2 shows the different integer data types, their bit size, and their range of values.
</P>


<A NAME="PAGENUM-37"><P>Page 37</P></A>



<P>Table 3.2<BR>
Integer Data Types
</P>

<TABLE>

<TR><TD>
Integer Type
</TD><TD>
Bits Width
</TD><TD>
Range
</TD></TR><TR><TD>
byte
</TD><TD>
8
</TD><TD>
_128 to 127
</TD></TR><TR><TD>
short
</TD><TD>
16
</TD><TD>
_32768 to 32767
</TD></TR><TR><TD>
int
</TD><TD>
32
</TD><TD>
_2147483648 to 2147483647
</TD></TR><TR><TD>
long
</TD><TD>
64
</TD><TD>
_9223372036854775808 to 9223372036854775807
</TD></TR></TABLE>


<P>The reason for defining so many different integer data types is to give the
programmer flexibility in dealing with integer values of varying ranges and memory requirements.
For very small integer values within the range of _128 to 127, for example, a byte
representation would be adequate. Integers that are smaller in bit size also take up less space.
The memory savings may be small if you are using just a few integer types. But if you
are defining an array of, say 1000 integers, then the choice of which integer type to use
can have an impact on the amount of memory allocated for the integer array.
</P>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Integer types are always signed in Java. If you are used to a language like C/C++,
there are no unsigned qualifiers. You must use table 3.2 to decide if the integer data type
can adequately represent the range of numbers.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>Table 3.3 shows a comparison of the amount of space used for integer arrays of
1000 elements. If you blindly use a type of int, as many programmers do out of habit, when
an integer type of byte is adequate, you will allocate 4000 bytes instead of 1000 bytes.
</P>

<P>Table 3.3<BR>
Comparison of Space Used for an Integer Array of 1000
Elements
</P>

<TABLE>

<TR><TD>
Integer Type
</TD><TD>
Amount of Space Used (Bytes)
</TD></TR><TR><TD>
byte
</TD><TD>
1000
</TD></TR><TR><TD>
short
</TD><TD>
2000
</TD></TR><TR><TD>
int
</TD><TD>
4000
</TD></TR><TR><TD>
long
</TD><TD>
8000
</TD></TR></TABLE>



<A NAME="PAGENUM-38"><P>Page 38</P></A>



<P>When arithmetic operations are performed, values that are of type byte or short
are evaluated internally as int before the arithmetic operation is performed. If a literal of
type int is assigned to a byte or short value, and the value is within the range of the data
type that is being assigned to, the integer literal is treated as a byte or short, respectively.
</P>

<P>Integer literals, the values that are used to express the range of values for an integer,
are written as a sequence of decimal, octal, or hexadecimal digits. The following
integer literals, for example, have the same value:
</P>

<PRE>
42     051      0x2A      0X2a
</PRE>

<P>The first number, 42, is a decimal integer literal&#151;it is based on the decimal
number system. Integer literals that are preceded with a leading 0 (zero) are in octal
number notation, and use a base of 8. Lastly, integer values that are preceded with a 0x or 0X
are in hexadecimal notation, and use a base of 16. In the hexadecimal notation the
digits corresponding to the decimal value of 10, 11, 12, 13, 14, 15 are written as A, B, C, D, E,
F. You can also use lowercase letters.
</P>

<P>Integer literals are assumed to be of type int, unless they end in the letter L or l
(el). Therefore, the examples of the literals mentioned earlier are all type int. Because the
letter l (el) can be easily confused with the digit 1 (one), it is best to use the L nota-tion
for long literals.
</P>

<P>Consider some examples of defining integer variables that are in the
IntEval.java file on the CD-ROM. This program is reproduced in listing 3.1.
</P>

<P>Listing 3.1
</P>

<PRE>
Line==================Java Source=================
01 /**
02  * IntEval: Test program to examine
03  * syntax errors for integer evaluation.
04  *
05  * Author: Karanjit S.G.S. Siyan
06  */
07 class IntEval
08 {
09     public static void main(String args[])
10     {
11         // Example 1
12         int      a;
13         short      b,c,d;
14         int      e,f = 2314;
</PRE>




<A NAME="PAGENUM-39"><P>Page 39</P></A>




<PRE>
15         byte      g = _45, h;
16
17         // Assigning to an int
18         a = g * f;
19
20         // Assigning to a short
21         b = g * f;
22
23         // Example 2
24
25         long    i, j;
26         int     k = 10000000000, el = 3;
27
28         // Assign to an int
29         a = k * 4L;
30
31         // Assign to a long
32         i = k * 4L;
33
34
35     } // end main
36
37 } // end IntEval
</PRE>

<P>Consider the following definitions in listing 3.1 (lines 12_15):
</P>

<PRE>
     int               a;
     short               b,c,d;
     int               e,f = 2314;
     byte               g = _45, h;
</PRE>

<P>The first definition defines an int variable, a, with no initial value. The second
example defines variables b, c, d of type short. No initial values are set for the short
variables. The third example defines int variables e and f and initializes the value of f to 2314.
Notice that this value is within the range of the int value. The fourth example defines
byte variables g and h, and initializes variable g to _45. Notice that _45 is a literal of type
int, but the assignment to a byte is permissible because it is in the range of value for the
byte type.
</P>

<P>Now, consider the following assignment statement in listing 3.1 (line 18):
</P>



<P><CENTER>
<a href="0031-0035.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0040-0043.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

