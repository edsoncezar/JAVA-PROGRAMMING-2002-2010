<HTML>
<HEAD>


<TITLE>Inside Java:Using Java Objects and Arrays:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0127-0131.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0138-0141.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-132"><P>Page 132</P></A>



<P>Listing 5.1, Continued
</P>


<PRE>
077         long    ns;
078         ms = (new Date()).getTime();
079         for (int i = 0; i &lt; 5; i++)
080         {
081
082             double  x = (double)i;
083             double  y = 1;
084             long    deltaT;
085
086             for (int j = 0; j &lt; 1000; j++)
087             {
088                 y = Math.atan(x)*Math.sqrt(x)*Math.sin(x)*y;
089                 x += y;
090                 x = Math.abs(x);
091
092             }  // end for
093
094
095             ns = (new Date()).getTime();
096             deltaT = ns  ms;
097             System.out.println(&quot;Loop time = &quot;+deltaT);
098             ms = ns;
099
100         }  // end for
101
102     }  // end main
103
104 }  // end DateUse
</PRE>

<P>So how do you fix the problem illustrated in figures 5.6 to 5.8 where the value of the
todate variable changes unexpectedly? The solution is to make sure that each of the
Date objects reference their own separate data objects. Some classes implement a
method called clone(). When implemented, you can call this method by using the following
method to obtain a copy of the object:
</P>
<PRE>
Object.clone();
</PRE>

<P>The class Date, however, is not one of the classes that implements the clone method,
so you must seek another type of solution. One way is to extend the class Date and
create
</P>

<A NAME="PAGENUM-133"><P>Page 133</P></A>



<P>another class that supports the cloneable interface. To do this you need to
understand how Java inheritance and interfaces work, and these are topics that deserve a
separate treatment.
</P>


<P>Consider the alternate following solution to create a separate
futureDate object that has the same value as
todate:
</P>
<PRE>
Date futureDate = new Date(todate.getTime());
</PRE>

<P>In this solution, a different constructor for Date is being used, whose argument is
the number of milliseconds since midnight Jan 1, 1970 GMT. The use of a constructor
for futureDate ensures that the data for this object is distinct from any other Date object.
</P>

<P><a href="images\ch05fg11.jpg"><img src="images\tn_ch05fg11.jpg"></a><BR>
Figure 5.11
<I>Output of modified program DateUse2.java.</I>
</P>

<P>In listing 5.2, the assignment statement that created the problem of two references to
the same object has been eliminated. The
futureDate is created with its own constructor, as
can be seen on line 46 in listing 5.2. Listing 5.2 contains the modified program and figure
5.11 shows the output of the program. Comparing figure 5.11 with the program in figure
5.2, you can observe that the problem with the date object value changing unexpectedly
has been fixed. The modified program is in the file DateUse2.java on the CD-ROM
that accompanies this book.
</P>

<P>Listing 5.2
</P>
<PRE>
Line==================Java Source=================
001 /**
002  * DateUse2: This demonstrates the use of objects using
</PRE>
<PRE>
                                                       <I>continues</I>
</PRE>


<A NAME="PAGENUM-134"><P>Page 134</P></A>



<P>Listing 5.2, Continued
</P>

<PRE>
003  * the predefined date class in package java.util. It
004  * fixes the object reference problem in the program in
005  * file DateUse.java
006  *
007  * Author: Karanjit S. G. S. Siyan
008  *
009  */
010
011 import java.util.Date;
012
013 class DateUse2
014 {
015
016     public static void main(String args[])
017     {
018         // Example 1
019
020         Date    todate = new Date();
021         System.out.println(&quot;Today's date is &quot;+todate);
022
023         Date    date1 = null;
024         Date    date2 = null;
025         Date    date3 = null;
026
027         System.out.println(&quot;Printing undefined date value &quot;+date1);
028
029         date1 = new Date(100, 0, 1);
030         date2 = new Date(100, 9, 16, 12, 55);
031         date3 = new Date(100, 11, 31, 23, 59, 59);
032
033         System.out.println(&quot;First date is &quot;+date1);
034         System.out.println(&quot;Second date is &quot;+date2);
035         System.out.println(&quot;Third date is &quot;+date3);
036
037         long    ms;
038
039         ms = todate.getTime();
</PRE>


<A NAME="PAGENUM-135"><P>Page 135</P></A>


<PRE>
040         System.out.println(&quot;Milliseconds since midnight Jan 1, 1970 = &quot;+ms);
041
042
043         long    days = 333L;
044         long    msPerDay = 24*3600000L;
045
046         Date    futureDate = new Date(ms);
047
048         futureDate.setTime(ms + days*msPerDay);
049
050         System.out.println(&quot;\nFuture date after &quot;+days+&quot; days is
&Acirc;&quot;+futureDate);
051         System.out.println(&quot;Today's date is &quot;+todate);
052
053         if (futureDate.equals(todate))
054         {
055             System.out.println(&quot;This is indeed strange! Let's verify it.&quot;);
056             System.out.println(&quot;Examining today's date again:\n\tIt's
&Acirc;&quot;+todate);
057             System.out.println(&quot;\tWhy is the future date the same as today's
&Acirc;date?&quot;);
058         }
059         else if (futureDate.after(todate))
060         {
061             System.out.println(&quot;Yes. As expected the future date is indeed
&Acirc;afer today's date.&quot;);
062         }
063         else
064         {
065             System.out.println(&quot;Dates are realy messed up.&quot;);
066
067         }  // end if
068
069
070         System.out.println(&quot;Future date in GMT is
&Acirc;&quot;+futureDate.toGMTString());
071
072         int tzOffset = todate.getTimezoneOffset();
</PRE>
<PRE>
                                                       <I>continues</I>
</PRE>

<A NAME="PAGENUM-136"><P>Page 136</P></A>


<P>Listing 5.2, Continued
</P>

<PRE>
073         System.out.println(&quot;Timezone offset is &quot;+tzOffset+&quot; minutes for
&Acirc;&quot;+todate);
074
075
076         // Example 2
077
078         long    ns;
079         ms = (new Date()).getTime();
080         for (int i = 0; i &lt; 5; i++)
081         {
082
083             double  x = (double)i;
084             double  y = 1;
085             long    deltaT;
086
087             for (int j = 0; j &lt; 1000; j++)
088             {
089                 y = Math.atan(x)*Math.sqrt(x)*Math.sin(x)*y;
090                 x += y;
091                 x = Math.abs(x);
092
093             }  // end for
094
095
096             ns = (new Date()).getTime();
097             deltaT = ns  ms;
098             System.out.println(&quot;Loop time = &quot;+deltaT);
099             ms = ns;
100
101         }  // end for
102
103     }  // end main
104
105 }  // end DateUse2
</PRE>

<H4><A NAME="ch05_ 5">
Using the Type Wrapper Classes
</A></H4>

<A NAME="PAGENUM-137"><P>Page 137</P></A>


<P>The type wrappers are Java classes that are used with Java basic data types such as
the Boolean, character, int, long, double, and float to provide additional methods to
perform operations upon these data types. The term
<I>type wrapper</I> is used to describe these classes because these classes take a basic Java type and encapsulate them with
methods.
</P>

<P>Because type wrappers are classes, the methods defined in that class are available
for use by any object of that class. You cannot perform arithmetic operations on the
type wrapper classes directly. You must have access to the basic type values that
are encapsulated in the type wrapper class before you can perform arithmetic operations
on them. This means that the type wrapper class and its corresponding basic Java type
are not interchangeable. The type wrapper classes often have the same or similar name
as the Java basic types but are distinguished by beginning with a capital letter.
</P>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
By convention all Java classes begin with a capital letter, and all object variables
begin with a lowercase letter. Although this convention is not enforced by the Java
language, you will find this convention universally used among all the Java built-in classes.
For the sake of consistency, you may want to adopt this convention also.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>The Java type wrapper classes, for example, have the following predefined names:
</P>

<UL>
<LI>          Boolean
<LI>          Character
<LI>          Double
<LI>          Float
<LI>          Integer
<LI>          Long
</UL>

<P>Each of these class names has special methods that operate on the data type that
it encapsulates. A great deal of commonality in the type and syntax of many of
these methods exists. These common types, therefore, will be presented first.
</P>

<P><B>
Common Methods for Type Wrapper Classes
</B></P>

<P>The common method types for each type wrapper class are the following:
</P>

<UL>
<LI>          public classtype(basictype)
<LI>          public basictype classtypeValue()
</UL>

<P><CENTER>
<a href="0127-0131.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0138-0141.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

