<HTML>
<HEAD>


<TITLE>Inside Java:Object-Oriented Programming with Java:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0243-0249.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0255-0261.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-250"><P>Page 250</P></A>


<PRE>
class Object
{
      public Object();      // Empty. Does nothing.
      public boolean equals(Object obj); // Tests if two objects have same
                                            value
      public final Class getClass(); // Returns Class object associated with
                                        Object
      public int hashCode(); // Mathematical hashcode value used with class
                                Hashtable
      public final void notify(); // Thread synchronization method
      public final void notifyAll(); // Thread synchronization method
      public final void wait(long timeout); // Thread synchronization method
      public final void wait(long timeout, int nanos); // Thread
                                                          synchronization method
      public final void wait(); // Thread synchronization method
      public String toString(); // Converts object to string representation
      public Object clone(); // Produces a separate copy of object
      public Object finalize(); // Releases resources no longer in use.
}
</PRE>

<P>The class Object has a method called
toString(). So when this method is invoked for the classes S and E, the
toString() method for the class Object is called, and this produces
a display of the object that is seen in figure 7.15.
</P>

<P>The class S defined in listing 7.3 is implicitly inherited from the class Object. Thus,
the following class definitions are equivalent:
</P>


<PRE>

class S
{
      ...
}

class S extends Object
{
      ...
}
</PRE>

<P>As you can see from the preceding example, when the extends reserved word is left
out in defining a class, the Java language automatically defaults to extending the class
from the class Object.
</P>



<A NAME="PAGENUM-251"><P>Page 251</P></A>



<H4><A NAME="ch07_ 9">
Overriding the toString() Method
</A></H4>

<P>If you want to print out the value of an object using the
println() method or use the + or += operators to concatenate the object with a string, the
toString() method for the object is invoked. If you do not have a
toString() method defined for the class, and you do not
want to use the default toString() method defined for the
Object class, you must implement the toString() method for the class. If you want classes S and E to be printed out, each of
the classes S and E should define the toString() method with the following signature:
</P>

<PRE>
      public String toString()
      {
         // Implementation
         // details...

      } // end toString
</PRE>

<P>The qualifier public ensures that the method
toString() can be invoked from classes that are not in the same file as the class S and class E.
</P>

<P>The toString() method for class S is:
</P>

<PRE>
      public String toString()
      {

         String pstr = &quot;&lt;&quot;+sx+&quot;, &quot;+sy+&quot;&gt;&quot;;
         return pstr;
</PRE>

<A NAME="PAGENUM-252"><P>Page 252</P></A>


<PRE>
      }  // end toString
</PRE>

<P>The preceding method prints the two-dimensional point in the following format:
</P>


<PRE>
      &lt;sx, sy&gt;
</PRE>

<P>The toString() method for class E is shown next:
</P>


<PRE>
      public String toString()
      {

         String pstr = super.toString();

         pstr = pstr.substring(0, pstr.lastIndexOf(`&gt;'))+&quot;, &quot;+ez+&quot;&gt;&quot;;

         return pstr;

      }  // end toString
</PRE>

<P>The preceding method prints the three-dimensional point in the following format:
</P>

<PRE>
      &lt;sx, sy, ez&gt;
</PRE>

<P>The method toString() for class E uses the
toString() method of the superclass in its
implementation. It strips the trailing &quot;&gt;&quot; character returned by
super.toString() and appends the value of the instance variable ez. An alternative to this implementation is to not use
the superclass's toString() method, but to create the string representation from scratch:
</P>

<PRE>
      public String toString()
      {

         String pstr = &quot;&lt;&quot;+sx+&quot;, `+sy+&quot;, &quot;+ez+&quot;&gt;&quot;;

         return pstr;

      }  // end toString
</PRE>

<P>Listing 7.4 contains the complete program (file OverrideMethod2.java on the
CD-ROM accompanying this book) that shows the modified program in listing 7.3. This
program defines the toString() method in each of the classes S and E. The
toString() method in class S overrides the same method in class Object, and
the toString() method in class E overrides the method in class S.
</P>

<P>Listing 7.4
</P>

<PRE>
Line==================Java Source=================
001
002 /**
003  * OverrideMethod2: This demonstrates the use of
004  * using superclass methods to extend the functionality
005  * of extended classes. Shows how to override toString().
006  *
007  * Author: Karanjit S. G. S. Siyan
008  *
009  */
010
011 class Dimensions
</PRE>

<A NAME="PAGENUM-253"><P>Page 253</P></A>


<PRE>
012 {
013     public static void main(String[] args)
014     {
015         S  ptxy1 = new S();
016         S  ptxy2 = new S(1.0, 2.0);
017
018         double sz, angle;
019         System.out.println();
020
021
022         // Dimensions for ptxy1
023         sz = ptxy1.size();
024         angle = ptxy1.angleyx();
025         System.out.println();
026
027         // Dimensions for ptxy2
028         sz = ptxy2.size();
029         angle = ptxy2.angleyx();
030         System.out.println();
031
032         // Dimensions for ptxyz1
033         E ptxyz1 = new E();
034         E ptxyz2 = new E(1.0, 2.0, 3.0);
035         System.out.println();
036
037         sz = ptxyz1.size();
038         angle = ptxyz1.angleyx();
039         angle = ptxyz1.anglezyx();
040         System.out.println();
041
042         // Dimensions for ptxyz2
043         sz = ptxyz2.size();
044         angle = ptxyz2.angleyx();
045         angle = ptxyz2.anglezyx();
046         System.out.println();
047
048         // Printing S and E objects
049         String sprnt = ptxy1.toString();
050         System.out.println(&quot;ptxy1 (string) = &quot;+sprnt);
</PRE>
<PRE>
                                                 <I>continues</I>
</PRE>
<A NAME="PAGENUM-254"><P>Page 254</P></A>


<P>Listing 7.4, Continued
</P>


<PRE>
051         System.out.println(&quot;ptxy1 (println) = &quot;+ptxy1);
052
053         String eprnt = ptxyz1.toString();
054         System.out.println(&quot;ptxyz1 (string) = &quot;+eprnt);
055         System.out.println(&quot;ptxyz1 (println) = &quot;+ptxyz1);
056
057
058     }  // end main
059
060 }  // end Dimensions
061
062
063 // Superclass S
064 class S extends Object
065 {
066     // Instance variables for class S.
067     double sx;      // Xaxis coordinate
068     double sy;      // Yaxis coordinate
069
070     // Constructors of S
071     S()
072     {
073         this(1.0, 1.0);
074         System.out.println(&quot;Exiting constructor S()&quot;);
075
076
077     }  // end S
078
079     S(double sx, double sy)
080     {
081
082          System.out.println(&quot;Invoking constructor S(double, double)&quot;);
083
084          this.sx = sx;
085          this.sy = sy;
086
087     }  // end S
088
</PRE>


<P><CENTER>
<a href="0243-0249.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0255-0261.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

