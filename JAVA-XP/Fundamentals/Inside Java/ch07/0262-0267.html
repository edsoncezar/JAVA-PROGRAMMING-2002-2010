<HTML>
<HEAD>


<TITLE>Inside Java:Object-Oriented Programming with Java:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0255-0261.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0268-0272.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-262"><P>Page 262</P></A>


<PRE>
class E extends S
{
private double ez;

      public E()
      {
         super();
         ez = 1.0;

      }  // end E

      public E(double x, double y, double z)
      {
         super(x, y);
         ez = z;

} // end E

      // Other methods

} // end E
</PRE>

<P>If a method/variable is not preceded by any of the access modifiers such as
public, private, or protected, then the method/variable is said to be
<I>friendly</I>. Note that there is no reserved word called &quot;friendly&quot;; instead the absence of explicit access
modifiers makes the method/variable friendly. A friendly method/variable can be accessed
within the declaring class and any class or subclass in the same package. This access mode
is also sometimes called the <I>default access
mode</I>. Listing 7.3 shows a default mode being used for all method/variable declarations in the package. Even though there is no
explicit package statement defined in this listing, the compiler treats the contents of the file
as belonging to a package with &quot;noname.&quot;
</P>

<P>Another access mode called the &quot;private protected&quot; may be used to further restrict
the behavior of the protected access mode. Recall that in the definition of the
protected access mode, any class in the same package as the declaring class can access
the method/variable. Suppose that you want to provide access to the method/variable to
the subclasses only, and not other classes defined in the same package. You can do this
by defining the method/variable as being a private protected. In the earlier example of
the
</P>



<A NAME="PAGENUM-263"><P>Page 263</P></A>



<P>protected class, any other class defined in the same package as class S could access
the instance variables sx and sy by creating an instance of the
</P>

<P>class S:
</P>


<PRE>
class S extends Object
{
      protected double sx;
      protected double sy;

      public S()
      {
         this(1.0, 1.0);

      }  // end S

      public S(double sx, double sy)
      {

         this.sx = sx;
         this.sy = sy;

      }  // end S

// Other methods

} // end S

class E extends S
{
// Variable definitions

      public E()
      {
         super();
         ez = 1.0;

      }  // end E

      public E(double x, double y, double z)
</PRE>


<A NAME="PAGENUM-264"><P>Page 264</P></A>


<PRE>
      {
         super(x, y);
         ez = z;

} // end E

      // Other methods

} // end E

class X
{

      void trouble()
      {
         S point = new S();

         // Unexpected modification of
        // instance variables
        point.sx = _99999.0;
        point.sy = 2345235.32;

      } // end trouble

} // end X
</PRE>

<P>In the preceding example, class X defined in the same package as S, defines a
method trouble() that has unexpected access to instance variables of S. To prevent the type
of modifications by class X in the preceding example, you can declare sx and sy as
being private protected:
</P>

<PRE>
class S extends Object
{
      private protected double sx;
      private protected double sy;

      public S()
      {
</PRE>


<A NAME="PAGENUM-265"><P>Page 265</P></A>


<PRE>
         this(1.0, 1.0);

      }  // end S

      public S(double sx, double sy)
      {

         this.sx = sx;
         this.sy = sy;

      }  // end S

      // Other methods

} // end S

class E extends S
{
      // Variable definitions

      public E()
      {
         super();
         ez = 1.0;

      }  // end E

      public E(double x, double y, double z)
      {
         super(x, y);
         ez = z;

      } // end E

      // Other methods

} // end E
</PRE>



<A NAME="PAGENUM-266"><P>Page 266</P></A>


<P>Table 7.1 summarizes the behavior of the different access modes discussed in
this section.
</P>

<CENTER>
<P>Table 7.1<BR>
Access Modes
</P>
</CENTER>

<TABLE>

<TR><TD>
Mode
</TD><TD>
Subclass in
same
package
</TD><TD>
Non-subclass
in same
package
</TD><TD>
Subclass
in different
package
</TD><TD>
Non-subclass
different  in
package
</TD></TR><TR><TD>
public
</TD><TD>
Yes
</TD><TD>
Yes
</TD><TD>
Yes
</TD><TD>
Yes
</TD></TR><TR><TD>
protected
</TD><TD>
Yes
</TD><TD>
Yes
</TD><TD>
Yes
</TD><TD>
No
</TD></TR><TR><TD>
private
</TD><TD>
No
</TD><TD>
No
</TD><TD>
No
</TD><TD>
No
</TD></TR><TR><TD>
private protected
</TD><TD>
Yes
</TD><TD>
No
</TD><TD>
Yes
</TD><TD>
No
</TD></TR><TR><TD>
friendly (default)
</TD><TD>
Yes
</TD><TD>
Yes
</TD><TD>
No
</TD><TD>
No
</TD></TR></TABLE>



<H4><A NAME="ch07_ 12">
Marking Methods and Classes as Final
</A></H4>

<P>In the examples that you have seen so far, you can see that you can extend a class
by defining a new class that inherits from an existing class. But suppose that you want
to prevent this type of inheritance. You may, for example, want to prevent anyone
extending the definition of a class E to, let's say, create a four-dimensional point. You can do
so by marking the class E as final:
</P>

<PRE>
      final class E extends S
      {
         // Class implementation

      } // end E
</PRE>

<P>The preceding code prevents another class from inheriting from class E. Therefore,
the following definition of a class F will be caught by the Java compiler as an error:
</P>

<PRE>
class F extends E
      {
         ...

      } // end F
</PRE>


<A NAME="PAGENUM-267"><P>Page 267</P></A>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A class marked as final cannot be subclassed.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>You can also mark a method as being final. A final method cannot be overridden.
You may want to do so for security reasons, where you want to prevent another
programmer from changing the definition of the method. In listing 7.4, for example, you may want
to prevent a subclass of S from overriding the method
angleyx() defined in S:
</P>


<PRE>
      class S extends Object
      {
         // Instance variables for class S.
        double sx;      // Xaxis coordinate
        double sy;      // Yaxis coordinate

        // Constructors of S

        // Instance methods for class S

        final double angleyx()
        {

            double ang;

            ang = Math.atan2(sy,sx) * 180.0/Math.PI;
            System.out.println(&quot;S.angleyx() = &quot;+ang+&quot; degs&quot;);

            return ang;

         }  // end angleyx

      }  // end S
</PRE>

<P>The preceding code would prevent subclass E from overriding the method
angleyx() in class S.
</P>

<H4><A NAME="ch07_ 13">
Finalizing a Class
</A></H4>

<P>You can define the finalize() method for a class that can perform important cleanup
actions before memory for the object of that class is reclaimed. Java implements an
automatic garbage collector that runs periodically to reclaim space occupied by
unreferenced objects. You may, however, want your class to perform other actions, such as
close
</P>


<P><CENTER>
<a href="0255-0261.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0268-0272.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

