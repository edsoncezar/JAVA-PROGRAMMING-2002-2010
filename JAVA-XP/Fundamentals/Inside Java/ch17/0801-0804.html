<HTML>
<HEAD>


<TITLE>Inside Java:JDBC:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0798-0800.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0805-0808.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-801"><P>Page 801</P></A>



<P>The following sections demonstrate how JDBC and Java were used to create a
Web shopping site.
</P>

<H4><A NAME="ch17_ 34">
System Overview
</A></H4>

<P>Figure 17.4 presents a system overview of the Web shopper site. From this figure, it
is evident that the application must read the databases at both sites and combine
the information to give a complete picture to the prospective customer.
</P>

<P>Assume that the application uses JDBC API 1.11. H2O obtained Oracle and mSQL
JDBC drivers from JDBC driver vendors. The application is logically composed of two units:
a user interface combined with a business logic component coded with Java, and
a database component coded with the JDBC API.
</P>

<P>H2O's aim is to first provide a list of the available water pumps from which the
shopper can make a selection. This can be followed by such information as price and
inventory, as well as update operations, such as ordering a particular water pump.
</P>

<P><a href="images\ch17fg04.jpg"><img src="images\tn_ch17fg04.jpg"></a><BR>
Figure 17.4
System overview of the Web shopper.
</P>

<H4><A NAME="ch17_ 35">
System Implementation
</A></H4>

<P>Because this chapter mainly targets JDBC, the discussion focuses on the
database component of the system. The implementation can be done in a series of
systematic steps, as follows:
</P>

<OL>
<LI>          Connecting to the database.
<LI>          Querying the database.
</OL>

<A NAME="PAGENUM-802"><P>Page 802</P></A>



<OL START="3">
<LI>          Updating operations.
<LI>          Closing statements and connections.
</OL>

<P>The following sections explore the process step by step.
</P>

<P><B>Step One: Connecting to the Databases
</P></B>

<P>The first step in any database application involves establishing a connection to
the databases that contain information pertinent to the application. The following
code creates a connection to the database at Macon, Georgia.
</P>

<P>Listing 17.1
</P>

<PRE>
Line===================Connecting to the Database at Macon=====================
01 DriverManager myManager = new imaginary.sql.iMsqlDriver();
02 String url = &quot;jdbc:msql://www.H2OMacon.com:4333/Shopdb&quot;;
03 Connection con = myManager.getConnection(url, &quot;nobody&quot;,                &quot;&quot;);
</PRE>

<P>The first line of code creates an instance of the mSQL JDBC driver provided by
Imaginary (refer to
<a href="http://www.imaginary.com/~borg/java).">
http://www.imaginary.com/~borg/Java).</A> The application communicates with
the mSQL database by using the previously mentioned mSQL JDBC driver. Another way
to inform the DriverManager about a Driver class is to use the following
standard Class.forName method:
</P>

<PRE>
Class.forName(&quot;imaginary.sql.iMsqlDriver&quot;);
</PRE>

<P>The second line of code creates a String object with the value of the location of the
H2O Macon office database. This String object is required to create a Connection object,
and it follows the naming convention defined in JDBC specifications. Here, the
substring &quot;jdbc&quot; informs the server that the protocol to be used is JDBC. The substring
&quot;msql&quot; defines the subprotocol, and
//www.H2OMacon.com:4333/Shopdb specifies the database
name &quot;Shopdb&quot; and the server name.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The value 4333 is the MSQL_PORT for non-root access on UNIX systems.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>The third line of the code actually creates the connection by using the location
specified by String URL and logging in as user &quot;nobody&quot; with an empty password parameter.
This entire section of code must be placed within a try block to catch any SQLException
that may be thrown during the execution of this code. A SQLException is thrown if a
connection could not be established.
</P>

<P>Other ways exist to obtain a database connection. One way is to use the Driver
interface
</P>

<A NAME="PAGENUM-803"><P>Page 803</P></A>


<P>to obtain a connection. For the same effect as the previously defined piece of
code, implement the code in listing 17.2.
</P>

<P>Listing 17.2
</P>

<PRE>
Line=============Alternative Method of Connecting to a Database==============
04           Properties props = new Properties();
05           props.put(&quot;server&quot;,&quot;www.H2OMacon.com:4333&quot;);
06           props.put(&quot;user&quot;,&quot;nobody&quot;);
07           props.put(&quot;password&quot;,&quot;&quot;);
08           Driver msqldr = new imaginary.sql.iMsqlDriver();
09           String url = &quot;jdbc:msql://www.H2OMacon.com:4333/Shopdb&quot;;
10           connection1 = msqldr.connect(url,props);
</PRE>

<P>Here, the connection is obtained by asking the mSQL JDBC driver to create a
connection to the given URL by using the given properties. In essence, both segments of
code achieve the same result&#151;they create a connection.
</P>

<P>The next action involves creating a connection to the database in the Atlanta office
of H2O. This can be accomplished by using a JDBC driver for Oracle (refer to
<a href="http://www.weblogic.com/&#151;this">
http://www.weblogic.com/&#151;this</A> is an Oracle JDBC driver offered by WebLogic Technologies)
or by using the JDBC-ODBC bridge. The code lines in listing 17.3 use jdbcKona, a
JDBC driver offered by WebLogic for connecting to Oracle, Sybase, and MS SQL databases.
</P>

<P>Listing 17.3
</P>

<PRE>
Line================Connecting to the Database at Atlanta=====================
11           Properties props = new Properties();
12           props.put(&quot;user&quot;,     &quot;nobody&quot;);
13           props.put(&quot;password&quot;, &quot;&quot;);
14           props.put(&quot;server&quot;,   &quot;www.H2OAtlanta.com/inventory&quot;);
15           try {
16                Connection connection2 =
&Acirc;DriverManager.getConnection(&quot;jdbc:weblogic:oracle&quot;, props);
17                }
18           catch (SQLException e) {
19           System.out.println(&quot;Error message &quot; + e.getMessage();
20           }
</PRE>

<P>Now that both the connections are set up, it is time to query the database.
</P>

<PRE>
                                                                <i>continues</i>
</PRE>

<A NAME="PAGENUM-804"><P>Page 804</P></A>

<P>Listing 17.3, Continued
</P>





<P><B>
Step Two: Querying the Database
</P></B>

<P>H2O must present to the prospective customer the list of all the different kinds of
water pumps available at both sites of the company. The solution involves running
queries against both databases and then combining the results for an overall picture. Listing
17.4 illustrates the queries in code.
</P>

<P>Listing 17.4
</P>

<PRE>
Line======================Querying the Databases=============================
21      Statement stmt1 = connection1.createStatement();
22      ResultSet set1 = stmt1.executeQuery(&quot;SELECT * from SHOP_MACON ORDER BY
&Acirc;Pump_Id&quot;);
23     // Pump_Id is the primary key which represents a unique pump
24     // identification number
25      Statement stmt2 = connection2.createStatement();
26      ResultSet set2 = stmt2.executeQuery(&quot;SELECT * from SHOP_ATLANTA ORDER
&Acirc;BY Pump_No&quot;);
27     // Pump_No is essentially same as Pump_Id but was named
28     // differently by the Atlanta database designers.
</PRE>

<P>After executing the preceding two statements, all the unique tuples from each site
are stored in ResultSets, set1, and set2. The
executeQuery() method of Statement interface is usually used to execute a non-update query. You also can
use java.sql.PreparedStatement for this purpose. A PreparedStatement can be used
to specify IN parameters to query statements. IN parameters are used to
dynamically change the query statement as required. If, for example, the prospective shopper
was interested only in pumps that cost less than a particular value, it might be efficient
to have a PreparedStatement with IN parameters, as shown in the following line of code:
</P>

<PRE>
29     PreparedStatement stmt3 = connection1.prepareStatement(&quot;SELECT *FROM
&Acirc;SHOP_MACON WHERE (Pump_Cost &lt; ?)&quot;);
</PRE>

<P>The question mark symbolizes an unknown IN parameter. To determine all the
pumps that cost less than 500 dollars, the following lines of code can be used:
</P>

<PRE>
30     stmt3.setInt(1, 500);
31     ResultSet set3 = stmt3.executeQuery();
</PRE>

<P>Line 30 sets the value of the first IN parameter to an integer value of 500. If there
had been more than one &quot;?&quot; symbol in the PreparedStatement, this would mean that
more than one IN parameter exists. The parameter number (the first argument that is sent to
the setInt method) is used to set one of the IN parameter values while using one of the
setXXX
</P>


<P><CENTER>
<a href="0798-0800.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0805-0808.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

