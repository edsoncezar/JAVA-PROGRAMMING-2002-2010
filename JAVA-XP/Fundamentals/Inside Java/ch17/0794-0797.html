<HTML>
<HEAD>


<TITLE>Inside Java:JDBC:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0790-0793.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0798-0800.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-794"><P>Page 794</P></A>



<P>The constructors of this class follow:
</P>

<UL>
<LI>          SQLException(): This constructs a SQLException object. The reason and
SQLState attributes of the object default to null, and the vendorCode attribute defaults
to zero.
<LI>          SQLException(String
reasonForException): This constructs a SQLException with a
reason. The SQLState attribute, however, defaults to null, and the vendorCode
attribute defaults to zero.
<LI>          SQLException(String
reasonForException): This constructs a SQLException with a
reason and a SQLState. The reasonForException attribute describes the exception, and
the SQLState attribute is an XOPEN code for the exception. The vendorCode
attribute, however, is set to zero.
<LI>          SQLException(String reasonForException, String SQLState, int
vendorCode): This constructs a fully specified SQLException.
</UL>

<P><B>Methods of the java.sql.SQLException Class
</P></B>

<P>The java.sql.SQLException class consists of the following methods:
</P>

<UL>
<LI>          int getErrorCode(): This returns the vendor-specific exception code.
<LI>          String getSQLState(): This returns the SQLState, defined in the XOPEN specification.
<LI>          SQLException getNextException(): This method is used to obtain the next exception that
is chained to the current exception.
<LI>          void setNextException(SQLException
nextSQLException): This adds a SQLException to the
end of the chain.
</UL>

<H4><A NAME="ch17_ 29">
The java.sql.SQLWarning Class
</A></H4>

<P>The java.sql.SQLWarning class extends the java.sql.SQLException class.
The SQLWarning class provides information about a database access warning. When
a method of an object causes a warning to be reported, the warning is chained to
that object. The following sections describe the constructors and methods for
the java.sql.SQLWarning class.
</P>

<P><B>Constructors for the java.sql.SQLWarning Class
</P></B>

<P>The constructors for this class have the following forms:
</P>

<UL>
<LI>          SQLWarning(): This constructs a SQLWarning with the reason and SQLState
at
</UL>

<A NAME="PAGENUM-795"><P>Page 795</P></A>




<UL>
tributes set to null; the vendorCode attribute is set to zero.<BR>
<LI>          SQLWarning (String
reasonForWarning): This constructs a SQLWarning with a reason.
The SQLState attribute, however, defaults to null, and the vendorCode
attribute defaults to zero.
<LI>          SQLWarning(String reasonForWarning, String
SQLState): This constructs a SQLWarning with values for the reason and SQLState attributes. The vendorCode attribute
defaults to zero.
<LI>          SQLWarning(String reasonForWarning, String SQLState, int
vendorCode): This constructs a SQLWarning object with a reason that describes the warning, a SQLState that is
an XOPEN code identifying the warning, and a vendorCode that is a
vendor-specific warning code.
</UL>

<P><B>Methods of the java.sql.SQLWarning Class
</P></B>

<P>The java.sql.SQLWarning class consists of the following methods:
</P>

<UL>
<LI>          SQLWarning getNextWarning(): This returns the SQLWarning object chained to
the current SQLWarning object.
<LI>          void setNextWarning(SQLWarning
nextwarning): This adds a SQLWarning object to the
end of the chain.
</UL>

<P>Because both SQL and Java have an existing data type structure, it is necessary to
have an agreed mapping between the two. This next section discusses the mapping of
SQL data types to Java data types.
</P>

<H3><A NAME="ch17_ 30">
Mapping SQL Data Types to Java <BR>
Data Types
</A></H3>

<P>Before assigning data that is retrieved from a database to application variables, be
sure that it is assigned to compatible types. Also, to store and retrieve parameters
and recover results returned after the execution of SQL statements, make sure that
enough type information is available to the program.
</P>

<A NAME="PAGENUM-796"><P>Page 796</P></A>




<P>A mapping of SQL data types to Java data types makes this conversion clear. Table
17.2 illustrates the default Java mapping for common SQL data types.
</P>

<P><B>
Table 17.2</B><BR>
Common SQL Data Types
</P>

<TABLE>

<TR><TD>
SQL Type
</TD><TD>
Java Type
</TD></TR><TR><TD>
TINYINT
</TD><TD>
byte
</TD></TR><TR><TD>
SMALLINT
</TD><TD>
short
</TD></TR><TR><TD>
INTEGER
</TD><TD>
int
</TD></TR><TR><TD>
BIGINT
</TD><TD>
long
</TD></TR><TR><TD>
REAL
</TD><TD>
float
</TD></TR><TR><TD>
FLOAT, DOUBLE
</TD><TD>
double
</TD></TR><TR><TD>
NUMERIC, DECIMAL
</TD><TD>
java.lang.Bignum
</TD></TR><TR><TD>
BIT
</TD><TD>
boolean
</TD></TR><TR><TD>
BINARY, VARBINARY, LONGVARBINARY
</TD><TD>
byte[]
</TD></TR><TR><TD>
CHAR, VARCHAR, LONGVARCHAR
</TD><TD>
String
</TD></TR><TR><TD>
DATE
</TD><TD>
java.sql.Date
</TD></TR><TR><TD>
TIME
</TD><TD>
java.sql.Time
</TD></TR><TR><TD>
TIMESTAMP
</TD><TD>
java.sql.Timestamp
</TD></TR></TABLE>


<P>The documentation provided by JavaSoft mentions that the Java data type does
not require exactly the same form as the SQL data type. Java, for instance, does not have
any fixed length arrays, so variable-length Java arrays can be used to represent both
fixed and variable-length SQL arrays.
</P>

<P>Also, Java strings have been used, although they do not match any of the SQL
CHAR types exactly.
</P>

<P>The following list details some of these mappings:
</P>

<UL>
<LI>          TINYINT&#247;byte. Represents an 8-bit value, so that it can be mapped to Java's
byte type.
</UL>

<A NAME="PAGENUM-797"><P>Page 797</P></A>


<UL>
<LI>          SMALLINT&#247;short. Represents a 16-bit value, so that it can be mapped to
Java's short type.
<LI>          INTEGER&#247;int. Represents a 32-bit value, so that it can be mapped to Java's
int type.
<LI>          BIGINT&#247;long. Represents a 64-bit value, so that it can be mapped to Java's
long type.
<LI>          REAL&#247;float. Must support 7 digits of mantissa precision, so that it can be
mapped to the float type in Java.
<LI>          FLOAT&#247;double. Must support 15 digits of mantissa precision.
<LI>          DOUBLE&#247;double. Must support 15 digits of mantissa precision.
<LI>          NUMERIC&#247;java.lang.Bignum. Represents fixed point numbers when
absolute precision is required. This type is often used for currency values.
<LI>          DECIMAL&#247;java.lang.Bignum. Represents fixed point numbers when
absolute precision is required. This type is often used for currency values.
</UL>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Both the NUMERIC and DECIMAL SQL data types are mapped to
java.lang.Bignum extended precision number type, which is provided in JDK 1.1. Moreover,
simple strings and arrays of characters can be used to access DECIMAL and
NUMERIC values. In this way, Java programmers can use
getString() to retrieve a NUMERIC or DECIMAL result.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<UL>
<LI>          BIT&#247;boolean. Maps directly to the boolean type in Java. It can be used to
indicate a 0 or 1 value.
<LI>          BINARY&#247;byte[]. Can be expressed as a byte array in Java. Java programmers
do not need to distinguish between the three SQL byte arrays:
BINARY, VARBINARY, and LONGVARBINARY.
<LI>          VARBINARY&#247;byte[]. Can be expressed as a byte array in Java.
<LI>          LONGVARBINARY&#247;byte[]: Can be expressed as a byte array in Java.
The LONGVARBINARY SQL type can be used to return multimegabyte data values,
so that it can be retrieved as a Java input stream. Programmers then can read data
from the stream in the chunk size that they prefer.
<LI>          CHAR&#247;String. Can be expressed as a String type in Java. Java programmers do
not need to distinguish between the CHAR, VARCHAR, and LONGVARCHAR
SQL data types because they can be expressed identically in Java.
<LI>          VARCHAR&#247;String. Can be expressed as a String type in Java.
</UL>

<P><CENTER>
<a href="0790-0793.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0798-0800.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

