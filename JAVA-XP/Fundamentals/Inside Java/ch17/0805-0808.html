<HTML>
<HEAD>


<TITLE>Inside Java:JDBC:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0801-0804.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0809-0811.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-805"><P>Page 805</P></A>



<P>methods (XXX stands for such values as Int, String, or Byte) that is defined for
the PreparedStatement interface.
</P>

<P>To modify the above query to search for pumps costing less than 1,000 dollars,
change the IN parameter, as shown in the following lines of code:
</P>

<PRE>
30     stmt3.setInt(1, 1000);
31     ResultSet set4 = stmt3.executeQuery();
</PRE>

<P>ResultSet set4 now contains all the pumps costing less than 1,000 dollars. As
the previous examples illustrate, PreparedStatements are an efficient way to code
dynamically changing queries.
</P>

<P>Let's return to H2O's Web shopping system. The ResultSets from querying
both databases have been obtained, but these results must be processed correctly to give
the Web shopper a complete picture. It is perfectly possible that the number of
attributes (columns) in ResultSets set1 and set2 vary and that the names of the
corresponding attributes are also different. As a result, the application programmer may need to
obtain the names of the attributes for processing the obtained data. This can be achieved
by using the ResultSetMetaData interface, as shown in the code in listing 17.5.
</P>

<P>Listing 17.5
</P>

<PRE>
Line=====================Using ResultSetMetaData===============================
32 ResultSetMetaData rset1 = set1.getMetaData();
33 int num_columns_in_set1 = rset1.getColumnCount();
34  String[] col_names1 = new String[num_columns_in_set1];
35  for (int iterator=0; iterator&lt;num_columns_in_set1; iterator++) {
36      try {
37           col_names1[iterator] = rset1.getColumnName(iterator);
38           }
39       catch (SQLException e) {e.getMessage()}
40      }
</PRE>

<P>Line 32 first defines a ResultSetMetaData object, and line 33 then uses the
metadata object to obtain the number of columns in the result. The application programmer
can use the getColumnName() method of the metadata object to determine the column names
of the attributes in ResultSet set1. This information can be used for printing purposes,
such as generating a report header.
</P>

<P>Assume for simplicity that the Web shopper is to be presented with three attributes
from each table&#151;Pump_Id in set1 and Pump_No in set2, Pump_Name in set1 and
Pump_Label in set2, and Pump_Cost in set1 and Pump_Price in set2.
</P>

<A NAME="PAGENUM-806"><P>Page 806</P></A>




<P>Furthermore, also assume that these attributes are columns numbered one, two,
and three respectively in the actual tables&#151;hence, they are numbered similarly in
the ResultSets.
</P>

<P>The following code in listings 17.6 and 17.7 extracts the required information from
the ResultSets set1 and set2.
</P>

<P>Listing 17.6
</P>

<PRE>
Line===============Navigating through the set1 ResultSet Object================
41 while (set1.next()) {
42      String  Pump_ID = set1.getString(1);
43      String  Pump_NAME = set1.getString(2);
44      float   Pump_COST = set1.getFloat(3);
45      Process_Row(Pump_ID, Pump_NAME, Pump_COST);
46      }
</PRE>

<P>The ResultSet object is automatically assigned a cursor at the time of its creation.
The name of the cursor can be obtained by using the
getCursorName() method of the ResultSet interface. To obtain the names and prices of the pumps satisfying the query, it
is necessary to iterate through the ResultSet by using the
next() method, which advances the cursor's position by one. Similarly, the results from ResultSet set2 also must be
read. This can be accomplished by implementing the code in listing 17.7.
</P>

<P>Listing 17.7
</P>

<PRE>
Line===============Navigating through the set2 ResultSet Object================
47 while (set2.next()) {
48      String  Pump_ID = set2.getString(&quot;Pump_No&quot;);
49      String  Pump_NAME = set1.getString(&quot;Pump_Label&quot;);
50      float   Pump_COST = set1.getFloat(&quot;Pump_Price&quot;);
51      Process_Row(Pump_ID, Pump_NAME, Pump_COST);
52     // Process_Row is a method that combines the results
53     // from the two tables.
54      }
</PRE>

<P>Note that the column names are used to index into each row in the ResultSet
directly. Although this process produces much more readable code, it is not as efficient as
using column indexes to index into each row.
</P>

<P><B>Step Three: Furthering the Scenario with Update
</P></B>


<A NAME="PAGENUM-807"><P>Page 807</P></A>


<P><B>
Operations
</P></B>

<P>The Java component of the system displays the information requested by the
Web shopper and then offers the shopper an opportunity to place an order.
</P>

<P>Assume that the Web shopper decides to purchase two HG55-E (Pump Id)
High-Power Water Pumps. After carefully considering the buyer's location, the business
logic component decides that the pumps should be delivered to the customer from the
Atlanta unit of H2O. The database must be updated to reflect the potential sale, as illustrated
in listing 17.8.
</P>

<P>Listing 17.8
</P>

<PRE>
Line====================Updating the Database at Atlanta====================
55 Statement stmt4 = connection2.createStatement();
56 String query = new String(&quot;UPDATE SHOP_ ATLANTA SET Pump_Units = Pump_Units
 &Acirc;_2 WHERE Pump_Id = &quot;);
57      // Pump_Units represents the number of pumps available in
58      // the inventory at that given instant.
59 query.concat(selected_Pump_Id);
60           //Selected_Pump_Id represents the String object containing
61           //the Id of the pump the shopper wants to buy.
2 try {
63      return_code = stmt4.executeUpdate(query);
64      }
65 catch (SQLException e) {
66      System.out.println(e.getMessage());
67      }
</PRE>

<P>As listing 17.8 illustrates, the
executeUpdate() method of Statement interface is used
to execute SQL statements that can make some changes to the database. This
includes UPDATE, INSERT, DELETE, and DDL (Data Definition Language) commands.
</P>

<P>The execution of the code in listing 17.8 does not indicate that the transaction has
been completed. H2O must mail the Web shopper an invoice, and the shipping office must
be informed of the requested delivery. The entire logic associated with these processes
can be handled by the stored shipping_and_invoice procedure, which takes these
parameters: Selected_Pump_Id, Quantity_Purchased, User_Name, and User_Address.
</P>

<P>The following code calls the stored shipping_and_invoice procedure.
</P>


<A NAME="PAGENUM-808"><P>Page 808</P></A>





<P>Listing 17.9
</P>

<PRE>
Line======================Calling a Stored Procedure===========================
68 try {
69      CallableStatement call_stmt = connection1.prepareCall(&quot;{ ? = call 67
&Acirc;shipping_and_invoice(?, ?, ?, ?)}&quot;);
70      }
71 catch (SQLException e) {}
72 call_stmt.registerOutParameter(1, java.sql.Types.Bit);
73 call_stmt.setString(2, Selected_Pump_Id);
74 call_stmt.setInt(3, Quantity_Purchased);
75 call_stmt.setString(4, User_Name);
76 call_stmt.setString(5, User_Address);
77 try {
78       call_stmt.executeUpdate();
79       }
80  catch (SQLException e) {}
81  boolean successful = call_stmt.getBoolean(1);
82  if (successful)
83       send_user_message(&quot;Transaction successful!&quot;);
84           // send_user_message displays a message on the screen
85 else
86      send_user_message(&quot;Transaction failed!&quot;);
</PRE>

<P>To execute a stored procedure, you must use the CallableStatement interface,
which extends the PreparedStatement interface used earlier. The CallableStatement object
is created by using the prepareCall method of the Connection object. (The
prepare     Call method takes a special escape sequence, so refer to
{call ....}. The curly braces form an escape sequence that instructs the driver and the Driver Manager that this is a stored
procedure.)
</P>



<P>Line 69 uses a version of the call statement that returns a result value, which is
indicated by the first question mark &quot;?&quot;. Every result value must be registered as an OUT
parameter with the CallableStatement. This is accomplished by using the
registerOutParameter, as shown in line 69. The java.sql.Types.Bit data type has been used because the
stored procedure is expected to return a Boolean value. Line 69 has several &quot;?&quot; symbols
apart from the result value. Here, these are used as IN parameters.
</P>

<P>Actually, these values can be used as either IN or OUT parameters. If used as
OUT parameters, they must be registered with the CallableStatement in a manner similar to
the result value. The IN parameters are specified by using the
setXXX (XXX represents such
</P>


<P><CENTER>
<a href="0801-0804.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0809-0811.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

