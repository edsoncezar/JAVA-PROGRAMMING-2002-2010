<HTML>
<HEAD>


<TITLE>Inside Java:Performing Java Input/Output:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="..\ch10\0401-0408.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0414-0419.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-409"><P>Page 409</P></A>



<H3><A NAME="ch11_ 1">
CHAPTER 11
</A></H3>


<H2>

Performing Java In-<BR>
put/Output

</H2>

<P><B>I</B>n many languages the input/output mechanism is implemented 
by external libraries that are not part of the language. This 
approach gives flexibility to the user to define his/her own
input/output mechanism but also results in non-portable code because
the libraries are not standardized.
</P>

<P>
Java provides a built-in mechanism for defining input/output by
using predefined classes that you can instantiate or extend to provide
additional functionality. This chapter will give you a guided tour of the
more important of these input/output classes.
</P>



<A NAME="PAGENUM-410"><P>Page 410</P></A>



<H3><A NAME="ch11_ 2">
Understanding Java Input/Output
</A></H3>

<P>Java input/output is provided by streams. Streams
are an ordered sequence of data items. Typically, one thinks of files as being an ordered sequence of bytes or
records with their own internal structure. In Java, these files can be considered streams.
</P>

<P>You can have two types of streams: an input
stream and an output stream, also called the source
stream and the destination stream. You read data from the input stream, and
you write data to the output stream. The input stream and output streams are modeled in
Java as abstract classes of type InputStream and OutputStream (see fig. 11.1).
Consequently, all input streams and output streams in Java either inherit the methods defined in
the InputStream and OutputStream class, or must override these methods:
</P>

<P>
<a href="images\ch11fg01.jpg"><img src="images\tn_ch11fg01.jpg"></a><BR>
Figure 11.1
<I>InputStream and OutputStream.</I>
</P>

<P>
The InputStream and OutputStream classes are considered in more detail in the
following sections because their methods are used or extended by all other input/output classes.
</P>

<H4><A NAME="ch11_ 3">
The InputStream Class
</A></H4>

<P>The following is a description of the
InputStream class. This class serves as the base class for a number of input classes. This class is abstract, and therefore you
cannot create instances of this class. Instead, you must use the subclasses that inherit from
this class. Note that many of the input methods throw the IOException, so if you call
these methods, your program must deal with them.
</P>

<PRE>
public abstract class InputStream
{
    // Public methods //
    // (--------------) //
</PRE>


<A NAME="PAGENUM-411"><P>Page 411</P></A>


<PRE>
    // This method reads a byte of data. It will
    // block if no input is available. It returns the
    // the byte that is read, or _1 if the end of the
    // stream is encountered.
    public abstract int read() throws IOException;

    // This method reads into an array of bytes. It
    // will block if no input is available. It returns
    // the actual number of bytes that are read, or
    // _1 if the end of the stream is encountered.
    public int read(byte b[]) throws IOException;


    // This method reads into an array of bytes. It
    // will block if no input is available. It returns
    // the actual number of bytes that are read, or
    // _1 if the end of the stream is encountered.
    // The off parameter indicates the offset into
    // the byte array where data is read.
    // The len parameter indicates the maximum
    // number of bytes to be read.
    public int read(byte b[], int off, int len)
               throws IOException;



    // This method skips the specified number of
    // bytes of input. It returns the actual number of
    // bytes that are skipped. The method actually
    // returns the value of a call to read()
    // with a byte array equal to the size of the
    // number of bytes to be skipped. It returns the
    // result of this read(). If an end of stream
    // is encountered, a value of _1 will be returned.
    public long skip(long n) throws IOException;

   // This method returns the number of bytes that
    
</PRE>


<A NAME="PAGENUM-412"><P>Page 412</P></A>


<PRE>
    // can be read without blocking.
    public int available() throws IOException;


    // This method closes the input stream. It must
    // be called to release any resources associated
    // with the stream.
    public void close() throws IOException;

    // This method marks the current position in the
    // input stream. A call to reset() will
    // reposition the stream to the last marked
    // position so that subsequent reads will reread
    // the same bytes as long as no more than
    // readlimit bytes have been read since the call to
    // mark() and the call to reset().
    public synchronized void mark(int readlimit);


    // This method repositions the stream to the last
    // marked position. If the stream has not been
    // marked, or if the mark has been invalidated,
    // an IOException is thrown.
    public synchronized void reset()
     throws IOException;

    // This method returns a boolean indicating
    // whether or not this stream type supports
    // mark()/reset().
    // You should use this method to determine
    // if mark()/reset() is supported, otherwise
    // an I/O exception will be raised if you
    // attempt to use reset() and it is not supported.
    public boolean markSupported();

} // end InputStream

</PRE>

<A NAME="PAGENUM-413"><P>Page 413</P></A>



<P>
Because the InputStream is an abstract class, you cannot create direct instances
of InputStream. You can, however, take instances of subclasses of InputStream.
Consider the following example:
</P>

<PRE>
InputStream is = new FileInputStream(&quot;testfile.dat&quot;);

for(;;)
{
      int     ich;

      try
      {
         ich = is.read();
      }
      catch (IOException e)
      {
      System.out.println(e);

      } // end try

      if (ich == _1) break;

} // end for

</PRE>

<P>The FileInputStream class is a subclass of the InputStream class. This class is used
for performing file input operations. The following line creates an instance of
the FileInputStream and assigns it to the is object:
</P>

<PRE>
InputStream is = new FileInputStream(&quot;testfile.dat&quot;);
</PRE>

<P>
Within the for loop, a call to the read() method for the input stream returns a byte from
the input stream. The read() method can throw an IOException, so this must be caught
or declared in the throws clause of the enclosing method. As you can see from the
definition of read() in the class InputStream, a value of _1 returned from the
read() indicates the end of file on that stream. The for loop is exited when a value of _1 is returned by
read().
</P>

<P>Listing 11.1 shows a complete program that uses the
read() method just discussed to perform a character analysis of the program. Figure 11.2 shows the output of
this program by using the java interpreter.
</P>


<P><CENTER>
<a href="..\ch10\0401-0408.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0414-0419.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

