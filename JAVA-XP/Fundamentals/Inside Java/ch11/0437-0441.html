<HTML>
<HEAD>


<TITLE>Inside Java:Performing Java Input/Output:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0432-0436.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0442-0447.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-437"><P>Page 437</P></A>


<PRE>
    // This method reads into an array of bytes, b.
    // The off parameter is the startof offset
    // into the data array.
    // The len parameter is the maximum number of
    // bytes read.
    // A value of _1 is returned when the end of the
    // stream is encountered.
    // This method overrides InputStream.read().
    public synchronized int read(byte b[], int off,
                                 int len);


    // This method skips the specified bytes of input.
    // It returns the actual number of bytes skipped.
    // This method overrides InputStream.skip().
    public synchronized long skip(long n);


    // This method returns the number of available
    // bytes in the buffer.
    // This method overrides InputStream.available().
    public synchronized int available();


    // This method resets the buffer to the beginning
    // of the byte array.
    public synchronized void reset();

} // end StringBufferInputStream

Here is an example of using the StringBufferInputStream:

String str = &quot;An example string of data&quot;;
InputStream is = new StringBufferInputStream(str);

char ch = (char)is.read(); // Retuns `A'
ch = (char)is.read(); // Returns `n'


</PRE>

<A NAME="PAGENUM-438"><P>Page 438</P></A>



<H4><A NAME="ch11_ 9">
Using FilterInputStream and
FilterOutputStream
</A></H4>

<P>The filter input/output classes are used to build
a chain of filters. A filter reads data from an input stream, does some optional processing in the data, and sends it to an
out
</P>


<P>
<a href="images\ch11fg03.jpg"><img src="images\tn_ch11fg03.jpg"></a><BR>
Figure 11.3
<I>The concept of a filter.</I>
</P>

<P>
stream, which is potentially read as an input stream by another filter or program (see
fig. 11.3).
</P>

<P>
The FilterInputStream class stores another input stream as part of its class definition.
All method calls sent to the FilterInputStream are forwarded to this internal input
stream. The FilterInputStream is constructed by passing it an instance of an input stream
that will be stored internally. Consider the following chain
of input filters:
</P>
<PRE>
InputStream is = new FileInputStream(&quot;test.dat&quot;);
FilterInputStream fis1 = new FilterInputStream(is);
FilterInputStream fis2 = new FilterInputStream(fis1);
FilterInputStream fis3 = new FilterInputStream(fis2);
FilterInputStream fis4 = new FilterInputStream(fis4);
</PRE>

<P>Now consider the read() method sent to fis4:
</P>

<PRE>
fis4.read();
</PRE>

<P>This will result in fis4 forwarding the read() method to fis3, which will then forward it
to fis2, which will then forward it to fis1, which will finally forward it to stream
is (see fig. 11.4).
</P>

<P>The FilterInputStream class, in itself, does not do any processing but instead
forwards the methods to its internal input stream. If you want useful processing to be done,
you must subclass the FilterInputClass and provide the necessary processing. Examples
of the standard subclasses of FilterInputStream are the following:
</P>

<UL>
<LI>          BufferedInputStream
<LI>          DataInputStream
</UL>

<A NAME="PAGENUM-439"><P>Page 439</P></A>


<P>
<a href="images\ch11fg04.jpg"><img src="images\tn_ch11fg04.jpg"></a><BR>
Figure 11.4
<I>Method forwarding for the FilterInputStream class.</I>
</P>

<UL>
<LI>          LineNumberInputStream
<LI>          PushbackInputStream
</UL>

<P>The FilterOutputStream is used to set up an output filter. The FilterOutputStream
class stores another output stream as part of its class definition. All method calls sent to
the FilterOutputStream are forwarded to this internal output stream. The
FilterOutputStream is constructed by passing it an instance of an output stream that will be stored
internally. Consider the following chain of output filters:
</P>

<PRE>
OutputStream os = new FileOutputStream(&quot;test.dat&quot;);
FilterOutputStream fos1 = new FilterOutputStream(os);
FilterOutputStream fos2 = new FilterOutputStream(fos1);
FilterOutputStream fos3 = new FilterOutputStream(fos2);
FilterOutputStream fos4 = new FilterOutputStream(fos4);
</PRE>

<P>Now consider the write() method sent to fos4:
</P>

<PRE>
fos4.write();
</PRE>

<P>This will result in fos4 forwarding the write() method to fos3, which will then forward it
to fos2, which will then forward it to fos1, which will finally forward it to stream
os (see fig. 11.5).
</P>

<P>The FilterOutputStream class, in itself, does not do any processing but forwards
the methods to its internal output stream. If you want useful processing to be done,
you must subclass the FilterOutputClass and provide the necessary processing. Examples
of the standard subclasses of FilterOutputStream are the following:
</P>

<UL>
<LI>          BufferedOutputStream
</UL>

<A NAME="PAGENUM-440"><P>Page 440</P></A>



<P>
<a href="images\ch11fg05.jpg"><img src="images\tn_ch11fg05.jpg"></a><BR>
Figure 11.5
<I>Method forwarding for the FilterOutput-Stream class.</I>
</P>

<UL>
<LI>          DataOutputStream
<LI>          PrintStream
</UL>

<P>Both FilterInputStream and FilterOutputStream override the methods of their
respective superclasses: InputStream and OutputStream.
</P>

<H4><A NAME="ch11_ 10">
Using BufferedInputStream and
BufferedOutputStream
</A></H4>

<P>The BufferedInputStream class overrides the methods of its superclass
FilterInputStream to provide an internal buffering action that enables large amounts of data to be
read internally within its buffer. Even though the FilterInputStream methods are
overridden, the filter mechanism is retained. By using internal buffering, actual data is read in
large pieces, such as the size of a disk block. Subsequent requests for reading are
satisfied from the internal buffer and appear to be faster than disk access.
</P>

<P>You can create BufferedInputStream objects by using any of the following constructors:
</P>

<PRE>
public BufferedInputStream(InputStream in);
public BufferedInputStream(InputStream in, int size);
</PRE>

<P>The first form uses a default buffer size, and the second form uses a user specified
buffer size as the second argument to the constructor. The default buffer size in
current implementations of Java is 2048 bytes.
</P>

<P>Earlier, you saw several examples of how to use the FileInputStream. This class does
not
</P>


<A NAME="PAGENUM-441"><P>Page 441</P></A>



<P>implement buffering. To create a buffered version of an input stream class that
performs file operations, you can do the following:
</P>

<PRE>
InputStream is = new BufferedInputStream(
         new FileInputStream(&quot;large.dat&quot;), 4096);
</PRE>

<P>The preceding statement input file stream class uses a buffer of 4096 bytes.
</P>

<P>The BufferedOutputStream class overrides the methods of its
superclass FilterOutputStream to provide an internal buffering action that enables large amounts
of data that are written first internally within its buffer, and when the buffer is full to
the actual output stream. Even though the FilterOutputStream methods are overridden,
the filter mechanism is retained. By using internal buffering, actual data is written to
internal memory, which appears to be faster than writes to the actual output stream.
</P>

<P>You can create BufferedOutputStream objects by using any of the following
constructors:
</P>

<PRE>
public BufferedOutputStream(OutputStream out);
public BufferedOutputStream(OutputStream out, int size);
</PRE>

<P>The first form uses a default buffer size, and the second form uses a user specified
buffer size as the second argument to the constructor. The default buffer size in
current implementations of Java is 512 bytes.
</P>

<P>Earlier, you saw several examples of how to use the FileOutputStream. This class
does not implement buffering. To create a buffered version of an output stream class
that performs file output operations, you can do the following:
</P>

<PRE>
OutputStream os = new BufferedOutputStream(
         new FileOutputStream(&quot;out.dat&quot;), 1024);
</PRE>

<P>The preceding statement output file stream class uses a buffer of 1024 bytes.
</P>

<H4><A NAME="ch11_ 11">
Using DataInputStream and
DataOutputStream
</A></H4>

<P>The input/output stream classes you have seen so far process data as a stream of
bytes. There are many applications where there is a need to process the data as one of the
Java fundamental types, such as Booleans, bytes, integers, and floating point numbers.
This is where the DataInputStream and DataOutputStream classes come in handy. By
using these classes, you can write or read a stream of the Java fundamental data types.
</P>


<P><CENTER>
<a href="0432-0436.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0442-0447.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

