<HTML>
<HEAD>


<TITLE>Inside Java:Performing Java Input/Output:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0442-0447.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0453-0458.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-448"><P>Page 448</P></A>


<PRE>

while ((str1 = dis.readLine()) != null)
{
      System.out.println(&quot;Read line &quot;+lis.getLineNumber());


      // Process the string str1.

} // end while
</PRE>

<P>Note that this example uses a filter chain. The FileInputStream reads the data in the
file. This data is buffered by using the BufferedInputStream filter, and later numbered
by using the LineNumberInputStream filter. Finally, the input stream is interpreted as
a stream of Java fundamental data types.
</P>

<P>It is important to construct the filter chain in the order in which you expect to use
the data in the stream. In the previous example, the DataInputStream had to be the
outermost filter, as you were expecting to read Java data types. The inner filters should be nested
in the order of their desired operation. If, for example, you are buffering the data, you
must use BufferedInputStream as close to the data source as possible, as seen in the
previous example.
</P>

<H4><A NAME="ch11_ 13">
Using the PipedInputStream and
PipedOutputStream
</A></H4>

<P>The PipedInputStream and PipedOutputStream classes are used to build UNIX-like
pipe streams. The PipedInputStream implements the input end of the pipe and
the PipedOutputStream implements the output end of the pipe.
</P>

<P>The PipedInputStream class is used to read data from the pipe that was written by
using the PipedOutputStream class. Therefore, before using this class, you must connect it
to the PipedOutputStream class. You can do this at the time you instantiate this class or
by a call to the connect() method. The
PipedInputStream contains very low-level methods
for reading the data. A FilterInputStream may be used to provide a higher level of
interface for reading data from the
PipedInputStream class.
</P>

<P>The PipedInputStream class subclasses the InputStream class, defines the
abstract method read(), and overrides the methods read(byte[] b, int off, int
len) and close(). The size of the pipe buffer in the current implementation is 1024 bytes. The methods
for PipedInputStream are described next:
</P>

<PRE>
public class PipedInputStream
       extends InputStream
{

</PRE>

<A NAME="PAGENUM-449"><P>Page 449</P></A>


<PRE>
    // Public methods //
    // -------------- //

    // Constructor to create an input file connected

    // to the specified PipedOutputStream.
    public PipedInputStream (PipedOutputStream src)
      throws IOException;


    // Constructor to create the object. But no
    // connection is done as yet. You must
    // connect it to a PipedOutputStream first.
    // One reason for doing the connection
    // later is that you may want to do some
    // computation before deciding which
    // PipedOutputStream to which to connect.
    public PipedInputStream ();


    // This method connects this input stream to
    // the specified sender PipedOutputStream
    // object.
    public void connect(PipedOutputStream src)
           throws IOException;


    // This method reads a byte of data. It will block
    // if no input is available, and return a _1 if
    // end of stream is encountered.
    // This method defines InputStream.read().
    public synchronized int read()
           throws IOException;

    // This method reads into an array of bytes, b.
    // The off parameter is the start of offset
    // into the data array.
    // The len parameter is the maximum number of
    // bytes read.

</PRE>

<A NAME="PAGENUM-450"><P>Page 450</P></A>

<PRE>

    // A value of _1 is returned when the end of the
    // stream is encountered.
    // This method overrides InputStream.read().
    public synchronized int read(byte b[], int off,
           int len)  throws IOException;

    // This method closes the input stream. It must be
    // called to release any resources associated with
    // the stream.
    // This method overrides InputStream.close().
    public void close()  throws IOException;

} // end PipedInputStream

</PRE>

<P>The PipedOutputStream class contains very low-level methods for writing the data.
A FilterOutputStream may be used to provide a higher level of interface for writing data
to the PipedOutputStream class. The methods for PipedOutputStream are described next:
</P>

<PRE>
public class PipedOutputStream extends OutputStream
{

    // Public methods //
    // -------------- //

    // Constructs the class using an output file
    // connected to the specified PipedInputStream.
    public PipedOutputStream(PipedInputStream snk);


    // This constructs the class that isn't connected
    // to anything yet. It must be connected before
    // being used.
    public PipedOutputStream();

    // This method connects this output stream to
    // a receive PipedInputStream.
    public void connect(PipedInputStream snk)
           throws IOException;


  </PRE>

<A NAME="PAGENUM-451"><P>Page 451</P></A>


<PRE>

    // This writes a byte. This method will block
    // until the byte is actually written. Overrides
    // OutputStream.write().


    public void write(int b)  throws IOException;


    // This method writes a sub array of bytes, b,
    // to the output stream. It will block until
    // the byte is actually written. The sub array
    // is len bytes long and begins at off. Overrides
    // OutputStream.write().
    public void write(byte b[], int off, int len)
           throws IOException;


    // This closes the stream and releases
    // resources for the stream.
    public void close() throws IOException;

} // end PipedOutputStream

</PRE>

<P>The following shows an example of using the piped stream:
</P>

<PRE>
PipedInputStream pis = PipedInputStream();
PipedOutputStream pos = PipedOutputStream(pis);
// A producer thread writes to pis.
for(;;)
{
      int x;

      // compute x
      pos.write(x);

} // end for
// The corresponding consumer thread reads from pis.
for(;;)
{
      int x;
      x = pis.read();
</PRE>



<A NAME="PAGENUM-452"><P>Page 452</P></A>



<PRE>
      // Process x

} // end for

</PRE>

<H4><A NAME="ch11_ 14">
Using SequenceInputStream
</A></H4>

<P>The SequenceInputStream class is a subclass of InputStream. You can use this class
to combine two separate streams into one logical stream.
</P>

<P>Data is read from the combined stream in the order in which the separate streams
are specified. When the end of one stream is reached, data is read from the second stream
in a seamless fashion.
</P>

<PRE>
public class SequenceInputStream extends InputStream
{

    // This constructs a new SequenceInputStream
    // initialized to the specified list e.
    public SequenceInputStream(Enumeration e);

    // This constructs a new SequenceInputStream
    // initialized to the two specified input streams.
    public SequenceInputStream(InputStream s1,
                               InputStream s2);

    // This continues reading in the next stream
    // if an EOF is reached.
    final void nextStream() throws IOException;


    // Reads a stream, and upon reaching an EOF,
    // starts to read from the next stream.
    // Returns _1 when all streams are read.
    public int read() throws IOException;


    // Reads data into a subarray of bytes, and upon
    // reaching an EOF it starts to read from the next
    // stream.


</PRE>

<P><CENTER>
<a href="0442-0447.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0453-0458.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

