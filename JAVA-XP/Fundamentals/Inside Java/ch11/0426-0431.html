<HTML>
<HEAD>


<TITLE>Inside Java:Performing Java Input/Output:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0420-0425.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0432-0436.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-426"><P>Page 426</P></A>


<PRE>
      os.write(b);
}
catch (IOException e)
{
      System.out.println(e);

} // end try
</PRE>

<P>You can also write a specified number of bytes from a slice of the byte array,
starting from a specific location to the output stream:
</P>

<PRE>
public void write(byte b[], int off, int len)
               throws IOException;
</PRE>

<P>Here is an example of using the preceding
write() method:
</P>

<PRE>
try
{
      // Write 500 bytes starting at offset 10
      os.write(buff, 10, 500);
}
catch (IOException e)
{
      System.out.println(e);

} // end try
</PRE>

<P>When you write to the output stream, your data may be temporarily cached in
internal buffers before being written out to the actual destination. If you want to ensure that
all data cached in internal buffers is flushed out to the destination, you can use the
flush() method:
</P>

<PRE>
public void flush() throws IOException;
</PRE>

<P>The flush() method for OutputStream is empty. Subclasses of OutputStream that
implement buffering are expected to override the
flush() method with logic that will perform the flushing action on the internal buffers. The output stream classes
BufferedOutputStream and PrintStream implement buffering.
</P>

<P>Here is an example of the use of the flush() method:
</P>


<A NAME="PAGENUM-427"><P>Page 427</P></A>


<PRE>
// Output stream, os, constructed
// that uses buffering.

byte[] buff = new byte[2048];

// Code to fill the buff array

try
{
      os.write(b);
      os.flush();
}
catch (IOException e)
{
      System.out.println(e);

} // end try
</PRE>

<P>After you are done writing the data, you should close
the stream to release the resources associated with writing the stream:
</P>

<PRE>
public void close() throws IOException;
</PRE>

<P>Here is a sample code fragment that illustrates the use of
close():
</P>

<PRE>
OutputStream os = new FileOutputStream(&quot;testfile.dat&quot;);
byte[] buff = new byte[2048];

// Code to fill the byte array buff.

try
{

      os.write(buff);
}
catch (IOException e)
{
      System.println(e)
}
finally
</PRE>

<A NAME="PAGENUM-428"><P>Page 428</P></A>


<PRE>
{
      os.close();

} // end try
</PRE>

<P>The finally clause will always be executed, whether an exception occurs or not, and
this will close the file.
</P>

<H3><A NAME="ch11_ 5">
Other Classes for Input/Output
</A></H3>

<P>So far you have examined the basic operations that are available for input and
output streams. Java provides a number of additional classes that you can use to enhance
these basic operations. These classes include the following:
</P>

<UL>
<LI>          File
<LI>          ByteArrayInputStream and ByteArrayOutputStream
<LI>          StringBufferInputStream
<LI>          FilterInputStream and FilterOutputStream
<LI>          BufferedInputStream and BufferedOutputStream
<LI>          DataInputStream and DataOutputStream
<LI>          PipedInputStream and PipedOutputStream
<LI>          SequenceInputStream
<LI>          LineNumberInputStream
<LI>          PushbackInputStream
<LI>          PrintStream
<LI>          RandomAccessFile
</UL>


<H4><A NAME="ch11_ 6">
Using the File Class
</A></H4>

<P>The File class provides a way of describing files and directories. After you build
an instance of the file class, you can query the file object for information about the file
or directory.
</P>


<A NAME="PAGENUM-429"><P>Page 429</P></A>



<P>The class includes several different types of constructors for convenience in
building the File object:
</P>

<PRE>
File fo1 = new File(&quot;testfile.dat&quot;);
File fo2 = new File(&quot;/docs&quot;, &quot;file.dat&quot;);
</PRE>

<P>You can then use test methods such as canRead(),
isFile(), and so on, to test the properties of files and directories. Many of these tests are implemented internally by calling
native methods for the underlying operating system and platform on which the Java
environment is hosted.
</P>

<P>Here is a detailed description of the File class methods:
</P>

<PRE>
public class File
{
    // Public constants //
    // ---------------- //

    // The system dependent file separator String
    // such as a forward slash (/) or backslash (\).
    public static final String separator;

    // The system dependent file separator character
    // such as a forward slash (/) or backslash (\)
    public static final char separatorChar;


    // The system dependent path separator String
    // such as a forward slash (/) or backslash (\).
    // Usually the same as the fileSepartor but
    // could be different.
    public static final String pathSeparator;



    // The system dependent path separator String
    // such as a forward slash (/) or backslash (\).
    // Usually the same as the fileSepartor but
    // could be different.
    public static final char pathSeparatorChar;

</PRE>


<A NAME="PAGENUM-430"><P>Page 430</P></A>


<PRE>
    // Constructors

    // Constructor 1:
    // Build a File class given path name of file
    public File(String path);

    // Constructor 2:
    // Creates a File object given the directory path
    // of the file object and the file name.
    // Concatenates path and name using separator
    // variable to form the path name and calls
    // constructor 1.
    public File(String path, String name);


    // Constructor 3:
    // Creates a File object given the directory name
    // and the file name.
    // Obtains path of the directory, and calls
    // constructor 2.
    public File(File dir, String name);

    // Public Methods //
    // -------------- //

    // Returns the name of the file without the
    // directory prefix.
    public String getName();

    // Returns the path of the file that was
    // built when the constructor was called.
    public String getPath();

    // Returns the complete path name of the file.
    // If the path that was specified when the
    // File constructor was called was a relative
    // path name, it prepends the current directory
    // to build the complete path name.

</PRE>

<A NAME="PAGENUM-431"><P>Page 431</P></A>


<PRE>
    public String getAbsolutePath();


    // Returns the parent directory. It returns if
    // the path that was specified in the constructor
    // for File was specified without a directory.
    public String getParent();

    // Returns a boolean indicating whether or not a
    // file exists.
    public boolean exists();

    // Returns a boolean indicating whether or not
    // a writable file exists.
    public boolean canWrite();


    // Returns a boolean indicating whether or not
    // a readable file exists.

    // Returns a boolean indicating whether or not
    // a normal file exists.
    public boolean isFile();


    // Returns a boolean indicating whether or not
    // a directory file exists.
    public boolean isDirectory();

    // Returns a boolean indicating whether the
    // file name is absolute.
    public native boolean isAbsolute();
    // Returns the last modification time.
    // The return value should only be used to
    // compare modification dates. Its absolute
    // value does not have any official meaning.
    public long lastModified();

</PRE>


<P><CENTER>
<a href="0420-0425.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0432-0436.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

