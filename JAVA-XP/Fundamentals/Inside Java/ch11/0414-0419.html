<HTML>
<HEAD>


<TITLE>Inside Java:Performing Java Input/Output:EarthWeb Inc.-</TITLE>







<P><CENTER>
<a href="0409-0413.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0420-0425.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-414"><P>Page 414</P></A>



<P>Listing 11.1
</P>

<PRE>
Line==================Java Source=================
001 /**
002  * ReadInputStream: Illustrates using the input
003  * stream.
004  *
005  * Author: Karanjit S. G. S. Siyan
006  *
007  */
008
009 import java.io.*;
010
011 class ReadInputStream
012 {
013
014     public static void main(String[] args)
015     {
016
017        InputStream  is = null;
018
019        if (args.length == 0)
020        {
021             is = System.in;
022        }
023        else if (args.length == 1)
024        {
025             try
026             {
027                 is = new FileInputStream(args[0]);
028             }
029             catch (FileNotFoundException e)
030             {
031                 System.out.println(&quot;File &quot;+args[0]+&quot; not found&quot;);
032                 System.exit(0);
033             }
034             catch (IOException e)
035             {
036                 System.out.println(e);
037
</PRE>


<A NAME="PAGENUM-415"><P>Page 415</P></A>



<PRE>
038             }  // end try
039
040        }  // end if
041
042        try
043        {
044            readInput(is);
045        }
046        catch (IOException e)
047        {
048             System.out.println(e);
049
050        }  // end try
051
052
053     }  // end main
054
055
056     public static void readInput(InputStream is)
057         throws IOException
058     {
059         int ich;
060         int count;
061         int spaces = 0;
062         int digits = 0;
063         int lowers = 0;
064         int uppers = 0;
065
066         for (count = 0; (ich = is.read()) != _1; count++)
067         {
068             char ch = (char)ich;
069
070             if (Character.isSpace(ch))
071             {
072                 spaces++;
073             }
074             else if (Character.isDigit(ch))
075             {
076                 digits++;

</PRE>
<PRE>
                                                       continues
</PRE>


<A NAME="PAGENUM-416"><P>Page 416</P></A>



<P>Listing 11.1, Continued
</P>

<PRE>
077             }
078             else if (Character.isLowerCase(ch))
079             {
080                 lowers++;
081             }
082             else if (Character.isUpperCase(ch))
083             {
084                 uppers++;
085
086             } // end if
087
088
089         }  // end for
090
091         System.out.println(&quot;Total chars &quot;+count+
092             &quot;\n\tspaces = &quot;+spaces+
093             &quot;\n\tdigits = &quot;+digits+
094             &quot;\n\tlowers = &quot;+lowers+
095             &quot;\n\tuppers = &quot;+uppers);
096
097         double density;
098
099         density = ((double)spaces)/((double)count);
100         System.out.println(&quot;\n\twhite space ratio = &quot;+density);
101
102     }  // end readInput
103
104 } // end ReadInputStream

</PRE>

<P>If you want to read the contents of the input stream into a byte array, you can use
the following read method:
</P>

<PRE>
public int read(byte b[]) throws IOException;

</PRE>


<A NAME="PAGENUM-417"><P>Page 417</P></A>



<P>
<a href="images\ch11fg02.jpg"><img src="images\tn_ch11fg02.jpg"></a><BR>
Figure 11.2
<I>Output of ReadInput-Stream.</I>
</P>

<P>
Consider the following code fragment that illustrates the use of this
read() method:
</P>

<PRE>
InputStream is = new FileInputStream(&quot;testfile.dat&quot;);
byte[] buff = new byte[2048];

int bytesRead;
bytesRead = is.read();
if (bytesRead == _1)
{
      System.out.println(&quot;End of File&quot;);

}
else
{
      System.out.println(&quot;Bytes read = &quot;+bytesRead);
      if (bytesRead &lt; buff.length)
      {
         System.out.println(&quot;Buffer not full&quot;);
      }
      else
      {
         System.out.println(&quot;Buffer full&quot;);

      } // end if

} // end if
</PRE>


<A NAME="PAGENUM-418"><P>Page 418</P></A>



<P>You can also read a specified number of bytes from the input stream into a slice of
the byte array, starting from a specific location in the byte array:
</P>

<PRE>
public int read(byte b[], int off, int len)
               throws IOException;
</PRE>

<P>Here is an example of using the preceding read:
</P>
<PRE>
try
{
      // Read 500 bytes starting at offset 10
      is.read(buff, 10, 500);
}
catch (IOException e)
{
      System.out.println(e);
}
</PRE>

<P>If you would like to skip a certain number of bytes, you can use the
skip() method:
</P>
<PRE>
public long skip(long n) throws IOException;
</PRE>

<P>This method returns the number of actual bytes skipped.
Here is an example of skipping the next 300 bytes from the input stream:
</P>
<PRE>
try
{
      // Skip 300 bytes
      bytesSkipped = is.skip(300);
}
catch (IOException e)
{
      System.out.println(e);
}

if (bytesSkipped != 300)
{
      System.out.println(&quot;Skipped fewer bytes&quot;);

} // end if
</PRE>


<A NAME="PAGENUM-419"><P>Page 419</P></A>



<P>To find out how many bytes are available on the input stream, you can use the
following method:
</P>

<PRE>
public int available() throws IOException;
</PRE>

<P>This method returns the number of bytes that can be read from the input stream
without blocking. Here is an example:
</P>

<PRE>
if (is.available() &lt; 100)
{
      System.out.println(&quot;Nearing the end of the stream&quot;);

} // end if
</PRE>

<P>Streams that model network connections or other abstract streams may not always
return the correct number of bytes until the end of the stream. On a network connection,
for example, the number of bytes waiting to be read may return zero, even though there
is more data to be read. If you want a better answer, you will have to subclass the
stream and define your own overriding available() method.
</P>

<P>You can also mark a stream and then later reset the stream to the marked position
by using the following methods:
</P>

<PRE>
public synchronized void mark(int readlimit);
public synchronized void reset()
     throws IOException;
</PRE>

<P>The readlimit parameter to the mark() method specifies the number of bytes that
you intend to allow to be read/skipped before you intend to reset to the marked
position. This limit is used so that the stream can remember the bytes that may be skipped. If
you read beyond this number and then attempt to reset to the marked position, the mark is
no longer valid, and an exception will be thrown. The mark/reset is useful if you need to
do an analysis of the data on the input stream up to a particular number of bytes to
determine what type of data is being read, and then invoke a suitable parser to handle
the data.
</P>

<P>Before attempting to use mark() and reset(), you must use the
markSupported() method to determine if the mark/reset option is supported for the input stream; otherwise,
an exception will be thrown.
</P>

<PRE>
public boolean markSupported();
</PRE>

<P>Here is an example of some sample code that uses the
mark(), reset(), and markSupported() methods:
</P>


<P><CENTER>
<a href="0409-0413.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0420-0425.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

