<HTML>
<HEAD>


<TITLE>Inside Java:Implementing Java Exception Handling:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0392-0395.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0401-0408.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-396"><P>Page 396</P></A>



<P>method, exception is thrown to the statement that called this method.
</P>

<P>It is important to list the catch statements in the order in which you want them to
be tried. Consider the following example:
</P>
<PRE>
try
{
      anExceptionalMethod();

}
catch (IndexOutOfBounds ie)
{
      // exception code goes here
}
catch (IllegalArgumentException ae)
{
      // exception code goes here
}
catch(RuntimeException re)
{
      // exception code goes here
}
catch (IOException ioe)
{
      // exception code goes here
}
catch(MyNewException me)
{
      // exception code goes here
}
catch(Exception ex)
{
      // exception code goes here
}
catch(Throwable te)
{
      // exception code goes here

}   // end try
</PRE>

<P>In this code, the first two catch clauses,
IndexOutOfBounds and IllegalArgument-     Ex
</P>

<A NAME="PAGENUM-397"><P>Page 397</P></A>



<P>ception, are subclasses of the RuntimeException class. If the thrown exception is
a runtime exception and it does not match the first two exceptions, it will match the
third catch clause, as this is the
RuntimeException class. If there is no match with
the RuntimeException class, then a check will be made to see if the exception type
is IOException and MyNewException. If there is still no match, the
Exception and Throwable class will be matched. A match should definitely occur here because
all exceptions are subclasses of at least either the
Exception or Throwable class. What if the previous catch statement was rewritten as the following:
</P>

<PRE>
try
{
      anExceptionalMethod();
}
catch(Throwable te)
{
      // exception code goes here
}
catch(Exception ex)
{
      // exception code goes here

}
catch (IndexOutOfBounds ie)
{
      // exception code goes here
}
catch (IllegalArgumentException ae)
{
      // exception code goes here
}
catch(RuntimeException re)
{
      // exception code goes here
}
catch (IOException ioe)
{
      // exception code goes here
}
catch(MyNewException me)
{
      // exception code goes here

}   // end try
</PRE>


<A NAME="PAGENUM-398"><P>Page 398</P></A>



<P>Do you see a problem with this try statement? Because the first catch statement will
try to match with the Throwable class, a match will always take place. Therefore, none of
the other catch statements will be executed.
</P>
<P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
In the catch clauses of the try statement, always list the subclass exceptions before
their superclass exceptions.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<H4><A NAME="ch10_ 9">
Code-Walk of an Exceptions Example
</A></H4>

<P>
<B>On the
CD</B><BR>
Listing 10.1 (file ThrowExceptions.java on the CD-ROM)
shows an example of a program that illustrates the features of Java exceptions. This program prints the square root of
an integer value between 0 and 1000, as long as the number is not an odd number, and it is
a perfect square. A perfect square is a number that is the square of another
number. Examples are 64 (square of 8), 100 (square of 10), 144 (square of 12), and so on.
</P>

<P>Lines 10_28 define an IntException class subclassed from the Exception class. This
class defines two constructors for building this class: one with an argument and one without.
</P>

<P>Lines 31_60 define an IntSubException class subclassed from the IntException
class. This class defines two constructors for building this class: one with an argument
and one without. Additionally, the exception message is stored in a protected class
instance variable.
</P>

<P>Lines 63_81 define an IntLargeException class subclassed from the Exception class.
This class defines two constructors for building this class: one with an argument and
one without.
</P>

<P>Figure 10.2 shows the class hierarchy diagram for the new exception classes.
</P>

<P>Lines 84_205 define the ThrowExceptions class, which uses the three exception
classes. The try statement (lines 92_111) calls
Integer.parseInt() on the argument to main(). If
no argument is passed, the reference to args[0] will result in the
Array-     IndexOutOfBoundsException exception. The
catch clause on line 96 checks if this exception is raised. If it is, the statements in the catch clause (lines 99_101) are
executed. These statements print out an error message and a message on how to invoke
the program correctly.
</P>

<P>If an attempt is made to pass a non-integer value, the exception
NumberFormat-     Exception will be thrown when
Integer.parseInt() is called on line 94. This exception will
be caught by the catch clause on line 104. If the
NumberFormatException is thrown, the statements in the corresponding catch clause (lines 106_109) are executed.
These statements print out an error message and a message on how to invoke the
program
</P>



<A NAME="PAGENUM-399"><P>Page 399</P></A>




<P>
<a href="images\ch10fg02.jpg"><img src="images\tn_ch10fg02.jpg"></a><BR>
<B>Figure 10.2</B>
<I>Class hierarchy diagram for exception classes in listing 10.1.</I>
</P>

<P>correctly.
</P>

<P>If an exception is thrown by calling
Integer.parseInt(), the return statements on lines 101
and 109 will result in the termination of the
main() method. If no exception is thrown, the
takeSqrt() method on line 114 is executed.
</P>

<P>In the takeSqrt() method (lines 120_160), the argument is first checked by calling
chkIntVal() in a try statement (lines 124_154). On examining the
throws clause for the chkIntVal() method (lines 164 and 165), you will notice that the checked exceptions
IntException, IntLargeException, and
IntSubException can be thrown. Consequently, you must
make arrangements to catch these exceptions. If you do not have
catch clauses to catch these exceptions, you must declare these exceptions in
the throws clause of the takeSqrt() method. The catch clause on line 128 catches
the IntException. This catch clause will catch both the
IntException and its subclass, the IntSubException. The if-statement on line 130 uses the
instanceof operator to distinguish between the two exception types. Alternatively, you could have separate catch
clauses for both these subclasses as shown, next:
</P>

<PRE>
try
{
      chkIntVal(ival);
}
catch (IntSubException)
{
</PRE>


<A NAME="PAGENUM-400"><P>Page 400</P></A>




<PRE>
      // Code
}
catch (IntException)
{
      // Code
}
</PRE>

<P>Using a superclass exception to catch all the subclass exceptions is useful if much of
the exception handling code is the same. You can use the
instanceof operator to distinguish between the subclasses.
</P>

<P>Lines 132 and 136 print out a message on the exception that was thrown. Lines
140_143 are common to both the IntException and IntSubException exception. These lines
print out the exception message by using
toString() and println(). Line 142 prints out the
exception stack.
</P>

<P>If the IntLargeException is thrown, it is caught on line 146. The message for the
exception is printed out (line 148). The output of
toString() and println() is also printed out
(lines 149 and 150). Line 151 prints out the exception stack for the thrown exception.
</P>

<P>Line 156 prints the result of taking the square root of the integer.
</P>

<P>Line 163_203 defines the chkIntVal(), which checks the integer value passed to it
and throws an exception if it is not the expected value. Lines 164 and 165 shows the
throws clause that enumerates the exceptions that can be thrown. Lines 168_170 define a
local array of integers that are used to test if the value is a perfect square.
</P>

<P>The if-statement on lines 172_181 throws an IntException exception (line 174) if the
value is negative, and a IntLargeException exception (line 179) if the value is greater than 1000.
</P>

<P>The if-statement on lines 184_188 throws an
IntSubException exception if the integer value is odd.
</P>

<P>The for-statement on lines 191_199 checks if the integer value is a perfect square.<BR>
If not, the IntSubException is thrown on line 201.
</P>

<P>Figures 10.3 and 10.4 show the output of the ThrowExceptions program under
various input values.
</P>

<P><CENTER>
<a href="0392-0395.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0401-0408.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

