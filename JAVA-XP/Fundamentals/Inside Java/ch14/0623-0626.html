<HTML>
<HEAD>


<TITLE>Inside Java:The New, Improved AWT: Menus, Events, and More New Features:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0617-0622.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0627-0632.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-623"><P>Page 623</P></A>



<P>When the associated events are fired, they are sent to the
processEvent() method, which is not overridden in this example. The default behavior of
processEvent() sends these events to the proper
process&lt;ListenerType&gt;Event() handler methods. In this case, these
handler methods are:
</P>

<UL>
<LI>          processItemEvent()
<LI>          processActionEvent()
<LI>          processMouseEvent()
</UL>

<P>When the mouse cursor enters either one of the ExchangeList list boxes shown in
figure 14.8, a MouseEvent is fired and passed to
processEvent(), which in turn passes it to
processMouseEvent() in line 87.
</P>
<PRE>
087       protected void processMouseEvent(MouseEvent e) {
</PRE>

<P>To determine which type of mouse event the MouseEvent represents, lines 88 and 94
call the inherited getId() method of the MouseEvent instance.
</P>
<PRE>
088           if (e.getId() == MouseEvent.MOUSE_ENTERED) {
094           else if (e.getId() == MouseEvent.MOUSE_EXITED) {
</PRE>

<P>Line 102 calls the processMouseEvent() method of the superclass. This is very
important because these event handler methods play a critical role in AWT event
processing. Whenever you override processEvent() or
process&lt;ListenerType&gt;Event(), always call that
method in the superclass.
</P>
<PRE>
102           super.processMouseEvent(e);
</PRE>
<H4><A NAME="ch14_ 16">
Deciding Which Event Model to Use
</A></H4>

<P>When deciding whether to use event listeners (in the Delegation Event Model)
versus
</P>

<P>
<a href="images\ch14fg08.jpg"><img src="images\tn_ch14fg08.jpg"></a><BR>
Figure 14.8 <I>WishList applet display.</I>
</P>

<A NAME="PAGENUM-624"><P>Page 624</P></A>



<P>overriding event processing methods (in the Extended Component Event
Model), consider the following points:
</P>

<UL>
<LI>          Using event listeners is preferred because it is more scaleable, less prone
to mistakes, and is conducive to separation of GUI and application logic.
<LI>          Extending a component should be reserved for cases where you actually
extend the component's look or behavior. Making use of the event processing
methods shouldn't be the only reason to extend a particular component.
<LI>          Using event listeners and overriden event processing methods in the
same program is acceptable, even in the same component. If you use both in the
same component, the events passed to
processEvent() are those for which an event
listener is registered, plus the ones that were enabled in the call to
enableEvents().
</UL>

<P>If you are familiar with the JDK 1.0 event model, you might have noticed that
the Extended Component Event Model in JDK 1.1 is similar to it&#151;both have event
handling methods that can be overridden. The 1.1 Extended Component Event Model, however,
is different in several respects:
</P>

<UL>
<LI>          Combined with the enableEvents() method, this model enables you to choose
the events delivered to the event handling methods. The default is that no events
are delivered, which improves performance.
<LI>          The 1.1 version has a richer and better organized set of event processing methods.
<LI>          The most recent model uses the new 1.1 event class hierarchy.
<LI>          Events in the JDK 1.1 beta 1 release are not automatically propagated up
the containment hierarchy, as they are in JDK 1.0.
</UL>
<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
TIP
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Using the 1.0 and 1.1 event models in the same program is not recommended,
because unpredictable results could occur. New Java programs written for 1.1 should
take advantage of the new model.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>Now that you have seen the new JDK 1.1 event models, this chapter will cover four
more new AWT features.
</P>
<H3><A NAME="ch14_ 17">
Moving On to More New JDK 1.1
</A></H3>

<P>This section explores some additional JDK 1.1 features related to the AWT;
focus traversal, accessing desktop colors, and how to use the clipboard and print from a
java
</P>

<A NAME="PAGENUM-625"><P>Page 625</P></A>



<P>program are all discussed here. The first feature presented, focus traversal, enables
the user to tab between fields. This feature was sorely missed by application
developers using JDK 1.0.

<H4><A NAME="ch14_ 18">
Enabling the User to Tab Between Fields <BR>
(Focus Traversal)
</A></H4>

<P>Users of most windowing systems expect to be able to use the Tab and Shift+Tab
keys to move focus from component to component in a window (frame or dialog). With
data entry and other applications, it is very handy to be able to use the Tab key to move
from field to field. As in the case of shortcut keys, this reduces the need for the use of
a mouse for people who either prefer not to or can't use a mouse. Java has begun
implementing this feature in JDK 1.1.
</P>

<P>Under most circumstances, you need not be concerned with the details of
implementing this feature, because it works by default. AWT components, such as buttons and
text boxes, that can accept focus automatically do so. Components, such as labels,
that shouldn't accept are automatically skipped when tabbing. You must, however,
be concerned with the tab order, or the order in which focus is received. In JDK 1.1, the
tab order is the same order as the components contained in the containers. This is
usually the same order in which the components were added to the containers.
</P>

<P><B>A Simple Example of Focus Traversal</B>
</P>

<P>Consider the case of a dialog box that has a text field (for entering the user's first
name) and two buttons (OK and Cancel.) The dialog box could be coded as follows:
</P>
<PRE>
Dialog nameDialog = new Dialog(this, &quot;Enter First Name&quot;, true);
Panel buttonPanel = new Panel();
Panel entryPanel = new Panel();
buttonPanel.add(new Button(&quot;OK&quot;));
buttonPanel.add(new Button(&quot;Cancel&quot;));
entryPanel.add(new Label(&quot;First Name:&quot;));
entryPanel.add(new TextField(null, 10));
nameDialog.add(&quot;Center&quot;, entryPanel);
nameDialog.add(&quot;South&quot;, buttonPanel);
nameDialog.setSize(300, 150);
nameDialog.setVisible(true);
</PRE>
<P>When the focus is on the text field and Tab is pressed, the focus moves to the
OK button, followed by the Cancel button, and back to the text field. This is because
the components in the dialog box are entryPanel and
buttonPanel, in that order. Within entryPanel, the component order is label and text field, but a label doesn't accept focus.
Within
</P>

<A NAME="PAGENUM-626"><P>Page 626</P></A>


<P>buttonPanel, the component order is OK button and Cancel button.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Javasoft has stated that in a future version of the JDK, a better scheme will improve
the process of setting the tab order. Until then, however, the current process
remains workable.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P><B>How Java Implements Focus Traversal</B>
</P>

<P>The way that Java implements focus traversal is actually very simple. A
private FocusManager object registered on the Window handles the focus traversal based
upon both the order of components (as described above) and whether a component will
accept keyboard focus when tabbing. The FocusManager determines this by making a call
to the component's isFocusTraversable() method. If it returns true, the component
receives focus, but if it returns false, the component won't receive focus.
</P>

<P><B>Considerations for Custom Components (Java <BR>Beans)</B>
</P>

<P>When designing a custom component, keep the following points in mind,
regarding focus traversal and keyboard focus.
</P>

<UL>
<LI>          For the user to be able to tab to your custom component, the
component's isFocusTraversable() must return true. If, for example, the custom component is
derived from the Canvas class, the
isFocusTraversable() must be overriden, because the
Canvas class returns false by default.
<LI>          If you want your custom component to accept keyboard focus when the
user clicks on it, you must catch the mouse-down event and call
requestFocus().
<LI>          You should provide some sort of visual feedback to the user that your
component has received focus. Some components use a bounding box to indicate that
they have keyboard focus. Text entry-oriented components indicate this with
the presence of the carat.
</UL>

<P>Chapter 15, &quot;Java Beans: Java's Component Architecture,&quot; examines these
custom components in more detail. Many JDK 1.1 features were added, at least in part,
to support Java Beans (the Java component architecture). The next feature, Desktop
Colors, is no exception.
</P>
<H4><A NAME="ch14_ 19">
Accessing Desktop Colors
</A></H4>

<P>Sometimes, it is useful to know the details of the desktop color scheme, especially
when
</P>

<P><CENTER>
<a href="0617-0622.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0627-0632.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

