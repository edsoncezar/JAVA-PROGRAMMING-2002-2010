<HTML>
<HEAD>


<TITLE>Inside Java:Java Beans: Java's Component Architecture:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0645-0648.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0654-0658.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-649"><P>Page 649</P></A>


<PRE>
17       protected String coordString = &quot;0,0&quot;;
18
19       public Scope() {
20           // Enable mouse and mouse motion events to be processed
21           enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK |
22                        AWTEvent.MOUSE_EVENT_MASK);
23           setSize(200, 200);
24       }
25
26       // The presence of both a setTick and getTick cause the
27       // Introspector to assume there is a &quot;tick&quot; property
28       public void setTicks(int ticks) {
29           this.ticks = ticks;
30       }
31
32       public int getTicks() {
33           return ticks;
34       }
35
36       public void paint(Graphics g) {
37           int tickSize = 5;
38           int xMax = getSize().width _1;
39           int yMax = getSize().height _1;
40           int xRes = xMax/ticks;
41           int yRes = yMax/ticks;
42
43           // Draw the crosshairs
44           g.setColor(Color.red);
45           g.drawRect(0, 0, xMax, yMax);
46           g.drawLine(xCoord, 0, xCoord, yMax);
47           g.drawLine(0, yCoord, xMax, yCoord);
48
49           // Build and draw the coordinate string
50           coordString = new Integer(xCoord) + &quot;,&quot; +
51                          new Integer(yCoord);
52           g.drawString(coordString, tickSize, yMax _ tickSize);
53
54           // Draw the tick marks
55           for (int i=0,x=0; i&lt;ticks; i++,x+=xRes) {
</PRE>
<PRE>
                                                       <I>continues</I>
</PRE>

<A NAME="PAGENUM-650"><P>Page 650</P></A>


<P>
Listing 15.1, Continued
</P>

<PRE>
56               g.drawLine(x, 0, x, tickSize);
57               g.drawLine(x, yMax _ tickSize, x, yMax);
58           }
59           for (int i=0,y=0; i&lt;ticks; i++,y+=yRes) {
60               g.drawLine(0, y, tickSize, y);
61               g.drawLine(xMax _ tickSize, y, xMax, y);
62           }
63       }
64
65       // When the mouse moves, update the display
66       protected boolean processMouseMotionEvent(MouseEvent e) {
67           if (e.getId() == MouseEvent.MOUSE_MOVED) {
68               xCoord = e.getX();
69               yCoord = e.getY();
70               repaint();
71           }
72           super.processMouseMotionEvent(e);
73           return false;
74       }
75
76       // When the mouse exits the Scope bean area,
77       // set coordinates to 0,0
78       protected Boolean processMouseEvent(MouseEvent e) {
79           if (e.getId() == MouseEvent.MOUSE_EXITED) {
80               xCoord = 0;
81               yCoord = 0;
82               repaint();
83           }
84           super.processMouseEvent(e);
85           return false;
86       }
87   }
</PRE>

<P>As mentioned earlier in the &quot;Java Beans Defined&quot; section, a Bean must be
persistent, which means that it must know how to store itself to a stream and then restore itself
from a stream. For this reason, the Scope Bean implements the Serializable interface in line
12 of listing 15.1.
</P>

<A NAME="PAGENUM-651"><P>Page 651</P></A>


<PRE>
12   public class Scope extends Canvas implements Serializable
</PRE>

<P>Also in line 12, you'll notice that this class extends Canvas. You choose the class
that you want the Bean to extend, based upon the functionality that you want to use.
This particular Bean draws a lot, so Canvas is a good choice for the superclass.
</P>

<P>Lines 14_17 declare four different fields of this class, but only one represents a
property of the Scope Bean. (This will be explained in a moment.)
</P>

<PRE>
14       protected int xCoord = 0,
15                     yCoord = 0,
16                     ticks = 8;
17       protected String coordString = &quot;0,0&quot;;
</PRE>

<P>In the constructor, the enableEvents() method in lines 21 and 22 should look
familiar, because it was covered in a previous chapter. In this case, we want all mouse events
to be sent to processEvent() so that they can be handled by the event processing methods
of this subclass.
</P>

<PRE>
21           enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK |
22                        AWTEvent.MOUSE_EVENT_MASK);
</PRE>

<P>
Lines 28_34 define two methods of this Bean. Because a
setTicks() method exists for a corresponding
getTicks() method, this Bean defines a read/write property named &quot;ticks.&quot;
In general, whenever a public
set&lt;PropertyName&gt;() method co-exists with a
corresponding public get&lt;PropertyName&gt;() method, a read/write &quot;propertyName&quot; property is defined. In
this Bean, the &quot;ticks&quot; field is used to store the value of the &quot;ticks&quot; property, but the
field could have been named anything.
</P>

<PRE>
28       public void setTicks(int ticks) {
29           this.ticks = ticks;
30       }
31
32       public int getTicks() {
33           return ticks;
34       }
</PRE>

<P>The define properties discussed in the preceding paragraph are useful in builder
tools. When a builder tool loads a Bean, it undergoes some of the following steps:
</P>

<OL>
<LI>          When a Bean is loaded into a builder tool it goes through a process known
as <I>introspection,</I> which analyzes the Bean.
</OL>


<A NAME="PAGENUM-652"><P>Page 652</P></A>


<OL START="2">	
<LI>          During part of the introspection process, the properties of the Bean are
analyzed. In this case, the introspection would see the matching
setTicks() and getTicks() methods, and then define a property named &quot;ticks.&quot; This
set&lt;PropertyName&gt;()<I>
</I>get&lt;PropertyName&gt;() rule is called a <I>design
pattern</I>, which is one of many design patterns used in the introspection process to analyze a Bean.
<LI>          The introspection process defines the &quot;ticks&quot; property as an integer
because getTicks() returns an integer and
setTicks() takes an integer argument.
<LI>          Because of the introspection process, when the builder tool displays a
property sheet for editing the properties of the Scope Bean, the property sheet contains
an input field for the &quot;ticks&quot; property. Figure 15.1 shows the Scope Bean
property sheet generated by the BDK beanbox.
</OL>

<P>
<a href="images\ch15fg01.jpg"><img src="images\tn_ch15fg01.jpg"></a><BR>
Figure 15.1 <I>The Scope Bean and PropertySheet in the BDK BeanBox.</I>
</P>

<P>Lines 36_63 initiate the overridden paint() method, which draws the visual aspects of
the Bean.
</P>

<P>Lines 38_41 calculate how far apart the tick marks should be on each axis, based
upon the dimensions of the Bean and the value of the ticks property. Because this Bean can
be resized, the calculation is performed whenever the
paint() method is invoked.
</P>
<A NAME="PAGENUM-653"><P>Page 653</P></A>


<PRE>
38           int xMax = getSize().width _1;
39           int yMax = getSize().height _1;
40           int xRes = xMax/ticks;
41           int yRes = yMax/ticks;
</PRE>

<P>Lines 44_47 draw a rectangle around the Bean and the crosshairs that track with
the mouse cursor. The xCoord and yCoord variables are changed by the mouse
event handling methods further down in the program.
</P>
<PRE>
44           g.setColor(Color.red);
45           g.drawRect(0, 0, xMax, yMax);
46           g.drawLine(xCoord, 0, xCoord, yMax);
47           g.drawLine(0, yCoord, xMax, yCoord);
</PRE>

<P>Lines 50_52 construct and draw a string that contains the current coordinates of
the mouse cursor, separated by a comma.
</P>
<PRE>
50           coordString = new Integer(xCoord) + &quot;,&quot; +
51                          new Integer(yCoord);
52           g.drawString(coordString, tickSize, yMax _ tickSize);
</PRE>

<P>Lines 55_62 draw the graduated tick marks in both dimensions, based upon the
previous calculations.
</P>

<PRE>
55           for (int i=0,x=0; i&lt;ticks; i++,x+=xRes) {
56               g.drawLine(x, 0, x, tickSize);
57               g.drawLine(x, yMax_tickSize, x, yMax);
58           }
59           for (int i=0,y=0; i&lt;ticks; i++,y+=yRes) {
60               g.drawLine(0, y, tickSize, y);
61               g.drawLine(xMax _ tickSize, y, xMax, y);
62           }
</PRE>

<P>Lines 66_74 contain the overridden mouse motion handling method. The only
mouse motion of interest to this Bean is the
MOUSE_MOVED event type. When the mouse moves over the Bean's display area, the x and y coordinates are retrieved from
the MouseEvent instance, and the Bean's display is repainted.
</P>
<PRE>
66       protected boolean processMouseMotionEvent(MouseEvent e) {
67           if (e.getId() == MouseEvent.MOUSE_MOVED) {
68               xCoord = e.getX();
69               yCoord = e.getY();
70               repaint();
</PRE>

<P><CENTER>
<a href="0645-0648.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0654-0658.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

