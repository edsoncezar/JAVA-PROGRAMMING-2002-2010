<HTML>
<HEAD>


<TITLE>Inside Java:Java Beans: Java's Component Architecture:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0694-0699.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0705-0709.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-700"><P>Page 700</P></A>


<P>Figure 15.6 depicts the ScopeFrame2 user interface.
</P>


<P>
<a href="images\ch15fg07.jpg"><img src="images\tn_ch15fg07.jpg"></a><BR>
Figure 15.7 <I>The Scope2, Coords, and Bar Beans in the BDK BeanBox.</I>
</P>


<P>
Figure 15.7 shows the Scope2, Coords, and Bar Beans in the BDK BeanBox.
</P>

<P><B>
Implementing Constrained Properties
</B></P>

<P>A constrained property requires the blessing of its listeners before its value may
be changed. This is very similar to the concept of bound properties in that a
property change event is sent out to the listeners when a constrained property changes.
The difference is that if any registered listener vetoes the change by throwing a
Property     VetoException, the change doesn't occur. To restrict the days that can be selected in
the Calendar2 Bean to valid working days, for example, a listener could be created that
vetos any changes that don't meet that criteria.
</P>

<P>The VetoableChangeSupport class, which is similar to the PropertyChangeSupport
class, handles the details associated with maintaining a registry of vetoable change
listeners and notifying the listeners of a property change. This class also notifies each
listener that a change is being withdrawn because a listener vetoed the
change. VetoableChangeSupport, which is a class in the java.beans package, has three 
methods:
</P>

<UL>
<LI>          void addVetoableChangeListener(VetoableChangeListener)
<LI>          void removeVetoableChangeListener(VetoableChangeListener)
</UL>

<A NAME="PAGENUM-701"><P>Page 701</P></A>

<UL>
<LI>          void fireVetoableChange(String, Object, Object)
</UL>


<P>
<a href="images\ch15fg08.jpg"><img src="images\tn_ch15fg08.jpg"></a><BR>
Figure 15.8 <I>Constrained properties and supporting VetoableChange-
Support methods.</I>
</P>

<P>
Figure 15.8 depicts the process by which constrained properties work and
how VetoableChangeSupport methods support constrained properties.
</P>



<P>The addVetoableChangeListener() method adds a VetoableChangeListener to <BR>
the registry. The removeVetoableChangeListener() method removes a
Vetoable-     ChangeListener from the registry.
</P>

<P>The fireVetoableChange() method calls the
vetoableChange() method of each registered VetoableChangeListener, passing a PropertyChangeEvent instance. If
any VetoableChangeListener throws a PropertyVetoException, then the
fireVetoableChange() method calls the
vetoableChange() method of each registered VetoableChangeListener
again, this time with the original property. The
fireVetoableChange() method then throws a PropertyVetoException so that the caller can catch it or relay it up the calling
chain. Generally, you should allow the property accessor method to throw this exception
so that the caller trying to set the property obtains the exception. This way, the caller
can tell that the change was unsuccessful.
</P>

<P>As with PropertyChangeSupport, to use VetoableChangeSupport you can either derive
a class from it or create an instance of it.
</P>

<P>The next section covers another advanced Beans topic&#151;introspection.
</P>

<H4><A NAME="ch15_ 11">
Java Bean Introspection
</A></H4>

<A NAME="PAGENUM-702"><P>Page 702</P></A>

<P>
A builder tool requires some way of identifying and analyzing the properties, 
events, and methods that are contained in a Java Bean. The process that JavaSoft
has designed for this purpose is called <I>Bean
introspection</I>.
</P>

	
<P>The Introspector class, which is included in the java.beans package, provides a
common mechanism for builder tools and applications to analyze a Java Bean. A few other
classes in the java.beans package are used in conjunction with the Introspector class
when
</P>
<P>
<a href="images\ch15fg09.jpg"><img src="images\tn_ch15fg09.jpg"></a><BR>
Figure 15.9 <I>java.beans classes that support introspection.</I>
</P>



<P>
doing Bean introspection. These are shown in figure 15.9, and the following
discussion examines these classes. In addition, the introspection process uses a low-level
mechanism, called the Java Core Reflection API, to identify an object's fields and
methods. Figure 15.9 shows the java.beans classes that support introspection.
</P>


<P>
As mentioned earlier in this chapter, a developer can define the properties, events,
and methods to be exposed to the builder tool in two ways:
</P>

<UL>
<LI>          Implicitly, through the use of design patterns
<LI>          Explicitly, via the BeanInfo interface
</UL>

<P>Design patterns for properties, events, and methods were described previously in <BR>
the chapter. The BeanInfo interface is explained next.
</P>

<P><B>
The BeanInfo Interface
</B></P>

<P>
You can explicitly define which properties, events, and methods are exposed by
provid–
</P>

<A NAME="PAGENUM-703"><P>Page 703</P></A>

<P>
ing a class that implements the BeanInfo interface. The name of this class is the name
of the Bean with BeanInfo added to the end. Therefore, the BeanInfo class for the
Calendar2 Bean is named Calendar2BeanInfo. Typically, this BeanInfo class is placed in
the same package as the Bean, which is the first place that the Introspector looks.
</P>

<P>To perform the introspection process on a Bean, call the static
getBeanInfo() method of the Introspector class, and supply the name of the class to be analyzed. You also can
supply the name of the superclass at which to stop the analysis. The Introspector performs
the following high-level steps during the introspection process:
</P>

<OL>
<LI>          Looks for the associated BeanInfo class.
<LI>          If one is found, obtains the explicit property, event, method, and other
Bean information by calling methods of this class.
<LI>          For any methods that supplied explicit information,
uses that information and goes to step 5. For methods that
didn't supply explicit information, continues with
step 4.
<LI>          Uses design patterns to discover implicitly defined properties, events, and methods.
<LI>          Moves to the superclass of the class being analyzed.
<LI>          If the top of the class hierarchy has been reached, or if the top class specified in
the two-argument version of the getBeanInfo() method has been reached, then
stops. Otherwise, returns to step 1.
</OL>

<P>Table 15.1 describes the methods of the BeanInfo interface referred to in steps 2 and
3. Many return values of these methods are instances of the classes in figure 15.9.
</P>

<P>Table 15.1
</P>
<P>Methods in the BeanInfo Interface
</P>

<TABLE>

<TR><TD>
Method
</TD><TD>
Description
</TD></TR><TR><TD>
BeanDescriptor
getBeanDescriptor()
</TD><TD>
Returns a BeanDescriptor instance that contains
overall information about the Bean. Returns null if
no explicit information is available.
</TD></TR><TR><TD>
PropertyDescriptor[]
getPropertyDescriptors()
</TD><TD>
Returns an array of PropertyDescriptor instances
that contain information about the Bean's proper
ties. Returns null if no explicit information is
available.
</TD></TR></TABLE>

<PRE>
                                                       <I>continues</I>
</PRE>


<A NAME="PAGENUM-704"><P>Page 704</P></A>


<P>
Table 15.1, Continued
</P>

<P>
Methods in the BeanInfo Interface
</P>


<TABLE>

<TR><TD>
Method
</TD><TD>
Description
</TD></TR><TR><TD>
int getDefaultPropertyIndex()
</TD><TD>
Returns the index of the PropertyDescriptor array
returned by getPropertyDescriptors() that should
be treated as the default in a builder tool. Returns
_1 if there is no default.
</TD></TR><TR><TD>
EventSetDescriptor[]
getEventSetDescriptors()
</TD><TD>
Returns an array of EventSetDescriptor instances
that contain information about such elements as
the Bean's events and listener methods. Returns
null if no explicit information is available.
</TD></TR><TR><TD>
int getDefaultEventIndex()
</TD><TD>
Returns the index of the EventSetDescriptor array
returned by getEventSetDescriptors() that should
be treated as the default in a builder tool. Returns 
_1 if there is no default.
</TD></TR><TR><TD>
MethodDescriptor[]
getMethodDescriptors()
</TD><TD>
Returns an array of MethodDescriptor instances
that contain information about the Bean's meth-
ods. Returns null if no explicit information
is available.
</TD></TR><TR><TD>
Image getIcon(int)
</TD><TD>
Returns an image object that can be used to
represent the Bean in a builder tool. The argument
is a constant that represents the image resolution
and the presence of color. These constants are
ICON_COLOR_16x16, ICON_COLOR_32x32,
ICON_MONO_16x16, and ICON_MONO_32x32.
Returns null if no icons are available.
</TD></TR><TR><TD>
BeanInfo[]
get AdditionalBeanInfo()
</TD><TD>
Returns references to additional BeanInfo instances
that can supply explicit information about this
Bean.
</TD></TR></TABLE>

<P>So, to provide explicit information, you provide a class that implements the
BeanInfo interface. If you want to provide explicit information about the Bean's properties,
for example, you would implement the
getPropertyDescriptors() method that returns an array
of PropertyDescriptor instances. Because the class implements the BeanInfo interface,
you also must supply an implementation for all the other BeanInfo methods, returning
null when design patterns should be used.
</P>

<P>SimpleBeanInfo, a convenience class shown in figure 15.9, implements all the
BeanInfo methods. Unless overridden, these methods return null (or in some cases
</P>

<P><CENTER>
<a href="0694-0699.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0705-0709.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

