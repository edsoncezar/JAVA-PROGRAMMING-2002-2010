<HTML>
<HEAD>


<TITLE>Inside Java:Networking with Java:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0467-0472.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0479-0485.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-473"><P>Page 473</P></A>



<P>The following sections describe how a server and a client can be written in Java.
</P>

<H4><A NAME="ch12_ 7">
A Model for Writing a Server Application <BR>in Java
</A></H4>

<P>Figure 12.5 illustrates the model that can be used to write a server application.
</P>

<P>Java provides the class ServerSocket to model the process of listening on a port for a 
</P>



<P><a href="images\ch12fg05.jpg"><img src="images\tn_ch12fg05.jpg"></a><BR>
Figure 12.5 <I>Model for writing a server.</I>
</P>

<P>connection (see fig. 12.5).
</P>

<B>
The ServerSocket Class
</B>

<P>You create the ServerSocket by passing to its constructor the port number on which
the server should listen. When a connection request occurs, you can invoke
the getNetAddress() instance method to get the InetAddress of the connecting client. The
accept() instance method accepts the incoming connection and returns an instance of
class Socket to handle future communication with the client. The method declarations for
the ServerSocket are presented next.
</P>


<A NAME="PAGENUM-474"><P>Page 474</P></A>



<P>Previously, all network errors in Java raised a SocketException, which didn't
provide enough information to decipher what went wrong. JDK 1.1 adds three new classes
that provide a finer granularity of reported errors. The one that deals with server-side
errors will be introduced next. The other two deal with client-side errors and will be
introduced in the next section.
</P>

<P>The java.net.BindException is derived from SocketException. It is raised when the
local port is in use, or when the requested bind address cannot be assigned locally.
</P>

<PRE>
public class ServerSocket extends Object
{

   protected final void implAccept(Socket client) throws IOExcpetion;
   public ServerSocket(int port) throws IOException;

   public ServerSocket(int port, int backlogQueueSize)
   throws IOException;

   public static synchronized void  setSocketFactory (SocketImplFact fac)
   throws IOException, SocketException;

   public Socket accept() throws IOException;

   public void close() throws IOException;
   public InetAddress getInetAddress();

   public int getLocalPort();

   public String toString();

} // end ServerSocket
</PRE>
<P>
<B>The Socket Class
</B>
</P>
<P>The Socket class is used for interprocess communications over a network. By calling
the Socket class constructor method, you create a connection to the specified host and
port number that is passed to the constructor. You can also specify if the
communication through the socket should be a connection-oriented stream-based protocol such as
TCP, or a connectionless protocol, such as UDP (User Datagram Protocol). UDP is a
simpler form of transport protocol that does not guarantee the delivery that TCP does.
</P>

<P>After creating the socket, you can use the
getInputStream() and getOutputStream() instance methods to return an instance of the InputStream and OutputStream classes. With
these
</P>

<A NAME="PAGENUM-475"><P>Page 475</P></A>



<P>classes you can perform any of the input/output methods<BR>
discussed in Chapter 11, &quot;Performing Java Input/Output.&quot; You can use
getInet     Address() and getPort() to return the IP address and the port number to which you were connected.
The instance method getLocalPort() returns the local port number that you are using.
The method declarations for the Socket are presented next.
</P>

<P>JDK 1.1 introduces two new exceptions to help refine the type of error that has
occurred. Both exceptions are derived from SocketException.
</P>

<P>The first is java.net.ConnectException, as is raised when a connection is refused at
the remote host, implying that there is no process listening on that port. The
second exception is
java.net.NoRouteToHostException. This is raised when the connect
attempt timed out, or the remote host is otherwise unreachable.
</P>

<P>JDK 1.1 now provides a type safe way to set Socket options. Each socket class has
a get/set method for each option it supports, taking and returning the appropriate type.
</P>

<P>For the Socket and SocketServer classes these new methods are:
</P>

<UL>
<LI> TCP_NODELAY&#151; Disable Nagle's algorithm.

<LI> SO_LINGER&#151; Specify a linger-on-close timeout.

<LI> SO_TIMEOUT&#151;Specify a timeout on blocking socket operations. (Caution:
Never block forever!!!)
</UL>

<PRE>
public class Socket extends Object
{

   public Socket(String host, int port)
   throws UnknownHostException, IOException;

   public Socket(String host, int port, boolean stream)
   throws IOException;

   public Socket(InetAddress address, int port)
   throws IOException;

   public Socket(InetAddress address, int port, boolean stream)
   throws IOException;

   public static synchronized void  setSocketImplFactory (SocketImplFact fac)
   throws IOException, SocketException;
</PRE>

<A NAME="PAGENUM-476"><P>Page 476</P></A>



<PRE>
   public void close() throws IOException;

   public InetAddress getInetAddress();

   public InputStream getInputStream();

   public OutputStream getOutputStream();

   public int getPort();

   public int getLocalPort();

   public String toString();

} // end Socket
</PRE>

<H4><A NAME="ch12_ 8">
Writing a Server Application in Java
</A></H4>

<P>The first step in writing the server is to initialize the server environment. But before
you do this, you must define a class to represent the server program:
</P>

<PRE>
public class MyServer extends Thread
{

      // Constructor for MyServer
      public MyServer(int port)
      {
         // Code to initialize the server
         // environment.

      } // end MyServer

} // end MyServer
</PRE>

<P>The server would be started with the following statement:
</P>

<PRE>
MyServer ms = new MyServer(portNumber);
</PRE>

<P>The argument to the constructor is the port number on which the server is to wait
and listen for a connection. The following is an example of how the MyServer
constructors that initialize the server environment can be written:
</P>

<A NAME="PAGENUM-477"><P>Page 477</P></A>


<PRE>
public class MyServer extends Thread
{
      int   port;
      public final static int DEFAULT_SERVER_PORT = 4000;
      ServerSocket srvSock;

      // Constructor for MyServer
      public MyServer(int port)
      {
         // Code to initialize the server
         // environment.
         this.port = port;

         try
         {
            srvSock = new ServerSocket(port);
         }
         catch (BindException e) {
            System.out.println(e);
            System.exit(1);
         } catch (SocketException e) {
            System.out.println(e);
            System.exit(1);
         } // end try

         System.out.println(&quot;MyServer: Listening on port&quot;+
port);

         start();

      } // end MyServer

      // Default constructor method
      public MyServer()
      {
         this(DEFAULT_SERVER_PORT);

      } // end MyServer

} // end MyServer
</PRE>

<A NAME="PAGENUM-478"><P>Page 478</P></A>



<P>Within the MyServer constructor, the port number that is passed is recorded in the
class instance variable port. An instance of the ServerSocket is created, and this is set to
the class instance variable srvSock. The code in the constructor handles exceptions
and prints messages. A default constructor is provided that creates a server socket with
a default port number (4000).
</P>

<P>At the end of the constructor a call is made to the
start() method. Because MyServer is a subclass of Thread, the call to
start() will result in a call to the run() method.
</P>

<P>The run() method must be implemented in MyServer to implement the main thread
logic. Here is an example of the run() method:
</P>

<PRE>
 public void run()
    {
        Socket clientSock;

        for(;;)
        {
            try
            {
                clientSock = srvSock.accept();
            }
            catch (UnknownHostException e) {
               System.out.println(e);
               System.exit(1);
            } catch (ConnectException e) {
               System.out.println(e);
               System.exit(1);
            } catch (NoRouteToHostException e) {
               System.out.println(e);
               System.exit(1);
            } catch IOException e) {
               System.out.println(e);
               System.exit(1);
            } // end try

            // Now process the connection request.
            ServerLogic srvLogic = new ServerLogic(clientSock);

        }  // end for

    }  // end run
</PRE>

<P><CENTER>
<a href="0467-0472.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0479-0485.html">Next</A>
</CENTER></P>







</BODY>
</HTML>

