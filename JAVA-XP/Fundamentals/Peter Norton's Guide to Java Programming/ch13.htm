<HTML>

<HEAD>
   <TITLE>Chapter 13 -- The Net and Debug Class Libraries</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336997&ad_type=POPUP&category=net&id=e1e6d7256fb3e9102b5ef9f135c4b52f";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 13</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>The Net and Debug Class Libraries</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#IntroductiontotheNetClassLibrary" >Introduction to the Net Class Library</A>
<UL>
<LI><A HREF="#TheContentHandlerClass" >The ContentHandler Class  </A>
<LI><A HREF="#TheDatagramPacketClass" >The DatagramPacket Class</A>
<LI><A HREF="#TheDatagramSocketClass" >The DatagramSocket Class</A>
<LI><A HREF="#TheInetAddressClass" >The InetAddress Class</A>
<LI><A HREF="#JavaSocketHandlers" >Java Socket Handlers</A>
<LI><A HREF="#JavaURLRelatedClasses" >Java URL-Related Classes</A>
<LI><A HREF="#TheURLClass" >The URL Class</A>
</UL>
<LI><A HREF="#IntroducingthesuntoolsdebugLibrary" >Introducing the sun.tools.debug Library</A>
<UL>
<LI><A HREF="#TheDebuggerCallbackInterface" >The DebuggerCallback Interface</A>
<LI><A HREF="#MethodsthatDealwithRemoteObjects" >Methods that Deal with Remote Objects</A>
<LI><A HREF="#TheRemoteStackFrameClass" >The RemoteStackFrame Class</A>
<LI><A HREF="#TheRemoteStackVariableClass" >The RemoteStackVariable Class</A>
<LI><A HREF="#TheRemoteDebuggerClass" >The RemoteDebugger Class</A>
<LI><A HREF="#TheStackFrameClass" >The StackFrame Class</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
A discussion of the API for the Internet's premier programming
language would not be complete without a look at the class library
that makes networking possible-<TT><FONT FACE="Courier">java.net</FONT></TT>.
Although <TT><FONT FACE="Courier">java.net</FONT></TT> is the
final class library in the original Java API, new class libraries
that extend the functionality of the Java programming language
are continually being introduced. One such class library is the
<TT><FONT FACE="Courier">sun.tools.debug</FONT></TT> library,
which was added to give Java built-in debugging support. Whenever
you use the Java debugger, you are accessing this library.
<H2><A NAME="IntroductiontotheNetClassLibrary"><B><FONT SIZE=5 COLOR=#Ff0000>Introduction
to the Net Class Library</FONT></B></A></H2>
<P>
The Net class library, <TT><FONT FACE="Courier">java.net</FONT></TT>,
provides a high-level interface for connections over the Internet
or any other kind of TCP/IP network. Using these interfaces makes
it possible for a Java application to connect to existing network
services, provide its own network services, and even allow for
multiuser, network-aware games over the Internet. Whereas these
can be quite complicated to program in other languages, the <TT><FONT FACE="Courier">java.net</FONT></TT>
package allows the basics of socket connection to be set up in
as little as 10 lines of code. That's power!
<P>
The following sections describe the classes in the <TT><FONT FACE="Courier">java.net</FONT></TT>
package.
<H3><A NAME="TheContentHandlerClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">ContentHandler</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
<TT><FONT FACE="Courier">ContentHandler</FONT></TT> is used to
read a stream of data that is generated by a network connection
and produce an object. The exact content handler called depends
on the MIME type of the remote data.
<P>
<TT><FONT FACE="Courier">ContentHandler</FONT></TT> should not
be called directly. This task is much better performed by <TT><FONT FACE="Courier">URL.getContent()</FONT></TT>
or <TT><FONT FACE="Courier">URLConnection</FONT><I><FONT SIZE=1 FACE="Courier">.</FONT></I><FONT FACE="Courier">getContent()</FONT></TT>,
which simplify the process of reading a stream of data.
<H3><A NAME="TheDatagramPacketClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">DatagramPacket</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
<TT><FONT FACE="Courier">DatagramPacket</FONT></TT> is used to
both send and receive datagram packets. A <I>datagram packet</I>
is a segment of data containing packet data, packet length, Internet
address, and port. This allows programming at the IP packet level.
<P>
<TT><FONT FACE="Courier">DatagramPacket</FONT></TT> methods are
used to determine the address, length, and port of the datagram
packet, as well as retrieve the data itself. See the online documentation
for details.
<H3><A NAME="TheDatagramSocketClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">DatagramSocket</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
<TT><FONT FACE="Courier">DatagramSocket</FONT></TT> is used for
creating UDP-based connections over a network. Services such as
Sun's <I>Network File System</I> (NFS) use UDP as the underlying
protocol. Java applications can also create and/or use UDP-based
network connections by making use of this class. Only the advanced
programmer will use this class. See the online documentation for
details.
<H3><A NAME="TheInetAddressClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">InetAddress</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
<TT><FONT FACE="Courier">InetAddress</FONT></TT> makes an object
of Internet addresses. This makes them able to be manipulated
as <TT><FONT FACE="Courier">String</FONT></TT> objects or within
other network classes.
<P>
Listing 13.1 is an example of using the <TT><FONT FACE="Courier">InetAddress</FONT></TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. An example of class </B><TT><B><FONT FACE="Courier">InetAddress</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main example simply accepts
a hostname as an argument and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prints out the following information.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hostname
and IP address of system application is running on.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP address
of hostname<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Additional
IP addresses associated with hostname&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(try www.microsoft.com)
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;hostname&gt;
<BR>
*/<BR>
<BR>
import java.net.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InetAddress inetAddr, inetAddrs[];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inetAddr
= InetAddress.getLocalHost();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Local
System:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;&nbsp;&nbsp;
&quot; + inetAddr);<BR>
// print out hostname and IP address of local host<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inetAddr
= InetAddress.getByName(args[0]);<BR>
// create an InetAddress object from a given hostname<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(inetAddr.getHostName()
+ &quot;:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;&nbsp;&nbsp;
&quot; + inetAddr);<BR>
// print out hostname and IP address in inetAddr<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Additional
addresses:&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inetAddrs
= InetAddress.getAllByName(args[0]);<BR>
// get all addresses associated with a give hostname<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;
i &lt; inetAddrs.length; i++) {<BR>
// loop through printing out all addresses<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;&nbsp;&nbsp;
&quot; + inetAddrs[i]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (UnknownHostException
e) {<BR>
// handle unknown host exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
Hostname cannot be resolved&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;
hostname = &quot; + args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="JavaSocketHandlers"><B>Java Socket Handlers</B></A>
</H3>
<P>
Java has classes within its <TT><FONT FACE="Courier">java.net</FONT></TT>
package to govern the use of sockets. <I>Sockets</I> are a network-specific
utility. Those of you who are familiar with UNIX network programming
are probably well versed in sockets.
<P>
Sockets are network processes that connect two hosts and create
a two-way &quot;pathway&quot; to carry data between the server
and the client. Sockets communicate on a specific port (but which
port is up to the programmer). The application notifies the operating
system that it is listening for activity on a certain port. The
application then goes into a waiting state until it is requested
to wake up due to activity on the port. It is not necessary for
it to constantly query the port; the operating system notifies
the application when there has been activity. The application
then wakes up, completes the connection, and does whatever the
programmer told it to do.
<P>
Sockets are useful in Java for implementing communication streams
between programs. Sockets are the primary method of communication
on the Internet. Web pages, file transfers, and electronic mail
all communicate with each other using sockets. Because of the
Java socket interface, it is easy to create Java applications
that can participate in this network connectivity.
<P>
Java uses three classes in <TT><FONT FACE="Courier">java.net</FONT></TT>
for sockets: <TT><FONT FACE="Courier">ServerSocket</FONT></TT>,
<TT><FONT FACE="Courier">Socket</FONT></TT>, and <TT><FONT FACE="Courier">SocketImpl</FONT></TT>.
The first two are the classes most likely to be used by a programmer.
The last, <TT><FONT FACE="Courier">SocketImpl</FONT></TT>, is
generally implemented by the Java-enabled operating system. In
other words, most programmers will not have to delve into the
inner workings of <TT><FONT FACE="Courier">SocketImpl</FONT></TT>.
<H4><B>The </B><TT><B><FONT FACE="Courier">ServerSocket</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">ServerSocket</FONT></TT> is the socket
created for the server side. <TT><FONT FACE="Courier">ServerSocket</FONT></TT>
listens for a connection request from a client and accepts the
connection for a port on the server side.
<P>
Two of the methods associated with <TT><FONT FACE="Courier">ServerSocket</FONT></TT>
are <TT><FONT FACE="Courier">accept</FONT></TT> and <TT><FONT FACE="Courier">close</FONT></TT>.
<TT><FONT FACE="Courier">accept</FONT></TT> is used to create
the socket and attach it to a port on the server end. <TT><FONT FACE="Courier">close</FONT></TT>
is used to shut down the connection at the end of its useful life.
It is best to manually shut down the socket as opposed to waiting
for the Java garbage collector to shut it down.
<P>
Listing 13.2 shows the source code for a generic socket server.
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. A Java-based generic socket server or daemon.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This example implements a
java based generic socket server or daemon.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It uses a socket to communicate
with a socket client&nbsp;&nbsp;&nbsp;It can be used as<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the basis for almost any type
of socker server based application. This<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;particular example includes
logging of the connections accepted and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will accept a filename as
part of the constructor which will be used<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for this logging capability.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To better demonstrate it's
use, a prototype of a POP server has been<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implemented.&nbsp;&nbsp;The
POP server does not actually retrieve mail, but<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;does accept a connection on
port 110 and will respond to a quit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main program simply creates
a new JPop object and then executes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;its start method.&nbsp;&nbsp;JPop
will then loop waiting for and processing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connections.&nbsp;&nbsp;MyMain
accepts a filename as an command line arguement.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is used for logging of
the connections.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;logfile
name&gt;<BR>
<BR>
*/<BR>
<BR>
import java.io.*;<BR>
import java.net.*;<BR>
import java.util.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPop jp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare JPop object<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jp = new JPop(args[0]);&nbsp;&nbsp;&nbsp;//
create JPop instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jp.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
starts the JPop daemon<BR>
&nbsp;&nbsp; }<BR>
}<BR>
<BR>
<BR>
class Daemon {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare Daemon class<BR>
<BR>
&nbsp;&nbsp;&nbsp;public DataInputStream is;&nbsp;&nbsp;&nbsp;//
declare input stream variable<BR>
&nbsp;&nbsp;&nbsp;public PrintStream os;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare output stream variable<BR>
&nbsp;&nbsp;&nbsp;public String remoteHost;&nbsp;&nbsp;&nbsp;&nbsp;//
declare variable to hold remote hostname<BR>
<BR>
&nbsp;&nbsp;&nbsp;Socket s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare socket object<BR>
&nbsp;&nbsp;&nbsp;ServerSocket ss;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare server socket object<BR>
&nbsp;&nbsp; PrintStream lf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare printstream object<BR>
&nbsp;&nbsp;&nbsp;String logFile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare logfile name variable<BR>
&nbsp;&nbsp;&nbsp;int port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare port number variable<BR>
&nbsp;&nbsp;&nbsp;String name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// declare application name variable<BR>
<BR>
&nbsp;&nbsp;&nbsp;// constructor for class Daemon<BR>
&nbsp;&nbsp;&nbsp;public Daemon(int port, String name, String
logFile) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.port = port;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save port number<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save application name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.logFile = logFile;&nbsp;&nbsp;&nbsp;//
save logfile name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lf = new
PrintStream(new FileOutputStream(logFile));&nbsp;&nbsp;&nbsp;//
open logfile<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle file not found exceptions
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(FileNotFoundException
e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
File not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;
File = &quot; + logFile);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(5);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e) {System.exit(6);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle IO exceptions<BR>
writeLogEnt(&quot;daemon started&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
write daemon started log entry<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void start() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
method to start daemon<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss = new
ServerSocket(port);&nbsp;&nbsp;&nbsp;// create server socket<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = ss.accept();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
wait for incoming connection<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get name
of remote host for logging<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteHost
= (s.getInetAddress()).getHostName();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// write
log entry<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeLogEnt(&quot;connection
accepted: port = &quot; + s.getLocalPort() + &quot;, <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&Acirc;host
= &quot; + remoteHost);&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// open
a data input stream using the socket getInputStream method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is = new
DataInputStream(s.getInputStream());&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// open
an output PrintStream using the socket getOutputStream method
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os = new
PrintStream(s.getOutputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
IOexception(1) encountered&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.exit(7);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void stop() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare stop method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeLogEnt(&quot;daemon stopped&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//
log daemon stopped message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is !=
null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test input stream is not null<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
explicitly close input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (os !=
null) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test if output stream is not null<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.flush();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
explicitly flush output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
explicitly close output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s !=
null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test if socket is null<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
explicitly close socket<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
IOexception(2) encountered&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.exit(8);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;String date() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare method for getting todays date<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date d = new Date();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(d.getMonth()+&quot;/&quot;+d.getDate()+&quot;
&quot;+d.getHours()+&quot;:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&Acirc;&quot;+d.getMinutes()+&quot;:&quot;+d.getSeconds());
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void writeLogEnt(String entry) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
delcare method for writing log entries<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lf.println(date() + &quot;
&quot; + name + &quot;: &quot; + entry);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void exit(int errCode) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare common exit method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// log exit message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeLogEnt(&quot;daemon exited
with error code &quot; + errCode);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s != null) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test socket is not null<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {s.close();}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
close socket<BR>
catch(IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
IOexception(3) encountered&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(errCode);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
exit application<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class JPop {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare Java POP class<BR>
<BR>
&nbsp;&nbsp;&nbsp;Daemon d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare Daemon object<BR>
<BR>
&nbsp;&nbsp;&nbsp;public JPop(String logFile) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
constructor for class JPop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = new Daemon(110, &quot;JPop&quot;,
logFile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create new Daemon instance
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void start() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare start method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
variable to hold response from client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {&nbsp;&nbsp;&nbsp;&nbsp;//
loop forever handling incoming connections<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
start daemon<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send
response to remote host<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;+OK
&quot; + d.remoteHost + &quot; JPOP server ready&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procConnection();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
process POP connection<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare method to process POP connecitons
<BR>
&nbsp;&nbsp;&nbsp;public void procConnection() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// variable to hold response
from client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String cmd = &quot;&quot;;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// process commands until
quit received<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (! cmd.equalsIgnoreCase(&quot;quit&quot;))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp = read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
read response from client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tokenize
client response for processing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer
st = new StringTokenizer(resp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd = st.nextToken();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get command<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cmd.equalsIgnoreCase(&quot;quit&quot;))
{&nbsp;&nbsp;&nbsp;&nbsp;// test for quit command<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
send server shutdown message to client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;+OK
&quot; + d.remoteHost + &quot; JPOP server shutdown&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
stop connection to client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
go to top of loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send
error message to client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;-ERR
Invalid command; valid commands:&nbsp;&nbsp;QUIT&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;void write(String cmd) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare method to write string to client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.os.println(cmd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
send string to client<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;String read() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare method to read string from client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp = &quot;&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {resp = d.is.readLine();}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
read response from client<BR>
catch(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
read IOException&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.exit(10);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(resp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return exit code<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;void exit(int errCode) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare exit method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
close connection to client<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(errCode);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
exit application<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
When you start this program, on the command line, you must pass
the name of the file that you want to log socket messages as an
argument. You can do this as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java MyMain socket.txt</FONT></TT>
</BLOCKQUOTE>
<P>
In the example, the filename <TT><FONT FACE="Courier">socket.txt</FONT></TT>
is the name of the file that will log socket messages. While the
program is running, you can test the socket connection and logging.
To do this, start your browser and point to the IP address of
your local system using port 110. If you are on a network-capable
machine such as UNIX or Windows NT, you can use the local loopback
IP address of 127.0.0.1 for testing. For example, the URL <TT><FONT FACE="Courier">http://127.0.0.1:110</FONT></TT>
could be used to test port 110.
<P>
If you are able to start the program and test the socket connection,
the text file will have entries similar to the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">daemon started<BR>
connection accepted: port = 110,host = ppp-5.ts-4.dc.idt.net</FONT></TT>
</BLOCKQUOTE>
<H4><B>The </B><TT><B><FONT FACE="Courier">Socket</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">Socket</FONT></TT> is the class used
to create network connections and processes. <TT><FONT FACE="Courier">Socket</FONT></TT>
is used in conjunction with <TT><FONT FACE="Courier">SocketImpl</FONT></TT>
to implement the actual socket operations. <TT><FONT FACE="Courier">Socket</FONT></TT>
and <TT><FONT FACE="Courier">SocketImpl</FONT></TT> are separated
so that the implementation can be changed depending on the kind
of firewall being used. See Listing 13.3 for an example of using
<TT><FONT FACE="Courier">Socket</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. A </B><TT><B><FONT FACE="Courier">Socket</FONT></B></TT><B>
usage example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This example implements a
java based version of the Unix &quot;biff&quot; utility.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It uses a socket to communicate
with a POP server to determine if there<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is any mail for the user.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main program simply calls
the JBiff class methods every 60 seconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to determine if there is new
mail present on the server or not. It<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accepts three command line
arguments specifying the host to connect<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to, the username to use, and
the password to use&nbsp;&nbsp;&nbsp;Note that this<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is intended as an example
only.&nbsp;&nbsp;Specifying passwords on command<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines is never recommended.&nbsp;&nbsp;To
make this fully functional, a separate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialogue box should be implemented
to prompt for the password.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;That is beyond the scope of
this chapter however.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;hostname&gt;
&lt;username&gt; &lt;password&gt;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Historical note:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where does
&quot;biff&quot; come from?&nbsp;&nbsp;A program for checking
mail was<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; written many
years ago for Unix systems.&nbsp;&nbsp;The programmer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decided
to simply name it after his or her dog &quot;biff&quot;.&nbsp;&nbsp;Many
other<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;biff&quot;
type programs have been written since then and many<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of these
have carried on the historical fun of the &quot;biff&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name.&nbsp;&nbsp;For
this reason, the class implementing the &quot;biff&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functionality
was called jbiff for Java biff.&nbsp;&nbsp;On another<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;note, I
had thought about naming the class after one<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of our dogs,
spot or buffy, but decided that a program that<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;was constantly
giving out false alarms was not a good idea.<BR>
*/<BR>
<BR>
import java.io.*;<BR>
import java.net.*;<BR>
import java.util.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JBiff jb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare jbiff object<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create jbiff instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jb = new JBiff(args[0], args[1],
args[2]);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop forever checking mail
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check
for new mail<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (jb.chkMail())
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print out have NEW mail message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;You
have NEW mail&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print out have mail message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;You
have mail&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(60000);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// sleep for 60 seconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException
e){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle exceptions<BR>
}<BR>
&nbsp;&nbsp; }<BR>
}<BR>
<BR>
<BR>
class&nbsp;&nbsp;JBiff {<BR>
<BR>
&nbsp;&nbsp;&nbsp;Socket s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare socket object<BR>
&nbsp;&nbsp;&nbsp;DataInputStream dis;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare data input stream object<BR>
&nbsp;&nbsp;&nbsp;PrintStream dos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare printstream object<BR>
&nbsp;&nbsp;&nbsp;// variables for hostname, username, and password
<BR>
&nbsp;&nbsp;&nbsp;String hostname, user, pass;<BR>
&nbsp;&nbsp;&nbsp;int mailBoxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
variable to hold last count of mail messages<BR>
&nbsp;&nbsp;&nbsp;boolean mailBoxFlg = false;&nbsp;&nbsp;// variable
to hold status of New mail flag<BR>
<BR>
&nbsp;&nbsp;&nbsp;// constructor for class jbiff<BR>
&nbsp;&nbsp;&nbsp;public JBiff(String hostname, String user, String
pass) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mailBoxCnt = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// initialize mail message count to zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hostname = hostname;
// save hostname<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.user = user;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save username<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pass = pass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save password<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare method for open socket connection
to pop server<BR>
&nbsp;&nbsp;&nbsp;void openMailBox() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
variable to hold response from server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// open
new socket connection to hostname on port 110<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new
Socket(hostname, 110);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// open
a data input stream using the socket getInputStream method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dis = new
DataInputStream(s.getInputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// open
an output PrintStream using the socket getOutputStream method
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos = new
PrintStream(s.getOutputStream());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle file not found errors
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(UnknownHostException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
Host not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;
Host = &quot; + hostname);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e){};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
catch general IO exceptions<BR>
resp = read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
read first line from pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp = write(&quot;USER &quot;
+ user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send username command
to pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp = write(&quot;PASS &quot;
+ pass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send password command
to pop server<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare method to check for mail on pop server
<BR>
&nbsp;&nbsp;&nbsp;public boolean chkMail() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// variable to hold response
from server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// variable to hold current
mail message count on server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int cnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return code for method<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean rcode;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call method to open new
connection to pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openMailBox();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// use STAT command to get
count of mail messages on server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp = write(&quot;STAT&quot;);
<BR>
&nbsp;&nbsp;&nbsp;// tokenize server response for processing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer st = new StringTokenizer(resp);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// skip leading OK/ERR token
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st.nextToken();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get count of messages on
server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt = (new Integer(st.nextToken())).intValue();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// send QUIT to close connection
to pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;QUIT&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if more mail messages since
last time, set new mail flag<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cnt &gt; mailBoxCnt) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mailBoxFlg =
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if fewer mail messages
since last time, clear new mail flag<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cnt &lt; mailBoxCnt) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mailBoxFlg =
false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mailBoxCnt = cnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
save number of messages for next comparison<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(mailBoxFlg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return status of new mail flag<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;String write(String cmd) {&nbsp;&nbsp; // declare
method to write string to pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dos.println(cmd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
send string command to pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(read());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return string returned from read of pop server<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;String read() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare method to read string from pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String resp = &quot;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
initialize response variable<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp = dis.readLine();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
read response from pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (! resp.startsWith(&quot;+OK&quot;))
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// test for acceptable
response<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
report error returned by pop server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
err returned by pop server&quot;);&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;
resp = &quot; + resp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(7);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
read socket error&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(6);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(resp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
return string read from pop server<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=571>
<BLOCKQUOTE>
If you cannot access your host using the IP address, try the fully qualified domain and hostname, such as <TT><FONT FACE="Courier">www.tvp.com</FONT></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4><B>The </B><TT><B><FONT FACE="Courier">SocketImpl</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">SocketImpl</FONT></TT> is an abstract
class, which means the programmer must subclass it to make it
work. <TT><FONT FACE="Courier">SocketImpl</FONT></TT> is used
in conjunction with <TT><FONT FACE="Courier">Socket</FONT></TT>
to successfully adapt to different environments. One of the main
reasons this is an abstract class is that the actual socket communications
via Java are platform or firewall specific.
<P>
<TT><FONT FACE="Courier">SocketImpl</FONT></TT> can be used with
either streams or datagrams. It contains methods that can set
a boolean as to whether the socket data is in a stream or a datagram.
<P>
The class defines other methods that accept, connect, close, and
bind sockets to a port. These methods manipulate and control the
socket. Of course, because they are part of an abstract class,
the programmer must fill in the necessary details like IP address,
port, and hostname.
<H3><A NAME="JavaURLRelatedClasses"><B>Java URL-Related Classes</B></A>
</H3>
<P>
Java has classes in the <TT><FONT FACE="Courier">java.net</FONT></TT>
package that allow manipulation and connection to other locations
on the Internet. These locations are denoted by a unique <I>Uniform
Reference Locator</I> (URL).
<P>
The URL is set up to perform certain activities when a connection
is made to it, such as loading a Web page or downloading a file.
You can include these interfaces in a Java applet or application.
<P>
These URL classes are similar to sockets in that they allow easy
integration of network applications into a program. URLs are a
bit more user-friendly to work with than are sockets.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=563>
<BLOCKQUOTE>
Many of the examples in <A HREF="ch10.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch10.htm" >Chapter 10</A>, &quot;The <TT><FONT FACE="Courier">java.lang</FONT></TT> and <TT><FONT FACE="Courier">java.applet</FONT></TT> Class Libraries,&quot; use URLs to access files. Check out Listing 10.3, which shows a 
program that reads an audio file based on a URL.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheURLClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">URL</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT><FONT FACE="Courier">URL</FONT></TT><I> </I>class transforms
a URL string into an object that can then be manipulated using
associated methods. These methods serve purposes such as getting
the filename, protocol, and hostname.
<P>
<TT><FONT FACE="Courier">URL</FONT></TT> also has methods that
can open and maintain the data connection of an input stream.
This is much easier to use than the socket classes.
<H4><B>The </B><TT><B><FONT FACE="Courier">URLConnection</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">URLConnection</FONT></TT> is another
abstract class used to create and control a connection to a platform-
and firewall-specific location. It is a simplified version of
connection interface for the <TT><FONT FACE="Courier">URL</FONT></TT>
class. See the online documentation for a full list of its methods.
<H4><B>The </B><TT><B><FONT FACE="Courier">URLEncoder</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">URLEncoder</FONT></TT> takes a string
of text and turns it into the into <TT><FONT FACE="Courier">x-www-form-urlencoded</FONT></TT>
format, which is a MIME format. This can then be used in conjunction
with the <TT><FONT FACE="Courier">URL</FONT></TT> class.
<H4><B>The </B><TT><B><FONT FACE="Courier">URLStreamHandler</FONT></B></TT><B>
Class</B></H4>
<P>
<TT><FONT FACE="Courier">URLStreamHandler</FONT></TT> is an abstract
class. Its purpose is to create a format for opening a stream
connection to a specific URL. This class is concerned with the
protocol of the URL. If a programmer wants to create a new URL
stream protocol, it is necessary to implement the methods specified
in this abstract class. This is most definitely only for advanced
programmers.
<H2><A NAME="IntroducingthesuntoolsdebugLibrary"><B><FONT SIZE=5 COLOR=#Ff0000>Introducing
the </FONT></B><TT><B><FONT SIZE=5 COLOR=#Ff0000 FACE="Courier">sun.tools.debug</FONT></B></TT><B><FONT SIZE=5 COLOR=#Ff0000>
Library</FONT></B></A></H2>
<P>
The <TT><FONT FACE="Courier">sun.tools.debug</FONT></TT> library
provides the necessary framework for debugging Java programs.
Whenever you use the Java debugger, you are accessing this library.
If you accessed its classes directly, you could create your own
debugger. Because most Java developers will not need to create
their own debugger, this section provides only an overview of
the classes the library contains to give you insight into the
debugging process.
<H3><A NAME="TheDebuggerCallbackInterface"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">DebuggerCallback</FONT></B></TT><B><FONT SIZE=4>
Interface</FONT></B></A></H3>
<P>
The <TT><FONT FACE="Courier">DebuggerCallback</FONT></TT> interface
is a template for implementing communications between an application
and a debugger. The basic syntax for the interface is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface DebuggerCallback {<BR>
&nbsp;&nbsp;&#133;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
All communications between client applications and a debugger
are <I>asynchronous</I>. Asynchronous communications are rather
like the way you and I use e-mail: We send a message and the receiver
responds to the message when he gets a chance. The sections that
follow look at the abstract methods in the <TT><FONT FACE="Courier">DebuggerCallback</FONT></TT>
interface.
<P>
One of the key methods in this interface is <TT><FONT FACE="Courier">breakpointEvent()</FONT></TT>,
which is used to report when a breakpoint has been reached. The
method accepts a <TT><FONT FACE="Courier">RemoteThread</FONT></TT>
object-the thread that reached the breakpoint-as a parameter.
You use breakpoints during advanced debugging to help determine
the behavior and state of the program at a certain point in the
program's execution.
<P>
<A HREF="ch23.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch23.htm" >See Chapter 23</A>, &quot;Advanced Debugging
and Troubleshooting&quot; for more information on breakpoints.
<P>
Other key methods in this class include <TT><FONT FACE="Courier">exceptionEvent()</FONT></TT>,
<TT><FONT FACE="Courier">printToConsole()</FONT></TT>, <TT><FONT FACE="Courier">quitEvent()</FONT></TT>,
and <TT><FONT FACE="Courier">threadDeathEvent()</FONT></TT>. The
<TT><FONT FACE="Courier">exceptionEvent()</FONT></TT> method is
used to report that an exception has occurred. It accepts a <TT><FONT FACE="Courier">RemoteThread</FONT></TT>
object and a <TT><FONT FACE="Courier">String</FONT></TT> object
as parameters.
<P>
The <TT><FONT FACE="Courier">printToConsole()</FONT></TT> method
is used whenever the <TT><FONT FACE="Courier">DebuggerCallback</FONT></TT>
interface prints messages to the console-which, as you will see
when you use the Java debugger, is quite often. The <TT><FONT FACE="Courier">printToConsole()</FONT></TT>
method accepts a <TT><FONT FACE="Courier">String</FONT></TT> object
as a parameter.
<P>
The <TT><FONT FACE="Courier">quitEvent()</FONT></TT> method is
used to tell the debugger that the client has exited. Generally,
clients exit either by returning from the main thread or by calling
<TT><FONT FACE="Courier">System.exit()</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">threadDeathEvent()</FONT></TT> is
used to report that a thread has died. This method accepts a <TT><FONT FACE="Courier">RemoteThread</FONT></TT>
object, which is the thread that died, as a parameter.
<H3><A NAME="MethodsthatDealwithRemoteObjects"><B>Methods that
Deal with Remote Objects</B></A></H3>
<P>
As you might expect, most of the classes in a debugging library
for an object-oriented programming language are designed to handle
the debugging methods associated with objects. A complete listing
of the types of remote objects handled by the debugger is as follows:
arrays, booleans, bytes, characters, classes, doubles, fields,
floats, integers, longs, shorts, strings, threads, thread groups,
and variable values.
<P>
Each of these object types is handled in a separate class. These
classes include
<BLOCKQUOTE>
<TT><FONT FACE="Courier">RemoteArray<BR>
RemoteBoolean<BR>
RemoteByte<BR>
RemoteChar<BR>
RemoteClass<BR>
RemoteDouble<BR>
RemoteField<BR>
RemoteFloat<BR>
RemoteInt<BR>
RemoteLong<BR>
RemoteShort<BR>
RemoteString<BR>
RemoteThread<BR>
RemoteThreadGroup<BR>
RemoteValue</FONT></TT>
</BLOCKQUOTE>
<P>
Most of the methods used with specific objects types are similar
to the methods used in the <TT><FONT FACE="Courier">RemoteObject</FONT></TT>
class. For example, the <TT><FONT FACE="Courier">RemoteArray</FONT></TT>
class is one of many classes in the <TT><FONT FACE="Courier">sun.tools.debug</FONT></TT>
package that allow remote debugging of specific object types.
As you can probably tell by the name of the class, the <TT><FONT FACE="Courier">RemoteArray</FONT></TT>
class allows remote debugging of arrays.
<P>
What you probably cannot tell from the class name is that the
<TT><FONT FACE="Courier">RemoteArray</FONT></TT> class uses an
extensive list of methods that handle every facet of debugging
array objects. Still, the methods in the <TT><FONT FACE="Courier">RemoteArray</FONT></TT>
class are similar to the methods in the more generic <TT><FONT FACE="Courier">RemoteObject</FONT></TT>
class. Therefore, by examining the methods in the <TT><FONT FACE="Courier">RemoteObject</FONT></TT>
class, you can gain an understanding of most of the other classes
in the <TT><FONT FACE="Courier">sun.tools.debug</FONT></TT> package.
<P>
Table 13.1 is a summary of the methods in the <TT><FONT FACE="Courier">RemoteObject</FONT></TT>
class.<BR>
<P>
<CENTER><B>Table 13.1. Methods in the </B><TT><B><FONT FACE="Courier">RemoteObject</FONT></B></TT><B>
class.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><I>Method</I></TD><TD WIDTH=349><I>Purpose</I>
</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">description()</FONT></TT>
</TD><TD WIDTH=349>Returns a description of the object</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">finalize()</FONT></TT>
</TD><TD WIDTH=349>Performs this code when garbage collection is run
</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">getClass()</FONT></TT>
</TD><TD WIDTH=349>Returns the object's class</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">getField()</FONT></TT>
</TD><TD WIDTH=349>Returns an instance variable</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">getFields()</FONT></TT>
</TD><TD WIDTH=349>Returns the non-static fields of an object
</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">getFieldValue()</FONT></TT>
</TD><TD WIDTH=349>Returns the value of an object's instance variable
</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">getId()</FONT></TT>
</TD><TD WIDTH=349>Returns the ID of an object</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">setField()</FONT></TT>
</TD><TD WIDTH=349>Sets an instance variable, specified by slot or name
</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">toString()</FONT></TT>
</TD><TD WIDTH=349>Returns the object as a string</TD></TR>
<TR><TD WIDTH=166><TT><FONT FACE="Courier">typeName()</FONT></TT>
</TD><TD WIDTH=349>Returns the object type</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheRemoteStackFrameClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">RemoteStackFrame</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
Using the <TT><FONT FACE="Courier">RemoteStackFrame</FONT></TT>
class, the debugger can examine a suspended thread's stackframe.
As a Java developer, you will often use the debugger to call the
methods of this class.
<P>
The <I>stackframe</I> provides a frame of reference for everything
related to a thread's stack. You can think of it as a snapshot
of a thread's internals, including the thread's program counter,
local variables, referenced methods, referenced classes, and the
current line number of execution. The methods used to retrieve
this information follow a very basic syntax. For example, when
you call the <TT><FONT FACE="Courier">getLineNumber()</FONT></TT>
method, the method returns the current line number of execution.
This and other methods in this class are shown in Table 13.2.
<BR>
<P>
<CENTER><B>Table 13.2. Methods in the </B><TT><B><FONT FACE="Courier">RemoteStackFrame</FONT></B></TT><B>
class.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><I>Method</I></TD><TD WIDTH=386><I>Purpose</I>
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getLineNumber()</FONT></TT>
</TD><TD WIDTH=386>Returns the current line number of execution
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getLocalVariable()</FONT></TT>
</TD><TD WIDTH=386>Returns a named stack variable in the current stackframe
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getLocalVariables()</FONT></TT>
</TD><TD WIDTH=386>Returns an array of all valid local variables and method arguments for the stackframe
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getMethodName()</FONT></TT>
</TD><TD WIDTH=386>Returns the method name that the stackframe references
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getpc()</FONT></TT>
</TD><TD WIDTH=386>Returns the program counter that the stackframe references
</TD></TR>
<TR><TD WIDTH=205><TT><FONT FACE="Courier">getRemoteClass()</FONT></TT>
</TD><TD WIDTH=386>Returns the class that the stackframe references
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheRemoteStackVariableClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">RemoteStackVariable</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT><FONT FACE="Courier">RemoteStackVariable</FONT></TT> class
is similar to the <TT><FONT FACE="Courier">RemoteStackFrame</FONT></TT>
class. Using this class, the caller can obtain information about
a specific stack variable.
<P>
The class has three methods: <TT><FONT FACE="Courier">getName()</FONT></TT>,
<TT><FONT FACE="Courier">getValue()</FONT></TT>, and <TT><FONT FACE="Courier">inScope()</FONT></TT>.
The <TT><FONT FACE="Courier">getName()</FONT></TT> method is used
to get the name of a variable on the stack. The <TT><FONT FACE="Courier">getValue()</FONT></TT>
method is used to get the value of a variable on the stack. The
<TT><FONT FACE="Courier">inScope</FONT></TT> method is used to
tell whether the variable is accessible.
<H3><A NAME="TheRemoteDebuggerClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">RemoteDebugger</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
Because the <TT><FONT FACE="Courier">RemoteDebugger</FONT></TT>
class can instantiate a connection with the Java interpreter session
being debugged, client applications use this class as an interface
to the Java debugging classes. To create a client interface, you
use a constructor. The <TT><FONT FACE="Courier">RemoteDebugger</FONT></TT>
class provides an overloaded constructor interface that allows
for the two different ways the debugger can be instantiated.
<P>
The first constructor is used to attach the debugger to a current
interpreter session. As you will learn in <A HREF="ch23.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch23.htm" >Chapter 23</A>,
you do this by first starting the Java interpreter with the <TT><FONT FACE="Courier">-debug</FONT></TT>
option. The interpreter passes back a password, which is then
passed to the debugger when it is invoked. In addition to accepting
the password as a parameter, the constructor accepts a <TT><FONT FACE="Courier">String</FONT></TT>
object that identifies
<UL>
<LI>The host running the current interpreter session
<LI>The client using the <TT><FONT FACE="Courier">DebuggerCallback</FONT></TT>
interface to receive messages from the debugger
<LI>A <TT><FONT FACE="Courier">verbose</FONT></TT> flag to turn
on internal debugger message text
</UL>
<P>
Here is the syntax for the first constructor:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public RemoteDebugger(String host,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
password,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DebuggerCallback
client,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean
verbose) throws Exception</FONT></TT>
</BLOCKQUOTE>
<P>
The second constructor is used to create a remote debugger that
will start a client interpreter session. When you start the debugger
directly, it in turn starts the Java interpreter with any parameters
you passed on the command line. For this reason, the second constructor
accepts arguments that are to be passed on to the interpreter.
Other parameters allow the client using the <TT><FONT FACE="Courier">DebuggerCallback</FONT></TT>
interface to receive messages from the debugger, and others set
a <TT><FONT FACE="Courier">verbose</FONT></TT> flag to turn on
or off internal debugger message text.
<P>
The syntax for the second constructor follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public RemoteDebugger(String javaArgs,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DebuggerCallback
client,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean
verbose) throws Exception</FONT></TT>
</BLOCKQUOTE>
<P>
Methods in the <TT><FONT FACE="Courier">RemoteDebugger</FONT></TT>
class enable debugging techniques you will use when you debug
your programs. These methods are shown in Table 13.3.<BR>
<P>
<CENTER><B>Table 13.3. Methods in the </B><TT><B><FONT FACE="Courier">RemoteDebugger</FONT></B></TT><B>
class.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><I>Method</I></TD><TD WIDTH=347><I>Purpose</I>
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">addSystemThread()</FONT></TT>
</TD><TD WIDTH=347>Adds a system thread</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">close()</FONT></TT>
</TD><TD WIDTH=347>Closes the connection to the remote debugger
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">findClass()</FONT></TT>
</TD><TD WIDTH=347>Finds a specified class</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">freeMemory()</FONT></TT>
</TD><TD WIDTH=347>Gets a report of the free memory available to the Java interpreter being debugged
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">gc()</FONT></TT></TD>
<TD WIDTH=347>Frees all objects referenced by the debugger</TD>
</TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">get()</FONT></TT></TD>
<TD WIDTH=347>Gets an object from the remote object cache</TD>
</TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">getExceptionCatchList()</FONT></TT>
</TD><TD WIDTH=347>Gets the list of the exceptions on which the debugger will stop
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">getSourcePath()</FONT></TT>
</TD><TD WIDTH=347>Gets the source file path the client is currently using
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">itrace()</FONT></TT>
</TD><TD WIDTH=347>Turns instruction tracing on or off</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">listBreakpoints()</FONT></TT>
</TD><TD WIDTH=347>Gets a list of the current breakpoints</TD>
</TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">listClasses()</FONT></TT>
</TD><TD WIDTH=347>Gets a list of the currently known classes
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">listThreadGroups()</FONT></TT>
</TD><TD WIDTH=347>Gets a list of the currently known thread groups
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">run()</FONT></TT></TD>
<TD WIDTH=347>Loads and runs a runnable Java class</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">setSourcePath()</FONT></TT>
</TD><TD WIDTH=347>Sets the search path for source files</TD>
</TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">totalMemory()</FONT></TT>
</TD><TD WIDTH=347>Obtains a report of the total memory used by the Java interpreter being debugged
</TD></TR>
<TR><TD WIDTH=243><TT><FONT FACE="Courier">trace(boolean)</FONT></TT>
</TD><TD WIDTH=347>Turns method call tracing on or off</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheStackFrameClass"><B>The </B><TT><B><FONT SIZE=4 FACE="Courier">StackFrame</FONT></B></TT><B><FONT SIZE=4>
Class</FONT></B></A></H3>
<P>
The <TT><FONT FACE="Courier">StackFrame</FONT></TT> class provides
a wrapper for the stackframe of a suspended thread. This class
has a very basic constructor and a single method, called <TT><FONT FACE="Courier">toString()</FONT></TT>,
that returns an object as a string.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></B></A>
</H2>
<P>
The <TT><FONT FACE="Courier">java.net</FONT></TT> package contains
classes that provide an easy-to-use interface to basic network
programming. By using these classes, you can enable your Java
application or applet to participate in the world of network connectivity.
Some classes provide an abstract framework for protocol-specific
programming. These abstract classes may be implemented in the
Java-enabled operating-system interface.
<P>
The <TT><FONT FACE="Courier">sun.tools.debug</FONT></TT> class
library adds built-in debugging support to the Java programming
language. Examining the classes in this library should have given
you insight into the debugging process.
<P>
The mail server and mail client examples in this chapter are good
demonstrations of how easy it can be to write complex network
programs in Java, enabling even novice programmers to develop
working network applications. This is yet another example of the
power that has been built into Java, making it <I>the</I> programming
language to use today!
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch12.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch12.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch14.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch14.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>