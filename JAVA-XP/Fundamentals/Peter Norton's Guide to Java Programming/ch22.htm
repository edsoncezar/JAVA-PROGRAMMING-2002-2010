<HTML>

<HEAD>
   <TITLE>Chapter 22 -- Integrating Native Programs
and Libraries</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015337405&ad_type=POPUP&category=net&id=39b885567c21ce5c23338c87e4645887";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 22</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Integrating Native Programs
and Libraries</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#WhyandWhentoUseNativeMethodswith" >Why and When to Use Native Methods with Java Applications</A>
<LI><A HREF="#UsingCPrograms" >Using C Programs</A>
<UL>
<LI><A HREF="#CreatingNewCProgramsforUsewithJav" >Creating New C Programs for Use with Java Applications</A>
<LI><A HREF="#UsingExistingCPrograms" >Using Existing C Programs</A>
</UL>
<LI><A HREF="#UsingProgrammingLanguagesOtherThanC" >Using Programming Languages Other Than C</A>
<UL>
<LI><A HREF="#CPrograms" >C++ Programs</A>
<LI><A HREF="#ProgramsinOtherLanguages" >Programs in Other Languages</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Although Java has many advantages, it is a relatively new programming
language compared with C, C++, or Smalltalk. These and other existing
languages provide some features not yet available in Java. Also,
many useful applications written in other languages are in use
in businesses today. Programmers can use Java in more applications
if they can include existing code written in other languages.
<P>
Despite the advantages of leveraging existing code, any time multiple
languages are used in a single application there is more complexity.
For example, it is necessary to create code to translate information
between the two different languages. This code will make some
Java methods available to other languages and will make the functions
from other languages available to Java. Data as well as functions
can be transferred between languages.
<H2><A NAME="WhyandWhentoUseNativeMethodswith"><B><FONT SIZE=5 COLOR=#Ff0000>Why
and When to Use Native Methods with Java Applications</FONT></B></A>
</H2>
<P>
Before explaining how to include native methods in your Java code,
this section provides a little more detail on when such methods
are appropriate. Part of the power of Java is its platform independence.
Code compiled on one platform can be run on any platform with
a Java interpreter. This advantage is lost, however, as soon as
native methods are used.
<P>
Even if the native method can be compiled on every platform where
the application is desired, there is still the additional cost
of maintaining multiple versions of the compiled code. With native
methods, the application will run only on platforms with the same
operating system, and the dynamic library used to store the native
methods must be transferred along with the application. Given
these restrictions, there are still times when you will find it
appropriate to use code written in a different language.
<P>
When the code you want to use already exists in another language,
it may be faster to integrate the existing code with a new Java
application than to rewrite it in Java. This is especially true
with large, complex applications. It also may be appropriate to
use Java as the front-end interface. Such an application would
leave the number-crunching or back-end interface in the existing
language. This combination would enable a programmer to develop
a graphical user interface for applications currently run with
a text-based interface. The users would have the advantage of
a graphical interface while the code for the remainder of the
application was still being rewritten.
<P>
When the features you need cannot yet be done with Java, it certainly
makes sense to use native methods. This is true even if you have
to create several different libraries for different platforms.
Examples of this situation include recording audio in applications
or displaying images in a format other than GIF or JPEG. Of course,
if you are using native methods for this reason, it is also worthwhile
to contact the Java development team to let them know what features
you want. If there is sufficient interest in a particular feature,
it will probably be added to the Java API.
<P>
Accessing a device on the machine that Java does not recognize
is another reason for employing native code. There are many new
peripherals being developed, and many of them have device drivers
specific to a particular platform. To access these devices, you
most likely will need to link dynamic libraries specific to the
platform where the device is installed.
<P>
The final reason for using native methods in Java applications
is speed. Even after optimizing your Java code to achieve as much
speed as possible, native methods may still run faster. This is
particularly true if they can access properties in the hardware,
additional processors, or video boards, which Java does not use.
<H2><A NAME="UsingCPrograms"><B><FONT SIZE=5 COLOR=#Ff0000>Using
C Programs</FONT></B></A></H2>
<P>
The C language is considered first because this language is so
prevalent. There is a large body of existing C code that has been
tested over time and that many businesses may be reluctant to
rewrite.
<P>
In fact, the use of C is so extensive that the Java Developer's
Kit includes a tool just to create header files for linking C
programs into Java applications. This tool is called <TT><FONT FACE="Courier">javah</FONT></TT>
and is used to create the header files for the example shown here.
<P>
The first topic in this section describes how to write a new C
program to work with a Java application. The next topic reviews
how to modify an existing C program to access it through Java.
Although the two topics are closely related, creating new code
is a longer, more complex process than modifying existing code.
<H3><A NAME="CreatingNewCProgramsforUsewithJav"><B>Creating New
C Programs for Use with Java Applications</B></A></H3>
<P>
The <TT><FONT FACE="Courier">SumGraph</FONT></TT> application
is used to illustrate how to create new code for use with Java
by rewriting the <TT><FONT FACE="Courier">ASum</FONT></TT> class
so that the sum is calculated in C rather than in Java. This is
an extreme example in that the calculations could easily be done
in Java, but it serves to illustrate how a Java class can be used
to encapsulate calculations done in other code. It also shows
how parameters can be transferred between Java and other languages.
<H4><B>Step 1: Create the Java Class</B></H4>
<P>
The first step is to create a Java class that declares a native
method. The previous Java class for <TT><FONT FACE="Courier">ASum</FONT></TT>
appeared as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ASum {<BR>
int theSum;<BR>
<BR>
public ASum() {theSum = 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructor
set instance variable to 0<BR>
public void incSum(int toAdd) {<BR>
theSum = theSum + toAdd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add to
instance variable<BR>
}<BR>
public int getSum(){<BR>
return theSum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Return the value
of the instance variable<BR>
}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This example explains how to modify it so that the calculations
currently done in the <TT><FONT FACE="Courier">incSum()</FONT></TT>
method are done in a C routine. The new <TT><FONT FACE="Courier">incSum</FONT></TT>
method appears as
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public native void incSum(int toAdd);</FONT></TT>
</BLOCKQUOTE>
<P>
Although the method definition for <TT><FONT FACE="Courier">incSum</FONT></TT>
has been replaced with a call to a native method, the method operates
as before. It updates the class variable <TT><FONT FACE="Courier">theSum</FONT></TT>
by adding the value in the input variable to the value already
stored in <TT><FONT FACE="Courier">theSum</FONT></TT>.
<P>
You must add one more feature to the class. Because the class
is using a native function, Java must be certain that the library
containing that function has been loaded into the runtime environment.
Java does this using a <I>class initializer</I>. A class initializer
starts with the keyword <TT><FONT FACE="Courier">static</FONT></TT>
followed by braces that surround the methods called when the class
is loaded. The modified code for <TT><FONT FACE="Courier">ASum</FONT></TT>
that calls a native C method appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ASum {<BR>
&nbsp;&nbsp;&nbsp;int theSum;<BR>
<BR>
&nbsp;&nbsp;&nbsp;public ASum() {theSum = 0;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Constructor set instance variable to 0<BR>
&nbsp;&nbsp;&nbsp;public native void incSum(int toAdd);<BR>
&nbsp;&nbsp;&nbsp;public int getSum(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return theSum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Return the value of the instance variable<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.loadLibrary(&quot;sum_in_c&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">loadLibrary()</FONT></TT> method
that replaces the method body loads a dynamic library. The string
passed to it is the name of the library containing the C function
that the method will use. This method looks for the library along
the library path. On UNIX systems, the library path is specified
in the environmental variable <TT><FONT FACE="Courier">LD_LIBRARY_PATH</FONT></TT>.
On Windows systems, the environmental variable <TT><FONT FACE="Courier">PATH</FONT></TT>
is used to search for DLL libraries. The directory where the executable
is stored is also checked for DLLs.
<P>
An alternate form is the <TT><FONT FACE="Courier">System.load()</FONT></TT>
method, which loads a library based on a complete pathname. If
you use this form, you can include libraries that are not part
of the library path in your application.
<P>
The <TT><FONT FACE="Courier">loadLibrary()</FONT></TT> method
is part of the <TT><FONT FACE="Courier">System</FONT></TT> class.
All the components of the <TT><FONT FACE="Courier">System</FONT></TT>
class are static, so it cannot be instantiated or subclassed.
It is, however, a useful class. In the nongraphical examples,
this class is used to supply an output stream that displays on
the user's command line. Here, the <TT><FONT FACE="Courier">System</FONT></TT>
class is used to load a dynamic library. The <TT><FONT FACE="Courier">System</FONT></TT>
class also can be accessed to run the garbage collector, obtain
parameters, or get the current time.
<P>
The new <TT><FONT FACE="Courier">ASum</FONT></TT> class is called
from within the Java application. The call remains exactly as
it was in earlier examples. The class is stored in the file <TT><FONT FACE="Courier">ASum.java</FONT></TT>
and compiled just like any other class. The command is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac ASum.java</FONT></TT>
</BLOCKQUOTE>
<P>
When the class has been compiled and the <TT><FONT FACE="Courier">.class</FONT></TT>
file has been created, the header files needed to create the C
code can be generated.
<H4><B>Step 2: Generate Header and Stub Files</B></H4>
<P>
The next step is to use the <TT><FONT FACE="Courier">.class</FONT></TT>
file generated by the Java compiler to create the header file
required by the C compiler. The header file can be automatically
generated by the <TT><FONT FACE="Courier">javah</FONT></TT> tool.
The header file defines a C structure to depict <TT><FONT FACE="Courier">ASum</FONT></TT>.
It also contains the function definition for the implementation
of the <TT><FONT FACE="Courier">incSum</FONT></TT> method.
<P>
To run <TT><FONT FACE="Courier">javah</FONT></TT> against your
class file and create the <TT><FONT FACE="Courier">ASum.h</FONT></TT>
file, type the following at the command line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javah ASum</FONT></TT>
</BLOCKQUOTE>
<P>
Be certain before running <TT><FONT FACE="Courier">javah</FONT></TT>
that the <TT><FONT FACE="Courier">CLASSPATH</FONT></TT> environmental
variable has been set to point to the <TT><FONT FACE="Courier">classes.zip</FONT></TT>
file. If it is not set, the <TT><FONT FACE="Courier">javah</FONT></TT>
program will return an error.
<P>
If everything is set correctly, the <TT><FONT FACE="Courier">javah</FONT></TT>
tool will place the <TT><FONT FACE="Courier">ASum.h</FONT></TT>
file in the same directory as the <TT><FONT FACE="Courier">.class</FONT></TT>
file. The contents of the file on a Windows 95/NT-based machine
are as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;native.h&gt;<BR>
/* Header for class ASum */<BR>
<BR>
#ifndef _Included_ASum<BR>
#define _Included_ASum<BR>
<BR>
typedef struct ClassASum {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long theSum;<BR>
} ClassASum;<BR>
HandleTo(ASum);<BR>
<BR>
#ifdef __cplusplus<BR>
extern &quot;C&quot; {<BR>
#endif<BR>
__declspec(dllexport) void ASum_incSum(struct HASum *,long);<BR>
#ifdef __cplusplus<BR>
}<BR>
#endif<BR>
#endif</FONT></TT>
</BLOCKQUOTE>
<P>
The header file defines a structure, <TT><FONT FACE="Courier">ClassASum</FONT></TT>,
that contains the instance variables in the Java class <TT><FONT FACE="Courier">ASum</FONT></TT>.
In this case there is only one instance variable, but it is important
to the application. After the instance variable structure, the
header file provides a check for a C++ compiler. If a C++ compiler
is used, you must define the C function as <TT><FONT FACE="Courier">extern</FONT></TT>.
This prevents the C++ compiler from modifying the function name.
<P>
The definition for the C function is generated as part of the
header file. The function is expected to be part of a DLL export
and is declared as such. The function returns a <TT><FONT FACE="Courier">void</FONT></TT>
and takes two parameters: an instance of the structure just defined
and the value passed to the method from the caller.
<P>
The name of the C function is <TT><FONT FACE="Courier">ASum_incSum</FONT></TT>.
The <TT><FONT FACE="Courier">javah</FONT></TT> tool created this
function name by combining the class name and the name of the
Java method. If the class were part of a package, the package
name would have been prefixed to the function name as well.
<P>
In addition to the header file, interfacing between Java and C
requires a stubs file that translates the parameters and return
values between the two programming languages. The stubs file is
also automatically generated using the <TT><FONT FACE="Courier">javah</FONT></TT>
tool. To create a stubs file, type the following at the command
line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javah -stubs ASum</FONT></TT>
</BLOCKQUOTE>
<P>
The resulting file is <TT><FONT FACE="Courier">ASum.c</FONT></TT>,
and it contains the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* DO NOT EDIT THIS FILE - it is machine
generated */<BR>
#include &lt;StubPreamble.h&gt;<BR>
<BR>
/* Stubs for class ASum */<BR>
/* SYMBOL: &quot;ASum/incSum(I)V&quot;, Java_ASum_incSum_stub
*/<BR>
__declspec(dllexport) stack_item *Java_ASum_incSum_stub<BR>
&Acirc;(stack_item *_P_,struct execenv *_EE_) {<BR>
extern void ASum_incSum(void *,long);<BR>
(void) ASum_incSum(_P_[0].p,((_P_[1].i)));<BR>
return _P_;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">ASum.c</FONT></TT> file is compiled
and linked when the C code is linked.
<H4><B>Step 3: Write the C Program</B></H4>
<P>
The C function must include the signature generated with <TT><FONT FACE="Courier">javah</FONT></TT>.
There are three included header files in the C code that follows.
The header file <TT><FONT FACE="Courier">StubPreamble.h</FONT></TT>
is included to provide information to the C code to enable it
to interact with the Java runtime system. This header file should
be included in any C code that is being linked to Java. The header
file generated earlier with <TT><FONT FACE="Courier">javah</FONT></TT>
is included in the C code to provide the function declaration.
The last header file included is the standard I/O header file.
<P>
The following code is saved in the file <TT><FONT FACE="Courier">ASumInC.c</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#include &lt;StubPreamble.h&gt;<BR>
#include &quot;ASum.h&quot;<BR>
#include &lt;stdio.h&gt;<BR>
<BR>
void ASum_incSum(struct HASum *this,long addend) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long currentSum;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;currentSum = unhand(this)-&gt;theSum;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unhand(this)-&gt;theSum = currentSum +
addend<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The next section explains how to compile and link the C program
on both UNIX and Windows platforms.
<H4><B>Step 4: Compile and Link the C Program</B></H4>
<P>
Before attempting to compile the C source code, be sure the directory
containing the Java <TT><FONT FACE="Courier">include</FONT></TT>
file <TT><FONT FACE="Courier">StubPreamble.h</FONT></TT> is in
your <TT><FONT FACE="Courier">include</FONT></TT> path. If it
is not, extend the <TT><FONT FACE="Courier">include</FONT></TT>
path as part of the compiler command.
<P>
The correct command to compile the C code and link a dynamic library
depends on the system on which you are compiling. For a Windows
system with Visual C++ version 2.0, the command is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">cl ASum.c ASumInC.c -FeASum.dll -MD -LD
javai.lib</FONT></TT>
</BLOCKQUOTE>
<P>
The library <TT><FONT FACE="Courier">javai.lib</FONT></TT> must
be the last argument to the C compiler. You may also need to update
the library path so the linker can locate this library. The command
to do so is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">set LIB=%JAVAHOME%\lib;%LIB%</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">JAVAHOME</FONT></TT> is the installation
directory for Java.
<P>
For a UNIX system, the command to compile and link is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">cc -G ASum.c ASumInC.c -o libASum.so</FONT></TT>
</BLOCKQUOTE>
<P>
Now that your program is compiled and linked, you can use the
<TT><FONT FACE="Courier">java</FONT></TT> class to start the program
as you would any other Java application.
<H4><B>Running the Program</B></H4>
<P>
Running an application with a native method is no different than
running any other Java application. If the environment has been
set up correctly, the native method is transparent to the user.
The command to run the example is still
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java SumGraph</FONT></TT>
</BLOCKQUOTE>
<P>
The program should perform as it has throughout the chapter. If
a <TT><FONT FACE="Courier">NullPointerException</FONT></TT> appears
when the application is run, make sure the library path is set.
In Windows, the library path is the same as your <TT><FONT FACE="Courier">PATH</FONT></TT>
variable. In UNIX C shell, the path is set using the command
<BLOCKQUOTE>
<TT><FONT FACE="Courier">setenv LD_LIBRARY_PATH mylibrarypath</FONT></TT>
</BLOCKQUOTE>
<P>
If an <TT><FONT FACE="Courier">UnsatisfiedLinkError</FONT></TT>
message is encountered, it indicates that the library path is
set but does not include the library that was just created for
this example. In Windows, extend the <TT><FONT FACE="Courier">PATH</FONT></TT>
using
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PATH = %PATH%;C:\path_to_dll_file</FONT></TT>
</BLOCKQUOTE>
<P>
In UNIX C shell, extend the library path using
<BLOCKQUOTE>
<TT><FONT FACE="Courier">setenv LD_LIBRARY_PATH mylibrarypath</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="UsingExistingCPrograms"><B>Using Existing C Programs</B></A>
</H3>
<P>
The previous section explained in detail how to create a new C
program and include it in your Java application. The steps to
include an existing C program are similar. Therefore, this section
only highlights the key differences.
<P>
If you already have C code to link into a Java program, you just
need to create the hooks in the Java classes to access your C
functions. The important, and difficult, task is to make sure
the header files generated by the Java compiler match the declaration
of the existing C functions.
<P>
To create structures accessible to both your C code and your Java
code, use the <TT><FONT FACE="Courier">unhand()</FONT></TT> function
in the C code. You may want to create an interface layer, which
does the <TT><FONT FACE="Courier">unhand</FONT></TT> and puts
the result in a separate structure known only to the C code.
<P>
There are several useful functions available for accessing Java
from within C. Java methods may be executed from within C code
using the following function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">long execute_java_dynamic_method(ExecEnv
*e, Hobject *ojb,<BR>
char *method_method_name, char*method_signature, ...);</FONT></TT>
</BLOCKQUOTE>
<P>
To have the C code throw a Java exception when control returns
to Java, use this function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SignalError(0, JAVAPKG &quot;NameOfExceptionClass&quot;,&quot;ExceptionMessage&quot;);
<BR>
</FONT></TT>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Peter's Principle</B></TD></TR>

<TR><TD WIDTH=581> <BLOCKQUOTE>When including native code in a Java application, it is worth giving some consideration to freeing memory allocated in the native method. If the native method does not use <TT><FONT FACE="Courier">alloc</FONT></TT> to reserve 
memory, this is not a concern. Unfortunately, most complex applications will make some use of memory-allocation functions. This memory must be freed at some point.
<P>
Java's garbage collector will not automatically reclaim memory allocated in native methods; you must write a native method to free the memory allocated in a native method. However, you can call the method used to free the memory from within your Java class 
using the<TT><FONT FACE="Courier"> dispose()</FONT></TT> method. This method is automatically called when your instance is garbage collected. In this way you can be assured that memory allocated by native methods in association with a specific instance of 
a class is freed when that instance is discarded.
</BLOCKQUOTE>
</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="UsingProgrammingLanguagesOtherThanC"><B><FONT SIZE=5 COLOR=#Ff0000>Using
Programming Languages Other Than C</FONT></B></A></H2>
<P>
There is a large body of C programs currently in use in the business
and scientific worlds, so it is expected that most of the code
linked to Java will be C code. However, there are many other languages
in use, and algorithms coded in those languages also can be linked
to Java.
<H3><A NAME="CPrograms"><B>C++ Programs</B></A></H3>
<P>
C++ code is the next-easiest language to link into a Java application.
Although you do not need to create C functions to call your C++
code, you do need to surround your C++ code with <TT><FONT FACE="Courier">extern
&quot;C&quot;</FONT></TT>. This will enable you to reference the
C++ functions by the names used in the source file. The following
is a simple example of using <TT><FONT FACE="Courier">extern &quot;C&quot;</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">extern &quot;C&quot; {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void HelloWorld(void) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &quot;Hello, world.\n&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // end HelloWorld<BR>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// end extern &quot;C&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
If you do not use <TT><FONT FACE="Courier">extern &quot;C&quot;</FONT></TT>
in your C++ code, the compiler will modify the names and the linker
will not be able to resolve the references. You may also run into
some type conflicts, which can be handled using wrapper functions.
However, accessing C++ functions from Java is usually no more
complicated than accessing C. Therefore, you can follow the same
steps outlined previously to link C++ code into Java applications.
To recap:
<OL>
<LI>Create the Java class with appropriate references for use
with native functions.
<LI>Generate header and stub files.
<LI>Write or modify the C++ program for use with Java.
<LI>Compile and link the C++ program.
</OL>
<H3><A NAME="ProgramsinOtherLanguages"><B>Programs in Other Languages</B></A>
</H3>
<P>
Any program compiled into a dynamically loadable library can be
linked into a Java program. The advantage using of C/C++ is the
availability of Java tools that create the appropriate header
and stub files. If you are linking in other languages, you must
create these files manually.
<P>
To incorporate other languages easily, consider linking the code
from that language into a C program and then linking the C code
to Java. The additional overhead of going through the extra compile
is offset by the advantage of having the Java compiler create
the header and stub files.
<P>
Microsoft has recently announced support for the Java language.
The new ActiveX controls, formerly known as OLE controls, will
make many full-featured components available to Java developers.
These components can be incorporated into Java applications and
applets. It would then be possible to include a Microsoft application
such as Excel in a Java application.
<P>
As you include features from other languages in your applications,
it is important to remember that these features are not available
on every platform. If you are developing for a specific target
audience, this may not be a problem. Many corporate information-systems
groups believe in keeping all desktop platforms standardized.
Developing in this environment means you can use any native tools
that are considered part of the corporate standard. However, if
you want your application to be truly portable, stay with objects
defined and supported as part of the Java Developer's Kit.
<P>
One final word of caution involves dynamically loadable libraries.
Be very certain that the names you provide for your libraries
do not conflict with other library names the user may have installed
already. The functions compiled in your libraries also must have
unique names. If the names are not unique, the Java application
risks interfering with applications already installed on the user's
system.
<P>
The fact that Java uses a combination of the package, class, and
method names to create the interface function names should help
to ensure uniqueness. If you notice any problems with other applications
after installing a Java application that calls native methods,
remove the dynamic library installed with the Java application.
If the other applications then perform normally, modify the names
of the functions in the dynamic library installed with the Java
application to resolve the conflict.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></B></A>
</H2>
<P>
Your Java applications can access native methods written in other
programming languages, such as C/C++. The Java Developer's Kit
includes a tool called <TT><FONT FACE="Courier">javah</FONT></TT>
that you can use to create header files for linking C programs
into Java applications, which makes C the easiest language to
integrate with Java.
<P>
C++ code is the next-easiest language to link into a Java application.
All you need to do is surround your C++ code with <TT><FONT FACE="Courier">extern
&quot;C&quot;</FONT></TT>. You can link programs written in other
programming languages into your Java applications as long as the
program is compiled into a dynamically linked library, yet for
ease of integration you will probably want to link the code into
a C program and then link the C code to Java.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch21.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch21.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch23.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch23.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>