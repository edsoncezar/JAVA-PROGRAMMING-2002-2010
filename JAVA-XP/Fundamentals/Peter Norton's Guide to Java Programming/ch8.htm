<HTML>

<HEAD>
   <TITLE>Chapter 8 -- Tying It All Together: Threads,
Exceptions, and More</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336676&ad_type=POPUP&category=net&id=8bccc31943bcc1de7e9f7566d61752eb";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 8</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Tying It All Together: Threads,
Exceptions, and More</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#Threads" >Threads</A>
<UL>
<LI><A HREF="#UsesofThreads" >Uses of Threads</A>
<LI><A HREF="#DeclaringThreads" >Declaring Threads</A>
<LI><A HREF="#newandtheInstantiationofThreads" >new and the Instantiation of Threads</A>
<LI><A HREF="#DestroyingaThread" >Destroying a Thread</A>
<LI><A HREF="#ThreadMethods" >Thread Methods</A>
<LI><A HREF="#NamedThreads" >Named Threads</A>
<LI><A HREF="#SynchronizationofThreads" >Synchronization of Threads</A>
<LI><A HREF="#SummaryofThreads" >Summary of Threads</A>
</UL>
<LI><A HREF="#Exceptions" >Exceptions</A>
<UL>
<LI><A HREF="#RationaleforJavaExceptions" >Rationale for Java Exceptions</A>
<LI><A HREF="#ExceptionMethods" >Exception Methods</A>
<LI><A HREF="#AnExamplewithtrycatchandfinally" >An Example with try, catch, and finally</A>
<LI><A HREF="#UsingtryinExceptionHandling" >Using try in Exception Handling</A>
<LI><A HREF="#UsingcatchinExceptionHandling" >Using catch in Exception Handling</A>
<LI><A HREF="#UsingfinallyinExceptionHandling" >Using finally in Exception Handling</A>
<LI><A HREF="#UsingthrowinExceptionHandling" >Using throw in Exception Handling</A>
<LI><A HREF="#ThejavalangExceptionClass" >The java.lang.Exception Class</A>
<LI><A HREF="#SummaryofExceptions" >Summary of Exceptions</A>
</UL>
<LI><A HREF="#Streams" >Streams</A>
<UL>
<LI><A HREF="#DataFlowwithJavaStreams" >Data Flow with Java Streams</A>
<LI><A HREF="#TheImportanceofStreams" >The Importance of Streams</A>
<LI><A HREF="#InputStreams" >Input Streams</A>
<LI><A HREF="#OutputStreams" >Output Streams</A>
<LI><A HREF="#SummaryofStreams" >Summary of Streams</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter examines the final pieces of the Java programming
language: threads, exceptions, and streams. Java uses these structures
to create and control simultaneous activities and to perform error
handling. These structures also perform interprocess communication
among Java-controlled activities.
<P>
With threads, a single application in Java can easily run multiple
concurrent code execution. This enables an application to do such
powerful things as download a file, update a screen, and respond
to user input all at the same time without the large amount of
overhead incurred by the traditional fork used in languages such
as C/C++.
<P>
Exceptions are Java's powerful and flexible method for handling
errors, replacing the <TT><FONT FACE="Courier">return type error</FONT></TT>
code found in other languages. They are objects in Java and provide
the same extensibility as any other object. Exceptions help to
enforce Java's goal of being the safest language in which to program.
<P>
Streams are Java's way of communicating with the outside world.
Streams enable a Java application to communicate with files, networks,
devices, and other applications, and also allow for communication
between threads within the same application. Streams are based
on reading or writing a sequence of bytes from or to an outside
source. Because the flow of data is a simple stream of bytes,
specific knowledge of where the data comes from or is going to
is not needed. This adds to Java's strength as a portable language.
<P>
There are several examples in this chapter that demonstrate these
programming concepts. Try them yourself; you must see their output
to appreciate and understand them. This is especially true because
Java is not a procedural language, and it is difficult for most
human minds to conceptualize nonsequentially. And you, the Java
programmer-to-be, will have a lot more fun with Java when these
powerful concepts are utilized.
<P>
These three structures are discussed in detail in the following
sections. It is important to have a grasp of the uses of threads,
exceptions, and streams to have powerful, pleasing Java applications
and applets.
<H2><A NAME="Threads"><FONT SIZE=5 COLOR=#Ff0000>Threads</FONT></A>
</H2>
<P>
<I>Threads</I> enable a single program to run multiple parts of
itself at the same time. For example, one part of a program can
display an animation on the screen while another part builds the
next animation to be displayed.
<P>
For advanced programmers, threads are a lightweight version of
a process. Threads are similar to processes in that they can be
executed independently and simultaneously, but are different in
that they do not have all the overhead that a process does.
<P>
The <TT><FONT FACE="Courier">fork</FONT></TT> command is used
to create a new process in C or C++. A <I>forked process</I> is
an exact copy of the original process, with exact copies of variables,
code, and so on. Making this complete copy of all of the parent
process makes using the <TT><FONT FACE="Courier">fork</FONT></TT>
resource expensive. When they are running, the child processes
are completely independent of the parent process inasmuch as they
can modify data without any effect on the parent process.
<P>
Threads do not make copies of the entire parent process. Instead,
only the code needed is run in parallel. This means that threads
can be started quickly because they don't have all of the overhead
of a complete process. They do, however, have complete access
to all data of the parent process.
<P>
Threads can read and/or write data that any other thread can access.
This makes interthread communication simpler, but can lead to
multiple threads modifying data in an unpredictable manner. Additional
programming care is required with threads.
<H3><A NAME="UsesofThreads">Uses of Threads</A></H3>
<P>
Threads are useful programming tools for two main reasons. First,
they enable programs to do multiple things at one time. This is
useful for such activities as letting a user do something while
something else happens in the background.
<P>
Second, threads enable the programmer to concentrate on program
functionality without worrying about the implementation of multitasking
schemes. A programmer can simply spin off another thread for some
background or parallel operation without being concerned about
interprocess communications.
<H3><A NAME="DeclaringThreads">Declaring Threads</A></H3>
<P>
To create classes that make use of threads, you can extend the
class <TT><FONT FACE="Courier">Thread</FONT></TT> or implement
the interface <TT><FONT FACE="Courier">Runnable</FONT></TT>. Both
yield the same result. By implementing <TT><FONT FACE="Courier">Runnable</FONT></TT>,
existing classes can be converted to threads without having to
change the classes on which they are based.
<H4>Creating Threads by Extending <TT><FONT FACE="Courier">Thread</FONT></TT>
</H4>
<P>
An example of creating a thread by extending class <TT><FONT FACE="Courier">Thread</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyMain {<BR>
&nbsp;&nbsp;&nbsp;public static void main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(String
args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CntThread cntThread;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread = new CntThread();&nbsp;&nbsp;&nbsp;&nbsp;//create
thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//start
thread running<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {System.in.read();}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//wait for keyboard input<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(java.io.IOException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread.stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//stop
thread<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class CntThread extends Thread {<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ix = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;running,
ix = &quot; + ix++);&nbsp;&nbsp;&nbsp;//write count to screen
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(1000);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//sleep 1 second<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</FONT></TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
To exit the program, press Ctrl+C.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
In this example, a thread is created that will write an incrementing
counter to the screen. It will continue to count until the <TT><FONT FACE="Courier">main</FONT></TT>
routine receives a character from the keyboard, at which time
the counting thread stops. This means you can press any key on
the keyboard followed by the Enter key or press only the Enter
key to stop the thread from counting.
<P>
This is an excellent example of the concept of threads because
it introduces the keywords <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> (discussed in the
&quot;Exceptions&quot; section in this chapter) and also demonstrates
the creation and termination of a thread.
<H4>Creating Threads by Implementing <TT><FONT FACE="Courier">Runnable</FONT></TT>
</H4>
<P>
The second way to create a thread is by implementing the <TT><FONT FACE="Courier">Runnable</FONT></TT>
interface. Like the previous example, the following code creates
a thread that increments a counter until a character is entered
from the keyboard:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.applet.*;<BR>
import java.awt.*;<BR>
<BR>
public class MyApplet extends Applet implements Runnable {<BR>
<BR>
&nbsp;&nbsp;&nbsp;int ix = 0;<BR>
&nbsp;&nbsp;&nbsp;Thread mainThread;<BR>
&nbsp;&nbsp;&nbsp;CntThread cntThread;<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mainThread == null) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainThread
= new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainThread.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//start
main thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread = new CntThread(this);&nbsp;&nbsp;&nbsp;&nbsp;//create
CntThread instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//start
cntThread instance<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public boolean keyDown(Event evt, int key) {&nbsp;&nbsp;&nbsp;&nbsp;//process
key press<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread.stop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//stop
cntThread instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(true);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;running,
ix = &quot; + ix, 10,20);&nbsp;&nbsp;//write count to screen<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class CntThread implements Runnable {<BR>
<BR>
&nbsp;&nbsp;&nbsp;MyApplet parent;<BR>
&nbsp;&nbsp;&nbsp;boolean loop;<BR>
&nbsp;&nbsp;&nbsp;Thread cntThread;<BR>
<BR>
&nbsp;&nbsp;&nbsp;public CntThread(MyApplet p) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//constructor
for CntThread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent = 
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//save
parent instance<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cntThread == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread
= new Thread(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//create counting thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cntThread.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//start
counting thread<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop = false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//set
value to exit main while loop<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (loop == true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.ix++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//incremen
t
counter<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.repaint();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//repaint screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(1000);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//sleep 1 second<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException
e) {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Before you can view the applet in the applet viewer or your browser,
you need to create an HTML document, such as the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;HTML&gt;<BR>
&lt;HEAD&gt;<BR>
&lt;TITLE&gt;Using the Runnable Interface&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;APPLET CODE=&quot;MyApplet.class&quot; WIDTH=400 HEIGHT=400&gt;
<BR>
&lt;EM&gt;&lt;B&gt;You need a Java enabled Browser to see this
cool applet&lt;/B&gt;&lt;EM&gt;<BR>
&lt;/APPLET&gt;<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
This example also uses <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> for exceptions.
Look at the <TT><FONT FACE="Courier">start</FONT></TT> and <TT><FONT FACE="Courier">stop</FONT></TT>
sections of the code. Starting and stopping threads are covered
in detail later in the &quot;Thread Methods&quot; section of this
chapter.
<H3><A NAME="newandtheInstantiationofThreads"><TT><FONT SIZE=4 FACE="Courier">new</FONT></TT><FONT SIZE=4>
and the Instantiation of Threads</FONT></A></H3>
<P>
Instances of threads are created using the standard <TT><FONT FACE="Courier">new</FONT></TT>
keyword. Arguments to <TT><FONT FACE="Courier">new</FONT></TT>
can either use the <TT><FONT FACE="Courier">Thread</FONT></TT>
class explicitly, as in 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">mainThread = new Thread(this);</FONT></TT>
</BLOCKQUOTE>
<P>
or specify a class that is a subclass of <TT><FONT FACE="Courier">Thread</FONT></TT>,
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">mainThread = new MyThreadClass();</FONT></TT>
</BLOCKQUOTE>
<P>
In the first example, the current instance, <TT><FONT FACE="Courier">this</FONT></TT>,
of an object is initialized as a thread. Any object, however,
can be passed as an argument to the <TT><FONT FACE="Courier">Thread</FONT></TT>
class.
<P>
Note that the <TT><FONT FACE="Courier">Thread</FONT></TT> class
has few constructors. If additional constructor types are needed,
creating a subclass of <TT><FONT FACE="Courier">Thread</FONT></TT>
with the needed constructors is quite useful. The second thread-creation
example allows for these possibilities.
<H3><A NAME="DestroyingaThread">Destroying a Thread</A></H3>
<P>
You can control the execution of a thread in several ways using
the <TT><FONT FACE="Courier">stop</FONT></TT>, <TT><FONT FACE="Courier">start</FONT></TT>,
and <TT><FONT FACE="Courier">destroy</FONT></TT> methods. The
object remains in existence as long as the object is referenced
somewhere, even if <TT><FONT FACE="Courier">stop</FONT></TT> is
invoked.
<P>
It is not necessary to explicitly destroy the thread object. Java's
garbage collector takes care of this detail. If it is necessary
to give the garbage-collection process a helping hand, make sure
all references are removed to the thread object. The simplest
way to do this is to assign the value <TT><FONT FACE="Courier">null</FONT></TT>
to all variables containing thread references, as in the following
example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Thread myThread = new Thread();<BR>
myThread.start();<BR>
myThread.stop();<BR>
myThread = null;</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the thread object is instantiated with <TT><FONT FACE="Courier">new</FONT></TT>.
The thread is then started and stopped. Finally, <TT><FONT FACE="Courier">null</FONT></TT>
is assigned to the variable containing the thread instance. This
last step ensures that Java's garbage collector will schedule
a resource deallocation for that object.
<H3><A NAME="ThreadMethods">Thread Methods</A></H3>
<P>
All Java threads implement four methods: <TT><FONT FACE="Courier">init</FONT></TT>,
<TT><FONT FACE="Courier">run</FONT></TT>, <TT><FONT FACE="Courier">start</FONT></TT>,
and <TT><FONT FACE="Courier">stop</FONT></TT>. These are default
methods in the <TT><FONT FACE="Courier">Thread</FONT></TT> class;
if a class implements <TT><FONT FACE="Courier">Runnable</FONT></TT>,
these methods must be declared explicitly.
<H4><TT><FONT FACE="Courier">init</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">init</FONT></TT> method is called
the first time a thread is started. It is usually used for initialization
of objects, but can be used in any way the programmer sees fit.
Here is an example of an <TT><FONT FACE="Courier">init</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void init() {<BR>
&nbsp;&nbsp;&nbsp;index = 0;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method simply assigns a value of zero to the <TT><FONT FACE="Courier">index</FONT></TT>
variable. Larger, more complex applications might include code
that opens databases, creates display objects, or just about anything
that should be done only the first time a thread is started.
<H4><TT><FONT FACE="Courier">start</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">start</FONT></TT> method is called
to start a thread execution. This method usually contains the
code for actually creating and starting a thread. Here is an example
of a <TT><FONT FACE="Courier">start</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void start() {<BR>
&nbsp;&nbsp;&nbsp;if (mainThread == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new mainThread = Thread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainThread.start();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method checks to see if a thread has not yet been created
by testing whether the thread object <TT><FONT FACE="Courier">mainThread</FONT></TT>
is null. If it is not, a new thread object is created using <TT><FONT FACE="Courier">new,</FONT></TT>
and then the thread itself is started by calling the object's
<TT><FONT FACE="Courier">start</FONT></TT> method.
<H4><TT><FONT FACE="Courier">stop</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">stop</FONT></TT> method contains
the code needed to stop a thread's execution, often in the form
of generating a signal that will be caught by all threads and
that causes them to exit. <TT><FONT FACE="Courier">stop</FONT></TT>
also can change an object that causes a calling loop in the <TT><FONT FACE="Courier">run</FONT></TT>
method to exit. Here is an example of a <TT><FONT FACE="Courier">stop</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void stop() {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;loop = false; {
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
This method simply sets a variable to <TT><FONT FACE="Courier">false</FONT></TT>.
<TT><FONT FACE="Courier">loop</FONT></TT> is used in a main loop
<TT><FONT FACE="Courier">run</FONT></TT> method for control flow.
<H4><TT><FONT FACE="Courier">run</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">run</FONT></TT> method is similar
in function to <TT><FONT FACE="Courier">main</FONT></TT> in C
or C++. <TT><FONT FACE="Courier">run</FONT></TT> contains the
main body of code to be executed by a thread. Here is an example
of a <TT><FONT FACE="Courier">run</FONT></TT> method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void run() {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;loop = true;
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;while (loop == true) {
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;index
= &quot; + index++);
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(1000);}
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException
e){}
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;}
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
The body of this method consists of the initialization of the
<TT><FONT FACE="Courier">loop</FONT></TT> variable and a <TT><FONT FACE="Courier">while</FONT></TT>
loop that will continue executing until <TT><FONT FACE="Courier">loop</FONT></TT>
no longer has a value of <TT><FONT FACE="Courier">true</FONT></TT>.
The body of the loop prints out the value of the <TT><FONT FACE="Courier">index</FONT></TT>
variable to the screen and then sleeps for one second.
<P>
This method can be combined with the example from <TT><FONT FACE="Courier">stop</FONT></TT>
to control processing.
<H3><A NAME="NamedThreads">Named Threads</A></H3>
<P>
Java provides a means for assigning names to threads. Names can
consist of any valid Java string. Naming threads makes it convenient
to distinguish one thread from another and enables a parent process
to query a thread for its name. A thread can be assigned a name
at creation time or at any point thereafter. Threads can also
be renamed at any time.
<P>
To assign a thread a name at creation time, simply use a <TT><FONT FACE="Courier">Thread</FONT></TT>
constructor that accepts a string as an additional argument, like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Thread myThread = new Thread(this.&quot;My
first named thread&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the thread is instantiated by <TT><FONT FACE="Courier">new</FONT></TT>
and assigned a name of <TT><FONT FACE="Courier">&quot;My first
named thread&quot;</FONT></TT>.
<H4>The <TT><FONT FACE="Courier">getName</FONT></TT> Method</H4>
<P>
You can query a thread for its name using the <TT><FONT FACE="Courier">getName</FONT></TT>
method. <TT><FONT FACE="Courier">getName</FONT></TT> returns the
name associated with a specified thread object, as in the following
example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.println(&quot;The name of
this thread is &quot; + myThread.getName());</FONT></TT>
</BLOCKQUOTE>
<P>
This example prints out the name assigned to the thread object
<TT><FONT FACE="Courier">myThread</FONT></TT>. Using the previous
example, this statement would print the following to the screen:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">The name of this thread is My first named
thread</FONT></TT>
</BLOCKQUOTE>
<P>
A thread can also query for its own name in the same way:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.println(&quot;My name is &quot;
+ this.getName());</FONT></TT>
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">setName</FONT></TT> Method</H4>
<P>
You can set or change a thread name after creation using the <TT><FONT FACE="Courier">setName</FONT></TT>
method. The parent process, the thread itself, or any other method
that has access to the thread object can do this. Following is
an example of changing a thread name using <TT><FONT FACE="Courier">setName</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">myThread.setName(&quot;My newly renamed
first thread&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
This example changes the name of the thread from <TT><FONT FACE="Courier">&quot;My
first named thread&quot;</FONT></TT> to <TT><FONT FACE="Courier">&quot;My
newly renamed first thread&quot;</FONT></TT>.
<H3><A NAME="SynchronizationofThreads">Synchronization of Threads</A>
</H3>
<P>
Multiple threads can access the same object or method because
threads are not independent processes with complete copies of
data objects. However, there is no guarantee which thread will
access an object at a given time, which can lead to unpredictable
results. In situations when this is not acceptable, use the Java
synchronization logic. The keyword that provides this logic is
<TT><FONT FACE="Courier">synchronized</FONT></TT>.
<H4>The <TT><FONT FACE="Courier">synchronized</FONT></TT> Keyword
</H4>
<P>
The <TT><FONT FACE="Courier">synchronized</FONT></TT> keyword
is used to lock an object long enough to execute a block of code.
No other thread can make changes to the specified object while
the block of code is being executed. Here is an example using
<TT><FONT FACE="Courier">synchronized</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void printIndex() {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;syncronized(index) {
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++;
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;index
= &quot; + index);
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;}
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the <TT><FONT FACE="Courier">printIndex</FONT></TT>
method contains a synchronized block of code. In this block, the
object <TT><FONT FACE="Courier">index</FONT></TT> is locked while
the block of code making up the body of the <TT><FONT FACE="Courier">synchronized</FONT></TT>
statement is executed. The increment of <TT><FONT FACE="Courier">index</FONT></TT>
and the printing of the value of <TT><FONT FACE="Courier">index</FONT></TT>
are contained inside the block. This ensures that the value of
<TT><FONT FACE="Courier">index</FONT></TT> is printed to the screen
without having to worry that some other thread incremented <TT><FONT FACE="Courier">index</FONT></TT>
before it was printed.
<P>
<TT><FONT FACE="Courier">synchronized</FONT></TT> also can be
used as a modifier for methods, thus ensuring that only one thread
at a time executes the method. The previous example could be rewritten
using this construct as
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public syncronized void printIndex()
{</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;index++;
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;index = &quot; + index);
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="SummaryofThreads">Summary of Threads</A></H3>
<P>
Threads are Java's way of running multiple, parallel code segments
simultaneously. They are a lightweight process that does not have
all the overhead that a normal process has. Threads do not make
complete new copies of variables in the way that the C/C++ <TT><FONT FACE="Courier">fork</FONT></TT>
command does, allowing for faster thread startup. It also means
that threads have access to each other's data. This can make communication
among threads easier, but synchronization of data access may be
a problem.
<P>
Threads are based on the class <TT><FONT FACE="Courier">Thread</FONT></TT>
and can be implemented by either extending class <TT><FONT FACE="Courier">Thread</FONT></TT>
or using the interface <TT><FONT FACE="Courier">Runnable</FONT></TT>.
Using <TT><FONT FACE="Courier">Runnable</FONT></TT>, you can add
threading to existing classes.
<P>
All threads implement the <TT><FONT FACE="Courier">init</FONT></TT>,
<TT><FONT FACE="Courier">start</FONT></TT>, <TT><FONT FACE="Courier">stop</FONT></TT>,
and <TT><FONT FACE="Courier">run</FONT></TT> methods. You can
explicitly define these in the code, or use the default methods
that come with the <TT><FONT FACE="Courier">Thread</FONT></TT>
class. <TT><FONT FACE="Courier">init</FONT></TT> is called the
first time a thread is started, and it is a good place to put
initialization code. <TT><FONT FACE="Courier">start</FONT></TT>
is called any time a thread is started. This is usually where
thread initialization is done and the thread is actually started.
<TT><FONT FACE="Courier">stop</FONT></TT> is used to stop the
execution of a thread and usually contains code that will terminate
the main body of the thread. Finally, <TT><FONT FACE="Courier">run</FONT></TT>
is started by <TT><FONT FACE="Courier">start</FONT></TT> and normally
contains the body of the thread code.
<P>
The problem of multiple threads modifying the same variable can
arise due to the structure of Java, which allows threads access
to common variables. Also, the system is in control of scheduling
the execution of threads, which may be a different schedule than
the programmer had anticipated. You can control this situation
by using <TT><FONT FACE="Courier">synchronized</FONT></TT>. <TT><FONT FACE="Courier">synchronized</FONT></TT>
can be used on an object or on a method, and ensures that only
one thread can execute a block of code at a given time.
<H2><A NAME="Exceptions"><FONT SIZE=5 COLOR=#Ff0000>Exceptions</FONT></A>
</H2>
<P>
So far, this book has presented the means by which a programmer
can generate code correctly in Java. Correct code is, after all,
is a valid programming goal. However, none but the simplest programs
is error free; for example, simply not allowing enough space in
an array for all needed elements results in an error.
<P>
There are problems that are beyond program control, and therefore
also beyond the programmer's control. These include problems such
as running out of memory. Other nonprogrammatic problems are the
network being down or a hardware failure.
<P>
There are two main classes of problems in Java: <I>errors</I>
and <I>exceptions</I>. Errors are caused by problems in Java itself
and are generally of too detailed a nature for the program itself
to solve. When an error is encountered, Java typically generates
an error message to the screen and aborts the program.
<H3><A NAME="RationaleforJavaExceptions">Rationale for Java Exceptions</A>
</H3>
<P>
Java handles potentially recoverable errors through <I>exceptions</I>,
a special object class that handles virtually all errors in Java.
Java continues the idea of making code as reusable and error-free
as possible by treating errors as objects. Exception-handling
code resides in the <TT><FONT FACE="Courier">java.lang</FONT></TT>
package and is automatically included in all compiled code.
<P>
The reason Java treats exceptions as objects is to be able to
handle various errors using a standard extensible interface. This
manner of treating exceptions confers all the standard advantages
that object-oriented design provides, such as reusability and
customization.
<P>
Exceptions can be handled in Java in several ways: In some cases
they can simply be ignored; they can be handled directly by the
code in which they occur; or they can be passed on to the code
that called the method containing the occurrence of the exception
in the hopes that it will be handled there.
<P>
If an exception is not handled explicitly anywhere in the code,
it is passed on to the Java interpreter. The Java interpreter
might handle it in some way or might simply exit. In the case
of an applet within a browser, this may result in the browser
dying. This is not a desirable activity, so exception handling
within a program is generally recommended.
<P>
As mentioned previously, some exceptions in Java can be completely
ignored. The Java compiler requires others to be handled in one
fashion or another to get a clean compile. This latter case is
the reason you have seen some exception handling in the examples
shown in <A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >Chapters 6</A>, &quot;Fundamentals
of the Java Language,&quot; and 7, &quot;Building Objects,&quot;
such as in the example of the <TT><FONT FACE="Courier">sleep</FONT></TT>
method. This method can generate an exception that Java requires
to be handled explicitly.
<P>
You can customize existing exceptions or create new ones. Remember,
all exceptions are located in class <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>.
To customize an existing exception, the program simply overrides
the existing methods or rewrites the existing variables. To create
a new exception, create a new class that extends <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>.
<H3><A NAME="ExceptionMethods">Exception Methods</A></H3>
<P>
Most Java exception handling is performed using the <TT><FONT FACE="Courier">try</FONT></TT>,
<TT><FONT FACE="Courier">catch</FONT></TT>, <TT><FONT FACE="Courier">throw</FONT></TT>,
and <TT><FONT FACE="Courier">finally</FONT></TT> methods. Of course,
these methods can be extended if some unusual circumstance requires
it.
<P>
Java uses the <TT><FONT FACE="Courier">try</FONT></TT>, <TT><FONT FACE="Courier">catch</FONT></TT>,
and <TT><FONT FACE="Courier">throw</FONT></TT> keywords to do
actual exception handling. They are conceptually similar to a
<TT><FONT FACE="Courier">switch</FONT></TT> statement; think of
<TT><FONT FACE="Courier">try</FONT></TT> like the <TT><FONT FACE="Courier">switch</FONT></TT>
statement in terms of exactly identifying the condition to be
tested.
<P>
<TT><FONT FACE="Courier">catch</FONT></TT> is used to specify
the action that should be taken for a particular type of exception.
It is similar to the <TT><FONT FACE="Courier">case</FONT></TT>
part of a <TT><FONT FACE="Courier">switch</FONT></TT> statement.
There can be several <TT><FONT FACE="Courier">catch</FONT></TT>
statements in a row to deal with each of the exceptions that may
be generated in the block specified by the <TT><FONT FACE="Courier">try</FONT></TT>
statement.
<H4><TT><FONT FACE="Courier">throw</FONT></TT></H4>
<P>
Understanding exception handling in Java requires that you learn
some new terminology. The first concept you need to grasp is that
of <I>throwing</I> an exception, Java's name for causing an exception
to be generated. For example, say a method was written to read
a file. If the method could not read the file because the file
did not exist, this would generate an <TT><FONT FACE="Courier">IOException</FONT></TT>.
In Java terminology, it is said that the method <I>threw</I> an
<TT><FONT FACE="Courier">IOException</FONT></TT>.
<P>
Think of it as a horse throwing a shoe: You must stop everything
before real damage is done.
<H4><TT><FONT FACE="Courier">catch</FONT></TT></H4>
<P>
The next term to learn in Java exception handling is <TT><FONT FACE="Courier">catch</FONT></TT>.
An exception <I>catch</I> is code that realizes the exception
has occurred and deals with it appropriately. In Java terms, you
say a thrown exception gets <I>caught</I>.
<P>
In the case of the <TT><FONT FACE="Courier">IOException</FONT></TT>
thrown because of the nonexistent file mentioned in the previous
section, the <TT><FONT FACE="Courier">catch</FONT></TT> statement
writes an error message to the screen stating that the specified
file does not exist. It then allows the user to try entering a
different filename if the first was incorrect, or it may exit.
In Java terminology, the <TT><FONT FACE="Courier">IOException</FONT></TT>
was caught.
<H4><TT><FONT FACE="Courier">try</FONT></TT></H4>
<P>
<TT><FONT FACE="Courier">try</FONT></TT> is the Java exception-handling
term that means a Java program is going to try to execute a block
of code that might generate (throw) an exception. The <TT><FONT FACE="Courier">try</FONT></TT>
is a way of telling the compiler that some attempt will be made
to deal with at least some of the exceptions generated by the
block of code.
<H4><TT><FONT FACE="Courier">finally</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">finally</FONT></TT> statement is
used to specify the action to take if none of the previous <TT><FONT FACE="Courier">catch</FONT></TT>
statements specifically deals with the situation. It is similar
to the <TT><FONT FACE="Courier">default</FONT></TT> part of a
<TT><FONT FACE="Courier">switch</FONT></TT> statement. <TT><FONT FACE="Courier">finally</FONT></TT>
is the big net that catches everything that falls out of the exception-handling
statement.
<H3><A NAME="AnExamplewithtrycatchandfinally">An Example with
<TT><FONT SIZE=4 FACE="Courier">try</FONT></TT><FONT SIZE=4>,
</FONT><TT><FONT SIZE=4 FACE="Courier">catch</FONT></TT><FONT SIZE=4>,
and </FONT><TT><FONT SIZE=4 FACE="Courier">finally</FONT></TT></A>
</H3>
<P>
The following example is the standard structure for Java exception
handling, incorporating <TT><FONT FACE="Courier">try</FONT></TT>,
<TT><FONT FACE="Courier">catch</FONT></TT>, and <TT><FONT FACE="Courier">finally</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;statement that generates an exception
<BR>
}<BR>
catch (ExceptionType1 e) {<BR>
&nbsp;&nbsp;&nbsp;process exception type 1<BR>
}<BR>
catch (ExceptionType2 e) {<BR>
&nbsp;&nbsp;&nbsp;process exception type 2<BR>
}<BR>
finally {<BR>
&nbsp;&nbsp;&nbsp;process all other exception types<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="UsingtryinExceptionHandling">Using <TT><FONT SIZE=4 FACE="Courier">try</FONT></TT><FONT SIZE=4>
in Exception Handling</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">try</FONT></TT> is used to inform Java
that a block of code may generate an exception and that some processing
of that exception will be done immediately following the <TT><FONT FACE="Courier">try</FONT></TT>.
The syntax of <TT><FONT FACE="Courier">try</FONT></TT> is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try statement;</FONT></TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;statement(s)
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">try</FONT></TT> begins the
<TT><FONT FACE="Courier">try</FONT></TT> construct and is followed
by a statement or block containing the code that might generate
an exception. This code could consist of several statements, one
or more of which may generate an exception.
<P>
If any one statement generates an exception, the remaining statements
in the block are skipped and execution continues with the first
statement following the <TT><FONT FACE="Courier">try</FONT></TT>
construct, which must be a <TT><FONT FACE="Courier">catch</FONT></TT>
or <TT><FONT FACE="Courier">finally</FONT></TT> statement. This
is an important point to remember. It is an easy way to determine
which block of code should be skipped if an error occurs. Here
is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyMain {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] myArray = new int[10];
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Before
valid array assignment&quot;);
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myArray[0]
= 1;
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Before
invalid array assignment&quot;);
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myArray[100]
= 1;
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;After
array exception&quot;);
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;}
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the array <TT><FONT FACE="Courier">myArray</FONT></TT>
is created with a length of 10. This is followed by a <TT><FONT FACE="Courier">try</FONT></TT>
statement that contains several statements. The first, third,
and fifth statements simply write trace messages to the screen.
The second statement contains a standard assignment statement
that assigns the value <TT><FONT FACE="Courier">1</FONT></TT>
to array element <TT><FONT FACE="Courier">0</FONT></TT>. The third
statement also assigns an array, but attempts to assign a value
of <TT><FONT FACE="Courier">1</FONT></TT> to element <TT><FONT FACE="Courier">100</FONT></TT>
of the array. Because the array is only 10 in size, this generates
an <TT><FONT FACE="Courier">ArrayIndexOutOfBounds</FONT></TT>
exception.
<P>
In tracing the execution of the block of code following the <TT><FONT FACE="Courier">try</FONT></TT>
statement, the first three statements are executed normally. The
fourth statement, the invalid assignment, will start to execute
and then generate an exception, which causes execution to continue
at the end of the block, skipping the fifth statement.
<P>
A compilation error will result if you attempt to compile this
code as it stands because any <TT><FONT FACE="Courier">try</FONT></TT>
statement must be followed immediately by one or more <TT><FONT FACE="Courier">catch</FONT></TT>
or <TT><FONT FACE="Courier">finally</FONT></TT> statements. No
other type of statement is allowed after the end of the <TT><FONT FACE="Courier">try</FONT></TT>
statement and before the first <TT><FONT FACE="Courier">catch</FONT></TT>
or <TT><FONT FACE="Courier">finally</FONT></TT> statement. (<TT><FONT FACE="Courier">catch</FONT></TT>
statements are explained in the next section.)
<H3><A NAME="UsingcatchinExceptionHandling">Using <TT><FONT SIZE=4 FACE="Courier">catch</FONT></TT><FONT SIZE=4>
in Exception Handling</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">catch</FONT></TT> is used to handle a
specific exception that has been generated in a <TT><FONT FACE="Courier">try</FONT></TT>
statement. The syntax is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">catch (ExceptionType ExceptionObj) statement;</FONT></TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT><FONT FACE="Courier">catch (ExceptionType exceptionObj) {
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;statement(s)<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">catch</FONT></TT> begins
the <TT><FONT FACE="Courier">catch</FONT></TT> construct, followed
by a parameter list that contains an exception type and an exception
object. This in turn is followed by a statement or block containing
the code used to process the exception.
<P>
Think of the <TT><FONT FACE="Courier">catch</FONT></TT> construct
as a method that will be called by the Java runtime interpreter
if the particular exception type specified in the parameter list
is generated. The object specified in the parameter list, <FONT SIZE=1 FACE="MCPdigital-I">exceptionObj</FONT>,
is a variable that contains the exception object generated and
is local to the <TT><FONT FACE="Courier">catch</FONT></TT> block.
Within this block it can be manipulated as needed. The object
must be assigned to a variable whose scope resides outside the
block to use it outside the <TT><FONT FACE="Courier">catch</FONT></TT>
block, as in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyMain {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;public static void main (String
args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] myArray = new int[10];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Before
valid array assignment&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myArray[0]
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Before
invalid array assignment&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myArray[100]
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;After
array exception&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(ArrayIndexOutOfBoundsException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;An
array index error has occured&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
This example continues the earlier <TT><FONT FACE="Courier">try</FONT></TT>
example in the &quot;Using <TT><FONT FACE="Courier">try</FONT></TT>
in Exception Handling&quot; section. The required <TT><FONT FACE="Courier">catch</FONT></TT>
statement has been added after the <TT><FONT FACE="Courier">try</FONT></TT>
statement. This <TT><FONT FACE="Courier">catch</FONT></TT> statement
will catch the <TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>
specifically. If any other exception occurs, this <TT><FONT FACE="Courier">catch</FONT></TT>
statement is ignored. In this case, an <TT><FONT FACE="Courier">ArrayIndexOutOfBoundsException</FONT></TT>
is generated, so the body of this <TT><FONT FACE="Courier">catch</FONT></TT>
statement will be executed. This body simply generates an error
message to the screen. Execution continues normally with the first
statement following the <TT><FONT FACE="Courier">catch</FONT></TT>
block that is not a <TT><FONT FACE="Courier">catch</FONT></TT>
or <TT><FONT FACE="Courier">finally</FONT></TT> block.
<P>
Additional <TT><FONT FACE="Courier">catch</FONT></TT> statements
can follow the first <TT><FONT FACE="Courier">catch</FONT></TT>
statement. They must immediately follow the <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>
statement; otherwise a compilation error will occur. When an exception
in a <TT><FONT FACE="Courier">try</FONT></TT> statement is generated,
the Java interpreter will treat all the <TT><FONT FACE="Courier">catch</FONT></TT>
statements following the <TT><FONT FACE="Courier">try</FONT></TT>
statement as cases in a <TT><FONT FACE="Courier">switch</FONT></TT>
statement. The first statement that is matched will be executed,
and the remainder will be skipped. (An example of this is provided
in the introduction to the &quot;Exceptions&quot; section of this
chapter.)
<P>
Note that Java does not require any processing of the exception
at all. Simply having a <TT><FONT FACE="Courier">catch</FONT></TT>
statement for an exception with an empty block is sufficient to
avoid program abortion. This has been used in several examples
in <A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >Chapters 6</A> and <A HREF="ch7.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch7.htm" >7</A>
with the <TT><FONT FACE="Courier">sleep</FONT></TT> method.
<P>
<TT><FONT FACE="Courier">sleep</FONT></TT> is used to put a process
to sleep for a specified period of time, during which an <TT><FONT FACE="Courier">InterruptedException</FONT></TT>
could be generated. This could result from some other process
signaling this process to continue or quit, for example. In the
examples used in this book, catching this type of exception is
considered unimportant, and no processing is required. However,
because in most cases the compiler generates an error if the exception
generated by <TT><FONT FACE="Courier">sleep</FONT></TT> is not
caught, an empty <TT><FONT FACE="Courier">catch</FONT></TT> statement
is used, as in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {Thread.sleep(timePeriod);}<BR>
catch(InterruptedException e);</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see, the <TT><FONT FACE="Courier">catch</FONT></TT>
statement simply ends in a semicolon (<TT><FONT FACE="Courier">;</FONT></TT>),
which does nothing. The result is an <TT><FONT FACE="Courier">InterruptedException</FONT></TT>
error that is caught and then totally ignored.
<H3><A NAME="UsingfinallyinExceptionHandling">Using <TT><FONT SIZE=4 FACE="Courier">finally</FONT></TT><FONT SIZE=4>
in Exception Handling</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">finally</FONT></TT> is used to handle
<I>any</I> exception generated within a <TT><FONT FACE="Courier">try</FONT></TT>
statement. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
discussed previously can handle only one type of exception; the
<TT><FONT FACE="Courier">finally</FONT></TT> statement can handle
any type of exception. Following is an example of the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">finally statement;</FONT></TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT><FONT FACE="Courier">finally {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;statement(s)
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">finally</FONT></TT> begins
the <TT><FONT FACE="Courier">finally</FONT></TT> construct, followed
by a statement or block containing the code used to process the
exception.
<P>
As with the <TT><FONT FACE="Courier">catch</FONT></TT> statement,
a <TT><FONT FACE="Courier">finally</FONT></TT> block must follow
immediately after a <TT><FONT FACE="Courier">try</FONT></TT> or
other <TT><FONT FACE="Courier">catch</FONT></TT> statement or
a compilation error results. A <TT><FONT FACE="Courier">finally</FONT></TT>
statement acts like a <TT><FONT FACE="Courier">default</FONT></TT>
case in a <TT><FONT FACE="Courier">switch</FONT></TT> statement
if it follows a series of <TT><FONT FACE="Courier">catch</FONT></TT>
statements. Anything that was not explicitly matched by an earlier
<TT><FONT FACE="Courier">catch</FONT></TT> statement is caught
by the <TT><FONT FACE="Courier">finally</FONT></TT> statement.
A <TT><FONT FACE="Courier">finally</FONT></TT> statement cannot
be followed by another <TT><FONT FACE="Courier">catch</FONT></TT>
or <TT><FONT FACE="Courier">finally</FONT></TT> statement or a
compilation error will result. Because <TT><FONT FACE="Courier">finally</FONT></TT>
catches everything, additional statements would never be executed
in any case. The following code fragment provides an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char readFile() {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;char ch = '\0';<BR>
&nbsp;&nbsp;&nbsp;while (ch == '\0') {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch = myFile.read();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (EOFException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system.out.Println(&quot;End
of file encountered&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promptUserForFileName(fileName);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myFile =
openFile(fileName);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system.out.Println(&quot;Unexpected
error encountered while reading file&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system.Exit(1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;return(ch);<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, a <TT><FONT FACE="Courier">while</FONT></TT>
loop is used to read a single character from a file. The first
statement in the loop is a <TT><FONT FACE="Courier">try</FONT></TT>
statement that attempts to read a character from a file. It is
followed by two <TT><FONT FACE="Courier">catch</FONT></TT> statements
that look for two specific exception types. A <TT><FONT FACE="Courier">finally</FONT></TT>
statement follows that catches all other types of errors. The
loop itself is followed by a return of the character read.
<P>
Many types of errors can occur when reading a file, including
<TT><FONT FACE="Courier">End of file</FONT></TT>, <TT><FONT FACE="Courier">File
not found</FONT></TT>, <TT><FONT FACE="Courier">Access permission
errors</FONT></TT>, and others. The first <TT><FONT FACE="Courier">catch</FONT></TT>
statement handles <TT><FONT FACE="Courier">End of file</FONT></TT>
exceptions by simply exiting the loop, resulting in the return
of a <TT><FONT FACE="Courier">null</FONT></TT> character. The
second <TT><FONT FACE="Courier">catch</FONT></TT> statement handles
<TT><FONT FACE="Courier">File not found</FONT></TT> errors by
prompting the user for a new or correct filename, opening the
file, and then allowing the <TT><FONT FACE="Courier">while</FONT></TT>
loop to try again. Lastly, the <TT><FONT FACE="Courier">finally</FONT></TT>
statement catches all other errors. It writes an error message
to the screen and then causes the application to exit.
<H3><A NAME="UsingthrowinExceptionHandling">Using <TT><FONT SIZE=4 FACE="Courier">throw</FONT></TT><FONT SIZE=4>
in Exception Handling</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">throw</FONT></TT> is used to cause the
code itself to generate an exception. It is then up to calling
routines to handle the exception. This is the preferred way of
passing error information to calling routines in Java. The syntax
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">throw(ExceptionObj);</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">throw</FONT></TT> begins
the <TT><FONT FACE="Courier">throw</FONT></TT> construct, followed
by a parameter list containing a single item. This item is an
<I>exception object</I>, an object that has been declared to be
of the desired exception type.
<P>
The exception type can be any of those predefined in Java or one
custom designed for the job. Most exceptions can be found in <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>.
To design a new exception, extend the class <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>.
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyMain {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;public static void main (String
args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MalformedURLException e;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e = new MalformedURLException(&quot;Are
you a novice? Get your URL's right!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(e);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, an exception object (<TT><FONT FACE="Courier">e</FONT></TT>)
is declared. The object itself is then created with a standard
<TT><FONT FACE="Courier">new</FONT></TT> statement, in which the
constructor allows replacing the standard error text for this
exception. Finally, the exception object is thrown.
<P>
When an exception is thrown using the <TT><FONT FACE="Courier">throw</FONT></TT>
statement, current code execution stops. The exception is passed
to the calling routine, and no other code is executed until the
exception is caught somewhere. At that time, execution continues
where the exception is caught. Keep this in mind when using the
<TT><FONT FACE="Courier">throw</FONT></TT> statement; it is usually
a good idea to clean up as much as possible before throwing an
exception. It is not a good idea to depend on the calling routines
to clean up.
<P>
In some cases it may be desirable to catch a standard Java exception
and then generate a customized exception by simply including a
<TT><FONT FACE="Courier">throw</FONT></TT> in a <TT><FONT FACE="Courier">catch</FONT></TT>
block, as in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyMain {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;public static void main (String
args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] myArray = new int[10];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myArray[100]
= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(ArrayIndexOutOfBoundsException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e = new
ArrayIndexOutOfBoundsException(&quot;Please insure your array
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&Acirc;index
is within bounds.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
This is a modified version of the earlier <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> examples. In this
version, a customized error message is generated regarding the
array index problem by reassigning <TT><FONT FACE="Courier">e</FONT></TT>
to a new exception object that includes the customized message
and then using <TT><FONT FACE="Courier">throw</FONT></TT> to throw
another exception that must be caught at a higher level. If a
<TT><FONT FACE="Courier">catch</FONT></TT> or <TT><FONT FACE="Courier">finally</FONT></TT>
statement followed this <TT><FONT FACE="Courier">catch</FONT></TT>
statement, it would be ignored. However, if this <TT><FONT FACE="Courier">try</FONT></TT>
statement were itself enclosed in a different <TT><FONT FACE="Courier">try</FONT></TT>
statement, the execution would catch the exception. In other words,
it is possible to catch a self-generated exception by putting
a <TT><FONT FACE="Courier">throw</FONT></TT> statement inside
a <TT><FONT FACE="Courier">try</FONT></TT> statement. This is
rather like playing catch with yourself!
<H3><A NAME="ThejavalangExceptionClass">The <TT><FONT SIZE=4 FACE="Courier">java.lang.Exception</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
Previously in the section titled &quot;Exceptions,&quot; references
were made to not only customizing existing exceptions, but creating
new exceptions. These can be used to provide customized error
codes for a particular application. Java does not provide a lot
of numeric error-return codes as are found in other languages,
so creating new exceptions falls right in with the Java philosophy.
<P>
Class <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>
is the superclass for all exceptions in Java. Creating your own
extensions is simply a matter of extending this class just like
extending any other class. For instance, to create a new exception
called <TT><FONT FACE="Courier">MyOutOfRangeException</FONT></TT>,
the following implementation could be used:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class MyOutOfRangeException extends
Exception {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;public MyOutOfRangeException ()
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;public MyOutOfRangeException (String s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(s);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, a new class called <TT><FONT FACE="Courier">MyOutOfRangeException</FONT></TT>
has been created by extending the <TT><FONT FACE="Courier">Exception</FONT></TT>
class. It contains two constructors. The first one calls the exception
superclass constructor. This creates a new exception, but does
not provide a way for the calling routing to customize the message.
The second constructor is the same, but enables the calling routine
to specify the error message associated with the exception.
<P>
To use this exception, simply declare a variable of type <TT><FONT FACE="Courier">MyOutOfRangeException</FONT></TT>,
initialize it with one of the two constructors, and then throw
it, as in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class VerifyRange {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;MyOutOfRangeException e;<BR>
&nbsp;&nbsp;&nbsp;public void verifyIntRange (int value, int low,
int high) <BR>
&nbsp;&nbsp;&nbsp;&Acirc;throws MyOutOfRangeException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((value &lt; low) || (value
&gt; high)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e = new
MyOutOfRangeException(&quot;number &quot; + value + &quot; out
of range&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(e);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, a class called <TT><FONT FACE="Courier">VerifyRange</FONT></TT>,
to verify ranges of objects, has been created. The only method,
<TT><FONT FACE="Courier">VerifyIntRange</FONT></TT>, verifies
that a value passed as an argument falls within the range also
specified in the method's arguments. If the argument falls outside
the range, a <TT><FONT FACE="Courier">MyOutOfRangeException</FONT></TT>
exception is created with <TT><FONT FACE="Courier">new</FONT></TT>
and then thrown with <TT><FONT FACE="Courier">throw</FONT></TT>.
<P>
Notice that the method specifically declares that it throws this
exception in the method declaration. Because of this, any calling
routines are required to either provide an exception handler or
explicitly declare that the method may pass on this exception.
This would not be required if the <TT><FONT FACE="Courier">throw</FONT></TT>
portion of the declaration were left off. It is up to the programmer
to determine whether an exception is important enough to require
handling on the part of the calling routine.
<H3><A NAME="SummaryofExceptions">Summary of Exceptions</A></H3>
<P>
Exceptions are Java's way of performing error handling. They are
used in many ways as a replacement for the more standard return
codes used by languages such as C and C++. Java itself makes heavy
use of exceptions for error conditions, and any programs should
be ready to handle them. Using instructions makes a program more
robust, which makes for a better program.
<P>
Exceptions are handled using a combination of three statement
types: <TT><FONT FACE="Courier">try</FONT></TT><I>, </I><TT><FONT FACE="Courier">catch</FONT></TT>,
and <TT><FONT FACE="Courier">finally</FONT></TT>. <TT><FONT FACE="Courier">try</FONT></TT>
is used to inform the compiler that exception handling will be
performed on an associated block of code. <TT><FONT FACE="Courier">catch</FONT></TT>
is used for processing a specific exception generated in the <TT><FONT FACE="Courier">try</FONT></TT>
block of code. Several <TT><FONT FACE="Courier">catch</FONT></TT>
statements can be specified sequentially to handle specific exceptions
in a specific order. The <TT><FONT FACE="Courier">finally</FONT></TT>
statement can be used to catch all exceptions not specifically
caught by a <TT><FONT FACE="Courier">catch</FONT></TT> statement.
<P>
A program can generate its own exceptions using the <TT><FONT FACE="Courier">throw</FONT></TT>
statement. The exception itself can be either preexisting or newly
created. Even a preexisting exception can be customized by specifying
a different message when creating the exception object.
<P>
If you need a new exception, you can create one by simply extending
an existing exception class such as <TT><FONT FACE="Courier">java.lang.Exception</FONT></TT>.
Exceptions are usually simple and can be created using only two
constructors. Everything else is done by the superclass that the
new exception extended.
<P>
Judicious use of exceptions make the difference between a program
and a truly user-friendly, good program. Nothing is less user-friendly
than an aborted program.
<H2><A NAME="Streams"><FONT SIZE=5 COLOR=#Ff0000>Streams</FONT></A>
</H2>
<P>
You have probably noticed that the complexity of programming with
Java has been slowly building in this book. The next subject is
probably the most complex Java concept that must be mastered to
complete your knowledge of Java: <I>streams</I>.
<P>
Streams in Java provide a way for two or more processes to send
information to each other without any of the processes having
to know anything about the others. This means that with streams
you can write an application or applet that can then pass data
to almost any other stream-based application or applet! It is
even possible for multiple threads making up a single process
to pass data to each other via streams.
<H3><A NAME="DataFlowwithJavaStreams">Data Flow with Java Streams</A>
</H3>
<P>
At the highest level, streams work by simply sending information
from a producer process to a consumer process. A <I>producer process</I>
generates data for use by another process. A <I>consumer process</I>
makes use of data produced by another process. Information that
leaves a producer process is known as an <I>output stream</I>.
Information that arrives at a consumer is known as an <I>input
stream</I>. The information that makes up a stream is simply a
sequence of data blocks sent one at a time from the producer process
to the consumer process. The blocks themselves can be almost anything,
from simple bytes to complex objects. Only the primitive data
types are directly supported in Java, but any object can be sent
as a data block by creating new stream classes.
<P>
Streams are <I>unidirectional</I>-that is, the data for a particular
stream travels only from the producer to the consumer. The consumer
cannot send any data back to the producer on this same stream.
However, there is nothing to prevent the consumer process from
opening a different stream back to the producer process. In fact,
a single process can have multiple streams that can be any combination
of producers and consumers. These also can be opened between multiple
other processes. This is one of the powerful attributes of streams.
<P>
Each stream has only a single producer and a single consumer.
A single producer stream cannot feed multiple consumer streams,
and a single consumer stream cannot be fed by multiple producer
streams. This is not to say that a producer process could not
feed multiple consumer processes; it's just that each consumer
process must be fed by a different and unique stream. The same
is true for a single consumer process that is fed by multiple
producer processes.
<P>
Consumer processes do not have to blindly accept data from a producer,
however. They can start and stop the flow of information, read
as much or as little of a stream as desired, and in some cases
even determine how much data is left in the stream. Consumer processes
can also reset the stream to an earlier point. This control makes
it sound like the consumer is communicating back to the producer
process, but what is actually happening is that the consumer process
is communicating with the Java internals that handle the stream.
<P>
If a consumer process pauses while receiving data from its end
of the stream, the producer will not necessarily pause in sending
data. The producer may continue to produce data, and the Java
stream-handling code may buffer the data until the consumer process
begins accepting data again. This is important to remember: <I>the
producer and consumer do not communicate directly with each other
over a streams interface</I>. Instead, the producer simply generates
a stream of data at one end, which then goes into the Java stream-handling
code. From there it is sent to the consumer. The producer and
consumer have no knowledge of each other.
<H3><A NAME="TheImportanceofStreams">The Importance of Streams</A>
</H3>
<P>
Streams have many uses in Java and, in fact, are used quite heavily
within Java itself. They are used to read and write information
to devices, files, databases, network sockets, other processes-almost
anything. All stream interfaces implement a basic set of methods
that the programmer can use. These methods are common across all
stream types, which makes using a new stream type simple.
<P>
There are a few stream methods found in some Java package extensions,
but the standard ones are found in the <TT><FONT FACE="Courier">java.io</FONT></TT>
package. This package must be imported in all applications or
applets that make use of threads.
<P>
There are some extended stream methods that are not always implemented,
such as the capability to reset the stream to an earlier point.
For these cases, there are other methods discussed in the following
sections that you can use to check whether extended methods are
supported. This makes it possible for a program to take advantage
of these methods if they are available.
<P>
So how do you implement a stream? Let's find out!
<H3><A NAME="InputStreams">Input Streams</A></H3>
<P>
<I>Input streams</I> are the data streams that are accepted and
processed by a consumer process. As mentioned before, stream classes
and their associated methods are found in the package <TT><FONT FACE="Courier">java.io</FONT></TT>.
Every application or applet that uses streams must explicitly
import this package in the beginning of the code. You do this
with a standard <TT><FONT FACE="Courier">import</FONT></TT> statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.io.*;</FONT></TT>
</BLOCKQUOTE>
<P>
There are many different classes of input streams. Each has its
own purpose and can, of course, be extended or customized as needed
by the programmer. Table 8.1 is a complete list of Java's input
stream classes.
<P>
<CENTER><B>Table 8.1. Input stream classes.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads data from the buffer to minimize number of actual reads needed
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads byte data into an array of bytes</TD>
</TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">DataInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads data objects from a stream rather than bytes like most other input streams
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">FileInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads data from a file</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">FilterInputStream</FONT></TT>
</TD><TD WIDTH=346>Allows a stream to connect to subclasses of itself that can be used to filter the data
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">InputStream</FONT></TT>
</TD><TD WIDTH=346>Abstracts the superclass to all <TT><FONT FACE="Courier">InputStream</FONT></TT> classes
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">LineNumberInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads an input stream that uses line numbers
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">PipedInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads data from a pipe connected to another process
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">PushBackInputStream</FONT></TT>
</TD><TD WIDTH=346>Allows pushing a single character back onto input stream
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">SequenceInputStream</FONT></TT>
</TD><TD WIDTH=346>Treats multiple sequential input streams as single input stream
</TD></TR>
<TR><TD WIDTH=244><TT><FONT FACE="Courier">StringBufferInputStream</FONT></TT>
</TD><TD WIDTH=346>Reads character data into an array of characters (a string)
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The methods associated with input streams are of two types: those
that are guaranteed to work with all input streams (see Table
8.2) and those that are not (see Table 8.3).<BR>
<P>
<CENTER><B>Table 8.2. Input stream methods guaranteed to work.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">read</FONT></TT></TD>
<TD WIDTH=393>Reads data from an input stream</TD></TR>
<TR><TD WIDTH=148><TT><FONT FACE="Courier">skip</FONT></TT></TD>
<TD WIDTH=393>Skips past data in an input stream</TD></TR>
<TR><TD WIDTH=148><TT><FONT FACE="Courier">markAvailable</FONT></TT>
</TD><TD WIDTH=393>Tests if the <TT><FONT FACE="Courier">mark</FONT></TT> method is available on this input stream
</TD></TR>
<TR><TD WIDTH=148><TT><FONT FACE="Courier">close</FONT></TT></TD>
<TD WIDTH=393>Closes an input stream</TD></TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 8.3. Input stream methods not guaranteed to work.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">available</FONT></TT>
</TD><TD WIDTH=351>Amount of data available in an input stream
</TD></TR>
<TR><TD WIDTH=109><TT><FONT FACE="Courier">mark</FONT></TT></TD>
<TD WIDTH=351>Marks a point in an input stream to which to return 
</TD></TR>
<TR><TD WIDTH=109><TT><FONT FACE="Courier">reset</FONT></TT></TD>
<TD WIDTH=351>Returns to a specified point in an input stream
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The methods not guaranteed to work either may not be available
as valid methods or may return inaccurate or inconsistent results
because of the uncertain nature of a producer. Some producers
send a consistent stream of data; others will not produce data
until the intervening Java stream-handling code indicates it is
ready. For these reasons, the results can be unpredictable.
<H4><TT><FONT FACE="Courier">read</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">read</FONT></TT> method is the most
basic of the input stream methods. This is the method an application
uses to read data from a stream. It has several variations, mainly
involving how much data is read, where in the stream the data
starts and stops, and to where the data is written. Which <TT><FONT FACE="Courier">read</FONT></TT>
method you use depends on your application's needs.
<P>
All <TT><FONT FACE="Courier">read</FONT></TT> methods are based
on a <I>blocking read</I>, meaning that when a <TT><FONT FACE="Courier">read</FONT></TT>
method is called, it will not return until all the data requested
has been received or an exception occurs. Recall that in some
earlier examples, a read of the keyboard was done. In these cases,
the <TT><FONT FACE="Courier">read</FONT></TT> function did not
return until a character was entered on the keyboard. This is
an example of a blocking read. If the equivalent of a non-blocking
read is needed, methods exist for checking if data is available
before a read is executed.
<P>
All read methods also throw the <TT><FONT FACE="Courier">IOException</FONT></TT>
exception. This must be handled in an application's code, either
by using a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding a <TT><FONT FACE="Courier">throws</FONT></TT>
statement to the class declaration. The syntax of <TT><FONT FACE="Courier">read</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int read();<BR>
</FONT></TT>int read(byte[] buffer);<BR>
<TT><FONT FACE="Courier">int read(byte[] buffer, int offset, int
length)</FONT></TT>
</BLOCKQUOTE>
<P>
The first form of <TT><FONT FACE="Courier">read</FONT></TT> simply
attempts to read a single byte from the input stream. The byte
<TT><FONT FACE="Courier">read</FONT></TT> is returned by the function
itself, cast as an <TT><FONT FACE="Courier">int</FONT></TT>. The
second form reads data into a <I>buffer</I>, an array of bytes.
It attempts to read enough data to fill the buffer. The last version
also attempts to fill a buffer, but starts at the indicated <TT><FONT FACE="Courier">offset</FONT></TT>
into the stream and will read only <TT><FONT FACE="Courier">length</FONT></TT>
bytes. All cases of <TT><FONT FACE="Courier">read</FONT></TT>
return an integer, which is used to indicate the number of bytes
actually read. If there is nothing more to be read, it returns
a <TT><FONT FACE="Courier">-1</FONT></TT>, as in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.io.*;<BR>
<BR>
</FONT></TT>public class MyMain {<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//declare s to be a file input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rcode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
a variable for the read return code<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//use try to catch file open exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new
FileInputStream(args[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//open
the input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcode =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (rcode
!= -1) {&nbsp;&nbsp;//loop reading file until entire file is read
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//use
try to catch IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcode
= s.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//read
character from file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ch
= &quot; + (char)rcode);//print char to screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error reading file &quot; + args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
e) {&nbsp;&nbsp;//handle file not found exception<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;File
&quot; + args[0] + &quot; not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">read</FONT></TT> is
used to read bytes from a file input stream. The name of the file
to read is passed as the first argument on the command line when
you run the application. Therefore, if you wanted the program
to read from a file called <TT><FONT FACE="Courier">sample.txt</FONT></TT>,
you would invoke the <TT><FONT FACE="Courier">MyMain</FONT></TT>
application using the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java MyMain sample.txt</FONT></TT>
</BLOCKQUOTE>
<P>
A stream object variable <TT><FONT FACE="Courier">s</FONT></TT>
is declared to be of type <TT><FONT FACE="Courier">FileInputStream</FONT></TT>.
It is then initialized by opening the file input stream using
the <TT><FONT FACE="Courier">new</FONT></TT> operator. This will
result in the file actually being opened, so a <TT><FONT FACE="Courier">File
not found</FONT></TT> exception must be caught at this point if
the file does not exist.
<P>
Next, a <TT><FONT FACE="Courier">while</FONT></TT> loop is used
to continuously read a single byte from the stream until the <TT><FONT FACE="Courier">read</FONT></TT>
method returns <TT><FONT FACE="Courier">-1</FONT></TT>. The body
of the <TT><FONT FACE="Courier">while</FONT></TT> loop starts
out by calling the <TT><FONT FACE="Courier">read</FONT></TT> method
to read a byte. <TT><FONT FACE="Courier">read</FONT></TT> may
return an <TT><FONT FACE="Courier">IOexception</FONT></TT>, so
it is also placed in a <TT><FONT FACE="Courier">try</FONT></TT>
statement. If the <TT><FONT FACE="Courier">read</FONT></TT> succeeds,
the byte is printed to the screen. If not, a <TT><FONT FACE="Courier">catch</FONT></TT>
statement writes an error and the application aborts.
<P>
This example shows the basics for handling a simple input stream.
It shows how to open an input stream, read data from it, detect
the end of it, and set up exception handling for both the <TT><FONT FACE="Courier">open</FONT></TT>
and the <TT><FONT FACE="Courier">read</FONT></TT> of it.
<H4><TT><FONT FACE="Courier">skip</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method is used to
bypass a fixed number of bytes of an input stream, thereby enabling
the program to move quickly through the stream. It can be used
to skip unneeded data or to move to a specific point in the stream.
If used with a database input stream, it can be used to skip through
a set of fixed-length records to get to the record needed. If
used with a file input stream, it can provide some of the same
functionality as the C/C++ <TT><FONT FACE="Courier">lseek</FONT></TT>
function.
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method works in
a forward direction only. It cannot be used to skip backward to
an earlier point in an input stream. Some input streams allow
this functionality, but they use the <TT><FONT FACE="Courier">mark</FONT></TT>
and <TT><FONT FACE="Courier">reset</FONT></TT> methods (covered
later in their respective sections) to accomplish this.
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method throws the
same <TT><FONT FACE="Courier">IOException</FONT></TT> exception
that <TT><FONT FACE="Courier">read</FONT></TT> does. This must
be handled in an application's code, either by using a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding throws to the class declaration. The syntax
of <TT><FONT FACE="Courier">skip</FONT></TT> follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">long skip(long num);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method accepts a
single argument of type <TT><FONT FACE="Courier">long</FONT></TT>:
the number of bytes to skip in the input stream. Because data
streams do not have any fixed size, if more bytes than can be
handled in a <TT><FONT FACE="Courier">long</FONT></TT> must be
skipped, use multiple <TT><FONT FACE="Courier">skip</FONT></TT>
statements.
<P>
There is a problem with large argument values in the implementation
of <TT><FONT FACE="Courier">skip</FONT></TT> as of this writing
(Java 1.0). The <TT><FONT FACE="Courier">long</FONT></TT> passed
as an argument is internally cast to an <TT><FONT FACE="Courier">int</FONT></TT>
because <TT><FONT FACE="Courier">skip</FONT></TT> is implemented
using the <TT><FONT FACE="Courier">read(byte[])</FONT></TT> method.
The problem with this is that arrays in Java are constrained to
be no larger than an <TT><FONT FACE="Courier">int</FONT></TT>.
If skips larger than <TT><FONT FACE="Courier">int</FONT></TT>
are required, they must be implemented as multiple <TT><FONT FACE="Courier">int</FONT></TT>
skips.
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method returns a
<TT><FONT FACE="Courier">long</FONT></TT> that is used to indicate
the number of bytes actually skipped. If the end of the input
stream has already been reached when <TT><FONT FACE="Courier">skip</FONT></TT>
is called, a <TT><FONT FACE="Courier">-1</FONT></TT> is returned.
The following code fragment provides an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public long skipRecords (int num) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;int recordSize = 512;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//size
of a record in bytes<BR>
&nbsp;&nbsp;&nbsp;long rcode = 0;<BR>
&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcode = s.skip(num*recordSize);&nbsp;&nbsp;&nbsp;//skip
num 512 byte records<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rcode &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcode /=
recordSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//compute records skipped<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error skipping &quot; + num + &quot; records&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;return(rcode/recordSize);<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">skip</FONT></TT> is
used in a method that indexes into an input stream by number of
fixed 512-byte records. A <TT><FONT FACE="Courier">try</FONT></TT>
statement is used to catch an exception during the <TT><FONT FACE="Courier">skip</FONT></TT>
process. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
prints an error message if an <TT><FONT FACE="Courier">IOException</FONT></TT>
exception is generated. The method returns the number of records
skipped, a <TT><FONT FACE="Courier">-1</FONT></TT> if the skip
was at end of input, or <TT><FONT FACE="Courier">0</FONT></TT>
if an exception occurred. (This example is based on <TT><FONT FACE="Courier">s</FONT></TT>
being a stream object that has already been opened as a variable
global to this method.)
<H4><TT><FONT FACE="Courier">close</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">close</FONT></TT> method is used
to close an input stream that an application or applet no longer
needs. Java closes input streams automatically when an application
or applet exits, which is why a <TT><FONT FACE="Courier">close</FONT></TT>
statement has not been used in the preceding stream examples.
However, it is good programming practice to close any resources
an application no longer needs.
<P>
The <TT><FONT FACE="Courier">close</FONT></TT> method throws the
same <TT><FONT FACE="Courier">IOException</FONT></TT> exception
that <TT><FONT FACE="Courier">read</FONT></TT> and <TT><FONT FACE="Courier">skip</FONT></TT>
do. This must be handled in an application's code, either by using
a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding <TT><FONT FACE="Courier">throw</FONT></TT>
statement to the class declaration.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public long closeStream () {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;try s.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//close
input stream<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp; //handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error closing input stream&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">close</FONT></TT> is
used in a method that encapsulates the <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> functionality into
a single location. A <TT><FONT FACE="Courier">try</FONT></TT>
statement is used to catch an exception during the <TT><FONT FACE="Courier">close</FONT></TT>
process. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
prints an error message if an <TT><FONT FACE="Courier">IOException</FONT></TT>
exception is generated. (As in the <TT><FONT FACE="Courier">skip</FONT></TT>
example used previously, this example is based on <TT><FONT FACE="Courier">s</FONT></TT>
being a stream object that has already been opened as a variable
global to this method.)
<H4><TT><FONT FACE="Courier">available</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">available</FONT></TT> method is used
to determine if some amount of data is ready to be read without
blocking in the input stream and to test whether enough data is
available for processing before some other method such as <TT><FONT FACE="Courier">read</FONT></TT>
is called. However, <TT><FONT FACE="Courier">available</FONT></TT>
does not return valid information for all input streams. Some
input streams always return <TT><FONT FACE="Courier">0</FONT></TT>,
whereas others may return inconsistent numbers. This is due to
the unknowns associated with the producer process and the implementation
of the underlying Java code that handles the connection between
the producer and consumer processes.
<P>
In other programming languages, the equivalent functionality of
<TT><FONT FACE="Courier">available</FONT></TT> is used to ensure
that a required amount of data is available before issuing a <TT><FONT FACE="Courier">read</FONT></TT>
command. This is done because <TT><FONT FACE="Courier">read</FONT></TT>
often blocks until the read has completed. For applications that
must continue doing other processing until all data needed is
available, this is the only way to ensure that the application
does not hang waiting for data.
<P>
In Java, threads can be used to handle this problem. By assigning
a specific thread to do reading on an input stream, that thread
can block, waiting for the required amount of input while other
threads continue with needed processing. The easy availability
of threads makes using <TT><FONT FACE="Courier">available</FONT></TT>
largely unnecessary. This is also why the incorrect or inconsistent
results returned by <TT><FONT FACE="Courier">available</FONT></TT>
are not considered big problems. The syntax of <TT><FONT FACE="Courier">available</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int available();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">available</FONT></TT> method simply
returns an <TT><FONT FACE="Courier">int</FONT></TT> indicating
the number of bytes in the input stream that can currently be
read without blocking. The <TT><FONT FACE="Courier">available</FONT></TT>
method does not have any parameters. Note that the return value
is an <TT><FONT FACE="Courier">int</FONT></TT>. Streams can be
of unlimited size, so even if more than an <TT><FONT FACE="Courier">int</FONT></TT>'s
worth of data is available, only an <TT><FONT FACE="Courier">int</FONT></TT>'s
worth is reported. The following code fragment provides an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public boolean isRecordReady () {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;int recordSize = 512;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//size
of a record in bytes<BR>
&nbsp;&nbsp;&nbsp;boolean rcode = false;<BR>
&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//test if at least 512 bytes
are available<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s.available &gt;= recordSize)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rcode =
true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error checking for record availability&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;return(rcode);<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">available</FONT></TT>
is used to determine if an entire fixed-length record of 512 bytes
is available in the input stream. A <TT><FONT FACE="Courier">try</FONT></TT>
statement is used to catch an exception during the <TT><FONT FACE="Courier">available</FONT></TT>
test. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
prints an error message if an <TT><FONT FACE="Courier">IOException</FONT></TT>
exception is generated. The method will return <TT><FONT FACE="Courier">true</FONT></TT>
if at least 512 bytes are ready or <TT><FONT FACE="Courier">false</FONT></TT>
if not. (As with <TT><FONT FACE="Courier">skip</FONT></TT> and
<TT><FONT FACE="Courier">close</FONT></TT>, this example is based
on <TT><FONT FACE="Courier">s</FONT></TT> being a stream object
that has already been opened as a variable global to this method.)
<H4><TT><FONT FACE="Courier">mark</FONT></TT>, <TT><FONT FACE="Courier">markSupported</FONT></TT>,
and <TT><FONT FACE="Courier">reset</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">mark</FONT></TT> method is used to
mark a point in an input stream to which it may be necessary to
return at a later time. This method is not available for all input
stream types. A separate method called <TT><FONT FACE="Courier">markSupported</FONT></TT>
determines if a particular input stream supports this functionality.
If <TT><FONT FACE="Courier">mark</FONT></TT> is supported, you
can use the <TT><FONT FACE="Courier">reset</FONT></TT> method
to return to the point indicated by <TT><FONT FACE="Courier">mark</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">mark</FONT></TT>/<TT><FONT FACE="Courier">reset</FONT></TT>
methods have several limitations that make them useful only for
specific applications. When <TT><FONT FACE="Courier">mark</FONT></TT>
is used, the program must specify a maximum amount of data that
can go by before the <TT><FONT FACE="Courier">reset</FONT></TT>
method is called. If more than this amount of data goes by, <TT><FONT FACE="Courier">reset</FONT></TT>
will throw an exception. Also, there is no way to specify multiple
<TT><FONT FACE="Courier">mark</FONT></TT>s on an input stream.
If <TT><FONT FACE="Courier">mark</FONT></TT> is called again before
a <TT><FONT FACE="Courier">reset</FONT></TT> is done, the <TT><FONT FACE="Courier">mark</FONT></TT>
is simply moved to the new location with the new limit on how
much can be read before a <TT><FONT FACE="Courier">reset</FONT></TT>
occurs. The syntax of <TT><FONT FACE="Courier">mark</FONT></TT>,
<TT><FONT FACE="Courier">markSupported</FONT></TT>, and <TT><FONT FACE="Courier">reset</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void mark(int readLimit);<BR>
<BR>
</FONT></TT>boolean markSupported();<BR>
<BR>
<TT><FONT FACE="Courier">void reset();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">mark</FONT></TT> method accepts a
single parameter of type <TT><FONT FACE="Courier">int</FONT></TT>
that indicates how much data in the input stream can go by before
calling the <TT><FONT FACE="Courier">reset</FONT></TT> method.
The <TT><FONT FACE="Courier">markSupported</FONT></TT> method
has no arguments and simply returns a <TT><FONT FACE="Courier">boolean</FONT></TT>
value indicating whether the <TT><FONT FACE="Courier">mark</FONT></TT>
function is available for a given input stream. <TT><FONT FACE="Courier">reset</FONT></TT>
has no calling arguments and no return value. It simply resets
the input stream to the point at which <TT><FONT FACE="Courier">mark</FONT></TT>
was called. The following code fragment provides an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static boolean checkForPostScriptHeader
(int size) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;byte buffer[];<BR>
&nbsp;&nbsp;&nbsp;String txt;<BR>
&nbsp;&nbsp;&nbsp;buffer = new byte[size];<BR>
&nbsp;&nbsp;&nbsp;if (s.markSupported() == false) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Input
Stream does not support mark&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(1);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;try s.read(buffer);<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error reading data stream&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);<BR>
}<BR>
&nbsp;&nbsp;&nbsp;try s.reset();<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error reseting data stream&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(3);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;txt = new String(buffer,size);<BR>
&nbsp;&nbsp;&nbsp;if ((txt.indexOf(&quot;\n%!&quot;) != -1) ||
(txt.indexOf(&quot;%!&quot;) == 0))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(true);<BR>
&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
This example is a method that checks a data input stream for a
postscript header. If there is one, it will return <TT><FONT FACE="Courier">true</FONT></TT>;
otherwise it will return <TT><FONT FACE="Courier">false</FONT></TT>.
The <TT><FONT FACE="Courier">mark</FONT></TT> and <TT><FONT FACE="Courier">reset</FONT></TT>
methods are used to return the data stream to its original location
so that the calling routines can process the stream as needed.
<P>
The method starts by checking whether the <TT><FONT FACE="Courier">mark</FONT></TT>
method is available for this input stream using the <TT><FONT FACE="Courier">markSupported</FONT></TT>
method. If it is not, an application exit is forced. If <TT><FONT FACE="Courier">mark</FONT></TT>
is available, the input stream is marked with the passed-in size.
This allows the calling application to specify how much data should
be checked for a postscript header. After the input stream is
marked, it is read into a buffer. If an <TT><FONT FACE="Courier">IOexception</FONT></TT>
occurs, a message is written to the screen and again the application
exits. If the input stream is read successfully, it is then reset
back to the location where the method was called. Again it tests
for an <TT><FONT FACE="Courier">IOException</FONT></TT> exception,
and an error message and an exit occur if an exception is detected.
<P>
After the input stream is reset, the buffer is converted to a
string value so that it can use the <TT><FONT FACE="Courier">indexOf</FONT></TT>
method to locate the postscript header. Finally, an <TT><FONT FACE="Courier">if</FONT></TT>
statement uses the <TT><FONT FACE="Courier">indexOf</FONT></TT>
method to locate the header. It is called twice: The first time
it checks to see if any line begins with the necessary postscript
header characters, and the second time it handles the special
case at the beginning of the file where there is no newline character
preceding the header. If a header is found, the method exits with
a return value of <TT><FONT FACE="Courier">true</FONT></TT>; otherwise,
it exits with a return value of <TT><FONT FACE="Courier">false</FONT></TT>.
<H3><A NAME="OutputStreams">Output Streams</A></H3>
<P>
<I>Output streams</I> are the data streams generated by a producer
process. As mentioned previously, stream classes and their associated
methods are found in the <TT><FONT FACE="Courier">java.io</FONT></TT>
package. Every application or applet that uses streams must explicitly
import this package at the beginning of the code with a standard
<TT><FONT FACE="Courier">import</FONT></TT> statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.io.*;</FONT></TT>
</BLOCKQUOTE>
<P>
As with input streams, there are many different classes of output
streams. Each has its own purpose and can, of course, be extended
or customized as needed by the programmer. Table 8.4 is a complete
list of Java's output stream classes.<BR>
<P>
<CENTER><B>Table 8.4. Output stream classes.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>
</TD><TD WIDTH=365>Writes data to buffer to minimize the number of actual writes needed
</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">ByteArrayOutputStream</FONT></TT>
</TD><TD WIDTH=365>Writes data to an array of bytes</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">DataOutputStream</FONT></TT>
</TD><TD WIDTH=365>Writes data objects to a stream rather than bytes like most other output streams
</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">FileOutputStream</FONT></TT>
</TD><TD WIDTH=365>Writes data to a file</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">FilterOutputStream</FONT></TT>
</TD><TD WIDTH=365>Allows a stream to connect to subclasses of itself that can be used to filter the data
</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">OutputStream</FONT></TT>
</TD><TD WIDTH=365>Abstracts the superclass to all output stream classes
</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">PipedOutputStream</FONT></TT>
</TD><TD WIDTH=365>Writes data to a pipe connected to another process
</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">PrintStream</FONT></TT>
</TD><TD WIDTH=365>Writes formatted data to the user's screen
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Table 8.5 lists the three methods associated with output streams.
Just like any other method in Java, these methods can be extended
and customized as needed by the programmer.<BR>
<P>
<CENTER><B>Table 8.5. Output stream methods.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">write</FONT></TT></TD>
<TD WIDTH=227>Writes data to an output stream</TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">flush</FONT></TT></TD>
<TD WIDTH=227>Forces data to be written to pipe</TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">close</FONT></TT></TD>
<TD WIDTH=227>Closes an output stream</TD></TR>
</TABLE></CENTER>
<P>
<H4><TT><FONT FACE="Courier">write</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">write</FONT></TT> method is the most
basic of the output stream methods. This is the method an application
uses to write data to a stream. As with the <TT><FONT FACE="Courier">read</FONT></TT>
method, there are several variations associated with it.
<P>
All <TT><FONT FACE="Courier">write</FONT></TT> methods are based
on a <I>blocking write</I>, meaning that when a <TT><FONT FACE="Courier">write</FONT></TT>
method is called, it will not return until all the data to be
sent has been accepted or an exception occurs. When a call blocks,
execution cannot continue until the call completes. This can cause
problems if the programmer wants the application to continue if
the <TT><FONT FACE="Courier">write</FONT></TT> takes a significant
amount of time. The solution, as with the input stream methods,
is to use threads. If you put <TT><FONT FACE="Courier">write</FONT></TT>
into a separate thread, other executions can continue and the
thread with <TT><FONT FACE="Courier">write</FONT></TT> can take
as long as it needs to complete the transaction.
<P>
All <TT><FONT FACE="Courier">write</FONT></TT> methods also throw
the <TT><FONT FACE="Courier">IOException</FONT></TT> exception.
This must be handled in an application's code, either by using
a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding <TT><FONT FACE="Courier">throws</FONT></TT>
to the class declaration. The syntax of <TT><FONT FACE="Courier">write</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void write(int b);<BR>
</FONT></TT>void write(byte[] buffer);<BR>
<TT><FONT FACE="Courier">void write(byte[] buffer, int offset,
int length)</FONT></TT>
</BLOCKQUOTE>
<P>
The variations on <TT><FONT FACE="Courier">write</FONT></TT> almost
exactly mirror those for <TT><FONT FACE="Courier">read</FONT></TT>:
The first simply writes a single byte to the output stream, and
the second writes data to a buffer. The buffer is an array of
bytes. The last version also writes a buffer, but will start at
the indicated <TT><FONT FACE="Courier">offset</FONT></TT> into
the array and will only write <TT><FONT FACE="Courier">length</FONT></TT>
bytes. All cases of <TT><FONT FACE="Courier">write</FONT></TT>
have a return type of <TT><FONT FACE="Courier">void</FONT></TT>.
The only way to determine if an error occurred is to catch any
exceptions that are thrown. Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.io.*;<BR>
<BR>
</FONT></TT>public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
s to a file output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n,ix;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
for loop variables<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//use
try to catch file open exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new
FileOutputStream(args[0]);&nbsp;&nbsp;&nbsp;&nbsp; //open the
output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (n=0;
n &lt; 20; n++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//outer
for loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(ix=0x30; ix &lt; 0x7b; ix++) {&nbsp;&nbsp;&nbsp;&nbsp;//inner
for loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//use
try to catch IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.write(ix);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//write
character to output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error writing file &quot; + args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;//bottom
of inner loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{ <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.write('\n');
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//write newline char to output stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch
(IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error writing file &quot; + args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(3);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb
sp;&nbsp;&nbsp;&nbsp;&nbsp;//bottom
of outer loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
file open exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error opening file &quot; + args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(1);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">write</FONT></TT> is
used to write bytes to a file output stream. The filename itself
is passed as the first argument on the command line. A stream
object variable <TT><FONT FACE="Courier">s</FONT></TT> is declared
to be of type <TT><FONT FACE="Courier">FileOutputStream</FONT></TT>.
It is then initialized by opening the file output stream using
the <TT><FONT FACE="Courier">new</FONT></TT> operator. This results
in either the creation of a new file using the filename specified
on the command line or the rewriting of an existing file. This
results in the file being opened, so a file <TT><FONT FACE="Courier">IOException</FONT></TT>
exception must be caught at this point if the file is not accessible.
Next, two nested <TT><FONT FACE="Courier">while</FONT></TT> loops
are used to write a series of characters to the stream.
<P>
The inner loop writes all ASCII characters between <TT><FONT FACE="Courier">0</FONT></TT>
and <TT><FONT FACE="Courier">z</FONT></TT>. The body of this loop
starts out by calling the <TT><FONT FACE="Courier">write</FONT></TT>
method to write a single character to the output stream. <TT><FONT FACE="Courier">write</FONT></TT>
may return an <TT><FONT FACE="Courier">IOException</FONT></TT>
exception, so it is placed in a <TT><FONT FACE="Courier">try</FONT></TT>
statement. If <TT><FONT FACE="Courier">write</FONT></TT> fails,
a <TT><FONT FACE="Courier">catch</FONT></TT> statement writes
an error and the application aborts.
<P>
The outer loop simply causes the inner loop to be run 20 times.
However, after every inner loop completes, the outer loop writes
a <TT><FONT FACE="Courier">newline</FONT></TT> character to the
output stream. This makes the resulting output file more readable.
<P>
This example shows the basics for handling a simple output stream.
It shows how to open an output stream, write data to it, and set
up exception handling for both <TT><FONT FACE="Courier">open</FONT></TT>
and <TT><FONT FACE="Courier">write</FONT></TT>.
<H4><TT><FONT FACE="Courier">flush</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">flush</FONT></TT> method is used
to force any data buffered for the output stream to be written
to the output device. Some streams may be connected to slow or
even hung consumer processes, in which cases <TT><FONT FACE="Courier">write</FONT></TT>
may block for an overly extended period of time, if not forever.
In these situations, the <TT><FONT FACE="Courier">flush</FONT></TT>
method can be used to force Java to accept the data. Java may
simply buffer the data itself, waiting for the consumer process
to begin accepting data again or to die, thus closing the pipe.
Remember that if a <TT><FONT FACE="Courier">write</FONT></TT>
is blocked, the only way for an application to force the <TT><FONT FACE="Courier">flush</FONT></TT>
to occur is to call <TT><FONT FACE="Courier">flush</FONT></TT>
using a different thread. This is another example of why putting
a stream I/O call into its own thread is a good idea. The syntax
of <TT><FONT FACE="Courier">flush</FONT></TT> follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void flush();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">flush</FONT></TT> method also throws
the same <TT><FONT FACE="Courier">IOException</FONT></TT> exception
that <TT><FONT FACE="Courier">write</FONT></TT> does. This must
be handled in an application's code, either by using a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding throws to the class declaration, as in
the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void flushStream () {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;try {s.flush();}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//close
output stream<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error flushing output stream&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">flush</FONT></TT> is
used in a method that encapsulates the <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> functionality into
a single location. A <TT><FONT FACE="Courier">try</FONT></TT>
statement is used to catch any exceptions during the <TT><FONT FACE="Courier">close</FONT></TT>
process. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
will print an error message if an <TT><FONT FACE="Courier">IOException</FONT></TT>
is generated. (This example is based on <TT><FONT FACE="Courier">s</FONT></TT>
being a stream object that has already been opened as a variable
global to this method.)
<H4><TT><FONT FACE="Courier">close</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">close</FONT></TT> method is virtually
identical to the <TT><FONT FACE="Courier">close</FONT></TT> used
for input streams. It is used to close an output stream that an
application or applet no longer needs. Java will automatically
close output streams when an application or applet exits, which
is why a <TT><FONT FACE="Courier">close</FONT></TT> statement
has not been used in the preceding stream examples. However, it
is good programming practice to close any resources an application
no longer needs. The syntax of <TT><FONT FACE="Courier">close</FONT></TT>
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void close();</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">close</FONT></TT> method throws the
same <TT><FONT FACE="Courier">IOException</FONT></TT> exception
that <TT><FONT FACE="Courier">write</FONT></TT> and <TT><FONT FACE="Courier">flush</FONT></TT>
do. This must be handled in an application's code, either by using
a <TT><FONT FACE="Courier">try</FONT></TT>/<TT><FONT FACE="Courier">catch</FONT></TT>/<TT><FONT FACE="Courier">finally</FONT></TT>
structure or by adding a <TT><FONT FACE="Courier">throw</FONT></TT>
statement to the class declaration. The following is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void closeStream () {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;try {s.close();}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//close
output stream<BR>
&nbsp;&nbsp;&nbsp;catch (IOException e) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Unknown
IO error closing output stream&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">close</FONT></TT> is
used in a method that encapsulates the <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> functionality into
a single location. A <TT><FONT FACE="Courier">try</FONT></TT>
statement is used to catch an exception during the <TT><FONT FACE="Courier">close</FONT></TT>
process. The <TT><FONT FACE="Courier">catch</FONT></TT> statement
will print an error message if an <TT><FONT FACE="Courier">IOException</FONT></TT>
exception is generated. (This example is based on <TT><FONT FACE="Courier">s</FONT></TT>
being a stream object that has already been opened as a variable
global to this method.)
<H3><A NAME="SummaryofStreams">Summary of Streams</A></H3>
<P>
Streams are Java's way of reading and writing data to entities
outside an application, such as files, networks, devices, or other
processes. All streams in Java consist of a flow of 8-bit bytes.
Some stream classes allow the writing of other object types, but
internally they simply convert these objects to bytes. Streams
can be broken into two main types: input streams and output streams.
<P>
Input streams accept data from an external source. Processes that
accept input streams are known as consumers. You can use several
methods with input streams: <TT><FONT FACE="Courier">read</FONT></TT>,
<TT><FONT FACE="Courier">skip</FONT></TT>, <TT><FONT FACE="Courier">markSupported</FONT></TT>,
and <TT><FONT FACE="Courier">close</FONT></TT> work with all input
stream types; and <TT><FONT FACE="Courier">available</FONT></TT>,
<TT><FONT FACE="Courier">mark</FONT></TT>, and <TT><FONT FACE="Courier">reset</FONT></TT>
only work with some input stream types. The <TT><FONT FACE="Courier">read</FONT></TT>
method is used to read data from an input stream. <TT><FONT FACE="Courier">skip</FONT></TT>
is used to skip over information in the input stream to get to
data farther on. <TT><FONT FACE="Courier">close</FONT></TT> simply
closes an input stream. The <TT><FONT FACE="Courier">available</FONT></TT>
method can be used to determine if more data is available in an
input stream, but the results returned by this method are not
always accurate. The <TT><FONT FACE="Courier">markSupported</FONT></TT>
method is used to determine if a particular stream supports the
<TT><FONT FACE="Courier">mark</FONT></TT><I>/</I><TT><FONT FACE="Courier">reset</FONT></TT>
methods. These methods are used to mark a particular location
in a stream and reset the stream back to that location.
<P>
Output streams produce data for an external destination. Processes
that produce output streams are known as <I>producers</I>. You
can use several methods with output streams: <TT><FONT FACE="Courier">write</FONT></TT>,
<TT><FONT FACE="Courier">flush</FONT></TT>, and <TT><FONT FACE="Courier">close</FONT></TT>.
The <TT><FONT FACE="Courier">write</FONT></TT> method is used
to write data to an output stream. <TT><FONT FACE="Courier">flush</FONT></TT>
is used to force data to be written that may be buffered. <TT><FONT FACE="Courier">close</FONT></TT>
simply closes an output stream.
<P>
By using input and output streams, Java applications and applets
can communicate with the rest of the world.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></A>
</H2>
<P>
This chapter examines the final pieces of the Java programming
language: threads, exceptions, and streams.
<P>
The section on threads covers concurrent execution of multiple
sections of code. The methods to create, initialize, start, stop,
and destroy a thread are also discussed. Threads are a powerful
part of the Java programming language, and a programmer who becomes
versed in their use can write more powerful, robust, and user-friendly
programs.
<P>
The section on exceptions covers Java's use of exceptions in place
of the more normal return-type error code. Exceptions provide
a more robust and extensible way to do error handling. The methods
for catching and handling an exception are explained, as well
as generation of new, customized exceptions. Because exceptions
are simply another object in Java, all the benefits regarding
code reuse and customization apply.
<P>
Finally, the section on streams covers Java's use of this construct
to communicate with the outside world. Streams are a sequence
of bytes. By using such a simple data format, Java applications
do not have to have specific knowledge of where data is coming
from or being written to. This in turn lends itself to simpler,
more reusable code. The methods to open, read, write, and close
a data stream are covered, in addition to more complex concepts
such as rereading a part of a stream. Streams in Java provide
a flexible-but above all, standardized-method for external communication.
<P>
This concludes the basics of Java programming. With the tool sets
covered to this point, you are now ready to create Java applications
that will serve your needs. Part IV, &quot;The Java Application
Programming Interface,&quot; covers the class libraries in Java.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch7.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch7.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch9.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch9.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
