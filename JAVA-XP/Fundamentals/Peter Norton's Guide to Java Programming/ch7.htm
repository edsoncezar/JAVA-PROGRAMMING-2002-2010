<HTML>

<HEAD>
   <TITLE>Chapter 7 -- Building Objects</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336494&ad_type=POPUP&category=net&id=4ef8f00764295c2d5fa7d1fea4ce2626";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 7</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Building Objects</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#AnIntroductiontoClasses" >An Introduction to Classes</A>
<UL>
<LI><A HREF="#Classes" >Classes</A>
<LI><A HREF="#ClassVariables" >Class Variables</A>
<LI><A HREF="#ClassMethods" >Class Methods</A>
<LI><A HREF="#MethodModifiers" >Method Modifiers</A>
<LI><A HREF="#DeclaringMethodSecurityandAccessibil" >Declaring Method Security and Accessibility</A>
<LI><A HREF="#OverloadingMethods" >Overloading Methods</A>
</UL>
<LI><A HREF="#WorkingwithObjects" >Working with Objects</A>
<UL>
<LI><A HREF="#CreatingandDestroyingObjects" >Creating and Destroying Objects</A>
<LI><A HREF="#TheConstructorMethod" >The Constructor Method</A>
</UL>
<LI><A HREF="#Packages" >Packages</A>
<UL>
<LI><A HREF="#DeclaringaPackage" >Declaring a Package</A>
<LI><A HREF="#AccessingOtherPackages" >Accessing Other Packages</A>
<LI><A HREF="#PackageNamingConventions" >Package-Naming Conventions</A>
<LI><A HREF="#TheCLASSPATHEnvironmentVariable" >The CLASSPATH Environment Variable</A>
<LI><A HREF="#SummaryofPackages" >Summary of Packages</A>
</UL>
<LI><A HREF="#Inheritance" >Inheritance</A>
<LI><A HREF="#DeclaringInheritance" >Declaring Inheritance</A>
<UL>
<LI><A HREF="#UsingInheritance" >Using Inheritance</A>
<LI><A HREF="#SummaryofInheritance" ><I>Summary of Inheritance</I></A>
</UL>
<LI><A HREF="#Interfaces" >Interfaces</A>
<UL>
<LI><A HREF="#DeclaringanInterface" >Declaring an Interface</A>
<LI><A HREF="#Modifiers" >Modifiers</A>
<LI><A HREF="#UsinganInterface" >Using an Interface</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
<I>Objects</I> can be almost anything in Java. Everything in the
language is designed to use small, somewhat self-contained pieces
of code, or objects. Objects use the fundamentals such as declarations
and expressions to do the real work of the language. The idea
is to use these pieces of code in appropriate ways so you don't
have to keep rewriting them for each use. This is why it's called
&quot;object-oriented&quot; programming. (This concept is discussed
in <A HREF="ch1.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch1.htm" >Chapter 1</A>, &quot;Introducing Java.&quot;)
<P>
The smallest logical unit of Java is the object. Everything else
is merely a grouping of objects on a larger scale. This chapter
describes how to create and use objects. It explores the structure
of Java in greater detail than the previous chapter. <A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >Chapter 6</A>,
&quot;Fundamentals of the Java Language,&quot; covers the smallest
parts of objects, such as primitive data types and control flow
keywords; this chapter shows you how to put the small pieces to
work in a structural framework.
<P>
To create applications with Java, it is essential to understand
how the parts fit together. Here you'll explore the grouping of
objects into classes. Classes are given characteristics through
inheritance. <I>Class libraries</I> are groups of classes. <I>Packages</I>
are groups of class libraries. <I>Methods</I> are functions that
perform activities within classes. Methods can have templates
managed by interfaces.
<P>
These are abstract concepts. There is tremendous power for application
flexibility in Java, but it is easy to get lost in terminology.
This chapter is full of examples to make the concepts concrete
and easy to understand. A conceptual example involving an apartment
building is used throughout the chapter to demonstrate the structure
of Java. 
<P>
By the end of the chapter you should have a good idea of the relationships
among the parts of Java and how to use them effectively.
<H2><A NAME="AnIntroductiontoClasses"><FONT SIZE=5 COLOR=#Ff0000>An
Introduction to Classes</FONT></A></H2>
<P>
Classes are made up of objects. This is easy to understand if
you are familiar with object-oriented programming. If you are
not, then what is an object? Think of an object as a unit that
can be made up of other smaller units. Think of an apartment building,
for example. It is made up of apartments. Each apartment probably
has doors, windows, a kitchen, a bedroom, and a bathroom, among
other things. Each apartment is a <I>unit.</I> Sometimes an apartment
building is referred to as a <I>five-unit apartment building.</I>
<P>
The apartments do not all have to be exactly alike. Some may be
on the first floor, some may be in the basement, some may face
south, and some may be recently refurbished. One apartment may
have two bedrooms and another, just down the hall, only one. Each
apartment has its own mail slot with an individual address. Even
though the apartments are not all identical, they are all apartments.
<P>
Apartments are the <I>objects </I>in this example. Even though
they have smaller parts and are not identical, conceptually each
is a unit. The apartment building is the <I>class.</I> It is made
up of objects, or units. These objects are not all exactly alike,
but they have enough similar characteristics that they can be
<I>classed</I> together.
<P>
Another term useful in object-oriented programming is <I>instance.</I>
Apartment building 3 is an <I>instance,</I> or actual apartment
building. It is real. An instance is one specific object within
the class of objects. 
<P>
Each apartment has more interesting information. One might be
empty. In this case, the empty status is the apartment's <I>state</I>.
A rental-application program could keep track of available apartments
on the basis of this state. A <I>method</I> would be associated
with testing for the state of this apartment.
<P>
Now let's take these ideas to another level of abstraction. Have
you ever driven by a huge apartment complex, say, outside a university?
The complex is made up of apartment buildings, which are made
up of apartment units. The whole complex can be referred to as
Countrybrook or something else equally romantic and descriptive.
The complex, then, is the conceptual gathering together of the
apartment buildings in the area even though each apartment building
is slightly different, with different addresses and other characteristics
that make them unique.
<P>
The apartment complex is an example of one of the classes in a
<I>class library.</I> A class library is a set of classes. Class
libraries group classes that perform similar functions but are
dissimilar enough to warrant their own classes. Recall that the
apartment complex is one class. Suppose right down the street
is a mall. The mall is made up of smaller units-stores. The mall
is another class in the class library. It is a building, but it
has quite a different structure and function than the apartment
building. It could be set up as its own class.
<P>
Java comes with a set of class libraries that handle many tasks,
such as input/output, screen painting, and mouse clicks. The class
libraries of Java are its heart and strength. In fact, this is
such an important subject that five chapters in this book are
devoted to it. See Part IV, &quot;The Java Application Programming
Interace,&quot; for more information on the Java class libraries.
<P>
At this point it is important to begin to understand the concept
of objects, libraries, class libraries, and packages. These concepts
are the structure of Java.
<H3><A NAME="Classes">Classes</A></H3>
<P>
Classes are made up of many different parts, such as methods and
variables. Think back to the apartment example. The class is a
template for information about a group of things, even though
the individual things may be somewhat different. Classes also
contain methods for obtaining information about the state of a
member. Each real member of a class is referred to as an <I>instance.</I>
<P>
<I>Methods</I> are functions that report back a status. Methods
can report back with a value such as an integer or a boolean.
Methods can be called by other classes outside their own immediate
class.
<P>
A <I>superclass </I>is the top-level class of every application.
In Java, it is automatically the <TT><FONT FACE="Courier">Object</FONT></TT>
class. This means that if a class does not implicitly declare
its superclass, or next higher class level, then it is a subclass
of <TT><FONT FACE="Courier">Object</FONT></TT><I>.</I> (Declarations
are discussed in the section &quot;Declaring a Class.&quot;) Every
instance of a class reimplements the definitions and logic created
by the superclass.
<P>
<I>Subclasses</I> extend the superclass and create a new variation
of the class. They inherit the characteristics of the preceding
class.
<H4>Declaring a Class</H4>
<P>
A class must have a valid identifier name; it can begin with an
alphabetic character, the underscore, or the dollar sign. When
you think of an appropriate name, use this syntax for declaring
a class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class <I>MySuperClass.MyClass </I>{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// class body<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The class body is declared within curly braces. Notice that the
name of the class has the superclass and <TT><FONT FACE="Courier">.</FONT></TT>
before the class name. (This is also how inheritance, discussed
subsequently, is shown.) This is how the compiler knows where
to go for information on the class.
<P>
The name associated with a class has the same restrictions that
identifier names do; that is, they can be named anything as long
as they begin with an alphabetic character, a dollar sign, or
an underscore. By convention, however, a class name should begin
with a capital letter. This makes the class easily distinguishable
from methods, variables, and so on. Java itself follows this convention;
it is highly recommended.
<H4>Overview of Application and Applet Classes</H4>
<P>
Java produces two program types: application and applet. <I>Applications</I>
are stand-alone and can be run directly from the command line.
<I>Applets</I> require an external program to provide an interface
to the user. Web browsers and the Java Developer's Kit (JDK) applet
viewer are examples of interfaces that support applets.
<P>
Applets are also more restricted in Java in what they can do.
Because Web browsers are a common method for accessing applets,
what the applet can do to the local system is a security concern.
Therefore, applets are prevented from reading or writing local
files to disk, accessing memory directly, and opening connections
to other applets that do not reside on the same server as the
current applet.
<P>
This provides basic security, such as preventing an applet on
an unknown Web page from automatically getting a copy of your
password file and sending it to the author of the applet. However,
Java allows some of these restrictions to be reduced. Using the
applet viewer, you can allow an applet to have read and write
access to a particular directory or set of directories. This is
potentially dangerous and should be used only with caution.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
The actual mechanism that provides security for applets is in the client application running the applet (for example, your browser or the applet viewer). This mechanism is usually the applet security manager. For more information on the applet security 
manager, refer to <A HREF="ch5.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch5.htm" >Chapter 5</A>, &quot;Java Tools and the JDK: A Primer.&quot; 
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Applications do not have these restrictions. Users running Java
applications are allowed to access any files, memory locations,
or network resources that they normally could.
<H4>Application Classes</H4>
<P>
Java applications are true applications, like those developed
by any other language, such as C or C++. The idea of Java applets
is popular at this writing, but Java applications have received
little fanfare. Sun Microsystems is trying to change that perception.
Sun anticipates the Java programming language to replace C++ as
the development language of choice, for several reasons. 
<P>
One reason is that it is a more streamlined language but still
offers much of the power of C++. Java was developed by specifications
in one organization; it has not just grown in an ad hoc manner
like many other programming languages. Therefore, parts of Java
fit together nicely. Java has eliminated some of the redundancy
found in C++.
<P>
Another reason is that Java is platform independent with regard
to programming and maintenance. An organization can write a Java
application that will run on <I>every</I> platform for which a
Java interpreter has been written. This is a huge win for companies
that must support multiple platforms.
<P>
Think about the way companies run today. They probably support
multiple platforms internally. They may want to sell applications
to run externally on a client base that supports multiple platforms
as well. It is not a rare occurrence to find users with multiple
terminals on desks to support and access a variety of applications.
Imagine being able to write one application that runs on a company's
pcs, Macintoshes, mainframes, UNIX systems, and whatever else
is available. You can do this with Java.
<P>
So, you ask, what is the drawback? The current problem is speed.
Java can run significantly slower than a natively compiled application
that converts source code into machine code. Performance relies
on many factors. However, it is difficult for an interpreted language
to compete with natively compiled code.
<P>
Performance issues will probably be overcome in the near future
with optimized Java interpreters, or just-in-time compilers, which
are slowly becoming available. There is also talk of writing native
compilers that will allow code to reside on local systems. (Entrepreneurs,
anyone?) The problem with this solution is the loss of the instant-updating
features of Java. It's also possible that the performance hit
will be acceptable because of the niceties of Java portability.
Giving up the performance of machine code for the development
ease of a higher-level language like C code was also deemed acceptable,
although some purists complained. Now is the time to move to the
next higher level of language instead of lamenting the loss of
C.<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
A software toolkit for Java that includes a just-in-time compiler is Symantec Caf&eacute;. Many other software companies plan to include just-in-time compilers as well. Who knows-maybe the mainstream integration of Java into operating systems will bring 
with it the speedy just-in-time compilers.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Java applications are similar in structure to applets. The only
major differences are method of declaration and program invocation.
We have seen many examples of declarations. It may not have been
obvious how the program began execution, though; this is handled
by the method <TT><FONT FACE="Courier">main</FONT></TT><I>.</I>
<H4><TT><FONT FACE="Courier">main</FONT></TT></H4>
<P>
Every Java application must define one method named <TT><FONT FACE="Courier">main</FONT></TT><I>,</I>
which is similar to <TT><FONT FACE="Courier">main</FONT></TT>
in C and C++. When a Java application is invoked, the Java interpreter
looks for the method named <TT><FONT FACE="Courier">main</FONT></TT>
and begins execution there. If <TT><FONT FACE="Courier">main</FONT></TT>
is not declared, the interpreter will complain.
<P>
<TT><FONT FACE="Courier">main</FONT></TT> methods must always
be declared public. It would be impossible for a program outside
Java to even start the Java application if <TT><FONT FACE="Courier">main</FONT></TT><I>
</I>were not declared public.
<P>
The <TT><FONT FACE="Courier">main</FONT></TT> method itself must
be declared in a fixed format:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static void main (String args[])
{<BR>
&nbsp;&nbsp;...body of main...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The public declaration enables <TT><FONT FACE="Courier">main</FONT></TT>
to be accessed from external programs. <TT><FONT FACE="Courier">static</FONT></TT>
indicates that this method cannot be modified by subclasses. <TT><FONT FACE="Courier">void</FONT></TT>
means that this method does not return a value of any kind. <TT><FONT FACE="Courier">main</FONT></TT>
is the required name of the method. <TT><FONT FACE="Courier">(String
args[])</FONT></TT> indicates that <TT><FONT FACE="Courier">main</FONT></TT>
will have command-line arguments consisting of an array of type
<TT><FONT FACE="Courier">String</FONT></TT>. This array contains
the command-line arguments specified when this application was
started.
<P>
Here is the standard Hello World! Java application:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class HelloWorld {<BR>
&nbsp;&nbsp;public static void main (String args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Hello World!&quot;);
<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
To compile the example, type the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac HelloWorld.java</FONT></TT>
</BLOCKQUOTE>
<P>
When the compiler finishes, invoke the Java interpreter as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java HelloWorld</FONT></TT>
</BLOCKQUOTE>
<P>
The output from the application should be as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Hello World!</FONT></TT>
</BLOCKQUOTE>
<H4>Applet Classes</H4>
<P>
Applets are the most famous aspect of the Java programming language
at this time. Java is associated with the World Wide Web; Java
applets are powerful in that they can take a fairly static Web
page and turn it into a highly interactive, animated multimedia
extravaganza.
<P>
Applets in Java rely on an external program to interface with
the user. They cannot be run by themselves. The Java-enabled Web
browser and the applet viewer that comes with the Java Developer's
Kit are two common examples of these programs.
<P>
Applets are an extension of an existing Java class, <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT><I>.</I>
An applet is really an example of a subclass. To declare an applet,
you again use the <TT><FONT FACE="Courier">class</FONT></TT> keyword,
but the modifier <TT><FONT FACE="Courier">extends</FONT></TT>
is added. This notifies the compiler that an applet is a subclass
of another class, in this case a subclass of <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>.
Here is an example declaration:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;&nbsp;&nbsp;&nbsp;&nbsp;//imports
the class libraries*****library*****<BR>
import java.awt.image.*;<BR>
import java.applet.*;<BR>
<BR>
public<BR>
class HelloWorldApplet extends Applet {<BR>
&nbsp;&nbsp;&nbsp;public void paint (Graphics g){<BR>
&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;Hello World!&quot;,
10, 10);<BR>
&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
After compiling the source code for the applet, you will need
to create an HTML document that will be used by your browser or
the applet viewer to display the applet. Here is a sample HTML
document for the HelloWorldApplet program:
</BLOCKQUOTE>
<BLOCKQUOTE>
&lt;HTML&gt;<BR>
&lt;HEAD&gt;<BR>
&lt;TITLE&gt;HelloWorldApplet&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;APPLET CODE=&quot;HelloWorldApplet&quot; WIDTH=300 HEIGHT=300&gt;&lt;/APPLET&gt;
<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;
</BLOCKQUOTE>
<P>
Applets generally must be more &quot;bulletproof&quot; than applications
because of the environment in which they run. Not only must they
run, but they must be able to handle events like mouse clicks,
repaints, suspensions, and others. Many things appear on the surface
to be handled by the browser but in reality are handled by applet
code.
<P>
An example of this is the following sequence of events: an applet
prints an image on the screen. The user brings up another window
that partially obscures the original image, and then removes the
new window. Who is responsible for repainting the applet image?
It is not the browser, but the applet. The browser will inform
the applet that a repaint is needed, but it is then up to the
applet to actually do the repaint or take other action.
<P>
Applets begin execution differently than applications. Applications
begin program execution by calling method <TT><FONT FACE="Courier">main</FONT></TT><I>.
</I>Applets instead use methods <TT><FONT FACE="Courier">init</FONT></TT>
and <TT><FONT FACE="Courier">start</FONT></TT><I>. </I>The browser
will invoke the <TT><FONT FACE="Courier">init</FONT></TT> method
followed by the <TT><FONT FACE="Courier">start</FONT></TT> method
every time a Java applet is started. These do not have to be explicitly
declared in the applet.
<P>
Look again at the <TT><FONT FACE="Courier">HelloWorldApplet</FONT></TT>
example. Notice that there is no call to invoke <TT><FONT FACE="Courier">paint</FONT></TT>,
yet the screen was painted anyway. Many things happen behind the
scenes in a Java applet. This is an example of an applet beginning
execution without an explicit declaration of methods <TT><FONT FACE="Courier">init</FONT></TT>
and <TT><FONT FACE="Courier">start</FONT></TT>, instead relying
on the default <TT><FONT FACE="Courier">init</FONT></TT> and <TT><FONT FACE="Courier">start</FONT></TT>
methods<I>.</I> The default <TT><FONT FACE="Courier">start</FONT></TT>
method automatically calls the <TT><FONT FACE="Courier">repaint</FONT></TT><I>
</I>method, which among other duties,<I> </I>invokes the <TT><FONT FACE="Courier">paint</FONT></TT><I>
</I>method. <TT><FONT FACE="Courier">paint</FONT></TT> must be
explicitly declared for anything to be written to the screen.
<P>
This summarizes the series of events that occur when a viewer
invokes an applet. It is important to understand this sequence
if any of the applet startup methods are overridden. The applet
will not execute to expectations if anything is left out. When
a viewer calls an applet, first the applet calls <TT><FONT FACE="Courier">init</FONT></TT>.
This is either explicitly declared or it is the default. The viewer
then calls <TT><FONT FACE="Courier">start</FONT></TT>, which is
once again either implicitly or explicitly declared. Within <TT><FONT FACE="Courier">start</FONT></TT><I>
</I>is a call to <TT><FONT FACE="Courier">repaint</FONT></TT>,
which schedules a call to <TT><FONT FACE="Courier">paint</FONT></TT><I>.</I>
The implicit <TT><FONT FACE="Courier">paint</FONT></TT> method
does not write anything to the screen, and therefore the method
must be overridden.
<H4><TT><FONT FACE="Courier">init</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">init</FONT></TT><I> </I>method is
only called the first time an applet is loaded into a viewer.
One-time-only initializations take place in the call to method
<TT><FONT FACE="Courier">init</FONT></TT><I>. </I>This is also
a good place to get command-line arguments from the HTML page
from which the applet was invoked. (Command-line arguments are
discussed in the &quot;Declaring a Package&quot; section.)
<P>
The <TT><FONT FACE="Courier">init</FONT></TT><I> </I>method has
a fixed format. It always must be named <TT><FONT FACE="Courier">init</FONT></TT>,
have a return type of <TT><FONT FACE="Courier">void</FONT></TT>,
be declared public, and have no arguments. An example of the <TT><FONT FACE="Courier">init</FONT></TT>
method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void init () {<BR>
&nbsp;&nbsp;&nbsp;counter = 0;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The only action in this example of an <TT><FONT FACE="Courier">init</FONT></TT>
method is to set the variable <TT><FONT FACE="Courier">counter</FONT></TT><I>
</I>to zero.
<P>
An <TT><FONT FACE="Courier">init</FONT></TT> method is not required.
It actually overrides an existing <TT><FONT FACE="Courier">init</FONT></TT>
method in class <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>;
this is why the name, return type, and other information are fixed.
<H4><TT><FONT FACE="Courier">start</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">start</FONT></TT><I> </I>method is
called after the <TT><FONT FACE="Courier">init</FONT></TT> method
the first time an applet is loaded into a viewer or if an applet
has been suspended and must be restarted. If the compiler can't
find a <TT><FONT FACE="Courier">start</FONT></TT><I> </I>method
explicitly declared in the applet, it will default to the <TT><FONT FACE="Courier">start</FONT></TT>
method in <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>.
An example of the <TT><FONT FACE="Courier">start</FONT></TT> method
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void start() {<BR>
&nbsp;&nbsp;run = true;<BR>
&nbsp;&nbsp;while (run == true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;count += 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();&nbsp;&nbsp;&nbsp;&nbsp;//note
that repaint is explicitly called<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(1000); }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException e) {}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This <TT><FONT FACE="Courier">start</FONT></TT> method sets variable
<TT><FONT FACE="Courier">run</FONT></TT> to <TT><FONT FACE="Courier">true</FONT></TT>
and then enters a <TT><FONT FACE="Courier">while</FONT></TT> loop
that will run as long as <TT><FONT FACE="Courier">run</FONT></TT>
is equal to <TT><FONT FACE="Courier">true</FONT></TT>. The loop
increments the counter that was initially set to zero in the <TT><FONT FACE="Courier">init</FONT></TT>
method. The <TT><FONT FACE="Courier">repaint</FONT></TT> call
causes the screen to be repainted after every increment. The <TT><FONT FACE="Courier">try</FONT></TT>
and <TT><FONT FACE="Courier">catch</FONT></TT> lines cause the
program to sleep for 1,000 milliseconds after every counter increment.
(<TT><FONT FACE="Courier">try</FONT></TT> and <TT><FONT FACE="Courier">catch</FONT></TT>
are exceptions covered in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>, &quot;Tying
It All Together: Threads, Exceptions, and More.&quot;)
<P>
A <TT><FONT FACE="Courier">start</FONT></TT> method is not required.
Like <TT><FONT FACE="Courier">init</FONT></TT>, it actually overrides
a default <TT><FONT FACE="Courier">start</FONT></TT> method provided
by the <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>
library. It also has a fixed format, as shown in the previous
example.
<H4><TT><FONT FACE="Courier">stop</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">stop</FONT></TT><I> </I>method is
called whenever an applet must be stopped or suspended. Without
the method the applet continues to run, consuming resources even
when the user has left the page on which the applet is located.
There may be times when continued execution is desirable, but
in general it is not. An example of the <TT><FONT FACE="Courier">stop</FONT></TT>
method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void stop() {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;run = false;
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
This <TT><FONT FACE="Courier">stop</FONT></TT> method sets the
<TT><FONT FACE="Courier">run</FONT></TT> variable to <TT><FONT FACE="Courier">false</FONT></TT>.
This causes the loop in the <TT><FONT FACE="Courier">start</FONT></TT>
method from the previous example to exit the loop and fall through
the end of the method. The result is that the application stops
running. Note that only the <TT><FONT FACE="Courier">run</FONT></TT>
variable is changed.
<P>
Just as with <TT><FONT FACE="Courier">init</FONT></TT> and <TT><FONT FACE="Courier">start</FONT></TT>,
a <TT><FONT FACE="Courier">stop</FONT></TT> method is not required.
It overrides a default <TT><FONT FACE="Courier">stop</FONT></TT>
method provided by the <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>
library. The <TT><FONT FACE="Courier">stop</FONT></TT> method
has a fixed format declaration, as shown in the previous example.
<H4><TT><FONT FACE="Courier">paint</FONT></TT></H4>
<P>
The method <TT><FONT FACE="Courier">paint</FONT></TT> is used
to paint or repaint the screen. It is automatically called by
<TT><FONT FACE="Courier">repaint</FONT></TT> or can be called
explicitly by the applet. The applet calls <TT><FONT FACE="Courier">paint</FONT></TT>
when the browser requires a repaint, such as when an obscured
applet is brought to the front of the screen again.
<P>
<TT><FONT FACE="Courier">paint</FONT></TT> has a fixed format.
It always must be named <TT><FONT FACE="Courier">paint</FONT></TT>,
have a return type of <TT><FONT FACE="Courier">void</FONT></TT>,
and be declared public. However, unlike <TT><FONT FACE="Courier">init</FONT></TT>
and <TT><FONT FACE="Courier">start</FONT></TT>, it does have an
argument, of type <TT><FONT FACE="Courier">Graphics</FONT></TT>.
This is a predefined type in Java that contains many of the methods
for writing graphics to the screen. Here is an example of a <TT><FONT FACE="Courier">paint</FONT></TT>
method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawstring(&quot;counter = &quot; +
counter, 10, 10);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method writes the value of <TT><FONT FACE="Courier">counter</FONT></TT>
to the screen each time it is invoked. Combine this with the <TT><FONT FACE="Courier">start</FONT></TT>
and <TT><FONT FACE="Courier">repaint</FONT></TT> methods. The
<TT><FONT FACE="Courier">start</FONT></TT> method increments <TT><FONT FACE="Courier">counter</FONT></TT><I>
</I>and then calls <TT><FONT FACE="Courier">repaint</FONT></TT>.
The screen displays the new value of <TT><FONT FACE="Courier">counter</FONT></TT>
every time it is updated.
<P>
The compiler does not require a <TT><FONT FACE="Courier">paint</FONT></TT>
method. It overrides a default method provided by <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>.
However, if you do not override it, you will not be able to write
anything to the screen.
<H4>An Example of <TT><FONT FACE="Courier">start</FONT></TT>,
<TT><FONT FACE="Courier">init</FONT></TT>, <TT><FONT FACE="Courier">paint</FONT></TT>,
and <TT><FONT FACE="Courier">stop</FONT></TT></H4>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.Graphics;<BR>
public class Counter extends java.applet.Applet {<BR>
&nbsp;&nbsp;int counter;<BR>
&nbsp;&nbsp;boolean run;<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;counter = 0;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;run = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (run == true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try { Thread.sleep(1000);
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(InterruptedException
e) {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run = false;<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(&quot;counter = &quot; +
counter, 10, 10);<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method will not yet run in this form; we still need threads
and exceptions (discussed in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>).
<H4>Modifiers</H4>
<P>
<I>Modifiers</I> alter certain aspects of classes. They are specified
in the declaration of a class before the class name. Several modifiers
have been used in the examples in this chapter.
<P>
Class modifiers are used to specify two aspects of classes: access
and type. <I>Access modifiers</I> are used to regulate internal
and external use of classes. <I>Type modifiers</I> declare the
implementation of a class. A class can be used as either a template
for subclasses or a class in and of itself. (These modifiers are
subsequently described in detail.)
<H4><TT><FONT FACE="Courier">Declaring Class Security</FONT></TT>
</H4>
<P>
Classes can be declared with security so they can be accessed
outside their package by using the <TT><FONT FACE="Courier">public</FONT></TT>
statement in the class declaration. If no explicit statement is
made at declaration time, the class may be accessed only from
within its own package. A compile error is generated if any other
security modifier is used in the declaration, such as private
or protected, which are reserved for methods.
<P>
The following are examples of declaring class security:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class <I>classname</I> {&nbsp;&nbsp;&nbsp;&nbsp;//able
to be accessed outside of<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//own
package<BR>
}<BR>
class <I>classname</I> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//only
able to be accessed within<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//own
package<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This is another example of code reuse in the same or different
applications in Java. Java's structure makes this easy and allows
for some protection if necessary.
<H4><TT><FONT FACE="Courier">Class Types: Abstract or Default</FONT></TT>
</H4>
<P>
There are only two types available to classes: abstract or default.
Abstract classes must be explicitly declared.
<P>
The <TT><FONT FACE="Courier">abstract</FONT></TT> modifier is
used to create template classes. These are classes that normally
are used to provide a superclass for other classes. An abstract
class can contain such things as variable declarations and methods
but cannot contain code for creating new instances.
<P>
An abstract class can also contain abstract methods. These are
methods that define return type, name, and arguments but do not
include any method body. Subclasses are then required to implement
those abstract methods in which they supply a body. If an abstract
class contains only methods and no variables, it is better to
use interfaces (covered in the &quot;Interfaces&quot; section).
Here is an example of an abstract class declaration:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract class AClass {<BR>
&nbsp;&nbsp;&nbsp;int globalVariable;<BR>
&nbsp;&nbsp;&nbsp;abstract void isBlack (boolean) {<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This abstract class declares a global variable called <TT><FONT FACE="Courier">globalVariable</FONT></TT><I>
</I>and defines a template for a method called <TT><FONT FACE="Courier">isBlack</FONT></TT><I>.</I>
Notice that there is no body for the <TT><FONT FACE="Courier">isBlack</FONT></TT>
method. That is left to subclasses of <TT><FONT FACE="Courier">AClass</FONT></TT>.
The subclasses must implement <TT><FONT FACE="Courier">isBlack</FONT></TT>
or they will receive a compile-time error.
<H3><A NAME="ClassVariables">Class Variables</A></H3>
<P>
<A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >Chapter 6</A> discusses variables in a detached,
stand-alone manner. This section shows how variables are used
in a class.
<P>
Variables are used in classes to hold data to be used later. Good
programming form places variables immediately following the class
declaration statement, as in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ShowVariables {<BR>
&nbsp;&nbsp;&nbsp;int Int1, Int2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
some integer variables<BR>
&nbsp;&nbsp;&nbsp;int Int3 = 37;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
and initialize a variable<BR>
&nbsp;&nbsp;&nbsp;char OneChar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
a character type variable;<BR>
&nbsp;&nbsp;&nbsp;float FloatArray[];&nbsp;&nbsp;//declare single
dimensional array of floating-point<BR>
&nbsp;&nbsp;&nbsp;boolean AmITrue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declare
boolean variable<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//here
would be code to do something...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The variable declaration statements in this example just set up
the variables to be used in this class. There are no methods or
expressions set up to do anything at this point.
<P>
Every class can have variables associated with it. Variables fall
into two categories: those that are particular to an instance,
called <I>instance variables</I><TT><FONT FACE="Courier">,</FONT></TT>
and those that are global to all instances of a particular class,
known as <I>class variables</I>. The use of the variable determines
its type.
<H4>Instance Variables</H4>
<P>
Instance variables exist only for a particular instance of an
object. This means that different instances of a given class each
have a variable of the same name, but Java stores different values
for that variable in different places in memory. Each of these
instance variables is manipulated individually. If an instance
goes away, so does the variable. You can access instance variables
from other instances, but the variable itself exists only in a
particular instance.
<P>
Instance variables have been shown in the examples so far in this
chapter. They are declared after a class declaration but before
method declarations. Every instance of that class has a copy of
this variable and can modify it as needed without affecting any
other instance copies of the variable. Here is an example of an
instance variable declaration:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ACat {<BR>
&nbsp;&nbsp;&nbsp;String[] name;<BR>
&nbsp;&nbsp;&nbsp;String[] color;<BR>
&nbsp;&nbsp;&nbsp;int weight;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Here every instance of class <TT><FONT FACE="Courier">ACat</FONT></TT>
has a name, color, and weight variable used to store information
about a particular cat. If you had two cats and wanted to put
them on your Web page, you could specify the name, color, and
weight of each cat in individual instances without worrying about
overwriting the information.
<H4>Static Variables</H4>
<P>
You can modify variable (and method) declarations with the <TT><FONT FACE="Courier">static</FONT></TT>
modifier. <I>Static variables</I> exist in only one location and
are globally accessible by all instances of a class. A variable
cannot be changed by a subclass if it has been declared static
and <I>final</I>. Further, static variables have the same information
in all instances of the class.
<P>
This is a valuable tool in situations in which a variable is shared
by several instances of a class and/or subclasses. All instances
will have the same value for the variable. All classes accessing
that variable point to the same place in memory. This variable
will remain there until the last instance accessing the variable
is flushed from memory.
<P>
A static variable is declared in the same way as an instance variable
but has the keyword <TT><FONT FACE="Courier">static</FONT></TT>
in front of it. In the following code, the variable <TT><FONT FACE="Courier">animalType</FONT></TT>
is declared static and is thus the same for all instances of class
<TT><FONT FACE="Courier">ACat</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ACat {<BR>
&nbsp;&nbsp;&nbsp;static String animalType[] = &quot;cat&quot;;
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this way, all the instances can check this variable for the
value of <TT><FONT FACE="Courier">animalType</FONT></TT>. An external
class can query this variable for the same information. Its value
needs to be specified only once and stored in one location because
the information is the same for all instances of class <TT><FONT FACE="Courier">ACat</FONT></TT>.
<H4>Predefined Instances</H4>
<P>
Java comes with three predefined object values: <TT><FONT FACE="Courier">null</FONT></TT><I>,
</I><TT><FONT FACE="Courier">this</FONT></TT><I>, </I>and <TT><FONT FACE="Courier">super</FONT></TT><I>.</I>
They are used as shortcuts for many common operations in Java.
<H4><TT><FONT FACE="Courier">null</FONT></TT></H4>
<P>
What happens when the class being created is a superclass? A variable
can be created that is simply a placeholder for subclasses to
fill with values. In this situation, a variable can be declared
<TT><FONT FACE="Courier">null</FONT></TT>,<BR>
meaning that no value is assigned to a variable, as in the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int PlaceHolder = null;&nbsp;&nbsp;&nbsp;&nbsp;//PlaceHolder
is an empty object</FONT></TT>
</BLOCKQUOTE>
<P>
Following is a code fragment using <TT><FONT FACE="Courier">null</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ACat{<BR>
&nbsp;&nbsp;&nbsp;static String name = null;<BR>
&nbsp;&nbsp;&nbsp;public void main (String args[]) {<BR>
&nbsp;&nbsp;&nbsp;ACat cat = new ACat();<BR>
&nbsp;&nbsp;&nbsp;if (cat.name == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promptForName(&quot;Enter
name&gt; &quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example the variable <TT><FONT FACE="Courier">name</FONT></TT>
is initialized to <TT><FONT FACE="Courier">null</FONT></TT>. It
is then tested in <TT><FONT FACE="Courier">main</FONT></TT> to
see if the variable is <TT><FONT FACE="Courier">null</FONT></TT>.
If so, the user is prompted to enter the cat's name. <TT><FONT FACE="Courier">null</FONT></TT>
cannot be used with primitive data types.
<H4><TT><FONT FACE="Courier">this</FONT></TT></H4>
<P>
To refer to the current object, use the keyword <TT><FONT FACE="Courier">this</FONT></TT>,
which allows the current instance of a variable to be referenced
explicitly. This is valuable when the current instance of a variable
is to be passed to another class that will also use the variable:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void promptForName (String prompt){<BR>
&nbsp;&nbsp;&nbsp;StringBuffer name;<BR>
&nbsp;&nbsp;&nbsp;char ch = '\0';<BR>
&nbsp;&nbsp;&nbsp;name = new StringBuffer();<BR>
&nbsp;&nbsp;&nbsp;System.out.print(prompt);<BR>
&nbsp;&nbsp;&nbsp;System.out.flush();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;While (ch != '\n') {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {ch = (char)System.in.read();
}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e) {};
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name.append(ch);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;this.name = name.toString();<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The compiler understands implicitly that the current instance
of a class variable is <TT><FONT FACE="Courier">this</FONT></TT><I>.</I>
Do not explicitly reference it unless necessary.
<H4><TT><FONT FACE="Courier">super</FONT></TT></H4>
<P>
<TT><FONT FACE="Courier">super</FONT></TT><I> </I>is a reference
to the superclass. It is often used as a shortcut or explicit
way to reference a member in the superclass of the current class.
In the following code, a subclass named <TT><FONT FACE="Courier">APersianCat</FONT></TT>
uses the <TT><FONT FACE="Courier">super</FONT></TT> keyword to
reference the method <TT><FONT FACE="Courier">promptForName</FONT></TT><I>
</I>in its superclass, <TT><FONT FACE="Courier">ACat</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class APersianCat extends ACat {<BR>
&nbsp;&nbsp;&nbsp;void getCatInfo {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.promptForName() :<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">APersianCat</FONT></TT> would look for
a method called <TT><FONT FACE="Courier">promptForName</FONT></TT>
in the current class if <TT><FONT FACE="Courier">super</FONT></TT>
were not used, generating a compile error.
<H3><A NAME="ClassMethods">Class Methods</A></H3>
<P>
We have been using methods throughout this chapter, but now a
better definition of methods is in order. <I>Methods</I> are functionally
similar to functions in C and C++. They provide a way to group
a block of code together and then refer to it by name. You can
use the block of code again simply by referring to the name of
the method. Also, the code does not have to intrude into the middle
of other code.
<P>
Methods do not have an explicit declaration keyword as classes
do<I>.</I> They do have names but also have arguments and return
types, which classes do not.
<P>
<I>Arguments </I>are parameters that are passed to the method
when it is called so that a method can be made to do different
tasks. The code internal to the method knows how to manipulate
the input parameters.
<P>
Methods also have a <I>return type.</I> This is a value that can
be returned to the code that called the method. Return values
can be of any valid Java type, including strings and numeric values.
<P>
Methods can be called from not only the current class, but also
from subclasses, superclasses, and even entirely unrelated classes.
This is the structure internal to Java that makes it so flexible
and time-effective.
<P>
An example of a method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static void main (String args[])
{<BR>
&nbsp;&nbsp;&nbsp;...body of method....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method has been used many times in this book. It is the method
<TT><FONT FACE="Courier">main</FONT></TT><I>, </I>which is the
first method called when a stand-alone Java application is started.
In this example, <TT><FONT FACE="Courier">public</FONT></TT> and
<TT><FONT FACE="Courier">static</FONT></TT> are method modifiers,
<TT><FONT FACE="Courier">void</FONT></TT> is the return type,
<TT><FONT FACE="Courier">main</FONT></TT> is the name of the method,
and<I> </I><TT><FONT FACE="Courier">(String args[])</FONT></TT>
is the list of method arguments. This is followed by an opening
<TT><FONT FACE="Courier">{</FONT></TT> that marks the beginning
of the body of the method. The method body can consist of any
valid block of Java code. It can also include calls to other methods,
even itself. Finally, the method body is followed by a final <TT><FONT FACE="Courier">}</FONT></TT>.
<H4>Return Types</H4>
<P>
Methods can return any valid Java type. This could be a simple
boolean, an array, an object representing an entire apartment
complex-anything. The return type immediately precedes the variable
name of a method. The following code declares a method named <TT><FONT FACE="Courier">isBlack</FONT></TT>
to return a variable with type <TT><FONT FACE="Courier">boolean</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean isBlack (Color color) {<BR>
&nbsp;&nbsp;&nbsp;if (color == black)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (true);<BR>
&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (false);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The method body tests whether the color passed is black. If it
is, the method uses the <TT><FONT FACE="Courier">return</FONT></TT>
keyword to specify that value to return to the calling method
is boolean <TT><FONT FACE="Courier">true</FONT></TT>. Otherwise,
it will use <TT><FONT FACE="Courier">return</FONT></TT><I> </I>to
return the boolean <TT><FONT FACE="Courier">false</FONT></TT>.
<P>
<TT><FONT FACE="Courier">void</FONT></TT> is a special return
type in Java that indicates that there is no return type of any
kind. This is used for methods that have no need to return anything
to the calling program, or that modify only method arguments or
global variables.
<P>
An example of a method that does not need to return anything is
one that only prints output to the screen. There is no need to
return anything because there is no further processing to be done.
There is no need to use the keyword <TT><FONT FACE="Courier">return</FONT></TT>
anywhere in the method if the method is declared <TT><FONT FACE="Courier">void</FONT></TT>.
<H3><A NAME="MethodModifiers">Method Modifiers</A></H3>
<P>
The concept of modifiers presented with classes also can be applied
to methods. Method modifiers control access to a method. Modifiers
also are used to declare a method's type. However, methods have
more modifiers available than do classes.
<H3><A NAME="DeclaringMethodSecurityandAccessibil">Declaring Method
Security and Accessibility</A></H3>
<P>
Method-declaration statements provide information to the compiler
about allowable access. In Java terms, accessibility is security.
The five levels of access follow:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Level</I></CENTER></TD><TD WIDTH=201><CENTER><I>Allowable Access</I></CENTER>
</TD></TR>
<TR><TD WIDTH=186><TT><FONT FACE="Courier">public</FONT></TT>
</TD><TD WIDTH=201>All other classes</TD></TR>
<TR><TD WIDTH=186><TT><FONT FACE="Courier">private</FONT></TT>
</TD><TD WIDTH=201>No other classes</TD></TR>
<TR><TD WIDTH=186><TT><FONT FACE="Courier">protected</FONT></TT>
</TD><TD WIDTH=201>Subclasses or same package</TD></TR>
<TR><TD WIDTH=186><TT><FONT FACE="Courier">private protected</FONT></TT>
</TD><TD WIDTH=201>Subclasses only</TD></TR>
<TR><TD WIDTH=186><TT><FONT FACE="Courier">&lt;default&gt;</FONT></TT>
</TD><TD WIDTH=201>Same package</TD></TR>
</TABLE></CENTER>
<P>
<H4><TT><FONT FACE="Courier">private</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">private</FONT></TT> modifier specifies
that no classes, including subclasses, can call this method. This
can be used to completely hide a method from all other classes.
If no other classes can access the method, it can be changed as
needed without causing problems. Here is an example of a method
declared <TT><FONT FACE="Courier">private</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">private void isBlack (Color color) {
<BR>
&nbsp;&nbsp;&nbsp;....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">protected</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">protected</FONT></TT> modifier specifies
that only the class in which the method is defined or subclasses
of that class can call the method. This allows access for objects
that are part of the same application, but not other applications.
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">protected void isBlack (Color color)
{<BR>
&nbsp;&nbsp;&nbsp;....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">private protected</FONT></TT></H4>
<P>
The<I> </I><TT><FONT FACE="Courier">private protected</FONT></TT>
modifier is a special combination of <TT><FONT FACE="Courier">private</FONT></TT>
and <TT><FONT FACE="Courier">protected</FONT></TT> access modifiers.
This modifier specifies that only the class in which the method
is defined or subclasses of the class can call the method. It
does not allow package access as <TT><FONT FACE="Courier">protected</FONT></TT>
does but also allows subclasses as <TT><FONT FACE="Courier">private</FONT></TT>
does not. Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">private protected void isBlack (Color
color) {<BR>
&nbsp;&nbsp;&nbsp;.....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">default</FONT></TT></H4>
<P>
The method defaults to an access control in which the class itself,
subclasses, and classes in the same package can call the method.
In this case, no access type is explicit in the method-declaration
statement. Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void isBlack (Color color) {<BR>
&nbsp;&nbsp;&nbsp;....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">static</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">static</FONT></TT><I> </I>modifier
is associated only with methods and variables, not classes. The
<TT><FONT FACE="Courier">static</FONT></TT><I> </I>modifier is
used to specify a method that can only be declared once. No subclasses
are allowed to implement a method of the same name. This is used
for methods, such as <TT><FONT FACE="Courier">main</FONT></TT>,
that are entry points into a program. The operating system would
not know which method to call first if there were two <TT><FONT FACE="Courier">main</FONT></TT><I>
</I>methods. Static methods are used to specify methods that should
not be overridden in subclasses. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">static void isBlack (Color color) {<BR>
&nbsp;&nbsp;&nbsp;....<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">final</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">final</FONT></TT> modifier indicates
that an object is fixed and cannot be changed. When you use this
modifier with a class-level object, it means that the class can
never have subclasses. When you apply this modifier to a method,
the method can never be overridden. When you apply this modifier
to a variable, the value of the variable remains constant. You
will get a compile-time error if you try to override a final method
or class. You will also get a compile-time error if you try to
change the value of a final variable.
<P>
Here is how you can use the <TT><FONT FACE="Courier">final</FONT></TT>
modifier:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class neverChanging {<BR>
<BR>
&nbsp;&nbsp;&nbsp;// a final variable<BR>
&nbsp;&nbsp;&nbsp;final int unchangingValue = 21;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// a final method<BR>
&nbsp;&nbsp;&nbsp;final int unchangingMethod(int a, int b) {<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">abstract</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">abstract</FONT></TT><I> </I>modifier
is used to create <I>template methods</I>, which are very similar
to function prototypes in C and C++. Abstract methods define return
type, name, and arguments but do not include any method body.
Subclasses are then required to implement the abstract method
and supply a body. Here is an example of an abstract class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract void isBlack (Color color) {
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This defines a template for a method named <TT><FONT FACE="Courier">isBlack</FONT></TT>.
Notice that no body of <TT><FONT FACE="Courier">isBlack</FONT></TT>
is specified; that is left to subclasses of the class in which
the abstract method is declared. The subclasses must implement
a body for method <TT><FONT FACE="Courier">isBlack</FONT></TT>,
or they will cause a compile-time error.
<H3><A NAME="OverloadingMethods">Overloading Methods</A></H3>
<P>
The concept of <I>overloading </I>methods seems nonsensical at
first. But when the idea seeps in, you will see that overloading
adds to the power of Java. Why would anyone want to define methods
with the same name but very different functionality? This is precisely
what overloading does. You can define a method with the same name
multiple times.
<P>
Java selects which method of the same name to call on the basis
of the calling parameters. Every overloaded method must have a
different and unique parameter list.
<P>
With Java you can overload any method in the current class or
any superclass unless the method is declared static. For example,
in the following code, method <TT><FONT FACE="Courier">isBlack</FONT></TT>
has been overloaded three times:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class CheckForBlack {<BR>
&nbsp;&nbsp;public boolean isBlack (Color color) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (color == black)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public boolean isBlack (String desc) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return(desc.compareTo(&quot;black&quot;);
<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public boolean isBlack (Paint paint) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (paint.reflectedLight &lt; .05)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(true);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(false);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Each method has the same name and return type, but each has a
different argument list. The first checks to see if the color
passed to the method is equal to the color black. The second method
compares a string passed to the argument to see if it is equal
to the string <TT><FONT FACE="Courier">&quot;black&quot;</FONT></TT>.
The last method determines if the <TT><FONT FACE="Courier">paint</FONT></TT>
object passed in to the method has a reflected light percentage
of less than 5%. If it does, it is considered black.
<P>
In all these cases, the method name and return type are the same,
but the arguments are different. The Java compiler automatically
uses the method that matches the arguments passed in the call
to determine the correct method. The Java compiler issues an error
if no method call has arguments to match any of the methods.
<P>
Method overloading allows for flexible use of method calls. In
the <TT><FONT FACE="Courier">isBlack</FONT></TT> example, if you
need another type of test, simply add it to the existing <TT><FONT FACE="Courier">CheckForBlack</FONT></TT>
class. A Java program can make <TT><FONT FACE="Courier">isBlack</FONT></TT>
calls using the new object.
<P>
In this way, you can cover multiple types of tests with only one
method name. Overriding means that the programmer does not need
to come up with different names for a method that accomplishes
the same thing, but perhaps in a different way. The programmer
can concentrate on readability and consistency without having
to worry about method names. This also means that in a large project,
a programmer does not need to worry about using a name that some
other programmer has already used (as long as the arguments are
different). 
<H2><A NAME="WorkingwithObjects"><FONT SIZE=5 COLOR=#Ff0000>Working
with Objects</FONT></A></H2>
<P>
Use of objects is one of the main differences between a procedural
language such as C and an object-oriented language such as C++
or Java. In a procedural language, data is usually thought of
as being distinct from the code. In object-oriented programming,
the code is thought of as being one with the data. 
<H3><A NAME="CreatingandDestroyingObjects">Creating and Destroying
Objects</A></H3>
<P>
Space is usually pre-allocated for data in procedural languages.
The compiler knows the size, types, and number of variables and
allocates space accordingly. The data-allocation space is fixed
in memory and continues to be allocated until the application
ends.
<P>
Data space is not pre-allocated in Java. Instead, it is created
as needed. Space is used for as long as something is accessing
the data, and then memory is automatically deallocated. This is
similar to using the <TT><FONT FACE="Courier">malloc</FONT></TT>
and <TT><FONT FACE="Courier">free</FONT></TT> system calls in
C.
<P>
The biggest difference between Java and C is that there is no
need to release memory explicitly after the program finishes with
it. In Java, an automatic garbage-collection system finds any
memory that is not in use and automatically frees it. This is
a huge bonus for the programmer because &quot;memory leaks&quot;
are a source of considerable problems in standard languages (and
one of the reasons reboots are a regularly scheduled event on
UNIX systems!).
<P>
Java and C++ have differences, also. In C++, constructor and destructor
functions run whenever an object is created or destroyed. Java
has an equivalent to the constructor function named <TT><FONT FACE="Courier">constructor</FONT></TT><I>,</I>
but there is no exact equivalent to a C++ destructor. All objects
in Java are removed using automatic garbage collection. There
is no way to invoke destructors manually. There is a method named
<TT><FONT FACE="Courier">finalize</FONT></TT> that can be used
like a C++ destructor to do final cleanup on an object before
garbage collection occurs, but finalizers have several limitations.
<H4>Creating an Instance</H4>
<P>
Java allocates memory space similar to <TT><FONT FACE="Courier">malloc</FONT></TT>
in C using the keyword <TT><FONT FACE="Courier">new</FONT></TT>.
<TT><FONT FACE="Courier">new</FONT></TT><I> </I>creates an object
of virtually any type, the exceptions being primitive data types.
A variable is then assigned that points to that object. An example
of this follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">String desc;<BR>
desc = new String(10);</FONT></TT>
</BLOCKQUOTE>
<P>
This allocates enough space in memory for a 10-character string
and associates it with the variable <TT><FONT FACE="Courier">desc</FONT></TT><I>.</I>
<TT><FONT FACE="Courier">desc</FONT></TT> is now considered an
object of type <TT><FONT FACE="Courier">String</FONT></TT> and
has all the methods associated with class <TT><FONT FACE="Courier">String</FONT></TT>.
<TT><FONT FACE="Courier">String</FONT></TT> methods include methods
to determine length, compare with other strings, obtain substrings,
and many others.
<P>
Method invocation in Java differs from that in C. In a procedural
language like C, the variable <TT><FONT FACE="Courier">desc</FONT></TT>
is normally passed as an argument to the appropriate function
call. In Java, the object associated with the variable <TT><FONT FACE="Courier">desc</FONT></TT>
already has all the methods built into it. This is a result of
the methods associated with type <TT><FONT FACE="Courier">String</FONT></TT>.
These methods became a part of object <TT><FONT FACE="Courier">desc</FONT></TT><I>
</I>when it was created with <TT><FONT FACE="Courier">new</FONT></TT>,
as in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sizeOfString = desc.length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//gets
the size of desc<BR>
if (desc.compareTo(&quot;black&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//tests
to see if desc is equal to &quot;black&quot;<BR>
locOfSubString = desc.indexOf(&quot;black&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//
returns index to substring</FONT></TT>
</BLOCKQUOTE>
<P>
These examples focus on the object, not the functions; thus the
name object-oriented programming.
<H4>Destroying an Instance</H4>
<P>
The <TT><FONT FACE="Courier">destroy</FONT></TT> method is always
called when an applet has completed or is being shut down. Any
final cleanup takes place here. The <TT><FONT FACE="Courier">destroy</FONT></TT>
method always must be named <TT><FONT FACE="Courier">destroy</FONT></TT>,
have a return type of <TT><FONT FACE="Courier">void</FONT></TT>,
be declared <TT><FONT FACE="Courier">public</FONT></TT>, and have
no arguments. An example of a <TT><FONT FACE="Courier">destroy</FONT></TT>
method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void destroy() {<BR>
&nbsp;&nbsp;&nbsp;counter = 0;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This <TT><FONT FACE="Courier">destroy</FONT></TT> method only
sets the variable <TT><FONT FACE="Courier">counter</FONT></TT><I>
</I>to zero. <TT><FONT FACE="Courier">destroy</FONT></TT> can
accomplish many things, such as cleanly terminating network connections,
logging information to files, and other final actions.
<P>
A <TT><FONT FACE="Courier">destroy</FONT></TT> method is not required.
It is actually overriding an existing <TT><FONT FACE="Courier">destroy</FONT></TT>
method in class <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>;
therefore, the name, return type, access security and arguments
are fixed.
<H3><A NAME="TheConstructorMethod">The Constructor Method</A>
</H3>
<P>
Recall that Java does not allocate memory for objects at application
startup time but rather when the instance is created by keyword
<TT><FONT FACE="Courier">new</FONT></TT><I>.</I> Several things
occur when <TT><FONT FACE="Courier">new</FONT></TT> is invoked.
First, Java allocates enough memory to hold the object. Second,
Java initializes any instance variables to default values.
<P>
Third, Java makes calls to any constructors that exist for that
class. <I>Constructors</I> are special methods that are used to
initialize an object. A constructor can do anything a normal method
can, but usually is used simply to initialize variables within
the object to some starting value.
<P>
Constructors do not have an explicit keyword to mark them as such.
Instead, the constructor method name is the same as the name of
the class in which the constructor is declared. In the following
example, there is a method named <TT><FONT FACE="Courier">Acat</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class. ACat {<BR>
&nbsp;&nbsp;&nbsp;void ACat (String breed[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.breed = breed;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Constructor methods always have a return type of <TT><FONT FACE="Courier">void</FONT></TT>
and a name that matches the class in which they are defined.
<P>
When <TT><FONT FACE="Courier">new</FONT></TT> is used to create
a new object, the constructor in the previous example is invoked.
For example, in the following code, the call to <TT><FONT FACE="Courier">new</FONT></TT><I>
</I>passes the value <TT><FONT FACE="Courier">Siamese</FONT></TT>
to the constructor, which initializes the <TT><FONT FACE="Courier">breed</FONT></TT><I>
</I>instance variable to that value:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ACat cat;<BR>
cat = new ACat(&quot;Siamese&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Constructors are like regular explicitly declared methods in that
they can be overloaded by declaring them more than once with different
arguments. Multiple constructors are created by declaring several
methods with the same name as the class. Also, like overloaded
methods, Java determines which constructor to use on the basis
of the arguments passed to <TT><FONT FACE="Courier">new</FONT></TT>,
as in the following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class. ACat {<BR>
&nbsp;&nbsp;&nbsp;void ACat (String breed[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.breed = breed;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;void ACat (Color color, int weight) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.weight = weight;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Here a second constructor with arguments of color and weight is
declared in addition to the first constructor, which has an argument
of breed. The second constructor is invoked as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ACat cat;<BR>
cat = new ACat(black, 15);</FONT></TT>
</BLOCKQUOTE>
<P>
This lends itself to great flexibility in the way a new object
is constructed. Appropriate constructors are created on the basis
of the needs of the application.
<P>
Constructors can call other constructors in the same class or
a superclass. Java extends the constructor naming convention by
using the <TT><FONT FACE="Courier">this</FONT></TT><I> </I>and
<TT><FONT FACE="Courier">super</FONT></TT><I> </I>keywords to
refer to constructors in the current or superclass, as in the
following example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class AMammal {<BR>
&nbsp;&nbsp;&nbsp;anAnimal(String mammalType[]) {<BR>
}<BR>
class ACat extends AMammal {<BR>
&nbsp;&nbsp;&nbsp;void ACat (String breed[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.breed = breed;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;void ACat (Color color, int weight) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.weight = weight;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;void ACat (Color color, int weight, String breed[])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(breed);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(color,weight);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; super(&quot;cat&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The third constructor takes all the arguments that were used for
the two other constructors. However, instead of duplicating the
initialization code in the other two constructors, it simply calls
them directly with the <TT><FONT FACE="Courier">this()</FONT></TT>
syntax. This example also shows a superclass named <TT><FONT FACE="Courier">AMammal</FONT></TT>
with a constructor that defines a mammal's type. The third <TT><FONT FACE="Courier">ACat</FONT></TT>
constructor uses this type using the <TT><FONT FACE="Courier">super()</FONT></TT>
syntax.
<H4>The <TT><FONT FACE="Courier">finalize</FONT></TT> Method</H4>
<P>
When an object is no longer referenced by any objects, Java reclaims
the memory space using garbage collection. Java calls a destructor
method before garbage collection takes place. Unlike the constructor
methods, destructor methods have a specific name: <TT><FONT FACE="Courier">finalize</FONT></TT>.
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">void finalize() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body of finalize method<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Finalize methods always have a return type of void and override
a default destructor in <TT><FONT FACE="Courier">java.object.Object</FONT></TT>.
<P>
A program can call <TT><FONT FACE="Courier">finalize</FONT></TT>
directly just as it would any other method. However, calling <TT><FONT FACE="Courier">finalize</FONT></TT>
will not initiate any type of garbage collection. It is treated
as any other method if called directly. When Java does garbage
collection, <TT><FONT FACE="Courier">finalize</FONT></TT> is still
called even if it has already been called directly by the program.
<P>
The <TT><FONT FACE="Courier">finalize</FONT></TT> method is like
other methods in that it can be overloaded. Remember, however,
that Java calls <TT><FONT FACE="Courier">finalize</FONT></TT>
automatically and does not pass any arguments at that time. If
Java finds a <TT><FONT FACE="Courier">finalize</FONT></TT> method
with arguments at garbage-collection time, it will look for a
<TT><FONT FACE="Courier">finalize</FONT></TT> method with no arguments.
If it does not find one, Java uses the default <TT><FONT FACE="Courier">finalize</FONT></TT>
method instead.
<P>
One difference between <TT><FONT FACE="Courier">finalize</FONT></TT>
and a C++ destructor is that the system only calls <TT><FONT FACE="Courier">finalize</FONT></TT><I>
</I>when it is ready to reclaim the memory associated with the
object. This is not immediately after an object is no longer referenced.
Cleanup is scheduled by the system on an as-needed basis. There
can be a significant delay between when the application finishes
and when <TT><FONT FACE="Courier">finalize</FONT></TT> is called.
This is true even if the system is busy, but there is no immediate
need for more memory. For these reasons, it may be better to call
<TT><FONT FACE="Courier">finalize</FONT></TT> directly at program
termination rather than wait for garbage collection to invoke
it automatically. It depends on the application.
<H2><A NAME="Packages"><FONT SIZE=5 COLOR=#Ff0000>Packages</FONT></A>
</H2>
<P>
How do packages fit into the hierarchy? Once again we return to
the apartment example. In our town, there are several large complexes
owned by a single company. This real estate company also owns
malls, empty commercially zoned land, and warehouses. These are
alike in that they are real property. Think of the company as
the largest unit of reference for the properties. The company
knows about each of the individual apartment units and can make
use of them as needed.
<P>
In Java terms, the company is the <I>package.</I> The package
groups together class libraries, such as the libraries containing
information about different commercial properties, as well as
tract land for suburbs. A package is the largest logical unit
of objects in Java.
<P>
Packages in Java group a variety of classes and/or interfaces
together. In packages, classes can be unique compared with classes
in other packages. Packages also provide a method of handling
access security. Finally, packages provide a way to &quot;hide&quot;
classes, preventing other programs or packages from accessing
classes that are for internal use of an application only.
<H3><A NAME="DeclaringaPackage">Declaring a Package</A></H3>
<P>
Packages are declared using the <TT><FONT FACE="Courier">package</FONT></TT>
keyword followed by a package name. This must occur as the first
statement in a Java source file, excluding comments and whitespace.
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">package mammals;<BR>
class AMammal {<BR>
&nbsp;&nbsp;&nbsp;...body of class AMammal<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the package name is <TT><FONT FACE="Courier">mammals</FONT></TT><I>.
</I>The class <TT><FONT FACE="Courier">AMammal</FONT></TT> is
now considered a part of this package<I>.</I> Including other
classes in package <TT><FONT FACE="Courier">mammals</FONT></TT>
is easy: Simply place an identical package line at the top of
those source files as well. Because every class is generally placed
in its own source file, every source file that contains classes
for a particular package must include this line. There can be
only one package statement in any source file.
<P>
Note that the Java compiler only requires classes that are declared
public to be put in a separate source file. Nonpublic classes
can be put in the same source file. Although it is good programming
practice to put each of these in its own source file, one package
statement at the top of a file will apply to all classes declared
in that file.
<P>
Java also supports the concept of package hierarchy. This is similar
to the directory hierarchy found in many operating systems. This
is done by specifying multiple names in a package statement, separated
by a period. In the following code, class <TT><FONT FACE="Courier">AMammal</FONT></TT><I>
</I>belongs to the package <TT><FONT FACE="Courier">mammal</FONT></TT>
that is in the <TT><FONT FACE="Courier">animal</FONT></TT> package
hierarchy:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">package animal.mammal;<BR>
class AMammal {<BR>
&nbsp;&nbsp;&nbsp;...body of class Amammal<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This allows grouping of related classes into a package and then
grouping related packages into a larger package. To reference
a member of another package, the package name is prepended to
the class name. This is an example of a call to method <TT><FONT FACE="Courier">promptForName</FONT></TT>
in class <TT><FONT FACE="Courier">ACat</FONT></TT> in subpackage
<TT><FONT FACE="Courier">mammal</FONT></TT><I> </I>in package
<TT><FONT FACE="Courier">animal</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">animal.mammal.Cat.promptForName();</FONT></TT>
</BLOCKQUOTE>
<P>
The analogy to a directory hierarchy is reinforced by the Java
interpreter. The Java interpreter requires that the <TT><FONT FACE="Courier">.class</FONT></TT>
files be physically located in a subdirectory with a name that
matches the subpackage name, when accessing a member of a subpackage.
If the previous example were located on a UNIX system, the class
<TT><FONT FACE="Courier">promptForName</FONT></TT> would be located
as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">animal/mammal/ACat.class</FONT></TT>
</BLOCKQUOTE>
<P>
Of course, the directory-naming conventions will be different
for different operating systems. The Java compiler will happily
place the <TT><FONT FACE="Courier">.class</FONT></TT> files into
the same directory as the source files. It may be necessary to
move the resulting class files into the appropriate directory
if the source files are not in the class files.
<P>
The class files can also be placed directly into the desired directory
by specifying the <TT><FONT FACE="Courier">-d</FONT></TT> (directory)
option on the <TT><FONT FACE="Courier">javac</FONT></TT> command
line. To continue the example, the following code places the resulting
output files in the subdirectory <TT><FONT FACE="Courier">animal/mammal/ACat</FONT></TT>
of the current directory:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&gt; javac -d animal/mammal/ACat ACat.java</FONT></TT>
</BLOCKQUOTE>
<P>
All classes actually belong to a package even if not explicitly
declared. Even though in the examples used throughout most of
this book no package name has been declared, the programs can
be compiled and run without problems. As usual in Java, what is
not explicitly declared automatically gets default values. In
this case, there is a default unnamed package to which all such
packages belong. The package does not have an explicit name, and
it is not possible for other packages to reference an unnamed
package. Therefore, no other package is able to reference most
of the examples in this book as they are now. It is a good idea
to place all nontrivial classes into packages.
<H3><A NAME="AccessingOtherPackages">Accessing Other Packages</A>
</H3>
<P>
Recall that you can reference packages by prepending a complete
package name to a class. A shortcut-using the <TT><FONT FACE="Courier">import</FONT></TT>
statement-can be used when there are many references to a particular
package or the package name is long and unwieldy.
<P>
The <TT><FONT FACE="Courier">import</FONT></TT><I> </I>statement
is used to include a list of packages to be searched for a particular
class. The syntax of an <TT><FONT FACE="Courier">import</FONT></TT>
statement follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import packagename;</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">import</FONT></TT><I> </I>is a keyword
and <TT><I><FONT FACE="Courier">packagename</FONT></I></TT> is
the name of the package to be imported. The statement must end
with <TT><FONT FACE="Courier">;</FONT></TT>. The <TT><FONT FACE="Courier">import</FONT></TT>
statement should appear before any class declarations in a source
file. Multiple <TT><FONT FACE="Courier">import</FONT></TT> statements
can also be made. The following is an example of an <TT><FONT FACE="Courier">import</FONT></TT>
statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import mammal.animal.Cat;</FONT></TT>
</BLOCKQUOTE>
<P>
In this example all the members (for example, variables, methods)
of class <TT><FONT FACE="Courier">Cat</FONT></TT> can now be directly
accessed by simply specifying their name without prepending the
entire package name.
<P>
This shortcut poses both an advantage and a disadvantage. The
advantage is that the code is no longer cluttered with long names
and is easier to type. The disadvantage is that it is more difficult
to determine from which package a particular member came. This
is especially true when a large number of packages are imported.
<P>
<TT><FONT FACE="Courier">import</FONT></TT> statements can also
include the wildcard character <TT><FONT FACE="Courier">*</FONT></TT>.
The asterisk specifies that all classes located in a hierarchy
be imported, rather than just a single class. For example, the
following code imports all classes that are in the <TT><FONT FACE="Courier">mammal.animal</FONT></TT>
subpackage:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import mammal.animal.*;</FONT></TT>
</BLOCKQUOTE>
<P>
This is a handy way to bring all classes from a particular package.
<P>
The <TT><FONT FACE="Courier">import</FONT></TT> statement has
been used quite heavily in the examples in this book. It has typically
been used to bring in various parts of the Java API. By default
the <TT><FONT FACE="Courier">java.lang.*</FONT></TT> set of classes
is always imported. The other Java class libraries must be explicitly
imported. For example, the following code brings in all the windowing
toolkit graphic and image classes (see Part IV):
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.Graphics;<BR>
import java.awt.Image;</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="PackageNamingConventions">Package-Naming Conventions</A>
</H3>
<P>
Packages can be named anything that follows the standard Java
naming scheme. By convention, however, packages begin with lowercase
letters to make it simpler to distinguish package names from class
names when looking at an explicit reference to a class. This is
why class names are, by convention, begun with an uppercase letter.
For example, when using the following convention, it is immediately
obvious that <TT><FONT FACE="Courier">mammal</FONT></TT> and <TT><FONT FACE="Courier">animal</FONT></TT>
are package names and <TT><FONT FACE="Courier">Cat</FONT></TT>
is a class name. Anything following the class name is a member
of that class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">mammal.animal.Cat.promptForName();</FONT></TT>
</BLOCKQUOTE>
<P>
Java follows this convention for the Java internals and API. The
<TT><FONT FACE="Courier">System.out.println()</FONT></TT> method
that has been used follows this convention. The package name is
not explicitly declared because <TT><FONT FACE="Courier">java.lang.*</FONT></TT>
is always imported implicitly. <TT><FONT FACE="Courier">System</FONT></TT>
is the class name from package <TT><FONT FACE="Courier">java.lang.*</FONT></TT>,
and it is capitalized. The full name of the method is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java.lang.System.out.println();</FONT></TT>
</BLOCKQUOTE>
<P>
Every package name must be unique to make the best use of packages.
Naming conflicts that will cause runtime errors will occur if
duplicate package names are present. The class files may step
on each other in the class directory hierarchy if there is duplication.
<P>
It is not difficult to keep package names unique if a single individual
or small group does the programming. Large-group projects must
iron out package-name conventions early in the project to avoid
chaos.
<P>
No single organization has control over the World Wide Web, and
many Java applications will be implemented over the Web. Remember
also that Web servers are likely to include Java applets from
multiple sources. It seems impossible to avoid duplicate package
names.
<P>
Sun recognized this problem late in the development stage but
before officially releasing Java. It developed a convention that
ensures package-name uniqueness using a variation on domain names,
which are guaranteed to be unique: to use the domain name in a
reverse manner. Domain <TT><FONT FACE="Courier">mycompany.com</FONT></TT>
would prefix all package names with <TT><FONT FACE="Courier">com.mycompany</FONT></TT><I>.</I>
Educational institute <TT><FONT FACE="Courier">city.state.edu</FONT></TT>
would prefix package names with <TT><FONT FACE="Courier">edu.state.city</FONT></TT><I>.</I>
This neatly solves the naming problem and generates a very nice
tree structure for all Java class libraries.
<H3><A NAME="TheCLASSPATHEnvironmentVariable">The <TT><FONT SIZE=4 FACE="Courier">CLASSPATH</FONT></TT><FONT SIZE=4>
Environment Variable</FONT></A></H3>
<P>
The Java interpreter must find all the referenced class libraries
when running a Java application. By default, Java looks in the
Java install tree for the libraries. It is usually better when
developing code to put your own class libraries someplace else.
An environment variable named <TT><FONT FACE="Courier">CLASSPATH</FONT></TT><I>
</I>can be used to tell Java where these libraries are located.
<TT><FONT FACE="Courier">CLASSPATH</FONT></TT> contains a list
of directories to search for Java class library trees. The syntax
of the list will vary according to the operating system being
used. On UNIX systems, <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
contains a colon-separated list of directory names. Under Windows,
the list is separated by <TT><FONT FACE="Courier">;</FONT></TT>.
The following is a <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
statement for a UNIX system:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">CLASSPATH=/grps/IT/Java/classes:/opt/apps/Java</FONT></TT>
</BLOCKQUOTE>
<P>
This tells the Java interpreter to look in the <TT><FONT FACE="Courier">/grps/IT/Java/classes</FONT></TT>
and <TT><FONT FACE="Courier">/opt/apps/Java</FONT></TT> directories
for class libraries.
<H3><A NAME="SummaryofPackages">Summary of Packages</A></H3>
<P>
Packages are used for grouping related classes together. They
can be used to access related classes as well as to hide the internals
of a package from outside programs.
<P>
Packages are declared using the <TT><FONT FACE="Courier">package</FONT></TT>
keyword, which must be located at the beginning of all source
files that are to be a part of the same package. Package members
can be accessed by prepending the complete package name separated
by <TT><FONT FACE="Courier">.</FONT></TT> to the needed member.
The contents of packages can also be accessed by importing the
package into a class using the <TT><FONT FACE="Courier">import</FONT></TT><I>
</I>keyword. Doing so enables the code to specify package members
directly without explicitly specifying the complete package name.
<P>
Package names by convention begin with lowercase letters. This
distinguishes them from class names, which by convention begin
with uppercase letters. Sun encourages programmers to use a reverse
Internet domain name as the top level of a package name to keep
package names unique on a global scale.
<P>
Packages can contain subpackages. Java requires that the resulting
<TT><FONT FACE="Courier">.class</FONT></TT> files reside in a
directory structure that mirrors the package name hierarchy. By
default, the Java interpreter looks for packages where the Java
programs were installed. Use the <TT><FONT FACE="Courier">CLASSPATH</FONT></TT>
environment variable to list a set of additional directories to
search.
<H2><A NAME="Inheritance"><FONT SIZE=5 COLOR=#Ff0000>Inheritance</FONT></A>
</H2>
<P>
One of the more powerful concepts in an object-oriented language
is the concept of <I>inheritance,</I> which is a methodology whereby
the code developed for one use can be extended for use elsewhere
without having to make an actual copy of the code.
<P>
In Java, inheritance is done by creating new classes that are
extensions of other classes. The new class is known as a <I>subclass</I>.
The original class is known as a <I>superclass</I>. The subclass
has all the attributes of the superclass, and in addition has
attributes that it defines itself. A class can have only one superclass.
This is known as <I>single inheritance</I>. A superclass can have
multiple subclasses. To better clarify this concept, let's look
at the apartment building example again.
<P>
Recall that an apartment building class is made up of individual
apartments and may be part of a larger complex made up of other
types of buildings such as schools, stores, and houses. One way
to implement this in Java is to start with the concept of a building.
All buildings share certain characteristics, including building
size (height, width, depth), size of lot, and type of heating.
Using these characteristics, we could build up a class that stores
and manipulates these characteristics.
<P>
An apartment building can be thought of as being a more specialized
version of a building. Apartment buildings are made up of a group
of individual apartments, any of which might be empty at any given
moment. These characteristics can be incorporated as part of the
building class but would not apply to a school. Instead, an apartment
building class is created that inherits characteristics of the
building class but also adds its own particular characteristics.
This creates a more specific version of building that is customized
for describing an apartment building. More specialized versions
of buildings could be created for a school, store, or house.
<H3><A NAME="DeclaringInheritance">Declaring Inheritance</A></H3>
<P>
Declaring inheritance in classes is simply an extension of the
class-declaration rules discussed earlier. This is done with the
<TT><FONT FACE="Courier">extends</FONT></TT> keyword:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class classname extends anotherclass
{<BR>
&nbsp;&nbsp;... body of class<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">extends</FONT></TT> keyword immediately
follows the class name. It is followed by the name of the superclass
from which this class will inherit characteristics. There can
be only one class name following the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword.
<P>
<TT><FONT FACE="Courier">Recall</FONT></TT> from the examples
in the &quot;Applet Classes&quot; section that the applets were
declared as subclasses of <TT><FONT FACE="Courier">java.applet.Applet</FONT></TT>.
A declaration such as this provides an applet with all its inherent
characteristics. There is no reason to code them because they
are inherited from the superclass.
<P>
Let's use the apartment building analogy to demonstrate inheritance,
starting with the building class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class Bldg {<BR>
&nbsp;&nbsp;&nbsp;int height, width, depth, lotsize;<BR>
&nbsp;&nbsp;&nbsp;String heatType;<BR>
&nbsp;&nbsp;&nbsp;public String getHeatType () {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(heatType);<BR>
&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<P>
In this simplistic version of a building class, variables for
holding <TT><FONT FACE="Courier">height</FONT></TT>, <TT><FONT FACE="Courier">width</FONT></TT>,
<TT><FONT FACE="Courier">depth</FONT></TT>, and <TT><FONT FACE="Courier">lotsize</FONT></TT>
and a method for printing out the type of heating have all been
declared. These are the characteristics that all buildings share.
<P>
The next step is to create an apartment building class that extends
the previously declared building class:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class AptBldg extends Bldg {<BR>
&nbsp;&nbsp;&nbsp;int numApts;<BR>
&nbsp;&nbsp;&nbsp;Apt apt[];<BR>
&nbsp;&nbsp;&nbsp;public int findVacatApt () {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; numApts;
i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (apt[i].isVacant
== true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(i);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
public class Apt {<BR>
&nbsp;&nbsp;&nbsp;boolean vacant;<BR>
&nbsp;&nbsp;&nbsp;int aptNumber;<BR>
&nbsp;&nbsp;&nbsp;public boolean isVacant() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(vacant);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, two classes are declared: an apartment building
class (<TT><FONT FACE="Courier">AptBldg</FONT></TT>) and an apartment
class (<TT><FONT FACE="Courier">Apt</FONT></TT>). The apartment
building class is declared using <TT><FONT FACE="Courier">extends<I>
</I>Bldg</FONT></TT>, which declares that <TT><FONT FACE="Courier">AptBldg</FONT></TT>
is a subclass of <TT><FONT FACE="Courier">Bldg</FONT></TT>. By
doing this, <TT><FONT FACE="Courier">AptBldg</FONT></TT> inherits
all the variables and methods declared in <TT><FONT FACE="Courier">Bldg</FONT></TT>.
<TT><FONT FACE="Courier">AptBldg</FONT></TT> extends <TT><FONT FACE="Courier">Bldg</FONT></TT>
by declaring a variable for number of apartments and an array
containing apartment objects. There is also a method that returns
the first vacant apartment in the array of apartments.
<P>
The <TT><FONT FACE="Courier">Apt</FONT></TT> class is a brand-new
class and does not extend any other classes. It declares two variables,
<TT><FONT FACE="Courier">vacant</FONT></TT> and <TT><FONT FACE="Courier">aptNumber</FONT></TT>,
as well as method <TT><FONT FACE="Courier">isVacant</FONT></TT>,
which can be used to determine if the apartment is vacant. The
next step is to use the classes that are now declared.
<H3><A NAME="UsingInheritance">Using Inheritance</A></H3>
<P>
It is now time to create a program for apartment managers. This
program must be able to do things such as find an empty apartment.
The classes declared previously are used in a new Java program
that can do this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public AptManager {<BR>
&nbsp;&nbsp;&nbsp;public findEmptyApt (AptBldg aptBldg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int AptNum;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String heatType;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AptNum = aptBldg.findVacantApt();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (AptNum &gt; 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heatType
= aptBldg.getHeatType();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Apartment
&quot; + AptNum + &quot;is available for rent&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Type
of heat is&quot; + heatType);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, a method for finding an empty apartment has been
created. It is passed an apartment building object as an argument.
The method then calls the <TT><FONT FACE="Courier">findVacantApt</FONT></TT>
method in the <TT><FONT FACE="Courier">aptBldg</FONT></TT> object
to locate a vacant apartment. If one is found, a call to the method
<TT><FONT FACE="Courier">getHeatType</FONT></TT> is made to determine
the type of heat in the building. Both of these pieces of information
are then printed out.
<P>
Notice that although <TT><FONT FACE="Courier">findVacantApt</FONT></TT>
is explicitly declared in <TT><FONT FACE="Courier">AptBldg</FONT></TT>,
the <TT><FONT FACE="Courier">getHeatType</FONT></TT> method is
not. It is instead declared in the <TT><FONT FACE="Courier">Bldg</FONT></TT>
class. Because <TT><FONT FACE="Courier">AptBldg</FONT></TT> is
declared a subclass of <TT><FONT FACE="Courier">Bldg</FONT></TT>,
it automatically inherits all of <TT><FONT FACE="Courier">Bldg</FONT></TT>'s
methods, including <TT><FONT FACE="Courier">getHeatType</FONT></TT>.
By using inheritance we have saved the effort of having to recode
the method of determining the heat type. If other subclasses of
<TT><FONT FACE="Courier">Bldg</FONT></TT>, such as <TT><FONT FACE="Courier">school</FONT></TT>
or <TT><FONT FACE="Courier">house</FONT></TT>, were declared,
they would also inherit this same method. On a grander scale,
you can save large amounts of coding effort.
<P>
Another important characteristic of Java is that it avoids the
&quot;fragile superclass&quot; problem of C++; that is, a recompile
of all subclasses must occur every time an upper-level class is
changed. The very nature of Java is such that, because it is an
interpreted language, no such recompile needs to take place. All
superclass characteristics are passed down through inheritance.
This is a great improvement over C++.
<H3><A NAME="SummaryofInheritance">Summary of Inheritance</A>
</H3>
<P>
Inheritance is a method of reusing existing code while allowing
for customization. When you're working with a group of objects
that are similar to each other in some, but not all, ways, inheritance
can be helpful.
<P>
Inheritance is used with class declarations. It is declared using
the <TT><FONT FACE="Courier">extends</FONT></TT> keyword. When
a class extends another class, it is known as a subclass. The
class it extends is known as the superclass. A class can have
any number of subclasses but can have only one superclass. This
is single inheritance.
<P>
With inheritance, a subclass can have full access to all the variables
and methods declared in its superclass. This allows for items
that are common to a group of classes to be placed in a single
location. Other variables and methods can be declared in each
subclass to add functionality or information as needed.
<P>
Inheritance provides a powerful mechanism for reusing existing
code. This can be important in a large project. It also makes
it simple to add new classes at any time.
<H2><A NAME="Interfaces"><FONT SIZE=5 COLOR=#Ff0000>Interfaces</FONT></A>
</H2>
<P>
<I>Interfaces</I> are Java's way of cutting down on the complexity
of a project. Single inheritance makes it easy to find out method
or class origins. However, this may be somewhat limiting. C++
permits multiple inheritance, which can be a breeding ground of
needless complexity but does allow for ultimate flexibility. Java
is less flexible but also less complex. It uses single inheritance
for simplicity's sake but uses interfaces to bring in functionality
from other classes. 
<P>
A review of methods is in order before continuing. <I>Methods</I>
are similar to functions in other languages. A method is a unit
of code that is called and returns a value. Methods perform work
on the variables and contain executable code. They are always
internal to a class and are associated with an object.
<P>
The concept of interfaces is one of the main differences in project
design between traditional C and Java application development.
The C and other procedural programming language systems' development
life cycle often begins with the definition of the application
function names and their arguments as empty &quot;black boxes.&quot;
In other words, the programmers know the necessary argument parameters
when programming code that calls these functions without knowing
how they are implemented in the function. Thus they can develop
code without first fully fleshing out all the functions. In C,
this could be done by defining a function prototype for all the
functions and then implementing them as resources and schedules
permit. How is this accomplished in Java? Through interfaces.
<P>
An interface only defines a method's name, return type, and arguments.
It does not include executable code or point to a particular method.
Think of an interface as a template of structure, not usage.
<P>
Interfaces are used to define the structure of a set of methods
that will be implemented by classes yet to be designed and coded.
In other words, the calling arguments and the return value must
conform to the definition in the interface. The compiler checks
this conformity. However, the code internal to one method defined
by the interface may achieve the intended result in a wildly different
way than a method in another class.
<P>
The concept of using interfaces is a variation on inheritance
used heavily in Java. The chief benefit of interfaces is that
many different classes can all implement the same interface. This
guarantees that all such classes will implement a few common methods.
It also ensures that all the classes will implement these common
methods using the same return type, name, and arguments.
<P>
Let's get theoretical. Say that a method is defined in the interface
as boolean. The only argument is an input string. In the <TT><FONT FACE="Courier">comments</FONT></TT>
section, the method is said to test something to see if it is
black and return <TT><FONT FACE="Courier">true</FONT></TT> or
<TT><FONT FACE="Courier">false</FONT></TT>. Methods using this
interface could be written to test cats, pavement, teeth, screen
color-just about anything. The only thing these methods have in
common is that they have the same definition. Any programmer seeing
the method name knows the purpose of the method and the calling
arguments.
<P>
Java, of course, does not require all classes that implement a
method of a certain name to use the interface for argument verification.
No language can make up for poor project management. It does,
however, provide the structure for use.
<H3><A NAME="DeclaringanInterface">Declaring an Interface</A>
</H3>
<P>
An interface is declared in much the same manner as a class, but
instead uses the <TT><FONT FACE="Courier">interface</FONT></TT>
keyword instead of the <TT><FONT FACE="Courier">class</FONT></TT>
keyword:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">interface name {<BR>
&nbsp;&nbsp;&nbsp;... body of interface<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The interface body is declared between the curly braces. The body
of an interface consists of declarations for variables and methods.
<H3><A NAME="Modifiers">Modifiers</A></H3>
<P>
The same modifiers-<TT><FONT FACE="Courier">public</FONT></TT>
and <TT><FONT FACE="Courier">default</FONT></TT>-available to
classes can be applied to an interface's declaration. The default
is <TT><FONT FACE="Courier">nonpublic</FONT></TT>, which means
accessible by any member of a given package. Most interfaces are
<TT><FONT FACE="Courier">public</FONT></TT> because interfaces
are the only means to share variable and method definitions between
different packages. Here is an example of a <TT><FONT FACE="Courier">public</FONT></TT>
interface declaration:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface AnInterface {<BR>
&nbsp;&nbsp;... //body of interface<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Variables and methods declared inside an interface also have modifiers
associated with them. However, the modifiers are limited to particular
combinations for variables and methods.
<P>
Modifiers for variables are limited to one specific set: <TT><FONT FACE="Courier">public
static final</FONT></TT>. In other words, variables declared in
interfaces can only function as constants. <TT><FONT FACE="Courier">public
static final</FONT></TT> are the default modifiers. It is not
necessary to declare the modifiers explicitly, but it makes the
code more self-documenting. Trying to assign other modifiers such
as <TT><FONT FACE="Courier">protected</FONT></TT> results in a
compile-time error. Here are examples of variable declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public static final int smtpSocket =
25;<BR>
<BR>
public static final float pie = 3.14159;<BR>
<BR>
public static final String = &quot;The quick brown fox&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Modifiers for methods are limited to one specific set as well:
<TT><FONT FACE="Courier">public abstract</FONT></TT>, meaning
that methods declared inside an interface can only be abstract.
These are the default modifiers for methods. It is not necessary
to declare them explicitly, but once again, it makes the code
easier to read.
<P>
Trying to assign other modifiers, such as <TT><FONT FACE="Courier">protected</FONT></TT>,
results in a compile-time error. Here are example interface method
declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public abstract boolean isBlack(Color);
<BR>
<BR>
public abstract boolean isBlack(String);<BR>
<BR>
public abstract StringBuffer promptForName(String);</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see in this example, overloaded methods can be declared
in an interface just as in a class. An entire interface based
on these examples follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface MyInterface {<BR>
&nbsp;&nbsp;&nbsp;public static final int smtpSocket = 25;<BR>
&nbsp;&nbsp;&nbsp;public static final float pie = 3.14159;<BR>
&nbsp;&nbsp;&nbsp;public static final String = &quot;The quick
brown fox&quot;;<BR>
&nbsp;&nbsp;&nbsp;public abstract boolean isBlack(Color);<BR>
&nbsp;&nbsp;&nbsp;public abstract boolean isBlack(String);<BR>
&nbsp;&nbsp;&nbsp;public abstract StringBuffer promptForName(String);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Interfaces also can extend other interfaces, just as classes can
extend other classes, using the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword. In the following code, the interface <TT><FONT FACE="Courier">AnInterface</FONT></TT>
declares a variable named <TT><FONT FACE="Courier">theAnswer</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface AnInterface {<BR>
&nbsp;&nbsp;&nbsp;public static final int theAnswer = 42;<BR>
}<BR>
public interface MyInterface extends AnInterface {<BR>
&nbsp;&nbsp;&nbsp;public static final int smtpSocket = 25;<BR>
&nbsp;&nbsp;&nbsp;public static final float pie = 3.14159;<BR>
&nbsp;&nbsp;&nbsp;public static final String = &quot;The quick
brown fox&quot;;<BR>
&nbsp;&nbsp;&nbsp;public abstract boolean isBlack(Color);<BR>
&nbsp;&nbsp;&nbsp;public abstract boolean isBlack(String);<BR>
&nbsp;&nbsp;&nbsp;public abstract StringBuffer promptForName(String);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The interface <TT><FONT FACE="Courier">MyInterface</FONT></TT>
specifies that it extends <TT><FONT FACE="Courier">AnInterface</FONT></TT>.
This means that any classes that use <TT><FONT FACE="Courier">MyInterface</FONT></TT>
will have access to not only the variables and methods declared
in <TT><FONT FACE="Courier">MyInterface</FONT></TT>, but also
those in <TT><FONT FACE="Courier">AnInterface</FONT></TT>.
<P>
You can also list multiple interfaces after the <TT><FONT FACE="Courier">extends</FONT></TT>
keyword. Multiple, possibly disparate, interfaces can be combined
into a logical whole if desired, as in the following: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface YourInterface extends
HerInterface, HisInterface {</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&nbsp;&nbsp;&nbsp;body of interface
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="UsinganInterface">Using an Interface</A></H3>
<P>
A continuation of the apartment example can be used to go into
more detail on interfaces. Recall that an apartment building class
<TT><FONT FACE="Courier">AptBldg</FONT></TT> was defined previously.
It contains all the information needed to define an apartment
building.
<P>
Another piece of information that could be added to the apartment
building class is address.<BR>
<TT><FONT FACE="Courier">Address</FONT></TT> can be manipulated
after it is added to the class; one way to do this is simply to
add address- manipulation methods to the existing apartment building
class. This limits the address information to just one class.
If all the address-manipulation methods were placed in an interface,
however, all classes would have access. Here is an example of
such an interface:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public interface Address {<BR>
&nbsp;&nbsp;&nbsp;public abstract void printAddress (anAddress);
<BR>
&nbsp;&nbsp;&nbsp;public abstract void setStreet (anAddress);
<BR>
&nbsp;&nbsp;&nbsp;public abstract String getState (anAddress);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The interface is a template for manipulating the address information
through methods. The methods print the entire address, change
the street name, and return only the state. Each of these methods
is specific to manipulating addresses. So why place methods in
an interface if it is easy to add to the existing class? Reusability
is the hallmark of Java!
<P>
Now that the interface is defined, a class can make use of it
with the <TT><FONT FACE="Courier">implements</FONT></TT> keyword.
Here is the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class name [extends <I>classname</I>
] implements <I>interfacename</I> [, <I>interfacename</I>] {<BR>
&nbsp;&nbsp;&nbsp;... body of class<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">implements</FONT></TT> keyword follows
the name of the class (or <TT><FONT FACE="Courier">extends</FONT></TT>
declaration) and in turn is followed by one or more comma-separated
interface names. The capability to specify a list of interfaces
enables a class to have access to a variety of predefined interfaces.
In the building example, the class is declared as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public class AptBuilding implements Address
{<BR>
&nbsp;&nbsp;&nbsp;... body of class<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Other classes can make use of these same methods by also implementing
the same interface after it has been declared. 
<P>
Suppose we decide to implement other classes, such as schools,
stores, and high-rise office buildings. Each of these could use
the same method definitions for manipulating addresses that were
defined for class <TT><FONT FACE="Courier">AptBldg</FONT></TT>.
Not only does that save programming steps by reusing an existing
template, it also enables all the different building classes to
use the same methods for manipulating addresses. The call needed
to look up a school's address is exactly the same as that needed
for a store's address. This also means that the same method name
is used. There is no need to come up with a unique name for every
class's address. This is important in large projects.
<P>
This methodology covers the similarities between classes. What
about the differences? Another application might need phone numbers
in addition to addresses. This is easy in Java! Java does not
specify that only methods derived from interfaces can be used.
Any class is free to add methods for anything necessary. This
customization only applies to one class, though. There is no need
to worry about affecting other classes that also use the interface
if an extension is used.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></A>
</H2>
<P>
This chapter covers the concepts of classes, packages, inheritance,
and interfaces. A solid knowledge of the relationships among these
parts of Java is essential to creating applets and applications.
<P>
Classes in Java are used to define an object. Objects can consist
of information and methods for manipulating that information.
An instance is a specific implementation of an object.
<P>
Packages are groups of class libraries, which are made up of related
classes. Packages can be used to control access security and make
it easier to import an entire set of classes.
<P>
Inheritance allows for the reuse of existing code while providing
a means for customization of new code. Java provides single inheritance
between classes and subclasses. Subclasses always inherit the
characteristics of their superclass. This is a building block
of object-oriented programming.
<P>
Interfaces are templates of methods used to standardize method
definitions. These are necessary due to Java's lack of multiple
inheritance. Interfaces allow unrelated classes to share related
methods.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
