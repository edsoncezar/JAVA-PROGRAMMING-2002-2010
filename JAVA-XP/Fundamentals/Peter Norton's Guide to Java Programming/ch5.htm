<HTML>

<HEAD>
   <TITLE>Chapter 5 -- Java Tools and the JDK: A Primer</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336308&ad_type=POPUP&category=net&id=1c6d3c1b3e227ef49e83013b1294a100";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 5</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Java Tools and the JDK: A Primer</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#ToolsintheJavaDevelopersKit" >Tools in the Java Developer's Kit</A>
<LI><A HREF="#CommandlineToolsintheJDK" >Command-line Tools in the JDK</A>
<UL>
<LI><A HREF="#TheJavaCompilerandAssociatedEnviron" >The Java Compiler and Associated Environment Tools</A>
<LI><A HREF="#TheJavaInterpreter" >The Java Interpreter</A>
<LI><A HREF="#TheJavaAppletViewer" >The Java Applet Viewer</A>
</UL>
<LI><A HREF="#GraphicalDevelopersTools" >Graphical Developer's Tools</A>
<UL>
<LI><A HREF="#MacintoshDevelopersTools" >Macintosh Developer's Tools</A>
<LI><A HREF="#JavaWorkShop" >Java WorkShop</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Programming in any language is easier if you have the proper tools.
The Java Developer's Kit includes a complete toolkit for Java
development. Beyond the JDK tools are tools featuring graphical
interfaces. The more you understand about the tools used for Java
development, the better prepared you will be to take advantage
of everything the Java programming language has to offer. This
chapter discusses the essential tools for creating, developing,
and debugging Java programs with a focus on how to get the most
out of them.
<H2><A NAME="ToolsintheJavaDevelopersKit"><FONT SIZE=5 COLOR=#Ff0000>Tools
in the Java Developer's Kit</FONT></A></H2>
<P>
A thorough understanding of the tools in the Java Developer's
Kit is essential for your success in Java programming. Previous
chapters discuss the basics of using some of these tools, but
the focus in those early chapters is on how to use the tools and
not on the features of the tools. As you will see in this chapter,
each tool has unique features that are designed to help you do
the following:
<UL>
<LI>Get more out of the Java programming language
<LI>Troubleshoot problems in your programs
<LI>Change environment defaults
<LI>Optimize Java for your development or target system
</UL>
<P>
Most versions of the JDK include seven tools for Java development:
<UL>
<LI>Java compiler
<LI>Java API documentation generator
<LI>Java header and stub file generator
<LI>Java interpreter
<LI>Java applet viewer
<LI>Java class file disassembler
<LI>Java debugger
</UL>
<P>
As you saw in <A HREF="ch2.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch2.htm" >Chapter 2</A>, &quot;Getting
Started with the JDK,&quot; the JDK is available for most operating
systems. For Windows 95/NT, OS/2, and UNIX platforms, the developer's
tools in JDK version 1.0 have a command-line interface. For Macintosh
(and soon for other platforms as well), the developer's tools
in JDK version 1.0 feature a graphical user interface. Graphical
development environments for UNIX and Windows-based platforms
are also available. Because you will get more out of this chapter
if I break down the discussion according to the interface the
tools use, it features two main sections. The first section is
on command-line tools, and the second section is on graphical
tools.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Looking Forward</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Because the Java debugger uses a separate API discussed in <A HREF="ch13.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch13.htm" >Chapter 13</A>, &quot;The Net and Debug Class Libraries,&quot; it is more appropriate to discuss using the debugger in a later chapter. For this reason, you will find a complete 
discussion on the Java debugger in <A HREF="ch23.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch23.htm" >Chapter 23</A>, &quot;Advanced Debugging and Troubleshooting.&quot;
</BLOCKQUOTE>
<BLOCKQUOTE>
Similarly, the Java class file disassembler is used to examine Java bytecode, and a better place to discuss the disassembler is <A HREF="ch24.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch24.htm" >Chapter 24</A>, &quot;The Java Virtual Machine.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="CommandlineToolsintheJDK"><FONT SIZE=5 COLOR=#Ff0000>Command-line
Tools in the JDK</FONT></A></H2>
<P>
For Windows 95/NT, OS/2, and UNIX platforms, the tools in the
Java Developer's Kit version 1.0 execute from the command line.
Although SunSoft and many third-party vendors have produced graphical
developer's environments for Java, current programmers and system
administrators may prefer the simplicity of the original command-line
tools.
<P>
The advantage of using tools that do not have a graphical user
interface is that they are streamlined, are generally more versatile,
and use minimal system resources. Command-line tools also let
you perform complex assignments and handle tasks with parameters
easily.
<H3><A NAME="TheJavaCompilerandAssociatedEnviron">The Java Compiler
and Associated Environment Tools</A></H3>
<P>
Most discussions on compiling Java programs relate to the Java
compiler, but there is a set of related tools you might want to
use at compile time. These related tools include the Java compiler,
the Java API documentation generator, and the Java header and
stub file generator.
<H4><TT>javac</TT></H4>
<P>
When you compile Java programs, you use the Java compiler. The
JDK includes two versions of the Java compiler. The first version,
<TT>javac</TT>, is optimized for normal
use and has only limited debugging capabilities. The second version,
<TT>javac_g</TT>, is optimized for
debugging and is intended for use with the Java debugger.
<P>
You run the Java compiler from the command line and pass it the
full name of your Java source file. The Java compiler expects
the source code to be in a file named with the <TT>.java</TT>
extension. Additionally, when the source file contains multiple
class declarations, the source file must be named after the primary
class declaration. Therefore, it is best to always name your source
files after the primary class declaration.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
You may be wondering what class is considered the <I>primary class</I>. For applications, the primary class is the class that contains the <TT>main()</TT> method. For applets, the primary class is the class that contains the <TT>init()</TT> and 
<TT>run()</TT> methods.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
For each class declaration in the source file, the Java compiler
creates a class file with a <TT>.class</TT>
extension. Because the compiler is case sensitive, the first part
of the class file will be named exactly as you typed it in the
source file. By default, the class files are placed in the same
directory as the source file. You can override this default with
the <TT>-d</TT> option. The <TT>-d</TT>
option of the Java compiler lets you specify the destination directory
for your class files.
<P>
On UNIX platforms, you can specify a default destination directory
as follows:
<BLOCKQUOTE>
<TT>javac -d $HOME/jb_apps/myclasses QuizMaker.java</TT>
</BLOCKQUOTE>
<P>
On Windows 95/NT and OS/2 platforms, you can specify a default
destination directory as follows:
<BLOCKQUOTE>
<TT>javac -d C:\jb_apps\myclasses QuizMaker.java</TT>
</BLOCKQUOTE>
<P>
If the application you are compiling references any classes that
are not stored in the current directory, you should either set
the <TT>CLASSPATH</TT> environment
variable or use the <TT>-classpath</TT>
option. The <TT>-classpath</TT> option
lets you specify a path for your class files that overrides the
default or current <TT>CLASSPATH</TT>
setting. Because this option takes precedence, you should set
it to include the current directory, the location of your personal
or third-party class files, and the location of the Java API classes.
<P>
On UNIX platforms, you can specify a path for class files as follows:
<BLOCKQUOTE>
<TT>javac -classpath .:/usr/jb_apps/vendorclasses:java/classes:
<BR>
&Acirc;java/lib/classes.zip QuizMaker.java</TT>
</BLOCKQUOTE>
<P>
On Windows 95/NT and OS/2 platforms, you can specify a path for
class files as follows:
<BLOCKQUOTE>
<TT>javac -classpath .;C:\jb_apps;C:\java\classes;
<BR>
&Acirc;C:\java\lib\classes.zip QuizMaker.java</TT>
</BLOCKQUOTE>
<P>
You can generate debugging tables with the <TT>-g</TT>
option. <I>Debugging tables</I> contain information about the
program organized by line numbers. A similar and more useful option
is the <TT>-debug</TT> option. This
option generates a full trace of compiler activity that primarily
relates to methods and declarations. If you change to the directory
containing the source for the <TT>FirstApp</TT>
program discussed in <A HREF="ch4.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch4.htm" >Chapter 4</A>, &quot;The
Java Language: A Primer,&quot; and type the following,
<BLOCKQUOTE>
<TT>javac -debug FirstApp.java</TT>
</BLOCKQUOTE>
<P>
you will see output similar to this:
<BLOCKQUOTE>
<TT>public static void main(java.lang.String[]);
<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(method (System#0.out) println &quot;My
first stand-alone application <BR>
&Acirc;is a success.&quot;);<BR>
}<BR>
[check field FirstApp.main]<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(method (System#0.out) println &quot;My
first stand-alone application <BR>
&Acirc;is a success.&quot;);<BR>
}<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(method (java.lang.System.out) println
&quot;My first stand-alone application <BR>
&Acirc;is a success.&quot;);<BR>
}<BR>
[check field FirstApp.&lt;init&gt;]<BR>
<BR>
{<BR>
}<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;(method super &lt;init&gt;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>}<BR>
<TT>[inline field FirstApp.main]<BR>
[inlined field FirstApp.main]<BR>
(method (&lt;empty&gt;.out) println &quot;My first stand-alone
application <BR>
&Acirc;is a success.&quot;);<BR>
[code field FirstApp.main]<BR>
[inline field FirstApp.&lt;init&gt;]<BR>
[inlined field FirstApp.&lt;init&gt;]<BR>
(method super &lt;init&gt;);<BR>
[code field FirstApp.&lt;init&gt;]</TT>
</BLOCKQUOTE>
<P>
As you can see, the <TT>-debug</TT>
option generates an awful lot of output even for small programs.
The output is useful, however, to get a line-by-line picture of
what the compiler is doing with methods and declarations.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
To capture the output of almost any Java tool to a file, redirect the output to a named file. For the Java compiler, you can do this using the following syntax:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>javac [options] filename.java &gt; outputfile</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you type the following,</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>javac -debug FirstApplet.java &gt; firstapp</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
all debugging information from the compiler is directed to the file called <TT>firstapp</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Although the <TT>-g</TT> and the <TT>-debug</TT>
options come in handy for advanced programs, you will find that
for basic- to intermediate-level programs you really will not
need to use them. Another option you might not need unless you
are developing advanced programs is the <TT>-nowarn</TT>
option. If you use this option, the compiler does not print out
warnings. (Because warnings are not actual errors, you might sometimes
want to stop the compiler's incessant displaying of them.) Typically,
though, you will not see warnings anyway with basic- to intermediate-level
programs.
<P>
One of the most useful command-line arguments for the compiler
is the <TT>-O</TT> option. With this
option, you can optimize your source code so that it runs faster
and uses fewer system resources. The compiler optimizes your code
by creating inline references to static, final, and private methods.
<P>
Anytime when speed and system resources are a consideration, I
highly recommend optimizing your code. However, there is a trade-off
to be made between the compiled size of your program and the optimization
of your program, which again primarily comes into play for advanced
programs. Because optimized code contains inline references, it
is sometimes-but not always-larger than non-optimized code. The
Java compiler also takes longer to finish the compilation when
you optimize the code.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Technical Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
To test the optimization, I ran some tests on my system. I compiled six Java programs of 100-300 lines in length with the <TT>-O</TT> option and all the associated class files were actually smaller-by 300-800 bytes-than the non-optimized versions. I tried 
the same test with Java programs that were more than 1,000 lines in length. Although the size of one program did increase by 500 bytes, the optimized versions were usually smaller. Optimization actually reduced the size of one program from 18KB to 14.5KB.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Another useful compiler option is <TT>-verbose</TT>.
With this option, you can turn on verbose messaging and see everything
the compiler and linker are doing. Not only will verbose messaging
tell you what source files are being read, but you can also see
<UL>
<LI>How long it took to parse each source file
<LI>When and from where the compiler is loading each class
<LI>When classes are being checked
<LI>When the class file is being written to
<LI>How long it took to complete the compilation
</UL>
<P>
Because the <TT>-verbose</TT> option
tells you what the compiler is doing to class and source files,
you can use it in conjunction with the <TT>-debug</TT>
option to get a complete picture of everything the compiler is
doing. If you change to the directory containing the source for
the <TT>FirstApplet</TT> program discussed
in the previous chapter and type the following,
<BLOCKQUOTE>
<TT>javac -verbose FirstApplet.java</TT>
</BLOCKQUOTE>
<P>
you will see output similar to this:
<BLOCKQUOTE>
<TT>[parsed FirstApplet.java in 500ms]<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/applet/Applet.class) in 110ms]
<BR>
[checking class FirstApplet]<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/Panel.class) in 0ms]
<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/Container.class) in 110ms]
<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/Component.class) in 160ms]
<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/lang/Object.class) in 0ms]
<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/image/ImageObserver.class)
in 0ms]<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/Image.class) in 60ms]
<BR>
[loaded C:\JAVA\LIB\CLASSES.ZIP(java/awt/Graphics.class) in 60ms]
<BR>
[wrote FirstApplet.class]<BR>
[done in 2030ms]</TT>
</BLOCKQUOTE>
<P>
You can pass multiple parameters to the compiler, but you must
precede each option with a hyphen. If you wanted to optimize the
code and use the <TT>-verbose</TT>
option, you would type the following:
<BLOCKQUOTE>
<TT>javac -O -verbose QuizMaker.java</TT>
</BLOCKQUOTE>
<P>
The command-line syntax for the compiler is
<BLOCKQUOTE>
<TT>javac [options] filename.java</TT>
</BLOCKQUOTE>
<P>
The compiler takes these options:<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Option</I></CENTER></TD><TD WIDTH=471><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=119><TT>-classpath</TT>
</TD><TD WIDTH=471>Overrides the default or current <TT>CLASSPATH</TT> environment variable setting
</TD></TR>
<TR><TD WIDTH=119><TT>-d</TT></TD>
<TD WIDTH=471>Specifies a destination directory for your class files
</TD></TR>
<TR><TD WIDTH=119><TT>-debug</TT>
</TD><TD WIDTH=471>Generates a full trace of compiler activity for methods and declarations
</TD></TR>
<TR><TD WIDTH=119><TT>-g</TT></TD>
<TD WIDTH=471>Adds debugging information, including line numbers
</TD></TR>
<TR><TD WIDTH=119><TT>-nowarn</TT>
</TD><TD WIDTH=471>Turns off compiler warnings</TD></TR>
<TR><TD WIDTH=119><TT>-O</TT></TD>
<TD WIDTH=471>Optimizes source code by inlining static, final, and private methods
</TD></TR>
<TR><TD WIDTH=119><TT>-verbose</TT>
</TD><TD WIDTH=471>Tells you what the compiler is doing to class and source files
</TD></TR>
</TABLE></CENTER>
<P>
<H4><TT>javah</TT></H4>
<P>
The Java C Header and Stub File Generator is an extremely useful
environment tool. You will use it when you need to implement native
methods. C header and stub files are necessary for Java and C
programs to interact. As C programmers know, header and stub files
are used by C programs to reference an object's instance variables.
If you plan to interface your Java program to C or C++, you should
generate header and stub files after compiling the Java source
code.
<P>
The JDK includes two versions of this tool. The first version,
<TT>javah</TT>, is optimized for normal
use and has only limited debugging capabilities. The second version,
<TT>javah_g</TT>, is optimized for
debugging and is intended for use with the Java debugger.
<P>
You run the Java C Header and Stub File Generator from the command
line and pass it the name of your Java class file without the
<TT>.class</TT> extension. By default,
<TT>javah</TT> creates a header file
with the <TT>.h</TT> extension for
each class name you pass to it and stores the file in the current
directory. Header files are named with the class name and the
<TT>.h</TT> extension. You can override
this default with the <TT>-o</TT>
option.
<P>
The <TT>-o</TT> option lets you specify
a single output file for all generated source information. This
is useful when you have Java programs that contain multiple class
files and you want to store the associated header and stub information
in one file. As <TT>javah</TT> stores
the output in the exact file you name, you should always specify
the <TT>.h</TT> extension in the destination
filename. The following example creates a header file called <TT>concat.h</TT>
for a Java program that has four classes associated with it:
<BLOCKQUOTE>
<TT>javah -o concat.h RGBcanvas RGBcontrols
HexInt RGB2Hex</TT>
</BLOCKQUOTE>
<P>
Generated header files contain C <TT>struct</TT>
definitions, define all the variables you might need, and create
a handle for passing values back and forth between C and Java.
The layout of the header file approximates the layout of the original
class file with fields that correspond to instance variables.
For every class you use in the Java program, there will be a <TT>struct</TT>
definition with the package name prepended to the class name.
Java replaces file path separators with the underscore character.
Here are some examples:
<BLOCKQUOTE>
<TT>struct Hjava_awt_peer_ComponentPeer;
<BR>
<BR>
struct Hjava_awt_Container;<BR>
<BR>
struct Hjava_awt_Color;</TT>
</BLOCKQUOTE>
<P>
Whereas header files are generated automatically, you must use
the <TT>-stubs</TT> option to create
a stub file with C declarations. Stub files are named with the
class name and the <TT>.c</TT> extension-in
the C programming language source files named with this extension.
You can use this option as follows:
<BLOCKQUOTE>
<TT>javah -stubs RGB2Hex</TT>
</BLOCKQUOTE>
<P>
During the generation of header and stub files, <TT>javah</TT>
builds temporary files. These files are generally stored in the
<TT>\tmp</TT> directory on UNIX systems
and on the <TT>C:\temp</TT> directory
on Windows-based systems. If you are compiling all classes associated
with an advanced application, these files can grow to be quite
large. You can override the default directory with the <TT>-td</TT>
option, which lets you specify the location of the temporary directory.
Specifying a new location for the temporary directory is often
useful, especially if your primary disk or the root partition
doesn't have a lot of free space.
<P>
On UNIX platforms, you can set the location of the temporary directory
as follows:
<BLOCKQUOTE>
<TT>javah -td \usr\temp RGB2Hex</TT>
</BLOCKQUOTE>
<P>
On Windows 95/NT and OS/2 platforms, you can set the location
of the temporary directory as follows:
<BLOCKQUOTE>
<TT>javah -td C:\windows\temp RGB2Hex<BR>
</TT>
</BLOCKQUOTE>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
On Windows and OS/2 platforms, <TT>javah</TT> stores temporary files in the directory specified by the <TT>TEMP</TT> environment variable, which on most systems is <TT>C:\temp</TT>. If the <TT>TEMP</TT> environment variable is not set on your system, 
<TT>javah</TT> checks for a <TT>TMP</TT> environment variable. Finally, if the <TT>TMP</TT> environment variable is not set, <TT>javah</TT> creates a temporary directory at <TT>C:\tmp</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Other options you can use include the <TT>-v</TT>
option and the <TT>-classpath</TT>
option. The <TT>-v</TT> option turns
on verbose messaging, which lets you see what classes and temporary
directory <TT>javah</TT> is using.
The <TT>-classpath</TT> option lets
you override the default and current <TT>CLASSPATH</TT>
setting. If the program for which you are creating header and
stub files makes use of any classes that are not stored in the
current directory, you should either set the <TT>CLASSPATH</TT>
environment variable or use the <TT>-classpath</TT>
option.
<P>
The command-line syntax for the header and stub file generator
is
<BLOCKQUOTE>
<TT>javah [options] classname</TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT>javah [options] classname1 classname2
classname3 &#133;</TT>
</BLOCKQUOTE>
<P>
The header and stub file generator takes these options:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Option</I></CENTER></TD><TD WIDTH=471><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=119><TT>-classpath</TT>
</TD><TD WIDTH=471>Overrides the default or current <TT>CLASSPATH</TT> environment variable setting
</TD></TR>
<TR><TD WIDTH=119><TT>-d</TT></TD>
<TD WIDTH=471>Specifies a destination directory for your header and stub files
</TD></TR>
<TR><TD WIDTH=119><TT>-o</TT></TD>
<TD WIDTH=471>Specifies a single output file for all generated header and source infor-mation
</TD></TR>
<TR><TD WIDTH=119><TT>-stubs</TT>
</TD><TD WIDTH=471>Creates stub files with C declarations in addition to the C header files
</TD></TR>
<TR><TD WIDTH=119><TT>-td</TT></TD>
<TD WIDTH=471>Specifies a directory for temporary files and overrides the default
</TD></TR>
<TR><TD WIDTH=119><TT>-v</TT></TD>
<TD WIDTH=471>Tells you what classes and temp directory <TT>javah</TT> is using
</TD></TR>
</TABLE></CENTER>
<P>
<H4><TT>javadoc</TT></H4>
<P>
The Java API Documentation Generator, as the name implies, is
used to generate documentation from source files. Because the
documentation is in the form of HTML documents, you can view it
online with any HTML browser. The great thing about HTML documentation
is that all object names are linked together. As a programmer,
you will appreciate how thorough the documentation this tool creates
is, especially if you are tired of having to write your own documentation.
In fact, Sun used this tool to create the documentation files
for the API.
<P>
You run the API Documentation Generator from the command line
and pass it the full name of your Java source file. Here's an
example:
<BLOCKQUOTE>
<TT>javadoc FirstApplet.java<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Caution</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
If you pass <TT>javadoc</TT> the name of your source file without the <TT>.java</TT> extension, it will create the documentation. However, <TT>javadoc</TT> will parse the source as it would a Java package. The result is a completely different set of 
documentation.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The API Documentation Generator expects the source code to be
in a file named with the <TT>.java</TT>
extension. You can also pass <TT>javadoc</TT>
the name of a package and it will generate documentation for the
entire package.
<P>
The only options you can use with the documentation generator
are <TT>-classpath</TT>, <TT>-d</TT>,
and <TT>-verbose</TT>. If the program
for which you are creating documentation makes use of any classes
that are not stored in the current directory, you should either
set the <TT>CLASSPATH</TT> environment
variable or use the <BR>
<TT>-classpath</TT> option. The <TT>-d</TT>
option lets you specify the destination directory for the HTML
documentation. The <TT>-verbose</TT>
option turns on verbose messaging and lets you see what classes
and source files the compiler and linker are using.
<P>
The command-line syntax for the header and stub file generator
is
<BLOCKQUOTE>
<TT>javadoc [options] sourcefile.java</TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT>javadoc [options] packagename</TT>
</BLOCKQUOTE>
<P>
The documentation generator takes these options:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Option</I></CENTER></TD><TD WIDTH=471><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=119><TT>-classpath</TT>
</TD><TD WIDTH=471>Overrides the default or current <TT>CLASSPATH</TT> environment variable setting
</TD></TR>
<TR><TD WIDTH=119><TT>-d</TT></TD>
<TD WIDTH=471>Specifies a destination directory for your class files
</TD></TR>
<TR><TD WIDTH=119><TT>-verbose</TT>
</TD><TD WIDTH=471>Tells you what the compiler is doing to class and source files
</TD></TR>
</TABLE></CENTER>
<P>
<H4>Using <TT>javadoc</TT></H4>
<P>
The documentation generator parses declarations and document-style
comments in Java source files and formats this into a set of HTML
documents. For a source file containing class declarations, <TT>javadoc</TT>
creates one documentation file for each class declaration. The
name of the file is the class name plus the <TT>.html</TT>
extension. These class documents contain a complete breakdown
of the class. Three additional documentation files are always
created as well:
<UL>
<LI><TT>packages.html</TT>-Documentation
file used for packages; is generally empty if you created documentation
for a source file with class declarations.
<LI><TT>AllNames.html</TT>-Index file
of all fields and methods used in the source file.
<LI><TT>tree.html</TT>-Documentation
file that shows the class hierarchy used in the source file.
</UL>
<P>
If you create documentation for packages, the <TT>packages.html</TT>
file will contain an entry for each package. These entries will
be linked to an appropriately named package file, such as <TT>Package-PackageName.html</TT>.
<P>
To better understand what <TT>javadoc</TT>
does and how it does it, let's create documentation for the <TT>FirstApplet</TT>
program. The first thing you will notice when you create documentation
with <TT>javadoc</TT> is that it expects
you to have the Java API documentation in HTML format installed
on your system. It also expects you to have the source file in
the base directory for the API documentation. Primarily, this
is because of the way <TT>javadoc</TT>
links object names back to the API documentation and because the
documentation uses images from the API documentation.
<P>
To get around this problem, you could move your source file to
the directory containing the API documentation and then run <TT>javadoc</TT>.
However, by doing so you will overwrite the <TT>packages.html</TT>
file that already exists in this directory. Also, if you generated
any previous documentation with <TT>javadoc</TT>,
you would overwrite the existing <TT>AllNames.html</TT>
and <TT>tree.html</TT> files.
<H4>Avoiding Problems with the Documentation Generator</H4>
<P>
To avoid overwriting existing documentation and to be able to
use the documentation with the API documentation, you might want
to do the following:
<OL>
<LI>Make a new directory.
<LI>Move the source file to the new directory.
<LI>Run <TT>javadoc</TT> in this directory
on the source file.
<LI>If you are not creating documentation for a package, remove
the <TT>packages.html</TT> file.
<LI>Using a text editor, edit the <TT>tree.html</TT>
file. Prepend the name of your class for all references to the
file <TT>AllNames.html</TT>. You could
do this by searching on the keyword <TT>AllNames.html</TT>
and replacing it with the appropriate name. There is generally
only one reference you have to update.
<LI>Using a text editor, edit the <TT>AllNames.html</TT>
file. Prepend the name of your class for all references to the
file <TT>tree.html</TT>. You could
do this by searching on the keyword <TT>tree.html</TT>
and replacing it with the appropriate name. There is generally
only one reference you have to update.
<LI>Move all remaining files to the directory containing the API
documentation.
</OL>
<P>
You can now use the documentation for your class with the API
documentation and don't have to worry about it being overwritten
the next time you create documentation.
<P>
To avoid overwriting existing documentation and to keep your documentation
separate from the API documentation, you might want to do the
following:
<OL>
<LI>Make a directory for your documentation.
<LI>Change to your documentation directory and make a subdirectory
called <TT>images</TT>.
<LI>Copy the contents of the <TT>images</TT>
directory from the Java API documentation to the <TT>images</TT>
directory you just made.
</OL>
<P>
Then, each time you want to create documentation for a new class,
you can do the following to update your personal documentation:
<OL>
<LI>Move the source to a temporary directory.
<LI>Run <TT>javadoc</TT> in this directory
on the source file.
<LI>If you are not creating documentation for a package, remove
the <TT>packages.html</TT> file.
<LI>Using a text editor, edit the <TT>tree.html</TT>
file. Prepend the name of your class for all references to the
file <TT>AllNames.html</TT>. You could
do this by searching on the keyword <TT>AllNames.html</TT>
and replacing it with the appropriate name. There is generally
only one reference you have to update.
<LI>Using a text editor, edit the <TT>AllNames.html</TT>
file. Prepend the name of your class for all references to the
file <TT>tree.html</TT>. You could
do this by searching on the keyword <TT>tree.html</TT>
and replacing it with the appropriate name. There is generally
only one reference you have to update.
<LI>Move all remaining files to your documentation directory.
</OL>
<P>
You can now use the documentation for your class and don't have
to worry about it being overwritten the next time you create documentation.
<H4>Generating Documentation for <TT>FirstApplet</TT>
</H4>
<P>
You can create documentation for the <TT>FirstApplet</TT>
program following the steps listed in the pre-vious section. Figure
5.1 shows what the resulting <TT>AllNames.html</TT>
file should look like. Each of the underlined phrases is a hypertext
link to key information within the document and to other documents.
<P>
<A HREF="f5-1.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-1.gif" ><B>Figure 5.1 :</B> <I>An automatically generated index for FirstApplet.</I></A>
<P>
The documentation generator puts a useful header on the document
that allows you to quickly locate fields and methods alphabetically.
Each of the entries in the main section of the document also contains
hypertext links that let you quickly and easily navigate through
lengthy documentation. You can access the <TT>tree.html</TT>
file by clicking on the link titled &quot;Class Hierarchy.&quot;
<P>
A partial view of the <TT>tree.html</TT>
file is shown in Figure 5.2. This file contains a listing of every
class used by the <TT>FirstApplet</TT>
program. All class references are linked back to the Java API
documentation.
<P>
<A HREF="f5-2.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-2.gif" ><B>Figure 5.2 : </B><I>An automatically generated class hierarchy for FirstApplet.</I></A>
<P>
The most useful file in the documentation is the class file. For
this example, the class file is named <TT>FirstApplet.html</TT>.
The first section of this file is shown in Figure 5.3. From the
class diagram shown at the top of the figure, you can see exactly
where the <TT>FirstApplet</TT> class
fits into the class hierarchy. As you can see, the <TT>FirstApplet</TT>
class extends the <TT>Applet</TT>
class, which in turn is an extension of other classes.
<P>
<A HREF="f5-3.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-3.gif" ><B>Figure 5.3 : </B><I>An automatically generated overview of FirstApplet.</I></A>
<P>
As shown in Figure 5.4, the next section of the document breaks
the <TT>FirstApplet</TT> class into
constructors and methods. Because this documentation is primarily
for more advanced programs than this one, there is a constructor
index and a method index that contain hypertext links to each
constructor and method used in the program.
<P>
<A HREF="f5-4.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-4.gif" ><B>Figure 5.4 : </B><I>Methods and constructors are broken down clearly in the documentation.</I></A>
<P>
In the constructor section, each class is broken down by its class
declaration. In the method section, each method is broken down
by its method declaration and shows the relationship of your method
to the methods in the API. Because the <TT>init()</TT>
method of the <TT>FirstApplet</TT>
class overrides the <TT>init()</TT>
method of the <TT>Applet</TT> class,
the <TT>FirstApplet</TT> class documentation
contains the following definition for this method:
<BLOCKQUOTE>
<TT>&nbsp;public void init()<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overrides:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init
in class Applet</TT>
</BLOCKQUOTE>
<H4>Enhancing the Documentation</H4>
<P>
You can enhance the documentation that <TT>javadoc</TT>
creates using document-style comments. The most basic form of
document-style comments allows you to add descriptions to the
classes, methods, and variable declarations you use in your programs.
You should always add comments just before the section or declaration
to which the comments pertain. The documentation generator uses
these comments to add a description to your classes, methods,
and variables. 
<P>
<A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >See Chapter 6</A>, &quot;Fundamentals of the
Java Language,&quot; for a complete discussion about using comments
in Java.
<P>
Add the following document-style comment to the <TT>FirstApplet</TT>
program just before the class declaration:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming<BR>
&nbsp;* The FirstApplet program creates a basic<BR>
&nbsp;* applet with multimedia features.<BR>
&nbsp;*/</TT>
</BLOCKQUOTE>
<P>
The documentation generator will include the description in the
first section of the <TT>FirstApplet.html</TT>
file. To support more advanced control over documentation, <TT>javadoc</TT>
also lets you place markup instructions within the comments. There
are two ways you can do this.
<P>
The first way is with HTML markup. To be useful, HTML markup should
not interfere with tags and formatting that <TT>javadoc</TT>
generates automatically. This means you should not use header
tags, horizontal rules, or tags that denote head or body sections.
One way to use HTML is to show code examples:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* The getImage() method is used to add an image to an applet
<BR>
&nbsp;* &lt;PRE&gt; NewImage = getImage(getCodeBase(),&quot;New.gif&quot;);
&lt;/PRE&gt;<BR>
*/</TT>
</BLOCKQUOTE>
<P>
The documentation generator also supports a special set of documenting
tags that are defined with the at symbol (<TT>@</TT>)
and are always defined within document-style comments. With these
tags, you can add many types of inline references including links
to other documents, author entries, and version control. To use
these tags, you specify the name of the tag followed by the reference
text, like this:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming<BR>
&nbsp;* The FirstApplet program creates a basic<BR>
&nbsp;* applet with multimedia features.<BR>
&nbsp;* @version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5 March 15, 1996
<BR>
&nbsp;*/</TT>
</BLOCKQUOTE>
<P>
When the documentation sees the version tag, it adds a version
entry in the HTML document for the associated class. The entry
would appear as follows:
<BLOCKQUOTE>
<TT>Version:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5 March 15, 1996</TT>
</BLOCKQUOTE>
<P>
The six special tags that <TT>javadoc</TT>
supports, as well as their corresponding entries in the documentation,
are shown in Table 5.1. Your doc tags must be placed at the beginning
of a line. Although you can use multiple tags of the same type
within a document, you should keep tags of the same type together.
For example, if there are multiple authors of the program, your
entry should look something like this:
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming<BR>
&nbsp;* The FirstApplet program creates a basic<BR>
&nbsp;* applet with multimedia features.<BR>
&nbsp;* @author&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peter Norton
<BR>
&nbsp;* @author&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;William Stanek
<BR>
&nbsp;* @version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.5 March 15, 1996
<BR>
&nbsp;*/<BR>
</TT>
</BLOCKQUOTE>
<P>

<CENTER><B>Table 5.1. Doc tags and their uses.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1>

<TR><TD WIDTH=127><CENTER><I>Doc tag</I></CENTER></TD><TD WIDTH=300><CENTER><I>Description</I></CENTER>
</TD><TD WIDTH=163><CENTER><I>Displayed as</I></CENTER></TD></TR>
<TR><TD WIDTH=127><TT>@author</TT>
</TD><TD WIDTH=300>Adds a reference for the author of the document. Used with construct-related comments.
</TD><TD WIDTH=163><TT>Author:Author Name</TT>
</TD></TR>
<TR><TD WIDTH=127><TT>@version</TT>
</TD><TD WIDTH=300>Adds a reference for the version of the document. Used with construct-related comments.
</TD><TD WIDTH=163><TT>Version: X.X 01/01/99</TT>
</TD></TR>
<TR><TD WIDTH=127><TT>@see</TT></TD>
<TD WIDTH=300>Adds a hypertext reference to an HTML document. You specify the name of the file without the <TT>.html</TT> extension. You can associate this tag with any valid class in the API simply by specifying the class name. If you associate this tag 
with variables or methods, you can add links to variables and parameters in other documents. To  create a reference to a class's method, separate the class name and the method name with a pound sign, such as <TT>Applet#start</TT>.
</TD><TD WIDTH=163><TT>See Also: filename.html</TT>
</TD></TR>
<TR><TD WIDTH=127><TT>@param</TT>
</TD><TD WIDTH=300>Adds a parameter to the parameters section f the document. You specify the name of the arameter followed by a description of the parameter. Used with method-related comments.
</TD><TD WIDTH=163><TT>Parameters: Name Description</TT>
</TD></TR>
<TR><TD WIDTH=127><TT>@return</TT>
</TD><TD WIDTH=300>Specifies the value a method returns. Used with method-related comments.
</TD><TD WIDTH=163>R<TT>eturns: Description</TT>
</TD></TR>
<TR><TD WIDTH=127><TT>@exception</TT>
</TD><TD WIDTH=300>Specifies an exception a class throws. You specify the name of the exception followed by a description of the exception. Used with method-related comments.
</TD><TD WIDTH=163><TT>Exception: Name Description</TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheJavaInterpreter">The Java Interpreter</A></H3>
<P>
The Java interpreter executes Java bytecode files. You will use
the interpreter to run Java applications. Before the interpreter
runs any program, it verifies that the classes associated with
the program are valid and do not violate any language constraints.
<P>
The JDK includes two versions of the interpreter. The first version,
<TT>java</TT>, is optimized for normal
use and has only limited debugging capabilities. The second version,
<TT>java_g</TT>, is optimized for
debugging and is intended for use with the Java debugger.
<P>
You run the interpreter from the command line and pass it the
name of your Java class file without the <TT>.class</TT>
extension. For applications that include many classes, you will
want to pass the interpreter the name of the class that declares
the application's <TT>main()</TT>
method. The interpreter executes the <TT>main()</TT>
method and any threads specified in the <TT>main()</TT>
method. If no threads are created by the <TT>main()</TT>
method, the interpreter executes the <TT>main()</TT>
method and then exits. If threads are created by the <TT>main()</TT>
method, the interpreter exits when the last thread exits.
<P>
Because the interpreter expects the class file to contain a <TT>main()</TT>
method, you generally cannot use the interpreter to run Java applets.
If you want to run Java applets, you should use the Java applet
viewer discussed in the next section of this chapter. The interpreter
uses the following syntax:
<BLOCKQUOTE>
<TT>java [options] classname [args]</TT>
</BLOCKQUOTE>
<P>
Like other tools in the JDK, the Java interpreter accepts many
options. Unlike other tools in the JDK, the interpreter also allows
you to pass arguments to the class's <TT>main()</TT>
method. You do this by putting the values for the arguments after
the class name.
<P>
The <TT>-classpath</TT> option lets
you specify a path for your class files that overrides the default
or current <TT>CLASSPATH</TT> setting.
Because this option takes precedence, you should set it to include
the current directory, the location of your personal or third-party
class files, and the location of the Java API classes.
<P>
On UNIX platforms, you can specify a path for class files as follows:
<BLOCKQUOTE>
<TT>java -classpath .:\usr\jb_apps\vendorclasses:java\classes:
<BR>
&Acirc;java\lib\classes.zip QuizMaker</TT>
</BLOCKQUOTE>
<P>
On Windows 95/NT and OS/2 platforms, you can specify a path for
class files as follows:
<BLOCKQUOTE>
<TT>java -classpath .;C:\jb_apps\vendor;C:\java\classes;
<BR>
&Acirc;C:\java\lib\classes.zip QuizMaker</TT>
</BLOCKQUOTE>
<P>
An option of the interpreter that is sure to be a quick favorite
in large development environments is <TT>-checksource</TT>.
This option instructs the interpreter to make sure the compiled
classes are current and to recompile the source files if they
are not. The interpreter does this by comparing the modification
date on the source files to the modification date on the class
files. If any source file has a more recent date, that source
file is recompiled before the interpreter uses the associated
class. You can instruct the interpreter to check the source using
either <TT>-checksource</TT> or <TT>-cs</TT>,
like this:
<BLOCKQUOTE>
<TT>java -cs FirstApp<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
The <TT>-cs</TT> option serves the same purpose as the <TT>-checksource</TT> option. The primary reason for introducing the <TT>-cs</TT> option was to save keystrokes over the longer <TT>-checksource</TT> option.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Another useful option is <TT>-debug</TT>,
which lets you attach the Java debugger tool to an interpreter
session. When you use this option, the interpreter displays a
password that must be used when starting the debugging session.
The password is randomly allocated by session.
<P>
To track interpreter activity, you will want to use the <TT>-verbose</TT>
or <TT>-v</TT> option. With this option,
you can turn on verbose messaging and see what class files the
interpreter is using. The classes the interpreter loads at runtime
are very different from the classes used when the source is compiled.
If you change to the directory containing the source for the <TT>FirstApp</TT>
program discussed in <A HREF="ch4.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch4.htm" >Chapter 4</A> and type
the following:
<BLOCKQUOTE>
<TT>java -verbose FirstApp<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
The <TT>-v</TT> option serves the same purpose as the <TT>-verbose</TT> option. The primary reason for introducing the <TT>-v</TT> option was to save keystrokes over the longer <TT>-verbose</TT> option.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
You will see output similar to the following:
<BLOCKQUOTE>
<TT>[Loaded java/lang/Cloneable.class from
C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/ThreadGroup.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/System.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/io/BufferedInputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Thread.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/Object.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/Class.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/String.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/ThreadDeath.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Error.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/Throwable.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Exception.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/RuntimeException.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Cloneable.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/ThreadGroup.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/System.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/io/BufferedInputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/FilterInputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/InputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/FileInputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/FileDescriptor.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/PrintStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/FilterOutputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/OutputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/BufferedOutputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/io/FileOutputStream.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/StringBuffer.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Integer.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/Number.class from C:\JAVA\LIB\CLASSES.ZIP]<BR>
[Loaded java/lang/NoClassDefFoundError.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/LinkageError.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/OutOfMemoryError.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/lang/VirtualMachineError.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded .\FirstApp.class]<BR>
[Loaded java/lang/Compiler.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/util/Properties.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/util/Hashtable.class from C:\JAVA\LIB\CLASSES.ZIP]
<BR>
[Loaded java/util/Dictionary.class from C:\JAVA\LIB\CLASSES.ZIP]</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>[Loaded java/util/HashtableEntry.class
from C:\JAVA\LIB\CLASSES.ZIP]</TT>
</BLOCKQUOTE>
<P>
Another way to track interpreter activity is with the <TT>-t</TT>
option. This option traces every instruction the Java virtual
machine executes and is used only with the debugging version of
the interpreter, <TT>java_g</TT>.
Although this option is useful for advanced debugging, the listing
is too lengthy for any other use. The instruction list for the
five-line <TT>FirstApp</TT> program
filled 175 pages.
<P>
If you want to check where your program is spending the most time
during execution, you can use the <TT>-prof</TT>
option. This option of the interpreter effectively replaced the
profiler tool that was included in the Alpha release of the Java
programming language. Using the <TT>-prof</TT>
option, you can pinpoint areas of the code that are eating up
more system time than they should. Often, you can rework the related
section of code and improve the performance of the program.
<P>
When you run the interpreter with the <TT>-prof</TT>
option, it dumps the profile information to a file called <TT>java.prof</TT>
in the current directory. If you use the profile option on the
<TT>FirstApp</TT> program, you will
generate a file that fills three printed pages. Profiling information
is broken down into sections. Each section is preceded by a comment
statement that tells you the order of columns in the output. You
can profile the <TT>FirstApp</TT>
program using the following command:
<BLOCKQUOTE>
<TT>java -prof FirstApp</TT>
</BLOCKQUOTE>
<P>
The example that follows has two sections of profile information.
The first section shows you the system count, the object called,
the calling object, and the system time. The second section shows
you how many handles were used, the number of free handles, the
amount of heap used, and the amount of heap free. Here's the example:
<BLOCKQUOTE>
<TT># count callee caller time<BR>
4 java/lang/System.arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V
<BR>
&Acirc;java/lang/String.getChars(II[CI)V 0<BR>
39 java/lang/System.arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V
<BR>
&Acirc;java/lang/String.&lt;init&gt;([C)V 0<BR>
1 java/lang/Thread.getThreadGroup()Ljava/lang/ThreadGroup; java/lang/
<BR>
&Acirc;ThreadGroup.&lt;init&gt;(Ljava/lang/String;)V 0<BR>
1 java/lang/String.valueOf(I)Ljava/lang/String; java/lang/StringBuffer.
<BR>
&Acirc;append(I)Ljava/lang/StringBuffer; 10<BR>
<BR>
# handles-used, handles-free heap-used heap-free</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>124 78518 5232 2511344</TT>
</BLOCKQUOTE>
<P>
The interpreter includes a set of options for optimizing the runtime
environment. Each program running on the Java runtime environment
has a memory allocation pool assigned to it. The memory allocation
pool is also referred to as the <I>garbage-collected heap</I>
or simply the <I>heap</I>.
<P>
The <TT>-mx</TT> option lets you specify
the maximum number of bytes to be allocated to the heap. All values
you specify for the heap must be greater than 1,000 bytes and
can be allocated in kilobytes or megabytes. By default, the interpreter
sets this value to 16MB.
<P>
To set the maximum heap size in kilobytes, follow the value by
<TT>k</TT>, with no intervening space,
like this:
<BLOCKQUOTE>
<TT>java -mx 900k FirstApp</TT>
</BLOCKQUOTE>
<P>
To set the maximum heap size in megabytes, follow the value by
<TT>m</TT>, with no intervening space,
like this:
<BLOCKQUOTE>
<TT>java -mx 1m FirstApp</TT>
</BLOCKQUOTE>
<P>
You can set the startup size of the heap using the <TT>-ms</TT>
option. All values you specify must be greater than 1,000 bytes
and can be allocated in kilobytes or megabytes. By default, the
interpreter sets this value to 1MB.
<P>
Java is a multithreaded programming environment. Each thread running
on the Java runtime environment has two stacks associated with
it. The first stack is used for Java code, and the second stack
is used for C code. Memory used by these stacks draws from the
total system memory pool. Whenever a new thread starts execution,
it is assigned a maximum stack size for Java code and for C code.
<P>
The default maximum stack size for Java code is 400KB. You can
override this default with the <TT>-oss</TT>
option. All values you specify must be greater than 1,000 bytes
and can be allocated in kilobytes or megabytes, such as
<BLOCKQUOTE>
<TT>java -oss 100k FirstApp</TT>
</BLOCKQUOTE>
<P>
The default maximum stack size for C code is 128KB. You can override
this default with the <TT>-ss</TT>
option. All values you specify must be greater than 1,000 bytes
and can be allocated in kilobytes or megabytes, such as
<BLOCKQUOTE>
<TT>java -ss 100k FirstApp<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=590><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
If you set new values for stack size, you are specifying a maximum value that is assigned when new threads begin execution. Thus every thread that is spawned will inherit this value.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The interpreter provides you with control over garbage collection.
Normally, garbage collection is performed automatically as a background
thread, and the runtime environment goes about its business without
telling anyone what it is doing. You can override this in two
ways. You can either set the verbose flag for garbage collection
using the <TT>-verbosegc</TT> option,
which tells the runtime environment to print out messages whenever
it frees memory, or you can turn off background garbage collection
using <TT>-noasyncgc</TT>, the no
asynchronous garbage-collection flag.
<P>
When you set the <TT>-noasyncgc</TT>
option, no garbage collection takes place unless the program runs
out of memory or explicitly tells the system to perform garbage
collection. If it seems like a bad thing to let the program run
out of memory before freeing memory, that's because it usually
is. Garbage collection is a powerful feature of Java, and you
should turn it off only in an extremely limited set of circumstances.
<P>
Before executing any program loaded over the network, the interpreter
checks the validity of the class files. Part of the validation
process is to ensure that the class file does not violate system
security. This default option is called <TT>-verifyremote</TT>.
The interpreter allows you to make verification more strict with
the <TT>-verify</TT> option and to
turn off verification completely with the <TT>-noverify</TT>
option. Whereas the <TT>-verify</TT>
option causes the interpreter to check the validity of all classes
prior to execution, the <TT>-noverify</TT>
option goes to the other extreme and tells the interpreter to
never validate classes.
<P>
To override property values set in any program, you can use the
<TT>-D</TT> option. This option redefines
a named property value to a value you set. You can use the <TT>-D</TT>
option to change the background color of text, windows, or buttons.
The syntax for this option is
<BLOCKQUOTE>
<TT>java -DpropertyName=newValue classname</TT>
</BLOCKQUOTE>
<P>
The command-line syntax for the interpreter is
<BLOCKQUOTE>
<TT>java [options] classname [args]</TT>
</BLOCKQUOTE>
<P>
The interpreter takes the following options:<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Option</I></CENTER></TD><TD WIDTH=415><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=175><TT>-classpath</TT>
</TD><TD WIDTH=415>Overrides the default or current <TT>CLASSPATH</TT> environment variable setting.
</TD></TR>
<TR><TD WIDTH=175><TT>-cs</TT>, <TT>-checksource</TT>
</TD><TD WIDTH=415>Instructs the interpreter to make sure the compiled classes are current and to recompile the source files if they are not.
</TD></TR>
<TR><TD WIDTH=175><TT>-ms</TT></TD>
<TD WIDTH=415>Sets the startup size of the heap.</TD></TR>
<TR><TD WIDTH=175><TT>-mx</TT></TD>
<TD WIDTH=415>Specifies the maximum number of bytes to be allocated to the heap.
</TD></TR>
<TR><TD WIDTH=175><TT>-noasyncgc</TT>
</TD><TD WIDTH=415>Tells the runtime environment to perform no asynchronous garbage collection unless the program runs out of memory or the program explicitly tells the system to perform garbage collection.
</TD></TR>
<TR><TD WIDTH=175><TT>-noverify</TT>
</TD><TD WIDTH=415>Turns off validity checking of class files.
</TD></TR>
<TR><TD WIDTH=175><TT>-oss</TT></TD>
<TD WIDTH=415>Sets the maximum stack size used for Java code.
</TD></TR>
<TR><TD WIDTH=175><TT>-prof</TT></TD>
<TD WIDTH=415>Dumps profiling information to a file called <TT>java.prof</TT> in the current directory.
</TD></TR>
<TR><TD WIDTH=175><TT>-ss</TT></TD>
<TD WIDTH=415>Sets the maximum stack size used for C code.</TD>
</TR>
<TR><TD WIDTH=175><TT>-t</TT></TD>
<TD WIDTH=415>Traces every instruction the Java Virtual Machine executes. Used only with the debugging version of the interpreter, <TT>java_g</TT>.
</TD></TR>
<TR><TD WIDTH=175><TT>-v</TT>, <TT>-verbose</TT>
</TD><TD WIDTH=415>Tells you what class files the interpreter is loading.
</TD></TR>
<TR><TD WIDTH=175><TT>-verbosegc</TT>
</TD><TD WIDTH=415>Tells the runtime environment to print out messages whenever it frees memory.
</TD></TR>
<TR><TD WIDTH=175><TT>-verify</TT>
</TD><TD WIDTH=415>Checks the validity of all class files.</TD>
</TR>
<TR><TD WIDTH=175><TT>-verifyremote</TT>
</TD><TD WIDTH=415>Checks the validity of the class files before loading over the network (default for the interpreter).
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TheJavaAppletViewer">The Java Applet Viewer</A></H3>
<P>
The Java applet viewer enables you to view applets without a Web
browser. Because applets extend the <TT>Applet</TT>
class and are made for viewing in Web documents, you must create
an HTML document with the appropriate markup before you can use
the applet viewer. After you have created such a document, you
can use the applet viewer to view your applets.
<P>
You run the applet viewer from the command line by passing it
the name or path to an HTML document that references one or more
applets, such as
<BLOCKQUOTE>
<TT>appletviewer example.html</TT>
</BLOCKQUOTE>
<P>
Before displaying any applets, the applet viewer verifies that
the HTML document contains an <TT>&lt;APPLET&gt;</TT>
tag with three specific attributes: <TT>CODE</TT>,<TT>
WIDTH</TT>, and <TT>HEIGHT</TT>.
The <TT>CODE</TT> attribute tells
the viewer what class file to load. The <TT>WIDTH</TT>
and <TT>HEIGHT</TT> attributes tell
the viewer what the size of the applet's canvas should be. The
viewer also looks for the optional <TT>&lt;PARAM&gt;</TT>
tag that sets input parameters for your applets. (<A HREF="ch15.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch15.htm" >See Chapter 15</A>,
&quot;Creating Java-Powered Web Presentations with Applets,&quot;
for a complete discussion on creating Java-enhanced HTML documents.)
<P>
The applet viewer does not make use of any other HTML tags within
the document. This means your HTML document will not look the
same as it would when viewed with a Java-capable Web browser.
For each defined <TT>&lt;APPLET&gt;</TT>
tag in the document, the applet viewer starts up a separate window,
the height and width of which are determined by the attributes
you set. This means that if you add three applets to a document,
the applet viewer will place the applets in three separate windows.
If you want to see how it looks to have three applets running
in separate windows, view the Web presentation you create in <A HREF="ch15.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch15.htm" >Chapter 15</A>
with the applet viewer.
<P>
The only option the applet viewer takes from the command line
is the <TT>-debug</TT> option, which
starts a debugging session with the Java debugger. With this option,
you can debug your applets. (<A HREF="ch23.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch23.htm" >See Chapter 23</A>
for more information on the Java debugger.)
<P>
The command-line syntax for the applet viewer is
<BLOCKQUOTE>
<TT>appletviewer [option] document.html</TT>
</BLOCKQUOTE>
<P>
The applet viewer takes the following option:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Option</I></CENTER></TD><TD WIDTH=194><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=81><TT>-debug</TT></TD>
<TD WIDTH=194>Starts a debugging session.</TD></TR>
</TABLE></CENTER>
<P>
<H4>Additional Options Available While Running the Applet Viewer
</H4>
<P>
When you are running an applet, an additional menu called Applets
is available from the menu bar. After editing the HTML document
associated with an applet, you can reload the document and the
applet by selecting Reload from the Applets menu. Another useful
option of the viewer is Clone. If you select Clone from the Applets
menu, you can make a new copy of the applet window and restart
the associated applet. This is useful if you are testing the behavior
of the applet. Instead of reloading all the files associated with
an applet or cloning an applet, you might want to restart the
applet. To do that, you can select Restart from the Applets menu.
<P>
Two other options available from the menu can provide you information
about an applet. The Tag option displays the <TT>&lt;APPLET&gt;</TT>
tag associated with the currently running applet. The Info option
shows additional information about the applet. Finally, the Close
option closes the applet viewer window, and the Quit option exits
the applet viewer.
<P>
When an applet is running in the applet viewer, these options
are available from the viewer's menu:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Menu Option</I></CENTER></TD><TD WIDTH=483><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=107>Clone</TD><TD WIDTH=483>Allows you to make a new copy of the applet window and restart the associated applet.
</TD></TR>
<TR><TD WIDTH=107>Edit</TD><TD WIDTH=483>Allows you to edit a document associated with the current applet.
</TD></TR>
<TR><TD WIDTH=107>Info</TD><TD WIDTH=483>Allows you to see additional information about the current applet.
</TD></TR>
<TR><TD WIDTH=107>Properties</TD><TD WIDTH=483>Allows you to set access options for the applet.
</TD></TR>
<TR><TD WIDTH=107>Quit</TD><TD WIDTH=483>Allows you to quit the viewer.
</TD></TR>
<TR><TD WIDTH=107>Reload</TD><TD WIDTH=483>Allows you to reload an applet and all associated files.
</TD></TR>
<TR><TD WIDTH=107>Restart</TD><TD WIDTH=483>Allows you to restart an applet but does not reload the applet or its associated files.
</TD></TR>
<TR><TD WIDTH=107>Tag</TD><TD WIDTH=483>Allows you to display the <TT>&lt;APPLET&gt;</TT> tag associated with the currently running applet.
</TD></TR>
</TABLE></CENTER>
<P>
<H4>Applet Viewer Security Mechanisms</H4>
<P>
The applet viewer loads local and remote applets using two different
mechanisms. Applets that exist on the local file system and in
a directory defined in the <TT>CLASSPATH</TT>
environment variable are loaded by the file system loader. Applets
downloaded from the network or that are not in a directory defined
in the <TT>CLASSPATH</TT> environment
variable are loaded by the applet class loader.
<P>
Applets loaded by the applet class loader are subject to the restrictions
of the applet security manager. The security manager adds an additional
layer of security controls to untrusted applets, which ensures
the integrity of the client machine is not compromised when accessing
remote information. These security controls place restrictions
on what untrusted applets can and cannot do on the client system.
<P>
Specifically, untrusted applets cannot
<UL>
<LI>Read or write files
<LI>Make directories
<LI>List files in a directory
<LI>Check file type, size, or modification date
<LI>Start another program on the client
<LI>Access other clients or IP addresses
<LI>Access native code or libraries
</UL>
<P>
Although applets loaded by the file system loader are trusted,
the applet viewer still maintains security controls over them.
These security controls can be relaxed by setting property values.
You set property values in the file called, appropriately, <TT>properties</TT>.
This file is located in the <TT>.hotjava</TT>
directory under the Java installation directory and can be edited
with a plain text editor.
<H4>Allowing Applets to Read Files and Directories</H4>
<P>
You can allow local applets to read files and directories by adding
them to the access control list. To do this, set the property
value <TT>acl.read</TT> equal to the
files or directories you want applets to be able to read.
<H5>Reading Files on UNIX Systems</H5>
<BLOCKQUOTE>
On a UNIX system, if you want applets to read a file called <TT>numbers.txt</TT>
in the <TT>$HOME\java</TT> directory,
edit the <TT>properties</TT> file
and insert the following line:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=$HOME\java\numbers.txt</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to access all the files in the
<TT>$HOME\java</TT> directory, you
can do this by setting the value for <TT>acl.read</TT>
to
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=$HOME\java</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to read multiple directories or
files, separate each entry by colons, like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=\java\applets\docs:\usr\images\gifs:\usr\temp</TT>
</BLOCKQUOTE>
<H5>Reading Files on Windows and OS/2 Systems</H5>
<BLOCKQUOTE>
On a Windows or OS/2 system, if you want applets to read a file
called <TT>numbers.txt</TT> in the
<TT>C:\java</TT> directory, edit the
<TT>properties</TT> file and insert
the following line:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=C:\java\numbers.txt</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to access all the files in the
<TT>C:\java</TT> directory, you can
do this by setting the value for <TT>acl.read</TT>
to
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=C:\java</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to read multiple directories or
files, separate each entry by semicolons, like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.read=C:\java;C:\java\applets\docs</TT>
</BLOCKQUOTE>
<H4>Allowing Applets to Write to Files and Directories</H4>
<P>
You can allow local applets to write to files and directories
by adding them to the access control list. To do this, set the
property value <TT>acl.write</TT>
equal to the files or directories to which you want applets to
be able to write.
<H5>Writing to Files on UNIX Systems</H5>
<BLOCKQUOTE>
On a UNIX system, if you want applets to write to a file called
<TT>numbers.txt</TT> in the <TT>$HOME\java</TT>
directory, edit the <TT>properties</TT>
file and insert the following line:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=$HOME\java\numbers.txt</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to write to files in the <TT>$HOME\java</TT>
directory, you can do this by setting the value for <TT>acl.write</TT>
to
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=$HOME\java</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to write to multiple directories
or files, separate each entry by colons, like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=\java\applets\docs:\usr\images\gifs:\usr\temp</TT>
</BLOCKQUOTE>
<H5>Writing to Files on Windows and OS/2 Systems</H5>
<BLOCKQUOTE>
On a Windows or OS/2 system, if you want applets to write to a
file called <TT>numbers.txt</TT> in
the <TT>C:\java</TT> directory, edit
the <TT>properties</TT> file and insert
the following line:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=C:\java\numbers.txt</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to write to files in the <TT>C:\java</TT>
directory, you can do this by setting the value for <TT>acl.write</TT>
to
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=C:\java</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want applets to be able to write to multiple directories
or files, separate each entry by semi-colons, like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>acl.write=C:\java;C:\java\applets\docs</TT>
</BLOCKQUOTE>
<H4>Applet Viewer Property Values</H4>
<P>
As you have seen, setting property values for local applets can
be very useful. Many other property values are available to local
applets as well. To access additional property values from within
an applet, you can use the <TT>getProperty()</TT>
method of the <TT>System</TT> class.
Here's how:
<BLOCKQUOTE>
<TT>String s = System.getProperty(&quot;valuename&quot;);</TT>
</BLOCKQUOTE>
<P>
where <TT><I><FONT FACE="Courier">valuename</FONT></I></TT> is
the name of the property value you want to check, such as
<BLOCKQUOTE>
<TT>String s = System.getProperty(&quot;java.version&quot;);</TT>
</BLOCKQUOTE>
<P>
As shown in Table 5.2, local applets can access some property
values by default. To remove access to these values, you can set
them to <TT>null</TT> in the <TT>.hotjava\properties</TT>
file, such as
<BLOCKQUOTE>
<TT>os.arch=null<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 5.2. Default system properties.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Property Value</I></CENTER></TD>
<TD WIDTH=333><CENTER><I>Description</I></CENTER></TD></TR>
<TR><TD WIDTH=196><TT>file.separator</TT>
</TD><TD WIDTH=333>The file separator for your operating system
</TD></TR>
<TR><TD WIDTH=196><TT>java.class.version</TT>
</TD><TD WIDTH=333>Java class version number</TD></TR>
<TR><TD WIDTH=196><TT>java.vendor</TT>
</TD><TD WIDTH=333>Java vendor-specific information</TD></TR>
<TR><TD WIDTH=196><TT>java.vendor.url</TT>
</TD><TD WIDTH=333>URL of a particular vendor</TD></TR>
<TR><TD WIDTH=196><TT>java.version</TT>
</TD><TD WIDTH=333>Java version number</TD></TR>
<TR><TD WIDTH=196><TT>line.separator</TT>
</TD><TD WIDTH=333>The line separator for your operating system
</TD></TR>
<TR><TD WIDTH=196><TT>os.arch</TT>
</TD><TD WIDTH=333>Operating-system architecture</TD></TR>
<TR><TD WIDTH=196><TT>os.name</TT>
</TD><TD WIDTH=333>Operating-system name</TD></TR>
<TR><TD WIDTH=196><TT>path.separator</TT>
</TD><TD WIDTH=333>The file path separator for your operating system
</TD></TR>
</TABLE></CENTER>
<P>
As shown in Table 5.3, there are other property values that local
applets can access only if they are set to <TT>true</TT>
in the <TT>.hotjava\properties</TT>
file. You enter these values in the form <TT>valuename.applet=true</TT>.
Here's how you could allow applets to read the <TT>user.name</TT>
value:
<BLOCKQUOTE>
<TT>user.name.applet=true<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 5.3. Restricted system properties.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Property Value</I></CENTER></TD>
<TD WIDTH=231><CENTER><I>Description</I></CENTER></TD></TR>
<TR><TD WIDTH=167><TT>java.home</TT>
</TD><TD WIDTH=231>Java installation directory</TD></TR>
<TR><TD WIDTH=167><TT>java.class.path</TT>
</TD><TD WIDTH=231>Java <TT>CLASSPATH</TT> setting
</TD></TR>
<TR><TD WIDTH=167><TT>user.name</TT>
</TD><TD WIDTH=231>User's account name</TD></TR>
<TR><TD WIDTH=167><TT>user.home</TT>
</TD><TD WIDTH=231>User's home directory</TD></TR>
<TR><TD WIDTH=167><TT>user.dir</TT>
</TD><TD WIDTH=231>User's current working directory</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="GraphicalDevelopersTools"><FONT SIZE=5 COLOR=#Ff0000>Graphical
Developer's Tools</FONT></A></H2>
<P>
Graphical developer's tools for Java are available directly from
Sun and from third-party vendors. This section examines the developer's
tools available from Sun and its subsidiaries.
<H3><A NAME="MacintoshDevelopersTools">Macintosh Developer's Tools</A>
</H3>
<P>
The Macintosh has an entirely graphical user interface. For this
reason, the JDK for Macintosh is much more than a simple port
of the UNIX version. The first thing you will notice about the
JDK tools is that they have a familiar look and feel. You can
drag-and-drop files onto any of the tool icons to start them.
You also can start the tools by clicking on their icons. After
the tools are started, you can access pull-down menus that provide
you with options and let you set or change defaults.
<H4>Key Differences in Java Tools for the Macintosh</H4>
<P>
Where the Java developer's tools differ from Macintosh applications
is behind the scenes. Unlike the Solaris and Windows 95/NT operating
systems, the Macintosh operating system is not inherently multithreaded.
Because some multithreaded operations such as memory management
are automatic in Java, the lack of built-in multithreading posed
a major problem to the JDK developers.
<P>
The workaround was to perform multithreading at a higher level
than on other systems. This provides Macintosh users with most
of the advantages of a multithreaded environment. However, some
operations that are controlled at the operating-system level or
otherwise beyond Java's control block other threads. For example,
when a menu is down, all other operations are blocked.
<P>
Memory management is an example of an operation that is sometimes
blocking. Java is designed to automatically manage memory for
you as a background task, yet on the Macintosh background memory
management is not always possible. Periodically, Java tries to
free memory by deleting objects that are no longer referenced.
If Java cannot satisfy a request for memory, memory management
moves temporarily from the background to the foreground. When
this happens, you will see a busy cursor as Java searches for
objects that can be freed.
<P>
You can avoid most memory problems by increasing the default settings
for memory heaps to fit your needs and your system. On the Macintosh,
Java maintains two memory heaps. The Macintosh Application Heap
is used entirely for Macintosh allocations such as menus, windows,
and buttons. The garbage-collected heap, or GC heap, is used by
Java.
<P>
Whenever you start a new Java application, some memory is allocated
to both the application heap and the GC heap. You can determine
how much memory a Java application is allocated by checking the
value associated with the largest unused block of memory before
and after starting the application. This value can be found by
clicking on About this Macintosh from the Finder.
<H4>Changing Heap Settings</H4>
<P>
You can change the heap settings in the Finder. To change the
Macintosh Application Heap setting, follow these steps:
<OL>
<LI>Access the Finder tool.
<LI>Click on the Get Info command.
<LI>Change the setting for the application heap in the space provided.
</OL>
<P>
To change the garbage-collected heap setting, follow these steps:
<OL>
<LI>Access the Finder tool.
<LI>Click on the Get Info command.
<LI>Change the setting for MultiFinder Temporary Memory.
</OL>
<P>

<CENTER<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Warning:</B></TD></TR>
<TR><TD WIDTH=590>Before you change the heap settings, you should experiment with Java on your system.
</TD></TR>
</TABLE></CENTER>
<P>
<H4>The Java Compiler for Macintosh</H4>
<P>
When you compile Java programs, you will use the Java compiler.
The Java compiler expects source code to be in a file named with
the <TT>.java</TT> extension. Additionally,
when the source file contains multiple class declarations, the
source file must be named after the primary class declaration.
Therefore, it is good to always name your source files after the
primary class declaration. By default, the compiler uses between
800KB and 6000KB of temporary memory.
<P>
A handy feature of the compiler is the capability to link in a
text editor that can be controlled by <TT>AppleEvents</TT>.
This provides you with direct access to Java source files from
within the compiler. Some of the text editors you can use include
SimpleText, BBEdit 3.5 or later versions, and CodeWarrior IDE
versions 7 or 8. You can set your preferred editor by selecting
Preferences from the menu.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note:</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
<TT>AppleEvents</TT> allow the text editor and the Java compiler to communicate by passing &quot;events&quot; back and forth. Events contain information that allows the compiler to start the text editor.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The Preferences submenu also lets you set compiler and debugging
options. To better understand what these various options offer
you, review the section on the command-line version of the Java
compiler in this chapter.
<P>
The Java compiler automatically compiles your source code when
you do one of the following:
<UL>
<LI>Drag-and-drop a source file with the <TT>.java</TT>
extension onto the compiler icon.
<LI>Click on the compiler icon. After the compiler is started,
select Open from the File menu.
</UL>
<P>
For each class declaration in the source file, the Java compiler
creates a class file with a <TT>.class</TT>
extension. Because the compiler is case sensitive, the first part
of the class file will be named exactly as you typed it in the
source file. By default, the class files are placed in the same
directory as the source file.
<P>
When you start the compiler, a status window appears. From the
status window you can determine
<UL>
<LI>The current free memory in the Java garbage-collected heap
<LI>The current compiler activity
<LI>The number of simultaneous compiles
</UL>
<P>
Errors that occur during compiling are shown in a pop-up window.
You can use the error report to pinpoint problems in the code.
If you have set a preferred editor, you can go directly into an
editor session by doing one of the following:
<UL>
<LI>Double-clicking on the errors shown in the error window
<LI>Selecting Edit from the File menu
</UL>
<P>
After you correct errors, save the file. You can now recompile
the source file simply by selecting Rebuild from the File menu.
The Rebuild option tells the compiler to recompile the last source
file you tried to compile. If the source file still has errors,
they will be listed to an error window.
<P>
To close pop-up windows started by the compiler, you can select
the Close option from the menu. Each time you select Close, the
frontmost window will close. If the status window is the frontmost
window, the compiler will exit. You can also exit the compiler
simply by selecting Quit from the menu. Because all current compiler
actions are aborted when you quit, you generally should wait until
the compiler completes what it is doing before exiting.
<P>
The compiler has the following menu options:
<P>



<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Menu Option</I></CENTER></TD><TD WIDTH=483><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=107>Close</TD><TD WIDTH=483>Allows you to close the frontmost window.
</TD></TR>
<TR><TD WIDTH=107>Edit</TD><TD WIDTH=483>Allows you to edit a source file.
</TD></TR>
<TR><TD WIDTH=107>Open</TD><TD WIDTH=483>Allows you to open a source file. The compiler automatically tries to compile any files you open.
</TD></TR>
<TR><TD WIDTH=107>Preferences</TD><TD WIDTH=483>Allows you to set compiler options.
</TD></TR>
<TR><TD WIDTH=107>Quit</TD><TD WIDTH=483>Allows you to quit the compiler.
</TD></TR>
<TR><TD WIDTH=107>Rebuild</TD><TD WIDTH=483>Allows you to recompile the last source file you tried to compile.
</TD></TR>
</TABLE></CENTER>
<P>
<H4>The Applet Viewer for Macintosh</H4>
<P>
On the Macintosh, the Java applet viewer is designated by the
AppletViewer icon. The applet viewer allows you to view applets
without a Web browser. Because applets extend the <TT>Applet</TT>
class and are made for viewing in Web documents, you must create
an HTML document with the appropriate markup before you can use
the applet viewer. After you have created such a document, you
can use the applet viewer to view your applets.
<P>
To view an applet with the applet viewer, you can do one of the
following:
<UL>
<LI>Drag-and-drop an HTML document with the <TT>.html</TT>
extension onto the AppletViewer icon.
<LI>Click on the AppletViewer icon. After the applet viewer is
started, select Open Local from the File menu.
</UL>
<P>
Before displaying any applets, the applet viewer verifies that
the HTML document contains an <TT>&lt;APPLET&gt;</TT>
tag with three specific attributes: <TT>CODE</TT>,
<TT>WIDTH</TT>, and <TT>HEIGHT</TT>.
The <TT>CODE</TT> attribute tells
the viewer what class file to load. The <TT>WIDTH</TT>
and <TT>HEIGHT</TT> attributes tell
the viewer what the size of the applet's canvas should be. The
viewer also looks for the optional <TT>&lt;PARAM&gt;</TT>
tag that sets input parameters for your applets. (<A HREF="ch15.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch15.htm" >See Chapter 15</A>
for a complete discussion on creating Java-enhanced HTML documents.)
<P>
The applet viewer does not make use of any other HTML tags within
the document. This means your HTML document will not look the
same as it would when viewed with a Java-capable Web browser.
For each defined <TT>&lt;APPLET&gt;</TT>
tag in the document, the applet viewer starts up a separate window,
the height and width of which are determined by the attributes
you set. This means that if you add three applets to a document,
the applet viewer will place the applets in three separate windows.
If you want to see how it looks to have three applets running
in separate windows, use the applet viewer to view the Web presentation
you create in <A HREF="ch15.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch15.htm" >Chapter 15</A>.
<P>
By default, the applet viewer uses 300KB to 3000KB of temporary
memory. When you start the applet viewer, a status window appears.
From the status window you can determine
<UL>
<LI>The current free memory in the Java garbage-collected heap
<LI>The number of applets currently running on the system
</UL>
<P>
The Macintosh applet viewer lets you access applets on the Web.
You can do this by selecting Open URL from the menu. If you type
in the URL to an HTML document on the Web containing an applet,
the applet viewer will display the applet. This lets any Mac user
with the JDK installed on his system view applets even if his
browser does not support them.
<P>
Just as you can configure a text editor for the compiler, you
can configure a text editor for the applet viewer. Again, the
text editor must be controllable by <TT>AppleEvents</TT>.
You can set your preferred editor by selecting Properties from
the menu. The Properties submenu also lets you set applet viewer
options such as automatic verification of the class file and network
access.
<P>
When you are running an applet, an additional menu called Applets
is available from the menu bar. If you have set a preferred editor
for the applet viewer, you can go directly into an editor session
by selecting Edit from the Applets menu. You can use the editor
session to edit the HTML document associated with the running
applet. After you have made the necessary changes, save the HTML
document. You can then reload the document and its associated
applet by selecting Reload from the Applets menu.
<P>
Another useful option of the viewer is Clone. If you select Clone
from the Applets menu, you can make a new copy of the applet window
and restart the associated applet. This is useful if you are testing
the behavior of the applet. Instead of reloading all the files
associated with an applet or cloning an applet, you might want
to restart the applet. To restart an applet, you can select Restart
from the Applets menu.
<P>
Two additional options available from the menu can provide you
information about an applet. The Tag option displays the <TT>&lt;APPLET&gt;</TT>
tag associated with the currently running applet. The Info option
shows additional information about the applet.
<P>
The applet viewer has the following menu options when no applets
are running:
<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Menu Option</I></CENTER></TD><TD WIDTH=483><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=107>Open Local</TD><TD WIDTH=483>Allows you to load a local HTML document. The applet viewer automatically tries to display the applets defined by the <TT>&lt;APPLET&gt;</TT> tag within the document.
</TD></TR>
<TR><TD WIDTH=107>Open URL</TD><TD WIDTH=483>Allows you to load an HTML document located on a remote host. The applet viewer automatically tries to display the applets defined by the <TT>&lt;APPLET&gt;</TT> tag within the document.
</TD></TR>
<TR><TD WIDTH=107>Properties</TD><TD WIDTH=483>Allows you to set viewer options.
</TD></TR>
<TR><TD WIDTH=107>Quit</TD><TD WIDTH=483>Allows you to quit the viewer.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
When an applet is running in the viewer, these options are added
under the Applets menu:<P>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Menu Option</I></CENTER></TD><TD WIDTH=483><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=107>Clone</TD><TD WIDTH=483>Allows you to make a new copy of the applet window and restart the associated applet.
</TD></TR>
<TR><TD WIDTH=107>Edit</TD><TD WIDTH=483>Allows you to edit a document associated with the current applet.
</TD></TR>
<TR><TD WIDTH=107>Info</TD><TD WIDTH=483>Allows you to see additional information about the current applet.
</TD></TR>
<TR><TD WIDTH=107>Properties</TD><TD WIDTH=483>Allows you to set viewer options.
</TD></TR>
<TR><TD WIDTH=107>Reload</TD><TD WIDTH=483>Allows you to reload an applet and all associated files.
</TD></TR>
<TR><TD WIDTH=107>Restart</TD><TD WIDTH=483>Allows you to restart an applet but does not reload the applet or its associated files.
</TD></TR>
<TR><TD WIDTH=107>Tag</TD><TD WIDTH=483>Allows you to display the <TT>&lt;APPLET&gt;</TT> tag associated with the currently running applet.
</TD></TR>
</TABLE></CENTER>
<P>
<H4>The Java Interpreter for Macintosh</H4>
<P>
The Java interpreter executes Java bytecode files. You will use
the interpreter to run Java applications. Before the interpreter
runs any program, it verifies that the classes associated with
the program are valid and do not violate any language constraints.
For applications that include many classes, you will want to pass
the interpreter the class file that declares the application's
<TT>main()</TT> method.
<P>
The interpreter executes the <TT>main()</TT>
method and any threads specified in the <TT>main()</TT>
method. If no threads are created by the <TT>main()</TT>
method, the interpreter executes the <TT>main()</TT>
method and then exits. If threads are created by the <TT>main()</TT>
method, the interpreter exits when the last thread exits. Because
the interpreter expects the class file to contain a <TT>main()</TT>
method, you generally cannot use the interpreter to run Java applets.
If you want to run Java applets, you should use the Java applet
viewer discussed in the previous section of this chapter.
<P>
To view a Java application with the interpreter, you can
<UL>
<LI>Drag-and-drop the class file with the <TT>main()</TT>
method onto the interpreter icon.
<LI>Click on the interpreter icon. After the interpreter is started,
select Open from the File menu.
</UL>
<P>
Most of the interpreter features are similar to those discussed
in the previous sections of this chapter. You can set properties
for the interpreter in the Properties menu. You can reload an
application by selecting Reload from the File menu. To quit the
current interpreter session, you select Quit from the File menu.
<P>
The interpreter has the following menu options:<P>

<CENTER> <TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Menu Option</I></CENTER></TD><TD WIDTH=483><CENTER><I>Description</I></CENTER>
</TD></TR>
<TR><TD WIDTH=107>Edit</TD><TD WIDTH=483>Allows you to edit a document associated with the current application.
</TD></TR>
<TR><TD WIDTH=107>Open</TD><TD WIDTH=483>Allows you to open a class file. The interpreter automatically tries to run any files you open.
</TD></TR>
<TR><TD WIDTH=107>Properties</TD><TD WIDTH=483>Allows you to set interpreter options.
</TD></TR>
<TR><TD WIDTH=107>Quit</TD><TD WIDTH=483>Allows you to quit the current interpreter session.
</TD></TR>
<TR><TD WIDTH=107>Reload</TD><TD WIDTH=483>Allows you to reload an application and all associated files.
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="JavaWorkShop">Java WorkShop</A></H3>
<P>
The Java WorkShop is an integrated development environment that
helps you develop and manage just about any type of programming
project. Java WorkShop is a commercial product currently in development
by SunSoft.
<P>
Java WorkShop is currently available for Solaris and Windows 95/NT.
Free developers versions of Java WorkShop are available directly
from SunSoft at 
<BLOCKQUOTE>
<TT><A HREF="tppmsgs\msgs0.htm#33" tppabs="http://www.sun.com/sunsoft/Developer-products/java/">http://www.sun.com/sunsoft/Developer-products/java/</A></TT>
</BLOCKQUOTE>
<H4>Navigating the WorkShop</H4>
<P>
Java WorkShop's entire graphical development environment is placed
within a Webified desktop. This makes Java WorkShop as easy to
use as your favorite Web browser. Figure 5.5 shows the main window
for WorkShop. The navigation buttons depicted on the menu bar
are accessible from any part of the desktop.
<P>
<A HREF="f5-5.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-5.gif" ><B>Figure 5.5 : </B><I>Navigating the WorkShop.</I></A>
<P>
By clicking on a menu button, you can move quickly from tool to
tool. The suitcase button takes you to a Portfolio Manager. The
puzzle button takes you to a Project Manager. The pencil-and-notepad
button takes you to the source editor. The wrench button takes
you to a build session. The magnifying glass takes you to a source
browser. The ladybug button takes you to the debugger. The light-switch
button runs the current applet or application. The question-mark
button takes you to WorkShop's online help.
<P>
Each tool in Java WorkShop displays in an HTML page that contains
a specialized applet that performs a specific function such as
debugging your code. Some applets launch an associated editor
or browser. For example, the debugger applet starts a debugger
browser. Let's look at each of the key tools in Java WorkShop.
<H4>Built-in Help</H4>
<P>
You can access Java WorkShop's online help system at any time
by clicking on the Help button icon-the question mark on the main
toolbar. The online help system is organized into eight subject
areas:
<UL>
<LI>Contents-A list of all the help pages
<LI>Index-A subject index of help topics
<LI>Getting Started-An overview of Java WorkShop
<LI>Debugging Applets-How to use Java WorkShop to debug Java programs
<LI>Building Applets-How to use Java WorkShop to build Java programs
<LI>Managing Applets-How to manage projects and portfolios using
Java WorkShop
<LI>Editing Source-How to use Java WorkShop to edit source files
<LI>Browsing Source-How to use Java WorkShop to browse source
files
</UL>
<P>
You can access any of the help topics using the help toolbar.
As you can see from Figure 5.6, the help toolbar is clearly labeled
for easy navigation.
<P>
<A HREF="f5-6.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-6.gif" ><B>Figure 5.6 : </B><I>Using the built in help.</I></A>
<H4>The Portfolio Manager</H4>
<P>
You can access Java WorkShop's Portfolio Manager at any time by
clicking on the Portfolio Manager icon-the suitcase icon on the
main toolbar. The purpose of the Portfolio Manager is to help
you create and manage groups of projects called <I>portfolios</I>.
Figure 5.7 shows the project-creation page in Java WorkShop. Your
WorkShop projects can include local applets, remote applets, stand-alone
applications, images, and Java packages.
<P>
<A HREF="f5-7.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-7.gif" ><B>Figure 5.7 : </B><I>Creating a new project with the Portfolio Manager.</I></A>
<P>
By grouping projects into a portfolio, Java WorkShop allows you
to quickly build, browse, and debug portfolio components. For
example, each project in the portfolio is assigned an icon and
a name. When you are on the Portfolio Manager page, you can compile
all source files associated with a project by selecting its icon
and then selecting the Build button on the main toolbar.
<H4>Editing Projects</H4>
<P>
When you create a project using the Portfolio Manager, you define
attributes for the project-the puzzle icon on the main toolbar.
These attributes can be changed with the Project Editor. You can
access Java WorkShop's Project Editor at any time by clicking
on the Project Editor icon-the puzzle icon on the main toolbar.
<P>
As you can see from Figure 5.8, the Project Editor contains five
folders in which you can assign default attributes for the project:
<P>
<A HREF="f5-8.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-8.gif" ><B>Figure 5.8 :</B> <I>Editing your Java projects.</I></A>
<UL>
<LI>General-Allows you to specify general information for the
project including the name, type, and source directory of the
project.
<LI>Build-Allows you to specify information used when the project
is compiled
<LI>Debug/Browse-Allows you to specify information used when you
debug and browse source files
<LI>Run-Allows you to specify information used when you run an
applet or stand-alone application
<LI>Publish-Allows you to specify information used when you publish
the project for others to use it.
</UL>
<P>
You can access any of these folders simply by clicking on its
associated tab. Whenever you change information in a folder, you
should apply the changes before moving to another folder.
<H4>The Source Editor</H4>
<P>
When you want to create source files in Java WorkShop, you click
on the Source Editor icon-the pencil-and-notepad icon on the main
toolbar. The Source Editor in Java WorkShop is a stand-alone text
editor. Although the features of the editor are very basic, it
is easy to use and performs most of the tasks you would want a
source code editor to do. Figure 5.9 shows the Source Editor.
<P>
<A HREF="f5-9.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-9.gif" ><B>Figure 5.9 : </B><I>The Source Editor in Java WorkShop.</I></A>
<H4>Building Projects</H4>
<P>
Java WorkShop allows you to compile and build at any stage of
a project. To start a build session, you simply press the Build
button-the wrench icon on the main toolbar.
<P>
As you can see from Figure 5.10, the Program Builder allows you
to compile entire projects or single files. If you build a project,
the Program Builder uses the information you specified in the
Project Manager or Project Editor information session. If you
build a single file, the Program Builder uses the default settings
for the current project to compile the file.
<P>
<A HREF="f5-10.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-10.gif" ><B>Figure 5.10 :</B><I> Building your Java project.</I></A>
<H4>The Source Browser</H4>
<P>
When you want to view relationships in your source code, you will
use the Source Browser. The Source Browser displays documentation
for your WorkShop projects that resembles the documentation generated
by the Java API documentation generator-<TT>javadoc</TT>.
The advantage of the Source Browser is that you can view relationships
at any time during or after the creation of a project simply by
pressing the Source Browser button-the magnifying-glass icon on
the main toolbar.
<P>
Figure 5.11 shows some of the classes used in the <TT>CheckersGame</TT>
class, which is part of a demo applet that comes with Java WorkShop.
To ensure this documentation is easy to use for programs of any
size, the Source Browser includes a utility that allows you to
search for references in specified source files.
<P>
<A HREF="f5-11.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-11.gif" ><B>Figure 5.11 : </B><I>The Source Browser.</I></A>
<H4>The Debugger</H4>
<P>
To debug your code, you will use the WorkShop debugger, which
is accessible at any time from the main toolbar. When you start
a debugging session by clicking on the Debugger button-the lady-
bug icon on the main toolbar-Java WorkShop moves to the debugger
screen and starts a debugging browser. The purpose of the debugging
browser is to let you see how specific changes affect the appearance
of your Java program.
<P>
Debugging functions are organized into six folders. You can see
the tabs for these folders in Figure 5.12, which also shows the
debugging browser. Each folder provides you with control over
a specific set of related functions. For example, the Thread/Stacks
folder lets you view the current status of threads and stacks,
start and stop threads, and add or remove items from the stack.
<P>
<A HREF="f5-12.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-12.gif" ><B>Figure 5.12 : </B><I>The debugger and debugging browser.</I></A>
<P>
After you start a debugging session, Java WorkShop allows you
to perform limited debugging functions in the Source Editor. To
do this, the editor automatically displays a new toolbar with
icons for common debugging functions. These functions allow you
to stop at a breakpoint, clear breakpoints, resume execution of
all threads, step into the program line by line, run to the current
cursor location, move up the stack, and move down the stack.
<P>
Figure 5.13 shows the Source Editor with the debugging toolbar.
If you compare Figure 5.13 with Figure 5.9, you can easily identify
the changes.
<P>
<A HREF="f5-13.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-13.gif" ><B>Figure 5.13 : </B><I>The Source Editor with the debugging toolbar.</I></A>
<H4>Running Projects in Java WorkShop</H4>
<P>
Running your project is as easy as clicking the Run button-the
light-switch icon on the main toolbar. Depending on the type of
project you are creating, WorkShop will either open a browser
session or create a shell tool. Figure 5.14 shows the Checkers
applet running in WorkShop's main window.
<P>
<A HREF="f5-14.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f5-14.gif" ><B>Figure 5.14 : </B><I>Running the project.</I></A>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></A>
</H2>
<P>
Whether you use a UNIX-based system or a Windows-based system,
the Java Developer's Kit provides you with a complete toolkit
for developing powerful Java programs. The tools you will use
most often are the Java compiler, interpreter, and applet viewer.
Other tools in the JDK have a more limited purpose but are useful
as well. You can use the Java API documentation generator to create
online documentation. You will use the Java header and stub file
generator when you want Java classes to interact with C/C++ libraries.
You will use the Java class file disassembler when you want to
gain insight into the inner workings of class files.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch4.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch4.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
