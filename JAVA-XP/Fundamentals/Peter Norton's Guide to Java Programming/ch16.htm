<HTML>

<HEAD>
   <TITLE>Chapter 16 -- Applet Reuse</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015337112&ad_type=POPUP&category=net&id=8869e6649d4feb741365deba75790ba0";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 16</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Applet Reuse</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#AddingFunctionalitytoExistingApplets" >Adding Functionality to Existing Applets</A>
<UL>
<LI><A HREF="#DecidingBetweenReusingandRewritingC" >Deciding Between Reusing and Rewriting Code</A>
</UL>
<LI><A HREF="#WhentoReuse" >When to Reuse</A>
<LI><A HREF="#WhentoRewrite" >When to Rewrite</A>
<LI><A HREF="#ExtendinganApplet" >Extending an Applet</A>
<UL>
<LI><A HREF="#ReusingScrollText" >Reusing ScrollText</A>
<LI><A HREF="#ReusingRGB2Hex" >Reusing RGB2Hex</A>
<LI><A HREF="#ReusingtheQuizMakerApplet" >Reusing the QuizMaker Applet</A>
<LI><A HREF="#RewritingtheQuizMakerApplet" >Rewriting the QuizMaker Applet</A>
</UL>
<LI><A HREF="#TestingtheExtendedApplet" >Testing the Extended Applet</A>
<UL>
<LI><A HREF="#TestingtheScrollText2Applet" >Testing the ScrollText2 Applet</A>
<LI><A HREF="#TestingtheRGB2Hex2Applet" >Testing the RGB2Hex2 Applet</A>
<LI><A HREF="#TestingtheExtendedQuizMakerApplet" >Testing the Extended QuizMaker Applet</A>
<LI><A HREF="#TestingtheRewrittenQuizMakerApplet" >Testing the Rewritten QuizMaker Applet</A>
<LI><A HREF="#CreatingTestsforYourOwnApplets" >Creating Tests for Your Own Applets</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Software has become increasingly sophisticated and robust. The
time allocated to develop it has decreased while its complexity
has increased. To meet these conflicting demands, better tools
for creating software were developed. Yet even with better tools,
it is expensive and time-consuming to develop new software for
every aspect of a project. Furthermore, often there are portions
of a new project that are similar to work done on a preceding
project. If the code from preceding projects is incorporated into
the new project, time is saved not only on coding, but also on
design and testing.
<P>
Because of the advantages of reusing code, modern languages have
attempted to make code reuse easier. The object-oriented paradigm
helps to encapsulate implementation details and promote reuse.
Because Java is object-oriented, reuse of existing applets is
an important consideration when creating new applets with similar
features.
<P>
Java applets can be extended without modifying the existing code
by merely extending the original classes and adding new ones.
The advantage of adding code is the minimized chance of breaking
any working applet. Although there is no guarantee that the extension
will work the first time, there is no chance that the original
applet will cease to operate or that other applets extending the
original will be affected.
<P>
There are, however, times when it is advantageous to rewrite existing
code to include new features rather than simply extending it,
such as when there are fundamental changes to the understanding
that led to the original design of the applet. The ramifications
of such a change will depend on how widely the applet is used.
Sometimes it is easier to release a completely new applet under
a different name than simply leverage code from the existing applet.
<P>
The beginning of this chapter covers how to determine when reuse
is appropriate based on the existing applet and the new requirements.
Several examples of reusing code by extending applets are included.
The chapter then presents an example in which rewriting is preferable
to reuse.
<H2><A NAME="AddingFunctionalitytoExistingApplets"><B><FONT SIZE=5 COLOR=#Ff0000>Adding
Functionality to Existing Applets</FONT></B></A></H2>
<P>
One of the biggest advantages to an object-oriented programming
language such as Java is the ease with which existing code can
be reused. The capability to reuse code increases the programmer's
ability to modify both applets and applications. 
<P>
Applets can be extended by creating a new applet as an extension
of an existing one. Adding functionality to existing applets decreases
design and coding time, resulting in modifications being released
faster. The decrease in time between requirements analysis and
applet release increases the likelihood that the applet will meet
user needs.
<P>
Adding functionality to existing applets makes it easier to have
several related products or different versions of the same product.
Each product or version can be the result of different extensions.
<H3><A NAME="DecidingBetweenReusingandRewritingC"><B>Deciding
Between Reusing and Rewriting Code</B></A></H3>
<P>
Reuse, in general, includes extending classes, adding new methods,
overriding existing methods, or creating new classes to increase
functionality. Reusing an applet implies that you will create
a new class that is an extension of the original class. This extension
is not a replacement; therefore, it must have a new name. However,
because it is created by extending the original class, it will
inherit portions of its functionality from that class.
<P>
Class reuse allows you to build larger, more complex, more sophisticated
applets because you do not need to build the same pieces each
time you start a new project. Benefits of class reuse include
less code to develop, less code to maintain, and not having to
redesign the same items repeatedly. As programmers learn more
about the existing Java classes and increase their understanding
of these classes, better ways to combine classes to provide the
desired functionality will become apparent.
<P>
Using the same tools repeatedly, rather than switching regularly,
enables the programmer to become thoroughly familiar with the
classes. Reuse enables developers to create classes from a common
base set so that many classes can be developed with the same features
without having to recode the features.
<P>
Reuse is a benefit when it is easier to locate and include existing
objects than it is to create new objects. Object-oriented programming
languages in general make it easier to include existing code because
objects are encapsulated and only interact with each other in
well-defined ways. Now that you have learned how reusing and rewriting
can be employed to add functionality to existing applets, you
need to learn when it is appropriate to use each option.
<P>
Rewriting an applet means modifying one or more of the existing
class definitions in the applet. This type of change can take
many forms, including adding new class variables, changing the
algorithm in a method, changing the interaction between methods
of the class, or altering any underlying design decisions. When
an applet is rewritten, it will have the same name as the original
but will function differently. The original functionality may
be enhanced or decreased, or may remain the same in the new applet.
When you rewrite code, there is the potential of introducing errors
in working applets and the danger of breaking classes that are
an extension of the rewritten class.
<P>
Rewriting might not seem like a problem, but if the class has
been used in several places, modifying it has the potential to
affect several applets. Methods that are overridden in the extensions
might no longer function as expected. Class-level variables used
in the extension might be eliminated. New algorithms that improve
the functioning of the class might be incompatible with the design
of the class extensions.
<P>
The amount of challenge involved in rewriting an applet depends
on how extensively the classes involved have been reused. For
a single developer, there might be little risk in rewriting an
existing applet. The developer can easily determine all the places
where the applet has been used. However, for a  multi-person development
team with common object classes, changing a class can be a major
undertaking. The team must locate all the places the class has
been used and determine how the rewrite will affect those objects.
<P>
Changes that can be isolated and do not affect the overall design
of the class are best made by extending the class. Changes that
affect the core functionality of the class are best accomplished
by rewriting. It may be prudent to rewrite using a new class name
so that classes that are extensions of the existing one will continue
to function correctly. Deciding between reusing an applet and
rewriting it begins by accurately assessing the needs of the users.
<P>
Just as the first step in any development project is to determine
the needs the program must fulfill, the beginning of any modification
or enhancement is determining the requirements. This includes
determining new functionality to be added, areas that could be
improved, and perhaps some features that can be eliminated altogether.
It is important to accurately understand the changes that are
desired. A project that successfully implements unwanted changes
is not truly successful.
<P>
Some questions to consider in determining the needs for a particular
applet with regard to reusing or rewriting are
<UL>
<LI>What functionality does the applet currently provide?
<LI>How could the existing features be enhanced?
<LI>What functionality is missing at this time?
<LI>Are all the features being used?
<LI>What functionality may be desired in the future?
</UL>
<P>
These questions are significant because they provide insight into
the true requirements of the new applet. An understanding of all
the existing functionality is needed so that all of it can be
incorporated into any rewrite and tested in the test plan for
the rewritten applet.
<P>
Studying ways to enhance the features of an applet to fulfill
new needs can help determine which classes you need to extend.
Asking about missing functionality indicates other ways the applet
needs to be extended. Similarly, noting unused features allows
for simplified redesign of an applet; unused features can be eliminated
altogether.
<P>
Looking at these needs helps to determine if an applet should
be extended or entirely rewritten. Suppose you have an applet
that allows a user to enter two numbers, sums the two numbers,
and displays the results. It is easy to imagine extending the
applet to display the average of the two numbers as well. However,
if you want an applet to sum a list of three or four numbers,
it might be more appropriate to rewrite the applet because there
will probably be modifications to the user input, code for checking
when the input is complete, changes to the summation routine,
and possibly changes to the display of the results to show how
many numbers were added. As part of the rewrite, the applet could
be made flexible enough to sum an arbitrarily long list of numbers
as well.<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD WIDTH=558>
<BLOCKQUOTE>
Although the coding effort involved in modifying an existing applet might not be as extensive as an initial development project, the analysis of requirements is as important and should be as extensive.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
When you have answered the questions about the current needs,
you can begin to look at ways to design and implement the new
features. Design is as important when extending an applet as it
is when creating a new one. When making these changes, it is often
helpful to find existing applets with functionality similar to
the features you plan to add. This is why a working knowledge
of a variety of Java objects is beneficial.
<P>
The best way to learn about the objects supplied with Java is
to examine existing applets and applications. You can look at
the ones supplied with this book, work through them, and then
download more applets from the Internet. You should also review
the API to determine existing classes that can make developing
your applet easier.
<P>
Carefully examine existing classes and look at functionality from
an object-oriented point of view. An applet that plays sound clips
when a user presses a button is not very different from an applet
that displays images or plays MPEG clips when the user presses
a button. You might be able to convert an existing applet to a
new task with just a few minor changes.
<P>
It is important to gain a thorough understanding of the classes
that make up the existing applet to determine how to incorporate
the changes. Be sure to examine how the objects in the applet
communicate with one another and how a new object will affect
that communication. For example, if you reduce the size of the
applet, you might need to change the size of some of the objects
it displays. Part of understanding the classes used in an applet
is determining how objects are placed on the screen. Then you
can see what must be done to add a new object or change the layout.
<P>
When adding a new method, look at all the objects it might encounter
and think of all the ways it might be invoked. Consider the possible
side effects of changes to class variables or objects. Although
you can never take all possibilities into account, you might want
to consider where future enhancements are likely to occur and
how things can be structured now to incorporate them easily later.
<P>
You should consider whether parts of another existing applet are
similar to parts of the enhancement. Perhaps the controls and
user-input areas are similar to something that exists and only
the display needs to change, or vice versa. If code can be leveraged
from an existing applet, writing the extended applet will be faster
and easier.
<P>
The challenge in analyzing existing objects lies in the sheer
volume of objects from which to choose. You have all of the API
at your disposal, plus all the applets you have written, plus
the many applets that are available at no cost through the Internet.
One way to simplify your first attempt at a development project
is to search for an applet similar to the one you want to create
and to modify it.
<P>
Appearance is the most obvious way to analyze existing objects.
Does this object display the way I want? Does it have all the
parts I need? This is somewhat deceiving because the actual appearance
of the object is the easiest to change. If you like the functionality
of an object but do not like the image it displays or the shape
it has, you can extend the object and rewrite only the method(s)
that affect the display. Normally, all of the display will be
isolated in one or two methods, such as <TT><FONT FACE="Courier">draw()</FONT></TT>
or <TT><FONT FACE="Courier">paint()</FONT></TT>.
<P>
Besides appearance, consider the functionality of the object.
Look for desired features an object possesses and determine if
several objects working together are needed to create them. Study
any features in the object that are unnecessary or unwanted to
determine if they can be easily eliminated. Then determine any
additional functionality you will need before the object can be
used in the applet.
<P>
When studying the objects in an applet and considering new ones,
you should also consider flexibility. Would it be better to rewrite
an existing class at this time because it does not include enough
options to allow for future expansion?
<P>
The hardest part in extending an existing object is being sure
that your extensions are sufficient to bring about the changes
you want without introducing any unwanted side effects. To do
so, carefully examine the source code for the object. Pay close
attention to when it creates its own methods and when it is using
methods from a superclass. When you replace a method, you might
want to use a call to the superclass to include the existing method
as well as the one you create. Then again, it might be that you
don't want the method of the object you are extending, but you
do want the method of its superclass. Java is flexible enough
to allow you to make that decision.
<H2><A NAME="WhentoReuse"><B><FONT SIZE=5 COLOR=#Ff0000>When to
Reuse</FONT></B></A></H2>
<P>
In most development efforts, even when creating a new applet,
you will reuse existing classes. Indeed, it would be exhausting
and pointless to create all the objects by extending the <TT><FONT FACE="Courier">Object</FONT></TT>
class directly. The capability to reuse existing objects makes
Java a powerful language.
<P>
Rather than creating an object by extending the <TT><FONT FACE="Courier">Object</FONT></TT>
class, you should extend an existing object when it meets the
following criteria:
<UL>
<LI>It meets most of your requirements
<LI>It can be easily extended to meet all of your requirements
<LI>It can be incorporated into your design without extensive
changes
</UL>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=585>
<BLOCKQUOTE>
Because applets are just a particular type of object, these same guidelines can be applied to them.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
There are four challenges to using existing objects:
<UL>
<LI>Locating the most appropriate object
<LI>Assessing the merits of the existing object
<LI>Modifying the object to the exact needs of the applet
<LI>Maintaining an accumulation of objects
</UL>
<P>
Java assists with all four of these areas. It makes it easy to
locate existing objects by supplying the developer with the API
documentation in HTML form, including links to related objects
and an easy-to-search index. Because the documentation is electronic,
it can be extended to include new objects as they are developed.
The widespread popularity of the Java language and its portability
across platforms increase the possibility of a particular object
existing. Searching for suitable objects available on the Net
is simplified by the platform independence and object-oriented
nature of the language.
<P>
Java's documentation features enable developers to supply comments
that can help assess an object's applicability to a given situation.
The encapsulation of objects makes it easier to determine if an
existing object supplies all the functions needed or if new methods
must be added to the object for the new applet. Java also makes
it easy to create a simple applet and test the class to determine
its robustness and suitability.
<P>
It is particularly easy to adapt existing Java classes to specific
needs by extending them. There is no limit on the number of extensions
to a class, so existing classes can be extended many times. Therefore,
it is reasonable to create most new classes by extending existing
ones rather than extending the <TT><FONT FACE="Courier">Object</FONT></TT>
class. This means that more code can be reused and customized
to fit your needs.
<P>
Java's ability to extract documentation from the comments included
in the class definition eases the task of maintaining a large
collection of useful objects. Its packaging features enable developers
to group related classes. Its object-oriented nature and encapsulation
features mean that a particular class can be stored without worry
that it will be &quot;missing something&quot; if it is used again
somewhere else.
<P>
The Java language is clearly meant to assist with all four of
the challenges of code reuse. Because it is so conducive to reusing
code, you might wonder when it is appropriate to rewrite a Java
object. This topic is discussed in the next section.
<H2><A NAME="WhentoRewrite"><B><FONT SIZE=5 COLOR=#Ff0000>When
to Rewrite</FONT></B></A></H2>
<P>
Because rewriting code is inherently more costly than reusing
it, even more consideration should be given to the decision to
rewrite an applet. Rewrite an applet in the following situations:
<UL>
<LI>When you are altering its core functionality.
<LI>When the changes you are making will affect more methods and
classes than they will leave alone.
<LI>When you are making a change in an assumption that was fundamental
to the creation of the applet.
</UL>
<P>
Rewriting is appropriate if the core functions of the applet have
changed, if the assumptions on which the applet is based have
changed, or if a better method of accomplishing the applet's task
is found. Rewriting also may be necessary if the applet is communicating
with another program and the interface is modified.
<P>
An applet is just a particular type of object, so it is not surprising
that rewriting a single object is as challenging as rewriting
an entire applet. Before rewriting an applet, it is important
to isolate all the places that the object is used. Determine how
the changes will affect each applet where the object appears and
if the changes are desired in all of them. If the changes are
desired only in some of the applets, you are better off copying
the code to a new object class, making the changes there, and
modifying only the applets that need the change so they point
to the new class. This is the safest and often best way to modify
any existing class.
<P>
Before presenting an example of rewriting an applet, the following
sections illustrate several examples of applet extension. This
demonstrates the ease with which applets can be extended. It also
assists in establishing the circumstances when extending is better
than rewriting and vice versa.
<H2><A NAME="ExtendinganApplet"><B><FONT SIZE=5 COLOR=#Ff0000>Extending
an Applet</FONT></B></A></H2>
<P>
The steps for extending an applet are similar to the steps for
constructing a new one. You must design the modification, code
it, and test it. Testing is even more important when modifying
existing applets because you must ensure that no existing functionality
is lost, so it is discussed in detail in the &quot;Testing the
Extended Applet&quot; section in this chapter.
<P>
You must take care when extending classes, and when creating them
in the first place, to choose new class names that do not conflict
with other classes in use. This potential can be reduced by carefully
choosing names and by grouping classes into appropriate packages.
Classes in the same package must have unique class names. 
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=586>
<BLOCKQUOTE>
When considering the possibility of naming conflicts, keep in mind the five levels of the namespace used by Java. If two packages exist with classes having the same name, the package name is used to differentiate between the classes in an applet. 
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
This section presents three increasingly complex examples of extending
existing applets. It concludes with an example of an applet rewrite.
Notice that the amount of work involved in the extension does
not necessarily depend on the complexity of the initial applet.
<H3><A NAME="ReusingScrollText"><B>Reusing </B><TT><B><FONT SIZE=4 FACE="Courier">ScrollText</FONT></B></TT></A>
</H3>
<P>
The first example shows how simple extending an applet can be.
You will add another parameter to the <TT><FONT FACE="Courier">ScrollText</FONT></TT>
applet to allow the HTML document to specify the background color
of the applet. With this enhancement, the applet can run with
the same background color as the document and the text will appear
to be scrolling without a rectangular box around it.
<P>
The design of this modification is straightforward. The extended
applet will read the new parameter and set the new background
color at initialization. If the background parameter is not passed
from the HTML file, the applet will set the background to white.
For simplicity, the applet accepts input as a single integer in
base 10. However, the program could easily expect three integers,
three floats, or a single hex number such as HTML uses.
<P>
To create this extension, you will extend the existing <TT><FONT FACE="Courier">ScrollText</FONT></TT>
class to create a new class called <TT><FONT FACE="Courier">ScrollText2</FONT></TT>.
You need to create a <TT><FONT FACE="Courier">.java</FONT></TT>
file containing the code for the new class. This file must go
in the same directory as the existing <TT><FONT FACE="Courier">ScrollText</FONT></TT>
file so that the Java compiler can find the original <TT><FONT FACE="Courier">ScrollText</FONT></TT>
class. The Java compiler needs to read the <TT><FONT FACE="Courier">ScrollText.class</FONT></TT>
file before extending the class.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Technical Note</B></TD></TR>
<TR><TD WIDTH=561>
<BLOCKQUOTE>
When extending a class, the Java compiler needs to locate the original class file. If it cannot locate the original class file but can locate the original source file, it will attempt to compile the original source code before compiling the new source code 
file. Therefore, if the <TT><FONT FACE="Courier">ScrollText.java</FONT></TT> file containing the original class and the <TT><FONT FACE="Courier">ScrollText2.java</FONT></TT> file containing the extended class are in the same directory, the Java compiler 
will first compile the <TT><FONT FACE="Courier">ScrollText.java</FONT></TT> file to obtain the necessary class file and then compile the <TT><FONT FACE="Courier">ScrollText2.java</FONT></TT> file. The result of this is a <TT><FONT 
FACE="Courier">ScrollText.class</FONT></TT> file and a <TT><FONT FACE="Courier">ScrollText2.class</FONT></TT> file.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
In the new class, you will use the <TT><FONT FACE="Courier">Color</FONT></TT>
class, so you must import <TT><FONT FACE="Courier">java.awt.Color</FONT></TT>.
This is shown at the top of Listing 16.1. The new class will have
two new class-level variables. The first will hold the string
containing the input value of the new parameter, and the second
is an object in the <TT><FONT FACE="Courier">Color</FONT></TT>
class.
<P>
The new class only has one method, <TT><FONT FACE="Courier">init()</FONT></TT>.
This method overrides the <TT><FONT FACE="Courier">init()</FONT></TT>
method in <TT><FONT FACE="Courier">ScrollText</FONT></TT>. However,
the first line of code in the new <TT><FONT FACE="Courier">init()</FONT></TT>
method calls the <TT><FONT FACE="Courier">init()</FONT></TT> method
of its superclass. This means the <TT><FONT FACE="Courier">init()</FONT></TT>
method in the original <TT><FONT FACE="Courier">ScrollText</FONT></TT>
class is used to read and store the parameters that are defined
there. When that is completed, the <TT><FONT FACE="Courier">init()</FONT></TT>
method for <TT><FONT FACE="Courier">ScrollText2</FONT></TT> reads
the parameter supplied under the name <TT><FONT FACE="Courier">background</FONT></TT>.
If the value of this parameter is null, the <TT><FONT FACE="Courier">backColor</FONT></TT>
object is set to a default background color of white. If the parameter
is not null, it is converted to an integer and used to define
a new color in the <TT><FONT FACE="Courier">backColor</FONT></TT>
object. In the final line of the method in Listing 16.1, the <TT><FONT FACE="Courier">backColor</FONT></TT>
object is used by the method <TT><FONT FACE="Courier">setBackground()</FONT></TT>,
thereby setting the new background color.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=574>
<BLOCKQUOTE>
For simplicity's sake, the applet accepts color input as a single integer in base 10. This means the value for the background parameter may be any integer between 0 and 16,777,216, which is the range of colors on Java's 16.7 million-color 
palette.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 16.1. The </B><TT><B><FONT FACE="Courier">ScrollText2</FONT></B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.Color;<BR>
<BR>
/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming <BR>
&nbsp;* The ScrollText2 Applet<BR>
&nbsp;* This applet is used to scroll a text banner across the
screen<BR>
&nbsp;* and is an extension of the ScrollText Applet<BR>
&nbsp;* The applet takes BACKGROUND, TEXT, WIDTH, and HEIGHT<BR>
&nbsp;* as parameters.<BR>
&nbsp;*/<BR>
<BR>
public class ScrollText2 extends ScrollText {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String bs = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Input string containing background color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color backColor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Background color<BR>
<BR>
/* Setup width, height, and display text */<BR>
public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.init();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Do original initialization<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bs = getParameter(&quot;background&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bs == null){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Read color as input, if not found use default<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backColor
= Color.white;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
// Convert color string to color<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backColor
= new Color(Integer.parseInt(bs));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBackground(backColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Set the background color according to input<BR>
<BR>
&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
As you can see, the code for this example is quite short; however,
although the change is small, it is reasonable to extend the existing
class rather than to modify it. By extending the class, you eliminate
the risk of breaking working HTML pages that use the applet as
defined. You also provide two different versions of the applet,
so the Web-page designer can select the most appropriate version.
<P>
To compile the applet, save it to the file <TT><FONT FACE="Courier">ScrollText2.java</FONT></TT>
in the same directory as <TT><FONT FACE="Courier">ScrollText.java</FONT></TT>.
Then change to the directory containing the <TT><FONT FACE="Courier">ScrollText2.java</FONT></TT>
file and type the following at the command prompt:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac ScrollText2.java</FONT></TT>
</BLOCKQUOTE>
<P>
The new <TT><FONT FACE="Courier">ScrollText2</FONT></TT> class
can be used in an HTML file by including the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;APPLET CODE=ScrollText2 WIDTH=400
HEIGHT=200&gt;&lt;/APPLET&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
This example and the next both modify the screen displayed to
the user. The third example is somewhat more complex because it
involves multiple classes and requires that several methods be
modified.
<H3><A NAME="ReusingRGB2Hex"><B>Reusing </B><TT><B><FONT SIZE=4 FACE="Courier">RGB2Hex</FONT></B></TT></A>
</H3>
<P>
In this section, you will extend the <TT><FONT FACE="Courier">RGB2Hex</FONT></TT>
applet by adding a color wheel in the middle of the applet's canvas.
Having a color wheel will provide a means of contrasting the color
the user has entered with other existing colors and will assist
your users in picking values for the color they want.
<P>
This new functionality meets the criteria for applet reuse because
most of the existing applet remains the same. The core functionality
of the applet is unchanged, as is its overall operation. Although
you must make changes in several parts of the code, these sections
are easily isolated and extended.
<P>
There are tradeoffs in any software-construction or -modification
project. In this case, you could have created the color wheel
as a separate class and included a component of that class on
the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>. Alternatively,
you could modify the <TT><FONT FACE="Courier">paint()</FONT></TT>
method of the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT> class
to paint the color wheel after it colors the canvas. In this case,
because the color wheel is not required to perform any task, the
second option is best. However, you will isolate the additions
by creating a new method, <TT><FONT FACE="Courier">paintwheel()</FONT></TT>,
which will display the color wheel. The code for the new method
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void paintwheel(Graphics g,int
wheel_size,int wheel_x,int wheel_y){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 0, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.orange);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 60, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 120, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.green);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 180, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 240, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(new Color(150,0,150));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 300, 60);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">paintwheel()</FONT></TT> method requires
that the caller supply the <TT><FONT FACE="Courier">Graphics</FONT></TT>
object on which the wheel will be drawn. This works because the
<TT><FONT FACE="Courier">paint()</FONT></TT> method calling the
<TT><FONT FACE="Courier">paintwheel()</FONT></TT> method will
have a <TT><FONT FACE="Courier">Graphics</FONT></TT> object to
pass. <TT><FONT FACE="Courier">paintwheel()</FONT></TT> also requires
that the caller supply the x and y coordinates at which to draw
the wheel and the size of the wheel.
<P>
The method uses the <TT><FONT FACE="Courier">setColor()</FONT></TT>
and <TT><FONT FACE="Courier">fillArc()</FONT></TT> methods from
the <TT><FONT FACE="Courier">Graphics</FONT></TT> class to draw
a color wheel with six colors at the location specified. The <TT><FONT FACE="Courier">setColor()</FONT></TT>
method requires a <TT><FONT FACE="Courier">Color</FONT></TT> object
as a parameter. It sets the default color to the value it is passed.
The <TT><FONT FACE="Courier">fillArc()</FONT></TT> method creates
an arc on the screen using the default color that was set by <TT><FONT FACE="Courier">setColor()</FONT></TT>.
The arcs are drawn in a circle using the same x,y coordinates.
Six 60-degree angles are used to create a full circle. The colors
used are all defined colors in the <TT><FONT FACE="Courier">Color</FONT></TT>
class of the Java API, except for the purple arc because purple
is not part of the existing <TT><FONT FACE="Courier">Color</FONT></TT>
class. Purple is created as a new color in the <TT><FONT FACE="Courier">paintwheel()</FONT></TT>
method and then passed to the <TT><FONT FACE="Courier">setColor()</FONT></TT>
method.
<P>
Another alternative would be to create a <TT><FONT FACE="Courier">Color</FONT></TT>
class that includes a <TT><FONT FACE="Courier">Color.Purple</FONT></TT>
variable. To keep the extended applet as short as possible, however,
this option was not chosen. It is sometimes faster and easier
to define an instance of an object with a specific property, such
as the color purple, than to extend the entire class to include
that property. On the other hand, if you were to create several
applets using a specific color scheme that included shades of
purple, you might want to define a class called <TT><FONT FACE="Courier">ShadesOfPurple</FONT></TT>
that would include variables such as <TT><FONT FACE="Courier">PalePurple</FONT></TT>,
<TT><FONT FACE="Courier">LightPurple</FONT></TT>, <TT><FONT FACE="Courier">MediumPurple</FONT></TT>,
and <TT><FONT FACE="Courier">DarkPurple</FONT></TT>. The class
<TT><FONT FACE="Courier">ShadesOfPurple</FONT></TT> would have
to be formed by extending the <TT><FONT FACE="Courier">Object</FONT></TT>
class because the <TT><FONT FACE="Courier">Color</FONT></TT> class
is declared as final in the API, meaning that it cannot be extended
directly.
<P>
The <TT><FONT FACE="Courier">paintwheel()</FONT></TT> method draws
a color wheel, but it must be incorporated into the applet. The
method is included in a new class formed by extending the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>
class. The new class is called <TT><FONT FACE="Courier">RGBcanvas2</FONT></TT>
and is declared as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class RGBcanvas2 extends RGBcanvas {</FONT></TT>
</BLOCKQUOTE>
<P>
The new class's one new method is <TT><FONT FACE="Courier">paintwheel()</FONT></TT>,
which overrides the <TT><FONT FACE="Courier">paint()</FONT></TT>
method from <TT><FONT FACE="Courier">RGBcanvas</FONT></TT> and
inherits the remainder of its features. If you had created the
color wheel as a separate object, you would have had to redraw
the wheel each time you painted the canvas so that the wheel would
remain on top of the canvas. This would have meant changing the
controls to draw both the canvas and the wheel. Sometimes the
best way to incorporate a change is the one that involves changing
the fewest methods.
<P>
In this case, you want the color wheel to appear on the canvas.
Furthermore, the color wheel should appear no matter how many
times the canvas is redrawn. Otherwise, the <TT><FONT FACE="Courier">paint()</FONT></TT>
method of the <TT><FONT FACE="Courier">RGBcanvas2</FONT></TT>
class should perform all the tasks the <TT><FONT FACE="Courier">paint</FONT></TT>
method in the original <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>
class performs. Therefore, the <TT><FONT FACE="Courier">paint()</FONT></TT>
method in the new class contains the code from the <TT><FONT FACE="Courier">paint()</FONT></TT>
method in the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT> class.
Following that, it will call the method defined previously to
paint the color wheel on the display using the following line
of code: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">paintwheel(g, r.height/2, r.width/2 -
r.height/4, r.height/4);</FONT></TT>
</BLOCKQUOTE>
<P>
This is a complicated-looking line of code. Let's examine it more
closely to see what it accomplishes. The <TT><FONT FACE="Courier">paintwheel()</FONT></TT>
method defined earlier takes four parameters. The first is the
<TT><FONT FACE="Courier">Graphics</FONT></TT> object on which
to paint. This is supplied by the <TT><FONT FACE="Courier">paint()</FONT></TT>
method in the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT> class
and is the first parameter passed on the code line.
<P>
The next parameter specified is the diameter of the color wheel.
Because the area of the <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>
object is wider than it is tall, use one-half the height as the
diameter of the wheel. Conveniently, the <TT><FONT FACE="Courier">paint()</FONT></TT>
method of <TT><FONT FACE="Courier">RGBcanvas</FONT></TT> already
calls the <TT><FONT FACE="Courier">bounds()</FONT></TT> method
to determine its size. It stores this information in the rectangle
object <TT><FONT FACE="Courier">r</FONT></TT> that is referenced
in the code line. The height of the rectangle is <TT><FONT FACE="Courier">r.height</FONT></TT>.
The wheel should have a diameter of half the height, so pass <TT><FONT FACE="Courier">r.height/2</FONT></TT>
as the size of the wheel.
<P>
The last two parameters are the x and y coordinates for the lower-left
corner of the region where you want the wheel drawn. This is required
to accommodate the <TT><FONT FACE="Courier">drawArc()</FONT></TT>method
used in the <TT><FONT FACE="Courier">paintwheel()</FONT></TT>
method. You want the wheel to be centered from top to bottom and
from left to right, and you know that its diameter is half the
height of the box. Therefore, the y coordinate of the lower-left
corner is set at one-quarter of the height of the box, or <TT><FONT FACE="Courier">r.height/4</FONT></TT>.
<P>
The x coordinate is a little more complicated because the box
is wider than it is tall. First, you determine the center of the
box, <TT><FONT FACE="Courier">r.width/2</FONT></TT>. Then subtract
half the width of the circle you will draw. The total height of
the circle is <TT><FONT FACE="Courier">r.height/2</FONT></TT>,
so half the height of the circle is <TT><FONT FACE="Courier">r.height/4</FONT></TT>.
Therefore, the x coordinate for the <TT><FONT FACE="Courier">paintwheel()</FONT></TT>
method is <TT><FONT FACE="Courier">r.width/2</FONT></TT>-<TT><FONT FACE="Courier">r.height/4</FONT></TT>.
<P>
The complete <TT><FONT FACE="Courier">paint()</FONT></TT> method
appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">public void paint(Graphics g) {<BR>
Rectangle r = bounds();<BR>
<BR>
createColor =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Color(super.RedValue, super.GreenValue,
super.blueValue);<BR>
g.setColor(createColor);<BR>
g.fillRect(0,0,r.width,r.height);<BR>
paintwheel(g, r.height / 2, r.width/2 - r.height/4, r.height/4);</FONT></TT>
</BLOCKQUOTE>
<P>
The method as defined raises two questions: First, why wasn't
a call to the superclass used, as in the last example, to use
the <TT><FONT FACE="Courier">paint()</FONT></TT> method in <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>?
Primarily because you needed the values <TT><FONT FACE="Courier">r.height</FONT></TT>
and <TT><FONT FACE="Courier">r.width</FONT></TT> to pass to the
<TT><FONT FACE="Courier">paintwheel()</FONT></TT> method. Because
you cannot access these values from the superclass, you had the
option of re-creating the entire procedure or repeating the work
of creating the rectangle. Second, why was this complex formula
created rather than giving <TT><FONT FACE="Courier">paintwheel</FONT></TT>
explicit x and y coordinates? The formula ensures that the color
wheel will be centered in the <TT><FONT FACE="Courier">RGBcanvas2</FONT></TT>
no matter how the canvas is sized. Using the formula means that
the class is flexible enough to handle small and large sizes.
<P>
Having added this new class, you can compile and test it. Notice
that there is no resulting change to the applet. You still must
use the new class somewhere in the existing code. To do this,
you must extend the applet itself. The new applet will be an extension
of <TT><FONT FACE="Courier">RGB2Hex</FONT></TT>, just as the new
canvas is an extension of <TT><FONT FACE="Courier">RGBcanvas</FONT></TT>.
<P>
Select a new name for the extended applet, in this case, <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>.
This applet is stored in a separate file, and the class <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>
is created as an extension of <TT><FONT FACE="Courier">RGB2Hex</FONT></TT>.
Remember, in extending the applet the existing class will remain
the same. The declaration for the new class appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class RGB2Hex2 extends RGB2Hex {</FONT></TT>
</BLOCKQUOTE>
<P>
This completes the changes required to add the color wheel to
the applet. Figure 16.1 shows the applet with the color wheel.
<P>
<A HREF="f16-1.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f16-1.gif" ><B>Figure 16.1 :</B> <I>The RGB2Hex2 applet.</I></A>
<P>
The changes made in this example do not differ in most respects
from adding a function in a conventional programming language.
However, the original applet, without the color wheel, remains
intact for others to use. To illustrate the size of the extended
applet in comparison to the code for the original applet, the
complete code listing for the extended applet is shown in Listing
16.2.
<HR>
<BLOCKQUOTE>
<B>Listing 16.2. The </B><TT><B><FONT FACE="Courier">RGB2Hex2</FONT></B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.*;<BR>
<BR>
/**<BR>
&nbsp;* Peter Norton's Guide to Programming Java&nbsp;&nbsp;*
The RGB2Hex2 Applet<BR>
&nbsp;* Converts Red, Green, and Blue values entered by the user
<BR>
&nbsp;* to a hexidecimal color code and displays the color.<BR>
&nbsp;* This applet extends the RGB2Hex applet.<BR>
&nbsp;* To help you better correlate colors the extended applet
<BR>
&nbsp;* displays a color wheel.<BR>
&nbsp;*/<BR>
<BR>
public class RGB2Hex2 extends RGB2Hex {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new BorderLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;RGBcanvas c = new RGBcanvas2();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;, c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;North&quot;, controls
= new RGBcontrols(c));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(300,300);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
/* Provides an object to display a color and colorwheel*/<BR>
class RGBcanvas2 extends RGBcanvas {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rectangle r = bounds();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createColor =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
Color(super.RedValue, super.GreenValue, super.blueValue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(createColor);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0,0,r.width,r.height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paintwheel(g, r.height / 2, r.width/2
- r.height/4, r.height/4);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
/* Paints color wheel on the graphics object at the location specified
*/<BR>
public void paintwheel(Graphics g,int wheel_size,int wheel_x,int
wheel_y){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 0, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.orange);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 60, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.yellow);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 120, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.green);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 180, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.blue);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 240, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(new Color(150,0,150));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillArc(wheel_x, wheel_y, wheel_size,
wheel_size, 300, 60);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The code for this applet should reside in the same directory as
the code for the <TT><FONT FACE="Courier">RGB2Hex</FONT></TT>
applet so the Java compiler can locate the classes defined in
<TT><FONT FACE="Courier">RGB2Hex</FONT></TT>. The compiler must
be able to locate those classes because all the classes defined
in <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT> are extensions
of classes in <TT><FONT FACE="Courier">RGB2Hex</FONT></TT>. The
command to compile the new applet follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac RGB2Hex2.java</FONT></TT>
</BLOCKQUOTE>
<P>
The results of this compilation are two new files: <TT><FONT FACE="Courier">RGB2Hex2.class</FONT></TT>
and <TT><FONT FACE="Courier">RGBcanvas2.class</FONT></TT>. The
applet can be added to an HTML file as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;HTML&gt;<BR>
&lt;HEAD&gt;<BR>
&lt;TITLE&gt; RGB to Hex Converter 2&lt;/TITLE&gt;<BR>
&lt;/HEAD&gt;<BR>
&lt;BODY&gt;<BR>
&lt;CENTER&gt;<BR>
&lt;H2&gt; The RGB to Hex Converter 2&lt;/H2&gt;<BR>
&lt;H3&gt; Written with JAVA &lt;H3&gt;<BR>
&lt;HR&gt;<BR>
&lt;APPLET CODE=&quot;RGB2Hex2&quot; WIDTH=300 HEIGHT=300&gt;
<BR>
&lt;/APPLET&gt;<BR>
&lt;/CENTER&gt;<BR>
&lt;/BODY&gt;<BR>
&lt;/HTML&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
Both of the examples so far have added to the display of the applet
but have not significantly added to its capabilities. The next
example increases the functionality of the applet so that it provides
an interactive service that was not present in the original applet.
<H3><A NAME="ReusingtheQuizMakerApplet"><B>Reusing the </B><TT><B><FONT SIZE=4 FACE="Courier">QuizMaker</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
In this example, you will modify the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet to allow the user to specify the length of time for the
timer. After all, not everyone wants to take a three-minute quiz.
This is an example of extending an applet to increase its functionality
without changing how the applet performs its task. Although the
change may seem more extensive than in the first example, the
basic functioning of the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet remains the same.
<P>
One of the key design concepts for the extended applet is the
need for somewhere to store the time for which the timer will
run. This storage place must be accessed by both the method checking
for the expiration of the timer and the method that displays it
to the user. Therefore, this value should be stored at a class
level.
<P>
The applet will also need to display this value to the user and
be able to read a new value from him or her. For now, let's assume
the applet will read the new value at the same time the button
is pressed to start the timer. You can add a text input field
to display the initial value and allow the user to modify it.
However, if the user sets it to zero or to an invalid value such
as text, you do not need to start the timer when the button is
pressed.
<P>
Should the timer length be stored as an object or as a variable?
Well, the value has no meaning apart from the timer that is using
it. It would not make sense to have a timer length without a timer.
Therefore, this is a property of the timer and not a separate
object. So you should store the timer length as a class-level
variable named <TT><FONT FACE="Courier">TimerLength</FONT></TT>.
This will be an integer value to store the number of seconds the
timer will run.
<P>
The text input field used to display and retrieve information
from the user can be created using a class, supplied in the API,
named <TT><FONT FACE="Courier">LengthEntry</FONT></TT>. It must
be present when the timer starts, so adding it to the applet will
be the responsibility of the <TT><FONT FACE="Courier">init()</FONT></TT>
method. This is done using the same <TT><FONT FACE="Courier">add()</FONT></TT>
method used by other objects. The line of code to add the text
field and initialize its value follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">this.add(LengthEntry = new TextField(&quot;180&quot;));</FONT></TT>
</BLOCKQUOTE>
<P>
This example initializes the value in the display to three minutes.
The <TT><FONT FACE="Courier">StopTimer()</FONT></TT> method must
be modified to check the class-level object instead of using the
value <TT><FONT FACE="Courier">180</FONT></TT> that was hard-coded
originally. The modified line appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if ((stopSec - startSec) &gt; TimerLength)
{</FONT></TT>
</BLOCKQUOTE>
<P>
The most interesting design decision is to determine when and
where to set the new value in the class variable. It must be done
after the button is pressed but before the start time is calculated.
It could be done as part of the event handler or as part of the
<TT><FONT FACE="Courier">start()</FONT></TT> method. It could
be coded into the existing methods, or a new method could be created
for this task.
<P>
To decide where to place the code that sets the timer length,
consider how the timer works. The decision to set the length of
the timer is really made by the user. The applet is reading in
the value in response to an action by the user. You could even
modify the timer at some point to provide a second button just
to accept new values for the timer length. This means that setting
the timer value is associated more with the user event than with
the starting of the timer. You might even want to modify the timer
to include an automatic restart, and you probably would not want
to have to reset the timer length every time. Therefore, a good
way to set this value is via the event handler. To keep the event
handler from becoming too long or complicated, create a new method
to handle this task and call the method from the event handler.
<P>
The new method appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">protected void setTimer() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= Integer.parseInt(LengthEntry.getText());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TimerLength
= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If
error occurs set length to 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (TimerLength &lt;
0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If length is invalid set to 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This method sets the timer if the value in the text field is a
valid integer greater than zero. If it is not an integer or is
less than zero, it will set the length to zero.
<P>
This completes all the modifications to the applet. Figure 16.2
shows how the resulting changes will appear to the user.
<P>
<A HREF="f16-2.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/f16-2.gif" ><B>Figure 16.2 :</B><I> The QuizMaker applet allowing the user to set the timer interval.</I></A>
<P>
The complete code for the extension is shown in Listing 16.3.
Notice how few lines of code are necessary to complete the entire
extension.
<HR>
<BLOCKQUOTE>
<B>Listing 16.3. The </B><TT><B><FONT FACE="Courier">QuizMaker2</FONT></B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.*;<BR>
import java.util.*;<BR>
<BR>
/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming <BR>
&nbsp;* The QuizMaker2 Applet<BR>
&nbsp;* Acts as an arbitrary length timer. Plays an audio message
to start and<BR>
&nbsp;* displays a start message. Plays an audio message at the
end with<BR>
&nbsp;* another display message.<BR>
&nbsp;* This applet extends the QuizMaker applet.<BR>
&nbsp;*/<BR>
<BR>
public class QuizMaker2 extends QuizMaker {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int TimerLength;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;TextField LengthEntry;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.add(LengthEntry = new TextField(&quot;180&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.init();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.paint(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LengthEntry.resize(50,20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LengthEntry.move(30,70);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Checks the current system time to determine
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 180 seconds has elapsed
since start */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected boolean stopTimer(int startSec)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int stopSec;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date StopTime = new Date();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Get the new time<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopSec = StopTime.getSeconds();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Get the number of seconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopSec += (StopTime.getMinutes()
* 60); // Add # of minutes times 60<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((stopSec - startSec) &gt; TimerLength)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
True means time has elapsed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
False means time not elapsed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Event handler to detect when the button
on the window is pressed */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
// If the button is pressed start timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof Button)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimer();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Set the length of time to run the timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runTimer();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Start the timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Return true so super does not act<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Return false so super can act on event<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void setTimer() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= Integer.parseInt(LengthEntry.getText());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TimerLength
= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If
error occurs set length to 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (TimerLength &lt;
0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If length is invalid set to 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This applet is significantly more versatile than the original
<TT><FONT FACE="Courier">QuizMaker</FONT></TT> applet. However,
there are always ways to improve software, and there are always
additional features desired by users. Not all of these features
are best added by extending an applet. The last example shows
why it may be appropriate to rewrite this particular applet.
<H3><A NAME="RewritingtheQuizMakerApplet"><B>Rewriting the </B><TT><B><FONT SIZE=4 FACE="Courier">QuizMaker</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
The <TT><FONT FACE="Courier">QuizMaker</FONT></TT> applet is more
flexible now that the user can set the timer, but it still stops
all the other functions of the computer while waiting on the timer.
On a modern multitasking computer, this is an inordinate waste
of resources. The user might want to run another application while
the timer is running. Therefore, it would be nice to have a timer
that runs in a single thread and allows the computer to perform
other functions.
<P>
This is a change to the basic underlying assumptions around which
the <TT><FONT FACE="Courier">QuizMaker</FONT></TT> applet was
created, altering the basic algorithm by which the applet functions.
Therefore, it would make sense to take the existing applet and
rewrite it. The new <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet will make use of multithreading so that the computer is
free to perform other tasks while the timer is running.
<P>
To use threads in the applet, your applet must implement the interface
<TT><FONT FACE="Courier">Runnable</FONT></TT>. The resulting declaration
appears as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class QuizMaker extends Applet implements
Runnable {</FONT></TT>
</BLOCKQUOTE>
<P>
The applet is declared as implementing <TT><FONT FACE="Courier">Runnable</FONT></TT>;
therefore, it must include a <TT><FONT FACE="Courier">run()</FONT></TT>
method. The <TT><FONT FACE="Courier">run()</FONT></TT> method
that follows is short and basically just enables the applet to
run while waiting on the user to shut it down:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Run the applet */<BR>
public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (killme != null) {}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">run</FONT></TT> method enables the
<TT><FONT FACE="Courier">QuizMaker</FONT></TT> applet to run as
long as the <TT><FONT FACE="Courier">killme</FONT></TT> thread
is not set to <TT><FONT FACE="Courier">null</FONT></TT>. Now you
need something to start the <TT><FONT FACE="Courier">run()</FONT></TT>
method and something else to set <TT><FONT FACE="Courier">killme</FONT></TT>
to <TT><FONT FACE="Courier">null</FONT></TT> when it is time to
end the applet. Because the <TT><FONT FACE="Courier">start()</FONT></TT>
method is called by the runtime environment each time a new instance
of the applet is created, the <TT><FONT FACE="Courier">start()</FONT></TT>
method is used to create a new <TT><FONT FACE="Courier">killme</FONT></TT>
thread, passing the applet object as a parameter. <TT><FONT FACE="Courier">start()</FONT></TT>
will then start this new thread. Starting the new thread calls
the <TT><FONT FACE="Courier">run()</FONT></TT> method for the
thread and-presto!-the applet is running in its own thread. The
code for the <TT><FONT FACE="Courier">start()</FONT></TT> method
follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* start new thread to run timer */<BR>
public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (killme == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killme = new Thread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killme.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Now you need a way to stop the thread when the applet is closed.
The <TT><FONT FACE="Courier">stop()</FONT></TT> method is perfect
for this. The value of the class variable <TT><FONT FACE="Courier">killme</FONT></TT>,
which is checked in the <TT><FONT FACE="Courier">run()</FONT></TT>
method, is changed in the <TT><FONT FACE="Courier">stop()</FONT></TT>
method. The <TT><FONT FACE="Courier">stop()</FONT></TT> method
is called only when the user leaves the page. The code for this
short method follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* End thread containing timer */<BR>
public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;killme = null;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Could you have created a threaded timer by simply extending the
existing <TT><FONT FACE="Courier">QuizMaker</FONT></TT> class?
Of course! After all, you are simply adding a variable, an object,
and a few methods to the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
class. However, because you now have a thread for your timer,
it would be convenient to use the <TT><FONT FACE="Courier">sleep()</FONT></TT>
method that is available as part of the <TT><FONT FACE="Courier">thread</FONT></TT>
class to implement the timer. This saves on computation by removing
the empty <TT><FONT FACE="Courier">while</FONT></TT> loop. Eliminating
the date manipulation can also reduce computation costs and results
in more readable code.
<P>
There are trade-offs here. If you use the <TT><FONT FACE="Courier">sleep()</FONT></TT>
method that is part of the <TT><FONT FACE="Courier">Thread</FONT></TT>
class, the code becomes easier to understand and you do not need
the <TT><FONT FACE="Courier">stopTimer()</FONT></TT> method. However,
if you eliminate the <TT><FONT FACE="Courier">stopTimer()</FONT></TT>
method, the extension you built in the previous section will not
work. You would have to rewrite the extension to provide the flexibility
of allowing the user to enter the time. Of course, you are rewriting
the applet anyway, so you could incorporate that flexibility into
the timer.
<P>
Let's allow the user to select the length of the timer in the
rewritten applet. Remove the <TT><FONT FACE="Courier">StopTimer()</FONT></TT>
method and replace the call to it with the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">try {Thread.sleep(TimerLength);} catch
(InterruptedException e) {}</FONT></TT>
</BLOCKQUOTE>
<P>
This calls the <TT><FONT FACE="Courier">sleep()</FONT></TT> method,
passing it the <TT><FONT FACE="Courier">TimerLength</FONT></TT>.
The value passed to <TT><FONT FACE="Courier">sleep()</FONT></TT>
is the time to suspend the thread in milliseconds. You must add
the <TT><FONT FACE="Courier">setTimer</FONT></TT> method you created
to extend the applet but must modify it to convert the value the
user enters from seconds into milliseconds. You also must include
the <TT><FONT FACE="Courier">LengthEntry</FONT></TT> object in
the <TT><FONT FACE="Courier">init()</FONT></TT> method, just as
you did for the applet extension.
<P>
The final version of the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
class is shown in Listing 16.4. As you can see, the display resulting
from this code is exactly the same as the display resulting from
extending the class in the previous section. Could you have made
all the changes as extensions and not had as much code in the
class? You could have, but it would have been unreasonably hard
to follow with methods being used in superclasses and then defined
away in subclasses. This difficulty justifies the decision to
rewrite the applet rather than extending it.
<HR>
<BLOCKQUOTE>
<B>Listing 16.4. The revised </B><TT><B><FONT FACE="Courier">QuizMaker</FONT></B></TT><B>
applet with multithreading.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">import java.awt.*;<BR>
import java.applet.*;<BR>
import java.util.*;<BR>
import java.net.*;<BR>
<BR>
/**<BR>
&nbsp;* Peter Norton's Guide to Java Programming <BR>
&nbsp;* Revised QuizMaker Applet<BR>
&nbsp;* Acts as an arbitrary length timer. Plays an audio message
to start and<BR>
&nbsp;* displays a start message. Plays an audio message at the
end with<BR>
&nbsp;* another display message.<BR>
&nbsp;* This applet is a multithreaded version of the original
QuizMaker applet.<BR>
&nbsp;*/<BR>
<BR>
public class QuizMaker extends Applet implements Runnable{<BR>
Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HglassImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Displays a picture of an hour glass<BR>
Button&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RunButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Lets the user start the timer<BR>
Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StatusLabel;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Displays the status to the user<BR>
URL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HglassURL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
URL of the applet<BR>
Thread killme = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Thread for
timer processing<BR>
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength;//
Number of seconds the timer should run<BR>
TextField&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LengthEntry;// User
entry for number of seconds<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get the picture to
add to the screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HglassImage = getImage(getCodeBase(),&quot;Hglass.gif&quot;);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Adds a label to display text
which can not be altered by the user<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(StatusLabel = new Label(&quot;Press
Run to start timer&quot;));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Adds a button to start the timer
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(RunButton
= new Button(&quot;Run&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.add(LengthEntry = new TextField(&quot;180&quot;));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize(400,300);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Resizes the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paint(getGraphics());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Displays applet<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HglassURL = getCodeBase();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Gets the URL for the applet<BR>
&nbsp;&nbsp;&nbsp;&nbsp; play(HglassURL,&quot;intro.au&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Play an intro<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;play(HglassURL,&quot;startTimer.au&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Play the start message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;play(HglassURL,&quot;endTimer.au&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Play the end message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(HglassImage,180,10,this);
// Draw the hour glass<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatusLabel.resize(150,20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Resizes the label<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatusLabel.move(10,10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Moves the label<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RunButton.resize(100,20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Resizes the button<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RunButton.move(20,40);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Moves the button<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LengthEntry.resize(70,20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Resizes the entry box<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LengthEntry.move(30,70);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Moves the box<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Lets the user know to start, saves
the start time<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and checks for time
out */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void runTimer() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartTime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Holds the time the timer started<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startSec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Start time in seconds<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Lets the user know to get ready
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatusLabel.setText(&quot;Get the
hour glass ready.&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;play(HglassURL,&quot;startTimer.au&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Play the start message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartTime = new Date();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Get the starting time<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Lets the user know to start<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatusLabel.setText(&quot;Time is
slipping away.&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Calculate the start time in seconds
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startSec = StartTime.getSeconds();&nbsp;&nbsp;//
Get the number of seconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startSec += (StartTime.getMinutes()
* 60);//Add # of minutes times 60<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(TimerLength);}
catch (InterruptedException e) {}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Informs the user the hour glass
is empty<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatusLabel.setText(&quot;The hour
glass is empty!&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;play(HglassURL,&quot;endTimer.au&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Event handler to detect when the button
on the window is pressed */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public boolean handleEvent(Event e) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int myint;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the window is closed end the
program<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.id == Event.WINDOW_DESTROY)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.target instanceof Button)
{&nbsp;&nbsp;&nbsp;// If the button is pressed start timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimer();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Set the length of time to run the timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runTimer();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Start the timer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Return true so super does not act<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Return false so super can act<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Reads value from user if valid multiply
by 1000 to convert */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* to seconds otherwise set timer to 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void setTimer() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= Integer.parseInt(LengthEntry.getText());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= TimerLength * 1000;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TimerLength
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (TimerLength &lt;
0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerLength
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* starts new thread to run timer */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (killme == null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killme =
new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killme.start();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Ends thread containing timer */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;killme = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* Runs the applet */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (killme != null) {}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This concludes the coding examples for this chapter. The next
section addresses testing the extended applets.
<H2><A NAME="TestingtheExtendedApplet"><B><FONT SIZE=5 COLOR=#Ff0000>Testing
the Extended Applet</FONT></B></A></H2>
<P>
Software testing in general is one of the most important and yet
most neglected aspects of software development. Testing code modifications
is often even more hurried than initial software testing, generally
due to time and budget constraints. Yet failure to adequately
design and implement tests can increase the total amount of time
and money spent on a project. Testing is also critical to providing
high-quality software. Although Java increases the amount of code
that can be reused, thereby decreasing the amount of new development,
it does not eliminate the necessity of testing.
<P>
<I>Regression testing</I> the extended applet involves testing
not only the new, but also the existing functionality. Your changes
should not have affected any of the existing features; there is
little risk of this if you are reusing an applet. However, you
must verify that there are no unexpected side effects generated
in the extension.
<P>
To ensure that you have tested all aspects of the applet and all
the areas of change, you should have a written test plan to provide
a methodical means of ensuring that all the tests are performed.
It can also ensure the tests are run in an orderly fashion. If,
while testing, you find a problem and make a correction, try to
rerun all the tests from the beginning of the test plan.
<P>
If possible, it is best to run the entire test plan and document
all the problem areas before making any changes. Often problems
in one area will be related to problems in another. Addressing
these problems as they occur in the test plan may result in an
incomplete understanding of the problem. Waiting until all the
problems are documented is best to reduce the amount of reworking
and retesting.
<P>
Although the need for a documented testing strategy is obvious
on large projects with several developers, it is just as helpful
on small projects. However, the documentation does not need to
be fancy binders with sophisticated forms. Yellow notepads can
work well for individuals testing their own applets. The next
sections present sample test plans for each of the modifications
described in this chapter.
<H3><A NAME="TestingtheScrollText2Applet"><B>Testing the </B><TT><B><FONT SIZE=4 FACE="Courier">ScrollText2</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
A suggested test plan for the <TT><FONT FACE="Courier">ScrollText2</FONT></TT>
applet follows:
<OL>
<LI>Create an HTML document and run <TT><FONT FACE="Courier">ScrollText2</FONT></TT>,
passing only the parameters required in <TT><FONT FACE="Courier">ScrollText</FONT></TT>.
Does the applet run and scroll text as expected?
<LI>Modify the HTML document to pass an additional parameter with
the name <TT><FONT FACE="Courier">background</FONT></TT> and the
value <TT><FONT FACE="Courier">121690</FONT></TT>. Does the text
now scroll on a green background?
<LI>Modify the HTML document to set the value for the background
parameter to <TT><FONT FACE="Courier">0</FONT></TT>. Does the
applet now appear to be a solid black box?
</OL>
<P>
In reading this test plan, note that the expected outcome is listed
for each test. In creating a test plan, you are trying to confirm
that the software does what is expected, not determine expected
behavior.
<P>
In the last test, black text on a black background may not be
the most desirable behavior. If changes such as these are being
made at the request of a user, it is reasonable to confirm with
the user that this type of danger is acceptable. The user may
request an additional change to create white text when the background
color is dark. These considerations are best made at design time,
but it is better to review them when testing than to surprise
the user at delivery.
<P>
This example is short, yet includes some important features of
test plans. The plan includes testing for error, normal, and boundary
conditions. The next test plan, for the <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>
applet, includes the same types of tests. Because the user has
more options available at runtime from the <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>
applet, a larger test plan is necessary to test each option.
<H3><A NAME="TestingtheRGB2Hex2Applet"><B>Testing the </B><TT><B><FONT SIZE=4 FACE="Courier">RGB2Hex2</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
Applets that receive numeric input such as the <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>
applet must be tested for correct results using both random-input
and specific test cases. The test cases should include boundary
conditions. They also should include changes in each of the text
entry fields. When retesting after making a change, all the original
test cases should be performed again. In addition, new test cases
must be added so that applets are not created specifically to
meet the needs of the test case.
<P>
A suggested test plan for the <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>
applet follows:
<OL>
<LI>Create an HTML document and run <TT><FONT FACE="Courier">RGB2Hex2</FONT></TT>.
Does the applet with the color wheel appear as expected?
<LI>Enter a new value for the <TT><FONT FACE="Courier">Blue</FONT></TT>
component and press the button. Does the color wheel still display?
Does the hexadecimal value still display? Check that the background
behind the color wheel displays the color entered by the user.
<LI>Enter zeros for all three color values. Does the background
turn black? Does the color wheel display? Does the hexadecimal
value appear as <TT><FONT FACE="Courier">000000</FONT></TT>?
<LI>Enter all values as <TT><FONT FACE="Courier">255</FONT></TT>.
Does the background turn white? Does the color wheel display?
Does the hexadecimal value appear as <TT><FONT FACE="Courier">FFFFFF</FONT></TT>?
</OL>
<P>
This test uses the same strategy used in the <TT><FONT FACE="Courier">ScrollText2</FONT></TT>
example. You test first for the normal conditions of the applet,
and then for the boundary conditions of <TT><FONT FACE="Courier">0</FONT></TT>
and <TT><FONT FACE="Courier">255</FONT></TT>. This strategy is
also used to test the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet. However, in testing <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
you must verify the timer accuracy as well as the display.
<H3><A NAME="TestingtheExtendedQuizMakerApplet"><B>Testing the
Extended </B><TT><B><FONT SIZE=4 FACE="Courier">QuizMaker</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
The test plan for the <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet must include tests for invalid input and timer accuracy
as well as verify that the original display and audio features
were not affected by the enhancements. The following test plan
incorporates all these situations:
<OL>
<LI>Create a new HTML document to load the <TT><FONT FACE="Courier">QuizMaker2</FONT></TT>
applet. Display the page and verify that the audio clips play
in the beginning and that the image is displayed as expected.
<LI>Verify that the time default is 180 seconds.
<LI>Start the timer for the default time and verify that the audio
messages play at appropriate times. Verify that the text display
changes at the end of three minutes.
<LI>Change the timer value to 300 seconds and press the button.
Verify that the text message changes back to <TT><FONT FACE="Courier">Time
is slipping away.</FONT></TT> and the audio clip plays.
<LI>Test that the timer runs for five minutes. Verify that the
text message changes to <TT><FONT FACE="Courier">done</FONT></TT>
at the end and that the other audio clip plays.
<LI>Enter a text value into the input field. Does the timer run
for zero seconds?
<LI>Enter a negative value into the input field. Does the timer
run for zero seconds?
<LI>Enter the value <TT><FONT FACE="Courier">99</FONT></TT> into
the input field. Does the timer run for 99 seconds?
</OL>
<P>
This test plan is more extensive than the previous plans and will
take more time to complete. The testing process may proceed faster
if the test plan is divided between several people; however, the
results from different testers should be compared before any corrections
are made.
<H3><A NAME="TestingtheRewrittenQuizMakerApplet"><B>Testing the
Rewritten </B><TT><B><FONT SIZE=4 FACE="Courier">QuizMaker</FONT></B></TT><B><FONT SIZE=4>
Applet</FONT></B></A></H3>
<P>
In addition to the tests listed previously, the test plan for
the rewritten applet must test for problems resulting from the
introduction of threads. The extended test plan will verify that
the applet runs correctly even when other programs are loaded
and unloaded:
<OL>
<LI>Run the tests in the test plan for the extended <TT><FONT FACE="Courier">QuizMaker</FONT></TT>
applet. Does the applet perform correctly for all of them?
<LI>Start the applet and set the timer for 300 seconds. Start
another program. Does the timer still run for the correct length
of time?
<LI>Set the timer for 200 seconds. Close the other program. Does
the timer still run for the correct length of time?
</OL>
<P>
If there were other pieces of functionality in the applet, you
would want to test those as well. If you had a test plan from
the original version of the applet, it would be reasonable to
repeat all the tests on it to verify that they still run correctly.
Clearly, there are more tests you could run for this particular
applet, but those listed here should be enough to instill a basic
level of confidence in the performance of the applet.
<H3><A NAME="CreatingTestsforYourOwnApplets"><B>Creating Tests
for Your Own Applets</B></A></H3>
<P>
After looking at the test plans for each of the applets modified
in this chapter, you now must consider how to create such test
plans. The most important thing to remember is that it will require
time to create a good plan, but you will reap more benefits. Well-crafted
test plans can be modified and reused much like applets can be.
<P>
Take care in creating test plans to be sure they are as comprehensive
and detailed as possible. The following list summarizes some of
the items to include in a well-written test plan:
<UL>
<LI>Create at least one test for every piece of functionality
included in the design of your applet.
<LI>Test all normal working conditions.
<LI>Include one test for each object on the screen, including
each button, text entry, and check box.
<LI>Include one test for each input from an HTML document.
<LI>Test all boundary conditions. Create one test for each boundary
condition.
<LI>Test all error handling. Create one test for every error condition.
<LI>State the expected results as part of the plan. Do not test
just to determine what the results are.
<LI>State expected results explicitly. State everything that will
appear on the screen, as opposed to stating that the screen will
appear as normal.
<LI>If possible, provide a picture for screen appearance.
<LI>Create several tests to determine performance under all conditions.
<LI>Suppose the applet is resized or moved; does it still work
as expected?
</UL>
<P>
Often you can begin creating the test plan as soon as the requirements
are understood. At that point, the plan should include basic tests
for the functionality described in the requirements. The plan
then can be modified during the design phase as new objects are
added. The modifications would include specific tests for each
object. The plan may be updated again during the coding phase
to be sure all error handling is included and all boundary conditions
are tested. A plan developed over time in this manner is generally
more comprehensive than one developed after coding and before
testing.
<P>
In general, remember that the more extensive the testing, the
more likely it is that potential problems will appear during testing
instead of after release. Testing is an important part of software
construction and should not be taken lightly.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></B></A>
</H2>
<P>
This chapter explores some of the ways you can extend existing
applets. It covers when it is appropriate to extend an applet
and when it is best to rewrite it. It provides several examples
of extending applets and one example of rewriting an applet. You
should now feel comfortable with modifying and extending existing
applets to use in your own presentations.
<P>
The chapter also explains the importance of testing, providing
many examples of test plans for applets and describing some important
aspects of creating your test plans. You should now be able to
create robust test plans for testing your own applets or those
supplied to you.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch15.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch15.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch17.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch17.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
