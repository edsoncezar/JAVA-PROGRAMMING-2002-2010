<HTML>

<HEAD>
   <TITLE>Chapter 6 -- Fundamentals of the Java Language</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336366&ad_type=POPUP&category=net&id=3c9e95f1533d8e321a76219dce35433c";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 6</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>Fundamentals of the Java Language</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Tokens" >Tokens</A>
<UL>
<LI><A HREF="#Identifiers" >Identifiers</A>
<LI><A HREF="#Keywords" >Keywords</A>
<LI><A HREF="#Literals" >Literals</A>
<LI><A HREF="#Separators" >Separators</A>
<LI><A HREF="#Operators" >Operators</A>
<LI><A HREF="#Comments" >Comments</A>
<LI><A HREF="#TokensSummary" >Tokens Summary</A>
</UL>
<LI><A HREF="#UsingDataTypes" >Using Data Types</A>
<UL>
<LI><A HREF="#PrimitiveDataTypes" >Primitive Data Types</A>
<LI><A HREF="#IntegerDataTypes" >Integer Data Types</A>
<LI><A HREF="#ReferenceDataTypes" >Reference Data Types</A>
</UL>
<LI><A HREF="#Expressions" >Expressions</A>
<UL>
<LI><A HREF="#UsingOperatorsinExpressions" >Using Operators in Expressions</A>
</UL>
<LI><A HREF="#Declarations" >Declarations</A>
<UL>
<LI><A HREF="#DeclaringintegerTypes" ><FONT SIZE=2>Declaring</FONT> integer T<FONT SIZE=2>ypes</FONT></A>
<LI><A HREF="#DeclaringFloatingPointTypes" >Declaring Floating-Point Types</A>
<LI><A HREF="#DeclaringcharacterTypes" ><FONT SIZE=2>Declaring</FONT> character <FONT SIZE=2>Types</FONT></A>
<LI><A HREF="#DeclaringArrays" >Declaring Arrays</A>
</UL>
<LI><A HREF="#ControlFlow" >Control Flow</A>
<UL>
<LI><A HREF="#BlocksandStatements" >Blocks and Statements</A>
<LI><A HREF="#ConditionalExpressions" >Conditional Expressions</A>
<LI><A HREF="#LoopingExpressions" >Looping Expressions</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This book has been using broad terms to discuss the significance
of Java as a programming language. It now digs deeper into Java
to discuss the building blocks for writing programs. Those of
you who are familiar with other languages such as C or C++ will
find many familiar constructs in Java. However, you may have to
&quot;unlearn&quot; some programming habits.
<P>
This chapter explains the fundamentals of Java programming language
from broad concepts and logical program flow to specific keywords.
<H2><A NAME="Tokens"><FONT SIZE=5 COLOR=#Ff0000>Tokens</FONT></A>
</H2>
<P>
The Java programming language has a term for its building blocks,
or basic elements: <I>tokens</I>. Becoming familiar with these
words and concepts is a prerequisite to programming in Java.
<P>
<A HREF="ch4.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch4.htm" >Chapter 4</A>, &quot;The Java Language: A Primer,&quot;
explains the series of events surrounding compiling and running
an application. This chapter explains the logic of the <TT><FONT FACE="Courier">javac</FONT></TT>
compiler. 
<P>
At compile time, the <TT><FONT FACE="Courier">javac</FONT></TT>
compiler takes the code and pulls out specific information, called
a <I>token,</I> for further processing.
<P>
First, <TT><FONT FACE="Courier">javac</FONT></TT> takes out escape
sequences from the raw byte codes. It determines if the escape
sequences are line terminators or input characters. Next, <TT><FONT FACE="Courier">javac</FONT></TT>
takes out whitespace that is not internal to a string, including
the ASCII space character, carriage return, line feed, and horizontal
tab. Then the compiler gets down to the business of pulling out
tokens.
<P>
There are several types of tokens: identifiers, keywords, literals,
operators, separators, and comments. 
<H3><A NAME="Identifiers">Identifiers</A></H3>
<P>
The <TT><FONT FACE="Courier">javac</FONT></TT> compiler needs
to know the names of items in the program. For example, it must
recognize the names of variables, methods, and component elements
of classes. <I>Identifiers</I> are either Java reserved words
or titles given to variables, classes, and methods. Reserved words
are names that may be used only by Java. Using these words in
any other way will cause a compile error.
<P>
Identifiers can be named anything as long as they begin with an
alphabet character, a dollar sign, or an underscore. However,
I do not recommend that you use the dollar sign or begin an identifier
name with an underscore because these symbols are used by the
Java libraries. This will help with debugging. Do use the underscore
to connect words to make an identifier meaningful, as in <TT><FONT FACE="Courier">this_book</FONT></TT>.
As with all good programming, the more descriptive the identifier,
the better.
<H4>Identifier Name Size</H4>
<P>
Java will often give a programmer just enough rope to get into
interesting knots. For example, the <TT><FONT FACE="Courier">javac</FONT></TT>
compiler will accept uppercase or mixed-case words the same way
it does keywords.
<P>
Java identifiers are case sensitive. For example, <TT><FONT FACE="Courier">char</FONT></TT>
is a reserved word in Java. This means that it is possible to
assign a variable the identifier <TT><FONT FACE="Courier">Char</FONT></TT>,
<TT><FONT FACE="Courier">chAR</FONT></TT>, or variations thereof.
However, this makes debugging difficult. You'll learn more on
reserved words in the next section.
<H3><A NAME="Keywords">Keywords</A></H3>
<P>
<I>Keywords </I>are reserved words, which means that they cannot
be used in any way other than how Java intends for them to be
used. Keywords are, therefore, special tokens. They are always
lowercase.
<P>
Java keywords are used as application flow controls, declarations,
class identifiers, and expressions. Table 6.1 lists all the reserved
keywords in Java. Keywords that pertain to the fundamentals of
Java are explained in the appropriate section of this chapter.
<BR>
<P>
<CENTER><B>Table 6.1. Reserved keywords in Java.</B></CENTER><BR>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=26%>
<TR><TD>
<H5>Data Declaration Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">boolean<BR>
byte<BR>
char<BR>
double<BR>
float<BR>
int<BR>
long<BR>
short</FONT></TT>
</BLOCKQUOTE>
<H5>Loop Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">break<BR>
continue<BR>
do<BR>
for<BR>
while</FONT></TT>
</BLOCKQUOTE>
<H5>Conditional Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">case<BR>
else<BR>
if<BR>
switch</FONT></TT>
</BLOCKQUOTE>
<H5>Exception Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">catch<BR>
finally<BR>
throw<BR>
try</FONT></TT>
</BLOCKQUOTE>
<H5>Structure Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">abstract<BR>
class<BR>
default<BR>
extends<BR>
implements<BR>
instance of<BR>
interface</FONT></TT>
</BLOCKQUOTE>
<H5>Modifier and Access Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">final<BR>
native<BR>
new<BR>
private<BR>
protected<BR>
public<BR>
static<BR>
synchronized<BR>
threadsafe<BR>
transient<BR>
void</FONT></TT>
</BLOCKQUOTE>
<H5>Miscellaneous Keywords</H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">false<BR>
import<BR>
null<BR>
package<BR>
return<BR>
super<BR>
this<BR>
true</FONT></TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<BLOCKQUOTE>
</BLOCKQUOTE>
<P>
The following keywords are reserved and are <I>not</I> being used
in Java 1.0; they may be used in future releases:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">byvalue<BR>
cast<BR>
const<BR>
future<BR>
generic<BR>
goto<BR>
inner<BR>
operator<BR>
outer<BR>
rest<BR>
var</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="Literals">Literals</A></H3>
<P>
Data is represented by <I>literals</I> in Java. Similar to literals
in other programming languages, Java literals are based on character
and number representations. The types of literals are integer,
floating-point, boolean, character, and string.
<P>
Every variable consists of a literal and a data type. The difference
between the two is that literals are entered explicitly into the
code. Data types are information about the literals, such as how
much room will be reserved in memory for that variable, as well
as the possible value ranges for the variable. (Data types are
discussed in the section &quot;Using Data Types.&quot;)
<H4>Integer Literals</H4>
<P>
Integers are whole numbers, such as 1 and 5280. <I>Integer literals</I>
can be decimal (base 10), octal (base 8), or hexadecimal (base
16).
<P>
Decimals can be positive, zero, or negative. Decimal literals
cannot start with 0, as in 01234. After the beginning number,
a decimal literal can consist of the numbers 0-9. Numbers beginning
with 0 are reserved for octal and hexadecimal literals. Therefore,
when using decimals, do not right-justify with leading zeros.
The upper limit of a positive decimal integer is 2<FONT SIZE=1>31</FONT>-1,
or 2,147,483,647. The lower limit is -2,147,483,648 or -2<FONT SIZE=1>31</FONT>.
<P>
Octal literals start with 0 and can be followed by any number
0-7. They can be positive, zero, or negative. The maximum value
of an octal literal is 017777777777, which is equivalent to 2<FONT SIZE=1>31</FONT>-1.
<P>
Hexadecimal integer literals start with 0x or 0X, followed by
one or more hexadecimal digits. Letters A-F used in a hexadecimal
integer can be uppercase or lowercase. Hexadecimal integers can
be positive, zero, or negative. The upper limit of a positive
hexadecimal literal is 0x7fffffff, which is, once again, equivalent
to 2<FONT SIZE=1>31</FONT>-1. The values available are 1-9, A-F,
and a-f.
<P>
A compile-time error will occur if any of these values is exceeded.
<H4>Floating-Point Literals</H4>
<P>
A <I>floating-point literal</I> represents a number that has a
decimal point in it, such as 3.7. Java standards specify that
floating-point numbers must follow the industry standard specification
as written in IEEE-754.
<P>
Single-precision floating-point numbers consist of a 32-bit space
and are designated by uppercase or lowercase <I>f</I>. Double-precision
numbers are allotted a 64-bit space and are designated by uppercase
or lowercase <I>d</I>. Double-precision floating-point numbers
are the default. Therefore, 3.7 is a double-precision floating-point
number, and 3.7f is a single-precision floating-point number.
<P>
How do you know whether to use a single- or double-precision floating-point
number? It depends on the size of the number. If there is any
possibility that a number could grow out of range or need to be
of greater precision than single, declare it a double.
<P>
Compile-time errors will occur if a nonzero floating-point literal
is too large or small.
<P>
The largest magnitude single-precision floating-point literal
is &#177;3.40282347e+38f, and the smallest is &#177;1.40239846e-45f.
The largest double-precision floating-point number is 1.79769313486231570e+308,
and 4.94065645841246544e-324 is the smallest floating-point  number.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Floating-point literals also can be expressed using exponents or scientific notation, as shown in the preceding paragraph. Uppercase or lowercase <I>e</I> is used to denote the exponent portion of a floating-point number. An example of this is 2.1e3f; this 
is a single-precision floating-point number representing 2100.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Boolean Literals</H4>
<P>
A boolean literal is either of the words <I>true</I> or <I>false</I>.
Unlike other programming languages, no numeric value such as 0
or 1 is assigned. Therefore, the value of a boolean literal is,
literally, true or false. Booleans are used extensively in program
control flow logic.
<H4>Character Literals</H4>
<P>
Programmers often use a single character as a value. In Java,
this is represented by <I>character literals</I>. The value of
a character literal is enclosed by single quotes. An example is
<TT><FONT FACE="Courier">'y'</FONT></TT>.
<P>
Assigning a value to a character literal gets more interesting
if the value must be a single quote, a backslash, or other nonprintable
characters. A backslash (<TT><FONT FACE="Courier">\</FONT></TT>)
is used to designate certain nonprintable characters or characters
that are properly part of the command. For example, assign the
value <TT><FONT FACE="Courier">'\''</FONT></TT> to characterize
the single quote. Table 6.2 shows some examples of assigning values
to character literals. <BR>
<P>
<CENTER><B>Table 6.2. Specifying character literals.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Description or Escape Sequence</I></CENTER>
</TD><TD WIDTH=100><CENTER><I>Sequence</I></CENTER></TD><TD WIDTH=237><I>Output</I>
</TD></TR>
<TR><TD WIDTH=227>Any character</TD><TD WIDTH=100><TT><FONT FACE="Courier">'y'</FONT></TT>
</TD><TD WIDTH=237><TT><FONT FACE="Courier">y</FONT></TT></TD>
</TR>
<TR><TD WIDTH=227>Backspace (BS)</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\b'</FONT></TT>
</TD><TD WIDTH=237>Backspace</TD></TR>
<TR><TD WIDTH=227>Horizontal tab (HT)</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\t'</FONT></TT>
</TD><TD WIDTH=237>Tab</TD></TR>
<TR><TD WIDTH=227>Linefeed (LF)</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\n'</FONT></TT>
</TD><TD WIDTH=237>Linefeed</TD></TR>
<TR><TD WIDTH=227>Formfeed (FF)</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\f'</FONT></TT>
</TD><TD WIDTH=237>Form feed</TD></TR>
<TR><TD WIDTH=227>Carriage return (CR)</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\r'</FONT></TT>
</TD><TD WIDTH=237>Carriage return</TD></TR>
<TR><TD WIDTH=227>Double quote</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\&quot;'</FONT></TT>
</TD><TD WIDTH=237><TT><FONT FACE="Courier">&quot;</FONT></TT>
</TD></TR>
<TR><TD WIDTH=227>Single quote</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\''</FONT></TT>
</TD><TD WIDTH=237><TT><FONT FACE="Courier">'</FONT></TT></TD>
</TR>
<TR><TD WIDTH=227>Backslash</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\\'</FONT></TT>
</TD><TD WIDTH=237><TT><FONT FACE="Courier">\</FONT></TT></TD>
</TR>
<TR><TD WIDTH=227>Octal bit pattern</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\ddd'</FONT></TT>
</TD><TD WIDTH=237>Octal value of ddd</TD></TR>
<TR><TD WIDTH=227>Hex bit pattern</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\xdd'</FONT></TT>
</TD><TD WIDTH=237>Hex value of dd</TD></TR>
<TR><TD WIDTH=227>Unicode character</TD><TD WIDTH=100><TT><FONT FACE="Courier">'\udddd'</FONT></TT>
</TD><TD WIDTH=237>Actual Unicode character of dddd</TD></TR>
</TABLE></CENTER>
<P>
<P>
Compile-time errors occur if anything other than a single quote
follows the value designator or the character after <TT><FONT FACE="Courier">'\'</FONT></TT>
is anything but <TT><FONT FACE="Courier">b</FONT></TT>, <TT><FONT FACE="Courier">t</FONT></TT>,
<TT><FONT FACE="Courier">n</FONT></TT>, <TT><FONT FACE="Courier">f</FONT></TT>,
<TT><FONT FACE="Courier">r</FONT></TT>, <TT><FONT FACE="Courier">&quot;</FONT></TT>,
<TT><FONT FACE="Courier">'</FONT></TT>, <TT><FONT FACE="Courier">\</FONT></TT>,
<TT><FONT FACE="Courier">0</FONT></TT>, <TT><FONT FACE="Courier">1</FONT></TT>,
<TT><FONT FACE="Courier">2</FONT></TT>, <TT><FONT FACE="Courier">4</FONT></TT>,
<TT><FONT FACE="Courier">5</FONT></TT>, <TT><FONT FACE="Courier">6</FONT></TT>,
or <TT><FONT FACE="Courier">7</FONT></TT>.
<H4>String Literals</H4>
<P>
<I>String literals</I> are a sequence of characters enclosed in
double quotes, such as <TT><FONT FACE="Courier">&quot;This is
a string literal&quot;</FONT></TT>. This could also be <TT><FONT FACE="Courier">&quot;Hello
World&quot;</FONT></TT> or even <TT><FONT FACE="Courier">&quot;&quot;</FONT></TT>
for a null character string. The <TT><FONT FACE="Courier">javac</FONT></TT>
compiler does not strip out whitespace from within string literals.
<P>
String literals can be concatenated. For example, if one string
contained <TT><FONT FACE="Courier">&quot;This is the beginning&quot;</FONT></TT>
and another string contained <TT><FONT FACE="Courier">&quot; of
a beautiful relationship&quot;</FONT></TT>, they could be concatenated
together. The representation would be <TT><FONT FACE="Courier">&quot;This
is the beginning&quot; + &quot; of a beautiful relationship&quot;</FONT></TT>.
(It is not necessary to have spaces on either side of the plus
sign.)
<P>
A string literal cannot span more than one line; those that do
so can be broken up at declaration time and then concatenated
at use time. This also makes programs more readable and strings
less likely to be mistaken for comments.
<P>
As with the character literal, the backslash is used to denote
symbols that otherwise would not work. The double quote is represented
by the string <TT><FONT FACE="Courier">&quot;\&quot;&quot;</FONT></TT>.
<H3><A NAME="Separators">Separators</A></H3>
<P>
Java uses the following separators: <TT><FONT FACE="Courier">()</FONT></TT>,
<TT><FONT FACE="Courier">{}</FONT></TT>, <TT><FONT FACE="Courier">[]</FONT></TT>,
<TT><FONT FACE="Courier">;</FONT></TT>, <TT><FONT FACE="Courier">,</FONT></TT>,
and <TT><FONT FACE="Courier">.</FONT></TT>.
<P>
The compiler uses these <I>separators</I> to divide the code into
segments. They can also force arithmetic precedence evaluation
within an expression. (You will learn more about precedence in
the section &quot;Using Operators in Expressions.&quot;) Separators
are also useful as visual and logical locators for programmers.
<P>
Note the use of separators in the following code fragment:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (location &lt; 10) {</FONT></TT>
</BLOCKQUOTE>
<P>
Here, the parentheses indicate to the compiler the boolean expression
to be evaluated, which is whether the value of <TT><FONT FACE="Courier">location</FONT></TT>
is less than 10. The trailing <TT><FONT FACE="Courier">{</FONT></TT>
indicates the start of a block of code that will be executed if
the boolean expression evaluates to <TT><FONT FACE="Courier">true</FONT></TT>.
<H3><A NAME="Operators">Operators</A></H3>
<P>
<I>Operators</I> are the symbols used for arithmetic and logical
operations. Arithmetic symbols define operations that apply to
numbers (for example, <TT><FONT FACE="Courier">2 + 3</FONT></TT>).
Operators, except the plus sign (+), are used only for arithmetic
calculations. The <TT><FONT FACE="Courier">+</FONT></TT> operator
can be used with strings as well, as shown in the previous example
of string literal concatenation. Tables 6.3 through 6.7 list all
the Java operators.
<P>
<CENTER><B>Table 6.3. The Java arithmetic operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=113><CENTER><I>Operation</I></CENTER>
</TD><TD WIDTH=78><CENTER><I>Example</I></CENTER></TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=113>Addition
</TD><TD WIDTH=78><TT><FONT FACE="Courier">g + h</FONT></TT></TD>
</TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=113>Subtraction
</TD><TD WIDTH=78><TT><FONT FACE="Courier">g - h</FONT></TT></TD>
</TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=113>Multiplication
</TD><TD WIDTH=78><TT><FONT FACE="Courier">g * h</FONT></TT></TD>
</TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">/</FONT></TT></TD><TD WIDTH=113>Division
</TD><TD WIDTH=78><TT><FONT FACE="Courier">g / h</FONT></TT></TD>
</TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">%</FONT></TT></TD><TD WIDTH=113>Modulus
</TD><TD WIDTH=78><TT><FONT FACE="Courier">g % h</FONT></TT></TD>
</TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 6.4. The Java assignment operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1>
<TR><TD WIDTH=78><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=169><CENTER><I>Operation</I></CENTER>
</TD><TD WIDTH=81><CENTER><I>Example</I></CENTER></TD><TD WIDTH=109><CENTER><I>Meaning</I></CENTER>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">=</FONT></TT></TD><TD WIDTH=169>Assign value
</TD><TD WIDTH=81><TT><FONT FACE="Courier">a = 7</FONT></TT></TD>
<TD WIDTH=109><TT><FONT FACE="Courier">a = 7</FONT></TT></TD>
</TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">+=</FONT></TT></TD>
<TD WIDTH=169>Add to current variable</TD><TD WIDTH=81><TT><FONT FACE="Courier">g += h</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g + h</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">-=</FONT></TT></TD>
<TD WIDTH=169>Subtract from current</TD><TD WIDTH=81><TT><FONT FACE="Courier">g -= h</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g</FONT></TT> <TT><FONT FACE="Courier">- h</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">*=</FONT></TT></TD>
<TD WIDTH=169>Multiply current</TD><TD WIDTH=81><TT><FONT FACE="Courier">g *= h</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g * h</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">/=</FONT></TT></TD>
<TD WIDTH=169>Divide current</TD><TD WIDTH=81><TT><FONT FACE="Courier">g /= h</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g / h</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">%=</FONT></TT></TD>
<TD WIDTH=169>Modulus current</TD><TD WIDTH=81><TT><FONT FACE="Courier">g %= h</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g % h</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 6.5. The Java increment and decrement operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=123><CENTER><I>Operation</I></CENTER>
</TD><TD WIDTH=121><CENTER><I>Example</I></CENTER></TD><TD WIDTH=109><CENTER><I>Meaning</I></CENTER>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=123>Increment by 1</TD><TD WIDTH=121><TT><FONT FACE="Courier">g++ or ++g</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g + 1</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=123>Decrement by 1</TD><TD WIDTH=121><TT><FONT FACE="Courier">g-- or --g</FONT></TT>
</TD><TD WIDTH=109><TT><FONT FACE="Courier">g = g -1</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 6.6. The Java comparison operators (which return
</B><TT><B><FONT FACE="Courier">true</FONT></B></TT><B> or </B><TT><B><FONT FACE="Courier">false</FONT></B></TT><B>).</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=156><CENTER><I>Operation</I></CENTER>
</TD><TD WIDTH=81><CENTER><I>Example</I></CENTER></TD><TD WIDTH=219><CENTER><I>Meaning</I></CENTER>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=156>Equal</TD><TD WIDTH=81><TT><FONT FACE="Courier">g == h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> equal to <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">!=</FONT></TT></TD>
<TD WIDTH=156>Not equal</TD><TD WIDTH=81><TT><FONT FACE="Courier">g != h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> not equal to <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=156>Less than</TD><TD WIDTH=81><TT><FONT FACE="Courier">g &lt; h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> less than <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;</FONT></TT></TD>
<TD WIDTH=156>Greater than</TD><TD WIDTH=81><TT><FONT FACE="Courier">g &gt; h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> greater than <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&lt;=</FONT></TT></TD>
<TD WIDTH=156>Less than or equal</TD><TD WIDTH=81><TT><FONT FACE="Courier">g &lt;= h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> less than or equal to <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;=</FONT></TT></TD>
<TD WIDTH=156>Greater than or equal</TD><TD WIDTH=81><TT><FONT FACE="Courier">g &gt;= h</FONT></TT>
</TD><TD WIDTH=219>Is <TT><FONT FACE="Courier">g</FONT></TT> greater than or equal to <TT><FONT FACE="Courier">h</FONT></TT>?
</TD></TR>
</TABLE></CENTER>
<P>
<P>
<CENTER><B>Table 6.7. The Java bitwise operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=217><CENTER><I>Operation</I></CENTER>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&amp;</FONT></TT></TD>
<TD WIDTH=217>Bitwise <TT><FONT FACE="Courier">AND</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">|</FONT></TT></TD><TD WIDTH=217>Bitwise <TT><FONT FACE="Courier">OR</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">^</FONT></TT></TD><TD WIDTH=217>Bitwise <TT><FONT FACE="Courier">XOR</FONT></TT>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&lt;&lt;</FONT></TT>
</TD><TD WIDTH=217>Left shift</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;&gt;</FONT></TT>
</TD><TD WIDTH=217>Right shift</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT>
</TD><TD WIDTH=217>Zero fill right shift</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=217>Bitwise complement
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&lt;&lt;=</FONT></TT>
</TD><TD WIDTH=217>Left shift assignment</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;&gt;=</FONT></TT>
</TD><TD WIDTH=217>Right shift assignment</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">&gt;&gt;&gt;=</FONT></TT>
</TD><TD WIDTH=217>Zero fill right shift assignment</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">x&amp;=y</FONT></TT>
</TD><TD WIDTH=217><TT><FONT FACE="Courier">AND</FONT></TT> assignment
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">x|=y</FONT></TT></TD>
<TD WIDTH=217><TT><FONT FACE="Courier">OR</FONT></TT> assignment
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">x^=y</FONT></TT></TD>
<TD WIDTH=217><TT><FONT FACE="Courier">NOT</FONT></TT> assignment
</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="Comments">Comments</A></H3>
<P>
Some programmers believe that if something is difficult to code,
it should be difficult to maintain. There is a special place in
the cosmos for them; let's hope that it's not on your project!
Of course, <I>comments</I> should be used throughout code to explain
the programmer's rationale. Comments also can be used to block
out certain code sections for testing purposes.
<P>
Comments have an initial indicator (usually text) and an end indicator.
Sometimes comments are used to separate logic, in which case there
may be no text.
<P>
Table 6.8 illustrates three ways to indicate comments in Java.
<BR>
<P>
<CENTER><B>Table 6.8. Comment indicators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Start</I></CENTER></TD><TD WIDTH=61><CENTER><I>Text</I></CENTER>
</TD><TD WIDTH=445><CENTER><I>End Comment</I></CENTER></TD></TR>
<TR><TD WIDTH=52><TT><FONT FACE="Courier">/*</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">text</FONT></TT></TD><TD WIDTH=445><TT><FONT FACE="Courier">*/</FONT></TT>
</TD></TR>
<TR><TD WIDTH=52><TT><FONT FACE="Courier">/**</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">text</FONT></TT></TD><TD WIDTH=445><TT><FONT FACE="Courier">*/</FONT></TT>
</TD></TR>
<TR><TD WIDTH=52><TT><FONT FACE="Courier">//</FONT></TT></TD>
<TD WIDTH=61><TT><FONT FACE="Courier">text</FONT></TT></TD><TD WIDTH=445>(everything to the end of the line is ignored by the compiler)
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT><FONT FACE="Courier">/*</FONT></TT> comment is familiar
to C programmers. The <TT><FONT FACE="Courier">/**</FONT></TT>
comment is typically used for machine-generated comments. The
third style is familiar to C++ programmers.
<P>
The following are examples of comments:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* this is an example of a comment */
<BR>
<BR>
/** this is another example of a comment. I can<BR>
&nbsp;&nbsp;&nbsp;&nbsp;go to multiple lines and the compiler
will<BR>
&nbsp;&nbsp;&nbsp;&nbsp;look at this as a comment until I do the
proper<BR>
&nbsp;&nbsp;&nbsp;&nbsp;end comment as in */<BR>
<BR>
//&nbsp;&nbsp;with this method I can't go to multiple lines unless
<BR>
// I start each line with the comment marker.</FONT></TT>
</BLOCKQUOTE>
<P>
Comments can be used anywhere in code without affecting the code's
execution or logic. Be sure to terminate the comment, or the compiler
will get confused.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Warning</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
If you forget to terminate a comment, you will see strange results when you try to compile or run the program. Basically, what happens is that the compiler interprets everything up to the next end-comment indicator as part of the comment, which can cut out 
entire sections of your program.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="TokensSummary">Tokens Summary</A></H3>
<P>
<I>Tokens</I> are the building blocks, the most basic parts of
Java. An understanding of them is essential to successful programming
in Java. The following sections give examples of the uses of tokens
in Java.
<H2><A NAME="UsingDataTypes"><FONT SIZE=5 COLOR=#Ff0000>Using
Data Types</FONT></A></H2>
<P>
A <I>variable</I> is something that changes, or varies. In Java,
a variable stores data. Data types define the kind of data that
can be stored in a variable and the limits of the data.
<P>
An example of the use of a data type is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char my_letter;</FONT></TT>
</BLOCKQUOTE>
<P>
This example demonstrates the two essential parts of a variable:
the type (<TT><FONT FACE="Courier">char</FONT></TT>) and the identifier
(<TT><FONT FACE="Courier">my_letter</FONT></TT>). The type notifies
the compiler that the variable <TT><FONT FACE="Courier">my_letter</FONT></TT>
will be of type <TT><FONT FACE="Courier">char</FONT></TT>. Recall
that <TT><FONT FACE="Courier">char</FONT></TT> is a reserved keyword,
and data types are always designated by one of the reserved keywords.
The variable name <TT><FONT FACE="Courier">my_letter</FONT></TT>
at this point has the value of <TT><FONT FACE="Courier">null</FONT></TT>,
which is the default value of type <TT><FONT FACE="Courier">char</FONT></TT>.
Finally, the semicolon tells the compiler that the defining of
the variable is finished.
<P>
Another example of defining data types follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int no_of_albums, b, YellowRose, chair;</FONT></TT>
</BLOCKQUOTE>
<P>
This code example has four variables: <TT><FONT FACE="Courier">no_of_albums</FONT></TT>,
<TT><FONT FACE="Courier">b</FONT></TT>, <TT><FONT FACE="Courier">YellowRose</FONT></TT>,
and <TT><FONT FACE="Courier">chair</FONT></TT>. Each of them is
of type <TT><FONT FACE="Courier">int</FONT></TT> (a reserved keyword).
You can enter multiple variables of the same type on the same
line when separated by a comma. The default value for integers
is <TT><FONT FACE="Courier">0</FONT></TT>. Once again, the semicolon
ends the definition.
<P>
There are two major data types in Java: reference types and primitive
types. 
<P>
Data types can be stored in variables, passed as arguments, returned
as values, and operated on.<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Remember, the definition or typing of a variable does not assign a value to the variable; it simply identifies the possible values of that variable.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="PrimitiveDataTypes">Primitive Data Types</A></H3>
<P>
Primitive data types can have only one value at a time. They do
not reference other data or indicate sequence in a group of data.
They are primitive in that they are the simplest built-in forms
of data in Java. All other data types are made up of combinations
of primitive data types. The primitive data type keywords are
shown in Table 6.9.
<P>
<CENTER><B>Table 6.9. Primitive data type keywords.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><TT><FONT FACE="Courier">Boolean
<BR>
char<BR>
byte<BR>
short<BR>
int<BR>
long<BR>
float<BR>
double</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="IntegerDataTypes">Integer Data Types</A></H3>
<P>
There are four integer data types: <TT><FONT FACE="Courier">byte</FONT></TT>,
<TT><FONT FACE="Courier">short</FONT></TT>, <TT><FONT FACE="Courier">int</FONT></TT>,
and <TT><FONT FACE="Courier">long</FONT></TT>. Each can handle
different ranges of numbers, as summarized in Table 6.10. <BR>
<P>
<CENTER><B>Table 6.10. Integer data type ranges.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Type</I></CENTER></TD><TD WIDTH=66><CENTER><I>Length</I></CENTER>
</TD><TD WIDTH=180><CENTER><I>Minimum Value</I></CENTER></TD>
<TD WIDTH=174><CENTER><I>Maximum Value</I></CENTER></TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">byte</FONT></TT></TD>
<TD WIDTH=66>8 bits</TD><TD WIDTH=180>-128</TD><TD WIDTH=174>127
</TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">short</FONT></TT></TD>
<TD WIDTH=66>16 bits</TD><TD WIDTH=180>-32768</TD><TD WIDTH=174>32767
</TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">int</FONT></TT></TD>
<TD WIDTH=66>32 bits</TD><TD WIDTH=180>-2147483648</TD><TD WIDTH=174>2147483647
</TD></TR>
<TR><TD WIDTH=71><TT><FONT FACE="Courier">long</FONT></TT></TD>
<TD WIDTH=66>64 bits</TD><TD WIDTH=180>-9223372036854775808</TD>
<TD WIDTH=174>9223372036854775807</TD></TR>
</TABLE></CENTER>
<P>
<P>
Java does some interesting things to integer values during operations.
For example, a variable <TT><FONT FACE="Courier">SmallNumber</FONT></TT>
of type <TT><FONT FACE="Courier">byte</FONT></TT> and a variable
<TT><FONT FACE="Courier">LargeNumber</FONT></TT> of type <TT><FONT FACE="Courier">int</FONT></TT>
are added together. The variables both automatically become type
<TT><FONT FACE="Courier">int</FONT></TT>, or 32 bits in length.
<TT><FONT FACE="Courier">SmallNumber</FONT></TT> widens to 32
bits for the operation. (The exception is if the result is boolean,
in which case no variables are expanded.) So whenever two integers
of varying length are operated on, the smaller of the integers
becomes the same length in memory as the larger.
<P>
The only case in which <TT><FONT FACE="Courier">ArithmeticException</FONT></TT>
is called is when there is an attempt to divide by zero, so test
for zero before attempting a divide operation.
<P>
In the section titled &quot;Conditional Expressions&quot; you
will find examples of how to check numerical values.
<P>
Other interesting things happen in Java when the value of an integer
exceeds its defined range. <TT><FONT FACE="Courier">ArithmeticException</FONT></TT>
will <I>not</I> occur. Instead, the value &quot;wraps&quot; around
to the other end of the numeric range for that type. Here is an
example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class IntWrap {<BR>
public static void main (String args[])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
byte StartNumber = 120;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte SmallNumber;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;LargeNumber;
<BR>
SmallNumber = StartNumber;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (LargeNumber=0; LargeNumber
&lt; 16; LargeNumber++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;StartNumber(&quot;
+ StartNumber + &quot;) + LargeNumber (&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LargeNumber
+ &quot;) = &quot; + SmallNumber);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SmallNumber++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
After you save the source code in a file called <TT><FONT FACE="Courier">IntWrap.java</FONT></TT>,
you can compile the source code by typing the following at the
command line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac IntWrap.java</FONT></TT>
</BLOCKQUOTE>
<P>
To run the program, type this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java IntWrap</FONT></TT>
</BLOCKQUOTE>
<P>
The output from the program should be as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">StartNumber(120) + LargeNumber (0) =
120<BR>
StartNumber(120) + LargeNumber (1) = 121<BR>
StartNumber(120) + LargeNumber (2) = 122<BR>
StartNumber(120) + LargeNumber (3) = 123<BR>
StartNumber(120) + LargeNumber (4) = 124<BR>
StartNumber(120) + LargeNumber (5) = 125<BR>
StartNumber(120) + LargeNumber (6) = 126<BR>
StartNumber(120) + LargeNumber (7) = 127<BR>
StartNumber(120) + LargeNumber (8) = -128<BR>
StartNumber(120) + LargeNumber (9) = -127<BR>
StartNumber(120) + LargeNumber (10) = -126<BR>
StartNumber(120) + LargeNumber (11) = -125<BR>
StartNumber(120) + LargeNumber (12) = -124<BR>
StartNumber(120) + LargeNumber (13) = -123<BR>
StartNumber(120) + LargeNumber (14) = -122</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">StartNumber(120) + LargeNumber (15) =
-121</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">char</FONT></TT> Data Types</H4>
<P>
Type <TT><FONT FACE="Courier">char</FONT></TT> is really a 16-bit
unsigned integer that represents a Unicode value. In other words,
it is possible to determine Unicode characters and escape codes
by using a numeric representation. Remember, each printable and
nonprintable character has a Unicode value. Because Java stores
all characters as Unicode, it can be used with virtually any written
language in the world. This is a prime strength for Java. Unfortunately,
at this time there is little support for internationalization
in the way of functions or methods to, for example, print dates,
monetary denominations, time, or numbers according to locale.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
<I>Unicode</I> is an international character set. By following the Unicode standard, Java can easily be used to print text in many different languages.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Floating-Point Data Types</H4>
<P>
Type <TT><FONT FACE="Courier">float</FONT></TT> designates that
the variable is a single-precision, 32-bit, floating-point number.
Type <TT><FONT FACE="Courier">double</FONT></TT> is a double-precision,
64-bit, floating-point number. Here are examples of declaring
floating-point variables:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">float SquareFootage;<BR>
<BR>
double GrossNationalProduct;</FONT></TT>
</BLOCKQUOTE>
<H4><TT><FONT FACE="Courier">boolean</FONT></TT> Data Types</H4>
<P>
Type <TT><FONT FACE="Courier">boolean</FONT></TT> can only have
a value of <TT><FONT FACE="Courier">true</FONT></TT> or <TT><FONT FACE="Courier">false</FONT></TT>.
Internal to Java, a <TT><FONT FACE="Courier">boolean</FONT></TT>
value is a 1-bit logical quantity.
<P>
Other programming languages have <TT><FONT FACE="Courier">boolean</FONT></TT>
values of <TT><FONT FACE="Courier">0</FONT></TT> for <TT><FONT FACE="Courier">false</FONT></TT>
and <TT><FONT FACE="Courier">1</FONT></TT> for <TT><FONT FACE="Courier">true</FONT></TT>.
You can get Java to mimic this behavior if necessary: As in the
C programming language, <TT><FONT FACE="Courier">x!=0</FONT></TT>
will convert the integer <TT><FONT FACE="Courier">x</FONT></TT>
to a <TT><FONT FACE="Courier">boolean</FONT></TT> in which <TT><FONT FACE="Courier">0</FONT></TT>
equals <TT><FONT FACE="Courier">false</FONT></TT> and anything
else equals <TT><FONT FACE="Courier">true</FONT></TT>. On the
other hand, <TT><FONT FACE="Courier">y?1:0</FONT></TT> will convert
the <TT><FONT FACE="Courier">boolean</FONT></TT> variable <TT><FONT FACE="Courier">y</FONT></TT>
to <TT><FONT FACE="Courier">0</FONT></TT> for <TT><FONT FACE="Courier">false</FONT></TT>
and <TT><FONT FACE="Courier">1</FONT></TT> for <TT><FONT FACE="Courier">true</FONT></TT>.
<P>
It is best to think of <TT><FONT FACE="Courier">boolean</FONT></TT>s
in a new light if your &quot;native&quot; language is C or C++.
It is a distinct data type best used to indicate success or failure.
<H4>Summary of Primitive Data Types</H4>
<P>
Primitive data types are the lowest-level objects in Java. Think
of them as actual nongrouped pieces of data, such as numbers and
single characters. Primitive data types can be only one value
at a time in a specific application. Java initializes all primitive
data types to default values if an initial value is not explicitly
specified by the programmer. Integer and floating-point variables
are initialized to <TT><FONT FACE="Courier">0</FONT></TT>. The
<TT><FONT FACE="Courier">char</FONT></TT> data type is initialized
to <TT><FONT FACE="Courier">null</FONT></TT>, and <TT><FONT FACE="Courier">boolean</FONT></TT>
data types are set to <TT><FONT FACE="Courier">false</FONT></TT>.
<H3><A NAME="ReferenceDataTypes">Reference Data Types</A></H3>
<P>
There are situations in which variables must be logically grouped
together for manipulation, possibly because they are going to
be accessed in sequence or identifiers must point to dynamically
allocated objects. These are called <I>reference data types.</I>
<P>
Recall that a primitive data type contains the actual value of
a typed variable; a reference data type contains the address of
a value rather than the value itself. The advantage is that reference
data types can contain addresses that point to a collection of
other data types. Those data types can themselves be of primitive
or reference type.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
There are three types of reference variables: array, class, and interface. Class and interface data types are covered in <A HREF="ch7.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch7.htm" >Chapter 7</A>, &quot;Building Objects.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H4>Arrays</H4>
<P>
<I>Arrays</I> are single- or multidimensional groups of variables.
Think of going grocery shopping with a partner who is as excited
about it as you are. You say, &quot;Honey, what is the third thing
on the list?&quot; (At my house, the reply is &quot;I would tell
you if I could read your handwriting.&quot; This is always good
for a little aisle discussion.) The grocery list acts as the array.
Each item on the list is an element, the smallest part of an array.
It is referenced by its place in the array, as in the third item
on the grocery list.
<P>
Elements can be of a primitive type, as in <TT><FONT FACE="Courier">float</FONT></TT>,
<TT><FONT FACE="Courier">char</FONT></TT>, or <TT><FONT FACE="Courier">int</FONT></TT>.
Elements can also be a class or interface type. Arrays can consist
of other arrays. Arrays can be a powerful and flexible Java tool
if used appropriately.
<P>
You can declare an array without allocating it. In other words,
the variable itself is created, but no space is allocated in memory
for array objects until the array is initialized or values are
assigned to the elements of the array. Arrays are generally initialized
with the <TT><FONT FACE="Courier">new</FONT></TT> command, which
creates a new instance of a reference data type. It is conceptually
similar to the <TT><FONT FACE="Courier">malloc</FONT></TT> command
in C or <TT><FONT FACE="Courier">new</FONT></TT> in C++. In Java,
declaring a reference type does not automatically create space
for that type; it merely creates space for the address that points
to that type.
<P>
The following code fragment shows the declaration of an array,
its creation, and the assignment of values to an element of an
array:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class Array {<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int LISTSIZE = 5;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[] ShoppingList;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = LISTSIZE;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create array<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList = new String[LISTSIZE];
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initialize array<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList[0] = &quot;carrots&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList[1] = &quot;tofu&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList[2] = &quot;rice
milk&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList[3] = &quot;onions&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShoppingList[4] = &quot;pasta
noodles&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i &lt; LISTSIZE;
i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(ShoppingList[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
After you save the source code in a file called <TT><FONT FACE="Courier">Array.java</FONT></TT>,
you can compile the source code by typing the following at the
command line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">javac Array.java</FONT></TT>
</BLOCKQUOTE>
<P>
To run the program, type this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">java Array</FONT></TT>
</BLOCKQUOTE>
<P>
The output from the program should be as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">carrots<BR>
tofu<BR>
rice milk<BR>
onions</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">pasta noodles</FONT></TT>
</BLOCKQUOTE>
<H4>More on Arrays</H4>
<P>
One-dimensional arrays are like the grocery list in the previous
example. There is only one way to reference the items: by using
a subscript to indicate which element number to access. The number
used to reference the specific element of an array is called the
<I>component.</I> This concept is represented in Java as
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char ShowArray[] = new char[5];</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">ShowArray</FONT></TT>
is the name of the array. The <TT><FONT FACE="Courier">[5]</FONT></TT>
declares that there are five elements in the array. All elements
are of type <TT><FONT FACE="Courier">char</FONT></TT>. The elements
are referenced by <TT><FONT FACE="Courier">ShowArray[0]</FONT></TT>
to <TT><FONT FACE="Courier">ShowArray[4].</FONT></TT> In Java,
the subscripts always start at zero and go to the length of the
array minus 1. The <TT><FONT FACE="Courier">new</FONT></TT> command
initializes the array to null characters. Memory space is allocated
to the array here so that values can be assigned to the array.
Reference to elements in the array is by subscript or component.
Therefore, <TT><FONT FACE="Courier">ShowArray[1] = 'j'</FONT></TT>
assigns the value of <TT><FONT FACE="Courier">j</FONT></TT> to
the second component in the array.
<P>
All the elements of an array must be of the same type.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
In theory, all Java arrays are one dimensional. In fact, an array of arrays can be defined in Java, functioning as a two-dimensional array. (This characteristic of Java is noted here because the technical specification of Java states that all arrays are 
one dimensional.)</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Two-dimensional arrays need two reference points because the data
is stored in a grid of rows and columns. Think of a two-dimensional
array as similar to the cells in a spreadsheet. An element is
referenced by the row and column number of its location, as in
<TT><FONT FACE="Courier">[3][4]</FONT></TT>. This means that the
current element being manipulated is in row 4, column 5 of an
array. (Remember that arrays start at zero!)
<H2><A NAME="Expressions"><FONT SIZE=5 COLOR=#Ff0000>Expressions</FONT></A>
</H2>
<P>
The main reasons that code is created are to manipulate, display,
and store data. <I>Expressions,</I> or formulas, are Java's way
of performing a computation. Operators are used in expressions
to do the work of the program and to operate on variables. Expressions
in Java are similar to, although a subset of, C and C++.
<P>
Variables must be declared before they are used. An error will
occur if you try to operate on an undeclared variable.
<P>
The expression <TT><FONT FACE="Courier">book = 4</FONT></TT> uses
the operator <TT><FONT FACE="Courier">=</FONT></TT> to assign
the value <TT><FONT FACE="Courier">4</FONT></TT> to variable <TT><FONT FACE="Courier">book</FONT></TT>.
It is necessary to understand what Java expects of its operators
and the correct syntax of its expressions to get anything accomplished
in this language. So get ready to express yourself in Java!
<H3><A NAME="UsingOperatorsinExpressions">Using Operators in Expressions</A>
</H3>
<P>
Every expression results in a value. The operators tell the <TT><FONT FACE="Courier">javac</FONT></TT>
compiler how to manipulate the variables and other data to give
the appropriate result.
<H4>Unary Operations</H4>
<P>
An operator that manipulates a single value is called a <I>unary
operator</I>. Binary operators act on two values.
<P>
The unary operation is useful to modify variables &quot;in place.&quot;
(C and C++ programmers may be <BR>
familiar with this concept, but to COBOL and BASIC programmers
it may be new.) That is, a <BR>
variable can be operated on in some instances without an intermediate
variable and then reassigned to the original variable. Whew! This
operation is easy in Java. Table 6.11 summarizes the unary operators.
<BR>
<P>
<CENTER><B>Table 6.11. Unary operators.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=153><CENTER><I>Operation</I></CENTER>
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">-</FONT></TT></TD><TD WIDTH=153>Unary negation
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">~</FONT></TT></TD><TD WIDTH=153>Bitwise complement
</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">++</FONT></TT></TD>
<TD WIDTH=153>Increment</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=153>Decrement</TD></TR>
<TR><TD WIDTH=78><TT><FONT FACE="Courier">!</FONT></TT></TD><TD WIDTH=153>Not
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Increment and decrement operators are operators that actually
change the value of the original variable. For example, after
<TT><FONT FACE="Courier">g++</FONT></TT> is executed, the value
of the variable <TT><FONT FACE="Courier">g</FONT></TT> will have
been incremented by one. Likewise, the decrement will actually
decrement variable <TT><FONT FACE="Courier">g</FONT></TT> by one.
The other unary operators do not change the original variable
but enable the coder to work with a &quot;temporary&quot; variable.
For example, after <TT><FONT FACE="Courier">!g</FONT></TT> is
executed, the value of <TT><FONT FACE="Courier">g</FONT></TT>
will remain unchanged.
<P>
Incrementing increases the value by one, as in
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GoUp++;&nbsp;&nbsp;&nbsp;&nbsp;//GoUp
is now incremented by 1</FONT></TT>
</BLOCKQUOTE>
<P>
Decrementing decreases the value by one, as in
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GoDown--;&nbsp;&nbsp;&nbsp;&nbsp;//GoDown
is now decremented by 1</FONT></TT>
</BLOCKQUOTE>
<P>
The bitwise complement reverses the bit structure of a variable.
It changes <TT><FONT FACE="Courier">1</FONT></TT> to <TT><FONT FACE="Courier">0</FONT></TT>
and <TT><FONT FACE="Courier">0</FONT></TT> to <TT><FONT FACE="Courier">1</FONT></TT>.
Unary negation multiplies the variable by <TT><FONT FACE="Courier">-1</FONT></TT>,
in effect reversing the sign of an integer from positive to negative
and negative to positive. However, the sign reversal is only in
effect during the operation. The variable itself is not affected.
<P>
The following example demonstrates unary negation:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">OppositeMe = -15;</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
CheckMe = -OppositeMe + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CheckMe
has the value of 16
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.println(OppositeMe);&nbsp;&nbsp;&nbsp;//OppositeMe
still has the value of -15</FONT></TT>
</BLOCKQUOTE>
<H4>Assignment Operations</H4>
<P>
An <I>assignment operator</I> stores a specific value in the memory
area allocated to a variable. For example, in the expression <TT><FONT FACE="Courier">g
+= 5;</FONT></TT>, <TT><FONT FACE="Courier">5</FONT></TT> is added
to the original value of variable <TT><FONT FACE="Courier">g</FONT></TT>,
and the old value is replaced. Here are more examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">g = 5;&nbsp;&nbsp;&nbsp;&nbsp;// assigns
to g the value 5<BR>
g -=7;&nbsp;&nbsp;&nbsp;&nbsp;// assigns to g the result of g
- 7<BR>
g *=8;&nbsp;&nbsp;&nbsp;&nbsp;// assigns to g the result of g
* 8<BR>
g /=4;&nbsp;&nbsp;&nbsp;&nbsp;// assigns to g the result of g
/ 4<BR>
g %=3;&nbsp;&nbsp;&nbsp;&nbsp;// assigns to g the result of g
% 3</FONT></TT>
</BLOCKQUOTE>
<H4>Binary Operations</H4>
<P>
Unary operators act on only one variable, and <I>binary operators</I>
act on two and return one value. Only the variable that receives
the value as a result of the expression is changed.
<P>
Let's look at the simple expression <TT><FONT FACE="Courier">c
= b + 5</FONT></TT>. In this example, <TT><FONT FACE="Courier">b
+ 5</FONT></TT> is the binary operation. Only variable <TT><FONT FACE="Courier">c</FONT></TT>
is changed as it is assigned the value of whatever is in <TT><FONT FACE="Courier">b</FONT></TT>
plus <TT><FONT FACE="Courier">5</FONT></TT>. Variable <TT><FONT FACE="Courier">b</FONT></TT>
is unchanged. This seems to involve only common sense in a simple
expression; however, more complex expressions do not appear so
straightforward. It is possible to combine unary operations such
as incrementing with binary operations to create a complex expression,
changing more than one variable in the expression. Break these
out in separate expressions if at all possible. This will help
greatly in later debugging and maintenance.
<P>
Complex integer expressions require the use of separators to avoid
unpredictable results. Separators such as parentheses notify the
compiler of the order in which operations should be completed.
In other words, separators set precedence. For example, the result
of <TT><FONT FACE="Courier">2 * 3 + 4</FONT></TT> is <TT><FONT FACE="Courier">10</FONT></TT>,
but <TT><FONT FACE="Courier">2 * (3 + 4)</FONT></TT> is <TT><FONT FACE="Courier">14</FONT></TT>.
In this situation, the separator overcomes the natural precedence
of Java. This is a good time to discuss evaluation order.
<H3>Java's Evaluation Order</H3>
<P>
Java evaluates from left to right, as in the following: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class test {<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args [])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ChangeYou, ChangeMe =
2;<BR>
ChangeYou = (ChangeMe+=2) * (ChangeMe+3);&nbsp;&nbsp;&nbsp;//this
is the important line<BR>
System.out.println(&quot;ChangeMe = &quot; + ChangeMe);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ChangeYou
= &quot; + ChangeYou);<BR>
&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This is the output of this code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ChangeMe = 4<BR>
<BR>
ChangeYou = 28</FONT></TT>
</BLOCKQUOTE>
<P>
In this expression, the variables <TT><FONT FACE="Courier">ChangeYou</FONT></TT>
and <TT><FONT FACE="Courier">ChangeMe</FONT></TT> are declared
to be type <TT><FONT FACE="Courier">int</FONT></TT> and initialized
to <TT><FONT FACE="Courier">2</FONT></TT>. Then the value of variable
<TT><FONT FACE="Courier">ChangeMe</FONT></TT> is incremented by
<TT><FONT FACE="Courier">2</FONT></TT>, resulting in <TT><FONT FACE="Courier">4</FONT></TT>.
The new value of <TT><FONT FACE="Courier">ChangeMe</FONT></TT>
is added to <TT><FONT FACE="Courier">3</FONT></TT>, resulting
in <TT><FONT FACE="Courier">7</FONT></TT>. The results of the
two values in parentheses, <TT><FONT FACE="Courier">4</FONT></TT>
and <TT><FONT FACE="Courier">7</FONT></TT>, are now multiplied.
This value, <TT><FONT FACE="Courier">28</FONT></TT>, is assigned
to <TT><FONT FACE="Courier">ChangeYou</FONT></TT>.
<P>
This is a very poor example of code readability. It would be much
better to break out the expression into multiple expressions.
This shows that just because something is possible does not mean
it is good. However, it is a demonstration of how Java fully executes
expressions from left to right.
<P>
Another place to remember that Java evaluates from left to right
is among operators of the same precedence value. In Java, <TT><FONT FACE="Courier">+</FONT></TT>
and <TT><FONT FACE="Courier">-</FONT></TT> are evaluated at the
same level of precedence. Therefore, if both a <TT><FONT FACE="Courier">+</FONT></TT>
and a <TT><FONT FACE="Courier">-</FONT></TT> operation occur in
the same expression, Java will resolve the expression from left
to right.
<P>
Table 6.12 lists operators from highest to lowest precedence.
Any operators that are on the same line are evaluated in the same
order.<BR>
<P>
<CENTER><B>Table 6.12. Operator precedence, from high to low.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD>Highest</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=119>&nbsp;
</TD><TD WIDTH=68>Lowest</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">[]</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">()</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=119>&nbsp;
</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">--</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">!</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER><TT><FONT FACE="Courier">~</FONT></TT></CENTER>
</TD><TD WIDTH=119><TT><FONT FACE="Courier">instanceof</FONT></TT>
</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">new (type) expression</FONT></TT>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">*</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">/</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER><TT><FONT FACE="Courier">%</FONT></TT></CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">+</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">-</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=119>&nbsp;
</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">&lt;&lt;</FONT></TT>
</TD><TD WIDTH=52><CENTER><TT><FONT FACE="Courier">&gt;&gt;</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER><TT><FONT FACE="Courier">&gt;&gt;&gt;</FONT></TT></CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">&lt;</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">&gt;</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER><TT><FONT FACE="Courier">&lt;=</FONT></TT></CENTER>
</TD><TD WIDTH=119><TT><FONT FACE="Courier">&gt;=</FONT></TT>
</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">==</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">!=</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=119>&nbsp;
</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">&amp;</FONT></TT></TD>
<TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">^</FONT></TT></TD>
<TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">&amp;&amp;</FONT></TT>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">||</FONT></TT></TD>
<TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">?:</FONT></TT></TD>
<TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=52><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=119>&nbsp;</TD><TD WIDTH=68>&nbsp;</TD></TR>
<TR><TD WIDTH=225><TT><FONT FACE="Courier">=</FONT></TT></TD>
<TD WIDTH=52><CENTER><TT><FONT FACE="Courier">op=</FONT></TT></CENTER>
</TD><TD WIDTH=52><CENTER>&nbsp;</CENTER></TD><TD WIDTH=119>&nbsp;
</TD><TD WIDTH=68>&nbsp;</TD></TR>
</TABLE></CENTER>
<P>
<P>
The separators <TT><FONT FACE="Courier">[] </FONT></TT>and <TT><FONT FACE="Courier">()</FONT></TT>
change precedence. Everything within these separators will be
computed before Java looks outside them. Java will evaluate the
expression in separators using its regular rules of precedence,
as in the following expression:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">ConfuseMe = (3 * 2 + 3) + (6 + 4 / 2);</FONT></TT>
</BLOCKQUOTE>
<P>
The value of <TT><FONT FACE="Courier">ConfuseMe</FONT></TT> is
<TT><FONT FACE="Courier">17</FONT></TT>. Multiplication is of
a higher precedence than addition, so <TT><FONT FACE="Courier">3
* 2</FONT></TT> is the first operation, which is then added to
<TT><FONT FACE="Courier">3</FONT></TT>. In the next set of parentheses,
division is of a higher precedence than addition, so <TT><FONT FACE="Courier">4
/ 2</FONT></TT> is the first operation, the result of which is
then added to <TT><FONT FACE="Courier">6</FONT></TT>. The values
from each set of parentheses, <TT><FONT FACE="Courier">9</FONT></TT>
and <TT><FONT FACE="Courier">8</FONT></TT>, are then added together
and assigned to variable <TT><FONT FACE="Courier">ConfuseMe</FONT></TT>.
Let's just hope that variable <TT><FONT FACE="Courier">ConfuseMe</FONT></TT>
has been typed as an integer!
<H4>Using Arrays in Expressions</H4>
<P>
You can use arrays and elements of arrays in the same way as any
other variable. It is not necessary to use any intermediate variable.
Here are some examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">TestArray[0] = 4<BR>
<BR>
TestArray[1] = TestArray[0] * 1996;&nbsp;&nbsp;&nbsp;//assigns
the value of the first element<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
TestArray multiplied by 1996 to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
the second element of array TestArray<BR>
<BR>
TestArray[2]++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// increments the value of the third element<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
of TestArray by one<BR>
<BR>
AnotherArray[45] = &quot;String data&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;assigns
a string of data to the 46th<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
element of AnotherArray</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see, arrays act as any other variable in an expression.
The array structure is in place to group like items together for
easy access.
<H4>Using <TT><FONT FACE="Courier">char</FONT></TT>s in Expressions
</H4>
<P>
Expressions are not just for numeric data types. Character variables
are also assigned by means of an expression. Following is a code
fragment that will get a character from the keyboard:
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Many of the concepts in this code fragment have not been covered up to this point, but don't worry. We will get to them soon.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/*<BR>
&nbsp;&nbsp;&nbsp;This is an example of getting a character from
the keyboard and assigning<BR>
it to a variable<BR>
*/<BR>
<BR>
//declares a new class of code<BR>
class GetCharFromKeyboard {<BR>
<BR>
&nbsp;&nbsp;&nbsp;//declares a method within the class<BR>
&nbsp;&nbsp;&nbsp;public static void main ( String args[] )<BR>
<BR>
&nbsp;&nbsp;&nbsp;//exception that could be generated here<BR>
&nbsp;&nbsp;&nbsp;throws java.io.IOException<BR>
<BR>
&nbsp;&nbsp;&nbsp;//start block of code for this method<BR>
&nbsp;&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//declares KeyboardChar
type char<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char KeyboardChar;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//assign keyboard input to
KeyboardChar<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyboardChar = (char) System.in.read();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//prints KeyboardChar to screen
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(KeyboardChar);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;//ends block of code for method main<BR>
&nbsp;&nbsp;&nbsp;}<BR>
</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
//ends declaration of class GetCharFromKeyboard
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Declarations"><FONT SIZE=5 COLOR=#Ff0000>Declarations</FONT></A>
</H2>
<P>
The <I>declaration statement</I> defines the type of variable.
This section gives more code examples of declaration use.
<P>
Declarations can happen anywhere in sections of code, although
it is best for readability to group them together in the beginning
of a code section.
<P>
Blocks are sections of code beginning and ending with curly braces
(<TT><FONT FACE="Courier">{}</FONT></TT>). Think of a block as
a logical unit of code that can call methods, perform expressions,
display output, and so on. A variable declared in a block is valid
for that block and all its sub-blocks; this is the <I>scope</I>
of the identifier. However, the scope of a variable does not move
outward to the enclosing block; that is, a variable that is declared
in a block has no meaning in the area outside its curly braces.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
With Java you can reuse identifier names between a block and sub-block of code. This means that in memory there may be more than one identifier of a given name. Be careful with this feature! The compiler does not check which variable is being called as 
long as the type is consistent.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Here is an example of <I>hiding</I> a variable by using a second
declared variable of the same name:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">class ShowHiding {<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[])<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;int TableTop;<BR>
&nbsp;&nbsp;&nbsp;TableTop = 2;<BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;switch&nbsp;&nbsp;(AnyCommand) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case '1':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int TableTop
= 4;&nbsp;&nbsp;&nbsp;&nbsp;// TableTop has just been declared
again<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
and assigned a value of 4<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;....&nbsp;&nbsp;&nbsp;/*return to the main loop
<BR>
&nbsp;&nbsp;&nbsp;System.out.println(TableTop);&nbsp;&nbsp;&nbsp;&nbsp;/*TableTop
still has a value of 2*/<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this situation, the second time variable <TT><FONT FACE="Courier">TableTop</FONT></TT>
has been declared as valid for the <TT><FONT FACE="Courier">case</FONT></TT>
command block only. Any values assigned to it are good only for
the scope of that block. When program execution returns to the
main block, any values assigned to the new variable are lost.
The upshot is that there must be a compelling reason to use a
variable name more than once in a program. And be careful not
to declare two variables with the same name accidentally!
<P>
The previous example also shows the combination of a declaration
and an assignment statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int TableTop = 4;</FONT></TT>
</BLOCKQUOTE>
<P>
This declares a variable of type <TT><FONT FACE="Courier">int</FONT></TT>,
with identifier name <TT><FONT FACE="Courier">TableTop</FONT></TT>
and a value of <TT><FONT FACE="Courier">4</FONT></TT>.
<H3><A NAME="DeclaringintegerTypes">Declaring <TT><FONT SIZE=4 FACE="Courier">integer</FONT></TT><FONT SIZE=4>
Types</FONT></A></H3>
<P>
Variables of type <TT><FONT FACE="Courier">integer</FONT></TT>
are declared by the amount of memory space they will be allotted.
(This is discussed more fully in the &quot;Integer Data Types&quot;
section.) Following are examples of <TT><FONT FACE="Courier">integer</FONT></TT>
declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">byte ByteVar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//8
bits<BR>
short ShortVar;&nbsp;&nbsp;&nbsp;&nbsp;//16 bits<BR>
int IntVar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//32
bits<BR>
long LongVar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//64 bits</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="DeclaringFloatingPointTypes">Declaring Floating-Point
Types</A></H3>
<P>
Floating-point variables are 32 or 64 bits in length. Following
are examples of floating-point declarations:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">float FloatVar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//32
bits<BR>
double DoubleVar;&nbsp;&nbsp;&nbsp;&nbsp;//64 bits</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="DeclaringcharacterTypes">Declaring <TT><FONT SIZE=4 FACE="Courier">character</FONT></TT><FONT SIZE=4>
Types</FONT></A></H3>
<P>
A <TT><FONT FACE="Courier">character</FONT></TT> type variable
holds only one character. This is different from the <TT><FONT FACE="Courier">Strings</FONT></TT>
class, which contains groups of characters. Remember, the <TT><FONT FACE="Courier">char</FONT></TT>
type holds an integer that references the Unicode character. The
following sample code declares two character types:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char MyChar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
holds one character<BR>
char MyChar = 'y';&nbsp;&nbsp;&nbsp;&nbsp;// declares variable
MyChar and assigns y to it</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="DeclaringArrays">Declaring Arrays</A></H3>
<P>
Arrays are covered in depth in the &quot;Data Types&quot; and
&quot;Expressions&quot; sections of this chapter. Arrays are one-dimensional
lists of objects that are referenced by component numbers or subscripts.
They can consist of other arrays, resulting in classic multidimensional
arrays.
<P>
Arrays are declared as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char MyCharArray[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//one-dimensional
array<BR>
char AnotherArray[][];&nbsp;&nbsp;&nbsp;&nbsp;//two-dimensional
array<BR>
int IntegerArray[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//one-dimensional
array of integers<BR>
int []IntegerArray;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//equivalent
to IntegerArray[]</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ControlFlow"><FONT SIZE=5 COLOR=#Ff0000>Control Flow</FONT></A>
</H2>
<P>
This chapter has been explaining the basic elements of programming
in Java: tokens, types, expressions, and declarations. Expressions,
operators, and separators can be combined to manipulate data in
a variety of ways. However, something is lacking: the ability
to make decisions in the program. These decisions instruct the
program which expression to solve or what data to assign to a
variable. The solution to this problem is control flow. <I>Control
flow</I> instructs the program how to make a decision and how
further processing should proceed on the basis of that decision.
Control flow gets your computer to start doing some of the thinking
for you!
<P>
The building blocks of control flow are the <TT><FONT FACE="Courier">{</FONT></TT>
and <TT><FONT FACE="Courier">}</FONT></TT> block delimiter characters
and the <TT><FONT FACE="Courier">if</FONT></TT>, <TT><FONT FACE="Courier">while</FONT></TT>,
<TT><FONT FACE="Courier">do</FONT></TT>, <TT><FONT FACE="Courier">for</FONT></TT>,
and <TT><FONT FACE="Courier">switch</FONT></TT> keywords. Each
of these can be used to control how your program executes by determining
if a condition is true and then executing a different section
of code, based on the result. This is called a <I>conditional
expression</I>.
<H3><A NAME="BlocksandStatements">Blocks and Statements</A></H3>
<P>
A<I> statement</I> is any line of code ending in a semicolon.
A statement can be an expression, a method call, or a declaration.
A <I>block </I>is a group of statements that form a single compound
statement. Think of blocks as statements logically grouped together
for program flow and readability.
<P>
How do you tell Java where a block starts and ends? The characters
<TT><FONT FACE="Courier">{</FONT></TT> and <TT><FONT FACE="Courier">}</FONT></TT>
group such sections together. For example, the following is considered
a block of code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">{<BR>
&nbsp;&nbsp;&nbsp;Store&nbsp;&nbsp;&nbsp;= &quot;Grocery&quot;;
<BR>
&nbsp;&nbsp;&nbsp;Item[0] = &quot;spinach&quot;;<BR>
&nbsp;&nbsp;&nbsp;Item[1] = &quot;tofu&quot;;<BR>
&nbsp;&nbsp;&nbsp;Item[3] = &quot;rice&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
When the program runs and gets to this block of code, it will
begin execution at the beginning <TT><FONT FACE="Courier">{</FONT></TT>
and will not continue execution elsewhere until leaving the final
<TT><FONT FACE="Courier">}</FONT></TT>. The opening <TT><FONT FACE="Courier">{</FONT></TT>,
the closing <TT><FONT FACE="Courier">}</FONT></TT>, and all code
in between is considered a <I>block</I>. The curly braces must
be paired one with one another or Java will not know where a block
begins and ends.
<H3><A NAME="ConditionalExpressions">Conditional Expressions</A>
</H3>
<P>
<I>Conditional expressions</I> will generally execute one of several
sections of code on the basis of a conditional test. This code
can be as simple as a single statement, but more complex sections
of code will be made up of many statements. Conditional expressions
are used to make decisions in a program. They are used to evaluate
whether a condition is true or false and will branch to different
sections of code on the basis of the answer.
<H4><TT><FONT FACE="Courier">if</FONT></TT></H4>
<P>
The simplest, but most important, conditional expression is the
<TT><FONT FACE="Courier">if</FONT></TT> statement. An <TT><FONT FACE="Courier">if</FONT></TT>
statement makes up a conditional expression of the form
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (expression) statement;</FONT></TT>
</BLOCKQUOTE>
<P>
or
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (<I>expression</I>)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
If the expression in the parentheses evaluates to the boolean
<TT><FONT FACE="Courier">true</FONT></TT>, <TT><I><FONT FACE="Courier">statement</FONT></I></TT>
is executed. If the expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>,
<TT><I><FONT FACE="Courier">statement</FONT></I></TT><I> </I>is
skipped and execution continues at the statement following the
<TT><FONT FACE="Courier">if</FONT></TT> statement. The following
code fragment shows how this works:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int Number;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare variable<BR>
Number = System.io.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get character from keyboard<BR>
if ( (Number % 2) == 0 )<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;even&quot;);&nbsp;&nbsp;//
test if number is even and<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print &quot;even&quot; if it is</FONT></TT>
</BLOCKQUOTE>
<P>
Note that <TT><FONT FACE="Courier">System.io.read</FONT></TT>
will retrieve only one character at a time, so this program actually
will handle only single-digit numbers. Only the first character
will be tested if you enter a multiple-digit number.
<P>
In this example, the program reads a number from the keyboard.
It is then tested to determine if it is even. If it is, the <TT><FONT FACE="Courier">System.out.println</FONT></TT>
statement is executed and the program terminates or continues
to the next statement block.
<P>
Here is how the previous example can be extended:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int Number;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare variable<BR>
Number =System.io.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get number from keyboard<BR>
if ( (Number % 2) == 0 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test if number is even<BR>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
begin block<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;even&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//
print message to screen<BR>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
end block</FONT></TT>
</BLOCKQUOTE>
<P>
There is an optional companion to the <TT><FONT FACE="Courier">if</FONT></TT>
statement that can extend its usefulness: the <TT><FONT FACE="Courier">else</FONT></TT>
statement. The statement following the <TT><FONT FACE="Courier">if</FONT></TT>
expression is executed only if the expression evaluates to <TT><FONT FACE="Courier">true</FONT></TT>.
The statement following the <TT><FONT FACE="Courier">else</FONT></TT>
is executed only if the <TT><FONT FACE="Courier">if</FONT></TT>
expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int Number;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare variable<BR>
Number = System.io.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get character from keyboard<BR>
if ( (Number % 2) == 0 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
test if number is even<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
begin if block<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;even&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//
print message to screen<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
end if block<BR>
else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
else if number not even<BR>
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
begin else block<BR>
&nbsp;&nbsp;&nbsp;System.out.println(&quot;odd&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print message to screen<BR>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
end else block</FONT></TT>
</BLOCKQUOTE>
<P>
You can also nest <TT><FONT FACE="Courier">if</FONT></TT> statements
within each other if you need a more complex multiway branch:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char KeyboardChar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/
declare variables<BR>
int Number;<BR>
System.out.print(&quot;Enter number&gt; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print prompt to screen<BR>
Number = System.in.read();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/
get character from keyboard<BR>
if ( (Number % 2) == 0 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/
test if number is even<BR>
{&nbsp;&nbsp;&nbsp;&nbsp;// begin if block<BR>
&nbsp;&nbsp;&nbsp;if ( Number &lt; 5 )<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;// begin nested if
block<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;even
&amp; &lt; 5&quot;);&nbsp;&nbsp;&nbsp;&nbsp;// print message to
screen<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// end nested if block
<BR>
&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;// else if number
not &lt; 0<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;// begin nested if
block<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;even
&amp; &gt;= 5&quot;);&nbsp;&nbsp;&nbsp;// print message to screen
<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// end nested if block
<BR>
}&nbsp;&nbsp;&nbsp;&nbsp;// end if block<BR>
else&nbsp;&nbsp;&nbsp;&nbsp;// else if number not even<BR>
{&nbsp;&nbsp;&nbsp;&nbsp;// begin else block<BR>
&nbsp;&nbsp;&nbsp;if ( Number &lt; 5 )<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;// begin nested if
block<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;odd
&amp; &lt; 5&quot;);&nbsp;&nbsp;&nbsp;&nbsp;// print message to
screen<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// end nested if block
<BR>
&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;// else if number
not &lt; 0<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;// begin nested if
block<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;odd
&amp; &gt;= 5&quot;);&nbsp;&nbsp;&nbsp;&nbsp;// print message
to screen<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// end nested if block
<BR>
}&nbsp;&nbsp;&nbsp;&nbsp;// end else block</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">if</FONT></TT> statements are powerful
and are the underpinnings for much of programming. The <TT><FONT FACE="Courier">if</FONT></TT>
statement is a fundamental control structure, because almost anything
can be tested with one.
<H4><TT><FONT FACE="Courier">switch</FONT></TT></H4>
<P>
A variation on the <TT><FONT FACE="Courier">if</FONT></TT> statement
is the <TT><FONT FACE="Courier">switch</FONT></TT> statement,
which performs a multiway branch instead of a simple binary branch.
<TT><FONT FACE="Courier">switch</FONT></TT> statements are of
the form
<BLOCKQUOTE>
<TT><FONT FACE="Courier">switch (<I>expression</I>)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;case <I>value</I>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;case <I>value</I>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>
&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">switch</FONT></TT> begins
the switch construct. The parentheses contain values that must
evaluate to a <TT><FONT FACE="Courier">byte</FONT></TT>, a <TT><FONT FACE="Courier">char</FONT></TT>,
a <TT><FONT FACE="Courier">short</FONT></TT>, or an <TT><FONT FACE="Courier">int</FONT></TT>.
Next is a required <TT><FONT FACE="Courier">{</FONT></TT>, followed
by any number of constructs that begin with the keyword <TT><FONT FACE="Courier">case</FONT></TT>
and end with <TT><FONT FACE="Courier">break</FONT></TT>, with
any number of statements between. Next there is an optional section
that begins with the keyword <TT><FONT FACE="Courier">default</FONT></TT>
and ends with <TT><FONT FACE="Courier">break</FONT></TT>. Finally,
a required <TT><FONT FACE="Courier">}</FONT></TT> completes the
<TT><FONT FACE="Courier">case</FONT></TT> statement. This sounds
complicated in description, but is obvious in usage, as demonstrated
in the next example.
<P>
The <TT><FONT FACE="Courier">case</FONT></TT> keywords are each
followed by a <TT><I><FONT FACE="Courier">value</FONT></I></TT>.
This must also be of type <TT><FONT FACE="Courier">byte</FONT></TT>,
<TT><FONT FACE="Courier">char</FONT></TT>, <TT><FONT FACE="Courier">short</FONT></TT>,
or <TT><FONT FACE="Courier">int</FONT></TT>. The <TT><FONT FACE="Courier">case</FONT></TT>
statement itself works by evaluating the expression and then scanning
down the <TT><FONT FACE="Courier">case</FONT></TT> statements
until an exact match is found. At this point the corresponding
group of statements between the <TT><FONT FACE="Courier">case</FONT></TT>
and <TT><FONT FACE="Courier">break</FONT></TT> will be executed.
When the break is encountered, execution will resume at the first
statement following the <TT><FONT FACE="Courier">switch</FONT></TT>
construct. If no matches are found and a default is present, the
group of statements associated with <TT><FONT FACE="Courier">default</FONT></TT>
will be executed. If no <TT><FONT FACE="Courier">default</FONT></TT>
is present, execution will fall through the entire <TT><FONT FACE="Courier">switch</FONT></TT>
construct and do nothing, with execution again continuing after
the end of the construct.
<P>
A <TT><FONT FACE="Courier">case</FONT></TT> statement does not
have to have a <TT><FONT FACE="Courier">break</FONT></TT> associated
with it. If <TT><FONT FACE="Courier">break</FONT></TT> is not
present, program execution falls through to the next <TT><FONT FACE="Courier">case</FONT></TT>
statement. It keeps executing that group of statements until a
<TT><FONT FACE="Courier">break</FONT></TT> is encountered, so
be sure to place appropriate breaks if this is not the intended
action.
<P>
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">static void ParseChar (char KeyboardChar)
<BR>
{<BR>
switch (KeyboardChar) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <I>'l'</I>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;left&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <I>'r'</I>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;right&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <I>'q'</I>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//note no break here, falls through<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <I>'\n'</I>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <I>'h'</I>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//note no break here either<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Syntax:
(l)eft, (r)ight, (q)uit&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Please
enter a valid character&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyboardChar
= '';<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example <TT><I><FONT FACE="Courier">expression</FONT></I></TT>
is a <TT><FONT FACE="Courier">char</FONT></TT> type, and each
<TT><FONT FACE="Courier">case</FONT></TT> contains a corresponding
<TT><FONT FACE="Courier">char</FONT></TT> value.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Warning:</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
A common programming error is to forget to put in a <TT><FONT FACE="Courier">break</FONT></TT> where it is needed; the result is that unintended codes are executed.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<TT><FONT FACE="Courier">case</FONT></TT> statements cannot evaluate
strings or objects, as is true with C and C++. Only items whose
values can be evaluated as integers can be used in <TT><FONT FACE="Courier">case</FONT></TT>
statements. Remember, of course, that <TT><FONT FACE="Courier">char</FONT></TT>
is evaluated as an integer. Many times you will wish <TT><FONT FACE="Courier">case</FONT></TT>
statements could handle more complex objects. If you are working
with one of the allowed expression types or can build some sort
of index that uses one of these types, the <TT><FONT FACE="Courier">switch</FONT></TT>
statement can be an efficient and easily understood method for
doing complex branching.
<H3><A NAME="LoopingExpressions">Looping Expressions</A></H3>
<P>
<I>Looping expressions</I> generally continue to loop through
a section of code until a certain condition is met. Some looping
expressions check the condition before executing the code. Other
looping expressions check the condition after executing the code.
<H4><TT><FONT FACE="Courier">while</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">while</FONT></TT> loop is a construct
that repeatedly executes a block of code as long as a boolean
condition remains <TT><FONT FACE="Courier">true</FONT></TT>. The
initial <TT><FONT FACE="Courier">while</FONT></TT> expression
is evaluated first. It is possible for the statements making up
a <TT><FONT FACE="Courier">while</FONT></TT> loop never to execute
if the initial expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
<TT><FONT FACE="Courier">while</FONT></TT> loops are of the form
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while ( <I>expression</I> ) <I>statement</I>;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or<BR>
while ( <I>expression</I> )<BR>
{<BR>
&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">while</FONT></TT> begins
the <TT><FONT FACE="Courier">while</FONT></TT> construct. The
parentheses contain an expression, which must evaluate to a boolean.
This is followed by a statement or a block.
<P>
When a <TT><FONT FACE="Courier">while</FONT></TT> loop is encountered,
the expression is evaluated first. If it evaluates to <TT><FONT FACE="Courier">true</FONT></TT>,
the statement or block following the <TT><FONT FACE="Courier">while</FONT></TT>
statement, known as the <I>body</I> of the <TT><FONT FACE="Courier">while</FONT></TT>
loop, is executed. When the end of the body is reached, the expression
is evaluated again. If it is <TT><FONT FACE="Courier">false</FONT></TT>,
execution will continue with the next statement following the
<TT><FONT FACE="Courier">while</FONT></TT> loop. If it is <TT><FONT FACE="Courier">true</FONT></TT>,
the body of the <TT><FONT FACE="Courier">while</FONT></TT> loop
will be executed again. The body will continue to be executed
until the expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
<P>
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">char KeyboardChar =(char)System.in.read();
<BR>
while (KeyboardChar != 'q')<BR>
{<BR>
&nbsp;&nbsp;&nbsp;ProcessChar(KeyboardChar);<BR>
&nbsp;&nbsp;&nbsp;KeyBoardChar = (char)System.in.read();<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This expression tests whether <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
is equal to the character <TT><FONT FACE="Courier">q</FONT></TT>.
If it is not, the body of the <TT><FONT FACE="Courier">while</FONT></TT>
loop will be executed, which will process the character and then
read in another. This will continue until the character <TT><FONT FACE="Courier">q</FONT></TT>
is read in. Notice in this example that <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
has been initialized by reading a character before the loop is
executed. If it was not explicitly set, the <TT><FONT FACE="Courier">while</FONT></TT>
loop might never be entered, depending on what value <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
had. This is another common programming error. Even if <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
were initialized to something, it would be processed before the
user had a chance to type in a character.
<P>
A <TT><FONT FACE="Courier">while</FONT></TT> loop continues to
loop until the expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
It is possible for a <TT><FONT FACE="Courier">while</FONT></TT>
loop to execute forever if the expression never evaluates to <TT><FONT FACE="Courier">false</FONT></TT>;
this is known as an <I>infinite loop</I>. A common cause of infinite
loops is that the programmer forgot to put a statement that changes
part of the expression in the body of the loop. If the expression
never changes, it will always evaluate the same and an infinite
loop occurs.
<H4><TT><FONT FACE="Courier">do-while</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">do</FONT></TT> loop enables your
code to repeatedly execute a block of code until a boolean expression
evaluates to <TT><FONT FACE="Courier">false</FONT></TT>. It is
almost identical to the <TT><FONT FACE="Courier">while</FONT></TT>
loop, except the expression is evaluated at the bottom of the
loop rather than the top. This means that the contents of the
loop will always be executed at least once. <TT><FONT FACE="Courier">do</FONT></TT>
loops are of the form
<BLOCKQUOTE>
<TT><FONT FACE="Courier">do <I>statement</I>; while ( <I>expression</I>
);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or<BR>
do<BR>
{<BR>
&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
} while ( <I>expression</I> );</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">do</FONT></TT> begins the
<TT><FONT FACE="Courier">do</FONT></TT> construct. This is followed
by a statement or a block. Next is the keyword <TT><FONT FACE="Courier">while</FONT></TT>,
followed by the parentheses containing an expression that must
evaluate to a boolean.
<P>
When a <TT><FONT FACE="Courier">do</FONT></TT> loop is encountered,
the statement or block following the <TT><FONT FACE="Courier">do</FONT></TT>
keyword is executed. When the <TT><FONT FACE="Courier">do</FONT></TT>
loop body completes, <TT><FONT FACE="Courier">expression</FONT></TT>
is evaluated. If it is <TT><FONT FACE="Courier">false</FONT></TT>,
execution will continue with the next statement following the
<TT><FONT FACE="Courier">do</FONT></TT> loop. If it is <TT><FONT FACE="Courier">true</FONT></TT>,
the body of the <TT><FONT FACE="Courier">do</FONT></TT> loop will
be executed again. The body will continue to be executed until
the expression evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
<P>
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">do<BR>
{<BR>
&nbsp;&nbsp;&nbsp;KeyBoardChar = (char)System.in.read();<BR>
&nbsp;&nbsp;&nbsp;ProcessChar(KeyboardChar);<BR>
} while (KeyboardChar != 'q')</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the body of the <TT><FONT FACE="Courier">while</FONT></TT>
loop is executed, which reads in a character and then processes
it. The expression is then evaluated to determine if <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
is equal to the character <TT><FONT FACE="Courier">q</FONT></TT>.
If it is, execution will continue with the first statement after
the <TT><FONT FACE="Courier">do</FONT></TT> loop. If it is not,
the <TT><FONT FACE="Courier">do</FONT></TT> loop body will be
executed again. This will continue until the character <TT><FONT FACE="Courier">q</FONT></TT>
is read in.
<P>
Compare this version with the <TT><FONT FACE="Courier">while</FONT></TT>
loop version shown previously. It does not need an initialization
of <TT><FONT FACE="Courier">KeyboardChar</FONT></TT> because the
variable will be read in at the beginning of the loop. This is
the most common reason for choosing a <TT><FONT FACE="Courier">do</FONT></TT>
over a <TT><FONT FACE="Courier">while</FONT></TT> loop.
<P>
Like with the <TT><FONT FACE="Courier">while</FONT></TT> loop,
it is possible to create an infinite loop by forgetting to put
in the body of the loop a statement that changes part of the expression.
<H4><TT><FONT FACE="Courier">for</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">for</FONT></TT> loop enables code
to execute repeatedly until a boolean expression evaluates to
<TT><FONT FACE="Courier">false</FONT></TT>. It is similar to a
<TT><FONT FACE="Courier">while</FONT></TT> loop but is more specialized.
As in a <TT><FONT FACE="Courier">while</FONT></TT> loop, the expression
is evaluated at the top of the loop. However, it provides a more
explicit means for initializing a loop variable and modifying
it at the end of the loop. <TT><FONT FACE="Courier">for</FONT></TT>
loops are of the form
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (<I>initialization</I>; <I>expression</I>;
<I>modification</I>) <I>statement</I>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or<BR>
for (<I>initialization</I>; <I>expression</I>; <I>modification</I>)
<BR>
{<BR>
&nbsp;&nbsp;&nbsp;<I>statement</I>(s);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The keyword <TT><FONT FACE="Courier">for</FONT></TT> begins the
<TT><FONT FACE="Courier">for</FONT></TT> construct. The parentheses
contain an <TT><I><FONT FACE="Courier">initialization</FONT></I></TT>,
an <TT><I><FONT FACE="Courier">expression</FONT></I></TT>, and
a <TT><I><FONT FACE="Courier">modification</FONT></I></TT>. The
<TT><I><FONT FACE="Courier">initialization</FONT></I></TT> can
be a statement of any kind, but typically its purpose is to initialize
part of the expression. Initialization is followed by a semicolon
(<TT><FONT FACE="Courier">;</FONT></TT>), followed by an expression.
Like the <TT><FONT FACE="Courier">while</FONT></TT> and <TT><FONT FACE="Courier">do</FONT></TT>
loops, the expression must evaluate to a boolean. This is followed
by another semicolon and then <TT><I><FONT FACE="Courier">modification</FONT></I></TT>.
<TT><I><FONT FACE="Courier">modification</FONT></I></TT> also
can be any statement, but again is typically used to modify part
of the expression. Finally, this is followed by a statement or
a block.
<P>
When a <TT><FONT FACE="Courier">for</FONT></TT> loop is encountered,
<TT><I><FONT FACE="Courier">initialization</FONT></I></TT> is
first executed, and then the expression. If it evaluates to <TT><FONT FACE="Courier">true</FONT></TT>,
the statement or block following the <TT><FONT FACE="Courier">while</FONT></TT>
statement is executed. This statement or block is known as the
<I>body</I> of the <TT><FONT FACE="Courier">for</FONT></TT> loop.
When the end of the body is reached, <TT><I><FONT FACE="Courier">modification</FONT></I></TT>
is executed. The expression is then evaluated again. If it is
<TT><FONT FACE="Courier">false</FONT></TT>, execution continues
with the next statement following the <TT><FONT FACE="Courier">for</FONT></TT>
loop. If it is <TT><FONT FACE="Courier">true</FONT></TT>, the
body of the <TT><FONT FACE="Courier">for</FONT></TT> loop is executed
again. The body continues to be executed until the expression
evaluates to <TT><FONT FACE="Courier">false</FONT></TT>.
<P>
Here is an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (char KeyboardChar=ProcessChar(KeyboardChar);
KeyboardChar != 'q';<BR>
KeyBoardChar=(char)System.in.read())<BR>
{<BR>
&nbsp;&nbsp;&nbsp;ProcessChar(KeyboardChar);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
is initialized by reading in a character. <TT><FONT FACE="Courier">expression</FONT></TT>
is then evaluated to determine if <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>
is equal to the character <TT><FONT FACE="Courier">q</FONT></TT>.
If so, execution will continue with the first statement after
the <TT><FONT FACE="Courier">for</FONT></TT> loop. If not, the
body of the <TT><FONT FACE="Courier">for</FONT></TT> loop will
be executed, which will process <TT><FONT FACE="Courier">KeyboardChar</FONT></TT>.
Next, another character will be read in. This will continue until
the character <TT><FONT FACE="Courier">q</FONT></TT> is read in.
<P>
You can use <TT><FONT FACE="Courier">for</FONT></TT> loops to
move through a range of numbers. This is used in conjunction with
arrays or other indexes. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int Array;<BR>
for (I=0; I &lt; ArraySize; I++)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;if (Array[i] &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
negative number encountered, index = &quot; + I);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessArray(Array[i]);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This <TT><FONT FACE="Courier">for</FONT></TT> loop will initialize
<TT><FONT FACE="Courier">I</FONT></TT> to a value of zero and
then step through <TT><FONT FACE="Courier">Array</FONT></TT>,
checking for negative numbers before processing an entry. This
is a compact, easily assimilated method of writing code.
<P>
Like with the <TT><FONT FACE="Courier">while</FONT></TT> and <TT><FONT FACE="Courier">do</FONT></TT>
loops, it is possible to create an infinite loop by forgetting
to put a statement that changes part of the expression in the
body of the loop.
<H4><TT><FONT FACE="Courier">break</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">break</FONT></TT> construct can be
used to break out of the middle of a <TT><FONT FACE="Courier">for</FONT></TT>,
<TT><FONT FACE="Courier">do</FONT></TT>, or <TT><FONT FACE="Courier">while</FONT></TT>
loop. (This chapter has already discussed how to use it to break
out of a <TT><FONT FACE="Courier">switch</FONT></TT> statement.)
When a <TT><FONT FACE="Courier">break</FONT></TT> statement is
encountered, execution of the current loop immediately stops and
resumes at the first statement following the current loop.
<P>
Here is how the previous <TT><FONT FACE="Courier">for</FONT></TT>
loop example could be extended:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int ix;<BR>
for (ix=0; ix &lt; ArraySize; ix++)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;if (Array[ix] &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
negative number encountered, index = &quot; + ix);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;ProcessArray(Array[ix]);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Again, this code will loop through <TT><FONT FACE="Courier">Array</FONT></TT>
looking for negative entries. However, by including the <TT><FONT FACE="Courier">break</FONT></TT>
statement, execution of this <TT><FONT FACE="Courier">for</FONT></TT>
loop will stop at the first negative entry. In this example, a
negative entry might be considered so severe that no other processing
should be done. Also notice that no <TT><FONT FACE="Courier">else</FONT></TT>
statement is needed because if an error occurs, execution will
jump to the end of the loop, skipping the entry-processing code.
<H4><TT><FONT FACE="Courier">continue</FONT></TT></H4>
<P>
The <TT><FONT FACE="Courier">continue</FONT></TT> construct can
be used to short-circuit parts of a <TT><FONT FACE="Courier">for</FONT></TT>,
<TT><FONT FACE="Courier">do</FONT></TT>, or <TT><FONT FACE="Courier">while</FONT></TT>
loop. When a <TT><FONT FACE="Courier">continue</FONT></TT> statement
is encountered, execution of the current loop immediately resumes
at the top, skipping all other code between it and the end of
the loop.
<P>
The following <TT><FONT FACE="Courier">for</FONT></TT> loop uses
the <TT><FONT FACE="Courier">continue</FONT></TT> construct:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">int ix;<BR>
for (ix=0; ix &lt; ArraySize; ix++)<BR>
{<BR>
&nbsp;&nbsp;if (Array[ix] &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
negative number encountered, index = &quot; + ix);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>
&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;ProcessArray(Array[ix]);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Again, this code will loop through <TT><FONT FACE="Courier">Array</FONT></TT>
looking for negative entries. However, the inclusion of the <TT><FONT FACE="Courier">continue</FONT></TT>
statement means that execution of this <TT><FONT FACE="Courier">for</FONT></TT>
loop will not continue in the body of the loop if a negative entry
is encountered. In this example, a negative entry might be considered
illegal and should not be processed. However, it is not so severe
that it stops processing other entries. Again, notice that no
<TT><FONT FACE="Courier">else</FONT></TT> statement is needed
because if an error occurs, execution will continue at the top
of the loop, skipping the entry-processing code.
<H4>Labeled Loops</H4>
<P>
If <TT><FONT FACE="Courier">break</FONT></TT> and <TT><FONT FACE="Courier">continue</FONT></TT>
only take you to the end or beginning of the current loop, what
do you do if you have nested loops and need to get out of more
than just the current one? Java provides an extended version of
<TT><FONT FACE="Courier">break</FONT></TT> and <TT><FONT FACE="Courier">continue</FONT></TT>
for just this purpose. By adding a label to a loop and referencing
it in a <TT><FONT FACE="Courier">break</FONT></TT> or <TT><FONT FACE="Courier">continue</FONT></TT>
statement, you can make execution continue at the end or beginning
of the loop of your choice.
<P>
Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">err:<BR>
for (ix=0; ix &lt; ArraySize; ix++)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;for (j=0; j &lt; ArraySize; j++)<BR>
&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Array[ix][j] &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;ERROR:
negative number encountered, index = &quot; + ix + &quot;,&quot;
+ j);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break err;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessArray(Array[ix][j]);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, <TT><FONT FACE="Courier">Array</FONT></TT> is
extended to two dimensions, and two <TT><FONT FACE="Courier">for</FONT></TT>
loops are used to step through all elements of the array. If a
negative entry is encountered, execution will branch to the end
of the <TT><FONT FACE="Courier">for</FONT></TT> loop labeled <TT><FONT FACE="Courier">err</FONT></TT>,
rather than the normal inner one. Without this construct, you
would need to set an additional flag variable and test it in the
outer loop. The label itself must immediately precede the intended
loop; if it is placed anywhere else in the code, a compile-time
error will occur.
<P>
The capability to jump out of the middle of a loop is handled
in C++ and some C implementations with a <TT><FONT FACE="Courier">goto</FONT></TT>
statement. The <TT><FONT FACE="Courier">goto</FONT></TT> can branch
anywhere in the code, which can lead to what is known as <I>spaghetti
code</I>. Of course, spaghetti code is something we recognize
in other people's code, but never our own! The labeled loop concept
in Java provides breakout capability while limiting the scope.
It is a good compromise.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></A>
</H2>
<P>
This chapter covers the most basic parts of the Java programming
language. It gives many examples of ways to use tokens, literals,
data types, expressions, declarations, and control flow. Together
these form the fundamentals of any program you write or application
you develop in Java. This chapter is also a good reference for
correct syntax. You will be well on your way to developing powerful
applications in Java when you combine these fundamentals with
the information covered in the next chapter.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch5.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch5.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch7.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch7.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
