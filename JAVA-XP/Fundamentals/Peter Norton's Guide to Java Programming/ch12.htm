<HTML>

<HEAD>
   <TITLE>Chapter 12 -- The Java I/O and Utility Class
Libraries</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<!--Begin JavaScript roadmap code.  If editing downloaded HTML source, delete
 this portion.-->

<script language="JavaScript">
<!--

function TripodShowPopup()
{
   var bName=navigator.appName;
   var bVer=parseInt(navigator.appVersion);
   var now = new Date();
   var popupURL = "/adm/popup/roadmap.shtml?"+"member_name=er4ebus&path=peternortonjavaprograming&client_ip=200.190.100.218&ts=1015336996&ad_type=POPUP&category=net&id=befd27efac775bceb1e0ba5a8997467a";
   var popupName = "TripodPopup";

   if (bName=="Netscape" && bVer<=3)
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=614,height=150');
   }
   else
   {
      var popup = window.open("", popupName,'toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=0,resizable=0,width=604,height=135');
   }
   popup.location = popupURL;
}

if(window.parent==window)
{
   TripodShowPopup();
}

// -->
</script>

<script language="JavaScript1.2">
<!--

function changeOpenFunction()
{
   var original_window_open = window.open;
   function new_open_function(url, name, features, replace)
   {
      if(name != "TripodPopup")
         return original_window_open(url, name, features, replace);
   }
   window.open = new_open_function;
}
var bName = navigator.appName;

if(bName != "Netscape")
   changeOpenFunction();

// -->
</script>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#Ff0000>Chapter 12</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#Ff0000>The Java I/O and Utility Class
Libraries</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#IntroductiontothejavaioPackage" >Introduction to the java.io Package</A>
<LI><A HREF="#HowJavasIOSystemWorks" >How Java's I/O System Works</A>
<LI><A HREF="#JavaInputStreams" >Java Input Streams</A>
<UL>
<LI><A HREF="#TheInputStreamClass" >The InputStream Class</A>
<LI><A HREF="#MoreontheInputStreamClassandItsSu" >More on the InputStream Class and Its Subclasses</A>
<LI><A HREF="#TheByteArrayInputStreamClass" >The ByteArrayInputStream Class</A>
<LI><A HREF="#TheFileInputStreamClass" >The FileInputStream Class</A>
<LI><A HREF="#TheSequenceInputStreamClass" >The SequenceInputStream Class</A>
<LI><A HREF="#TheStringBufferInputStreamClass" >The StringBufferInputStream Class</A>
</UL>
<LI><A HREF="#JavaOutputStreams" >Java Output Streams</A>
<UL>
<LI><A HREF="#TheOutputStreamClass" >The OutputStream Class</A>
<LI><A HREF="#MiscellaneousIOClasses" >Miscellaneous I/O Classes</A>
</UL>
<LI><A HREF="#ThejavautilPackage" >The java.util Package</A>
<UL>
<LI><A HREF="#TheBitsetClass" >The Bitset Class</A>
<LI><A HREF="#TheDateClass" >The Date Class</A>
<LI><A HREF="#TheDictionaryClass" >The Dictionary Class</A>
<LI><A HREF="#TheHashtableClass" >The Hashtable Class</A>
<LI><A HREF="#ThePropertiesClass" >The Properties Class</A>
<LI><A HREF="#TheRandomClass" >The Random Class</A>
<LI><A HREF="#TheVectorClass" >The Vector Class</A>
<LI><A HREF="#TheStackClass" >The Stack Class</A>
<LI><A HREF="#TheStringTokenizerClass" >The StringTokenizer Class</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter continues our adventure of exploring the Java packages.
Two packages are covered here: <TT><FONT FACE="Courier">java.io</FONT></TT>
and <TT><FONT FACE="Courier">java.util</FONT></TT>. The <TT><FONT FACE="Courier">java.io</FONT></TT>
package contains interfaces, classes, and methods that facilitate
input and output of data to applets and applications. The <TT><FONT FACE="Courier">java.util</FONT></TT>
package is a mixed bag of utilities useful in writing Java programs.
Its classes are used to manipulate dates, create hash tables,
and directly manipulate stacks of objects, among other things.
<H2><A NAME="IntroductiontothejavaioPackage"><FONT SIZE=5 COLOR=#Ff0000>Introduction
to the </FONT><TT><FONT SIZE=5 COLOR=#Ff0000 FACE="Courier">java.io</FONT></TT><FONT SIZE=5 COLOR=#Ff0000>
Package</FONT></A></H2>
<P>
The Java input and output package-<TT><FONT FACE="Courier">java.io-</FONT></TT>is
used to implement streams. Streams are covered in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>,
&quot;Tying It All Together: Threads, Exceptions, and More;&quot;
refer to that chapter if you have difficulty with some of the
examples or information in this chapter. Here I cover the classes
and methods that manipulate streams.
<P>
<I>Streams</I> are used to move groups of data from point A to
the Java application or from the Java application to point B.
At its simplest, transmitted data is in the form of a stream of
bytes without formatting or identification. It is up to the Java
application to reformat and reinterpret it in such a way that
the data makes sense to the application.
<P>
Data traditionally has been stored in files on a disk somewhere.
Moving data was a simple matter of opening a file, copying the
data to memory, copying the needed portions from memory, and moving
the data from memory to a new disk location under a new filename
on a system that controlled all the steps of the process.
<P>
That scenario is certainly not the case these days. Data can be
generated by users on a local network and loaded on a distributed
system. It can come from just about any system in the world over
the Internet; and from disk, tape, CD-ROM, and so on. The source
of the data may be running any number of operating systems, which
means that the data might be in a format foreign to the system
running the Java application. Therefore, Java must be able to
interpret data in many formats from many sources. It must be adaptable
enough to handle this data without requiring code changes if the
data stream origin changes. The classes and methods in <TT><FONT FACE="Courier">java.io</FONT></TT>
help make this happen.
<H2><A NAME="HowJavasIOSystemWorks"><FONT SIZE=5 COLOR=#Ff0000>How
Java's I/O System Works</FONT></A></H2>
<P>
Remember that the whole idea behind Java is to provide a non-platform-specific
application language. This includes the movement and interpretation
of data. The classes and methods in the <TT><FONT FACE="Courier">java.io</FONT></TT>
package allow great flexibility in sending and receiving data.
<P>
Java provides control over the flow of input streams using <TT><FONT FACE="Courier">mark</FONT></TT>
and <TT><FONT FACE="Courier">reset</FONT></TT> (discussed in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>).
However, not all forms of Java I/O allow the use of <TT><FONT FACE="Courier">mark</FONT></TT>
and <TT><FONT FACE="Courier">reset</FONT></TT>.
<P>
The following sections discuss the various ways to move data in
Java. Pick the one that best suits your needs, because each has
advantages and disadvantages.
<H2><A NAME="JavaInputStreams"><FONT SIZE=5 COLOR=#Ff0000>Java
Input Streams</FONT></A></H2>
<P>
<I>Input streams</I> are streams of data that arrive from a source
and are loaded into Java. Java doesn't care about the data's origins;
it only cares about the data being available to send to the Java
application. All the input stream classes throw the exception
<TT><FONT FACE="Courier">IOException</FONT></TT>. (Refer to the
section in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A> called &quot;Exceptions&quot;
for more information.)
<P>
All the input stream classes are based on the abstract class <TT><FONT FACE="Courier">InputStream</FONT></TT>.
The next section discusses the methods associated with that class.
<H3><A NAME="TheInputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">InputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">InputStream</FONT></TT> is the abstract
class that contains all the possible types of inputs to Java.
Its subclasses use most or all of its methods. These methods are
discussed in the &quot;Input Streams&quot; section of <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>,
but let's go over them again.
<H4>read</H4>
<P>
All of <TT><FONT FACE="Courier">InputStream</FONT></TT>'s subclasses
can read data from an input stream. These reads are based on <I>blocking</I>,
which allows the Java application to wait if the input stream
is not continuous.
<H4>skip</H4>
<P>
The <TT><FONT FACE="Courier">skip</FONT></TT> method is used to
bypass a fixed number of bytes of an input stream. This method
is available to all of <TT><FONT FACE="Courier">InputStream</FONT></TT>'s
subclasses.
<H4>close</H4>
<P>
The <TT><FONT FACE="Courier">close</FONT></TT><I> </I>method is
used to shut down an input stream that is no longer being used.
Files are closed automatically when the Java garbage collector
finalizes and closes them. However, it is important to manually
close the stream if the file is going to be opened again soon.
You can't know exactly when the garbage collector will finally
close the stream, and Java will not reopen an already open file.
<H4>available</H4>
<P>
The <TT><FONT FACE="Courier">available</FONT></TT> method is used
to determine whether the data is ready to be sent. Remember, the
program will block if the data is not ready but a <TT><FONT FACE="Courier">read</FONT></TT>
request has been sent. If you put the <TT><FONT FACE="Courier">read</FONT></TT>
request in a separate thread, it won't matter if the block occurs;
in that case it is not necessary to use <TT><FONT FACE="Courier">available</FONT></TT>.
Make sure, however, that this makes sense in the application.
Using separate threads is not advisable if the whole application
relies on the data to be sent.
<P>
The <TT><FONT FACE="Courier">available</FONT></TT> method is not
available for all subclasses of <TT><FONT FACE="Courier">InputStream</FONT></TT>.
<H4>mark, markSupported, and reset</H4>
<P>
The <TT><FONT FACE="Courier">mark</FONT></TT> method marks a point
in an input stream to return to later. The <TT><FONT FACE="Courier">markSupported</FONT></TT>
method makes sure that the type of input stream allows <TT><FONT FACE="Courier">mark</FONT></TT>.
The <TT><FONT FACE="Courier">reset</FONT></TT> method returns
to the point marked by <TT><FONT FACE="Courier">mark</FONT></TT>.
These methods are not supported in all the subclasses of <TT><FONT FACE="Courier">InputStream</FONT></TT>.
<H3><A NAME="MoreontheInputStreamClassandItsSu">More on the <TT><FONT SIZE=4 FACE="Courier">InputStream</FONT></TT><FONT SIZE=4>
Class and Its Subclasses</FONT></A></H3>
<P>
The subclasses of <TT><FONT FACE="Courier">InputStream</FONT></TT>
are <TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT>,
<TT><FONT FACE="Courier">FileInputStream</FONT></TT>, <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>,
<TT><FONT FACE="Courier">PipedInputStream</FONT></TT>, <TT><FONT FACE="Courier">SequenceInputStream</FONT></TT>,
and <TT><FONT FACE="Courier">StringBufferInputStream</FONT></TT>.
Each is discussed in detail in the following sections.
<H4>The <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">FilterInputStream</FONT></TT> has four
subclasses: <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>,
<TT><FONT FACE="Courier">DataInputStream</FONT></TT>, <TT><FONT FACE="Courier">LineNumberInputStream</FONT></TT>,
and <TT><FONT FACE="Courier">PushbackInputStream</FONT></TT>.
These subclasses work in a unique way with <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>:
They allow it<I> </I>to control the flow of a file to them. <TT><FONT FACE="Courier">FilterInputStream</FONT></TT><I>
</I>does nothing by itself.
<P>
Think of <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>
as providing the structure of the pipe for the flow of data while
its subclasses chop the data up into small, usable bits. Picture
<TT><FONT FACE="Courier">FilterInputStream</FONT></TT> as the
a pasta maker that squeezes out the dough while the subclass turns
it into spaghetti or fettucine or lasagna noodles. The data is
the dough. It is also possible to change the &quot;mold,&quot;
or subclass, midstream, just as you would change the form on the
pasta maker. However, you don't have to stop the machine while
changing the form; the data still flows through.
<P>
<TT><FONT FACE="Courier">FilterInputStream</FONT></TT>'s subclasses
are widely used in writing Java programs. Following is a discussion
of the subclasses. (Read the online documentation for a full list
of each subclass's capabilities.)
<H5>The <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">BufferedInputStream</FONT></TT> is a
subclass of <TT><FONT FACE="Courier">FilterInputStream</FONT></TT><I>.</I>
It implements all the methods defined in the superclass <TT><FONT FACE="Courier">InputStream</FONT></TT>.
<BR>
</BLOCKQUOTE>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">BufferedInputStream</FONT></TT> is the <I>only</I> class that uses <TT><FONT FACE="Courier">mark</FONT></TT> and <TT><FONT FACE="Courier">reset</FONT></TT> correctly.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<BLOCKQUOTE>
Another key attraction to using <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>
is that it creates a read<I> buffer</I>, which is an array of
bytes. This read buffer smooths out the stream of data so that
reading can be continuous, as opposed to waiting for the input
to reach the stream. The size of the buffer and the size of the
reads can be controlled through <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>'s
methods. Listing 12.1 is an example of <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>
and <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 12.1. An example of BufferedInputStream and BufferedOutputStream<FONT FACE="I Avant Garde BookOblique">.
<BR>
</FONT></B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This class implements
buffered file input/output streams by extending<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class BufferedInputStream.&nbsp;&nbsp;This
is not a complete implementation of all<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of FileInputStream (not enough
constructors, or getFd()).<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main example simply copies
the first 128 bytes of file one to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file two, then resets file
one to the beginning and proceeds to copy<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all of file one to file two.&nbsp;&nbsp;This
has no practical purpose, but does<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;demonstrate that a BufferedFileInputStream
class has been created that<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements mark and reset,
which FileInputStream does not support.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;source
file&gt; &lt;dest file&gt;<BR>
*/<BR>
<BR>
import java.io.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare buffered file input
stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedFileInputStream bfis;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare buffered file output
stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedFileOutputStream bfos;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare buffer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte buf[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int cnt;<BR>
<BR>
// create 1024 byte buffer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = new byte[1024];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create
buffered file input stream using first argument<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//on command
line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfis = new
BufferedFileInputStream(args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//create
buffered file output stream using second argument<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//on command
line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfos = new
BufferedFileOutputStream(args[1]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mark
beginning of file to be buffered for 128 bytes<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfis.mark(128);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// read
128 bytes from source file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfis.read(buf,0,128);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// write
buffered bytes to dest file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfos.write(buf,0,buf.length);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// reset
to beginning of file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfis.reset();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop
through source file reading 1024 bytes at a time<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (bfis.read(buf,0,
1024) != -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
write buffer to dest file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bfos.write(buf,
0, buf.length);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// close
source file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfis.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// close
source file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bfos.close();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// catch file not found errors
(do nothing)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// catch IO errors (do nothing)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (IOException e){}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare new class that extends buffered input stream<BR>
class&nbsp;&nbsp;BufferedFileInputStream extends BufferedInputStream
{<BR>
<BR>
// declare file input stream<BR>
&nbsp;&nbsp;&nbsp;FileInputStream f;<BR>
<BR>
// override buffered input stream constructor<BR>
&nbsp;&nbsp;&nbsp;public BufferedFileInputStream(String filename)
throws IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create buffered input stream
using file input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(new FileInputStream(filename));
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare new class that extends buffered output stream<BR>
class&nbsp;&nbsp;BufferedFileOutputStream extends BufferedOutputStream
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;// override buffered output stream<BR>
&nbsp;&nbsp;&nbsp;public BufferedFileOutputStream(String filename)
throws <BR>
&nbsp;&nbsp;&nbsp;IOException {&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create buffered output
stream using file output stream constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(new FileOutputStream(filename));
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H5>The <TT><FONT FACE="Courier">DataInputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DataInputStream</FONT></TT> is a subclass
of <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>. It
also implements the <TT><FONT FACE="Courier">DataInput</FONT></TT>
interface. Look at the following list of methods in <TT><FONT FACE="Courier">DataInputStream</FONT></TT>,
and the major use of the class becomes obvious (note that these
same methods are used by the class <TT><FONT FACE="Courier">RandomAccessFile</FONT></TT>):
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">readBoolean<BR>
readByte<BR>
readChar<BR>
readDouble<BR>
readFloat<BR>
readInt<BR>
readLine<BR>
readLong<BR>
readShort<BR>
readUTF<BR>
readUnsignedByte<BR>
readUnsignedShort</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
These methods are used to read primitive data types. Remember
primitive data types from <A HREF="ch6.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch6.htm" >Chapter 6</A>, &quot;Fundamentals
of the Java Language&quot;? This class interprets primitive data
types across platforms and makes them accessible to Java.
</BLOCKQUOTE>
<H5>The <TT><FONT FACE="Courier">LineNumberInputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LineNumberInputStream</FONT></TT> is
a subclass of <TT><FONT FACE="Courier">FilterInputStream</FONT></TT>.
This class keeps track of line numbers, which could be used to
mark and reset data streams. <TT><FONT FACE="Courier">LineNumberInputStream</FONT></TT>
also can be used to nest the handling of input streams so that
it is possible to simultaneously read the stream for other purposes
and keep track of line numbers.
</BLOCKQUOTE>
<H5>The <TT><FONT FACE="Courier">PushbackInputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PushbackInputStream</FONT></TT> is a
subclass of <TT><FONT FACE="Courier">FilterInputStream</FONT></TT><I>.</I>
It creates a one-byte input buffer that allows the input stream
to retreat one byte after it has been read. This makes it possible
to test the next byte before taking action. Listing 12.2 is an
example of <TT><FONT FACE="Courier">PushbackInputStream</FONT></TT>.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 12.2. An example of </B><TT><B><FONT FACE="Courier">PushbackInputStream</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This class implements
a word search program. A word is defined as a<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;character string.&nbsp;&nbsp;It
considered a word instead of a substring if the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word is followed by a space.&nbsp;&nbsp;The
algorithm works its way through the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input stream.&nbsp;&nbsp;If
it actually finds a word, it pushes the space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that delimited the word back
on the stream so that it can be processed<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if needed by other algorithms.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main example accepts a
string to search for and a filename to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search in as command line
arguments.&nbsp;&nbsp;It will print &quot;Word found&quot; if
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the word is successfully found,
and &quot;Word not found&quot; if it does not.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;string
to search for&gt; &lt;file to search&gt;<BR>
*/<BR>
<BR>
import java.io.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare FindWord object
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FindWord f;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create
FindWord object by passing it a FileInputStream object.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//File opened
in second argument on command line.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = new
FindWord(new FileInputStream(args[1]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// find
word specified as first argument on command line.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (f.find(args[0]))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print out found message if word is found<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Word
found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print out not found message if word not found<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Word
not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle file not found exceptions
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(FileNotFoundException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
File not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;&nbsp;file
= &quot; + args[1]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare class FindWord<BR>
class&nbsp;&nbsp;FindWord {<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare PushbackInputStreamObject<BR>
&nbsp;&nbsp;&nbsp;PushbackInputStream pbs;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare FindWord constructor<BR>
&nbsp;&nbsp;&nbsp;public FindWord(InputStream in) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create pushback stream
using passed in input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbs = new PushbackInputStream(in);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare method to find word in stream<BR>
&nbsp;&nbsp;&nbsp;public boolean find (String word) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare buffer to be used
in stream reads<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte buf[];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare booleans for word
found and end-of-file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean found, EOF;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create one byte array needed
by stream read<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf = new byte[1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initialize word found variable
to false<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initialize end-of-file
variable to false<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EOF = false;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare string buffer so
a space can be appended to search word<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sbWord;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create string buffer initialized
to search word followed by a space<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbWord = new StringBuffer(word
+ &quot; &quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;// label for labeled continue inside loop<BR>
&nbsp;&nbsp;&nbsp;startOver:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop waiting for word found
or end of file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((! found) &amp;&amp;
(! EOF)) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop
for matching search word to chars in input stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;
i &lt; sbWord.length(); i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
read char from stream checking for EOF<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(pbs.read(buf,0,1) == -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
set EOF boolean if EOF reached<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EOF
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
compare stream char to search word char<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
((char)buf[0] != sbWord.charAt(i)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
if different continue in OUTER while loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
startOver;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
handle IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException
e){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
exit application if IO error occurred<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(3);}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// word
found if this point reached, push space back on stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {pbs.unread(buf[0]);}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle
IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException
e){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
exit application if IO error occurred<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(4);}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return
true since word found<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(true);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return false since word
not found<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheByteArrayInputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">ByteArrayInputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">The ByteArrayInputStream</FONT></TT>
class extends the <TT><FONT FACE="Courier">InputStream</FONT></TT>
class. This class is used to create an input stream from a buffer.
The input stream is accessed in the number of bytes set by the
programmer. The flow of data to the input stream is controlled
by three variables:
<UL>
<LI><TT><FONT FACE="Courier">buf</FONT></TT>-The buffer where
data is stored
<LI><TT><FONT FACE="Courier">Count</FONT></TT>-The number of bytes
to use in the buffer
<LI><TT><FONT FACE="Courier">Pos</FONT></TT>-The current position
in the buffer
</UL>
<P>
<TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT> allows
use of the <TT><FONT FACE="Courier">reset</FONT></TT> method,
which<I> </I>resets the input stream back to the beginning. There
is no <TT><FONT FACE="Courier">mark</FONT></TT> method to mark
a specific place in the stream.
<H3><A NAME="TheFileInputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">FileInputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">The FileInputStream</FONT></TT> class
extends the <TT><FONT FACE="Courier">InputStream</FONT></TT> class.
This class allows Java to read files. This will work only with
sequential files, not with hash tables or indexed files. The file
itself must be accessible to Java.
<P>
Be sure to explicitly close the file input stream if there are
to be subsequent accesses to it after the end of file has been
reached. <TT><FONT FACE="Courier">mark</FONT></TT> and <TT><FONT FACE="Courier">reset</FONT></TT>
are not available to <TT><FONT FACE="Courier">FileInputStream</FONT></TT>.
The only way to return to a position is to skip to it and then
read to find a desired piece of data. There is no way to know
exact positions in the file directly with <TT><FONT FACE="Courier">FileInputStream</FONT></TT>.
<P>
Refer to the section in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A> titled
&quot;Input Streams&quot; for an example of the use of <TT><FONT FACE="Courier">FileInputStream</FONT></TT>.
<H3><A NAME="TheSequenceInputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">SequenceInputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">SequenceInputStream</FONT></TT> allows
multiple files to be read in sequence and converted into a single
stream. The first input is read through to the end of file, then
the next file is read, and so on. The output is a byte array.
The only methods available are <TT><FONT FACE="Courier">read</FONT></TT>
and <TT><FONT FACE="Courier">close</FONT></TT>.
<P>
One reason to use <TT><FONT FACE="Courier">SequenceInputStream</FONT></TT>
is to receive multiple inputs, create one input stream, and pass
the stream off to another class that has more data-manipulation
methods available.
<H3><A NAME="TheStringBufferInputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">StringBufferInputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">StringBufferInputStream</FONT></TT> is
used to create an input stream from a buffer. The input stream
is an array of string characters. The flow of data to the input
stream is controlled by three variables:
<UL>
<LI><TT><FONT FACE="Courier">buf</FONT></TT>-The buffer where
data is stored
<LI><TT><FONT FACE="Courier">Count</FONT></TT>-The number of characters
to use in the buffer
<LI><TT><FONT FACE="Courier">Pos</FONT></TT>-The current position
in the buffer
</UL>
<P>
This is similar to <TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT>;
the only difference is that <TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT>
inputs the stream as an array of bytes, whereas <TT><FONT FACE="Courier">StringBufferInputStream</FONT></TT>
creates the input stream as an array of string characters. With
<TT><FONT FACE="Courier">StringBufferInputStream</FONT></TT>,
you can use the <TT><FONT FACE="Courier">reset</FONT></TT> method,
which resets the input stream to the beginning. There is no <TT><FONT FACE="Courier">mark</FONT></TT>
method to mark a specific place in the stream.
<H2><A NAME="JavaOutputStreams"><FONT SIZE=5 COLOR=#Ff0000>Java
Output Streams</FONT></A></H2>
<P>
Once again, refer to <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A> for a detailed
discussion of output streams. I will do only a quick review here.
This section discusses the <TT><FONT FACE="Courier">java.io</FONT></TT>
package and its output stream classes.
<P>
<I>Output streams</I> are data streams generated by a Java application
or applet for use elsewhere. There are several ways to format
the data for output: It can be piped, buffered, printed to a screen,
stored in an array of bytes, or output to a file. Output stream
classes perform the output duty.
<P>
All the output stream classes are based on the abstract class
<TT><FONT FACE="Courier">OutputStream</FONT></TT>. The next section
discusses the methods associated with <TT><FONT FACE="Courier">OutputStream</FONT></TT>.
<H3><A NAME="TheOutputStreamClass">The <TT><FONT SIZE=4 FACE="Courier">OutputStream</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">OutputStream</FONT></TT> is the abstract
class that contains all the possibilities of output from Java.
Its subclasses are <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>,
<TT><FONT FACE="Courier">ByteArrayOutputStream</FONT></TT>, <TT><FONT FACE="Courier">DataOutputStream</FONT></TT>,
<TT><FONT FACE="Courier">FileOutputStream</FONT></TT>, <TT><FONT FACE="Courier">FilterOutputStream</FONT></TT>,
<TT><FONT FACE="Courier">PipedOutputStream</FONT></TT>, and <TT><FONT FACE="Courier">PrintStream</FONT></TT>.
<P>
<TT><FONT FACE="Courier">OutputStream</FONT></TT>'s subclasses
use most or all of its methods. These methods are discussed in
<A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>, but a quick review never hurts.
<H5><TT><FONT FACE="Courier">write</FONT></TT></H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">write</FONT></TT> method is used
to write data to a stream. It varies for each class in its output.
All <TT><FONT FACE="Courier">write</FONT></TT> methods are the
same in that they block, or wait, for the receiving device to
catch up. All <TT><FONT FACE="Courier">write</FONT></TT> methods
also throw the exception <TT><FONT FACE="Courier">IOException</FONT></TT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
See the section titled &quot;Input Streams&quot; in <A HREF="ch8.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch8.htm" >Chapter 8</A>
for an example of <TT><FONT FACE="Courier">write</FONT></TT>.
</BLOCKQUOTE>
<H5><TT><FONT FACE="Courier">flush</FONT></TT></H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">flush</FONT></TT> method is used
to force any data buffered for the output stream to be written
to the output device. This is the only way to override a block.
This also may be the only way to write data if the receiving device
requires it.
</BLOCKQUOTE>
<H5><TT><FONT FACE="Courier">close</FONT></TT></H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">close</FONT></TT> method closes an
output stream. It is identical in logic to the <TT><FONT FACE="Courier">close</FONT></TT>
used for input streams. The Java garbage collector schedules a
cleanup to the output streams when an applet or application closes.
Be sure to manually call <TT><FONT FACE="Courier">close</FONT></TT><I>
</I>if the application can't wait for the garbage collector.
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">FilterOutputStream</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">FilterOutputStream</FONT></TT> has three
subclasses: <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>,
<TT><FONT FACE="Courier">DataOutputStream</FONT></TT>, and <TT><FONT FACE="Courier">PrintStream</FONT></TT>.
These subclasses work in a unique way with <TT><FONT FACE="Courier">FilterOutputStream</FONT></TT>;
they allow it<I> </I>to control the flow of a file to them. <TT><FONT FACE="Courier">FilterOutputStream</FONT></TT><I>
</I>does nothing by itself. (This is the output equivalent to
<TT><FONT FACE="Courier">FilterInputStream</FONT></TT>.)
<P>
Following is a discussion of the subclasses. Read the online documentation
for a full list of each subclass's capabilities.
<H5>The <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<P>
<TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT> implements
all the methods defined in superclass <TT><FONT FACE="Courier">OutputStream</FONT></TT>.
<TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT> uses
<TT><FONT FACE="Courier">flush</FONT></TT> and can create a nested
stream to allow other output streams to flush.
<P>
Another key attraction to using <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>
is that it creates a write buffer in the form of an array of bytes.
This write buffer smooths out the stream of data so that writing
can be continuous, as opposed to waiting for the output to reach
the stream. The size of the buffer and the size of the writes
can be controlled through <TT><FONT FACE="Courier">BufferedOutputStream</FONT></TT>'s
methods.
<H5>The <TT><FONT FACE="Courier">DataOutputStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DataOutputStream</FONT></TT> also implements
the <TT><FONT FACE="Courier">DataOutput</FONT></TT><I> </I>interface.
It is the inverse of <TT><FONT FACE="Courier">DataInputStream</FONT></TT>
and is used to write primitive data types. Following is a list
of associated methods:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">writeBoolean<BR>
writeByte<BR>
writeChar<BR>
writeDouble<BR>
writeFloat<BR>
writeInt<BR>
writeLine<BR>
writeLong<BR>
writeShort<BR>
writeUTF<BR>
writeUnsignedByte<BR>
writeUnsignedShort</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DataOutputStream</FONT></TT> is used
with <TT><FONT FACE="Courier">BufferedInputStream</FONT></TT>
to pull and push primitive data types across platforms.
</BLOCKQUOTE>
<H5>The <TT><FONT FACE="Courier">PrintStream</FONT></TT><FONT SIZE=2>
Class</FONT></H5>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PrintStream</FONT></TT> is used to write
formatted data to the user's screen. <TT><FONT FACE="Courier">PrintStream</FONT></TT>
is the actual class used to perform the printing in methods, like
this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">System.out.print()<BR>
System.out.println()</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
It is possible to do autoflushing with <TT><FONT FACE="Courier">PrintStream</FONT></TT><I>.</I>
The two constructors to use with <TT><FONT FACE="Courier">PrintStream</FONT></TT>
are
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PrintStream(OutputStream)-Creates a new
PrintStream<BR>
PrintStream(OutputStream, boolean)-Creates a new PrintStream,
with autoflushing</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PrintStream</FONT></TT> formats primitive
data types for display to the screen. The following methods are
used:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print(Object)<BR>
print(String)<BR>
print(char[])<BR>
print(char)<BR>
print(int)<BR>
print(long)<BR>
print(float)<BR>
print(double)<BR>
print(boolean)<BR>
println()<BR>
println(Object)<BR>
println(String)<BR>
println(char[])<BR>
println(char)<BR>
println(int)<BR>
println(long)<BR>
println(float)<BR>
println(double)<BR>
println(boolean)</FONT></TT>
</BLOCKQUOTE>
<P>
See Listing 12.3 for an example of the use of <TT><FONT FACE="Courier">PrintStream</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 12.3. An example of the use of </B><TT><B><FONT FACE="Courier">PrintStream</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This class implements
a generic write class that can write any arbitrary<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object type to a file.&nbsp;&nbsp;The
constructor is used to open the file.&nbsp;&nbsp;The<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resulting output stream is
used as the constructor for the PrintStream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class.&nbsp;&nbsp;PrintStream
is used because it can write arbitrary objects.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintStreams implicitly use
&quot;toString&quot; methods within objects to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convert objects to strings.
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An arbitrary class called
PhoneInfo is created simply for the purpose of<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;demonstrating PrintStream's
ability to write any type of object.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main example simply populates
a PhoneInfo array and then uses the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteObjToFile class to actually
write the information to the file.&nbsp;&nbsp;The<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename to write to is specified
on the command line.<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntax:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &lt;dest
file&gt;<BR>
*/<BR>
<BR>
import java.io.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare WriteObjToFile
object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteObjToFile w;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create info to populate
phone info database<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[] s =&nbsp;&nbsp;{&quot;Roy
Rogers&quot;, &quot;(111) 111-1111&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Jesse
James&quot;, &quot;(222) 222-2222&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Wyatt
Earp&quot;, &quot;(333) 333-3333&quot;};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare PhoneInfo array
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhoneInfo[] p;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create PhoneInfo array
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = new PhoneInfo[s.length/2];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop through PhoneInfo
array creating phoneinfo objects<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;s.length; i+=2)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[i/2] =
new PhoneInfo(s[i],s[i+1]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create
WriteObjToFile object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w = new
WriteObjToFile(args[0]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop
through phone database passing objects to WriteObjToFile<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0;
i&lt;p.length; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.write(p[i]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// catch IO exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
IO Exception&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare PhoneInfo class<BR>
class PhoneInfo {<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare information variables<BR>
&nbsp;&nbsp;&nbsp;String name, phoneNum;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare PhoneInfo constructor<BR>
&nbsp;&nbsp;&nbsp;public PhoneInfo(String name, String phoneNum)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initialize name based on
constructor argument<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = new String(name);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// initialize phone number
based on constructor argument<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.phoneNum = new String(phoneNum);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare toString method for returning string
representation of instance<BR>
&nbsp;&nbsp;&nbsp;public String toString() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(&quot;Name: &quot;
+ name + &quot;\nPhone Number: &quot; + phoneNum);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare WriteObjToFile class<BR>
class&nbsp;&nbsp;WriteObjToFile {<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare PrintStream object<BR>
&nbsp;&nbsp;&nbsp;PrintStream ps;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare constructor<BR>
&nbsp;&nbsp;&nbsp;public WriteObjToFile(String filename) throws
IOException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create
printstream using FileOutPutStream as the stream to write to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps = new
PrintStream(new FileOutputStream(filename));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle file not found errors
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (FileNotFoundException
e) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
File not found&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;&nbsp;&nbsp;&nbsp;File
= &quot; + filename);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare method to write arbitrary objects
<BR>
&nbsp;&nbsp;&nbsp;public void write (Object o) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// write object to output
stream<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps.println(o);<BR>
<BR>
&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H4>The <TT><FONT FACE="Courier">ByteArrayOutputStream</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">ByteArrayOutputStream</FONT></TT>, the
counterpart of <TT><FONT FACE="Courier">ByteArrayInputStream</FONT></TT>,
is used to create an input stream from a buffer-that is, it pushes
Java output into a buffer. The buffer grows as needed.
<P>
The flow of data to the output stream is controlled by two variables:
<UL>
<LI><TT><FONT FACE="Courier">buf</FONT></TT>-The buffer where
data is stored
<LI><TT><FONT FACE="Courier">Count</FONT></TT>-The number of bytes
in the buffer
</UL>
<P>
With <TT><FONT FACE="Courier">ByteArrayOutputStream</FONT></TT>,
you can use the <TT><FONT FACE="Courier">reset</FONT></TT> method,
which resets the output stream buffer so that the space of the
buffer is not released and can be reused. There is no <TT><FONT FACE="Courier">mark</FONT></TT>
method to mark a specific place in the stream.
<H4>The <TT><FONT FACE="Courier">FileOutputStream</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">FileOutputStream</FONT></TT>, the counterpart
to <TT><FONT FACE="Courier">FileInputStream</FONT></TT>, enables
Java to write to files. The file and directory must be accessible
to Java, which is a security issue.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Warning</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Be sure to explicitly close the file output stream if there are to be subsequent accesses to it after the end of file has been reached. Otherwise, the file will not be properly terminated with an end of file marker and you will get errors.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The only methods available to <TT><FONT FACE="Courier">FileOutputStream</FONT></TT>
are the following:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">close()</FONT></TT>-Closes the stream
<BR>
<TT><FONT FACE="Courier">finalize()</FONT></TT>-Closes the stream
when garbage is collected<BR>
<TT><FONT FACE="Courier">getFD()</FONT></TT>-Returns the file
descriptor associated with this stream<BR>
<TT><FONT FACE="Courier">write(int)-</FONT></TT>Writes a byte
of data<BR>
<TT><FONT FACE="Courier">write(byte[])</FONT></TT>-Writes an array
of bytes<BR>
<TT><FONT FACE="Courier">write(byte[], int, int)</FONT></TT>-Writes
a subarray of bytes
</BLOCKQUOTE>
<H4>The <TT><FONT FACE="Courier">PipedOutputStream</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">PipedOutputStream</FONT></TT> supports
moving data to and from threads that are piped together using
the <TT><FONT FACE="Courier">PipeInputStream</FONT></TT>. Because
<TT><FONT FACE="Courier">PipedOutputStream</FONT></TT> is connected
to the <TT><FONT FACE="Courier">PipeInputStream</FONT></TT>, the
two must work together.
<P>
The methods associated with these classes are
<BLOCKQUOTE>
<TT><FONT FACE="Courier">close()</FONT></TT>-Closes the stream
<BR>
<TT><FONT FACE="Courier">connect(PipedInputStream)</FONT></TT>-Connects
this output stream to a receiver<BR>
<TT><FONT FACE="Courier">write(int)</FONT></TT>-Writes a byte
<BR>
<TT><FONT FACE="Courier">write(byte[], int, int)</FONT></TT>-Writes
a subarray of bytes
</BLOCKQUOTE>
<H3><A NAME="MiscellaneousIOClasses">Miscellaneous I/O Classes</A>
</H3>
<P>
The <TT><FONT FACE="Courier">java.io</FONT></TT> package includes
two miscellaneous I/O classes for dealing with files: <TT><FONT FACE="Courier">File</FONT></TT>
and <TT><FONT FACE="Courier">RandomAccessFile</FONT></TT>.
<H4>The <TT><FONT FACE="Courier">File</FONT></TT> Class</H4>
<P>
The <TT><FONT FACE="Courier">File</FONT></TT> class is used to
represent a filename on a host system. It cannot read or write
to the file, but it can get information about the file such as
its name, path, and so on. It works as an abstract way of dealing
with a platform-specific file.
<H4>The <TT><FONT FACE="Courier">RandomAccessFile</FONT></TT>
Class</H4>
<P>
<TT><FONT FACE="Courier">RandomAccessFile</FONT></TT> implements
both <TT><FONT FACE="Courier">DataInput</FONT></TT> and <TT><FONT FACE="Courier">DataOutput</FONT></TT>
interfaces. It combines both input and output access to a file
within the security confines of Java. The numerous methods associated
with it read and write primitive data types, close the file, and
locate the file. <TT><FONT FACE="Courier">RandomAccessFile</FONT></TT>
also allows <TT><FONT FACE="Courier">skip</FONT></TT>.
<H2><A NAME="ThejavautilPackage"><FONT SIZE=5 COLOR=#Ff0000>The
</FONT><TT><FONT SIZE=5 COLOR=#Ff0000 FACE="Courier">java.util</FONT></TT><FONT SIZE=5 COLOR=#Ff0000>
Package</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">java.util</FONT></TT> package is
sort of a catch-all for handy utilities. It contains the following
classes:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">BitSet<BR>
Date<BR>
Dictionary<BR>
Hashtable<BR>
Observable<BR>
Properties<BR>
Random<BR>
Stack<BR>
StringTokenizer<BR>
Vector</FONT></TT>
</BLOCKQUOTE>
<P>
As you can see, this is certainly a mixed bag of classes. Read
on for a description of each one. See the online documentation
for details on all the methods associated with each class.
<H3><A NAME="TheBitsetClass">The <TT><FONT SIZE=4 FACE="Courier">Bitset</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">Bitset</FONT></TT> class creates
a set of bits that can grow as needed. It has methods that can
manipulate the bits in the set. Listing 12.4 is an example of
how to use <TT><FONT FACE="Courier">Bitset</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 12.4. An example using </B><TT><B><FONT FACE="Courier">Bitset</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;This class does 7 bit even parity
generation and checking.<BR>
*/<BR>
import java.util.*;<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parity p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare parity object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = new Parity((byte)100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// create parity object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.genParity();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// generate parity bit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (p.chkParity())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
check for parity error<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;no
parity error&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;parity
error&quot;);<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class&nbsp;&nbsp;Parity {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare class parity<BR>
<BR>
&nbsp;&nbsp;&nbsp;BitSet b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare bitset object<BR>
<BR>
&nbsp;&nbsp;&nbsp;public Parity(byte data) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare parity constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = new BitSet(8);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
create new bitset object length 8<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;7; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
copy input data bits to bitset<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((1
&lt;&lt; i) &amp; data) == 1) { // test if data bit is 1<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.set(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
set corresponding bitset bit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public void genParity() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// method to generate parity bit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i, cnt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;7; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// loop through bitset counting data bits<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.get(i))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
if ((cnt % 2) == 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// test if even or odd number data bits set<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.clear(7);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// even, clear parity bit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.set(7);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
odd, set parity bit<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;public boolean chkParity() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
method to check for parity errors<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i, cnt, parityBit;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;7; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// loop through bitset counting data bits<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.get(i))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
increment count of set data bits<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.get(7))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get setting of parity bit<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parityBit
= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
parity bit set<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parityBit
= 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
parity bit not set<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((cnt %2) ^ parityBit)
== 0) // check if parity bit set correctly<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// no parity error detected<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// parity error detected<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheDateClass">The <TT><FONT SIZE=4 FACE="Courier">Date</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Date</FONT></TT> provides methods for
examining and manipulating date and time. Time in Java is measured
in milliseconds since January 1, 1970. Java attempts to handle
time from the system with which it is interacting. UTC is Coordinated
Universal Time, which seems to be the worldwide standard.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Date</FONT></TT> class does not work as documented in the Java API. Although you should be able to work with dates since 1900, dates before January 1, 1970 are generally not usable.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
See Table 12.1 for a list of methods to see the full scope of
this class.<BR>
<P>
<CENTER><B>Table 12.1. Methods available for the </B><TT><B><FONT FACE="Courier">Date</FONT></B></TT><B>
class.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><CENTER><I>Method</I></CENTER></TD><TD WIDTH=355><CENTER><I>Purpose</I></CENTER>
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">UTC(int, int, int, int, int, int)</FONT></TT>
</TD><TD WIDTH=355>Calculates a UTC value from YMDHMS</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">after(Date)</FONT></TT>
</TD><TD WIDTH=355>Checks whether this date comes after the specified date
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">before(Date)</FONT></TT>
</TD><TD WIDTH=355>Checks whether this date comes before the specified date
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">equals(Object)</FONT></TT>
</TD><TD WIDTH=355>Compares this object against the specified object
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getDate()</FONT></TT>
</TD><TD WIDTH=355>Returns the day of the month</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getDay()</FONT></TT>
</TD><TD WIDTH=355>Returns the day of the week</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getHours()</FONT></TT>
</TD><TD WIDTH=355>Returns the hour</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getMinutes()</FONT></TT>
</TD><TD WIDTH=355>Returns the minute</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getMonth()</FONT></TT>
</TD><TD WIDTH=355>Returns the month</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getSeconds()</FONT></TT>
</TD><TD WIDTH=355>Returns the second</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getTime()</FONT></TT>
</TD><TD WIDTH=355>Returns the time in milliseconds since the epoch
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getTimezoneOffset()</FONT></TT>
</TD><TD WIDTH=355>Returns the time zone offset in minutes for the current locale that is appropriate for this time
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">getYear()</FONT></TT>
</TD><TD WIDTH=355>Returns the year after 1900</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">hashCode()</FONT></TT>
</TD><TD WIDTH=355>Computes a number that is used when storing objects in hash tables.
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">parse(String)</FONT></TT>
</TD><TD WIDTH=355>Given a string representing a time, parses it and returns the time value
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setDate(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the date</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setHours(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the hours</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setMinutes(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the minutes</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setMonth(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the month</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setSeconds(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the seconds</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setTime(long)</FONT></TT>
</TD><TD WIDTH=355>Sets the time</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">setYear(int)</FONT></TT>
</TD><TD WIDTH=355>Sets the year</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">toGMTString()</FONT></TT>
</TD><TD WIDTH=355>Converts a date to a <TT><FONT FACE="Courier">String</FONT></TT> object using the Internet GMT conventions
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">toLocaleString()</FONT></TT>
</TD><TD WIDTH=355>Converts a date to a <TT><FONT FACE="Courier">String</FONT></TT> object, using the locale conventions
</TD></TR>
<TR><TD WIDTH=235><TT><FONT FACE="Courier">toString()</FONT></TT>
</TD><TD WIDTH=355>Converts a date to a <TT><FONT FACE="Courier">String</FONT></TT> object using the UNIX time conventions
</TD></TR>
</TABLE></CENTER>
<P>
<P>
It is important to remember that months start with 0, which is
January, and end with 11, which is December. The days of the week
also start with 0, which is Sunday, and go through 6, which is
Saturday. Dates of the month are normal.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD WIDTH=590>
<BLOCKQUOTE>
Dates that are not within the normal range parameters are interpreted through consecutive iterations of the date range. For example, 32 January is recognized as 1 February.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 12.5 is an example of the use of the <TT><FONT FACE="Courier">Date</FONT></TT>
class<I>.</I>
<HR>
<BLOCKQUOTE>
<B>Listing 12.5. Using </B><TT><B><FONT FACE="Courier">Date</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java's time handling
utilities in java.util do not seem to handle<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dates before 1970 even though
it is documented as 1900.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Usage: date specified on the
command line as first argument:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMain &quot;18
Apr 1972&quot;<BR>
*/<BR>
<BR>
import java.util.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
BDay b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare birthday object;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = new BDay(args[0]);&nbsp;&nbsp;&nbsp;&nbsp;
// create birthday object initialized<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
to first date specified on command line<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.printBDayInfo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
print out resulting birthday information<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class&nbsp;&nbsp;BDay {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare new class birthday<BR>
<BR>
&nbsp;&nbsp;&nbsp;String sign;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare string object to hold Astrological sign<BR>
&nbsp;&nbsp;&nbsp;Date d;<BR>
// declare date object to hold date of birth<BR>
<BR>
&nbsp;&nbsp;&nbsp;public BDay(String date) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare constructor for this class<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// declare date object used for comparisons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int year;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
declare int to hold year of birth<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = new Date(date);<BR>
// create new date object initialized to birthday<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year = d.getYear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
get year from birth date<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// loop finding Astrological sign<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;20 Jan &quot; + year);<BR>
// create comparison date of end of capricorn period<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
// check if birth date came before capricorn<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Capricorn&quot;);&nbsp;&nbsp;&nbsp;&nbsp; //
if so, set sign to capricorn<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;//
break out of while loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;19 Feb &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for aquarius<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Aquarius&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;21 Mar &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for pisces<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Pisces&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;20 Apr &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for aries<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Aries&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;21 May &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for taurus<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Taurus&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;21 Jun &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for gemini<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Gemini&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;23 Jul &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for cancer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Cancer&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;23 Aug &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for leo<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Leo&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;23 Sep&quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for virgo<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Virgo&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;23 Oct &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for libra<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Libra&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;22 Nov &quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for scorpio<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Scorpio&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;22 Dec&quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
repeat above for sagittarius<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Sagittarius&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new
Date(&quot;31 Dec&quot; + year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
catch end case for capricorn<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (d.before(c))
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign
= new String(&quot;Capricorn&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<BR>
// declare method for printing birthdate information<BR>
&nbsp;&nbsp;&nbsp;public void printBDayInfo() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date t,c;<BR>
// declare date objects for todays date and for comparisons<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = new Date();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
obtain todays date<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.setHours(0);<BR>
// set hours of todays date to zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.setMinutes(0);<BR>
// set minutes of todays date to zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.setSeconds(0);<BR>
// set seconds of todays date to zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new Date(t.getYear(),
(d.getMonth()-1), d.getDate());<BR>
// create date object for this years birthday<BR>
System.out.println(&quot;You were born on: &quot; + (d.getMonth()+1)
+ &quot;/&quot; + <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.getDate() + &quot;/&quot;
+ d.getYear());&nbsp;&nbsp;&nbsp;&nbsp; // print out birth date
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Your
sign is:&nbsp;&nbsp;&nbsp;&nbsp; &quot; + sign);<BR>
// print out Astrological sign<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c.before(t))<BR>
// check if birthday already occurred this year<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Your
birthday has already occurred this year&quot;);<BR>
// print out birthday already occurred<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c.after(t))
<BR>
// check if birthday is yet to come this year<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Your
birthday has yet to occur this year&quot;);<BR>
// print out birthday is yet to come<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;TODAY
IS YOUR BIRTHDAY!&quot;);<BR>
// if neither before today or after today, it must be today<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
As you can see, there are numerous ways to use <TT><FONT FACE="Courier">Date</FONT></TT>'s
methods to manipulate and examine dates.
<H3><A NAME="TheDictionaryClass">The <TT><FONT SIZE=4 FACE="Courier">Dictionary</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Dictionary</FONT></TT> is an abstract
class. Its only current subclass is <TT><FONT FACE="Courier">Hashtable</FONT></TT>.
<TT><FONT FACE="Courier">Dictionary</FONT></TT> is used to create
a way of organizing objects. (See the following &quot;<TT><FONT FACE="Courier">Hashtable</FONT></TT>&quot;
section for the implementation of <TT><FONT FACE="Courier">Dictionary</FONT></TT>.)
<P>
The idea is to access objects nonsequentially. There are keys
to identify and access objects. Think of <TT><FONT FACE="Courier">Dictionary</FONT></TT>
as storing objects in a structure similar to an indexed file.
<H3><A NAME="TheHashtableClass">The <TT><FONT SIZE=4 FACE="Courier">Hashtable</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Hashtable</FONT></TT> extends <TT><FONT FACE="Courier">Dictionary</FONT></TT>
and is used to map keys to values. The methods associated with
<TT><FONT FACE="Courier">Hashtable</FONT></TT> enable the placing,
locating, and retrieving of objects that are used as keys. The
<TT><FONT FACE="Courier">Properties</FONT></TT> class extends
<TT><FONT FACE="Courier">Hashtable</FONT></TT>.
<H3><A NAME="ThePropertiesClass">The <TT><FONT SIZE=4 FACE="Courier">Properties</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Properties</FONT></TT> is a class that
loads an input stream into a hash table. It also allows saves
and gets from the hash table.
<H3><A NAME="TheRandomClass">The <TT><FONT SIZE=4 FACE="Courier">Random</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Random</FONT></TT> contains methods that
create pseudo-random numbers. These numbers can be either <TT><FONT FACE="Courier">Gaussian</FONT></TT>,
<TT><FONT FACE="Courier">Double</FONT></TT>, <TT><FONT FACE="Courier">Float</FONT></TT>,
<TT><FONT FACE="Courier">Int</FONT></TT>, or <TT><FONT FACE="Courier">Long</FONT></TT>.
The seed, or starting point, can be reset anytime using the appropriate
method.
<H3><A NAME="TheVectorClass">The <TT><FONT SIZE=4 FACE="Courier">Vector</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Vector</FONT></TT> is the abstract parent
class for <TT><FONT FACE="Courier">Stack</FONT></TT>. You will
use the vector class to implement a growable array of objects.
<H3><A NAME="TheStackClass">The <TT><FONT SIZE=4 FACE="Courier">Stack</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
<TT><FONT FACE="Courier">Stack</FONT></TT> extends the <TT><FONT FACE="Courier">Vector</FONT></TT>
class. It creates a last in, first out (LIFO) stack of objects.
See Listing 12.6 for an example using <TT><FONT FACE="Courier">Stack</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 12.6. An example using </B><TT><B><FONT FACE="Courier">Stack</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/* Notes:<BR>
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Either java or
NT java will not accept &quot;-&quot; as a command line argument.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The user must specify &quot;--&quot;
to get the program to simply see &quot;-&quot;.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This program works by specifying
an RPN string on the command line.<BR>
*/<BR>
<BR>
import java.util.*;<BR>
<BR>
public class MyMain {<BR>
<BR>
&nbsp;&nbsp;&nbsp;public static void main (String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare RPN calculator
object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RPncalculator c;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create RPN calculator passing
command line arguments<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = new RPncalculator(args);
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
// declare new RPN calculator class<BR>
class&nbsp;&nbsp;RPncalculator {<BR>
<BR>
&nbsp;&nbsp;&nbsp;// declare Stack object<BR>
&nbsp;&nbsp;&nbsp;Stack s;<BR>
&nbsp;&nbsp;&nbsp;// declare generic object<BR>
&nbsp;&nbsp;&nbsp;Object o;<BR>
<BR>
&nbsp;&nbsp;&nbsp;// RPN Calculator constructor which also solves
equation string passed to it<BR>
&nbsp;&nbsp;&nbsp;public RPncalculator(String args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i,j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] num;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// declare object to hold
current arithmetic operator<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Character operator;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create new stack<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = new Stack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// create two integer array
to hold operands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = new int[2];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// loop through equation strings
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i &lt; args.length;
i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle
number format exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
try converting string to number and push on stack if successful
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(args[i]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// string
is not a number, must be an operator<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(java.lang.NumberFormatException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
convert string operator to character<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operator
= new Character(args[i].charAt(0));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
loop through operands operator will be used with<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(j=0; j&lt;2; j++) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
not enough operands on stack, generate error<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(s.empty()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
stack is empty&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
extract operand from stack<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num[j]
= ((Integer)s.pop()).intValue();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
switch based on operator<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch
(operator.charValue()) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// operator is &quot;+&quot;, add operands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case '+':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(num[1] + num[0]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// operator is &quot;-&quot;, subtract operands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case '-':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(num[1] - num[0]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// operator is &quot;*&quot;, multiply operands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case '*':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(num[1] * num[0]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// operator is &quot;/&quot;, divide operands<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case '/':<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.push(new
Integer(num[1] / num[0]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
unknown operator, print error message<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(&quot;ERROR:
invalid operator: &quot; + operator);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(3);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// value remaining on stack
must be answer, print to screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(((Integer)s.pop()).intValue());
<BR>
&nbsp;&nbsp;&nbsp;}<BR>
<TT><FONT FACE="Courier">}</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TheStringTokenizerClass">The <TT><FONT SIZE=4 FACE="Courier">StringTokenizer</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">StringTokenizer</FONT></TT> class
provides a set of methods for converting an input stream into
a set of tokens. Methods are provided for specifying which characters
make up a token, which characters serve as token delimiters, whether
case should be considered, and whether numeric characters should
be converted to numbers. The <TT><FONT FACE="Courier">StringTokenizer</FONT></TT>
class also understands the <TT><FONT FACE="Courier">/* */</FONT></TT>
comment-naming conventions of C, C++, and Java as well as the
<TT><FONT FACE="Courier">//</FONT></TT> used in C++ and Java.
<P>
The <TT><FONT FACE="Courier">StringTokenizer</FONT></TT> class
specifies all the parts that determine a token and then retrieves
a single token in its entirety piece by piece from an input stream.
This can be used for anything from splitting a simple sentence
into individual words to processing something as complex as Java
source code. (See the online documentation for details of the
individual methods.)
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>Summary</FONT></A>
</H2>
<P>
Java provides several ways to deal with moving data through its
applications. The <TT><FONT FACE="Courier">java.io</FONT></TT>
package contains classes that handle the input and output of data.
The data arrives in a stream and can be sliced and diced in various
ways by the subclasses of the abstract classes <TT><FONT FACE="Courier">InputStream</FONT></TT>
and <TT><FONT FACE="Courier">OutputStream</FONT></TT>.
<P>
The data stream may block, or wait, if the flow is not continuous.
Both input and output classes provide buffers to smooth this flow.
All input classes are able to skip a certain number of bytes forward
in the stream; some classes can mark a spot and then reset the
stream to that spot. Some classes store the data in byte arrays,
and one class stores it in a character string array.
<P>
Data accessed or stored by Java must originate or be placed in
an area that is Java accessible. Much of the Java security schema
relies on the segmentation of Java data from other system data.
Therefore, it would not be a good idea to put a copy of your password
file in this area.
<P>
The <TT><FONT FACE="Courier">java.io</FONT></TT> package doesn't
care where data originates; it only cares about what the programmer
wants to do with it. The data-manipulation classes enable Java
to be truly non-platform-specific, even when manipulating data.
<P>
The <TT><FONT FACE="Courier">java.util</FONT></TT> package contains
classes that add functionality to Java. These classes include
a date manipulator (<TT><FONT FACE="Courier">Date</FONT></TT>)
and a bitset creator and manipulator (<TT><FONT FACE="Courier">Bitset</FONT></TT>).
There are also classes that provide a mechanism for a hash table
structure of an object file (<TT><FONT FACE="Courier">Dictionary</FONT></TT>
and <TT><FONT FACE="Courier">Hashtable</FONT></TT>). There is
a pseudo-random number generator (<TT><FONT FACE="Courier">Random</FONT></TT>).
Another class creates a stack of objects (<TT><FONT FACE="Courier">Stack</FONT></TT>),
and another turns a string of characters into tokens (<TT><FONT FACE="Courier">StringTokenizer</FONT></TT>).
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch11.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch11.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch13.htm" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/ch13.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/835574400/1-57521/1-57521-088-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>
<HR WIDTH="100%"></P>
<P>


</BODY>
</HTML>
