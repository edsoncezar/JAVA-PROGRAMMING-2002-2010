<HTML>
<HEAD>
<TITLE>Exceptions</TITLE>
<META name="description" content="Object oriented design guidelines from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java, java, Design, design, Book, book, Object, object, Oriented, oriented, Thread, thread, Safe, safe">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/85494fc4?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjNJava" ><img src="..\cgi-bin\getimage.cgi\85494fc4\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="sts">Chapter 7</SPAN><BR>
<SPAN class="ts">Exceptions</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="fieldsmethods.html">Previous</A>&nbsp;|
<A href="brokencontract.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
The Guidelines:

<UL>
<LI><A href="brokencontract.html"><STRONG>Use exceptions to indicate a broken semantic contract.</STRONG></A>
<LI><A href="abnormalconditions.html"><STRONG>Throw exceptions on abnormal conditions.</STRONG></A>

<LI><A href="checkedexceptions.html"><STRONG>Use checked exceptions for conditions that client code
may reasonably be expected to handle.</STRONG></A>
<LI><A href="exceptiontype.html"><STRONG>Throw a different exception type for each
abnormal condition.</STRONG></A>
<!-- put exceptions in package they are thrown -->
</UL>

<P>This page shows the raw material from which I will build the guidelines
and idioms that pertain to exceptions:

<P>Five months ago, I began a mini-series of articles about designing
objects.  In this <STRONG>Design Techniques</STRONG> article, I'll
continue that series by looking at design principles that concern error
reporting and exceptions.  I'll assume in this article that you know
what exceptions are and how they work.

<P>
<FONT SIZE="+1"><STRONG>The benefits of exceptions</STRONG></FONT><BR>
Exceptions have several benefits. First, they allow you to separate
error handling code from normal code.  You can surround the code that
you expect to execute 99.9% of the time with a try block, and then
place error handling code in catch clauses -- code that you don't expect
to get executed often, if ever. This arrangement has the nice benefit
of making your "normal" code less cluttered.

<P>
If you feel that a method doesn't know how to handle a particular
error, you can throw an exception from the method and let someone else
deal with it. If you throw a "checked" exception, you enlist the help
of the Java compiler to force client programmers to deal with the
potential exception, either by catching it or declaring it in the
<CODE>throws</CODE> clause of their methods. The fact that Java
compilers make sure checked exceptions are handled helps make Java
programs more robust.

<P>
<FONT SIZE="+1"><STRONG>When to throw exceptions</STRONG></FONT><BR>
When should you throw an exception? The answer can be summed up in one
guideline:

<P>
<blockquote>
If your method encounters an abnormal condition that it can't handle,
it should throw an exception.
</blockquote>

<P>
Unfortunately, though this guideline may be easy to memorize and may sound
impressive when you recite it at parties, it doesn't
clear up the picture too much. It actually leads to a different
question: What is an "abnormal condition?"

<P>
That, it turns out, is the $64,000 question. Deciding whether or not a
particular event qualifies as an "abnormal condition" is a subjective
judgment. The decision is not always obvious. It's one reason they pay
you the big bucks.

<P>
A more helpful rule of thumb could be:

<P>
<blockquote>
Avoid using exceptions to indicate conditions that can reasonably be
expected as part of the typical functioning of the method.
</blockquote>

<P>
An abnormal condition, therefore, would be any condition that wouldn't
reasonably be expected as part of the "normal functioning" of a method.
To help you get a feel for what I mean by "normal functioning of a
method," allow me to give a few examples.

<P>
<FONT SIZE="+1"><STRONG>A few examples</STRONG></FONT><BR>
As an illustration, consider the <CODE>FileInputStream</CODE> and
<CODE>DataInputStream</CODE> classes from the <CODE>java.io</CODE>
package. Here is an application that uses <CODE>FileInputStream</CODE>
to print the text of a file to the standard output:

<P>
<PRE>
// In source packet in file except/ex9/Example9a.java
import java.io.*;
class Example9a {

    public static void main(String[] args)
        throws IOException {

        if (args.length == 0) {
            System.out.println("Must give filename as first arg.");
            return;
        }

        FileInputStream in;
        try {
            in = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println("Can't find file: " + args[0]);
            return;
        }

        int ch;
        while ((ch = in.read()) != -1) {
            System.out.print((char) ch);
        }
        System.out.println();

        in.close();
    }
}
</pre>

<P>
This example shows that the <CODE>read()</CODE> method of
<CODE>FileInputStream</CODE> reports an "end of file has been reached"
condition not by throwing an exception, but by returning a special
value: -1. In this method, reaching end of file is considered a
"normal" part of using the method. It is not considered an "abnormal"
condition. The usual way to read bytes is to keep on reading them until
you hit the end.

<P>
The <CODE>DataInputStream</CODE> class, on the other hand, takes a
different approach when reporting end of file:

<P>
<PRE>
// In source packet in file except/ex9b/Example9b.java
import java.io.*;
class Example9b {

    public static void main(String[] args)
        throws IOException {

        if (args.length == 0) {
            System.out.println("Must give filename as first arg.");
            return;
        }

        FileInputStream fin;
        try {
            fin = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println("Can't find file: " + args[0]);
            return;
        }

        DataInputStream din = new DataInputStream(fin);
        try {
            int i;
            for (;;) {
                i = din.readInt();
                System.out.println(i);
            }
        }
        catch (EOFException e) {
        }

        fin.close();
    }
}
</pre>

<P>
Each time the <CODE>readInt()</CODE> method of
<CODE>DataInputStream</CODE> is invoked, it reads four bytes from the
stream and interprets them as an <CODE>int</CODE>. When
<CODE>readInt()</CODE> encounters end of file, it throws
<CODE>EOFException</CODE>.

<P>
Throwing an exception is a reasonable approach for this method for two
reasons. First, <CODE>readInt()</CODE> can't return a special value to
indicate end of file, because all possible return values are valid
<CODE>int</CODE>s. (It can't return -1 on end of file, for example,
because it may read a -1 from the stream and need to return it as a
valid <CODE>int</CODE> value.) Second, if <CODE>readInt()</CODE>
encounters end of file after reading only one, two, or three bytes,
that probably qualifies as an "abnormal condition." The method is
supposed to read four bytes, but only one to three are available. Given
that this exception is an integral part of using this class, it is a
checked exception (a subclass of <CODE>Exception</CODE>). Client
programmers are forced to deal with it.

<P>
A third approach to signaling an "end has been reached" condition is
illustrated by the <CODE>StringTokenizer</CODE> and <CODE>Stack</CODE>
classes in the following example:

<P>
<PRE>
// In source packet in file except/ex9b/Example9c.java
// This program prints the white-space separated tokens of an
// ASCII file in reverse order of their appearance in the file.
import java.io.*;
import java.util.*;
class Example9c {

    public static void main(String[] args)
        throws IOException {

        if (args.length == 0) {
            System.out.println("Must give filename as first arg.");
            return;
        }

        FileInputStream in = null;
        try {
            in = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println("Can't find file: " + args[0]);
            return;
        }

        // Read file into a StringBuffer
        StringBuffer buf = new StringBuffer();
        try {
            int ch;
            while ((ch = in.read()) != -1) {
                buf.append((char) ch);
            }
        }
        finally {
            in.close();
        }

        // Separate StringBuffer into tokens and
        // push each token into a Stack
        StringTokenizer tok = new StringTokenizer(buf.toString());
        Stack stack = new Stack();
        while (tok.hasMoreTokens()) {
            stack.push(tok.nextToken());
        }

        // Print out tokens in reverse order.
        while (!stack.empty()) {
            System.out.println((String) stack.pop());
        }
    }
}
</pre>

<P>
This example reads in the bytes of a file, converts them to
<CODE>char</CODE>s, and places the <CODE>char</CODE>s into a
<CODE>StringBuffer</CODE>. It then uses a <CODE>StringTokenizer</CODE>
to extract one white-space separated token (a <CODE>String</CODE>) at a
time and push it onto a <CODE>Stack</CODE>. Next it pops all tokens
from the <CODE>Stack</CODE> and prints them out one per line. Because
<CODE>Stack</CODE> implements a Last In First Out (LIFO) stack, the
tokens are printed in reverse order from their appearance in the file.

<P>
Both the <CODE>StringTokenizer</CODE> and the <CODE>Stack</CODE> must
signal an "end has been reached" condition. The
<CODE>StringTokenizer</CODE> constructor takes as a parameter the
source <CODE>String</CODE> to tokenize. Each invocation of
<CODE>nextToken()</CODE> returns a <CODE>String</CODE> that represents
the next token of the source <CODE>String</CODE>. Eventually, all the
tokens in the source <CODE>String</CODE> will be consumed, and
<CODE>StringTokenizer</CODE> must somehow indicate that the end of
tokens has been reached. In this case, there is a special return value,
<CODE>null</CODE>, that could have been used to indicate the end of
tokens. But the designer of this class took a different approach. A
separate method, <CODE>hasMoreTokens()</CODE>, returns a
boolean value indicating whether or not the end of tokens
has been reached. You  must invoke <CODE>hasMoreTokens()</CODE> each
time you invoke <CODE>nextToken()</CODE>.

<P>
This approach shows that the designer did not consider reaching the end
of tokens an abnormal condition. It is a normal way to use the class.
After the end has been reached, however, if you don't check
<CODE>hasMoreTokens()</CODE> and call
<CODE>nextToken()</CODE>, you
will be rewarded with the <CODE>NoSuchElementException</CODE>. Although
this exception is thrown on an end of tokens condition, it is an
unchecked exception (a subclass of <CODE>RuntimeException</CODE>). It
is thrown more to indicate a software bug -- that you are not using the
class correctly -- than to indicate the end of tokens condition.

<P>
Similarly, the <CODE>Stack</CODE> class has a method,
<CODE>empty()</CODE>, that returns a boolean to indicate
that the last object has been popped from the stack. You must invoke
<CODE>empty()</CODE> each time you invoke <CODE>pop()</CODE>. If you
neglect to invoke <CODE>empty()</CODE>and invoke <CODE>pop()</CODE> on
an empty stack, you get an <CODE>EmptyStackException</CODE>. Although
this exception is thrown when an "end of objects on the stack"
condition is encountered, it is another unchecked runtime exception. It
is intended to be more an indication of a software bug in the client
code (the improper use of the <CODE>Stack</CODE> class) than the normal
way to detect an empty stack.

<P>
<FONT SIZE="+1"><STRONG>Exceptions indicate a broken contract</STRONG></FONT><BR>
The examples above should give you a feel for when you would want to
throw an exception instead of using some other means to communicate
an event. One other way to think about exceptions, which may give you
more insight into when you should use them, is that exceptions indicate
a "broken contract."

<P>
One design approach often discussed in the context of object-oriented
programming is the Design by Contract approach. This approach to
software design says that a method represents a contract between the
client (the caller of the method) and the class that declares the
method. The contract includes preconditions that the client must
fulfill and postconditions that the method itself must fulfill.

<P>
<STRONG>Precondition</STRONG><BR>
One example of a method with a precondition is the <CODE>charAt(int
index)</CODE> method of class <CODE>String</CODE>. This method requires
that the <CODE>index</CODE> parameter passed by the client be between 0
and one less than the value returned by invoking <CODE>length()</CODE>
on the <CODE>String</CODE> object. In other words, if the length of a
<CODE>String</CODE> is 5, the <CODE>index</CODE> parameter must be
between 0 and 4, inclusive.

<P>
<STRONG>Postcondition</STRONG><BR>
The postcondition of <CODE>String</CODE>'s <CODE>charAt(int
index)</CODE> method is that its return value will be the character at
position <CODE>index</CODE> and the string itself will remain
unchanged.

<P>
If the client invokes <CODE>charAt()</CODE> and passes -1 or some value
<CODE>length()</CODE> or greater, the client has broken the contract.
In this case, the <CODE>charAt()</CODE> method can't do its job
correctly, and it signals this to the client by throwing a
<CODE>StringIndexOutOfBoundsException</CODE>. This exception indicates
that the client has some kind of software bug or has not used the class
correctly.

<P>
If the <CODE>charAt()</CODE> method finds that it has received good
input (the client has kept its part of the bargain), but for some
reason is unable to return the character at the requested index (unable
to fulfill its end of the contract), it would indicate this condition
by throwing an exception. Such an exception would indicate that the
method has some kind of bug or difficulty with runtime resources.

<P>
So, if an event represents an "abnormal condition" or a "broken
contract," the thing to do in Java programs is to throw an exception.

<P>
<FONT SIZE="+1"><STRONG>What to throw?</STRONG></FONT><BR>
Once you have decided to throw an exception, you need to decide which
exception to throw. You can throw an instance of class
<CODE>Throwable</CODE>, or any subclass of <CODE>Throwable</CODE>. You
can throw an already existing throwable object from the Java API, or
define and throw one of your own. How do you decide?

<P>
<STRONG>Exceptions versus errors</STRONG><BR>
In general, you should throw an exception and and never throw errors.
<CODE>Error</CODE>, a subclass of <CODE>Throwable</CODE>, is intended
for drastic problems, such as <CODE>OutOfMemoryError</CODE>, which
would be reported by the JVM itself. On occasion an error, such as
<CODE>java.awt.AWTError</CODE>, could be thrown by the Java API. In
your code, however, you should restrict yourself to throwing exceptions
(subclasses of class <CODE>Exception</CODE>). Leave the errors to the
big guys.

<P>
<STRONG>Checked vs Unchecked exceptions</STRONG><BR>
The big question, then, is whether to throw a "checked" or an
"unchecked" exception. A checked exception is some subclass of
<CODE>Exception</CODE> (or <CODE>Exception</CODE> itself), excluding
class <CODE>RuntimeException</CODE> and its subclasses. Unchecked
exceptions are <CODE>RuntimeException</CODE> and any of its
subclasses.  Class <CODE>Error</CODE> and its subclasses also are
unchecked, but as you should be focusing on throwing exceptions only,
your decision should be whether to throw a subclass of
<CODE>RuntimeException</CODE> (an unchecked exception) or some other
subclass of <CODE>Exception</CODE> (a checked exception).

<P>
If you throw a checked exception (and don't catch it), you will need to
declare the exception in your method's <CODE>throws</CODE> clause.
Client programmers who wish to call your method will then need to
either catch and handle the exception within the body of their methods,
or declare the exception in the throws clause of their methods. Making
an exception checked forces client programmers to deal with the
possibility that the exception will be thrown.

<P>
If you throw an unchecked exception, client programmers can decide
whether to catch or disregard the exception, just as with checked
exceptions. With an unchecked exception, however, the compiler doesn't
force client programmers either to catch the exception or declare it in
a throws clause. In fact, client programmers may not even know that the
exception could be thrown.  Either way, client programmers are less
likely to think about what they should do in the event of an unchecked
exception than they are in the case of an checked exception.

<P>
The simple guideline is:

<P>
<blockquote>
If you are throwing an exception for an abnormal condition that you
feel client programmers should consciously decide how to handle, throw
a checked exception.
</blockquote>

<P>
In general, exceptions that indicate an improper use of a class should be unchecked. The <CODE>StringIndexOutOfBoundsException</CODE> thrown by
<CODE>String</CODE>'s <CODE>charAt()</CODE> method is an unchecked
exception. The designers of the <CODE>String</CODE> class didn't want
to force client programmers to deal with the possibility of an invalid
<CODE>index</CODE> parameter every time they called <CODE>charAt(int
index)</CODE>.

<P>
The <CODE>read()</CODE> method of class
<CODE>java.io.FileInputStream</CODE>, on the other hand, throws
<CODE>IOException</CODE>, which is a checked exception. This exception
indicates some kind of error occurred while attempting to read from the
file. It doesn't indicate that the client has used the
<CODE>FileInputStream</CODE> class improperly. It just signals that
the method itself is unable to fulfill its contractual responsibility
of reading in the next byte from the file. The designers of the
<CODE>FileInputStream</CODE> class considered this abnormal condition
to be common enough, and important enough, to force client programmers
to deal with it.

<P>
That is the trick, then, of deciding between a checked and an unchecked
exception. If the abnormal condition is a failure of the method to
fulfill its contract, and you feel it is common or important enough
that client programmers should be forced to deal with the possibility
of the exception, throw a checked exception. Otherwise, throw an
unchecked exception.

<P>
<STRONG>Define a specific exception class</STRONG><BR>
Finally, you must decide which exception class to instantiate
and throw. The general rule here is to be specific. Don't just
throw <CODE>Exception</CODE>, for example, with a string message
indicating the kind of abnormal condition that caused the exception.
Define or choose an already existing exception class for each kind of
abnormal condition that may cause your method to throw an exception.
This way, client programmers can define a separate catch clause for
each kind of exception, or can catch some but not others, without
having to query the object to determine the kind of abnormal condition
that caused the exception.

<P>
You may wish to embed some information in the exception object, to give
the catch clause more details about the exception. But you don't want
to rely solely on embedded information to distinguish one type of
exception from another. You don't want clients to have to query the
exception object to determine, for example, whether the problem was an
I/O error or an illegal argument.

<P>
Note that when <CODE>String.charAt(int index)</CODE> receives a bad
input, it doesn't throw <CODE>RuntimeException</CODE> or even
<CODE>IllegalArgumentException</CODE>. It throws
<CODE>StringIndexOutOfBoundsException</CODE>. The type name indicates
that the problem was a string index, and the program can query the
object to find out what the bad index was.

<P>
<FONT SIZE="+1"><STRONG>Conclusion</STRONG></FONT><BR>
The most important point to take away from this article is that
exceptions are there for <EM>abnormal</em> conditions and shouldn't be
used to report conditions that can be reasonably expected as part of
the everyday functioning of a method. Although the use of exceptions can
help make your code easier to read by separating the "normal" code from
the error handling code, their inappropriate use can make your
code harder to read.

<P>
Here is a collection of the exception guidelines put forth by this article:

<P>
<UL>
<LI>If your method encounters an abnormal condition that it can't
handle, it should throw an exception.

<P>
<LI>Avoid using exceptions to indicate conditions that can reasonably
be expected as part of the normal functioning of the method.

<P>
<LI>If your method discovers that the client has breached its
contractual obligations (for example, by passing in bad input data),
throw an unchecked exception.

<P>
<LI>If your method is unable to fulfill its contract, throw either a
checked or unchecked exception.

<P>
<LI>If you are throwing an exception for an abnormal condition that
you feel client programmers should consciously decide how to handle,
throw a checked exception.

<P>
<LI>Define or choose an already existing exception class for each kind
of abnormal condition that may cause your method to throw an
exception.
</UL>

<P>You can <A href="src\exceptions.html">download</A> the example source code from this article.
<P>If you have any opinions about the guidelines presented in this
article, feel free to express yourself in the
<A href="fjf\index.html">Flexible Java Forum</A>.
The Forum's <A href="fjf\exceptions\index.html">Designing With
Exceptions</A> topic is devoted to the guidelines presented in
this article and chapter.
</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/exceptions.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
