<HTML>
<HEAD>
<TITLE>Flyweights as Pluggable Nuggets of Behavior</TITLE>
<META name="description" content="Design guideline from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/76ce24e4?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjDesWkshp" ><img src="..\cgi-bin\getimage.cgi\76ce24e4\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Guideline 5</SPAN><BR>
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Use Flyweights as pluggable nuggets of behavior</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="messenger.html">Previous</A>&nbsp;|
<A href="immutable.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
Although most
<P>
This <CODE>StampDispenser</CODE> really offers the same service to clients as the
<CODE>StampDispenser</CODE> in example 1, but through
a different interface and with an implementation that is more code-heavy than
example 1. Were I to have to implement a <CODE>StampDispenser</CODE>, I would
do it the way I did in example 1. With example 2, I wanted to show how state
machines and service-oriented objects are similar, and I wanted to have a launching
point for using the state pattern.

<P>
The state pattern is an implementation pattern, so it doesn't really impact APIs,
but it will allow me to show you a good example of a flyweight. The state pattern
says that when you end up with switch statements such as those that appear in
example 2, where you have a case statement for each of some finite number
of states, you should consider factoring out the behavior for each state into
its own object. You end up with an implementation that looks like this:

<P>
<CENTER>
<IMG src="images\statepattern.gif">
</CENTER>

<P>
You then define one concrete subclass for each state:

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4
 5 <EM>/**
 6 * &lt;code&gt;StampDispenserState&lt;/code&gt; subclass that represents
 7 * the &lt;em&gt;Has0&lt;/em&gt; stamp dispenser state. See the documentation
 8 * for class &lt;code&gt;StampDispenserState&lt;/code&gt; for a state
 9 * transition table that specifies the required behavior of
10 * instances of this class.
11 */</EM>
12 class Has0State extends StampDispenserState {
13
14     <EM>/**
15     * The single instance of &lt;code&gt;Has0State&lt;/code&gt;
16     */</EM>
17     private static Has0State singleton = new Has0State();
18
19     <EM>/**
20     * Constructs a &lt;code&gt;Has0State&lt;/code&gt; instance. This constructor is
21     * private to enable this class to restrict the number
22     * of instances of &lt;code&gt;Has0State&lt;/code&gt; to one. I.e., &lt;code&gt;Has0State&lt;/code&gt; is
23     * a singleton.
24     */</EM>
25     private Has0State() {
26     }
27
28     <EM>/**
29     * Factory method that returns the single instance of
30     * &lt;code&gt;Has0State&lt;/code&gt;.
31     */</EM>
32     static StampDispenserState getState() {
33         return singleton;
34     }
35
36     <EM>/**
37     * Performs actions appropriate for the state represented by
38     * the class of this object for the add5 message. Returns a
39     * reference to the state object that represents the next state
40     * to transition to as a result of the arrival of this add5 message.
41     *
42     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
43     *     object represents
44     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
45     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
46     */</EM>
47     StampDispenserState add5(StampDispenser stampDispenser,
48         Set listeners) {
49
50         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 5);
51         fireCoinAccepted(event, listeners);
52         return Has5State.getState();
53     }
54
55     <EM>/**
56     * Performs actions appropriate for the state represented by
57     * the class of this object for the add10 message. Returns a
58     * reference to the state object that represents the next state
59     * to transition to as a result of the arrival of this add10 message.
60     *
61     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
62     *     object represents
63     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
64     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
65     */</EM>
66     StampDispenserState add10(StampDispenser stampDispenser,
67         Set listeners) {
68
69         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 10);
70         fireCoinAccepted(event, listeners);
71         return Has10State.getState();
72     }
73
74     <EM>/**
75     * Performs actions appropriate for the state represented by
76     * the class of this object for the returnCoins message. Returns a
77     * reference to the state object that represents the next state
78     * to transition to as a result of the arrival of this returnCoins message.
79     *
80     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
81     *     object represents
82     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
83     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
84     */</EM>
85     StampDispenserState returnCoins(StampDispenser stampDispenser,
86         Set listeners) {
87
88         return this;
89     }
90 }
</pre>

<P>
The Go4 book claims that the benefit of the state pattern is that it localizes state specific code. I.e., all
the code for each state is in one place, the concrete subclass for the state. It therefore eliminates the
switch statements, which can be difficult to maintain, especially if they are long because there's lots
of states. In addition, if the state objects are stateless, they can be shared. Such stateless state objects,
the Go4 book goes on to  say, are, in fact, basically flyweights.

<P>
Which brings me to flyweights. If you look closely at the <CODE>Has0State</CODE> class, you'll see that
its instances have no state. The <CODE>Has0State</CODE> class, like all its sibling <CODE>State</CODE>
subclasses, has no instance variables. That makes <CODE>Has0State</CODE> a flyweight, which sits at
the behavior end of the state-behavior spectrum.

<P>
The <CODE>State</CODE> subclasses are flyweights: bundles of pure behavior.
Though flyweights can have some state too. Extrisic/Intrinsic. Extrinsic
state in this case is the <CODE>StampDispenser</CODE> and the <CODE>Set</CODE> of <CODE>StampDispenserListener</CODE>s
passed to the <CODE>add5</CODE>, <CODE>add10</CODE>, and <CODE>returnCoins</CODE> methods.
The main intent of flyweights as described in Go4 is to enable sharing of objects to
reduce the number of objects in a system. <CODE>Has0State</CODE> is shared. It's
a singleton shared by all instances of <CODE>StampDispenser</CODE>.

<P>
Represent the "behavior end" of a Behavior/State spectrum

<P>
Talk about intrinsic versus extrinsic state. Talk about a non-stateless flyweight.

<P>
My point is that at the flyweight end of the spectrum, the behavior of an object doesn't
depend anymore on an object's state, just its class. So the way you get interesting behavior
is by subsituting an object of some other class. I.e., I switch from a <CODE>Has0State</CODE>
to a <CODE>Has5State</CODE>, and I get different behavior.

<P>
The dull comedian from the previous guideline was a flyweight. The comedian was dull because
every time you asked him to tell a joke, he told you the same joke. Because he didn't have
state to help him provide interesting behavior in his <CODE>tellJoke</CODE> method, he always
did the same behavior:

<PRE>
 1 package com.artima.examples.comedian.ex1;
 2
 3 <EM>/**
 4  * A comedian that tells jokes.
 5  */</EM>
 6 class Comedian {
 7
 8     <EM>/**
 9      * Returns a joke as a &lt;CODE&gt;String&lt;/CODE&gt;.
10      */</EM>
11     public String tellJoke() {
12
13         return "Why did the chicken cross the road? To get to the other side.";
14     }
15 }
</PRE>

<P>
In the case of this kind of comedian, then, what you'd need to do to have an interesting
evening is invite all the one-joke comedians you know over to your house for a party, then
keep asking different people for a joke. Even if everyone only knows one joke, if you
have enough people to ask, you can have an enjoyable evening. This is what the
<CODE>StampDispenser</CODE> in ex3 does. It keeps swapping out the current state object,
so that when it asks the current state to <CODE>add10</CODE>, it isn't sure what's
going to happen (what will happen depends only on the class of the current state object),
which allows the <CODE>StampDispenser</CODE> to provide interesting behavior to its
client.

<P>
This is why I say use flyweights to provide pluggable nuggets of behavior. Given that
a flyweight has little or no state, its main utility comes in being able to unplug
one flyweight an plug in another flyweight that has the same interface. The flyweights
function as pluggable nuggets of behavior.

<P>
Moved this here from guideline 3, which was getting too big. Can reiterate that state is
used to have interesting behavior, the point of 3, in this guideline.

<P>
By using their state to decide how to behave, service-oriented objects can have
more interesting behavior.
For example, if I ask you 50 times to tell a joke, and you always tell the same joke, that's
kind of boring behavior. If a class has no state, then every time I ask an instance of
that class to perform a service for me it behaves in exactly the same way:

<P>
<STRONG>Listing 6-2. A boring comedian.</STRONG>

<PRE>
 1 package com.artima.examples.comedian.ex1;
 2
 3 <EM>/**
 4  * A comedian that tells jokes.
 5  */</EM>
 6 class Comedian {
 7
 8     <EM>/**
 9      * Returns a joke as a &lt;CODE&gt;String&lt;/CODE&gt;.
10      */</EM>
11     public String tellJoke() {
12
13         return "Why did the chicken cross the road? To get to the other side.";
14     }
15 }
</PRE>
<P>
Better that the class have an arsenal of jokes, and a state
variable indicating the next joke to tell:

<P>
<STRONG>Listing 6-3. A slightly less boring comedian.</STRONG>

<PRE>
 1 package com.artima.examples.comedian.ex2;
 2
 3 <EM>/**
 4  * A comedian that tells jokes.
 5  */</EM>
 6 class Comedian {
 7
 8     private static final String jokes[] = {
 9         "Why did the chicken cross the road? To get to the other side.",
10         "What's green and sings? Elvis Parsley.",
11         "What's the last thing to go through a bug's mind when it hits your windshield? Its butt.",
12     };
13
14     private int nextJoke = 0;
15
16     <EM>/**
17      * Returns a joke as a &lt;CODE&gt;String&lt;/CODE&gt;.
18      */</EM>
19     public String tellJoke() {
20
21         int jokeIndex = nextJoke;
22         ++nextJoke;
23         if (nextJoke &gt;= jokes.length) {
24             nextJoke = 0;
25         }
26         return jokes[jokeIndex];
27     }
28 }
29
</PRE>
<P>
That's more interesting behavior,
because the object is using its state (the <CODE>nextJoke</CODE> instance variable) to decide how to behave
(which joke to tell).

</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/Flyweights.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
