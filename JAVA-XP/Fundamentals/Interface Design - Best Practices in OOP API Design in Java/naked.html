<HTML>
<HEAD>
<TITLE>Design objects that can defend themselves</TITLE>
<META name="description" content="An object-oriented design idiom from Interface Design: Best Practices in Object Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/2fc5dc88?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ArtimaTraining" ><img src="..\cgi-bin\getimage.cgi\2fc5dc88\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Guideline 7</SPAN><BR>
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Design objects that can defend themselves</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="immutable.html">Previous</A>&nbsp;|
<A href="cominhint.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
Objects that expose public instance variables are messengers, because they carry data,
but these objects are naked messengers.
<UL>
<LI>
Naked Objects can act as Messengers
<LI>
Arrays can be used for multi-valued returns
<LI>
Contain public instance variables (act like C structs)
<LI>
AWT's <CODE>Point</CODE> and <CODE>Dimension</CODE> -- could be immutables
<LI>
Jini's <CODE>ServiceMatches</CODE> -- could be immutable
<LI>
Jini/JavaSpaces <CODE>Entry</CODE> -- good reason to be defenseless
<LI>
What is gained by making messenger variables private?
<UL>
<LI>If immutable, can pass without worries of side effects
<LI>And, can cache a returned object as a performance optimization
</UL>
</UL>

<P>
Messengers are more vulnerable when they walk around naked, because they
are exposing their privates. For example, I can set the <CODE>width</CODE>
field of a <CODE>java.awt.Dimension</CODE> to -5, a corrupt value, and
there's not a damn thing that <CODE>Dimension</CODE> can do about it.
Is this the kind of world you want to live in?

<P>
A <CODE>Dimension</CODE> with both <CODE>set</CODE> and <CODE>get</CODE>
methods could be reused,

<P>
Class <CODE>Entry</CODE> is an interesting example of a naked object. Explain
the reasoning behind them. Any methods I've ever put into entries are for
convenience. Because when you don't control your data, you can't guarantee
that you can fulfill a contract. In summary, naked messengers are
quite contrary to the whole thrust of object-oriented design, where
responsibilities are divided among various objects, and each object
promised to fulfill the obligations outlined in its contract.
Talk about the <CODE>increment</CODE> method in <CODE>ChatMessage</CODE>
and perhaps the <CODE>getFactory</CODE>
method in <CODE>UIDescriptor</CODE>. Private data is key to enabling an
object to fulfill its contract.

<P>
Most of the things I mentioned in Guideline 1, debuggable, flexible, modular, abstract, require
private data.

<P>
When you don't control your data, you don't control your destiny.

<P>
Use the <CODE>URLFactoryLink</CODE> as an example of can't cache a messenger. Got to
create a new <CODE>ServiceItem</CODE> each time. What they did in <CODE>Component</CODE> was
add a <CODE>getSize</CODE> method that takes a <CODE>Dimension</CODE>, a bucket to fill.
Oddly enough, if the idea of making public data is that it can be reused, then it is up
to the client to reuse the object, because provider can't cache and reuse.

<!--
<P>
The internet is full of naked data. Perhaps you've even seen some of it.
-->

<P>
<CODE>get</CODE> is sometimes dropped from high traffic methods (e.g., <CODE>iterator()</CODE> in
<CODE>java.util.Collection</CODE> instead of <CODE>getIterator()</CODE>, so <CODE>getX()</CODE>
could have been left as <CODE>x()</CODE>.

<P>
Make members as private as possible, especially data.

<HR align="left" width="100%" size="4" noshade>
<H2>Separate Interface and Implementation</H2>
<UL>
<LI>
Guideline: <EM>Design objects that can defend themselves.</EM>
<LI>
Minimize coupling
<LI>
Interface is the "point of coupling"
<LI>
Thus, minimize the interface
<LI>
I.e., make members as private as possible, especially data
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>Why Private Data?</H2>
<UL>
<LI>
Because the semantic contract should be behavior
<LI>
Keeps behavior code in one place
<LI>
More Robust: Can control the behavior
<LI>
More Flexible: Can change the implementation of the behavior
<LI>
Only way to make objects thread safe
<LI>
Only way to make objects immutable
<LI>
When you <CODE>set()</CODE> and <CODE>get()</CODE>, <CODE>set()</CODE>
and <CODE>get()</CODE> properties, not instance variables
</UL>

<P>
I also tend to shy away from protected data and package access data. At least in package access data,
the coupling is still limited to the package, but its still more heavily coupled. A class can't really
be responsible for fulfilling its contract if it has package-access data, its package is responsible
for fulfilling its contract. Likewise, if data is protected, then its package and all its subclasses
are responsible for fulfilling its contract. Once again, you can see the responsibility being spread
to far and wide. You are missing the advantage of encapsulation.

<H3>Notes from private as possible:</H3>

<P>
Occasionally, bundles of class methods or bundles of
constants
Use class members to control access to
objects, provide utility methods, or offer bundles of constants.
Examples of controlling access to objects, static factory methods, singleton pattern.

<P>
<BLOCKQUOTE>
James Gosling: What is the API to Windows?  Nobody knows.  In fact, even Microsoft doesn't know what the Windows API is.
Because they publish an API, but lots of people sneak in through back doors. [...]

<P>
Because there isn't a really good, strong interface notion in C, people just sort of reach in through the back doors.
And they do God knows what.  And so when Microsoft goes to release a new version of Windows, what
they essentially have to do is test everything.

<P>
It was a very important property of interfaces that they are very strict.  That wasn't just me deciding to be
nasty.  That was the world is madness if the contracts aren't strict.  Because then all of a sudden--the whole
notion of object-oriented programming falls apart.
You lose the ability to unplug this and plug that in. If you don't
know what the shape of the plug is, how do you know it can plug in?
</BLOCKQUOTE>

<P>
Complexity is the enemy of robustness, because complexity tends to generate
highly coupled systems. The more complex a system
becomes, the more difficult it is to achieve overall robustness.
that objects are a debuggable units.
Because of minimized coupling, you can hammer away at those objects and get them working very well.
Achieve robustness on the whole by having each object piece be very robust (i.e., work well).
An object is also a debuggable unit. Objects help programmers manage, not eliminate, complexity. Individual
objects can still be quite complex. And where there is complexity, there are bugs.

<P>
At the first Jini
Community meeting, Bill Joy said that back when he was at Berkeley, he would print out C code that
comprised UNIX and try and see how many bugs he could find by just looking at the code. He said he found an average
of two bugs per page. He said that because C doesn't have a strong interface notion, it's hard to isolate things,
which encourages highly coupled systems.

<P>
I once worked on a C program that served as control software for a semiconductor
photomask inspection station. Unfortunately,
the code that I changed was using a global variable that was coupled to some other, completely unrelated part
of the program in a very non-intuitive way. Before long, a customer reported a serious new bug.
By making seemingly innocuous changes to fix a very minor bug, I had inadvertently created the serious bug.

<P>
Separation of interface and implementation, one of the main ideas in object-oriented programming, helps
programmers create robust objects.
The code that manipulates an object's data is sitting in the object's class. If that data becomes corrupt
while the object is in use, you know the bug is in some method in the object's class. Once you find the bug
and fix it, it is fixed everywhere. When code that uses data is spread out all over the place, as is often
the case in C programs, you can't be certain you won't encounter the same bug in some other snipet of
code somewhere else that access the same data.

<P>
If the instance variables of an object are private, and those
Because each island represents a managable level of complexity,
Once the provider of an object gets all the bugs get ironed out of the object's implementation, those bugs
tend to stay fixed because
client's can't directly interact with the implementation, they can only talk to the interface.
(Of course, someone in the next cubicle could of course  in there and unfixes it).

<P>
Well-designed objects allow you to prevent such scary coupling in your systems, no matter how complex.

<P>
A modular unit: Can't go around the interface, so can unplug this and plug that back in. (Requires strict
enforcement of separation of interface and implementatoin at runtime.)

<P>
A Secure Unit - Type Safety is the cornerstone of Java's security model
</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/Naked.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
