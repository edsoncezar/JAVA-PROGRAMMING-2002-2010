<HTML>
<HEAD>
<TITLE>Understand the difference between inheritance and composition</TITLE>
<META name="description" content="An object-oriented design idiom from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/3cce7334?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ArtimaTraining" ><img src="..\cgi-bin\getimage.cgi\3cce7334\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Understand the difference between inheritance and composition</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="enlisthelp.html">Previous</A>&nbsp;|
<A href="interfacesabstract.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->


<P>
<CODE>Stack extends Vector</CODE> is a great example of where is-a wasn't really
satisfied, and composition would have been much more flexible.
Also, the Vector methods didn't really belong in Stack. When the retrofitted
Vector to implement List, a whole bunch of other methods got added to the
Stack interface.

<P>
A big part of the adapter pattern's significance is that it shows that objects
involved in a composition relationship have interfaces that are independent
of each other.

<!--
<H2>
Inheritance vs. Composition
</H2>
<UL>
<LI>
Guideline: <EM>Understand the difference between inheritance and
composition.</EM>
<LI>
Inheritance<BR>
<BR>
<PRE>
class Fruit {
    //...
}

class Apple extends Fruit {
    //...
}
</PRE>
Fruit: superclass, Apple: subclass
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Inheritance vs. Composition
</H2>
<UL>
<LI>
Composition<BR>
<BR>
<PRE>
class Carrot {
    //...
}

class Apple {
    private Carrot carrot = new Carrot();
    //...
}
</PRE>
Apple: front-end class, Carrot: back-end class
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Inheritance and Change
</H2>
<UL>
<LI>
Polymorphism<BR>
<BR>
<PRE>
Fruit fruit = new Apple();
</PRE>
<LI>
Dynamic Binding<BR>
<BR>
<PRE>
fruit.peel();
</PRE>
<LI>
Easy to add new Subclasses:<BR>
<BR>
<PRE>
class Mango extends Fruit {
    //...
}

Fruit fruit = new Mango();
fruit.peel();
</PRE>
<LI>
But adding subclasses is not the only kind of change you may need to make
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Changing the Superclass
</H2>
<UL>
<LI>
Tight Coupling: changes to superclass interface can break subclasses, and
vice versa
<LI>
Weak Encapsulation: changes to superclass can break code that uses subclass
directly
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Code Reuse via Inheritance
</H2>
<UL>
<LI>
<PRE>
class Fruit {

    // Return int number of pieces of peel that
    // resulted from the peeling activity.
    public int peel() {

        System.out.println("Peeling is appealing.");
        return 1;
    }
}

class Apple extends Fruit {
}

class Example1 {

    public static void main(String[] args) {

        Apple apple = new Apple();
        int pieces = apple.peel();
    }
}
</PRE>
<LI>
<CODE>Apple</CODE> inherits (reuses) <CODE>Fruit</CODE>'s implementation
of <CODE>peel()</CODE>
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Changing Superclass <CODE>Fruit</CODE>
</H2>
<UL>
<LI>
<PRE>
class Peel {

    private int peelCount;

    public Peel(int peelCount) {
        this.peelCount = peelCount;
    }

    public int getPeelCount() {

        return peelCount;
    }
    //...
}

class Fruit {

    // Return a Peel object that
    // results from the peeling activity.
    public Peel peel() {

        System.out.println("Peeling is appealing.");
        return new Peel(1);
    }
}

// Apple still compiles and works fine
class Apple extends Fruit {
}

// This old implementation of Example1
// is broken and won't compile.
class Example1 {

    public static void main(String[] args) {

        Apple apple = new Apple();
        int pieces = apple.peel();
    }
}
</PRE>
<LI>
Changing superclass <CODE>Fruit</CODE> breaks <CODE>Example1</CODE> code
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Code Reuse via Composition
</H2>
<UL>
<LI>
<PRE>
class Carrot {

    // Return int number of pieces of peel that
    // resulted from the peeling activity.
    public int peel() {

        System.out.println("Peeling is appealing.");
        return 1;
    }
}

class Apple {

    private Carrot carrot = new Carrot();

    public int peel() {
        return carrot.peel();
    }
}

class Example2 {

    public static void main(String[] args) {

        Apple apple = new Apple();
        int pieces = apple.peel();
    }
}
</PRE>
<LI>
Subclass becomes "front-end" class
<LI>
Superclass becomes "back-end" class
<LI>
Explicit forwarding/delegation of <CODE>peel()</CODE> method invocation
required
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Changing a Back-End Class
</H2>
<UL>
<LI>
<PRE>
class Peel {

    private int peelCount;

    public Peel(int peelCount) {
        this.peelCount = peelCount;
    }

    public int getPeelCount() {

        return peelCount;
    }
    //...
}

class Carrot {

    // Return int number of pieces of peel that
    // resulted from the peeling activity.
    public Peel peel() {

        System.out.println("Peeling is appealing.");
        return new Peel(1);
    }
}

// Apple must be changed to accomodate
// the change to Fruit
class Apple {

    private Carrot carrot = new Carrot();

    public int peel() {

        Peel peel = carrot.peel();
        return peel.getPeelCount();
    }
}

// This old implementation of Example2
// still works fine.
class Example2 {

    public static void main(String[] args) {

        Apple apple = new Apple();
        int pieces = apple.peel();
    }
}
</PRE>
-->
<P>
Ripple effect from changing a back-end class stops (or can stop) at the
front-end class

<HR align="left" width="100%" size="4" noshade>
<H2>Composition vs. Inheritance</H2>
Inheritance Yields (Slightly) Better Performance:
<UL>
<LI>
Composition's method forwarding/delegation will often be slower than
inheritance's dynamic binding
<LI>
Composition results in more objects getting instantiated, which can
incur a performance cost at allocation, <CODE>&lt;init&gt;()</CODE>,
and GC time
</UL>
Composition Yields Better Flexibility:
<UL>
<LI>
Interfaces of classes involved in a composition relationship need not be
compatible, so it's easier to change the interfaces
<LI>
Composition allows you to delay creation of back-end objects until (and
unless) you need them
<LI>
Composition allows you to change back-end objects throughout the lifetime
of the front-end object
<LI>
Composition allows front-end objects to share the same back-end objects
</UL>
But:
<UL>
<LI>
Composition's method forwarding/delegation results in more code that has to
be written, debugged, and maintained.
<LI>
Easier to add new subclasses than new front-end classes, <EM>unless you
use composition with interfaces</EM>
</UL>

<P>
Describe adding method to superclass that has same name but different
semantics as subclass. Also the problem of just inheriting an added
method signature that you don't want in the subclass.

<P>
Class extension (full-blown inheritance -- interface and implementation)
is like strapping on a backpack in which your instances carry around
not only their own instance variables and everything they refer to in
a graph of objects, but also those of all their superclasses. If you don't
own the superclass, owner can change superclss by adding lots of
heavy instance data that gets added to your backpack and you don't
have a choice but carry it around everywhere. The owner can also add a method to the
superclass interface that you don't like in your subclass, but suddently
its a part of your interface whether you like it there or not (or, what's the
ultimate problem has, the same signature but incompatible semantics as
an existing method in your subclass). If the superclass owner adds lots
of heavy instance data to the superclass, that owner basically has added
all that weight to your subclass instance's backpack. Your subclass instances
have no choice but carry that around everywhere they go. (In a composition relationship you
could change the back-end object, delay initilization until needed, share
same backend amont multiple front-ends, etc...)

<P>
Could show the decorator example from chapter 4 in UML form and mention
the intent thing?
</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/CompoInhDiff.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
