<HTML>
<HEAD>
<TITLE>Use Immutables to represent values of abstract data types</TITLE>
<META name="description" content="An object-oriented design idiom from Interface Design: Best Practices in Object Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/c612030c?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjNJava" ><img src="..\cgi-bin\getimage.cgi\c612030c\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Guideline 6</SPAN><BR>
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Use Immutables to represent values of abstract data types</SPAN><BR>
</DIV>
<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="flyweights.html">Previous</A>&nbsp;|
<A href="naked.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
With a mutable object like the <CODE>StampDispenser</CODE> in Listing 3-1, identity is important. If I have
3 stamp dispenser machines and I enter a dime in one and a dime in another, I don't get a stamp. I have
to insert at least 20 cents in a particular stamp dispenser to get the stamp. The identity of the machine into
which I insert that second dime matters -- it has to be the same machine in which I inserted the first dime.

<H2>The Immutable</H2>
<UL>
<LI>
Guideline: <EM>Use Immutables to represent values of abstract data types.</EM>
<LI>
State fixed at creation time
<LI>
Rather than changing the state, methods create and return a new object with
the new state
<LI>
Are thread-safe
<LI>
Needn't be cloned before being passed
<LI>Also, can return without side effects, so can cache, as
described in next guideline
</UL>

<PRE>
  1 package com.artima.examples.complexnum.ex1;
  2
  3 <EM>/**
  4 * Represents a complex number whose real and imaginary
  5 * components are &lt;CODE&gt;double&lt;/CODE&gt;s.
  6 */</EM>
  7 public class ComplexNumber {
  8
  9     private double real;
 10     private double imaginary;
 11
 12     <EM>/**
 13     * Construct a new &lt;code&gt;ComplexNumber&lt;/code&gt; with the passed
 14     * real and imaginary components.
 15     */</EM>
 16     public ComplexNumber(double real, double imaginary) {
 17
 18         this.real = real;
 19         this.imaginary = imaginary;
 20     }
 21
 22     <EM>/**
 23     * Returns the real component of this &lt;code&gt;ComplexNumber&lt;/code&gt;.
 24     */</EM>
 25     public double getReal() {
 26         return real;
 27     }
 28
 29     <EM>/**
 30     * Returns the imaginary component of this &lt;code&gt;ComplexNumber&lt;/code&gt;.
 31     */</EM>
 32     public double getImaginary() {
 33         return real;
 34     }
 35
 36     <EM>/**
 37     * Returns the conjugate of this complex number. The conjugate
 38     * of complex number a + &lt;em&gt;i&lt;/em&gt;b is a - &lt;em&gt;i&lt;/em&gt;b.
 39     */</EM>
 40     public ComplexNumber getConjugate() {
 41
 42         return new ComplexNumber(real, -imaginary);
 43     }
 44
 45     <EM>/**
 46     * Compares the passed &lt;CODE&gt;ComplexNumber&lt;/CODE&gt; to this
 47     * &lt;code&gt;ComplexNumber&lt;/code&gt; for equality. Two &lt;code&gt;ComplexNumber&lt;/code&gt;
 48     * objects are semantically equal if their real components are
 49     * equal and their imaginary components are equal.
 50     *
 51     * @param An object to compare to this &lt;code&gt;ComplexNumber&lt;/code&gt;
 52     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;ComplexNumber&lt;/code&gt; is semantically equal
 53     *    to the passed &lt;code&gt;ComplexNumber&lt;/code&gt;
 54     */</EM>
 55     public boolean equals(Object o) {
 56
 57         if ((o == null) || (getClass() != o.getClass())) {
 58             return false;
 59         }
 60
 61         ComplexNumber cn = (ComplexNumber) o;
 62
 63         <EM>// Because this class extends Object, don't</EM>
 64         <EM>// call super.equals()</EM>
 65
 66         <EM>// To be semantically equal, the complex numbers</EM>
 67         <EM>// must have equal real and imaginary components</EM>
 68         if ((real != cn.real) || (imaginary != cn.imaginary)) {
 69             return false;
 70         }
 71
 72         return true;
 73     }
 74
 75     <EM>/**
 76     * Computes the hash code for this &lt;code&gt;ComplexNumber&lt;/code&gt;.
 77     *
 78     * @return a hashcode value for this &lt;code&gt;ComplexNumber&lt;/code&gt;
 79     */</EM>
 80     public int hashcode() {
 81
 82         <EM>// Got this idea from Double's hashcode method. </EM>
 83         long re = Double.doubleToLongBits(real);
 84         long im = Double.doubleToLongBits(imaginary);
 85
 86         int rex = (int) (re ^ (re &gt;&gt;&gt; 32));
 87         int imx = (int) (im ^ (im &gt;&gt;&gt; 32));
 88
 89         return rex ^ imx;
 90     }
 91
 92     <EM>/**
 93     * Adds the passed &lt;code&gt;ComplexNumber&lt;/code&gt; to this one. The sum of
 94     * two complex numbers a + &lt;em&gt;i&lt;/em&gt;b and c + &lt;em&gt;i&lt;/em&gt;d is
 95     * (a + c) + &lt;em&gt;i&lt;/em&gt;(c + d).
 96     *
 97     * @param addend the &lt;code&gt;ComplexNumber&lt;/code&gt; to add to this one
 98     * @returns the sum of this and the passed &lt;code&gt;ComplexNumber&lt;/code&gt;
 99     */</EM>
100     public ComplexNumber add(ComplexNumber addend) {
101         return new ComplexNumber(real + addend.real, imaginary + addend.imaginary);
102     }
103
104     <EM>/**
105     * Subtracts the passed &lt;code&gt;ComplexNumber&lt;/code&gt; from this one. The difference
106     * between two complex numbers, a + &lt;em&gt;i&lt;/em&gt;b - c + &lt;em&gt;i&lt;/em&gt;d, is
107     * (a - c) + &lt;em&gt;i&lt;/em&gt;(b - d).
108     *
109     * @param subtrahend the &lt;code&gt;ComplexNumber&lt;/code&gt; to subtract from this one
110     * @returns the difference of this and the passed &lt;code&gt;ComplexNumber&lt;/code&gt;s
111     */</EM>
112     public ComplexNumber sub(ComplexNumber subtrahend) {
113         return new ComplexNumber(real - subtrahend.real, imaginary - subtrahend.imaginary);
114     }
115
116     <EM>/**
117     * Multiplies this &lt;code&gt;ComplexNumber&lt;/code&gt; (the multiplicand) with
118     * the passed &lt;code&gt;ComplexNumber&lt;/code&gt; (multiplier). The product of two
119     * complex numbers a + &lt;em&gt;i&lt;/em&gt;b and c + &lt;em&gt;i&lt;/em&gt;d is
120     * (ac - bd) + &lt;em&gt;i&lt;/em&gt;(bc + ad).
121     *
122     * @returns the difference of this and the passed &lt;code&gt;ComplexNumber&lt;/code&gt;s
123     */</EM>
124     public ComplexNumber mult(ComplexNumber multiplier) {
125
126         double prodReal = (real * multiplier.real) - (imaginary * multiplier.imaginary);
127         double prodImaginary = (imaginary * multiplier.real) + (real * multiplier.imaginary);
128
129         return new ComplexNumber(prodReal, prodImaginary);
130     }
131
132     <EM>/**
133     * Divides this &lt;code&gt;ComplexNumber&lt;/code&gt; (the numerator) by
134     * the passed &lt;code&gt;ComplexNumber&lt;/code&gt; (denominator). The quotient of two
135     * complex numbers a + &lt;em&gt;i&lt;/em&gt;b / c + &lt;em&gt;i&lt;/em&gt;d is
136     * ((ac + bd) + &lt;em&gt;i&lt;/em&gt;(bc - ad)) / (c*c + d*d).
137     *
138     * @returns the difference of this and the passed &lt;code&gt;ComplexNumber&lt;/code&gt;s
139     */</EM>
140     public ComplexNumber div(ComplexNumber denominator) {
141
142         <EM>// Perform division by first multiplying both the numerator and denominator</EM>
143         <EM>// by the conjugate of the denominator.</EM>
144         ComplexNumber conj = denominator.getConjugate();
145         ComplexNumber tempNumerator = mult(conj);
146         ComplexNumber tempDenominator = denominator.mult(conj);
147
148         <EM>// By multiplying the denominator by its conjugate, its imaginary</EM>
149         <EM>// component drops to zero. Can then just divide the real and imaginary</EM>
150         <EM>// components of the numerator by the denominator's real value.</EM>
151         return new ComplexNumber(tempNumerator.real / tempDenominator.real,
152             tempNumerator.imaginary / tempDenominator.real);
153     }
154 }
</PRE>

<HR align="left" width="100%" size="4" noshade>
<H2>When to Use Immutables</H2>
<UL>
<LI>
One way to look at objects is as abstract data types
<LI>
Java comes with <CODE>int</CODE>, <CODE>float</CODE>, ...
<LI>
What if you want a <CODE>ComplexNumber</CODE>, a <CODE>Matrix</CODE>,
or a <CODE>Bitmap</CODE>?
<LI>
If instances of a class represent <EM>values</EM> of an abstract data type,
consider using an immutable
<LI>
May want a companion state machine too (can be passed in as bucket, but
the bucket is ugly and not seen often, i.e., OK to pass in a service-oriented
object (strategy, command, etc...,) but not an empty mutable messenger.)
<LI>
Safest hashtable keys
</UL>

<P>
The main difference between the State Machine and the immutable is the
way the object reacts to messages being sent (via methods invoked on
the public interface). Whereas the State Machine changes its own state,
the Immutable creates a new object of its own class that has the new
state and returns it.

<P>
Another way to think about objects is as Abstract Data Types. For example,
you may want a <CODE>ComplexNumber</CODE> object, or a <CODE>Matrix</CODE>
object. You may want a <CODE>BigInteger</CODE> object. You may want
a <CODE>Color</CODE> object or a <CODE>String</CODE>, or
a <CODE>BitMap</CODE> object. Each of these
concepts is a relatively simple thing. All classes represent data types, one
way to look at object-oriented programming is that by defining classes
you are extending the programming language with new types. Java comes
with <CODE>int</CODE>, <CODE>float</CODE>, and so on built-in (plus the
classes in <CODE>java.lang</CODE>, and you are adding new ones.

<P>
You want to restrict immutables for objects that are small, because a lot
of them may get created. On the other hand, because they don't have the
aliasing problems associated with State Machines, they don't have to be
cloned when passed to other methods. In other words, they can be shared.
This could actually result in fewer objects being created.

<P>
Messenger objects are usually immutable. Actor objects are by definition
immutable, because if you don't have state, you can't change your state.
But ADT type immutables actually could be implemented as State Machines,
because they offer services that would ordinarily be though of as something
that would change their state. But instead of changing state, they create
a new object of their class that has the new state and return that.
<P>
Make objects immutable where appropriate. (Exceptions, most Events, things
that will need to be passed around (like String, make a StringBuffer too.))
Perhaps talk about ways to pass objects to methods when you want
to make sure the method doesn't alter the object.
Use an immutable object especially if the object is small or
represents a fundamental data type

<P>
<FONT SIZE="+1"><STRONG>RGBColor # 3: Thread safety through immutability</STRONG></FONT><BR>
Here's an immutable version of RGBColor:

<P>
<PRE>
// In file threads/ex3/RGBColor.java
// Instances of this immutable class
// are thread-safe.
public class RGBColor {

    private final int r;
    private final int g;
    private final int b;

    public RGBColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        this.r = r;
        this.g = g;
        this.b = b;
    }

    /**
    * returns color in an array of three ints: R, G, and B
    */
    public int[] getColor() {

        int[] retVal = new int[3];
        retVal[0] = r;
        retVal[1] = g;
        retVal[2] = b;

        return retVal;
    }

    public RGBColor invert() {

        RGBColor retVal = new RGBColor(255 - r,
            255 - g, 255 - b);

        return retVal;
    }

    private static void checkRGBVals(int r, int g, int b) {

        if (r < 0 || r > 255 || g < 0 || g > 255 ||
            b < 0 || b > 255) {

            throw new IllegalArgumentException();
        }
    }
}
</pre>

<P>
Note that the <CODE>setColor()</CODE> method is simply removed, as it
doesn't make sense in an immutable <CODE>RGBColor</CODE> object.  The
<CODE>getColor()</CODE> method, which reads the instance variables, is
identical to what it has been, except now it doesn't have to be
synchronized. The <CODE>invert()</CODE> method, which writes to the
instance variables, is changed. Instead of inverting the current
object's color, this new <CODE>invert()</CODE> creates a new
<CODE>RGBColor</CODE> object that represents the inverse of the object
upon which <CODE>invert()</CODE> is invoked, and returns a reference to
that object.

<P>
<STRONG>Using immutable objects</STRONG><BR>
Achieving thread safety by making objects immutable (Approach 2) works
well when objects are small and represent values of a simple abstract
data type. The Java API includes several examples of immutable objects,
including <CODE>String</CODE> and the primitive type wrappers such as
<CODE>Integer</CODE>, <CODE>Long</CODE>, <CODE>Float</CODE>,
<CODE>Boolean</CODE>, <CODE>Character</CODE>, and so on.

<P>
It's worth noting that instances of the AWT's <CODE>Color</CODE> class
are immutable. Likewise, the immutable approach may make sense for this
article's <CODE>RGBColor</CODE> class, which is similar in
functionality to the AWT's <CODE>Color</CODE> class, because
<CODE>RGBColor</CODE> objects are small (they contain only 3
<CODE>int</CODE>s) and conceptually represent values of a simple
abstract data type.

<P>
Another benefit of immutable objects is that you can pass references to
them to methods without worrying that the method will change the
object's state.  In addition, if the overhead of immutability
(excessive creation of short-lived objects) may at times be too
inefficient, you can also define a mutable companion class that can be
used when the immutable version isn't appropriate. An example of this
design approach in the Java API is the <CODE>StringBuffer</CODE> class,
which serves as a mutable companion to the immutable
<CODE>String</CODE> class. Note that the <CODE>StringBuffer</CODE>
class is also thread-safe, but it uses the "normal" approach: its
instance variables are private and its critical sections are
synchronized.

<H3>Intent</H3>

<P>
Define objects whose state can't change after they are created.

<H3>Also Known As</H3>

<H3>Motivation</H3>

<P>
Immutable objects have several different uses. They are thread-safe.
They can't be changed when passed to methods. They act more like
values of abstract data types than state machines.

<H3>Recipe</H3>

<P>
Here's a step by step outline of this idiom's solution to this problem.
In general, whenever you define a Java class:

<OL>

<LI>Make sure each constructor is able to create a complete object.

<LI>Don't provide any non-private methods that change the state.

<LI>Instead of transforming data, have methods create and return
a new instance of the type.
</OL>

<P>
Note that defining <CODE>finalize()</CODE> is not part of this
idiom. A finalizer is not appropriate in the general case. Cases
in which it is appropriate are described in item?.

<H3>Example Code</H3>

Here's some Java code that illustrates using the I Shall Return idiom
to return multiple <CODE>String</CODE>s from a method that parses a name.

<PRE>
// A more interesting one might be a matrix.
public class ComplexNumber
    implements Cloneable, Serializable {

    private double real;
    private double imaginary;

    public ComplexNumber(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    public ComplexNumber add(ComplexNumber cn) {
        return new ComplexNumber(real + cn.real,
            imaginary + cn.imaginary);
    }

    public ComplexNumber sub(ComplexNumber cn) {
        return new ComplexNumber(real - cn.real,
            imaginary - cn.imaginary);
    }

    public ComplexNumber mult(ComplexNumber cn) {
        return new ComplexNumber(real * cn.real,
            imaginary * cn.imaginary);
    }

    public ComplexNumber div(ComplexNumber cn) {
        return new ComplexNumber(real / cn.real,
            imaginary / cn.imaginary);
    }
}

class Test {

    public static void main(String[] args) {

        NameManager.SplitNameReturnVal sn =
            NameManager.splitName("F. Scott Fitzgerald");

        System.out.println(sn.getFirst() + " " + sn.getMiddle()
            + " " + sn.getLast());
    }
}
</PRE>

<H3> Implementation guidelines</H3>

<H3> Variants</H3>

Also can define a mutable companion class, such as <CODE>StringBuffer</CODE>
is to <CODE>String</CODE>.

Also think about File objects that can be closed, but not opened again.
This is a one time only kind of object, not quite immutable, but not
reusable. This kind of object also appears often and this kind of object
can kind of be passed down but not really.

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/Immutable.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
