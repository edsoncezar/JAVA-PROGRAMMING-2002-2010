<HTML>
<HEAD>
<TITLE>Appreciate the significance of the interface</TITLE>
<META name="description" content="An object-oriented design idiom from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/a4c5644c?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjDesWkshp" ><img src="..\cgi-bin\getimage.cgi\a4c5644c\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Appreciate the significance of the interface</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="interfacesabstract.html">Previous</A>&nbsp;|
<A href="whatcando.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<H2>
Java's Interface
</H2>
<UL>
<LI>
Guideline: <EM>Appreciate the significance of the</EM> <CODE>interface</CODE>.
<LI>
Understood the mechanics, but not the point
<LI>
"How were Java's interfaces an improvement over C++'s multiple inheritance
mechanism?"
<LI>
Clue: I was using interfaces a lot more than I ever used multiple inheritance
in C++
</UL>

<!--
<HR align="left" width="100%" size="4" noshade>
<H2>
The Diamond Problem
</H2>
<UL>
<LI>
<IMG align="right" src="../images/diamond.gif">
<PRE>
abstract class Animal {

    // (Don't do this at home)
    public int legCount;

    abstract void talk();
}

class Frog extends Animal {

    void talk() {

        System.out.println("Ribbit, ribbit.");
    }
}

class Dinosaur extends Animal {

    void talk() {
        System.out.println(
            "Oh I'm a dinosaur and I'm okay...");
    }
}

// (This won't compile, of course, because Java
// only supports single inheritance.)
class Frogosaur extends Frog, Dinosaur {
}
</PRE>
<LI>
Diamond problem ambiguity: which <CODE>legCount</CODE>, <CODE>Frog</CODE>'s
or <CODE>Dinosaur</CODE>'s?
<PRE>
Frogosaur frogosaur = new Frogosaur();
System.out.println(frogosaur.legCount);
</PRE>
<LI>
Also, upcasting may require changing the reference value, not just the
reference type.
<LI>
"V" problem ambiguity: which <CODE>talk()</CODE>?
<PRE>
Animal animal = new Frogosaur();
animal.talk();
</PRE>
<LI>
Interfaces solve the diamond problem because only interface, never
implementation, is multiply inherited
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Diamond Problem Solved
</H2>
<PRE>
interface Animal {

    // Can't declare an instance var

    void talk();
}

interface Frog extends Animal {

    void talk();
}

class FrogImpl implements Frog {

    public int legCount;

    public void talk() {

        System.out.println("Ribbit, ribbit.");
    }
}

class Dinosaur implements Animal {

    public int legCount;

    public void talk() {
        System.out.println(
            "Oh I'm a dinosaur and I'm okay...");
    }
}

// Could inherit Dinosaur's implentation, or as done here,
// delegate to FrogImpl's implementation

class Frogosaur extends Dinosaur implements Frog {
    private Frog frog = new FrogImpl();

    public void talk() {
        frog.talk();
    }
}
</PRE>
<UL>
<LI>
No ambiguity: This prints <CODE>Dinosaur</CODE>'s <CODE>legCount</CODE>:
<PRE>
Frogosaur frogosaur = new Frogosaur();
System.out.println(frogosaur.legCount);
</PRE>
<LI>
No ambiguity: This prints <CODE>"Ribbit, ribbit."</CODE>:
<PRE>
Animal animal = new Frogosaur();
animal.talk();
</PRE>
<LI>
Upcasting only requires a change of the reference type, never its value.
<LI>
Was this the key insight into the interface?
</UL>
-->

<HR align="left" width="100%" size="4" noshade>
<H2>Code Reuse with Composition</H2>
<UL>
<LI>
<CODE>OverdraftAccount</CODE> enlists the help of <CODE>Account</CODE> and
<CODE>OverdraftEventGenerator</CODE>
<LI>
Code Reuse: YES
<LI>
Polymorphism: NO
<BR><BR>
</FONT>
<CENTER>
<IMG src="images\compoonly.gif">
</CENTER>
</UL>
<UL>
<LI>
Code reuse: <CODE>OverdraftAccount</CODE> reuses (delegates to) <CODE>Account</CODE>'s
<CODE>getBalance()</CODE> method
<LI>
No polymorphism: Can't pass an <CODE>OverdraftAccount</CODE> object to a method
that expects an <CODE>Account</CODE>
</UL>
<PRE>
 1 package com.artima.examples.account.ex3;
 2
 3 <EM>/**
 4 * Represents a bank account. Money is stored in this account
 5 * in integral units. Clients can use this account to store
 6 * any kind of value, such as money or points, etc. The meaning
 7 * of the integral units stored in this account is a decision
 8 * of the client that instantiates the account. The maximum
 9 * amount of units that can be stored as the current balance of
10 * an &lt;code&gt;Account&lt;/code&gt; is Long.MAX_VALUE.
11 */</EM>
12 public class Account {
13
14     <EM>/**
15     * The current balance
16     */</EM>
17     private long balance;
18
19     <EM>/**
20     * Withdraws exactly the passed amount from the
21     * &lt;code&gt;Account&lt;/code&gt;. Subclasses must withdraw
22     * at least the passed amount, but may effectively withdraw more.
23     * For example, if a subclass includes the notion of
24     * a withrawal fee, the subclass's implementation of
25     * this method may charge that fee by decrementing it
26     * from the account at the time of withdrawal.
27     *
28     * @param amount amount to withdraw
29     * @returns amount withdrawn from the &lt;code&gt;Account&lt;/code&gt;
30     * @throws InsufficientFundsException if the &lt;code&gt;Account&lt;/code&gt;
31     *     contains insufficient funds for the requested withdrawal
32     */</EM>
33     public long withdraw(long amount)
34         throws InsufficientFundsException {
35
36         if (amount &gt; balance) {
37             throw new InsufficientFundsException(
38                 amount - balance);
39         }
40
41         balance -= amount;
42         return amount;
43     }
44
45     <EM>/**
46     * Deposits exactly the passed amount into the &lt;code&gt;Account&lt;/code&gt;.
47     * Subclasses may effectively deposit more or less than the passed
48     * amount into the &lt;code&gt;Account&lt;/code&gt;. For example, if a subclass
49     * includes the notion of funds matching, the subclass implementation
50     * of this method may match some or all of the deposited amount at
51     * the time of deposit, effectively increasing the deposited amount.
52     * Or, if a subclass includes the notion of
53     * a deposit fee, the subclass's implementation of
54     * this method may charge that fee by decrementing it
55     * from the account at the time of withdrawal, effectively reducing
56     * the deposited amount.
57     *
58     * @param amount amount to deposit
59     * @throws ArithmeticException if requested deposit would cause the
60     *     balance of this &lt;code&gt;Account&lt;/code&gt; to exceed Long.MAX_VALUE.
61     */</EM>
62     public void deposit(long amount) {
63
64         <EM>// TO DO: Check for overflow</EM>
65         balance += amount;
66     }
67
68     <EM>/**
69     * Gets the current balance of this &lt;code&gt;Account&lt;/code&gt;
70     *
71     * @returns the current balance
72     */</EM>
73     public long getBalance() {
74         return balance;
75     }
76 }
77

 1 package com.artima.examples.account.ex3;
 2
 3 import java.util.Set;
 4 import java.util.Iterator;
 5 import java.util.HashSet;
 6
 7 <EM>/**
 8 * A class that manages registration and unregistration of
 9 * &lt;code&gt;OverdraftListener&lt;/code&gt;s and the firing of
10 * &lt;code&gt;OverdraftEvent&lt;/code&gt;s.
11 *
12 * @author Bill Venners
13 */</EM>
14 class OverdraftEventGenerator {
15
16     private Set listeners = new HashSet();
17
18     <EM>/**
19     * Constructs a new &lt;code&gt;OverdraftEventGenerator&lt;/code&gt;. The
20     * &lt;code&gt;OverdraftEventGenerator&lt;/code&gt; starts its life with an
21     * empty listeners list.
22     */</EM>
23     public OverdraftEventGenerator() {
24     }
25
26     <EM>/**
27     * Adds the specified overdraft listener to receive overdraft events.
28     * If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception
29     * is thrown and no action is performed. If &lt;code&gt;l&lt;/code&gt; is already registered
30     * as a listener, no action is performed.
31     */</EM>
32     public synchronized void addOverdraftListener(OverdraftListener l) {
33
34         listeners.add(l);
35     }
36
37     <EM>/**
38     * Removes the specified overdraft listener so that it no longer
39     * receives overdraft events. This method
40     * performs no function, nor does it throw an exception, if the listener
41     * specified by the argument was not previously added to this
42     * component. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
43     * thrown and no action is performed.
44     */</EM>
45     public synchronized void removeOverdraftListener(OverdraftListener l) {
46
47         listeners.remove(l);
48     }
49
50     <EM>/**
51     * Fires overdraftOccurred events to registered listeners.
52     *
53     * @param event the &lt;code&gt;OverdraftEvent&lt;/code&gt; to propagate
54     */</EM>
55     void fireOverdraftOccurred(OverdraftEvent event) {
56
57         Iterator it = listeners.iterator();
58         while (it.hasNext()) {
59             OverdraftListener l = (OverdraftListener) it.next();
60             l.overdraftOccurred(event);
61         }
62     }
63
64     <EM>/**
65     * Fires overdraftRepaid events to registered listeners.
66     *
67     * @param event the &lt;code&gt;OverdraftEvent&lt;/code&gt; to propagate
68     */</EM>
69     void fireOverdraftRepaid(OverdraftEvent event) {
70
71         Iterator it = listeners.iterator();
72         while (it.hasNext()) {
73             OverdraftListener l = (OverdraftListener) it.next();
74             l.overdraftRepaid(event);
75         }
76     }
77 }

  1 package com.artima.examples.account.ex3;
  2
  3 <EM>/**
  4 * Represents a bank account with overdraft protection. Instances
  5 * of this class are instantiated with a specified maximum
  6 * overdraft. If a client attempts to withdraw more than the
  7 * current account balance, the bank may loan the amount in
  8 * excess of the balance to the client. The overdraft maximum
  9 * passed to an &lt;code&gt;OverdraftAccount&lt;/code&gt;'s constructor
 10 * is the maximum amount the bank will lend to the client in
 11 * this manner. When a client makes a deposit, the bank will
 12 * pay itself back first before increasing the account's balance.
 13 *
 14 * &lt;p&gt;
 15 * Money is stored in this account in integral units. Clients
 16 * can use this account to store any kind of value, such as money
 17 * or points, etc. The meaning of the integral units stored in
 18 * this account is a decision of the client that instantiates the
 19 * account. The maximum amount of units that can be stored as
 20 * the current balance of an &lt;code&gt;Account&lt;/code&gt; is Long.MAX_VALUE.
 21 */</EM>
 22 public class OverdraftAccount {
 23
 24     <EM>/**
 25     * Helper back-end object
 26     */</EM>
 27     private Account account = new Account();
 28     private OverdraftEventGenerator eventGen = new OverdraftEventGenerator();
 29
 30     <EM>/**
 31     * The maximum amount the bank will loan to the client.
 32     */</EM>
 33     private final long overdraftMax;
 34
 35     <EM>/**
 36     * The current amount the bank has loaned to the client
 37     * which has not yet been repaid. This must be zero to
 38     * overdraftMax.
 39     */</EM>
 40     private long overdraft;
 41
 42     <EM>/**
 43     * Constructs a new &lt;code&gt;OverdraftAccount&lt;/code&gt; with the
 44     * passed &lt;code&gt;overdraftMax&lt;/code&gt;.
 45     *
 46     * @param overdraftMax the maximum amount the bank will loan
 47     *     to the client
 48     */</EM>
 49     public OverdraftAccount(long overdraftMax) {
 50         this.overdraftMax = overdraftMax;
 51     }
 52
 53     <EM>/**
 54     * Adds the specified overdraft listener to receive overdraft events
 55     * from this &lt;code&gt;OverdraftAccount&lt;/code&gt;. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception
 56     * is thrown and no action is performed. If &lt;code&gt;l&lt;/code&gt; is already registered
 57     * as a listener, no action is performed.
 58     */</EM>
 59     public synchronized void addOverdraftListener(OverdraftListener l) {
 60
 61         eventGen.addOverdraftListener(l);
 62     }
 63
 64     <EM>/**
 65     * Removes the specified overdraft listener so that it no longer
 66     * receives overdraft events from this &lt;code&gt;OverdraftAccount&lt;/code&gt;. This method
 67     * performs no function, nor does it throw an exception, if the listener
 68     * specified by the argument was not previously added to this
 69     * component. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
 70     * thrown and no action is performed.
 71     */</EM>
 72     public synchronized void removeOverdraftListener(OverdraftListener l) {
 73
 74         eventGen.removeOverdraftListener(l);
 75     }
 76
 77     <EM>/**
 78     * Returns the current overdraft, the amount the bank has
 79     * loaned to the client that has not yet been repaid.
 80     *
 81     * @returns the current overdraft
 82     */</EM>
 83     public long getOverdraft() {
 84         return overdraft;
 85     }
 86
 87     <EM>/**
 88     * Returns the overdraft maximum, the maximum amount the
 89     * bank will allow the client to owe it. For each instance
 90     * of &lt;code&gt;OverdraftAccount&lt;/code&gt;, the overdraft maximum
 91     * is constant.
 92     *
 93     * @returns the overdraft maximum
 94     */</EM>
 95     public long getOverdraftMax() {
 96         return overdraftMax;
 97     }
 98
 99     <EM>/**
100     * Gets the current balance of this &lt;code&gt;OverdraftAccount&lt;/code&gt;
101     *
102     * @returns the current balance
103     */</EM>
104     public long getBalance() {
105         return account.getBalance();
106     }
107
108     <EM>/**
109     * Withdraws exactly the passed amount from the
110     * &lt;code&gt;Account&lt;/code&gt;. If the passed amount is
111     * less than or equal to the current balance, all withdrawn
112     * funds will be taken from the balance, and the balance
113     * will be decremented by the passed amount. If the passed amount
114     * exceeds the current balance, the bank may loan the client the
115     * difference. The bank will make the loan only if the difference
116     * between the passed amount and the balance is less than or equal to
117     * the available overdraft. The available overdraft is equal to
118     * the current overdraft (the amount already loaned to the client and
119     * not yet repaid), subtracted from the overdraft maximum, which
120     * is passed to the constructor of any &lt;code&gt;OverdraftAccount&lt;/code&gt;.
121     *
122     * &lt;p&gt;
123     * If the passed amount less the current balance is less than or equal
124     * to the available overdraft, the &lt;code&gt;withdraw&lt;/code&gt; method returns
125     * the requested amount, sets the current balance to zero, and records
126     * the loan. Otherwise, if the passed amount less the current balance
127     * exceeds the available overdraft, the &lt;code&gt;withdraw&lt;/code&gt; method throws
128     * &lt;code&gt;InsufficientFundsException&lt;/code&gt;.
129     *
130     * @param amount amount to withdraw
131     * @returns amount withdrawn from the &lt;code&gt;Account&lt;/code&gt;
132     * @throws InsufficientFundsException if the &lt;code&gt;Account&lt;/code&gt;
133     *     contains insufficient funds for the requested withdrawal
134     */</EM>
135     public long withdraw(long amount)
136         throws InsufficientFundsException {
137
138         long balance = account.getBalance();
139         if (balance &gt;= amount) {
140
141             <EM>// Balance has sufficient funds, just take the</EM>
142             <EM>// money from the balance.</EM>
143             balance -= amount;
144             return amount;
145         }
146
147         long shortfall = amount - balance;
148         long extraAvailable = overdraftMax - overdraft;
149
150         if (shortfall &gt; extraAvailable) {
151             throw new InsufficientFundsException(shortfall - extraAvailable);
152         }
153         overdraft += shortfall;
154         account.withdraw(amount - shortfall);
155
156         eventGen.fireOverdraftOccurred(new OverdraftEvent(this, overdraft));
157
158         return amount;
159     }
160
161     <EM>/**
162     * Deposits exactly the passed amount into the &lt;code&gt;Account&lt;/code&gt;.
163     * If the current overdraft is zero, the balance will be increased
164     * by the passed amount. Otherwise, the bank will attempt to pay
165     * off the overdraft first, before increasing the current balance
166     * by the amount remaining after the overdraft is repaid, if any.
167     *
168     * &lt;p&gt;
169     * For example, if the balance is 200, the overdraft is 100, and the
170     * &lt;code&gt;deposit&lt;/code&gt; method is invoked with a passed &lt;code&gt;amount&lt;/code&gt;
171     * of 50, the bank would use all 50 of those monetary units to pay down
172     * the overdraft. The overdraft would be reduced to 50 and the balance would
173     * remain at 200. If subsequently, the client deposits another 100 units,
174     * the bank would use 50 of those units to pay off the overdraft loan and
175     * direct the remaining 50 into the balance. The new overdraft would
176     * be 0 and the new balance would be 250.
177     *
178     * @param amount amount to deposit
179     * @throws ArithmeticException if requested deposit would cause the
180     *     balance of this &lt;code&gt;Account&lt;/code&gt; to exceed Long.MAX_VALUE.
181     */</EM>
182     public void deposit(long amount) {
183         if (overdraft &gt; 0) {
184             if (amount &lt; overdraft) {
185                 overdraft -= amount;
186             }
187             else {
188                 long diff = amount - overdraft;
189                 overdraft = 0;
190                 account.deposit(diff);
191             }
192
193             eventGen.fireOverdraftRepaid(new OverdraftEvent(this, overdraft));
194         }
195         else {
196             account.deposit(amount);
197         }
198     }
199 }
</PRE>

<HR align="left" width="100%" size="4" noshade>
<H2>Full Blown Multiple Inheritance</H2>
<UL>
<LI>
Code Reuse: YES
<LI>
Polymorphism: YES
<BR><BR>
</FONT>
<CENTER>
<IMG src="images\fullblown.gif">
</CENTER>
</UL>
<UL>
<LI>
Code reuse: <CODE>OverdraftAccount</CODE> reuses (inherits) <CODE>Account</CODE>'s
<CODE>getBalance()</CODE> method
<LI>
Polymorphism: Can pass an <CODE>OverdraftAccount</CODE> object to a method
that expects an <CODE>Account</CODE>
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>The ABC Alternative</H2>
<UL>
<LI>
Abstract Base Classes (ABCs) are a multiple inheritance special case
<LI>
Polymorphism: YES
<LI>
Code Reuse: NO
<LI>
<EM>(ABCs give you the opposite of composition)</EM>
<BR><BR>
</FONT>
<CENTER>
<IMG src="images\abccase.gif">
</CENTER>
</UL>
<UL>
<LI>
No code reuse: <CODE>OverdraftAccount</CODE> can't reuse <CODE>Account</CODE>'s
<CODE>getBalance()</CODE> method, because it is abstract
<LI>
Polymorphism: Can pass an <CODE>OverdraftAccount</CODE> object to a method
that expects an <CODE>Account</CODE>
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>Multiple Inheritance Usefulness</H2>
<UL>
<LI>
Full blown multiple inheritance gives you more code reuse and polymorphism<BR>
<BLOCKQUOTE>
Useful in 5% of design situations
</BLOCKQUOTE>
<LI>
ABC special case of multiple inheritance gives you more polymorphism, but
no code reuse<BR>
<BLOCKQUOTE>
Useful in 50% of design situations
</BLOCKQUOTE>
<LI>
James Gosling took the 50% case and called it the <CODE>interface</CODE>
<LI>
But left the 5% case out. (Can mimic full blown multiple inheritance with
<CODE>interface</CODE>s and composition)
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>Composition with <CODE>interface</CODE>s</H2>
<UL>
<LI>
Polymorphism: YES
<LI>
Code Reuse: YES
<BR><BR>
</FONT>
<CENTER>
<IMG src="images\compoint.gif">
</CENTER>
</UL>
<PRE>
</PRE>
<UL>
<LI>
Code reuse: <CODE>PaperDocument</CODE> reuses <CODE>Scanner</CODE>'s
<CODE>scan()</CODE> method
<LI>
Polymorphism: Can pass a <CODE>PaperDocument</CODE> object to a method
that expects a <CODE>Printable</CODE>
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>Why are <CODE>interface</CODE>s so useful?</H2>
<UL>
<LI>
Often, semantic contract of classes to some extent involves implementation (contract is less abstract)
<LI>
ABCs (interfaces): allow you to say what services an object provides, without
saying what that object <EM>is</EM> (contract is more abstract)
<LI>
Full-blown MI: what an object <EM>does</EM> intermingles
with what an object <EM>is</EM>
<LI>
Interfaces give you implementation choices: an abstract method inherited from an
<CODE>interface</CODE> can be implemented in many ways:
<UL>
<LI>explicitly
<LI>inherited from a superclass
<LI>delegated to back-end objects in a composition relationship
</UL>
<LI>
Interface method parameter and return types allow you to program to interfaces,
not implementations -- makes code very versatile
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>
Interfaces and C++
</H2>
<UL>
<LI>
If interfaces are so useful in Java, why is it that you did
not make use of pure virtual base classes in C++?
<LI>
Is there some difference between them which make the Java
interface easier to use?
<LI>
Has Java, by disallowing multiple implementation inheritance,
made you take the step of separating implementation from
interface in a way you would not have done without being
forced to?
<LI>
Also, if you now went back to C++ would you now make much
more use of virtual base classes than you did before?
</UL>

<P>
Doesn't make sense for ArrayList to be superclass of LinkedList, because LinkedList has no
common implementation interest with ArrayList. Class extension makes sense when there is
common implementation interest -- you can see it as factoring out common code into one
place. But you can do the same kind of factoring with composition. And, like the factoring
of moving code to data described in Guideline 2, you do this factoring ahead of time
in an oo design.
</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/SigInterface.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
