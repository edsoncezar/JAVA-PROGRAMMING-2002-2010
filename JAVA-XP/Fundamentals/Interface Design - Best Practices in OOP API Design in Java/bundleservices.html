<HTML>
<HEAD>
<TITLE>Objects as Bundles of Behavior</TITLE>
<META name="description" content="Design guideline from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/c8644ca4?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjNJava" ><img src="..\cgi-bin\getimage.cgi\c8644ca4\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Guideline 2</SPAN><BR>
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">See objects as bundles of behavior, not bundles of data</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="sigobjects.html">Previous</A>&nbsp;|
<A href="serviceoriented.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
One of the most basic object-oriented ideas is encapsulation -- associating data with code that
manipulates the data. The data, stored in instance variables, represents the object's state.
The code, stored in instance methods, represents the object's behavior.
Because of encapsulation, therefore, you can think of objects as either bundles of data,
bundles of behavior, or both. To reap the greatest benefit from encapsulation, however, you
should think of objects primarily as bundles of behavior, not bundles of data.
You should think of objects less as carriers of information, embodied in the data, and
more as providers of services, represented by the behavior.

<P>
Why should you think of objects as bundles of services?
If data is exposed, code that manipulates that data gets spread across
the program.
If higher-level services are exposed, code that manipulates the data is concentrated
in one place: the class.
This concentration reduces code duplication,
localizes bug fixes, and makes it easier to achieve robustness.

<H1>A Data-Oriented Matrix</H1>
<P>
Consider the <CODE>Matrix</CODE> class shown in Listing 2-1, whose instances act more like
bundles of data than bundles of behavior. Although the instance variables declared in this
class are private, the only services it offers besides <CODE>equals</CODE>, <CODE>hashcode</CODE>,
and <CODE>clone</CODE> are accessor methods <CODE>set</CODE>, <CODE>get</CODE>, <CODE>getCols</CODE>,
and <CODE>getRows</CODE>.
These accessor methods are very data oriented, because they don't
do anything interesting with the object's state. They just provide clients with access to
the state.

<P>
<STRONG>Listing 2-1. A data-oriented matrix.</STRONG>

<PRE>
  1 package com.artima.examples.matrix.ex1;
  2
  3 /**
  4 * Represents a matrix each of whose elements is an &lt;CODE&gt;int&lt;/CODE&gt;.
  5 */
  6 public class Matrix {
  7
  8     private int[][] elements;
  9     private int rowCount;
 10     private int colCount;
 11
 12     /**
 13     * Construct a new &lt;EM&gt;square zero matrix&lt;/EM&gt; whose order is determined
 14     * by the passed number of rows. (The matrix is square. It has the
 15     * same number of rows and columns.)
 16     * All elements of the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 17     * will be initialized to zero.
 18     */
 19     public Matrix(int rows) {
 20         elements = new int[rows][rows];
 21         rowCount = rows;
 22         colCount = rows;
 23     }
 24
 25     /**
 26     * Construct a new &lt;EM&gt;zero matrix&lt;/EM&gt; whose order is determined
 27     * by the passed number of rows and columns. The order is (rows by columns).
 28     * All elements of the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 29     * will be initialized to zero.
 30     *
 31     * @param rows The number of rows in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 32     * @param cols The number of columns in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 33     * @exception IllegalArgumentException if &lt;code&gt;rows&lt;/code&gt; or &lt;code&gt;cols&lt;/code&gt; is less than zero
 34     */
 35     public Matrix(int rows, int cols) {
 36         if (rows &lt; 0 || cols &lt; 0) {
 37             throw new IllegalArgumentException();
 38         }
 39         elements = new int[rows][cols];
 40         rowCount = rows;
 41         colCount = cols;
 42     }
 43
 44     /**
 45     * Construct a new &lt;CODE&gt;Matrix&lt;/CODE&gt; whose elements will be initialized
 46     * with values from the passed two-dimensional array of &lt;CODE&gt;int&lt;/CODE&gt;s.
 47     * The order of the matrix will be determined by the sizes of the passed arrays.
 48     * For example, a two dimensional array constructed with &lt;CODE&gt;new int[4][9]&lt;/CODE&gt;,
 49     * would yield a matrix whose order is 4 by 9. The lengths of each of the arrays
 50     * held from the initial array must be the same. The two-dimensional array passed
 51     * as &lt;CODE&gt;init&lt;/CODE&gt; will not be used as part of the state of the newly constructed
 52     * &lt;CODE&gt;Matrix&lt;/CODE&gt; object.
 53     */
 54     public Matrix(int[][] init) {
 55
 56         checkValidity(init);
 57
 58         elements = (int[][]) init.clone();
 59         rowCount = init.length;
 60         colCount = init[0].length;
 61     }
 62
 63     /**
 64     * Returns the element value at the specified row and column.
 65     */
<STRONG> 66     public int get(int row, int col) {
 67         checkIndices(row, col);
 68         return elements[row][col];
 69     }
 70
 71     /**
 72     * Sets the element value at the specified row and column to the
 73     * passed &lt;CODE&gt;value&lt;/CODE&gt;.
 74     */
 75     public void set(int row, int col, int value) {
 76         checkIndices(row, col);
 77         elements[row][col] = value;
 78     }
 79
 80     /**
 81     * Returns the number of rows in this matrix.
 82     */
 83     public int getRows() {
 84         return rowCount;
 85     }
 86
 87     /**
 88     * Returns the number of cols in this matrix.
 89     */
 90     public int getCols() {
 91         return colCount;
 92     }</STRONG>
 93
 94     /**
 95     * Ensures passed two-dimensional array is valid
 96     * for initializing a &lt;CODE&gt;Matrix&lt;/CODE&gt; object.
 97     */
 98     private static void checkValidity(int[][] val) {
 99
100         try {
101             int rows = val.length;
102             if (rows == 0) {
103                 throw new IllegalArgumentException();
104             }
105             int cols = val[0].length;
106             if (cols == 0) {
107                 throw new IllegalArgumentException();
108             }
109             for (int i = 1; i &lt; rows; ++i) {
110                 if (val[i].length != cols) {
111                     throw new IllegalArgumentException();
112                 }
113             }
114         }
115         catch (NullPointerException e) {
116             throw new IllegalArgumentException();
117         }
118     }
119
120     /**
121     * Ensures passed row and column represent valid indices into
122     * this &lt;CODE&gt;Matrix&lt;/CODE&gt;.
123     */
124     private void checkIndices(int row, int col) {
125         if (row &gt;= rowCount || row &lt; 0 || col &gt;= colCount || col &lt; 0) {
126             throw new IndexOutOfBoundsException();
127         }
128     }
129 }
</pre>

<P>
Listing 2-2 shows an example of a client of the data-oriented
<CODE>Matrix</CODE>. This client wants
to add two matrices and print the sum to the standard output:

<P>
<STRONG>Listing 2-2. A client of the data-oriented matrix.</STRONG>

<PRE>
 1 package com.artima.examples.matrix.ex1;
 2
 3 class Example1 {
 4
 5     public static void main(String[] args) {
 6
 7         int[][] init1 = { {2, 2}, {2, 2} };
 8         int[][] init2 = { {1, 2}, {3, 4} };
 9
10         Matrix m1 = new Matrix(init1);
11         Matrix m2 = new Matrix(init2);
12
13         // Add m1 & m2, store result in a new Matrix object
<STRONG>14         Matrix sum = new Matrix(2, 2);
15         for (int i = 0; i < 2; ++i) {
16             for (int j = 0; j < 2; ++j) {
17                 int addend1 = m1.get(i, j);
18                 int addend2 = m2.get(i, j);
19                 sum.set(i, j, addend1 +  addend2);
20             }
21         }</STRONG>
22
23         // Print out the sum
<STRONG>24         System.out.print("Sum: {");
25         for (int i = 0; i < 2; ++i) {
26             for (int j = 0; j < 2; ++j) {
27                 int val = sum.get(i, j);
28                 System.out.print(val);
29                 if (i == 0 || j == 0) {
30                     System.out.print(", ");
31                 }
32             }
33         }</STRONG>
34         System.out.println("}");
35
36     }
37 }
</pre>

<P>
To add the matrices, <CODE>Example1</CODE> in Listing 2-2 first instantiates a matrix to hold
the sum. Then, for each row and column, <CODE>Example1</CODE> retrieves an element
value from each addend matrix using <CODE>get</CODE>. <CODE>Example1</CODE> adds the two values
and stuffs the result into the corresponding row and column of the sum matrix using <CODE>set</CODE>.

<P>
This all works fine, but imagine if there were 50 different places in your system where
you needed to add two matrices. The code shown from lines 14 to 21 of <CODE>Example1</CODE>
would have to be replicated in 50 different places. Perhaps in 46 of those places would perform
flawless matrix addition, but in four of those places a bug existed.
If you detected and fixed a bug in one of those four buggy places, you'd still have
three matrix addition bugs lurking elsewhere.
A similar problem would exist in printing out the value of the matrix. If there were
50 places where you wanted to print out a matrix, the code shown in lines 24 to 33 of
<CODE>Example1</CODE> would appear in 50 different places, with the same maintanence
problems.

<H1>A Service-Oriented Matrix</H1>

<P>
By contrast, consider the <CODE>Matrix</CODE> class shown in Listing 2-3, which you can think of
as a second iteration in the design of this class.
In this iteration, <CODE>Matrix</CODE> retains the <CODE>get</CODE> methods that return information
about the object's state, but the <CODE>set</CODE> method of the previous iteration has been
replaced by more service-oriented methods: <CODE>add</CODE>, <CODE>subtract</CODE>, and <CODE>multiply</CODE>.
In addition, a <CODE>toString</CODE> method has been added, which produces a <CODE>String</CODE>
representing the state of the <CODE>Matrix</CODE>.

<P>
<STRONG>Listing 2-3. A service-oriented matrix.</STRONG>

<PRE>
  1 package com.artima.examples.matrix.ex2;
  2
  3 import java.io.Serializable;
  4
  5 /**
  6 * A two-dimensional matrix of &lt;CODE&gt;int&lt;/CODE&gt;s.
  7 *
  8 * &lt;P&gt;
  9 * The &lt;em&gt;order&lt;/em&gt; of
 10 * the matrix is its number of rows and columns. For example, the order
 11 * of a matrix with 5 rows and 4 columns is "5 by 4." A matrix with the
 12 * same number of rows and columns, such as a 3 by 3 matrix, is a
 13 * &lt;em&gt;square matrix&lt;/em&gt;. A matrix all of whose elements is zero is
 14 * a &lt;em&gt;zero matrix&lt;/em&gt;.
 15 *
 16 * &lt;P&gt;
 17 * Instances of &lt;CODE&gt;Matrix&lt;/CODE&gt; are immutable.
 18 */
 19 public class Matrix implements Serializable, Cloneable {
 20
 21     private int[][] elements;
 22     private int rowCount;
 23     private int colCount;
 24
 25     /**
 26     * Construct a new square &lt;code&gt;Matrix&lt;/code&gt; whose order is determined
 27     * by the passed number of rows.
 28     * Yields a zero matrix, i.e., all elements of the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 29     * will be initialized to zero.
 30     *
 31     * @param rows The number of rows and cols in the new square &lt;CODE&gt;Matrix&lt;/CODE&gt;
 32     * @exception IllegalArgumentException if &lt;code&gt;rows&lt;/code&gt; or &lt;code&gt;cols&lt;/code&gt; is less than 1
 33     */
 34     public Matrix(int rows) {
 35        if (rows &lt; 1) {
 36             throw new IllegalArgumentException();
 37         }
 38         elements = new int[rows][rows];
 39         rowCount = rows;
 40         colCount = rows;
 41     }
 42
 43     /**
 44     * Construct a new &lt;EM&gt;zero matrix&lt;/EM&gt; whose order is determined
 45     * by the passed number of rows and columns. The order is (rows by columns).
 46     * Yields a zero matrix, i.e., all elements of the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 47     * will be initialized to zero.
 48     *
 49     * @param rows The number of rows in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 50     * @param cols The number of columns in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 51     * @exception IllegalArgumentException if &lt;code&gt;rows&lt;/code&gt; or &lt;code&gt;cols&lt;/code&gt; is less than 1
 52     */
 53     public Matrix(int rows, int cols) {
 54         if (rows &lt; 1 || cols &lt; 1) {
 55             throw new IllegalArgumentException();
 56         }
 57         elements = new int[rows][cols];
 58         rowCount = rows;
 59         colCount = cols;
 60     }
 61
 62     /**
 63     * Construct a new &lt;CODE&gt;Matrix&lt;/CODE&gt; whose elements will be initialized
 64     * with values from the passed two-dimensional array of &lt;CODE&gt;int&lt;/CODE&gt;s.
 65     * The order of the matrix will be determined by the sizes of the passed arrays.
 66     * For example, a two dimensional array constructed with &lt;CODE&gt;new int[4][9]&lt;/CODE&gt;,
 67     * would yield a matrix whose order is 4 by 9. The lengths of each of the arrays
 68     * held from the initial array must be the same. The two-dimensional array passed
 69     * as &lt;CODE&gt;init&lt;/CODE&gt; will not be used as part of the state of the newly constructed
 70     * &lt;CODE&gt;Matrix&lt;/CODE&gt; object.
 71     *
 72     * @param rows The number of rows in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 73     * @param cols The number of columns in the new &lt;CODE&gt;Matrix&lt;/CODE&gt;
 74     * @exception IllegalArgumentException if the length of any passed array is zero,
 75     *    or if the length of all the secondary arrays are not equivalent.
 76     */
 77     public Matrix(int[][] init) {
 78
 79         checkValidity(init);
 80
 81         elements = (int[][]) init.clone();
 82         rowCount = init.length;
 83         colCount = init[0].length;
 84     }
 85
 86     /**
 87     * Returns the element value at the specified row and column.
 88     *
 89     * @param row The row of the element whose value is to be returned
 90     * @param col The column of the element whose value is to be returned
 91     * @return value of element at specified row and column
 92     * @exception IndexOutOfBoundsException if &lt;code&gt;row&lt;/code&gt; is
 93     *    less than zero or greater than the number of rows minus 1, or if
 94     *    &lt;code&gt;col&lt;/code&gt; is less than 0 or greater than the number of
 95     *    columns minus 1.
 96     */
 97     public int get(int row, int col) {
 98         checkIndices(row, col);
 99         return elements[row][col];
100     }
101
102     /**
103     * Returns the number of rows in this &lt;code&gt;Matrix&lt;/code&gt;.
104     *
105     * @return number of rows in this &lt;code&gt;Matrix&lt;/code&gt;
106     */
107     public int getRows() {
108         return rowCount;
109     }
110
111     /**
112     * Returns the number of columns in this &lt;code&gt;Matrix&lt;/code&gt;.
113     *
114     * @return number of columns in this &lt;code&gt;Matrix&lt;/code&gt;
115     */
116     public int getCols() {
117         return colCount;
118     }
119
120     /**
121     * Adds the passed &lt;code&gt;Matrix&lt;/code&gt; to this one.
122     * The order of the passed &lt;code&gt;Matrix&lt;/code&gt; must be identical
123     * to the order of this &lt;code&gt;Matrix&lt;/code&gt;.
124     *
125     * &lt;P&gt;
126     * The sum of two &lt;code&gt;Matrix&lt;/code&gt; objects is a &lt;code&gt;Matrix&lt;/code&gt;
127     * of the same order of the two addends. Each element of the sum
128     * &lt;code&gt;Matrix&lt;/code&gt; is equal to the sum of the corresponding elements
129     * in the &lt;code&gt;Matrix&lt;/code&gt; addends. For example:
130     *
131     * &lt;PRE&gt;
132     * | 1 2 3 |   |  9 -8  7 |   | 10 -6 10 |
133     * | 4 5 6 | + | -6  5 -4 | = | -2 10  2 |
134     * | 7 8 9 |   | -3  2 -1 |   |  4 10  8 |
135     * &lt;/PRE&gt;
136     *
137     * &lt;P&gt;
138     * This method does not throw any exception on overflow.
139     *
140     * @param addend the &lt;code&gt;Matrix&lt;/code&gt; to add to this one
141     * @return The sum of this &lt;code&gt;Matrix&lt;/code&gt; and the passed &lt;code&gt;Matrix&lt;/code&gt;
142     * @exception IllegalArgumentException if the order of the passed
143     *     &lt;code&gt;Matrix&lt;/code&gt; object differs from the order of this &lt;code&gt;Matrix&lt;/code&gt;
144     */
<STRONG>145     public Matrix add(Matrix addend) {
146
147         // Make sure addend has the same order as this matrix
148         if ((addend.rowCount != rowCount) || (addend.colCount != colCount)) {
149             throw new IllegalArgumentException();
150         }
151
152         Matrix retVal = new Matrix(elements);
153         for (int row = 0; row &lt; rowCount; ++row) {
154             for (int col = 0; col &lt; colCount; ++col) {
155                 retVal.elements[row][col] += addend.elements[row][col];
156             }
157         }
158         return retVal;
159     }</STRONG>
160
161     /**
162     * Subtracts the passed &lt;code&gt;Matrix&lt;/code&gt; from this one.
163     * The order of the passed &lt;code&gt;Matrix&lt;/code&gt; must be identical
164     * to the order of this &lt;code&gt;Matrix&lt;/code&gt;. Returned &lt;code&gt;Matrix&lt;/code&gt;
165     * equals the sum of this &lt;code&gt;Matrix&lt;/code&gt; and the negation of the
166     * passed &lt;code&gt;Matrix&lt;/code&gt;.
167     *
168     * &lt;P&gt;
169     * The difference of two &lt;code&gt;Matrix&lt;/code&gt; objects is a &lt;code&gt;Matrix&lt;/code&gt;
170     * of the same order of the minuend and subtrahend. Each element of the sum
171     * &lt;code&gt;Matrix&lt;/code&gt; is equal to the difference of the corresponding elements
172     * in the minuend (this) and subtrahend (passed) &lt;code&gt;Matrix&lt;/code&gt; objects.
173     * For example:
174     *
175     * &lt;PRE&gt;
176     * | 1 2 3 |   |  9 -8  7 |   | -8 10 -4 |
177     * | 4 5 6 | - | -6  5 -4 | = | 10  0 10 |
178     * | 7 8 9 |   | -3  2 -1 |   | 10  6 10 |
179     * &lt;/PRE&gt;
180     *
181     * &lt;P&gt;
182     * This method does not throw any exception on overflow.
183     *
184     * @param subtrahend the &lt;code&gt;Matrix&lt;/code&gt; to subtract from this one
185     * @return The difference of this &lt;code&gt;Matrix&lt;/code&gt; and the passed &lt;code&gt;Matrix&lt;/code&gt;
186     * @exception IllegalArgumentException if the order of the passed
187     *     &lt;code&gt;Matrix&lt;/code&gt; object differs from the order of this &lt;code&gt;Matrix&lt;/code&gt;
188     */
189     public Matrix sub(Matrix subtrahend) {
190
191         // To be subtracted, subtrahend must have the same order
192         if ((subtrahend.rowCount != rowCount) || (subtrahend.colCount != colCount)) {
193             throw new IllegalArgumentException();
194         }
195
196         Matrix retVal = new Matrix(elements);
197         for (int row = 0; row &lt; rowCount; ++row) {
198             for (int col = 0; col &lt; colCount; ++col) {
199                 retVal.elements[row][col] -= subtrahend.elements[row][col];
200             }
201         }
202         return retVal;
203     }
204
205     /**
206     * Multiplies this matrix by the passed scalar. Returns
207     * a new matrix representing the result of the multiplication.
208     * To negate a matrix, for example, just multiply it by
209     * -1.
210     *
211     * &lt;P&gt;
212     * The product of a &lt;code&gt;Matrix&lt;/code&gt; and a scalar is a &lt;code&gt;Matrix&lt;/code&gt;
213     * of the same order as the &lt;code&gt;Matrix&lt;/code&gt; multiplicand. Each element of the product
214     * &lt;code&gt;Matrix&lt;/code&gt; is equal to the product of the corresponding element
215     * in the &lt;code&gt;Matrix&lt;/code&gt; multiplicand and the scalar multiplier. For example:
216     *
217     * &lt;PRE&gt;
218     *      | 1 2 3 |   |  -2  -4  -6 |
219     * -2 * | 4 5 6 | = |  -8 -10 -12 |
220     *      | 7 8 9 |   | -14 -16 -18 |
221     * &lt;/PRE&gt;
222     *
223     * &lt;P&gt;
224     * This method does not throw any exception on overflow.
225     *
226     * @param addend the &lt;code&gt;Matrix&lt;/code&gt; to add to this one
227     * @return The sum of this &lt;code&gt;Matrix&lt;/code&gt; and the passed &lt;code&gt;Matrix&lt;/code&gt;
228     * @exception IllegalArgumentException if the order of the passed
229     *     &lt;code&gt;Matrix&lt;/code&gt; object differs from the order of this &lt;code&gt;Matrix&lt;/code&gt;
230     */
231     public Matrix mult(int scalar) {
232
233         Matrix retVal = new Matrix(elements);
234         for (int row = 0; row &lt; rowCount; ++row) {
235             for (int col = 0; col &lt; colCount; ++col) {
236                 retVal.elements[row][col] *= scalar;
237             }
238         }
239         return retVal;
240     }
241
242     /**
243     * Multiplies this &lt;code&gt;Matrix&lt;/code&gt; (the multiplicand) by the passed
244     * &lt;code&gt;Matrix&lt;/code&gt; (the multiplier). The number of columns in this
245     * multiplicand &lt;code&gt;Matrix&lt;/code&gt; must equal the number rows in the
246     * passed multiplier &lt;code&gt;Matrix&lt;/code&gt;.
247     *
248     * &lt;P&gt;
249     * The product of two &lt;code&gt;Matrix&lt;/code&gt; objects is a &lt;code&gt;Matrix&lt;/code&gt; that has
250     * the same number of rows as the multiplicand (this &lt;code&gt;Matrix&lt;/code&gt;) and the
251     * same number of columns as the multiplier (passed &lt;code&gt;Matrix&lt;/code&gt;).
252     * Each element of the product &lt;code&gt;Matrix&lt;/code&gt; is equal to sum of the products
253     * of the elements of corresponding multiplicand row and multiplier column.
254     * For example:
255     *
256     * &lt;PRE&gt;
257     * | 0 1 |   | 6 7 |   | (0*6 + 1*8) (0*7 + 1*9) |   |  8  9 |
258     * | 2 3 | * | 8 9 | = | (2*6 + 3*8) (2*7 + 3*9) | = | 36 41 |
259     * | 4 5 |             | (4*6 + 5*8) (4*7 + 5*9) |   | 64 73 |
260     * &lt;/PRE&gt;
261     *
262     * &lt;P&gt;
263     * This method does not throw any exception on overflow.
264     *
265     * @param multiplier the &lt;code&gt;Matrix&lt;/code&gt; to multiply to this one
266     * @return A new &lt;code&gt;Matrix&lt;/code&gt; representing the product of this
267     *    &lt;code&gt;Matrix&lt;/code&gt; and the passed &lt;code&gt;Matrix&lt;/code&gt;
268     * @exception IllegalArgumentException if the number of rows of the passed
269     *     &lt;code&gt;Matrix&lt;/code&gt; object differs from the number of columns of
270     *     this &lt;code&gt;Matrix&lt;/code&gt;
271     */
272     public Matrix mult(Matrix multiplier) {
273
274         // To do a matrix multiplication, the number of columns in this
275         // matrix must equal the number of rows of the passed multiplicand.
276         if (colCount != multiplier.rowCount) {
277             throw new IllegalArgumentException();
278         }
279
280         // Calculate order of result
281         int resultRows = rowCount;
282         int resultCols = multiplier.colCount;
283
284         // Create array for result
285         int[][] resultArray = new int[resultRows][resultCols];
286
287         Matrix retVal = new Matrix(elements);
288         for (int row = 0; row &lt; resultRows; ++row) {
289             for (int col = 0; col &lt; resultCols; ++col) {
290                 for (int i = 0; i &lt; colCount; ++i) {
291                     resultArray[row][col] += elements[row][i] * multiplier.elements[i][col];
292                 }
293             }
294         }
295         return retVal;
296     }
297
298     /**
299     * Returns a &lt;code&gt;String&lt;/code&gt; that contains the
300     * integer values of the elements of this
301     * &lt;code&gt;Matrix&lt;/code&gt;. Each row of element values
302     * is enclosed in parentheses and separated by
303     * commas, and the entire result is enclosed in
304     * a set of parentheses. For example, for the matrix:
305     *
306     * &lt;PRE&gt;
307     * | 1 2 3 |
308     * | 4 5 6 |
309     * | 7 8 9 |
310     * &lt;/PRE&gt;
311     *
312     * This method would return the string:
313     *
314     * &lt;PRE&gt;
315     * ((1, 2, 3), (4, 5, 6), (7, 8, 9))
316     * &lt;/PRE&gt;
317     *
318     * @return A new &lt;code&gt;String&lt;/code&gt; representation of the state of
319     *    this &lt;code&gt;Matrix&lt;/code&gt;
320     */
<STRONG>321     public String toString() {
322
323         StringBuffer retVal = new StringBuffer("(");
324
325         for (int row = 0; row &lt; rowCount; ++row) {
326             retVal.append("(");
327             for (int col = 0; col &lt; colCount; ++col) {
328                 retVal.append(elements[row][col]);
329                 if (col != colCount - 1) {
330                     retVal.append(", ");
331                 }
332             }
333             retVal.append(")");
334             if (row != rowCount - 1) {
335                 retVal.append(", ");
336             }
337         }
338         retVal.append(")");
339         return retVal.toString();
340     }</STRONG>
341
342     /**
343     * Clones this object.
344     *
345     * @return A clone of this &lt;code&gt;Matrix&lt;/code&gt;
346     */
347     public Object clone() {
348         try {
349             Matrix clone = (Matrix) super.clone();
350             clone.elements = new int[rowCount][colCount];
351
352             for (int row = 0; row &lt; rowCount; ++row) {
353                 for (int col = 0; col &lt; colCount; ++col) {
354                     clone.elements[row][col] = elements[row][col];
355                 }
356             }
357             return clone;
358         }
359         catch (CloneNotSupportedException e) {
360             // Can't happen
361             throw new InternalError();
362         }
363     }
364
365     /**
366     * Compares passed &lt;CODE&gt;Matrix&lt;/CODE&gt; to this
367     * &lt;code&gt;Matrix&lt;/code&gt; for equality. Two &lt;code&gt;Matrix&lt;/code&gt;
368     * objects are semantically equal if they have the same
369     * order (i.e., same number of rows and columns), and
370     * the &lt;code&gt;int&lt;/code&gt; value of each element in
371     * this &lt;code&gt;Matrix&lt;/code&gt; is equal to the corresponding
372     * &lt;code&gt;int&lt;/code&gt; value in the passed &lt;code&gt;Matrix&lt;/code&gt;.
373     *
374     * @param An object to compare to this &lt;code&gt;Matrix&lt;/code&gt;
375     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Matrix&lt;/code&gt; is semantically equal
376     *    to the passed &lt;code&gt;Matrix&lt;/code&gt;
377     */
378     public boolean equals(Object o) {
379
380         if ((o == null) || (getClass() != o.getClass())) {
381             return false;
382         }
383
384         Matrix m = (Matrix) o;
385
386         // Because this class extends Object, don't
387         // call super.equals()
388
389         // To be semantically equal, both matrices must
390         // have the same order
391         if ((rowCount != m.rowCount) || (colCount != m.colCount)) {
392             return false;
393         }
394
395         // To be semantically equal, corresponding
396         // elements of both matrices must be equal
397         for (int row = 0; row &lt; rowCount; ++row) {
398             for (int col = 0; col &lt; colCount; ++col) {
399
400                 if (elements[row][col] != m.elements[row][col]) {
401                     return false;
402                 }
403             }
404         }
405
406         return true;
407     }
408
409     /**
410     * Computes the hash code for this &lt;code&gt;Matrix&lt;/code&gt;.
411     *
412     * @return a hashcode value for this &lt;code&gt;Matrix&lt;/code&gt;
413     */
414     public int hashcode() {
415
416         int retVal = rowCount * colCount;
417
418         for (int row = 0; row &lt; rowCount; ++row) {
419             for (int col = 0; col &lt; colCount; ++col) {
420
421                 retVal *= elements[row][col];
422             }
423         }
424
425         return retVal;
426     }
427
428     /**
429     * Ensures passed two-dimensional array is valid
430     * for initializing a &lt;CODE&gt;Matrix&lt;/CODE&gt; object.
431     */
432     private static void checkValidity(int[][] val) {
433
434         try {
435             int rows = val.length;
436             if (rows == 0) {
437                 throw new IllegalArgumentException();
438             }
439             int cols = val[0].length;
440             if (cols == 0) {
441                 throw new IllegalArgumentException();
442             }
443             for (int i = 1; i &lt; rows; ++i) {
444                 if (val[i].length != cols) {
445                     throw new IllegalArgumentException();
446                 }
447             }
448         }
449         catch (NullPointerException e) {
450             throw new IllegalArgumentException();
451         }
452     }
453
454     /**
455     * Ensures passed row and column represent valid indices into
456     * this &lt;CODE&gt;Matrix&lt;/CODE&gt;.
457     */
458     private void checkIndices(int row, int col) {
459         if (row &gt;= rowCount || row &lt; 0 || col &gt;= colCount || col &lt; 0) {
460             throw new IndexOutOfBoundsException();
461         }
462     }
463 }
</pre>

<P>
The data required for matrix addition sits inside instances of
class <CODE>Matrix</CODE>, in the <CODE>elements</CODE>, <CODE>rowCount</CODE>, and
<CODE>colCount</CODE> instance variables.
In this second iteration of class <CODE>Matrix</CODE>, the code that performs matrix addition
has been moved to the class that contains the data.
In the previous iteration, this code existed outside class
<CODE>Matrix</CODE>, in the <CODE>Example1</CODE> client shown in Listing 2-2. This code
now shows up in the <CODE>Matrix</CODE> class's <CODE>add</CODE> method, lines 145 to 159 of Listing 2-3.
Similarly, the code for building a <CODE>String</CODE> representation of the <CODE>Matrix</CODE>
has also been moved to the data.
This code shows up in the <CODE>toString</CODE> method, lines 321 to 340.
In the previous iteration this code existed outside class
<CODE>Matrix</CODE>, in lines 24 to 34 of <CODE>Example1</CODE>.
These changes allow clients, rather than performing the add and string building services themselves,
to ask the <CODE>Matrix</CODE> object to perform those services for them. Clients can now delegate
responsibility for matrix addition and string building to the class that has the necessary data,
class <CODE>Matrix</CODE>.

<P>
For example, consider the <CODE>Example2</CODE> client shown in Listing 2-4. <CODE>Example2</CODE>
performs the same function as <CODE>Example1</CODE>, it adds two matrices and prints the result. But
<CODE>Example2</CODE> is a client of the new improved <CODE>Matrix</CODE> of Listing 2-3:

<!--
Listing 2-4 shows a client
of the new service-oriented <CODE>Matrix</CODE>. Like class <CODE>Example1</CODE> shown in Listing 2-2,
this client adds two matrices and prints out the sum:
-->

<P>
<STRONG>Listing 2-4. A client of the service-oriented matrix.</STRONG>

<PRE>
 1 package com.artima.examples.matrix.ex2;
 2
 3 class Example2 {
 4
 5     public static void main(String[] args) {
 6
 7         int[][] init1 = { {2, 2}, {2, 2} };
 8         int[][] init2 = { {1, 2}, {3, 4} };
 9
10         Matrix m1 = new Matrix(init1);
11         Matrix m2 = new Matrix(init2);
12
13         // Add m1 & m2, store result in a new matrix object
<STRONG>14         Matrix sum = m1.add(m2);</STRONG>
15
16         // Print out the sum
<STRONG>17         System.out.println("Sum: " + sum.toString());</STRONG>
18     }
19 }
</pre>

<P>
Now, instead of <CODE>Example1</CODE>'s 8 lines of code (lines 14 to 21) that performs matrix addition,
<CODE>Example2</CODE> needs just one line of code, line 14. Similarly, instead of <CODE>Example1</CODE>'s
10 lines of code (lines 24 to 33) to print out a matrix, <CODE>Example2</CODE> requires 1 line of
code, line 17. If matrix addition needs to occur 50 different places, only the one-liner
shown on line 14 needs to be replicated throughout the system. If a bug is detected in the addition algorithm, only
one place need be debugged and fixed, the <CODE>add</CODE> method in class <CODE>Matrix</CODE>.
Once the bug is fixed, you know you've fixed it everywhere
matrix addition is performed.

<H1>Objects as Bundles of Services</H1>
<P>
Now, you may be saying that this is obvious. That I was simply factoring out duplicate code
into a single method that everyone calls. That's true, but when you perform an object-oriented design,
you in effect do this code-to-data refactoring ahead of time.

<P>
During the initial stages of a object-oriented design,
you discover objects. You assign to each object a general area of responsibility.
For each area of responsibility, you flesh out what services should be provided
by the type of object fulfilling those responsibilities. Finally, you design the interfaces
through which objects provide their services to clients.
In the process, you are effectively moving code to data.

<P>
For example,
you might decide that in your solution there will be a <CODE>Matrix</CODE> object, whose
area of responsibility is matrix
mathematics. As you flesh out the details, you decide that the <CODE>Matrix</CODE>
class will be responsible for matrix addition, matrix subtraction, and scalar and matrix multiplication.
You then design an interface through which the <CODE>Matrix</CODE> will fulfill its responsibilities,
such as the interface of the service-oriented <CODE>Matrix</CODE> class shown in Listing 2-3.
By discovering the service-oriented <CODE>Matrix</CODE> in the initial design phase, rather than first starting
with the data-oriented <CODE>Matrix</CODE> and later refactoring towards the service-oriented
<CODE>Matrix</CODE>, you in effect moved
code to data during the design process.

<P>
In Guideline 1, I mentioned that one way object-oriented programming helps programmers manage
complexity is it enables them to think more in terms of the problem
domain. However, often when you would do something <EM>to</em> an object in the real world, you
are more likely to ask an object to do that thing to itself in an object-oriented program.
For example, in the real world you might multiply a matrix by -1, but in an object-oriented program,
you might instead ask a <CODE>Matrix</CODE> object to <CODE>multiply</CODE> itself by -1.
The reason you would ask a <CODE>Matrix</CODE> to <CODE>multiply</CODE> itself by -1 is because matrix
multiplication involves matrix data. Therefore, the code that represents the matrix multiplication know-how
belongs in the very class that has the matrix data, the <CODE>Matrix</CODE> class itself.

<P>
Data-oriented methods, such as the <CODE>get</CODE> and <CODE>set</CODE> that appear
in Listing 2-1, are not inherently bad.
They are certainly appropriate in many situations. The service-oriented <CODE>Matrix</CODE> shown
in Listing 2-3, for
example, still offers three <CODE>get</CODE> methods. Plain old <CODE>get(int, int)</CODE> returns
an element value for the passed row and column. The other two methods, <CODE>getRows</CODE> and
<CODE>getCols</CODE>, return the number of rows and columns in the matrix.

<P>
Nevertheless,
the best mindset to maintain when designing object methods is to think service-oriented.
In general, design
methods for your objects that do something interesting with the object's data, something
more than just providing clients with access to the data. In the process, you will
be moving the code that knows how to manipulate data to the object that contains the data.
Moving code to data gives you one of the prime benefits of object-oriented approach to
programming: a shot at robustness.

<P>
It is easier to achieve system robustness when you move code
to data in the system design. I have found in my own development experiences that system robustness requires
composing the system out of robust parts. In an object-oriented system,
those robust parts are objects.
I often feel that robustness is almost an emergent propery of building
the system out of robust objects. Each object acts an tiny island of uncorruptible data.
And thousands of little islands of uncorrupted data yields a robust system.

<!--
<P>
John Kennedy, had he gone into programming instead of politics, might have put it this way:

<blockquote>
Ask not that an object give you its state, or set its state explicitly,
ask an object to do something for you with its state.
</blockquote>

<P>
<STRONG>Extra Stuff</STRONG>

<P>
Each instance method in an object interface sits ready to provide a service. To ask the object to
perform the service for you, you invoke the method. Objects also usually have state, maintained
in their instance variables. But usually, objects use that state to help them perform their
the services offered by their methods.

<P>
Each object as a whole can be thought of
as a higher level service, composed of the constituent services offered by its methods. For
example,

<P>
I'd like to leave you with a picture that shows what your program should look like. On the
right is a program whose objects are very data-oriented. Those objects are asking each other
for their data, and doing things with that data. The objects on the program on the left,
by contrast, are asking each other to perform higher level services -- to do something'
interesting with their state:

<P>
<CENTER>
<IMG src="images/ServiceOriented.gif"><BR><BR>
<STRONG> Figure 2-1. Service-oriented versus data-oriented objects</STRONG>
</CENTER>

<P>
iterator() method in Collection dropped leading "get" to save typing and space, so that means
that the iterator is not a property of a JavaBean.

<P>
Probably need to say something about an object has both data and offers services. Probably need
to define semantic contract here, because I already want to use it.
An object has code and data. The code embodies services and the data embodies information. But
you should think as an object more in terms of a bundle of services, not as a bundle of data.

<P>
One of the effects of this object-oriented approach to design is that code moves to data. In particular,
the code that operates on particular data gets encapsulated in the object that contains the data.
This is a very important process to understand, because from it arises the benefit of
minimized coupling made possible by objects. This process yields objects that offer higher-level
services to clients other than just providing access to data.

<H1>Deleted</H1>
<P>
Also, the point is that if you think of an object as a bundle of services, you design the data
after you figure out the responsibilities. The data is whatever is needed by the methods. This
contrasts with doing a data model design, where you start by thinking more about the data.
I'm not sure that minimized coupling is really my point here, but more helping achieve
robustness by minimizing
code duplication, and pointing out the difference between an OO design and a data model
design.

<P>
Promise of Jini is
that the network will be thousands of islands of uncorrupted data, encapsulated in
network-mobile objects, whose contracts are expressed in terms of behavior.
-->

</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/BundleServices.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
