<HTML>
<HEAD>
<TITLE>Understand the relationship between mutable service-oriented objects and state machines</TITLE>
<META name="description" content="Design guideline from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/6aa1408c?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ArtimaTraining" ><img src="..\cgi-bin\getimage.cgi\6aa1408c\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Understand the relationship between mutable Service-Oriented Objects and state machines</SPAN><BR>
</DIV>
<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="serviceoriented.html">Previous</A>&nbsp;|
<A href="messenger.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->


<P>
In <A href="sigobjects.html">Guideline 1</A>, I said that objects are machines. The kind of machine that service-oriented objects
resemble, mathematically speaking at least, is the state machine.
A state machine is defined by:

<UL>
<LI>a set of states, one of which is identified as the initial state
<LI>a set of messages the state machine can receive
<LI>a set of actions the state machine can take
<LI>the actions taken and next state that results from receiving each message in each state
</UL>

<P>
When a state machine is in some way built and put into motion, it starts out its lifetime in its initial state.
At any time during its life it has a current state.
The outside world interacts with the state machine by sending it messages. When the state
machine receives a message, it performs actions, including potentially changing state.

<P>
Similarly, when a service-oriented object is instantiated, it starts
out its lifetime in some initial state, which is established by the object's constructor.
At any time during its life it has a current state.
The outside world interacts with the object by invoking its methods. When a method is
invoked, the object performs actions, including potentially changing state, and returns.

<P>
Most often, the behavior of objects is defined by some human language description, such
as a written specification.
Now and then, however, you'll see behavior specified with
formal state machines. For example, the Java Telephony API specification
includes a state-transition diagram
that defines the states that a single "call" can progress through.

<P>
<CENTER>
Show the Java Telephony API state-transition diagram.<BR><BR>
<STRONG> Figure 4-1. The state-transition diagram for a telephone call.</STRONG>
</CENTER>


<P>
By sheer coincidence,
the behavior of the stamp dispenser example from <A href="serviceoriented.html">Guideline 3</A>, the
can also be expressed in terms of a state machine. The stamp dispenser state machine has:

<UL>
<LI>
Four States: <CODE>HAS_0</CODE>, <CODE>HAS_5</CODE>, <CODE>HAS_10</CODE>,
<CODE>HAS_15</CODE>
<LI>
Three Messages: <CODE>add5</CODE>, <CODE>add10</CODE>, <CODE>returnCoins</CODE>
<LI>
Four Actions: <CODE>dispenseStamp</CODE>, <CODE>ret5</CODE>,
<CODE>ret10</CODE>, <CODE>ret15</CODE>
</UL>

<P>
A stamp dispenser's current state indicates how much money has been inserted. If no money
has been inserted, the stamp dispenser is in the <CODE>HAS_0</CODE> state. If a nickel
has been inserted, the stamp dispenser is in the <CODE>HAS_5</CODE> state, and so on.
No <CODE>HAS_20</CODE> state appears in the list, because as soon as 20 cents has been
inserted, a stamp is automatically issued and any change is returned.

<P>
The three messages represent the actions
the user of a stamp dispenser can take: inserting a nickel (<CODE>add5</CODE>),
inserting a dime (<CODE>add10</CODE>), or pressing the coin
return lever (<CODE>returnCoins</CODE>).
The four actions the stamp dispenser
can take are return a nickel (<CODE>ret5</CODE>), return a dime (<CODE>ret10</CODE>), return
15 cents (<CODE>ret15</CODE>), or dispense a 20 cent stamp (<CODE>dispenseStamp</CODE>).

<P>
Table 4-1 shows the state-transition table that defines the actions taken and next state that results
from a stamp dispenser receiving each message in each state:

<P>
<CENTER>
<STRONG> Table 4-1. The stamp dispenser state-transition table.</STRONG>
</CENTER>

<P>
<TABLE align="center" border="1" cellpadding="5">
<TR>
<TH>
Current State
</TH>
<TH>
Message
</TH>
<TH>
Action
</TH>
<TH>
Next State
</TH>
</TR>

<TR>
<TD>
HAS_0
</TD>
<TD>
add5
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_5
</TD>
</TR>

<TR>
<TD>
HAS_0
</TD>
<TD>
add10
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_10
</TD>
</TR>

<TR>
<TD>
HAS_0
</TD>
<TD>
returnCoins
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_5
</TD>
<TD>
add5
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_10
</TD>
</TR>

<TR>
<TD>
HAS_5
</TD>
<TD>
add10
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_15
</TD>
</TR>

<TR>
<TD>
HAS_5
</TD>
<TD>
returnCoins
</TD>
<TD>
ret5
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_10
</TD>
<TD>
add5
</TD>
<TD>
&nbsp;
</TD>
<TD>
HAS_15
</TD>
</TR>

<TR>
<TD>
HAS_10
</TD>
<TD>
add10
</TD>
<TD>
dispenseStamp
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_10
</TD>
<TD>
returnCoins
</TD>
<TD>
ret10
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_15
</TD>
<TD>
add5
</TD>
<TD>
dispenseStamp
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_15
</TD>
<TD>
add10
</TD>
<TD>
dispenseStamp,ret5
</TD>
<TD>
HAS_0
</TD>
</TR>

<TR>
<TD>
HAS_15
</TD>
<TD>
returnCoins
</TD>
<TD>
ret15
</TD>
<TD>
HAS_0
</TD>
</TR>
<TR>
<TD colspan="4">
Initial State: HAS_0
</FONT>
</TD>
</TR>
</TABLE>

<P>
Figure 4-2 shows the state-transition diagram for the same state machine:

<P>
<CENTER>
<IMG src="images\statemachine.gif"><BR><BR>
<STRONG> Figure 4-2. The stamp dispenser state-transition diagram.</STRONG>
</CENTER>

<P>
I started out this guideline by saying that service-oriented objects resemble state machines, once
those state machines are built and put into motion. The state machine has to be built, not just specified,
to act like a service-oriented object. But how do you build a state machine?
Well, one way to build a state machine is to model it with a service-oriented object.
Given any state machine, you can directly map a state machine to a service-oriented
object like this:

<UL>
<LI>
<STRONG>States</STRONG>: range of possible values in (private) instance variables
<LI>
<STRONG>Messages</STRONG>: invocation of (non-private) methods
<LI>
<STRONG>Actions</STRONG>: actions performed by invoked method
<LI>
<STRONG>State Changes</STRONG>: changes to instance variables done by
invoked method
<LI>
<STRONG>Initial State</STRONG>: set up by constructors and initializers
</UL>

<P>
For example, the stamp dispenser state machine defined in Table 4-1 can be directly mapped to
the object defined by the following class:

<P>
<STRONG>Listing 4-1. A code-heavy stamp dispenser.</STRONG>

<PRE>
  1 package com.artima.examples.stampdispenser.ex2;
  2
  3 import java.util.Set;
  4 import java.util.Iterator;
  5 import java.util.HashSet;
  6
  7 <EM>/**
  8 * A stamp dispenser that accepts nickels and dimes and dispenses
  9 * twenty cent stamps.
 10 *
 11 * @author Bill Venners
 12 */</EM>
 13 public class StampDispenser {
 14
 15     private static final int HAS_0 = 0;
 16     private static final int HAS_5 = 1;
 17     private static final int HAS_10 = 2;
 18     private static final int HAS_15 = 3;
 19
 20     private int currentState = HAS_0;
 21     private Set listeners = new HashSet();
 22
 23     <EM>/**
 24     * Constructs a new stamp dispenser with a starting balance of zero.
 25     */</EM>
 26     public StampDispenser() {
 27     }
 28
 29     <EM>/**
 30     * Adds the specified stamp dispenser listener to receive stamp dispenser events
 31     * from this stamp dispenser. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception
 32     * is thrown and no action is performed. If &lt;code&gt;l&lt;/code&gt; is already registered
 33     * as a listener, no action is performed.
 34     */</EM>
 35     public synchronized void addStampDispenserListener(StampDispenserListener l) {
 36
 37         listeners.add(l);
 38     }
 39
 40     <EM>/**
 41     * Removes the specified stamp dispenser listener so that it no longer
 42     * receives stamp dispenser events from this stamp dispenser. This method
 43     * performs no function, nor does it throw an exception, if the listener
 44     * specified by the argument was not previously added to this
 45     * component. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
 46     * thrown and no action is performed.
 47     */</EM>
 48     public synchronized void removeStampDispenserListener(StampDispenserListener l) {
 49
 50         listeners.remove(l);
 51     }
 52
 53     <EM>/**
 54     * Add 5 cents to the stamp dispenser. If the amount added
 55     * causes the current value to become or exceed 20 cents, the price of
 56     * a stamp, the stamp will be automatically dispensed.
 57     */</EM>
 58     public synchronized void add5() {
 59
 60         switch (currentState) {
 61
 62         case HAS_0:
 63             StampDispenserEvent event = new StampDispenserEvent(this, 0, 5);
 64             fireCoinAccepted(event, listeners);
 65             currentState = HAS_5;
 66             break;
 67
 68         case HAS_5:
 69             event = new StampDispenserEvent(this, 0, 10);
 70             fireCoinAccepted(event, listeners);
 71             currentState = HAS_10;
 72             break;
 73
 74         case HAS_10:
 75             event = new StampDispenserEvent(this, 0, 15);
 76             fireCoinAccepted(event, listeners);
 77             currentState = HAS_15;
 78             break;
 79
 80         case HAS_15:
 81
 82             event = new StampDispenserEvent(this, 0, 0);
 83             fireStampDispensed(event, listeners);
 84             currentState = HAS_0;
 85             break;
 86         }
 87     }
 88
 89     <EM>/**
 90     * Add 10 cents to the stamp dispenser. If the amount added
 91     * causes the current value to become or exceed 20 cents, the price of
 92     * a stamp, the stamp will be automatically dispensed.
 93     */</EM>
 94     public synchronized void add10() {
 95
 96         switch (currentState) {
 97
 98         case HAS_0:
 99             StampDispenserEvent event = new StampDispenserEvent(this, 0, 10);
100             fireCoinAccepted(event, listeners);
101             currentState = HAS_10;
102             break;
103
104         case HAS_5:
105             event = new StampDispenserEvent(this, 0, 15);
106             fireCoinAccepted(event, listeners);
107             currentState = HAS_15;
108             break;
109
110         case HAS_10:
111             event = new StampDispenserEvent(this, 0, 0);
112             fireStampDispensed(event, listeners);
113             currentState = HAS_0;
114             break;
115
116         case HAS_15:
117
118             event = new StampDispenserEvent(this, 5, 0);
119             fireStampDispensed(event, listeners);
120             currentState = HAS_0;
121             break;
122         }
123     }
124
125     <EM>/**
126     * Returns coins. If the balance is zero, no action is
127     * performed.
128     */</EM>
129     public synchronized void returnCoins() {
130
131         switch (currentState) {
132
133         case HAS_0:
134             currentState = HAS_0;
135             break;
136
137         case HAS_5:
138             StampDispenserEvent event = new StampDispenserEvent(this, 5, 0);
139             fireCoinsReturned(event, listeners);
140             currentState = HAS_0;
141             break;
142
143         case HAS_10:
144             event = new StampDispenserEvent(this, 10, 0);
145             fireCoinsReturned(event, listeners);
146             currentState = HAS_0;
147             break;
148
149         case HAS_15:
150
151             event = new StampDispenserEvent(this, 15, 0);
152             fireCoinsReturned(event, listeners);
153             currentState = HAS_0;
154             break;
155         }
156     }
157
158     <EM>/**
159     * Helper method that fires coinAccepted events.
160     */</EM>
161     private static void fireCoinAccepted(StampDispenserEvent event,
162         Set listeners) {
163
164         Iterator it = listeners.iterator();
165         while (it.hasNext()) {
166             StampDispenserListener l = (StampDispenserListener) it.next();
167             l.coinAccepted(event);
168         }
169     }
170
171     <EM>/**
172     * Helper method that fires stampDispensed events.
173     */</EM>
174     private static void fireStampDispensed(StampDispenserEvent event,
175         Set listeners) {
176
177         Iterator it = listeners.iterator();
178         while (it.hasNext()) {
179             StampDispenserListener l = (StampDispenserListener) it.next();
180             l.stampDispensed(event);
181         }
182     }
183
184     <EM>/**
185     * Helper method that fires coinsReturned events.
186     */</EM>
187     private static void fireCoinsReturned(StampDispenserEvent event,
188         Set listeners) {
189
190         Iterator it = listeners.iterator();
191         while (it.hasNext()) {
192             StampDispenserListener l = (StampDispenserListener) it.next();
193             l.coinsReturned(event);
194         }
195     }
196 }
</PRE>

<P>
This <CODE>StampDispenser</CODE> really offers the same service to clients as the
<CODE>StampDispenser</CODE> shown in <A href="serviceoriented.html">Guideline 3</A>, but
this <CODE>StampDispenser</CODE> has a less intuitive interface
and a more code-heavy implementation. I prefer both the interface and implementation
of the <CODE>StampDispenser</CODE> shown in Guideline 3. I find the single <CODE>add(int)</CODE>
method of Guideline 3's <CODE>StampDispenser</CODE> to be easier to understand than
this <CODE>StampDispenser</CODE>'s separate <CODE>add5()</CODE> and <CODE>add10()</CODE> methods.
And I prefer the more concise implementations of the <CODE>add</CODE> and
<CODE>returnCoins</CODE> methods in Guideline 3's <CODE>StampDispenser</CODE>
to this <CODE>StampDispenser</CODE>'s elaborate switch statements.
Nevertheless, this <CODE>StampDispenser</CODE> has value because it serves as
a convenient launching point for a discussion about the state pattern.

<P>
The state pattern suggests that when you find yourself with switch statements
with a case for each of some finite number
of states, you should consider factoring out the behavior for each state into
its own class. For example, in the code-heavy <CODE>StampDispenser</CODE> of
Listing 4-1, the <CODE>add5</CODE>, <CODE>add10</CODE>, and
<CODE>returnCoins</CODE> methods are implemented as switch statements. The
switch statements have
one case for each of the stamp dispenser state machine's four states:
<CODE>HAS_0</CODE>, <CODE>HAS_5</CODE>, <CODE>HAS_10</CODE>, and <CODE>HAS_15</CODE>.
Thus, the state pattern suggests refactoring this class by collecting all the code for
each stamp dispenser state into its own class. This refactoring process yields five new classes: an
abstract <CODE>State</CODE> class, and four concrete subclasses, one for each
of the four states of the state machine: <CODE>Has0State</CODE>, <CODE>Has5State</CODE>,
<CODE>Has10State</CODE>, <CODE>Has15State</CODE>.

<!--
A UML diagram for these classes
is shown in Figure 4-3.

<P>
<CENTER>
<IMG src="images/statepattern.gif"><BR><BR>
<STRONG> Figure 4-3. The state pattern stamp machine.</STRONG>
</CENTER>
-->

<P>
You start by defining an abstract class (or interface) that contains a method for
each message that can be sent to the state machine. In the stamp dispenser case, the
messages are <CODE>add5</CODE>, <CODE>add10</CODE>, and <CODE>returnCoins</CODE>.
Here's an abstract class named <CODE>State</CODE> that defines three abstract methods, one
for each message:

<P>
<STRONG>Listing 4-2. Class <CODE>StampDispenserState</CODE>.</STRONG>

<PRE>
  1 package com.artima.examples.stampdispenser.ex3;
  2
  3 import java.util.Iterator;
  4 import java.util.Set;
  5
  6 <EM>/**
  7 * Abstract superclass for all stamp dispenser state classes.
  8 *
  9 * The state machine that embodies the behavior of the
 10 * stamp dispenser (which determines the behavior of the
 11 * &lt;CODE&gt;StampDispenserState&lt;/code&gt; subclasses) is described
 12 * in this &lt;a href="../../../../../statemachine.html"&gt;state transition table&lt;/a&gt;.
 13 */</EM>
 14 abstract class StampDispenserState {
 15
 16     <EM>/**
 17     * Performs actions appropriate for the state represented by
 18     * the class of this object for the add5 message. Returns a
 19     * reference to the state object that represents the next state
 20     * to transition to as a result of the arrival of this add5 message.
 21     *
 22     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 23     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 24     */</EM>
<STRONG> 25     abstract StampDispenserState add5(StampDispenser stampDispenser,
 26         Set listeners);</STRONG>
 27
 28     <EM>/**
 29     * Performs actions appropriate for the state represented by
 30     * the class of this object for the add10 message. Returns a
 31     * reference to the state object that represents the next state
 32     * to transition to as a result of the arrival of this add10 message.
 33     *
 34     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 35     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 36     */</EM>
<STRONG> 37     abstract StampDispenserState add10(StampDispenser stampDispenser,
 38         Set listeners);</STRONG>
 39
 40     <EM>/**
 41     * Performs actions appropriate for the state represented by
 42     * the class of this object for the returnCoins message. Returns a
 43     * reference to the state object that represents the next state
 44     * to transition to as a result of the arrival of this returnCoins message.
 45     *
 46     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 47     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 48     */</EM>
<STRONG> 49     abstract StampDispenserState returnCoins(StampDispenser stampDispenser,
 50         Set listeners);</STRONG>
 51
 52     <EM>/**
 53     * Helper method that fires coinAccepted events.
 54     *
 55     * @param event &lt;code&gt;StampDispenserEvent&lt;/code&gt; to propagate
 56     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 57     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 58     */</EM>
 59     static void fireCoinAccepted(StampDispenserEvent event,
 60         Set listeners) {
 61
 62         Iterator it = listeners.iterator();
 63         while (it.hasNext()) {
 64             StampDispenserListener l = (StampDispenserListener) it.next();
 65             l.coinAccepted(event);
 66         }
 67     }
 68
 69     <EM>/**
 70     * Helper method that fires stampDispensed events.
 71     *
 72     * @param event &lt;code&gt;StampDispenserEvent&lt;/code&gt; to propagate
 73     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 74     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 75     */</EM>
 76     static void fireStampDispensed(StampDispenserEvent event,
 77         Set listeners) {
 78
 79         Iterator it = listeners.iterator();
 80         while (it.hasNext()) {
 81             StampDispenserListener l = (StampDispenserListener) it.next();
 82             l.stampDispensed(event);
 83         }
 84     }
 85
 86     <EM>/**
 87     * Helper method that fires coinsReturned events.
 88     *
 89     * @param event &lt;code&gt;StampDispenserEvent&lt;/code&gt; to propagate
 90     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
 91     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
 92     */</EM>
 93     static void fireCoinsReturned(StampDispenserEvent event,
 94         Set listeners) {
 95
 96         Iterator it = listeners.iterator();
 97         while (it.hasNext()) {
 98             StampDispenserListener l = (StampDispenserListener) it.next();
 99             l.coinsReturned(event);
100         }
101     }
102 }
</pre>

<P>
You then define one concrete subclass for each state.
In this example, the four concrete <CODE>State</CODE> subclasses -- named
<CODE>Has0State</CODE>, <CODE>Has5State</CODE>, <CODE>Has10State</CODE>, and
<CODE>Has15State</CODE> -- are all implemented as singletons.
The methods of class <CODE>Has0State</CODE>
are responsible for fulfilling the stamp dispenser's contract when it is in
the <CODE>HAS_0</CODE> state.
Likewise, the methods of class <CODE>Has5State</CODE> are responsible for fulfilling the
stamp dispenser's contract when it is in
the <CODE>HAS_5</CODE> state.
Here are all four concrete <CODE>State</CODE> subclasses:

<P>
<STRONG>Listing 4-3. Class <CODE>Has0State</CODE>.</STRONG>

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4
 5 <EM>/**
 6 * &lt;code&gt;StampDispenserState&lt;/code&gt; subclass that represents
 7 * the &lt;em&gt;Has0&lt;/em&gt; stamp dispenser state. See the documentation
 8 * for class &lt;code&gt;StampDispenserState&lt;/code&gt; for a state
 9 * transition table that specifies the required behavior of
10 * instances of this class.
11 */</EM>
12 class Has0State extends StampDispenserState {
13
14     <EM>/**
15     * The single instance of &lt;code&gt;Has0State&lt;/code&gt;
16     */</EM>
17     private static Has0State singleton = new Has0State();
18
19     <EM>/**
20     * Constructs a &lt;code&gt;Has0State&lt;/code&gt; instance. This constructor is
21     * private to enable this class to restrict the number
22     * of instances of &lt;code&gt;Has0State&lt;/code&gt; to one. I.e., &lt;code&gt;Has0State&lt;/code&gt; is
23     * a singleton.
24     */</EM>
25     private Has0State() {
26     }
27
28     <EM>/**
29     * Factory method that returns the single instance of
30     * &lt;code&gt;Has0State&lt;/code&gt;.
31     */</EM>
32     static StampDispenserState getState() {
33         return singleton;
34     }
35
36     <EM>/**
37     * Performs actions appropriate for the state represented by
38     * the class of this object for the add5 message. Returns a
39     * reference to the state object that represents the next state
40     * to transition to as a result of the arrival of this add5 message.
41     *
42     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
43     *     object represents
44     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
45     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
46     */</EM>
47     StampDispenserState add5(StampDispenser stampDispenser,
48         Set listeners) {
49
50         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 5);
51         fireCoinAccepted(event, listeners);
52         return Has5State.getState();
53     }
54
55     <EM>/**
56     * Performs actions appropriate for the state represented by
57     * the class of this object for the add10 message. Returns a
58     * reference to the state object that represents the next state
59     * to transition to as a result of the arrival of this add10 message.
60     *
61     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
62     *     object represents
63     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
64     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
65     */</EM>
66     StampDispenserState add10(StampDispenser stampDispenser,
67         Set listeners) {
68
69         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 10);
70         fireCoinAccepted(event, listeners);
71         return Has10State.getState();
72     }
73
74     <EM>/**
75     * Performs actions appropriate for the state represented by
76     * the class of this object for the returnCoins message. Returns a
77     * reference to the state object that represents the next state
78     * to transition to as a result of the arrival of this returnCoins message.
79     *
80     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
81     *     object represents
82     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
83     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
84     */</EM>
85     StampDispenserState returnCoins(StampDispenser stampDispenser,
86         Set listeners) {
87
88         return this;
89     }
90 }
</pre>

<P>
<STRONG>Listing 4-4. Class <CODE>Has5State</CODE>.</STRONG>

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4
 5 <EM>/**
 6 * &lt;code&gt;StampDispenserState&lt;/code&gt; subclass that represents
 7 * the &lt;em&gt;Has5&lt;/em&gt; stamp dispenser state. See the documentation
 8 * for class &lt;code&gt;StampDispenserState&lt;/code&gt; for a state
 9 * transition table that specifies the required behavior of
10 * instances of this class.
11 */</EM>
12 class Has5State extends StampDispenserState {
13
14     <EM>/**
15     * The single instance of &lt;code&gt;Has0State&lt;/code&gt;
16     */</EM>
17     private static Has5State singleton = new Has5State();
18
19     <EM>/**
20     * Constructs a &lt;code&gt;Has5State&lt;/code&gt; instance. This constructor is
21     * private to enable this class to restrict the number
22     * of instances of &lt;code&gt;Has5State&lt;/code&gt; to one. I.e., &lt;code&gt;Has5State&lt;/code&gt; is
23     * a singleton.
24     */</EM>
25     private Has5State() {
26     }
27
28     <EM>/**
29     * Factory method that returns the single instance of
30     * &lt;code&gt;Has5State&lt;/code&gt;.
31     */</EM>
32     static StampDispenserState getState() {
33         return singleton;
34     }
35
36     <EM>/**
37     * Performs actions appropriate for the state represented by
38     * the class of this object for the add5 message. Returns a
39     * reference to the state object that represents the next state
40     * to transition to as a result of the arrival of this add5 message.
41     *
42     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
43     *     object represents
44     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
45     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
46     */</EM>
47     StampDispenserState add5(StampDispenser stampDispenser,
48         Set listeners) {
49
50         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 10);
51         fireCoinAccepted(event, listeners);
52         return Has10State.getState();
53     }
54
55     <EM>/**
56     * Performs actions appropriate for the state represented by
57     * the class of this object for the add10 message. Returns a
58     * reference to the state object that represents the next state
59     * to transition to as a result of the arrival of this add10 message.
60     *
61     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
62     *     object represents
63     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
64     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
65     */</EM>
66     StampDispenserState add10(StampDispenser stampDispenser,
67         Set listeners) {
68
69         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 15);
70         fireCoinAccepted(event, listeners);
71         return Has15State.getState();
72     }
73
74     <EM>/**
75     * Performs actions appropriate for the state represented by
76     * the class of this object for the returnCoins message. Returns a
77     * reference to the state object that represents the next state
78     * to transition to as a result of the arrival of this returnCoins message.
79     *
80     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
81     *     object represents
82     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
83     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
84     */</EM>
85     StampDispenserState returnCoins(StampDispenser stampDispenser,
86         Set listeners) {
87
88         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 5, 0);
89         fireCoinsReturned(event, listeners);
90         return Has0State.getState();
91     }
92 }
</pre>

<P>
<STRONG>Listing 4-5. Class <CODE>Has10State</CODE>.</STRONG>

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4
 5 <EM>/**
 6 * &lt;code&gt;StampDispenserState&lt;/code&gt; subclass that represents
 7 * the &lt;em&gt;Has10&lt;/em&gt; stamp dispenser state. See the documentation
 8 * for class &lt;code&gt;StampDispenserState&lt;/code&gt; for a state
 9 * transition table that specifies the required behavior of
10 * instances of this class.
11 */</EM>
12 class Has10State extends StampDispenserState {
13
14     <EM>/**
15     * The single instance of &lt;code&gt;Has0State&lt;/code&gt;
16     */</EM>
17     private static Has10State singleton = new Has10State();
18
19     <EM>/**
20     * Constructs a &lt;code&gt;Has10State&lt;/code&gt; instance. This constructor is
21     * private to enable this class to restrict the number
22     * of instances of &lt;code&gt;Has10State&lt;/code&gt; to one. I.e., &lt;code&gt;Has10State&lt;/code&gt; is
23     * a singleton.
24     */</EM>
25     private Has10State() {
26     }
27
28     <EM>/**
29     * Factory method that returns the single instance of
30     * &lt;code&gt;Has10State&lt;/code&gt;.
31     */</EM>
32     static StampDispenserState getState() {
33         return singleton;
34     }
35
36     <EM>/**
37     * Performs actions appropriate for the state represented by
38     * the class of this object for the add5 message. Returns a
39     * reference to the state object that represents the next state
40     * to transition to as a result of the arrival of this add5 message.
41     *
42     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
43     *     object represents
44     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
45     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
46     */</EM>
47     StampDispenserState add5(StampDispenser stampDispenser,
48         Set listeners) {
49
50         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 15);
51         fireCoinAccepted(event, listeners);
52         return Has15State.getState();
53     }
54
55     <EM>/**
56     * Performs actions appropriate for the state represented by
57     * the class of this object for the add10 message. Returns a
58     * reference to the state object that represents the next state
59     * to transition to as a result of the arrival of this add10 message.
60     *
61     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
62     *     object represents
63     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
64     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
65     */</EM>
66     StampDispenserState add10(StampDispenser stampDispenser,
67         Set listeners) {
68
69         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 0);
70         fireStampDispensed(event, listeners);
71         return Has0State.getState();
72     }
73
74     <EM>/**
75     * Performs actions appropriate for the state represented by
76     * the class of this object for the returnCoins message. Returns a
77     * reference to the state object that represents the next state
78     * to transition to as a result of the arrival of this returnCoins message.
79     *
80     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
81     *     object represents
82     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
83     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
84     */</EM>
85     StampDispenserState returnCoins(StampDispenser stampDispenser,
86         Set listeners) {
87
88         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 10, 0);
89         fireCoinsReturned(event, listeners);
90         return Has0State.getState();
91     }
92 }
</pre>

<P>
<STRONG>Listing 4-6. Class <CODE>Has15State</CODE>.</STRONG>

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4
 5 <EM>/**
 6 * &lt;code&gt;StampDispenserState&lt;/code&gt; subclass that represents
 7 * the &lt;em&gt;Has10&lt;/em&gt; stamp dispenser state. See the documentation
 8 * for class &lt;code&gt;StampDispenserState&lt;/code&gt; for a state
 9 * transition table that specifies the required behavior of
10 * instances of this class.
11 */</EM>
12 class Has15State extends StampDispenserState {
13
14     <EM>/**
15     * The single instance of &lt;code&gt;Has5State&lt;/code&gt;
16     */</EM>
17     private static Has15State singleton = new Has15State();
18
19     <EM>/**
20     * Constructs a &lt;code&gt;Has15State&lt;/code&gt; instance. This constructor is
21     * private to enable this class to restrict the number
22     * of instances of &lt;code&gt;Has15State&lt;/code&gt; to one. I.e., &lt;code&gt;Has15State&lt;/code&gt; is
23     * a singleton.
24     */</EM>
25     private Has15State() {
26     }
27
28     <EM>/**
29     * Factory method that returns the single instance of
30     * &lt;code&gt;Has15State&lt;/code&gt;.
31     */</EM>
32     static StampDispenserState getState() {
33         return singleton;
34     }
35
36     <EM>/**
37     * Performs actions appropriate for the state represented by
38     * the class of this object for the add5 message. Returns a
39     * reference to the state object that represents the next state
40     * to transition to as a result of the arrival of this add5 message.
41     *
42     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
43     *     object represents
44     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
45     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
46     */</EM>
47     StampDispenserState add5(StampDispenser stampDispenser,
48         Set listeners) {
49
50         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 0, 0);
51         fireStampDispensed(event, listeners);
52         return Has0State.getState();
53     }
54
55     <EM>/**
56     * Performs actions appropriate for the state represented by
57     * the class of this object for the add10 message. Returns a
58     * reference to the state object that represents the next state
59     * to transition to as a result of the arrival of this add10 message.
60     *
61     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
62     *     object represents
63     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
64     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
65     */</EM>
66     StampDispenserState add10(StampDispenser stampDispenser,
67         Set listeners) {
68
69         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 5, 0);
70         fireStampDispensed(event, listeners);
71         return Has0State.getState();
72     }
73
74     <EM>/**
75     * Performs actions appropriate for the state represented by
76     * the class of this object for the returnCoins message. Returns a
77     * reference to the state object that represents the next state
78     * to transition to as a result of the arrival of this returnCoins message.
79     *
80     * @param stampDispenser the &lt;code&gt;StampDispenser&lt;/code&gt; whose state this
81     *     object represents
82     * @param listeners &lt;code&gt;Set&lt;/code&gt; containing zero to many (and only)
83     *     &lt;code&gt;StampDispenserListener&lt;/code&gt;s
84     */</EM>
85     StampDispenserState returnCoins(StampDispenser stampDispenser,
86         Set listeners) {
87
88         StampDispenserEvent event = new StampDispenserEvent(stampDispenser, 15, 0);
89         fireCoinsReturned(event, listeners);
90         return Has0State.getState();
91     }
92 }
</pre>

<P>
In the refactored <CODE>StampDispenser</CODE> shown in Listing 4-7, the <CODE>currentState</CODE> variable,
which was type <CODE>int</CODE> in
the code-heavy <CODE>StampDispenser</CODE>, is changed
to type <CODE>State</CODE>.
The <CODE>StampDispenser</CODE>
initializes <CODE>currentState</CODE> with the singleton for <CODE>Has0State</CODE>,
the specified initial state. The <CODE>StampDispenser</CODE> then forwards all
messages received from its client back to current state object, which is responsible
for fulfilling the <CODE>StampDispenser</CODE>'s contract. The current <CODE>State</CODE>
object also indicates to the <CODE>StampDispenser</CODE> what next state should be,
by returning a <CODE>State</CODE> object from each of its methods.

<P>
<STRONG>Listing 4-7. The refactored <CODE>StampDispenser</CODE>.</STRONG>

<PRE>
 1 package com.artima.examples.stampdispenser.ex3;
 2
 3 import java.util.Set;
 4 import java.util.HashSet;
 5
 6 <EM>/**
 7 * A stamp dispenser that accepts nickels and dimes and dispenses
 8 * twenty cent stamps.
 9 *
10 * @author Bill Venners
11 */</EM>
12 public class StampDispenser {
13
14     private StampDispenserState currentState = Has0State.getState();
15     private Set listeners = new HashSet();
16
17     <EM>/**
18     * Constructs a new stamp dispenser with a starting balance of zero.
19     */</EM>
20     public StampDispenser() {
21     }
22
23     <EM>/**
24     * Adds the specified stamp dispenser listener to receive stamp dispenser events
25     * from this stamp dispenser. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception
26     * is thrown and no action is performed. If &lt;code&gt;l&lt;/code&gt; is already registered
27     * as a listener, no action is performed.
28     */</EM>
29     public synchronized void addStampDispenserListener(StampDispenserListener l) {
30
31         listeners.add(l);
32     }
33
34     <EM>/**
35     * Removes the specified stamp dispenser listener so that it no longer
36     * receives stamp dispenser events from this stamp dispenser. This method
37     * performs no function, nor does it throw an exception, if the listener
38     * specified by the argument was not previously added to this
39     * component. If &lt;code&gt;l&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, no exception is
40     * thrown and no action is performed.
41     */</EM>
42     public synchronized void removeStampDispenserListener(StampDispenserListener l) {
43
44         listeners.remove(l);
45     }
46
47     <EM>/**
48     * Add 5 cents to the stamp dispenser. If the amount added
49     * causes the current value to become or exceed 20 cents, the price of
50     * a stamp, the stamp will be automatically dispensed.
51     */</EM>
52     public void add5() {
53
54         currentState = currentState.add5(this, listeners);
55     }
56
57     <EM>/**
58     * Add 10 cents to the stamp dispenser. If the amount added
59     * causes the current value to become or exceed 20 cents, the price of
60     * a stamp, the stamp will be automatically dispensed.
61     */</EM>
62     public void add10() {
63
64         currentState = currentState.add10(this, listeners);
65     }
66
67     <EM>/**
68     * Returns coins. If the balance is zero, no action is
69     * performed.
70     */</EM>
71     public void returnCoins() {
72
73         currentState = currentState.returnCoins(this, listeners);
74     }
75 }
</PRE>

<P>
The Go4 book claims that the benefit of the state pattern is that it localizes state specific code. I.e., all
the code for each state is in one place, the concrete subclass for the state. The state
pattern eliminates those unsightly switch statements that have a case for each state.
Such switch statements are difficult to maintain, the Go4 claims, especially if there are many
states.
The <CODE>StampDispenser</CODE> example
demonstrates that the switch statements of the code-heavy version do indeed disappear when refactored with
the state pattern.
The Go4 book does mention the potential maintenance cost of distributing the behavior for
different states across several classes, which increases the number of classes and is less compact
than a single class. But Go4 insists that more classes is better than long switch statements, especially
if there are many states.

<P>
To me, the state pattern makes the most sense when the requirements are understood in terms of
a state machine in the first place. For example, when writing a class that deals with
the Java Telephony API, it may make sense to use the state pattern where the states map to
the well-understood and recognized states through which a telephone call progresses. This state
machine, which is shown in Figure 4-1, appears in the Java Telephony specification.
The point of the state pattern is to make code easier to understand and change. If the state machine isn't
well understood, then a state pattern organization of the class won't be either. For example, now
that I've seen the state pattern <CODE>StampDispenser</CODE>, I still prefer the original
version of <CODE>StampDispenser</CODE> shown in Guideline 3. I think the Guideline 3
<CODE>StampDispenser</CODE> is the easiest to
understand and change. So my take on the state pattern is that the state pattern makes
sense in the solution, only in those relatively rare cases in which a state machine
is used to define the requirements. Otherwise, programmers will be scratching their heads
trying to figure out your state machine, which may end up making it more difficult to
understand your class.

<P>
The reason I included this example, however, is because I feel the state pattern illustrates well the
way in which service-oriented objects act like state machines.
I find this state-machine view of objects to be a valuable insight
in design. When you design service-oriented objects, you are designing elaborate state machines.

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/StatePattern.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
