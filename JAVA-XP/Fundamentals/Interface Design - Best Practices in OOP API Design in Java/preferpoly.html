<HTML>
<HEAD>
<TITLE>Prefer polymorphism over instanceof and downcasting</TITLE>
<META name="description" content="An object-oriented design idiom from Interface Design: Best Practices in Object-Oriented API Design in Java by Bill Venners.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#006666">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\images\ac.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/6ed9601c?REGION=Cyan&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ArtimaTraining" ><img src="..\cgi-bin\getimage.cgi\6ed9601c\region=cyan&campaign=default&account=artima&banner" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#006666">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Interface Design by Bill Venners</SPAN><BR>
<SPAN class="ts">Prefer polymorphism over instanceof and downcasting</SPAN><BR>
</DIV>

<!--BEGIN_PRECISE_OBJECT_LINKS-->
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interface&nbsp;Design</A>&nbsp;|
<A href="contents.html">Contents</A>&nbsp;|
<A href="isa.html">Previous</A>&nbsp;|
<A href="dynarefl.html">Next</A>
</STRONG>
</FONT>
</CENTER>
<!--END_PRECISE_OBJECT_LINKS-->

<P>
Use getPlace() as an example of instanceof. Use perhaps values() and keySet() of LinkMap as example of
polymorphism and dynamic binding.

<P>
Guideline could be simplified to prefer polymorphism to instanceof.

<P>
Try to design things so clients don't have to use instanceof and downcasting. This is where your
modeling of abstract types comes in. When you design class Animal, you say what it means to be
an animal by saying what services every Animal provides (the syntax and semantics). A good example
of this is Set and List and Collection. These rich types allow abstract return types that clients
don't usually have to downcast. In your APIs, set things up so people don't have to use instanceof.
Sometimes, though, you may find yourself requiring clients to downcast.
Show LinkMap, ModifiableLinkMap, DynamicLinkMap. Know a LinkMap is coming, but don't know whether
its a DynamicLinkMap unless you use instanceof. If so, can downcast to DynamicLinkMap.

<H2>Downcasting and <CODE>instanceof</CODE></H2>
<UL>
<LI>
<EM>Prefer polymorphism over </EM><CODE>instanceof</CODE><EM> or reflection.</EM>
<PRE>
// In file rtci/ex5/Animal.java
class Animal {
    //...
}

// In file rtci/ex5/Dog.java
class Dog extends Animal {
    public void woof() {
        System.out.println("Woof!");
    }
    //...
}

// In file rtci/ex5/Cat.java
class Cat extends Animal {
    public void meow() {
        System.out.println("Meow!");
    }
    //...
}

// In file rtci/ex5/Hippopotamus.java
class Hippopotamus extends Animal {
    public void roar() {
        System.out.println("Roar!");
    }
    //...
}

// In file rtci/ex5/Example5.java
class Example5 {

    public static void main(String[] args) {

        makeItTalk(new Cat());
        makeItTalk(new Dog());
        makeItTalk(new Hippopotamus());
    }

    public static void makeItTalk(Animal animal) {

        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.meow();
        }
        else if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.woof();
        }
        else if (animal instanceof Hippopotamus) {
            Hippopotamus hippopotamus = (Hippopotamus) animal;
            hippopotamus.roar();
        }
    }
}
</PRE>
<LI>
Hopefully triggers alarms in object-oriented brains
<LI>
To add <CODE>Orangutan</CODE>, would need to add a new if-else clause
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>The OO Way</H2>
<UL>
<LI>
Here downcasting and <CODE>instanceof</CODE> cast aside in favor of
polymorphism and dynamic binding
<PRE>
// In file rtci/ex6/Animal.java
abstract class Animal {
    public abstract void talk();
    //...
}

// In file rtci/ex6/Dog.java
class Dog extends Animal {
    public void talk() {
        System.out.println("Woof!");
    }
    //...
}

// In file rtci/ex6/Cat.java
class Cat extends Animal {
    public void talk() {
        System.out.println("Meow!");
    }
    //...
}

// In file rtci/ex6/Hippopotamus.java
class Hippopotamus extends Animal {
    public void talk() {
        System.out.println("Roar!");
    }
    //...
}

// In file rtci/ex6/Example6.java
class Example6 {

    public static void main(String[] args) {

        makeItTalk(new Cat());
        makeItTalk(new Dog());
        makeItTalk(new Hippopotamus());
    }

    public static void makeItTalk(Animal animal) {

        animal.talk();
    }
}
</PRE>
<LI>
Enables you to write code that doesn't need to know about subtypes
<LI>
To be an <CODE>Animal</CODE>, you must be able to <CODE>talk()</CODE>
</UL>

<HR align="left" width="100%" size="4" noshade>
<H2>Why Design with Types?</H2>
<UL>
<LI>
Clients should know what semantics are coming
<LI>
Dynamic binding best
<LI>
<CODE>instanceof</CODE> and downcasting second best
<LI>
Reflection is least desirable, because types imply semantics
</UL>

<P>
Mention UI factory object in Service UI API, in that "UIFactory" is not a type that
all UI factory interfaces implement. It is a concept. Client must use the equivalent
of instanceof and downcasting. Here, to separate the codebases, there's a different
way to find out the UI factory types. (UIFactoryTypes attribute). But the reason we
did it that way was we didn't feel we could predict what was coming. By leaving it
open, by forcing clients to look for interfaces they understand, we made the UI
factory concept more amenable to future changes. Same thing with the service context
object in the current Place API. But in general, should avoid the instanceof and
downcasting thing and go for specific types (i.e, <CODE>UIFactory</CODE>
rather than concepts, (i.e., UI factory).

<P>
The real trouble with reflection philosophically, which I want to emphasize here, is
that you lose semantics when you just look at message signatures. What types really
add is the semantics to go along with the message signatures. Using reflection in Java is
like using a weakly typed language. If there's a method with an appropriate signature,
invoke it. What I said in most recent seminar, "How can I ask you to do something for
me, if I don't know what you are going to do when I ask?"

</TD>
</TR>

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/interfacedesign/PreferPoly.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
