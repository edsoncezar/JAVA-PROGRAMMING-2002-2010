<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 5 - Interpreted and Dynamic

</title>
</head>
<body bgcolor="#ffffff">








 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="interpreted.doc.html">PREV</a>
 | <a href="interpreted.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="1167"><i>	5.1	</i> Dynamic Loading and Binding
</a></h2>

<blockquote>
<a name="1168"><!-- --></a>
The Java language&#39;s portable and interpreted nature produces a highly <em>dynamic</em> and <em>dynamically-extensible</em> system. The Java language was designed to adapt to evolving environments. Classes are linked in as required and can be downloaded from across networks. Incoming code is verified before being passed to the interpreter for execution. <p>
<a name="1169"><!-- --></a>
Object-oriented programming has become accepted as a means to solve at least a part of the &#34;software crisis&#34;, by assisting encapsulation of data and corresponding procedures, and encouraging reuse of code. Most programmers doing object-oriented development today have adopted C++ as their language of choice. But C++ suffers from a serious problem that impedes its widespread use in the production and distribution of &#34;software ICs&#34;. This defect is known as the <em>fragile superclass problem</em>.<p>
</blockquote>
<br>
<h3>
<a name="1170"><!-- --></a>
<i>	5.1.1	</i> The Fragile Superclass Problem
</h3>

<blockquote>
<a name="1171"><!-- --></a>
This problem arises as a side-effect of the way that C++ is usually implemented. Any time you add a new method or a new instance variable to a class, any and all classes that reference that class will require a recompilation, or they&#39;ll break. Keeping track of the dependencies between class definitions and their clients has proved to be a fruitful source of programming error in C++, even with the help of &#34;make&#34;-like utilities.The fragile superclass issue is sometimes also referred to as the &#34;constant recompilation problem.&#34; You <em>can</em> avoid these problems in C++, but with extraordinary difficulty, and doing so effectively means not using any of the language&#39;s object-oriented features directly. By avoiding the object-oriented features of C++, developers defeat the goal of re-usable &#34;software ICs&#34;.<p>
</blockquote>
<br>
<h3>
<a name="1173"><!-- --></a>
<i>	5.1.2	</i> Solving the Fragile Superclass Problem
</h3>

<blockquote>
<a name="1174"><!-- --></a>
The Java language solves the fragile superclass problem in several stages. The Java compiler doesn&#39;t compile references down to numeric values&#45;&#45;instead, it passes symbolic reference information through to the byte code verifier and the interpreter. The Java interpreter performs final name resolution once, when classes are being linked. Once the name is resolved, the reference is rewritten as a numeric offset, enabling the Java interpreter to run at full speed.<p>
<a name="1176"><!-- --></a>
Finally, the storage layout of objects is not determined by the compiler. The layout of objects in memory is deferred to run time and determined by the interpreter. Updated classes with new instance variables or methods can be linked in without affecting existing code.<p>
<a name="1177"><!-- --></a>
At the small expense of a name lookup the first time any name is encountered, the Java language eliminates the fragile superclass problem. Java programmers can use object-oriented programming techniques in a much more straightforward fashion without the constant recompilation burden engendered by C++. Libraries can freely add new methods and instance variables without any effect on their clients. Your life as a programmer is simpler.<p>
</blockquote>
<br>
<h3>
<a name="1183"><!-- --></a>
<i>	5.1.3	</i> Run-Time Representations
</h3>

<blockquote>
<a name="1184"><!-- --></a>
Classes in the Java language have a run-time representation. There is a class named <kbd>Class</kbd>, instances of which contain run-time class definitions. If you&#39;re handed an object, you can find out what class it belongs to. In a C or C++ program, you may be handed a pointer to an object, but if you don&#39;t know what type of object it is, you have no way to find out. In the Java language, finding out based on the run-time type information is straightforward. <p>
<a name="1185"><!-- --></a>
It is also possible to look up the definition of a class given a string containing its name. This means that you can compute a data type name and easily have it dynamically-linked into the running system.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="interpreted.doc.html">PREV</a>
 | <a href="interpreted.doc2.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://docs.rinet.ru:8080/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
