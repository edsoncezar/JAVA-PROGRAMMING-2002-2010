<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<title>The Java Language Environment: 3 - Java is Object Oriented

</title>
</head>
<body bgcolor="#ffffff">








 
<table width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="object.doc1.html">PREV</a>
 | <a href="object.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font --></td><td align=right><i>The Java Language Environment</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="6681"><i>	3.3	</i> Basics of Objects
</a></h2>

<blockquote>
<a name="6841"><!-- --></a>
<p><img src="http://docs.rinet.ru/langenviron/Object.doc.anc2.gif"><p>
<a name="6726"><!-- --></a>
<p>
<a name="6838"><!-- --></a>
<p>
<a name="6839"><!-- --></a>
<p>
<a name="6840"><!-- --></a>
<p>
<a name="6730"><!-- --></a>
<p>
<a name="6845"><!-- --></a>
An object&#39;s <em>behavior</em> is defined by its <em>methods</em>. Methods manipulate the instance variables to create new state; an object&#39;s methods can also create new objects. <p>
<a name="3915"><!-- --></a>
The small picture to the left is a commonly used graphical representation of an object. The diagram illustrates the conceptual structure of a software object&#45;&#45;it&#39;s kind of like a cell, with an outer membrane that&#39;s its interface to the world, and an inner nucleus that&#39;s protected by the outer membrane.<p>
<a name="2353"><!-- --></a>
An object&#39;s <em>instance variables</em> (data) are packaged, or encapsulated, within the object. The instance variables are surrounded by the object&#39;s <em>methods</em>. With certain well-defined exceptions, the object&#39;s methods are the only means by which other objects can access or alter its instance variables. In Java, classes can declare their instance variables to be <kbd>public</kbd>, in which cases the instance variables are globally accessible to other objects. Declarations of accessibility are covered later in <em>Access Specifiers</em>. Later on you will also find a discussion on class variables and class methods.<p>
</blockquote>
<br>
<h3>
<a name="1372"><!-- --></a>
<i>	3.3.1	</i> Classes
</h3>

<blockquote>
<a name="1542"><!-- --></a>
A <em>class</em> is a software construct that defines the data (state) and methods (behavior) of the specific concrete objects that are subsequently constructed from that class. In Java terminology, a class is built out of <em>members</em>, which are either <em>fields</em> or <em>methods</em>. Fields are the data for the class. Methods are the sequences of statements that operate on the data. Fields are normally specific to an object&#45;&#45;that is, every object constructed from the class definition will have its own copy of the field. Such fields are known as <em>instance variables.</em> Similarly, methods are also normally declared to operate on the instance variables of the class, and are thus known as <em>instance methods</em>. <p>
<a name="5978"><!-- --></a>
A class in and of itself is not an object. A class is like a blueprint that defines how an object will look and behave when the object is created or <em>instantiated</em> from the specification declared by the class. You obtain concrete objects by instantiating a previously defined class. You can instantiate many objects from one class definition, just as you can construct many houses all the same<a href="#6025"><sup>1</sup></a> from a single architect&#39;s drawing. Here&#39;s the basic declaration of a very simple class called Point<p>
</blockquote><a name="3107"><!-- --></a>
<blockquote><pre>    class Point extends Object {<br>        public double  x;    /*  <em>instance variable</em>  */<br>        public double  y;    /*  <em>instance variable</em>  */<br>    }</pre></blockquote><blockquote>
<a name="4534"><!-- --></a>
As mentioned, this declaration merely defines a template from which real objects can be instantiated, as described next.<p>
</blockquote>
<br>
<h3>
<a name="3121"><!-- --></a>
<i>	3.3.2	</i> Instantiating an Object from its Class
</h3>

<blockquote>
<a name="4514"><!-- --></a>
Having declared the size and shape of the Point <em>class</em> above, any other object can now create a <kbd>Point</kbd> <em>object</em>&#45;&#45;an instance of the <kbd>Point</kbd> class&#45;&#45;with a fragment of code like this:<p>
</blockquote><a name="3122"><!-- --></a>
<blockquote><pre>    Point  myPoint;          //  <em>declares a variable to refer to a</em> Point <em>object<br></em><br>    myPoint = new Point();   //  <em>allocates an instance of  a</em> Point <em>object</em></pre></blockquote><blockquote>
<a name="3104"><!-- --></a>
Now, you can access the variables of this Point object by referring to the names of the variables, qualified with the name of the object:<p>
</blockquote><a name="3127"><!-- --></a>
<blockquote><pre>    myPoint.x = 10.0;<br>    myPoint.y = 25.7;</pre></blockquote><blockquote>
<a name="4157"><!-- --></a>
This referencing scheme, similar to a C structure reference, works because the instance variables of <kbd>Point</kbd> were declared <kbd>public</kbd> in the class declaration. Had the instance variables not been declared <kbd>public</kbd>, objects outside of the package within which <kbd>Point</kbd> was declared could not access its instance variables in this direct manner. The <kbd>Point</kbd> class declaration would then need to provide <em>accessor methods</em> to set and get its variables. This topic is discussed in a little more detail after this discussion on constructors. <p>
</blockquote>
<br>
<h3>
<a name="4517"><!-- --></a>
<i>	3.3.3	</i> Constructors
</h3>

<blockquote>
<a name="4518"><!-- --></a>
When you declare a class in Java, you can declare optional <em>constructors</em> that perform initialization when you instantiate objects from that class. You can also declare an optional <em>finalizer</em>, discussed later. Let&#39;s go back to our <kbd>Point</kbd> class from before:<p>
</blockquote><a name="4519"><!-- --></a>
<blockquote><pre>    class Point extends Object {<br>        public double  x;    /*  <em>instance variable</em>  */<br>        public double  y;    /*  <em>instance variable</em>  */<br>    <br>        Point() {        /*  <em>constructor to initialize to default zero value</em>  */<br>            x = 0.0;<br>            y = 0.0;<br>        }<br>                        /*  <em>constructor to initialize to specific value</em>  */<br>        Point(double x, double y) {<br>            this.x = x;    /*  <em>set instance variables to passed parameters</em>  */<br>            this.y = y;<br>        }<br>    }</pre></blockquote><blockquote>
<a name="4520"><!-- --></a>
Methods with the same name as the class as in the code fragment are called <em>constructors</em>. When you create (instantiate) an object of the <kbd>Point</kbd> class, the constructor method is invoked to perform any initialization that&#39;s needed&#45;&#45;in this case, to set the instance variables to an initial state.<p>
<a name="4521"><!-- --></a>
This example is a variation on the <kbd>Point</kbd> class from before. Now, when you wish to create and initialize <kbd>Point</kbd> objects, you can get them initialized to their default values, or you can initialize them to specific values:<p>
</blockquote><a name="4522"><!-- --></a>
<blockquote><pre>    Point  lowerLeft;<br>    Point  upperRight;<br><br>    lowerLeft = new Point();        /* <em> initialize to default zero value</em>  */<br>    upperRight = new Point(100.0, 200.0);  /* <em> initialize to non- zero </em>  */</pre></blockquote><blockquote>
<a name="4523"><!-- --></a>
The specific constructor that&#39;s used when creating a new <kbd>Point</kbd> object is determined from the type and number of parameters in the <kbd>new</kbd> invocation.<p>
</blockquote>

<blockquote>
<a name="5241"><!-- --></a>
<i><b> The <em>this</em> Variable
</b></i>
</blockquote>
<blockquote>
<a name="5242"><!-- --></a>
What&#39;s the <kbd>this</kbd> variable in the examples above? <kbd>this</kbd> refers to the object you&#39;re &#34;in&#34; right now. In other words, <kbd>this</kbd> refers to the receiving object. You use <kbd>this</kbd> to clarify which variable you&#39;re referring to. In the two-parameter <kbd>Point</kbd> method, <kbd>this.x</kbd> means the <kbd>x</kbd> instance variable of this object, rather than the <kbd>x</kbd> parameter to the <kbd>Point</kbd> method.<p>
<a name="5255"><!-- --></a>
In the example above, the constructors are simply conveniences for the <kbd>Point</kbd> class. Situations arise, however, where constructors are necessary, especially in cases where the object being instantiated must itself instantiate other objects. Let&#39;s illustrate one of those situations by declaring a <kbd>Rectangle</kbd> class that uses two <kbd>Point</kbd> objects to define its bounds:<p>
</blockquote><a name="4994"><!-- --></a>
<blockquote><pre>    class Rectangle extends Object {<br>       private Point lowerLeft;<br>        private Point upperRight;<br><br>        Rectangle() {<br>            lowerLeft = new Point();<br>            upperRight = new Point();<br>        }<br>            . . .<br>         <em>instance methods appear in here<br></em>            . . .<br>    }</pre></blockquote><blockquote>
<a name="5032"><!-- --></a>
In this example, the <kbd>Rectangle</kbd> constructor is vitally necessary to ensure that the two <kbd>Point</kbd> objects are instantiated at the time a <kbd>Rectangle</kbd> object is instantiated, otherwise, the <kbd>Rectangle</kbd> object would subsequently try to reference points that have not yet been allocated, and would fail.<p>
</blockquote>
<br>
<h3>
<a name="4559"><!-- --></a>
<i>	3.3.4	</i> Methods and Messaging
</h3>

<blockquote>
<a name="6852"><!-- --></a>
<p>
<a name="4563"><!-- --></a>
<p><img src="http://docs.rinet.ru/langenviron/Object.doc.anc3.gif"><p>
<a name="6652"><!-- --></a>
<p>
<a name="6653"><!-- --></a>
<p>
<a name="6654"><!-- --></a>
<p>
<a name="6655"><!-- --></a>
<p>
<a name="6656"><!-- --></a>
<p>
<a name="6657"><!-- --></a>
<p>
<a name="6658"><!-- --></a>
If an object wants another object to do some work on its behalf, then in the parlance of object-oriented programming, the first object sends a <em>message</em> to the second object. In response, the second object selects the appropriate <em>method</em> to invoke. Java method invocations look similar to functions in C and C++.<p>
<a name="2228"><!-- --></a>
Using the message passing paradigms of object-oriented programming, you can build entire networks and webs of objects that pass messages between them to change state. This programming technique is one of the best ways to create models and simulations of complex real-world systems. Let&#39;s redefine the declaration of the <kbd>Point</kbd> class from above such that its instance variables are <kbd>private</kbd>, and supply it with <em>accessor methods</em> to access those variables.<p>
</blockquote><a name="4162"><!-- --></a>
<blockquote><pre>    class Point extends Object {<br>        private double  x;    /*  <em>instance variable</em>  */<br>        private double  y;    /*  <em>instance variable</em>  */<br>    <br>        Point() {    /*  <em>constructor to initialize to zero</em>  */<br>            x = 0.0;<br>            y = 0.0;<br>        }<br>                           /*  <em>constructor to initialize to specific value</em>  */<br>        Point(double x, double y) {<br>            this.x = x;<br>            this.y = y;<br>        }<br>        public void setX(double x) {    /*  <em>accessor method</em>  */<br>            this.x = x;<br>        }<br>        public void setY(double y) {    /*  <em>accessor method</em>  */<br>            this.y = y;<br>        }<br>        public double getX() {    /*  <em>accessor method</em>  */<br>            return x;<br>        }<br>        public double getY() {    /*  <em>accessor method</em>  */<br>            return y;<br>        }<br>    }</pre></blockquote><blockquote>
<a name="4164"><!-- --></a>
These method declarations provide the flavor of how the <kbd>Point</kbd> class provides access to its variables from the outside world. Another object that wants to manipulate the instance variables of <kbd>Point</kbd> objects must now do so via the accessor methods:<p>
</blockquote><a name="4165"><!-- --></a>
<blockquote><pre>    Point  myPoint;          //  <em>declares a variable to refer to a</em> Point <em>object<br></em><br>    myPoint = new Point();   //  <em>allocates an instance of  a</em> Point <em>object</em></pre></blockquote><a name="4167"><!-- --></a>
<blockquote><pre>    myPoint.setX(10.0);      //  <em>sets the x variable via the accessor method<br></em>    myPoint.setY(25.7);</pre></blockquote><blockquote>
<a name="4278"><!-- --></a>
Making instance variables <kbd>public</kbd> or <kbd>private</kbd> is a design tradeoff the designer makes when declaring the classes. By making instance variables <kbd>public</kbd>, you expose details of the class implementation, thereby providing higher efficiency and conciseness of expression at the possible expense of hindering future maintenance efforts. By hiding details of the internal implementation of a class, you have the potential to change the implementation of the class in the future without breaking any code that uses that class.<p>
</blockquote>
<br>
<h3>
<a name="2653"><!-- --></a>
<i>	3.3.5	</i> Finalizers
</h3>

<blockquote>
<a name="3936"><!-- --></a>
You can also declare an optional <em>finalizer</em> that will perform necessary tear-down actions when the garbage collector is about to free an object. This code fragment illustrates a <kbd>finalize</kbd> method in a class. <p>
</blockquote><a name="2602"><!-- --></a>
<blockquote><pre>    /**<br>      * Close the stream when garbage is collected.<br>      */  <br>    protected void finalize() {<br>        try {<br>            file.close();<br>        } catch (Exception e) {<br>        }<br>    } </pre></blockquote><blockquote>
<a name="2654"><!-- --></a>
This <kbd>finalize</kbd> method will be invoked when the object is about to be garbage collected, which means that the object must shut itself down in an orderly fashion. In the particular code fragment above, the <kbd>finalize</kbd> method merely closes an I/O file stream that was used by the object, to ensure that the file descriptor for the stream is closed. <p>
</blockquote>
<br>
<h3>
<a name="2600"><!-- --></a>
<i>	3.3.6	</i> Subclasses
</h3>

<blockquote>
<a name="1378"><!-- --></a>
<em>Subclasses</em> are the mechanism by which new and enhanced objects can be defined in terms of existing objects. One example: a zebra is a horse with stripes. If you wish to create a zebra object, you notice that a zebra is kind of like a horse, only with stripes. In object-oriented terms, you&#39;d create a new class called Zebra, which is a <em>subclass</em> of the Horse class. In Java language terms, you&#39;d do something like this:<p>
</blockquote><a name="1379"><!-- --></a>
<blockquote><pre>    class Zebra extends Horse {<br>        <em>Your new instance variables and new methods go here<br></em>    }</pre></blockquote><blockquote>
<a name="1380"><!-- --></a>
The definition of <kbd>Horse</kbd>, wherever it is, would define all the methods to describe the <em>behavior</em> of a horse: eat, neigh, trot, gallop, buck, and so on. The only method you need to override is the method for drawing the hide. You gain the benefit of already written code that does all the work&#45;&#45;you don&#39;t have to re-invent the wheel, or in this case, the hoof. The <kbd>extends</kbd> keyword tells the Java compiler that Zebra is a subclass of Horse. Zebra is said to be a <em>derived class</em>&#45;&#45;it&#39;s derived from Horse, which is called a <em>superclass</em>. <p>
<a name="5262"><!-- --></a>
Here&#39;s an example of making a subclass which is a variant of our <kbd>Point</kbd> class from previous examples to create a new three-dimensional point called <kbd>ThreePoint</kbd>:<p>
</blockquote><a name="5266"><!-- --></a>
<blockquote><pre>    class Point extends Object {<br>        protected double  x;    /*  <em>instance variable</em>  */<br>        protected double  y;    /*  <em>instance variable</em>  */<br>    <br>        Point() {    /*  <em>constructor to initialize to zero</em>  */<br>            x = 0.0;<br>            y = 0.0;<br>        }<br>    }</pre></blockquote><a name="5096"><!-- --></a>
<blockquote><pre>    class ThreePoint extends Point {<br>        protected double z;    /*  <em>the z coordinate of the point</em>  */<br>        <br>        ThreePoint() {      /*  <em>default constructor</em>  */<br>            x = 0.0;        /*  <em>initialize the coordinates</em>  */<br>            y = 0.0;<br>            z = 0.0;<br>        }<br>        ThreePoint(double x, double y, double z) {/* <em>specific constructor</em> */<br>            this.x = x;        /*  <em>initialize the coordinates</em>  */<br>            this.y = y;<br>            this.z = z;<br>        }<br>    }</pre></blockquote><blockquote>
<a name="1385"><!-- --></a>
Notice that <kbd>ThreePoint</kbd> adds a new instance variable for the <em>z</em> coordinate of the point. The <em>x</em> and <em>y</em> instance variables are <em>inherited</em> from the original <kbd>Point</kbd> class, so there&#39;s no need to declare them in <kbd>ThreePoint</kbd>. However, notice we had to make <kbd>Point</kbd>&#39;s instance variables <kbd>protected</kbd> instead of <kbd>private</kbd> as in the previous examples. Had we left <kbd>Point</kbd>&#39;s instance variables <kbd>private</kbd>, even its subclasses would be unable to access them, and the compilation would fail.<p>
<a name="5147"><!-- --></a>
Subclasses enable you to use existing code that&#39;s already been developed and, much more important, tested, for a more generic case. You override the parts of the class you need for your specific behavior. Thus, subclasses gain you reuse of existing code&#45;&#45;you save on design, development, and testing. The Java run-time system provides several libraries of utility functions that are tested and are also <em>thread safe</em>. <p>
<a name="6867"><!-- --></a>
All classes in Java ultimately inherit from <kbd>Object</kbd>. <kbd>Object</kbd> is the most general of all the classes. New classes that you declare add functionality to their superclasses. The further down the class hierarchy you go&#45;&#45;that is, the further you get from <kbd>Object</kbd>	&#45;&#45;the more specialized you classes become.<p>
</blockquote>

<blockquote>
<a name="6868"><!-- --></a>
<i><b> Single Inheritance and the Class Hierarchy
</b></i>
</blockquote>
<blockquote>
<a name="6869"><!-- --></a>
Java implements what is known as a <em>single-inheritance</em> model. A new class can subclass (<em>extend</em>, in Java terminology) only one other class. Ultimately, all classes eventually inherit from the <kbd>Object</kbd> class, forming a tree structure with <kbd>Object</kbd> as its root. This picture illustrates the class hierarchy of the classes in the Java utility package, <kbd>java.util.</kbd><p>
<a name="6186"><!-- --></a>
The <kbd>HashTable</kbd> class is a subclass of <kbd>Dictionary</kbd>, which in turn is a subclass of <kbd>Object</kbd>. <kbd>Dictionary</kbd> inherits all of <kbd>Object</kbd>&#39;s variables and methods (behavior), then adds new variables and behavior of its own. Similarly, <kbd>HashTable</kbd> inherits all of <kbd>Object</kbd>&#39;s variables and behavior, plus all of <kbd>Dictionary</kbd>&#39;s variables and behavior, and goes on to add its own variables and behavior. <p>
<a name="6873"><!-- --></a>
Then the <kbd>Properties</kbd> class subclasses <kbd>HashTable</kbd> in turn, inheriting all the variables and behavior of its class hierarchy. In a similar manner, <kbd>Stack</kbd> and <kbd>ObserverList</kbd> are subclasses of <kbd>Vector</kbd>, which in turn is a subclass of <kbd>Object</kbd>. The power of the object-oriented methodology is apparent&#45;&#45;none of the subclasses needed to re-implement the basic functionality of their superclasses, but needed only add their own specialized behavior.<p>
<a name="6874"><!-- --></a>
<p>
<a name="6875"><!-- --></a>
<p><img src="http://docs.rinet.ru/langenviron/Object.doc.anc.gif"><p>
<a name="6208"><!-- --></a>
<p>
<a name="6792"><!-- --></a>
<p>
<a name="6793"><!-- --></a>
<p>
<a name="6794"><!-- --></a>
<p>
<a name="6795"><!-- --></a>
<p>
<a name="6804"><!-- --></a>
<p>
<a name="6949"><!-- --></a>
However, the above diagram points out the minor weakness with the single-inheritance model. Notice that there are two different kinds of <em>enumerator</em> classes in the picture, both of which inherit from <kbd>Object</kbd>. An enumerator class<p>
<a name="6765"><!-- --></a>
implements behavior that iterates through a collection, obtaining the elements of that collection one by one. The enumerator classes define behavior that both <kbd>HashTable</kbd> and <kbd>Vector</kbd> find useful. Other, as yet undefined collection classes, such as list or queue, may also need the behavior of the enumeration classes. Unfortunately, they can inherit from only one superclass.<p>
<a name="6231"><!-- --></a>
A possible method to solve this problem would be to enhance some superclass in the hierarchy to add such useful behavior when it becomes apparent that many subclasses could use the behavior. Such an approach would lead to chaos and bloat. If every time some common useful behavior were required for all subsequent subclasses, a class such as <kbd>Object</kbd> would be undergoing constant modification, would grow to enormous size and complexity, and the specification of its behavior would be constantly changing. Such a &#34;solution&#34; is untenable. The elegant and workable solution to the problem is provided via Java <em>interfaces</em>, the subject of the next topic.<p>
</blockquote>
<br>
<h3>
<a name="6185"><!-- --></a>
<i>	3.3.7	</i> Java Language Interfaces
</h3>

<blockquote>
<a name="6244"><!-- --></a>
<em>Interfaces</em> were introduced to Java to enhance Java&#39;s single-inheritance model. The designers of Java decided that multiple inheritance created too many problems for programmers and compiler writers, and decided that a single inheritance model was better overall. Some of the problems described in the previous discussion on the single-inheritance model are solved in a more elegant fashion by the use of interfaces.  <p>
<a name="6597"><!-- --></a>
An <em>interface</em> in the Java language is simply a specification of methods that an object declares it implements. An interface does not include instance variables or implementation code&#45;&#45;only declarations of constants and methods. The concept of an interface in the Java language was borrowed from the Objective-C concept of a <em>protocol</em>.<p>
<a name="6703"><!-- --></a>
Whereas a class can inherit from only one superclass, a class can <em>implement</em> as many interfaces as it chooses to. Using the examples from the previous discussion, the <kbd>HashTableEnumerator</kbd> and <kbd>VectorEnumerator</kbd> classes both implement an <kbd>Enumeration</kbd> interface  that&#39;s specific to the characteristics of the <kbd>HashTable</kbd> and <kbd>Vector</kbd> classes. When you define a new collection class&#45;&#45;a <kbd>Queue</kbd> class, for instance&#45;&#45;you&#39;ll also probably define a <kbd>QueueEnumerator</kbd> class that implements the <kbd>Enumeration</kbd> interface.<p>
<a name="6704"><!-- --></a>
The concept of the interface is powerful&#45;&#45;classes that implement a given interface need do so only at the appropriate level in the class hierarchy. This picture illustrates the use of interfaces.<p>
<a name="6811"><!-- --></a>
<p>
<a name="6812"><!-- --></a>
<p><img src="http://docs.rinet.ru/langenviron/Object.doc.anc1.gif"><p>
<a name="6813"><!-- --></a>
<p>
<a name="6814"><!-- --></a>
<p>
<a name="6815"><!-- --></a>
<p>
<a name="6816"><!-- --></a>
<p>
<a name="6710"><!-- --></a>
In this illustration, interfaces are represented by rectangles. You see that the <kbd>Cloneable</kbd> interface is implemented by multiple classes. In addition, the <kbd>HashtableEnumerator</kbd> and the <kbd>VectorEnumerator</kbd> classes both implement the <kbd>Enumeration</kbd> interface. Any given class can implement as many interfaces as it wants to, and in any way that it wants to. Details of the actual implementation of the interface are hidden within the class definition, and should be replaceable without affecting the outside view of the interface in any way.  Recall, however, that an interface merely declares methods; it does not<p>
<a name="6712"><!-- --></a>
implement them.  When inheriting from classes (in languages such as C++), the implementation of inherited classes is also inherited, so more code can be reused when compared to the amount of code re-use in multiply-inherited interfaces.  For this reason, inheriting from interfaces provides a reasonable alternative to multiple inheritance, but this practice should not be seen as a substitute for the more powerful but often confusing practice of inheriting from multiple classes.<p>
</blockquote>
<br>
<h3>
<a name="6711"><!-- --></a>
<i>	3.3.8	</i> Access Control
</h3>

<blockquote>
<a name="1387"><!-- --></a>
When you declare a new class in Java, you can indicate the level of access permitted to its members&#45;&#45;that is, its instance variables and methods. Java provides four levels of access. Three of the levels must be explicitly specified: <kbd>public</kbd>, <kbd>protected</kbd>, and <kbd>private</kbd>. Members declared <kbd>public</kbd> are available to any other class anywhere. Members declared <kbd>protected</kbd> are accessible only to subclasses of that class, and nowhere else. Members declared <kbd>private</kbd> are accessible only from within the class in which they&#39;re declared&#45;&#45;they&#39;re not available even to their subclasses.<p>
<a name="6721"><!-- --></a>
<p>
<a name="1388"><!-- --></a>
The fourth access level doesn&#39;t have a name&#45;&#45;it&#39;s often called &#34;friendly&#34; and is the access level you obtain if you don&#39;t specify otherwise. The &#34;friendly&#34; access level indicates that the class&#39;s members are accessible to all objects within the same package, but inaccessible to objects outside the package. Packages, a useful tool for grouping together related collections of classes and interfaces, are discussed below.<p>
</blockquote>
<br>
<h3>
<a name="1389"><!-- --></a>
<i>	3.3.9	</i> Packages
</h3>

<blockquote>
<a name="6086"><!-- --></a>
Java <em>packages</em> are collections of classes and interfaces that are related to each other in some useful way. Such classes need to be able to access each other&#39;s instance variables and methods directly. A geometry package consisting of <kbd>Point</kbd> and <kbd>Rectangle</kbd> classes, for instance, might well be easier and cleaner to implement&#45;&#45;as well as more efficient&#45;&#45;if the <kbd>Point</kbd>&#39;s instance variables were directly available to the <kbd>Rectangle</kbd> class. Outside of the geometry package, however, the details of implementations are hidden from the rest of the world, giving you the freedom to changed implementation details without worrying you&#39;ll break code that uses those classes. Packages are created by storing the source files for the classes and interfaces of each package in a separate directory in the file system.<p>
<a name="6645"><!-- --></a>
The primary benefit of packages is the ability to organize many class definitions into a single unit. For example, all the Java I/O system code is collected into a single package called <kbd>java.io</kbd>. The secondary benefit from the programmer&#39;s viewpoint is that the &#34;friendly&#34; instance variables and methods are available to all classes within the same package, but not to classes defined outside the package.<p>
</blockquote>
<br>
<h3>
<a name="2996"><!-- --></a>
<i>	3.3.10	</i> Class Variables and Class Methods
</h3>

<blockquote>
<a name="2991"><!-- --></a>
Java follows conventions from other object-oriented languages in providing <em>class methods</em> and <em>class variables</em>. Normally, variables you declare in a class definition are <em>instance variables</em>&#45;&#45;there is one of those variables in every separate object created (instantiated) from the class. A class variable, on the other hand, is local to the class itself&#45;&#45;there&#39;s only a single copy of the variable and it&#39;s shared by every object you instantiate from the class. <p>
<a name="5067"><!-- --></a>
To declare class variables and class methods in Java programs, you declare them <kbd>static</kbd>. This short code fragment illustrates the declaration of class variables:<p>
</blockquote><a name="3014"><!-- --></a>
<blockquote><pre>    class Rectangle extends Object {<br>        static  final int version = 2;<br>        static  final int revision = 0;<br>    } </pre></blockquote><blockquote>
<a name="3005"><!-- --></a>
The <kbd>Rectangle</kbd> class declares two <kbd>static</kbd> variables to define the version and revision level of this class. Now, every instance of Rectangle you create from this class will share these same variables. Notice they&#39;re also defined as <kbd>final</kbd> because you want them to be constants.<p>
<a name="3058"><!-- --></a>
Class methods are common to an entire class. When would you use class methods? Usually, when you have behavior that&#39;s common to every object of a class. For example, suppose you have a <kbd>Window</kbd> class. A useful item of information you can ask the class is the current number of currently open windows.  This information is shared by every instance of <kbd>Window</kbd> and it is only available through knowledge obtained from other instances of <kbd>Window</kbd>.  For these reasons,  it is necessary to have just one class method to return the number of open windows.<p>
<a name="5074"><!-- --></a>
In general, class methods can operate only on class variables. Class methods can&#39;t access instance variables, nor can they invoke instance methods. Like class variables, you declare class methods by defining them as <kbd>static</kbd>. <p>
<a name="6147"><!-- --></a>
We say, &#34;in general&#34;, because you could pass an object reference to a class method, and the class method could then operate on the object&#39;s public instance variables, and invoke the object&#39;s instance methods via the reference. However, you&#39;re usually better off doing only class-like operations at the class level, and doing object-like operations at the object level.<p>
</blockquote>
<br>
<h3>
<a name="3057"><!-- --></a>
<i>	3.3.11	</i> Abstract Methods
</h3>

<blockquote>
<a name="2992"><!-- --></a>
Abstract methods are a powerful construct in the object-oriented paradigm. To understand abstract methods, we look at the notion of an <em>abstract superclass</em>. An abstract superclass is a class in which you declare methods that aren&#39;t actually implemented by that class&#45;&#45;they only provide place-holders that subsequent subclasses must override and supply their actual implementation.<p>
<a name="1392"><!-- --></a>
This all sounds wonderfully, well, <em>abstract</em>, so why would you need an abstract superclass? Let&#39;s look at a <em>concrete</em> example, no pun intended. Let&#39;s suppose you&#39;re going to a restaurant for dinner, and you decide that tonight you want to eat fish. Well, <em>fish</em> is somewhat abstract&#45;&#45;you generally wouldn&#39;t just order fish; the waiter is highly likely to ask you what <em>specific</em> kind of fish you want. When you actually get to the restaurant, you will find out what kind of fish they have, and order a specific fish, say, sturgeon, or salmon, or opakapaka.<p>
<a name="1393"><!-- --></a>
In the world of objects, an abstract class is like generic fish&#45;&#45;the abstract class defines generic state and generic behavior, but you&#39;ll never see a real live implementation of an abstract class. What you will see is a <em>concrete subclass</em> of the abstract class, just as opakapaka is a specific (concrete) kind of fish.<p>
<a name="4943"><!-- --></a>
Suppose you are creating a drawing application. The initial cut of your application can draw rectangles, lines, circles, polygons, and so on. Furthermore, you have a series of operations you can perform on the shapes&#45;&#45;move, reshape, rotate, fill color, and so on. You <em>could</em> make each of these graphic shapes a separate class&#45;&#45;you&#39;d have a Rectangle class, a Line class, and so on. Each class needs instance variables to define its position, size, color, rotation and so on, which in turn dictates methods to set and get at those variables.<p>
<a name="1394"><!-- --></a>
At this point, you realize you can collect all the instance variables into a single abstract superclass called <kbd>Graphical</kbd>, and implement most of the methods to manipulate the variables in that abstract superclass. The skeleton of your abstract superclass might look something like this:<p>
</blockquote><a name="1395"><!-- --></a>
<blockquote><pre>abstract class Graphical extends Object {<br>    protected Point lowerLeft;     //  <em>lower left of bounding box<br></em>    protected Point upperRight;    //  <em>upper right of bounding box<br></em>                     . . .<br>                <em>more instance variables<br></em>                     . . .<br>    public void setPosition(Point ll, Point ur) {<br>        lowerLeft = ll;<br>        upperRight = ur;<br>    }<br>    abstract void drawMyself();   //  <em>abstract method<br></em>    }<br><br>}</pre></blockquote><blockquote>
<a name="1588"><!-- --></a>
Now, you can&#39;t instantiate the <kbd>Graphical</kbd> class, because it&#39;s declared <kbd>abstract</kbd>. You can only instantiate a <em>subclass</em> of it. You would implement the <kbd>Rectangle</kbd> class or the <kbd>Circle</kbd> class as a subclass of <kbd>Graphical</kbd>. Within <kbd>Rectangle</kbd>, you&#39;d provide a <em>concrete</em> implementation of the <kbd>drawMySelf </kbd>method that draws a rectangle, because the definition of <kbd>drawMySelf</kbd> must by necessity be unique to each shape inherited from the <kbd>Graphical</kbd> class. Let&#39;s see a small fragment of the <kbd>Rectangle</kbd> class declaration, where its <kbd>drawMySelf</kbd> method operates in a somewhat PostScript&#39;y fashion:<p>
</blockquote><a name="4950"><!-- --></a>
<blockquote><pre>abstract class Rectangle extends Graphical {<br>    void drawMySelf() {	        //  <em>really does the drawing<br></em>        moveTo(lowerLeft.x, lowerLeft.y);<br>        lineTo(upperRight.x, lowerLeft.y);<br>        lineTo(upperRight.x, upperRight.y)<br>        lineTo(lowerLeft.x, upperRight.y);<br>                     . . .<br>                  <em>and so on and so on<br></em>                     . . .<br>    }<br>}</pre></blockquote><blockquote>
<a name="4948"><!-- --></a>
Notice, however, that in the declaration of the <kbd>Graphical</kbd> class, the <kbd>setPosition</kbd> method was declared as a regular (<kbd>public void</kbd>) method. All methods that <em>can</em> be implemented by the abstract superclass can be declared there and their implementations defined at that time. Then, every class that inherits from the abstract superclass will also inherit those methods.<p>
<a name="5359"><!-- --></a>
You can continue in this way adding new shapes that are subclasses of <kbd>Graphical</kbd>, and most of the time, all you ever need to implement is the methods that are unique to the specific shape. You gain the benefit of re-using all the code that was defined inside the abstract superclass.<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --> <a href="index.html">CONTENTS</a> | <a href="object.doc1.html">PREV</a>
 | <a href="object.doc3.html">NEXT</a> <!-- | <a href="Readings.doc.html">INDEX</a>  -->
<!-- /font -->

<hr>
Please send any comments or corrections to
<a href="mailto:jdk-comments@java.sun.com">jdk-comments@java.sun.com</a><br>
<font size="-1"><i><A HREF="http://docs.rinet.ru:8080/html/Copyright.doc.html">Copyright</a> &#169 1997 Sun Microsystems, Inc. All Rights Reserved.</i></font>


</body>
</html>
