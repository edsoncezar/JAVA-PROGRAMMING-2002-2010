<HTML>
<HEAD>
<TITLE>Chapter 30 -- Performing Secure Transactions</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">












<H1><FONT SIZE=6 COLOR=#FF0000>Chapter 30</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Performing Secure Transactions</FONT>
</H1>
<P>
<I><B>by Mark Wutka</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#LettingCustomersDigitallySignOrders">
Letting Customers Digitally Sign Orders</A>
<LI><A HREF="#UsingEncryptioninAllNetworkCommunications">
Using Encryption in All Network Communications</A>
<LI><A HREF="#CreatingJavaServicesforNetscapeServers">
Creating Java Services for Netscape Servers</A>
<UL>
<LI><A HREF="#CreatingaServerSidequotHelloWorldquot">
Creating a Server-Side &quot;Hello World&quot;</A>
<LI><A HREF="#InstallingaNewServerSideJavaApplet">
Installing a New Server-Side Java Applet</A>
<LI><A HREF="#HandlingFormsfromServerSideApplets">
Handling Forms from Server-Side Applets</A>
<LI><A HREF="#SendingFilesasaResponse">
Sending Files as a Response</A>
<LI><A HREF="#ReturningMultiPartResponses">
Returning Multi-Part Responses</A>
<LI><A HREF="#MaintainingInformationBetweenAppletInvocations">
Maintaining Information Between Applet Invocations</A>
</UL>
<LI><A HREF="#MakingServerSideAppletsWorkonDifferentWebServers">
Making Server-Side Applets Work on Different Web Servers</A>
<LI><A HREF="#PerformingSecureTransactions">
Performing Secure Transactions</A>
</UL>

<HR>
<P>
When you do business on the Web, you need to assure your customers
that their personal information is safe. Obviously, you need to
keep the credit card numbers secure, but sometimes you need to
protect more than that. Sometimes the contents of an order need
to be kept quiet. You may be selling items or services of a personal
nature, for instance. Sometimes competitors can learn about a
company's plans just by analyzing their recent orders.
<P>
Obviously, you need to provide Web services that support encryption
to keep the contents of the services private. For you to really
do this securely, you need a signed digital certificate, registered
with some trusted certificate authority. To protect your customers,
you should also allow customers to verify themselves with signed
certificates, as well.
<P>
As digital commerce becomes more mainstream, digital signatures
will continue to grow in importance. Your digital signature may
one day be as important, or even more important, than your handwritten
signature. Unfortunately, digital signatures are still rather
expensive to maintain. The average user isn't going to pay a fee
to a certificate authority just to keep their signature on file.
<P>
At some point, however, there should be a cheaper way to keep
digital signatures on file. It may be a service offered by credit
card companies, who have a vested interest in preventing fraud.
It is also possible that other signature mechanisms will be available
soon.
<H2><A NAME="LettingCustomersDigitallySignOrders"><FONT SIZE=5 COLOR=#FF0000>
Letting Customers Digitally Sign Orders</FONT></A></H2>
<P>
Security is making its way onto the Web slowly, but its pace is
increasing. With the increasing need to secure browsers and servers,
more companies are able to offer secure services. There are enough
companies doing business without security, however, so that the
ability to do a secure transaction is a competitive advantage.
<P>
One of the next new features will be personal digital signatures.
Each customer will have their own signature, or set of signatures.
By letting a customer digitally sign an order, you protect yourself
and your customer.
<P>
From the customer's standpoint, being able to digitally sign orders
means that other people can't place phony orders using the customer's
name and credit card number. This gives the customer extra security,
knowing that even if someone had their credit card number, they
couldn't place an order on your system.
<P>
This mechanism also protects you from the same kind of fraud.
You don't want someone else placing phony orders using the names
of your good customers. When you receive a digitally signed order,
you know that it came from the person who signed the order.
<P>
Your customer places an order, digitally signing it to verify
that it is their order. The customer then sends both the order
and the digital signature to you, as shown in Figure 30.1.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-1.gif"><B>Figure 30.1 : </B><I>A customer sends you a digitally signed
order</I>.</A>
<P>
At this point, you can confirm the customer's identity by verifying
it with a certificate authority. If someone were trying to create
a fake order, they would not know the customer's digital signature
key, so they would not be able to sign the order.
<P>
In the future, credit card companies might require digital signatures
on all electronic transactions. This could cut down on fraud,
as long as people keep their private signature keys away from
prying eyes. There are a number of signature exchange protocols
that may be required for credit card transactions. The credit
card company would need your signature on a receipt, as well as
the customer's.
<P>
After a customer sends you a digitally signed order, you create
an electronic credit card receipt and digitally sign it, then
pass it to the customer, as shown in Figure 30.2.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-2.gif"><B>Figure 30.2 : </B><I>You send the customer an electronic, digitally
signed credit card receipt</I>.</A>
<P>
Figure 30.3 illustrates the next step in the sequence. The customer
verifies your signature on the receipt, then digitally signs the
receipt and sends it back.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-3.gif"><B>Figure 30.3 : </B><I>The customer digitally signs the receipt
and sends it back</I>.</A>
<P>
Now, you have a signed receipt to send to the credit card company
which shows that the customer agrees to the transaction. The credit
card company can verify the customer's signature.
<P>
You can also use digital signatures to prevent the transmission
of credit card numbers over the Internet. In this case, you need
some way to get the customer's credit card number up front, as
well as the public key for their digital signature. You keep their
credit card number in a secure database, along with their signature
key and the customer account number.
<P>
Now, when a customer places an order, they give you only their
customer number, which you use to look up their credit card number.
Since you also require that the order is digitally signed, someone
else couldn't use that customer's account number.
<P>
It is conceivable that you could perform unencrypted transactions
this way, however, you still need to use a secure download method
to download the Java applets that will perform the transaction.
Otherwise, you have the potential for someone to create a phony
applet, as discussed in <A HREF="ch27.htm" >Chapter 27</A>, &quot;Encrypting Data.&quot;
<H2><A NAME="UsingEncryptioninAllNetworkCommunications"><FONT SIZE=5 COLOR=#FF0000>
Using Encryption in All Network Communications</FONT></A></H2>
<P>
At the moment, the only encryption mechanism that is readily accessible
to Java applets is through the SSL protocol built into the Web
browsers. Unfortunately, not all Java-enabled browsers support
SSL.
<P>
Future releases of Java will include a security library with many
encryption routines. This will eventually allow remote-object
systems, like RMI and CORBA, to support encrypted sessions. This
is extremely important. You don't want to be tied to the restrictions
of http communications, as you are when using https URLs (SSL-enabled
URLs).
<H2><A NAME="CreatingJavaServicesforNetscapeServers"><FONT SIZE=5 COLOR=#FF0000>
Creating Java Services for Netscape Servers</FONT></A></H2>
<P>
While it would be nice to write secure Web services using a Java
Web server like Jeeves or Jigsaw, these servers do not yet support
secure protocols such as SSL. If you were really desperate to
use one of these, you could write a CGI script on a secure server
to forward requests to the non-secure Java Web server and then
relay the results back. This is not a very pretty solution, however.
<P>
Netscape's Web servers support server-side Java programs, which
Netscape calls &quot;server-side applets.&quot; In addition, Netscape's
Web servers support the SSL protocol, allowing you to create secure
transactions. You used the SSL protocol in <A HREF="ch28.htm" >Chapter 28</A> to download
an applet securely. For secure transactions, you also use it to
transmit data.
<P>
Netscape took a more traditional CGI-like approach to server-side
Java. Every time the server gets a request that is serviced by
a server applet, the server creates a new instance of the server
applet and invokes that applet's <TT>run</TT>
command. When the applet has serviced the request and sent a result,
the applet terminates.
<P>
If you look at the <TT>HttpApplet</TT>
class, and its parent class, <TT>ServerApplet</TT>,
you'll notice that they are similar to CGI. Instead of environment
variables for the various HTTP header values, there are methods
to retrieve the interesting header values. You can retrieve any
value from the header using the <TT>getHeader
</TT>method, like:
<BLOCKQUOTE>
<PRE>
String contentType = getHeader(&quot;Content-type&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>ServerApplet</TT> class also
provides methods to get an input stream and an output stream for
the client connection. In CGI, these are mapped to the standard
input and standard output streams. The <TT>getInputStream</TT>
and <TT>getOutputStream</TT> methods
are defined as follows:
<BLOCKQUOTE>
<PRE>
public InputStream getInputStream() throws IOException
public OutputStream getOutputStream() throws IOException
</PRE>
</BLOCKQUOTE>
<P>
When your <TT>HttpApplet</TT> is ready
to return a response to the client, it calls the <TT>returnNormalResponse</TT>
method:
<BLOCKQUOTE>
<PRE>
public boolean returnNormalResponse(String contentType) throws IOException
</PRE>
</BLOCKQUOTE>
<P>
The <TT>returnNormalResponse</TT>
method returns true if you need to send a response. The reason
for this is that there is an HTTP request type called &quot;HEAD&quot;
that doesn't expect a response. The <TT>returnNormalResponse</TT>
method returns false if the incoming request was a HEAD request.
If you are returning an HTML form, you should use &quot;text/html&quot;
for the <TT>contentType</TT> parameter.
If you are returning non-HTML text, you should use a <TT>contentType</TT>
of &quot;text/plain.&quot;
<H3><A NAME="CreatingaServerSidequotHelloWorldquot">
Creating a Server-Side &quot;Hello World&quot;</A></H3>
<P>
You now have enough information to write the ubiquitous &quot;Hello
World&quot; program for a Netscape Web server. Listing 30.1 shows
the <TT>ServerHello class</TT>, which
generates a &quot;Hello World&quot; page in HTML.
<HR>
<BLOCKQUOTE>
<B>Listing 30.1&nbsp;&nbsp;Source Code for ServerHello.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;

public class ServerHello extends HttpApplet {

        ServerHello() {}

        public void run() throws Exception {

            if (returnNormalResponse(&quot;text/html&quot;)) {
                  PrintStream out = getOutputStream();

               out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
               out.println(&quot;&lt;TITLE&gt;Hello World!&lt;/TITLE&gt;&quot;);
               out.println(&quot;&lt;/HEAD&gt;&quot;);

               out.println(&quot;&lt;BODY&gt;&quot;);
               out.println(&quot;&lt;H1&gt;Hello World!&lt;/H1&gt;&quot;);
               out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
                }
        }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Figure 30.4 shows the very simple output from this applet on a
Web browser.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-4.gif"><B>Figure 30.4 : </B><I>Server-side Java applets may generate HTML
output</I>.</A>
<H3><A NAME="InstallingaNewServerSideJavaApplet">
Installing a New Server-Side Java Applet</A></H3>
<P>
The Netscape Web servers store all the Java applets in a single
directory. From the root directory of the server, the applets
are installed in <TT>plugins/java/applets</TT>.
When you install a new applet, you just copy the .class file into
that directory, and restart the server.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
While it seems to go against the &quot;on-demand&quot; loading concept taken by many Java environments, Netscape Web servers load all the Java applets at startup, taking the speed hit up front, instead of when the applet is requested.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Once you install a server-side Java applet, you can run it using
an URL of this form:
<BLOCKQUOTE>
<PRE>
http://<I>host_name</I>/server-java/<I>applet_name</I>
</PRE>
</BLOCKQUOTE>
<P>
For example, if you were running the ServerHello applet on a host
called <TT>pandora.contessa.com</TT>,
you would use the following URL:
<BLOCKQUOTE>
<PRE>
http://pandora.contessa.com/server-java/ServerHello
</PRE>
</BLOCKQUOTE>
<H3><A NAME="HandlingFormsfromServerSideApplets">
Handling Forms from Server-Side Applets</A></H3>
<P>
It is very simple to handle forms in a server-side applet. The
<TT>HttpApplet</TT> class takes the
same approach as the servlet API by returning the form parameters
in a hash table. You simply call the <TT>getFormData</TT>
method, like this:
<BLOCKQUOTE>
<TT>Hashtable formItems = getFormData();</TT>
</BLOCKQUOTE>
<P>
Listing 30.2 shows a server-side applet that displays a form,
and then receives the submitted form. It is able to do both of
these things because the form results are sent using an HTTP <TT>POST</TT>,
while the initial input form is retrieved via <TT>GET</TT>.
The applet simply checks to see what HTTP method was used to invoke
it.
<HR>
<BLOCKQUOTE>
<B>Listing 30.2&nbsp;&nbsp;Source Code for FormDemo.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;
import java.util.Hashtable;
import java.util.Enumeration;

// This is a Netscape server-side applet that generates a
// form which posts information back to this same applet.

public class FormDemo extends HttpApplet {

        FormDemo() {}

        public void run() throws Exception {

          if (returnNormalResponse(&quot;text/html&quot;)) {

// If this applet was retrieved with a GET, send the input form
               if (getMethod().equals(&quot;GET&quot;)) {
                    sendInputForm();
               } else {
// Otherwise, this must have been a post, so retrieve the posted data
                    processForm();
               }
          }
     }

     protected void sendInputForm()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Send the header
          out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
          out.println(&quot;&lt;TITLE&gt;Java-Five Needs Input!&lt;/TITLE&gt;&quot;);
          out.println(&quot;&lt;/HEAD&gt;&quot;);

          out.println(&quot;&lt;BODY&gt;&quot;);
          out.println(&quot;&lt;H1&gt;Give Me Some Input!&lt;/H1&gt;&quot;);

// Send the input form
          out.println(&quot;&lt;FORM action=\&quot;/server-java/FormDemo\&quot; &quot;+
               &quot;method=POST&gt;&quot;);

// Input field titled &quot;First Name&quot;
          out.println(&quot;First Name: &quot;);
          out.println(&quot;&lt;INPUT type=\&quot;text\&quot; name=\&quot;First Name\&quot;&gt;&quot;);
          out.println(&quot;&lt;P&gt;&quot;);

// Input field titled &quot;Last Name&quot;
          out.println(&quot;Last Name: &quot;);
          out.println(&quot;&lt;INPUT type=\&quot;text\&quot; name=\&quot;Last Name\&quot;&gt;&quot;);
          out.println(&quot;&lt;P&gt;&quot;);

// Button to submit the form
          out.println(&quot;&lt;INPUT type=submit&gt;&lt;P&gt;&quot;);
          out.println(&quot;&lt;/FORM&gt;&quot;);
          out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
        }

     protected void processForm()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Send the initial part of the response

          out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
          out.println(&quot;&lt;TITLE&gt;OOOOH!!  Input!! MMM!!&lt;/TITLE&gt;&quot;);
          out.println(&quot;&lt;/HEAD&gt;&quot;);

          out.println(&quot;&lt;BODY&gt;&quot;);
          out.println(&quot;&lt;H1&gt;Thanks for the input!&lt;/H1&gt;&quot;);
          out.println(&quot;Just for the record, here's what you sent:&lt;P&gt;&quot;);

// Get the fields from the form
          Hashtable formData = getFormData();
     
// For each field on the form, print the value
          Enumeration keys = formData.keys();
          while (keys.hasMoreElements()) {
               String key = (String) keys.nextElement();

               out.println(key+&quot;: &quot;+formData.get(key)+&quot;&lt;P&gt;&quot;);
          }
          out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<PRE>
Figure 30.5 shows the initial input form from this applet, while Figure 30.6 shows the results from the submission of the form.
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-5.gif"><B>Figure 30.5 : </B><I>The </I><TT>FormDemo</TT><I>
applet displays a simple input form</I>.</A>
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-6.gif"><B>Figure 30.6 : </B><I>The </I><TT>FormDemo</TT><I>
applet processes its own input form</I>.</A>
<H3><A NAME="SendingFilesasaResponse">
Sending Files as a Response</A></H3>
<P>
Instead of generating HTML or other content straight from Java,
you can create server-side applets that return other files. For
example, you might be creating an on-demand audio or video library
controlled by a server-side applet. The applet verifies the client's
access, handles any billing information, and then tells the server
to return the requested file. The <TT>returnFile</TT>
method lets you tell the server which file to return. The method
is defined like this:
<BLOCKQUOTE>
<PRE>
public void returnFile(String contentType, File file)
throws IOException
</PRE>
</BLOCKQUOTE>
<P>
The file is an absolute pathname; it is not relative to the root
directory of the Web server. This means that a server-side applet
can return any file on the system, as long as it has sufficient
permissions.
<P>
If the server can figure out the type of the file based on its
suffix (like <TT>.gif</TT> or <TT>.mov</TT>),
you don't have to specify the content type when you return a file.
In these cases, you can use the alternate version of <TT>returnFile</TT>:
<BLOCKQUOTE>
<PRE>
public void returnFile(File file) throws IOException
</PRE>
</BLOCKQUOTE>
<P>
Listing 30.3 shows a minimal server-side applet that returns an
image file. Since the filename ends with &quot;.jpg,&quot; the
applet doesn't have to specify the content type.
<HR>
<BLOCKQUOTE>
<B>Listing 30.3&nbsp;&nbsp;Source Code for ShowPicture.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.File;

public class ShowPicture extends HttpApplet {

        ShowPicture() {}

        public void run() throws Exception {
          returnFile(new File(&quot;\\pictures\\kaitlynn.jpg&quot;));
        }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Figure 30.7 shows the picture returned by this applet. Notice
that there is no surrounding text, only an image.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-7.gif"><B>Figure 30.7 : </B><I>A server-side applet can return images,
movies, and audio files</I>.</A>
<H3><A NAME="ReturningMultiPartResponses">
Returning Multi-Part Responses</A></H3>
<P>
Multi-part responses are a neat little hack to HTTP that allow
you to perform primitive kinds of animation. The idea is that,
instead of sending a single response to the client, you send multiple
responses. This allows you to send a series of images as an animation,
or display a page of information that occasionally updates itself.
The <TT>returnMultipartResponse</TT>
method in the <TT>HttpApplet</TT>
class allows your server-side Java programs to return multi-part
responses:
<BLOCKQUOTE>
<PRE>
public boolean returnMultipartResponse(String subtype)
     throws IOException
</PRE>
</BLOCKQUOTE>
<P>
The <TT>subtype</TT> value should
either be &quot;mixed&quot; or &quot;x-mixed-replace.&quot; Once
you send the multi-part response header, you send responses normally,
using the <TT>returnNormalResponse</TT>
method.
<P>
When you generate a multi-part response, you keep the connection
to the client open until you tell the client that you are through
sending responses. In a server-side applet, you tell the client
you are through sending responses by calling the <TT>endMultipartResponse</TT>
method:
<BLOCKQUOTE>
<PRE>
public void endMultipartResponse() throws IOException
</PRE>
</BLOCKQUOTE>
<P>
Listing 30.4 shows a server-side applet that displays the current
time using a multi-part response. It updates the time every five
seconds.
<HR>
<BLOCKQUOTE>
<B>Listing 30.4&nbsp;&nbsp;Source Code for Multipart.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;
import java.util.Date;

// This applet sends a multi-part response that displays the
// current time every 5 seconds.

public class Multipart extends HttpApplet {

        Multipart() {}

        public void run() throws Exception {

// Tell the server we are sending a multi-part response

          if (returnMultipartResponse(&quot;x-mixed-replace&quot;)) {

               PrintStream out = getOutputStream();

               while (true) {

// Send the next part of the response
                    returnNormalResponse(&quot;text/html&quot;);

                    out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
                    out.println(&quot;&lt;TITLE&gt;Web Clock&lt;/TITLE&gt;&quot;);
                    out.println(&quot;&lt;/HEAD&gt;&quot;);

                    out.println(&quot;&lt;BODY&gt;&quot;);
                    out.println(&quot;&lt;H1&gt;Current Time&lt;/H1&gt;&quot;);
                    out.println(new Date());
                    out.println(&quot;&lt;P&gt;&quot;);
                    out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);

// Wait a little while before sending another
                    Thread.sleep(5000);
               }
                }
        }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="MaintainingInformationBetweenAppletInvocations">
Maintaining Information Between Applet Invocations</A></H3>
<P>
One of the advantages to the Servlet API is that there is only
one instance of a particular servlet and it stays around after
a request completes. The Netscape server-side applets don't work
that way. There are multiple instances of a particular applet,
and the instances go away after completing their assigned task.
<P>
This is not a difficult problem to get around, however. All you
need to do is set up another class that is implemented as a singleton.
In other words, there is only one instance of the class. Listing
30.5 shows an example singleton class.
<HR>
<BLOCKQUOTE>
<B>Listing 30.5&nbsp;&nbsp;Source Code for PersistentInfo.java
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.util.Vector;

// This is a singleton class that maintains a vector of
// strings. Since the constructor is protected, the only
// way you can get an instance of this class is by calling
// the instance method, which returns the single shared
// copy of the class.

public class PersistentInfo
{
// singleInstance is the lone instance of this class
     protected static PersistentInfo singleInstance;

// info is the vector of strings
     protected Vector info;

// instance returns the lone instance of this class, and creates one
// if there isn't one already.

     public synchronized static PersistentInfo instance()
     {
          if (singleInstance == null) {
               singleInstance = new PersistentInfo();
          }
          return singleInstance;
     }

     protected PersistentInfo()
     {
          info = new Vector();
     }

// getInfo returns an array of the strings stored in the info vector

     public synchronized String[] getInfo()
     {
          String[] strings = new String[info.size()];

          info.copyInto(strings);

          return strings;
     }

// addInfo adds another string to the info list

     public synchronized void addInfo(String newInfo)
     {
          info.addElement(newInfo);
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>PersistentInfo</TT> class
stays active while the Java VM is running. This means that any
instances of <TT>HttpApplet</TT> can
access the info in <TT>PersistentInfo</TT>
at any time. You can use this method to keep database connections
open, or keep open a session with a host that may take a long
time to set up.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you use singleton classes with your applets, be especially careful about using synchronization. While you may not be explicitly creating threads, each <TT>HttpApplet</TT> object runs in its own thread.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Listing 30.6 shows a server-side applet that uses the <TT>PersistentInfo</TT>
object. The applet generates a form with a single text field.
Any information in the text field is added to the <TT>PersistentInfo</TT>
object.
<HR>
<BLOCKQUOTE>
<B>Listing 30.6&nbsp;&nbsp;Source Code for PersistDemo.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;
import java.util.Hashtable;
import java.util.Enumeration;

// This is a Netscape server-side applet that generates a
// form which posts information back to this same applet.
// It uses a second class called PersistentInfo.
// The PersistentInfo class sticks around, so information
// is preserved for future instances of this class.

public class PersistDemo extends HttpApplet {

        PersistDemo() {}

        public void run() throws Exception {

          if (returnNormalResponse(&quot;text/html&quot;)) {

// If this applet was retrieved with a GET, send the input form
               if (getMethod().equals(&quot;GET&quot;)) {
                    sendInputForm();
               } else {
// Otherwise, this must have been a post, so retrieve the posted data
                    processForm();
               }
          }
     }

     protected void sendInputForm()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Send the header
          out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
          out.println(&quot;&lt;TITLE&gt;Persistent Information Demo&lt;/TITLE&gt;&quot;);
          out.println(&quot;&lt;/HEAD&gt;&quot;);

          out.println(&quot;&lt;BODY&gt;&quot;);

          out.println(&quot;&lt;H1&gt;Current information:&lt;/H1&gt;&quot;);

// Print out the strings currently stored in the PersistenceInfo class

          String strings[] = PersistentInfo.instance().getInfo();

          for (int i=0; i &lt; strings.length; i++) {
               out.println(strings[i]+&quot;&lt;P&gt;&quot;);
          }

          out.println(&quot;&lt;H1&gt;Please enter some new information&lt;/H1&gt;&quot;);

// Send the input form
          out.println(&quot;&lt;FORM action=\&quot;/server-java/PersistDemo\&quot; &quot;+
               &quot;method=POST&gt;&quot;);

// Input field titled &quot;First Name&quot;
          out.println(&quot;Information: &quot;);
          out.println(&quot;&lt;INPUT type=\&quot;text\&quot; name=\&quot;Information\&quot;&gt;&quot;);
          out.println(&quot;&lt;P&gt;&quot;);

// Button to submit the form
          out.println(&quot;&lt;INPUT type=submit&gt;&lt;P&gt;&quot;);
          out.println(&quot;&lt;/FORM&gt;&quot;);
          out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
        }

     protected void processForm()
     throws Exception
     {
// Get the fields from the form
          Hashtable formData = getFormData();
     
// If there's any information, add it to the PersistentInfo class
          String newInfo = (String) formData.get(&quot;Information&quot;);
          if (newInfo != null) {
               PersistentInfo.instance().addInfo(newInfo);
          }

// Put up another form so we can get more input
          sendInputForm();
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Figure 30.8 shows the output from this server-side applet.
<P>
<A HREF="http://docs.rinet.ru/JSol/f30-8.gif"><B>Figure 30.8 : </B><I>A singleton object can preserve information
for multiple </I><TT>HttpApplet</TT><I>
instances</I>.</A>
<H2><A NAME="MakingServerSideAppletsWorkonDifferentWebServers"><FONT SIZE=5 COLOR=#FF0000>
Making Server-Side Applets Work on Different Web Servers</FONT></A></H2>
<P>
If you need to create secure server-side Java objects, whether
they are applets or servlets, you want to do the tough work only
once. In fact, you want to write the application only one time.
<P>
After that, you may have to do a little work hooking your application
into the local Web server. This goes back to one of the basic
design principles, where you design the application without considering
the user interface. When you run an application on a Java Web
server, the applet or servlet represents the user interface.
<P>
Try to create the application without regard to the user interface.
Don't return HTML forms from the application itself, and don't
let it parse HTML. Instead, dedicate your servlet, or server-side
applet, to handling HTML and invoking methods on a separate application
object.
<P>
This method will allow you to provide multiple forms of access
to your application. You might have a Web interface and a CORBA
interface to the same application simultaneously.
<H2><A NAME="PerformingSecureTransactions"><FONT SIZE=5 COLOR=#FF0000>
Performing Secure Transactions</FONT></A></H2>
<P>
The only mechanism currently available for performing a secure
transaction with Java is through https URLs. Furthermore, the
only Web servers that currently support Java on the server side,
and https, are the Netscape Web servers.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If the URL for your service starts with http and not https, your transactions are <FONT FACE="I Helvetica Oblique">not</FONT> encrypted.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This will certainly not be the case forever, though. As security
becomes integrated into the Java environment, more Web servers,
and other systems, will support encryption and digital signatures.
The trick, as always, is to design and build your applications
so you can run them now, but keep them flexible enough to embrace
other technologies as they become available.
<P>
Listing 30.7 shows a framework for a simple ordering system. Notice
that the system doesn't have any knowledge of applets or servlets-just
ordering.
<HR>
<BLOCKQUOTE>
<B>Listing 30.7&nbsp;&nbsp;Source Code for TheStore.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
// A dummy storefront that has some items for sale.
// The store doesn't record its transactions, however.

public class TheStore
{
// Make sure there's only one instance of the store

     protected static TheStore singleInstance;

     protected StoreItem items[];

     public static TheStore instance()
     {
          if (singleInstance == null) {
               singleInstance = new TheStore();
          }
          return singleInstance;
     }

// Create a store with some items
     protected TheStore()
     {
          items = new StoreItem[3];

          items[0] = new StoreItem(&quot;Dongle&quot;, 199);
          items[1] = new StoreItem(&quot;Widget&quot;, 599);
          items[2] = new StoreItem(&quot;Tweaker&quot;, 799);
     }

// Return a list of available items

     public StoreItem[] getItems()
     throws StoreException
     {
          try {
               return (StoreItem[]) items.clone();
          } catch (Exception e) {
               return null;
          }
     }

// A dummy routine for purchasing products

     public void purchase(String customerId, String itemList[])
     throws StoreException
     {
// Normally you would do something here to record the purchase
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This class also uses some auxiliary classes, which are shown in
Listings 30.8 and 30.9.
<HR>
<BLOCKQUOTE>
<B>Listing 30.8&nbsp;&nbsp;Source Code for StoreException.java
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class StoreException extends Exception
{
     public StoreException(String why)
     {
          super(why);
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 30.9&nbsp;&nbsp;Source Code for StoreItem.java<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class StoreItem
{
     public String itemName;
     public int price;

     public StoreItem(String itemName, int price)
     {
          this.itemName = itemName;
          this.price = price;
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Now that the first step has been taken, and there is an application
defined, you can start creating different interfaces into the
application. Since you already have some examples of server-side
applets that present HTML forms and parse them, it is fairly simple
to create a similar applet that places orders with this application.
Listing 30.10 shows an HTML front end for this application.
<HR>
<BLOCKQUOTE>
<B>Listing 30.10&nbsp;&nbsp;Source Code for HTMLStoreFront.java
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

// This class implements an HTML interface for the TheStore class.

public class HTMLStoreFront extends HttpApplet {

        HTMLStoreFront() {}

        public void run() throws Exception {

          if (returnNormalResponse(&quot;text/html&quot;)) {

// If this applet was retrieved with a GET, send the input form
               if (getMethod().equals(&quot;GET&quot;)) {
                    sendInputForm();
               } else {
// Otherwise, this must have been a post, so retrieve the posted data
                    processForm();
               }
          }
     }

     protected void sendInputForm()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Send the header
          out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
          out.println(&quot;&lt;TITLE&gt;The Store&lt;/TITLE&gt;&quot;);
          out.println(&quot;&lt;/HEAD&gt;&quot;);

          out.println(&quot;&lt;BODY&gt;&quot;);
          out.println(&quot;&lt;H1&gt;What would you like to order?&lt;/H1&gt;&quot;);

// Send the input form
          out.println(&quot;&lt;FORM action=\&quot;/server-java/HTMLStoreFront\&quot; &quot;+
               &quot;method=POST&gt;&quot;);

          out.println(&quot;&lt;P&gt;Customer ID #: &quot;);
          out.println(&quot;&lt;INPUT type=text name=\&quot;customerID\&quot;&gt;&quot;);
          out.println(&quot;&lt;P&gt;&quot;);
// List the items on sale from the store, and their prices
          StoreItem[] items = TheStore.instance().getItems();

          for (int i=0; i &lt; items.length; i++) {
               out.println(&quot;&lt;INPUT type=checkbox name=\&quot;&quot;+
                    items[i].itemName+&quot;\&quot; value=off&gt;&quot;);
               out.println(items[i].itemName+&quot;     &quot;+
                    items[i].price+&quot;&lt;P&gt;&quot;);
          }

// Button to submit the form
          out.println(&quot;&lt;INPUT type=submit&gt;&lt;P&gt;&quot;);
          out.println(&quot;&lt;/FORM&gt;&quot;);
          out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
        }

     protected void processForm()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Get the fields from the form
          Hashtable formData = getFormData();

          Vector partOrder = new Vector();
          String customerID = null;

// For each field on the form, see if the checkbox is on

          Enumeration keys = formData.keys();
          while (keys.hasMoreElements()) {
               String key = (String) keys.nextElement();

// If we got the customerID field, save it and go on

               if (key.equals(&quot;customerID&quot;)) {
                    customerID = (String) formData.get(key);
                    continue;
               }

// If the checkbox was on for this part, add it to the parts vector

               partOrder.addElement(key);
          }

          String[] orderItems = new String[partOrder.size()];

          partOrder.copyInto(orderItems);

          try {
               TheStore.instance().purchase(customerID, orderItems);

// Send a success response
               out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
               out.println(&quot;&lt;TITLE&gt;The Store - Order Completed&quot;);
               out.println(&quot;&lt;/TITLE&gt;&quot;);
               out.println(&quot;&lt;/HEAD&gt;&quot;);

               out.println(&quot;&lt;BODY&gt;&quot;);
               out.println(&quot;&lt;H1&gt;Order Complete. &quot;);
               out.println(&quot;Thanks for the business!&lt;/H1&gt;&quot;);

               out.println(&quot;&lt;P&gt;Items on your order:&lt;P&gt;&quot;);
               for (int i=0; i &lt; orderItems.length; i++) {
                    out.println(orderItems[i]+&quot;&lt;P&gt;&quot;);
               }

          } catch (Exception e) {

// If we got an error ordering, print the reason
               out.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
               out.println(&quot;&lt;TITLE&gt;The Store - Order Aborted!&quot;);
               out.println(&quot;&lt;/TITLE&gt;&quot;);
               out.println(&quot;&lt;/HEAD&gt;&quot;);

               out.println(&quot;&lt;BODY&gt;&quot;);
               out.println(&quot;&lt;H1&gt;Order Aborted!&lt;/H1&gt;&quot;);
               out.println(&quot;Here's why:&lt;P&gt;&quot;);
               out.println(e+&quot;&lt;P&gt;&quot;);
          }
          out.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Plain old HTML forms are pretty boring. You really want to liven
up your ordering system by running a Java applet on the client
side, right? You can do this, and still keep everything secure!
<P>
You can use the technique outlined in <A HREF="ch6.htm" >Chapter 6</A> &quot;Communicating
with a Web Server,&quot; for posting to a URL. This will allow
you to send secure data to a server-side applet, which can then
interpret the posted data and send a response.
<P>
Rather than making your applet parse the form returned by the
<TT>HTMLStoreFront</TT> class, you
can create a similar class that is friendly to applets. Instead
of sending HTML data, it sends plain text in a format that the
applet can easily read. Listing 30.11 shows such a class.
<HR>
<BLOCKQUOTE>
<B>Listing 30.11&nbsp;&nbsp;Source Code for AppletStoreFront.java
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import netscape.server.applet.*;
import java.io.PrintStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

// This class implements a secure interface for the TheStore class.
// This interface is used by client-side applets to store and
// retrieve data securely.

public class AppletStoreFront extends HttpApplet {

        AppletStoreFront() {}

        public void run() throws Exception {

          if (returnNormalResponse(&quot;text/plain&quot;)) {

// If this applet was retrieved with a GET, send the input form
               if (getMethod().equals(&quot;GET&quot;)) {
                    sendItemList();
               } else {
// Otherwise, this must have been a post, so retrieve the posted data
                    processOrder();
               }
          }
     }

     protected void sendItemList()
     throws Exception
     {
                PrintStream out = getOutputStream();

          StoreItem[] items = TheStore.instance().getItems();

          for (int i=0; i &lt; items.length; i++) {
               out.println(items[i].itemName);
               out.println(items[i].price);
          }
        }

     protected void processOrder()
     throws Exception
     {
                PrintStream out = getOutputStream();

// Get the fields from the form
          Hashtable formData = getFormData();

          Vector partOrder = new Vector();
          String customerID = null;

// For each field on the form, see if the checkbox is on

          Enumeration keys = formData.keys();
          while (keys.hasMoreElements()) {
               String key = (String) keys.nextElement();

// If we got the customerID field, save it and go on

               if (key.equals(&quot;customerID&quot;)) {
                    customerID = (String) formData.get(key);
                    continue;
               }

// add the part to the parts vector

               partOrder.addElement(key);
          }

          String[] orderItems = new String[partOrder.size()];

          partOrder.copyInto(orderItems);

          try {
               out.println(&quot;OK&quot;);
          } catch (Exception e) {
               out.println(&quot;ERROR: &quot;+e);
          }
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Once again, you haven't had to change a single line of code in
the original application class. All you do is add new user interfaces
for it. You could follow this same track and create an RMI interface
and a CORBA interface to this application. Of course, if you can't
get a secure version of RMI or CORBA yet, you can't do secure
transactions.
<HR>

<CENTER><P><A HREF="ch29.htm"><IMG SRC="http://docs.rinet.ru/JSol/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JSol/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JSol/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch31.htm"><IMG SRC="http://docs.rinet.ru/JSol/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
