<HTML>
<HEAD>
<TITLE>Chapter 24 -- Writing Web Services for Jeeves</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">












<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp; 24</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Writing Web Services for Jeeves</FONT>
</H1>
<P>
<I><B>by David Edgar Liebke</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#WhatIsJeeves">
What Is Jeeves?</A>
<LI><A HREF="#TheJeevesHTTPServer">
The Jeeves HTTP Server </A>
<UL>
<LI><A HREF="#ArchitecturalOverview">
Architectural Overview</A>
<LI><A HREF="#InstallingandRunningtheJeevesHTTPServer">
Installing and Running the Jeeves HTTP Server</A>
<LI><A HREF="#AdministeringtheJeevesWebServer">
Administering the Jeeves Web Server</A>
<LI><A HREF="#HTTPServerSecurity">
HTTP Server Security</A>
</UL>
<LI><A HREF="#ExtendingJeevesFunctionalitywithServlets">
Extending Jeeves' Functionality with Servlets</A>
<UL>
<LI><A HREF="#EmployingtheServletAPI">
Employing the Servlet API</A>
<LI><A HREF="#UsingtheJeevesDevelopmentToolkit">
Using the Jeeves Development Toolkit</A>
</UL>
<LI><A HREF="#BuildingaDatabaseServlet">
Building a Database Servlet</A>
<UL>
<LI><A HREF="#GettingtheInformationfromtheUsers">
Getting the Information from the Users</A>
<LI><A HREF="#ConnectingYourServlettoaJDBCDatabase">
Connecting Your Servlet to a JDBC Database</A>
<LI><A HREF="#InsertingDataintheDatabase">
Inserting Data in the Database</A>
<LI><A HREF="#SearchingtheDatabase">
Searching the Database</A>
</UL>
<LI><A HREF="#BuildingaSimpleAutonomousAgentSystemwithJeeves">
Building a Simple Autonomous Agent System with Jeeves</A>
<UL>
<LI><A HREF="#UsingObjectSerializationtoTransportAgentsAcrosstheInternet">
Using Object Serialization to Transport Agents Across the
Internet</A>
<LI><A HREF="#BuildingtheRemoteAgency">
Building the Remote Agency</A>
<LI><A HREF="#CreatingaGenericAgentInterface">
Creating a Generic Agent Interface</A>
<LI><A HREF="#ImplementingaDatabaseSearchAgent">
Implementing a Database Search Agent</A>
<LI><A HREF="#BuildingtheHomeAgency">
Building the Home Agency</A>
<LI><A HREF="#LaunchingtheAgent">
Launching the Agent</A>
<LI><A HREF="#DebriefingtheAgent">
Debriefing the Agent</A>
</UL>
</UL>
<HR>
<P>
<FONT COLOR=#000000>Jeeves is a Java-based Web server development
toolkit that includes a fully functional HTTP Web server. This
chapter describes how to write servlets that extend the function
of the HTTP server using the Web server toolkit.</FONT>
<P>
The chapter begins by introducing the HTTP server's architecture.
You will go through the process of administering the server. This
background knowledge lays the foundation for the rest of the chapter.
<P>
In the second part of the chapter, you learn how to write servlets
that extend Jeeves' functions. This section begins with an introduction
to the servlet API, which is at the heart of Jeeves' functionality
and extensibility. You then learn about Jeeves' rich collection
of tools that enhance servlet development.
<P>
Finally, two examples show you what can be done with servlets
and Jeeves. The first is a database servlet that puts a Web front
end on any database that supports the Java Database Connectivity
(JDBC) interface. The second takes advantage of Java's object
serialization to create a simple example of an autonomous agent
system.
<H2><A NAME="WhatIsJeeves"><FONT SIZE=5 COLOR=#FF0000>
What Is Jeeves?</FONT></A></H2>
<P>
Jeeves is often described simply as a Java Web server, but it
is much more. Jeeves is a server development toolkit. At the center
of the Jeeves toolkit is a package of generic server classes.
With these classes, any developer can quickly build connection-oriented
servers.
<P>
Another important component of the toolkit is the <TT><I>servlet</I></TT>.
Servlets are Java objects that comply with the servlet API and
are used to add functions to Web servers. The servlet API is Sun's
proposed standard for extending Web server functions with Java.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In addition to Jeeves, Acme Serve is a basic Web server that complies with the servlet API. It is available at <TT><B><A HREF="http://www.acme.com/">http://www.acme.com/</A></B></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In addition to the servlet API and the generic server classes,
the Jeeves toolkit includes security classes, administrative classes,
utility classes, and a set of servlets that provide basic Web
server functions.
<P>
The Jeeves HTTP server was developed from this toolkit and is
a fully functioning Web server that provides all the features
common to other Web servers.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
For more information about Jeeves, check out <TT><B><A HREF="http://www.javasoft.com/products/jeeves">http://www.javasoft.com/products/jeeves</A></B></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheJeevesHTTPServer"><FONT SIZE=5 COLOR=#FF0000>
The Jeeves HTTP Server </FONT></A></H2>
<P>
This part of the chapter introduces you to the Jeeves HTTP server.
It begins with an architectural overview and then moves on to
basic server installation and administration.
<P>
By the end of this section, you'll have a basic understanding
of the server architecture and administrative design. This lays
the foundation for extending the server with servlets, which you
will learn how to do in the second part of this chapter.
<H3><A NAME="ArchitecturalOverview">
Architectural Overview</A></H3>
<P>
The Jeeves HTTP server is built on the framework provided by the
generic server classes discussed earlier. This framework is the
core of the Jeeves server development toolkit. Here is a brief
description of the workings of a generic Jeeves server, followed
by a description of the specific workings of the HTTP server.
<P>
An object of the <TT>sun.server.Server</TT>
class waits in a loop for connection requests. Connections are
placed on a queue while the server determines if there are handler
objects of the <TT>sun.server.ServerHandler</TT>
class available in the handler thread pool.
<P>
If none are available and the maximum number of handler threads
has not been reached, the server starts a new handler thread.
If, on the other hand, the number of handlers exceeds the minimum
needed, and some have been idle for a period longer than the specified
timeout parameter, the idle handlers expire.
<P>
In the case of the HTTP server, once the server receives an HTTP
request, it is queued for servicing by the pool of HTTP server
handler threads. The HTTP handler then authorizes and applies
name translation rules to the request, and passes the request
on to the appropriate servlet.
<P>
Servlets provide the core function of the Jeeves HTTP server,
as well as providing a means for extending that function. The
HTTP server includes a set of core servlets that provide common
Web server functions.
<P>
For instance, the <TT>FileServlet</TT>
fulfills HTTP <TT>GET</TT> requests,
returning the requested file to the client. The <TT>Invoker</TT>
servlet is used to dynamically invoke servlets that have been
explicity requested by a client using an URL of the form:
<BLOCKQUOTE>
<TT><B>http://ServerHostName/servlet/&lt;servletName&gt;</B></TT>
</BLOCKQUOTE>
<P>
The <TT>Invoker</TT> supports only
local servlets but will soon be able to dynamically load servlets
from across a network. The <TT>SSInclude</TT>
servlet parses server-side include files (files with an .shtml
extension) and calls any servlet that was referenced.
<P>
The <TT>CgiServlet</TT> provides backward
compatibility for the large body of existing CGI programs. The
<TT>ImageMapServlet</TT> uses server-side
image maps. Finally, there is the <TT>Admin</TT>
Servlet that works together with the Admin applet to help with
administrative tasks (you'll learn more about this in the next
section).
<H3><A NAME="InstallingandRunningtheJeevesHTTPServer">
Installing and Running the Jeeves HTTP Server</A></H3>
<P>
First, you need a host that has the Java runtime installed. Once
you have an appropriate host, installing Jeeves is simply a matter
of unzipping the distribution and running the httpd program found
in the bin directory under the main installation directory. You
can test whether the server is up by pointing a Web browser at
the following URL:
<BLOCKQUOTE>
<TT><B>http://ServerHostName:8888/</B></TT>
</BLOCKQUOTE>
<P>
The server's default port is 8888; you will learn how to change
this and other defaults in this chapter.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You must have at least version 1.0.2 of the JDK to run Jeeves.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you are running Jeeves on a Windows 95 machine, you must make sure that the logs directory is under the main installation directory. Unzip tends not to extract directories that have no files, as is the case with the logs directory.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="AdministeringtheJeevesWebServer">
Administering the Jeeves Web Server</A></H3>
<P>
There are two ways to administer the Jeeves Web server. You can
use the administration Web page, which includes an applet that
enables you to modify many of the server's parameters dynamically.
Or you can change the configuration files, listed in Table 24.1,
by hand.
<P>
You can adjust many parameters. Some of these changes take effect
immediately and others do not take effect until the server is
restarted. In the following section, you will proceed step-by-step
through the administration process, using both the administration
Web page and the configuration files.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Some properties can be changed only by hand. For instance, the server allows you to change the welcome page property from the default of index.html but you cannot do this from the administration Web page. You must change the httpd.properties file using a 
text editor.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER><B>Table 24.1&nbsp;&nbsp;Jeeves Configuration Files</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=131><I>File Name</I></TD><TD WIDTH=459><I>Properties</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>httpd.properties</TD><TD WIDTH=459>Server name, port number, minimum threads, maximum threads, timeout, ramcache, keepalive, keepalive timeout, and location of other property files
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>rules.properties</TD><TD WIDTH=459>Translation rules for invoking servlets
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>alias.properties</TD><TD WIDTH=459>Translation rules for path aliases
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>servlet.properties</TD><TD WIDTH=459>Servlet codebase, servlet code, and initArgs
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>mime.properties</TD><TD WIDTH=459>MIME configuration
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=131>acl.properties</TD><TD WIDTH=459>Access control file
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Administering Jeeves from a Java-Enabled Browser</H4>
<P>
You can manage the Jeeves Web server remotely using any Java-enabled
Web browser. Once the server is running, you can access the administration
Web page by pointing your browser at the following URL:
<BLOCKQUOTE>
<TT><B>http://ServerHostName:8888/admin/admin.html</B></TT>
</BLOCKQUOTE>
<P>
You are prompted for a user name and password. The default administration
account name and password are <TT><B>admin</B></TT>.
Once authorized, you see the page shown in Figure 24.1.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-1.gif"><B>Figure 24.1 : </B><I>HTTP configuration using the Admin applet</I>.</A>
<P>
The window on the left includes a list of administrative tasks,
including HTTP configuration, log configuration, file aliasing,
servlet aliasing, servlet loading, MIME configuration, user configuration,
group configuration, access control list (ACL) configuration,
and resource protection.
<H4>Modifying Basic Web Server Parameters</H4>
<P>
Jeeves has many tunable parameters. Figure 24.1 shows the parameters
you can modify from the administration Web page. There are other
properties, such as the server user (UNIX version only) and server
host name, that can be changed only from the httpd.properties
file.
<P>
Jeeves lets you set the number of handler threads that are started
and how long an idle thread remains before being destroyed. In
the httpd.properities file, you'll find the following thread properties:
<TT>server.min.threads</TT>, <TT>server.max.threads</TT>,
and <TT>server.timeout</TT>.
<P>
Jeeves uses connection <TT>keepalive</TT>
to improve performance by keeping the connections to client browsers
open even after the request has been fulfilled. This reduces the
overhead of bringing the connection up and down for multiple requests
from the same client.
<P>
The <TT>keepalive</TT> count property
determines the number of hits from a single client that are received
before the connection is brought down. The <TT>keepalive</TT>
timeout determines the time in seconds the connection stays up
after a request has been fulfilled.
<H4>Configuring Web Server Logging</H4>
<P>
You can specify where log files are stored and the level of logging
detail for the Access, Error, and Event logs. These changes are
made from the Log Configuration screen (see Figure 24.2) or the
httpd.properties file.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-2.gif"><B>Figure 24.2 : </B><I>Log Configuration using the Admin applet</I>.</A>
<P>
The Access log is in Common Log format, which lets you use existing
log-analyzing scripts on them. All the log files reside in the
$JEEVES-HOME/logs directory.
<H4>Creating File Aliases</H4>
<P>
You can map virtual paths in the requested URL to an arbitrary
real path name on the server's disk. These changes take effect
immediately if done from the File Aliasing screen (see Figure
24.3); otherwise, you can make the changes to the alias.properties
file.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-3.gif"><B>Figure 24.3 : </B><I>File aliasing using the Admin applet</I>.</A>
<H4>Configuring MIME</H4>
<P>
The mime.properties file and the Mime Section of the administration
Web page allows you to map Mime types to file extensions. This
information is sent from the server to the client browser.
<P>
The browser uses this information to figure out what to do with
the file it is about to receive from the server. For example,
in the case of a file with a .mov extension, the browser should
start up a QuickTime viewer. You can also change the mime.properties
file by hand.
<H4>Loading Servlets into the Web Server</H4>
<P>
To execute servlets, you must map the servlet name to a class
that lies somewhere in the server's <TT>CLASSPATH</TT>
environment variable. You can do this from the Servlet Loading
screen of the administration Web page (see Figure 24.4).
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-4.gif"><B>Figure 24.4 : </B><I>Servlet loading using the Admin applet</I>.</A>
<P>
Remote servlets can also be loaded by specifying their URL to
the location field of the administration page.
<P>
When you use the Web page, the changes take effect immediately.
When you use the servlets.properties file, you can map the servlet
called <TT>myservlet</TT> to the <TT>MyServlet</TT>
class in the <TT>mypackage</TT> package
with the following entry:
<BLOCKQUOTE>
<PRE>
myservlet.code=mypackage.MyServlet
</PRE>
</BLOCKQUOTE>
<P>
When you change the servlet.properties file, the changes do not
take effect until the server is restarted. You can now invoke
<TT>myservlet</TT> with the following
URL:
<BLOCKQUOTE>
<TT><B>http://&lt;server_host&gt;/servlet/myservlet</B></TT>
</BLOCKQUOTE>
<P>
The virtual path <TT><B>/servlet</B></TT>
is mapped to the Invoker, which then calls the referenced servlet.
<H4>Creating Servlet Aliases</H4>
<P>
Servlets can also be mapped to arbitrary document names. When
you use the Servlet Aliasing screen (see Figure 24.5), all changes
are dynamic. Otherwise, change the rules.properties file. Again,
changes to the configuration files take effect after the server
has been restarted.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-5.gif"><B>Figure 24.5 : </B><I>Servlet aliasing using the Admin applet</I>.</A>
<P>
To map <TT>myservlet</TT> to <TT>myservlet.html</TT>,
put the following line into the rules.properties file:
<BLOCKQUOTE>
<PRE>
/myservlet.html=myservlet
</PRE>
</BLOCKQUOTE>
<H3><A NAME="HTTPServerSecurity">
HTTP Server Security</A></H3>
<P>
Jeeves uses an extensible, access-control list framework for controlling
requests for files and servlets. Only the Basic HTTP authentication
scheme is allowed, but Jeeves accepts the configuration of different
authentication schemes when they become available.
<P>
Access control lists can be associated with any file, directory,
or servlet. If a file or directory is not explicitly protected
by an ACL, it inherits the protection of its parent directory.
<P>
If there is no ACL for the entire directory structure, access
is granted. If a servlet is not explicitly protected by an ACL,
a default is used. If it doesn't exist, access is granted. Servlets
can also use their own access-control list, using the security
classes available in Jeeves.
<P>
Jeeves also makes use of security realms. Realms are used to set
broad security policies. When users, groups, or access-control
lists are added to the Web server, they are assigned to a realm.
<P>
People who have common security needs can be put into a Single
realm, such as the adminRealm. When you want to protect a resource,
you associate it with an access-control list in a realm. Jeeves
comes with two built-in realms, adminRealm and defaultRealm.
<H4>Servlet Security</H4>
<P>
The four basic types of servlets are core servlets, local servlets,
signed network servlets, and unsigned network servlets. These
servlets are treated differently with respect to security.
<P>
The core servlets and local servlets are thought to be trusted
and are granted full access to the server's resources. Signed
network servlets are granted a limited subset of privileges, as
determined by the site administrator. Unsigned servlets are not
trusted and are only executed in a restrictive environment, called
the <TT><I>server sandbox</I></TT>.
<H4>Protecting Web Resources</H4>
<P>
Using the Resource Protection section of the administration Web
page (see Figure 24.6), you can assign schemes and realms to Web
resources. These resources include documents and servlets.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-6.gif"><B>Figure 24.6 : </B><I>Protecting resources with the administration
Web page</I>.</A>
<H4>Adding Users to Security Realms</H4>
<P>
You can add users to different realms. The easiest way to add
users is through the Users screen of the administration Web page
(see Figure 24.7). Simply select the realm, and enter the user's
name and password.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-7.gif"><B>Figure 24.7 : </B><I>Adding a user to a realm with the Admin
applet</I>.</A>
<H4>Creating Groups of Users</H4>
<P>
You can group together users who should share the same privileges
using the Groups section of the administration Web page (see Figure
24.8). Select the realm and group you want to change and enter
the user you want to add. You can also create new groups by entering
the new group name in the field above the user name.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-8.gif"><B>Figure 24.8 : </B><I>Adding a user to a group with the Admin
applet</I>.</A>
<H4>Creating and Modifying ACLs</H4>
<P>
You can create new ACLs in a realm or add entries to an existing
realm from the ACL screen on the administration Web page (see
Figure 24.9). To add an entry to an existing ACL, select it from
the center window and click the Add ACL Entry button.
<P>
<A HREF="http://docs.rinet.ru/JSol/f24-9.gif"><B>Figure 24.9 : </B><I>Creating and modifying ACLs with the administration
Web page</I>.</A>
<P>
A new window appears. On the far left is a select box with a plus
sign and a minus sign. Choose the plus sign to grant privileges
or choose the minus sign to restrict them.
<P>
The next select box lets you choose whether you are modifying
the privileges of a group or of an individual user. There is a
text field to enter the group or user name. Finally, select the
privileges you want (such as <TT>GET</TT>,
<TT>POST</TT>, or <TT>PUT</TT>)
for that user or group.
<P>
To add a new ACL, choose the Create ACL button. A box appears
prompting you for the ACL name. To delete an ACL, select it from
the list and choose the Delete ACL button.
<H2><A NAME="ExtendingJeevesFunctionalitywithServlets"><FONT SIZE=5 COLOR=#FF0000>
Extending Jeeves' Functionality with Servlets</FONT></A></H2>
<P>
Now that you have a basic understanding of the HTTP server architecture
and are familiar with the administrative design, you can move
on to extending the server's function with servlets.
<P>
Creating servlets is like creating applets. Servlets are basically
applets without graphical front ends. Both servlets and applets
can be loaded dynamically from across a network.
<P>
Both applets and servlets are small programs that extend the function
of a browser or server, respectively. Both can run on any platform
that supports Java and the applet or servlet APIs, respectively.
<P>
In this part of the chapter, you are introduced to the Servlet
API, and you'll write some generic servlets. You then learn about
the additional classes provided by the Jeeves server development
toolkit that make extending Web server functions even simpler.
<P>
Next, you build a servlet that accesses any database that supports
the Java Database Connectivity (JDBC) interface, letting users
insert data and search for data from a Web page.
<P>
Finally, you use servlets to build a simple example of an autonomous
agent system. You'll write a couple of simple agency servlets
that provide an environment for roaming autonomous agents.
<P>
You'll create an agent that is transported to a remote agency
where it gathers some information from a JDBC database. The agency
asks the agent where it lives and sends it home.
<P>
The agent's home agency stores the agent in a file for later processing.
Finally, you'll restore the agent and extract the information
it has gathered.
<H3><A NAME="EmployingtheServletAPI">
Employing the Servlet API</A></H3>
<P>
The Servlet API is Sun's proposed standard for extending Web server
function with Java. Other servers that have Java APIs include
Netscape, Oracle, and the World Wide Web Consortium's Jigsaw server,
which, like Jeeves, is written entirely in Java.
<P>
Each of the above servers uses a different API. This reduces Java's
inherent platform independence by requiring developers to write
different Java programs for each of these servers.
<P>
A single Java Web server API will greatly simplify development
of Web services. It is not yet clear whether servlets will become
the standard that applets have become. But servlets have a lot
going for them, not the least of which is the support of Sun,
the developer of Java.
<P>
The classes associated with the servlet API are in a single package,
<TT>java.servlet</TT>. This package
includes four Java interfaces: <TT>ServletContext</TT>,
<TT>ServletRequest</TT>, <TT>ServletResponse</TT>,
and <TT>ServletStub</TT>; and three
classes: <TT>Servlet</TT>, <TT>ServletInputStream</TT>,
and <TT>ServletOutputStream</TT>.
<P>
The server developer must use the four interfaces to make the
server comply with the servlet API. You then use the server's
implementations of these interfaces along with the <TT>Servlet</TT>,
<TT>ServletInputStream</TT>, and <TT>ServletOutputStream</TT>
classes to write servlets.
<P>
In this section, you learn the basics behind the classes and interfaces
that make up the servlet package.
<H4>Extending the <TT>Servlet</TT>
Class</H4>
<P>
The <TT>Servlet</TT> class provides
the basic function necessary to create servlets. This class includes
the methods shown in Table 24.2.<BR>
<P>
<CENTER><B>Table 24.2&nbsp;&nbsp;Methods in the Servlet Class</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=295><I>Method Name</I></TD><TD WIDTH=295><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>service</TT>(<TT>ServletRequest</TT>, <TT>ServletResponse</TT>)
</TD><TD WIDTH=295>Services a single request from a client.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>init()</TT>
</TD><TD WIDTH=295>Called by system when servlet is first loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>GetInitParameter</TT>(String)
</TD><TD WIDTH=295>Gets the named initialization parameter.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>GetServletContext()</TT>
</TD><TD WIDTH=295>Returns the servlet context object.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>log</TT>(String)
</TD><TD WIDTH=295>Logs a message to the servlet log.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>GetServletInfo()</TT>
</TD><TD WIDTH=295>Returns a string containing information  about the servlet.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>destroy()</TT>
</TD><TD WIDTH=295>Destroys servlet and cleans up after it.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=295><TT>SetStub</TT>(<TT>ServletStub</TT>)
</TD><TD WIDTH=295>Sets servlet stub; this is done by the system.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The first step in writing Servlets is extending the <TT>Servlet</TT>
class and overriding the <TT>service</TT>
method. The following servlet prints &quot;Hello World&quot; to
the client browser.
<P>
The first step is to get the <TT>OutputStream</TT>
from the <TT>ServletResponse</TT>
object and create a <TT>PrintStream</TT>
with it. Next, you set the response status to <TT>OK</TT>
using the static variable <TT>SC_OK</TT>
from the <TT>ServletResponse</TT>
class.
<P>
Then, you set the content type of the response to text/plain and
write out the headers. Finally, print the Hello World string to
the <TT>PrintStream</TT>.
<BLOCKQUOTE>
<PRE>
import java.servlet.*;

public class SimpleServlet extends Servlet {
     public void service( ServletRequest req, ServletResponse res ) {
     PrintStream ps = new PrintStream(res.getOutputStream());
     res.setStatus(ServletResponse.SC_OK);
     res.setContentType(&quot;text/plain&quot;);
     res.writeHeaders();
     ps.println(&quot;Hello World&quot;);
     ps.flush();
     }
}
</PRE>
</BLOCKQUOTE>
<P>
After you compile the class, load it into the HTTP server using
either the servlet.properties file or the servlet loading screen
of the administration Web page, as was discussed in the first
part of this chapter. You can access the servlet with the following
URL:
<BLOCKQUOTE>
<TT><B>http://&lt;server&gt;/servlet/&lt;servlet_name&gt;</B></TT>
</BLOCKQUOTE>
<P>
where <TT>&lt;servlet_name&gt;</TT>
is the name you assigned to your servlet when you loaded it into
the HTTP server.
<H4>Sending Information with the <TT>ServletResponse</TT>
Interface</H4>
<P>
The <TT>ServletResponse</TT> interface
allows you to send information to the client's browser. It includes
methods for getting an output stream directed at the client, setting
the header information, sending errors to the client, and setting
the status of the response. Table 24.3 shows more of <TT>ServletResponse</TT>'s
methods.
<P>
<TT>ServletResponse</TT> also includes
a list of static integer variables used in setting the response
status. The previous example used the <TT>SC_OK</TT>
variable. Other responses include <TT>SC_CREATED</TT>,
<TT>SC_NO_CONTENT</TT>, <TT>SC_MOVED_PERMANENTLY</TT>,
<TT>SC_MOVED_TEMPORARILY</TT>, <TT>SC_BAD_REQUEST</TT>,
<TT>SC_UNATHORIZED</TT>, <TT>SC_FORBIDDEN</TT>,
<TT>SC_NOT_FOUND</TT>. For a complete
list of methods and variables, see the servlet API documentation.
<BR>
<P>
<CENTER><B>Table 24.3&nbsp;&nbsp;ServletResponse Methods</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=232><I>Method</I></TD><TD WIDTH=358><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>getOuputStream()</TT>
</TD><TD WIDTH=358>Returns the output stream for writing responses.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SendError</TT>(int, String)
</TD><TD WIDTH=358>Sends an error message to the client.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>sendRedirect</TT>(String)
</TD><TD WIDTH=358>Sends a redirect response to the client using a specified redirect URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SetContentLength</TT>(int)
</TD><TD WIDTH=358>Sets the content length for this response.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SetContentType</TT>(String)
</TD><TD WIDTH=358>Sets the content type for this response.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SetDateHeader</TT>(String, long)
</TD><TD WIDTH=358>Sets the date header field.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SetHeader</TT>(String, String)
</TD><TD WIDTH=358>Sets the value of a header field.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>setIntHeader</TT>(String, int)
</TD><TD WIDTH=358>Sets the value of an integer header field.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>WriteHeaders()</TT>
</TD><TD WIDTH=358>Writes the status line and message headers for this response to the output stream.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=232><TT>SetStatus</TT>(int)
</TD><TD WIDTH=358>Sets the status code and a default message for this response.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Receiving Information with the <TT>ServletRequest</TT>
Interface</H4>
<P>
In addition to the <TT>ServletResponse</TT>
object, Servlets get a <TT>ServletRequest</TT>
object as an argument. This object lets the servlet get information
directly from the client making the request, as well as from the
server that called the servlet.
<P>
<TT>ServletRequest</TT> includes methods
for getting an input stream from the client, gathering header
information, and extracting path and query information from the
requested URL.
<P>
Table 24.4 shows the <TT>ServletRequest</TT>
methods. For complete information, see the servlet API documentation.
<BR>
<P>
<CENTER><B>Table 24.4&nbsp;&nbsp;ServletRequest Methods</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Method Name</I></TD><TD WIDTH=356><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getAuthType()</TT>
</TD><TD WIDTH=356>Returns the authentication scheme of the request or null if none.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetContentLength()</TT>
</TD><TD WIDTH=356>Returns the size of the request entity data or -1 if not known.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getContentType()</TT>
</TD><TD WIDTH=356>Returns the MIME type of the request entity data.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetDateHeader</TT>(String, long)
</TD><TD WIDTH=356>Returns the value of a date header field.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getHeader</TT>(String)
</TD><TD WIDTH=356>Returns the value of a header field.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getHeader</TT>(int)
</TD><TD WIDTH=356>Returns the nth header field.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetHeaderName</TT>(int)
</TD><TD WIDTH=356>Returns the name of the nth header field.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetInputStream()</TT>
</TD><TD WIDTH=356>Returns an input stream for reading request data.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetIntHeader</TT>(String, int)
</TD><TD WIDTH=356>Returns the value of an integer header field.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getMethod()</TT>
</TD><TD WIDTH=356>Returns the method with which the request was made.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetPathInfo()</TT>
</TD><TD WIDTH=356>Returns optional extra path information following the servlet path and preceding the query. string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetPathTranslated()</TT>
</TD><TD WIDTH=356>Returns extra path information translated to a real path.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetProtocol()</TT>
</TD><TD WIDTH=356>Returns the protocol and version of the request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetQueryParameter</TT>(String)
</TD><TD WIDTH=356>Returns the value of the specified query string parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetQueryParameters()</TT>
</TD><TD WIDTH=356>Returns a hash table of query string parameter values.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetQueryString()</TT>
</TD><TD WIDTH=356>Returns the query string part of the servlet URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetRemoteAddr()</TT>
</TD><TD WIDTH=356>Returns the IP address of the agent that sent the request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetRemoteHost()</TT>
</TD><TD WIDTH=356>Returns name of the host making the request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetRemoteUser()</TT>
</TD><TD WIDTH=356>Returns the name of the user making the request or null if not known.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetRequestPath()</TT>
</TD><TD WIDTH=356>Returns the part of the request URI that corresponds to the servlet path, plus optional path information. 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetRequestURI()</TT>
</TD><TD WIDTH=356>Returns the request URI.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetServerName()</TT>
</TD><TD WIDTH=356>Returns the host name of the server.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetServerPort()</TT>
</TD><TD WIDTH=356>Returns the port number on which this request was received.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetServletPath()</TT>
</TD><TD WIDTH=356>Returns the part of the request URI that refers to the servlet being invoked.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Getting Information with the <TT>ServletContext</TT>
Interface</H4>
<P>
The <TT>getServletContext</TT> method
from the <TT>Servlet</TT> class returns
a <TT>ServletContext</TT>. This object
lets you find out information about the environment in which the
servlet is running.
<P>
The <TT>getServerInfo</TT> method
returns the name and version of the server running. The <TT>getServlet</TT>
method returns a servlet with its name, and the <TT>getServlets</TT>
method returns an enumeration of all the available servlets in
this context.
<H3><A NAME="UsingtheJeevesDevelopmentToolkit">
Using the Jeeves Development Toolkit</A></H3>
<P>
In addition to the servlet API, Jeeves includes additional classes
that simplify the development of Web services. For example, there
are several prebuilt servlets that extend the function of the
generic <TT>Servlet</TT> class. These
include a form servlet that processes HTML form input and a filter
interface that lets you embed servlets in HTML pages using server-side
includes.
<P>
Sun also includes several sample servlets to get you started.
Other classes in the toolkit let you generate HTML, set servlet
security, and do other useful tasks.
<H4>Processing Form Input with the <TT>FormServlet</TT>
</H4>
<P>
The <TT>FormServlet</TT> greatly simplifies
the processing of HTML form input. To process data from a form,
extend the <TT>FormServlet</TT> class
and override the <TT>sendResponse</TT>
method.
<P>
The <TT>sendResponse</TT> method doesn't
take a <TT>ServletRequest</TT> object
as an argument. Instead, it gets a hash table containing the values
from the HTML form. The following example shows how to get the
value from the form field called <TT>field_name</TT>.
<BLOCKQUOTE>
<PRE>
 Public class SimpleFormServlet extends FormServlet {
     public void sendResponse(ServletResponse res, Hashtable table) {
     String field_value = table.get(&quot;field_name&quot;);
     ...
     }
}
</PRE>
</BLOCKQUOTE>
<H4>Using the Filter Interface to Embed Servlets in HTML Pages
</H4>
<P>
Using the Jeeves Filter interface, you can create servlets that
can be embedded in HTML pages using a server-side include statement.
The following server-side include statement calls <TT>myServlet</TT>
and passes the <TT>name1</TT> and
<TT>name2</TT> parameters to it in
the form of a hash table:
<BLOCKQUOTE>
<PRE>
&lt;SERVLET CODE=&quot;myServlet&quot; name1=&quot;value1&quot; name2=&quot;value2&quot;&gt;
</PRE>
</BLOCKQUOTE>
<P>
The following servlet inserts the date into the Web page it is
embedded in:
<BLOCKQUOTE>
<PRE>
import java.servlet.*;
import java.io.*;
import java.util.*;

public class SSIServlet extends Servlet implements Filter {
     public void service(InputStream is, OutputStream os, Hashtable params)
     throws java.io.IOException
     {
     Date now = new Date();
     PrintStream ps = new PrintStream(os);
     ps.println(today);
     ps.flush();
     }
}
</PRE>
</BLOCKQUOTE>
<P>
Notice that the <TT>service</TT> method
accepts different arguments from normal. Instead of <TT>ServletRequest</TT>
and <TT>ServletResponse</TT>, the
arguments to service are an <TT>InputStream</TT>,
<TT>OutputStream</TT>, and <TT>Hashtable</TT>.
The hash table is used to store the parameters passed to the servlet
by the server-side include statement.
<H4>Generating HTML with the Jeeves HTML Classes</H4>
<P>
Sun provides a package of classes that generate HTML. The package
includes the <TT>HtmlContainer</TT>
and <TT>HtmlElement</TT> interfaces,
as well as the <TT>HtmlContainerImpl</TT>,
<TT>HtmlPage</TT>, <TT>HtmlTag</TT>,
<TT>HtmlTagPair</TT>, and <TT>HtmlText</TT>
classes.
<P>
Start by creating a new <TT>HtmlPage</TT>
object. Then, using the <TT>addTag</TT>,
<TT>addTagPair</TT>, and <TT>addText</TT>
methods, insert the necessary HTML. The following example shows
a simple use of these classes:
<BLOCKQUOTE>
<PRE>
import java.servlet.*;
import sun.server.html
import java.io.*;

public class HtmlServlet extends Servlet {
     pubic service(ServletRequest req, ServletResponse res)
     throws Exception {
     res.setContentType(&quot;text/html&quot;);
     res.setStatus(ServletResponse.SC_OK);
     OutputStream os = res.getOutputStream();
     
     HtmlPage page = new HtmlPage(&quot;A Simple HTML page&quot;);
     page.addTagPair(&quot;H1&quot;, &quot;This is a Simple HTML Page&quot;);
     page.addTag(&quot;p&quot;);
     page.addText(&quot;This page was generated by the sun.server.html package&quot;);
     
     page.write(os);
     os.flush();
     }
}
</PRE>
</BLOCKQUOTE>
<H2><A NAME="BuildingaDatabaseServlet"><FONT SIZE=5 COLOR=#FF0000>
Building a Database Servlet</FONT></A></H2>
<P>
In this section, you build a Servlet that processes an HTML form
and either searches for or inserts data into a JDBC database.
This servlet could be used by a site to register new users, process
orders, survey users, or enable users to search one of your publicly
accessible databases.
<H3><A NAME="GettingtheInformationfromtheUsers">
Getting the Information from the Users</A></H3>
<P>
The first step is to process the form data with a <TT>FormServlet</TT>.
This is a generic registration form that asks the user's name,
title, company, and address. The following is a <TT>sendResponse</TT>
method that returns the information supplied by the user in an
HTML table:
<BLOCKQUOTE>
<PRE>
public void sendResponse(ServletResponse res, Hashtable table)
throws IOException
{
     PrintStream ps = new PrintStream(res.getOutputStream());
     log(&quot;MyServlet running&quot;);
     res.setStatus(ServletResponse.SC_OK);
     res.setContentType(&quot;text/html&quot;);
     res.writeHeaders();
     
     String name = (String) table.get(&quot;name&quot;);
     String title = (String) table.get(&quot;title&quot;);
     String company = (String) table.get(&quot;company&quot;);
     String address = (String) table.get(&quot;address&quot;);

     ps.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
     ps.println(&quot;&lt;TITLE&gt;Registration Information&lt;/TITLE&gt;&quot;);
     ps.println(&quot;&lt;/HEAD&gt;&lt;BODY&gt;&quot;);
     ps.println(&quot;&lt;H2&gt;This is the information you submitted&lt;/H2&gt;&quot;);
     ps.println(&quot;&lt;TABLE Border&gt;&quot;);
     ps.println(&quot;&lt;CAPTION&gt;Your Registration Information&lt;/CAPTION&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Name&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +name +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Title&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +title +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Company&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +company +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Address&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +address +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;/TABLE&gt;&quot;);
     ps.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
     ps.flush();
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ConnectingYourServlettoaJDBCDatabase">
Connecting Your Servlet to a JDBC Database</A></H3>
<P>
The next step is to connect to a SQL database. The Java Database
Connectivity package makes this possible. The servlet also uses
a very simple SQL generator.
<P>
The <TT>generator</TT> class takes
an object of the <TT>DBRecord</TT>
class as an argument and returns a string containing SQL commands.
<TT>DBRecord</TT> is a container class
that holds the table's name, its primary key, and the names and
values of the fields to be changed.
<P>
To increase the performance of the database queries, the servlet
connects to the database in its <TT>init()</TT>
method. This makes the servlet connect to the database as soon
as it is loaded.
<P>
By telling Jeeves to load the servlet when the server starts up,
you can reduce the overhead associated with reestablishing the
connection for each request. See the previous section on loading
servlets to learn how to make Jeeves load the servlet at startup.
<BLOCKQUOTE>
<PRE>
 Public class JDBCServlet extends FormServlet {
     Connection con;
     Statement stmt;
     
     public void init() {
     try {
     Class.forName(&quot;imaginary.sql.iMsqlDriver&quot;);
     String url = &quot;jdbc:msql://pandora.scripps.edu:1112/userreg&quot;;
     connection = DriverManager.getConnection(url, &quot;guest&quot;, &quot;&quot;);
     } catch (Exception e) {
     System.out.println(e.getMessage());
     e.printStackTrace();
     }
     }
     public void destroy() throws Exception {
     ocn.close();
     }

}
</PRE>
</BLOCKQUOTE>
<P>
The JDBCServlet's <TT>init()</TT>
method made the connection to an <TT>msql</TT>
database with the <TT>imaginary.sql.iMsqlDriver</TT>.
The connection could have been made to any database with a JDBC
driver. Even databases that use only ODBC could be used with an
ODBC-JDBC bridge.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Weblogic Company has both pure Java JDBC drivers for most of the major RDBMSs and ODBC-JDBC bridges. To find out more, check out <TT><B><A HREF="http://www.weblogic.com/">http://www.weblogic.com/</A></B></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="InsertingDataintheDatabase">
Inserting Data in the Database</A></H3>
<P>
The next step is to override the <TT>sendResponse</TT>
method. You put the information submitted with the form into a
<TT>DBRecord</TT> object, and then
you generate a string containing SQL commands with the <TT>SQLgen</TT>
object.
<P>
Use that string in the <TT>executeQuery</TT>
method of the JDBC <TT>Statement</TT>
class. The Query returns a <TT>ResultSet</TT>
object containing the response to your query, in the case of a
search. 
<P>
Listing 24.1 shows how data is inserted in a JDBC database. When
the data is inserted in the database, the user gets an acknowledgment.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Since the Jeeves Web server is multithreaded, a servlet may be called by several handler threads simultaneously. You must make your servlets thread-safe by using synchronized methods and blocking when necessary.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 24.1&nbsp;&nbsp;JDBCSERVLET.JAVA-The sendResponse Method
of the </B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<B>JDBCServlet<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
Public void sendResponse(Servlet res, Hashtable table)
throws Exception
{
     Statement stmt;
     SQLgen dbaction;
     ResultSet rs;

     // Create a new DBRecord object and fill its fields with
     // the values obtained from the HTML form.
     DBRecord rec = new DBRecord();
     rec.setTable(&quot;userreg&quot;);
     String name = (String) table.get(&quot;name&quot;);
     if (name.length() &gt; 0) {
     rec.setField(new DBField(&quot;name&quot;, name);
     }
     String title = (String) table.get(&quot;title&quot;);
     if (title.length() &gt; 0) {
     rec.setField(new DBField(&quot;title&quot;, title);
     }
     String company = (String) table.get(&quot;company&quot;);
     if (company.length() &gt; 0) {
     rec.setField(new DBField(&quot;company&quot;, company);
     }
     String address = (String) table.get(&quot;address&quot;);
     if (address.length() &gt; 0) {
     rec.setField(new DBField(&quot;address&quot;, address);
     }
     String action = (String) table.get(&quot;action&quot;);
     if (action.equals(&quot;Insert&quot;)) {
     rec.setActionInsert();
     }
     
     // Create a generator object with the completed DBRecord object.
     dbaction = new SQLgen(rec);
     // Create a JDBC Statement object.
     stmt = con.createStatement();
     // Execute the SQL query generated by the SQLgen object
     rs = stmt.executeQuery(dbaction.getSQL());
     stmt.close();

     // Create a new PrintStream to output an acknowledgment of the users
     // registration
     PrintStream ps = new PrintStream(res.getOutputStream());
     log(&quot;JDBCServlet running&quot;);
     res.setStatus(ServletResponse.SC_OK);
     res.setContentType(&quot;text/html&quot;);
     res.writeHeaders();
     ps.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
     ps.println(&quot;&lt;TITLE&gt;Registration Complete&lt;/TITLE&gt;&quot;);
     ps.println(&quot;&lt;/HEAD&gt;&lt;BODY&gt;&quot;);
     ps.println(&quot;&lt;H2&gt;Thank you for registering&lt;/H2&gt;&quot;);
     ps.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
     ps.flush();
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="SearchingtheDatabase">
Searching the Database</A></H3>
<P>
You can make your servlet search the database and insert data
into it by adding the following code fragments to the above <TT>sendResponse</TT>
method. The first piece checks to see if the form's action was
set to search.
<P>
If it is, the <TT>action</TT> field
of the <TT>DBRecord</TT> object is
also set to search. The second piece returns the search results
in the form of an HTML table.
<BLOCKQUOTE>
<PRE>
 if (action.equals(&quot;Search&quot;)) {
     rec.setActionInsert();
}

...

if (action.equals(&quot;Search&quot;)) {
     ps.println(&quot;&lt;TABLE Border&gt;&quot;);
ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Name&lt;/TD&gt;&lt;TD&gt;Title&lt;/TD&gt;&lt;TD&gt;Company&lt;/TD&gt;&lt;TD&gt;Address&lt;/TD&gt;&lt;/TR&gt;&quot;);
     while(rs.next()) {
     String name = rs.getString(1);
     String title = rs.getString(2);
     String company = rs.getString(3);
     String address = rs.getString(4);
     
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&quot; +name +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; +title +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; );
     ps.println(company +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; + address +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;)
     }
     ps.println(&quot;&lt;/TABLE&gt;&quot;);
 }
</PRE>
</BLOCKQUOTE>
<P>
Following is the complete code listing for the JDBC Serlvet. This
simple example shows the power of using Java on the server-side.
Combining servlets with the JDBC makes a strong argument for server-side
Java.
<P>
Listing 24.2 shows a simple autonomous agent system that takes
advantage of another of Java's powerful features, object serialization.
<HR>
<BLOCKQUOTE>
<B>Listing 24.2&nbsp;&nbsp;JDBCSERVLET.JAVA-Complete Code for
the JDBC Servlet<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.sql.*;
import java.io.*;
import java.util.*;
import sun.server.http.*;
import java.servlet.*;
import db.*;

public class JDBCServlet extends FormServlet {
     Connection con;
     Statement stmt;
     
     public void init() {
     try {
     Class.forName(&quot;imaginary.sql.iMsqlDriver&quot;);
     String url = &quot;jdbc:msql://pandora.scripps.edu:1112/userreg&quot;;
     con = DriverManager.getConnection(url, &quot;guest&quot;, &quot;&quot;);
     } catch (Exception e) {
     System.out.println(e.getMessage());
     e.printStackTrace();
     }
     }
     public void destroy(){
     try {
               con.close();
     } catch (Exception e) {
     System.out.println(e.getMessage());
     e.printStackTrace();
     }

     }

     public void sendResponse(ServletResponse res, Hashtable table)
     throws Exception
     {
     Statement stmt;
     SQLgen dbaction;
     ResultSet rs;

     // Create a new DBRecord object and fill its fields with
     // the values obtained from the HTML form.
          DBRecord rec = new DBRecord();
     rec.setTable(&quot;userreg&quot;);
     String name = (String) table.get(&quot;name&quot;);
     if (name.length() &gt; 0) {
     rec.setField(new DBField(&quot;name&quot;, name));
     }
     String title = (String) table.get(&quot;title&quot;);
     if (title.length() &gt; 0) {
     rec.setField(new DBField(&quot;title&quot;, title));
     }
     String company = (String) table.get(&quot;company&quot;);
     if (company.length() &gt; 0) {
     rec.setField(new DBField(&quot;company&quot;, company));
     }
     String address = (String) table.get(&quot;address&quot;);
     if (address.length() &gt; 0) {
     rec.setField(new DBField(&quot;address&quot;, address));
     }
     String action = (String) table.get(&quot;action&quot;);
     if (action.equals(&quot;Insert&quot;)) {
     rec.setActionInsert();
     }
          if (action.equals(&quot;Search&quot;)) {
     rec.setActionInsert();
     }

     
     // Create a generator object with the completed DBRecord object.
          dbaction = new SQLgen(rec);
          try {
          // Create a JDBC Statement object.
     stmt = con.createStatement();
     // Execute the SQL query generated by the SQLgen object
     rs = stmt.executeQuery(dbaction.getSQL());
     stmt.close();

     // Create a new PrintStream to output an acknowledgment of the users
     // registration
          PrintStream ps = new PrintStream(res.getOutputStream());
          log(&quot;JDBCServlet running&quot;);
     res.setStatus(ServletResponse.SC_OK);
     res.setContentType(&quot;text/html&quot;);
     res.writeHeaders();
     ps.println(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);
     ps.println(&quot;&lt;TITLE&gt;Registration Complete&lt;/TITLE&gt;&quot;);
     ps.println(&quot;&lt;/HEAD&gt;&lt;BODY&gt;&quot;);
          ps.println(&quot;&lt;H2&gt;Thank you for registering&lt;/H2&gt;&quot;);
          if (action.equals(&quot;Search&quot;)) {
     ps.println(&quot;&lt;TABLE Border&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Name&lt;/TD&gt;&lt;TD&gt;Title&lt;/TD&gt;&quot;);
                ps.println(&quot;&lt;TD&gt;Company&lt;/TD&gt;&lt;TD&gt;Address&lt;/TD&gt;&lt;/TR&gt;&quot;); 
                while(rs.next()) {
     name = rs.getString(1);
     title = rs.getString(2);
     company = rs.getString(3);
     address = rs.getString(4);
     
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&quot; +name +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; +title +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; );
                   ps.println(company +&quot;&lt;/TD&gt;&lt;TD&gt;&quot; + address 
               +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);

     }
     ps.println(&quot;&lt;/TABLE&gt;&quot;);
     }
               if (action.equals(&quot;Insert&quot;)) {
          ps.println(&quot;&lt;H2&gt;This is the information you submitted&lt;/H2&gt;&quot;);
     ps.println(&quot;&lt;TABLE Border&gt;&quot;);
     ps.println(&quot;&lt;CAPTION&gt;Your Registration Information&lt;/CAPTION&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Name&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +name +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Title&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +title +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Company&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +company +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;TR&gt;&lt;TD&gt;&lt;B&gt;Address&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&quot; +address +&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);
     ps.println(&quot;&lt;/TABLE&gt;&quot;);
     }

     ps.println(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
     ps.flush();

     } catch (Exception e) {
     System.out.println(e.getMessage());
     e.printStackTrace();
     }

}
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="BuildingaSimpleAutonomousAgentSystemwithJeeves"><FONT SIZE=5 COLOR=#FF0000>
Building a Simple Autonomous Agent System with Jeeves</FONT></A></H2>
<P>
This example shows how servlets can be used to create an environment
in which small, self-contained Java programs can roam the Internet,
gathering and processing information before returning home for
debriefing. This example has five components: the agent, the remote
agency servlet, the home agency servlet, the agent launcher, and
the agent debriefing program.
<P>
The agent launcher instructs the agent of the information it is
to retrieve from a particular JDBC database and then transports
it to the destination. The remote agency servlet provides an environment
where the agent can execute its <TT>run</TT>
method, which then queries the specified database. 
<P>
After that, the remote agency asks the agent where it lives and
then sends it on its way. The home agency servlet then accepts
the agent and stores it in a file for later debriefing. Finally,
the agent debriefing program restores the agent and requests the
information it was sent to retrieve.
<P>
This is a simple system designed only for illustration. A real
system needs to use strict security measures, which Jeeves does
provide through a servlet-specific, access-control list.
<P>
A real system also needs a way of advertising services that are
accessible to agents. This way, agents can find new services themselves.
<H3><A NAME="UsingObjectSerializationtoTransportAgentsAcrosstheInternet">
Using Object Serialization to Transport Agents Across the
Internet</A></H3>
<P>
Java's object serialization provides transportation for your agent.
Object serialization is the process of turning any Java object
or graph of objects (an object and all the objects it is made
up of) into a stream of information. This stream can be transported
using any <TT>OutputStream</TT> or
<TT>InputStream</TT> and restored
to its original state when it reaches the other side.
<P>
Object serialization can be used to give persistence to an object
by serializing an object into a file for later retrieval. This
is done to the <TT>JDBCAgent</TT>
in the following example.
<P>
Serializing an object is as easy as creating an <TT>ObjectOutputStream</TT>
and calling its <TT>writeObject</TT>
method with the object to be serialized as the argument.
<BLOCKQUOTE>
<PRE>
ObjectOutputStream oos = ObjectOutputStream(socket.getOutputStream());
oos.writeObject(myobject);
</PRE>
</BLOCKQUOTE>
<P>
Deserializing an object is just as straightforward. First, create
an <TT>ObjectInputStream</TT> and
call its <TT>readObject</TT> method
with the object to be deserialized as the argument.
<BLOCKQUOTE>
<PRE>
ObjectInputStream ois = ObjectInputStream(socket.getInputStream());
ois.readObject(myobject);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The object serialization classes are not included with the JDK as of release 1.0.2. They can be downloaded with the Remote Method Invocation package from the Javasoft Web site.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
For more information on object serialization, see Sun's white paper: Java Object Serialization Specification, available at the Javasoft Web site (<TT><B><A HREF="http://www.javasoft.com/">http://www.javasoft.com/</A></B></TT>).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="BuildingtheRemoteAgency">
Building the Remote Agency</A></H3>
<P>
Start by building the remote agency. The <TT>RemoteAgencyServlet</TT>
class extends the <TT>Servlet</TT>
class. Its sole purpose in Listing 24.3 is to deserialize the
agent, execute the agent's <TT>run</TT>
method, ask the agent where it lives, and send it on its way.
Again, in a real system, you need to use careful security procedures.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This agency accepts any Java object that conforms to a simple interface and executes its <TT>run</TT> method. The servlet also bypasses all of Jeeves' built-in security procedures used to protect the server from remote servlets.
</BLOCKQUOTE>
<BLOCKQUOTE>
This is extremely dangerous in the real world. You should use strict access control on this servlet. At the same time, this example shows the power of servlets and Java.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Jeeves provides an elaborate access-control mechanism that can be used to protect the server from dangerous agents. You can also create servlet-specific authentication procedures with the security classes.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 24.3&nbsp;&nbsp;REMOTEAGENCYSERVLET.JAVA-The RemoteAgencyServlet
 Class<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*;
import java.servlet.*;
import java.net.*;

public class RemoteAgencyServlet extends Servlet
{
     public String getServletInfo() {
          return &quot;Remote Agent Servlet&quot;;
     }
     public void service(ServletRequest req, ServletResponse res)
     throws Exception
     {
     // Load the agent from the client's agent launcher
     ObjectInputStream ois = new ObjectInputStream(req.getInputStream());
     // Cast the incoming object to AgentInterface, which is a simple that
     // all agents must implement.
     AgentInterface agent = (AgentInterface) ois.readObject();
     // Call the agents run method.
     agent.run();
     
     // Now that the agent has completed its task, find out where it lives.
     URL agenthome = agent.getAgentHome();
     int port = agenthome.getPort();
     String host = agenthome.getHost();
     String file = agenthome.getFile();
     // Now that you know where the agent lives send it on its way.
     // Open up a connection to the agents home, which is a servlet compliant
     // web server.
     Socket socket = new Socket(host, port);
     PrintStream ps = new PrintStream(socket.getOutputStream());
     // Request to HomeAgentServlet from the web server
     ps.println(&quot;POST&quot; +file);
     ps.flush();
     // Create an ObjectOutputStream
     ObjectOutputStream oos = new 
     ObjectOutputStream(socket.getOutputStream());
     oos.writeObject(agent);
     oos.flush();
     }
}  
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="CreatingaGenericAgentInterface">
Creating a Generic Agent Interface</A></H3>
<P>
Using agents from the <TT>AgentInterface</TT>
interface allows new agents to be created to run on any servlet
that knows the interface. This agent interface is simple, but
other methods could be added.
<P>
The current interface has only three methods. The <TT>run</TT>
method causes the agent to carry out the mission for which it
was sent. The <TT>getAgentHome</TT>
method is used by the remote agency to determine where to send
the agent.
<P>
Finally, the <TT>getAuthentication</TT>
method is used by the server to authenticate the agent. In this
example, <TT>getAuthentication</TT>
returns null.
<BLOCKQUOTE>
<PRE>
import java.net.URL;
public interface AgentInterface {
     public void run();
     public URL getAgentHome();
     public String getAuthentication();
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ImplementingaDatabaseSearchAgent">
Implementing a Database Search Agent</A></H3>
<P>
The <TT>JDBCAgent</TT> uses the <TT>AgentInterface</TT>.
This agent, shown in Listing 24.4, queries a JDBC database using
much of the same code as the earlier database example. It has
methods for specifying the remote host, database, JDBC driver,
and the agent's home.
<HR>
<BLOCKQUOTE>
<B>Listing 24.4&nbsp;&nbsp;JDBCAGENT.JAVA-The JDBCAgent Class
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.sql.*;
import java.io.*;
import java.util.*;
import java.net.URL;
import db.*;

public class JDBCAgent implements AgentInterface
{
     Connection con;
     Statement stmt;
     DBRecord rec;
     JDBCInfo jdbcinfo;
     Vector v;
     URL agenthome;
     
     public void run() {
     try {
     String url = jdbcinfo.getURL();
     String driver = jdbcinfo.getDriver();
     String user = jdbcinfo.getUser();
     String password = jdbcinfo.getPassword();

     Class.forName(driver);
     con = DriverManager.getConnection(url, user, password);
     stmt = con.createStatement();
     SQLgen dbaction = new SQLgen(rec);
     ResultSet rs = stmt.executeQuery(dbaction.getSQL());
     
     while(rs.next()) {
     Hashtable hashtable = new Hashtable();
     hashtable.put(&quot;name&quot;, rs.getString(1));
     hashtable.put(&quot;id&quot;, rs.getString(2));
     hashtable.put(&quot;company&quot;, rs.getString(3));
     hashtable.put(&quot;location&quot;, rs.getString(4));
     v.addElement(hashtable);
     }
     stmt.close();
     } catch (Exception e) {
     System.out.println(e.getMessage());
     e.printStackTrace();
     }
     }
     
     public Vector getResultVector() {
     return v;
     }
     public void setQuery(DBRecord rec) {
     this.rec = rec;
     }
     public void setJDBCInfo(JDBCInfo jdbcinfo) {
     this.jdbcinfo = jdbcinfo;
     }
     public void setAgentHome(URL agenthome) {
     this.agenthome = agenthome;
     }
     public URL getAgentHome() {
     return agenthome;
     }
     public String getAuthentication() {
     return null;
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="BuildingtheHomeAgency">
Building the Home Agency</A></H3>
<P>
The <TT>HomeAgencyServlet</TT> stores
returning agents until the user is ready to debrief them. This
servlet deserializes an incoming agent and then stores it in a
file (see Listing 24.5).
<HR>
<BLOCKQUOTE>
<B>Listing 24.5&nbsp;&nbsp;HOMEAGENCYSERVLET.JAVA-The HomeAgency
Class<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*;
import java.servlet.*;
import java.net.*;

public class HomeAgencyServlet extends Servlet
{
     public String getServletInfo()
     {
     return &quot;Agent Home Servlet&quot;;
     }

     public void service(ServletRequest req, ServletResponse res) 
     throws Exception
     {
     // create ObjectInputStream from the InputStream originating a the  RemoteAgencyServlet.
          ObjectInputStream ois = new 
          ObjectInputStream(req.getInputStream());
          // Read in the Agent object from the stream.
     AgentInterface agent = (AgentInterface) ois.readObject();
     // open a file to store the agent in until debriefing
     FileOutputStream fos = new 
FileOutputStream(&quot;/agents/storage/agent99&quot;);
     // Create an ObjectOutputStream pointing to the file
     ObjectOutputStream oos = new ObjectOutputStream(fos);
     // Write the agent to the file.
     oos.writeObject(agent);
     oos.flush();
     fos.close();
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="LaunchingtheAgent">
Launching the Agent</A></H3>
<P>
The <TT>AgentLauncher</TT> sets the
agent's mission and then transports it to the <TT>RemoteAgencyServlet</TT>.
It uses a class called <TT>JDBCInfo</TT>
to set the specific database information. 
<P>
<TT>JDBCInfo</TT> is a container class
that holds information on which database driver to use, the URL,
and the user name and password for the database. The <TT>AgentLauncher</TT>
then places the query in a <TT>DBRecord</TT>
object. 
<P>
Finally, it contacts the agency servlet on a remote HTTP server
and uses object serialization to transport the agent to the remote
agency (see Listing 24.6).
<HR>
<BLOCKQUOTE>
<B>Listing 24.6&nbsp;&nbsp;AGENTLAUNCHER.JAVA-The AgentLauncher
Class<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*;
import java.util.*;
import java.net.*;
import db.*;

public class AgentLauncher {
     public static void main(String[] argv) throws Exception {
     JDBCAgent jdbcagent = new JDBCAgent();
     
     JDBCInfo jdbcinfo = new JDBCInfo();
     jdbcinfo.setDriver(&quot;imaginary.sql.iMsqlDriver&quot;);
     jdbcinfo.setURL(&quot;jdbc:msql://agency.agentworld.com:1112/agentdb&quot;);
     jdbcinfo.setUser(&quot;agent99&quot;);
     jdbcinfo.setPassword(&quot;&quot;);
     jdbcagent.setJDBCInfo(jdbcinfo);
     
     DBRecord rec = new DBRecord();
     rec.setTable(&quot;agents&quot;);
     rec.setPrimaryKey(&quot;recordnumber&quot;);
     rec.setField(new DBField(&quot;location&quot;, &quot;North America&quot;));
     rec.setActionSelect();
     jdbcagent.setQuery(rec);
     
     URL homeurl = new 
URL(&quot;http://pandora.scripps.edu/servlet/homeagency&quot;);
     jdbcagent.setAgentHome(homeurl);

     Socket socket = new Socket(&quot;buddha&quot;, 8888);
     PrintStream ps = new PrintStream(socket.getOutputStream());
     ps.println(&quot;POST /servlet/RemoteAgency&quot;);
     ps.flush();
     ObjectOutputStream oos = new ObjectOutputStream(ps);
     oos.writeObject(jdbcagent);
     oos.flush();
     }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="DebriefingtheAgent">
Debriefing the Agent</A></H3>
<P>
The <TT>AgentDebriefing</TT> class,
shown in Listing 24.7, restores the agent from the file that it
is stored in and requests the information it was sent to gather.
This program is run by the user when the agent has returned. The
<TT>HomeAgency</TT> could have been
designed to send mail, letting the user know when an agent returns.
<HR>
<BLOCKQUOTE>
<B>Listing 24.7&nbsp;&nbsp;AGENTDEBRIEFING.JAVA-The AgentDebriefing
class<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*;
import java.util.*;
import java.net.Socket;
import db.*;

public class AgentDebriefing {
     public static void main(String[] argv) throws Exception {
     JDBCAgent jdbcagent = new JDBCAgent();
     FileInputStream fis = new FileInputStream(&quot;/agents/storage/agent99&quot;);
     ObjectInputStream ois = new ObjectInputStream(fis);
     JDBCAgent agent = (JDBCAgent) ois.readObject();
     
     Vector v = agent.getResultVector();
     for (Enumeration e=v.elements(); e.hasMoreElements();) {
     Hashtable hash = (Hashtable) (e.nextElement());
     System.out.println(&quot;Name: &quot; +hash.get(&quot;name&quot;));
     System.out.println(&quot;id: &quot; +hash.get(&quot;id&quot;));
     System.out.println(&quot;Company: &quot; +hash.get(&quot;company&quot;));
     System.out.println(&quot;location: &quot; +hash.get(&quot;location&quot;));
     }
     }
}
</PRE>
</BLOCKQUOTE>
<HR>

<CENTER><P><A HREF="ch23.htm"><IMG SRC="http://docs.rinet.ru/JSol/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JSol/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JSol/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch25.htm"><IMG SRC="http://docs.rinet.ru/JSol/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
