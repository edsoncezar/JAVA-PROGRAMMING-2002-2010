


















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Operators</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="vars.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="expressions.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/javaHeader.gif" width=26 height=26 align=bottom border=0 alt="Learning the Java Language | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>The Nuts and Bolts of the Java Language</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Operators
</h2>
<p>
<blockquote>

The <code>countChars</code> method uses several operators
including <code>=</code>, <code>!=</code>, <code>++</code>,
and <code>+</code>, which are highlighted in this listing:
<blockquote>
<pre>
import java.io.*;
public class Count {
   public static void countChars(Reader in) throws IOException
   {
       int count <strong>=</strong> 0;

       while (in.read() <strong>!=</strong> -1)
           count<strong>++</strong>;
       System.out.println("Counted " <strong>+</strong> count <strong>+</strong> " chars.");
   }
   // <em>... main method omitted ...</em>
}
</pre>
</blockquote>
Operators perform some function on either one or two operands or three operands.
Operators that require one operand are called <em>unary operators</em>.
For example, <code>++</code> is a unary operator that increments
the value of its operand by 1.
Operators that require two operands are <em>binary operators</em>. For
example, <code>=</code> is a binary operator that assigns the value from
its right-hand operand to its left-hand operand.
And finally <em>tertiary operators</em> are those that require three operands.
The Java language has one tertiary operator, <code>?:</code>,
which is a short-hand <code>if</code>-<code>else</code> statement.
<p>
Java's unary operators can use either prefix or postfix notation.
Prefix notation means that the operator appears <em>before</em> its operand:
<blockquote>
<pre>
operator op
</pre>
</blockquote>
Postfix notation means that the operator appears <em>after</em> its operand:
<blockquote>
<pre>
op operator
</pre>
</blockquote>
All of Java's binary operators use infix notation, which means that
the operator appears <em>between</em> its operands:
<blockquote>
<pre>
op1 operator op2
</pre>
</blockquote>
Java's only tertiary operator is also infix;
each component of the operator appears between operands:
<blockquote>
<pre>
expr ? op1 : op2
</pre>
</blockquote>
In addition to performing the operation, an operator also returns a value.
The value and its type depends on the operator and the type of its operands.
For example, the arithmetic operators,
which perform basic arithmetic operations such as addition and subtraction,
return numbers-the result of the arithmetic operation.
The data type returned by the arithmetic operators
depends on the type of its operands:
If you add two integers, you get an integer back.
An operation is said to <em>evaluate to</em> its result. 
<p>
It's useful to divide Java's operators into these categories:
arithmetic, relational and conditional, bitwise and logical, and assignment.
These are discussed in the following sections.

<h4>Arithmetic Operators</h4>
<blockquote>
The Java language supports various arithmetic operators
for all floating-point and integer numbers. These include
<code>+</code> (addition), <code>-</code> (subtraction), <code>*</code>
(multiplication), <code>/</code> (division), and <code>%</code>
(modulo).
For example, you can use this Java code to add two numbers:
<blockquote>
<pre>
addThis + toThis
</pre>
</blockquote>
Or you can use the following Java code to compute the remainder
that results from dividing
<code>divideThis</code> by <code>byThis</code>:
<blockquote>
<pre>
divideThis % byThis
</pre>
</blockquote>
<p>
This table summarizes Java's binary arithmetic operations:
<p>

<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Description</th>
<tr>
    <td><code>+</code></td>
    <td><code>op1 + op2</code> </td>
    <td>Adds <tt>op1</tt> and <tt>op2</tt></code> </td>
</tr>
<tr>
    <td><code>-</code></td>
    <td><code>op1 - op2 </code> </td>
    <td>Subtracts <tt>op2</tt> from <tt>op1</tt></code> </td>
</tr>
<tr>
    <td><code>*</code></td>
    <td><code>op1 * op2</code> </td>
    <td>Multiplies <tt>op1</tt> by <tt>op2</tt></code> </td>
</tr>
<tr>
    <td><code>/</code></td>
    <td><code>op1 / op2</code> </td>
    <td>Divides <tt>op1</tt> by <tt>op2</tt></code> </td>
</tr>
<tr>
    <td><code>%</code></td>
    <td><code>op1 % op2</code> </td>
    <td>Computes the remainder of dividing <tt>op1</tt> by <tt>op2</tt></code> </td>
</tr>

</table>
<p>
<hr>
<strong>Note:</strong> The Java language extends the definition of the
<code>+</code> operator to include string concatenation.
The <code>countChars</code> method
uses <code>+</code> to concatenate "<code>Counted </code>", the value of
<code>count</code>, and "<code> chars.</code>", as shown here:
<blockquote>
<pre>
System.out.println("Counted " + count + " chars.");
</pre>
</blockquote>
This operation
automatically coerces the value <code>count</code> to a <code>String</code>.
You'll see more about this in
<a href="arraysandstrings.html">Arrays and Strings</a>.
<hr>
<p>
The <code>+</code> and <code>-</code> operators have unary versions
that perform the following operations:
<p>

<!-- TABLE -->
<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Description</th>
<tr>
    <td>
	<code>+</code>
    </td>
    <td>
	<code>+op</code>
    </td>
    <td>
	Promotes <code>+</code> to <code>int</code>
	if it's a <code>byte</code>, <code>short</code>, or <code>char</code>
    </td>
</tr>

<tr>
    <td>
	<code>-</code>
    </td>
    <td>
	<code>-op</code>
    </td>
    <td>
	Arithmetically negates <code>op</code>
    </td>
</tr>

</table>


<p>
There also are two short cut arithmetic operators, <code>++</code>
which increments its operand by 1, and <code>--</code> which decrements
its operand by 1. The <code>countChars</code> method uses <code>++</code> to
increment the <code>count</code> variable each time it reads a character from
the input source with this statement:
<blockquote>
<pre>
count++;
</pre>
</blockquote>
Note that the <code>++</code> operator appears after its operand in this
example. This is the <em>postfix version</em> of the operator.
<code>++</code> also
has a <em>prefix version</em> in which <code>++</code> appears before its operand.
Both the prefix and postfix versions of this operator increment the operand
by 1. So why are there two different versions? Because each version evaluates
a different value: <code>op++</code> evaluates to the value of the operand
<em>before</em> the increment operation, and <code>++op</code> evaluates the
value of the operand <em>after</em> the increment operation.
<p>
In the <code>countChars</code> method, suppose that <code>count</code>
is say, 5, before the following statement is executed:
<blockquote>
<pre>
count++;
</pre>
</blockquote>
After the statement is executed the value of <code>count</code> is 6.
No surprises there. However, the statement <code>count++</code> evaluates
to 5. In the same scenario the prefix version of <code>++</code>
would also set <code>count</code> to 6.
However the statement <code>++count</code>
does not evaluate to 5 like the postfix version of <code>++</code> does;
rather, it evaluates to 6:
<blockquote>
<pre>
++count; 
</pre>
</blockquote>
This difference is unimportant in <code>countChars</code> but
is critical in situations where the value of the statement is used
in the middle of a more complex computation,
for flow control, or for something else. For example,
the following loop will execute one less time if you change
<code>count++</code> to <code>++count</code>:
<blockquote>
<pre>
do {
    . . .
} while (count++ &lt; 6);
</pre>
</blockquote>

<p>
Similarly, <code>--</code> also has prefix and postfix versions,
which function in the same way as <code>++</code>.
The operations of these operators are summarized in the following
table:
<p>

<!-- TABLE -->
<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Description</th>
<tr>
    <td>
	<code>++</code>
    </td>
    <td>
	<code>op++</code>
    </td>
    <td>
	Increments <code>op</code> by 1; evaluates to value before incrementing
    </td>
</tr>
<tr>
    <td>
	<code>++</code>
    </td>
    <td>
	<code>++op</code>
    </td>
    <td>
	Increments <code>op</code> by 1; evaluates to value after incrementing
    </td>
</tr>
<tr>
    <td>
	<code>--</code>
    </td>
    <td>
	<code>op--</code>
    </td>
    <td>
	Decrements <code>op</code> by 1; evaluates to value before decrementing
    </td>
</tr>
<tr>
    <td>
	<code>--</code>
    </td>
    <td>
	<code>--op</code>
    </td>
    <td>
	Decrements <code>op</code> by 1; evaluates to value after decrementing
    </td>
</tr>

</table>
<p>
</blockquote>

<h4>Relational and Conditional Operators</h4>
<blockquote>
A relational operator compares two values and determines the relationship
between them. For example, <code>!=</code> returns <code>true</code> if the two
operands are unequal. The <code>countChars</code> method uses <code>!=</code>
to determine whether the value returned by <code>in.read</code>
is not equal to <code>-1</code>.
This table summarizes Java's relational operators:
<p>

<!-- TABLE -->

<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Return <code>true</code> if</th>

<tr>

    <td>
	<code>></code>
    </td>
    <td>
	<code>op1 &gt; op2 </code>
    </td>
    <td>
	<code>op1</code> is greater than <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>&gt;=</code>
    </td>
    <td>
	<code>op1 &gt;= op2</code>
    </td>
    <td>
	<code>op1</code> is greater than or equal to <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code><</code>
    </td>
    <td>
	<code>op1 &lt; op2</code>
    </td>
    <td>
	<code>op1</code> is less than <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>&lt;=</code>
    </td>
    <td>
	<code>op1 &lt;= op2 </code>
    </td>
    <td>
	<code>op1</code> is less than or equal to <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>==</code>
    </td>
    <td>
	<code>op1 == op2</code>
    </td>
    <td>
	<code>op1</code> and <code>op2</code> are equal
    </td>
</tr>
<tr>
    <td>
	<code>!=</code>
    </td>
    <td>
	<code>op1 != op2 </code>
    </td>
    <td>
	<code>op1</code> and <code>op2</code> are not equal
    </td>
</tr>

</table>

<p>
Relational operators often are used with the conditional operators
to construct more complex decision-making expressions.
One such operator is <code>&&</code>, which performs the <em>boolean and</em>
operation. For example, you can use two different relational operators along with
<code>&&</code> to determine if both relationships are true. The following
line of code uses this technique to determine if an array index is between two
boundaries. It determines if the index is both greater than 0 and less than
<code>NUM_ENTRIES</code> (which is a previously defined constant value):
<blockquote>
<pre>
0 &lt; index && index &lt; NUM_ENTRIES
</pre>
</blockquote>
Note that in some instances, the second operand to a conditional operator
may not be evaluated. Consider this statement:
<blockquote>
<pre>
((count &gt; NUM_ENTRIES) && (in.read() != -1))
</pre>
</blockquote>
If <code>count</code> is less than <code>NUM_ENTRIES</code>, the left-hand
operand for <code>&&</code> evaluates to false. The <code>&&</code> operator
will return true only if <em>both</em> operands are true. So in this situation,
the return value of <code>&&</code> can be determined without evaluating
the right-hand operand. In such a case, Java will not evaluate the
right-hand operand. Thus, <code>in.read</code> won't get called and
a character will not be read from standard input.
<p>
The operator <code>&</code> is similar to <code>&&</code> if
both of its operands are of boolean type. However, <code>&</code>
always evaluates both of its operands and returns <code>true</code>
if both are <code>true</code>. Likewise, <code>|</code> is similar
to <code>||</code> if both of its operands are boolean. This operator
always evalutes both of its operands and returns <code>false</code>
if they are both <code>false</code>.
<p>
Java supports five binary conditional operators, shown in the
following table:
<p>

<!-- TABLE -->
<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Returns <code>true</code> if</th>

<tr>
    <td>
	<code>&&</code>
    </td>
    <td>
	<code>op1 && op2</code>
    </td>
    <td>
	<code>op1</code> and <code>op2</code> are both <code>true</code>,
	conditionally evaluates <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>||</code>
    </td>
    <td>
	<code>op1 || op2</code>
    </td>
    <td>
	either <code>op1</code> or <code>op2</code> is <code>true</code>,
	conditionally evaluates <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>!</code>
    </td>
    <td>
	<code>! op</code>
    </td>
    <td>
	<code>op</code> is <code>false</code>
    </td>
</tr>
<tr>
    <td>
	<code>&</code>
    </td>
    <td>
	<code>op1 & op2</code>
    </td>
    <td>
	<code>op1</code> and <code>op2</code> are both <code>true</code>,
	always evaluates <code>op1</code> and <code>op2</code
    </td>
</tr>
<tr>
    <td>
	<code>|</code>
    </td>
    <td>
	<code>op1 | op2</code>
    </td>
    <td>
	either <code>op1</code> or <code>op2</code> is <code>true</code>,
	always evaluates <code>op1</code> and <code>op2</code
    </td>
</tr>

</table>

In addition, Java supports one other conditional
operator--the <code>?:</code> operator.
This operator is a tertiary operator
and is basically short-hand for an <code>if</code>-<code>else</code> statement:
<blockquote>
<pre>
expression ? op1 : op2
</pre>
</blockquote>
The <code>?:</code> operator evaluates <code>expression</code>
and returns <code>op1</code> if it's true and <code>op2</code> if it's false.

</blockquote>

<h4>Bitwise Operators</h4>
<blockquote>
A bitwise operator allows you to perform bit manipulation on data.
This table summarizes the bitwise and logical operators available
in the Java language.
<p>

<! -- TABLE -->

<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Operation</th>

<tr>
    <td>
	<code>>></code>
    </td>
    <td>
	<code>op1 >> op2</code>
    </td>
    <td>
	shift bits of <code>op1</code> right by distance <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code><<</code>
    </td>
    <td>
	<code>op1 << op2</code>
    </td>
    <td>
	shift bits of <code>op1</code> left by distance <code>op2</code>
    </td>
</tr>
<tr>
    <td>
	<code>>>></code>
    </td>
    <td>
	<code>op1 >>> op2</code>
    </td>
    <td>
	shift bits of <code>op1</code> right by distance <code>op2</code> (unsigned)
    </td>
</tr>
<tr>
    <td>
	<code>&</code>
    </td>
    <td>
	<code>op1 & op2</code>
    </td>
    <td>
	bitwise <code>and</code>
    </td>
</tr>

<tr>
    <td>
	<code>|</code>
    </td>
    <td>
	<code>op1 | op2</code>
    </td>
    <td>
	bitwise <code>or</code>
    </td>
</tr><tr>
    <td>
	<code>^</code>
    </td>
    <td>
	<code>op1 ^ op2</code>
    </td>
    <td>
	bitwise <code>xor</code>
    </td>
</tr>
<tr>
    <td>
	<code>~</code>
    </td>
    <td>
	<code>~op2</code>
    </td>
    <td>
	bitwise complement
    </td>
</tr>

</table>

<p>
The three shift operators simply shift the bits of the left-hand operand
over by the number of positions indicated by the right-hand operand.
The shift occurs in the direction indicated by the operator itself.
For example, the following statement,
shifts the bits of the integer 13 to the right by one position:
<blockquote>
<pre>
13 >> 1;
</pre>
</blockquote>
The binary
representation of the number 13 is 1101. The result of the shift operation is
1101 shifted to the right by one position--110 or 6 in decimal. Note that
the bit farthest to the right falls off the end into the bit bucket.
A right shift of 1 bit is equivalent to, but more efficient than,
dividing the left-hand operand by 2.
A left shift of 1 bit is equivalent to multiplying by 2.
<p>

<! -- TABLE -->
<table border cellpadding=5>
<th><code>op1</code></th>
<th><code>op2</code></th>
<th>Result</th>

<tr>
    <td>0</td><td>0</td><td>0</td>
</tr>

<tr>
    <td>0</td><td>1</td><td>0</td>
</tr>

<tr>
    <td>1</td><td>0</td><td>0</td>
</tr>

<tr>
    <td>1</td><td>1</td><td>1</td>
</tr>

</table>
<p>
The bitwise and operation performs the "and" function on each parallel pair
of bits in each operand. The "and" function sets the resulting bit to 1
if both operands are 1.
<p>
Suppose you were to "and" the values 12 and 13:
<blockquote>
<pre>
12 & 13
</pre>
</blockquote>
The result of this operation is 12. Why? Well, the binary representation
of 12 is 1100, and the binary representation of 13 is 1101. The "and" function
sets the resulting bit to 1 if both operand bits are 1, otherwise, the
resulting bit is 0. So, if you line up the two operands and perform the
"and" function, you can see that the two high-order bits (the two bits farthest
to the left of each number) of each operand are 1.  Thus the resulting bit in
the result is also 1. The low-order bits evaluate to 0 because either one
or both bits in the operands are 0:
<blockquote>
<pre>
    1101
  & 1100
  ------
    1100
</pre>
</blockquote>
The <code>|</code> operator performs the inclusive or operation and <code>^</code>
performs the exclusive or operation. Inclusive or means that if either of
the two bits are 1 then the result is 1.  The following table shows the
results of your inclusive or operations:
<p>

<! -- TABLE >
<table border cellpadding=5>
<th><code>op1</code></th>
<th><code>op2</code></th>
<th>Result</th>

<tr>
    <td>0</td><td>0</td><td>0</td>
</tr>

<tr>
    <td>0</td><td>1</td><td>1</td>
</tr>

<tr>
    <td>1</td><td>0</td><td>1</td>
</tr>

<tr>
    <td>1</td><td>1</td><td>1</td>
</tr>

</table>
<p>
Exclusive or means that if the two operand bits are different the result is
1, otherwise the result is 0.  The following table shows the results
of your exclusive or operation.
<p>

<! -- TABLE >
<table border cellpadding=5>
<th><code>op1</code></th>
<th><code>op2</code></th>
<th>Result</th>

<tr>
    <td>0</td><td>0</td><td>0</td>
</tr>

<tr>
    <td>0</td><td>1</td><td>1</td>
</tr>

<tr>
    <td>1</td><td>0</td><td>1</td>
</tr>

<tr>
    <td>1</td><td>1</td><td>0</td>
</tr>

</table>
<p>
And finally, the complement operator inverts the value of each bit of the operand:
if the operand bit is 1 the result is 0 and if the operand bit is 0 the result is 1.
<p>
Among other things, bitwise manipulations are useful for managing sets of boolean
flags. Suppose for example, that you had several boolean flags in your program that
indicated the state of various components in your program: is it visible,
is it draggable, and so on. Rather than define a separate boolean
variable to hold each flag, you could define a single variable, <code>flags</code>,
for all of them. Each bit within <code>flags</code> would represent
the current state of one of the flags. You would then use bit manipulations to set
and get each flag.
<p>
First, set up constants that indicated the various flags
for your program. These flags should each be a different power of two to
ensure that the "on" bit didn't overlap with another flag. 
Define a variable, <code>flags</code>, whose bits would be set according to
the current state of each flag. The following code sample initializes <code>flags</code>
to 0 which means that all flags are false (none of the bits are set).
<blockquote>
<pre>
final int VISIBLE = 1;
final int DRAGGABLE = 2;
final int SELECTABLE = 4;
final int EDITABLE = 8;

int flags = 0;
</pre>
</blockquote>
To set the "visible" flag when something became visible you would use this statement:
<blockquote>
<pre>
flags = flags | VISIBLE;
</pre>
</blockquote>
To test for visibility, you could then write:
<blockquote>
<pre>
flags & VISIBLE
</pre>
</blockquote>
</blockquote>

<h4>Assignment Operators</h4>
<blockquote>
You use the basic assignment operator,
<code>=</code>, to assign one value to another.
The <code>countChars</code> method uses <code>=</code>
to initialize <code>count</code>
with this statement:
<blockquote>
<pre>
int count <strong>=</strong> 0;
</pre>
</blockquote>
Java also provides several short cut 
assignment operators that allow you to perform an arithmetic, logical, or
bitwise operation and an assignment operation all with one operator.
Suppose you wanted to add a number to a variable and assign the result back
into the variable, like this:
<blockquote>
<pre>
i = i + 2;
</pre>
</blockquote>
You can shorten this statement using the short cut operator <code>+=</code>.
<blockquote>
<pre>
i += 2;
</pre>
</blockquote>
The two previous lines of code are equivalent.
<p>
This table lists the shortcut assignment operators and their lengthy equivalents:
<p>

<! -- TABLE -->
<table border cellpadding=5>
<th>Operator</th>
<th>Use</th>
<th>Equivalent to</th>

<tr>
    <td>
	<code>+=</code>
    </td>
    <td>
	<code>op1 += op2</code>
    </td>
    <td>
	<code>op1 = op1 + op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>-=</code>
    </td>
    <td>
	<code>op1 -= op2</code>
    </td>
    <td>
	<code>op1 = op1 - op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>*=</code>
    </td>
    <td>
	<code>op1 *= op2</code>
    </td>
    <td>
	<code>op1 = op1 * op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>/=</code>
    </td>
    <td>
	<code>op1 /= op2</code>
    </td>
    <td>
	<code>op1 = op1 / op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>%=</code>
    </td>
    <td>
	<code>op1 %= op2</code>
    </td>
    <td>
	<code>op1 = op1 % op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>&=</code>
    </td>
    <td>
	<code>op1 &= op2 </code>
    </td>
    <td>
	<code>op1 = op1 & op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>|=</code>
    </td>
    <td>
	<code>op1 |= op2</code>
    </td>
    <td>
	<code>op1 = op1 | op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>^=</code>
    </td>
    <td>
	<code>op1 ^= op2</code>
    </td>
    <td>
	<code>op1 = op1 ^ op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>&lt;&lt;=</code>
    </td>
    <td>
	<code>op1 &lt;&lt;= op2</code>
    </td>
    <td>
	<code>op1 = op1 &lt;&lt; op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>&gt;&gt;=</code>
    </td>
    <td>
	<code>op1 &gt;&gt;= op2</code>
    </td>
    <td>
	<code>op1 = op1 &gt;&gt; op2</code>
    </td>
</tr>

<tr>
    <td>
	<code>&gt;&gt;&gt;=</code>
    </td>
    <td>
	<code>op1 &gt;&gt;&gt;= op2</code>
    </td>
    <td>
	<code>op1 = op1 &gt;&gt;&gt; op2</code>
    </td>
</tr>

</table>

</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="vars.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="expressions.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/javaHeader.gif" width=26 height=26 align=top border=0 alt="Learning the Java Language | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>The Nuts and Bolts of the Java Language</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
