


















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Locking an Object</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="synchronization.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="reentrant.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/coreHeader.gif" width=26 height=26 align=bottom border=0 alt="Essential Java Classes | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Doing Two or More Tasks At Once: Threads</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Locking an Object
</h2>
<p>
<blockquote>

The code segments within a program that access the same object from
separate, concurrent threads are called <em>critical sections</em>.
In the Java
language, a critical section can be a block or a method and are
identified with the <code>synchronized</code> keyword.
The Java platform then
associates a lock with every object that has synchronized code.

<p>
In the producer/consumer example, the <code>put</code> and
<code>get</code> methods of the <code>CubbyHole</code> (page 645) are
the critical sections. The <code>Consumer</code> should not access the
<code>CubbyHole</code> when the <code>Producer</code> is changing it,
and the <code>Producer</code> should not modify it when the
<code>Consumer</code> is getting the value. So <code>put</code> and
<code>get</code> in the <code>CubbyHole</code> class should be marked
with the <code>synchronized</code> keyword.
<p>
Here's a code skeleton for the <code>CubbyHole</code> class: 
<blockquote>
<pre>
public class CubbyHole {
    private int contents;
    private boolean available = false;

    public synchronized int get() {
        ...
    }

    public synchronized void put(int value) {
        ...
    }
}
</pre>
</blockquote>
Note that the method declarations for both <code>put</code> and
<code>get</code> contain the <code>synchronized</code> keyword.
 Hence, the system
associates a unique lock with every instance of <code>CubbyHole</code>
(including the one shared by the <code>Producer</code> and the
<code>Consumer</code>). Whenever control enters a synchronized method,
the thread that called the method locks the object whose method has
been called. Other threads cannot call a synchronized method on the
same object until the object is unlocked.
<p>
So, when the <code>Producer</code> calls <code>CubbyHole</code>'s
<code>put</code> method, it locks the <code>CubbyHole</code>, thereby
preventing the <code>Consumer</code> from calling the
<code>CubbyHole</code>'s <code>get</code> method:
<blockquote>
<pre>
public synchronized void put(int value) {
    // CubbyHole locked by the Producer
    ..
    // CubbyHole unlocked by the Producer
}
</pre>
</blockquote>
When the <code>put</code> method returns, the <code>Producer</code>
unlocks the <code>CubbyHole</code>.
<p>
Similarly, when the <code>Consumer</code> calls
<code>CubbyHole</code>'s <code>get</code> method, it locks the
<code>CubbyHole</code>, thereby preventing the <code>Producer</code>
from calling <code>put</code>:
<blockquote>
<pre>
public synchronized int get() {
    // CubbyHole locked by the Consumer
    ...
    // CubbyHole unlocked by the Consumer
}
</pre>
</blockquote>
The acquisition and release of a lock is done automatically and
atomically by the Java runtime system. This ensures that race
conditions cannot occur in the underlying implementation of the
threads, thus ensuring data integrity.
Synchronization isn't the whole story. The two threads must also be able to notify one another when they've done their job. Learn more about that after a brief foray into reentrant locks.

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="synchronization.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="reentrant.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/coreHeader.gif" width=26 height=26 align=top border=0 alt="Essential Java Classes | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Doing Two or More Tasks At Once: Threads</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
