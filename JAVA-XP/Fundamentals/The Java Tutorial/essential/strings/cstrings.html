


















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Java Strings Are First-Class Objects</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="index.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous"></a>
</td>
</tr>
</table>

<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Java Strings Are First-Class Objects
</h2>
<p>
<blockquote>

By convention, C and C++ strings are null-terminated array of characters; 
there is no real entity in C and C++ that is a string.
Java strings are first-class objects.
<p>
Strings as objects provides several advantages to the programmer:
<ul>
<li>
The manner in which you obtain strings and elements of
strings is consistent across all strings and all systems.
<li>
Since the programming interface for the <code>String</code> and <code>StringBuffer</code>
classes is well-defined, Java strings function predictably every time.
<li>
The <code>String</code> and <code>StringBuffer</code> classes do extensive runtime checking
for boundary conditions.  They catch errors for you.
</ul>

<!--The rest of this file doesn't appear to be in the book.-->
To illustrate why this is an important feature of Java, let's
look at a small example. This C function copies the contents
of <code>src</code> into <code>dest</code>.
<blockquote>
<pre>
int myStrCopy(char *dest, char *src)
{
    for ( ; *src != '\0'; src++, dest++)
        *dest = *src;
}
</pre>
</blockquote>

<h4>C <code>String</code>s Behave Unpredictably</h4>
<blockquote>
In the example shown above, the developer uses pointer
arithmetic to step through both strings copying one
into the other. While allowing programmers to inspect
arbitrary memory locations through pointers
is a powerful tool, this power can be the
source of many errors. One fruitful source of errors
is pointers that stray off the end of an array.
The <code>myStrCopy</code> function above has such an error: the <code>for</code>
loop in the function does not check the length of <code>dest</code>, and
if <code>src</code> is longer than <code>dest</code> the string copy
writes right over the end of <code>dest</code>. Here's a
program that tickles the bug.
<blockquote>
<pre>
main() {
    char *s = "HotJava is Cool!";
    char t[] = "Java is Cool!";

    printf("%s, %s\n", s, t);
    myStrCopy(t, s);
    printf("%s, %s\n", s, t);
}
</pre>
</blockquote>

On my machine, the program prints:
<blockquote>
<pre>
HotJava is Cool!, HotJava is Cool!%s, %s
</pre>
</blockquote>

<code>myStrCopy</code> writes over the end of <code>dest</code> thereby
corrupting whatever was stored in the memory after it.
<strong>Note:</strong> <code>%s, %s</code> are the characters that happened
to be stored in the memory location after <code>dest</code> and will probably
be different when you run the program on your machine.

<p>
Sure, the error in <code>myStrCopy</code> can be fixed easily.
But errors like this are often difficult to find.
</blockquote>

<h4>Java Strings Are Predictable</h4>
<blockquote>
Java strings are first-class objects deriving either from the <code>String</code>
class or the <code>StringBuffer</code> class. This makes finding and fixing an entire class of
common and frustrating programming errors such as the one illustrated
above trivial.
<p>
Here's the program above (including the error) rewritten in the Java language:

<blockquote>
<pre>
class strcpy {
    public static void main(String[] args) {
        String s = "HotJava is Cool!";
        StringBuffer t = new StringBuffer("Java is Cool!");

        System.out.println(s + ", " + t);
        myStrCopy(t, s);
        System.out.println(s + ", " + t);
    }

    static void myStrCopy(StringBuffer dest, String src) {
        int i, len = src.length();

        for (i = 0; i &lt len; i++)
            dest.setCharAt(i, src.charAt(i));
    }
}
</pre>
</blockquote>

Notice that this translation uses the <code>String</code> class, the
<code>StringBuffer</code> class,
and the methods appropriate for obtaining
specific characters instead of character arrays and pointers.

<p>
Like the C version, the Java language version of the <code>myStrCopy</code> method loops over the
length of <code>src</code> and never checks the length of <code>dest</code>.
Thus, when <code>src</code> is longer than <code>dest</code>, the method
tries to obtain characters beyond the end of <code>dest</code>. However,
when you run the Java language version,
you'll see the following runtime error message:
<blockquote>
<pre>
Exception in thread "main" java.lang.StringIndexOutOfRangeException String index out of range: 13
    at java.lang.Exception.&lt init &gt(Exception.java)
    at java.lang.StringIndexOutOfRangeException.&lt init &gt(StringIndexOutOfRangeException.java)
    at java.lang.StringBuffer.setCharAt(StringBuffer.java)
    at strcpy.myStrCopy(strcpy.java:23)
    at strcpy.main(strcpy.java:15)
</pre>
</blockquote>
The primary difference between the Java language version of this program and
the C version is that the Java program will reliably and obviously
crash, whereas the C program will do something obscure.
</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="index.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous"></a>
</td>
</tr>
</table>

</body>
</html>
