


















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Changes to the Java Language</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="newclasses.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="compatibility.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/jdk1_1.gif" width=26 height=26 align=bottom border=0 alt="To 1.1 -- And Beyond! | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Migrating to 1.1</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Changes to the Java Language
</h2>
<p>
<blockquote>

<h4>Inner Classes</h4>
<blockquote>
Probably the single most significant change to the Java language
for JDK 1.1 is the ability to define classes as members of
other classes. Such classes are called <em>inner classes</em>
and are covered in
[PENDING: link to inner classes]
</blockquote>

<h4>Anonymous Classes</h4>
<blockquote>
When you are writing simple subclasses or implementations of interfaces,
creating a bunch of classes for each trivial class can be awkward.
Anonymous classes are a convenient short form of inner classes that
have no name, only an implementation that is specified right along
with the <code>new</code>. 
<p>
For a brief discussion of anonymous classes and an example that
uses one, refer to
[PENDING: link to inner classes].
</blockquote>

<h4>Instance Initializers</h4>
<blockquote>
In JDK 1.0.2, the Java language supported
<code>static</code> initializers that let you initialize
class variables.
<blockquote>
<pre>
class ClassWithStaticInitializer {
    static {
	// <em>... initialization code ...</em>
    }
}
</pre>
</blockquote>
JDK 1.1 adds a similar syntax for performing
<em>instance initialization</em>:
<blockquote>
<pre>
class ClassWithInstanceInitializer {
    {
	// <em>... initialization code ...</em>
    }
}
</pre>
</blockquote>
Initialization code introduced without the <code>static</code>
keyword is executed by every constructor,
just after the superclass constructor is called,
in the same order that they appear in the source code,
along with any instance variable initializations.
<p>
An instance initializer may not return,
nor throw a checked exception,
unless that exception is explicitly
declared in the <code>throws</code> clause
of each constructor.
An instance initializer in an anonymous
class <em>can</em> throw any exceptions.
<p>
Instance initializers are useful when instance
variables (including blank finals) 
must be initialized by code which must catch exceptions,
or perform other kinds of control flow which cannot
be expressed in a single initializer expression.
Instance initializers are required if an anonymous
class is to initialize itself, since an anonymous
class cannot declare any constructors.
<p>
[PENDING: link to new material that talks about this
in the book]
</blockquote>

<h4>Array Initialization</h4>
<blockquote>
You can initialize the contents of an array when you
<code>new</code> it. For example, the following would
be a flexible way to create an array of strings:
<p>
<blockquote>
<pre>
String[] tutorialTeam = new String[] {
	    "Alison", "Kathy", "Mary"
};
</pre>
</blockquote>
The array allocation syntax is extended to support
initialization of the elements of anonymous arrays.
</blockquote>

<h4>Class literals</h4>
<blockquote>
A <em>class literal</em> is an expression
consisting of the name of a class, interface, array, 
or primitive type followed by a `<code>.</code>'
and the token <code>class</code>.
It evaluates to an object of type <code>Class</code>,
the class object for the named type (or for void).
<p>
For reference types, a class literal is equivalent
to a call to <code>Class.forName</code> 
with the appropriate string,
except that it does not raise any checked exceptions.
(Its efficiency is likely to be comparable to that of a field access, 
rather than a method call.)
The class literal of a reference type can raise 
<code>NoClassDefFoundError</code>,
in much the same way that a class variable 
reference can raise that error if the variable's class is not available.
<p>
The class literal of a primitive type
or void is equivalent to a static variable 
reference to a pre-installed primitive type descriptor,
according to this table: 
<Table Border="0">
<caption></caption>
<tr><td><br><pre>        boolean.class   ==   Boolean.TYPE
        char.class      ==   Character.TYPE
        byte.class      ==   Byte.TYPE
        short.class     ==   Short.TYPE
        int.class       ==   Integer.TYPE
        long.class      ==   Long.TYPE
        float.class     ==   Float.TYPE
        double.class    ==   Double.TYPE
        void.class      ==   Void.TYPE
</pre>

</Table>

</blockquote>

<h4>New Uses for final</h4>
<blockquote>
Method parameters and local variables can be declared <code>final</code>.
If you do not expect to change the value of a parameter or variable
inside the method, you can declare it <code>final</code> to let the
compiler enforce that.
The compiler can also optimize uses of a <code>final</code>
parameter or variable since it knows the value will never change.
<p>
The <code>final</code>-ness of a parameter is not part of the
method signature-it is simply a detail of the implementation.
A subclass can override a method and add or drop any <code>final</code>
parameter modifiers you wish.
You can also add or drop <code>final</code> modifiers in a method's
parameters without causing any harm to existing compiled code that
uses that method.
The <code>final</code> declaration does not show up in the
documentation generated from doc comments.
<p>
You can defer initialization of a <code>final</code> field or variable,
as long as you initialize it before it is used and assign a value to it
exactly once. The compiler will check for proper assignment,
as will the verifier before code is executed.
Deferred initialization can be useful when the proper value can
only be calculated by a loop or other code that is hard or
impossible to encode in a variable initializer,
such as code that throws exceptions that must be caught and handled.
</blockquote>

<h4>Transient Defined in 1.1</h4>
<blockquote>
The <code>transient</code> keyword, 
has defined meaning for 1.1 (whereas it was
undefined in 1.0.2. In 1.1, <code>transient</code>
is used to mark member variables that should not
be saved during object serialization.
</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="newclasses.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="compatibility.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/jdk1_1.gif" width=26 height=26 align=top border=0 alt="To 1.1 -- And Beyond! | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Migrating to 1.1</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
