




















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>Painting</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="event.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="threads.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=bottom border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Swing Features and Concepts</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    Painting
</h2>
<p>
<blockquote>

You might not need the information in this section at all.
However, if your components don't seem
to be painting themselves correctly,
understanding the concepts in this section
might help you figure out what's wrong.
If you plan to create custom painting code for a component, 
this section is required reading.


<h4>
<a name="howitworks">How Painting Works</a>
</h4>
<blockquote>

When a Swing GUI needs to paint itself --
whether for the first time,
in response to becoming unhidden,
or because it needs to reflect
a change in the program's state --
it starts with the highest component that needs to be repainted
and works its way down the containment hierarchy.
This process is orchestrated by the AWT painting system,
and made more efficient and smooth by the Swing repaint manager
and double-buffering code.

<p>

Swing components generally repaint themselves
whenever necessary.
When you invoke the <code>setText</code> method on a component,
for example,
the component should automatically repaint itself
and, if appropriate, resize itself.
If it doesn't, it's a bug.
The workaround is to invoke the
<code>repaint</code> method on the component
to request that the component be scheduled for painting.
If the component's size or position needs to change
but doesn't do so automatically,
you should invoke <code>revalidate</code> upon the component
before invoking <code>repaint</code>.

<p>

Like event-handling code,
painting code executes on the event-dispatching thread.
While an event is being handled,
no painting will occur.
Similarly, if a painting operation takes a long time,
no events will be handled during that time.

<p>

Programs should paint only when the painting system tells them to
because each occurrence of a component painting itself
must execute without interruption.
Otherwise, unpredictable results could occur,
such as a button being painted as half pressed
and half unpressed.

<p>

For smoothness, Swing painting is <em>double-buffered</em> 
by default --
performed to an offscreen buffer 
and then flushed to the screen once finished.
It might slightly help performance 
if you make a Swing component opaque,
so that the Swing painting system can know 
not to paint anything behind the component.
To make a Swing component opaque,
invoke <code>setOpaque(true)</code> on the component.

<p>

Although their available painting area is always rectangular,
non-opaque Swing components can appear to be any shape.
A button, for instance, might display itself
by painting a filled octagon.
The component behind the button 
(its container, most likely) 
would then be visible,
showing through at the corners of the button's bounds.
The button would have to include
special hit detection code
to avoid acting pressed
if the user happens to click on its corners.
[PENDING: link to where hit detection would be discussed.
In mouse listener?]

<p>

</blockquote>
<h4>
<a name="example">An Example of Painting</a>
</h4>
<blockquote>

To illustrate painting, we'll use the <code>SwingApplication</code> program,
which is explained in 
<a target="_top" href="..\start\swingtour.html">A Quick Tour Through a Swing Application's Code</a><a target="_top" href="..\start\swingtour.html"><img src="http://docs.rinet.ru/Jtuta/images/uiIcon.gif" width=20 height=20 border=0 alt="(in the Creating a User Interface trail)"></a>.
Here is <code>SwingApplication</code>'s GUI:

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/overview/SwingApplication.gif" WIDTH="268 " HEIGHT="119" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT="SwingApplication's GUI"></blockquote>
Here, again, is its containment hierarchy:

<p>
<pre>
                        JFrame (a top-level container)
                          |
                         ...
                          |
                     content pane <!--[Container; actually, JPanel]-->

                          |
                        JPanel
                          |
                  +----------------+
                  |                |
               JButton          JLabel
</pre>

<p>

When the GUI for <code>SwingApplication</code> is painted,
here's what happens:
<ol>
<li> The top-level container, <code>JFrame</code>, paints itself.
<li> The content pane first paints its background,
     which is a solid gray rectangle.
     It then tells the <code>JPanel</code> to paint itself.
     The content pane's background rectangle doesn't 
     actually appear in the finished GUI
     because the content pane is completely obscured by the
     <code>JPanel</code>.

     <hr>
     <strong>Note:</strong>
     It's important that the content pane be opaque.
     Otherwise, messy repaints will result.
     Because the <code>JPanel</code> is opaque,
     we could make it the content pane
     (by subsituting <code>setContentPane</code> for
     the existing code <code>getContentPane().add</code>).
     This would slightly simplify the containment hierarchy and painting 
     by removing an unnecessary container.
     <hr>
<li> The <code>JPanel</code> first paints its background,
     a solid gray rectangle.
     Next, it paints its border.
     The border is an <code>EmptyBorder</code>,
     which has no effect except for
     increasing the <code>JPanel</code>'s size
     by reserving some space at the edge of the panel.
     Finally, the panel asks its children to paint themselves.
<li> To paint itself, the <code>JButton</code> paints
     its background rectangle,
     if necessary, and then paints the text 
     that it contains.
     If the button has the keyboard focus, 
     meaning that any typing goes directly to the button
     for processing,
     then the button does some look-and-feel-specific
     painting to make clear that it has the focus.
<li> To paint itself, the <code>JLabel</code> paints its text.
</ol>

In this way, each component paints itself
before any of the components it contains.
This ensures that the background of a <code>JPanel</code>,
for example, 
is visible only where it isn't covered by 
painting performed by one of the components it contains.
The following figure illustrates
the order in which each component
that inherits from <code>JComponent</code>
paints itself:

<blockquote>
<table>
<tr valign=top>
<th> 1. background
<br>
(if opaque)
<th> 2. custom 
<br>painting
<br>
(if any)
<th> 3. border
<br>
(if any)
<th> 4. children
<br>
(if any)

<tr>
<td>
<pre>
.............
.............
.............
.............
.............
.............
</pre>

<td>
<pre>
.............
....().......
.............
.............
.............
.............
</pre>

<td>
<pre>
=============
=...()......=
=...........=
=...........=
=...........=
=============
</pre>

<td>
<pre>
=============
=...()......=
=.---------.=
=.|JButton|.=
=.---------.=
=============
</pre>

</table>
[PENDING: convert ASCII drawings to real drawings]
</blockquote>

For more information on how to paint, see the
<a target="_top" href="..\painting\index.html">Working with Graphics</a><a target="_top" href="..\painting\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiIcon.gif" width=20 height=20 border=0 alt="(in the Creating a User Interface trail)"></a> lesson.

</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="event.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="threads.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=top border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Swing Features and Concepts</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
