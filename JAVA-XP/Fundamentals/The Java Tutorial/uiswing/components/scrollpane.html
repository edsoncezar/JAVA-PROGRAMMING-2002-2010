




















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>How to Use Scroll Panes</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="panel.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="splitpane.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=bottom border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Swing Components</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    How to Use Scroll Panes
</h2>
<p>
<blockquote>

A
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JScrollPane.html"><code>JScrollPane</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JScrollPane.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> provides a scrollable view of a component.
When screen real estate is limited,
use a scroll pane to display
a component that is large or
one whose size can change dynamically.
<p>
The code to create a scroll pane can be minimal.
For example, here's a picture of a demo program that
uses a scroll pane to view textual output:

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/ToolBarDemo.gif" WIDTH="411" HEIGHT="129" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
And here's the code that creates the text area,
makes it the scroll pane's client,
and adds the scroll pane to the window:
<blockquote>
<pre>
textArea = new JTextArea(5, 30);
JScrollPane scrollPane = new JScrollPane(textArea);
...
contentPane.setPreferredSize(new Dimension(400, 100));
...
contentPane.add(scrollPane, BorderLayout.CENTER);
</pre>
</blockquote>
The program provides the text area as an argument to
<code>JScrollPane</code>'s constructor. This establishes
the text area as the scroll pane's client.
The scroll pane handles everything else:
creating the scroll bars when necessary,
redrawing the client when the user moves the scroll knobs,
and so on.
<p>
Note that the code sample sets the preferred size
of the scroll pane's container.
An alternative would be to set the preferred size
of the scroll pane.
Either way, 
you're limiting the size of the scroll pane.
This is necessary because the default preferred size of the scroll pane
is likely to be too big.

<p>
At first, a scroll pane tries to call its client's
<code>getPreferredScrollableViewportSize</code> method
to determine how large its scrollable area should be.
If the client doesn't have such a method,
the scroll pane sizes itself so that its client
displays at its preferred size.
This makes the scroll pane redundant.
Scrolling-savvy classes, like
<a href="list.html">lists</a>,
<a href="table.html">tables</a>,
<a href="text.html">text components</a>, and
<a href="tree.html">trees</a>,
implement <code>getPreferredScrollableViewportSize</code>.
Implementations of this method
generally report a preferred size for scrolling
that's smaller than the component's standard preferred size.
For example, by default, the value returned by
<code>JList</code>'s implementation of
<code>getPreferredScrollableViewportSize</code>
is just big enough to display eight rows.
If the component that you've put in a scroll pane,
doesn't implement <code>getPreferredScrollableViewportSize</code>
or if you don't like the value it returns,
set the preferred size of the scroll pane
or its container.

<p>

If all you need to do is provide basic scrolling
for a component, read no further.
As this demo program illustrates,
a generic scroll pane is sufficient for many programs.

<p>
However, a scroll pane is a highly customizable object.
You can determine the circumstances
under which scroll bars are displayed.
You can also decorate the scroll pane 
with a row header, column header, and corners.
Finally, you can implement a scrolling-savvy client
that advises the scroll pane about scrolling behavior
such as preferred size for the scrollable area,
and unit and block increments.
These topics are discussed in the following sections:

<ul>
<li> <a href="#operation">How a Scroll Pane Works</a>
<li> <a href="#scrollbars">Setting the Scroll Bar Policy</a>
<li> <a href="#decorations">Providing Custom Decorations</a>
<li> <a href="#scrollable">Implementing a Scrolling-Savvy Client</a>
<li> <a href="#api">The Scroll Pane API</a>
<li> <a href="#eg">Examples that Use Scroll Panes</a>
</ul>

<a name="operation">
<h4>How a Scroll Pane Works</h4>
</a>
<blockquote>
Here is a snapshot of an application
that uses a fully-loaded scroll pane
to view a picture of Mary's dad as a youth: 

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/ScrollDemo.gif" WIDTH="353" HEIGHT="321" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
The scroll pane in this application looks remarkably different
from the one in the previous demo program.
Rather than text, this scroll pane contains a large image.
The scroll pane also has two scroll bars, a row header, a column header,
and three custom corners, one of which contains a toggle button.

<blockquote>
<hr>
<strong>Try this:</strong>
<ol>
<li> Compile and run the application.
     The main source file is
     <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/ScrollDemo.java"><code>ScrollDemo.java</code></a>.
     You also need
     <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/ScrollablePicture.java">
     <code>ScrollablePicture.java</code></a>,
     <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/Rule.java"><code>Rule.java</code></a>,
     <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/Corner.java"><code>Corner.java</code></a>
     and
     <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/images/youngdad.jpeg">
     <code>youngdad.jpeg</code></a>.
     <br>
     See <a href="..\start\index.html">Getting Started with Swing</a> if you need help.

<li> Move the knobs on the scroll bars.
     Watch the image scroll and the horizontal and vertical rulers scroll along.
<li> Click the <strong>cm</strong> toggle in the upper left corner.
     The units on the row and column headers change to inches
     (or back to centimeters).
<li> Click the arrow buttons on the scroll bars.
     Also, try clicking on the track above or below the knob
     on the vertical scroll bar, or to the left or right of the horizontal one.
<li> Resize the window.
     Notice that the scroll bars disappear when the scroll pane
     is large enough to display the entire image
     and reappear again when the scroll pane is too small to
     show the entire client.
   
</ol>
<hr>
</blockquote>
This program establishes the scroll pane's client
when creating the scroll pane:
<blockquote>
<pre>
// <em>where the member variables are declared</em>
private ScrollablePicture picture;
...
	// <em>where the GUI is created</em>
        picture = new ScrollablePicture(<em> ... </em>);
        JScrollPane pictureScrollPane = new JScrollPane(picture);
</pre>
</blockquote>
You can change a scroll pane's client dynamically by calling the
<code>setViewportView</code> method.
<p>
When you manipulate the scroll bars in a scroll pane,
you change the area of the client that is visible.
This picture shows this relationship and indicates the
classes that the scroll pane commissions to help:

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/scrollarchitecture.gif" WIDTH="531" HEIGHT="334" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
<p>
When you move the knob on the vertical scroll bar up and down,
the visible area of the client moves up and down. Similarly, when you
move the knob on the horizontal scroll bar to the right and
left, the visible area of the client moves back and forth accordingly.

<p>
A scroll pane uses a
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JViewport.html"><code>JViewport</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JViewport.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> instance to manage the visible area of the client.
The viewport computes the bounds of the current visible area,
based on the positions
of the scroll bars,
and displays it.
A scroll pane uses two separate instances of 
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JScrollBar.html"><code>JScrollBar</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JScrollBar.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> for the scroll bars. The scroll bars provide the
interface for the user to manipulate the visible area.

<p>
Typical programs don't directly instantiate or
call methods on a viewport or scroll bar.
Instead, programs achieve their scrolling
behavior using the <code>JScrollPane</code> API 
and the API discussed in 
<a href="#scrollable">Implementing a Scrolling-Savvy Client</a>.
Some scrolling-savvy components such as
<code>JTable</code> and <code>JTree</code> also provide some API
to help you affect their scrolling behavior.
</blockquote>

<a name="scrollbars">
<h4>Setting the Scroll Bar Policy</h4>
</a>
<blockquote>
On startup, the <code>ScrollDemo</code>
application contains two scroll bars.
If you make the window as large as your screen,
both scroll bars disappear because they are no longer needed.
This behavior is controlled by the scroll pane's
<em>scroll bar policy</em>. Actually, it's two
policies:  you specify the policy
for each scroll bar separately.
<p>
Of the constructors provided by <code>JScrollPane</code>,
two let you set the scroll bar policies
when you create the scroll pane:
<blockquote>
<pre>
JScrollPane(Component, int, int)
JScrollPane(int, int)
</pre>
</blockquote>
The first <code>int</code> specifies the policy for the vertical
scroll bar, the second specifies the policy for the horizontal scroll bar.
You can also set the policies dynamically with the
<code>setHorizontalScrollBarPolicy</code>
and 
<code>setVerticalScrollBarPolicy</code> methods.
With both the constructors and the methods, use
one of the following <code>int</code>s defined
in the 
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/ScrollPaneConstants.html"><code>ScrollPaneConstants</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/ScrollPaneConstants.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> interface which is implemented by <code>JScrollPane</code>:
<p>
<table cellpadding=5 border=1>
<tr>
<th>Policy<th>Description

<tr>
<td><font size=-1><code>VERTICAL_SCROLLBAR_AS_NEEDED</code></font><br>
    <font size=-1><code>HORIZONTAL_SCROLLBAR_AS_NEEDED</code></font>
<td>The default.
    The scroll bar appears when the viewport is smaller than the client
    and disappears when the viewport is larger than the client.

<tr>
<td><font size=-1><code>VERTICAL_SCROLLBAR_ALWAYS</code></font><br>
    <font size=-1><code>HORIZONTAL_SCROLLBAR_ALWAYS</code></font>
<td>Always display the scroll bar.
    The knob disappears if the viewport is large enough to show the whole client.

<tr>
<td><font size=-1><code>VERTICAL_SCROLLBAR_NEVER</code></font><br>
    <font size=-1><code>HORIZONTAL_SCROLLBAR_NEVER</code></font>
<td>Never display the scroll bar.
    Use this option if you don't want the user to directly control
    what part of the client is shown. Perhaps you have an application
    which requires all scrolling to occur programmatically.

</table>

</blockquote>

<a name="decorations">
<h4>Providing Custom Decorations</h4>
</a>
<blockquote>
At most,
the area drawn by a scrollpane is divided into nine parts:
the center, four sides, and four corners.
The center is the only component that is always
present in all scroll panes.
The top side can contain a column header,
the left side can contain a row header,
the bottom side can contain a horizontal scroll bar,
and the right side can contain a vertical scroll bar.
The presence of each corner depends entirely
on the presence of the two sides that intersect there.

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/scrollpanedecorations.gif" WIDTH="508" HEIGHT="333" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
As shown in the figure, the scroll pane in <code>ScrollDemo.java</code>
has custom row and column headers.
Additionally, because all four sides are populated,
all four corners are present.  Three of the corners are customized.
<p>
The scroll pane's row and column headers are provided
by a custom <code>JComponent</code> subclass,
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/Rule.java"><code>Rule.java</code></a>,
that draws a ruler in centimeters or inches.
Here's the code that creates and sets the scroll pane's row
and column headers:
<blockquote>
<pre>
...<em>where the member variables are defined</em>...
private Rule columnView;
private Rule rowView;
    ...
    // Create the row and column headers
    ImageIcon david = new ImageIcon("images/youngdad.jpeg");
    columnView = new Rule(Rule.HORIZONTAL, false);
    columnView.setPreferredWidth(david.getIconWidth());
    rowView = new Rule(Rule.VERTICAL, false);
    rowView.setPreferredHeight(david.getIconHeight());
    ...
    pictureScrollPane.setColumnHeaderView(columnView);
    pictureScrollPane.setRowHeaderView(rowView);
    ...
</pre>
</blockquote>
You can use any component
for a scroll pane's row and column headers.
The scroll pane puts the row and column headers
in <code>JViewPort</code>s of their own.
Thus, when scrolling horizontally, the column header follows along,
and when scrolling vertically, the row header follows along.
<p>
As a <code>JComponent</code> subclass,
<code>Rule</code> renders itself
by overriding the <code>paintComponent</code> method.
Careful scrutiny of the code reveals that special
effort is taken to draw only within the current clipping bounds.
[PENDING: say more here about what that means?]
Your custom row and column headers should do the same
to ensure speedy scrolling.
<p>
You can also use any component for the corners of a scroll pane.
<code>ScrollDemo.java</code> illustrates this by putting a toggle
button in the upper left corner,
and custom
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/Corner.java"><code>Corner</code></a>
objects in the upper right and lower left corners.
Here's the code that creates
the corner objects and calls <code>setCorner</code> to place them:
<blockquote>
<pre>
// Create the corners
JPanel buttonCorner = new JPanel();
isMetric = new JToggleButton("cm", true);
isMetric.setFont(new Font("SansSerif", Font.PLAIN, 11));
isMetric.setMargin(new Insets(2,2,2,2));
isMetric.addItemListener(new UnitsListener());
buttonCorner.add(isMetric); //Use the default FlowLayout

<em>...// Set the corners:</em>
pictureScrollPane.setCorner(JScrollPane.UPPER_LEFT_CORNER, 
				buttonCorner);
pictureScrollPane.setCorner(JScrollPane.LOWER_LEFT_CORNER,
				new Corner());
pictureScrollPane.setCorner(JScrollPane.UPPER_RIGHT_CORNER,
				new Corner());
</pre>
</blockquote>
Remember that the size of each corner is completely determined by
the size of the sides intersecting there.
So for some components
you must take care that the specific instance
of the component fits in its corner.
For example, the toggle button was set up specifically
to fit within the corner established by the headers.
It's not an issue with the <code>Corner</code> class
because that class colors its entire bounds,
whatever they happen to be, with a solid color.
<p>
As you can see from the code, constants indicate the corner positions.
This figure shows the constant for each position:

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/scrollpanecorners.gif" WIDTH="513" HEIGHT="122" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
</table>
<p>
The constants are defined in the <code>ScrollPaneConstants</code> interface,
which <code>JScrollPane</code> implements.

</blockquote>
<a name="scrollable">
<h4>Implementing a Scrolling-Savvy Client</h4>
</a>
<blockquote>

To customize the way that a client component interacts 
with its scroll pane,
you can make the component implement the 
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/Scrollable.html"><code>Scrollable</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/Scrollable.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> interface.
By implementing <code>Scrollable</code>,
a client can specify both
the size of the viewport the scroll pane uses to view it
and the amount to scroll for clicks on the different controls on a scrollbar.

<p>

The following figure shows the three areas of a scroll bar:
the knob, the buttons, and the track.

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/scrollbarparts.gif" WIDTH="248" HEIGHT="109" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
You might have noticed when manipulating the scroll bars
in <code>ScrollDemo</code> that clicking the buttons
scrolls the image to a tick boundary. You might also
have noticed that clicking in the track scrolls the
picture by a "screenful". More generally, the button
scrolls the visible area by a <em>unit increment</em> and the track
scrolls the visible area by a <em>block increment</em>.
The behavior you see in the example is not the scroll pane's default
behavior, but is specified by the client
in its implementation of the <code>Scrollable</code> interface.

<p>

The client for the <code>ScrollDemo</code> program is
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/ScrollablePicture.java">
<code>ScrollablePicture.java</code></a>.
<code>ScrollablePicture</code> is a subclass of <code>JLabel</code>
that provides implementations of all five <code>Scrollable</code> methods:

<ul>
<li> <code>getScrollableBlockIncrement</code>
<li> <code>getScrollableUnitIncrement</code>
<li> <code>getPreferredViewportSize</code>
<li> <code>getScrollableTracksViewportHeight</code>
<li> <code>getScrollableTracksViewportWidth</code>
</ul>

<code>ScrollablePicture</code> implements the <code>Scrollable</code>
interface primarily to affect the unit and block increments.
However, it must provide implementations for all five methods.
So it provides reasonable defaults for the other three methods
that you might want to copy for your scrollable classes.
<p>
The scroll pane calls the client's
<code>getScrollableUnitIncrement</code>
method whenever the user clicks
one of the buttons on the scroll bar.
This method returns the number of pixels to scroll.
An obvious implementation of this method returns the
number of pixels between tick marks on the header rulers.
But <code>ScrollablePicture</code> does something different:
It returns the value required to position the image on
a tick mark boundary. Here's the implementation:
<blockquote>
<pre>
public int getScrollableUnitIncrement(Rectangle visibleRect,
				      int orientation,
				      int direction) {
    //get the current position
    int currentPosition = 0;
    if (orientation == SwingConstants.HORIZONTAL)
        currentPosition = visibleRect.x;
    else
        currentPosition = visibleRect.y;

    //return the number of pixels between currentPosition
    //and the nearest tick mark in the indicated direction
    if (direction < 0) {
        int newPosition = currentPosition -
			 (currentPosition / maxUnitIncrement) *
			  maxUnitIncrement;
        return (newPosition == 0) ? maxUnitIncrement : newPosition;
    } else {
        return ((currentPosition / maxUnitIncrement) + 1) * 
		 maxUnitIncrement - currentPosition;
    }
}
</pre>
</blockquote>
If the image is already on a tick mark boundary, this method returns
the number of pixels between ticks. Otherwise, it returns the number
of pixels from the current location to the nearest tick.
<p>
Likewise,
the scroll pane calls the client's <code>getScrollableBlockIncrement</code>
method each time the user clicks on the track.
Here's
<code>ScrollablePicture</code>'s implementation of this method:
<blockquote>
<pre>
public int getScrollableBlockIncrement(Rectangle visibleRect,
				       int orientation,
				       int direction) {
    if (orientation == SwingConstants.HORIZONTAL)
        return visibleRect.width - maxUnitIncrement;
    else
        return visibleRect.height - maxUnitIncrement;
}
</pre>
</blockquote>
This method returns the height of the visible rectangle minus a tick mark.
This behavior is typical. A block increment should be slightly smaller
than the viewport to leave a little of the previous visible area for context.
For example, a text area might leave one or two lines of text for context
and a table might leave a row or column (depending on the scroll direction).
<p>
See the <a href="#scrollableAPI">Implementing the Scrollable Interface</a>
API table for further details about the methods
defined in <code>Scrollable</code>.
<p>
The Swing packages provide these scrolling-savvy classes:
<ul>
<li><a href="list.html">lists</a>
<li><a href="table.html">tables</a>
<li><a href="text.html">text components</a>
<li><a href="tree.html">trees</a>
</ul>
</blockquote>

<h4>
<a name="api">The Scroll Pane API</a>
</h4>
<blockquote>
The following tables list the commonly used
<code>JScrollPane</code> constructors and methods.
Other methods you're likely to call
are defined by the
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JComponent.html"><code>JComponent</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/JComponent.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> and
<a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.awt.Component.html"><code>Component</code></a><a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.awt.Component.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> classes
and include
[PENDING: anything in particular for JScrollPane?].
[Link to JComponent and Component discussions.]

<p>

The API for using scroll panes falls into these categories:

<ul>
<li><a href="#setup">Setting Up the Scroll Pane</a>
<li><a href="#decorationsAPI">Decorating the Scroll Pane</a>
<li><a href="#scrollableAPI">Implementing the Scrollable Interface</a>
</ul>

<p>

<table border=1>
<caption><a name="setup">Setting Up the Scroll Pane</a></caption>
<tr>
<th align=left>Method
<th align=left>Purpose

<tr>
<td><font size=2><code>JScrollPane()
    <br>
    JScrollPane(Component)
    <br>
    JScrollPane(int, int)
    <br>
    JScrollPane(Component, int, int)</code></font>
<td>Create a scroll pane.
    The <code>Component</code> parameter, when present, sets
    the scroll pane's client.
    The two <code>int</code> parameters, when present, set the
    vertical and horizontal scroll bar policies (respectively).

<tr>
<td><font size=2><code>void setViewportView(Component)</code></font>
<td>Set the scroll pane's client.

<tr>
<td><font size=2><code>void setVerticalScrollBarPolicy(int)
    <br>
    int getVerticalScrollBarPolicy()</code></font>
<td>Set or get the vertical scroll policy.
    <code>ScrollPaneConstants</code> defines three values
    for specifying this policy:
    <code>VERTICAL_SCROLLBAR_AS_NEEDED<code> (the default),
    <code>VERTICAL_SCROLLBAR_ALWAYS<code>, and
    <code>VERTICAL_SCROLLBAR_NEVER<code>.

<tr>
<td><font size=2><code>void setHorizontalScrollBarPolicy(int)
    <br>
    int getHorizontalScrollBarPolicy()</code></font>
<td>Set or get the horizontal scroll policy.
    <code>ScrollPaneConstants</code> defines three values
    for specifying this policy:
    <code>HORIZONTAL_SCROLLBAR_AS_NEEDED<code> (the default),
    <code>HORIZONTAL_SCROLLBAR_ALWAYS<code>, and
    <code>HORIZONTAL_SCROLLBAR_NEVER<code>.

<tr>
<td><font size=2><code>void setViewportBorder(Border)
    <br>
    Border getViewportBorder()</code></font>
<td>Set or get the border around the viewport.

</table>

<p>
<table border=1>
<caption><a name="decorationsAPI">Decorating the Scroll Pane</a></caption>
<tr>
<th align=left>Method
<th align=left>Purpose

<tr>
<td><font size=2><code>void setColumnHeaderView(Component)
    <br>
    void setRowHeaderView(Component)</code></font>
<td>Set the column or row header for the scroll pane.

<tr>
<td><font size=2><code>void setCorner(Component, int)
    <br>
    Component getCorner(int)</code></font>
<td>Set or get the corner specified.
    The <code>int</code> parameter specifies which corner
    and must be one of the following constants defined in
    <code>ScrollPaneConstants</code>:
    <code>UPPER_LEFT_CORNER</code>,
    <code>UPPER_RIGHT_CORNER</code>,
    <code>LOWER_LEFT_CORNER</code>, and
    <code>LOWER_RIGHT_CORNER</code>.
</table>

<p>
<table border=1>
<caption><a name="scrollableAPI">Implementing the Scrollable Interface</a></caption>
<tr>
<th align=left>Method
<th align=left>Purpose

<tr>
<td><font size=2><code>int getScrollableUnitIncrement(Rectangle, int, int)
    <br>
    void getScrollableBlockIncrement(Rectangle, int, int)</code></font>
<td>Get the unit or block increment in pixels.
    The <code>Rectangle</code> parameter is the bounds of the
    currently visible rectangle.
    The first <code>int</code> parameter is either
    <code>SwingConstants.HORIZONTAL</code> or
    <code>SwingConstants.VERTICAL</code> depending on what scroll bar
    the user clicked on.
    The second <code>int</code> parameter indicates which direction
    to scroll. A value less than 0 indicates up or left. A value
    greater than 0 indicates down or right.

<tr>
<td><font size=2><code>Dimension getPreferredScrollableViewportSize()</code></font>
<td>Get the preferred size of the viewport.
    This allows the client to influence
    the size of the viewport in which it will be displayed.
    If the viewport size is unimportant,
    implement this method to return <code>getPreferredSize</code>.

<tr>
<td><font size=2><code>boolean getScrollableTracksViewportWidth()
    <br>
    boolean getScrollableTracksViewportHeight()</code></font>
<td>Get whether the scroll pane should force the client to be the same
    width or height as the viewport.
    A return value of <code>true</code>
    from either of these methods effectively disallows
    horizontal or vertical scrolling (respectively).

</table>

</blockquote>

<h4>
<a name="eg">Examples that Use Scroll Panes</a>
</h4>
<blockquote>
This table shows the examples that use <code>JScrollPane</code>
and where those examples are described.
<p>
<table>
<tr>
<th align=left> Example
<th align=left> Where Described
<th align=left> Notes

<tr>
<td> <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/ToolBarDemo.java"><code>ToolBarDemo.java</code></a>
<td> This page and<br>
     <a href="toolbar.html">How to Use Tool Bars</a>.
<td> Shows a simple, yet typical, use of a scroll pane.

<tr>
<td> <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/ScrollDemo.java"><code>ScrollDemo.java</code></a>
<td> This page.
<td> Uses many of scroll pane's bells and whistles.

<tr>
<td> <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/SplitPaneDemo.java"><code>SplitPaneDemo.java</code></a>
<td> <a href="splitpane.html">How to Use Split Panes</a> and
     <a href="list.html">How to Use Lists</a>.
<td> Puts a list in a scroll pane.
     Also, shows how to handle the case when a scrollable client changes size.

<tr>
<td> <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/TableDemo.java"><code>TableDemo.java</code></a>
<td> <a href="table.html">How to Use Tables</a>.
<td> Puts a table in a scroll pane.

<tr>
<td> <a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/TreeDemo.java"><code>TreeDemo.java</code></a>
<td> <a href="tree.html">How to Use Trees</a>.
<td> Puts a tree in a scroll pane.

</table>

</blockquote>


</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="panel.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="splitpane.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=top border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Swing Components</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
