




















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<title>General Rules for Using Text Components</title>
</head>
<body BGCOLOR="#ffffff">










<table width="100%">
<tr>
<td align=left>
<a href="simpletext.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=bottom border=0 alt="Previous | "></a><a
href="textfield.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=bottom border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=bottom border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=bottom border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Swing Components</em></strong></a>
</td>
</tr>
</table>
<p>
<center>
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
<IMG SRC="http://docs.rinet.ru/Jtuta/images/shoeline2.GIF" ALIGN="BOTTOM" BORDER="0" WIDTH="202"
    HEIGHT="25" NATURALSIZEFLAG="3">
</center>
<p> 

<h2>
    General Rules for Using Text Components
</h2>
<p>
<blockquote>

<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/JTextComponent.html"><code>JTextComponent</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/JTextComponent.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> is the foundation for Swing's text components,
and provides these customizable
features for all of its descendants:

<ul>
<li> A separate model, known as a <em>document</em>,
     to manage the component's content.
<li> A separate view, which is in charge of displaying the
     component on screen. This tutorial does not discuss views.
<li> A separate controller, known as an <em>editor kit</em>,
     that can read and write text
     and implements editing capabilities with action commands.
<li> Customizable keymaps and key bindings.
<li> Support for infinite undo/redo.
<li> Pluggable caret and support for caret change listeners.
</ul>

This section uses the application shown below
to explore each of these capabilities.
The demo application contains a <code>JTextPane</code>--
one of <code>JTextComponent</code>'s subclasses that supports
styled text, embedded icons, and embedded components--
to illustrate the capabilities inherited by all of
<code>JTextComponent</code>'s subclasses.
For information specific to <code>JTextPane</code>
refer to <a href="editorpane.html">How to Use Editor Panes and Text Panes</a>.

<blockquote><IMG SRC="http://docs.rinet.ru/Jtuta/figures/uiswing/components/TextComponentDemo.gif" WIDTH="390" HEIGHT="368" ALIGN="BOTTOM" NATURALSIZEFLAG="3" ALT=""></blockquote>
The upper text component is the customized <code>JTextPane</code>.
The lower text component is a <code>JTextArea</code>,
which serves as a log that reports all changes
made to the contents of the text pane.
The status line at the bottom of the window reports either
the location of the selection or the position of the caret,
depending on whether text is selected.
<blockquote>
<hr>
<strong>Note</strong>:
The main source file for this application is
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/TextComponentDemo.java"><code>TextComponentDemo.java</code></a>.
You also need 
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/LimitedStyledDocument.java"><code>LimitedStyledDocument.java</code></a>.
<hr>
</blockquote>

Through this example application, you will learn
how to use a text component's capabilities
and how to customize them.
This section covers these topics,
which can be applied to all <code>JTextComponent</code> subclasses:
:
<ul>
<li> <a href="#document">Concepts: About Documents</a>
<li> &nbsp;&nbsp;&nbsp;<a href="#customdocument">Customizing a Document</a>
<li> &nbsp;&nbsp;&nbsp;<a href="#doclisteners">Listening for Changes on a Document</a>
<li> <a href="#editorkits">Concepts: About Editor Kits</a>
<li> &nbsp;&nbsp;&nbsp;<a href="#commands">Associating Actions with Menus and Buttons</a>
<li> <a href="#keymaps">Concepts: About Keymaps</a>
<li> &nbsp;&nbsp;&nbsp;<a href="#bindingkeystrokes">Associating Actions with Keystrokes</a>
<li> <a href="#undo">Implementing Undo and Redo</a>
<li> <a href="#caret">Listening for Caret and Selection Changes</a>
</ul>

<a name="document">
<h4>Concepts: About Documents</h4>
</a>
<blockquote>
Like other Swing components, 
a text component separates its data (known as the
<em>model</em>) from its view of the data.
If you are not yet familiar with the model-view split
used by Swing components,
refer to
<a href="..\overview\swingfeatures.html#model">
Separate Data and State Models</a>.
<p>
A text component's model is known as
a <em>document</em>. It contains text,
supports editing of text,
and notifies listeners of changes to the text.
A document is an instance of a class that implements the
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Document.html"><code>Document</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Document.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> interface or its
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/StyledDocument.html"><code>StyledDocument</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/StyledDocument.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> subinterface.
<p>
The <code>javax.swing.text</code> package provides
this hierarchy of document classes:
<blockquote>
<pre>
	AbstractDocument
      (implements Document)
                |
	+-------+-------+
	|		|
  PlainDocument	    DefaultStyledDocument
		    (implements StyledDocument)
</pre>
</blockquote>
By default, a text field, a password field, and a text area
each use an instance of <code>PlainDocument</code> as its document.
<code>PlainDocument</code> provides a basic container for text
where all the text is displayed in the same font.
An editor pane and a text pane each use an instance of
<code>DefaultStyledDocument</code> for its document.
<code>DefaultStyledDocument</code> provides additional
support for styled text.
<p>
You can customize any Swing text component
by setting its document to an instance of any class,
including those that you write,
that implements the <code>Document</code> or
<code>StyledDocument</code> interfaces.
</blockquote>

<a name="customdocument">
<h4>Customizing a Document</h4>
</a>
<blockquote>
The <code>TextComponentDemo</code> application has a custom document,
<a href="http://docs.rinet.ru/Jtuta/uiswing/components/example-swing/LimitedStyledDocument.java">
<code>LimitedStyledDocument</code></a>,
that limits the number of characters that it can contain.
<code>LimitedStyledDocument</code>
is a subclass
of <code>DefaultStyledDocument</code>,
the default document for <code>JTextPane</code>.
<p>
Here's the code from the example program
that creates a <code>LimitedStyledDocument</code>
and makes it the document for the text pane:
<blockquote>
<pre>
...<em>where the member variables are declared</em>...
JTextPane textPane;
static final int MAX_CHARACTERS = 300;
    ...<em>in the constructor for the frame</em>...
    //Create the document for the text area
    LimitedStyledDocument lpd = new LimitedStyledDocument(MAX_CHARACTERS);
    ...
    //Create the text pane and configure it
    textPane = new JTextPane();
    textPane.setDocument(lpd);
    ...
</pre>
</blockquote>
To limit the characters allowed in the document,
<code>LimitedStyledDocument</code> overrides its
superclass's <code>insertString</code> method, which
is called each time text is inserted into the document.
<blockquote>
<pre>
public void insertString(int offs, String str, AttributeSet a)
	           			throws BadLocationException {
    if ((getLength() + str.length()) <= maxCharacters)
        super.insertString(offs, str, a);
    else
        Toolkit.getDefaultToolkit().beep();
}
</pre>
</blockquote>
In addition to <code>insertString</code>,
custom documents commonly override
the <code>remove</code> method ,
which is called each time text is removed from the document.
<p>
One common use of a custom document is to create
a keystroke-validated text field
(a field whose value is checked each time the field is edited).
For two examples of validated text fields, refer to
<a href="textfield.html#validation">Creating a Validated Text Field</a>.
<p>
For more information, see these API tables:
<a href="#docclasses">
Classes and Interfaces that Represent Documents</a>
and
<a href="#docmethods">
Useful Methods for Working with Documents</a>.
</blockquote>

<a name="doclisteners">
<h4>Listening for Changes on a Document</h4>
</a>
<blockquote>
A document notifies interested listeners
of changes to the document.
Use a document listener to react
when text is inserted or removed from a document,
or when the style of some of the text changes.
<p>
The <code>TextComponentDemo</code> program uses a document
listener to update the change log whenever a change is made
to the text pane. This line of code registers an instance of
<code>MyDocumentListener</code> as a listener on the
<code>LimitedStyledDocument</code> used in the example:
<blockquote>
<pre>
LimitedStyledDocument lpd = new LimitedStyledDocument(MAX_CHARACTERS);
lpd.addDocumentListener(new MyDocumentListener());
</pre>
</blockquote>
Here's the implementation of <code>MyDocumentListener</code>:
<blockquote>
<pre>
protected class MyDocumentListener implements DocumentListener {
    public void insertUpdate(DocumentEvent e) {
        update(e);
    }
    public void removeUpdate(DocumentEvent e) {
        update(e);
    }
    public void changedUpdate(DocumentEvent e) {
        //Display the type of edit that occurred
        changeLog.append(e.getType().toString() +
                         ": from " + e.getOffset() +
                         " to " + (e.getOffset() + e.getLength() - 1) +
                         newline);
        changeLog.setCaretPosition(changeLog.getDocument().getLength() - 1);
    }
    private void update(DocumentEvent e) {
        //Display the type of edit that occurred and
        //the resulting text length
        changeLog.append(e.getType().toString() +
                         ": text length = " +
                         e.getDocument().getLength() + newline);
        changeLog.setCaretPosition(changeLog.getDocument().getLength() - 1);
    }
} 
</pre>
</blockquote>
The listener in our example displays
the type of change that occurred and,
if affected by the change,
the length of the text.
For general information about document listeners
and document events,
see
<a href="..\events\documentlistener.html">
How to Write a Document Listener</a>.
<p>
<a name="dontdothis"></a>
Remember that the document for this text pane limits
the number of characters allowed in the document.
If you try to add text so that the maximum would be exceeded,
the document blocks the change and the listener's
<code>insertUpdate</code> method is not called.
Document listeners are notified of changes only if
the change has already occurred.
<p>
Sometimes, you might be tempted to change the
document's text from within a document listener.
For example, if you have a text field that
should contain only integers
and the user enters some other type of data,
you might want to change the text to <code>0</code>.
<strong> 
However, you should never modify the contents of
text component from within a document listener.
</strong>
In fact, if you attempt to modify the text in a text component
from within a document listener, your program will likely deadlock!
Instead, provide a custom document and override
the <code>insert</code> and <code>remove</code> methods.
<a href="textfield.html#validation">
Creating a Validated Text Field</a> shows you how.
</blockquote>

<a name="editorkits">
<h4>Concepts: About Editor Kits</h4>
</a>
<blockquote>
All Swing text components supports standard
editing commands such as cut, copy, paste, and
inserting characters.
Each editing command is represented and implemented by an
<a href="..\misc\action.html">action</a> object.
This makes it easy for you to associate a command
with a GUI component, such as a menu item or button,
and build a GUI around a text component.
<p>
Under the hood,
a text component uses an <code>EditorKit</code>
object to create and manage its actions.
Besides managing a set of actions for a text component,
an editor kit also knows how to read and write documents of
a particular format.
<p>
The Swing text package provides these editor kits:
<dl>
<dt>
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/DefaultEditorKit.html"><code>DefaultEditorKit</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/DefaultEditorKit.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a><dd> Reads and writes unstyled text.
     Provides a basic set of editing commands.
     All the other editor kits are descendants of this one.

<dt>
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/StyledEditorKit.html"><code>StyledEditorKit</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/StyledEditorKit.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a><dd> Reads and writes styled text and
     provides a minimal set of actions for styled text.
     This class is a subclass of <code>DefaultEditorKit</code>
     and is the editor kit used by <code>JTextPane</code>
     by default.

<dt>
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/html/HTMLEditorKit.html"><code>HTMLEditorKit</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/html/HTMLEditorKit.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a><dd>Reads, writes, and edits HTML. This is a subclass of
    <code>StyledEditorKit</code>.
</dl>

Most programmers don't need to write code
that interacts directly with editor kits
because <code>JTextComponent</code> provides
the API you need to indirectly invoke editor kit capabilities.
For example, <code>JTextComponent</code> provides
<code>read</code> and <code>write</code> methods,
which invoke the editor kit's <code>read</code> and
<code>write</code> methods.
<code>JTextComponent</code> also provides
a method, <code>getActions</code>, which returns
all of the actions supported by a component.
This method gets the list of actions from the component's editor kit.
However, the editor kit classes provide useful inner classes
and class variables that are useful when creating a GUI
around a text component.
<a href="#commands">Associating Actions with Menu Items</a>
shows you how to hook an action up to a menu item
and <a href="#keymaps">Associating Actions with Keystrokes</a>
shows you how to hook an action up to a specific keystroke.
Both sections make use of handy classes or variables defined
in Swing's standard editor kits.
</blockquote>

<a name="commands">
<h4>Associating Actions with Menus and Buttons</h4>
</a> 
<blockquote> 
As mentioned previously, you can
call the <code>getActions</code> method on any
text component to get an array containing
all of the actions supported by it.
It's often convenient to load the array of actions
into a <code>Hashtable</code> so your program can retrieve
an action by name.
Here's the code from <code>TextComponentDemo</code>
that gets the actions from the text pane and loads
them into a <code>Hashtable</code>:
<blockquote>
<pre>
private void createActionTable(JTextComponent textComponent) {
    actions = new Hashtable();
    Action[] actionsArray = textComponent.getActions();
    for (int i = 0; i < actionsArray.length; i++) {
        Action a = actionsArray[i];
        actions.put(a.getValue(Action.NAME), a);
    }
}    
</pre>
</blockquote>
And here's a convenient method for retrieving an
action by its name from the hashtable:
<blockquote>
<pre>
private Action getActionByName(String name) {
    return (Action)(actions.get(name));
}
</pre>
</blockquote>
You can use both methods almost verbatim in your programs.
Just change <code>actions</code> to the name of your hashtable.
<p>
Now, let's look at how the <strong>Cut</strong> menu item is created and
associated to the action of removing text from the text component:
<blockquote>
<pre>
protected JMenu createEditMenu() {
    JMenu menu = new JMenu("Edit");
    ...
    menu.add(getActionByName(DefaultEditorKit.cutAction));
    ...
</pre>
</blockquote>
This code gets the action by name using the handy
method described previously
and adds the action to the menu.
That's all you need to do. The menu
and the action take care of everything else.
You'll note that the name of the action
comes from
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/DefaultEditorKit.html"><code>DefaultEditorKit</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/DefaultEditorKit.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a>.
This kit provides actions for basic text editing
and is the superclass for all the editor kits provided by Swing.
So its capabilities are available to all text components
unless overridden by a customization.
<p>
For performance and efficiency reasons,
text components share actions.
The <code>Action</code> object returned by
<code>getActionByName(DefaultEditorKit.cutAction)</code>
is shared by the (uneditable) <code>JTextArea</code>
at the bottom of the window.
This has two important ramifications:
<ul>
<li> Generally speaking, you shouldn't modify
     <code>Action</code> objects you get from editor kits.
     If you do, the changes affects
     all text components in your program.
<li> <code>Action</code> objects can operate
     on other text components in the program,
     perhaps more than you intended.
     In this example, even though its uneditable,
     the <code>JTextArea</code> shares
     actions with the <code>JTextPane</code>.
     If you don't want to share,
     consider instantiating the <code>Action</code> object yourself.
     <code>DefaultEditorKit</code> defines a number of
     useful <code>Action</code> subclasses.
</ul>

Setting up the <strong>Style</strong> menu
is similar. Here's the
code that creates the menu and puts the
<strong>Bold</strong> menu item in it:
<blockquote>
<pre>
protected JMenu createStyleMenu() {
    JMenu menu = new JMenu("Style");
 
    Action action = new StyledEditorKit.BoldAction();
    action.putValue(Action.NAME, "Bold");
    menu.add(action);
    ...
</pre>
</blockquote>
The <code>StyledEditorKit</code>
provides <code>Action</code> subclasses to implement
editing commands for styled text.
You'll note that
instead of getting the action from the editor kit,
this code creates an
instance of the <code>BoldAction</code> class.
Thus, this action is not shared with any other text component,
and changing its name won't affect any other text component.
<p>
In addition to associating an action with a GUI component,
you can also associate an action with a keystroke.
<a href="#keymaps">Associating Actions with Keystrokes</a>
shows you how.
<p>
See the
<a href="#apiforcommands">Text Editing Commands</a>
API table for related API.
</blockquote>

<a name="keymaps">
<h4>Concepts: About Keymaps</h4>
</a> 
<blockquote> 
This section assumes that you understand actions
and how to get them from the editor kit.
If you don't, read
<a href="#editorkits">Concepts: About Editor Kits</a>
and
<a href="#commands">Associating Actions with Menus and Buttons</a>.
<p>
Every text component has one or more <em>keymaps</em>--
each of which is an instance of the
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Keymap.html"><code>Keymap</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Keymap.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> class.
A keymap contains a collection of name-value pairs
where the name is a <code>KeyStroke</code> and the
value is an <code>Action</code>.
Each pair <em>binds</em>
the keystroke to the action such that when the user
types the keystroke, the action occurs.
<p>
By default, a text component has one keymap named
<code>JTextComponent.DEFAULT_KEYMAP</code>.
This keymap contains standard, basic key bindings.
For example,
the arrow keys are mapped to caret movement, and so on.
You can enhance or modify the default keymap
in the following ways:
<ul>
<li> Add a custom keymap to the text component
     with <code>JTextComponent</code>'s <code>addKeymap</code> method.
<li> Add key bindings to the default keymap with
     <code>Keymap</code>'s <code>addActionForKeyStroke</code> method.
     The default keymap is shared among text components,
     so use this with caution.
<li> Remove key bindings from the default keymap with
     <code>Keymap</code>'s <code>removeKeyStrokeBinding</code> method.
     The default Keymap is shared among text components,
     so use this with caution.
</ul>
When resolving a keystroke to its action, the text component
checks the keymaps in the order they are added to the text component.
Thus, the binding for a specific keystroke in a keymap
that you add to a text component overrides any binding for
the same keystroke in the default keymap.
</blockquote>

<a name="bindingkeystrokes">
<h4>Associating Actions with Keystrokes</h4>
</a> 
<blockquote> 
The text pane in the <code>TextComponentDemo</code>
adds four key bindings to the default keymap.
<ul>
<li> <code>CTRL-B</code> for moving the caret backward one character
<li> <code>CTRL-F</code> for moving the caret forward one character
<li> <code>CTRL-P</code> for moving the caret up one line
<li> <code>CTRL-N</code> for moving the caret down one line
</ul>
The following code adds the <code>CTRL-B</code> key binding
to the default keymap.
The code for adding the other three is similar.
<blockquote>
<pre>
//Get the current, default map
Keymap keymap = textPane.addKeymap("MyEmacsBindings",
				   textPane.getKeymap());

//Ctrl-b to go backward one character
Action action = getActionByName(StyledEditorKit.backwardAction);
KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_B, Event.CTRL_MASK);
keymap.addActionForKeyStroke(key, action);
</pre>
</blockquote>
The code first adds a keymap to the components hierarchy.
The <code>addKeymap</code> methods creates the keymap for you
with the name and parent provided in the method call.
In the example, the parent is the text pane's default keymap.
Next, the code gets the backward action from the editor kit
and gets a
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/KeyStroke.html"><code>KeyStroke</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/KeyStroke.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> object representing the
<code>CTRL-B</code> key sequence.
Finally, the code adds the action and keystroke pair to the keymap,
thereby binding the key to the action.
<p>
For related API, see the
<a href="#keybindings">Binding KeyStrokes to Actions</a>
API table.
</blockquote>

<a name="undo">
<h4>Implementing Undo and Redo</h4>
</a> 
<blockquote> 
<blockquote>
<hr>
<strong>Note</strong>:
The implementation of undo and redo in <code>TextComponentDemo</code>
was copied directly from the NotePad demo that comes with Swing.
Many programmers will also be able to copy this implementation of
undo/redo without modification.
<hr>
</blockquote>
<p>
Implementing undo/redo has two parts:
<ul>
<li> <a href="#undoableedits">Remembering the undoable edits that occur</a>.
<li> <a href="#undoredoactions">Implementing the undo and redo commands</a>
     and providing a user interface for them.
</ul>

<p>
<a name="undoableedits">
<strong>Part 1: Remembering Undoable Edits</strong>
</a>
<br>
To support undo/redo, a text component must remember
each edit that occurs on it, the order edits occur
in relation to one another, and what it takes to undo it.
The example program uses an undo manager,
an instance of the
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/undo/UndoManager.html"><code>UndoManager</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/undo/UndoManager.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> class in Swing's <code>undo</code> package,
to manage its list of undoable edits.
The undo manager is created 
where the member variables are declared:
<blockquote>
<pre>
protected UndoManager undo = new UndoManager();
</pre>
</blockquote>
Now, let's look at how the program finds out about
undoable edits and adds them to the undo manager.
<p>
A document notifies interested listeners
whenever an undoable edit occurs on its content.
An important step in implementing
undo and redo is register an undoable edit listener on the
document of the text component.
This code adds an instance of <code>MyUndoableEditListener</code>
to the text pane's document:
<blockquote>
<pre>
lpd.addUndoableEditListener(new MyUndoableEditListener());
</pre>
</blockquote>
The undoable edit listener used in our example
adds the edit to the undo manager's list:
<blockquote>
<pre>
protected class MyUndoableEditListener implements UndoableEditListener {
    public void undoableEditHappened(UndoableEditEvent e) {
        //Remember the edit and update the menus
        undo.addEdit(e.getEdit());
        undoAction.update();
        redoAction.update();
    }
}  
</pre>
</blockquote>
Note that this method updates two objects: <code>undoAction</code>
and <code>redoAction</code>.
These are the action objects attached to the <strong>Undo</strong>
and <strong>Redo</strong> menu items, respectively.
The next step shows you how the menu items are created
and the implementation of the two actions.
<p>
For general information about undoable edit listeners
and undoable edit events,
see
<a href="..\events\undoableeditlistener.html">
How to Write an Undoable Edit Listener</a>.
<p>

<a name="undoredoactions">
<strong>Part 2: Implementing the Undo/Redo Commands</strong>
</a>
<br>
The first step in this part of implementing undo and redo is
to create the actions to put in the <strong>Edit</strong> menu.
<blockquote>
<pre>
JMenu menu = new JMenu("Edit");

//Undo and redo are actions of our own creation
undoAction = new UndoAction();
menu.add(undoAction);

redoAction = new RedoAction();
menu.add(redoAction);
...
</pre>
</blockquote>
The undo and redo actions are implemented by
custom <code>AbstractAction</code> subclasses:
<code>UndoAction</code> and <code>RedoAction</code>
respectively. These classes are inner classes of
the example's primary class.
<p>
When the user invokes the <strong>Undo</strong> command,
<code>UndoAction</code>'s <code>actionPerformed</code> method,
shown here, gets called:
<blockquote>
<pre>
public void actionPerformed(ActionEvent e) {
    try {
        undo.undo();
    } catch (CannotUndoException ex) {
        System.out.println("Unable to undo: " + ex);
        ex.printStackTrace();
    }
    update();
    redoAction.update();
}
</pre>
</blockquote>
This method calls the undo manager's <code>undo</code>
method and updates the menu items to reflect the new undo/redo state.
<p>
Similarly, when the user invokes the <strong>Redo</strong> command,
the <code>actionPerformed</code> method in <code>RedoAction</code>
gets called:
<blockquote>
<pre>
public void actionPerformed(ActionEvent e) {
    try {
        undo.redo();
    } catch (CannotRedoException ex) {
        System.out.println("Unable to redo: " + ex);
        ex.printStackTrace();
    }
    update();
    undoAction.update();
}
</pre>
</blockquote>
This method is similar except that it calls
the undo manager's <code>redo</code> method.
<p>
Much of the code in the <code>UndoAction</code>
and <code>RedoAction</code> classes is dedicated to
enabling and disabling the actions as appropriate for
the current state, and changing the names of the menu
items to reflect the edit to be undone or redone.
<p>
[PENDING: Can more be said here? Should talk more about
what's in the undo package and about sharing undo managers
between objects (or not).]
</blockquote>

<a name="caret">
<h4>Listening for Caret and Selection Changes</h4>
</a> 
<blockquote> 
The <code>TextComponentDemo</code> program uses
a caret listener to display
the current position of the caret or,
if text is selected,
the extent of the selection.
<p>
The caret listener in this example is also a label.
Here's the code that creates the caret listener label,
adds it to the window,
and makes it a caret listener of the text pane:
<blockquote>
<pre>
//Create the status area
JPanel statusPane = new JPanel(new GridLayout(1, 1));
CaretListenerLabel caretListenerLabel = new CaretListenerLabel(
						"Caret Status");
statusPane.add(caretListenerLabel);
...
textPane.addCaretListener(caretListenerLabel);
</pre>
</blockquote>
A caret listener must implement one method, <code>caretUpdate</code>,
which is called each time the caret moves or the selection changes.
Here's the <code>CaretListenerLabel</code>
implementation of <code>caretUpdate</code>:
<blockquote>
<pre>
public void caretUpdate(CaretEvent e) {
    //Get the location in the text
    int dot = e.getDot();
    int mark = e.getMark();
    if (dot == mark) {  // no selection
        try {
            Rectangle caretCoords = textPane.modelToView(dot);
            //Convert it to view coordinates
            setText("caret: text position: " + dot +
                    ", view location = [" +
                    caretCoords.x + ", " + caretCoords.y + "]" +
                    newline);
        } catch (BadLocationException ble) {
            setText("caret: text position: " + dot + newline);
        }
     } else if (dot < mark) {
        setText("selection from: " + dot + " to " + mark + newline);
     } else {
        setText("selection from: " + mark + " to " + dot + newline);
     }
}

</pre>
</blockquote>
As you can see, this listener updates its text label
to reflect the current state of the caret or selection.
The listener gets the information displayed from the
caret event object.
For general information about caret listeners
and caret events,
see
<a href="..\events\caretlistener.html">
How to Write a Caret Listener</a>.
<p>
As with document listeners, a caret listener is passive.
It reacts to changes in the caret or in the selection but
does not change the caret or the selection.
Instead of modifying the caret or selection from a caret
listener, you should use a custom caret.
To create a custom caret,
write a class that implements the
<a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Caret.html"><code>Caret</code></a><a target="_top" href="http://java.sun.com/products/jfc/swingdoc-api/javax/swing/text/Caret.html"><img src="http://docs.rinet.ru/Jtuta/images/apiIcon.gif" width=20 height=20 border=0 alt="(in the API reference documentation)"></a> interface,
then provide an instance of your class as an argument
to <code>setCaret</code> on a text component.

<p>
For related API, see the
<a href="#selection">JTextComponent Methods for Manipulating the Current Selection</a>
and
<a href="#carrots">Manipulating Carets and Selection Highlighters</a>
API tables.
</blockquote>

</blockquote>
<p>
<hr size=4>
<p> 
<table width="100%">
<tr>
<td align=left>
<a href="simpletext.html"><img src="http://docs.rinet.ru/Jtuta/images/PreviousArrow.gif" width=26 height=26 align=top border=0 alt="Previous | "></a><a
href="textfield.html"><img src="http://docs.rinet.ru/Jtuta/images/NextArrow.gif" width=26 height=26 align=top border=0 alt="Next | "></a><a
href="..\..\trailmap.html"><img src="http://docs.rinet.ru/Jtuta/images/WayUpArrow.gif" width=26 height=26 align=top border=0 alt="Trail Map | "></a><a
href="..\index.html"><img src="http://docs.rinet.ru/Jtuta/images/uiHeader.gif" width=26 height=26 align=top border=0 alt="Creating a GUI with JFC/Swing | "></a>
</td>
<td align=right>
<a href="index.html"><strong><em>Using Swing Components</em></strong></a>
</td>
</tr>
</table>
</body>
</html>
