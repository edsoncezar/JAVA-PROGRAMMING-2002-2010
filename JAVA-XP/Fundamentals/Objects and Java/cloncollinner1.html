<HTML>
<HEAD>
<TITLE>Cloning, Collections, and Inner Classes: Chapter 8 of Objects and Java</TITLE>
<META name="description" content="How to clone objects, put objects into collections, and create nested top level classes, member inner classes, local inner classes, and anonymous inner classes.">
<META name="keywords" content="Java Programming, Java Book, Java Tutorial">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#663300">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\..\images\ab.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/2c4bb4a4?REGION=Brown&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjDesWkshp" ><img src="..\..\cgi-bin\getimage.cgi\2c4bb4a4\region=brown&campaign=default&account=artima&banne" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#663300">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Objects and Java by Bill Venners</SPAN><BR>
<SPAN class="sts">Chapter 8:</SPAN><BR>
<SPAN class="ts">Cloning, Collections, and Inner Classes</SPAN><BR>
</DIV>

<!--BEGIN_OAJBOOK_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="http://www.artima.com/objectsandjava/index.html">Objects and Java</A>&nbsp;|
<A href="index.html">Contents</A>&nbsp;|
<A href="polymorphisminterfaces1.html">Previous</A>&nbsp;|
<A href="exceptions1.html">Next</A>&nbsp;
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_OAJBOOK_LINKS-->

<P>Although the previous chapter covered object initialization in great detail, it didn’t quite cover all
ways to initialize objects in Java, because it didn’t cover all ways to <EM>create</em> objects in Java.
Aside from the <CODE>new</CODE> operator, which was the focus of the last chapter, Java offers two
other ways to create objects: <CODE>clone()</CODE>, which is described in this chapter, and
<CODE>newInstance()</CODE>, which is described in Part IV.

<P>The <CODE>newInstance()</CODE> method, a member of class <CODE>Class</CODE>, is
most often used in the context of class loaders and dynamic program extension. The
<CODE>clone()</CODE> method, a member of class <CODE>Object</CODE>, is Java’s
mechanism for making copies of objects.

<H2>The <CODE>clone()</CODE> Method</H2>

<P>In Java, the way to make an identical copy of an object is to invoke <CODE>clone()</CODE> on
that object. When you invoke <CODE>clone()</CODE>, it should either:

<OL>
<LI>return an <CODE>Object</CODE> reference to a copy of the object upon which it is invoked, or
<LI>throw <CODE>CloneNotSupportedException</CODE>
</OL>

<P>Because <CODE>clone()</CODE> is declared in class <CODE>Object</CODE>, it is inherited
by every Java object. Object’s implementation of <CODE>clone()</CODE> does one of two things,
depending upon whether or not the object implements the <CODE>Cloneable</CODE> interface. If
the object doesn’t implement the <CODE>Cloneable</CODE> interface, <CODE>Object</CODE>’s
implementation of <CODE>clone()</CODE> throws a
<CODE>CloneNotSupportedException</CODE>. Otherwise, it creates a new instance of the
object, with all the fields initialized to values identical to the object being cloned, and returns a reference
to the new object.

<P>The <CODE>Cloneable</CODE> interface doesn’t have any members. It is an empty interface,
used only to indicate cloning is supported by a class. Class <CODE>Object</CODE> doesn’t implement
<CODE>Cloneable</CODE>. To enable cloning on a class of objects, the class of the object itself, or
one of its superclasses other than <CODE>Object</CODE>, must implement the
<CODE>Cloneable</CODE> interface.

<P>In class <CODE>Object</CODE>, the <CODE>clone()</CODE> method is declared protected.
If all you do is implement <CODE>Cloneable</CODE>, only subclasses and members of the same
package will be able to invoke <CODE>clone()</CODE> on the object. To enable any class in any
package to access the <CODE>clone()</CODE> method, you’ll have to override it and declare it
public, as is done below. (When you override a method, you can make it less private, but not more private.
Here, the protected <CODE>clone()</CODE> method in <CODE>Object</CODE> is being
overridden as a public method.)

<PRE>
// In Source Packet in file clone/ex1/CoffeeCup.java
class CoffeeCup implements Cloneable {

    private int innerCoffee;

    public Object clone() {
        try {
            return super.clone();
        }
        catch (CloneNotSupportedException e) {
            // This should never happen
            throw new InternalError(e.toString());
        }
    }

    public void add(int amount) {
        innerCoffee += amount;
    }

    public int releaseOneSip(int sipSize) {
        int sip = sipSize;
        if (innerCoffee < sipSize) {
            sip = innerCoffee;
        }
        innerCoffee -= sip;
        return sip;
    }

    public int spillEntireContents() {
        int all = innerCoffee;
        innerCoffee = 0;
        return all;
    }
}
</pre>

<P>You could make a copy of this <CODE>CoffeeCup</CODE> class, which implements
<CODE>Cloneable</CODE>, as follows:

<PRE>
// In Source Packet in file clone/ex1/Example1.java
class Example1 {
    public static void main(String[] args) {

        CoffeeCup original = new CoffeeCup();
        original.add(75); // Original now contains 75 ml of coffee
        CoffeeCup copy = (CoffeeCup) original.clone();
        copy.releaseOneSip(25); // Copy now contains 50 ml of coffee

        // Figure 15-1 shows the heap at this point in the program

        int origAmount = original.spillEntireContents();
        int copyAmount = copy.spillEntireContents();
        System.out.println("Original has " + origAmount
            + " ml of coffee.");
        System.out.println("Copy has " + copyAmount
            + " ml of coffee.");
    }
}
</pre>

<P>In this example, a new <CODE>CoffeeCup</CODE> object is instantiated and given an initial 75
ml of coffee. The <CODE>clone()</CODE> method is then invoked on the
<CODE>CoffeeCup</CODE> object. Because class <CODE>CoffeeCup</CODE> declares a
<CODE>clone()</CODE> method, that method is executed when <CODE>clone()</CODE> is
invoked on the <CODE>CoffeeCup</CODE> object referred to by the <CODE>original</CODE>
reference. <CODE>CoffeeCup</CODE>’s <CODE>clone()</CODE> does just one thing: invoke the
<CODE>clone()</CODE> method in <CODE>CoffeeCup</CODE>’s superclass,
<CODE>Object</CODE>. The first thing <CODE>Object</CODE>’s <CODE>clone()</CODE>
does is check to see whether the object’s class implements the <CODE>Cloneable</CODE> interface.
This test passes because <CODE>CoffeeCup</CODE>, the object’s class, does indeed implement
<CODE>Cloneable</CODE>. The <CODE>clone()</CODE> method then creates a new instance
of <CODE>CoffeeCup</CODE>, and initializes its one field, <CODE>innerCoffee</CODE>, to
75--the same value it has in the <CODE>CoffeeCup</CODE> object being cloned.
<CODE>Object</CODE>’s <CODE>clone()</CODE>returns a reference to the new object, which is
then returned by <CODE>CoffeeCup</CODE>’s <CODE>clone()</CODE>.

<P>The reference returned by <CODE>clone()</CODE> refers to a <CODE>CoffeeCup</CODE>
object, but the reference itself is of type <CODE>Object</CODE>. The code above downcasts the
returned reference from <CODE>Object</CODE> to <CODE>CoffeeCup</CODE> before assigning
it to local variable <CODE>copy</CODE>. At this point, both <CODE>CoffeeCup</CODE> objects--
<CODE>original</CODE> and <CODE>copy</CODE>--contain 75 ml of coffee. Finally, 25 ml is
removed from the copy, so it ends up with only 50 ml of coffee. A graphical representation of the result
inside the Java Virtual Machine of executing the first four statements in <CODE>main()</CODE> is
shown in Figure 15-1. (As mentioned in the last chapter, the native pointer to class information shown
here is just one potential way a Java Virtual Machine could connect instance data to its class information.)

<P><IMG src="images\clonefig1.gif"><BR>
Figure 15-1. Cloning a <CODE>CoffeeCup</CODE>.

<P><CODE>CoffeeCup</CODE>’s <CODE>clone()</CODE> implementation surrounds the call to
<CODE>Object</CODE>’s clone implementation with a try block so it can catch
<CODE>CloneNotSupportedException</CODE>. This exception should never actually be thrown
by <CODE>Object</CODE>’s <CODE>clone()</CODE>, because in this case,
<CODE>CoffeeCup</CODE> correctly implements <CODE>Cloneable</CODE>. If
<CODE>CoffeeCup</CODE>’s <CODE>clone()</CODE> didn’t explicitly catch it, however, then
<CODE>clone()</CODE> would have to declare in a <CODE>throws</CODE> clause that it may
throw <CODE>CloneNotSupportedException</CODE>. This would force any method invoking
<CODE>clone()</CODE> on a <CODE>CoffeeCup</CODE> object to deal with the exception,
either by explicitly catching it or declaring it in their own <CODE>throws</CODE> clause. Thus,
<CODE>CoffeeCup</CODE>’s <CODE>clone()</CODE> catches
<CODE>CloneNotSupportedException</CODE> to make it simpler for other methods to invoke
<CODE>clone()</CODE> on a <CODE>CoffeeCup</CODE>.

<H2>Cloning Objects that Contain Other Objects</H2>

<P>If you wish to enable cloning of an object that includes object references as part of its instance data,
you may have to do more work in <CODE>clone()</CODE> than just calling
<CODE>super.clone()</CODE>. Clone should return an independent copy of the object.
<CODE>Object</CODE>’s <CODE>clone()</CODE> will copy the value of each instance variable
from the original object into the corresponding instance variables of the copy object. If one of those
variables is an object reference, the copy object will get a duplicate reference to the same object.

<P>As an example, consider this version of <CODE>CoffeeCup</CODE>, in which the
<CODE>innerCoffee</CODE> field has been upgraded from a mere <CODE>int</CODE> to a full
fledged object reference:

<PRE>
// In Source Packet in file clone/ex2/CoffeeCup.java
class CoffeeCup implements Cloneable {

    private Coffee innerCoffee = new Coffee(0);

    public Object clone() {
        try {
            return super.clone();
        }
        catch (CloneNotSupportedException e) {
            // This should never happen
            throw new InternalError(e.toString());
        }
    }

    public void add(int amount) {
        innerCoffee.add(amount);
    }

    public int releaseOneSip(int sipSize) {
        return innerCoffee.remove(sipSize);
    }

    public int spillEntireContents() {
        return innerCoffee.removeAll();
    }
}

// In Source Packet in file clone/ex2/Coffee.java
public class Coffee implements Cloneable {

    private int volume; // Volume in milliliters

    Coffee(int volume) {
        this.volume = volume;
    }

    public Object clone() {
        try {
            return super.clone();
        }
        catch (CloneNotSupportedException e) {
            // This should never happen
            throw new InternalError(e.toString());
        }
    }

    public void add(int amount) {
        volume += amount;
    }

    public int remove(int amount) {
        int v = amount;
        if (volume < amount) {
            v = volume;
        }
        volume -= v;
        return v;
    }

    public int removeAll() {
        int all = volume;
        volume = 0;
        return all;
    }
}
</pre>

<P>Given these declarations of <CODE>CoffeeCup</CODE> and <CODE>Coffee</CODE>, there
would be a surprise waiting for any method that attempts to clone a <CODE>CoffeeCup</CODE>
object:

<PRE>
// In Source Packet in file clone/ex2/Example2.java
class Example2 {
    public static void main(String[] args) {

        CoffeeCup original = new CoffeeCup();
        original.add(75); // Original now contains 75 ml of coffee
        CoffeeCup copy = (CoffeeCup) original.clone();
        copy.releaseOneSip(25);
        // Copy now contains 50 ml of coffee.
        // Unfortunately, so does original.

        // Figure 15-2 shows the heap at this point in the program

        int origAmount = original.spillEntireContents();
        int copyAmount = copy.spillEntireContents();
        System.out.println("Original has " + origAmount
            + " ml of coffee.");
        System.out.println("Copy has " + copyAmount
            + " ml of coffee.");
    }
}
</pre>

<P>Here, when <CODE>releaseOneSip()</CODE> is invoked on <CODE>copy</CODE> with a
parameter of 25 ml, that amount of coffee is correctly removed from the <CODE>CoffeeCup</CODE>
object referenced by <CODE>copy</CODE>. The trouble is that 25 ml of coffee is also removed from the
cup referenced by <CODE>original</CODE>. The reason is that both the original and copy objects
contain a reference to the same <CODE>Coffee</CODE> object. A graphical representation of the
result of these statements is shown in Figure 15-2.

<P><IMG src="images\clonefig2.gif"><BR>
Figure 15-2. Incorrect cloning of a <CODE>CoffeeCup</CODE> that contains object references.

<P>	To rectify this situation, you need to modify <CODE>CoffeeCup</CODE>’s
<CODE>clone()</CODE> method:

<PRE>
// In Source Packet in file clone/ex3/CoffeeCup.java
class CoffeeCup implements Cloneable {

    private Coffee innerCoffee = new Coffee(0);

    public Object clone() {
        CoffeeCup copyCup = null;
        try {
            copyCup = (CoffeeCup) super.clone();
        }
        catch (CloneNotSupportedException e) {
            // this should never happen
            throw new InternalError(e.toString());
        }
        copyCup.innerCoffee = (Coffee) innerCoffee.clone();
        return copyCup;
    }

    public void add(int amount) {
        innerCoffee.add(amount);
    }

    public int releaseOneSip(int sipSize) {
        return innerCoffee.remove(sipSize);
    }

    public int spillEntireContents() {
        return innerCoffee.removeAll();
    }
}
</pre>

<P>In this version of <CODE>clone()</CODE>, <CODE>Object</CODE>’s
<CODE>clone()</CODE> is invoked as before. But instead of simply returning the reference to the
new <CODE>CoffeeCup</CODE> object created by <CODE>Object</CODE>’s
<CODE>clone()</CODE>, the new <CODE>CoffeeCup</CODE> object is modified before it is
returned. First, the <CODE>Coffee</CODE> object referenced by <CODE>innerCoffee</CODE> is
cloned. A reference to the cloned <CODE>Coffee</CODE> object is then stored in the
<CODE>innerCoffee</CODE> variable of the cloned <CODE>CoffeeCup</CODE> object . At this
point, the original object and the clone refer to their own <CODE>Coffee</CODE> objects, but those
<CODE>Coffee</CODE> objects are exact duplicates of each other.

<P>If you now performed the same statements on this version of <CODE>CoffeeCup</CODE>, you
would once again have the expected behavior:

<PRE>
// In Source Packet in file clone/ex3/Example3.java
class Example3 {
    public static void main(String[] args) {

        CoffeeCup original = new CoffeeCup();
        original.add(75); // original now contains 75 ml of coffee
        CoffeeCup copy = (CoffeeCup) original.clone();
        copy.releaseOneSip(25);
        // Copy now contains 50 ml of coffee.
        // Original still has 75 ml of coffee.

        // Figure 15-3 shows the heap at this point in the program

        int origAmount = original.spillEntireContents();
        int copyAmount = copy.spillEntireContents();
        System.out.println("Original has " + origAmount
            + " ml of coffee.");
        System.out.println("Copy has " + copyAmount
            + " ml of coffee.");
    }
}
</pre>

<P>Because the <CODE>CoffeeCup</CODE> objects referenced by <CODE>original</CODE>
and <CODE>copy</CODE> each have their own <CODE>Coffee</CODE> objects, when
<CODE>copy</CODE>’s was reduced by 25 ml, <CODE>original</CODE>’s wasn’t affected. A
graphical representation of the result of these statements is shown in Figure 15-3.

<P><IMG src="images\clonefig3.gif"><BR>
Figure 15-3. Proper cloning of a <CODE>CoffeeCup</CODE> that contains object references.

<P>These examples demonstrate the customary approach to writing <CODE>clone()</CODE>. The
first thing to do in any <CODE>clone()</CODE> method (besides <CODE>Object</CODE>’s) is
invoke <CODE>super.clone()</CODE>. This will cause <CODE>Object</CODE>’s
implementation of <CODE>clone()</CODE> to be executed first. This scheme is similar to that of
constructors, in which an invocation of the superclass’s constructor is always executed first.
<CODE>Object</CODE>’s <CODE>clone()</CODE> will create a new instance of the class and
copy the values contained in the original’s instance data to the new object’s instance data. Catching
<CODE>CloneNotSupportedException</CODE> is also a good idea, to make calling
<CODE>clone()</CODE> on that class of objects simpler to code.

<P>When <CODE>super.clone()</CODE> returns, a <CODE>clone()</CODE> method should
make clones of any mutable objects referenced by its instance variables, and assign these clones to the
instance variables of the copy. A <EM>mutable</em> object is one whose state can change over the
course of its lifetime. An object whose state can’t change is <EM>immutable</em>.

<P>An example of an immutable object is <CODE>String</CODE>. You must give a value to a
<CODE>String</CODE> when you create it. Once created, a <CODE>String</CODE>’s value can’t
change over the lifetime of the <CODE>String</CODE> object. The same is true for the wrapper
objects <CODE>Integer</CODE>, <CODE>Float</CODE>, and so on. You assign them a value
when they are created, and there is no way to change it for the remainder of their lifetimes.

<P>The real trouble with the <CODE>clone()</CODE> method shown above that didn’t clone
<CODE>Coffee</CODE> was that <CODE>Coffee</CODE> is mutable. When the state of the
<CODE>Coffee</CODE> object changed (<CODE>volume</CODE> changed from 75 to 50), both
<CODE>CoffeeCup</CODE> objects saw their own internal state change. Had
<CODE>CoffeeCup</CODE> included an instance variable of type <CODE>String</CODE>, you
wouldn’t have had to clone it because <CODE>String</CODE>s are immutable. (In fact, you couldn’t
have cloned it, because <CODE>String</CODE> doesn’t implement <CODE>Cloneable</CODE>.
Since <CODE>String</CODE>s are immutable, it doesn’t make sense to clone them.)

<H2>Disallowing Cloning</H2>

<P>Java’s cloning mechanism enables you to allow cloning, allow cloning conditionally, or forbid cloning
altogether. If you wish to completely forbid cloning, you have a few different approaches to choose from.
To decide which way to forbid cloning upon a particular class of objects, you must know something about
the class’s superclasses.

<P>If none of the superclasses implement <CODE>Cloneable</CODE> or override
<CODE>Object</CODE>’s <CODE>clone()</CODE> method, you can prevent cloning of objects of
that class quite easily. Simply don’t implement the <CODE>Cloneable</CODE> interface and don’t
override the <CODE>clone()</CODE> method in that class. The class will inherit
<CODE>Object</CODE>’s <CODE>clone()</CODE> implementation, which will throw
<CODE>CloneNotSupportedException</CODE> anytime <CODE>clone()</CODE> is
invoked on objects of that class. All the classes shown as examples in this book prior to the
<CODE>CoffeeCup</CODE> class declared immediately above used this method of preventing
cloning. By doing nothing, they disallowed cloning. Thus, forbidding cloning is the default behavior for
an object.

<P>In cases where a superclass already implements <CODE>Cloneable</CODE>, and you don’t want
the subclass to be cloned, you’ll have to override <CODE>clone()</CODE> in the subclass and throw a
<CODE>CloneNotSupportedException</CODE> yourself. In this case, instances of the superclass
will be clonable, but instances of the subclass will not.

<H2>Clone and the Copy Constructor</H2>

<P>For those of you who know C++, Java’s <CODE>clone()</CODE> method is what happened to
C++’s copy constructor. For those of you who don’t know C++, a copy constructor is one which takes a
single parameter of the same type of the class. In the body of the copy constructor, you have to copy all
values from the object passed as a parameter to the object under construction. Like Java’s
<CODE>clone()</CODE> method, in a C++ copy constructor, you should allocate new memory for
objects referenced (or pointed to) from instance (member) variables. For example, a copy constructor for
class <CODE>CoffeeCup</CODE> would be:

<PRE>
// In Source Packet in file clone/ex4/CoffeeCup.java
// Copy constructors are not the Java way...
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup(CoffeeCup cup) {
        innerCoffee = cup.innerCoffee;
    }
    //...
}
</pre>

<P>One of the primary uses of the copy constructor in C++ is to pass objects by value. The copy
constructor is used to create a copy of an object that is passed by value to a function. This is not an issue in
Java, because all objects in Java programs are passed by reference.

<P>If you are a C++ programmer and feel the urge to write a copy constructor in a Java class, STOP!
Close your eyes. Take a few deep breaths. Then--when you feel your ready--open your eyes, implement
<CODE>Cloneable</CODE> and write <CODE>clone()</CODE>. It will be OK.

<!--
<H2>Exercises</H2>
<H2>The Resources Page</H2>
For links to more information about the topics covered in this chapter, visit the resources page at
http://www.artima.com/innerjava/resources.html.
-->


</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/objectsandjava/webuscript/ClonCollInner1.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
