<HTML>
<HEAD>
<TITLE>Expressions and Statements: Chapter 3 of Objects and Java</TITLE>
<META name="description" content="The ins and outs of expressions and statements in Java.">
<META name="keywords" content="Java Design, Java Book">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#663300">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\..\images\ab.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/4783c2be?REGION=Brown&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjDesWkshp" ><img src="..\..\cgi-bin\getimage.cgi\4783c2be\region=brown&campaign=default&account=artima&banne" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#663300">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Objects and Java by Bill Venners</SPAN><BR>
<SPAN class="sts">Chapter 3:</SPAN><BR>
<SPAN class="ts">Expressions and Statements</SPAN><BR>
</DIV>
<!--BEGIN_OAJBOOK_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="http://www.artima.com/objectsandjava/index.html">Objects and Java</A>&nbsp;|
<A href="index.html">Contents</A>&nbsp;|
<A href="classesobjects1.html">Previous</A>&nbsp;|
<A href="initcleanup1.html">Next</A>&nbsp;
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_OAJBOOK_LINKS-->

<P>
Another difference between the source files of C++ and the source files of
Java is that Java source is written in Unicode, a 16-bit international
character set standard. If you create an ASCII source file, the Java
compiler will treat the ASCII characters as if they were the equivalent
Unicode characters. This will be discussed at greater length in Chapter 3.

<P>This
chapter will reveal to you the details of expressions and statements in the Java language. It discusses
operators, expressions, literals, local variables, control-flow, and gives some general guidelines on various
aspects of method implementation.
<H2>Expressions</H2>
<P>Expressions perform operations on data and move data around. Some expressions will be evaluated
for their results, some for their side effects, some for both. An expression can have three kinds of result:
<OL>
<LI>a value, such as the result of: <CODE>(4 * i)</CODE>
<LI>a variable, such as the result of: <CODE>i = 4</CODE>
<LI>nothing (in the case of an invocation of a method declared as <CODE>void</CODE>)
</OL>
An expression that results in a variable is called an <EM>lvalue</em> in C++ and many other languages.
A variable expression in Java is the same thing, the Java Language Specification just uses the name
<EM>variable</em> instead of lvalue. Such an expression can be used on the left hand side of an
assignment operator. <EM>Side effects </em>come about when an expression includes an assignment,
increment, decrement, or method invocation.
<H3>Literals</H3>
<P>Each type in the Java programming language has <EM>literals</em>, the way to specify
unnamed constant values for the type. For example, the boolean type has two literals,
<CODE>true</CODE> and <CODE>false</CODE>. Object reference types have only one literal,
<CODE>null</CODE>.
<P>Integer literals come in three forms: decimal, hexadecimal, and octal. The way an integer literal
begins indicates the base of the number. If the number begins with a <CODE>0x</CODE> or
<CODE>0X</CODE>, it is hexadecimal (base 16). Some examples are: <CODE>0x5</CODE>,
<CODE>0X00FF</CODE>, and <CODE>0xcafebabe</CODE>. If the number begins with only a
zero, it is an octal (base 8). Some examples are: <CODE>035</CODE>, <CODE>0777</CODE>,
<CODE>0321</CODE>. If the number begins with a non-zero digit, it is decimal:
<CODE>31</CODE>, <CODE>255</CODE>, <CODE>20</CODE>. If an integer literal ends in an
<CODE>L</CODE> or <CODE>l</CODE>, it is a <CODE>long</CODE>, otherwise it is an
<CODE>int</CODE>. Some examples of long integer literals are: <CODE>0XCAFEBABEL</CODE>,
<CODE>035L</CODE>, <CODE>31L</CODE>. If an <CODE>int</CODE> literal is assigned to a
variable of type <CODE>short</CODE> or <CODE>byte</CODE>, the literal is treated as if it were a
<CODE>short</CODE> or <CODE>byte</CODE> type so long as the literal value is within the valid
range for that type.

<P>Floating point literals are made up of decimal digits, optionally containing a decimal point, and
optionally followed by an <CODE>E</CODE> or <CODE>e</CODE> and an exponent. Some examples
of floating point literals are: <CODE>3.14159</CODE>, <CODE>.314159e1</CODE>,
<CODE>34.26E23</CODE>. If a floating point literal ends in a <CODE>F</CODE> or
<CODE>f</CODE>, it is a <CODE>float</CODE>, otherwise it is a <CODE>double</CODE>.
Optionally, a <CODE>double</CODE> floating point literal can end in <CODE>D</CODE> or
<CODE>d</CODE>. Some examples of float literals are: <CODE>3.14159F</CODE> and
<CODE>3e5f</CODE>. The same values expressed as doubles could look like this:
<CODE>3.14159</CODE> and <CODE>3e5D</CODE>.

<P>Character literals can be any Unicode character between single quotes, such as
<CODE>'A'</CODE>. In addition to providing an explicit character between the single quotes, you can
provide an octal or hex number preceded by a backslash. The octal number must be between
<CODE>'\0'</CODE> and <CODE>'\377'</CODE>. The hex number must have four digits. It is
preceded with either a <CODE>\u</CODE> or <CODE>\uu</CODE>, as in:
<CODE>'\u0073'</CODE> and <CODE>'\uu039d'</CODE>. There are also several character
literals represented by special escape sequences, shown in Table 3-1.

<P>Table 3-1. Special Character Literal Escape Sequences<BR>
<TABLE>
<TR><TD>Literal</TD><TD>Meaning</TD></TR>
<TR><TD><CODE>\n</CODE></TD><TD>line feed (<CODE>\u000A</CODE>)</TD></TR>
<TR><TD><CODE>\b</CODE></TD><TD>backspace (<CODE>\u0008</CODE>)</TD></TR>

<TR><TD><CODE>\t</CODE></TD><TD>tab (<CODE>\u0009</CODE>)</TD></TR>

<TR><TD><CODE>\f</CODE></TD><TD>form feed (<CODE>\u000C</CODE>)</TD></TR>

<TR><TD><CODE>\r</CODE></TD><TD>carriage return (<CODE>\u000D</CODE>)</TD></TR>

<TR><TD><CODE>\"</CODE></TD><TD>double quote (<CODE>\u0022</CODE>)</TD></TR>

<TR><TD><CODE>\'</CODE></TD><TD>single quote (<CODE>\u0027</CODE>)</TD></TR>

<TR><TD><coce>\\</CODE></TD><TD>backslash (<CODE>\005C</CODE>)</TD></TR>

</TABLE>

<P>The hex version of the character literal can have either one or two <CODE>u</CODE>'s to facilitate
conversion of Unicode source files to ASCII and back again. All Java source files are Unicode by
definition. When you create an Java source file in ASCII, it is treated as the first 128 Unicode characters.
(The first 128 Unicode characters, <CODE>\u0000</CODE> to <CODE>\u007f</CODE>, map to the
7-bit ASCII character set. The second 128 Unicode characters, <CODE>\u0080</CODE> to
<CODE>\u00ff</CODE>, map to the ISO-Latin-1 character set.) If you include in a Unicode source file
the Greek character <CODE>'q'</CODE> (lower case theta), it will be converted into the string
<CODE>'\u03b8'</CODE> in the ASCII file. When the ASCII file is converted back to Unicode, the
<CODE>'\u03b8'</CODE> will be changed back into a <CODE>'q'</CODE>. If, however, in your
Unicode file you included the character literal <CODE>'\u03b8'</CODE>, this would be converted
into <CODE>'\uu03b8'</CODE> in the ASCII file. If the extra <CODE>u</CODE> were not added,
when the ASCII file was translated back to Unicode you'd end up with a <CODE>'q'</CODE> where
you used to have a <CODE>'\u03b8'</CODE>. To avoid this problem,
<CODE>'\uu03b8'</CODE> is transformed into <CODE>'\u03b8'</CODE> when converting
from ASCII back to Unicode.

<P>The Unicode escape sequences are valid not only for character and string literals, they are valid
anywhere in a Java source file. For example, instead of typing this into your Unicode source file:

<PRE>
// (Not on the CD-ROM)
class Example1a {

    public static void main(String[] args) {
        int q = 25;
        System.out.println(q);
    }
}
</pre>
You could type this into a Unicode or an ASCII source file:
<PRE>
// In Source Packet in file expr/ex1/Example1b.java
class Example1b {

    public static void main(String[] args) {
        int \u03b8 = 25;
        System.out.println(\u03b8);
    }
}
</pre>
If you wanted to be extremely cryptic, you could even type:
<PRE>
// In Source Packet in file expr/ex1/Example1c.java
class Example1c {

    public static void main(String[] args) {
        \u0069\u006e\u0074\u0020\u03b8\u0020\u003d
            \u0020\u0032\u0035\u003b
        System.out.println(\u03b8);
    }
}
</pre>

The <CODE>main()</CODE> method of <CODE>Example1c</CODE> starts with the same
statement as the previous two examples, but with every character--including spaces and the semicolon--
replaced by the equivalent Unicode escape sequence. All three versions compile and do the same thing
when run: they declare an <CODE>int</CODE> named <CODE>q</CODE>, initialize it to 25, and
print out its value.

<P>String literals, which appear between double quotes, as in <CODE>"appear"</CODE>, are actually
references to instances of class <CODE>String</CODE>. Strings will be described in detail in Chapter 10.

<H3>Operators</H3>

<P>Java's binary arithmetic operators--addition: <CODE>+</CODE>, subtraction: <CODE>-</CODE>,
multiplication: <CODE>*</CODE>, division: <CODE>/</CODE>, and remainder: <CODE>%--
</CODE>operate on any numerical type. The <CODE>%</CODE> operator, which is called
<EM>modulo</em> in C++, is called <EM>remainder</em> in Java. It performs the same operation:
calculating the remainder of a division. You can also use the <CODE>+</CODE> operator to concatenate
strings. String concatenation will be described in Chapter 10.
[bv: may want to add more details of IEEE754 math]

<P>Java also has unary <CODE>+</CODE> and <CODE>-</CODE>, which allow you to indicate a
literal number is positive or negative, as in <CODE>-3</CODE> or <CODE>+4.0</CODE>. If you
don't specify a unary <CODE>+</CODE> or <CODE>-</CODE>, a literal number is interpreted as
positive. The unary - can also be used to negate a variable, as in: <CODE>negativeVal = -
val</CODE>.

<P>Java also has increment: <CODE>++</CODE>, and decrement: <CODE>--</CODE>, operators.
These operators can be placed before or after the variable expression they modify. If they are placed before
(a <EM>prefix</em> operator), they modify the variable expression before its value is used. If they are
placed after (a <EM>postfix</em> operator), they modify the variable expression after its value is used.

<P>Java's relational and equality operators are: greater than: <CODE>&lt;</CODE>, less than:
<CODE>&gt;</CODE>, greater than or equal to: <CODE>&gt;=</CODE>, less than or equal to:
<CODE>&lt;=</CODE>, equal to: <CODE>==</CODE>, and not equal to: <CODE>!=</CODE>. All
yield a boolean result. The unary <CODE>!</CODE> operator inverts boolean value.

<P>The conditional operators, conditional-AND: <CODE>&&</CODE>, and conditional-OR:
<CODE>||</CODE>, take boolean operands and yield a boolean result. Expressions built from these
operators only evaluate as far as needed to determine the result. For example, assume
<CODE>salt()</CODE>, <CODE>pepper()</CODE>, <CODE>toBe()</CODE>,
<CODE>and</CODE> <CODE>notToBe()</CODE> are methods that return a boolean. If
<CODE>salt()</CODE> evaluates to <CODE>false</CODE> in the expression:<CODE>(salt()
&& pepper())</CODE>, then <CODE>pepper()</CODE> is never evaluated. Likewise, if
<CODE>toBe()</CODE> evaluates to <CODE>true</CODE> in the expression:<CODE>(toBe()
|| notToBe())</CODE>, then <CODE>notToBe()</CODE> is never evaluated.  Conditional-
AND and conditional-OR are also called logical-AND and logical-OR.

<P>Java has several operators that perform operations on individual bits. The binary bitwise
operators are: bitwise AND: <CODE>&</CODE>, bitwise inclusive OR: <CODE>|</CODE>, and bitwise
exclusive OR (or bitwise XOR): <CODE>^</CODE>. The unary bitwise complement operator,
<CODE>~</CODE>, inverts each bit in its operand. There are also three shift operators: shift left:
<CODE>&lt;&lt;</CODE>, shift right: <CODE>&gt;&gt;</CODE>, and unsigned shift right:
<CODE>&gt;&gt;&gt;</CODE>. The shift operators shift the integer value on the left of the operator
by the amount specified by the integer value on the right. Shift left and unsigned shift right fill with
zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the left hand value as it shifts.

<P>The conditional operator, <CODE>? :</CODE>,  is a shorthand for an <CODE>if-then-
else</CODE> construction that does one of two different things depending upon the result of a boolean
expression. The expression:

<PRE>
variable = booleanExpr ? value1 : value2;
</pre>
has the same effect as:
<PRE>
if (booleanExpr) {
	variable = value1;
}
else {
	variable = value2;
}
</pre>
The conditional operator is also sometimes called the <EM>ternary operator</em> or the <EM>question-
colon operator</em>.

<P>In addition to the basic assignment operator, <CODE>=</CODE>, Java includes many shorthand
assignment operators that allow you to write expressions such as <CODE>j = j + 1</CODE> in
shorthand as <CODE>j += 1</CODE>. The main difference between these two approaches is that in
the shorthand version, the variable expression <CODE>j</CODE> is evaluated only once. In the
longhand version, the variable expression <CODE>j</CODE> is evaluated twice. This difference matters
in cases where the variable expression has a side effect, as in <CODE>someArray[i++]</CODE>. All
the shorthand assignment operators are listed in Table 3-2. [bv: must add in about one guy
needing to be assignable to the other and that being the type of the
expression.]

<H3>Operator Precedence and Associativity</H3>
<P>Operator precedence determines which parts of an expression are evaluated before the other parts. For
example, the expression
<PRE>
2 + 2 * 7
</pre>
evaluates to 16, not 28, because the * operator has a higher precedence than the + operator. Thus the 2 * 7
part of the expression is evaluated before the 2 + 2 part. If you wish, you can use parentheses in
expressions to clarify evaluation order or to override precedence. For example, if you really wanted the
result of the expression above to be 28, you could write the expression like this:
<PRE>
(2 + 2) * 7
</pre>

<P>Table 3-2 shows all Java's operators and their precedence. The postfix operators, shown at the top of
the table, have the highest precedence. The assignment operators, shown at the bottom, have the lowest
precedence.

<P>Table 3-2. Operator precedence
<TABLE>
<TR><TD>Operator Type</TD><TD>Operator</TD><TR>
<TR><TD>Postfix operators</TD><TD><CODE>[] . (</CODE><EM>params</em><CODE>) </CODE><EM>expr</em><CODE>++ </CODE><EM>expr</em><CODE>--</CODE></TD><TR>
<TR><TD>Unary operators</TD><TD><CODE>++<EM>expr</em></CODE> <CODE>--<EM>expr</em></CODE> <CODE>+<EM>expr</em></CODE> <CODE>-<EM>expr</em></CODE> <CODE>~</CODE> <CODE>!</CODE></TD><TR>
<TR><TD>Creation or cast</TD><TD><CODE>new (</CODE><EM>type</em><CODE>)</CODE><EM>expr</em></TD><TR>
<TR><TD>Multiplicative</TD><TD><CODE>* / %</CODE></TD><TR>
<TR><TD>Additive</TD><TD><CODE>+ -</CODE></TD><TR>
<TR><TD>Shift</TD><TD><CODE>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</CODE></TD><TR>
<TR><TD>Relational</TD><TD><CODE>&lt; &gt; &gt;= &lt;= instanceof</CODE></TD><TR>
<TR><TD>Equality</TD><TD><CODE>== !=</CODE></TD><TR>
<TR><TD>Bitwise AND</TD><TD><CODE>&</CODE></TD><TR>
<TR><TD>Bitwise exlusive OR</TD><TD><CODE>^</CODE></TD><TR>
<TR><TD>Bitwise inclusive OR</TD><TD><CODE>|</CODE></TD><TR>
<TR><TD>Conditional-AND</TD><TD><CODE>&&</CODE></TD><TR>
<TR><TD>Conditional-OR</TD><TD><CODE>||</CODE></TD><TR>
<TR><TD>Conditional</TD><TD><CODE>?:</CODE></TD><TR>
<TR><TD>Assignment</TD><TD><CODE>= += -= *= /= %= &gt;&gt;= &lt;&lt;= &gt;&gt;&gt;= &= ^= |=</CODE></TD><TR>
</TABLE>

<P>When multiple operators of the same precedence appear side by side in an expression, the
<EM>associativity</em> of the operators determines the order of evaluation. In Java, all binary operators
except the assignment operators are <EM>left-associative</em>. Assignment operators are <EM>right-
associative</em>. For example, <CODE>i + j - k</CODE> is evaluated as <CODE>(i + j) -
k</CODE>. <CODE>i = j = k</CODE> is evaluated as <CODE>i = (j = k)</CODE>.

<H3>Complex Expressions</H3>

<P>Operator precedence is part of the Java language. You needn't be afraid to use it. But on the other
hand, if you find yourself attempting to show off your knowledge of precedence, consider using
parentheses to clarify what operators are operating upon what expressions. When you do rely on
precedence, make sure you are as smart as you think you are. Many bugs arise from mistaken assumptions
about precedence. The best is approach is somewhere in the middle. If you use too many parentheses, or
not enough, the code can be difficult to understand. You should choose the form that you feel maximizes
your code's readability. Remember, it's not a contest to see who can write the most cryptic code, but who
can write the most lucid code.

<P>One approach to writing complex expressions is to separate them out into several stages, placing
intermediate values into variables with descriptive names. Using well-named variables to hold
intermediate values of long computation expressions can help others understand what is going on. As a
bonus, a programmer can check the value of intermediate results in a debugger by inspecting the
intermediate variables.

<H3>Order of Evaluation</H3>

<P>After taking into account precedence and parentheses, Java guarantees that expressions will be
evaluated left to right. For example, to evaluate <CODE>eat() + drink() -
beMerry()</CODE>, Java will first evaluate <CODE>eat()</CODE>, then
<CODE>drink(</CODE>), then perform the addition, then evaluate <CODE>beMerry()</CODE>,
and finally perform the subtraction. <CODE>eat()</CODE> is evaluated before
<CODE>drink()</CODE>, because <CODE>eat()</CODE> is to the left of
<CODE>drink()</CODE>, and expressions are evaluated left to right. This guarantee is important
because the invocations of <CODE>eat()</CODE> and <CODE>drink()</CODE> may have side
effects that would differ if they were invoked in the opposite order.

<P>In general, every operand to an operator is evaluated before the operator is evaluated. Three
exceptions are the conditional-AND: <CODE>&&</CODE>, the conditional-OR: <CODE>||</CODE>,
and the conditional operator: <CODE>?:</CODE>. The right hand side of conditional-AND and
conditional-OR expressions won't be evaluated if the left hand side determines the result. For example, if
the left hand side of a conditional-AND expression evaluates to <CODE>false</CODE>, the result of
the expression will definitely be <CODE>false</CODE>, so the right hand side is not evaluated.
Likewise, if the left hand side of an conditional-OR expression evaluates to <CODE>true</CODE>, the
result of the expression will definitely be <CODE>true</CODE>, so the right hand side is not evaluated.

<P>In the case of a conditional expression, the boolean-expression is evaluated first. Depending upon the
result of this evaluation, only one of the other expressions will be evaluated. For example, in the
expression <CODE>isHungry() ? eat() : beMerry()</CODE>,
<CODE>isHungry()</CODE> will be evaluated first. If it evaluates to <CODE>true</CODE>,
<CODE>eat()</CODE> will be evaluated and <CODE>beMerry()</CODE> will not. Otherwise,
<CODE>beMerry()</CODE> will be evaluated and <CODE>eat()</CODE> will not.

<H2>Statements</H2>

<P>A Java method body is a series of zero or more <EM>statements</em>. In the Java programming
language, statements are the fundamental unit of execution. All statements except blocks are terminated
by a semicolon. Blocks are denoted by open and close curly braces. Statements are executed for their
effects; they do not have values. There are many different kinds of statements in Java:
<UL>
<LI>blocks
<LI>local variable declaration statements
<LI>the empty statement
<LI>expression statements
<LI>the <CODE>if</CODE> and <CODE>if-else</CODE> statements
<LI>the <CODE>while</CODE> statement
<LI>the <CODE>do-while</CODE> statement
<LI>the <CODE>for</CODE> statement
<LI>the <CODE>break</CODE> statement
<LI>the <CODE>continue</CODE> statement
<LI>the <CODE>return</CODE> statement
<LI>the <CODE>switch</CODE> statement
<LI>the <CODE>throw</CODE> statement
<LI>the <CODE>try</CODE> statement
<LI>the <CODE>synchronized</CODE> statement
</UL>

<P>Most of these statement types will be described below. A few will be described in later chapters.[bv: am I missing anything that was added
in JDK 1.1 or 1.2?]

<H3>Blocks</H3>

<P>A block is a series of zero or more statements between a matching set of open and close curly braces.
The bodies of methods and <CODE>switch</CODE> statements are blocks.

The bodies of <CODE>if</CODE>,
<CODE>for</CODE>, <CODE>while</CODE>, and <CODE>do-while</CODE>
statements may also be blocks. Also, you can also simply create a new block
inside another block by enclosing code within curly braces. A block contained within another block is
itself a statement of the outer block. Blocks that contain no statements are called empty.

<H3>Local Variable Declaration Statements</H3>

<P>[bv: need to add final here.]
<P>Declaration statements establish a name, type, and possibly an initial value for a new local variable.
Local variables in Java can be declared anywhere in a method. A local variable need not be initialized
where it is declared, but it must be initialized before it is used. If it isn't, the source file won't compile.
For example, the following snippet of code won't compile:

<PRE>
// In Source Packet in file expr/ex2/Example2a.java
class Example2a {
    public static void main(String[] args) {
        // THIS WON'T COMPILE.
        int i;
        if (i < 100) {
            //...
        }
    }
}
</pre>
This code won't compile because <CODE>i</CODE> is used before it is initialized. To fix this problem,
you could initialize <CODE>i</CODE> when you declare it:
<PRE>
// In Source Packet in file expr/ex2/Example2b.java
class Example2b {
    public static void main(String[] args) {
        // This compiles fine.
        int i = 5;
        if (i < 100) {
            //...
        }
    }
}
</pre>
Alternatively, you could assign a value to <CODE>i</CODE> after you declare it, but before you use it:
<PRE>
// In Source Packet in file expr/ex2/Example2c.java
class Example2c {
    public static void main(String[] args) {
        // This compiles fine.
        int i;
        i = 5;
        if (i < 100) {
            //...
        }
    }
}
</pre>

<P>The "<CODE>i</CODE>" in "<CODE>int i</CODE>" and the "<CODE>i = 5</CODE>" in
"<CODE>int i = 5</CODE>" are called  <EM>declarators</em>. As in C++, you can place
multiple local variable declarators, separated by commas, into the same local variable declaration
statement, as in:
<PRE>
int i, j = 5, k;
</pre>

<P>The scope of a local variable extends from the point where the local variable is declared to the end of
the block in which it is declared. No other local variable of the same name can be declared within a local
variable's scope. For example, the following won't compile, because a second local variable
<CODE>i</CODE> is declared within the scope of a first local variable <CODE>i</CODE>:
<PRE>
// In Source Packet in file expr/ex2/Example2d.java
class Example2d {
    public static void main(String[] args) {
        // THIS WON'T COMPILE.
        int i = 4;
        if (i < 10) {
            int i = 3;  // Can't use name i again.
            //...
        }
    }
}
</pre>

<H3>The Empty Statement</H3>

<PRE>
	;
</pre>
<P>[note to editors: the above semicolon is intended to be the entire text of this section. If I were to
explain the semicolon in a sentence, it would be: "The empty statement, represented by a semicolon and
nothing else, does nothing." The lone semicolon above is an empty (English) statement about the empty
(Java) statement. All the programmers who reviewed this chapter "got it."]

<H3>Expression Statements</H3>

<P>Expression statements are valid Java expressions that are terminated by a semicolon. Unlike C and
C++, not all kinds of valid expressions can be expression statements. In Java, there are four kinds of
expression statements:
<UL>
<LI>assignment expressions, such as <CODE>a += 5</CODE>, <CODE>b *= 7</CODE>, or
<CODE>c = 3</CODE>
<LI>prefix and postfix increment and decrement, such as <CODE>++a</CODE>, <CODE>--b</CODE>,
<CODE>c++</CODE>, <CODE>d--</CODE>
<LI>method invocations, whether or not they return a value
<LI>object creation expressions, such as <CODE>new CoffeeCup</CODE>
</UL>
All expressions except invocations of methods that don't return a value (methods declared as
<CODE>void</CODE>) yield a value upon evaluation. When an expression is used as an expression
statement, the end value of the expression is discarded. Such expressions are evaluated simply for their
side effects, as in:
<PRE>
++i;
</pre>
The full details of expressions will be expressed later in this chapter.

<H3>The <CODE>if</CODE> and <CODE>if-else</CODE> Statements</H3>

<P>The simplest control flow construct in Java is the <CODE>if</CODE> statement, which can have an
optional <CODE>else</CODE> clause. Here is the format without the <CODE>else</CODE> clause:
<PRE>
if (<EM>boolean-expression</em>)
	<EM>statement</em>
</pre>
The <EM><CODE>statement</CODE></em> can be a simple statement terminated by a semicolon or
a block enclosed in curly braces. Alternatively, you can add an <CODE>else</CODE>:
<PRE>
if (<EM>boolean-expression</em>)
	<EM>statement1</em>
else
	<EM>statement2</em>
</pre>

<P>As in C++, an <CODE>else</CODE> in Java matches the closest <CODE>if</CODE>.

<P>Note that Java's <CODE>if</CODE> statement differs from that of C++ in that the expression
contained in the parentheses must be <CODE>boolean</CODE>. In Java, if <CODE>i</CODE> is an
<CODE>int</CODE>, then <CODE>if (i)</CODE> won't compile. You must say <CODE>if (i
!= 0)</CODE>. This is also true of the expressions in the <CODE>while</CODE>,
<CODE>do</CODE>, and <CODE>for</CODE> loops. This feature of Java enables the compiler to
catch accidental use of <CODE>=</CODE> instead of <CODE>==</CODE> inside an expression. For
example, if you accidentally type <CODE>i = 3</CODE> instead of <CODE>i == 3</CODE> in an
<CODE>if</CODE> expression, it won't compile:
<PRE>
// In Source Packet in file expr/ex2/Example2e.java
class Example2e {
    public static void main(String[] args) {
        int i = 4;
        // In Java, THIS WON'T COMPILE, because the resulting
        // value of the expression isn't boolean.
        if (i = 3) {
            //...
        }
    }
}
</pre>

<H3>The <CODE>while</CODE> and <CODE>do-while</CODE> Statements</H3>

<P>The while statement looks like this:

<PRE>
while (<EM>boolean-expression</em>)
	<EM>statement</em>
</pre>
Java's <CODE>while</CODE> loop behaves like C++'s <CODE>while</CODE> loop (the difference
between the two is that Java's expression must be boolean.) The <EM><CODE>boolean-
expression</CODE></em> is evaluated first. If the expression is <CODE>true</CODE>,
<EM><CODE>statement</CODE></em> is executed. This process is repeated until the expression
evaluates to <CODE>false</CODE> (or a <CODE>break</CODE>, <CODE>continue</CODE>,
or <CODE>return</CODE> is executed, or an exception is thrown).

<P>The <CODE>do-while</CODE> statement differs from the <CODE>while</CODE> in that the
<EM><CODE>statement</CODE></em> is always executed at least once. In a
<CODE>while</CODE> loop, if the <EM><CODE>boolean-expression</CODE></em>
evaluates to <CODE>false</CODE> the first time, <EM><CODE>statement</CODE></em> is
never executed. Here is what a <CODE>do-while</CODE> looks like:
<PRE>
do
	<EM>statement</em>
while (<EM>boolean-expression</em>);
</pre>

<H3>The <CODE>for</CODE> Statement</H3>

<P>The <CODE>for</CODE> loop is used to iterate through a sequence of values. It takes the same
form as in C++:
<PRE>
for (<EM>init-expr</em>; <EM>boolean-expr</em>; <EM>incr-expr</em>)
	<EM>statement</em>
</pre>

<P>The <EM><CODE>init-expr</CODE></em> is an initialization expression, such as <CODE>i
= 0</CODE>. You can optionally initialize multiple variables in <EM><CODE>init-
expr</CODE></em> by separating each initialization expression by a comma, as in <CODE>i = 0,
j = 0</CODE>. You can even declare a new variable in the <EM><CODE>init-
expr</CODE></em>:
<PRE>
for (int i = 0; i < 10; ++i) {
    //...
}
</pre>

<P>The scope of this variable <CODE>i</CODE> is only within the
<EM><CODE>statement</CODE></em> portion of the <CODE>for</CODE> itself (in this
example, a block). This contrasts with C++, which also allows you to declare a variable in the
<EM><CODE>init-expr</CODE></em> portion of a <CODE>for</CODE> loop, but that variable
has a scope as if it were declared just above the <CODE>for</CODE> loop. In Java, the variable has a
scope as if it were declared inside the <EM><CODE>statement</CODE></em> of the
<CODE>for</CODE> loop.

<P>The <EM><CODE>incr-expr</CODE></em> is usually an increment expression such as
<CODE>++i</CODE>. Like the <EM><CODE>init-expr</CODE></em>, it can contain multiple
statements separated by commas, as in: <CODE>++i, ++j</CODE>.

<P>The <CODE>for</CODE> loop executes by first executing <EM><CODE>init-
expr</CODE></em>, then evaluating <EM><CODE>boolean-expr</CODE></em>. If
<EM><CODE>boolean-expr</CODE></em> evaluates to <CODE>true</CODE>,
<EM><CODE>statement</CODE></em> is executed. After
<EM><CODE>statement</CODE></em> is executed, <CODE>incr-expr</CODE> is executed
and <EM><CODE>boolean-expr</CODE></em> is checked again. The process of
<EM><CODE>boolean-expr</CODE></em> check, <EM><CODE>statement</CODE></em>
execution, <EM><CODE>incr-expr</CODE></em> execution repeats until
<EM><CODE>boolean-expr</CODE></em> evaluates to <CODE>false</CODE> (or a
<CODE>break</CODE>, <CODE>continue</CODE>, or <CODE>return</CODE> is executed, or
an exception is thrown).

<P>Each of the three components in a <CODE>for</CODE> loop's parentheses are optional. If you
leave out the <CODE>boolean-expr</CODE>, it is assumed to be <CODE>true</CODE>. Thus, the
customary way to write an infinite loop is:
<PRE>
// a "forever" loop
for (;;) {
    //...
}
</pre>

<H3>The <CODE>switch</CODE> Statement</H3>

<P>The <CODE>switch</CODE> statement gives an alternative to a cascade of <CODE>if-
else</CODE> constructs:
<PRE>
// In Source Packet in file expr/ex3/Example3a.java
class Example3a {
    public static void main(String[] args) {
        int i = (int) (Math.random() * 5.0);
        if (i == 0) {
            System.out.println("Zero");
        }
        else if (i == 1) {
            System.out.println("One");
        }
        else if (i == 2 || i == 3) {
            System.out.println("Two or Three");
        }
        else {
            System.out.println("Other");
        }
    }
}
</pre>
The equivalent switch statement is:
<PRE>
// In Source Packet in file expr/ex3/Example3b.java
class Example3b {
    public static void main(String[] args) {
        int i = (int) (Math.random() * 5.0);
        switch (i) {

        case 0:
            System.out.println("Zero");
            break;

        case 1:
            System.out.println("One");
            break;

        case 2:
        case 3:
            System.out.println("Two or Three");
            break;

        default:
            System.out.println("Other");
            break;
        }
    }
}
</pre>
A <CODE>switch</CODE>'s expression (<CODE>i</CODE> in this example) must be an
<CODE>int</CODE>. The case labels must be compile-time constants. They can either be literals, as
shown here, or <CODE>static</CODE> <CODE>final</CODE> fields
of some class. A <CODE>break</CODE> statement is used in a <CODE>switch</CODE> to indicate
the processing for that <CODE>case</CODE> is done. You need not have a <CODE>break</CODE>
for every <CODE>case</CODE>. You can "fall through" to the code for the next case label, as was done
by <CODE>case 2</CODE> in this example.
<H3>The <CODE>break</CODE> and <CODE>continue</CODE> Statements</H3>

<P>You can use <CODE>break</CODE> to exit <CODE>while</CODE>, <CODE>do-
while</CODE>, <CODE>for</CODE>, and <CODE>switch</CODE> statements. When a break is
executed, the execution continues just after the end of the current simple statement or block.
[bv: actually, I think this statement is too simple. break hops to the end
of the current while, do-while, or switch block, right?]
<P>You can use <CODE>continue</CODE> inside a <CODE>while</CODE>, <CODE>do-
while</CODE>, and <CODE>for</CODE> loop. When a <CODE>continue</CODE> is executed,
the rest of the loop's body is skipped and the <EM><CODE>boolean-expression</CODE></em>
is again evaluated.

<P>You can optionally use a label to indicate which loop or <CODE>switch</CODE> you want a
<CODE>break</CODE> to operate on, or which loop you want a or <CODE>continue</CODE> to
operate on. This enables you to easily break out of nested loops or <CODE>switch</CODE> statements,
or to continue nested loops. To do so you must label the beginning of the loop or switch statement:
<PRE>
<EM>label</em>: <EM>statement</em>
</pre>
Here's an example:
<PRE>
// In Source Packet in file expr/ex4/Example4.java
class Example4 {
    public static void main(String[] args) {

dance:  for (int i = 0; i < 10; ++i) {
            System.out.println(i + ": Swing your partner...");
            for (int j = 0; j < 10; ++j) {
                System.out.println(j + ": Round and round...");
                if (i == 5 && j == 5) {
                    break dance;
                }
            }
        }
        // Execution continues here after break dance is encountered.
        System.out.println("Now, twirl on your back.");
    }
}
</pre>
<P>When the <CODE>break</CODE> <CODE>dance</CODE> statement is executed, the
<CODE>for</CODE> loop labeled <CODE>dance</CODE> (the outer loop) is exited.

<H3>The <CODE>return</CODE> Statement</H3>

<P>The <CODE>return</CODE> statement returns from a method, potentially returning a value. If the
method is declared as <CODE>void</CODE>, you must use a simple <CODE>return</CODE>
statement:
<PRE>
return;
</pre>
Otherwise, you must indicate a return value with a type that matches the return type of the method. For
example, a method declared with a boolean return type could have the following statement:
<PRE>
return true;
</pre>

<H3>Other Statements</H3>

<P>A handful of other statements will be covered in later chapters. Chapter 11 will describe the
<CODE>throw</CODE> and <CODE>try</CODE> statements. Chapter 13 will describe the
<CODE>synchronized</CODE> statement.

<H2>Reachability</H2>

<P>With one exception, statements in a Java program must be <EM>reachable</em>. There must be at
least one path of execution that will "reach" each statement. For example, the following code won't
compile, because the <CODE>++i</CODE> is unreachable:
<PRE>
// In Source Packet in file expr/ex5/Example5a.java
class Example5a {
    public static void main(String[] args) {
        // THIS WON'T COMPILE
        int i = 0;
        while (false) {
            ++i;
        }
    }
}
</pre>
The exception to the reachability rule is the <CODE>if</CODE> statement. The following code does
compile:
<PRE>
// In Source Packet in file expr/ex5/Example5b.java
class Example5b {
    public static void main(String[] args) {
        // This compiles fine.
        int i = 0;
        if (false) {
            ++i;
        }
    }
}
</pre>
The reason the <CODE>if</CODE> statement is special is so it can be used for conditional compilation.
(Because Java doesn't have a preprocessor like C++, it can't use C++'s method for conditional
compilation.) The above code would compile, but the <CODE>if (false) { ++i; }</CODE> code
would not appear in the class file.

<!--
<H2>Exercises</H2>
<H2>The Resources Page</H2>
For links to more information about the topics covered in this chapter, visit the resources page at
http://www.artima.com/innerjava/resources.html.
-->

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/objectsandjava/webuscript/ExpressionsStatements1.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
