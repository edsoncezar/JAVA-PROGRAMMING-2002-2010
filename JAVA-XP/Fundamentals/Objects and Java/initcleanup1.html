<HTML>
<HEAD>
<TITLE>Initialization and Cleanup: Chapter 4 of Objects and Java</TITLE>
<META name="description" content="All about the beginning and end of a Java object's lifetime.">
<META name="keywords" content="Java Design, Java Book, Object Initialization, Object Finalization">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#663300">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\..\images\ab.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/5a751782?REGION=Brown&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ObjNJava" ><img src="..\..\cgi-bin\getimage.cgi\5a751782\region=brown&campaign=default&account=artima&banne" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#663300">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Objects and Java by Bill Venners</SPAN><BR>
<SPAN class="sts">Chapter 4:</SPAN><BR>
<SPAN class="ts">Initialization and Cleanup</SPAN><BR>
</DIV>
<!--BEGIN_OAJBOOK_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="http://www.artima.com/objectsandjava/index.html">Objects and Java</A>&nbsp;|
<A href="index.html">Contents</A>&nbsp;|
<A href="expressionsstatements1.html">Previous</A>&nbsp;|
<A href="packagesaccess1.html">Next</A>&nbsp;
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_OAJBOOK_LINKS-->

<P>Variables
have lifetimes. The lifetime of an instance variable matches that of
the object to which it belongs. The lifetime of a class variable
matches that of the class to which it belongs. The lifetime of a local
variable is from the point it is created to the point where it goes
out of scope. The Java language and virtual machine have mechanisms
to ensure each of these kinds of variables are initialized before
they are used.

<P>As discussed in Chapter 3,
the Java compiler and Java virtual machine make sure local variables are
explicitly initialized before they are used.

<P>
[bv: talk briefly about the lifetime of a class here]
<P>
At the beginning of an object's life, the Java virtual machine (JVM)
allocates enough memory on the heap to accommodate the object's
instance variables. When that memory is first allocated, however, the
data it contains is unpredictable. If the memory were used as is, the
behavior of the object would also be unpredictable. To guard against
such a scenario, Java makes certain that memory is initialized, at
least to predictable default values, before it is used by any code.

<P>
Initialization is important because, historically, uninitialized data
has been a common source of bugs. Bugs caused by uninitialized data
occur regularly in C, for example, because it doesn't have
built-in mechanisms to enforce proper initialization of data. C
programmers must always remember to initialize data after they allocate
it and before they use it. The Java language, by contrast, has built-in
mechanisms that help you ensure proper initialization of the memory
occupied by a newly-created object.  With proper use of these
mechanisms, you can prevent an object of your design from ever being
created with an invalid initial state.

<H2>Object Initialization Mechanisms</H2>
<P>
The Java language has three mechanisms dedicated to ensuring proper
initialization of objects:
<UL>
<LI>constructors
<LI>instance variable initializers
<LI>instance initializers
</UL>
Instance variable initializers and instance initializers may together
be called simply &quot;initializers.&quot; All three mechanisms result in
Java code
that is executed automatically when an object is created. When you
allocate memory for a new object with the <CODE>new</CODE> operator,
the Java virtual machine will insure that initialization code is run before
you can use the newly-allocated memory. If you design your classes such
that initializers and constructors always produce a valid state for
newly-created objects, there will be no way for anyone to create and
use an object that isn't properly initialized.

<H2><A name="index-default+initial+values">Default initial values</A></H2>
<P>
Up to this point, the examples used in this book have done no explicit initialization of instance
variables. This is perfectly legal in Java, and results in predictable <EM>default initial values</em>,
which are based only upon the type of the variable. Table 4-1 shows the default initial values for each of
the variable types. (These are the default initial values for both instance and class variables. Initialization
of class variables will be discussed in depth in Chapter 6.)

<P>
<CENTER>
<TABLE BORDER="1" CELLPADDING="2">
<TR BGCOLOR="#0066CC">
<TH>Type</TH>

<TH>Default Value</TH>
</TR>

<TR>
<TD><CODE>boolean</CODE></TD>
<TD><CODE>false</CODE></TD>
</TR>

<TR>
<TD><CODE>byte</CODE></TD>
<TD><CODE>(byte) 0</CODE></TD>
</TR>

<TR>
<TD><CODE>short</CODE></TD>
<TD><CODE>(short) 0</CODE></TD>
</TR>

<TR>
<TD><CODE>int</CODE></TD>
<TD><CODE>0</CODE></TD>
</TR>

<TR>
<TD><CODE>long</CODE></TD>
<TD><CODE>0L</CODE></TD>
</TR>

<TR>
<TD><CODE>char</CODE></TD>
<TD><CODE>\u0000</CODE></TD>
</TR>

<TR>
<TD><CODE>float</CODE></TD>
<TD><CODE>0.0f</CODE></TD>
</TR>

<TR>
<TD><CODE>double</CODE></TD>
<TD><CODE>0.0d</CODE></TD>
</TR>

<TR>
<TD>object reference</TD>
<TD><CODE>null</CODE></TD>
</TR>
</TABLE>
<P>
<STRONG> Table 4-1. Default values for fields</STRONG>
</CENTER>

<P>If you don't explicitly initialize an instance variable, then that variable will still have its default initial
value when <CODE>new</CODE> returns its reference. For example, in all the versions of class
<CODE>CoffeeCup</CODE> prior to this chapter, the <CODE>innerCoffee</CODE> field was
not explicitly initialized (The class contains no constructors or initializers.):
<PRE>
// This class has no constructors or initializers
public class CoffeeCup {

    private int innerCoffee;

    // The rest of the class...
}
</pre>
As a result, when the reference to a new <CODE>CoffeeCup</CODE> object is first returned by
<CODE>new</CODE>, the <CODE>innerCoffee</CODE> field would be its default initial value.
Because <CODE>innerCoffee</CODE> is an <CODE>int</CODE>, its default initial value is zero.

<P>
Note that this means that if you explicitly initialize
<CODE>innerCoffee</CODE>, say to a value of 100, then when each
<CODE>CoffeeCup</CODE> object is created, <CODE>innerCoffee</CODE>
will, in effect, be initialized twice. First, <CODE>innerCoffee</CODE>
will be given its default initial value of zero. Later, the zero will
be overwritten with the proper initial value of 100. All of this takes
place while the Java virtual machine is creating the new object --
before it returns the reference to the new object. By the time the
reference to a new <CODE>CoffeeCup</CODE> object is returned from the
<CODE>new</CODE> operator, the <CODE>innerCoffee</CODE> field will be
set to 100.

<P>
As mentioned in Chapter 2, local variables do not participate in the default
initial values that instance variables (and, as you will see in
Chapter 6, class variables) are guaranteed to receive. The value of a local
variable is undefined until you explicitly initialize it.

<H2><A name="index-constructors-introduction+to">Constructors</A></H2>
<P>
The central player in object initialization is the
<EM>constructor</em>. In Java, constructors are similar to methods, but
they are not methods. Like a method, a constructor has a set of
parameters and a body of code. Unlike methods, however, constructors
have no return type. Like methods, you can give access specifiers to
constructors, but unlike methods, constructors with public, protected,
or package access are not inherited by subclasses. (Also, instead of
determining the ability to invoke a method, the access level of a
constructor determines the ability to instantiate an object.)

<H3>Constructor Basics</H3>
<P>
In the source file, a constructor looks like a method declaration in
which the method has the same name as the class but has no return type.
For example, here is a constructor declaration for class
<CODE>CoffeeCup</CODE>:

<P>
<PRE>
// In source packet in file init/ex2/CoffeeCup.java
class CoffeeCup {
    // Constructor looks like a method declaration
    // minus the return type
    public CoffeeCup() {
        // Body of constructor
    }
    // ...
}
</pre>

<P>
As with methods, you can overload constructors by varying the number,
types, and order of parameters.  Here is a class <CODE>CoffeeCup</CODE>
with two constructors:

<P>
<PRE>
// In source packet in file init/ex3/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {
        innerCoffee = 237;
    }

    public CoffeeCup(int amount) {
        innerCoffee = amount;
    }
    // ...
}
</pre>

<P>
When you instantiate an object with <CODE>new</CODE>, you must specify
a constructor. For example, given the <CODE>CoffeeCup</CODE> class
above that has two constructors, you could instantiate it in either of
these two ways:

<P>
<PRE>
// In source packet in file init/ex3/Example3.java
class Example3 {
    public static void main(String[] args) {

        // Create an empty cup
        CoffeeCup cup1 = new CoffeeCup();

        // Create a cup with 355 ml of coffee in it
        CoffeeCup cup2 = new CoffeeCup(355);
    }
}
</pre>

<H3><A name="index-no+arg+constructor-introduction">The No-Arg Constructor</A></H3>
<P>
In Java jargon, constructors that take no parameters (or no arguments)
are called &quot;no-arg constructors.&quot; In the code shown above,
the first instantiation of a <CODE>CoffeeCup</CODE> object specifies
the no-arg constructor. The second instantiation specifies the
constructor that requires an <CODE>int</CODE> as its only parameter.

<H3><A name="<CODE>this()</CODE>+invocation-introduction">The <CODE>this()</CODE> invocation</H3>
<P>
From within a constructor, you can explicitly invoke another
constructor from the same class by using the
<CODE>this()</CODE> statement. You may want to do this if you have
several overloaded constructors in a class, all of which must execute
much of the same code. Here's an example:

<P>
<PRE>
// In source packet in file init/ex4/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {
        this(237); // Calls other constructor
        // Could have done more construction here
    }

    public CoffeeCup(int amount) {
        innerCoffee = amount;
    }
    // ...
}
</pre>

<P>
In this example, the no-arg constructor invokes the constructor
that takes an <CODE>int</CODE> as its only parameter. It passes
<CODE>237</CODE> to the other constructor, which assigns that value to
<CODE>innerCoffee</CODE>.

<P>
You cannot call <CODE>this()</CODE> from methods, only from
constructors. If you do call <CODE>this()</CODE>in a constructor, you
must call it first, before any other code in the constructor, and you
can only call it once. Any code you include after the call to
<CODE>this()</CODE> will be executed after the invoked constructor
completes.

<A name="index-constructors-compared+to+methods"><H3>Constructors Are Not Methods</H3></A>
<P>
To further illustrate the difference between methods and constructors,
consider this fact: The name of a class is a valid name for its
methods. In other words, class <CODE>CoffeeCup</CODE> could have
methods named <CODE>CoffeeCup</CODE>:

<P>
<PRE>
// In source packet in file init/ex5/CoffeeCup.java
// THIS WORKS, BUT IT IS AN EXAMPLE OF POOR METHOD NAMING
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {	// The constructor
        innerCoffee = 237;
    }

    public void CoffeeCup() {	// The method
        innerCoffee = 99;
    }
    // ...
}
</pre>

<P>
Given the above definition of class <CODE>CoffeeCup</CODE>, you could
legally do the following:

<P>
<PRE>
// In source packet in file init/ex5/Example5.java
class Example5 {
    public static void main(String[] args) {

        CoffeeCup cup = new CoffeeCup(); // invoke the constructor
        cup.CoffeeCup(); // invoke the method
    }
}
</pre>

<P>
Although it is legal to give a method the same name as a class, in
practice you should never do so, in part because other programmers
might confuse it with a constructor, but also because it breaks many of
the rules for good method naming. First, a class name is not a verb;
it's a noun (at least it <EM>should be</em> a noun). Method names
should be verbs. You should name methods after the action they perform,
and &quot;<CODE>CoffeeCup</CODE>&quot; is not an action. Also,
&quot;<CODE>CoffeeCup</CODE>&quot; doesn't follow the naming convention
for methods, in which the first letter is lowercase. The purpose of this
example is merely to highlight the fact that constructors aren't
methods by showing that a constructor does not conflict with a method
that has the same signature. Java's recommended naming conventions are
described later in this chapter, in the Design Corner section.

<H3><A name="index-default+constructors-introduction">Default constructors</A></H3>

<P>
If you declare a class with no constructors, the compiler will
generate a constructor for you.
Such automatically-generated constructors, which are called
<EM>default constructors</EM>,
take no parameters (they are no-arg
constructors) and have empty bodies. Because the compiler will
automatically generate a
default constructor if you don't declare any constructors explicitly,
all classes are guaranteed to have at least one constructor.

<P>For
example, if you declare a <CODE>CoffeeCup</CODE> class without
declaring a constructor explicitly:

<P>
<PRE>
// In source packet in file init/ex6/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public void add(int amount) {
        innerCoffee += amount;
    }
    //...
}
</pre>

<P>
The compiler will generate the same class file as if you had
explicitly declared a no-arg constructor with an empty body:

<P> <PRE>
// In source packet in file init/ex7/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {
    }

    public void add(int amount) {
        innerCoffee += amount;
    }
    //...
}
</pre>

<H2><A name="index-instance+initialization+methods-introduction">
Instance Initialization Methods</A></H2>
<P>
When you compile a class, the Java compiler creates an <EM>instance
initialization method</em> for each constructor you declare in the
source code of the class. Although the constructor is not a method, the
instance initialization method is. It has a name, <CODE>&lt;init&gt;</CODE>, a return type,
<CODE>void</CODE>, and a set of parameters that match the parameters of
the constructor from which it was generated. For example, given the following
two constructors in the source file for class <CODE>CoffeeCup</CODE>:

<P>
<PRE>
// In source packet in file init/ex8/CoffeeCup.java
class CoffeeCup {
    public CoffeeCup() {
        //...
    }
    public CoffeeCup(int amount) {
        //...
    }
    // ...
}
</pre>

<P>
the compiler would generate the following two instance initialization
methods in the class file for class <CODE>CoffeeCup</CODE>, one for
each constructor in the source file:

<P>
<PRE>
// In binary form in file init/ex8/CoffeeCup.class:
public void &lt;init&gt;(CoffeeCup this) {...}
public void &lt;init&gt;(CoffeeCup this, int amount) {...}
</pre>

<P>
Note that <CODE>&lt;init&gt;</CODE> is not a valid
Java method name, so you could not define a method in your source file
that accidentally conflicted with an instance initialization method.
(To be precise, <CODE>&lt;init&gt;</CODE> is not a method in the Java
language sense of the term, because it has an illegal name. In the
compiled, binary Java class file, however, it is a valid method.)

<P>
Also, the <CODE>this</CODE> reference passed as the first parameter to
<CODE>&lt;init&gt;</CODE> is inserted by the Java compiler into the
parameter list of every instance method. For example, the method
<CODE>void add(int amount)</CODE> in the source file for
class <CODE>CoffeeCup</CODE> would become the <CODE>void add(CoffeeCup
this, int amount)</CODE> method in the class file. The hidden
<CODE>this</CODE> reference is the way in which instance methods,
including instance initialization methods, are able to access instance
data.

<P>
If you don't explicitly declare a constructor in a class, the Java
compiler will create a default constructor on the fly, then translate
that default constructor into a corresponding instance initialization
method. Thus, every class will have at least one instance initialization method.

<P>
When the compiler generates an instance initialization method, it bases
it on a constructor. It gives the method the same parameter list as the
constructor, and it puts the code contained in the constructor's body
into the method's body. But the instance initialization method does not
necessarily represent a mere compilation of the constructor with the
name changed to <CODE>&lt;init&gt;</CODE> and a return value of
<CODE>void</CODE> added. Often, the code of an instance initialization
method does more than the code defined in the body of its corresponding
constructor. The compiler also potentially adds code for any
initializers and an invocation of the superclass's constructor.

<H2><A name="index-initializers-introduction">
Initializers</A></H2>
<P>
Besides constructors, Java offers one other way for you to
assign an initial value to instance variables: initializers.
As mentioned previously, the two kinds of
<EM><A name="index-initializers-definition">initializers</A></EM> in Java are
instance variable initializers and instance initializers.

<H3><A name="index-instance+variable+initializers-introduction">
Instance variable initializers</A></H3>
<P>
In a constructor, you have the freedom to write as much code as needed
to calculate an initial value. In an
<EM><A name="index-instance+variable+initializers-definition">
instance variable initializer</A></EM>, by contrast,
you have only an equals sign and an expression.
The left-hand side of the equals sign is the instance variable being
initialized.
The right-hand side of the equals sign
can be any expression that evaluates to the type of the instance variable.

<P>
For example, if you wanted
to always start coffee cups out with 355 milliliters of fresh brewed
coffee in them, you could initialize <CODE>innerCoffee</CODE> with a
constructor:

<P>
<PRE>
// In source packet in file init/ex9/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {
        innerCoffee = 355;
    }
    // ...
}
</pre>

<P>
Alternatively, you could initialize <CODE>innerCoffee</CODE> with an
instance variable initializer:

<P>
<PRE>
// In source packet in file init/ex10/CoffeeCup.java
class CoffeeCup {
    private int innerCoffee = 355; // "= 355" is an initializer
    // no constructor here
    // ...
}
</pre>


<H3><A name="index-instance+initializers-introduction">
<A name="index-instance+initialization+blocks-introduction">
Instance Initializers</A></A></H3>
<P>
Java 1.1 introduced instance initializers.
<EM><A name="index-instance+initializers-definition">Instance initializers</A></EM>, which may also be called
<EM><A name="index-instance+initialization+blocks-definition">instance
initialization blocks</A></EM>, are blocks of code (marked by open
and close curly braces)
that sit in the body of a class, but outside the body of any method declared
in that class.

<P>
For example, here is the same

<CODE>CoffeeCup</CODE> class with its <CODE>innerCoffee</CODE> variable initialized
by an instance initializer:

<P>
<PRE>
// In source packet in file init/ex19/CoffeeCup.java
class CoffeeCup {
    private int innerCoffee;

    // The following block is an instance initializer
    {
        innerCoffee = 355;
    }
    // no constructor here
    // ...
}
</pre>

<P>
This manner of initializing <CODE>innerCoffee</CODE> yields the same
result as the previous two examples: <CODE>innerCoffee</CODE> is
initialized to 355.

<P>
Instance initializers are a useful alternative to instance variable
initializers whenever: (1) initializer code must catch exceptions
(described in Chapter 13), or
(2) perform fancy calculations that can't be expressed with an instance
variable initializer. You could, of course, always write such code in
constructors. But in a class that had multiple constructors, you would
have to repeat the code in each constructor.  With an instance
initializer, you can just write the code once, and it will be executed
no matter what constructor is used to create the object. Instance
initializers are also useful in anonymous inner classes (described
in Chapter 11), which can't declare any constructors at all.

<P>
Note that the code inside an instance initializer may not return.
In addition, instance initializers have special rules regarding
exceptions.  Information about these special rules is given
in Chapter 13.

<H3>
<A name="index-instance+initializers-forward+references+and">
<A name="index-forward+references-instance+initializers+and">
Initializers Can't Make Forward References
</A>
</A>
</H3>
<P>
When you write an initializer (either an instance variable initializer
or instance initializer), you must be sure not to refer to any instance
variables declared textually after the variable being initialized. In
other words, you can't make a forward reference from an
initializer.  (A
<EM><A name="index-forward+reference-definition">forward reference</A></EM>
is simply a use of a
variable declared textually after the current statement in the
source file.) If you disobey this rule, the compiler will give you an
error message and refuse to generate a class file.

<P>
<A name="index-initializers-textual+order+of+execution">
<A name="index-instance+initializers-textual+order+of+execution">
<A name="index-instance+variable+initializers-textual+order+of+execution">
<A name="index-instance+initialization+blocks-textual+order+of+execution">
When an object is
</A>
</A>
</A>
</A>
created, initializers are executed in <EM>textual order</em> -- their
order of appearance in the source code. The forward-referencing rule helps
prevent
initializers from using instance variables that have yet to be properly
initialized.

<P>
For example, here is a virtual caf&eacute class that has four chairs
for every table:

<P>
<PRE>
// In source packet in file init/ex11/VirtualCafe.java
class VirtualCafe {
    private int tablesCount = 20;
    private int chairsCount = 4 * tablesCount;
    //...
}
</pre>

<P>
These initializers work fine. The <CODE>chairsCount</CODE> initializer,
<CODE>= 4 * tablesCount</CODE>, refers to an instance variable declared
textually before it, so the compiler is happy.  Because initializers
are executed in textual order, <CODE>tablesCount</CODE> is already
initialized to 20 by the time <CODE>chairsCount</CODE>'s initializer
multiplies it by four. Thus, <CODE>chairsCount</CODE> is initialized to
80.

<P>
If you were able to use instance variables declared textually later,
you could end up with unexpected behavior:

<P>
<PRE>
// In source packet in file init/ex12/VirtualCafe.java
// THIS WON'T COMPILE, BUT AS A THOUGHT EXPERIMENT,
// IMAGINE IT WERE POSSIBLE
class VirtualCafe {
    private int chairsCount = 4 * tablesCount;
    private int tablesCount = 20;
    //...
}
</pre>

<P>
If the above declaration were possible, <CODE>chairsCount</CODE>'s
initializer would use <CODE>tablesCount</CODE> before
<CODE>tablesCount</CODE> were assigned a value of 20. At that point,
the <CODE>tablesCount</CODE> variable would have its default initial
value of zero. Hence, this code would initialize
<CODE>chairsCount</CODE> to four times zero. If you do the math, you
will discover that, in this case, <CODE>chairsCount</CODE> does <EM>not</em>
get initialized to 80.

<H3>
<A name="index-forward+referencing+rule-subverting">
Getting around the forward reference rule
</A>
</H3>
<P>
Although this kind of forward referencing is disallowed by the compiler
in an attempt to help programmers avoid just the above kind of mistake,
you can't let down your guard completely. There is still a way you
could inadvertently (or purposefully) circumvent the compiler's
preventative restrictions:

<P>
<PRE>
// In source packet in file init/ex13/VirtualCafe.java
class VirtualCafe {

    private int chairsCount = initChairsCount();
    private int tablesCount = 20;

    private int initChairsCount() {
        return tablesCount * 4;
    }
    //...
}
</pre>

<P>
The above code compiles fine, and has the same result as the previous
thought experiment. Here <CODE>chairsCount</CODE>'s initializer
sneakily invokes a method that uses <CODE>tablesCount</CODE> before its
initializer has been executed. When <CODE>initChairsCount()</CODE>
calculates <CODE>tablesCount * 4</CODE>, <CODE>tablesCount</CODE> is
still at its default initial value of zero.  As a result,
<CODE>initChairsCount()</CODE> returns zero, and <CODE>chairsCount</CODE>
is initialized to zero.

<H2>Other Ways to Instantiate Objects</H2>
Besides the <CODE>new</CODE> operator, Java provides three other ways
to instantiate objects:
<UL>
<LI>Invoking <CODE>clone()</CODE> on an object
<LI>Deserializing an object
<LI>Invoking the <CODE>newInstance()</CODE> method of class <CODE>java.lang.Class</CODE>
</UL>

These other ways of creating objects are described in later chapters.
Cloning is described in Chapter 14; deserialization in Chapter 19; and
<CODE>newInstance()</CODE> in Chapter 23.

<H2>More Object Initialization to Come</H2>
<P>
Although the information here  may seem like a lot, there is still more
to object initialization, in particular, the way in which initialization
interacts with inheritence.
Information about initialization and inheritance will be given in
Chapter 7.

<H2>Design Corner</H2>
<H2>Behind the Scenes</H2>
<P>
[bv: perhaps show that diagram of relationship between language,
class file, and virtual machine.]
The <CODE>&lt;init&gt;</CODE> method is not actually part of the Java
language. Rather, it is something the Java virtual machine expects to
see in a Java class file. This distinction is significant because the
Java language does not depend on the class file. Java source can be
compiled into other binary formats, including native executables. A
Java compiler that translates Java language source into some other
binary format need not generate a method named
<CODE>&lt;init&gt;</CODE>, so long as objects are initialized in the
proper way at the proper time. The Java Language Specification (JLS) details
the order of initialization and when it occurs, but doesn't say how it
is actually accomplished.
 Still,
understanding how initialization works inside class files can help you
understand the order of initialization in the language.

<H1>Class Initialization</H1>

<P>Variables have lifetimes. The lifetime of an instance variable
matches that of
the object to which it belongs. The lifetime of a class variable
matches that of the class to which it belongs. The lifetime of a local
variable is from the point it is created to the point where it goes
out of scope. The Java language and virtual machine have mechanisms
to ensure each of these kinds of variables are initialized before
they are used.

<P>
[bv: talk briefly about the lifetime of a class here]

[bv:Clean up this class init stuff. It is too redundant with object
init stuff and a bit too cutseypie with suger packets.]

<P>Introduce class variable initializers and static initialization blocks.

<H2>Default Initial Values</H2>

<P>Class variables get initialized to the same default initial values
as instance variables. These default initial values are shown in
Table 4-1.

<H2>Class Variable Initializers</H2>
<PRE>
public class SugarHolder {
      private int sugarPacketCount; // instance variable
      private static int sugarPacketsInCafeCount; // class variable
}
</pre>

<P>Class <CODE>SugarHolder</CODE> contains one instance variable and one class variable. In
this example, the <CODE>SugarHolder</CODE> class maintains a class variable,
<CODE>sugarPacketsInCafeCount</CODE>, to track the total number of packets of sugar sitting
in sugar holders throughout the café. The instance variable, <CODE>sugarPacketCount</CODE>,
just tracks the number of packets of sugar in an individual sugar holder.

<P>In the example above, <CODE>sugarPacketsInCafeCount</CODE> will have an initial value
of zero, because zero is the default initial value for <CODE>ints</CODE>. If you wanted a different
initial value for <CODE>sugarPacketsInCafeCount</CODE>, you would have to explicitly
initialize it to the other value. For example, imagine you are simulating a café that always starts out with
five sugar holders, each of which contains five sugar packets. You could easily initialize the
<CODE>sugarPacketsInCafeCount</CODE> to 25 using a <EM>class variable initializer</em>.
You write a class variable initializer with an equals sign and an expression, as shown below:
<PRE>
class SugarHolder {
      private int sugarPacketCount;
      private static int sugarPacketsInCafeCount = 25;
}
</pre>

<P>In the above example, <CODE>sugarPacketsInCafeCount</CODE> will be set to 25 before
any use of the class. The class variable initializer is " = 25".

<P>The Java compiler enforces the same forward referencing rule on class
variable initializers. Class variable initializers may
refer to any class variable that appears textually before it in the class, but not after. This rule aims to
prevent situations in which a class variable is used before it is initialized.

<P>Some examples of static initialization blocks are shown below. In these examples the
<CODE>SugarHolder</CODE> class from an earlier example has been enhanced to include class
variables that track the total number of particular types of sugar packets in the café. This café offers four
type of sugar packets, each of which comes in a different color package. The white packet contains plain
old sugar. The brown packet contains unbleached brown granules of sugar. The pink and blue packets
contain two different brands of sugar substitutes. The first example shows an unruly class initializer that
refers to class variables that appear textually after it. Because of this one class variable initializer's
disregard for the rules, the entire class will be rejected by the compiler.
<PRE>
class SugarHolder {
      private int sugarPacketCount;

      // This won't compile because the following class
      // variable initializer refers to class variables
      // that appear textually after it.
      private static int sugarPacketsInCafeCount =
            whitePacketsInCafeCount + brownPacketsInCafeCount
            + pinkPacketsInCafeCount + bluePacketsInCafeCount;
      private static int whitePacketsInCafeCount = 10;
      private static int brownPacketsInCafeCount = 5;
      private static int pinkPacketsInCafeCount = 5;
      private static int bluePacketsInCafeCount = 5;
}
</pre>

<P>The following example rectifies the problem by simply moving the declaration of
<CODE>sugarPacketsInCafeCount</CODE> such that it appears textually after the declarations
of the class variables it uses.
<PRE>
class SugarHolder {
      private int sugarPacketCount;

      private static int whitePacketsInCafeCount = 10;
      private static int brownPacketsInCafeCount = 5;
      private static int pinkPacketsInCafeCount = 5;
      private static int bluePacketsInCafeCount = 5;
      // This class will compile because the following class
      // variable initializer only refers to other class
      // variables that appear textually before it.
      private static int sugarPacketsInCafeCount =
            whitePacketsInCafeCount + brownPacketsInCafeCount
            + pinkPacketsInCafeCount + bluePacketsInCafeCount;
}
</pre>

<H2>Static Initialization Blocks</H2>

<P>If you need to initialize a class variable in a manner too complex to express with an equals sign and
expression, you can write a <EM>static initialization block</em>. A static initialization block is a code
block preceded by the word <CODE>static</CODE>, as in:
<PRE>
class SugarHolder {
	// ...
	static {
		// code for the static initialization
		// goes here
	}
	// ...
</pre>

<P>For a more concrete example, suppose instead of starting over with a fresh café each time you run
your simulation program, you want to continue the state of the previous café. In this case you could write a
static initialization block such as the one shown below:
<PRE>
// Defined in file SugarHolder.java
public class SugarHolder {
      private int sugarPacketCount;
      private static int sugarPacketsInCafeCount;
      static {
            // Initialize the total number of sugar packets with
            // state data left over from previous execution of
            // the simulation program.
            int sugarHolderCount =
                  PersistentStorage.getSugarHolderCount();
            for (int i = 0; i < sugarHolderCount; ++i) {
                 sugarPacketsInCafeCount +=
                       PersistentStorage.getSugarPacketCount(i);
            }
      }
}
// Defined in file PersistentStorage.java:
public class PersistentStorage {
	public int getSugarPacketCount(int sugarHolderIndex) {
		// For now return something that looks good. Later,
		// actually set up persistent storage
		return 23;
	}
	// ...
}
</pre>

<P>In the above example, the code in the static initialization block will be executed before the class is
used, resulting in a <CODE>sugarPacketsInCafeCount</CODE> that is initialized to a value
retrieved from persistent storage.

<P>You can include in a class as many class variable initializers as there are class variables, and as many
static initialization blocks as you wish. You can place static initialization blocks anywhere in your class.
You could, for example, write one static initialization block that initializes several class variables.
Alternatively, you could write a separate static initialization block for each class variable. You could even
write several static initialization blocks for a single class variable, although in this case your peers might
think you're a bit odd. The point here is that there is no one-to-one correspondence between class
variables and static initialization blocks. You can, in fact, create static initialization blocks in classes that
don't have any class variables.

<P>Static initialization blocks have full privileges of regular static methods, with one exception. A static
initialization block may refer to any class variable that appears textually before it in the class, but not
after. The Java compiler will balk if one of your static initialization blocks uses or assigns a class variable
the appears textually after it, even though such variables are in scope.

<P>The next example includes a static initialization block with a healthy disrespect for authority. Like the
irreverent class variable initializer from a previous example, this static initialization block accesses class
variables that appear textually after it. In this case, authority will win again, because the class will not
compile.
<PRE>
// Defined in file SugarHolder.java:
// This class won't compile, because the static initialization block
// refers to class variables that appear textually after it.
class SugarHolder {
      private int sugarPacketCount;
      private static int sugarPacketsInCafeCount;
      static {
            // Initialize the total number of sugar packets with
            // state data left over from previous execution of
            // the simulation program.
            int sugarHolderCount =
                  PersistentStorage.getSugarHolderCount();
            for (int i = 0; i < sugarHolderCount; ++i) {
                 sugarPacketsInCafeCount +=
                       PersistentStorage.getSugarPacketCount(i);
                 whitePacketsInCafeCount +=
                       PersistentStorage.getWhitePacketCount(i);
                 brownPacketsInCafeCount +=
                       PersistentStorage.getBrownPacketCount(i);
                 pinkPacketsInCafeCount +=
                       PersistentStorage.getPinkPacketCount(i);
                 bluePacketsInCafeCount +=
                       PersistentStorage.getBluePacketCount(i);
            }
      }
      private static int whitePacketsInCafeCount;
      private static int brownPacketsInCafeCount;
      private static int pinkPacketsInCafeCount;
      private static int bluePacketsInCafeCount;
}
// Defined in file PersistentStorage.java:
public class PersistentStorage {
	public int getSugarPacketCount(int sugarHolderIndex) {
		return 23;
	}
	public int getWhitePacketCount(int sugarHolderIndex) {
		return 6;
	}
	public int getBrownPacketCount(int sugarHolderIndex) {
		return 7;
	}
	public int getPinkPacketCount(int sugarHolderIndex) {
		return 5;
	}
	public int getBluePacketCount(int sugarHolderIndex) {
		return 5;
	}
	// ...
}
</pre>

<P>One solution to the problem in the previous example is to simply move the colored packet class
variables above the static initialization block, as shown below:
<PRE>
// This class compiles happily.
class SugarHolder {
      private int sugarPacketCount;
      private static int sugarPacketsInCafeCount;
      private static int whitePacketsInCafeCount;
      private static int brownPacketsInCafeCount;
      private static int pinkPacketsInCafeCount;
      private static int bluePacketsInCafeCount;
      static {
            // Initialize the total number of sugar packets with
            // state data left over from previous execution of
            // the simulation program.
            int sugarHolderCount =
                  PersistentStorage.getSugarHolderCount();
            for (int i = 0; i < sugarHolderCount; ++i) {
                 sugarPacketsInCafeCount +=
                       PersistentStorage.getSugarPacketCount(i);
                 whitePacketsInCafeCount +=
                       PersistentStorage.getWhitePacketCount(i);
                 brownPacketsInCafeCount +=
                       PersistentStorage.getBrownPacketCount(i);
                 pinkPacketsInCafeCount +=
                       PersistentStorage.getPinkPacketCount(i);
                 bluePacketsInCafeCount +=
                       PersistentStorage.getBluePacketCount(i);
            }
      }
}
</pre>

<P>Another solution is to move the problem-causing portion of the static initialization block code to
another static initialization block that appears textually after the colored packet class variables, as in:
<PRE>
// This class also compiles happily.
class SugarHolder {
      private int sugarPacketCount;
      private static int sugarPacketsInCafeCount;
      static {
            // Initialize the total number of sugar packets with
            // state data left over from previous execution of
            // the simulation program.
            int sugarHolderCount =
                  PersistentStorage.getSugarHolderCount();
            for (int i = 0; i < sugarHolderCount; ++i) {
                 sugarPacketsInCafeCount +=
                       PersistentStorage.getSugarPacketCount(i);
            }
      }
      private static int whitePacketsInCafeCount;
      private static int brownPacketsInCafeCount;
      private static int pinkPacketsInCafeCount;
      private static int bluePacketsInCafeCount;
      static {
            // Initialize the total number of colored packets with
            // state data left over from previous execution of
            // the simulation program.
            int sugarHolderCount =
                  PersistentStorage.getSugarHolderCount();
            for (int i = 0; i < sugarHolderCount; ++i) {
                 whitePacketsInCafeCount +=
                       PersistentStorage.getWhitePacketCount(i);
                 brownPacketsInCafeCount +=
                       PersistentStorage.getBrownPacketCount(i);
                 pinkPacketsInCafeCount +=
                       PersistentStorage.getPinkPacketCount(i);
                 bluePacketsInCafeCount +=
                       PersistentStorage.getBluePacketCount(i);
            }
      }
}
</pre>

<P>[bv: mention things get initialized in textual order?]

<P>As an example of a static initialization block in a class that contains no class variables, consider the
StaticGreeting class below. From outward appearances, this class behaves like a typical "Hello World"
program with a coffee-oriented message. This program, however, manages to print its greeting before the
<CODE>main</CODE> method is ever invoked. Even though the class does not contain any class
variables, the static intialization block will be rolled into a <CODE>&lt;clinit&gt;</CODE>
method. The Java Virtual Machine will execute the <CODE>&lt;clinit&gt;</CODE> method when
the class is initialized, before <CODE>main</CODE> is invoked, and the
<CODE>&lt;clinit&gt;</CODE> method will print out the greeting.
<PRE>
class StaticGreeting {
      public static void main(String args[]) {
      }
      static {
            System.out.println("Wake up and smell the coffee!");
      }
}
</pre>

<P>When executed, the above program prints out:
<PRE>
Wake up and smell the coffee!
</pre>

<P>The example above points out that code within a static initialization block is not limited to just
initializing class variables, but can do anything a regular <CODE>static</CODE> method can do, so
long as it doesn't access class variables that appear textually after it.
Yet as a design guideline, you should try to keep initializers just
focused on initialization.

<H2>Be Careful</H2>

<P>Code within static initalizers can call other static methods in the class, can instantiate an object of its
own type and call instance methods on the object, can call methods in other classes and pass the object to
those methods, all before the class has been completely initialized. This means that you have the power to
write static initialization blocks such that a class is used before it is fully initialized. As a result some class
variables could be used while they still have their default initial values, rather than their proper initial
values. For example, the following program demonstrates one way a class can be used before it is
initialized:
<PRE>
class StaticGreeting2 {
      public static void main(String args[]) {
      }
      static {
            printGreeting();
      }
	String s = "Wake up and smell the coffee!";
      static void printGreeting() {
            System.out.println(s);
      }
}
</pre>

<P>When executed, the above program prints out the following decidedly feeble greeting:
<PRE>
null
</pre>

<P>In the previous example, the static initialization block invoked static method
<CODE>printGreeting</CODE> before <CODE>String s</CODE> was initialized with a cheery
greeting. In effect, the static initialization block used a loophole in the law against referring to class
variables that appear textually later. It invoked a method that refers to the class variable. In so doing, the
class variable is used while it still had its default initial value of <CODE>null</CODE>. When
designing static initialization blocks, you should attempt to ensure that class variables are not used before
they are fully initialized.

<P>Static init blocks can call static methods. So methods can run even when things haven't had their
initializers run. This is true for instance fields too. BUT, because they always have their default value, at
least things are predictable.

<P>[bv: refer to exceptions chapter, as in obj init chapter.]
Static init blocks can't result in checked exceptions being thrown. They can invoke methods that may
throw checked exceptions, but they must catch them. Similar is true for class var initializers.

<H2>The Class Initialization Method</H2>

<P>All the class variable initializers and static initialization blocks of a class are collected by the Java
compiler and placed into one special method, the <EM>class initialization method</em>. This method is
named "<CODE>&lt;clinit&gt;</CODE>". Static initialization blocks and class variable
initializers are executed in textual order, because the code of the <CODE>&lt;clinit&gt;</CODE>
method implements the class variable initializers and static initialization blocks in the order in which they
appear in the class declaration. If a class has no class variable initializers or static initialization blocks, it
will have no <CODE>&lt;clinit&gt;</CODE> method.  The Java Virtual Machine invokes the
<CODE>&lt;clinit&gt;</CODE> method, if it exists, once for each class. Regular methods cannot
invoke a <CODE>&lt;clinit&gt;</CODE> method, because
<CODE>&lt;clinit&gt;</CODE> is not a valid method name in Java. During a class's preparation
phase, the class variables are set to default values. During the initialization phase, the Java Virtual
Machine executes the <CODE>&lt;clinit&gt;</CODE> method, which sets class variables to their
proper initial values.
[bv: mention name spaces]

<H2>When Do Class Variables Get Initialized?</H2>

<P>The Java Virtual Machine initializes classes and interfaces on their first <EM>active use</em>. An
active use is:
<UL>
<LI>The invocation of a method declared by the class (not inherited from a superclass)
<LI>The invocation of a constructor of the class
<LI>The use or assignment of a field declared by a class (not inherited from a superclass), except for fields
that are both <CODE>static</CODE> and <CODE>final</CODE>, and are initialized by a
compile-time constant expression.
</UL>

<P>[bv: perhaps give a nice example of this.]

<H3>Special Treatment for Primitive Constants</H3>

<P>The Java compiler resolves references to fields that are both <CODE>static</CODE> and
<CODE>final</CODE>, and initialized by a compile-time constant expression, to a copy of the
constant value. An example of two constant fields are shown below as part of class
<CODE>CoffeeCup</CODE>. The <CODE>maxCapacity</CODE> field is initialized by a compile-
time constant, but the <CODE>currentCoffeeAmount</CODE> field is not. References to the
<CODE>maxCapacity</CODE> field are compiled to refer directly to a constant pool entry with the
constant value 250. The <CODE>maxCapacity</CODE> field is not initialized by the
<CODE>&lt;clinit&gt;</CODE> method. However, because the constant value of
<CODE>currentCoffeeAmount</CODE> is not known at compile time, it must be initialized by
<CODE>&lt;clinit&gt;</CODE>. The Java Virtual Machine will execute the
<CODE>&lt;clinit&gt;</CODE> method during the initialization phase of the class, and the
<CODE>&lt;clinit&gt;</CODE> method will invoke <CODE>Math.random</CODE>, multiply
the result by 250, and assign <CODE>currentCoffeeAmount</CODE> its initial value, which will
thereafter remain constant.
<PRE>
class CoffeeCup {
	static final int maxCapacity = 250; // milliliters
	static final int currentCoffeeAmount =
            (int) (Math.random() * 250d);
}
</pre>

<P>The use or assignment of a <CODE>static</CODE>, <CODE>final</CODE> field is not an
active use of a class, because such fields are not initialized via the <CODE>&lt;clinit&gt;</CODE>
method. A constant field is a class variable that is declared <CODE>final</CODE> as well as
<CODE>static</CODE>, and is initialized with a compile-time constant expression. Such fields are
resolved to constant expressions To initialize a class, the Java Virtual Machine executes the class's
<CODE>&lt;clinit&gt;</CODE> method, if it has one. A class's superclass must be initialized
before the class is initialized, so the Java Virtual Machine will invoke the
<CODE>&lt;clinit&gt;</CODE> methods of the class's superclass if it hasn't yet been invoked.
The code of a <CODE>&lt;clinit&gt;</CODE> method does not explicitly invoke a superclass's
<CODE>&lt;clinit&gt;</CODE> method, therefore the Java Virtual Machine must make certain
the <CODE>&lt;clinit&gt;</CODE> methods of superclasses have been executed before it invokes
the <CODE>&lt;clinit&gt;</CODE> method of a class.

<P>To initialize an interface, the Java Virtual Machine executes the interface's
<CODE>&lt;clinit&gt;</CODE> method, if it has one, just as it does for classes. An interface may
have a <CODE>&lt;clinit&gt;</CODE> method because interfaces can contain constants. In
interfaces, constants are <CODE>public</CODE>, <CODE>final</CODE>,
<CODE>static</CODE> variables. The variables must have an initialization expression, which is the
interface version of a class variable initializer. Interfaces cannot have static initialization blocks. As with
classes, only initializers that require evaluation of expressions that are not compile-time constants will end
up as code in the <CODE>&lt;clinit&gt;</CODE> method. Therefore, if an interface has at least
one constant that is initialized by an expression that is not a compile time constant, that interface will
have a <CODE>&lt;clinit&gt;</CODE> method. Initialization of an interface does not require
prior initialization of its superinterfaces.

<P>[SHOW THAT THESE ARE PUT INTO SEPARATE CLASS FILES AND THAT THEY ARE
USED BY THE CASE STATEMENTS OF SWITCHES, AND TO DO CONDITIONAL
COMPILATION.]

<H2>The End of an Object's Life</H2>

<P>This chapter shows you how to ensure proper cleanup of objects at the end of their lives. It
discusses garbage collection, finalizers, and cleanup routines to release non-memory resources.
<P>Here, "end of an object's lifetime" does not mean when an object is garbage collected, but when
your program stops using it. If your object's validity depends upon its exclusive hold on a non-memory
resource, such as a file handle, your object should release that resource not upon garbage collection, but
upon
<P>	Class FileOutputStream is the perfect example of a cleanup method (close()) and the double
checking done by a finalizer.
<P>[MENTION freeMemory(), and totalMemory() in Runtime and runFinalization(), gc() in both System and
Runtime.]
<P>[A] Cleanup
 <P> Cleanup is about releasing resources at the end of an object's life.
<P>I. Cleanup is important because objects use finite resources which must be released back to the system at
the end of an object's life. Certainly memory, possibly other resources. Java has a garbage collector to
clean up memory. You must write Java code to clean up any non-memory resource, including possibly
a special method called a finalizer which is automatically run by the garbage collector when the
object is reclaimed.

<P>[B] The Garbage Collector
<P>I. Paint a general picture of the garbage collector
<P>II. Explain when finalize() is called by the garbage collector. Perhaps paint a picture of the garbage
collection session.
<P>III. Objects may never get garbage collected. A lot of times garbage collection happens only when the
system runs out of memory. If it doesn't ever run out of memory, it doesn't ever garbage collect.
<P>IV. You can give the gc a hint that this would be a good time to run.
<P>V. Finalizers may or may not be run on exit, depending upon the runFinalizersOnExit() parameter of
System? Did this get into Java 1.1?
<P>VI. Describe the process of first pass, second pass.
<P>[B] Finalizers
<P>I. Finalizers can help if you allocate memory in native methods.
<P>II. Could use finalizers to release memory created in some other way than by calling new. (For example,
in native methods.) "Finalizers are about memory." That's all they should be worrying about.
<P>III. Finalizers can use try/catch to handle any exceptions thrown during their execution. Any uncaught
exceptions thrown by the finalizer itself are ignored by the JVM.
<P>IV. Don't resurrect objects. Clone() an existing one if you have to.
<P>V. Finalizer() is called only once by the garbage collector. So if you resurrect it, and then it gets garbage
collected again, finalizer() won't get called the second time.
<P>VI. The possibility of object resurrection shows that the gc must do another marking process after the
finalizers have been run.
<P>VII. Always invoke super.finalize() at the end of your finalizer().
<P>[B] Why use a finalizer?
<P>1) Not very many compelling reasons. Most of the time, don't.
<P>2) Give an example of using the finalizer to double check on a sloppy programmer who didn't call
close() or cleanup(). (Talk about just opening the file when you need it, using it, then closing it all in
one method. In other words, the file handle is not part of the object's long term state. In this case, you
don't have to worry about close(), cleanup(), or finalize(). But if it takes up too much time to do all
that openning and closing...)
<P>3) One of the few things finalizers are good for is to keep track of data about the garbage collector's
performance. Another is for freeing memory that was allocated via native methods. Even this,
however, should be able to fit into a cleanUp() method.
<P>4) Even though Object() has a protected finalize(), that doesn't mean the the Java Virtual Machine will
always call it. Java Virtual Machine implementations should be smart about figuring out whether you
actually override it or even do something useful in the overridden guy.
<P>[B] Strategies for ensuring the release of non-memory resources
Clean up: Another area in which the garbage collector will influence your designs and
implementations is in object clean up. In C++ there is a destructor that does the opposite job of the
constructor. The destructor's primary use is to explicitly free any memory pointed to by data members of
the object. There is, of course, no need to do this in Java, because the garbage collector takes care of
freeing memory. However, C++ destructors were also used to release any non-memory resources, such as
file handles or graphic display contexts, that may have been used by the object. It is important to release
resources such as these, because there is a finite number of them available to the program. If you do not
release these kinds of resources when you are done with them, your program may run out of them. In Java,
such resources are not released by the garbage collector, so the programmer must release them explicitly.
Because Java objects have no destructors, the design challenge becomes one of making sure non-memory
resources will be released when an object doesn't need them anymore.
<P>A straightforward solution is to design objects that don't hang onto a resource for their entire
lifetimes. Instead, aim for objects that grab a resource only when it is needed during a method invocation,
and then release the resource before returning from the method. Objects designed in this way don't need
cleanup. However, this won't work in all cases. So, when you have an object that requires a release of non-
memory resources upon the object's "death," you should define a method that performs this service, and
invoke it on your object when your program no longer needs the object. This method will end up being
invoked where you would have explicitly deallocated an object in a non-garbage-collected language such
as C++. So it resurrects that old problem of figuring out when an object is no longer needed. You'll
probably want to write this function to recognize that it has been accidentally called twice and either
throw an exception or ignore the second call. Also, you could even put a check in the finalizer of the class
to make sure the cleanup routine has been called. If it hasn't been called, the finalizer could call it.
<P>Finalizers: This brings us to finalizers. You may be wondering, why can't a finalizer be used for
clean up? Isn't it kind of like a destructor? It turns out that often the best finalizer is no finalizer.
<P>Finalizers are guaranteed to be called before the memory used by an object is reclaimed.
However, there is no guarantee that any object's memory will ever be reclaimed. Hence, there is no
guarantee that a finalizer will ever be called. (There is a promise that, barring catastrophic error
conditions, all finalizers will be run on any left-over objects when the Java Virtual Machine exits;
However, this likely too late if your program is waiting for a file handle to be released. (Besides, I'm not
convinced it happens anyway.)) Therefore, it is vital that you never rely on a finalizer to free finite
resources, such as file handles, that may be needed later by your program.
<P>You might be tempted to use the finalizer as your clean up routine, given that it is perfectly legal
in Java to invoke a finalizer explicitly just like any other method. You could write the finalizer such that it
does the clean up the first time it is invoked, and does nothing any subsequent time it is invoked. In this
way it would serve as a fail safe in case you ever forget to invoke it explicitly. However, this is not the best
approach because finalizers require CPU time to run. (One finalizer that just checks an instance variable,
discovers the method has already been finalized, and returns won't take too long. But if your program
generates 1,000,000 of those objects, the small amount of time for each could add up to something
significant.) Also, objects without finalizers are "easier" for the garbage collector to dispose of. The heap
space for an object might get reclaimed sooner if that object doesn't have a finalizer. (Explain the
process?) Therefore, it is usually better that clean up be done by a method that is not the finalizer, so that
clean up is done in a program thread, not a garbage collector thread. In this manner you can retain control
of precisely when the clean up happens, and ease the garbage collector's demands on CPU time.
<P>[A] Memory Management
<P>Stress: One last thing you need to keep in mind in your designs and implementations is the
garbage collector's stress level. If your program is generating millions of little objects and discarding them
shortly after their creation, you could be placing a heavy burden on the garbage collector, which could
degrade the performance of your program. Because each Java Virtual Machine can implement its garbage
collector differently, giving lots of work to the garbage collector can affect your program's performance
differently on different platforms. One way to combat this is to redesign your program so it doesn't create
millions of little objects with short lifetimes. If this is not possible, you may want to create a container
class that allows you to reuse little objects that have come to the end of their short lifetimes. By reusing an
object, rather than discarding it and allocating a new one, you reduce the garbage collector's work load.
  Garbage collection doesn't solve all memory management problems. You could still run out of
memory, and you could still have a memory leak.
  Don't leave unused references to objects lying around. Null out the reference.
  It's OK to return something you allocated.
A garbage-collected heap solves certain design dilemmas common in environments where
programmers must do their own deallocation, such as returning objects created by a method.
Returning objects: Having a garbage-collected heap allows you to treat objects in your Java
programs a bit more like you treat them in the real world. In a language such as C or C++, where the
programmer must explicitly deallocate memory, there is a pesky design issue whenever a function needs to
return a pointer to some memory that it allocated. It is common among programmers to consider such a
function unfriendly, because the function requires some other function to free the memory it allocated.
Idealists pontificate about the virtuous program in which all functions, before returning, free any
memory that they allocate. Indeed this is a worthy goal, but unfortunately not always practical. In Java,
the issue goes away. If you find yourself in a similar situation in a Java program, just create the new object
and return it. When the recipient of the object is done with it, the garbage collector will take care of
freeing the memory. A good example is a method from which you want to return several ints. In Java, you
can guiltlessly allocate an array of ints and return the array. When the program is done with the array
object, the garbage collector will reclaim the memory.

Can say: A Java object does not have a destructor, like C++ objects. Given
the architecture of the JVM, Java object lives to not have clean, well-defined
ends. Where a C++ object experiences a traumatic and sudden death, a
Java object kind of fades away.

<P><FONT SIZE="+1"><STRONG>Why clean up?</STRONG></FONT><BR>
Every object in a Java program uses computing resources that are
finite. Most obviously, all objects use some memory to store their
images on the heap. (This is true even for objects that declare no
instance variables. Each object image must include some kind of pointer
to class data, and can include other implementation-dependent
information as well.) But objects may also use other finite resources
besides memory. For example, some objects may use resources such as
file handles, graphics contexts, sockets, and so on. When you design an
object, you must make sure it eventually releases any finite
resources it uses so the system won't run out of those resources.

<P>
Because Java is a garbage-collected language, releasing the memory
associated with an object is easy. All you need to do is let go of all
references to the object. Because you don't have to worry about
explicitly freeing an object, as you must in languages such as C or
C++, you needn't worry about corrupting memory by accidentally freeing
the same object twice. You do, however, need to make sure you actually
release all references to the object. If you don't, you can end up with
a memory leak, just like the memory leaks you get in a C++ program when
you forget to explicitly free objects. Nevertheless, so long as you
release all references to an object, you needn't worry about explicitly
"freeing" that memory.

<P>
Similarly, you needn't worry about explicitly freeing any constituent
objects referenced by the instance variables of an object you no longer
need. Releasing all references to the unneeded object will in effect
invalidate any constituent object references contained in that object's
instance variables. If the now-invalidated references were the only
remaining references to those constituent objects, the constituent
objects will also be available for garbage collection. Piece of cake,
right?

<P>
<FONT SIZE="+1"><STRONG>The rules of garbage collection</STRONG></FONT><BR>
Although garbage collection does indeed make memory management in Java
a lot easier than it is in C or C++, you aren't able to completely
forget about memory when you program in Java. To know when you may need
to think about memory management in Java, you need to know a bit about
the way garbage collection is treated in the Java specifications.

<P>
<STRONG>Garbage collection is not mandated</STRONG><BR>
The first thing to know is that no matter how diligently you search
through the Java Virtual Machine Specification (JVM Spec), you won't be able
to find any sentence that commands, <EM>Every JVM must have a garbage
collector.</em> The Java Virtual Machine Specification gives VM designers a
great deal of leeway in deciding how their implementations will manage
memory, including deciding whether or not to even use garbage
collection at all. Thus, it is possible that some JVMs (such as a
bare-bones smart card JVM) may require that programs executed in each
session "fit" in the available memory.

<P>
Of course, you can always run out of memory, even on a virtual memory
system. The JVM Spec does not state how much memory will be available
to a JVM. It just states that whenever a JVM <EM>does</em> run out of
memory, it should throw an <CODE>OutOfMemoryError</CODE>.

<P>
Nevertheless, to give Java applications the best chance of executing
without running out of memory, most JVMs will use a garbage collector.
The garbage collector reclaims the memory occupied by unreferenced
objects on the heap, so that memory can be used again by new objects,
and usually de-fragments the heap as the program runs.

<P>
<STRONG>Garbage collection algorithm is not defined</STRONG><BR>
Another command you won't find in the JVM specification is <EM>All JVMs
that use garbage collection must use the XXX algorithm.</em> The designers
of each JVM get to decide how garbage collection will work in their
implementations. Garbage collection algorithm is one area in which JVM
vendors can strive to make their implementation better than the
competition's. This is significant for you as a Java programmer for the
following reason:

<P>
<EM>Because you don't generally know how garbage collection
will be performed inside a JVM, you don't know when any particular object will
be garbage collected.</em>

<P>
So what? you might ask. The reason you might care when an object is
garbage collected has to do with finalizers. (A <EM>finalizer</em> is
defined as a regular Java instance method named <CODE>finalize()</CODE>
that returns void and takes no arguments.) The Java specifications make
the following promise about finalizers:

<P>
<EM>Before reclaiming the memory occupied by an object that has a
finalizer, the garbage collector will invoke that object's finalizer.</em>

<P>
Given that you don't know when objects will be garbage collected, but
you do know that finalizable objects will be finalized as they are
garbage collected, you can make the following grand deduction:

<P>
<EM>You don't know when objects will be finalized.</em>

<P>
You should imprint this important fact on your brain and forever allow
it to inform your Java object designs.

<P>
<FONT SIZE="+1"><STRONG>Finalizers to avoid</STRONG></FONT><BR>
The central rule of thumb concerning finalizers is this:

<P>
<EM>Don't design your Java programs such that correctness depends upon
"timely" finalization.</em>

<P>
In other words, don't write programs that will break if certain objects
aren't finalized by certain points in the life of the program's
execution. If you write such a program, it may work on some
implementations of the JVM but fail on others.

<P>
<STRONG>Don't rely on finalizers to release non-memory resources</STRONG><BR>
An example of an object that breaks this rule is one that opens a file
in its constructor and closes the file in its <CODE>finalize()</CODE>
method. Although this design seems neat, tidy, and symmetrical, it
potentially creates an insidious bug. A Java program generally will
have only a finite number of file handles at its disposal. When all
those handles are in use, the program won't be able to open any more
files.

<P>
A Java program that makes use of such an object (one that opens a file
in its constructor and closes it in its finalizer) may work fine on
some JVM implementations. On such implementations, finalization would
occur often enough to keep a sufficient number of file handles
available at all times. But the same program may fail on a different
JVM whose garbage collector doesn't finalize often enough to keep the
program from running out of file handles. Or, what's even more
insidious, the program may work on all JVM implementations now but
fail in a mission-critical situation a few years (and release cycles)
down the road.

<P>
<STRONG>Other finalizer rules of thumb</STRONG><BR>
Two other decisions left to JVM designers are selecting the thread (or
threads) that will execute the finalizers and the order in which
finalizers will be run. Finalizers may be run in any order --
sequentially by a single thread or concurrently by multiple threads. If
your program somehow depends for correctness on finalizers being run in
a particular order, or by a particular thread, it may work on some JVM
implementations but fail on others.

<P>
You should also keep in mind that Java considers an object to be
finalized whether the <CODE>finalize()</CODE> method returns normally
or completes abruptly by throwing an exception. Garbage collectors
ignore any exceptions thrown by finalizers and in no way notify the
rest of the application that an exception was thrown. If you need to
ensure that a particular finalizer fully accomplishes a certain
mission, you must write that finalizer so that it handles any
exceptions that may arise before the finalizer completes its mission.

<P>
One more rule of thumb about finalizers concerns objects left on
the heap at the end of the application's lifetime. By default, the
garbage collector will not execute the finalizers of any objects left
on the heap when the application exits. To change this default, you
must invoke the <CODE>runFinalizersOnExit()</CODE> method of class
<CODE>Runtime</CODE> or <CODE>System</CODE>, passing <CODE>true</CODE>
as the single parameter. If your program contains objects whose
finalizers must absolutely be invoked before the program exits, be sure
to invoke <CODE>runFinalizersOnExit()</CODE> somewhere in your
program.

<P>
<FONT SIZE="+1"><STRONG>So what are finalizers good for?</STRONG></FONT><BR>
By now you may be getting the feeling that you don't have much use for
finalizers. While it is likely that most of the classes you design
won't include a finalizer, there are some reasons to use finalizers.

<P>
One reasonable, though rare, application for a finalizer is to free
memory allocated by native methods. If an object invokes a native
method that allocates memory (perhaps a C function that calls
<CODE>malloc()</CODE>), that object's finalizer could invoke a native
method that frees that memory (calls <CODE>free()</CODE>). In this
situation, you would be using the finalizer to free up memory allocated
on behalf of an object -- memory that will not be automatically
reclaimed by the garbage collector.

<P>
Another, more common, use of finalizers is to provide a fallback
mechanism for releasing non-memory finite resources such as file
handles or sockets. As mentioned previously, you shouldn't rely on
finalizers for releasing finite non-memory resources. Instead, you
should provide a method that will release the resource.  But you may
also wish to include a finalizer that checks to make sure the resource
has already been released, and if it hasn't, that goes ahead and
releases it. Such a finalizer guards against (and hopefully will not
encourage) sloppy use of your class. If a client programmer forgets to
invoke the method you provided to release the resource, the
finalizer will release the resource if the object is ever garbage
collected. The <CODE>finalize()</CODE> method of the
<CODE>LogFileManager</CODE> class, shown later in this article, is an
example of this kind of finalizer.

<P>
<FONT SIZE="+1"><STRONG>Avoid finalizer abuse</STRONG></FONT><BR>
The existence of finalization produces some interesting complications
for JVMs and some interesting possibilities for Java programmers. For a
discussion of the impact of finalizers on JVMs, see the <A name="return1" href="#sidebar1">sidebar</A>, a short excerpt from chapter 9,
"Garbage Collection," of my book, <A href="http://www.artima.com/insidejvm/blurb.html"><EM>Inside the Java
Virtual Machine</em></A>.

<P>
What finalization grants to programmers is power over the life and
death of objects. In short, it is possible and completely legal in Java
to resurrect objects in finalizers -- to bring them back to life by
making them referenced again. (One way a finalizer could accomplish
this is by adding a reference to the object being finalized to a static
linked list that is still "live.") Although such power may be tempting
to exercise because it makes you feel important, the rule of thumb is
to resist the temptation to use this power. In general, resurrecting
objects in finalizers constitutes finalizer abuse.

<P>
The main justification for this rule is that any program that uses
resurrection can be redesigned into an easier-to-understand program
that doesn't use resurrection. A formal proof of this theorem is left
as an exercise to the reader (I've always wanted to say that), but in
an informal spirit, consider that object resurrection will be as random
and unpredictable as object finalization. As such, a design that uses
resurrection will be difficult to figure out by the next maintenance
programmer who happens along -- who may not fully understand the
idiosyncrasies of garbage collection in Java.

<P>
If you feel you simply must bring an object back to life, consider
cloning a new copy of the object instead of resurrecting the same old
object. The reasoning behind this piece of advice is that garbage
collectors in the JVM invoke the <CODE>finalize()</CODE> method of an
object only once. If that object is resurrected and becomes
available for garbage collection a second time, the object's
<CODE>finalize()</CODE> method will not be invoked again.

<P>
<FONT SIZE="+1"><STRONG>Managing non-memory resources</STRONG></FONT><BR>
Because heap memory is automatically reclaimed by the garbage
collector, the main thing you need to worry about when you design an
object's end-of-lifetime behavior is to ensure that finite non-memory
resources, such as file handles or sockets, are released. You can take
any of three basic approaches when you design an object that needs to
use a finite non-memory resource:

<P>
<OL>
<LI>Obtain and release the resource within each method that needs the resource
<LI>Provide a method that obtains the resource and another that releases it
<LI>Obtain the resource at creation time and provide a method that releases it
</OL>

<P>
<FONT SIZE="+1"><STRONG>Approach 1: Obtain and release within each relevant method</STRONG></FONT><BR>
As a general rule, the releasing of non-memory finite resources should
be done as soon as possible after their use because the resources are,
by definition, finite. If possible, you should try to obtain a
resource, use it, then release it all within the method that needs the
resource.

<P>
<STRONG>A log file class: An example of Approach 1</STRONG><BR>
An example of a class where Approach 1 might make sense is a log file
class. Such a class takes care of formatting and writing log messages
to a file. The name of the log file is passed to the object as it is
instantiated. To write a message to the log file, a client invokes a
method in the log file class, passing the message as a
<CODE>String</CODE>. Here's an example:

<P>
<PRE>
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.IOException;

class LogFile {

    private String fileName;

    LogFile(String fileName) {
        this.fileName = fileName;
    }

    // The writeToFile() method will catch any IOException
    // so that clients aren't forced to catch IOException
    // everywhere they write to the log file.  For now,
    // just fail silently. In the future, could put
    // up an informative non-modal dialog box that indicates
    // a logging error occurred. - bv 4/15/98
    void writeToFile(String message) {

        FileOutputStream fos = null;
        PrintWriter pw = null;

        try {
            fos = new FileOutputStream(fileName, true);
            try {
                pw = new PrintWriter(fos, false);

                pw.println("------------------");
                pw.println(message);
                pw.println();
            }
            finally {
                if (pw != null) {
                    pw.close();
                }
            }
        }
        catch (IOException e) {
        }
        finally {
            if (fos != null) {
                try {
                    fos.close();
                }
                catch (IOException e) {
                }
            }
        }
    }
}

</pre>

<P>
Class <CODE>LogFile</CODE> is a simple example of Approach 1. A more
production-ready <CODE>LogFile</CODE> class might do things such as:

<P>
<UL>
<LI>Insert the date and time each log message was written

<P>
<LI>Allow messages to be assigned a level of importance (such as ERROR,
INFO, or DEBUG) and enable a level to be set that will prevent unwanted
detail (such as DEBUG messages) from making it into the log file

<P>
<LI>Manage in some way the size of the log file, i.e., by copying it
to a different filename and starting fresh each time the log file
achieves a certain size
</UL>

<P>
The main feature of this simple version of class <CODE>LogFile</CODE>
is that it surrounds each log message with a series of dashes and a
blank line.

<P>
<STRONG>Using <EM>finally</em> to ensure resource release</STRONG><BR>
Note that in the <CODE>writeToFile()</CODE> method, the releasing of
the resource is done in finally clauses. This is to make sure the
finite resource (file handle) is actually released no matter how the
code is exited. If an <CODE>IOException</CODE> is thrown, the file will
be closed.

<P>
<STRONG>Pros and cons of Approach 1</STRONG><BR>
The approach to resource management taken by class <CODE>LogFile</CODE>
(Approach 1 from the above list) helps make your class easy to use,
because client programmers don't have to worry about explicitly
obtaining or releasing the resource. In both Approach 2 and 3 from the list above
client programmers must remember to explicitly invoke a
method to release the resource. In addition -- and what can be far more
difficult -- client programmers must figure out when their programs no
longer need a resource.

<P>
A problem with Approach 1 is that obtaining and releasing the
resource each time you need it may be too inefficient. Another problem
is that, in some situations, you may need to hold onto the resource
between invocations of methods that use the resource (such as
<CODE>writeToFile()</CODE>), so no other object can have access to it.
In such cases, one of the other two approaches is preferable.

<P>
<FONT SIZE="+1"><STRONG>Approach 2: Offer methods for obtaining and releasing resources</STRONG></FONT><BR>
In Approach 2 from the list above, you provide one method for
obtaining the resource and another method for releasing it.  This
approach enables the same class instance to obtain and release a
resource multiple times. Here's an example:

<P>
<PRE>
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.IOException;

class LogFileManager {

    private FileOutputStream fos;
    private PrintWriter pw;
    private boolean logFileOpen = false;

    LogFileManager() {
    }

    LogFileManager(String fileName) throws IOException {
        openLogFile(fileName);
    }

    void openLogFile(String fileName) throws IOException {
        if (!logFileOpen) {
            try {
                fos = new FileOutputStream(fileName, true);
                pw = new PrintWriter(fos, false);
                logFileOpen = true;
            }
            catch (IOException e) {
                if (pw != null) {
                    pw.close();
                    pw = null;
                }
                if (fos != null) {
                    fos.close();
                    fos = null;
                }
                throw e;
            }
        }
    }

    void closeLogFile() throws IOException {
        if (logFileOpen) {
            pw.close();
            pw = null;
            fos.close();
            fos = null;
            logFileOpen = false;
        }
    }

    boolean isOpen() {
        return logFileOpen;
    }

    void writeToFile(String message) throws IOException {

        pw.println("------------------");
        pw.println(message);
        pw.println();
    }

    protected void finalize() throws Throwable {
        if (logFileOpen) {
            try {
                closeLogFile();
            }
            finally {
                super.finalize();
            }
        }
    }
}
</pre>

<P>
In this example, class <CODE>LogFileManager</CODE> declares methods
<CODE>openLogFile()</CODE> and <CODE>closeLogFile()</CODE>. Given this
design, you could write to multiple log files with one instance of this
class. This design also allows a client to monopolize the resource for
as long as it wants. A client can write several consecutive messages to
the log file without fear that another thread or process will slip in
any intervening messages. Once a client successfully opens a log file
with <CODE>openLogFile()</CODE>, that log file belongs exclusively to
that client until the client invokes <CODE>closeLogFile()</CODE>.

<P>
Note that <CODE>LogFileManager</CODE> uses a finalizer as a fallback
in case a client forgets to invoke <CODE>closeLogFile()</CODE>. As
mentioned earlier in this article, this is one of the more common uses
of finalizers.

<P>
Note also that after invoking <CODE>closeLogFile()</CODE>,
<CODE>LogFileManager</CODE>'s finalizer invokes
<CODE>super.finalize()</CODE>. Invoking superclass finalizers is good
practice in any finalizer, even in cases (such as this) where no
superclass exists other than <CODE>Object</CODE>. The JVM does not
automatically invoke superclass finalizers, so you must do so
explicitly. If someone ever inserts a class that declares a finalizer
between <CODE>LogFileManager</CODE> and <CODE>Object</CODE> in the
inheritance hierarchy, the new object's finalizer will already be
invoked by <CODE>LogFileManager</CODE>'s existing finalizer.

<P>
Making <CODE>super.finalize()</CODE> the last action of a finalizer
ensures that subclasses will be finalized before superclasses. Although
in most cases the placement of <CODE>super.finalize()</CODE> won't
matter, in some rare cases, a subclass finalizer may require that its
superclass be as yet unfinalized. So, as a general rule of thumb, place
<CODE>super.finalize()</CODE> last.

<P>
<FONT SIZE="+1"><STRONG>Approach 3: Claim resource on creation, offer method for release</STRONG></FONT><BR>
In the last approach, Approach 3 from the above list, the object
obtains the resource upon creation and declares a method that releases
the resource. Here's an example:

<P>
<PRE>
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.IOException;

class LogFileTransaction {

    private FileOutputStream fos;
    private PrintWriter pw;
    private boolean logFileOpen = false;

    LogFileTransaction(String fileName) throws IOException {
        try {
            fos = new FileOutputStream(fileName, true);
            pw = new PrintWriter(fos, false);
            logFileOpen = true;
        }
        catch (IOException e) {
            if (pw != null) {
                pw.close();
                pw = null;
            }
            if (fos != null) {
                fos.close();
                fos = null;
            }
            throw e;
        }
    }

    void closeLogFile() throws IOException {
        if (logFileOpen) {
            pw.close();
            pw = null;
            fos.close();
            fos = null;
            logFileOpen = false;
        }
    }

    boolean isOpen() {
        return logFileOpen;
    }

    void writeToFile(String message) throws IOException {

        pw.println("------------------");
        pw.println(message);
        pw.println();
    }

    protected void finalize() throws Throwable {
        if (logFileOpen) {
            try {
                closeLogFile();
            }
            finally {
                super.finalize();
            }
        }
    }
}
</pre>

<P>
This class is called <CODE>LogFileTransaction</CODE> because every time
a client wants to write a chunk of messages to the log file (and then
let others use that log file), it must create a new
<CODE>LogFileTransaction</CODE>. Thus, this class models one
transaction between the client and the log file.

<P>
One interesting thing to note about Approach 3 is that this is the
approach used by the <CODE>FileOutputStream</CODE> and
<CODE>PrintWriter</CODE> classes used by all three example log file
classes. In fact, if you look through the <CODE>java.io</CODE> package,
you'll find that almost all of the <CODE>java.io</CODE> classes that
deal with file handles use Approach 3. (The two exceptions are
<CODE>PipedReader</CODE> and <CODE>PipedWriter</CODE>, which use
Approach 2.)

<H2>Behind the Scenes</H2>
<P>
The <CODE>&lt;init&gt;</CODE> method is not actually part of the Java
language. Rather, it is something the Java virtual machine expects to
see in a Java class file. This distinction is significant because the
Java language does not depend on the class file. Java source can be
compiled into other binary formats, including native executables. A
Java compiler that translates Java language source into some other
binary format need not generate a method named
<CODE>&lt;init&gt;</CODE>, so long as objects are initialized in the
proper way at the proper time. The Java Language Specification (JLS) details
the order of initialization and when it occurs, but doesn't say how it
is actually accomplished.
 Still,
understanding how initialization works inside class files can help you
understand the order of initialization in the language.

<H3>Special Treatment for Primitive Constants</H3>

<P>The Java compiler resolves references to fields that are both <CODE>static</CODE> and
<CODE>final</CODE>, and initialized by a compile-time constant expression, to a copy of the
constant value. An example of two constant fields are shown below as part of class
<CODE>CoffeeCup</CODE>. The <CODE>maxCapacity</CODE> field is initialized by a compile-
time constant, but the <CODE>currentCoffeeAmount</CODE> field is not. References to the
<CODE>maxCapacity</CODE> field are compiled to refer directly to a constant pool entry with the
constant value 250. The <CODE>maxCapacity</CODE> field is not initialized by the
<CODE>&lt;clinit&gt;</CODE> method. However, because the constant value of
<CODE>currentCoffeeAmount</CODE> is not known at compile time, it must be initialized by
<CODE>&lt;clinit&gt;</CODE>. The Java Virtual Machine will execute the
<CODE>&lt;clinit&gt;</CODE> method during the initialization phase of the class, and the
<CODE>&lt;clinit&gt;</CODE> method will invoke <CODE>Math.random</CODE>, multiply
the result by 250, and assign <CODE>currentCoffeeAmount</CODE> its initial value, which will
thereafter remain constant.
<PRE>
class CoffeeCup {
	static final int maxCapacity = 250; // milliliters
	static final int currentCoffeeAmount =
            (int) (Math.random() * 250d);
}
</pre>

<P>The use or assignment of a <CODE>static</CODE>, <CODE>final</CODE> field is not an
active use of a class, because such fields are not initialized via the <CODE>&lt;clinit&gt;</CODE>
method. A constant field is a class variable that is declared <CODE>final</CODE> as well as
<CODE>static</CODE>, and is initialized with a compile-time constant expression. Such fields are
resolved to constant expressions To initialize a class, the Java Virtual Machine executes the class's
<CODE>&lt;clinit&gt;</CODE> method, if it has one. A class's superclass must be initialized
before the class is initialized, so the Java Virtual Machine will invoke the
<CODE>&lt;clinit&gt;</CODE> methods of the class's superclass if it hasn't yet been invoked.
The code of a <CODE>&lt;clinit&gt;</CODE> method does not explicitly invoke a superclass's
<CODE>&lt;clinit&gt;</CODE> method, therefore the Java Virtual Machine must make certain
the <CODE>&lt;clinit&gt;</CODE> methods of superclasses have been executed before it invokes
the <CODE>&lt;clinit&gt;</CODE> method of a class.

<P>To initialize an interface, the Java Virtual Machine executes the interface's
<CODE>&lt;clinit&gt;</CODE> method, if it has one, just as it does for classes. An interface may
have a <CODE>&lt;clinit&gt;</CODE> method because interfaces can contain constants. In
interfaces, constants are <CODE>public</CODE>, <CODE>final</CODE>,
<CODE>static</CODE> variables. The variables must have an initialization expression, which is the
interface version of a class variable initializer. Interfaces cannot have static initialization blocks. As with
classes, only initializers that require evaluation of expressions that are not compile-time constants will end
up as code in the <CODE>&lt;clinit&gt;</CODE> method. Therefore, if an interface has at least
one constant that is initialized by an expression that is not a compile time constant, that interface will
have a <CODE>&lt;clinit&gt;</CODE> method. Initialization of an interface does not require
prior initialization of its superinterfaces.

<P>[SHOW THAT THESE ARE PUT INTO SEPARATE CLASS FILES AND THAT THEY ARE
USED BY THE CASE STATEMENTS OF SWITCHES, AND TO DO CONDITIONAL
COMPILATION.]

</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/objectsandjava/webuscript/InitCleanup1.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
