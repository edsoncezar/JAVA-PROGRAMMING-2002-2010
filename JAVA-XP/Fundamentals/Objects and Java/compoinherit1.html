<HTML>
<HEAD>
<TITLE>Composition and Inheritance: Chapter 6 of Objects and Java</TITLE>
<META name="description" content="How to design classes with composition and inheritance.">
<META name="keywords" content="Java Design, Java Book, Object Oriented Design, Thread Safe Design">
<LINK rel="stylesheet" type="text/css" href="http://www.artima.com/artima.css">
</HEAD>
<BODY text="#000000" alink="#663300">
<TABLE width="100%" cellspacing="0">
<TR>
<TD align="left" valign="bottom">
<A href="http://www.artima.com/index.jsp"><IMG src="..\..\images\ab.gif" alt="artima.com" border="0" width="150" height="31"></A>
</TD>
<TD align="right">
<a href="http://www.artima.com/cgi-bin/redirect.cgi/a6cfe006?REGION=Brown&CAMPAIGN=Default&ACCOUNT=Artima&BANNER=ArtimaTraining" ><img src="..\..\cgi-bin\getimage.cgi\a6cfe006\region=brown&campaign=default&account=artima&banne" border=0 width=468 height=60 alt="ad" ></a>
</TD>
</TR>
</TABLE>
<TABLE width="100%" bgcolor="#663300">
<TR>
<TD align="center">
<DIV class="ml">
<A href="http://www.artima.com/search.html" class="hl">Search</A>&nbsp;|
<A href="http://www.artima.com/java/index.html" class="hl">Java</A>&nbsp;|
<A href="http://www.artima.com/javadesign/index.html" class="hl">Design</A>&nbsp;|
<A href="http://www.artima.com/jvm/index.html" class="hl">JVM</A>&nbsp;|
<A href="http://www.artima.com/jini/index.html" class="hl">Jini</A>&nbsp;|
<A href="http://www.artima.com/forums/index.jsp" class="hl">Forums</A>&nbsp;|
<A href="http://www.artima.com/javaseminars/index.html" class="hl">Seminars</A>&nbsp;|
<A href="http://lists.artima.com/mailman/listinfo/artima-newsletter/" class="hl">Subscribe</A>
</DIV>
</TD>
</TR>
</TABLE>
<BR>
<DIV class="vegies">
<DIV class="tc">
<SPAN class="sts">Objects and Java by Bill Venners</SPAN><BR>
<SPAN class="sts">Chapter 6:</SPAN><BR>
<SPAN class="ts">Composition and Inheritance</SPAN><BR>
</DIV>

<!--BEGIN_OAJBOOK_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="http://www.artima.com/objectsandjava/index.html">Objects and Java</A>&nbsp;|
<A href="index.html">Contents</A>&nbsp;|
<A href="packagesaccess1.html">Previous</A>&nbsp;|
<A href="polymorphisminterfaces1.html">Next</A>&nbsp;
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_OAJBOOK_LINKS-->

<P>Modeling the relationships between types is a fundamental part of the process of object-oriented
design. This chapter shows you how to model relationships using composition and inheritance. It
describes many facets of inheritance in Java, including abstract classes and final classes.
[bv:need better intro]
<H2> Composition</H2>

<P>As you progress in an object-oriented design, you will likely encounter objects in the problem domain
that contain other objects. In this situation you will be drawn to modeling a similar arrangement in the
design of your solution. In an object-oriented design of a Java program, the way in which you model
objects that contain other objects is with
<EM><A name="index-composition-definition">composition</A></em>, the act of composing a class out of
references to other objects. With composition, references to the constituent objects become fields of the
containing object.

<P>For example, it might be useful if the coffee cup object of your program could contain coffee. Coffee
itself could be a distinct class, which your program could instantiate. You would award coffee with a type
if it exhibits behavior that is important to your solution. Perhaps it will swirl one way or another when
stirred, keep track of a temperature that changes over time, or keep track of the proportions of coffee and
any additives such as cream and sugar.

<P>To use composition in Java, you use instance variables of one object
to hold references to other objects. For the
<CODE>CoffeeCup</CODE> example, you could create a field for coffee within the definition of class
<CODE>CoffeeCup</CODE>, as shown below:
[bv: implement the methods]
<PRE>
// In Source Packet in file inherit/ex1/CoffeeCup.java
class CoffeeCup {

    private Coffee innerCoffee;

    public void addCoffee(Coffee newCoffee) {
        // no implementation yet
    }

    public Coffee releaseOneSip(int sipSize) {
        // no implementation yet
        // (need a return so it will compile)
        return null;
    }

    public Coffee spillEntireContents() {
        // no implementation yet
        // (need a return so it will compile)
        return null;
    }
}

// In Source Packet in file inherit/ex1/Coffee.java
public class Coffee {

    private int mlCoffee;

    public void add(int amount) {
        // No implementation yet
    }

    public int remove(int amount) {
        // No implementation yet
        // (return 0 so it will compile)
        return 0;
    }

    public int removeAll() {
        // No implementation yet
        // (return 0 so it will compile)
        return 0;
    }
}
</pre>

<P>In the example above, the <CODE>CoffeeCup</CODE> class contains a reference to one other
object, an object of type <CODE>Coffee</CODE>. Class <CODE>Coffee</CODE> is defined is a
separate source file.

<P>The relationship modeled by composition is often referred to as the
<A name="index-has+a+relationship-definition">"has-a" relationship</A>. In this case a
<CODE>CoffeeCup</CODE> <EM>has</em> <CODE>Coffee</CODE>. As you can see from this
example, the has-a relationship doesn’t mean that the containing object must have a constituent object at
all times, but that the containing object may have a constituent object at some time. Therefore the
<CODE>CoffeeCup</CODE> may at some time contain <CODE>Coffee</CODE>, but it need not
contain <CODE>Coffee</CODE> all the time. (When a <CODE>CoffeeCup</CODE> object doesn’t
contain <CODE>Coffee</CODE>, its <CODE>innerCoffee</CODE> field is
<CODE>null</CODE>.)
In addition, note that the object contained can change throughout the
course of the containing object's life.

<P>[bv: need to add UML diagram for composition, and explain the difference
between composition and agregation and why I draw my diagrams like I do.]

<H2>
<A name="index-inheritance-introduction">
Inheritance
</A>
</H2>

<P>As you partition your problem domain into types you will likely want to model relationships in which
one type is a more specific or specialized version of another. For example you may have identified in your
problem domain two types, <CODE>Cup</CODE> and <CODE>CoffeeCup</CODE>, and you want to
be able to express in your solution that a <CODE>CoffeeCup</CODE> is a more specific kind of
<CODE>Cup</CODE> (or a special kind of <CODE>Cup</CODE>). In an object-oriented design, you
model this kind of relationship between types with <EM>inheritance</em>.

<H3>Building Inheritance Hierarchies</H3>

<P>The relationship modeled by inheritance is often referred to as the “is-a” relationship. In the case of
<CODE>Cup</CODE> and <CODE>CoffeeCup</CODE>, a "<CODE>CoffeeCup</CODE> is-a
<CODE>Cup</CODE>." Inheritance allows you to build hierarchies of classes, such as the one shown in
Figure 5-1. The upside-down tree structure shown in Figure 5-1 is an example of an
<EM><A name="index-inheritance+hierarchy-definition">inheritance hierarchy</A></em> displayed in
<A name="index-UML+diagrams-inheritance">UML</A> form.
Note that the classes become increasingly more specific as you traverse down the tree. A
<CODE>CoffeeCup</CODE> is a more specific kind of <CODE>Cup</CODE>. A
<CODE>CoffeeMug</CODE> is a more specific kind of <CODE>CoffeeCup</CODE>. Note also
that the is-a relationship holds even for classes that are connected in the tree through other classes. For
instance, a <CODE>CoffeeMug</CODE> is not only more specific version of a
<CODE>CoffeeCup</CODE>, it is also a more specific version of a <CODE>Cup</CODE>. Therefore,
the is-a relationship exists between <CODE>CoffeeMug</CODE> and <CODE>Cup</CODE>: a
<CODE>CoffeeMug</CODE> is-a <CODE>Cup</CODE>.

<P>
<IMG SRC="images\inhefig1.gif"><BR>
Figure 5-1. The is-a relationship of inheritance

<P>[bv: mention this is a UML diagram]

<P>When programming in Java, you express the inheritance relationship with the
<CODE>extends</CODE> keyword:

<PRE>
class Cup {
}
class CoffeeCup extends Cup {
}
class CoffeeMug extends CoffeeCup {
}
</pre>

<P>In Java terminology, a more general class in an inheritance hierarchy is called a
<EM><A name="index-superclass-definition">superclass</A></em>.
A more specific class is a
<EM><A name="index-subclass-definition">subclass</A></em>.
In Figure 5-1,
<CODE>Cup</CODE> is a superclass of both <CODE>CoffeeCup</CODE> and
<CODE>CoffeeMug</CODE>. Going in the opposite direction, both <CODE>CoffeeMug</CODE>
and <CODE>CoffeeCup</CODE> are subclasses of <CODE>Cup</CODE>. When two classes are
right next to each other in the inheritance hierarchy, their relationship is said to be <EM>direct</em>.
For example <CODE>Cup</CODE> is a
<EM><A name="index-direct+superclass-definition">direct superclass</A></em> of
<CODE>CoffeeCup</CODE>, and <CODE>CoffeeMug</CODE> is a
<EM><A name="index-direct+subclass-definition">direct subclass</A></em>
of <CODE>CoffeeCup</CODE>.

<P>The act of declaring a direct subclass is referred to in Java circles as
<EM><A name="index-class-extension-definition">class extension</A></em>. For
example, a Java guru might be overheard saying, “Class <CODE>CoffeeCup</CODE>
<EM>extends</em> class <CODE>Cup</CODE>.” Owing to the flexibility of the English language, Java
in-the-knows may also employ the term “subclass” as a verb, as in “Class <CODE>CoffeeCup</CODE>
<EM>subclasses</em> class <CODE>Cup</CODE>.” One other way to say the same thing is, “Class
<CODE>CoffeeCup</CODE> <EM>descends from</em> class <CODE>Cup</CODE>.”

<P>An inheritance hierarchy, such as the one shown in Figure 5-1, defines a
<EM><A name="index-family+of+types-definition">family of types</A></em>.
The most general class in a family of types--the one at the root of the inheritance hierarchy--is called the
<EM><A name="index-base+class-definition">base class</A></em>. In Figure 5-1, the base class is <CODE>Cup</CODE>. Because every class
defines a new type, you can use the word "type" in many places you can use
“class.” For example, a base
class is a base type, a subclass is a
<A name="index-subtype-definition">subtype</A>, and a direct superclass is a direct <A name="index-supertype-definition">supertype</A>.

<P>In Java, every class descends from one common base class: <CODE>Object</CODE>. The
declaration of class <CODE>Cup</CODE> above could have been written:

<PRE>
class Cup extends Object { // "extends Object" is optional
}
</pre>

<P>This declaration of <CODE>Cup</CODE> has the same effect as the earlier one that excluded the
“<CODE>extends Object</CODE>” clause. If a class is declared with no
<CODE>extends</CODE> clause, it by default extends the <CODE>Object</CODE> class. (The
only exception to this rule is class <CODE>Object</CODE> itself, which has no superclass.) The
inheritance hierarchy of Figure 5-1 could also have shown the <CODE>Object</CODE> class hovering
above the <CODE>Cup</CODE> class, in its rightful place as the most super of all superclasses. In this
case, class <CODE>Object</CODE> remained invisible, because the purpose of the figure was to focus
on one particular family of types, the <CODE>Cup</CODE> family.

<P>In Java, a class can have only one direct superclass. In object-oriented parlance, this is referred to as
<EM>
<A name="index-single+inheritance-definition">
<A name="index-inheritance-single-definition">
single inheritance
</A>
</A>
</em>.
It contrasts with
<EM>
<A name="index-multiple+inheritance-definition">
<A name="index-inheritance-multiple-definition">
multiple inheritance
</A>
</A>
</em>,
in which a class can
have multiple direct superclasses. Although Java only supports single inheritance of classes through class
extension, it supports a special variant of multiple inheritance through “interface implementation.” Java
interfaces, and how a class implements them, will be discussed in Chapter 7.

<H3>Inheriting interface and implementation</H3>

<P>Modeling an is-a relationship is called inheritance because the subclass <EM>inherits</em> the
interface and, by default, the implementation of the superclass.
<A name="index-interface-inheritance+of">
Inheritance of interface
</A>
guarantees that a
subclass can accept all the same messages as its superclass. A subclass object can, in fact, be used
anywhere a superclass object is called for. For example, a <CODE>CoffeeCup</CODE> as defined in
Figure 5-1 can be used anywhere a <CODE>Cup</CODE> is needed. This substitutability of a subclass (a
more specific type) for a superclass (a more general type) works because the subclass accepts all the same
messages as the superclass. In a Java program, this means you can invoke on a subclass object any method
you can invoke on the superclass object.

<P>This is only half of the inheritance story, however, because by default, a subclass also inherits the
entire implementation of the superclass. This means that not only does a subclass accept the same
messages as its direct superclass, but by default it behaves identically to its direct superclass when it
receives one of those messages. Yet unlike inheritance of interface, which is certain, inheritance of
implementation is optional. For each method inherited from a superclass, a subclass may choose to adopt
the inherited implementation, or to <EM>override</em> it.
To
<A name="index-override-definition">
override
</A>
a method, the subclass merely implements its own version of the method.

<P>
Overiding methods is a primary way a subclass specializes its behavior with
respect to its superclass.
A subclass has one other way to specialize besides overriding the
implementation of methods that exist in its
direct superclass. It can also extend the superclass’s interface by adding new methods. This possibility will
be discussed in detail later in the next chapter.

<P>Suppose there is a method in class <CODE>Cup</CODE> with the following signature:

<PRE>
public void addLiquid(Liquid liq) {
}
</pre>

The <CODE>addLiquid()</CODE> method could be invoked on any <CODE>Cup</CODE> object.
Because <CODE>CoffeeCup</CODE> descends from <CODE>Cup</CODE>, the
<CODE>addLiquid()</CODE> method could also be invoked on any <CODE>CoffeeCup</CODE>
object.

<P>If you do not explicitly define in class <CODE>CoffeeCup</CODE> a method with an identical
signature and return type as the <CODE>addLiquid()</CODE> method shown above, your
<CODE>CoffeeCup</CODE> class will inherit the same implementation (the same body of code) used
by superclass <CODE>Cup</CODE>. If, however, you do define in <CODE>CoffeeCup</CODE> an
<CODE>addLiquid()</CODE> method with the same signature and return type, that implementation
<EM>overrides</em> the implementation that would otherwise have been inherited by default from
<CODE>Cup</CODE>.

<P>When you override a method, you can make the access permission more public, but you cannot make
it less public. So far, you have only been introduced to two access levels, public and private. There are,
however, two other access levels that sit in-between public and private, which form the two ends of the
access-level spectrum. (All four access levels will be discussed together in Chapter 8.). In the case of the
<CODE>addLiquid()</CODE> method, because class <CODE>Cup</CODE> declares it with public
access, class <CODE>CoffeeCup</CODE> must declare it public also. If
<CODE>CoffeeCup</CODE> attempted to override <CODE>addLiquid()</CODE> with any other
access level, class <CODE>CoffeeCup</CODE> wouldn’t compile.

<P>For an illustration of the difference between inheriting and overriding the implementation of a
method, see Figure 5-2. The left side of this figure shows an example of inheriting an implementation,
whereas the right side shows an example of overriding the implementation.

<P>The method in question is the
familiar <CODE>addLiquid()</CODE> method. In the superclass, <CODE>Cup</CODE>, a
comment indicates that the code of the method, which is not shown in the figure, will cause the liquid to
swirl clockwise as it is added to the cup. Liquid added to an instance of the
<CODE>CoffeeCup</CODE> class defined on the left will also swirl clockwise, because that
<CODE>CoffeeCup</CODE> inherits <CODE>Cup</CODE>’s implementation of
<CODE>addLiquid()</CODE>, which swirls clockwise. By contrast, liquid added to an instance of
the <CODE>CoffeeCup</CODE> class defined on the right will swirl counterclockwise, because this
<CODE>CoffeeCup</CODE> class overrides <CODE>Cup</CODE>’s implementation with one of its
own. A more advanced <CODE>CoffeeCup</CODE> could override
<CODE>addLiquid()</CODE> with an implementation that first checks to see whether the coffee cup
is in the northern or southern hemisphere of the planet, and based on that information, decide which way
to swirl.
<P>
<IMG SRC="images\inhefig2.gif"><BR>
Figure 5-2. Inheriting vs. overriding the implementation of a method

<P>In addition to the bodies of public methods, the implementation of a class includes any private
methods and any fields defined in the class. Using the official Java meaning of the term “inherit,” a
subclass does not inherit private members of its superclass. It only inherits accessible members. Well-
designed classes most often refuse other classes direct access to their non-constant fields, and this policy
generally extends to subclasses as well. If a superclass has <CODE>private</CODE> fields, those
fields will be part of the object data in its subclasses, but they will not be “inherited” by the subclass.
Methods defined in the subclasses will not be able to directly access them. Subclasses, just like any other
class, will have to access the superclass’s <CODE>private</CODE> fields indirectly, through the
superclass’s methods.

<H2> Hiding Fields</H2>
<P>If you define a field in a subclass that has the same name as an accessible field in its superclass, the
subclass's field <EM><A name="index-hiding+fields">hides</A></EM> the
superclass's version. (The type of the variables need not match, just
the names.) For example, if a superclass declares a public field, subclasses will either inherit or hide it.
(You can’t override a field.) If a subclass hides a field, the superclass’s version is still part of the
subclass’s object data; however, the subclass doesn’t “inherit” the superclass’s version of the field, because
methods in the subclass can’t access the superclass’s version of the field by its simple name. They can
only access the subclass’s version of the field by its simple name. You can access the superclass’s version
by qualifying the simple name with the <CODE>super</CODE> keyword, as in
<CODE>super.fieldName</CODE>. (More on <CODE>super</CODE> in the next section.)
<P>Java permits you to declare a field in a subclass with the same name as a field in a superclass so you
can add fields to a class without worrying about breaking compatibility with already existing subclasses.
For example, you may publish a library of classes that your customers can use in their programs. If your
customers subclass the classes in your library, you will likely have no idea what new fields they have
declared in their subclasses. In making enhancements to your library, you may inadvertently add a field
that has the same name as a field in one of your customer’s subclasses. If Java didn’t permit field hiding,
the next time you released your library, your customer’s program might not run properly, because the like-
named field in the subclass would clash with the new field in the superclass from your library. Java’s
willingness to tolerate hidden fields makes subclasses more accepting of changes in their superclasses.

<P>[bv: See Behind the Scenes in this chapter for a description of object
images on a JVM heap?]

<H2> Abstract Classes and Methods</H2>

<P>As you perform an object-oriented design, you may come across classes of objects that you would
never want to instantiate. Those classes will nevertheless occupy a place in your hierarchies. An example
of such a class might be the <CODE>Liquid</CODE> class from the previous discussions. Class
<CODE>Liquid</CODE> served as a base class for the family of types that included subclasses
<CODE>Coffee</CODE>, <CODE>Milk</CODE>, and <CODE>Tea</CODE>. While you can
picture a customer walking into a café and ordering a coffee, a milk, or a tea, you might find it unlikely
that a customer would come in and order a “liquid.” You might also find it difficult to imagine how you
would serve a “liquid.” What would it look like? How would it taste? How would it swirl or gurgle?

<P>Java provides a way to declare a class as conceptual only, not one that represents actual objects, but
one that represents a category of types. Such classes are called <EM>abstract</em> <EM>classes</em>.
To mark a class as abstract in Java, you merely declare it with the <CODE>abstract</CODE>
keyword. The <CODE>abstract</CODE> keyword indicates the class should not be instantiated.
Neither the Java compiler nor the Java Virtual Machine will allow an abstract class to be instantiated. The
syntax is straightforward:
<PRE>
// In Source Packet in file inherit/ex6/Liquid.java
abstract class Liquid {

    void swirl(boolean clockwise) {
        System.out.println("One Liquid object is swirling.");
    }

    static void gurgle() {
        System.out.println("All Liquid objects are gurgling.");
    }
}
</pre>

<P>The above code makes <CODE>Liquid</CODE> a place holder in the family tree, unable to be an
object in its own right.
<P>Note that the <CODE>Liquid</CODE> class shown above still intends to implement a default
behavior for swirling and gurgling. This is perfectly fine, however, classes are often made abstract when it
doesn’t make sense to implement all of the methods of the class’s interface. The
<CODE>abstract</CODE> keyword can be used on methods as well as classes, to indicate the method
is part of the interface of the class, but does not have any implementation in that class. Any class with one
or more abstract methods is itself abstract and must be declared as such. In the
<CODE>Liquid</CODE> class, you may decide that there is no such thing as a default swirling
behavior that all liquids share. If so, you can declare the <CODE>swirl()</CODE> method abstract
and forgo an implementation, as shown below:
<PRE>
// In Source Packet in file inherit/ex7/Liquid.java
abstract class Liquid {

    abstract void swirl(boolean clockwise);

    static void gurgle() {
        System.out.println("All Liquid objects are gurgling.");
    }
}
</pre>

<P>In the above declaration of <CODE>Liquid</CODE>, the <CODE>swirl()</CODE> method is
part of <CODE>Liquid</CODE>’s interface, but doesn’t have an implementation. Any subclasses that
descend from the <CODE>Liquid</CODE> class shown above will have to either implement
<CODE>swirl()</CODE> or declare themselves abstract. For example, if you decided there were so
many varieties of coffee that there is no sensible default implementation for <CODE>Coffee</CODE>,
you could neglect to implement <CODE>swirl()</CODE> in <CODE>Coffee</CODE>. In that case,
however, you would need to declare <CODE>Coffee</CODE> abstract. If you didn’t, you would get a
compiler error when you attempted to compile the <CODE>Coffee</CODE> class. You would have to
subclass <CODE>Coffee</CODE> (for example: <CODE>Latte, Espresso,
CafeAuLait)</CODE> and implement <CODE>swirl()</CODE> in the subclasses, if you wanted
the <CODE>Coffee</CODE> type to ever see any action.

<P>Most often you will place abstract classes at the upper regions of your inheritance hierarchy, and non-
abstract classes at the bottom. Nevertheless, Java does allow you to declare an abstract subclass of a non-
abstract superclass. For example, you can declare a method inherited from a non-abstract superclass as
abstract in the subclass, thereby rendering the method abstract at that point in the inheritance hierarchy.
This design implies that the default implementation of the method is not applicable to that section of the
hierarchy. As long as you implement the method again further down the hierarchy, this design would
yield an abstract class sandwiched in the inheritance hierarchy between a non-abstract superclass and non-
abstract subclasses.
<H2> Final Classes and Methods</H2>

<P>Most Java programmers have two hats on their shelf, both of which they wear at different times.
Sometimes they wear their “designer” hat, and build libraries of classes for others to use. Other times they
wear their “client” hat, and make use of a library of classes created by someone else. Some Java
programmers even wear both hats at the same time, completely oblivious to the rules of fashion.
<P>When you put on your “designer” hat and work to build a library of classes that will be distributed to
people you don’t know and don’t necessarily trust, you will likely encounter situations in which you want
to prevent a client from declaring a subclass of one of the classes in your library. Or you might want to
allow a client to declare a subclass, but you want to prevent them from overriding specific methods of the
superclass. The reason you’ll feel the need for this kind of control is that a client could take advantage of
polymorphism to effectively change the behavior of the classes in your library. For example, a
<CODE>swirl()</CODE> method of a hot beverage object could be redefined to swirl right out of the
cup and dampen or possibly even scald a customer. Fortunately, Java gives you the
<CODE>final</CODE> keyword to prevent just such nightmarish scenarios as that.

<P>If you declare a method <CODE>final</CODE>, no subclass will be allowed to override that
method. If you declare an entire class <CODE>final</CODE>, no other class will be allowed to extend
it. In other words, a class declared <CODE>final</CODE> cannot be subclassed.  In an inheritance
diagram, a <CODE>final</CODE> class is the end of the line. No other classes will appear below it.
Subclasses can appear below a non-<CODE>final</CODE> class that contains a
<CODE>final</CODE> method, but every subclass will inherit the <CODE>final</CODE>
implementation of the method.

<P>Because marking a class or method <CODE>final</CODE> is so restrictive to clients of the class,
you should use it with caution. Only if you are certain you want to absolutely prevent clients from
declaring a subclass or overriding a method should you use the <CODE>final</CODE> keyword on a
class or method.

<P>
<FONT SIZE="+1"><STRONG>Initialization and inheritance</STRONG></FONT><BR>
When an object is initialized, all the instance variables defined in
the object's class must be set to proper initial values. While this is
necessary, often it is not enough to yield a fully initialized class.
An object incorporates not only the fields explicitly declared in its
class, but also those declared in its superclasses.  To fully
initialize an object, therefore, all instance variables declared in its
class and in all its superclasses must be initialized.

<P>
<STRONG>Instance data of objects</STRONG><BR>
Every object, except class <CODE>Object</CODE> itself, has at least one
superclass. When an object is created, the Java virtual machine
allocates enough space for all the object's instance variables, which
include all fields defined in the object's class and in all its
superclasses. For example, consider the following classes:

<P>
<PRE>
// Declared in file Object.java (not In source packet)
package java.lang;
public class Object {
    // Has no fields
    // Has several methods, not shown...
}

// In source packet in file init/ex14/Liquid.java
class Liquid {
    // Has two fields:
    private int mlVolume;
    private float temperature; // in Celsius
    // Has several methods, not shown...
}

// In source packet in file init/ex14/Coffee.java
class Coffee extends Liquid {
    // Has two fields:
    private boolean swirling;
    private boolean clockwise;
    // Has several methods, not shown...
}
</pre>

<P>
<CENTER>
<TABLE CELLPADDING="5" BORDER="0"><TR><TD>
<CENTER>
<IMG SRC="images\initfig1.gif">
<BR><FONT SIZE="-1"><STRONG>
Figure 4-1. Class <CODE>Coffee</CODE>'s superclasses and fields
</STRONG></FONT></CENTER>
</TD></TR></TABLE>
</CENTER>

<P>
You can see the inheritance hierarchy for class <CODE>Coffee</CODE>, as
defined above, in Figure 1.  This figure, as well as the code above,
shows <CODE>Object</CODE> as having no instance variables.  But it is
possible that <CODE>Object</CODE> could have instance variables. The
actual internal make-up of class <CODE>Object</CODE> is a detail
specific to each Java platform implementation. It is extremely likely,
however, that <CODE>Object</CODE> will have no fields in any given Java
platform implementation. Because <CODE>Object</CODE> is the superclass
of all other objects, any fields declared in <CODE>Object</CODE> must
be allocated for every object used by every Java program.

<P>
In Figure 2, you can see the data that must be allocated on the heap
for a <CODE>Coffee</CODE> object. The part of the heap that is occupied
by the instance data for the <CODE>Coffee</CODE> object is shown in the
cyan color. Keep in mind that the actual manner of representing objects
on the heap is an implementation detail of each particular Java virtual
machine. This figure represents just one of many possible schemes for
storing objects on the heap inside the JVM.

<P>
<CENTER>
<TABLE CELLPADDING="5" BORDER="0"><TR><TD>
<CENTER>
<IMG SRC="images\initfig2.gif">
<BR><FONT SIZE="-1"><STRONG>
Figure 4-2. Instance data for a  <CODE>Coffee</CODE> object
</STRONG></FONT></CENTER>
</TD></TR></TABLE>
</CENTER>

<P>
Figure 2 shows that the instance data for a <CODE>Coffee</CODE> object
includes each instance variable defined in class <CODE>Coffee</CODE>
and each of <CODE>Coffee</CODE>'s superclasses. Both of
<CODE>Liquid</CODE>'s fields, <CODE>mlVolume</CODE> and
<CODE>temperature</CODE>, are part of the <CODE>Coffee</CODE> object's
data, as well as <CODE>Coffee</CODE>'s fields: <CODE>swirling</CODE>
and <CODE>clockwise</CODE>. This is true even though
<CODE>Coffee</CODE> doesn't actually <EM>inherit</em> the
<CODE>mlVolume</CODE> and <CODE>temperature</CODE> fields from class
<CODE>Liquid</CODE>.

<P>
<STRONG>A note on the word &quot;inherit&quot;</STRONG><BR>
In Java jargon, the word &quot;inherit&quot; has a restricted meaning.
A subclass inherits only accessible members of its superclasses -- and
only if the subclass doesn't override or hide those accessible members.
A class's members are the fields and methods actually declared in the
class, plus any fields and methods it inherits from superclasses. In
this case, because <CODE>Liquid</CODE>'s <CODE>mlVolume</CODE> and
<CODE>temperature</CODE> fields are private, they are not accessible to
class <CODE>Coffee</CODE>.  <CODE>Coffee</CODE> does not inherit those
fields.  As a result, the methods declared in class <CODE>Coffee</CODE>
can't directly access those fields.  Despite this, those fields are
still part of the instance data of a <CODE>Coffee</CODE> object.

<P>
<STRONG>Pointers to class data</STRONG><BR>
Figure 2 also shows, as part of the instance data of the
<CODE>Coffee</CODE> object, a mysterious 4-byte quantity labeled
&quot;native pointer to class information.&quot; Every Java virtual
machine must have the capability to determine information about its
class, given only a reference to an object. This is needed for many
reasons, including type-safe casting and the <CODE>instanceof</CODE>
operator.

<P>
Figure 2 illustrates one way in which a Java virtual machine
implementation could associate class information with the instance data
for an object.  In this figure, a native pointer to a data structure
containing class information is stored along with the instance
variables for an object.  The details in which the various ways a JVM
could connect an object's data with its class information are beyond
the scope of this article. The important thing to understand here is
that class information will <EM>in some way</em> be associated with the
instance data of objects, and that the instance data includes fields
for an object's class and all its superclasses.

<P>
<STRONG>Initializing fields in superclasses</STRONG><BR>
Each class contains code to initialize the fields explicitly declared
in that class. Unlike methods, constructors are never inherited. If you
don't explicitly declare a constructor in a class, that class will not
inherit a constructor from its direct superclass. Instead, the compiler
will generate a default constructor for that class. This is because a
superclass constructor can't initialize fields in the subclass. A
subclass must have its own constructor to initialize its own instance
variables. In the class file, this translates to: every class has at
least one <CODE>&lt;init&gt;</CODE> method responsible for initializing
the class variables explicitly declared in that class.

<P>
For every object, you can trace a path of classes on an inheritance
hierarchy between the object's class and class <CODE>Object</CODE>. For
the <CODE>Coffee</CODE> object described above and shown in Figures 1
and 2, the path is: <CODE>Coffee</CODE>, <CODE>Liquid</CODE>,
<CODE>Object</CODE>. To fully initialize an object, the Java virtual
machine must invoke (at least) one instance initialization method from
each class along the object's inheritance path. In the case of
<CODE>Coffee</CODE>, this means that at least one instance
initialization method must be invoked for each of the classes
<CODE>Coffee</CODE>, <CODE>Liquid</CODE>, and <CODE>Object</CODE>.

<P>
During initialization, an <CODE>&lt;init&gt;</CODE> method may use one
field in calculating another field's initial value. While this is
perfectly reasonable, it brings up the possibility that a field could
be used before it has been initialized to its proper (not default)
initial value. As mentioned earlier in this article, Java includes
mechanisms that help prevent an instance variable from being used
before it has been properly initialized. One mechanism is the rule,
enforced by the Java compiler, forbidding initializers from directly
using instance variables declared textually after the variable being
initialized.  Another mechanism is the order in which the fields from
each class along an object's inheritance path are initialized: the
&quot;order of initialization.&quot;

<P>
<STRONG>Order of initialization</STRONG><BR>
In Java, the fields of an object are initialized starting with the
fields declared in the base class and ending with the fields declared
in the object's class. For a <CODE>CoffeeCup</CODE> object with the
inheritance path shown in Figure 1, the order of initialization of
fields would be:

<P>
<OL>
<LI><CODE>Object</CODE>'s fields (this will be quick, because there are
none)
<LI><CODE>Liquid</CODE>'s fields (<CODE>mlVolume</CODE> and
<CODE>temperature</CODE>)
<LI><CODE>Coffee</CODE>'s fields (<CODE>swirling</CODE> and
<CODE>clockwise</CODE>)
</OL>

<P>
This base-class-first order aims to prevent fields from being used
before they are initialized to their proper (not default) values. In a
constructor or initializer, you can safely use a superclass's field
directly, or call a method that uses a superclass's field. By the time
the code in your constructor or initializer is executed, you can be
certain that the fields declared in any superclasses have already been
properly initialized.

<P>
For example, you could safely use the <CODE>temperature</CODE> variable
declared in class <CODE>Liquid</CODE> when you are initializing the
<CODE>swirling</CODE> variable declared in class <CODE>Coffee</CODE>.
(Perhaps if the temperature is above the boiling point for coffee, you
set <CODE>swirling</CODE> to false.) If <CODE>temperature</CODE> were
not private, class <CODE>Coffee</CODE> would inherit the field, and you
could use it directly in an initializer or constructor of class
<CODE>Coffee</CODE>. In this case, <CODE>temperature</CODE> is private,
so you'll have to use the <CODE>temperature</CODE> field indirectly,
through a method:

<P>
<PRE>
// In source packet in file init/ex15/Liquid.java
class Liquid {

    private int mlVolume;
    private float temperature; // in Celsius

    public Liquid() {
        mlVolume = 300;
        temperature = (float) (Math.random() * 100.0);
    }

    public float getTemperature() {
        return temperature;
    }
    // Has several other methods, not shown...
}

// In source packet in file init/ex15/Coffee.java
class Coffee extends Liquid {

    private static final float BOILING_POINT = 100.0f; // Celsius
    private boolean swirling;
    private boolean clockwise;

    public Coffee(boolean swirling, boolean clockwise) {
        if (getTemperature() >= BOILING_POINT) {
            // Leave swirling at default value: false
            return;
        }
        this.swirling = swirling;
        if (swirling) {
            this.clockwise = clockwise;
        } // else, leave clockwise at default value: false
    }
    // Has several methods, not shown,
    // but doesn’t override getTemperature()...
}
</pre>

<P>
In the example, the constructor for <CODE>Coffee</CODE> invokes
<CODE>getTemperature()</CODE> and uses the return value in the
calculation of the proper initial value of <CODE>swirling</CODE> and
<CODE>clockwise</CODE>.  <CODE>getTemperature()</CODE> returns the
value of the <CODE>temperature</CODE> variable; thus, the constructor
for <CODE>Coffee</CODE> uses a field declared in <CODE>Liquid</CODE>.
This works because, by the time the code inside <CODE>Coffee</CODE>'s
constructor is executed, the instance variables declared in
<CODE>Liquid</CODE> are guaranteed to have already been initialized to
their proper starting values.

<H2>Design Corner</H2>

<H3>Composition versus Inheritance</H3>

<H2>Behind the Scenes</H2>
<P>[bv: want to have description of object image on the JVM heap here?]
<P>[bv: want to mention that Object can be redefined?]

<P>
<FONT SIZE="+1"><STRONG>The structure of <CODE>&lt;init&gt;</CODE></STRONG></FONT><BR>
How does Java ensure the correct ordering of initialization? By the
manner in which the Java compiler generates the instance initialization
method. Into each <CODE>&lt;init&gt;</CODE> method, the compiler can
place three kinds of code:

<P>
<OL>
<LI>An invocation of another constructor
<LI>Initializers in textual order
<LI>The constructor body
</OL>

<P>
The order in which the compiler places these components into the
<CODE>&lt;init&gt;</CODE> method determines the order of initialization
of an object's fields.

<P>
<STRONG>(Almost) every constructor's first act</STRONG><BR>
For every class except <CODE>Object</CODE>, the first thing each
<CODE>&lt;init&gt;</CODE> method will do is invoke another constructor.
If you included a <CODE>this()</CODE> invocation as the first statement
in a constructor, the corresponding <CODE>&lt;init&gt;</CODE>
method will start by calling another <CODE>&lt;init&gt;</CODE> method
of the same class. For example, for the following class:

<P>
<PRE>
// In source packet in file init/ex4/CoffeeCup.java
class CoffeeCup {

    private int innerCoffee;

    public CoffeeCup() {
        this(237); // Calls other constructor
        // Could have done more construction here
    }

    public CoffeeCup(int amount) {
        innerCoffee = amount;
    }
    // ...
}
</pre>

<P>
The <CODE>&lt;init&gt;</CODE> method for the no-arg constructor would
first invoke the <CODE>&lt;init&gt;</CODE> method for the constructor,
which takes an <CODE>int</CODE> parameter, passing it 237.

<P>
<STRONG>Automatic invocation of <CODE>super()</CODE></STRONG><BR>
For any class except class <CODE>java.lang.Object</CODE>, if you write
a constructor that does not begin with a <CODE>this()</CODE>
invocation, the <CODE>&lt;init&gt;</CODE> method for that
constructor will begin with an invocation of a superclass constructor.
You can explicitly invoke a superclass constructor using the
<CODE>super()</CODE> statement. If you don't, the compiler will
automatically generate an invocation of the superclass's no-arg
constructor. (This is true for default constructors as well. With the
exception of class <CODE>Object</CODE>, the <CODE>&lt;init&gt;</CODE>
method for any default constructor will do only one thing: invoke the
<CODE>&lt;init&gt;</CODE> method for the superclass's no-arg
constructor.) For example, given this <CODE>CoffeeCup</CODE>
constructor from the example above:

<P>
<PRE>
public CoffeeCup(int amount) {
    innerCoffee = amount;
}
</pre>

<P>
The corresponding <CODE>&lt;init&gt;</CODE> method would begin with an
invocation of the <CODE>&lt;init&gt;</CODE> method for
<CODE>Liquid</CODE>'s (the direct superclass's) no-arg constructor.

<P>
Alternatively, you could have included an explicit <CODE>super()</CODE>
statement at the top of the <CODE>Coffee</CODE> constructor, as in:

<P>
<PRE>
public CoffeeCup(int amount) {
    super();
    innerCoffee = amount;
}
</pre>

<P>
This version has the same effect as the previous version. If you want
to invoke the superclass's no-arg constructor, you needn't provide an
explicit <CODE>super()</CODE> invocation. The compiler will generate a
no-arg <CODE>super()</CODE> invocation for you.

<P>
<STRONG>Invoking <CODE>super()</CODE> with arguments</STRONG><BR>
If, on the other hand, you want to invoke a superclass constructor that
takes parameters, you must provide an explicit <CODE>super()</CODE>
invocation. Here's an example:

<P>
<PRE>
// In source packet in file init/ex16/Liquid.java
class Liquid {

    private int mlVolume;
    private float temperature; // in Celsius

    public Liquid(int mlVolume, float temperature) {
        this.mlVolume = mlVolume;
        this.temperature = temperature;
    }

    public float getTemperature() {
        return temperature;
    }
    // Has several other methods, not shown,
    // but doesn’t include another constructor...
}

// In source packet in file init/ex16/Coffee.java
public class Coffee extends Liquid {

    private static final float BOILING_POINT = 100.0f; // Celsius
    private boolean swirling;
    private boolean clockwise;

    public Coffee(int mlVolume, float temperature,
        boolean swirling, boolean clockwise) {

        super(mlVolume, temperature);
        if (getTemperature() > BOILING_POINT) {
            // Leave swirling at default value: false
            return;
        }
        this.swirling = swirling;
        if (swirling) {
            this.clockwise = clockwise;
        } // else, leave clockwise at default value: false
    }
    // has several methods, not shown,
    // but doesn’t override getTemperature()...
}
</pre>

<P>
In this example, <CODE>Coffee</CODE>'s constructor explicitly invokes
<CODE>Liquid</CODE>'s constructor with a <CODE>super()</CODE>
statement. Because class <CODE>Liquid</CODE> explicitly declares a
constructor, the Java compiler won't generate a default constructor.
Moreover, because <CODE>Liquid</CODE> doesn't explicitly declare a
no-arg constructor, class <CODE>Liquid</CODE> won't have a no-arg
constructor at all.  For this reason, had <CODE>Coffee</CODE>'s
constructor not started with an explicit <CODE>super()</CODE>
invocation, class <CODE>Coffee</CODE> would not have compiled. (Given
this declaration of class <CODE>Liquid</CODE>, a simple <CODE>new
Liquid()</CODE> statement would not compile either.  You must invoke
the constructor that is available to you, as in:  <CODE>new Liquid(25,
50.0)</CODE>.) If a subclass's direct superclass does not offer a
no-arg constructor, every constructor in that subclass must begin with
either an explicit <CODE>super()</CODE> or
<CODE>this()</CODE>invocation.

<P>
<STRONG>Only one constructor invocation allowed</STRONG><BR>
Note that you can't have both <CODE>this()</CODE> and
<CODE>super()</CODE> in the same constructor. You can only have one or
the other (or neither, if the direct superclass includes a no-arg
constructor). If a constructor includes a <CODE>this()</CODE> or
<CODE>super()</CODE> invocation, it must be the first statement in the
constructor.

<P>
<STRONG>Catching exceptions not allowed</STRONG><BR>
One other rule enforced on constructors is that you can't catch any
exceptions thrown by the constructor invoked with <CODE>this()</CODE>
or <CODE>super()</CODE>. To do so, you would have to begin your
constructor with a <CODE>try</CODE> statement:

<P>
<PRE>
// In source packet in file init/ex17/Coffee.java
// THIS WON'T COMPILE, BECAUSE THE super() INVOCATION
// DOESN'T COME FIRST IN THE CONSTRUCTOR
class Coffee extends Liquid {
    //...
    public Coffee(int mlVolume, float temperature,
        boolean swirling, boolean clockwise) {

        try {
            super(mlVolume, temperature);
        }
        catch (Throwable e) {
            //...
        }
        //...
    }
    //...
}
</pre>

<P>
The point to understand here is that if any instance initialization
method completes abruptly by throwing an exception, initialization of
the object fails. This in turn means that object creation fails,
because in Java programs, objects must be properly initialized before
they are used.

<P>
The proper way to signal that an error occurred during object
initialization is by throwing an exception. If an
<CODE>&lt;init&gt;</CODE> method throws an exception, it is likely that
at least some of the fields that <CODE>&lt;init&gt;</CODE> method
normally takes responsibility for did not get properly initialized. If
you were able to catch an exception thrown by an
<CODE>&lt;init&gt;</CODE> method you invoked with <CODE>this()</CODE>
or <CODE>super()</CODE>, you could ignore the exception and complete
normally. This could result in an improperly or incompletely
initialized object being returned by <CODE>new</CODE>. This is why
catching exceptions thrown by <CODE>&lt;init&gt;</CODE> methods invoked
via <CODE>this()</CODE> or <CODE>super()</CODE> is not allowed.

<P>
<STRONG>Inheritance and initialization order</STRONG><BR>
From the many rules that surround the invocation of instance
initialization methods via <CODE>this()</CODE> or <CODE>super()</CODE>,
there arises a clear and certain order for instance variable
initialization.  Although <CODE>&lt;init&gt;</CODE> methods are called
in an order starting from the object's class and proceeding up the
inheritance path to class <CODE>Object</CODE>, instance variables are
initialized in the reverse order. Instance variables are initialized in
an order starting from class <CODE>Object</CODE> and proceeding down
the inheritance path to the object's class. The reason the order of
instance variable initialization is reverse to that of
<CODE>&lt;init&gt;</CODE> method invocation is that the first thing
each <CODE>&lt;init&gt;</CODE> method (except <CODE>Object</CODE>'s)
does is call another <CODE>&lt;init&gt;</CODE> method. So the
superclass <CODE>&lt;init&gt;</CODE> method is invoked and completes
before any initialization code of the current class's
<CODE>&lt;init&gt;</CODE> method begins execution.

<P>
As an example of this ordering, consider again the inheritance
hierarchy for class <CODE>Coffee</CODE> as shown in Figure 1 and the
following implementation of those classes:

<P>
<PRE>
// In source packet in file init/ex18/Liquid.java
class Liquid {

    private int mlVolume;
    private float temperature; // in Celsius

    Liquid(int mlVolume, float temperature) {
        this.mlVolume = mlVolume;
        this.temperature = temperature;
    }
    //...
}

// In source packet in file init/ex18/Coffee.java
class Coffee extends Liquid {

    private boolean swirling;
    private boolean clockwise;

    public Coffee(int mlVolume, float temperature,
        boolean swirling, boolean clockwise) {

        super(mlVolume, temperature);
        this.swirling = swirling;
        this.clockwise = clockwise;
    }
    //...
}
</pre>

<P>
When you instantiate a new <CODE>Coffee</CODE> object with the
<CODE>new</CODE> operator, the Java virtual machine first will allocate
(at least) enough space on the heap to hold all the instance variables
declared in <CODE>Coffee</CODE> and its superclasses. Second, the
virtual machine will initialize all the instance variables to their
default initial values. Third, the virtual machine will invoke the
<CODE>&lt;init&gt;</CODE> method in the <CODE>Coffee</CODE> class.

<P>
The first thing <CODE>Coffee</CODE>'s <CODE>&lt;init&gt;</CODE> method
will do is invoke the <CODE>&lt;init&gt;</CODE> method in its direct
superclass, <CODE>Liquid</CODE>. The first thing <CODE>Liquid</CODE>'s
<CODE>&lt;init&gt;</CODE> method will do is invoke the no-arg
<CODE>&lt;init&gt;</CODE> method in its direct superclass,
<CODE>Object</CODE>.  <CODE>Object</CODE>'s <CODE>&lt;init&gt;</CODE>
method most likely will do nothing but return, because it has no
instance variables to initialize. (Once again, what
<CODE>Object</CODE>'s <CODE>&lt;init&gt;</CODE> method actually does is
an implementation detail of each particular Java runtime environment.)
When <CODE>Object</CODE>'s <CODE>&lt;init&gt;</CODE> method returns,
<CODE>Liquid</CODE>s <CODE>&lt;init&gt;</CODE> method will initialize
<CODE>mlVolume</CODE> and <CODE>temperature</CODE> to their proper
starting values and return. When <CODE>Liquid</CODE>s
<CODE>&lt;init&gt;</CODE> method returns, <CODE>Coffee</CODE>'s
<CODE>&lt;init&gt;</CODE> method will initialize <CODE>swirling</CODE>
and <CODE>clockwise</CODE> to their proper starting values and return.
Upon normal completion of <CODE>Coffee</CODE>'s
<CODE>&lt;init&gt;</CODE> method (in other words, so long as it doesn't
complete abruptly by throwing an exception), the JVM will return the
reference to the new <CODE>Coffee</CODE> object as the result of the
<CODE>new</CODE> operator.

<P>
<STRONG><CODE>this()</CODE> won't change the order of initialization</STRONG><BR>
Note that if an <CODE>&lt;init&gt;</CODE> method begins not by invoking
a superclass's <CODE>&lt;init&gt;</CODE> method (a <CODE>super()</CODE>
invocation), but instead by invoking another <CODE>&lt;init&gt;</CODE>
method from the same class (a <CODE>this()</CODE> invocation), the
order of instance variable initialization remains the same.  You can
have several <CODE>this()</CODE> invocations in a row if you wish. In
other words, you could have an <CODE>&lt;init&gt;</CODE> method that
invokes another with <CODE>this()</CODE>, and that
<CODE>&lt;init&gt;</CODE> method invokes yet another with
<CODE>this()</CODE>, and so on. But in the end, there will always be an
<CODE>&lt;init&gt;</CODE> method with a <CODE>super()</CODE> invocation
-- either an explicit <CODE>super()</CODE> invocation or a
compiler-generated one. Since <CODE>this()</CODE> and
<CODE>super()</CODE> are both always the first action a constructor
takes, the instance variables will always be initialized in order from
the base class on down.

<P>
In addition to the code for constructor invocations and constructor
bodies, the Java compiler also places code for any initializers in the
<CODE>&lt;init&gt;</CODE> method. If a class includes initializers, the
code for them will be placed after the superclass method invocation but
before the code for the constructor body, in every
<CODE>&lt;init&gt;</CODE> method that begins with an explicit or
implicit <CODE>super()</CODE> invocation. Code for initializers are not
included as part of <CODE>&lt;init&gt;</CODE> methods that begin with a
<CODE>this()</CODE> invocation. Because initializer code appears only
in <CODE>&lt;init&gt;</CODE> methods that begin with a
<CODE>super()</CODE> invocation, and not in those that begin with a
<CODE>this()</CODE> invocation, the initializers for a class are
guaranteed to be run only once for each new class creation. Because
initializers appear after the <CODE>super()</CODE> invocation and
before the code from the constructor's body, you can always be certain
that initializers will have been run by the time any constructor code
for that class is executed.

<P>
<STRONG>Calling subclassed methods from constructors</STRONG><BR>
The strict ordering of instance variable initialization enforced by the
Java compiler is, in part, an effort to ensure that during the
initialization process, instance variables are never used before they
have been initialized to their proper initial values. As illustrated
earlier in this article, however, the rules of ordering are not
bulletproof. There are ways you can use an instance variable during
initialization before it has been initialized to its proper value,
while it still has its default value. In the case of instance variable
initializers, you can invoke a method that uses a variable declared
textually after the variable being initialized. Another way to use an
instance variable before it has been properly initialized is to invoke
a method from a superclass initializer or constructor that uses
instance variables in a subclass.

<P>
Unlike C++, which treats the invocation of virtual functions from
constructors specially, Java methods invoked from
<CODE>&lt;init&gt;</CODE> methods behave the same as if they were
invoked from any method. If <CODE>&lt;init&gt;</CODE> in a superclass
invokes a method that has been overridden in a subclass, the subclass's
implementation of that method will run. If the subclass's method
implementation uses instance variables explicitly declared in the
subclass, those variables will still have their default initial
values.

<P>
You should be careful when you invoke methods from initializers or
constructors, because you can end up using instance variables before
they've been properly initialized -- while they still have their
default initial values. It is fine to use variables while they still
have their default initial values, so long as it is the result you are
aiming for. If you invoke non-private methods from initializers and
constructors, remember that later some other programmer could come
along, extend your class, and override those methods, thereby thwarting
your grand initialization scheme.

<H2> Example Programs</H2>

<P>Could perhaps show how class vars can be used to keep track of
all the instances of the class and then how a <CODE>gurgleAllObjects()</CODE>
class method can send <CODE>gurgle()</CODE> methods to all objects.

<H2> On the CD-ROM</H2>

<P>The CD-ROM contains several examples from this chapter, all of which are in subdirectories of the
<CODE>inherit</CODE> directory. The files for example one are in the <CODE>ex1</CODE>
subdirectory, the files for example two are in <CODE>ex2</CODE>, and so on.
<P>Example one is simply the <CODE>CoffeeCup</CODE> and <CODE>Coffee</CODE> classes,
shown above, that illustrate composition. In this version of <CODE>CoffeeCup</CODE>, the
<CODE>innerCoffee</CODE> instance variable is a reference to an object of type
<CODE>Coffee</CODE>. The files are in the <CODE>inherit/ex1</CODE> directory.
<P>Example two is the polymorphism example. All of the code for this example is shown above as part of
the text of this chapter. The files are in the <CODE>inherit/ex2</CODE> directory. In this example,
the <CODE>addLiquid()</CODE> method of class <CODE>CoffeeCup</CODE> use
polymorphism to call the appropriate <CODE>swirl()</CODE> method an object that either is or
descends from class <CODE>Liquid</CODE>. If you execute the Java application,
<CODE>Example2</CODE>, it will print out the output:
<PRE>
Liquid Swirling
Coffee Swirling
Milk Swirling
</pre>

<P>Example three is an example of poor design that doesn’t take advantage of polymorphism. Only the
<CODE>UglyCoffeeCup</CODE> class from this example is shown in the text of this chapter. (The
rest aren’t shown because this example doesn’t provide a positive role model.) All the files exist in the
<CODE>inherit/ex3</CODE> directory of the CD-ROM, however, so you can run the application
<CODE>Example3</CODE>. When you run <CODE>Example3</CODE>, you get the same output as
<CODE>Example2</CODE> gives you. The example works, it just doesn’t take advantage of
polymorphism. Try to avoid this style of program design.

<P>Example four illustrates the difference between static and dynamic binding. The code for all the files
in this example, which are shown above as part of the text of this chapter. The files are in the
<CODE>inherit/ex4</CODE> directory. You can see the different between static and dynamic
binding by running <CODE>Example4a</CODE>, which doesn’t yield the desired behavior of gurgling
all milk objects. <CODE>Example4b</CODE> shows one way to gurgle milk, however, the preferred
way to gurgle milk is shown in <CODE>Example4c</CODE>. When you run
<CODE>Example4c</CODE>, it will print out:
<PRE>
One Milk object is swirling.
All Milk objects are gurgling.
</pre>

<P>Example five illustrates adding behavior to one member of a family of types, and using
<CODE>instanceof</CODE> to access that behavior. All of the code in this example is shown above
in the text of this chapter. The files are in the <CODE>inherit/ex5</CODE> directory of the CD-
ROM. In this example, two of the source files, <CODE>Example5a.java</CODE> and
<CODE>Example5c.java</CODE>, don’t compile. These files illustrate that you can’t access a
method defined in a subclass, <CODE>Tea</CODE>, if you have a reference to a superclass,
<CODE>Liquid</CODE>. You can, however, run <CODE>Example5b</CODE> and
<CODE>Example5d</CODE>. When you run <CODE>Example5d</CODE>, which illustrates the
proper way to access the <CODE>readFuture()</CODE> method defined in subclass
<CODE>Tea</CODE>, the application will print out:
<PRE>
Tea Swirling
Reading the future...
</pre>

<P>Examples six and seven are simply the two <CODE>Liquid</CODE> classes, shown above, that
illustrate abstract classes and methods. In example six, which is in the <CODE>inherit/ex6</CODE>
directory, class <CODE>Liquid</CODE> is declared abstract even though it doesn’t contain any
abstract methods. In example seven, which is in the <CODE>inherit/ex7</CODE> directory, both
the <CODE>swirl()</CODE> method and the <CODE>Liquid</CODE> class itself are declared
abstract.


</DIV>
<HR width="100%">
<TABLE width="100%">
<TR>
<TD align="left">
<DIV class="sp">
Last Updated: Sunday, March 3, 2002<BR>
<A href="http://www.artima.com/copyright.html">Copyright</A> &copy; 1996-2002 Artima Software, Inc. All Rights Reserved.
</DIV>
</TD>
<TD align="right">
<DIV class="sp">
URL: http://www.artima.com/objectsandjava/webuscript/CompoInherit1.html<BR>
Artima.com is created by <A href="http://www.artima.com/consulting.html">Bill Venners</A>
</DIV>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
