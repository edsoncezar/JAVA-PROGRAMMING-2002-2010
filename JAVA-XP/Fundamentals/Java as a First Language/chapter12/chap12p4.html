<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>12.4 Homogenous binary streams</title>

</head>

<body BGCOLOR="WHITE">

<h2>12.4 Homogenous binary streams<br>
</h2>

<p>
This section will introduce the use of binary streams by developing
a demonstration client which will write, and subsequently read,
an array of objects to a stream. In this first example all of
the objects will be of exactly the same class, hence <i><b>homogenous</b></i>.
It is more useful, and more common, for a stream consisting of
values of different classes to be written and read; such streams
are described as <i><b>heterogeneous</b></i>. The handling of
heterogeneous streams is more complex than the handling of homogenous
streams and will be considered in the next section.<br>

<p>
The <i>WarningCounter</i> class, first introduced in Chapter 4,
will be used, with minor modifications, for the instances to be
stored in the stream. As the writing and reading of a single instance
would not be a very convincing demonstration a data structure
containing an iteration of <i>WarningCounter</i>s, implemented
in a class called <i>HomogenousMonitors</i>, will be used. The
reason why the collection of <i><font FACE="Arial">Counters</font></i>
is called a collection of <i>Monitors</i> will become clear in
the next section. The object diagram of the <i>HomogenousMonitors</i>
class is given in Figure 12.1.<br>

<p>
<center><img SRC="c12p4i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/c12p4i1.gif" WIDTH="343" HEIGHT="361">
</center>
<p>
The constructor will create an indeterminate number of <i>WarningCounter</i>
instances (between 2 and 7) and will initialise each to an indeterminate
state. This decision was made in order that the demonstration
of the stream facility will be more convincing if a different
number of items, with different values, are used each time the
demonstration client is run. The design of the constructor is
as follows.<br>

<p>
<center><img SRC="c12p4i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/c12p4i2.gif" WIDTH="703" HEIGHT="510">
</center>
<p>
The basis of this design is to randomly decide upon the number
of counters and then to initialise an array of <i>WarningCounters</i>
to this size. Each <i>WarningCounter</i> in turn is then constructed,
with the default minimum and maximum limits, and is then initialised
by randomly deciding upon the number of occurrences to <i>count</i>
and <i>unCount</i>. An occurrence can only be uncounted if there
is already an occurrence counted, otherwise there is an equal
chance of a an occurrence being counted or uncounted. The implementation
of the constructor, and the context clause of the class, is as
follows. <br>

<pre>
<font>0001  // Filename HomogenousMonitors.java.
0002  // Contains an indeterminate number of WarningCounter 
0003  // instances with actions to write then to and read 
0004  // them from a stream. 
0005  //
0006  // Written for JFL Book Chapter 12.
0007  // Fintan Culwin, V 0.1, Jan 1997. 
0008  
0009  <b>import</b> Counters.WarningCounter;
0010  <b>import</b> java.io.*;
0011  <b>import</b> java.util.Random;
0012  <b>import</b> java.util.Date;
0013  
0014  
0015  <b>class</b> HomogenousMonitors { 
0016  
0017  <b>private</b>  Random generator = <b>new</b> Random( <b>new</b> Date().getTime()); 
0018  <b>private</b>  WarningCounter theMonitors[];
0019  
0020     <b>public</b> HomogenousMonitors(){
0021     
0022     <b>int</b> numberOfMonitors = 2 + (<b>int</b>) (generator.nextDouble() * 5.0);
0023     <b>int</b> index; 
0024     <b>int</b> anotherIndex;
0025     <b>int</b> numberOfOccurrences; 
0026                      
0027        theMonitors = <b>new</b> WarningCounter[ numberOfMonitors];
0028        <b>for</b> ( index =0; index &lt; numberOfMonitors; index++) { 
0029           theMonitors[ index] = <b>new</b> WarningCounter();
0030           numberOfOccurrences = 10 + 
0031                         (<b>int</b>) (generator.nextDouble() * 20.0);
0032           <b>for</b> ( anotherIndex =0; 
0033                 anotherIndex &lt; numberOfOccurrences;
0034                 anotherIndex++) {                      
0035              <b>if</b> ( (generator.nextDouble() &gt; 0.5)              &amp;&amp;
0036                 (theMonitors[ index].numberCountedIs() &gt; 0) ){
0037                 theMonitors[ index].unCount();  
0038              } <b>else</b> { 
0039                 theMonitors[ index].count(); 
0040              } // End if.
0041           } // End for anotherIndex.                         
0042        } // End for index.  
0043     } // End HomogenousMonitors constructor.<br>
</font>
</pre>

<p>
The local variable <i><font FACE="Arial">numberOfMonitors</font></i>
is initialised upon declaration using a random number on line
0022 and the value is subsequently used to determine the bounds
of an array of <i><font FACE="Arial">WarningCounter</font></i>s,
called <i><font FACE="Arial">theMonitors</font></i>, on
line 0027. A definite loop between lines 0028 and 0042 then considers
each <i><font FACE="Arial">WarningCounter</font></i> instance
in turn. The <i><font FACE="Arial">WarningCounter</font></i>
is created, using the default constructor, on line 0029.<br>

<p>
A second definite loop between 0032 and 0041, controlled by a
random value obtained on lines 0030 and 0031, then either calls
the <i><font FACE="Arial">WarningCounters count()</font></i>
or <i><font FACE="Arial">unCount()</font></i> action on
a 50/&nbsp;50 random basis. However the <i><font FACE="Arial">unCount()</font></i>
action is only called if the <i><font FACE="Arial">numberCountedIs()</font></i>
enquiry action indicates that there is an occurrence to uncount.
<br>

<p>
The <i>resetMonitors</i> action will reinitialise the monitors
into their default state, where they have counted no occurrences,
by recreating each instance. The <i>toString</i> action labels
each counter as being associated with a room; and calls the <i><font FACE="Arial">WarningCounter</font></i>
<i><font FACE="Arial">toString()</font></i> action to obtain
a <i><font FACE="Arial">String</font></i> representing
the state of the counter to be appended to the label. The implementation
of these two actions will be presented without a design, as follows.
<br>

<pre>
<font>0046     <b>public void</b> <i>resetMonitors</i>() {
0047      
0048     <b>int</b> <i>index</i>; 
0049            
0050        <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {
0051           <i>theMonitors</i>[ <i>index</i>] = <b>new</b> <i>WarningCounter</i>();
0052        } // End for.
0053     } // End <i>resetMonitors</i>.

0099     <b>public</b> String <i>toString</i>(){ 
0100  
0101     StringBuffer <i>theString</i> = <b>new</b> <i>StringBuffer</i>();
0102     <b>int</b>          <i>index</i>;
0103     <b>char</b>         <i>theRoom</i> = 'A';
0104     
0105        <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {  
0106           <i>theString</i>.append( &quot;Room &quot; + theRoom + &quot;   &quot; + 
0107                             <i>theMonitors</i>[ <i>index</i>].<i>toString</i>() + &quot;\n&quot;);
0108           <i>theRoom</i>++;                           
0109        } // End for.
0110        <b>return</b> <i>theString</i>.toString(); 
0111     } // End toString;<br>
</font>
</pre>

<p>
The first part of the demonstration harness for this class uses
the constructor to create an instance of the <i>HomogenousMonitors</i>
class and then outputs it to the screen. The implementation of
this part of the harness and the output which it might produce
is as follows. <br>

<pre>
<font>0001  // Filename <i>HomoDemo.java</i>.
0002  // Contains a demonstration harness for the
0003  // <i>HomogenousMonitors</i> class.
0004  //
0005  // Written for JFL Book Chapter 12.
0006  // Fintan Culwin, V 0.1, Jan 1997. 
0007  
0008  <b>import</b> <i>HomogenousMonitors</i>;
0009  
0010  <b>class</b> <i>HomoDemo</i> { 
0011  
0012     <b>public static void</b> <i>main</i>(String <i>args</i>[]) {
0013     
0014     <i>HomogenousMonitors</i> <i>demoMonitors</i>; 
0015     
0016         System.out.println( &quot;\tHomogeneous File Demonstration\n&quot;);
0017      
0018         System.out.println( &quot;\nPreparing and showing the monitors ... \n&quot;);
0019         <i>demoMonitors</i> = <b>new</b> <i>HomogenousMonitors</i>();
0020         System.out.println( <b>demoMonitors</b>);      </font>
</pre>

<p>

<hr>
<ul>

<pre>
<font>	Homogeneous File Demonstration

Preparing and showing the monitors ... 

Room A   Now in room : 5
Room B   Now in room : 0
Room C   Now in room : 2

</font>
</pre>
</ul>
<hr>
<p>
On this run of the program three counters were created and placed
into the states as shown. As aspects of the behaviour of this
program are largely controlled by random numbers a second, or
subsequent, run of the program is unlikely to produce this precise
output. <br>

<p>
All of the actions which have been introduced so far have consolidated
the use of arrays and random numbers which were first introduced
in Chapter 6. The new aspects are introduced in the <i><font FACE="Arial">writeMonitors()</font></i>
and <i><font FACE="Arial">readMonitors()</font></i> actions.
The design of the <i><font FACE="Arial">writeMonitors()</font></i>
action is as follows.<br>

<p>
<center><img SRC="c12p4i3.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/c12p4i3.gif" WIDTH="783" HEIGHT="426">
</center>
<p>
The design indicates that the first action is to create the stream,
using the filename supplied as an argument, and then to write
the number of elements in the array. A definite loop then writes
each element in the array to the stream, identified as <i>theStream</i>,
making use of the write action of the <i>WarningCounter</i> class.
This action was not included in Chapter 4 and its implementation
will be presented shortly. The implementation of the <i><font FACE="Arial">writeMonitor()</font></i>
action is as follows. <br>

<pre>
<font>0056     <b>public void</b> <i>writeMonitors</i>( String <i>filename</i>) { 
0057  
0058     <b>int</b> <i>index</i>;     
0059     DataOutputStream <i>theStream</i>;
0060  
0061        <b>try</b> { 
0062           <i>theStream</i> = <b>new</b> DataOutputStream( 
0063                               <b>new</b> FileOutputStream( <i>filename</i>));
0064           <i>theStream</i>.writeInt( <i>theMonitors</i>.length);                    
0065           <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {
0066              <i>theMonitors</i>[ <i>index</i>].<i>write</i>( <i>theStream</i>);           
0067           } // End for.  
0068           <i>theStream</i>.close();
0069        } <b>catch</b> ( java.io.IOException <i>exception</i>) { 
0070           System.out.println( &quot;Exception thrown on writing ... abending&quot;);
0071           System.exit( -1); 
0072        } // End try/catch.   
0073     } // End <i>writeMonitors</i>.<br>
</font>
</pre>

<p>
The first part of the action, on lines 0062 to 0063, creates a
<font FACE="Arial">DataOutputStream</font> called <i><font FACE="Arial">theStream</font></i>
from a <font FACE="Arial">FileOutputStream</font> associated
with the filename supplied as an argument. This is exactly equivalent
to the creation of <font FACE="Arial">DataInputStream</font>s
earlier in this chapter; the difference between a text stream
and a binary stream is determined by the actions which are applied
to the stream, not to the stream itself. The first of these actions
is on line 0064 where the <i><font FACE="Arial">writeInt()</font></i>
action of <i><font FACE="Arial">theStream</font></i> is
used to output the number of elements in the array to the stream.
<br>

<p>
This is followed by a definite iteration where each <i><font FACE="Arial">WarningCounter</font></i>
in the array has its <i><font FACE="Arial">write()</font></i>
action called, causing its state to be stored in the stream. The
implementation of the <i><font FACE="Arial">WarningCounter'</font></i>s
write action is as follows.<br>

<pre>
<font>0047      // Action to write state to a stream, added for Chapter 12.
0048      <b>public void</b> <i>write</i>( DataOutputStream <i>writeTo</i>) <b>throws</b> IOException{ 
0049           <i>writeTo</i>.writeInt( <b>this</b>.<i>numberCountedIs</i>());
0050      } // End <i>write</i>.<br>
</font>
</pre>

<p>
This action is implemented using the <i><font FACE="Arial">writeInt()</font></i>
action of the stream passed as the <i><font FACE="Arial">writeTo</font></i>
argument. The value which is written is the value of the only
data attribute of this class, obtained using its enquiry action.
<br>

<p>
Once all of the elements have been written the stream's <i><font FACE="Arial">close()</font></i>
action is called. All of the actions concerned with the stream
in the <i><font FACE="Arial">writeMonitors()</font></i>
action may cause an <font FACE="Arial">IOException</font>
to be thrown and an exception handler is supplied which informs
the user and abends the program.<br>

<p>
The remaining action in the <i><font FACE="Arial">HomogeneousMonitors</font></i>
class is the <i><font FACE="Arial">readMonitors()</font></i>
action whose design is as follows.<br>

<p>
<center><img SRC="c12p4i4.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/c12p4i4.gif" WIDTH="769" HEIGHT="570">
</center>
<p>
In many ways this design is comparable to the <i>writeMonitors</i>
design above. It commences by preparing an input stream and then
reads the number of elements from it. Having obtained this information
it can recreate the array with this number of elements, before
iterating through each element of the array creating a new <i><font FACE="Arial">WarningCounter</font></i>
instance and then using its <i>read</i> action to restore its
state from the stream. The implementation of this design is as
follows. <br>

<pre>
<font>0076     <b>public void</b> <i>readMonitors</i>( String <i>filename</i>) { 
0077  
0078     <b>int</b> <i>index</i>; 
0079     <b>int</b> <i>numberOfMonitors</i>;    
0080     DataInputStream <i>theStream</i>;
0081  
0082        <b>try</b> { 
0083           <i>theStream</i> = <b>new</b> DataInputStream( 
0084                               <b>new</b> FileInputStream( <i>filename</i>));
0085           <i>numberOfMonitors</i> = <i>theStream</i>.readInt();
0086           <i>theMonitors</i> = <b>new</b> <i>WarningCounter</i>[ <i>numberOfMonitors</i>]; 
0087           <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {
0088              <i>theMonitors</i>[ <i>index</i>] = <b>new</b> <i>WarningCounter</i>();
0089              <i>theMonitors</i>[ <i>index</i>].<i>read</i>( <i>theStream</i>);           
0090           } // End for.  
0091           <i>theStream</i>.close();
0092        } <b>catch</b> ( java.io.IOException <i>exception</i>) { 
0093           System.out.println( &quot;Exception thrown on reading ... abending&quot;);
0094           System.exit( -1); 
0095        } // End try/catch.   
0096     } // End <i>readMonitors</i>.<br>
</font>
</pre>

<p>
On line 0085 the <i><font FACE="Arial">readInt()</font></i>
action of <i><font FACE="Arial">theStream</font></i> is
used to read the number of elements back from the stream into
the local variable <i><font FACE="Arial">numberOfMonitors</font></i>.
This value is then used on line 0086 to re-determine the bounds
of <i><font FACE="Arial">theMonitors</font></i> array.
This action, of resetting the bounds of an array which already
has bounds and contents causes the existing contents of the array
to be disposed of. Consequently there is no requirement that the
new bounds of the array are equal to the old bounds of the array.
<br>

<p>
The definite loop on lines 0087 to 0090 then iterates through
the array where, on line 0088, a new <i><font FACE="Arial">WarningCounter</font></i>
instance is created and its <i><font FACE="Arial">read()</font></i>
action is used on line 0089 to restore its state from the stream.
The <i><font FACE="Arial">read()</font></i> action of the
<i><font FACE="Arial">WarningCounter</font></i> class has
also been added for this chapter. Its declaration is as follows.
<br>

<pre>
<font>0053       // Action to read the state from a stream, added for Chapter 12.
0054       <b>public void</b> <i>read</i>( DataInputStream <i>readFrom</i>) <b>throws</b> IOException{
0055            <b>this</b>.<i>setCountTo</i>( <i>readFrom</i>.readInt()); 
0056       } // End read.<br>
</font>
</pre>

<p>
On line 0055 the <i><font FACE="Arial">readInt()</font></i>
action of the <i><font FACE="Arial">readFrom</font></i>
stream, passed as an argument, is used to obtain an integer value
from the input stream. This value is then used as the argument
of the <i><font FACE="Arial">BasicCounter setCountTo()</font></i>
action, which the <i><font FACE="Arial">WarningCounter</font></i>
has inherited, to restore the state of the single data attribute.
<br>

<p>
The remaining parts of the <i><font FACE="Arial">HomogenousMonitor
readMonitors()</font></i> action are concerned with closing the
stream and handling any exceptions in a manner comparable with
the <i><font FACE="Arial">writeMonitors()</font></i> action.
The remaining parts of the demonstration harness demonstrate the
<i><font FACE="Arial">writeMonitors(),</font></i> <i><font FACE="Arial">resetMonitors()</font></i>
and <i><font FACE="Arial">readMonitors()</font></i> actions,
as follows. <br>

<pre>
<font>0022         System.out.println( &quot;\nWriting the monitors ... &quot;);
0023         <i>demoMonitors.writeMonitors</i>( &quot;Homo.dat&quot;);
0024  
0025         System.out.println( &quot;\nResetting and showing the monitors ... &quot;);
0026         <i>demoMonitors.resetMonitors</i>();
0027         System.out.println( <i>demoMonitors</i>); 
0028         
0029         System.out.println( &quot;\nReading and showing the monitors ... &quot;);
0030         <i>demoMonitors.readMonitors</i>( &quot;Homo.dat&quot;);
0031         System.out.println( <i>demoMonitors</i>);        
0032      } // End main.
0033  } // End <i>HomoDemo</i>.<br>
</font>
</pre>

<p>
The output from this part of the harness is as follows. 
<p>
<hr>
<ul>
<pre>
<font>Writing the monitors ... 
	
Resetting and showing the monitors ... 
Room A   Now in room : 0
Room B   Now in room : 0
Room C   Now in room : 0
	
Reading and showing the monitors ... 
Room A   Now in room : 5
Room B   Now in room : 0
Room C   Now in room : 2</font>

</pre>
</ul>
<hr>

<p>
Which seems to show that the information in the <i><font FACE="Arial">HomogenousCounters</font></i>
instance has been successfully written to and read back from a
file. After this program has been executed a file called &quot;Homo.dat&quot;
will exist in the file system. Unlike the text files produced
earlier in this chapter this file is not intended to be read by
humans; this can be verified by loading it into a text editor
and attempting to examine its contents. The precise details of
the contents of the file might differ from compiler to compiler
and a detailed consideration of them is outside the scope of this
book.<br>
<br>


<p>
<hr>
<h2>
<ul>
<a HREF="homogenousmonitors.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/HomogenousMonitors.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i> HomogenousMonitors.java</i> source code</a>.
<p>
<a HREF="homodemo.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/HomoDemo.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>HomoDemo.java</i> source code</a>.
<p>
<a HREF="chap12p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/chap12p5.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
12.5 Heterogeneous binary streams</a>.
<p>
<a HREF="chap12p3.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/chap12p3.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
12.3 An output file stream</a>.
</ul>
</h2>
<hr>
</body>

</html>
&#26;