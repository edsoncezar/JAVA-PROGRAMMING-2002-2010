<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>12.5 Heterogeneous binary streams</title>

</head>

<body BGCOLOR="WHITE">

<h2>12.5 Heterogeneous binary streams<br>
</h2>

<p>
The homogenous data structure developed and demonstrated in the
previous section was only capable of writing and reading instances
of the <i><font FACE="Arial">WarningCounters</font></i>
class. This section will introduce the considerations concerned
with the writing and reading of streams which can contain instances
of different classes. <br>

<p>
To accomplish this a comparable class called <i><font FACE="Arial">HeterogenousMonitors</font></i>
will be developed which is capable of containing a mixture of
<i><font FACE="Arial">WarningCounter</font></i> and <i><font FACE="Arial">RoomMonitor</font></i>
instances. As with the version of the <i><font FACE="Arial">WarningCounter</font></i>
used above the <i><font FACE="Arial">RoomMonior</font></i>
will require some additional actions, compared with the version
presented in Chapter 4, for it to be suitable. <br>

<p>
The first change is to add a <i><font FACE="Arial">count()
</font></i>action as suggested in Exercise 5.3. This is essential
in this implementation in order that an instance of the <i><font FACE="Arial">RoomMonitor</font></i>
class can respond appropriately to a <i><font FACE="Arial">count()</font></i>
action. Also, as with the <i><font FACE="Arial">WarningCounter</font></i>
class, a <i><font FACE="Arial">write()</font></i> and a
 <i><font FACE="Arial">read() </font></i>action will have
to be supplied. The implementation of these three actions in the
revised <i><font FACE="Arial">RoomMonitor</font></i> class
definition is as follows. <br>

<pre>
<font>0069       // Action to ensure count() acts appropriately, added for Chapter 12.
0070       <b>public void</b> <i>count</i>() { 
0071            <b>this</b>.<i>enterRoom</i>();
0072       } // End count.
0073
0074       // Action to write the state to a stream, added for Chapter 12.
0075       <b>public void</b> <i>write</i>( DataOutputStream <i>writeTo</i>) <b>throws</b> IOException{ 
0076           <b>super</b>.<i>write</i>( <i>writeTo</i>);
0077           <i>writeTo</i>.writeInt( <i>maxEverInRoom</i>);
0078           <i>writeTo</i>.writeInt( <i>totalNumberEntered</i>);
0079       } // End <i>write</i>.
0080   
0081       // Action to read the state from a stream, added for Chapter 12.
0082       <b>public void</b> <i>read</i>( DataInputStream <i>readFrom</i>) <b>throws</b> IOException{
0083           <b>super</b>.<i>read</i>( <i>readFrom</i>);
0084           <i>maxEverInRoom</i>      = <i>readFrom</i>.readInt();
0085           <i>totalNumberEntered</i> = <i>readFrom</i>.readInt();
0086       } // End <i>read</i>.<br>
</font>
</pre>

<p>
The <i><font FACE="Arial">count()</font></i> declaration
ensures that a call of the <i><font FACE="Arial">count()</font></i>
action has exactly the same effect as a call of the existing <i><font FACE="Arial">enterRoom()</font></i>
action by indirecting to it. The <i><font FACE="Arial">write()</font></i>
action commences by calling its parent's (<i><font FACE="Arial">WarningCounter</font></i>)
<i><font FACE="Arial">write()</font></i> action, in order
for it to write its single data attribute, and then uses the <i><font FACE="Arial">writeTo
writeInt()</font></i> action to write its own data attributes
to the stream. The <i><font FACE="Arial">read()</font></i>
action is the inverse of this, first calling its parent's <i><font FACE="Arial">read()</font></i>
action and then reading, and restoring, its own two additional
data attributes.<br>

<p>
The class diagram for the <i><font FACE="Arial">HeterogeneousMonitors</font></i>
class does not differ significantly from that presented for the
<i><font FACE="Arial">HomogenousMonitors</font></i> class,
offering exactly the same actions. The design of the constructor
differs only very slightly from the <i><font FACE="Arial">HomogenousMonitors
</font></i>constructor, by randomly deciding between constructing
an instance of a <i><font FACE="Arial">WarningMonitor</font></i>
and of a <i><font FACE="Arial">RoomMonitor</font></i>.
The implementation of the class as far as the end of the constructor
is as follows. <br>

<pre>
<font>0001  // Filename HeterogenousMonitors.java.
0002  // Contains an indeterminate number of WarningCounter 
0003  // or RoomMonitor instances with actions to write and 
0004  // read them from a stream. 
0005  //
0006  // Written for JFL Book Chapter 12.
0007  // Fintan Culwin, V 0.1, Jan 1997. 
0008  
0009  <b>import</b> Counters.WarningCounter;
0010  <b>import</b> Counters.RoomMonitor;
0011  <b>import</b> java.io.*;
0012  <b>import</b> java.util.Random;
0013  <b>import</b> java.util.Date;
0014  
0015  
0016  <b>class</b> HeterogenousMonitors { 
0017  
0018  <b>private</b>  Random generator = <b>new</b> Random( <b>new</b> Date().getTime()); 
0019  <b>private</b>  WarningCounter theMonitors[];
0020  
0021      
0022     <b>public</b> HeterogenousMonitors(){
0023     
0024     <b>int</b> numberOfMonitors = 2 + 
0025                 (<b>int</b>) (generator.nextDouble() * 5.0);
0026     <b>int</b> index; 
0027     <b>int</b> anotherIndex;
0028     <b>int</b> numberOfOccurrences; 
0029                      
0030        theMonitors = <b>new</b> WarningCounter[ numberOfMonitors];
0031        <b>for</b> ( index =0; index &lt; numberOfMonitors; index++) {
0032           <b>if</b> (generator.nextDouble() &gt; 0.5) {     
0033              theMonitors[ index] = <b>new</b> WarningCounter();
0034           } <b>else</b> { 
0035              theMonitors[ index] = <b>new</b>  RoomMonitor();
0036           } // End if.   
0037           numberOfOccurrences = 10 + 
0038                         (<b>int</b>) (generator.nextDouble() * 20.0);
0039           <b>for</b> ( anotherIndex =0; 
0040                 anotherIndex &lt; numberOfOccurrences;
0041                 anotherIndex++) {                      
0042              <b>if</b> ( (generator.nextDouble() &gt; 0.5)              &amp;&amp;
0043                   (theMonitors[ index].numberCountedIs() &gt; 0) ){
0044                 theMonitors[ index].unCount();  
0045              } <b>else</b> { 
0046                 theMonitors[ index].count(); 
0047              } // End if.
0048           } // End for.                         
0049        } // End for.  
0050     } // End HeterogenousMonitors constructor.<br>
</font>
</pre>

<p>
This constructor differs significantly on lines 0032 to 0036 where
there is a 50/&nbsp;50 chance of it constructing a <i><font FACE="Arial">WarningCounter</font></i>
or a <i><font FACE="Arial">RoomMonitor</font></i>. The
array <i><font FACE="Arial">theMonitors</font></i> is declared,
on line 0019, as an array of <i><font FACE="Arial">WarningCounters</font></i>
yet on line 0035 a <i><font FACE="Arial">RoomMonitor</font></i>
instance might be stored in one of its elements. This is acceptable
to Java as a <i><font FACE="Arial">RoomMonitor</font></i>
<i><b>is&nbsp;a</b></i>n extended <i><font FACE="Arial">WarningCounter</font></i>.
<br>

<p>
The implementation of the <i><font FACE="Arial">toString()</font></i>
action in the <i><font FACE="Arial">HeterogenousMonitors</font></i>
class is exactly identical to its implementation in the <i><font FACE="Arial">HomogenousMonitors</font></i>
class and the implementation of the demonstration client is essentially
identical to the previous demonstration client. The output produced
by a run of the demonstration client, up to the point where an
instance of the <i><font FACE="Arial">HeterogenousMonitors</font></i>
has been created and output might be as follows. <br>
<p>
<hr>
<ul>
<pre>
<font>Heterogeneous File Demonstration


Preparing and showing the monitors ...

Room A   Now in room : 5
Room B   Now in room : 1 Max in room : 3 Total entered : 10<br>
</font>
</pre>
</ul>
<hr>

<p>
Which indicates that a <i><font FACE="Arial">WarningCounter</font></i>
is stored in the first element of the array and a RoomMonitor
in the second. It also indicates that the call of the <i><font FACE="Arial">count()</font></i>
action on line 0046 will <i><b>dynamically dispatch</b></i> to
the appropriate <i><font FACE="Arial">count()</font></i>
action. That is, if the instance is a <i><font FACE="Arial">WarningCounter</font></i>
instance then Java will call the <i><font FACE="Arial">WarningCounter
count()</font></i> action, if it is a <i><font FACE="Arial">RoomMonitor</font></i>
instance it will call the <i><font FACE="Arial">RoomMonitor
count()</font></i> action. It is only able to make this decision
when the program is running as the decision on whether an element
in the array is a <i><font FACE="Arial">RoomMonitor</font></i>
or a <i><font FACE="Arial">WarningCounter</font></i> is
not made until the program is executing. Likewise the appropriate
<i><font FACE="Arial">toString()</font></i> action will
be called to produce the representation of the state of each monitor.
The <i><font FACE="Arial">resetMonitor()</font></i> action
has similar changes to the constructor, randomly deciding to create
a <i><font FACE="Arial">RoomMonitor</font></i> or a <i><font FACE="Arial">WarningCounter</font></i>
instance. <br>

<p>
Before considering the <i><font FACE="Arial">writeMonitors()</font></i>
and <i><font FACE="Arial">readMonitors()</font></i> actions
a small digression is essential. When the homogenous data file
was written in the previous section it consisted of an integer
value indicating the number of items stored in the file followed
by that many <i><font FACE="Arial">WarningCounter</font></i>s.
The heterogeneous file which will be written by this class will
also commence with an integer value indicating the number of items
which follow it. However each item in the file might be a <i><font FACE="Arial">WarningCounter</font></i>
or it might be a <i><font FACE="Arial">RoomMonitor</font></i>
and there has to be some way of deciding which is which. <br>

<p>
One way to accomplish this might be to write a single character
before each item in the file. If the character is a 'w' it might
indicate that a <i><font FACE="Arial">WarningCounter</font></i>
is stored next, if it is a 'r' a <i><font FACE="Arial">RoomMonitor</font></i>.
This would work for this example, but if at some stage in the
future an addition extended <i><font FACE="Arial">WarningCounter</font></i>
were to be stored in the file then the <i><font FACE="Arial">write()
</font></i>action and the <i><font FACE="Arial">read()</font></i>
action would require extensive modification. Development by extension
is intended to avoid precisely this situation. If an additional
class is added to a class hierarchy at some time in the future
then all existing code, with the obvious exception of user interfaces,
should not require any changes.<br>

<p>
Java provides facilities for exactly this situation. The <font FACE="Arial">Object</font>
class from which all other classes in Java are directly or indirectly
descended from supplies a final <font FACE="Arial">getClass()</font>
action which returns an instance of the <font FACE="Arial">Class</font>
class. An instance of the <font FACE="Arial">Class </font>class
provides a system descriptor of the class and the <font FACE="Arial">Class
getName()</font> action will return a <font FACE="Arial">String</font>
containing the name of the class. Thus for any instance of any
class the term <i><font FACE="Arial">anyInstance</font></i><font FACE="Arial">.Class().getName()</font>
will return a <font FACE="Arial">String</font> containing
the name of the class. This technique can be used in the <i><font FACE="Arial">writeMonitors()</font></i>
action to write a description of the class before each class is
written, as follows. <br>

<pre>
<font>0066     <b>public void</b> <i>writeMonitors</i>( String <i>filename</i>) { 
0067  
0068     <b>int</b> <i>index</i>;     
0069     DataOutputStream <i>theStream</i>;
0070  
0071         <b>try</b> { 
0072            <i>theStream</i> = <b>new</b> DataOutputStream( 
0073                                <b>new</b> FileOutputStream( <i>filename</i>));
0074            <i>theStream</i>.writeInt( <i>theMonitors</i>.length);                    
0075            <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {
0076               <i>theStream</i>.writeUTF( <i>theMonitors</i>[ <i>index</i>].getClass().getName());
0077               <i>theMonitors</i>[ <i>index</i>].write( <i>theStream</i>);           
0078            } // End for.  
0079            <i>theStream</i>.close();
0080         } <b>catch</b> ( java.io.IOException <i>exception</i>) { 
0081            System.out.println( &quot;Exception thrown on writing ... abending&quot;);
0082            System.exit( -1); 
0083         } // End try/catch.   
0084     } // End <i>writeMonitors</i>.<br>
</font>
</pre>

<p>
On line 0076 the name of the class stored in each location in
the array is obtained and written to the stream. The <font FACE="Arial">writeUTF()</font>
action should be used when a String value is written to a binary
stream, and subsequently read using <i><font FACE="Arial">readUTF()</font></i>
as will be shown below. The effect of this action is to write
the number of items to the stream and then write each element
stored in the array, preceded by a UTF encoded <font FACE="Arial">String</font>
describing its contents. Thus, if at some stage in the future
an additional class is added to the hierarchy, no changes will
be required to this action as the UTF description will be automatically
written to the stream.<br>

<p>
The <i><font FACE="Arial">HeterogeneousMonitors readMonitors()</font></i>
action must be able to read the UTF description of which class
is stored next in the stream, create an instance of that particular
class and then read the next item from the stream. This is accomplished
within the <i><font FACE="Arial">readMonitors()</font></i>
action on lines 0104 to 0108. <br>

<pre>
<font>0087     <b>public void</b> <i>readMonitors</i>( String <i>filename</i>) { 
0088  
0089     <b>int    </b> <i>index</i>; 
0090     <b>int    </b> <i>numberOfMonitors</i>; 
0091     
0092     String  <i>className</i>;
0093     Class   <i>theClass</i>;
0094     Object  <i>anObject</i>;
0095        
0096     DataInputStream <i>theStream</i>;
0097  
0098         <b>try</b> { 
0099            <i>theStream</i> = <b>new</b> DataInputStream( 
0100                                <b>new</b> FileInputStream( <i>filename</i>));
0101            <i>numberOfMonitors</i> = <i>theStream</i>.readInt();
0102            <i>theMonitors</i> = <b>new</b> <i>WarningCounter</i>[ <i>numberOfMonitors</i>]; 
0103            <b>for</b> ( <i>index</i> =0; <i>index</i> &lt; <i>theMonitors</i>.length; <i>index</i>++) {
0104               <i>className</i> = <i>theStream</i>.readUTF();    
0105               <i>theClass</i>  = Class.forName( <i>className</i>);
0106               <i>anObject</i>  = <i>theClass</i>.newInstance();
0107               <i>theMonitors</i>[ <i>index</i>]  = (<i>WarningCounter</i>) <i>anObject</i>;
0109               <i>theMonitors</i>[ <i>index</i>].<i>read</i>( <i>theStream</i>);           
0110            } // End for.  
0111            theStream.close();
0112         } <b>catch</b> ( Exception <i>exception</i>) { 
0113            System.out.println( &quot;Exception thrown on writing ... abending&quot;);
0114            System.exit( -1); 
0115         } // End try/catch.   
0116     } // End <i>writeMonitors</i>.<br>
</font>
</pre>

<p>
On line 0104 the UTF string description of the class which follows
is read from the stream and stored as a normal <i><font FACE="Arial">String</font></i>
in the local variable. An instance of the <font FACE="Arial">Class</font>
<font FACE="Arial">class</font>, which describes the class
to the system, is then created using the <font FACE="Arial">Class</font>
<font FACE="Arial">forName()</font> action passing the
<font FACE="Arial">String</font> <i><font FACE="Arial">className</font></i>
as an argument, on line 0105. Having obtained a <font FACE="Arial">Class</font>
instance, called <i><font FACE="Arial">theClass</font></i>,
which describes the class which is about to be read from the stream,
its <font FACE="Arial">newInstance()</font> action is used
to create a new instance of the class described in <i><font FACE="Arial">anObject</font></i>,
on line 0106. This instance, of the appropriate type, can be assigned,
with type qualification, to an element of the <i><font FACE="Arial">theMonitors</font></i>
array, on line 0107. Having done all this its <i><font FACE="Arial">read()</font></i>
action can be used to initialise itself from the stream, on line
0108.<br>

<p>
It might appear that there is a fault in line 0107, if the instance
being read is a <i><font FACE="Arial">RoomMonitor</font></i>.
However as a <i><font FACE="Arial">RoomMonitor</font></i>
<i><b>is a</b></i>n extended <i><font FACE="Arial">WarningCounter</font></i>
instance this as acceptable to Java. The demonstration client
below will show that even if the instance being read is a <i><font FACE="Arial">RoomMonitor
</font></i>it is recovered from the stream and stored in the array.
<br>

<p>
The remaining output of the demonstration test harness again indicates
that the <i><font FACE="Arial">writeMonitor()</font></i>
and <i><font FACE="Arial">readMonitor()</font></i> actions
seem to be effective.<br>

<p>
<hr>
<ul>
<pre>
<font>Writing the monitors ...

Resetting and showing the monitors ...
Room A   Now in room : 0 Max in room : 0 Total entered : 0
Room B   Now in room : 0 Max in room : 0 Total entered : 0
Room c   Now in room : 0 


Reading and showing the monitors ...
Room A   Now in room : 5
Room B   Now in room : 1 Max in room : 3 Total entered : 10<br>


</pre>
</ul>

<hr>

<p>
In this run of the program the <i><font FACE="Arial">resetMonitor()</font></i>
action has, by chance, created an array of three elements the
first two of which are <i><font FACE="Arial">RoomMonitor</font></i>s
and the third is a <i><font FACE="Arial">WarningMonitor</font></i>.
The <i><font FACE="Arial">readMonitor()</font></i> action
restores the state which was shown, before it was written, above.
<br>
<br>

<p>
<hr>
<h2>
<ul>
<a HREF="heterogeneousmonitors.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/HeterogeneousMonitors.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>HeterogenousMonitors.java</i> source code</a>.
<p>
<a HREF="heterodemo.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/HeteroDemo.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>HomoDemo.java</i> source code</a>.
<p>
<a HREF="chap12sum.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/chap12sum.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Summary of Chapter 12</a>.
<p>
<a HREF="chap12p4.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter12/chap12p4.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
12.4 Homogenous binary streams</a>.
</ul>
</h2>
<hr>
</body>

</html>
&#26;