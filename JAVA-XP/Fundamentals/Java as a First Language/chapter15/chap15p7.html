<html>

<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>15.7 The TreeNode class and BinaryTree add action</title>
</head>

<body bgcolor="#FFFFFF">

<h2>15.7 The <i>TreeNode</i> class and <i>BinaryTree</i> <i>add</i>
action<br>
</h2>

<p>The class diagram of the <i>BinaryTree</i> class does not
differ significantly from that of the <i>LinkedList</i> class
given in Figure 15.3. The encapsulated node class is known as the
<i>TreeNode</i> class and the Enumeration class as the <i>BinaryTreeEnumeration</i>.
The class diagram for the <i>TreeNode</i> class differs from that
of the <i>ListNode</i> class by having enquiry and attribute
changing actions for each of the links. Its class diagram is
given in Figure 15.13.<br>
</p>

<p align="center"><img src="c15p7i1.gif" width="502" height="390"
tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p7i1.gif"> </p>

<p>The class diagram is incomplete, shown by the dotted lines,
for reasons which will be explained below. The implementation of
this design is as follows. <br>
</p>

<pre>
0255  ///////////////////////////////////////////////////////// 
0256  // Private <i>TreeNode</i> class, providing the nodes which   //
0257  // are linked together to implement the <i>BinaryTree</i>.    //
0258  ///////////////////////////////////////////////////////// 
0259  
0260  
0261  <b>class</b> <i>TreeNode</i> { 
0262  
0263  <i>Keyable</i>  <i>theData</i>;
0264  <i>TreeNode</i> <i>leftSubTree</i>;
0265  <i>TreeNode</i> <i>rightSubTree</i>;
0266  
0267      <b>protected</b> <i>TreeNode</i>( <i>Keyable toStore</i>){ 
0268         <i>theData</i>        = <i>toStore.copy()</i>;
0269         <i>leftSubTree</i>    = <b>null</b>;
0270         <i>rightSubTree</i>   = <b>null</b>;
0271      } // End <i>TreeNode</i> constructor.
0272  
0273      <b>protected</b> <i>Keyable dataIs</i>(){ 
0274         <b>return</b> <i>theData.copy()</i>;
0275      } // End <i>dataIs</i>.
0276      
0277      <b>protected</b> <i>TreeNode</i> <i>leftTreeIs</i>(){ 
0278         <b>return</b> <i>leftSubTree</i>;
0279      } // End <i>leftTreeIs</i>. 
0280      
0282      <b>protected</b> <i>TreeNode</i> <i>rightTreeIs</i>(){ 
0283         <b>return</b> <i>rightSubTree</i>;
0284      } // End <i>rightTreeIs</i>. 
0285      
0286      <b>protected void</b> <i>setLeftTree</i>( <i>TreeNode setTo</i>) { 
0287         <i>leftSubTree</i>  = <i>setTo</i>;
0288      } // End <i>setLeftTree</i>.
0289      
0290      <b>protected void</b> <i>setRightTree</i>( <i>TreeNode setTo</i>) { 
0291         <i>rightSubTree</i>  = <i>setTo</i>;
0292      } // End <i>setRightTree</i>.  
0293      

0302  } // End <b>class</b> <i>TreeNode</i>.


</pre>

<p>The encapsulated <i>leftSubTree</i> and <i>rightSubTree</i>
attributes of this <b>class</b> are themselves instances of the <b>class</b>
being declared and so are recursively contained within it. The
constructor actions are comparable with the actions of the <i>ListNode</i>
class above, with the exception that a new node can only be
constructed with empty (<b>null</b>) sub trees. The design of the
<i>add()</i> action is as follows. <br>
</p>

<p align="center"><img src="c15p7i2.gif" width="709" height="705"
tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p7i2.gif"> </p>

<p>The <i>add()</i> action itself is concerned with dealing with
the special case of adding to an empty tree, in all other cases
it calls the <b>private</b> action <i>addNode().</i> This action
will decide, using the key of the element to be added and the key
of the current node, if it is to add the element to the left sub
tree or to the right sub tree. Assuming it is to be added to the
left sub-tree, if this tree is empty a new node will be
constructed and added to it. Otherwise it calls the <i>addNode</i>
action passing as the <i>addHere</i> argument the left node. A
similar pattern of actions happens if the new element is to be
added to the right tree. The implementation of this design is as
follows. <br>
</p>

<pre>
0033     <b>public void</b> <i>add</i>(<i> Keyable</i> <i>toAdd</i>) {
0035        <b>if</b> ( <i>theTree</i> == <b>null</b>) {  
0036             <i>theTree</i> = <b>new</b> <i>TreeNode</i>( <i>toAdd</i>);
0037             <i>numberOfElements</i>++;
0038        } <b>else</b> { 
0039             <i>addNode</i>( <i>theTree</i>, <i>toAdd.keyToAdd()</i>, <i>toAdd</i>); 
0040        } // End if. 
0041     } // End add.
0042  
0043  
0044     <b>private void</b> <i>addNode</i>( <i>TreeNode</i>  <i>addHere</i>,
0045                           <i>Orderable</i> <i>keyToAdd</i>,
0046                           <i>Keyable</i>   <i>toAdd</i>) {
0047                           
0048       <b>if</b> ( <i>keyToAdd.keyIsEqualTo</i>( 
0049                      <i>addHere.dataIs</i>().<i>keyValueIs</i>())) { 
0050          <b>throw new</b> <i>AlreadyPresentException</i>();                
0051       } <b>else if</b> ( <i>keyToAdd.keyIsLessThan</i>( 
0052                      <i>addHere.dataIs</i>().<i>keyValueIs</i>())) { 
0053           <b>if</b> ( <i>addHere</i>.<i>leftTreeIs</i>() == <b>null</b>) { 
0054              <i>addHere.setLeftTree</i>( <b>new</b> <i>TreeNode</i>( <i>toAdd</i>));
0055              <i>numberOfElements</i>++;
0056           } <b>else</b> {                   
0057              <i>addNode</i>( <i>addHere.leftTreeIs</i>(), <i>keyToAdd</i>, <i>toAdd</i>);
0058           } // End if.                                       
0059        } <b>else</b> {
0060           <b>if</b> ( <i>addHere.rightTreeIs</i>() == <b>null</b>) { 
0061              <i>addHere.setRightTree</i>( <b>new</b> <i>TreeNode</i>( <i>toAdd</i>));
0062              <i>numberOfElements</i>++;
0063           } <b>else</b> {              
0064              <i>addNode</i>( <i>addHere.rightTreeIs</i>(),<i>keyToAdd</i>, <i>toAdd</i>);
0065           } // End if.
0066        } // End if.                                   
0067     } // End <i>addNode</i>.                    


</pre>

<p>This implementation should become clearer if a trace of an
addition is considered. Assuming that a tree is in the state
shown in the fifth diagram of Figure 15.12, the addition of the <i>dull</i>
element will proceed as follows. <br>
</p>

<p>As <i>theTree</i> is not empty the test in <i>add()</i> on
line 0035 will be <b>false</b> and the <i>addNode()</i> action
will be called passing <i>theList</i> as the <i>addHere</i>
argument. Within <i>addNode</i> the test on line 0048 will be <b>false</b>
and that on line 0051 <b>true</b>, as the key of the element
being added, <i>dull</i>, is alphabetically lower than the
element stored at the root, <i>geek</i>. The test on line 0053
will be <b>false</b> as the left sub tree of the <i>geek</i> node
is not empty. So the action on line 0057 will be executed,
recursively calling <i>addNode</i> and passing <i>geek</i>'s left
subtree as the <i>addHere</i> argument. This is a recursive call
of <i>addNode</i>, as the call is made within the execution of <i>addNode</i>,
and for this reason is shown in a double bounded box in the
design. <br>
</p>

<p>On this second call <i>addHere</i> refers to the <i>boring</i>
node and the condition on line 0048 will again be <b>false</b>
and that on line 0051, effectively <i>dull </i>&lt; <i>boring</i>,
will be <b>false</b>. The condition on line 0060 will be <b>true</b>
as the right hand sub tree of the <i>boring</i> node is empty.
Execution of line 0061 will create a new node, linked to the
right of the <i>boring</i> node, containing the name <i>dull</i>
and with two empty sub trees and subsequently increment the <i>numberOfElements</i>
attribute. This is the state shown in the last diagram in Figure
15.12 as expected.<br>
</p>

<p>At this point execution of the second call of <i>addNode()</i>
will terminate and flow of control will return to the point in
the first call of <i>addNode()</i> where the second call was
recursively invoked. This was line 0057 and the next step in this
call is to terminate, returning flow of control to the <i>add()</i>
action on line 0039 which also terminates. This recursive descent
and ascent of flow of control is an important consideration in
the actions which follow.<br>
</p>

<p>The complexity of this implementation of the <i>BinaryTree add()</i>
action should be compared with that of the <i>LinkedList add()</i>
action. Allowing for the consideration that recursive control
structures are cognitively more complex than sequence, selection
and iteration, it should be clear that this action is much
simpler.<br>
<br>
</p>

<hr>

<ul>
    <li><a href="binarytree.java"
        tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/BinaryTree.java"><img
        src="..\next.gif" align="middle" border="0" width="50"
        height="40"
        tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif"> Send
        the <i>BinaryTree.java</i> source code</a>. <p><a
        href="chap15p8.html"
        tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p8.html"><img
        src="..\next.gif" align="middle" border="0" width="50"
        height="40"
        tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif"> 15.8
        The <i>BinaryTree</i> <i>obtain(),</i> <i>isPresent()</i>
        and <i>toString()</i> actions</a>. </p>
        <p><a href="chap15p6.html"
        tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p6.html"><img
        src="..\last.gif" align="middle" border="0" width="50"
        height="40"
        tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif"> 15.6
        Binary Trees</a>. </p>
    </li>
</ul>

<hr>
</body>
</html>
