<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>15.4 The linked list obtain(), remove() and isPresent() actions</title>

</head>

<body BGCOLOR="WHITE">

<h2>15.4 The linked list <i>obtain(),</i> <i>remove()</i> and <i>isPresent()</i> actions<br>
</h2>

<p>
These three actions are essentially very similar. Only the <i>obtain()</i>
action, whose design follows, will be described in detail. <br>

<p>
<center><img SRC="c15p4i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p4i1.gif" WIDTH="568" HEIGHT="333">
</center>
<p>
Again the explanation of this design will be by a trace of its
implementation, which is as follows. 

<pre>
0086     <b>public</b> <i>Keyable</i> obtain( <i>Orderable keyToObtain</i>) {
0087      
0088     <i>ListNode</i> <i>thisNode</i>  = <i>theList</i>;
0089     <b>boolean</b>  <i>found</i>     = <b>false</b>;
0090     <b>boolean</b>  <i>exhausted</i> = <b>false</b>;
0091     
0092        <b>while</b> ( !<i>found</i> &amp;&amp; !<i>exhausted</i>) { 
0093          <b>if</b> ( <i>thisNode</i> == <b>null</b>) { 
0094             <i>exhausted</i> = <b>true</b>;
0095          } <b>else if</b> ( <i>keyToObtain.keyIsEqualTo</i>( 
0096                           <i>thisNode.dataIs</i>().<i>keyValueIs</i>()) ){ 
0097             <i>found</i> = <b>true</b>;  
0098          } <b>else</b> { 
0099             <i>thisNode</i> = <i>thisNode.nextIs</i>();
0100          } // End if.
0101        } // End while. 
0102                   
0103        <b>if</b> ( <i>found</i> ) { 
0104           <b>return</b> <i>thisNode.dataIs</i>().<i>copy</i>();
0105        } <b>else</b> { 
0106           <b>throw new</b> <i>NoSuchElementException</i>();
0107        } // End if.            
0108     } // End obtain.  <br>

</pre>

<p>
Assuming the list in Figure 15.9 is being used and the element
<i>geek@nowhere.edu</i> is wanted to be <i>obtain</i>ed.
The loop condition on line 0092 evaluates <b>true</b>
when it is evaluated for the first time. The <i>thisNode</i>
local variable will reference <i>anorak@boring.com</i> so the
condition on line 0093 will be <b>false</b>
casing the condition on lines 0095 to 0096 to be evaluated, which
will also be <b>false</b>. The
execution of line 0099 will cause <i>thisNode</i>
to move down the list to the <i>geek</i> node. The loop will iterate
for a second time with the condition on line 0093 evaluating <b>false</b>
again, and that on line 0095 and 0096 <b>true</b>.
This will terminate the loop as line 0097 sets the <i>found</i>
flag <b>true</b>. The condition
on line 0103 will be <b>true</b>
causing the statement on line 0104 to return a copy of the element
referenced by <i>thisNode</i>.
<br>

<p>
If the element <i>notinlist@nowhere.gov</i> were being <i>obtain</i>ed
the iteration would have continued until <i>theNode</i>
had moved down to the end of the list and taken the <b>null</b>
value of the <i>sad</i> node's link. This would then cause the
condition on line 0093 to be <b>true</b>,
subsequently the <i>exhausted</i>
flag would become <b>true</b>
and the exception would be <b>throw</b>n
on line 0106. The implementation of the <i>isPresent()</i>
action is essentially identical.<br>

<pre>
0147     <b>public  boolean</b> <i>isPresent</i>( <i>Orderable keyToCheck</i>){
0148     
0149     <i>ListNode</i> <i>thisNode</i>  = <i>theList</i>;
0150     <b>boolean</b>  <i>found</i>     = <b>false</b>;
0151     <b>boolean</b>  <i>exhausted</i> = <b>false</b>;
0152     
0153        <b>while</b> ( !<i>found</i> &amp;&amp; !<i>exhausted</i>) { 
0154          <b>if</b> ( <i>thisNode</i> == <b>null</b>) { 
0155             <i>exhausted</i> = <b>true</b>;
0156          } <b>else if</b> ( <i>keyToCheck.keyIsEqualTo</i>( 
0157                           <i>thisNode.dataIs</i>().<i>keyValueIs</i>())) { 
0158             <i>found</i> = <b>true</b>;  
0159          } <b>else</b> { 
0160             <i>thisNode</i> = <i>thisNode.nextIs</i>();
0161          } // End if.
0162        } // End while.            
0163        <b>return</b> <i>found</i>;
0164     } // End <i>isPresent</i>.    <br>

</pre>

<p>
The <i>remove()</i> action differs
by also maintaining a <i>lastNode</i>
link which always references the node before <i>thisNode</i>.
If the node to be removed is <i>found</i>,
the value of the <i>lastNode</i>
is manipulated to remove <i>thisNode</i>
from the list. The implementation of the <i>remove()</i>
action is as follows. <br>

<pre>
0112     <b>public</b><i> Keyable remove</i>( <i>Orderable keyToRemove</i>) { 
0113  
0114     <i>Keyable  hold</i>; 
0115     <i>ListNode</i> <i>thisNode  </i>= <i>theList</i>;
0116     <i>ListNode</i> <i>lastNode</i>  = <b>null</b>;
0117     <b>boolean</b>  <i>found</i>     = <b>false</b>;
0118     <b>boolean</b>  <i>exhausted</i> = <b>false</b>;
0119     
0120        <b>while</b> ( !<i>found</i> &amp;&amp; !<i>exhausted</i>) { 
0121          <b>if</b> ( <i>thisNode</i> == <b>null</b>) { 
0122             <i>exhausted</i> = <b>true</b>;
0123          } <b>else if</b> ( <i>keyToRemove.keyIsEqualTo</i>( 
0124                           <i>thisNode.dataIs</i>().<i>keyValueIs</i>()) ){ 
0125             <i>found</i> = <b>true</b>;  
0126          } <b>else</b> { 
0127             <i>lastNode</i> = <i>thisNode</i>;        
0128             <i>thisNode</i> = <i>thisNode.nextIs</i>(); 
0129          } // End if.
0130        } // End while.                  
0131     
0132        <b>if</b> ( !<i>found</i> ) { 
0133           <b>throw new</b> NoSuchElementException();
0134        } <b>else</b> {
0135           <i>hold</i>  = <i>thisNode.dataIs</i>();
0136           <b>if</b> ( <i>thisNode</i> == <i>theList</i>) { 
0137              <i>theList</i> = <i>theList.nextIs</i>();
0138           } <b>else</b> { 
0139              <i>lastNode.setNextNode</i>( <i>thisNode.nextIs</i>());
0140           } // End if.
0141           <i>numberOfElements</i>--;
0141           <b>return</b> <i>hold</i>;
0142        } // End if.     
0143     } // End remove.  <br>

</pre>

<p>
So if the <i>geek</i> node from Figure 15.9 were to be <i>remove</i>d,
the loop would terminate with <i>thisNode</i>
referencing <i>geek</i> and <i>lastNode</i>
referencing the <i>anorak</i> node. Line 0139 will cause the <i>anorak</i>
node's link to point to <i>sad</i> node, isolating the <i>geek</i>
node from the list, as shown in Figure 15.11.<br>
<br>

<p>
<center><img SRC="c15p4i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p4i2.gif" WIDTH="313" HEIGHT="205"></center>
<br>
<center>Figure 15.11 The list from Figure 15.9 during the removal of <i>geek@nowhere.edu</i>.
</center>
<p>
As the <i>geek</i> node now has nothing referencing it Java will
remove it, recovering its resources, in due course. The implementation
of the steps on lines 0135 to 0141 <i>hold</i>s
a copy of the data being removed whilst it is removed and, on
line 0137, has to treat the first node in the list as a special
case, before a copy of the held node is returned on line 0141.
<br>
<br>



<p>
<hr>
<h2>
<ul>

<a HREF="chap15p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p5.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
15.5 The remaining <i>LinkedList</i> actions and the <i>LinkedListEnumeration</i> class</a>.
<p>
<a HREF="chap15p3.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p3.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
15.3 The LinkedList constructor and <i>add()</i> actions</a>.
</ul>
</h2>
<hr>
</body>

</html>
