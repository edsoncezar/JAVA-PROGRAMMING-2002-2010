<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>15.8 The BinaryTree obtain(), isPresent() and toString() actions</title>

</head>

<body BGCOLOR="WHITE">

<h2>15.8 The <i>BinaryTree</i> <i>obtain(),</i> <i>isPresent()</i> and <i>toString()</i> actions
</h2>

<p>
The design of the <i>obtain()</i>
action is as follows. <br>
<br>

<p>
<center><img SRC="c15p8i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p8i1.gif" WIDTH="709" HEIGHT="460">
</center>
<p>
The <i>obtain()</i> action consists
of a call of the private <i>obtainFromTree()</i>
action passing on <i>theTree</i>
as an argument and passing back the value <i>obtained</i>
from the call. The action itself either raises an exception if
the tree passed is empty, or returns a copy of the element stored
at the current node if it is the one being sought, or recursively
calls the <i>obtainFromTree()</i>
action passing either the left or right subtree depending upon
the alphabetic relationship between the key being sought and the
key of the current node. The implementation of this design is
as follows. <br>

<pre>
0070     <b>public</b> <i>Keyable</i> obtain( <i>Orderable keyToObtain</i>) {    
0071       <b>return</b> <i>obtainFromTree</i>( <i>theTree, keyToObtain</i>);
0072     } // End <i>obtain</i>.  
0073     
0074     <b>private</b> <i>Keyable</i> <i>obtainFromTree</i>( <i>TreeNode  thisNode</i>,
0075                                     <i>Orderable toObtain</i>) {    
0076        <b>if</b> ( <i>thisNode</i> == <b>null</b>) { 
0077           <b>throw  new</b> <i>NoSuchElementException</i>();
0078        } <b>else if</b> ( <i>toObtain.keyIsEqualTo</i>( 
0079                      <i>thisNode.dataIs</i>().<i>keyValueIs</i>())){  
0080           <b>return</b> <i>thisNode.dataIs</i>().<i>copy</i>();  
0081        } <b>else if</b> ( <i>toObtain.keyIsLessThan</i>( 
0082                      <i>thisNode.dataIs</i>().<i>keyValueIs</i>())){ 
0083            <b>return</b> <i>obtainFromTree</i>( <i>thisNode.leftTreeIs</i>(), <i>toObtain</i>); 
0084        } <b>else</b> { 
0085            <b>return</b> <i>obtainFromTree</i>( <i>thisNode.rightTreeIs</i>(), <i>toObtain</i>); 
0086        } // End if.    
0087     } // End <i>obtainFromTree</i>.<br>

</pre>

<p>
Assuming that the last tree in Figure 15.12 is being searched
for the name <i>dull</i>. The
<i>obtain()</i> action will call
<i>obtainFromTree()</i> passing
<i>theTree</i> as the <i>thisNode</i>
argument. The test on line 0076 will be <b>false</b>
as the tree is not empty and the test on line 0078 will also be
<b>false</b> as the keys <i>geek</i>
and <i>dull</i> are not equal. The test on line 0081 will be <b>true</b>
as <i>dull</i> is less than <i>geek</i>, causing the <i>obtainFromTree()</i>
action to be called recursively with <i>geek</i>'s left subtree
passed as the <i>thisTree</i>
argument. <br>

<p>
On this call the first two tests, on lines 0076 and 0078, will
again be <b>false</b> and the
test on line 0081 will be <b>false</b>
as <i>dull</i> is not less than <i>boring</i>. This will cause
another recursive call of <i>obtainFromTree()</i>
passing <i>boring</i>'s right subtree as the <i>thisTree</i>
argument. <br>

<p>
On this call the test on line 0076 will be <b>false</b>
but the test on line 0078 will be <b>true</b>
as <i>dull</i> is equal to <i>dull</i>. Line 0080 will <b>return</b>
the element data stored at this node from this third call to the
place where it was called from the second call. This is line 0083
which is itself part of a <b>return</b>
statement returning the data to the place in the first call where
the second call was called from. This also is line 0083 and this
<b>return</b> returns the data
to the place in <i>obtain()</i>
where it was called from. This is line 0071 where the <i>dull</i>
data, which has flown up the calls, is <b>return</b>ed
as the result of the <i>obtain()</i>
action.<br>

<p>
If the search was for the name <i>duller</i>, rather than the
name <i>dull</i>, then the pattern of actions would have been
the same until the third call. On this call the test for equality
would have been <b>false</b>
and, as <i>duller</i> is considered alphabetically greater than
<i>dull</i>, a fourth call of <i>obtainFromTree()</i>,
passing <i>dull</i>'s right sub tree, would have been made. On
this call the test on line 0076 would have been <b>true</b>
as <i>dull</i>'s right subtree is empty causing the NoSuchElement
exception to be thrown. <br>

<p>
The design and implementation of the <i>isPresent()</i>
action is essentially identical to that of <i>obtain();
</i> its implementation is as follows. <br>

<pre>
0180     <b>public</b>  <b>boolean</b> <i>isPresent</i>( <i>Orderable keyToCheck</i>){   
0181        <b>return</b> <i>isKeyPresent</i>( <i>theTree, keyToCheck</i>);               
0182     } // End <i>isPresent</i>.    
0183     
0184     <b>private</b>  <b>boolean</b> <i>isKeyPresent</i>( <i>TreeNode  thisNode</i>,
0185                                    <i>Orderable toCheck</i>){ 
0186        <b>if</b> ( <i>thisNode</i> == <b>null</b>) { 
0187           <b>return false</b>;
0188        } <b>else if</b> ( <i>toCheck.keyIsEqualTo</i>( 
0189                      <i>thisNode.dataIs</i>().<i>keyValueIs</i>())){  
0190           <b>return true</b>;  
0191        } <b>else if</b> ( <i>toCheck.keyIsLessThan</i>( 
0192                      <i>thisNode.dataIs</i>().<i>keyValueIs</i>())){ 
0193            <b>return</b> <i>isKeyPresent</i>( <i>thisNode.leftTreeIs</i>(), <i>toCheck</i>); 
0194        } <b>else</b> { 
0195            <b>return</b> <i>isKeyPresent</i>( thisNode.<i>rightTreeIs</i>(), <i>toCheck</i>); 
0196        } // End if.    
0197     } // End <i>isKeyPresent</i>;<br>

</pre>

<p>
The implementation of <i>toString()</i>,
which is about to be presented, does not use the Enumeration
facility for reasons which will be explained below. Its design
and implementation are as follows. <br>

<p>
<center><img SRC="c15p8i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/c15p8i2.gif" WIDTH="605" HEIGHT="603">
</center>
<p>
<pre>
0215     <b>public</b> String <i>toString</i>(){ 
0216     
0217     <i>StringBuffer</i> <i>buffer</i>   = <b>new</b> <i>StringBuffer</i>();
0218     <b>int</b>          <i>theCount</i>;
0219  
0220        <i>theCount</i> = <i>treeString</i>( <i>theTree</i>, <i>buffer</i>, 0);                            
0221        <b>return</b> <i>buffer.toString</i>();
0222     } // End <i>toString</i>.    
0223
0224     <b>private int</b> <i>treeString</i>( <i>TreeNode</i>     <i>thisTree</i>,
0225                             <i>StringBuffer</i> <i>addTo</i>,
0226                             <b>int</b>          <i>soFar</i>) { 
0227     
0228        <b>if</b> (<i>thisTree</i> == <b>null</b>) { 
0229           <b>return</b> <i>soFar</i>;
0230        } <b>else</b> { 
0231           <i>soFar</i> = <i>treeString</i>(<i>thisTree.leftTreeIs</i>(), <i>addTo</i>, <i>soFar</i>);
0232           <i>addTo.append</i>( ++<i>soFar</i> + &quot; &quot; + <i>thisTree.dataIs</i>() + &quot;\n&quot;);
0233           <i>soFar</i> =  <i>treeString</i>(<i>thisTree.rightTreeIs</i>(), <i>addTo</i>, <i>soFar</i>);
0234           <b>return</b> <i>soFar</i>;
0235        } // End if.   
0236     } // End <i>treeString</i>.<br>

</pre>

<p>
Assuming that this action is called to output the tree shown in
the fourth diagram in Figure 15.12. The <i>toString()</i>
action will call the <i>treeString()</i>
action passing <i>theTree</i>,
an empty buffer and the value 0 in the three arguments. As the
tree is not empty it will, on line 0231, recursively call itself
passing <i>geek</i>'s left subtree
as the <i>thisTree</i> argument.
On the second call exactly the same pattern of steps will take
place, passing <i>boring</i>'s left subtree. This is an empty
subtree so the action will return on line 0220 passing the value
of <i>count</i> (&nbsp;0&nbsp;)
as the returned value of the function. <br>

<p>
Flow of control will return to the second call with the <i>boring</i>
node specified as the <i>thisTree</i>
argument and its next action, on line 0232 is to append the pre-incremented
value of <i>soFar</i>, and the
value of the data, to the buffer <i>addTo</i>.
This would be &quot;<i>1 E-mail : boring@ <b>etc.</b></i>&quot;.
The next action is to call <i>treeString()</i>
with <i>boring</i>'s right subtree specified, the changed value
of the buffer <i>addTo</i> and
the incremented value of <i>soFar</i>
as the arguments. This is an empty tree so the contents of the
buffer will not be changed and the value of <i>soFar</i>
will be returned unchanged. This is the last action of the <i>boring</i>
call of <i>treeString()</i> and
flow of control returns to the original call of <i>treeString(),</i>
when the <i>geek</i> node was specified. <br>

<p>
The next action of this call is to append its details to the buffer
<i>addTo</i>, the pre-incremented
value of <i>soFar</i> (&nbsp;2&nbsp;)
and the details stored at that node (&nbsp;&quot;<i>geek@<b>etc</b></i>&quot;&nbsp;).
The next action of this call is to call <i>treeString()</i>
passing <i>geek</i>'s right hand subtree. This is the <i>sad</i>
node and its sequence of actions is to call <i>treeString()</i>
with its left, empty, node, which has no effect; append its details
to the buffer (&nbsp;&quot;<i>3&nbsp;sad@<b>etc</b></i>&quot;&nbsp;)
and then call <i>treeString()</i>
passing its right subtree. This call on the <i>zzz</i> node will
call <i>treeString()</i> passing
its empty left node, adding its own details to the buffer (&nbsp;&quot;<i>4&nbsp;zzz@<b>etc</b></i>&quot;&nbsp;),
and calling <i>treeString()</i>
passing its empty right subtree.<br>

<p>
At this point the call on the <i>zzz</i> node will terminate,
following which the call on the <i>sad</i> node will terminate
and then the original call on the <i>geek</i> node. If the pattern
in which the details were added to the buffer is considered it
can be seen that the details are in the sequence <i>boring</i>,
<i>geek</i>, <i>sad</i> and <i>zzz</i>, each preceded by its sequence
number. When the original call, with the <i>geek</i> node specified,
terminates the changed buffer will be available and the value
of <i>soFar</i> (&nbsp;4&nbsp;)
returned into <i>theCount</i>.
The contents of the buffer are then returned as the String
result of the <i>toString()</i>
action, the value of <i>theCount</i>
is discarded.<br>
<br>


<p>
<hr>
<h2>
<ul>

<a HREF="chap15p9.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p9.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
15.9 The remaining <i>BinaryTree</i> actions</a>.
<p>
<a HREF="chap15p7.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter15/chap15p7.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
15.7 The <i>TreeNode</i> class and <i>BinaryTree</i> <i>add</i> action</a>.
</ul>
</h2>
<hr>
</body>

</html>
