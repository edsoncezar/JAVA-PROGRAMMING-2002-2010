<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPad 2.0">
<title> 7.1 The TextTuttle class </title>
</head>

<body bgcolor="#FFFFFF">

<h1 align="center">7.1 The <font size="5" face="Arial"><i>TextTuttle</i></font><font
size="5"> </font><font size="6">class</font></h1>

<p>The class diagram for the <font size="2" face="Arial"><i>TextTuttle</i></font>
class is presented in Figure 7.1.</p>

<p align="center"><font size="2"><b><img src="fig71.gif"
width="426" height="368"></b></font></p>

<p align="center"><font size="2"><b>Figure 7.1</b> The </font><font
size="2" face="Arial"><i>TextTuttle</i></font><font size="2">
class diagram.</font></p>

<p>The constructor has the same effect as the <font size="2"
face="Arial"><i>Tuttle</i></font> constructor, requesting a
tuttle drawing area with the dimensions specified and passing the
identity of the <font size="2" face="Arial">applet</font> for use
by the tuttle. The other public attributes shown on the diagram
are the manifest values of all the commands which the <font
size="2" face="Arial"><i>TextTuttle</i></font> will respond to.
The <font size="2" face="Arial"><i>identifyCommand()</i></font>
method will attempt to return the manifest value of the command
contained in the <font size="2" face="Arial">String</font>
argument <font size="2" face="Arial"><i>command</i></font>, or
the value <font size="2" face="Arial"><i>UNKNOWN</i></font>, if
it cannot be recognised. The remaining method, <font size="2"
face="Arial"><i>doCommand()</i></font>, will take a complete <font
size="2" face="Arial"><i>command</i> String</font> and attempt to
execute it. If it is possible for the <font size="2" face="Arial"><i>TextTuttle</i></font>
to process the instruction, <font size="2" face="Arial"><i>doCommand()</i></font>
will return an empty <font size="2" face="Arial">String</font> in
<font size="2" face="Arial"><i>comment</i></font>, otherwise it
will contain an explanation of why the instruction could not be
obeyed. The class diagram also shows two private methods called <font
size="2" face="Arial"><i>doCommand()</i></font> and <font
size="2" face="Arial"><i>identifyColor()</i></font> whose use
will be described below. The implementation of this class, as far
as the end of the constructor, is as follows. </p>

<pre><font size="3">0001  // Filename <i>TextTuttle.java</i>.
0002  // Extends the <i>Tuttle</i> class by providing a text 
0003  // interface for its commands.
0004  //
0005  // Written for the Java Interface Book Chapter 7.
0006  // Fintan Culwin, v 0.2, August 1997.
0007  
0008  <b>package</b> <i>Tuttles</i>;
0009  
0010  <b>import</b> java.awt.*;
0011  <b>import</b> java.applet.*;
0012  <b>import</b> java.util.StringTokenizer;
0013  
0014  <b>import</b> <i>Tuttles.Tuttle</i>;
0015  
0016  <b>public class</b> <i>TextTuttle</i> <b>extends</b> <i>Tuttle</i> {
0017  
0018  <b>public static final int</b> <i>UNKNOWN</i>         = -1;
0019  <b>public static final int</b> <i>FORWARD</i>         = 0;
0020  <b>public static final int</b> <i>BACKWARD</i>        = 1;
0021  <b>public static final int</b> <i>TURN_RIGHT</i>      = 2;
0022  <b>public static final int</b> <i>TURN_LEFT</i>       = 3;
0023  <b>public static final int</b> <i>FOREGROUND</i>      = 4;
0024  <b>public static final int</b> <i>BACKGROUND</i>      = 5;
0025  <b>public static final int</b> <i>PEN_UP</i>          = 6;
0026  <b>public static final int</b> <i>PEN_DOWN</i>        = 7;
0027  <b>public static final int</b> <i>CLEAR</i>           = 8;
0028  <b>public static final int</b> <i>RESET</i>           = 9;
0029  <b>public static final int</b> <i>CLEAR_AND_RESET</i> = 10;
0030  <b>public static final int</b> <i>EXIT</i>            = 11;
0031  <b>public static final int</b> <i>MAX_COMMANDS</i>    = 11;
0032  
0033  <b>private static final</b> String[] <i>commands</i> = 
0034                         { &quot;fd&quot;, &quot;bd&quot;, &quot;tr&quot;, &quot;tl&quot;,
0035                           &quot;fg&quot;, &quot;bg&quot;, &quot;pu&quot;, &quot;pd&quot;, 
0036                           &quot;cl&quot;, &quot;rs&quot;, &quot;cr&quot;, 
0037                           &quot;exit&quot; };
0038  
0039  
0040     <b>public</b> <i>TextTuttle</i>(  Applet <i>applet</i>, <b>int</b> <i>width</i>, <b>int</b> <i>height</i>) { 
0041        <b>super</b>( <i>applet</i>, <i>width</i>, <i>height</i>);      
0042     } // End <i>TextTuttle </i>constructor.</font></pre>

<p>The manifest values for the commands are enumerated on lines
0018 to 0031, with delimiting values for <font size="2"
face="Arial"><i>UNKNOWN</i></font> commands and for the maximum
number of commands. The declaration of the <font size="2"
face="Arial">String</font> array <font size="2" face="Arial"><i>commands[]</i></font>,
on lines 0033 to 0037, provides the corresponding two letter
abbreviation for each command, apart from the &quot;<i>exit</i>&quot;
command. Finally, in this part, the constructor is implemented as
a dispatching call of the parent, <font size="2" face="Arial"><i>Tuttle</i></font>,
constructor. The <font size="2" face="Arial"><i>doCommand()</i></font>
method relies upon the <font size="2" face="Arial"><i>identifyCommand()</i></font>
method; the implementation of these two methods is as follows. </p>

<pre><font size="3">0045     <b>public</b> String <i>doCommand</i>( String <i>theCommand</i>) { 
0046     
0047     StringTokenizer <i>tokenizer</i> = <b>new</b> StringTokenizer( <i>theCommand</i>);
0048     String          <i>firstTerm</i> = <b>null</b>;
0049     String          <i>theReply</i>;   
0050  
0051     <b>int</b> <i>thisCommand</i> = <i>UNKNOWN</i>;
0052     
0053        <b>if</b> ( <i>tokenizer</i>.hasMoreTokens()) { 
0054           <i>firstTerm</i>   = <i>tokenizer</i>.nextToken().toLowerCase();
0055           <i>thisCommand</i> = <i>identifyCommand</i>( <i>firstTerm</i>);
0056           
0057           <b>if</b> ( <i>thisCommand</i> == <i>UNKNOWN</i> ) { 
0058              <i>theReply</i> = <b>new</b> String( &quot;The command &quot; + <i>firstTerm</i> + 
0059                                     &quot; is not known!&quot;);
0060           } <b>else</b> { 
0061              <i>theReply</i> = <i>dispatchCommand</i>( <i>thisCommand</i>, <i>tokenizer</i>);       
0062           } // End if.
0063        } <b>else</b> { 
0064           <i>theReply</i> = <b>new</b> String( &quot;There does not seem to be a command given!&quot;);
0065        } // End if.
0066        <b>return</b> <i>theReply</i>;
0067     } // End <i>doCommand</i>.
0068  
0069  
0070     <b>public int</b> <i>identifyCommand</i>( String <i>toIdentify</i>) { 
0071     
0072     <b>int</b> <i>thisCommand</i> = <i>MAX_COMMANDS</i>;
0073     <b>int</b> <i>identified</i>  = <i>UNKNOWN</i>;
0074     
0075       <b>while</b> ( ( <i>identified</i>  == <i>UNKNOWN</i>) &amp;&amp;
0076               ( <i>thisCommand</i> != <i>UNKNOWN</i>) ){
0077          <b>if</b> ( <i>toIdentify</i>.equals( <i>commands</i>[ <i>thisCommand</i>])) { 
0078             <i>identified</i> = <i>thisCommand</i>;
0079          } <b>else</b> { 
0080             <i>thisCommand</i>--;
0081          } // End if.            
0082       } // End while.
0083       <b>return</b> <i>identified</i>;
0084     } // End <i>identifyCommand</i>.</font></pre>

<p>The <font size="2" face="Arial"><i>doCommand()</i></font>
method commences, on line 0047, by constructing a <font size="2"
face="Arial">StringTokenizer</font> instance called <font
size="2" face="Arial"><i>tokenizer</i></font> which will be used
to split its single <font size="2" face="Arial">String</font>
argument, <font size="2" face="Arial"><i>theCommand</i></font>,
into its constituent parts. The provision of a suitable command
to this method is the responsibility of the tuttle text
interfaces, as will be described below.</p>

<p>Having initialised the <font size="2" face="Arial"><i>tokenizer</i></font>,
on line 0053, the <font size="2" face="Arial"><i>tokenizer</i></font>
<font size="2" face="Arial">hasMoreTokens()</font> method is used
to make sure that <font size="2" face="Arial"><i>theCommand</i></font>
is not empty and, if it is, <font size="2" face="Arial"><i>theReply</i></font>
is prepared with a suitable message on line 0064. Otherwise the <font
size="2" face="Arial"><i>firstTerm</i></font> is obtained from
the <font size="2" face="Arial"><i>tokenizer</i></font> on line
0054 and identified, using <font size="2" face="Arial"><i>identifyCommand()</i></font>,
on line 0055. If the <font size="2" face="Arial"><i>firstTerm</i></font>
is not identified a suitable reply is placed into <font size="2"
face="Arial"><i>theReply</i></font> on lines 0058 and 0059. If
this is not the case then the <font size="2" face="Arial"><i>firstTerm</i></font>
has been identified as a valid command and it is processed by the
<font size="2" face="Arial"><b>private</b></font> <font size="2"
face="Arial"><i>dispatchCommand()</i></font> method, on line
0061, passing as the second argument the <font size="2"
face="Arial"><i>tokenizer</i></font> which still contains any
remaining terms. In this case the <font size="2" face="Arial">String</font>
returned by <font size="2" face="Arial"><i>dispatchCommand()</i></font>
is stored in <font size="2" face="Arial"><i>theReply</i></font>
to be returned as the result of the <font size="2" face="Arial"><i>doCommand()</i></font>
method, on line 0066.</p>

<p>The <font size="2" face="Arial"><i>identifyCommand()</i></font>
method, on lines 0070 to 0084, is a sequential search of the <font
size="2" face="Arial"><i>commands[]</i></font> array. It returns
the appropriate manifest value identifying the command contained
in its <font size="2" face="Arial"><i>toIdentify</i></font>
argument, or the value <font size="2" face="Arial"><i>UNKNOWN</i></font>
if it does not contain a valid command. Should additional
commands be added during maintenance, then additional manifest
values can be added to the list and their string representation
to the <font size="2" face="Arial"><i>commands[]</i></font>
array, and this method will still operate correctly.</p>

<p>The <font size="2" face="Arial"><i>dispatchCommand()</i></font>
method has the responsibility of checking any arguments of the <font
size="2" face="Arial"><i>Tuttle</i></font> command and returning
an appropriate message should too many, too few or an
inappropriate argument be supplied. If the arguments do prove to
be acceptable the appropriate method of the parent, <font
size="2" face="Arial"><i>Tuttle</i></font>, class should be
called and an empty <font size="2" face="Arial">String </font>returned.
</p>

<p>The first part of its implementation, as follows, is concerned
with processing those commands which require a single <font
size="2" face="Arial"><b>int</b></font>eger argument: <i>forwards</i>,
<i>backwards</i>, <i>turn&nbsp;left</i> and <i>turn&nbsp;right</i>.
. </p>

<pre><font size="3">0087     <b>private</b> String <i>dispatchCommand</i>( <b>int</b>             <i>theCommand</i>, 
0088                                     StringTokenizer <i>arguments</i>){ 
0089                                       
0090     StringBuffer <i>theResponse</i> = <b>new</b> StringBuffer( &quot;&quot;);
0091     <b>boolean</b>      <i>processed</i>   = <b>false</b>;
0092                                          
0093       <b>switch</b>( <i>theCommand</i>) { 
0094       
0095       <b>case</b> <i>FORWARD</i>:
0096       <b>case</b> <i>BACKWARD</i>:
0097       <b>case</b> <i>TURN_RIGHT</i>:
0098       <b>case</b> <i>TURN_LEFT</i>:
0099          <b>if</b> (<i>arguments</i>.countTokens() == 1) { 
0100          <b>int</b> <i>toStepOrTurn</i>;        
0101              <b>try</b> { 
0102                 <i>toStepOrTurn</i> = Integer.parseInt( <i>arguments</i>.nextToken());
0103                 <b>switch</b> ( <i>theCommand</i>) {
0104                 <b>case</b> <i>FORWARD</i>: 
0105                    <b>this</b>.<i>forward</i>( <i>toStepOrTurn</i>);
0106                    <b>break</b>;
0107                 <b>case</b> <i>BACKWARD</i>:
0108                    <b>this</b>.<i>backward</i>( <i>toStepOrTurn</i>);
0109                    <b>break</b>; 
0110                 <b>case</b> <i>TURN_RIGHT</i>:
0111                    <b>this</b>.<i>turnRight</i>( <i>toStepOrTurn</i>);
0112                    <b>break</b>;                                      
0113                 <b>case</b> <i>TURN_LEFT</i>:
0114                    <b>this</b>.<i>turnLeft</i>( <i>toStepOrTurn</i>);
0115                    <b>break</b>;                  
0116                 } // End switch.
0117                 <i>processed</i> = <b>true</b>;          
0118              } <b>catch</b> ( NumberFormatException <i>exception</i>) { 
0119                 <i>processed</i> = <b>false</b>;                    
0120              } // End try/ catch.
0121          } // End if.
0122          <b>if</b> ( !<i>processed</i>) { 
0123             <i>theResponse</i>.append( <i>commands</i>[ <i>theCommand</i>] +  
0124                          &quot; should be followed by a single number.&quot;);
0125          } // End if. 
0126          <b>break</b>;</font></pre>

<p>The <font size="2" face="Arial"><b>switch</b></font> structure
starting on line 0093 is controlled by the manifest value of <font
size="2" face="Arial"><i>theCommand</i></font>, passed to <font
size="2" face="Arial"><i>dispatchCommand()</i></font> from the <font
size="2" face="Arial"><i>doCommand()</i></font> method. On lines
0095 to 0098 the first branch of the outer switch statement
starting on line 0093 lists, as <font size="2" face="Arial"><b>case</b></font>
selectors, the manifest values of the commands which require a
single <font size="2" face="Arial"><b>int</b></font>eger
argument. </p>

<p>The processing of these commands commences, on line 0099, with
a check to make sure that only a single argument remains in the <font
size="2" face="Arial">StringTokenizer</font> instance called <font
size="2" face="Arial"><i>arguments</i></font>, which was passed
from the <font size="2" face="Arial"><i>doCommand()</i></font>
method. If this is so then, on line 0102, an attempt is made,
within a <font size="2" face="Arial"><b>try/&nbsp;catch</b></font>
structure, to interpret this argument as an <font size="2"
face="Arial"><b>int</b></font>eger and store it in the local
variable <font size="2" face="Arial"><i>toStepOrTurn</i></font>.
Assuming that an exception is not throw a second inner <font
size="2" face="Arial"><b>switch</b></font> structure, between
lines 0103 and 0116, dispatches to a call of the appropriate <font
size="2" face="Arial"><i>Tuttle</i></font> method passing the
value of <font size="2" face="Arial"><i>toStepOrTurn</i></font>
as its argument. The final stage of the <font size="2"
face="Arial"><b>try</b></font> part of the <font size="2"
face="Arial"><b>try/&nbsp;catch</b></font> structure sets the <font
size="2" face="Arial"><i>processed</i></font> flag <b>true</b>. </p>

<p>If the command has not been processed, either because there
are too many or too few arguments, or because the single argument
does not contain an <font size="2" face="Arial"><b>int</b></font>eger
value, the value of <font size="2" face="Arial"><i>processed</i></font>
will be <font size="2" face="Arial"><b>false</b></font>,
unchanged from its declaration on line 0091. This will cause a
suitable message to be placed into the <font size="2"
face="Arial">StringBuffer <i>theResponse</i></font>, on lines
0123 to 0124. Finally, on line 0126, this part of the <font
size="2" face="Arial"><b>switch</b></font> structure which
started on line 0093 is completed with a <font size="2"
face="Arial"><b>break</b></font> statement.</p>

<p>For example if the <font size="2" face="Arial"><i>doCommand()</i></font>
method were called with the String &quot;<i>fd 30</i>&quot;. The <i>fd</i>
part of the command would be extracted and identified by <font
size="2" face="Arial"><i>identifyCommand()</i></font> as the
manifest value <font size="1" face="Arial"><i>FORWARD</i></font>.
This will cause <font size="2" face="Arial"><i>dispachCommand()</i></font>
to be called with <font size="1" face="Arial"><i>FORWARD </i></font>as
its first, <font size="2" face="Arial"><i>theCommand</i></font>,
argument and the <font size="2" face="Arial">StringTokenizer</font>,
still containing &quot;30&quot; as its second argument. The value
<font size="1" face="Arial"><i>FORWARD </i></font>will match the
selector on line 0095 and cause the <font size="2" face="Arial"><b>switch</b></font>
branch commencing on line 0099 to be executed. The <font size="2"
face="Arial"><b>if </b></font>condition on line 0099 would
evaluate <font size="2" face="Arial"><b>true</b></font> and so
the <font size="2" face="Arial"><b>try</b></font>/&nbsp;<font
size="2" face="Arial"><b>catch</b></font> structure on line 0101
would be attempted. As &quot;30&quot; can be interpreted as the <font
size="2" face="Arial"><b>int</b></font>eger value 30, no
exception would be thrown on line 0102 and the inner <font
size="2" face="Arial"><b>switch</b></font> structure on line 0103
would be considered. The value <font size="1" face="Arial"><i>FORWARD
</i></font>in <font size="2" face="Arial"><i>theCommand</i></font>
would cause line 0105 to be executed. This is a call of the <font
size="2" face="Arial"><i>Tuttle forward()</i></font> method,
inherited by the <font size="2" face="Arial"><i>TextTuttle</i></font>
class, and will result in the tuttle moving forwards 30 steps.
The next line to be executed would be line 0117 setting the value
of the <font size="2" face="Arial"><i>processed</i></font> flag <font
size="2" face="Arial"><b>true</b></font> and avoiding any message
being placed into <font size="2" face="Arial"><i>theResponse</i></font>
on lines 0123 and 0124.</p>

<p>Alternatively if the command received by the <font size="2"
face="Arial"><i>doCommand()</i></font> method were &quot;<i>fd</i>&quot;
or &quot;<i>fd&nbsp;30&nbsp;please</i>&quot;, the command would
still be identified as <font size="1" face="Arial"><i>FORWARD </i></font>but
the <font size="2" face="Arial"><b>if</b></font> condition on
line 0099 would be <font size="2" face="Arial"><b>false</b></font>
and result in lines 0123 and 0124 placing a suitable message in <font
size="2" face="Arial"><i>theResponse</i></font>. This would also
happen if the command were &quot;<i>fd&nbsp;please</i>&quot;: the
condition on line 0099 would now be <font size="2" face="Arial"><b>true</b></font>
but the attempted conversion of &quot;<i>please</i>&quot; to an <font
size="2" face="Arial"><b>int</b></font>eger, on line 0102 would
throw a <font size="2" face="Arial"><i>NumberFormatException</i></font>
which, when it was caught on line 0118, would set the <font
size="2" face="Arial"><i>processed</i></font> flag to cause the
message to be placed in to <font size="2" face="Arial"><i>theResponse</i></font>,
as before. </p>

<p>The next part of the <font size="2" face="Arial"><i>dispatchCommand()</i></font>
method processes those actions which require no arguments: <i>pen&nbsp;up</i>,
<i>pen&nbsp;down</i>, <i>reset</i>, <i>clear</i> and <i>clear and
reset</i>. Its implementation, which follows, is similar to the
previous fragment.</p>

<pre><font size="3">0128       <b>case</b> <i>PEN_UP</i>:
0129       <b>case</b> <i>PEN_DOWN</i>:
0130       <b>case</b> <i>RESET</i>:
0131       <b>case</b> <i>CLEAR</i>:
0132       <b>case</b> <i>CLEAR_AND_RESET</i>:
0133          <b>if</b> (<i>arguments</i>.countTokens() == 0) { 
0134             <b>switch</b> ( <i>theCommand</i>) {
0135             <b>case</b> <i>PEN_UP</i>:
0136                <b>this</b>.<i>setPenUp</i>();
0137                <b>break</b>;
0138             <b>case</b> <i>PEN_DOWN</i>:
0139                <b>this</b>.<i>setPenDown</i>();
0140                <b>break</b>;
0141             <b>case</b> <i>RESET</i>:        
0142                <b>this</b>.<i>resetTuttle</i>();
0143                <b>break</b>; 
0144             <b>case</b> <i>CLEAR</i>:        
0145                <b>this</b>.<i>clearTuttleArea</i>();
0146                <b>break</b>;                   
0147             <b>case</b> <i>CLEAR_AND_RESET</i>:        
0148                <b>this</b>.<i>clearAndReset</i>();
0149                <b>break</b>; 
0150             } // End switch.
0151             <i>processed</i> = <b>true</b>;   
0152          } // End if.
0153          <b>if</b> ( !<i>processed</i>) { 
0154              <i>theResponse</i>.append( <i>commands</i>[ <i>theCommand</i>] + 
0155                           &quot; should not  be followed by anything.&quot;);         
0156          } // End if.                                                         
0157          <b>break</b>;</font></pre>

<p>Line 0133 ensures that no arguments have been supplied and if
this is so then an inner <font size="2" face="Arial"><b>switch</b></font>
structure, between lines 0134 to 0150 dispatches to a call of the
appropriate parent <font size="2" face="Arial"><i>Tuttle</i></font>
method. Should any arguments be supplied then lines 0154 to 0155
will place an appropriate message in <font size="2" face="Arial"><i>theResponse</i></font>.
The next part of the method deals with the <i>foreground</i> and <i>background</i>
commands, which require a single argument identifying one of the
six acceptable <font size="2" face="Arial"><i>Tuttle</i></font>
colors.</p>

<pre><font size="3">0159       <b>case</b> <i>FOREGROUND</i>:
0160       <b>case</b> <i>BACKGROUND</i>:
0161          <b>if</b> (<i>arguments</i>.countTokens() == 1) { 
0162          Color <i>theColor</i>; 
0163             <i>theColor</i> = <i>identifyColor</i>( <i>arguments</i>.nextToken().toLowerCase());
0164             <b>if</b> ( <i>theColor</i> != <b>null</b>) { 
0165                <b>if</b> ( <i>theCommand</i> == <i>FOREGROUND</i>) { 
0166                   <b>this</b>.<i>setForeground</i>( <i>theColor</i>);
0167                } <b>else</b> { 
0168                   <b>this</b>.<i>setBackground</i>( <i>theColor</i>);
0169                } // End if.
0170                <i>processed</i> = <b>true</b>;
0171             } // End if.
0172          } // End if.
0173          <b>if</b> ( !<i>processed</i>) { 
0174             <i>theResponse</i>.append( <i>commands</i>[ <i>theCommand</i>] + 
0175                          &quot; should only be followed by white, black, red, &quot; + 
0176                          &quot;blue, green or yellow.&quot;);                        
0177          } // End if.     
0178          <b>break</b>;
0179       } // End switch.
0180       <b>return</b> <i>theResponse</i>.toString();
0181    } // End <i>dispatchCommand</i>.</font></pre>

<p>Line 0164 uses the <font size="2" face="Arial"><b>private</b></font>
<font size="2" face="Arial"><i>identifyColor()</i></font> method
to decide if a valid color name has been supplied in the single
argument. The implementation of the <font size="2" face="Arial"><i>identifyColor()</i></font>
method is given below. If the color name is recognized the
appropriate tuttle command is called, otherwise a message is
placed into <font size="2" face="Arial"><i>theResponse</i></font>.
The <font size="2" face="Arial"><i>dispatchCommand()</i></font>
method concludes, on line 0180, by returning the <font size="2"
face="Arial">String</font> contained in <font size="2"
face="Arial"><i>theResponse</i></font>, which will be empty if
the command has been passed to the tuttle or will contain a
suitable message otherwise.</p>

<pre><font size="3">0185     <b>private</b> Color <i>identifyColor</i>( String <i>possibleColor</i>) { 
0186  
0187     Color <i>theColor</i> = <b>null</b>;
0188        <b>if</b> ( <i>possibleColor</i>.equals( &quot;black&quot;)) { 
0189           <i>theColor</i> = Color.black;
0190        } <b>else if</b> ( <i>possibleColor</i>.equals( &quot;white&quot;)) {       
0191           <i>theColor</i> = Color.white;
0192        } <b>else if</b> ( <i>possibleColor</i>.equals( &quot;yellow&quot;)) {  
0193           <i>theColor</i> = Color.yellow;  
0194        } <b>else if</b> ( <i>possibleColor</i>.equals( &quot;green&quot;)) {  
0165           <i>theColor</i> = Color.green;
0196        } <b>else if</b> ( <i>possibleColor</i>.equals( &quot;red&quot;)) {  
0197           <i>theColor</i> = Color.red;         
0198        } <b>else if</b> ( <i>possibleColor</i>.equals( &quot;blue&quot;)) {  
0199           <i>theColor</i> = Color.blue;         
0200        } // End if.        
0201        <b>return</b> <i>theColor</i>;
0202     } // End <i>IdentifyColor</i>.</font></pre>

<p>The <font size="2" face="Arial"><i>dispatchCommand()</i></font>
method does not attempt to process the <i>exit</i> command
because, as explained in the previous chapter, exiting from an
application must be the responsibility of a translation module
not of an application module. The processing of the exit command
will be described in the two text interfaces later in this
chapter. </p>

<p>This completes the implementation of the <font size="2"
face="Arial"><i>TextTuttle</i></font> class but a complete
demonstration of its effectiveness cannot be provided until the <font
size="2" face="Arial"><i>CommandLineTuttle</i></font> interface
is considered later in this chapter. However a partial
demonstration is contained with the <font size="2" face="Arial"><i>TextMenuTuttle</i></font>
class which follows. </p>

<p>&nbsp;</p>

<hr>

<blockquote>
    <p><a href="..\tuttles\tuttles\texttuttle.java"><font
    size="5"><img src="list.gif" align="middle" border="0"
    width="40" height="35"> TextTuttle.java</font></a></p>
</blockquote>

<hr>

<blockquote>
    <p><a href="ch72.html"><img src="next.gif" align="middle"
    border="0" width="50" height="40"><font size="5">7.2 The </font><font
    size="4" face="Arial"><i>TextMenuTuttle</i></font><font
    size="4"> </font><font size="5">interface</font></a></p>
    <p><a href="chap7.html"><font size="6"><img src="last.gif"
    align="middle" border="0" width="50" height="40"></font><font
    size="5">Chapter 7 Text based user interfaces</font></a></p>
</blockquote>

<hr>
</body>
</html>
