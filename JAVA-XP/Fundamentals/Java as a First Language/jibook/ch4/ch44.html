<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPad 2.0">
<title> 4.4 The TuttleCursor class</title>
</head>

<body bgcolor="#FFFFFF">

<h2 align="center"><font size="6">4.4 The </font><font size="6"
face="Arial"><i>TuttleCursor</i></font><font size="6"> class</font></h2>

<p>The <font size="2" face="Arial"><i>TuttleCursor</i></font>
class supplies a cursor to the <font size="2" face="Arial"><i>Tuttle</i></font>
class. The cursor has to be capable of being rotated to indicate
the direction of the <font size="2" face="Arial"><i>tuttle</i></font>
and has to be capable of being re-colored to indicate the
foreground color of the <font size="2" face="Arial"><i>tuttle</i></font>.
Its class diagram is given in Figure 4.7. This class is being
introduced not only to supply the <font size="2" face="Arial"><i>Tuttle</i></font>
class with a suitable cursor but also to introduce the techniques
by which an <font size="2" face="Arial">Image</font> can be
algorithmically processed by a Java artifact. As with the <font
size="2" face="Arial"><i>Tuttle</i></font> class itself a
detailed knowledge of the implementation of this class is not
required for the use of the <font size="2" face="Arial"><i>Tuttle</i></font>
object, although the techniques are essential for the development
of any Java image processing applications.</p>

<p align="center"><b><img src="fig47.gif" width="372"
height="322"></b></p>

<p align="center"><b>Figure 4.7</b> The <font face="Arial"><i>TuttleCursor</i></font>
class diagram.</p>

<p>The image which is to be used as the cursor is supplied to the
<font size="2" face="Arial"><i>TuttleCursor</i></font>
constructor from the private <font size="2" face="Arial"><i>initialiseCursor()</i></font>
method of the <font size="2" face="Arial"><i>Tuttle</i></font>
class whose implementation, which was omitted above, is as
follows. </p>

<pre><font size="3">0078     <b>private void</b> <i>initialiseCursor</i>(){ 
0079     
0080     MediaTracker <i>tuttleTracker</i>;
0081     
0087        <i>theCursor</i> = ( <i>itsApplet</i>.getImage( 
0088                         <i>itsApplet</i>.getCodeBase(), &quot;Tuttles/tuttle.gif&quot;));           
0089        <i>tuttleTracker</i> = <b>new</b> MediaTracker( <b>this</b>);
0090        <i>tuttleTracker</i>.addImage( <i>theCursor</i>, 0);
0091        <b>try</b> { 
0092            <i>tuttleTracker</i>.waitForID( 0);
0093        } <b>catch</b> ( InterruptedException <i>exception</i>) {       
0094          // Do nothing!
0095        } // End try/ catch.  
0096  
0097        <b>if</b> ( (<i>theCursor</i> == <b>null</b>)               || 
0098             (<i>theCursor</i>.getWidth(  <b>this</b>) &lt; 1)  ||
0099             (<i>theCursor</i>.getHeight( <b>this</b>) &lt; 1)  ){
0100           System.out.println( &quot;Empty cursor image ... abending&quot;);
0101           System.exit( -1);         
0102        } // End if.
0103        <i>rotatingCursor</i> = <b>new</b> TuttleCursor( <i>theCursor</i>, <b>this</b>);
0104        <i>rotatingCursor</i>.<i>setCursorColor</i>( <i>currentForeground</i>); 
0105        <i>theCursor</i> = <i>rotatingCursor</i>.<i>rotate</i>( <i>direction</i>);      
0106     } // End <i>initialiseCursor</i>.</font></pre>

<p>The tuttle cursor is stored as a GIF format image in a file
called &quot;<i>tuttle.gif</i>&quot;, which is assumed to be
located in a sub-directory, called <font size="2" face="Arial"><i>Tuttles</i></font>,
of the directory containing the <font size="2" face="Arial"><i>Tuttles</i></font>
package. This image has to be retrieved from the file and
imported into the applet as a Java <font size="2" face="Arial">Image</font>
instance. </p>

<p>In order to accomplish this the <font size="2" face="Arial">Applet
getImage()</font> method is called on lines 0087 and 0088. The
arguments to this method are the <font size="2" face="Arial"><i>codeBase</i></font>
of the <font size="2" face="Arial">Applet</font>, which is the
Internet location where the applet was downloaded from; and the
name of the file at this location. The second argument indicates
that the file which contains the image (&quot;<i>tuttle.gif</i>&quot;)
is contained in the <font size="2" face="Arial"><i>Tuttles</i></font>
sub-directory of the <font size="2" face="Arial"><i>Tuttles</i></font>
package directory. This method executes asynchronously in a
separate thread of control and lines 0089 to 0095 involve the use
of a <font size="2" face="Arial">MediaTracker</font> instance to
suspend the current thread until the image has completely loaded.
</p>

<p><font size="2" face="Arial">MediaTracker</font>s allow
monitoring and synchronization of the separate threads which are
loading multimedia files, as mentioned above. In this example, on
line 0090, the <font size="2" face="Arial"><i>tuttleTracker</i></font>
is asked to monitor the loading of the <font size="2"
face="Arial"><i>theCursor</i></font> <font size="2" face="Arial">Image</font>.
The second argument to the <font size="2" face="Arial">addImage()</font>
method indicating the degree of priority to be used and allowing
one of a number of activities which a <font size="2" face="Arial">MediaTracker</font>s
instance might be monitoring to be identified. Lines 0091 to 0095
then effectively suspend the main thread until the image in the
&quot;<i>tuttle.gif</i>&quot; file has been fully loaded. </p>

<p>It is possible that the image will not load, possibly because
the file containing it could not be found or does not contain a
valid image. Accordingly, lines 0097 to 0102 contain a guard
which abends the program if the cursor image cannot be obtained.
Once it is certain that the cursor image has loaded, and thus
that <font size="2" face="Arial"><i>theCursor</i> Image</font> is
complete, on line 0103, the <font size="2" face="Arial"><i>TuttleCursor</i></font>
constructor is called passing <font size="2" face="Arial"><i>theCursor</i></font>
image and identity of the <font size="2" face="Arial">Tuttle</font>
component being constructed as arguments. Finally on lines 0104
and 0105 the <font size="2" face="Arial"><i>setCursorColor()</i></font>
and <font size="2" face="Arial"><i>rotate()</i></font> methods of
the <font size="2" face="Arial"><b>new</b></font>ly constructed <font
size="2" face="Arial"><i>TuttleCursor</i></font> instance, <font
size="2" face="Arial"><i>rotatingCursor</i></font>, are called to
ensure that <font size="2" face="Arial"><i>theCursor</i></font>
is ready for use. </p>

<p>The declaration of the <font size="2" face="Arial"><i>TuttleCursor</i></font>
class, as far as the start of its constructor, is as follows. </p>

<pre><font size="3">0001  // Filename <i>TuttleCursor.java</i>.
0002  // Provides a rotating cursor capability for the 
0003  // <i>Tuttle</i> class.
0004  //
0005  // Written for the Java Interface Book Chapter 4.
0006  // Fintan Culwin, v 0.2, August 1997.
0007  
0009  <b>package</b> <i>Tuttles</i>;
0011  
0012  <b>import</b> java.awt.*;
0013  <b>import</b> java.awt.image.*;
0014  <b>import</b> java.lang.Math;
0016  
0017  <b>class</b> <i>TuttleCursor</i> <b>extends</b> Object { 
0018  
0019  <b>private int</b>       <i>imageWidth</i>;  
0020  <b>private int</b>       <i>imageHeight</i>;  
0021  <b>private int</b>       <i>pixels</i>[];
0022  <b>private int</b>       <i>rotatedPixels</i>[];  
0023  <b>private</b> Component <i>component</i>;   
0024  <b>private</b> Image     <i>rotatedImage</i>;       </font></pre>

<p>The <font size="2" face="Arial"><i>TuttleCursor</i></font>
class encapsulates two arrays of <font size="2" face="Arial"><b>int</b></font>egers.
One, called <font size="2" face="Arial"><i>pixels</i></font>,
contains a copy of the cursor <font size="2" face="Arial">Image</font>.
The second, called <font size="2" face="Arial"><i>rotatedPixels</i></font>,
is used to contain a rotated copy of the first, which will be
transferred as an <font size="2" face="Arial">Image</font> into
the <font size="2" face="Arial"><i>rotatedImage</i></font>
attribute when rotation is required. The <font size="2"
face="Arial"><i>imageWidth</i></font> and <font size="2"
face="Arial"><i>imageHeight</i></font> attributes store the size
of the cursor image. </p>

<p>This provides a common pattern for image processing operations
which can be adapted for use when other operations are required.
The pattern of operations is illustrated in Figure 4.8. It shows
that the <font size="2" face="Arial">Image</font> has first to be
converted into a one dimensional array of<b> int</b>, which can
then be processed, in this example being rotated, before it is
converted back into an <font size="2" face="Arial">Image</font>. </p>

<p align="center"><b><img src="fig48.gif" width="555"
height="178"></b></p>

<p align="center"><b>Figure 4.8</b> Algorithmic processing of an <font
size="2" face="Arial">Image</font>. </p>

<p>The implementation of the <font size="2" face="Arial"><i>TuttleCursor</i></font>
constructor is as follows.</p>

<pre><font size="3">0028     <b>protected</b> <i>TuttleCursor</i>( Image         <i>toRotate</i>,
0029                             ImageObserver <i>observer</i>) { 
0030     
0031     PixelGrabber <i>grabber</i>;
0032     <b>boolean</b>      <i>status</i>;
0033     
0034        <i>component</i>     =  <i>observer</i>;
0035        <i>imageWidth</i>    =  <i>toRotate</i>.getWidth( <i>observer</i>);
0036        <i>imageHeight</i>   =  <i>toRotate</i>.getHeight( <i>observer</i>);
0037        <i>pixels</i>        =  <b>new</b> <b>int</b>[ <i>imageWidth</i> * <i>imageHeight</i>];
0038        <i>rotatedPixels</i> =  <b>new int</b>[ <i>imageWidth</i> * <i>imageHeight</i>];
0039  
0040        <i>grabber</i>       =  <b>new</b> PixelGrabber( <i>toRotate</i>, 0, 0,
0041                                           <i>imageWidth</i>,<i>imageHeight</i>,  
0042                                           <i>pixels</i>, 0, <i>imageWidth</i>);
0043        <b>try</b> {     
0044           <i>status</i> = <i>grabber</i>.grabPixels(); 
0045           <b>if</b> ( !<i>status</i>) { 
0046              <b>throw new</b> InterruptedException();
0047           } // End if.            
0048        } <b>catch</b> ( InterruptedException <i>exception</i>) {
0049           System.err.println(&quot;Exception grabbing pixels ... abending&quot;);
0050           System.exit( -1);            
0051        } // End try/catch.
0052     } // End <i>TuttleCursor</i> constructor.</font></pre>

<p>The <font size="2" face="Arial"><i>TuttleCursor</i></font>
constructor requires the <font size="2" face="Arial">Image</font>
to be used for the cursor and also an <font size="2" face="Arial"><i>ImageObserver</i></font>,
for reasons as discussed above and as will be elaborated below.
The first part of the constructor, on line 0034, stores the
identity of the <font size="2" face="Arial"><i>ImageObserver </i></font>in
the <font size="2" face="Arial"><i>observer</i></font> instance
attribute. The width and height of the cursor image are then
obtained, using the <font size="2" face="Arial"><i>toRotate</i></font>
<font size="2" face="Arial">getWidth()</font> and <font size="2"
face="Arial">getHeight()</font> methods which both require an <font
size="2" face="Arial">ImageObserver</font> argument. Having
established the size of the cursor image, on lines 0037 and 0038,
the sizes of the <font size="2" face="Arial"><b>int</b></font> <font
size="2" face="Arial"><i>pixels</i></font> array, which will
contain the raw image and the <font size="2" face="Arial"><b>int</b>
<i>rotatedPixels</i></font> array, which will contain the
processed image, can be established.</p>

<p>On lines 0040 to 0042 an instance of the <font size="2"
face="Arial">PixelGrabber</font> class is constructed whose
arguments ensure that it will be capable of extracting all the
pixels from the <font size="2" face="Arial"><i>toRotate</i> Image</font>
into the <font size="2" face="Arial">pixels</font> array. This
will comprise the first part of the image processing pattern
shown in Figure 4.8. The grabbing is accomplished within the <font
size="2" face="Arial"><b>try/&nbsp;catch</b></font> structure
guarding the call of the <font size="2" face="Arial">grabPixels()</font>
method on lines 0044 whose <font size="2" face="Arial"><b>catch</b></font>
part abends the program should it fail. </p>

<p>The outcome of the constructor is that the <font size="2"
face="Arial"><i>pixels</i></font> array contains a representation
of the <font size="2" face="Arial"><i>toRotate</i> Image </font>containing
the cursor. This representation will be processed into the <font
size="2" face="Arial"><i>rotatedPixels</i></font> array,
implementing the second stage from Figure 48. The implementation
of the <font size="2" face="Arial"><i>rotate()</i></font> method,
is as follows.</p>

<pre><font size="3">0059     <b>protected</b> Image <i>rotate</i>( <b>int</b> <i>angle</i>) { 
0060     
0061     <b>int</b>    <i>x</i>, <i>y</i>;
0062     <b>int</b>    <i>fromX</i>, <i>fromY</i>;
0063     <b>int</b>    <i>toX</i>,   <i>toY</i>;
0064     <b>int</b>    <i>transparent</i> = 0x00000000;
0065     <b>double</b> <i>radians</i>  = (((<i>double</i>) (-(<i>angle</i> -180) ) %360) / 180.0) * Math.PI;
0066     <b>double</b> <i>cosAngle</i> = Math.cos( <i>radians</i>);
0067     <b>double</b> <i>sinAngle</i> = Math.sin( <i>radians</i>); 
0068  
0069  
0070        <b>for</b> ( <i>y</i> = 0; <i>y</i> &lt; <i>imageHeight</i>; <i>y</i>++) { 
0071           <b>for</b> ( <i>x</i> = 0; <i>x</i> &lt; <i>imageWidth</i>; <i>x</i>++) {
0072              // Rotate around the center of the image.
0073              <i>toX</i>   = ( <i>imageWidth</i>  /2) - x;
0074              <i>toY</i>   = ( <i>imageHeight</i> /2) - y;
0075              <i>fromX</i> = (<b>int</b>)( ( <i>toX</i> * <i>cosAngle</i>) - ( <i>toY</i> * <i>sinAngle</i>));
0076              <i>fromY</i> = (<b>int</b>)( ( <i>toX</i> * <i>sinAngle</i>) + ( <i>toY</i> * <i>cosAngle</i>)); 
0077              <i>fromX</i> += <i>imageWidth</i>  /2;
0078              <i>fromY</i> += <i>imageHeight</i> /2;          
0079                                
0080              <b>if</b> ( (<i>fromX</i> &lt; 0) || (<i>fromX</i> &gt;= <i>imageWidth</i>)  ||
0081                   (<i>fromY</i> &lt; 0) || (<i>fromY</i> &gt;= <i>imageHeight</i>) ){
0082                 // Rotated point is outside the image
0083                 <i>rotatedPixels</i>[ (<i>y</i> * <i>imageWidth</i>) + <i>x</i>] = <i>transparent</i>;
0084              } <b>else</b> {                            
0085                 <i>rotatedPixels</i>[ (<i>y</i> * <i>imageWidth</i>) + <i>x</i>] =
0086                        <i>pixels</i>[ (<i>fromY</i> * <i>imageWidth</i>) + <i>fromX</i>];
0087              } // End if.          
0088           } // End x loop.
0089        } // End y loop.         
0090        
0093        <i>rotatedImage</i> =  <i>component</i>.createImage( 
0094                             <b>new</b> MemoryImageSource( <i>imageWidth</i>, <i>imageHeight</i>,  
0095                                                   <i>rotatedPixels</i>, 0, <i>imageWidth</i>));
0096        <b>return </b><i>rotatedImage</i>;         
0097     } // End <i>rotate</i>.</font></pre>

<p>Before considering the details of this method the 32 bit RGB
pixel value as shown in Figure 4.4 needs to be reconsidered. The
upper eight bits in locations 24 to 31, shown as <i>AA</i>,
control the <i>transparency</i> of the pixel. A pixel value which
has all of these bits set (the hexadecimal value 0xFF) is
completely opaque and the RGB color in the remaining 24 bits will
be rendered exactly as specified onto the image. A pixel value
which has all of these bits clear (the hexadecimal value 0x00) is
completely transparent and the RGB color in the remaining 24 bits
is irrelevant as it will not be rendered. Intermediate values
produce a varying degree of transparency. This information is
known as the <i>alpha channel</i> and a full 32 bit pixel value
in this format is known as an <i>ARGB</i> value.</p>

<p>The image which is used as the cursor has been prepared so
that it contains only two colors and all the pixels in the image
which do not form a part of the cursor have their alpha values
set so as to be transparent. When the cursor is rendered the
transparent parts will have no effect upon the existing
background of the <font size="2" face="Arial"><i>Tuttle</i></font>
area. This consideration is also required when the image is
rotated; any parts of the rotated image which would have come
from outside the cursor are set to the value of the transparent
mask as declared on line 0064 of the listing. This consideration
is illustrated in Figure 4.9. </p>

<p align="center"><img src="fig49.gif" width="266" height="153"></p>

<p align="center"><font size="2"><b>Figure 4.9</b> Rotating an
image, the gray areas indicate the parts of the </font><br>
rotated image which originated outside the original image. <br>
</p>

<hr>

<blockquote>
    <p><b><i>Design Advice</i></b> </p>
    <p>When rotating an image, calculate the location where each
    pixel of the rotated area comes from not the location where
    each pixel on the original image will be rotated to. This
    will avoid gaps appearing in the image. </p>
</blockquote>

<hr>

<p>The rotating of the cursor takes place within the double loop
between lines 0070 and 0089. Each pixel on the rotated image is
considered in turn and the location on the original image where
it might have originated from is determined using the appropriate
trigonometric transformation. If the <font size="2" face="Arial"><b>if</b></font>
decision on lines 0080 and 0081 indicates that the original
location is outside the bounds of the original image, the rotated
pixel is set to the transparent mask. Otherwise the location is
known to be within the bounds and the pixel value is copied from
the original image to the rotated image on lines 0085 and 0086. </p>

<p>This implementation is further complicated by two other
factors. Firstly the image is rotated around its center point, so
the locations where the pixel is to be moved to (&nbsp;<font
size="2" face="Arial"><i>toX</i></font> and <font size="2"
face="Arial"><i>toY</i></font>) and where it is moved from
(&nbsp;<font size="2" face="Arial"><i>fromX</i></font> and <font
size="2" face="Arial"><i>fromY</i></font>) have to be expressed
as displacements from the center as the rotation is performed in
lines 0083 to 0086. However the <font size="2" face="Arial"><i>y</i></font>
and <font size="2" face="Arial"><i>x</i></font> indices of the
loops are expressed in the normal top left bottom right scan line
sequence and the <font size="2" face="Arial"><i>fromX</i></font>
and <font size="2" face="Arial"><i>fromY</i></font> are converted
to this convention in lines 0077 and 0078. </p>

<p>The second complication is that the <font size="2"
face="Arial"><i>pixel</i></font> and <font size="2" face="Arial"><i>rotatedPixel</i></font>
arrays are single dimensional, as required by the <font size="2"
face="Arial">PixelGrabber</font> class, and the two coordinate
values have to be combined when the array is accessed between
lines 0083 to 0086. </p>

<p>Once the original image in the <font size="2" face="Arial"><i>pixels</i></font>
array has been rotated into the <font size="2" face="Arial"><i>rotatedPixels</i></font>
array, the <font size="2" face="Arial"><i>rotatedPixels</i></font>
array is used to construct an <font size="2" face="Arial">Image</font>
instance on lines 0093 to 0095, implementing the third part of
Figure 4.8. This step employs an instance of the <font size="2"
face="Arial">MemoryImageSource</font> class to accomplish the
conversion and the <font size="2" face="Arial">Image</font>
produced from it is <font size="2" face="Arial"><b>return</b></font>ed
from the method, and used by the <font size="2" face="Arial"><i>Tuttle</i></font>
class to indicate the direction of the <font size="2"
face="Arial"><i>tuttle</i></font>. </p>

<p>The implementation of the <font size="2" face="Arial"><i>setCursorColor()</i></font>
method is simpler. Its requirement is to consider each pixel in
the pixel array and, if it is not a transparent pixel, replace
its value with a non-transparent <font size="2" face="Arial"><i>newColorMask</i></font>
obtained from the <font size="2" face="Arial"><i>newColor</i></font>
argument. Its implementation is as follows. </p>

<pre><font size="3">0100     <b>protected void</b> <i>setCursorColor</i>( Color <i>newColor</i>) { 
0101     
0102     <b>int</b> <i>x</i>, <i>y</i>;
0103     <b>int</b> <i>newColorMask</i>    = 0;
0104     <b>int</b> <i>transparentMask</i> = 0xFF000000;
0105        
0106        <i>newColorMask</i> = <i>transparentMask</i>             |
0107                       (<i>newColor</i>.getRed()   &lt;&lt; 16) |
0108                       (<i>newColor</i>.getGreen() &lt;&lt; 8)  |
0109                        <i>newColor</i>.getBlue();
0110       
0111        <b>for</b> ( <i>y</i> = 0; <i>y</i> &lt; <i>imageHeight</i>; <i>y</i>++) { 
0112           <b>for</b> ( <i>x</i> = 0; <i>x</i> &lt; <i>imageWidth</i>; <i>x</i>++) {            
0113                <b>if</b> ( (<i>pixels</i>[ (<i>y</i> * <i>imageWidth</i>) + x] &amp; <i>transparentMask</i>) 
0114                                                   == <i>transparentMask</i> ) { 
0115                   <i>pixels</i>[ (<i>y</i> * <i>imageWidth</i>) + <i>x</i>] = <i>newColorMask</i>;              
0116                } // End if.                     
0117           } // End <i>x</i> loop.
0118        } // End <i>y</i> loop.                    
0119     } // End <i>setCursorColor</i>.</font></pre>

<p>The <font size="2" face="Arial"><i>newColorMask</i></font> is
constructed from the <font size="2" face="Arial"><i>transparentMask</i></font>
and the RGB components of the <font size="2" face="Arial"><i>newColor</i></font>,
obtained using the <font size="2" face="Arial">getRed()</font>,<font
size="2" face="Arial"> getGreen()</font> and <font size="2"
face="Arial">getBlue()</font> methods on lines 0106 to 0109. This
is accomplished using the bitwise left shift operator
(&nbsp;&lt;&lt;&nbsp;) and bitwise <b><i>or</i></b>ing
(&nbsp;|&nbsp;)of the resulting values so as to produce a 32 bit
ARGB value as illustrated in Figure 4.4. The <font size="2"
face="Arial"><i>pixels</i></font> array is then processed by
having every value considered and if it is not transparent is
replaced with the <font size="2" face="Arial"><i>newColorMask</i></font>
on line 0015. This will ensure that the next time a cursor is
requested by using the <font size="2" face="Arial"><i>rotate()</i></font>
method, the color of the cursor will have changed.</p>

<p>The techniques used in the <font size="2" face="Arial"><i>TuttleCursor</i></font>
class are also used in the <font size="2" face="Arial"><i>Tuttle</i></font>
<font size="2" face="Arial"><i>setBackground()</i></font> method,
which was omitted above. Its implementation is as follows. </p>

<pre><font size="3">0228     <b>public void</b> <i>setBackground</i>( Color <i>newColor</i>) { 
0229     
0230     <b>int</b>    <i>x</i>, <i>y</i>;
0231     <b>int</b>    <i>pixels</i>[];
0232     Image  <i>newImage</i>;
0233     <b>int    </b><i>newColorMask</i>;
0234     <b>int</b>    <i>oldColorMask</i>;
0235     Color  <i>oldColor</i>;  
0236  
0237     PixelGrabber <i>grabber</i>;
0238     <b>boolean</b>      <i>status</i>;   
0239     
0240        <i>pixels</i>            =  <b>new</b> <i>int</i>[ <i>screenWidth</i> * <i>screenHeight</i>];
0241        <i>newColorMask</i>      =  0xFF000000                  |
0242                             (<i>newColor</i>.getRed()   &lt;&lt; 16) |
0243                             (<i>newColor</i>.getGreen() &lt;&lt; 8)  |      
0244                             <i>newColor</i>.getBlue();
0245        <i>oldColorMask</i>      =  0xFF000000                           |
0246                             (<i>currentBackground</i>.getRed()   &lt;&lt; 16) |
0247                             (<i>currentBackground</i>.getGreen() &lt;&lt; 8)  |      
0248                             <i>currentBackground</i>.getBlue(); 
0249                             
0250        <i>newImage</i> = <i>createImage</i>( <i>tuttleImage</i>.getSource());                    
0251        <i>grabber</i> =  <b>new</b> PixelGrabber( <i>newImage</i>, 
0252                                     0, 0,
0253                                     <i>screenWidth</i>, <i>screenHeight</i>,  
0254                                     <i>pixels</i>, 0, <i>screenWidth</i>);                          
0255  
0256        <b>try</b> {    
0257           <i>status</i> = <i>grabber</i>.grabPixels();           
0258           <b>if</b> ( !<i>status</i>) { 
0259              <b>throw new</b> InterruptedException();
0260           } // End if.            
0261        } <b>catch</b> ( InterruptedException <i>exception</i>) {
0262           System.err.println(&quot;Exception grabbing pixels ... abending&quot;);
0263           System.exit( -1);            
0264        } // End try/catch.
0265        
0266        <b>for</b> ( <i>y</i> = 0; <i>y</i> &lt; <i>screenHeight</i>; <i>y</i>++) { 
0267           <b>for</b> ( <i>x</i> = 0; <i>x</i> &lt; <i>screenWidth</i>; <i>x</i>++) {            
0268                <b>if</b> ( <i>pixels</i>[ (<i>y</i> * <i>screenWidth</i>) + <i>x</i>] == <i>oldColorMask</i>) { 
0269                   <i>pixels</i>[ (<i>y</i> * <i>screenWidth</i>) + <i>x</i>]   =  <i>newColorMask</i>;              
0270                } // End if.
0271           } // End x loop.
0272        } // End y loop.                                                                       
0273  
0274        <i>newImage</i> = <b>this</b>.createImage( <b>new</b> MemoryImageSource( 
0275                                               <i>screenWidth</i>, <i>screenHeight</i>,
0276                                               <i>pixels</i>, 0, <i>screenWidth</i>));
0277        <i>tuttleGraphics</i>.drawImage( <i>newImage</i>, -(<i>screenWidth</i> /2), 
0278                                  -(<i>screenHeight</i> /2), <b>this</b>);                                                        
0279  
0280        <i>currentBackground</i> = <i>newColor</i>;                                                        
0281        repaint();   
0282     } // End <i>setBackground</i>.</font></pre>

<p>This method operates by obtaining a copy of the <font size="2"
face="Arial">Image</font> as an array of pixels, between lines
0250 and 0264, which is the first part of Figure 4.8. The method
then iterates through the array replacing any pixel which has the
<font size="2" face="Arial"><i>oldColorMask</i></font> value with
the <font size="2" face="Arial"><i>newColorMask</i></font> value,
which is the second part of Figure 4.8. It then recreates an <font
size="2" face="Arial">Image</font> in <font size="2" face="Arial"><i>newImage</i></font>
from the <font size="2" face="Arial"><i>pixel</i></font> array,
on lines 0274 to 0276, which is the third part of Figure 4.8. It
concludes by copying the processed <font size="2" face="Arial"><i>newImage</i></font>
it into the <font size="2" face="Arial"><i>tuttleImage</i></font>
attribute on lines 0277 and 0278, causing it to be displayed when
the <font size="2" face="Arial"><i>repaint()</i></font> method is
called on line 0281, after it has noted the <font size="2"
face="Arial"><i>newColor</i></font> in its <font size="2"
face="Arial"><i>currentBackground</i></font> attribute. The
effect is for any pixels of the old background color to be
replaced with pixels of the new background color and leaving the
rest of the image unchanged.</p>

<p>The pattern for the processing of an <font size="2"
face="Arial">Image</font>, shown in Figure 4.8, has been
demonstrated twice in this section. It was used in the <font
size="2" face="Arial"><i>rotate()</i></font> method of the <font
size="2" face="Arial"><i>TuttleCursor</i></font> class and also
in the <font size="2" face="Arial"><i>setBackground()</i></font>
method of the <font size="2" face="Arial"><i>Tuttle</i></font>
class. This pattern of actions, and the Java techniques to
implement them, can be adapted for other image processing
operations, some possible operations are suggested in the end of
chapter exercises. </p>

<p>&nbsp;</p>

<hr>

<blockquote>
    <p><a href="tuttles\tuttlecursor.java"><font size="5"><img
    src="list.gif" align="middle" border="0" width="40"
    height="35"> TuttleCursor.java</font></a></p>

    <p><a href="tuttles\tuttle.gif"><font size="5"><img
    src="tuttles\tuttle.gif" align="middle" border="0" width="40"
    height="35"> tuttle gif file</font></a></p>   

</blockquote>

<hr>

<blockquote>
    <p><a href="ch45.html"><font size="4"><img src="next.gif"
    align="middle" border="0" width="50" height="40"></font><font
    size="5">4.5 The </font><font size="5" face="Arial"><i>TuttleTest</i></font><font
    size="5"> demonstration class</font></a></p>
    <p><a href="ch43.html"><font size="4"><img src="last.gif"
    align="middle" border="0" width="50" height="40"></font><font
    size="5">4.3 The construction of the</font> <font size="5"
    face="Arial"><i>Tuttle</i></font><font size="5"> class</font></a></p>
</blockquote>

<hr>
</body>
</html>
