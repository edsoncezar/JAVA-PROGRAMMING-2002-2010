<HTML>

<HEAD><meta http-equiv="pragma" content="no-cache">

<TITLE>Not whether Java but how Java</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>

<BODY BGCOLOR=WHITE>

<H1><CENTER> Not <I>whether </I>Java but <I>how </I>Java<BR>
</CENTER></H1>

<P>
<CENTER><FONT SIZE=2>Chris Wallace, Peter Martin and Bob Lang</FONT></CENTER>
<P>
<CENTER><FONT SIZE=2>University of the West of England</FONT></CENTER>
<P>
<CENTER><FONT SIZE=2>Bristol<BR>
</FONT></CENTER>
<H2>1.1. Hard decisions</H2>

<P>
Everyone who has taught programming has agonised over difficult
curriculum design questions.  Most prominent is the question of
first language choice, a matter still undecided by the great and
the good in computer science education these past 40 odd years.
 Fewer words have been expended on questions of curriculum structure:
 is a programming language to be learnt separate from or together
with program design;  should specification be introduced before/after/with
implementation;  what is the appropriate balance between programming
in the large and programming in the small; teach one large language
or many small languages?  The position we each adopt on these
questions depends on a range of contextual issues; on the ability
and expectations of our students  and staff; on what we believe
good programming  <B>is</B> ; on how the skills, knowledge and
motivation of programmers is best acquired.
<P>
The report on the Open University Workshop on language choice
held in September 1993 (Woodman 1996) makes salutary reading in
this regard.  It is noticeable that the exclusive focus of the
bulk of the essays is on the languages themselves as artefacts:
their syntax, semantics and the programming styles they enable.
 There is seldom a mention of the learner; her needs, her conceptual
development, her motivation.  Nor is there much evidence of reflection
on the end-point - of what constitutes expert performance in the
programming task, seen not only as the process of constructing
logically sound symbolic systems but also artefacts which satisfy
human and economic needs.  The attempts at 'scientific' treatment
of the language choice question often, as a result, appeared to
be window-dressing on a more complex set of ill-grounded beliefs
and shared cultural prejudice.
<H2>1.2. Whether Java?</H2>

<P>
Reviewing the straightforward technical comparison, it appears
to me that, had the conference been held now, Java would have
been the choice of over half the authors.  Many were forced reluctantly
to adopt C++, despite its lack of garbage collection, mixture
of value, pointer and reference semantics and general trickiness.
 Java has removed most of  C++'s disadvantages, and Java 1.1 will
remove more, albeit at the expense of a more complex language.
 Java syntax is close enough to C to help when students need to
use C - particularly for interfacing to legacy systems.  Unfortunately
some poor syntax has been carried over in to Java too but nothing
that cannot be lived with.  
<P>
Other authors, such as Woodman at the  Open University, chose
Smalltalk.  I was particularly struck by one sentence: <I>'If
developments in the financial sector are anything to go by, then
Smalltalk could be tomorrow's language' </I> Sadly not.  I myself
hold Smalltalk in great affection, and am teaching it now to 130
second year computing students, perhaps for the last time.  They
love the environment at the present but the lack of code management
(in Smalltalk Express) will annoy them in the end.  Packages are
essential, not just for project sanity but, by providing a tangible
distinction between the student's work and Parcplace/Digitalks,
for pride of accomplishment.  Java's advantages of integration
of concurrency and error handling, distinction between type and
class via Interfaces and its widespread use in distributed systems
would outweigh for most teachers the appeal of the uniform object
model of Smalltalk.
<H2>1.3. If Java, then how?</H2>

<P>
Given both the difficulty of rational language choice, and the
rough analysis that Java would now be a popular choice, based
on the criteria suggested by various authors at the OU workshop
, we should shift our attention from the <I>whether Java</I> question
to the <I>if Java, then how</I> question. 
<P>
One paper at the OU workshop (Petre, 1996) does attempt to broaden
the question from technical considerations by reflecting on observations
of expert programmer behaviour.  While the whole paper warrants
reading, I shall only quote her concluding implications for the
teaching of programming and the training of programmers. 
<P>
<UL>
<I>emphasize programming cultures, not programming languages;</I>
<P>
<I>support paradigm shifts; teach reasoning styles as selectable
tools;</I>
<P>
<I>cultivate strategy and abstraction skills;</I>
<P>
<I>decouple solutions from coding;</I>
<P>
<I>cultivate readership and reflective programming;</I>
<P>
<I>recognise the importance of secondary notation;</I>
<P>
<I>provide operational information;</I>
<P>
<I>choose a genuine general -purpose language;</I>
<P>
<I>if you provide training wheels, remember to take them off;</I>
<P>
<I>foreshadow professional practice</I>
</UL>
<P>
Academic leaders face other problems too in changing languages,
such as staff development, material development, and choice of
teaching environments, but I believe it would be helpful to keep
these pedagogic issues in mind as we wrestle with  the problem
of curriculum design.
<H2>1.4. The UWE modular Programme.</H2>

<P>
The Faculty of Computer Studies and Mathematics runs an undergraduate
modular programme of awards which range across the spectrum of
Business Decision Analysis, Information Systems, Computer Science
and Computing for Real Time systems.  HND and Honours degrees
awards are part of the programme which has an intake of some 400
students each year.  Students take the equivalent of six full
modules each year, but for computing students, the curriculum
is divided into term length half-modules.  Currently none of the
awards require A-Level or OND computing although about two-thirds
of the current cohort do have prior computing studies.  
<P>
This programme is being reviewed after having been in operation
for four  years. In the revised scheme we want to strengthen the
mainstream computing awards by requiring some basic computing
practice prior to entry.  <I>Ab initio</I> students may also take
the same module but require to take an additional bridging module.
 Information systems courses such as the long-established degree
in Systems and Analysis and a new course in Business Information
 Systems are moving away from teaching programming altogether.
 Mathematics awards have the same problem over first language
choice for their students.  Currently this is Fortran but they
would like to move to a language which supports symbolic manipulation
and Maple is currently preferred.
<P>
For the computing awards,  we are taking the opportunity to revisit
the choice of first programming language, which for the past six
years has been Modula-2.   Teaching of introductory programming
is currently split into a number of half-modules totalling 2 full
modules.  Language teaching in Modula-2 is one half-module, the
teaching of program design, currently functional decomposition
with pseudo-code, another.  The two are coupled by a common problem
set, and solutions are expected to be designed in pseudo-code
before implementation in Modular-2.  Second term half-modules
expand on the language development and on program design. Most
students will also take a half-module in Formal Specification,
using Z.
<P>
This fine-grained design is being replaced by two full modules
in the revised programme.  One in 'programming in the small' is
a combined language and design course aimed at developing single
-language systems.  It is for this module that Java is being considered
as the replacement for Modula-2. Some aspects of formal specification
are required to be included, particularly pre-conditions, post-conditions
and invariants.
<P>
The other module adopts a 'programming in the large' approach
which tackles the design of systems running on multiple platforms
with multiple languages, reusing or customising existing software
resources. Here we expect to introduce the students to Perl and
develop intranet applications.  The two modules come together
when Java applets are incorporated in the intranet applications.
  In this module we also teach notations for,  first describing
and then prescribing the structure of complex software and communications
systems.
<P>
The other first year modules are computer systems architecture,
analytic modelling, a module specific to the award and a elective
module from some other Faculty such as Business, Art Media and
design or  Modern Languages. 
<P>
In the second year, there are further core modules in software
engineering, software design, data structures and databases and
operating systems and networks in addition to further award-specific
modules. In the final year there is a wide range of optional modules
in computing specialities alongside a 2-module individual design
project.
<P>
<B>1.5.  Java at UWE</B>
<P>
It is always with some reservation that the thorny
question of first language choice is raised.  It is however noticeable
that, once Java was proposed, staff were more interested in questions
of what this would mean for teaching than on debate about that
choice.  There is of course some anxiety about a new language,
particularly in the face of increased pressure on our time through
'efficiency cuts' and increasing quality demands. 
<P>
Our approach has been to prototype the delivery of
a first year Java course by changing from Smalltalk to Java on
one version of a second-year half-module on object oriented development.
 Our HND stream is, this term, based on Java whilst the degree
students remain with Smalltalk..  The groups are of unequal size
- 60 HND students and 140 degree students.  Although the two groups
are not closely matched, and there is inevitably a element of
Hawthorne effect with this new initiative, it will nevertheless
be interesting to see how the two groups compare in the understanding
of object-oriented concepts by the end of the modules. The four
Java practical sessions are tutored by the lecturers who currently
teach Modula-2 in the first year.  We hope that this approach
will provide some staff development as well as experience in the
practical difficulties of Java teaching before we have to tackle
the problem of 200 first-year students.  We will also provide
an in-house course during our staff development week at Easter.

<P>
Although the problems encountered in a second level
course covering object-oriented concepts are clearly different
from those likely to be encountered in a first level  course on
introductory programming, there are a number of issues in common,
and if, as is our present intention, object-orientation is to
be introduced in the latter part of  the new first-level course,
the efficacy of Java as a vehicle for the teaching of basic OO
concepts remains important.
<P>
Experience gained so far, and we are only three weeks
into the course, would suggest that Java is a more accessible
language for a first level course than either Smalltalk or C++.
However, a number of issues have been raised and are discussed
briefly below :-<BR>

<UL>
<LI>Availability of suitable and affordable text
books.</FONT>
<LI>Availability of programming environments for
home use.</FONT>
<LI>Compile time performance for large group working.</FONT>
<LI>Compile time diagnostics and debugging tools.</FONT>
<LI>Support for simple I/O on the one hand and GUI
development on the other.</FONT>
<LI>Suitability as a vehicle for other paradigms.</FONT>
<LI>Language features and relationship to other languages.</FONT>
<LI>Student expectations.</FONT>
</UL>

<P>
</FONT>
<P>
Taking these points in order, the first problem encountered
was that of finding a text book which adequately addressed the
OO concepts and the use of Java in application development. Many
of the extensive array of Java texts that have leapt onto the
bookshelves are poorly written, contain numerous typographical
errors, spend an undue amount of time illustrating the development
of Applets and concentrate on images, sound and animation at the
expense of  object-orientation.<BR>
</FONT>
<P>
The major drawback of Java for student home use is
the need for Windows-95, but our feeling on this is that the problem
will go away quickly as the average student machine configuration
improves.<BR>
</FONT>
<P>
Compile time performance is important when using
a networked system with large practical groups and we are currently
conducting some comparison trials between Modula-2 and Java. On
the positive side, the compile time diagnostics, whilst not guaranteeing
to catch all class usage errors, does produce helpful diagnostics.
The existence of language sensitive editors which allow compilation
within the editor also serve to shorten the edit-compile-correct
cycle.<BR>
</FONT>
<P>
One of the most obvious shortcomings first encountered
with Java is its lack of provision of simple numeric input and
formatted output when used in a simple VT100 mode. Correcting
this is simply a matter of providing the necessary sub-classes
or extensions to existing classes and it does seem strange that
this has not been done.<BR>
</FONT>
<P>
On the other hand, the support for GUI's is good,
given the constraints imposed by the need for platform independence
and windows based application development, even without the help
of a GUI builder is not beyond the capabilities of first level
students.<BR>
</FONT>
<P>
One motivation for using Java as a first language
is the teaching possibilities it opens up, not just for programming
in the large, but for supporting the study of other paradigms
such as concurrent programming, networking and distributed programming,
data bases and of course the more traditional procedural approach
adopted in structured programming.<BR>
</FONT>
<P>
The syntactic similarity between C, C++ and Java
is at once an advantage and the cause for some concern. The benefit
of this similarity lies in the ease of moving between these languages
given the need our students have to program in C and C++ in more
specialised modules at level 2 and 3, such as Image processing,
graphics, embedded systems development etc. The unfortunate consequence
is that a number of unsatisfactory features of C have been inherited
- such as the switch statement, the use of break and continue
and the absence of an enumerated type. On balance however, the
elimination of the more dangerous features from C and C++ and
the adoption of a fully dynamic model for objects eases the understanding
of OO concepts.<BR>
</FONT>
<P>
One problem encountered early-on in the current course
was dealing with the often unreasonably high expectations that
students have, due to the amount of hype currently attached to
Java, of being able to develop GUI's with animation and sound
easily. Although it is undeniable that such programs can be hacked-out
quickly, they are not as simple as might be expected for novices
and if adopting a disciplined and professional object-oriented
approach to software development, do not reasonably appear until
quite late in a course.<BR>
</FONT>
<P>
One aim of the current Java course was to make use
of graphics at the earliest opportunity. But to do this in any
context other than a paint program development, requires the use
of an MVC approach if misconceptions are to be avoided. Luckily,
Java supports MVC quite well but this is clearly in the realms
of the more advanced topics covered.</FONT>
<H2>1.6. Program design paradigms</H2>

<P>
Although there has been some debate about the syntax of Java,
there is much more concern about what the change means for the
teaching of program design approaches.  In the current programme,
 students start with top-down functional decomposition using pseudo-code.
 Depending on the specific award and student choice, students
will encounter formal specification with Z, JSP, object-orientation,
concurrent programming, functional and logic programming.  Each
paradigm has its own group of adherents within the faculty.  Given
these competing paradigms, there is potential for tension in the
change to Java.  The choice of Java does not of itself solve the
more fundamental problem of the scheduling of the teaching of
program design paradigms.  Java has the capability of reducing
the number of languages which students encounter but will not
eliminate the need for other languages. 
<H2>1.7. Comparative examples</H2>

<P>
I have always taught object orientation by starting from problems
which are biased towards the paradigm, believing that this provided
the best  way to convert mind-sets.  This year, driven more by
the programme review than any change of heart,  I started from
an existing problem set chosen as suitable for a functional decomposition
approach.  Students had already encountered these in year 1. So
that the Smalltalk students should not feel left out of the Java
revolution, model answers were also provided in Smalltalk, together
with the Modula-2 specimens.  
<H2>1.8. Armstrong numbers</H2>

<P>
The first problem is used as a worked example in the present program
design module.  The problem is to decide which integers have the
property of being equal to the sum of their digits raised to the
power of the units, called Armstrong numbers. 
<P>
Appendix  A explains the problem and provides solutions in Modula-2,
Java and Smalltalk.
<P>
Both the Java and Modula-2 programs adopt the same paradigm of
procedural abstraction.  Curiously neither of these solutions
follows directly from the pseudo-code of the worked example, since
this does not use procedural abstraction, presumably because it
is thought to be too early in the course for this concept to be
introduced.  Indeed the suggested monolithic solution, by intertwining
the computation of the Armstrong property and the counting of
the numbers, makes procedural abstraction less likely.  
<P>
The Smalltalk solution shows the power of a pure object language
in which existing base classes can be extended and expressions
executed directly.  The implementation of integers of unlimited
size is ideal for exploratory programming.  It shows too the power
of collection classes and closures in closing the gap between
problem and solution. This kind of solution is not possible in
Java because integers are not objects, and even if they were,
compiled classes can only be extended by subclassing.  I shall
miss it.
<P>
But beyond these differences lies much commonalty.  Any solution
to this problem must draw on the basic concepts of sequence, iteration
and selection, arithmetic operations such as +, * , mod and div,
the idiom of iterative modification , the algorithm for reduction
of a number to its digits and the generalisation of a three-digit
number  to an n-digit number.  A good solution should also include
procedural abstraction and, despite syntactic differences, all
the languages enable this solution.  We must ensure that students
have the opportunity to develop clear understanding of these basic
concepts, idioms and design strategies, whatever programming language
is chosen.   We must not lose sight of these more general mental
tools in our enthusiasm to tackle exciting problem-centred programming,
be it interactive applets or symbolic mathematics.  
<H2>1.9. Snakes and Ladders</H2>

<P>
The problem set for the first year course concludes with a choice
of this problem, in which a game of snakes and ladders is to be
simulated, or the computation of a calendar for any month.  Appendix
B shows solutions to this problem in Modula-2, Java and Smalltalk.
 The solutions differ in the user interface provided and in the
granularity of objects.  
<P>
Here the advantages of Smalltalk over Java have diminished.  Java
in providing a package structure (not used in this example) provides
a better means of separating user code from reused code.  Indeed
the Smalltalk solution is incomplete since the Random class used
is not a base class but one I had  written and then forgotten.
 Code management tools ease this problem but are an extra layer
of complexity for Smalltalk. 
<P>
Smalltalk collection classes provide a advantage in ease of use
of Vector and Enumeration and string handling is easier,  but
the real problem for a programmer lies in the structuring of the
objects and their interrelationships.  However much more time
is spent, even by an experienced OO programmer on such issues
as:
<H3>granularity</H3>

<P>
What are the objects? are squares, snakes and ladders, moves objects?
 In the Smalltalk solution I have squares as elements of an array,
snakes and ladders as integers.  Moves are objects in the Smalltalk
solution but not in Java, merely because I was further down the
track of putting a GUI on the Smalltalk model.  These decisions
will always be hard, even in a pure object language and we must
not trivialise the difficulty by subscribing to the notion that
finding objects is easy. 
<H3>visibility</H3>

<P>
which objects know about which other objects?   Here I have been
driven to an unnatural position - that the game exists as a object
which can 'see' everything, that a player can see the board but
not the other players etc.  Not much help from the problem structure
here either.  
<H3>allocation of behaviour</H3>

<P>
who throws the die? I have the game throwing the die and telling
the player what the result was.  I could objectify the die and
pass it to the player to throw.  No obvious choices here either.
<P>
All too easily we have passed in to a world of undecidable issues.
 We might appeal to the ease with which the objects can be reused,
but this merely introduces the need to envisage an imaginary world
of  future games builders to decide on how to divide the overall
behaviour into fragments which can be individually overwritten
whilst still making sense of the whole. 
<H2>1.10. Conclusions</H2>

<P>
Both the  procedural and object oriented paradigms are essential
parts of a modern education in computer programming.  We must
not think that, in finding that Java can provide satisfactory
solutions to the implementation of both styles, we have thereby
avoided the need, on the one hand, to pay proper attention to
basic concepts, programming idioms and algorithms, and on the
other to recognise the real difficulty of applying these styles
to even apparently simple problems. 
<H2>I would propose that the object oriented features
of Java be kept  in check until the basics of procedural abstraction
have been laid.  Objects cannot be avoided entirely and careful
choice of problem set will needed.</FONT></H2>

<H2>1.11.  References</H2>

<P>
Petre, Marian(1996) 'Programming Paradiigms and Culture: Implications
of Expert Practice' in  (Woodman , 1996)
<P>
Woordman, Mark ed (1996) <I>Programming Language Choice: Practice
and Experience</I>, Thompson Computer Press
<H1>Appendix A - Armstrong Numbers</H1>

<H2>A.1. The problem </H2>

<P>
<I>An Armstrong number is calculated by taking a number, raising
each digit to the power of the final digit and summing the result.
 If the result of this computation is equal to the original number,
the original number is an Armstrong number.  For example, given
the number 153:</I>
<P>
<I> 1 raised to the power 3 = 1</I>
<P>
<I> 5 raised to the power 3 = 125</I>
<P>
<I> 3 raised to the power 3 = 27</I>
<P>
<I> 1 + 125  + 27 = 153</I>
<P>
<I>153 is therefore an Armstrong number.</I>
<P>
<I>Write a design for a program to list all the Armstrong numbers
in the range 1 to 200 inclusive.  In addition, the program should
report on the number of Armstrong numbers that have been detected.</I>
<H2>A.2. Modular- 2 </H2>

<P>
written by Bob Lang
<OL>
<LI>MODULE Armstrong;
<LI> FROM InOut IMPORT
<LI>   WriteString, WriteCard, WriteLn;

<P>

<LI> CONST
<LI>   MinTestNumber = 1;
<LI>   MaxTestNumber = 200;
<LI>
<LI> PROCEDURE CardPower (Val, Exp:  CARDINAL) : CARDINAL;
<LI>   VAR
<LI>     Result,  (* The final result *)
<LI>   i  (* Loop counter *)
<LI>       CARDINAL;
<LI>   BEGIN (* CardPower *)
<LI>     Result := 1;
<LI>     FOR i := 1 TO Exp DO
<LI>       Result := Result * Val;
<LI>     END (* For *);
<LI>     RETURN Result;
<LI>   END CardPower;
</OL>

<P>

<OL>
<LI> PROCEDURE IsArmstrong (Number: CARDINAL) : BOOLEAN;
<LI>   VAR
<LI>     TempNumber, (* Working copy of input parameter:
Number *)
<LI>     LastDigit, (* Last digit of number being
tested *)
<LI>     NextDigit, (* Current digit of number being
processed *)
<LI>     Sum:  (* Sum of accumulated powers *)
<LI>       CARDINAL;
<LI>   BEGIN (* IsArmstrong *)
<LI>     LastDigit := Number MOD 10;
<LI>     IF LastDigit &lt;&gt; 0 THEN
<LI>      TempNumber := Number;
<LI>  Sum := 0;
<LI>  WHILE TempNumber &gt; 0 DO
<LI>     NextDigit := TempNumber MOD 10;
<LI>     TempNumber := TempNumber DIV 10;
<LI>     Sum := Sum + CardPower (NextDigit, LastDigit);
<LI>  END (* While *);
<LI>  RETURN Sum = Number;
<LI>     ELSE
<LI>        RETURN FALSE;
<LI>     END (* If *);
<LI>   END IsArmstrong;
</OL>

<P>

<OL>
<LI> VAR
<LI>   TestNumber,  (* The number being tested for
Armstrong-ness *)
<LI>   Count:  (* How many Armstrong numbers have
been found *)
<LI>     CARDINAL;
<LI> BEGIN (* Armstrong *)
<LI>   WriteString (&quot;This program produces a
list of Armstrong numbers between &quot;);
<LI>   WriteCard (MinTestNumber, 1);
<LI>   WriteString (&quot; and &quot;);
<LI>   WriteCard (MaxTestNumber, 1);
<LI>   WriteLn;
<LI>   WriteLn;
<LI>   Count := 0;
<LI>   FOR TestNumber := MinTestNumber TO MaxTestNumber
DO
<LI>     IF IsArmstrong (TestNumber) THEN
<LI>       WriteCard (TestNumber, 6);
<LI>  WriteString (&quot; is an Armstrong number&quot;);
<LI>  WriteLn;
<LI>  INC (Count);
<LI>     END (* If *);
<LI>   END (* For *);
<LI>   WriteLn;
<LI>   WriteString (&quot;There were &quot;);
<LI>   WriteCard (Count, 1);
<LI>   WriteString (&quot; Armstrong numbers found.&quot;);
<LI>   WriteLn;
<LI> END Armstrong.
</OL>

<P>

<H2>A.3. Java </H2>

<P>
Written by Chris Wallace<BR>
<PRE>
1. public class Armstrong {
2.  public static int raisedToInteger(int val,int power)  {
3.    int result=1;
4.    for (int i=1; i&lt;=power; i++) {
5.        result *= val;
6.    }
7.    return result;
8. }
9.  public static boolean isArmstrong(int number) {  
10.    int tempNumber, power, digit, sum ;
11.    power = number % 10;
12.    if (power != 0)  {
13.        tempNumber = number;
14.        sum = 0;
15.        while (tempNumber &gt; 0 ) {
16.            digit = tempNumber % 10;
17.            tempNumber = tempNumber/ 10;
18.             sum += Armstrong.raisedToInteger(digit,power);
19.         }
20.        return sum == number;
21.    }
22.    else
23.         return false;
24.  }
25.  public static void testRange(int min, int max) {
26.    for (int i=min; i &lt;= max; i++ )  
27.       if( Armstrong.isArmstrong(i))
28.          System.out.println( String.valueOf(i) + &quot; is an Armstrong number&quot;);       
29.  } 
30.  public static void main(String args[]) {
31.    try {
32.        Armstrong.testRange(1, Integer.parseInt(args[0]));
33.    }
34.    catch  (NumberFormatException e) {
35.        System.out.println(args[0] + &quot; is not an integer.&quot;);
36.   }
37.  }
38. }
39  &gt;  java Armstrong 200
</PRE>

<H2>A.4. Smalltalk </H2>

<P>
Written by Chris Wallace.
<P>
<PRE>
<B>  Integer instance methods</B>
2. armstrongTotal
3.   | num digit power sum |
4.   num := self.
5.  sum := 0.
6.   power := num \\ 10.
7.   (power ~= 0) ifTrue: [
8.        [num ~= 0 ] whileTrue: [
9.               digit := num \\ 10.
10.               num := num // 10 .
11.               sum := sum + ( digit raisedToInteger: power) .
12.               ].
13.         ].
14.   ^ sum
15. isArmstrong
16.    ^ self armstrongTotal = self Execute in the Transcript Window:
17.  (1  to: 200 )  select: [ :i |  i isArmstrong  ]  
18.  ( 1  to: 200) select: [:i | i  factorial isArmstrong ]
</PRE>

<P>
<HR>
<P>
<UL>
<A HREF="conference.html" tppabs="http://www.scism.sbu.ac.uk/jfl/conference/conference.html">Return to the Java Confernce Home Page</A>.
</UL>
<P>
<HR>
<P>

</BODY>

</HTML>
