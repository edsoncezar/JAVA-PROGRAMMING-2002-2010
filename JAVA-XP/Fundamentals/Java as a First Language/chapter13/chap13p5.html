<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>13.5 Hashtables</title>

</head>

<body BGCOLOR="WHITE">

<h2>13.5 Hashtables<br>
</h2>

<p>
The <i><font FACE="Arial">ContactList</font></i> application
developed in the previous section using a <font FACE="Arial">Vector</font>
will be re-developed in this section making use of a pre-supplied
data structure called a <font FACE="Arial">Hashtable</font>.
As mentioned above, when using a <font FACE="Arial">Vector</font>
the remove name option is implemented in an inelegant manner,
requiring the user to input the location of the element in the
list which is to be removed. <br>

<p>
It would be possible for this action to be replaced with one which
requires the user to input the e-mail address of the person who
is to be removed from the list. However, this would require a
<i><b>sequential search</b></i> of the <font FACE="Arial">Vector</font>.
Each element in turn would have to be obtained from the <font FACE="Arial">Vector</font>
and its e-mail attribute compared with the e-mail to be removed.
If there was a match then the element could be removed; otherwise,
once all elements in the <font FACE="Arial">Vector</font>
have been examined, the user could be informed that a person with
that e-mail address is not present in the list.<br>

<p>
This approach would be acceptable for small <font FACE="Arial">Vector</font>s,
but as the list which is being maintained becomes larger and larger
it becomes increasingly inefficient. A more elegant and efficient
solution would be to use a <font FACE="Arial">Hashtable</font>
instance instead of a <font FACE="Arial">Vector</font>
instance to store the list. In order for a <font FACE="Arial">Hashtable</font>
to be used, for any requirement, the data elements which are to
be stored in it have to have a unique identifying <i><b>key</b></i>.
The key value has to be specified when an element is stored in
the <font FACE="Arial">Hashtable</font> and can subsequently
be used to identify which element is to be retrieved, or removed,
from the table. In the example being considered the e-mail address
of the personal details being stored in the list is a, hopefully,
unique identifying key. <br>

<p>
As the key value identifies each element uniquely it is not possible
for two different elements in a table to have the same key. This
consideration will correct a second fault in the previous version
of the <i><font FACE="Arial">ContactList</font></i> application.
In that version it was possible for two entries in the list to
have the same e-mail address. Again this could have been avoided
by searching through the existing list before adding the new element,
and again this would become increasingly unacceptable as the amount
of information grows. When using a <font FACE="Arial">Hashtable</font>,
a request to store an element with a key which is already present
will cause any existing element to be replaced by the new one.
<br>

<p>
The overall structure of the <i><font FACE="Arial">ContactList</font></i>
application will not change, but the context clause will have
to <b><font FACE="Arial">import</font></b> the <font FACE="Arial">java.util.Hashtable</font>
class and the declaration of <i><font FACE="Arial">aList</font></i>
will have to construct an empty <font FACE="Arial">Hashtable</font>
instance as follows.<br>

<pre>
<font>0048    Hashtable <i>aList</i> = <b>new</b> Hashtable();
<br>
</font>
</pre>

<p>
The design of the <font FACE="Arial">Hashtable</font> version
of the <i><font FACE="Arial">removeOption()</font></i>
action is as follows. <br>

<p>
<center><img SRC="c13p5i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter13/c13p5i1.gif" WIDTH="690" HEIGHT="400">
</center>
<p>
The basis of the design, assuming the list is not empty, is to
obtain the e-mail address of the person whose details are to be
removed. If an element with this e-mail is present in the list
the details can be removed, otherwise the user is informed that
the requested details could not be found in the list. The implementation
of this design is as follows. <br>

<pre>
<font>0106     <b>static private void</b> <i>removeOption</i>( Hashtable <i>aList</i>) {
0107  
0108     String  <i>toRemove</i> = &quot;&quot;;
0109     <b>boolean</b> <i>emailOK</i>  = <b>false</b>;    
0110      
0111        <b>if</b> ( <i>aList</i>.isEmpty()) { 
0112            System.out.println( &quot;The list is empty! &quot; + 
0113                  &quot;So it is not possible to remove a person.&quot;);
0114        } <b>else</b> { 
0115            <b>while</b> ( ! <i>emailOK</i>) { 
0116               <b>try</b> { 
0117                  System.out.print( 
0118                     &quot;Please enter the email address of the person to remove :&quot;);
0119                  System.out.flush();
0120                  <i>toRemove</i> = <b>new</b> String( <i>theKeyboard</i>.readLine()).trim();
0121                  <i>emailOK</i>  = <b>true</b>;             
0122               } <b>catch</b> ( IOException <i>exception</i>) { 
0123                  System.out.println( 
0124                             &quot;Sorry there seems to be a problem!\n&quot; +
0125                             &quot;Could you please try again.&quot;);
0126               } // End try/ catch.   
0127            } // End while.           
0128         
0129            <b>if</b> ( <i>aList</i>.containsKey( <i>toRemove</i>)) { 
0130               System.out.print( <i>aList</i>.get( <i>toRemove</i>));
0131               <i>aList</i>.remove( <i>toRemove</i>); 
0132               System.out.println( &quot; ... has been removed from the list.&quot;);         
0133            } <b>else</b> { 
0134               System.out.println( &quot;That email address is not in the list.&quot;);
0135            } // End if.
0136         } // End if.      
0137      } // End <i>removeOption</i>.            <br>
</font>
</pre>

<p>
The <i><font FACE="Arial">aList</font></i><font FACE="Arial">
isEmpty()</font> action is used on line 0111 to make sure that
the list contains at least one element before continuing. If the
list is not empty the e-mail address <i><font FACE="Arial">toRemove</font></i>
is obtained, using a standard <font FACE="Arial">String</font>
input dialog, on lines 0115 to 0127. On line 0129 the e-mail address
to be removed is used as the argument of the <i><font FACE="Arial">aList</font></i><font FACE="Arial">
containsKey()</font> action; this action will return <b><font FACE="Arial">true</font></b>
if an element in the list has the key specified and <b><font FACE="Arial">false</font></b>
otherwise. If it returns <b><font FACE="Arial">true</font></b>
then the details of the existing entry in the list are obtained
on line 0130, using the <i><font FACE="Arial">aList</font></i><font FACE="Arial">
get()</font> action, and output before the new details are removed
from the list using the <i><font FACE="Arial">aList</font></i><font FACE="Arial">
remove()</font> action on line 0131. Should the <i><font FACE="Arial">containsKey()</font></i>
action on line 0129 return <b><font FACE="Arial">false</font></b>
then a suitable message is output on line 0134. A sample interaction
with this option is as follows. <br>

<p>
<hr>
<ul>
<pre>
<font>        Contact list main menu

A.   Add to contact list.
B.   Remove from contact list
C.   Show contact list.
D.   Exit

Please enter your choice : <i><b>c

</b></i>1  E-mail fred@bedrock.quarry.com Name : Fred Flintstone  Phone : 111-222-3333
2  E-mail barney@bedrock.quarry.com Name : Barney Rubble  Phone : 222-333-4444

Contact list main menu

A.   Add to contact list.
B.   Remove from contact list
C.   Show contact list.
D.   Exit

Please enter your choice : <i><b>b

</b></i>Please enter the email address of the person to remove : <i><b>fred@bedrock.quarry.com

</b></i>E-mail fred@bedrock.quarry.com Name : Fred Flintstone  Phone : 111-222-3333 ... has been removed from the list.
</font>
</pre>
</ul>
<hr>

<p>
The first option of the application, to add a person's details,
will also require a re-design and re-implementation. The <font FACE="Arial">Hashtable
put()</font> action requires as arguments a key and an element;
if the key is not already present in the table then the element
is added. However, if the key is already present the existing
contents of the identified element are replaced with the new contents.
At a very minimum the user should be made aware of this and ideally
should be asked to confirm the action before the details are replaced.
This design will only inform the user, upgrading it to obtain
a confirmation will be left as an end of chapter exercise.<br>

<p>
<center><img SRC="c13p5i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter13/c13p5i2.gif" WIDTH="726" HEIGHT="422">
</center>
<p>
The basis of the design is to obtain a suitable new <i>EmailPerson</i>
instance using exactly the same technique as was used in the previous
version of the <i>addOption</i>. However before the details are
added to the list a check is made and, if a person with the same
e-mail address is already in the list, a warning is issued before
the new details are added to the list. The implementation of this
design is as follows. <br>

<pre>
<font>0082     <b>static private void</b> <i>addOption</i>( Hashtable <i>aList</i>,
0083                                    BasicMenu <i>theMenu</i>) { 
0084     
0085     <b>char</b>        <i>subMenuChoice</i>;
0086     <i>EmailPerson</i> <i>aPerson</i>;
0087 
0088        <i>subMenuChoice</i> = <i>theMenu.offerMenuAsChar();</i>
0089        <b>if</b> ( <i>subMenuChoice</i> == PART_OPTION) {            
0090           <i>aPerson</i> = <b>new</b> <i>NamedPerson</i>();
0091        } <b>else</b> {              
0092           <i>aPerson</i> = <b>new</b> <i>PhonePerson</i>();
0093        } // End if. 
0094        <i>aPerson</i>.<i>read</i>();
0095        
0096        <b>if</b> ( <i>aList</i>.containsKey( <i>aPerson.eMailIs</i>())) { 
0097           System.out.println( <i>aList</i>.get( <i>aPerson</i>.<i>eMailIs</i>()) + 
0098                               &quot; ... has been removed.&quot;);
0099        } // End if.
0100        
0101        <i>aList</i>.put( <i>aPerson</i>.eMailIs(), <i>aPerson</i>); 
0102        System.out.println( <i>aPerson</i> + &quot; ... has been added&quot;);          
0103     } // end <i>addOption</i>.<br>
</font>
</pre>

<p>
The first part of this implementation, as far as line 0095, is
identical with the previous version. On line 0096 the <i><font FACE="Arial">aList</font></i><font FACE="Arial">
containsKey()</font> action is used to find out if an element
with the e-mail specified is already present in the list, the
<i><font FACE="Arial">EmailPerson eMailIs()</font></i>
enquiry action being used to obtain the key value for the new
<i><font FACE="Arial">Persons</font></i> instance. If the
key is already present the details of the element which is about
to be removed are output. Following this, in all cases, the new
details are added using the <i><font FACE="Arial">aList</font></i>
<font FACE="Arial">put()</font> action on line 0101. The
<font FACE="Arial">put()</font> action requires the key
value and the element value to be supplied, as shown. Finally
the action is closed by informing the user that the details have
been added to the list. A possible interaction with this action,
showing a new element replacing an existing element, might be
as follows. <br>

<p>
<hr>
<ul>
<pre>
<font>        Contact list main menu

A.   Add to contact list.
B.   Remove from contact list
C.   Show contact list.
D.   Exit

Please enter your choice : <i><b>a

</b></i>          Add contact sub menu

A.   Add name and e-mail
B.   Add name, e-mail and phone number

Please enter your choice : <i><b>b
</b></i>Please enter the email        : <i><b>wilma@bedrock.quarry.com
</b></i>Please enter the name         : <i><b>Wilma Flintstone
</b></i>Please enter the phone number : <i><b>555-666-7777

</b></i>E-mail : wilma@bedrock.quarry.com Name : Wilma Flintstone ... has been removed.

E-mail : wilma@bedrock.quarry.com Name : Wilma Flintstone  Phone: 555-666-7777 ... has been added.</font>
</pre>
</ul>

<hr>

<p>
The implementation of the remaining <i><font FACE="Arial">ContactList</font></i>
action, <i><font FACE="Arial">showOption(),</font></i>
is identical to the third version of the <i><font FACE="Arial">showOption()</font></i>
action presented above. The <font FACE="Arial">Hashtable</font>
class supplies an <font FACE="Arial">elements()</font>
action returning an <font FACE="Arial">Enumeration</font>
instance, which can be used to iterate through the contents of
the structure as before. As suggested by the illustrative output
above there is no particular order in the sequence in which the
elements are retrieved from the structure, a shortcoming which
will be put right in the next chapter.<br>

<p>
The <i><font FACE="Arial">ContactList</font></i> implementation
in this section has used a <font FACE="Arial">Hashtable</font>
constructor and its <font FACE="Arial">IsEmpty(), put(),
get(), elements()</font> and <font FACE="Arial">containsKey()</font>
actions. A summary of these actions, and of some of its other
actions, is given in Table 13.2.<br>

<p>
<center>
<table BORDER="1">

<tr><td WIDTH="331"><center><b><font>Action</font></b><tt><b><font FACE="Courier New"> </font></b></tt></center>
</td><td WIDTH="331"><center><b>note</b></center></td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public </font></b><font>Hashtable();</font></tt>
</td><td WIDTH="331"><font>Default constructor, capacity 101 &amp; load factor 0.75.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public </font></b><font>Hashtable( int initialCapacity);</font></tt>
</td><td WIDTH="331"><font>Alternative constructor specifying initial capacity and load  factor 0.75.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public </font></b><font>Hashtable( int initialCapacity,                  int loadFactor);</font></tt>
</td><td WIDTH="331"><font>Alternative constructor specifying initial capacityand load factor.</font>
</td></tr>

<tr><td WIDTH="331"></td><td WIDTH="331"></td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public final synchronized </font></b><font>Object                     put( Object key,                         Object value);</font></tt>
</td><td WIDTH="331"><font>Add a copy of the object supplied as value to the table using the key specified, replacing any existing element with the same key. Returns the old value of the object or null.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public final synchronized </font></b><font>Object                     get( Object key);</font></tt>
</td><td WIDTH="331"><font>Returns the Object stored with the key in the table, or null if no such object is stored.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public synchronized </font></b><font>Object                   remove( Object key);<b> </b></font></tt>
</td><td WIDTH="331"><font>Removes the element associated with the key, if any.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public synchronized boolean</font></b><font>               containsKey( Object key);<b> </b></font></tt>
</td><td WIDTH="331"><font>Returns true if an element in the table is associated with the key specified, or false otherwise. </font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public synchronized void </font></b><font>clear();</font></tt>
</td><td WIDTH="331"><font>Empties the table of all elements.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public boolean </font></b><font>IsEmpty();</font></tt>
</td><td WIDTH="331"><font>True if the table is empty.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public int </font></b><font>size();</font></tt>
</td><td WIDTH="331"><font>Returns the number of elements in the table.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public synchronized </font></b><font>Enumeration                             elements();</font></tt>
</td><td WIDTH="331"><font>Returns an Enumeration instance which can be used to iterate through the table, in no defined sequence.</font>
</td></tr>

<tr><td WIDTH="331"><tt><b><font FACE="Courier New">public synchronized </font></b><font>Enumeration                                 keys();</font></tt>
</td><td WIDTH="331"><font>Returns an Enumeration instance which can be used to iterate through the table's keys, in no defined sequence.</font>
</td></tr>

</table>
</center>
<center><font>Table 13.2. The actions of the </font><font FACE="Arial">Hashtable</font><font>
class.<br>
</font></center>
<p>
The capacity argument to the constructors indicate the initial
capacity of the table and the load factor determines the point
at which the table should reorganise itself. Once the load factor
has been reached the table will allocate more space and reorganise
its contents to maintain efficiency. <br>

<p>
When using a <font FACE="Arial">Hashtable</font> the class
which is used to supply <font FACE="Arial">Key</font> values
must have <font FACE="Arial">hashCode()</font> and <font FACE="Arial">equals()</font>
actions defined. The <font FACE="Arial">Object</font> class,
from which all Java class are implicitly extended itself defines
primitive versions of these actions, but in most cases they should
be overloaded. <br>

<p>
The characteristics of a suitable <i><font FACE="Arial">hashCode()</font></i>
action are beyond the scope of this book, the default is to base
the code on the instance's memory address which is adequate, if
inefficient, for most situations. An <i><font FACE="Arial">equals()</font></i>
action should be implemented for developer supplied classes which
compares the appropriate attribute of the instances for equality.
For example, if an <i><font FACE="Arial">equals()</font></i>
action were to be developed for the <i><font FACE="Arial">Persons</font></i>
hierarchy it should decide that two instances were equal if they
both have the same e-mail address irrespective of the contents
of the other attributes. The default would be to decide equality
on the basis of the addresses of the objects so that two objects
are considered equal only if they are the same object. Fortunately
for the examples in this book the <font FACE="Arial">String</font>
class overloads the two actions with suitable implementations.
<br>
<br>

<p>
<hr>
<h2>
<ul>

<a HREF="chap13sum.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter13/chap13sum.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Summary of Chapter 13</a>.
<p>
<a HREF="chap13p4.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter13/chap13p4.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
13.4 Iterator classes</a>.
<p>
</ul>
</h2>
<hr>
</body>

</html>
&#26;