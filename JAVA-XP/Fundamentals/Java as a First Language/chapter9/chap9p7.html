<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>9.7 Exceptions in Java</title>

</head>

<body BGCOLOR="WHITE">

<h2>9.7 Exceptions in Java<br>
</h2>

<p>
This chapter has introduced the throwing and catching of exceptions
in Java in some considerable detail. These considerations, and
some aspects which have not been brought out in the examples,
will be summarised here.<br>

<p>
The Java exception class hierarchy, whose root class is <font FACE="Arial">java.lang.Exception</font>,
is divided into two groups of classes which are treated differently
by the Java language. Firstly there is the <font FACE="Arial">java.lang.RuntimeException</font>
class and all the classes which are derived from it; and secondly
all other classes descended from <font FACE="Arial">java.lang.Exception</font>.
To make the discussion which follows easier these will be referred
to as the <font FACE="Arial">Runtime </font>and<font FACE="Arial">
non- Runtime</font> exceptions. The essential difference between
them is that a <font FACE="Arial">Runtime </font>exception
does not have to be caught, whilst a <font FACE="Arial">non-
Runtime</font> must be.<br>

<p>
Any action which throws an instance of a <font FACE="Arial">non-
Runtime</font> exception must do one of two things: it must either
completely handle itself or it must indicate that the exception
may be propagated from the action by including a <b><font FACE="Arial">throws</font></b>
clause in the header of the action. For example the declaration
of the <i><font FACE="Arial">SimpleInput readLong</font></i>()
action from this chapter was as follows.<br>

<pre>
<font>	<b>protected static long</b> <i>readLong</i>() <b>throws</b> java.lang.IOException { 
<br>
</font>
</pre>

<p>
Any client of an action such as this, which indicates in its heading
that it might throw an exception, <u><b>must</b></u> catch it.
In practice this means that the call of the action must be enclosed
within a <b><font FACE="Arial">try/ catch</font></b> structure.
<br>

<p>
On the other hand, <font FACE="Arial">Runtime</font> exceptions
need not be handled within the action where they are thrown, nor
need they indicate in their header that they might propagate an
exception. For example the <i><font FACE="Arial">WarningCounter
count</font></i> and <i><font FACE="Arial">unCount</font></i>()
actions both had the possibility of throwing a <i><font FACE="Arial">CounterException</font></i>.
However, as this exception was declared as an extended <font FACE="Arial">Runtime</font>
exception there was no requirement for these actions to include
a <b><font FACE="Arial">throws</font></b> clause in their
header. However it is regarded as good style to do so and this
convention will be adopted for the rest of this book.<br>

<p>
If a called action does throw a <font FACE="Arial">Runtime</font>
exception and the calling environment does not catch it, the exception
will propagate to the place in the program where the calling environment
was itself called from. If this part of the program does not catch
it either, the exception will continue to propagate. Eventually
the exception will be propagated to the <i><font FACE="Arial">main</font></i>()
action of the application where, if it is not caught, it will
cause the program to finish early. <br>

<p>
So <font FACE="Arial">Runtime</font> exceptions are easier
for the developer to throw, as they do not have to include a <b><font FACE="Arial">throws</font></b>
clause in the action's header and are easier for developer to
work with as they do not have top provide a <b><font FACE="Arial">try/
catch</font></b> structure around the call. But precisely because
of this they are more dangerous as an uncaught exception may crash
the program.<br>

<p>
The purpose of throwing an exception is to signal to the calling
environment that something unexpected or unusual has happened.
The information indicating exactly what has caused it to be thrown
can be transmitted in the type of exception which is thrown. For
example the input routine in the <b><font FACE="Arial">try</font></b>
part of the <i><font FACE="Arial">SimpleInput getLong</font></i>()
action will throw a <i><font FACE="Arial">NumberFormatException</font></i>
if the user's input cannot be interpreted as an integer value
or an <i><font FACE="Arial">IOException</font></i> if an
end of file condition occurs. <br>

<p>
Alternatively the exception itself can encapsulate the reason
why the exception was thrown and the exception's class can provide
manifest values to support this. For example the <i><font FACE="Arial">OutputFormatException</font></i>
thrown by the <i><font FACE="Arial">OutputFormatter</font></i>
actions has an <i><font FACE="Arial">obtainReason</font></i>()
action which can be used to determine if the exception was thrown
because the base is invalid ( <i><font FACE="Arial">INVALID_BASE</font></i>)
or because the floating point number was too large or too small
( <i><font FACE="Arial">FP_TOO_LARGE</font></i>).<br>

<p>
Using either of these two techniques the <b><font FACE="Arial">catch</font></b>
part of a <b><font FACE="Arial">try/ catch</font></b> structure
can be divided into a number of different sections, each of which
will attempt to deal with different causes of the exception being
thrown. For example this fragment illustrates how to handle different
errors with different exception types. <br>

<pre>
<font>	<b>try</b> { 
	   // Do something which might throw different exceptions
	   // e.g. the input routine from </font><i>SimpleInput getLong</i><font FACE="Courier New">().
	} <b>catch</b> ( java.io.IOException <i>exception</i>) { 
	   // Handle io errors here.
	} <b>catch</b> ( java.io.NumberFormatException <i>exception</i>) { 
	   // Handle invalid floating point values here.
	} // End try/ catch.<br>
</font>
</pre>

<p>
Whereas this fragment illustrates how to handle different errors
with the same type of exception.<br>

<pre>
<font>	<b>try</b> { 
	   // Do something which might throw an<i> OutputFormatException</i>.
	} <b>catch</b> ( <i>OutputFormatException exception</i>) { 
	   <b>switch</b> (<i>exception.obtainReason()</i> ){ 
	      <b>case</b> <i>OutputFormatException.INVALID_BASE</i>:
	         // Handle invalid bases here.
	         <b>break</b>;
	      <b>case</b> <i>OutputFormatException.FP_TOO_LARGE</i>:
	         // Handle invalid floating point values here.
	         <b>break</b>;
	   } // End switch.
	} // End try/ catch.<br>
</font>
</pre>

<p>
In this second example the <b><font FACE="Arial">catch</font></b>
clause will only trap exceptions of the <i><font FACE="Arial">OutoutFormatException</font></i>
class. Any exceptions of any other class which are thrown in the
try part of the structure will not be handled and will be propagated
upward to the next enclosing level, looking for a handler. <br>

<p>
To avoid this it is possible, though generally not advisable,
to catch an exception in a general manner. For example the following
catch clause will <b><font FACE="Arial">catch</font></b>
all <font FACE="Arial">Runtime</font> exceptions. <br>

<pre>
<font>	} <b>catch</b> ( java.lang.RuntimeException <i>exception</i>) { 
<br>
</font>
</pre>

<p>
And the following will catch all exceptions<br>

<pre>
<font>	 } <b>catch</b> ( java.lang.Exception <i>exception</i>) {
<br>
</font>
</pre>

<p>
Thus there are a bewildering number of considerations and possibilities
concerned with the throwing and catching of exceptions, of which
this is only an introduction. For the first programs being produced
by a novice developer the intention is to produce an initial confidence
and competence in software development and the throwing and handling
of exceptions can be largely ignored. However for more realistic
programs, and especially for production quality programs, these
considerations are essential. <br>

<p>
The design of any action should not only consider what it will
do and how it will do it, but should also consider what might
go wrong and how it will be handled. As usual there are many more
things that can cause a system to go wrong than to help it go
right. The skills involved ion recognising these possibilities
and in designing and implementing an appropriate strategy for
dealing with the them can only emerge from practical experience
and considered reflection.<br>
<br>

<p>
<hr>
<h2>
<ul>
<a HREF="chap9sum.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter9/chap9sum.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Summary of Chapter 9</a>.
<p>
<a HREF="chap9p6.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter9/chap9p6.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
9.6 The <i>OutputFormatter</i> class <i>formatDouble</i> action</a>.
</ul>
</h2>
<hr>
</body>

</html>
&#26;