<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>11.6 Comparison of methods and techniques</title>

</head>

<body BGCOLOR="WHITE">

<h2>11.6 Comparison of methods and techniques<br>
</h2>

<p>
The contents of this chapter provide a partial test rationale
and test plan for the testing of the <i><font SIZE="2" FACE="Arial">JulianDate</font></i>
hierrachy. It should be clear from this that the testing of a
software artefact is every bit as complex, if not more complex,
than its production. What is perhaps not as clear from this chapter
is that processes of designing tests are not as clear cut as the
processes of software design and testing. A good test is one which
has a high probability of detecting a fault and a good test designer
is one who can produce such tests. The techniques introduced in
this chapter should be regarded as the starting points for the
production of test plans: additional tests will be required in
almost all cases.<br>

<p>
The validity of the testing process is determined by the quality
of the rationale. The rationale includes the black box diagrams,
range diagrams, test cases, test plans, flowgraphs and lists of
paths; but it should also contain a written commentary justifying
why the successful passing of the tests provides sufficient confidence
in the correctness of the software. A mechanistic application
of the rationales is unlikely to produce sufficient confidence
in the software and the imaginative application of testing principles
is required in all cases.<br>

<p>
The extent of the confidence required will depend upon the purpose
of the software and upon the consequences of software failure.
For a trivial program implementing a small, possibly temporary,
part of a much larger software system where the consequences of
failure are fairly negligible, then the test rationale may be
minimal. For a program which performs a 'mission&nbsp;critical'
task for the organisation using it the rationale must be sufficiently
thorough. Some software systems are so critical, particularly
those involving a risk to human life, that testing of the program
should consist of a validation process which attempts to use mathematical
reasoning to provide an almost absolute proof of the program's
correctness. Such proofs, known as <i><b>formal&nbsp;methods</b></i>,
are at the moment not very well known and require such extensive,
and thus expensive, skills that they are considered beyond the
scope of this book.<br>

<p>
Testing is essential to ensure the quality of the software product
but in itself cannot introduce quality into the product. To ensure
that the product has quality attributes, and thus has a high possibility
of passing its tests with minimal effort, all stages of the production
process are rigorously carried out. This implies that the developer
must have a good understanding of the specification, produce a
validated design and implement the design rigorously. Although
testing is a time consuming and expensive process, the resulting
quality assurance will pay off in the life span of the product.
In the case of the <i><font SIZE="2" FACE="Arial">JulianDate</font></i>
hierarchy if the design, production and testing are carried out
rigorously, then the class can subsequently be used by a large
number of client programs with a high probability that no further
development or maintenance will be required.<br>

<p>
Of the four black box techniques: parallel, inverse, relational
and composite the only certainty is that the parallel method can
always be applied to all programs. However if there is a choice
of methods, then the methods should be considered in the sequence
<br>
<ul>
<p>
 most favoured  -&gt; inverse
<p>
<ul><ul>
    composite
<p>
    relational
<p>
</ul></ul>
 least favoured  -&gt; parallel<br>
</ul>
<p>
The consideration should include not only the applicability of
the method but also the ease and possibility of performing the
composite or relational comparisons which will validate the outputs.
Usually a combination of the methods will be used, as illustrated
above.<br>

<p>
The possibility of automated testing should always be considered,
even in the case of interactive programs as described in section
11.4. The advantages of automated testing are that a larger number
of tests can be applied in a shorter period of time with greater
accuracy. It also allows the tests to be repeated either after
the program has been amended when it has failed one of the tests,
or when the program has been changed during maintenance. The disadvantage
of automated testing is that a computer program to test the program
under test has to be designed and implemented. This program itself
will require testing, before its result which is increased confidence
in the artefact under test, can be relied upon. This in itself
is not an overwhelming problem as the effort of testing the test
harness program will be repaid in the greater number of tests
and the greater ease of testing the artefact and can be used to
retest it after maintenance.<br>

<p>
Finally the possibility of white box testing should always be
borne in mind. White box methods are much more expensive and fragile
than black box methods. A black box rationale can be derived from
the artefact's specification and will not change unless the specification
changes. White box rationales depend upon the structure of the
source code which implements the artefact and so any changes to
the code will require a new rationale to be prepared. Again a
cost benefit analysis could be used to decide is white box testing
is appropriate. <br>


<p>
<hr>
<h2>
<ul>

<a HREF="chap11sum.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter11/chap11sum.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Summary of Chapter 11</a>.
<p>
<a HREF="chap11p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter11/chap11p5.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
11.5 White box considerations</a>.
<p>
</ul>
</h2>
<hr>
</body>

</html>
&#26;