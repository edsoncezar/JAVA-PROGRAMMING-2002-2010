<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>Chapter 14 Developer Supplied Data Structures</title>

</head>

<body BGCOLOR="WHITE">

<h1>Chapter 14 Developer Supplied Data Structures<br>
</h1>

<p>
The data structures introduced in the previous chapter had two
major problems which might limit their use, or make their use
dangerous. Firstly, it was possible for an object of any class
to be stored in the structure at any time. For example, although
the <i>ContactList</i> application
was only supposed to store instances from the <i>Persons</i>
package this was not enforced. It would be possible for a maintenance
developer, or indeed the original developer, to avoid this limitation
and store in the list instances of any class. This may not seem
a sensible thing to do but the errors which creep into programs
rarely have a sensible cause. Increased security can be enforced
by ensuring that only instances of a specific class, which includes
extended instances of the class, can be stored in a structure.


<p>
The second limitation concerns the pattern by which the instances
are added to and retrieved from the structure. In the first version
of the <i>ContactList</i> application,
using a Vector, new elements
were added to the end of the list and elements could be removed
from any location in the list. In the second version, using a
Hashtable, there was no consideration
of ordering in the list all that was important was the key value
of the instance being added. Many applications require that the
elements which are stored in a list are added, maintained and
retrieved in a particular sequence. Examples include <i><b>queues</b></i>
where elements can only be added to the end of the structure and
removed from the front, <i><b>stacks</b></i> where elements can
only be added and retrieved from the front and <i><b>ordered&nbsp;lists</b></i>
where the elements are maintained in a sequence determined by
their keys.<br>

<p>
These structures could be implemented by extending the pre-supplied
Vector and Hashtable
classes, as was done in the previous chapter. However this would
add a potential insecurity into the implementation. For example
if a Vector was extended to implement
a queue it would be expected that a developer would only add elements
at the end and remove elements from the front. However, as an
extended Vector the queue structure
would inherit all the other Vector
operations which allow elements to be added or removed in the
middle of the list. In order to provide a secure implementation
of a queue, or stack, or ordered list, it is necessary to encapsulate
an instance of a <i>Vector</i>,
or array, or <i>Hashtable</i>,
within the class and only export suitable operations from it.
<br>

<p>
The previous chapter also briefly introduced the use of Interfaces.
An Interface is a mechanism which
allows the statement of <i><b>what</b></i> actions a class supplies
to be more clearly separated from the details of <i><b>how</b></i>
the class implements those actions. The specification of what
a class does is implicit in its class diagram and the action sigantures
from its implementation. The specification of how a class does
what it does is contained within the implementation of its actions.
It is possible, and in many cases desirable, for a number of different
<i><b>how</b></i>s to be associated with a single <i><b>what</b></i>.
<br>

<p>
For example the Enumeration actions
specify <i><b>what</b></i> actions can be used to iterate through
the contents of a structure. The different implementations of
the Enumeration actions in the
Vector and Hashtable
classes state <i><b>how</b></i> these actions are implemented
in ways appropriate to the nature of the structure. For a user
of an Enumeration class, details
of <i><b>how</b></i> the actions are implemented are irrelevant,
all that is necessary is to know <i><b>what</b></i> actions are
supplied. In the next chapter this will be illustrated further
when a set of Enumeration actions
are introduced for a developer supplied data structure. <br>




<p>
<hr>
<h2>
<ul>
<a HREF="chap14p1.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/chap14p1.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
14.1 The abstract <i>UnorderedList</i> class</a>.
<p>
<a HREF="..\jflcontents.html" tppabs="http://www.scism.sbu.ac.uk/jfl/jflcontents.html"><img SRC="..\up.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/up.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="50">
JFL Contents</a>.
</ul>
</h2>
<hr>

</body>

</html>
