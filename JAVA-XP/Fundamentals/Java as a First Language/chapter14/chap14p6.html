<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>14.6 The OrderedList remaining actions</title>

</head>

<body BGCOLOR="WHITE">

<h2>14.6 The <i>OrderedList</i> remaining actions<br>
</h2>

<p>
The addition of a new element into an existing list, as described
above, used a <i><b>sequential search</b></i> to locate the appropriate
position for the new element to be inserted. When using an ordered
structure it is possible to use a more elegant technique, known
as a <i><b>binary chop</b></i> <i><b>search</b></i>, which is
more efficient for large structures. The implementation of the
<i>OrderedList</i> class has
a private action called <i>findKey()</i>
whose task is to find the location within the list of the key
supplied, or indicate if it is not present. The design of this
action is as follows. <br>

<p>
<center><img SRC="c14p6i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/c14p6i1.gif" WIDTH="699" HEIGHT="570">
</center>
<p>
The essence of this design is to examine a range of the list for
the key being sought. Initially the range consists of the entire
list and the element in the middle of the list is the first to
be checked. If this is the element being sought then the loop
will terminate, otherwise the range of the search is restricted.
As the list is ordered, if the key of the element being examined
is greater than the key being sought then the element, if it is
present, must be in the lower part of the range; otherwise it
must be in the higher part of the range. <br>

<p>
Having limited the range of the search to the lower or upper part
of the current range, the loop iterates restricting the search
to the appropriate part of the list. This will continue until
the element being sought is located in the middle of the range,
or the range has been restricted to a single element and it is
not the element being sought.<br>

<p>
For example consider the list shown in Figure 14.7. <br>

<p>
<center><img SRC="c14p6i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/c14p6i2.gif" WIDTH="448" HEIGHT="216">
</center>
<p>
A search for <i>dull@hopeless.com</i> would start by considering
the address in the middle of the table, <i>geek@nowhere.edu</i>.
This is not the address being sought, but it is alphabetically
greater than it, so if <i>dull@hopeless.com</i> is in the table
it must be somewhere below location 2 in the list. The second
iteration would restrict the search to this part of the list and
might examine the address at location 0. This, also, is not the
address being sought but is alphabetically lower than it. So on
the third iteration the search will be restricted to the part
of the current range above location 0 and below location 2. This
is a range consisting of a single element, which is the one sought,
so the search will terminate indicating that <i>dull@hopeless.com</i>
is at location 1 in the table.<br>

<p>
Alternatively if the address <i>whoisit@whereisit.org</i> were
being sought, the first iteration would examine location 2 and
decide to restrict the search to the range 3 to 4. On the second
iteration location 3 would be examined and the search restricted
to the range 4 to 4 on the third iteration. As this is not the
element sought and the range has only one element in it the search
can conclude that the address is not contained in the list. <br>

<p>
The advantage of a binary chop search over a sequential search
should now be obvious. A sequential search may have to examine
every entry in the list to conclude that the element being sought
is, or is not, present. A binary chop search will be able to reach
the same conclusion by examining far fewer elements. The implementation
of this design is as follows. <br>

<pre>
0097     <b>private int</b> <i>findKey</i>( <i>Orderable keyToFind</i>){
0098  
0099     <i>Orderable thisKeyValue</i>;
0100     <b>int</b>       <i>lowerBound     </i>= 0;
0101     <b>int</b>       <i>upperBound     </i>= <i>theList.size</i>();
0102     <b>int</b>       <i>thisLocation   </i>= (<i>upperBound</i> + <i>lowerBound</i>) /2;
0103     <b>int</b>       <i>nextLocation;</i>
0104     <b>boolean</b>   <i>found          </i>= <b>false</b>;
0105     <b>boolean</b>   <i>exhausted      </i>= <b>false</b>;
0106     
0107        <b>while</b> ( (!<i>found</i>) &amp;&amp; (!<i>exhausted</i>) ){ 
0108           <i>thisKeyValue</i>   = ( (<i>Keyable</i>) 
0109                               <i>theList.elementAt</i>( <i>thisLocation</i>)).
0110                               <i>keyValueIs</i>();
0111           <b>if</b> ( <i>thisKeyValue.keyIsEqualTo</i>( <i>keyToFind</i>)) { 
0112               <i>found </i>= <b>true</b>;
0113           } <b>else</b> { 
0114               <b>if</b> ( <i>thisKeyValue.keyIsGreaterThan</i>( <i>keyToFind</i>))  {               
0115                  <i>upperBound</i> = <i>thisLocation</i> -1; 
0116              } <b>else</b> {             
0117                  <i>lowerBound</i> = <i>thisLocation</i> +1;
0118              } // End if.   
0119              <i>nextLocation </i>= (<i>upperBound</i> + <i>lowerBound</i>) /2;         
0120              <i>exhausted    </i>= (<i>thisLocation </i>== <i>nextLocation</i>);            
0121              <i>thisLocation </i>= <i>nextLocation</i>;  
0122          } // End if.
0123        } // End while.
0124     
0125        <b>if</b> ( <i>found</i>) { 
0126           <b>return</b> <i>thisLocation</i>;
0127        } else { 
0128           <b>return</b> <i>KEY_NOT_PRESENT</i>;
0129        } // End if.         
0130     } // End <i>findKey</i>. <br>

</pre>

<p>
The implementation of the decision to terminate the search when
the list has been exhaustively checked, on lines 0119 and 0120,
is implemented as a check to make sure that the next location
to be checked is not the same as the last location checked. It
was implemented in this way to avoid obscure problems with <b>int</b>eger
arithmetic.  <br>

<p>
The remaining <i>OrderedList</i>
actions which are concerned with maintaining the list can now
be implemented by taking advantage of the <i>findKey()</i>
action, as follows. <br>

<pre>
0066     <b>public</b> <i>Keyable obtain</i>( <i>Orderable keyToObtain</i>) { 
0067     
0068     <b>int</b> <i>location </i>= <i>findKey</i>( <i>keyToObtain</i>);
0069     
0070        <b>if</b> ( <i>location</i> == <i>KEY_NOT_PRESENT</i>) { 
0071           <b>throw new</b> NoSuchElementException();
0072        } <b>else</b> { 
0073           <b>return</b> ((<i>Keyable</i>) <i>theList.elementAt</i>( <i>location</i>)).<i>copy</i>();
0074        } // End if.
0075     } // End <i>obtain</i>.  
0076     
0077  
0078     <b>public</b> <i>Keyable remove</i>( <i>Orderable keyToRemove</i>) { 
0079  
0080     <b>int</b>     <i>location</i> = <i>findKey</i>( <i>keyToRemove</i>);
0081     <i>Keyable hold</i>;
0082     
0083        <b>if</b> ( <i>location</i> == <i>KEY_NOT_PRESENT</i>) { 
0084           <b>throw  new</b> NoSuchElementException();
0085        } <b>else</b> { 
0086           <i>hold </i>=  ((<i>Keyable</i>) <i>theList.elementAt</i>( <i>location</i>)); 
0087           <i>theList.removeElementAt</i>( <i>location</i>);
0088           <b>return</b> <i>hold</i>;           
0089        } // End if.     
0090     } // End <i>remove</i>.  
0091     
0092     <b>public  boolean</b> <i>isPresent</i>( <i>Orderable keyToCheck</i>){ 
0093        <b>return</b> (<b>this</b>.<i>findKey</i>( <i>keyToCheck</i>)) != <i>KEY_NOT_PRESENT</i>;
0094     } // End <i>isPresent</i>.    <br>

</pre>

<p>
For example, the <i>remove()</i>
action calls the <i>findKey()</i>
action and stores the result in a local variable called <i>location</i>.
If this value is equal to the manifest value <i>KEY_NOT_PRESENT</i>
a<i> </i>NoSuchElementException
is thrown. Otherwise the element is retrieved from the Vector
and held, whilst it is removed, before the held element is returned.
The <i>obtain()</i> action is
virtually identical but, on line 0073, returns a <i>copy()</i>
of the element stored at <i>location</i>
in <i>theList</i>. The <i>elementAt()</i>
action returns an Object value
which has to be cast to a Keyable
value before the <i>copy()</i>
action can be applied to it, requiring the brackets as shown.
The remaining <i>OrderedList</i>
actions, with the exception of the <i>toString()</i>
action are implemented as calls of the equivalent <i>theList</i>
Vector action.<br>

<p>
<pre>
0133     <b>public</b> Enumeration <i>elements</i>() {    
0134       <b>return</b> <i>theList</i>.elements();
0135     } // End <i>elements</i>.
0136     
0137     
0138     <b>public int</b> <i>size</i>() { 
0139        <b>return</b> <i>theList</i>.size();
0140     } // End <i>size</i>.
0141     
0142     
0143     <b>public boolean</b> <i>isEmpty</i>() { 
0144        <b>return</b> <i>theList</i>.isEmpty();
0145     } // End <i>isEmpty</i>.
0146     
0147     
0148     <b>public</b> String <i>toString</i>(){ 
0149  
0150     <b>int</b>          <i>thisElement</i> = 0;
0151     Object       <i>fromList</i>;
0152     StringBuffer <i>buffer</i>     = <b>new</b> StringBuffer();
0153     Enumeration  <i>contents</i>   = <i>theList</i>.elements();
0154     
0155        <b>while</b>( <i>contents</i>.hasMoreElements() ) { 
0156           <i>fromList</i> = <i>contents</i>.nextElement();      
0157           <i>thisElement</i>++;
0158           <i>buffer</i>.append( <i>thisElement</i> + &quot;  &quot; + <i>fromList</i> + &quot;\n&quot;);       
0159        } // End while;
0160        <b>return</b> <i>buffer</i>.toString();   
0161     } // End <i>toString</i>.    <br>

</pre>

<p>
The <i>toString()</i> action
uses an Enumeration object to
iterate through the Vector and
store each element, preceded by a sequence number, in a <i>StringBuffer</i>
which subsequently has its toString()
action used to return the entire String.
The completion of the <i>OrderedList</i>
demonstration test harness will be left as an end of chapter exercise.
<br>

<p>
There is one possible insecurity in this generic implementation.
The <i>Keyable</i> element is
checked to make sure that it is of an acceptable class before
it is stored in the list, and so it need not be tested when it
is recovered from the list. However, no check is made upon the
<i>Orderable</i> arguments. At
the time of compilation Java will make sure that the actual arguments
are of an <i>Orderable</i> class,
but cannot check that they are of the precise <i>Orderable</i>
class which should be used with the stored <i>Keyable</i>
class. <br>

<p>
For example, using an example introduced above, the <i>LibraryList
Orderable</i> class is <i>AcquisitionNumber</i>.
As the <i>AcquisitionNumber</i>
class is an <i>Orderable</i>
class Java will allow it to be passed as an argument to an <i>OrderedList</i>
which has been constructed to store <i>Persons</i>.
However when an attempt was made to compare an <i>AcquisitionNumber</i>
with an <i>EmailAddress</i>,
the Java run time system would be unable to find a suitable action
and will throw an exception. <br>

<p>
Although the facilities which have been introduced in this chapter
have been described as generic, they are really only a partial
and rather cumbersome attempt to provide such facilities. Some
languages, for example Ada, supply a true generic facility which
allows examples such as this to be implemented much more easily
and powerfully. However the advantages of using generic data structure
merits the inclusion of the facilities in this chapter.<br>
<br>



<p>
<hr>
<h2>
<ul>

<p>
<a HREF="chap14sum.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/chap14sum.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Summary of Chapter 14</a>.
<p>
<a HREF="chap14p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/chap14p5.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
14.5 The <i>OrderedList</i> constructor and <i>add()</i> actions</a>.
<p>
</ul>
</h2>
<hr>
</body>

</html>
