<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>14.4 The Generics interfaces</title>

</head>

<body BGCOLOR="WHITE">

<h2>14.4 The <i>Generics</i> interfaces<br>
</h2>

<p>
A sibling class of the <i>UnorderedList</i>
class, the <i>OrderedList</i>
class, will be introduced in this part of the chapter. An ordered
list maintains the elements in its structure according to some
well defined key value. For example using the <i>Persons</i>
package the entries in the list might have to be held in an alphabetic
ordering according to their e-mail addresses. <br>

<p>
It would be possible to produce a specific <i>OrderedContactList</i>
class which maintained a list of personal contacts ordered by
their e-mail addresses, but this structure could not be reused
to maintain, for example, a list of <i>LibraryBooks</i>
ordered by their <i>AquisitionNumbers</i>
or a list of Vehicles ordered by their <i>RegistrationNumbers</i>.
This chapter is concerned with providing <i><b>generic</b></i>
data structures rather than particular solutions and so a general
approach will be presented. <br>

<p>
In order for a generic <i>OrderedList</i>
class to be produced there must be a limitation upon the classes
which can be used to instantiate it. This limitation is that the
class <u><b>must</b></u> supply two actions. The first, <i>keyValueIs()</i>,
returns an Object which itself
must have relational actions, that can be used to decide upon
the ordering of the elements. The second required action is <i>copy()</i>
which returns a copy of the instance. <br>

<p>
The Java mechanism to guarantee that an action is supplied by
a class is the use of <i><b>interfaces</b></i>. An Interface
declaration states the signatures of the actions which a class
declaring itself to be of that Interface
<u><b>must</b></u> supply. In the example being developed the
classes which are intended to be stored in an <i>OrderedList</i>
must supply an action called <i>keyValueIs()</i>
which returns an Object of the
class <i>Orderable</i> and an
action called <i>copy()</i> which
must return an object of the class <i>Keyable</i>.
This is stated in the <i>Keyable</i>
interface declaration, as follows. <br>

<pre>
0001 // Filename <i>Keyable.java</i>.
0002 // Interface declaration for classes which are 
0003 // intended to be used in <i>OrderedStructures</i>.
0004
0005 <b>package</b> <i>Generics</i>;
0006 
0007 <b>import</b>  <i>Generics.Orderable</i>;
0008
0009 <b>public interface</b> <i>Keyable</i> { 
0010
0011    <b>public</b> <i>Orderable</i> <i>keyValueIs</i>();
0012
0013    <b>public</b> <i>Keyable</i> <i>copy</i>();
0014
0015 } // End interface <i>Keyable</i>.<br>

</pre>

<p>
The declaration of an Interface
is somewhat similar to the declaration of a class, but the action
signatures only have to be stated and do not have to have to be
defined. The <i>Persons EmailPerson</i>
class declaration states that it implements the <i>Keyable</i>
Interface in its class declaration,
as follows. <br>

<p>
<pre>
0011 import <i>Generics.Orderable</i>;
0012 import java.io.*; 
0013
0014 <b>abstract class</b> <i>EmailPerson</i> <b>extends</b>    Object 
0015                            <b>implements</b> <i>Keyable</i> {
<br>
</pre>

<p>
A class declaration can only <b>extend</b>
a single parent class but can implement any number of Interfaces.
In this example the class promises that it will declare suitable
<i>keyValueIs()</i> and <i>copy()</i>
actions and the Java compiler will make sure that it does. In
return Java will allow an instance of the <i>EmailPerson</i>
class, or of any class extended from it, to be used where the
formal argument states that an instance of the <i>Keyable</i>
class is expected. <br>

<p>
The implementation of the <i>keyValueIs()</i>
action in the definition of the <i>EmailPerson</i>
class is as follows. <br>

<p>
<pre>
0050    <b>public</b> <i>Orderable</i> <i>keyValueIs</i>(){
0051       <b>return this.</b><i>theirEmail</i>;
0052    } // End <i>keyValueIs<br>
</i>
</pre>

<p>
The <i>theirEmail</i> data attribute
of the <i>EmailPerson</i> class
is of the <i>EmailAddress</i>
class which itself implements the <i>Orderable</i>
interface.<br>

<p>
<pre>
0013 <b>package</b> <i>Persons</i>;
0014
0015 <b>import</b> <i>Generics.Orderable</i>;
0016 <b>import</b> java.io.*;
0017 
0018 <b>public class</b> <i>EmailAddress</i> <b>implements</b> <i>Orderable</i> {
<br>

</pre>

<p>
The <i>Orderable</i> interface
promises that a class which implements its interface will supply
actions which can be used to decide upon the ordering of instances
of the class.<br>

<p>
<pre>
0001  // Filename <i>Orderable.java</i>.
0002  // <i>Orderable</i> interface definition, allowing
0003  // two objects to be compared for a defined relationship.
0004  // Required for the <i>OrderedStructure</i> generic class.
0005  //
0006  // Written for JFL book Chapter 14.
0007  // Fintan Culwin, V 0.1, August 1997.
0008  
0009  <b>package</b> <i>Generics</i>;
0010  
0011  <b>public interface</b> <i>Orderable</i> { 
0012  
0013     <b>public boolean</b> <i>keyIsEqualTo</i>( <i>Orderable other</i>);
0014     
0015     <b>public boolean</b> <i>keyIsGreaterThan</i>( <i>Orderable other</i>);
0016     
0017     <b>public boolean</b> <i>keyIsLessThan</i>( <i>Orderable other</i>);
0018  
0019  } // End interface <i>Orderable</i>.<br>

</pre>

<p>
To summarise, a class which is intended to be used as the element
type of an <i>OrderedList</i>
must supply actions called <i>copy()</i>
and <i>keyValueIs()</i>. The
<i>keyValueIs()</i> action must
return an instance of a class which itself must supply actions
to determine the ordering of instances of this class. These requirements
are enforced by the use of the <i>Keyable</i>
and <i>Orderable</i> interface
declarations. <br>

<p>
The <i>OrderedList</i> class
can now have its actions defined solely in terms of the <i>Orderable</i>
and <i>Keyable</i> classes; which
will ensure that, upon instantiation, it will be able to accept
as elements any <i>Keyable</i>
class. The most elegant way to do this is to declare an <i>OrderedStructure</i>
interface and then declare the <i>OrderedList</i>
class as implementing this interface. The <i>OrderedStructure</i>
Interface definition is as follows.
<br>

<p>
<pre>
0001  // Filename <i>OrderedStructure.java</i>.
0002  // Interface for a set of ordered list actions,
0003  // to be implemented by a number of different data 
0004  // structures.
0005  //
0006  // Written for JFL book, chapter 14.
0007  // Fintan Culwin, v0.1, August 1997.
0008  
0009  <b>package</b> <i>Generics</i>;
0010           
0011  <b>import</b> <i>Generics.Orderable</i>; 
0012  <b>import</b> <i>Generics.Keyable</i>;                             
0013  <b>import</b> java.util.Enumeration;
0014  
0015  <b>public interface</b> <i>OrderedStructure</i> { 
0016  
0017     <b>public void</b> <i>add</i>( <i>Keyable toAdd</i>);
0018     
0019     <b>public</b>  <i>Keyable remove</i>( <i>Orderable keyToRemove</i>);
0020     
0021     <b>public</b>  <i>Keyable obtain</i>( <i>Orderable keyToObtain</i>); 
0022     
0023     <b>public</b>  <b>boolean</b> <i>isPresent</i>( <i>Orderable keyToCheck</i>); 
0024  
0025     <b>public</b>  <b>boolean</b> <i>isEmpty</i>();
0026     
0027     <b>public</b>  <b>int</b> <i>size</i>();
0028     
0029     <b>public</b>  Enumeration <i>elements</i>();
0030  
0031  } // End interface <i>OrderedStructure</i>.<br>

</pre>

<p>
As this interface only states the types of the arguments to the
actions as <i>Keyable</i> or
<i>Orderable</i>, and the <i>OrderedList</i>
class must implement these actions in order to implement this
interface, an <i>OrderedList</i>
list will then be capable of instantiation to store any <i>Keyable</i>
elements.<br>

<p>
Before considering the implementation and demonstration of the
<i>OrderedList</i> class the
nature of the <i>copy()</i> action
needs to be clarified. From the earliest chapter the use of the
<b>new</b> reserved word to create
and construct an instance of a class has been used. This is the
only way in which an instance of a class can be created. However
the identifier which is used in conjunction with the new term
merely <i><b>designates</b></i> the instance, it is not the instance
itself. <br>

<p>
The implication of this is that when the value of a <i>designator</i>
is assigned to another identifier they both then designate the
same instance. This can be illustrated in the following fragment.
<br>

<hr>

<pre>
<ul>
	WarningCounter aCounter       = <b>new</b> WarningCounter();
	WarningCounter theSameCounter = aCounter;

	aCounter.count();
	
	System.out.println( &quot;aCounter &#133; &quot; + 
	                     aCounter.hashCode() + 
	                    &quot; has counted &quot; + 
                     aCounter.numberCountedIs());

	System.out.println( &quot;theSameCounter &#133; &quot; + 
	                    theSameCounter.hashCode() + 
	                    &quot; has counted &quot; + 
                    theSameCounter.numberCountedIs());
</ul>
</pre>

<hr>

<p>
Only one instance of the <i>WarningCounter</i>
class is constructed but both <i>aCounter</i>
and <i>theSameCounter</i> designate
it. This is illustrated in the output produced by this fragment,
which might be something like what follows. <br>

<p>
<hr>

<pre>
<ul>
	aCounter &amp; 4357648 has counted 1
	theSameCounter &amp; 4357648 has counted 1
</ul>
</pre>

<hr>

<p>
The value output by the <i>hashCode()</i>
action (&nbsp;4357648&nbsp;) indicates that both identifiers designate
the same instance and so an action called by either of them may
change the state of the instance and be reflected in the behaviour
of the other. <br>

<p>
The significance of this consideration is that the Vector
and Hashtable structures from
the previous chapters and the <i>Queue</i>
and <i>Stack</i> structures above
have only stored copies of the designators and not copies of the
objects. So if an instance is stored within a structure it can
be changed whilst it is within the structure if a designator still
references it. So the state of the object retrieved from the structure
may differ from its state when it was stored in the structure.
This is sometimes the desired behaviour, but on other occasions
the state of an object retrieved from a structure is required
to be unchanged from that when it was stored. This behaviour will
be accomplished in the following data structures by copying the
instance into the structure when it is stored and copying it out
again when it is retrieved. <br>

<p>
A class instance continues to exist as long as there is something
to designate it. When the last designator of an instance is reassigned
to designate another instance or, if it is a local variable, is
destroyed when the action terminates; the instance can no longer
be accessed. Java will become aware of this and will ensure that,
in due course, it is destroyed and its resources reclaimed for
use; a process known as <i><b>garbage collection</b></i>. It is
possible for the Object <i>finalize()</i>
action to be overridden in a class declaration if there are any
steps which should be taken before an instance is destroyed. 
<br>
<br>

<p>
<hr>
<h2>
<ul>
<a HREF="keyable.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/Keyable.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>Keyable.java</i> interface source code</a>.
<p>
<a HREF="orderable.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/Orderable.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>Orderable.java</i> interface source code</a>.
<p>
<a HREF="orderedstructure.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/OrderedStructure.java"><img SRC="..\list.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/list.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="40" HEIGHT="35">
<i>OrderedStructure.java</i> source code</a>.


<p>
<a HREF="chap14p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/chap14p5.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
14.5 The <i>OrderedList</i> constructor and <i>add()</i> actions</a>.
<p>
<a HREF="chap14p3.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter14/chap14p3.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
14.3 The <i>Stack</i> class</a>.
<p>
</ul>
</h2>
<hr>
</body>

</html>
