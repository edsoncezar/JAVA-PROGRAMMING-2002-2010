<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>16.4 The remaining actions, apart from main()</title>

</head>

<body BGCOLOR="WHITE">

<h2>16.4 The remaining actions, apart from <i>main()</i>
</h2>

<p>
The <i>updateDisplays()</i> action,
as called at the end of the <i>init()</i>
action, has to use the appropriate enquiry actions of <i>RoomMonitor</i>
encapsulated instance to obtain the number of people currently
in the room, the maximum number of people ever in the room and
the total number of people who have entered the room. Having obtained
these values it has to format them as required and then pass them
onto the display Labels to become
visible to the user. The implementation of this action is as follows.
<br>

<pre>
0065     <b>private void</b> <i>updateDisplays</i>(){
0066  
0067     <b>int</b> <i>theCount</i>   = <i>theMonitor.numberCurrentlyInRoomIs</i>();
0068     <b>int</b> <i>maxCount</i>   = <i>theMonitor.maxEverInRoomIs</i>();
0069     <b>int</b> <i>totalCount</i> = <i>theMonitor.totalNumberEnteredIs</i>();
0070     
0071        <i>countDisplay.</i>setText( 
0072                     <i>OutputFormatter.formatLong</i>( <i>theCount</i>,
0073                     4, <b>true</b>, <i>OutputFormatter.DECIMAL</i>));
0074        <i>maxDisplay.</i>setText( 
0075                     <i>OutputFormatter.formatLong</i>( <i>maxCount</i>,
0076                     4, <b>true</b>, <i>OutputFormatter.DECIMAL</i>));
0077        <i>totalDisplay.</i>setText( 
0078                     <i>OutputFormatter.formatLong</i>( <i>totalCount</i>,
0079                     4, <b>true</b>, <i>OutputFormatter.DECIMAL</i>));
0080      } // End <i>updateDisplays</i>.<br>

</pre>

<p>
Taking the maximum number of people as an example. The <i>maxEverInRoomIs()</i>
action of <i>theMonitor</i> is
called on line 0068 and the value it returns is stored in the
local variable <i>maxCount</i>.
On lines 0074 to 0076 the <i>setText()</i>
action of the <i>maxDisplay</i>
Label instance is called passing
to it the String returned when
<i>theCount</i> is formatted
in decimal, to a width of 4 characters, with leading zeros, by
the class wide <i>OutputFormatter formatLong()</i>
action. The effect of calling the setText()
action is for the Label to change
the text which it is displaying, possibly instigating a new round
of geometry negotiations. The overall effect of the steps described
is for the <i>maxDisplay</i>
Label to show to the user the
value of the maximum number of people ever in the room as reported
by <i>theMonitor</i> instance.
The overall effect of the <i>updateDisplays()</i>
action is to show all three data attributes of <i>theMonitor</i>
to the user.  <br>

<p>
The other action called by the <i>init()</i>
action before it finishes is the <i>resetState()</i>
action whose implementation is as follows. <br>

<pre>
0123      <b>private int</b> <i>resetState</i>(){
0124         <i>theMonitor.reset</i>();
0125         <i>enterButton.enable</i>();
0126         <i>resetButton.disable</i>();
0127         <i>leaveButton.disable</i>();
0128         <b>return</b> RESET_STATE;
0129      } // End <i>resetState</i>.<br>

</pre>

<p>
The action commences by calling <i>theMonitor</i>'s
reset action to ensure that it is in its default state. Every
component inherits from the Component
class an enable() and disable()
action. An enabled component
is capable of interacting with the user in whatever way is appropriate.
A disabled component is prevented
from doing so and this is indicated by the AWT by presenting the
component in a greyed out manner. The effect of this action is
that only the <i>enterButton</i>
is enabled and this is confirmed by the greying of the two other
buttons in Figure 16.8. The action returns a manifest value indicating
the state so that the <i>currentState</i>
variable can be conveniently set to indicate the new value as
in line 0060 above. The three remaining state changing actions
are as follows. <br>

<pre>
0131      <b>private int</b> <i>countingState</i>(){
0132         <i>enterButton</i>.enable();
0133         <i>resetButton</i>.enable();
0134         <i>leaveButton</i>.enable();
0135         <b>return</b> <i>COUNTING_STATE</i>;
0136      } // End <i>resetState</i>.
0137  
0138      <b>private int</b> <i>minimalState</i>(){
0139         <i>enterButton</i>.enable();
0140         <i>resetButton</i>.enable();
0141         <i>leaveButton</i>.disable();
0142         <b>return</b> <i>MINIMAL_STATE</i>;
0143      } // End <i>resetState</i>.
0144  
0145      <b>private int</b> <i>maximalState</i>(){
0146         <i>enterButton</i>.disable();
0147         <i>resetButton</i>.enable();
0148         <i>leaveButton</i>.enable();
0149         <b>return</b> <i>MAXIMAL_STATE</i>;
0150      } // End <i>resetState</i>.<br>

</pre>

<p>
The only other actions which communicate with <i>theMonitor</i>
are the <i>isPreMinimal()</i>
and <i>isPreMaximal()</i> <b>boolean</b>
enquiry actions. These are required to return <b>true</b>
if the value of the current number of people in the room is one
greater than the minimum or one less than the maximum respectively,
and <b>false</b> otherwise. Their
implementations are as follows. <br>

<pre>
0153      <b>private boolean</b> <i>isPreMinimal</i>() { 
0154         <b>return</b> ( <i>theMonitor.numberCurrentlyInRoomIs</i>() - 
0155                  <i>theMonitor.minimumIs</i>()) == 1;
0156      } // End <i>isPreMinimal</i>.
0157  
0158      <b>private boolean</b> <i>isPreMaximal</i>() { 
0159         <b>return</b>( <i>theMonitor.maximumIs</i>() - 
0160                 <i>theMonitor.numberCurrentlyInRoomIs</i>() ) == 1;
0161      } // End <i>isPreMaximal</i>.<br>

</pre>

<p>
These actions can be thought of as the infrastructure which supports
the behaviour of the interface, which is contained within the
<i>transition()</i> action. However
this action has to be called in response to the user pressing
a button and the <i>action()</i>
action has this responsibility. Whenever the user interacts with
the interface, by moving the mouse, or pressing one of its buttons,
or by using the keyboard, Java generates an Event
class instance and places it in an <i><b>event&nbsp;queue</b></i>.
Another thread will remove it from the queue and <i><b>dispatch</b></i>
it to an action() event handler.
So pressing a button on this interface will cause the <i>roomMonitorGUI
action() </i>to<i> </i>be
called, passing to it an Event
containing the details of which Button
was pressed. <br>

<p>
The responsibility of the <i>roomMonitorGUI
action()</i> action is to decide if the Event
passed to it is of interest to the application and, if so, invoke
its <i>transition()</i> action.
The implementation of this action is as follows. <br>

<pre>
0086      <b>public boolean</b> <i>action</i>( Event <i>event</i>, Object <i>object</i>) {
0087         <b>if</b> (<i>event.target</i> <b>instanceof</b> Button) {
0088            <b>this</b>.<i>transition</i>( (Button) <i>event.target</i>);
0089            <b>return true</b>;
0090         } <b>else</b> {   
0091            <b>return false</b>;
0092         } // End if.   
0093      } // End action.<br>

</pre>

<p>
The second, Object, argument
to this action contains further details of the event and need
not be considered in this example. The <i>action()</i>
action has to return a <b>boolean</b>
value to the Java event dispatcher to inform it if it has, or
has not, fully handled the event. In this example it is only prepared
to handle events which were generated by a Button
and the public target attribute
of the event class is accessed on line 0087 to determine this.
If this indicates that the event was generated by a Button
the identity of the Button is
passed, with type qualification, as the argument to the <i>transition()</i>
action and the value <b>true</b>
is returned to indicate that the event has been fully handled.
Otherwise this <i>action()</i>
is not prepared to handle the event and the value <b>false</b>
is returned, which will cause the event dispatcher to try to find
another <i>action()</i> handler
which might be interested in it.<br>

<p>
The <i>transition()</i> action
has the responsibility of implementing the behaviour of the interface
as expressed in the state transition diagram in Figure 16.2 and
the state table in Figure 16.3. This is the only action whose
implementation is sufficiently complex to require a JSP design,
as follows. <br>

<p>
<center><img SRC="c16p4i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/c16p4i1.gif" WIDTH="677" HEIGHT="497">
</center>
<p>
To indicate how to verify this design a couple of transitions
will be considered. If the interface is in its <i>reset</i> state
then only the <i>enter</i> button can be pressed. Thus condition
1 will be <b>true</b> as will
condition 3, causing the <i>countingState()</i>
action to be called; following this the <i>RoomMonitor
enterRoom()</i> action will be called and finally the <i>updateDisplays()</i>
action. If the interface is in the counting state recording one
person in the room and the <i>leave</i> button is pressed, condition
2 will be <b>true</b> and condition
5 will be <b>false</b>; however
condition 6 will be <b>true</b>
causing the <i>minimalState()</i>
action to be called. This will be followed by a call of the <i>leaveRoom()</i>
action and finally the <i>updateDisplays()</i>
action. The remaining possible behaviours from the state table
can be verified in a similar manner. The implementation of this
design is as follows. <br>

<pre>
0097      <b>private void</b> <i>transition</i>( Button <i>pressed</i>){ 
0098      
0099        <b>if</b> ( <i>pressed</i> == <i>enterButton</i>) {           
0100            <b>if</b> ( ( <i>currentState</i> == <i>RESET_STATE</i>)   ||
0101                 ( <i>currentState</i> == <i>MINIMAL_STATE</i>) ){
0102               <i>currentState</i> = <i>countingState</i>();
0103            } <b>else if</b> ( <i>isPreMaximal</i>()) { 
0104                  <i>currentState</i> = <i>maximalState</i>();
0105            } // End if.
0106            <i>theMonitor.enterRoom</i>();
0107         
0108         } <b>else if</b> ( <i>pressed</i> == <i>leaveButton</i>) { 
0109            <b>if</b> ( <i>currentState</i> == <i>MAXIMAL_STATE</i>) {
0110               <i>currentState</i> = <i>countingState</i>();
0111            } <b>else if</b> ( <i>isPreMinimal</i>()) { 
0112               <i>currentState</i> = <i>minimalState</i>();
0113            } // End if.
0114            <i>theMonitor.leaveRoom</i>();      
0115                   
0116         } <b>else</b> { 
0117             <i>currentState</i> = <i>resetState</i>();       
0118         } // End if.
0119         <i>updateDisplays</i>();    
0120      } // End <i>transition</i>.<br>
<br>

</pre>


<p>
<hr>
<h2>
<ul>
<a HREF="chap16p5.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/chap16p5.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
16.5 Executing the application</a>.
<p>
<a HREF="chap16p3.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/chap16p3.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
16.3 The <i>RoomMonitorGUI</i> class declaration and <i>init()</i> action</a>.
</ul>
</h2>
<hr>




</body>

</html>
