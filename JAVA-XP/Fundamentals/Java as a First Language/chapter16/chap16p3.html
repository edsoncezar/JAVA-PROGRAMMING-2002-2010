<html>

<head><meta http-equiv="pragma" content="no-cache">

<meta NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
<title>16.3 The RoomMonitorGUI class declaration and init() action</title>

</head>

<body BGCOLOR="WHITE">

<h2>16.3 The <i>RoomMonitorGUI</i> class declaration and <i>init()</i> action
</h2>

<p>
The application presenting the <i>RoomMonitor</i>
functionality with a GUI will be provided by an instance of the
<i>RoomMonitorGUI</i> class which
is an extension of the Applet class containing a <i>RoomMonitor</i>
instance. As an extended Applet
the <i>RoomMonitorGUI</i> class
will inherit the actions which are required for it to post itself
onto the display and obtain the user's responses from the mouse
and/&nbsp;or keyboard. The class diagram for the <i>RoomMonitorGUI</i>
class is given in Figure 16.7.<br>

<p>
<center><img SRC="c16p3i1.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/c16p3i1.gif" WIDTH="422" HEIGHT="439"></center>
<br>
<center>Figure 16.7 The <i>RoomMonitorGUI</i> class diagram.<br>
</center>
<p>
The class need only provide three public actions which do not
include a constructor. The <i>init()</i>
action has the responsibility of creating the interface which
will be automatically posted after it has been called. The <i>action()</i>
action is responsible for responding to the users interaction
with the components and the <i>main()</i>
action will be called as usual when the application is started.
<br>

<p>
The private Component data attributes
which are required to implement the interface have not been included
in the diagram but the encapsulated <i>RoomMonitor</i>
instance, <i>theMonitor</i>,
has been shown. The other data attribute shown, <i>currentState</i>,
is used to indicate the current state from the state transition
diagram. The <b>private</b> <i>updateDisplays()</i>
action will be used to obtain the three values required by the
<i>countDisplay</i>, <i>maxDisplay</i>
and <i>totalDisplay</i> Labels
from <i>theMonitor</i> instance
and communicate them to the Labels.
The four <i>State</i> actions
<i>resetState</i>, <i>countingState</i>,
<i>minimalState</i> and <i>maximalState</i>
will be used to effect the transitions, ensuring that the controls
are set to their appropriate sensitivities. The final two <b>private</b>
actions, <i>isPreMinimal</i>
and <i>isPreMaximal</i>, are
<b>boolean</b> enquiry actions
provided to support the decisions required for the transitions
to the <i>minimal</i> and <i>maximal</i> states respectively.
The implementation of this class, as far as the start of the <i>init()</i>
action, is as follows. <br>

<pre>
0001  // Filename <i>RoomMonitorGUI.java</i>.
0002  // Provides an interactive interface for the <i>RoomMonitor</i>
0003  // class. 
0004  //
0005  // Written for the Java book Chapter 16 - see text.
0006  // Fintan Culwin, v 0.1, September 1996.
0007  
0008  
0009  <b>import</b> java.awt.*;
0010  <b>import</b> java.applet.*;
0011  
0012  <b>import</b> <i>OutputFormatter</i>;
0013  <b>import</b> <i>Counters.RoomMonitor</i>;
0014  
0015  
0016   <b>public class</b> <i>RoomMonitorGUI</i> <b>extends</b> Applet {
0017  
0018   <b>private</b> <i>RoomMonitor</i> <i>theMonitor</i>  = <b>new</b> <i>RoomMonitor</i>();
0019  
0020  
0021   <b>private static final int</b> <i>INITIAL_STATE</i>  = 0;
0022   <b>private static final int</b> <i>RESET_STATE</i>    = 1;
0023   <b>private static final int</b> <i>COUNTING_STATE</i> = 2;
0024   <b>private static final int</b> <i>MINIMAL_STATE</i>  = 3;
0025   <b>private static final int</b> <i>MAXIMAL_STATE</i>  = 4;
0026   <b>private static int</b>       <i>currentState</i>   = <i>INITIAL_STATE</i>;
0027   
0028   <b>private</b> Button <i>enterButton</i>  = <b>new</b> Button( &quot;+&quot;);
0029   <b>private</b> Button <i>resetButton</i>  = <b>new</b> Button( &quot;0&quot;);
0030   <b>private</b> Button <i>leaveButton</i>  = <b>new</b> Button( &quot;-&quot;);
0031   
0032   <b>private</b> Label  <i>countDisplay</i> = <b>new</b> Label();  
0033   <b>private</b> Label  <i>maxDisplay</i>   = <b>new</b> Label();  
0034   <b>private</b> Label  <i>totalDisplay</i> = <b>new</b> Label();  
0035   <br>

</pre>

<p>
As the output on the displays have to be formatted to specified
lengths with leading zeros the <i>OutputFormatter</i>
class, from Chapter 9, is <b>import</b>ed.
The <i>RoomMonitorGUI</i> class
is declared as an extended Applet
class on line 0016 and the encapsulated <i>RoomMonitor</i>,
<i>theMonitor</i>, is declared
and constructed on line 0018. The encapsulated <i>currentState</i>
variable declared on line 0026 is used to indicate the current
state of the interface and is supported by the preceding manifest
declarations on lines 0021 to 0025. <br>

<p>
On lines 0028 to 0031 the three <i>Button</i>
instances from the instance hierarchy diagram are declared and
constructed. This <i>Button</i>
constructor takes a single String
argument which will be used to label the <i>Button</i>.
This is followed on lines 0032 to 0034 by the similar declaration
and construction of the three Label
instances which will be used for the numeric displays. The default
Label constructor, as used in
these calls, creates an empty Label
which would show as an empty space on the interface. However,
as will be described below, these interface objects will be given
values before they become visible.<br>

<p>
The remaining components required for the interface, as shown
in Figure 16.5, the Panels and
the labelling Labels, only need
to be referenced as the interface is <i>init</i>ialised
and so are declared as local variables of the <i>init()</i>
action, whose implementation is as follows. <br>

<pre>
0036     <b>public void</b> <i>init</i>() {
0037  
0038     Panel  <i>displayPanel</i> = <b>new</b> Panel();
0039     Panel  <i>controlPanel</i> = <b>new</b> Panel();
0040     Label  <i>countLabel</i>   = <b>new</b> Label( &quot;Current &quot;);
0041     Label  <i>maxLabel</i>     = <b>new</b> Label( &quot;Max &quot;);
0042     Label  <i>totalLabel</i>   = <b>new</b> Label( &quot;Total &quot;);
0043  
0044        <b>this</b>.<i>setLayout</i>( <b>new</b> <i>BorderLayout</i>( 0, 0));
0045        
0046        <i>displayPanel.setLayout</i>( <b>new</b> <i>GridLayout</i>(3, 2, 0, 1));
0047        <i>displayPanel</i>.add( <i>countLabel</i>);
0048        <i>displayPanel</i>.add( <i>countDisplay</i>);
0049        <i>displayPanel</i>.add( <i>maxLabel</i>);
0050        <i>displayPanel</i>.add( <i>maxDisplay</i>);
0051        <i>displayPanel</i>.add( <i>totalLabel</i>);
0052        <i>displayPanel</i>.add( <i>totalDisplay</i>);
0053        <b>this</b>.add( &quot;Center&quot;, <i>displayPanel</i>);
0054  
0055        <i>controlPanel</i>.add( <i>enterButton</i>);
0056        <i>controlPanel</i>.add( <i>resetButton</i>);
0057        <i>controlPanel</i>.add( <i>leaveButton</i>);
0058        <b>this</b>.add( &quot;South&quot;, <i>controlPanel</i>);
0059          
0060        <i>currentState</i> = <i>resetState</i>();  
0061        <b>this</b>.<i>updateDisplays</i>();
0062     } // End init.<br>

</pre>

<p>
The remaining five components of the interface are declared and
constructed on lines 0038 to 0042 with the Label
components using an alternative Label
constructor, whose String argument
is used as the text that it is to display. <br>

<p>
On lines 0044 and 0046 the layout management policy of two of
the Panels, the <i>RoomMonitorGUI</i>
Applet Panel (&nbsp;<b>this</b>&nbsp;)
and the <i>displayPanel</i> are
specified. The third Panel, the
<i>controlPanel</i>, has a suitable
default layout management policy. The default layout management
policy of any Panel is FlowLayout,
where its instance children are laid out in a single row from
left to right in the sequence in which they are added to it. So,
on lines 0055 to 0057, the three Buttons
are added to the <i>controlPanel</i>
using its add() action and will
form a single row of push buttons as required by the visual design
in Figure 16.1.<br>

<p>
The six Label components which
have to be added to the <i>displayPanel</i>
need to be laid out in a two column by three row grid, and the
GridLayout LayoutManager
class supports this policy. On line 0046 the layout policy of
the <i>displayPanel</i> is specified
by using its setLayout() action,
supplying an anonymous instance of the GridLayout
class as an argument. The four arguments to the GridLayout
constructor specify 3 rows by 2 columns with a 0 pixel
horizontal and 1 pixel vertical spacing between them. The instance
children of a GridLayout Panel are
displayed in a top left to bottom right fashion which determines
the sequence in which its six instance children are added on lines
0047 to 0052.<br>

<p>
A 2 row by 1 column GridLayout could
have been specified for the <i>RoomMonitorGUI</i>
Panel (&nbsp;<b>this</b>&nbsp;)
on line 0044, but as all the components of a GridLayout
layout have to be the same size this would not provided
an aesthetically pleasing result. Instead a BorderLayout
policy is used with the two arguments to the BorderLayout
constructor specifying the vertical and horizontal spacing, in
this case each is zero. BorderLayouts
can have up to five children one in the Centre
and the other four North, South,
East and West
of it. On line 0053 the displayPanel
is added to the Centre location
of the Applet and on line 0058
the controlPanel is added to
the South of it.<br>

<p>
At the end of the <i>init()</i>
action, and before the Applet
is displayed on the screen, <i><b>geometry negotiation</b></i>
will take place. The Applet will
ask each of its children how much space they require upon the
screen. The <i>displayPanel</i>
will, recursively, ask each of its children for their requirements
and, as all of its children have to be the same size, it will
determine its preferred size based upon the largest of its children.
The <i>controlPanel</i> will
likewise ask its children, and add their three preferred widths
together to obtain its width; using the tallest of its children
as its own preferred height. The Applet
now knows the preferred size of its children and, as it has a
BorderLayout policy, will allow
both its children to have whatever heights they have requested,
however both will be told to use the width of its widest child.
This is likely to be the width of the <i>displayPanel</i>
and so the <i>controlPanel</i>
will be given a wider width than it requested, spacing its children
so as to be in the middle. <br>

<p>
This process produces the layout required to produce the visual
design shown in Figure 16.1 and is the reason why two subsidiary
panels are required in the instance hierarchy design. The appearance
of this interface when executed in a Windows 95 environment is
shown in Figure 16.8.<br>

<p>
<center><img SRC="c16p3i2.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/c16p3i2.gif" WIDTH="180" HEIGHT="184"></center>
<p>
<center>Figure 16.8 The <i>RoomMonitorGUI</i>
in the <i>reset</i> state under Windows 95.<br>
</center>
<p>
Before the<i> init() </i>action
finishes, the state of the interface is set to the <i>reset</i>
state on line 0060 and the numeric displays are updated to reflect
the current state of <i>theMonitor</i>
on line 0061 using the <i>updateDisplays()</i>
action. Both of these actions will be described in detail below.
<br>
<br>




<p>
<hr>
<h2>
<ul>
<a HREF="roommonitorgui.java" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/RoomMonitorGUI.java"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
Send the <i>RoomMonitorGUI.java</i> source code</a>.
<p>

<a HREF="chap16p4.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/chap16p4.html"><img SRC="..\next.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/next.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
16.4 The remaining actions, apart from <i>main()</i></a>.
<p>
<a HREF="chap16p2.html" tppabs="http://www.scism.sbu.ac.uk/jfl/Chapter16/chap16p2.html"><img SRC="..\last.gif" tppabs="http://www.scism.sbu.ac.uk/jfl/last.gif" ALIGN="MIDDLE" BORDER="0" WIDTH="50" HEIGHT="40">
16.2 The component instance hierarchy</a>.
</ul>
</h2>
<hr>
</body>

</html>
