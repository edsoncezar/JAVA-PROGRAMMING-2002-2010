<HTML>
<HEAD>
<TITLE>Day 2-- Object-Oriented Programming and Java</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;2</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Object-Oriented Programming and
Java</FONT></H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ThinkinginObjectsAnAnalogy">
Thinking in Objects: An Analogy</A>
<LI><A HREF="#ObjectsandClasses">
Objects and Classes</A>
<LI><A HREF="#BehaviorandAttributes">
Behavior and Attributes</A>
<UL>
<LI><A HREF="#Attributes">
Attributes</A>
<LI><A HREF="#Behavior">
Behavior</A>
<LI><A HREF="#CreatingaClass">
Creating a Class </A>
</UL>
<LI><A HREF="#InheritanceInterfacesandPackages">
Inheritance, Interfaces, and Packages</A>
<UL>
<LI><A HREF="#Inheritance">
Inheritance</A>
<LI><A HREF="#CreatingaClassHierarchy">
Creating a Class Hierarchy</A>
<LI><A HREF="#HowInheritanceWorks">
How Inheritance Works</A>
<LI><A HREF="#SingleandMultipleInheritance">
Single and Multiple Inheritance</A>
<LI><A HREF="#InterfacesandPackages">
Interfaces and Packages</A>
<LI><A HREF="#CreatingaSubclass">
Creating a Subclass</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Object-oriented programming (OOP) is one of the biggest programming
ideas of recent years, and you might worry that you must spend
years learning all about object-oriented programming methodologies
and how they can make your life easier than The Old Way of programming.
It all comes down to organizing your programs in ways that echo
how things are put together in the real world.
<P>
Today you'll get an overview of object-oriented programming concepts
in Java and how they relate to how you structure your own programs:
<UL>
<LI>What classes and objects are and how they relate to each other
<LI>The two main parts of a class or object: its behaviors and
its attributes
<LI>Class inheritance and how inheritance affects the way you
design your programs
<LI>Some information about packages and interfaces
</UL>
<P>
If you're already familiar with object-oriented programming, much
of today's lesson will be old hat to you. You may want to skim
it and go to a movie today instead. Tomorrow, you'll get into
more specific details.
<H2><A NAME="ThinkinginObjectsAnAnalogy"><FONT SIZE=5 COLOR=#FF0000>
Thinking in Objects: An Analogy</FONT></A></H2>
<P>
Consider, if you will, Legos. Legos, for those who do not spend
much time with children, are small plastic building blocks in
various colors and sizes. They have small round bits on one side
that fit into small round holes on other Legos so that they fit
together snugly to create larger shapes. With different Lego parts
(Lego wheels, Lego engines, Lego hinges, Lego pulleys), you can
put together castles, automobiles, giant robots that swallow cities,
or just about anything else you can imagine. Each Lego part is
a small object that fits together with other small objects in
predefined ways to create other larger objects. That is roughly
how object-oriented programming works: putting together smaller
elements to build larger ones.
<P>
Here's another example. You can walk into a computer store and,
with a little background and often some help, assemble an entire
pc computer system from various components: a motherboard, a CPU
chip, a video card, a hard disk, a keyboard, and so on. Ideally,
when you finish assembling all the various self-contained units,
you have a system in which all the units work together to create
a larger system with which you can solve the problems you bought
the computer for in the first place.
<P>
Internally, each of those components may be vastly complicated
and engineered by different companies with different methods of
design. But you don't need to know how the component works, what
every chip on the board does, or how, when you press the A key,
an A</FONT> gets sent to your computer.
As the assembler of the overall system, each component you use
is a self-contained unit, and all you are interested in is how
the units interact with each other. Will this video card fit into
the slots on the motherboard, and will this monitor work with
this video card? Will each particular component speak the right
commands to the other components it interacts with so that each
part of the computer is understood by every other part? Once you
know what the interactions are between the components and can
match the interactions, putting together the overall system is
easy.
<P>
What does this have to do with programming? Everything. Object-oriented
programming works in exactly this same way. Using object-oriented
programming, your overall program is made up of lots of different
self-contained components (objects), each of which has a specific
role in the program and all of which can talk to each other in
predefined ways.
<H2><A NAME="ObjectsandClasses"><FONT SIZE=5 COLOR=#FF0000>
Objects and Classes</FONT></A></H2>
<P>
Object-oriented programming is modeled on how, in the real world,
objects are often made up of many kinds of smaller objects. This
capability of combining objects, however, is only one very general
aspect of object-oriented programming. Object-oriented programming
provides several other concepts and features to make creating
and using objects easier and more flexible, and the most important
of these features is classes.
<P>
When you write a program in an object-oriented language, you don't
define actual objects. You define classes of objects, where a
class</FONT> is a template for multiple
objects with similar features. Classes embody all the features
of a particular set of objects. For example, you might have a
<TT>Tree</TT> class that describes
the features of all trees (has leaves and roots, grows, creates
chlorophyll). The <TT>Tree</TT> class
serves as an abstract model for the concept of a tree-to reach
out and grab, or interact with, or cut down a tree you have to
have a concrete instance of that tree. Of course, once you have
a tree class, you can create lots of different instances</FONT>
of that tree, and each different tree instance can have different
features (short, tall, bushy, drops leaves in autumn), while still
behaving like and being immediately recognizable as a tree (see
Figure 2.1).
<P>
<A HREF="http://docs.rinet.ru/J21/f2-1.gif"><B>Figure 2.1 : </B><I>The Tree class and several Tree instances</I>.</A>
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A class</FONT> is a generic template for a set of objects with similar features.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
An instance </FONT>of a class is
another word for an actual object. If class is the general (generic)
representation of an object, an instance is its concrete representation.
So what, precisely, is the difference between an instance and
an object? Nothing, really. Object is the more general term, but
both instances and objects are the concrete representation of
a class. In fact, the terms instance and object are often used
interchangeably in OOP lingo. An instance of a tree and a tree
object are both the same thing.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An instance</FONT> is the specific concrete representation of a class. Instances and objects are the same thing. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
What about an example closer to the sort of things you might want
to do in Java programming? You might create a class for the user
interface element called a button. The <TT>Button</TT>
class defines the features of a button (its label, its size, its
appearance) and how it behaves. (Does it need a single-click or
a double-click to activate it? Does it change color when it's
clicked? What does it do when it's activated?) After you define
the <TT>Button</TT> class, you can
then easily create instances of that button-that is, button objects-that
all take on the basic features of the button as defined by the
class, but may have different appearances and behavior based on
what you want that particular button to do. By creating a <TT>Button</TT>
class, you don't have to keep rewriting the code for each individual
button you want to use in your program, and you can reuse the
<TT>Button</TT> class to create different
kinds of buttons as you need them in this program and in other
programs.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you're used to programming in C, you can think of a class as sort of creating a new composite data type by using <TT>struct</TT> and <TT>typedef</TT>. Classes, however, can provide much more than just a collection of data, as you'll discover in the rest 
of today's lesson.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
When you write a Java program, you design and construct a set
of classes. Then when your program runs, instances of those classes
are created and discarded as needed. Your task, as a Java programmer,
is to create the right set of classes to accomplish what your
program needs to accomplish.
<P>
Fortunately, you don't have to start from the very beginning:
The Java environment comes with a standard set of classes (called
a class</FONT> library</FONT>)
that implement a lot of the basic behavior you need-not only for
basic programming tasks (classes to provide basic math functions,
arrays, strings, and so on), but also for graphics and networking
behavior. In many cases, the Java class libraries may be enough
so that all you have to do in your Java program is create a single
class that uses the standard class libraries. For complicated
Java programs, you may have to create a whole set of classes with
defined interactions between them.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A class library</FONT> is a collection of classes intended to be reused repeatedly in different programs. The standard Java class libraries contain quite a few classes for accomplishing basic programming tasks in Java.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="BehaviorandAttributes"><FONT SIZE=5 COLOR=#FF0000>
Behavior and Attributes</FONT></A></H2>
<P>
Every class you write in Java has two basic features: attributes
and behavior. In this section you'll learn about each one as it
applies to a theoretical simple class called <TT>Motorcycle</TT>.
To finish up this section, you'll create the Java code to implement
a representation of a motorcycle.
<H3><A NAME="Attributes">
Attributes</A></H3>
<P>
Attributes are the individual things that differentiate one object
from another and determine the appearance, state, or other qualities
of that object. Let's create a theoretical class called <TT>Motorcycle</TT>.
A motorcycle class might include the following attributes and
have these typical values:
<UL>
<LI><TT>Color</TT>: red, green, silver,
brown
<LI><TT>Style</TT>: cruiser, sport
bike, standard
<LI><TT>Make</TT>: Honda, BMW, Bultaco
</UL>
<P>
Attributes of an object can also include information about its
state; for example, you could have features for engine condition
(off or on) or current gear selected.
<P>
Attributes are defined in classes by variables. Those variables'
types and names are defined in the class, and each object can
have its own values for those variables. Because each instance
of a class can have different values for its variables, these
variables are often called instance
variables.<BR>
</FONT><P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An instance variable </FONT>defines the attributes of the object. Instance variables' types and names are defined in the class, but their values are set and changed in the object.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Instance variables may be initially set when an object is created
and stay constant throughout the life of the object, or they may
be able to change at will as the program runs. Change the value
of the variable, and you change an object's attributes.
<P>
In addition to instance variables, there are also class variables,
which apply to the class itself and to all its instances. Unlike
instance variables, whose values are stored in the instance, class
variables' values are stored in the class itself. You'll learn
about class variables later on this week and more specifics about
instance variables tomorrow.
<H3><A NAME="Behavior">
Behavior</A></H3>
<P>
A class's behavior determines how an instance of that class operates;
for example, how it will &quot;react&quot; if asked to do something
by another class or object or if its internal state changes. Behavior
is the only way objects can do anything to themselves or have
anything done to them. For example, to go back to the theoretical
<TT>Motorcycle</TT> class, here are
some behaviors that the <TT>Motorcycle</TT>
class might have:
<UL>
<LI>Start the engine
<LI>Stop the engine
<LI>Speed up
<LI>Change gear
<LI>Stall
</UL>
<P>
To define an object's behavior, you create methods</FONT>,
a set of Java statements that accomplish some task. Methods look
and behave just like functions in other languages but are defined
and accessible solely inside a class. Java does not have functions
defined outside classes (as C++ does). <BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Methods</FONT> are functions defined inside classes that operate on instances of those classes.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
While methods can be used solely to operate on an individual object,
methods are also used between objects to communicate with each
other. A class or an object can call methods in another class
or object to communicate changes in the environment or to ask
that object to change its state. 
<P>
Just as there are instance and class variables, there are also
instance and class methods. Instance methods (which are so common
that they're usually just called methods) apply and operate on
an instance of a class; class methods apply and operate on the
class itself. You'll learn more about class methods later on this
week.
<H3><A NAME="CreatingaClass">
Creating a Class </A></H3>
<P>
Up to this point, today's lesson has been pretty theoretical.
In this section, you'll create a working example of the <TT>Motorcycle</TT>
class so that you can see how instance variables and methods are
defined in a class in Java. You'll also create a Java application
that creates a new instance of the <TT>Motorcycle</TT>
class and shows its instance variables.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
I'm not going to go into a lot of detail about the actual syntax of this example here. Don't worry too much about it if you're not really sure what's going on; it will become clear to you later on this week. All you really need to worry about in this 
example is understanding the basic parts of this class definition.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Ready? Let's start with a basic class definition. Open the text
editor you've been using to create Java source code and enter
the following (remember, upper- and lowercase matters):
<BLOCKQUOTE>
<PRE>
class Motorcycle {

}
</PRE>
</BLOCKQUOTE>
<P>
Congratulations! You've now created a class. Of course, it doesn't
do very much at the moment, but that's a Java class at its very
simplest.
<P>
First, let's create some instance variables for this class-three
of them, to be specific. Just below the first line, add the following
three lines:
<BLOCKQUOTE>
<PRE>
String make;
String color;
boolean engineState = false;
</PRE>
</BLOCKQUOTE>
<P>
Here you've created three instance variables: Two, <TT>make</TT>
and <TT>color</TT>, can contain <TT>String</TT>
objects (a string is the generic term for a series of characters;
<TT>String</TT>, with a capital S</FONT>,
is part of that standard class library mentioned earlier). The
third, <TT>engineState</TT>, is a
<TT>boolean</TT> variable that refers
to whether the engine is off or on; a value of <TT>false</TT>
means that the engine is off, and <TT>true</TT>
means that the engine is on. Note that boolean is lowercase b</FONT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A boolean</FONT> is a value of either true or false.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>boolean</TT> in Java is a real data type that can have the values <TT>true</TT> or <TT>false</TT>. Unlike in C, booleans are not numbers. You'll hear about this again tomorrow so that you won't forget.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now let's add some behavior (methods) to the class. There are
all kinds of things a motorcycle can do, but to keep things short,
let's add just one method-a method that starts the engine. Add
the following lines below the instance variables in your class
definition:
<BLOCKQUOTE>
<PRE>
void startEngine() {
    if (engineState == true)
        System.out.println(&quot;The engine is already on.&quot;);
    else {
        engineState = true;
        System.out.println(&quot;The engine is now on.&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>startEngine()</TT> method
tests to see whether the engine is already running (in the part
<TT>engineState == true</TT>) and,
if it is, merely prints a message to that effect. If the engine
isn't already running, it changes the state of the engine to <TT>true</TT>
(turning the engine on) and then prints a message. Finally, because
the <TT>startEngine()</TT> method
doesn't return a value, its definition includes the word void
at the beginning. (You can also define methods to return values;
you'll learn more about method definitions on <A HREF="ch6.htm">Day 6</A>, &quot;Creating
Classes and Applications in Java.&quot;)<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Here and throughout this book, whenever I refer to the name of a method, I'll add empty parentheses to the end of the name (for example, as I did in the first sentence of the previous paragraph: &quot;The <TT>startEngine()</TT> method&#133;&quot; This is a 
convention used in the programming community at large to indicate that a particular name is a method and not a variable. The parentheses are silent. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
With your methods and variables in place, save the program to
a file called <TT>Motorcycle.java</TT>
(remember that you should always name your Java source files the
same names as the class they define). Listing 2.1 shows what your
program should look like so far.
<HR>
<BLOCKQUOTE>
<B>Listing 2.1. The </B><TT><B>Motorcycle.java</B></TT><B>
file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:class Motorcycle {
 2:
 3: String make;
 4: String color;
 5: boolean engineState = false;
 6:
 7: void startEngine() {
 8:     if (engineState == true)
 9:         System.out.println(&quot;The engine is already on.&quot;);
10:     else {
11:         engineState = true;
12:         System.out.println(&quot;The engine is now on.&quot;);
13:     }
14: }
15:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The indentation of each part of the class isn't important to the Java compiler. Using some form of indentation, however, makes your class definition easier for you and other people to read. The indentation used here, with instance variables and methods 
indented from the class definition, is the style used throughout this book. The Java class libraries use a similar indentation. You can choose any indentation style that you like. </BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Before you compile this class, let's add one more method just
below the <TT>startEngine()</TT> method
(that is, between lines 14 and 15). The <TT>showAtts()</TT>
method is used to print the current values of all the instance
variables in an instance of your <TT>Motorcycle</TT>
class. Here's what it looks like:
<BLOCKQUOTE>
<PRE>
void showAtts() {
    System.out.println(&quot;This motorcycle is a &quot;
        + color + &quot; &quot; + make);
    if (engineState == true)
        System.out.println(&quot;The engine is on.&quot;);
    else System.out.println(&quot;The engine is off.&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>showAtts()</TT> method prints
two lines to the screen: the <TT>make</TT>
and <TT>color</TT> of the motorcycle
object and whether the engine is on or off.
<P>
Now you have a Java class with three instance variables and two
methods defined. Save that file again, and compile it using one
of the following methods:<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
After this point, I'm going to assume you know how to compile and run Java programs. I won't repeat this information after this.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Windows</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
From inside a DOS shell, <TT>CD</TT> to the directory containing your Java source file, and use the <TT>javac</TT> command to compile it:
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<BLOCKQUOTE>
<PRE>
javac Motorcycle.java<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Macintosh</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Drag and drop the <TT>Motorcycle.java</TT> file onto the Java Compiler icon.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Salaris</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
From a command line, <TT>CD</TT> to the directory containing your Java source file, and use the <TT>javac</TT> command to compile it:
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
javac Motorcycle.java
</PRE>
</BLOCKQUOTE>
<P>
When you run this little program using the <TT>java</TT>
or Java Runner programs, you'll get an error. Why? When you run
a compiled Java class directly, Java assumes that the class is
an application and looks for a <TT>main()</TT>
method. Because we haven't defined a <TT>main()</TT>
method inside the class, the Java interpreter (<TT>java</TT>)
gives you an error something like one of these two errors:
<BLOCKQUOTE>
<PRE>
In class Motorcycle: void main(String argv[]) is not defined
Exception in thread &quot;main&quot;:  java.lang.UnknownError
</PRE>
</BLOCKQUOTE>
<P>
To do something with the <TT>Motorcycle</TT>
class-for example, to create instances of that class and play
with them-you're going to need to create a separate Java applet
or application that uses this class or add a <TT>main()</TT>
method to this one. For simplicity's sake, let's do the latter.
Listing 2.2 shows the <TT>main()</TT>
method you'll add to the <TT>Motorcycle</TT>
class. You'll want to add this method to your <TT>Motorcycle.java</TT>
source file just before the last closing brace (<TT>}</TT>),
underneath the <TT>startEngine()</TT>
and <TT>showAtts()</TT> methods.
<HR>
<BLOCKQUOTE>
<B>Listing 2.2. The </B><TT><B>main()</B></TT><B>
method for </B><TT><B>Motorcycle.java</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: public static void main (String args[]) {
 2:    Motorcycle m = new Motorcycle();
 3:    m.make = &quot;Yamaha RZ350&quot;;
 4:    m.color = &quot;yellow&quot;;
 5:    System.out.println(&quot;Calling showAtts...&quot;);
 6:    m.showAtts();
 7:    System.out.println(&quot;--------&quot;);
 8:    System.out.println(&quot;Starting engine...&quot;);
 9:    m.startEngine();
10:    System.out.println(&quot;--------&quot;);
11:    System.out.println(&quot;Calling showAtts...&quot;);
12:    m.showAtts();
13:    System.out.println(&quot;--------&quot;);
14:    System.out.println(&quot;Starting engine...&quot;);
15:    m.startEngine();
16:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
With the <TT>main()</TT> method in
place, the <TT>Motorcycle</TT> class
is now an official application, and you can compile it again and
this time it'll run. Here's how the output should look:
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Calling showAtts...
This motorcycle is a yellow Yamaha RZ350
The engine is off.
--------
Starting engine...
The engine is now on.
--------
Calling showAtts...
This motorcycle is a yellow Yamaha RZ350
The engine is on.
--------
Starting engine...
The engine is already on.<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The contents of the <TT>main()</TT> method are all going to look very new to you, so let's go through it line by line so that you at least have a basic idea of what it does (you'll get details about the specifics of all of this tomorrow and the day after).

</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The first line declares the <TT>main()</TT>
method. The first line of the <TT>main()</TT>
method always looks like this; you'll learn the specifics of each
part later this week.
<P>
Line 2, <TT>Motorcycle m = new Motorcycle();</TT>,
creates a new instance of the <TT>Motorcycle</TT>
class and stores a reference to it in the variable <TT>m</TT>.
Remember, you don't usually operate directly on classes in your
Java programs; instead, you create objects from those classes
and then call methods in those objects.
<P>
Lines 3 and 4 set the instance variables for this <TT>Motorcycle</TT>
object: The make is now a <TT>Yamaha RZ350</TT>
(a very pretty motorcycle from the mid-1980s), and the color is
<TT>yellow</TT>.
<P>
Lines 5 and 6 call the <TT>showAtts()</TT>
method, defined in your <TT>Motorcycle</TT>
object. (Actually, only 6 does; 5 just prints a message that you're
about to call this method.) The new motorcycle object then prints
out the values of its instance variables-the <TT>make</TT>
and <TT>color</TT> as you set in the
previous lines-and shows that the engine is off.
<P>
Line 7 prints a divider line to the screen; this is just for prettier
output.
<P>
Line 9 calls the <TT>startEngine()</TT>
method in the motorcycle object to start the engine. The engine
should now be on.
<P>
Line 11 prints the values of the instance variables again. This
time, the report should say the engine is now on.
<P>
Line 15 tries to start the engine again, just for fun. Because
the engine is already on, this should print the message <TT>The
engine is already on</TT>.
<P>
Listing 2.3 shows the final <TT>Motorcycle</TT>
class, in case you've been having trouble compiling and running
the one you've got (and remember, this example and all the examples
in this book are available on the CD that accompanies the book):
<HR>
<BLOCKQUOTE>
<B>Listing 2.3. The final version of </B><TT><B>Motorcycle.java</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class Motorcycle {
 2: 
 3:    String make;
 4:    String color;
 5:    boolean engineState;
 6: 
 7:    void startEngine() {
 8:       if (engineState == true)
 9:           System.out.println(&quot;The engine is already on.&quot;);
10:       else {
11:           engineState = true;
12:           System.out.println(&quot;The engine is now on.&quot;);
13:       }
14:    }
15:    
16:   void showAtts() {
17:       System.out.println(&quot;This motorcycle is a &quot;
18:          + color + &quot; &quot; + make);
19:       if (engineState == true)
20:         System.out.println(&quot;The engine is on.&quot;);
21:       else System.out.println(&quot;The engine is off.&quot;);
22:    }
23: 
24:    public static void main (String args[]) {
25:       Motorcycle m = new Motorcycle();
26:       m.make = &quot;Yamaha RZ350&quot;;
27:       m.color = &quot;yellow&quot;;
28:       System.out.println(&quot;Calling showAtts...&quot;);
29:       m.showAtts();
30:      System.out.println(&quot;------&quot;);
31:       System.out.println(&quot;Starting engine...&quot;);
32:       m.startEngine();
33:       System.out.println(&quot;------&quot;);
34:       System.out.println(&quot;Calling showAtts...&quot;);
35:       m.showAtts();
36:       System.out.println(&quot;------&quot;);
37:       System.out.println(&quot;Starting engine...&quot;);
38:       m.startEngine();
39:    }
40:}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="InheritanceInterfacesandPackages"><FONT SIZE=5 COLOR=#FF0000>
Inheritance, Interfaces, and Packages</FONT></A></H2>
<P>
Now that you have a basic grasp of classes, objects, methods,
variables, and how to put them all together in a Java program,
it's time to confuse you again. Inheritance, interfaces, and packages
are all mechanisms for organizing classes and class behaviors.
The Java class libraries use all these concepts, and the best
class libraries you write for your own programs will also use
these concepts.
<H3><A NAME="Inheritance">
Inheritance</A></H3>
<P>
Inheritance is one of the most crucial concepts in object-oriented
programming, and it has a very direct effect on how you design
and write your Java classes. Inheritance is a powerful mechanism
that means when you write a class you only have to specify how
that class is different from some other class; inheritance will
give you automatic access to the information contained in that
other class.
<P>
With inheritance, all classes-those you write, those from other
class libraries that you use, and those from the standard utility
classes as well-are arranged in a strict hierarchy (see Figure
2.2). Each class has a superclass (the class above it in the hierarchy),
and each class can have one or more subclasses (classes below
that class in the hierarchy). Classes further down in the hierarchy
are said to inherit from</FONT>
classes further up in the hierarchy.
<P>
<A HREF="http://docs.rinet.ru/J21/f2-2.gif"><B>Figure 2.2 : </B><I>A class hierarchy</I>.</A>
<P>
Subclasses inherit all the methods and variables from their superclasses-that
is, in any particular class, if the superclass defines behavior
that your class needs, you don't have to redefine it or copy that
code from some other class. Your class automatically gets that
behavior from its superclass, that superclass gets behavior from
its superclass, and so on all the way up the hierarchy. Your class
becomes a combination of all the features of the classes above
it in the hierarchy.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Inheritance</FONT> is a concept in object-oriented programming where all classes are arranged in a strict hierarchy</FONT>. Each class in the hierarchy has superclasses</FONT> (classes above it in the hierarchy) and any number of subclasses</FONT> (classes 
below it in the hierarchy). Subclasses inherit attributes and behavior from their superclasses.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
At the top of the Java class hierarchy is the class <TT>Object</TT>;
all classes inherit from this one superclass. <TT>Object</TT>
is the most general class in the hierarchy; it defines behavior
inherited by all the classes in Java. Each class further down
in the hierarchy adds more information and becomes more tailored
to a specific purpose. In this way, you can think of a class hierarchy
as defining very abstract concepts at the top of the hierarchy
and those ideas becoming more concrete the farther down the chain
of superclasses you go.
<P>
Most of the time when you write new Java classes, you'll want
to create a class that has all the information some other class
has, plus some extra information. For example, you may want a
version of a <TT>Button</TT> with
its own built-in label. To get all the <TT>Button</TT>
information, all you have to do is define your class to inherit
from <TT>Button</TT>. Your class will
automatically get all the behavior defined in <TT>Button</TT>
(and in <TT>Button</TT>'s superclasses),
so all you have to worry about are the things that make your class
different from <TT>Button</TT> itself.
This mechanism for defining new classes as the differences between
them and their superclasses is called subclassing</FONT>.
<P>
Subclassing</FONT> involves creating
a new class that inherits from some other class in the class hierarchy.
Using subclassing, you only need to define the differences between
your class and its parent; the additional behavior is all available
to your class through inheritance. <BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Subclassing</FONT> is the process of creating a new class that inherits from some other already-existing class.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
What if your class defines an entirely new behavior and isn't
really a subclass of another class? Your class can also inherit
directly from <TT>Object</TT>, which
still allows it to fit neatly into the Java class hierarchy. In
fact, if you create a class definition that doesn't indicate its
superclass in the first line, Java automatically assumes you're
inheriting from <TT>Object</TT>. The
<TT>Motorcycle</TT> class you created
in the previous section inherited from <TT>Object</TT>.
<H3><A NAME="CreatingaClassHierarchy">
Creating a Class Hierarchy</A></H3>
<P>
If you're creating a larger set of classes for a very complex
program, it makes sense for your classes not only to inherit from
the existing class hierarchy, but also to make up a hierarchy
themselves. This may take some planning beforehand when you're
trying to figure out how to organize your Java code, but the advantages
are significant once it's done:
<UL>
<LI>When you develop your classes in a hierarchy, you can factor
out information common to multiple classes in superclasses, and
then reuse that superclass's information over and over again.
Each subclass gets that common information from its superclass.
<LI>Changing (or inserting) a class further up in the hierarchy
automatically changes the behavior of its subclasses-no need to
change or recompile any of the lower classes because they get
the new information through inheritance and not by copying any
of the code.
</UL>
<P>
For example, let's go back to that <TT>Motorcycle</TT>
class and pretend you created a Java program to implement all
the features of a motorcycle. It's done, it works, and everything
is fine. Now, your next task is to create a Java class called
<TT>Car</TT>.
<P>
<TT>Car</TT> and <TT>Motorcycle</TT>
have many similar features-both are vehicles driven by engines.
Both have transmissions, headlamps, and speedometers. So your
first impulse may be to open your <TT>Motorcycle</TT>
class file and copy over a lot of the information you already
defined into the new class <TT>Car</TT>.
<P>
A far better plan is to factor out the common information for
<TT>Car</TT> and <TT>Motorcycle</TT>
into a more general class hierarchy. This may be a lot of work
just for the classes <TT>Motorcycle</TT>
and <TT>Car</TT>, but once you add
<TT>Bicycle</TT>, <TT>Scooter</TT>,
<TT>Truck</TT>, and so on, having
common behavior in a reusable superclass significantly reduces
the amount of work you have to do overall.
<P>
Let's design a class hierarchy that might serve this purpose.
Starting at the top is the class <TT>Object</TT>,
which is the root of all Java classes. The most general class
to which a motorcycle and a car both belong might be called <TT>Vehicle</TT>.
A vehicle, generally, is defined as a thing that propels someone
from one place to another. In the <TT>Vehicle</TT>
class, you define only the behavior that enables someone to be
propelled from point a to point b, and nothing more.
<P>
Below <TT>Vehicle</TT>? How about
two classes: <TT>PersonPoweredVehicle</TT>
and <TT>EnginePoweredVehicle</TT>?
<TT>EnginePoweredVehicle</TT> is different
from <TT>Vehicle</TT> because it has
an engine, and the behaviors might include stopping and starting
the engine, having certain amounts of gasoline and oil, and perhaps
the speed or gear in which the engine is running. Person-powered
vehicles have some kind of mechanism for translating people motion
into vehicle motion-pedals, for example. Figure 2.3 shows what
you have so far.
<P>
<A HREF="http://docs.rinet.ru/J21/f2-3.gif"><B>Figure 2.3 : </B><I>The basic vehicle hierarchy</I>.</A>
<P>
Now let's become even more specific. With <TT>EnginePoweredVehicle</TT>,
you might have several classes: <TT>Motorcycle</TT>,
<TT>Car</TT>, <TT>Truck</TT>,
and so on. Or you can factor out still more behavior and have
intermediate classes for <TT>TwoWheeled</TT>
and <TT>FourWheeled</TT> vehicles,
with different behaviors for each (see Figure 2.4).
<P>
<A HREF="http://docs.rinet.ru/J21/f2-4.gif"><B>Figure 2.4 : </B><I>Two-wheeled and four-wheeled vehicles</I>.</A>
<P>
Finally, with a subclass for the two-wheeled engine-powered vehicles,
you can have a class for motorcycles. Alternatively, you could
additionally define scooters and mopeds, both of which are two-wheeled
engine-powered vehicles but have different qualities from motorcycles.
<P>
Where do qualities such as make or color come in? Wherever you
want them to go-or, more usually, where they fit most naturally
in the class hierarchy. You can define the make and color on <TT>Vehicle</TT>,
and all the subclasses will have those variables as well. The
point to remember is that you have to define a feature or a behavior
only once in the hierarchy; it's automatically reused by each
subclass.
<H3><A NAME="HowInheritanceWorks">
How Inheritance Works</A></H3>
<P>
How does inheritance work? How is it that instances of one class
can automatically get variables and methods from the classes further
up in the hierarchy?
<P>
For instance variables, when you create a new instance of a class,
you get a &quot;slot&quot; for each variable defined in the current
class and for each variable defined in all its superclasses. In
this way, all the classes combine to form a template for the current
object, and then each object fills in the information appropriate
to its situation.
<P>
Methods operate similarly: New objects have access to all the
method names of its class and its superclasses, but method definitions
are chosen dynamically when a method is called. That is, if you
call a method on a particular object, Java first checks the object's
class for the definition of that method. If it's not defined in
the object's class, it looks in that class's superclass, and so
on up the chain until the method definition is found (see Figure
2.5).
<P>
<A HREF="http://docs.rinet.ru/J21/f2-5.gif"><B>Figure 2.5 : </B><I>How methods are located</I>.</A>
<P>
Things get complicated when a subclass defines a method that has
the same signature (name, number, and type of arguments) as a
method defined in a superclass. In this case, the method definition
that is found first (starting at the bottom and working upward
toward the top of the hierarchy) is the one that is actually executed.
Therefore, you can intentionally define a method in a subclass
that has the same signature as a method in a superclass, which
then &quot;hides&quot; the superclass's method. This is called
overriding</FONT> a method. You'll
learn all about methods on <A HREF="ch7.htm">Day 7</A>, &quot;More About Methods.&quot;
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Overriding</FONT> a method is creating a method in a subclass that has the same signature (name, number, and type of arguments) as a method in a superclass. That new method then hides the superclass's method (see Figure 2.6).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<A HREF="http://docs.rinet.ru/J21/f2-6.gif"><B>Figure 2.6 : </B><I>Overriding methods</I>.</A>
<H3><A NAME="SingleandMultipleInheritance">
Single and Multiple Inheritance</A></H3>
<P>
Java's form of inheritance, as you learned in the previous sections,
is called single inheritance</FONT>.
Single inheritance means that each Java class can have only one
superclass (although any given superclass can have multiple subclasses).
<P>
In other object-oriented programming languages, such as C++, classes
can have more than one superclass, and they inherit combined variables
and methods from all those classes. This is called multiple
inheritance</FONT>. Multiple inheritance can provide enormous
power in terms of being able to create classes that factor just
about all imaginable behavior, but it can also significantly complicate
class definitions and the code to produce them. Java makes inheritance
simpler by being only singly inherited.
<H3><A NAME="InterfacesandPackages">
Interfaces and Packages</A></H3>
<P>
There are two remaining concepts to discuss here: packages and
interfaces. Both are advanced topics for implementing and designing
groups of classes and class behavior. You'll learn about both
interfaces and packages on <A HREF="ch16.htm">Day 16</A>, &quot;Packages and Interfaces,&quot;
but they are worth at least introducing here.
<P>
Recall that each Java class has only a single superclass, and
it inherits variables and methods from that superclass and all
its superclasses. Although single inheritance makes the relationship
between classes and the functionality those classes implement
easy to understand and to design, it can also be somewhat restrictive-in
particular, when you have similar behavior that needs to be duplicated
across different &quot;branches&quot; of the class hierarchy.
Java solves this problem of shared behavior by using the concept
of interfaces, which collect method names into one place and then
allow you to add those methods as a group to the various classes
that need them. Note that interfaces contain only method names
and interfaces (arguments, for example), not actual definitions.
<P>
Although a single Java class can have only one superclass (due
to single inheritance), that class can also implement any number
of interfaces. By implementing an interface, a class provides
method implementations (definitions) for the method names defined
by the interface. If two very disparate classes implement the
same interface, they can both respond to the same method calls
(as defined by that interface), although what each class actually
does in response to those method calls may be very different.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
An interface</FONT> is a collection of method names, without definitions, that can be added to classes to provide additional behavior not included with those methods the class defined itself or inherited from its superclasses.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You don't need to know very much about interfaces right now. You'll
learn more as the book progresses, so if all this is very confusing,
don't panic!
<P>
The final new Java concept for today is packages. Packages</FONT>
in Java are a way of grouping together related classes and interfaces
in a single library or collection. Packages enable modular groups
of classes to be available only if they are needed and eliminate
potential conflicts between class names in different groups of
classes.
<P>
You'll learn all about packages, including how to create and use
them, in Week 3. For now, there are only a few things you need
to know:
<UL>
<LI>The class libraries in the Java Developer's Kit are contained
in a package called <TT>java</TT>.
The classes in the <TT>java</TT> package
are guaranteed to be available in any Java implementation and
are the only</FONT> classes guaranteed
to be available across different implementations. The <TT>java</TT>
package itself contains other packages for classes that define
the language, the input and output classes, some basic networking,
the window toolkit functions, and classes that define applets.
Classes in other packages (for example, classes in the <TT>sun</TT>
or <TT>netscape</TT> packages) may
be available only in specific implementations.
<LI>By default, your Java classes have access to only the classes
in <TT>java.lang</TT> (the base language
package inside the <TT>java</TT> package).
To use classes from any other package, you have to either refer
to them explicitly by package name or import them into your source
file.
<LI>To refer to a class within a package, list all the packages
that class is contained in and the class name, all separated by
periods (<TT>.</TT>). For example,
take the <TT>Color</TT> class, which
is contained in the <TT>awt</TT> package
(<TT>awt</TT> stands for Abstract
Windowing Toolkit). The <TT>awt</TT>
package, in turn, is inside the <TT>java</TT>
package. To refer to the <TT>Color</TT>
class in your program, you use the notation <TT>java.awt.Color</TT>.
</UL>
<H3><A NAME="CreatingaSubclass">
Creating a Subclass</A></H3>
<P>
To finish up today, let's create a class that is a subclass of
another class and override some methods. You'll also get a basic
feel for how packages work in this example.
<P>
Probably the most typical instance of creating a subclass, at
least when you first start programming in Java, is creating an
applet. All applets are subclasses of the class <TT>Applet</TT>
(which is part of the <TT>java.applet</TT>
package). By creating a subclass of <TT>Applet</TT>,
you automatically get all the behavior from the window toolkit
and the layout classes that enable your applet to be drawn in
the right place on the page and to interact with system operations,
such as keypresses and mouse clicks.
<P>
In this example, you'll create an applet similar to the Hello
World applet from yesterday, but one that draws the <TT>Hello</TT>
string in a larger font and a different color. To start this example,
let's first construct the class definition itself. Let's go to
your text editor, and enter the following class definition:
<BLOCKQUOTE>
<PRE>
public class HelloAgainApplet extends java.applet.Applet {

}
</PRE>
</BLOCKQUOTE>
<P>
Here, you're creating a class called <TT>HelloAgainApplet</TT>.
Note the part that says <TT>extends java.applet.Applet</TT>-that's
the part that says your applet class is a subclass of the <TT>Applet</TT>
class. Note that because the <TT>Applet</TT>
class is contained in the <TT>java.applet</TT>
package, you don't have automatic access to that class, and you
have to refer to it explicitly by package and class name.
<P>
The other part of this class definition is the <TT>public</TT>
keyword. Public means that your class is available to the Java
system at large once it is loaded. Most of the time you need to
make a class <TT>public</TT> only
if you want it to be visible to all the other classes in your
Java program, but applets, in particular, must be declared to
be public. (You'll learn more about <TT>public</TT>
classes in Week 3.)
<P>
A class definition with nothing in it doesn't really have much
of a point; without adding or overriding any of its superclasses'
variables or methods, there's no reason to create a subclass at
all. Let's add some information to this class, inside the two
enclosing braces, to make it different from its superclass.
<P>
First, add an instance variable to contain a <TT>Font</TT>
object:
<BLOCKQUOTE>
<PRE>
Font f = new Font(&quot;TimesRoman&quot;, Font.BOLD, 36);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>f</TT> instance variable now
contains a new instance of the class <TT>Font</TT>,
part of the <TT>java.awt</TT> package.
This particular <TT>Font</TT> object
is a Times Roman font, boldface, 36 points high. In the previous
Hello World applet, the font used for the text was the default
font: 12-point Times Roman. Using a <TT>Font</TT>
object, you can change the font of the text you draw in your applet.
<P>
By creating an instance variable to hold this font object, you
make it available to all the methods in your class. Now let's
create a method that uses it.
<P>
When you write applets, there are several &quot;standard&quot;
methods defined in the applet superclasses that you will commonly
override in your applet class. These include methods to initialize
the applet, to make it start running, to handle operations such
as mouse movements or mouse clicks, or to clean up when the applet
stops running. One of those standard methods is the <TT>paint()</TT>
method, which actually displays your applet onscreen. The default
definition of <TT>paint()</TT> doesn't
do anything-it's an empty method. By overriding <TT>paint()</TT>,
you tell the applet just what to draw on the screen. Here's a
definition of <TT>paint()</TT>:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {
    g.setFont(f);
    g.setColor(Color.red);
    g.drawString(&quot;Hello again!&quot;, 5, 40);
}
</PRE>
</BLOCKQUOTE>
<P>
There are two things to know about the <TT>paint()</TT>
method. First, note that this method is declared <TT>public</TT>,
just as the applet itself was. The <TT>paint()</TT>
method is actually <TT>public</TT>
for a different reason-because the method it's overriding is also
<TT>public</TT>. If a superclass's
method is defined as <TT>public</TT>,
your override method also has to be <TT>public</TT>,
or you'll get an error when you compile the class.
<P>
Second, note that the <TT>paint()</TT>
method takes a single argument: an instance of the <TT>Graphics</TT>
class. The <TT>Graphics</TT> class
provides platform-independent behavior for rendering fonts, colors,
and behavior for drawing basic lines and shapes. You'll learn
a lot more about the <TT>Graphics</TT>
class in Week 2, when you create more extensive applets.
<P>
Inside your <TT>paint()</TT> method,
you've done three things:
<UL>
<LI>You've told the graphics object that the default drawing font
will be the one contained in the instance variable <TT>f</TT>.
<LI>You've told the graphics object that the default color is
an instance of the <TT>Color</TT>
class for the color red.
<LI>Finally, you've drawn your <TT>&quot;Hello
Again!&quot;</TT> string onto the screen, at the <TT>x</TT>
and <TT>y</TT> positions of <TT>5</TT>
and <TT>25</TT>. The string will be
rendered in the new font and color.
</UL>
<P>
For an applet this simple, this is all you need to do. Here's
what the applet looks like so far:
<BLOCKQUOTE>
<PRE>
public class HelloAgainApplet extends java.applet.Applet {

  Font f = new Font(&quot;TimesRoman&quot;,Font.BOLD,36);

  public void paint(Graphics g) {
    g.setFont(f);
    g.setColor(Color.red);
    g.drawString(&quot;Hello again!&quot;, 5, 40);
  }
}
</PRE>
</BLOCKQUOTE>
<P>
If you've been paying close attention, you'll notice that something
is wrong with this example up to this point. If you don't know
what it is, try saving this file (remember, save it to the same
name as the class: <TT>HelloAgainApplet.java</TT>)
and compiling it. You should get a bunch of errors similar to
this one:
<BLOCKQUOTE>
<PRE>
HelloAgainApplet.java:7: Class Graphics not found in type declaration.
</PRE>
</BLOCKQUOTE>
<P>
Why are you getting these errors? Because the classes you're referring
to in this class, such as <TT>Graphics</TT>
and <TT>Font</TT>, are part of a package
that isn't available by default. Remember that the only package
you have access to automatically in your Java programs is <TT>java.lang</TT>.
You referred to the <TT>Applet</TT>
class in the first line of the class definition by referring to
its full package name (<TT>java.applet.Applet</TT>).
Further on in the program, however, you referred to all kinds
of other classes as if they were available. The compiler catches
this and tells you that you don't have access to those other classes.
<P>
There are two ways to solve this problem: Refer to all external
classes by full package name or import the appropriate class or
package at the beginning of your class file. Which one you choose
to do is mostly a matter of choice, although if you find yourself
referring to a class in another package lots of times, you may
want to import it to cut down on the amount of typing.
<P>
In this example, you'll import the classes you need. There are
three of them: <TT>Graphics</TT>,
<TT>Font</TT>, and <TT>Color</TT>.
All three are part of the <TT>java.awt</TT>
package. Here are the lines to import these classes. These lines
go at the top of your program, before the actual class definition:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;
import java.awt.Font;
import java.awt.Color;<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You also can import an entire package of <TT>public</TT> classes by using an asterisk (<TT>*</TT>) in place of a specific class name. For example, to import all the classes in the <TT>awt</TT> package, you can use this line:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.awt.*;</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now, with the proper classes imported into your program, <TT>HelloAgainApplet.java</TT>
should compile cleanly to a class file. Listing 2.4 shows the
final version to double-check.
<HR>
<BLOCKQUOTE>
<B>Listing 2.4. The final version of </B><TT><B>HelloAgainApplet.java</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.awt.Graphics;
 2:import java.awt.Font;
 3:import java.awt.Color;
 4:
 5:public class HelloAgainApplet extends java.applet.Applet {
 6:
 7:  Font f = new Font(&quot;TimesRoman&quot;,Font.BOLD,36);
 8:
 9:  public void paint(Graphics g) {
10:    g.setFont(f);
11:    g.setColor(Color.red);
12:    g.drawString(&quot;Hello again!&quot;, 5, 40);
13:  }
14:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
To test it, create an HTML file with the <TT>&lt;APPLET&gt;</TT>
tag as you did yesterday. Here's an HTML file to use:
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Another Applet&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;My second Java applet says:
&lt;BR&gt;&lt;APPLET CODE=&quot;HelloAgainApplet.class&quot; WIDTH=200 HEIGHT=50&gt;
&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<P>
For this HTML example, your Java class file is in the same directory
as this HTML file. Save the file to <TT>HelloAgainApplet.html</TT>
and fire up your Java-enabled browser or the Java applet viewer.
Figure 2.7 shows the result you should be getting (the <TT>&quot;Hello
Again!&quot;</TT> string is red).
<P>
<A HREF="http://docs.rinet.ru/J21/f2-7.gif"><B>Figure 2.7 : </B><I>The </I><TT>HelloAgain</TT><I>
applet</I>.</A>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
If this is your first encounter with object-oriented programming,
a lot of the information in this lesson is going to seem really
theoretical and overwhelming. Fear not-the further along in this
book you get, and the more Java classes and applications you create,
the easier it is to understand.
<P>
One of the biggest hurdles of object-oriented programming is not
necessarily the concepts; it's their names. OOP has lots of jargon
surrounding it. To summarize today's material, here's a glossary
of terms and concepts you learned today:
<BLOCKQUOTE>
<I>class</FONT></I>:</FONT>
A template for an object, which contains variables and methods
representing behavior and attributes. Classes can inherit variables
and methods from other classes.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>class method:</FONT></I> A method
defined in a class, which operates on the class itself and can
be called via the class or any of its instances.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>class variable</FONT></I>:
</FONT>A variable that is &quot;owned&quot; by the class and all
its instances as a whole and is stored in the class.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>instance</FONT></I>:</FONT>
The same thing as an object; each object is an instance of some
class.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>instance method</FONT></I>:</FONT>
A method defined in a class, which operates on an instance of
that class. Instance methods are usually called just methods</FONT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>instance variable</FONT></I>:
</FONT>A variable that is owned by an individual instance and
whose value is stored in the instance.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>interface</FONT></I>:
</FONT>A collection of abstract behavior specifications that individual
classes can then implement.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>object</FONT></I>:</FONT>
A concrete instance of some class. Multiple objects that are instances
of the same class have access to the same methods, but often have
different values for their instance variables.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>package</FONT></I>:
</FONT>A collection of classes and interfaces. Classes from packages
other than <TT>java.lang</TT> must
be explicitly imported or referred to by full package name.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>subclass</FONT></I>:</FONT>
A class lower in the inheritance hierarchy than its parent, the
superclass. When you create a new class, it's often called subclassing</FONT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>superclass</FONT></I>:</FONT>
A class further up in the inheritance hierarchy than its child,
the subclass.
</BLOCKQUOTE>
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Methods are effectively functions that are defined inside classes. If they look like functions and act like functions, why aren't they called functions?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Some object-oriented programming languages do call them functions (C++ calls them member functions). Other object-oriented languages differentiate between functions inside and outside a body of 
a class or object, where having separate terms is important to understanding how each works. Because the difference is relevant in other languages and because the term method is now in such common use in object-oriented technology, Java uses the word as 
well.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I understand instance variables and methods, but not the idea of class variables and methods.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Most everything you do in a Java program will be with objects. Some behaviors and attributes, however, make more sense if they are stored in the class itself rather than in the object. For 
example, to create a new instance of a class, you need a method that is defined and available in the class itself. (Otherwise, how can you create an object? You need an object to call the method, but you don't have an object yet.) Class variables, on the 
other hand, are often used when you have an attribute whose value you want to share with all the instances of a class.
<P>
Most of the time, you'll use instance variables and methods. You'll learn more about class variables and methods later this week.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch1.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
