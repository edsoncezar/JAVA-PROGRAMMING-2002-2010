<HTML>
<HEAD>
<TITLE>Day 20 -- Using Native Methods and Libraries</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;20</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Using Native Methods and Libraries</FONT>
</H1>
<P>
<I><B>by Laura Lemay and Charles L. Perkins</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#WhyUseNativeMethods">
Why Use Native Methods?</A>
<UL>
<LI><A HREF="#AdvantagesofUsingNativeMethods">
Advantages of Using Native Methods</A>
</UL>
<LI><A HREF="#DisadvantagesofNativeMethods">
Disadvantages of Native Methods</A>
<LI><A HREF="#TheIllusionofRequiredEfficiency">
The Illusion of Required Efficiency</A>
<UL>
<LI><A HREF="#DesignFirstEfficiencyLater">
Design First, Efficiency Later</A>
<LI><A HREF="#JustinTimeCompilers">
Just-in-Time Compilers</A>
<LI><A HREF="#SimpleOptimizationTricks">
Simple Optimization Tricks</A>
</UL>
<LI><A HREF="#WritingNativeMethods">
Writing Native Methods</A>
<UL>
<LI><A HREF="#WriteYourJavaCode">
Write Your Java Code</A>
<LI><A HREF="#GenerateHeaderandStubFiles">
Generate Header and Stub Files</A>
<LI><A HREF="#ImplementingtheNativeLibrary">
Implementing the Native Library</A>
<LI><A HREF="#UsingYourLibrary">
Using Your Library</A>
</UL>
<LI><A HREF="#ToolsandTechniquesforWritingNativeImplementations">
Tools and Techniques for Writing Native Implementations</A>
<UL>
<LI><A HREF="#Names">
Names</A>
<LI><A HREF="#AccessingJavaObjects">
Accessing Java Objects</A>
<LI><A HREF="#CallingMethods">
Calling Methods</A>
<LI><A HREF="#CreatingNewJavaObjects">
Creating New Java Objects</A>
<LI><A HREF="#HandlingExceptions">
Handling Exceptions</A>
<LI><A HREF="#DealingwithStrings">
Dealing with Strings</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Up to this point in the book you've been learning specifically
about programming in the Java language and with the Java class
libraries. That's why this book is called <I>Teach Yourself Java,</I>
after all. Today I'm going to digress a little bit and talk about
native methods and libraries.
<P>
<I>Native</I> methods and libraries are bits of executable code
that are written in the traditional way: They are written in a
language such as C or C++ and compiled into a platform-specific
library such as a DLL or a shared library. Inside your Java applications
you can gain access to the functions inside those libraries, allowing
you to create a sort of hybrid Java and native code application.
Although using native methods can give you some extra benefits
Java does not provide (such as faster execution or access to a
large body of existing code), there are significant disadvantages
in using native methods as well.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Native methods</I> and <I>native libraries</I> are bits of platform-specific executable code (written in languages such as C or C++) contained in libraries or DLLs. You can create a hybrid Java application that has access to those native libraries.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Today's lesson covers various topics relating to native methods,
including the following:
<UL>
<LI>The advantages and disadvantages of using native methods
<LI>Why using native methods for speed or efficiency is often
unnecessary
<LI>The steps for creating native methods, header and stub files,
and native implementations, and linking it all together
<LI>Various functions and utilities for mapping between Java and
C and C++
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In today's lesson you'll learn the basic techniques for writing native methods in the current version of Java. For the Java 1.1 release, Sun will publish further guidelines for writing native methods to help make sure that native implementations will work 
between different versions of the Java runtime. These guidelines will be in addition to the technique you will learn in today's lesson, and will build on the skills you learn here.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="WhyUseNativeMethods"><FONT SIZE=5 COLOR=#FF0000>
Why Use Native Methods?</FONT></A></H2>
<P>
Before I get into the nitty-gritty details of creating native
methods, you should first be aware of what native methods give
you-and what they take away. Although native methods provide some
advantages, those advantages may not appear too exciting when
viewed in light of native methods' disadvantages. This section
describes both.
<H3><A NAME="AdvantagesofUsingNativeMethods">
Advantages of Using Native Methods</A></H3>
<P>
There are several reasons that you might want to consider using
native methods in your own Java programs. By far the best of these
reasons are
<UL>
<LI>Gaining access to special capabilities of your computer or
operating system
<LI>Needing the extra speed that native methods provide
<LI>Needing access to a large body of existing code
</UL>
<P>
The first, and by far the best, reason to implement native methods
is because you need to utilize a special capability of your computer
or operating system that the Java class library does not already
provide for you. Such capabilities include interfacing to new
peripheral devices or plug-in cards, accessing a different type
of networking, or using a unique, but valuable feature of your
particular operating system. Two more concrete examples are acquiring
real-time audio input from a microphone or using 3D &quot;accelerator&quot;
hardware in a 3D library. Neither of these is provided to you
by the current Java environment, so you must implement them outside
Java, in some other language (currently C or any language that
can link with C).
<P>
The second, and often illusory, reason to use native methods is
speed. The argument has been made that because interpreted bytecode
is terribly slow in comparison to how quickly native code runs
(and it is far slower, as much as 25 times slower), Java code
is unsuitable for most applications. In many cases this simply
isn't true, or you may be able to extract a fair amount of speed
out of your Java program without resorting to native methods (as
we'll explore in greater detail later in today's lesson). If,
however, your Java application uses very processor-intensive calculations
(for example, number crunching or 3D rendering), using native
methods for the speed-critical functions and Java for the more
general interfaces creates a system with more benefits than a
system written in either pure native code or pure Java. In fact,
the Java class library uses this approach for many critical system
classes to raise the overall level of efficiency in the system.
As a user of the Java environment, you don't even know (or see)
any side effects of this (except, perhaps, a few classes or methods
that are <TT>final</TT> that might
not be otherwise).
<P>
The third reason to use native classes is if your project has
a large body of existing code (what's called <I>legacy code</I>,
which may be hundreds of lines of code written and maintained
by other people over the years). As a good Java programmer and
advocate you would, of course, want to port this large body of
code to Java. However, real-life considerations of time and resources
often don't allow this option. Native methods allow you to write
a single interface to that code through Java and link into the
existing code as it's needed. 
<H2><A NAME="DisadvantagesofNativeMethods"><FONT SIZE=5 COLOR=#FF0000>
Disadvantages of Native Methods</FONT></A></H2>
<P>
After reading the advantages of using native methods, you may
be all set to jump to the section on how to use them and skip
this section. Don't. For every good thing native methods provide
in your Java code, they take away a benefit that Java provides
in the first place: the ability for your code to run anywhere
and be easily ported from one system to another.
<P>
Using pure Java, an application or applet can be run on any Java
environment in the world by downloading it via the Web or by simply
loading the class file on that system. Any new architectures created-or
new operating systems written-are irrelevant to your code. All
you need is that the (tiny) Java Virtual Machine (or a browser
that has one inside it) be available, and it can run anywhere,
anytime-now and in the future.
<P>
With a hybrid Java and native method program, however, you've
given up that cross-platform capability. First of all, Java programs
that use native methods cannot be applets. Period. For security
reasons, applets cannot load native code. So if you use native
methods, you've just removed the enormous number of users on the
World Wide Web from your market.
<P>
Even if you're just creating a Java application, however, and
don't intend your code to be run on the Web, using native methods
also negates the capability of your program to run on any platform.
Native code is, by definition, platform specific. The native code
must exist on the platform your Java program is running on for
that program to work. For your program to work on different platforms,
you'll have to port your native code to that specific platform-which
may not be a trivial task. And as new systems or new versions
of operating systems appear, you may have to update or re-release
new versions of that native code for every system. The write-it-once-run-it-everywhere
advantage of Java ceases to exist when you use native methods.
<H2><A NAME="TheIllusionofRequiredEfficiency"><FONT SIZE=5 COLOR=#FF0000>
The Illusion of Required Efficiency</FONT></A></H2>
<P>
Let's digress for a moment and talk about the concept of speed
and efficiency of Java programs-or the supposed lack thereof,
which may drive you to using native code in your Java programs.
<P>
Java bytecode has acquired the reputation of being extraordinarily
slow to run in comparison with native executable code. And, examining
the benchmarks, Java bytecode is indeed very much slower-as much
as 25 times slower. However, that doesn't necessarily make a Java
program unbearable to use. Simple applets or applications that
rely on user interface elements will appear to run just as fast
as their native equivalents. Button clicks are just as fast in
Java as they are in native code, and your users are very slow
compared to modern computers. It's only in the case of very processor-intensive
operations that Java starts to come up short in comparison to
native code.
<P>
At any rate, worrying over the speed of your Java programs before
you write them is often a rathole that can distract you from the
larger issues. In this section I'll look at both those larger
issues and at the solutions that can make your Java programs run
faster.
<H3><A NAME="DesignFirstEfficiencyLater">
Design First, Efficiency Later</A></H3>
<P>
When you design your program, all your energy and creativity should
be directed at the design of a tight, concise, minimal set of
classes and methods that are maximally general, abstract, and
reusable. (If you think that is easy, look around for a few years
and see how bad most software is.) If you spend most of your programming
time on thinking and rethinking these fundamental goals and how
to achieve them, you are preparing for the future-a future where
software is assembled as needed from small components swimming
in a sea of network facilities, and anyone can write a component
seen by millions (and reused in their programs) in minutes. If,
instead, you spend your energy worrying about the speed your software
will run <I>right now</I> on some computer, your work will be
irrelevant after the 18 to 36 months it will take hardware to
be fast enough to hide that minor inefficiency in your program.
<P>
So you should ignore efficiency altogether? Of course not! Some
of the great algorithms of computer science deal with solving
hard or &quot;impossible&quot; problems in reasonable amounts
of time-and writing your programs carelessly can lead to remarkably
slow results. Carelessness, however, can as easily lead to incorrect,
fragile, or nonreusable results. If you correct all these latter
problems first, the resulting software will be clean, will naturally
reflect the structure of the problem you're trying to solve, and
thus will be amenable to &quot;speeding up&quot; later.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There are always cases where you <I>must</I> be fanatical about efficiency in many parts of a set of classes. The Java class library itself is such a case, as is anything that must run in real-time for some critical real-world application (such as flying a 
plane). Such applications are rare, however.
</BLOCKQUOTE>
<BLOCKQUOTE>
When speaking of a new kind of programming that must soon emerge, Bill Joy likes to invoke the four S's of Java: small, simple, safe, and secure. The &quot;feel&quot; of the Java language itself encourages the pursuit of clarity and the reduction of 
complexity. The intense pursuit of efficiency, which increases complexity and reduces clarity, is antithetical to these goals.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Once you build a solid foundation, debug your classes, and your
program (or applet) works as you'd like it to, <I>then </I>it's
time to begin optimizing it.
<H3><A NAME="JustinTimeCompilers">
Just-in-Time Compilers</A></H3>
<P>
The first thing to keep in mind about the execution speed of Java
is that lots of people are working on fixing it. And the most
promising of these technical advancements is the just-in-time
(JIT) compiler. 
<P>
<I>Just-in-time compilers</I> translate Java bytecode into native
machine code on-the-fly as the bytecode is running. Depending
on how good the JIT compiler is, you can often get very close
to native execution speeds out of a standard Java program-without
needing to use native code and without needing to make any modifications
to your Java program-it just works. 
<P>
The disadvantage, however, is that to get the speed increase your
Java program must be run on a platform that has a JIT compiler
installed. At the time of this writing, JIT compilers are still
new. Many companies are working on JIT compilers, however, and
most of them have versions working or bundled in with development
tools so you can experiment with their power. Microsoft's Internet
Explorer Web browser, for example, has a JIT compiler built into
it. (You'll learn more about the available JIT compilers are expected
on <A HREF="ch22.htm">Day 22</A>, &quot;Java Programming Tools.&quot;) JIT compilers
are expected to become much more popular and widespread over the
next year.
<H3><A NAME="SimpleOptimizationTricks">
Simple Optimization Tricks</A></H3>
<P>
In addition to relying on JIT technology to speed up your Java
programs, there are usually simple optimization tricks you can
do to make your programs run more efficiently. Your development
environment may even provide a <I>profiler</I>, which tells you
where the slowest or more frequently run portions of your program
are occurring. Even if you don't have a profiler, you can often
use debugging tools to find the bottlenecks in your programs and
begin to make targeted changes to your classes.
<P>
Whole books have been written for optimizing various bits of code
in any language, and they can describe it much better than we
can. But there are a few simple tricks you can try for the first
pass. 
<P>
First, identify the crucial few methods that take most of the
time (there are almost always just a few, and often just one,
that take up the majority of your program's time). If those methods
contain loops, examine the inner loops to see whether they
<UL>
<LI>Call methods that can be made <TT>final</TT>
<LI>Call a group of methods that can be collapsed into a single
method
<LI>Create objects that can be reused rather than created anew
for each loop
</UL>
<P>
If you notice that a long chain of, for example, four or more
method calls is needed to reach a destination method's code, <I>and</I>
this execution path is in one of the critical sections of the
program, you can &quot;short-circuit&quot; directly to that destination
method in the topmost method. This may require adding a new instance
variable to reference the object for that method call directly.
This quite often violates layering or encapsulation constraints.
This violation, and any added complexity, is the price you pay
for efficiency.
<H2><A NAME="WritingNativeMethods"><FONT SIZE=5 COLOR=#FF0000>
Writing Native Methods</FONT></A></H2>
<P>
If, after all these tricks, your Java code is still <I>just too
slow</I>, it's time to consider using native methods. In this
section you'll learn the steps you must take to write your Java
code so that it uses native methods, how to write the native code
to implement those native methods, and how to compile and link
it all together so it works. This involves four basic steps:
<UL>
<LI>Write your Java code so that the methods that will be native
have special declarations using the <TT>native</TT>
modifier.
<LI>Compile your Java code and use the <TT>javah</TT>
program to generate special header and stub files, which make
up the starting point for your native code.
<LI>Write your native implementations of the native methods.
<LI>Compile all the native files into a shared library or DLL
and run your Java program.
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This discussion-and, in fact, the JDK itself-assumes that you'll be writing your native code in C and C++. Other Java development environments may support other languages.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="WriteYourJavaCode">
Write Your Java Code</A></H3>
<P>
The first step to implementing native methods is to decide which
methods in which classes of your Java program will be native.
The mapping between Java and native libraries is through methods
(functions), so designing your Java code and keeping track of
which methods are native is the most important first step.
<P>
To declare that a method will be native inside your Java code,
you add the <TT>native</TT> modifier
to that method signature, like this:
<BLOCKQUOTE>
<PRE>
public native void goNative(int x, int y);<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>native</TT> modifier can be used with many of the modifiers you learned about on <A HREF="ch15.htm">Day 15</A>, &quot;Modifiers, Access Control, and Class Design,&quot; including <TT>public</TT>, <TT>private</TT>, <TT>protected</TT>, 
<TT>final</TT>, and so on. It cannot be used with <TT>abstract</TT> because abstract methods do not have definitions, native or otherwise.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Note also that the native method in your Java code has no method
body. Because this is a native method, its implementation will
be provided by the native code, not by Java. Just add a semicolon
to the end of the line.
<P>
The other change you'll have to make to your Java code is to explicitly
load the native library that will contain the native code for
these methods. To do this, you add the following boilerplate code
to your Java class:
<BLOCKQUOTE>
<PRE>
static {
    System.loadLibrary(&quot;libmynativelibrary.so&quot;);
</FONT>}
</PRE>
</BLOCKQUOTE>
<P>
This bit of code, called a <I>static initializer</I>, is used
to run code only once when the class is first loaded into the
system. In this case, the static initializer executes the <TT>System.loadLibrary()</TT>
method to load in your native library as the class itself is being
loaded. If the native library fails to load for some reason, the
loading of the Java class fails as well, guaranteeing that no
half-set-up version of the class can ever be created.
<P>
You can pick any name you want for your native library-here we've
used the UNIX convention that libraries start with the word <TT>lib</TT>
and end with the extension <TT>.so</TT>.
For Windows systems, libraries typically end with the extension
<TT>.DLL</TT>.
<P>
You can also use the <TT>System.load()</TT>
method to load your native libraries. The difference is that the
single argument to <TT>load()</TT>
is the complete pathname to your native library, whereas the argument
to <TT>loadLibrary()</TT> is just
the library name, and Java uses the standard way of finding libraries
for your system to locate that library (usually environment variables
such as <TT>LD_LIBRARY_PATH</TT>).
The latter is more flexible and general-purpose, so it's recommended
you use it instead.
<P>
And that's all you need to do in your Java code to create native
methods and libraries. Subclasses of any class containing your
new <TT>native</TT> methods can still
override them, and these new (Java) methods are called for instances
of the new subclasses (just as you'd expect).
<P>
Listing 20.1 shows an example of a Java program called <TT>SimpleFile</TT>
that was written to use native methods. This program might be
used in a version of the Java environment that does not provide
file input or output (I/O). Because file I/O is typically system-dependent,
native methods must be used to implement those operations.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This example combines simplified versions of two actual Java library classes, <TT>java.io.File</TT> and <TT>java.io.RandomAccessFile</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 20.1. </B><TT><B>SimpleFile</B></TT><B>,
a Java program that uses native methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: public class  SimpleFile {
 2:     public static final  char    separatorChar = '&gt;';
 3:     protected    String  path;
 4:     protected    int     fd;
 5: 
 6:     public  SimpleFile(String s) {
 7:         path = s;
 8:     }
 9: 
10:     public String  getFileName() {
11:         int  index = path.lastIndexOf(separatorChar);
12: 
13:         return (index &lt; 0) ? path : path.substring(index + 1);
14:     }
15: 
16:     public String  getPath() {
17:         return path;
18:     }
19: 
20:     public native boolean  open();
21:     public native void     close();
22:     public native int      read(byte[]  buffer, int  length);
23:     public native int      write(byte[]  buffer, int  length);
24: 
25:     static {
26:         System.loadLibrary(&quot;simple&quot;);  // runs when class first loaded
27:     }
</FONT>28: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first thing you notice about <TT>SimpleFile</TT>'s
implementation is how unremarkable the first two-thirds of its
Java code is! It looks just like any other class, with a class
and an instance variable, a constructor, and two normal method
implementations (<TT>getFileName()</TT>
and <TT>getPath()</TT>). Then, in
lines 20 through 23, there are four <TT>native</TT>
method declarations, which are just normal method declarations
with the code block replaced by a semicolon and the modifier <TT>native</TT>
added. These are the methods you have to implement in C code later.
<P>
Finally, note the call to <TT>System.loadLibrary()</TT>
in line 26, which loads a native library called <TT>simple</TT>.
(We've intentionally violated library-naming standards here to
make this example simpler.)<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The unusual <TT>separatorChar</TT> (<TT>'&gt;'</TT>) is used simply to demonstrate what an implementation might look like on some strange computer whose file system didn't use any of the more common path-separator conventions. Early Xerox computers used 
<TT>'&gt;'</TT> as a separator, and several existing computer systems still use strange separators today, so this is not all that farfetched.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
After you write the native part of your Java program, <TT>SimpleFile</TT>
objects can be created and used in the usual way:
<BLOCKQUOTE>
<PRE>
SimpleFile  f = new SimpleFile(&quot;&gt;some&gt;path&gt;and&gt;fileName&quot;);

f.open();
f.read(...);
f.write(...);
</FONT>f.close();
</PRE>
</BLOCKQUOTE>
<H3><A NAME="GenerateHeaderandStubFiles">
Generate Header and Stub Files</A></H3>
<P>
The second step to implementing native code is to generate a special
set of header and stub files for use by your C or C++ files that
implement those native methods. To generate these header and stub
files, you use the <TT>javah</TT>
program, which is part of the JDK (it's called <TT>JavaH</TT>
in the Mac JDK).
<P>
First, you'll need to compile your Java program as you would any
other Java program, using the Java compiler.
<H4>Header Files</H4>
<P>
To generate the headers you need for your native methods, use
the <TT>javah</TT> program. For the
<TT>SimpleFile</TT> class listed in
the previous section, use one of the following:
<P>
To generate header files for a class, use the <TT>javah</TT>
program with the name of the class file, minus the <TT>.class</TT>
extension. For example, to generate the header file for the <TT>SimpleFile</TT>
class, use this command line:
<BLOCKQUOTE>
<PRE>
javah SimpleFile
</PRE>
</BLOCKQUOTE>
<P>
To generate the header file for the <TT>SimpleFile</TT>
class, drag-and-drop the class file onto the JavaH icon.
<P>
The file <TT>SimpleFile.h</TT> will
be created in the same directory as the <TT>SimpleFile.class</TT>
file.
<P>
Note that if the class you've given to <TT>javah</TT>
is inside a package, <TT>javah</TT>
prepends the package's full name to the header filename (and to
the structure names it generates inside that file) with all the
dots (<TT>.</TT>) replaced by underscores
(<TT>_</TT>). If <TT>SimpleFile</TT>
had been contained in a hypothetical package called <TT>acme.widgets.files</TT>,
<TT>javah</TT> would have generated
a header file named <TT>acme_widgets_files_SimpleFile.h</TT>,
and the various names within it would have been renamed in a similar
manner.
<P>
Listing 20.2 shows the header file that is generated by <TT>javah</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 20.2. </B><TT><B>SimpleFile.h</B></TT><B>
(a header file).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: #include &lt;native.h&gt;
 2: /* Header for class SimpleFile */
 3: 
 4: #ifndef _Included_SimpleFile
 5: #define _Included_SimpleFile
 6: struct Hjava_lang_String;
 7: 
 8: typedef struct ClassSimpleFile {
 9: #define SimpleFile_separatorChar 62L
10:     struct Hjava_lang_String *path;
11:     long fd;
12: } ClassSimpleFile;
13: HandleTo(SimpleFile);
14: 
15: #ifdef __cplusplus
16: extern &quot;C&quot; {
17: #endif
18: extern /*boolean*/ long SimpleFile_open(struct HSimpleFile *);
19: extern void SimpleFile_close(struct HSimpleFile *);
20: extern long SimpleFile_read(struct HSimpleFile *,HArrayOfByte *,long);
21: extern long SimpleFile_write(struct HSimpleFile *,HArrayOfByte *,long);
22: #ifdef __cplusplus
23: }
24: #endif
</FONT>25: #endif
</PRE>
</BLOCKQUOTE>
<HR>
<P>
There are a few things to note about this header file. First,
note the <TT>struct</TT> <TT>ClassSimpleFile</TT>,
which contains variables that parallel the instance variables
inside your class. Second, note the method signatures at the end
of the file; these are the function definitions you'll use in
your C or C++ file to implement the actual native methods in the
Java code.
<H4>Stub Files</H4>
<P>
To &quot;run interference&quot; between the Java world of objects,
arrays, and other high-level constructs and the lower-level world
of C, you need stubs, which translate arguments and return values
between Java and C.
<P>
<I>Stubs </I> are pieces of  &quot;glue&quot; code that tie together
Java and C. Stubs translate arguments and values and convert the
various constructs in each language to something that can be understood
in the other. 
<P>
Stubs can be automatically generated by <TT>javah</TT>,
just like headers. There isn't much you need to know about the
stub file, just that it has to be compiled and linked with the
C code you write to allow it to interface properly with Java.
<P>
To create stub files, you also use the <TT>javah</TT>
program:
<P>
Use the <TT>javah</TT> program with
the <TT>-stubs</TT> option to create
the stub file:
<BLOCKQUOTE>
<PRE>
javah -stubs SimpleFile
</PRE>
</BLOCKQUOTE>
<P>
The file <TT>SimpleFile.c</TT> will
be generated in the same directory as the class file.
<P>
The stub file was generated at the same time you created the header
file.
<P>
Listing 20.3 shows the result of the stub file for the <TT>SimpleFile</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 20.3. </B><TT><B>SimpleFile.c</B></TT><B>
(a stub file).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:/* DO NOT EDIT THIS FILE - it is machine generated */
 2:#include &lt;StubPreamble.h&gt;
 3: 
 4:/* Stubs for class SimpleFile */
 5:/* SYMBOL: &quot;SimpleFile/open()Z&quot;, Java_SimpleFile_open_stub */
 6:__declspec(dllexport) stack_item *Java_SimpleFile_open_stub(stack_item *_P_,
 7:    struct execenv *_EE_) {
 8:        extern long SimpleFile_open(void *);
 9:        _P_[0].i = (SimpleFile_open(_P_[0].p) ? TRUE : FALSE);
10:        return _P_ + 1;
11:}
12:/* SYMBOL: &quot;SimpleFile/close()V&quot;, Java_SimpleFile_close_stub */
13:__declspec(dllexport) stack_item *Java_SimpleFile_close_stub(stack_item *_P_,
14:    struct execenv *_EE_) {
15:        extern void SimpleFile_close(void *);
16:        (void) SimpleFile_close(_P_[0].p);
17:        return _P_;
18:}
19:/* SYMBOL: &quot;SimpleFile/read([BI)I&quot;, Java_SimpleFile_read_stub */
20:__declspec(dllexport) stack_item *Java_SimpleFile_read_stub(stack_item *_P_,
21:    struct execenv *_EE_) {
22:        extern long SimpleFile_read(void *,void *,long);
23:        _P_[0].i = SimpleFile_read(_P_[0].p,((_P_[1].p)),((_P_[2].i)));
24:        return _P_ + 1;
25:}
26:/* SYMBOL: &quot;SimpleFile/write([BI)I&quot;, Java_SimpleFile_write_stub */
27:__declspec(dllexport) stack_item *Java_SimpleFile_write_stub(stack_item *_P_,
28:    struct execenv *_EE_) {
29:        extern long SimpleFile_write(void *,void *,long);
30:        _P_[0].i = SimpleFile_write(_P_[0].p,((_P_[1].p)),((_P_[2].i)));
31:        return _P_ + 1;
</FONT>32:}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ImplementingtheNativeLibrary">
Implementing the Native Library</A></H3>
<P>
The last step, and the most difficult, is to write the C code
for your native methods.
<P>
The header file generated by <TT>javah</TT>
gives you the prototypes of the functions you need to implement
to make your native code complete. You then write some C code
that implements those functions and provides the native facilities
that your Java class needs (in the case of <TT>SimpleFile</TT>,
some low-level file I/O routines).
<P>
You'll want to include your header file as part of the initial
<TT>include</TT>s for your native
implementation:
<BLOCKQUOTE>
<PRE>
#include &lt;SimpleFile.h&gt;<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This description glosses over a lot of what you might want to do to actually implement those methods. In particular, Java provides several utility functions that help your native methods interact with Java methods and classes and help map C and C++ 
constructs to their Java equivalents. We'll describe several of these functions later on in today's lesson in the section &quot;Tools and Techniques for Writing Native Implementations.&quot;</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Listing 20.4 shows the native implementation of the methods from
the <TT>SimpleFile</TT> class.
<HR>
<BLOCKQUOTE>
<B>Listing 20.4. </B><TT><B>SimpleFileNative.c</B></TT><B>,
a C implementation of a native method from </B><TT><B>SimpleFile</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: #include &quot;SimpleFile.h&quot;     /* for unhand(), among other things */
 2: 
 3: #include &lt;sys/param.h&gt;      /* for MAXPATHLEN */ 
 4: #include &lt;fcntl.h&gt;          /* for O_RDWR and O_CREAT */
 5: 
 6: #define LOCAL_PATH_SEPARATOR  '/'    /* UNIX */
 7: 
 8: static void  fixSeparators(char *p) { 
 9:     for (;  *p != '\0';  ++p)
10:         if (*p == SimpleFile_separatorChar) 
11:             *p = LOCAL_PATH_SEPARATOR;
12: }
13: 
14: long  SimpleFile_open(struct HSimpleFile  *this) { 
15:     int   fd;
16:     char  buffer[MAXPATHLEN];
17: 
18:     javaString2CString(unhand(this)-&gt;path, buffer, sizeof(buffer)); 
19:     fixSeparators(buffer);
20:     if ((fd = open(buffer, O_RDWR | O_CREAT, 0664)) &lt; 0)    /* UNIX open */
21:         return(FALSE);   /* or, SignalError() could &quot;throw&quot; an exception */
22:     unhand(this)-&gt;fd = fd;         /* save fd in the Java world */ 
23:     return(TRUE);
24: }
25: 
26: void  SimpleFile_close(struct HSimpleFile  *this) { 
27:     close(unhand(this)-&gt;fd);
28:     unhand(this)-&gt;fd = -1;
29: }
30: 
31: long  SimpleFile_read(struct HSimpleFile  *this, 
32:     HArrayOfByte  *buffer, _ long  count) {
33:     char  *data     = unhand(buffer)-&gt;body;  /* get array data   */ 
34:     int    len      = obj_length(buffer);    /* get array length */ 
35:     int    numBytes = (len &lt; count ? len : count);
36: 
37:     if ((numBytes = read(unhand(this)-&gt;fd, data, numBytes)) == 0) 
38:         return(-1);
39:     return(numBytes);       /* the number of bytes actually read */ 
40: }
41: 
42: long  SimpleFile_write(struct HSimpleFile  *this, 
43:     HArrayOfByte  *buffer,_ long  count) {
44:     char  *data = unhand(buffer)-&gt;body; 
45:     int    len  = obj_length(buffer);
46: 
47:     return(write(unhand(this)-&gt;fd, data, (len &lt; count ? len : count))); 
</FONT>48: }
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Compile Everything into a Shared Library</H4>
<P>
The final step is to compile all the <TT>.c</TT>
files, including the stub file and your native method files. Use
your favorite C compiler to compile and link those two files into
a shared library (a DLL on Windows). On some systems, you may
need to specify special compilation flags that mean &quot;make
it relocatable and dynamically linkable.&quot; (Those flags, if
they are required, may vary from system to system; check with
your compiler documentation for details.)<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=580><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=580>
<BLOCKQUOTE>
If you have several classes with <TT>native</TT> methods, you can include all their stubs in the same <TT>.c</TT> file, if you like. Of course you might want to name it something else, such as <TT>Stubs.c</TT>, in that case.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The resulting library should be the same name as you gave in your
original Java class file as the argument to <TT>System.loadLibrary()</TT>.
In the <TT>SimpleFile</TT> class,
that library was called <TT>libmynativelibrary.so</TT>.
You'll want to name the library that same name and install it
wherever your particular system needs libraries to be installed.
<H3><A NAME="UsingYourLibrary">
Using Your Library</A></H3>
<P>
With all the code written and compiled and installed in the right
place, all you have to do is run your Java program using the Java
bytecode interpreter. When the Java class is loaded, it will also
try to load the native library automatically; if it succeeds you
should be able to use the classes in your Java class, and they
will transparently run the native libraries as they are needed.
<P>
If you get an error that the library was not found, the most likely
problem is that you do not have your environment set up correctly
or that you have not installed your library in the right place.
<P>
DLL files are located according to the standard Windows algorithm:
the directory the application was located in, the current directory,
the System directory in Windows 95 (System32 in NT), the System
directory in NT, the Windows directory, and then directories listed
in the <TT>PATH</TT> environment variable.
<P>
UNIX systems use the environment variable <TT>LD_LIBRARY_PATH</TT>
to search for libraries. This environment variable should include
the standard places shared libraries are stored, as well as the
current directory (<TT>.</TT>). After
<TT>LD_LIBRARY_PATH</TT> has been
set, Java will be able to find your library.
<P>
Shared libraries for Java must be stored in the folder <TT>System
Folder: Extensions:JavaSoft Folder</TT>. Rather than copying
your native library there, you can also just create an alias to
your native library and put it in that folder.
<H2><A NAME="ToolsandTechniquesforWritingNativeImplementations"><FONT SIZE=5 COLOR=#FF0000>
Tools and Techniques for Writing Native Implementations</FONT></A></H2>
<P>
When writing the code for native implementations, a whole set
of useful macros and functions is available for mapping between
C and C++ and Java, and for accessing Java runtime structures.
(Several of them were used in <TT>SimpleFileNative.c</TT>.)
In addition, there are several rules and techniques for dealing
with the conversion between Java and C. In this section you'll
learn about those functions and techniques to make writing your
native code easier.
<H3><A NAME="Names">
Names</A></H3>
<P>
Java names for classes, methods, and variables can be used inside
native methods with the following changes (if needed):
<UL>
<LI>Any Unicode characters in names are converted to <TT>_0dddd</TT>,
where the <TT>d</TT>s represent the
Unicode number for that character. For example, the Unicode registered
trademark symbol, which is Unicode <TT>00ae</TT>,
would be represented in C as <TT>_000ae</TT>.
<LI>Package names are included with all names, with the dots replaced
by underscores (<TT>_</TT>). So, for
example, <TT>java.Math.pi</TT> would
be <TT>java_Math_pi</TT> from the
native side.
<LI>Slashes in package names, if any, are replaced by underscores.
<LI>Class names are renamed with the word <TT>Class</TT>
prepended to the full name (including package names) For example,
the Java class <TT>SimpleFile</TT>
would be <TT>ClassSimpleFile</TT>
(usually, however, you'll refer to classes through handles, which
are explained in the next section).
</UL>
<H3><A NAME="AccessingJavaObjects">
Accessing Java Objects</A></H3>
<P>
Java objects are passed to native methods using handles to structures.
The handle name is the name of the object (including any package
names), prepended with the letter <TT>H</TT>.
So, for example, the class <TT>SimpleFile</TT>
would have a handle called <TT>HSimpleFile</TT>.
The class <TT>java.lang.String</TT>
would convert to <TT>Hjava_lang.String</TT>
(remember, class names have package names included, with underscores
to separate them).
<P>
<I>Handles</I> are references to structures that represent Java
objects. Each handle has the same name as the class it references,
with the letter <TT>H</TT> prepended.
<P>
Each native function automatically gets passed at least one handle
in its parameter list. This is called the <I>automatic parameter</I>,
and it's a handle to the class that contained the original native
method. Even if the original name method has no arguments, the
C equivalent for that method is passed a handle to the class so
it can reference other parts of that object or pass data back
to it. In fact, because the handle to the original class behaves
as if it were the <TT>this</TT> object,
it's often called <TT>this</TT> in
the native code's method signature as well.
<P>
The <I>automatic parameter</I> is a handle to the original Java
class that called the native method. Because it is roughly equivalent
to <TT>this</TT> in Java, the automatic
parameter is also often called <TT>this</TT>.
<P>
Note the native method signature for the <TT>open()</TT>
method in <TT>SimpleFileNative.c</TT>,
which shows the automatic parameter:
<BLOCKQUOTE>
<PRE>
long  SimpleFile_open(struct HSimpleFile  *this)
</PRE>
</BLOCKQUOTE>
<P>
To get to the methods or variables inside a class, you must dereference
that class's handle. To do this, you can use the macro <TT>unhand()</TT>
(as in &quot;Unhand that object!&quot;). The <TT>unhand()</TT>
macro returns a pointer to a struct. So, for example, to get at
the variables inside the <TT>this</TT>
handle, you'd reference it like this:
<BLOCKQUOTE>
<PRE>
unhand(this);
</PRE>
</BLOCKQUOTE>
<P>
After the handle is dereferenced, you can access its variables
as if they were normal <TT>struct</TT>
elements:
<BLOCKQUOTE>
<PRE>
unhand(this)-&gt;path;
</PRE>
</BLOCKQUOTE>
<P>
References to arrays are slightly different than references to
objects, although both are passed as handles, and you can reference
their elements by &quot;unhanding&quot; them as well. In the case
of arrays, however, the name of the handle includes the words
<TT>ArrayOf</TT> prepended to the
type of the array, and the letter <TT>H</TT>
prepended to that. So, for example, an array of integers, declared
like this in Java:
<BLOCKQUOTE>
<PRE>
int[] lotsOfInts;
</PRE>
</BLOCKQUOTE>
<P>
would look like this on the native side:
<BLOCKQUOTE>
<PRE>
HArrayOfInt *lotsOfInts;
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CallingMethods">
Calling Methods</A></H3>
<P>
In the previous section you learned how to deal with references
to Java objects as handles. Using <TT>unhand()</TT>,
you can dereference those handles and get to the object's variables.
But what about methods? From your native code, you can call methods
inside Java objects using several utility functions for just that
purpose.
<P>
In addition, as you pass data back and forth between the Java
side and the native side, you'll need to know how data types convert
and how to deal with those types in either side.
<H4>Functions for Executing Methods</H4>
<P>
To call methods inside Java objects from within native code, you
use special utility functions. To call a regular Java method,
use the function <TT>execute_java_dynamic_method()</TT>.
To call a class method, use the function <TT>execute_java_static_method()</TT>.
Here's the signature for these functions (from the Java <TT>include</TT>
file <TT>interpreter.h</TT>, which
defines things like this):
<BLOCKQUOTE>
<PRE>
long execute_java_dynamic_method(ExecEnv *env, HObject *obj,
     char *method_name, char *signature, ...);
long execute_java_static_method(ExecEnv *env, ClassClass *cb,
</FONT>     char *method_name, char *signature, ...);
</PRE>
</BLOCKQUOTE>
<P>
Both functions take at least four arguments:
<UL>
<LI>An <TT>ExecEnv</TT> structure,
which defines the current execution environment. Right now the
only possible value for this argument is <TT>0</TT>,
which refers to the current execution environment.
<LI>For dynamic methods, a reference to the object in which the
method you're calling is defined. This would be the left side
of the dot in normal Java dot notation. Here, it's a handle to
that object.
<LI>For static (class) methods, a reference to the class structure
in which the method is defined. You can get a hold of a reference
to a class using the <TT>FindClass()</TT>
and <TT>FindClassFromClass()</TT>
functions, described later on in this section.
<LI>The method name (as a string).
<LI>The method signature.
</UL>
<P>
Any remaining arguments to the <TT>execute_java_static_method()</TT>
and <TT>execute_java_dynamic_method()</TT>
functions are arguments to the method itself.
<P>
Method signatures can be complex, because in this case they are
not simply the list of arguments and the return types. Method
signatures, for this function, are strings with a set of parentheses
containing an argument list, and a return type just after the
closing parentheses. Both the argument list and the return type
are letters or strings that represent a type.
<P>
For the primitive types, use single-letter codes for the argument
list and the return type (<TT>B</TT>
is <TT>byte</TT>, <TT>I</TT>
is <TT>int</TT>, <TT>V</TT>
is <TT>void</TT>, and <TT>Z</TT>
is <TT>boolean</TT>). For arrays,
use an open square bracket before the type (for example, <TT>[B</TT>
denotes a byte array).  More letter codes for different types
are contained in the Java <TT>include</TT>
file <TT>signature.h</TT>. So, for
example, a method that has no arguments and returns <TT>void</TT>
would have a signature of <TT>()V</TT>.
One that take three integer arguments and returns an integer would
have a signature of <TT>(III)V</TT>.
<P>
For object arguments, the code is the letter <TT>L</TT>,
then the class name (including the package, with all elements
separated by slashes), followed by a semicolon. So, for example,
a reference to a <TT>String</TT> object
would be <TT>Ljava/lang/String;</TT>.
<P>
Got all that? Here are a few examples:
<BLOCKQUOTE>
<PRE>
execute_java_dynamic_method(0, this, &quot;close&quot;, &quot;()Z&quot;
execute_java_static_method(0, MyClass, &quot;reverseString&quot;, 
   &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, &quot;This is my string&quot;);
execute_java_dynamic_method(0, this, &quot;open_speaker()&quot;, 
</FONT>   &quot;(Lcom/lne/audio/Device;)Z&quot;, theDevice);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>FindClass()</TT> and <TT>FindClassFromClass()</TT>
functions can be used to get a reference to a class structure
(a pointer of type <TT>ClassClass</TT>)
for use with the <TT>execute_java_static_method()</TT>
function. Here are their signatures:
<BLOCKQUOTE>
<PRE>
ClassClass *FindClass(ExecEnv *env, 
    char *className, bool_t resolve);
ClassClass *FindClassFromClass(ExecEnv *env, 
</FONT>    char *className, bool_t resolve, ClassClass *from);
</PRE>
</BLOCKQUOTE>
<P>
As with the functions for calling methods, the first argument
should be <TT>0</TT> to indicate that
this function is to be run in the current environment. The second
argument is the class name to find. The <TT>resolve</TT>
argument is a boolean which, if <TT>TRUE</TT>
or <TT>1</TT>, indicates that the
<TT>resolve Class()</TT> method should
be called on that class (class resolution is a function of the
class loader; it's probably safe to use <TT>TRUE</TT>
for this argument in most cases). In the case of <TT>FindClassFromClass</TT>,
the fourth argument is an already existing class; the class loader
that loaded that class will also be used to find and load the
new class.
<H4>Passing Parameters Back and Forth</H4>
<P>
To pass parameters to Java methods from native code or vice versa,
you have to understand how data types convert between the two
sides of the process.
<P>
The primitive data types in Java convert to their nearest equivalents
in C. All the Java integer types (<TT>char</TT>,
<TT>byte</TT>, <TT>short</TT>,
<TT>int</TT>) and <TT>boolean</TT>
convert to C <TT>long</TT> types;
<TT>long</TT> converts to <TT>int64_t</TT>,
and <TT>float</TT> and <TT>double</TT>
remain floats and doubles. Keep in mind that because of these
conversions, your original native method definitions may need
return types that reflect the values sent back from the C side
of the native method (for example, all methods that return <TT>integer</TT>
types must actually return <TT>long</TT>).
<P>
Object types are passed as handles to structures, as you learned
earlier, and must be dereferenced using <TT>unhand()</TT>
in order to be used.
<H3><A NAME="CreatingNewJavaObjects">
Creating New Java Objects</A></H3>
<P>
Because you can access Java objects and call methods from inside
your native code, the one thing left is the capability to create
new objects. You can do this too, using the <TT>execute_class_constructor()</TT>
function. This function is very similar to the functions for calling
methods; in fact, it has the same set of arguments that <TT>execute_java_static_method()</TT>
does:
<BLOCKQUOTE>
<PRE>
HObject *execute_java_constructor(ExecEnv *, char *classname,
</FONT>   ClassClass *cb, char *signature, ...);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>execute_java_static_method()</TT>
function has four arguments, but can have more. The four required
arguments are
<UL>
<LI><TT>0</TT>, for the current environment
(the only value of this argument currently supported).
<LI>A string representing the class name that defines this constructor.
<LI>A class handle such as the one you'd get from <TT>FindClass()</TT>.
If you use a class name, this argument should be <TT>NULL</TT>;
if you use a class object, the class name should be <TT>NULL</TT>
(use one or the other, not both). Using class references over
class names can be more efficient if you expect to create lots
of objects with the same class, because you can just use the same
class reference over and over again (class names must be looked
up each time).
<LI>The signature of the constructor which, as with the functions
to execute Java methods, is a string representing the arguments
to the method (constructors don't have a return type). As with
the functions to call methods, <TT>[T</TT>
is array of type <TT>T</TT>, <TT>B</TT>
is <TT>byte</TT>, <TT>I</TT>
is <TT>int</TT>, and <TT>Z</TT>
is <TT>boolean</TT>. Other types are
defined in <TT>signature.h</TT> (part
of the standard Java <TT>include</TT>
files).
<LI>Any other arguments to the constructor are added onto the
end of the parameter list.
</UL>
<P>
Here are some examples:
<BLOCKQUOTE>
<PRE>
execute_java_constructor(0, &quot;MyClass&quot;, NULL, &quot;()&quot;);
</FONT>execute_java_constructor(0, &quot;MyOtherClass&quot;, NULL, &quot;(II)&quot;, 10, 12);
</PRE>
</BLOCKQUOTE>
<P>
The first example creates an instance of the <TT>MyClass</TT>
class, using the constructor with no arguments. The second creates
an instance of <TT>MyOtherClass</TT>,
in which the constructor has two integer arguments. Those arguments,
<TT>10</TT> and <TT>12</TT>,
are included at the end of the parameter list.
<H3><A NAME="HandlingExceptions">
Handling Exceptions</A></H3>
<P>
To handle errors, Java has exceptions. In your native C code,
you can set up a Java exception using <TT>SignalError</TT>,
like this:
<BLOCKQUOTE>
<PRE>
SignalError(0, JAVAPKG &quot;ExceptionClassName&quot;, &quot;message&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Here, the exception class name is the name of a Java exception
class, including its package name, with the separation of package
names delineated with a slash rather than a period as in Java.
So, for example, the class <TT>java.io.IOException</TT>
would be <TT>&quot;java/io/IOException&quot;</TT>
when used inside <TT>SignalError</TT>.
<P>
The exception will be thrown in Java when your native method returns
(which it should immediately after the <TT>SignalError</TT>).
Note that just like regular methods, native methods that throw
exceptions must be declared to throw those exceptions using the
<TT>throw</TT> keyword.
<H3><A NAME="DealingwithStrings">
Dealing with Strings</A></H3>
<P>
Several functions and macros are available in the <TT>include</TT>
file <TT>javaString.h</TT> to help
manage strings. To gain access to these functions, include that
header as part of your native code:
<BLOCKQUOTE>
<PRE>
#include &lt;javaString.h&gt;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>makeJavaString()</TT> function
creates a Java <TT>String</TT> object
out of a C string. To convert a Java <TT>String</TT>
object into a C string, you can use <TT>makeCString()</TT>
or <TT>allocCString()</TT> (where
the former allocates the string from temporary storage and the
latter from the heap). Here are their signatures:
<BLOCKQUOTE>
<PRE>
Hjava_lang_String  *makeJavaString(char  *string, int  length)

char  *makeCString(Hjava_lang_String *s)
</FONT>char  *allocCString(Hjava_lang_String *s)
</PRE>
</BLOCKQUOTE>
<P>
To copy Java <TT>String</TT>s into
preexisting Unicode or ASCII C buffers, you can use <TT>javaString2unicode()</TT>
and <TT>javaString2CString()</TT>:
<BLOCKQUOTE>
<PRE>
unicode  *javaString2unicode(Hjava_lang_String *s, unicode  *buf, int  len)
</FONT>char     *javaString2CString(Hjava_lang_String *s, char     *buf, int  len)
</PRE>
</BLOCKQUOTE>
<P>
Finally, the <TT>javaStringPrint()</TT>
function prints a Java <TT>String</TT>
object (just like <TT>System.out.print()</TT>),
and the <TT>javaStringLength()</TT>
function gets its length:
<BLOCKQUOTE>
<PRE>
void  javaStringPrint(Hjava_lang_String *s)
</FONT>int   javaStringLength(Hjava_lang_String *s)
</PRE>
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you have learned about the advantages and disadvantages
of using <TT>native</TT> methods,
about the many ways that Java (and you) can make your programs
run faster, and also about the often illusory need for efficiency.
<P>
Finally, you learned the procedure for creating <TT>native</TT>
methods, from both the Java and the C sides, in detail-by generating
header files and stubs, and by compiling and linking a full example.
<P>
After working your way through today's difficult material, you've
mastered one of the most complex parts of the Java language. As
a reward, tomorrow we'll look &quot;under the hood&quot; to see
some of the hidden power of Java, and you can just sit back and
enjoy the ride.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Your descriptions here are somewhat sparse. What can I use to supplement what I've learned here?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Look at Sun's Java tutorial (online or on the CD-ROM included with this book) for a more detailed version of how to work with native methods.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Does the Java class library need to call <TT><B>System.loadLibrary()</B></TT> to load the built-in classes?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>No, you won't see any <TT>loadLibrary()</TT> calls in the implementation of any classes in the Java class library. That's because the Java team had the luxury of being able to statically link 
most of their code into the Java environment, something that really makes sense only when you're in the unique position of providing an entire system, as they are. Your classes must <I>dynamically</I> link their libraries into an already-running copy of 
the Java system. This is, by the way, more flexible than static linking; it allows you to unlink old and relink new versions of your classes at any time, making updating them trivial.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Can I statically link my own classes into Java like the Java team did?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Yes. You can, if you like, ask Sun Microsystems for the sources to the Java runtime environment itself, and, as long as you obey the (relatively straightforward) legal restrictions on using 
that code, you can relink the entire Java system plus your classes. Your classes are then statically linked into the system, but you have to give everyone who wants to use your program this special version of the Java environment. Sometimes, if you have 
strong enough requirements, this is the only way to go, but most of the time, dynamic linking is not only good enough, but preferable.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch19.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch21.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
