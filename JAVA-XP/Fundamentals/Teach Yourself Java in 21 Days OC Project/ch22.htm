<HTML>
<HEAD>
<TITLE>Day 22 -- Java Programming Tools</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;22</FONT>
</H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Java Programming Tools</FONT></H1>
<P>
<I><B>by Michael Morrison</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#OverviewoftheStandardJDKTools">
Overview of the Standard JDK Tools</A>
<LI><A HREF="#TheRuntimeInterpreter">
The Runtime Interpreter</A>
<UL>
<LI><A HREF="#Usage1">Usage</A>
<LI><A HREF="#TheOptionsArgument1">The <TT><I>Options</I></TT>Argument</FONT></A>
<LI><A HREF="#TheNonOptimizedInterpreter">The Non-Optimized Interpreter</A>
</UL>

<LI><A HREF="#TheCompiler">The Compiler</A>
<UL>
<LI><A HREF="#Usage2">Usage</A>
<LI><A HREF="#TheOptionsArgument2">The <TT><I>Options</I></TT>Argument</FONT></A>
<LI><A HREF="#TheNonOptimizingCompiler">The Non-Optimizing Compiler</A>
</UL>
<LI><A HREF="#TheAppletViewer">The Applet Viewer</A>
<UL>
<LI><A HREF="#Usage3">Usage</A>
<LI><A HREF="#TheOptionsArgument3">The <TT><I>Options</I></TT>Argument</FONT></A>
<LI><A HREF="#Commands1">Commands</A>
<LI><A HREF="#ProfilingJavaApplets">Profiling Java Applets</A>
</UL>
<LI><A HREF="#TheDebugger">The Debugger</A>
<UL>
<LI><A HREF="#Usage4">Usage</A>
<LI><A HREF="#TheOptionsArgument4">The <TT><I>Options</I></TT>Argument</FONT></A>
<LI><A HREF="#Commands2">Commands</A>
</UL>
<LI><A HREF="#TheClassFileDisassembler">The Class File Disassembler</A>
<UL>
<LI><A HREF="#Usage5">Usage</A>
<LI><A HREF="#TheoptionsArgument5">The <TT><I>Options</I></TT>Argument</FONT></A>
</UL>
<LI><A HREF="#TheHeaderandStubFileGenerator">The Header and Stub File Generator</A>
<UL>
<LI><A HREF="#Usage6">Usage</A>
<LI><A HREF="#TheOptionsArgument6">The <TT><I>Options</I></TT>Argument</FONT></A>
</UL>
<LI><A HREF="#TheDocumentationGenerator">The Documentation Generator</A>
<UL>
<LI><A HREF="#Usage7">Usage</A>
<LI><A HREF="#TheOptionsArgument7">The <TT><I>Options</I></TT>Argument</FONT></A>
<LI><A HREF="#DocumentationTags">Documentation Tags</A>
</UL>
<LI><A HREF="#VisualDevelopmentTools">Visual Development Tools</A>
<UL>
<LI><A HREF="#SunsJavaWorkShop">Sun's Java WorkShop</A>
<LI><A HREF="#SymantecCafeacute">Symantec Caf&eacute;</A>
<LI><A HREF="#MicrosoftVisualJ">Microsoft Visual J++</A>
<LI><A HREF="#NaturalIntelligencesRoaster">Natural Intelligence's Roaster</A>
<LI><A HREF="#RogueWaveSoftwaresJFactory">Rogue Wave Software's JFactory</A>
<LI><A HREF="#PenumbraSoftwaresMojo">Penumbra Software's Mojo</A>
<LI><A HREF="#AimtechsJamba">Aimtech's Jamba</A>
<LI><A HREF="#KinetixsHyperwire">Kinetix's Hyperwire</A>
</UL>
<LI><A HREF="#Summary">Summary</A>
<LI><A HREF="#QampABR">Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Trying to perform any craft without the proper tools is a daunting
task at best. Java programming is indeed a craft, and like woodworking
or engraving, your level of programming success largely depends
on your choice of tools as well as your skill in using the tools.
You begin this bonus week by looking inside the standard Java
programming tools included with the Java Developer's Kit (JDK).
Today's lesson isn't just a cursory glance at the Java tools,
however. You actually dig into the details of using the tools,
including some hidden features and capabilities that seem to have
been glossed over in much of the Java documentation. After learning
the ins and outs of the standard JDK tools, you'll finish up the
lesson by taking a look at some of the more popular Java visual
development tools.
<P>
Today's lesson covers the following major topics:
<UL>
<LI>The tools included with the JDK and where to get the latest
versions
<LI>Executing programs with the Java runtime interpreter
<LI>Compiling source files with the Java compiler
<LI>Debugging programs with the Java debugger
<LI>Visual development tools
</UL>
<P>
By the end of today's lesson, you will be well acquainted with
the standard JDK tools and how they work. This insight into the
standard tools will allow you to use them more effectively in
your own projects. Even if you decide to use one of the visual
tools highlighted toward the end of the lesson, such as Symantec
Caf&eacute; or Visual J++, you may still sometimes find the JDK
tools invaluable in certain situations.
<H2><A NAME="OverviewoftheStandardJDKTools"><FONT SIZE=5 COLOR=#FF0000>
Overview of the Standard JDK Tools</FONT></A></H2>
<P>
The JDK provides a core set of tools necessary for developing
programs in Java. Even though the JDK tools aren't particularly
fancy in their implementation, they are guaranteed to work with
the latest Java release because updated JDK tools are written
in Java and are a part of each release. And although third-party
add-ons and development environments promise to make Java development
smoother and easier, the JDK provides all the essential tools
and information necessary to write professional Java applets immediately
and at no cost. Because the JDK is Sun's official development
kit for Java, you can always count on it to provide the most extensive
Java support.
<P>
Following is a complete list of the tools that are standard with
the JDK:
<UL>
<LI>The runtime interpreter
<LI>The compiler
<LI>The applet viewer
<LI>The debugger
<LI>The class file disassembler
<LI>The header and stub file generator
<LI>The documentation generator
</UL>
<P>
You'll learn about each of these tools in detail in today's lesson.
Before you get started, however, it's important to make sure you
have the latest version of the JDK. As of this writing, the latest
version of the JDK is version 1.02, which is included on the accompanying
CD-ROM. This version will probably be around for a while, so you
should be okay using it. Just to be sure, you can check Sun's
Java Web site at <TT><A HREF="http://www.javasoft.com/">http://www.javasoft.com</A></TT>
to see what the latest version is. This Web site provides all
the latest news and information regarding Java, including the
latest release of the JDK. Keep in mind that Java is a new technology
that is still in a state of rapid change. Be sure to keep an eye
on the Java Web site for the latest information.
<H2><A NAME="TheRuntimeInterpreter"><FONT SIZE=5 COLOR=#FF0000>
The Runtime Interpreter</FONT></A></H2>
<P>
The Java runtime interpreter is a standalone version of the Java
interpreter built into Java-compatible Web browsers, such as Netscape
Navigator 3.0 and Microsoft Internet Explorer 3.0. The runtime
interpreter provides the support to run Java executable programs
in the compiled bytecode class format. Since the interpreter doesn't
directly provide any means to view graphical output, you are limited
to using it to execute purely textual Java programs and applications
that manage their own graphics. If you want to run graphical Java
applets, you need to use either the Java applet viewer or a Java-compatible
Web browser.
<P>
You can think of the runtime interpreter as exposing the bare
essentials of the Java runtime system. Even though I use the term
<I>bare</I> <I>essentials</I>, the interpreter actually lets you
do quite a lot. Essentially, you can run any Java programs that
don't rely on the <TT>Applet</TT>
class. In fact, the statement earlier about not being able to
run graphical programs isn't entirely true; you can run graphical
Java applications, but you just can't run Java applets. The difference
between a Java application and a Java applet is that an application
is responsible for creating and maintaining its own window should
it require the need for graphical output, whereas an applet relies
on a Web browser to provide a window on which to display graphics.
So the Java interpreter is capable of executing both textual Java
programs and graphical Java applications, but not applets.
<H3><A NAME="Usage1">Usage</A></H3>
<P>
The runtime interpreter is a command-line tool for running Java
programs and applications; Java applets require the graphics and
display support of a Web browser.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>command-line tool</I> is a tool that is executed at a command prompt, such as a DOS or UNIX shell prompt, with a specified list of arguments.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The syntax for using the Java runtime interpreter follows:
<BLOCKQUOTE>
<PRE>
java <I>Options Classname Arguments</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>Classname</I></TT> argument
specifies the name of the class you want to execute. If the class
resides in a package, you must fully qualify the name. For example,
if you want to run a class called <TT>SolveIt</TT>
that is located in a package called <TT>Equations</TT>,
you would execute it in the interpreter like this:
<BLOCKQUOTE>
<PRE>
java Equations.SolveIt
</PRE>
</BLOCKQUOTE>
<P>
When the Java interpreter executes a class, what it is really
doing is executing the <TT>main</TT>
method of the class. The interpreter exits when the <TT>main</TT>
method and any threads created by it are finished executing. The
<TT>main</TT> method accepts a list
of arguments that can be used to control the program. Following
is the definition of the <TT>main</TT>
method as specified by the Java language:
<BLOCKQUOTE>
<PRE>
class DoIt {
  public static void main(String argv[]) {
    // do something
  }
}
</PRE>
</BLOCKQUOTE>
<P>
Notice that <TT>main</TT> has a single
parameter, <TT>argv</TT>, which is
an array of <TT>String</TT> objects.
This brings us to the <TT><I>Arguments</I></TT>
argument for the runtime interpreter, which specifies the arguments
passed into the <TT>main</TT> method.
Any arguments passed to the runtime interpreter via <TT><I>Arguments</I></TT>
are accessible from the <TT>argv</TT>
parameter in <TT>main</TT>. The following
interpreter call passes two numeric arguments to the <TT>main</TT>
method in the <TT>DoIt</TT> class:
<BLOCKQUOTE>
<PRE>
java DoIt 8 24<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The fact that the Java runtime interpreter actually executes the <TT>main</TT> method when running a class should give you an idea about one of the reasons why you can't run applets using the runtime interpreter. Give up? The answer is that applets don't 
even have a <TT>main</TT> method, so there is no way for the runtime interpreter to know how to begin executing an applet.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheOptionsArgument1">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
specifies options related to how the runtime interpreter executes
the Java program. Following is a list of the most common runtime
interpreter options:
<BLOCKQUOTE>
<PRE>
-debug
-checksource or -cs
-classpath <I>Path
</I>-mx <I>x
</I>-ms <I>x
</I>-noasyncgc
-noverify
-prof
-ss <I>x
</I>-oss <I>x
</I>-t
-verbose or -v
-verbosegc
-verify
-verifyremote
-D<I>PropertyName</I>=<I>NewValue</I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-debug</TT> option starts
the interpreter in debugging mode, which allows you to use the
Java debugger (<TT>jdb</TT>) in conjunction
with the interpreter. You'll learn more about using the Java debugger
a little later in today's lesson.
<P>
The <TT>-checksource</TT> option causes
the interpreter to compare the modification dates of the source
code files and executable class files. If the source file is more
recent, the class is automatically recompiled and the new bytecode
executable is loaded.
<P>
The Java interpreter uses an environment variable, <TT>CLASSPATH</TT>,
to determine where to look for user-defined classes. The <TT>CLASSPATH</TT>
variable contains a semicolon-delimited list of system paths to
user-defined Java classes. Actually, most of the Java tools use
the <TT>CLASSPATH</TT> variable to
know where to find user-defined classes. The <TT>-classpath</TT>
option informs the runtime interpreter to override <TT>CLASSPATH</TT>
with the path specified by <TT><I>Path</I></TT>.
<P>
The <TT>-mx <I>x</I></TT> option allows
you to modify the maximum size of the memory allocation pool,
or garbage collection heap, used by the interpreter. By default,
the pool has a maximum size of 16MB (<TT>-mx
16m</TT>). <TT><I>x</I></TT>
specifies the new maximum size of the pool and is measured in
bytes by default. You can also specify <TT><I>x</I></TT>
in either kilobytes or megabytes by appending the letter <TT>k</TT>
or <TT>m</TT> (respectively) onto
the value. Also, <TT><I>x</I></TT>
must be greater than 1000 bytes, meaning that the pool must have
a maximum size of at least 1000 bytes.
<P>
The <TT>-ms <I>x</I></TT> option is
similar to the <TT>-mx</TT> option,
except it allows you to modify the initial size of the memory
allocation pool rather than the maximum size. By default, the
size of the pool is initially set to 1MB (<TT>-ms
1m</TT>). <TT><I>x</I></TT>
specifies the new initial pool size, and is measured in bytes
by default. Similar to the <TT>-mx</TT>
option, you can also specify <TT><I>x</I></TT>
in either kilobytes or megabytes by appending the letter <TT>k</TT>
or <TT>m</TT> (respectively) onto
the value. Additionally, <TT><I>x</I></TT>
must be greater than 1000 bytes.
<P>
The Java runtime system typically performs garbage collection
automatically to make sure unneeded memory stays freed up. This
takes place in an asynchronous thread that runs alongside other
threads in the runtime system. The <TT>-noasyncgc</TT>
option alters this behavior by turning off asynchronous garbage
collection. The result is that no garbage collection takes place
unless it is explicitly called on or the Java program runs out
of memory.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You can force an explicit garbage collection by calling the <TT>gc</TT> method in the <TT>System</TT> class.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>-noverify</TT> option turns
all code verification off, meaning that no bytecodes are processed
by the bytecode verifier. Typically, the verifier verifies code
loaded into the system using a class loader.
<P>
The runtime interpreter includes a built-in profiler, which is
invoked using the <TT>-prof</TT> option.
The profiler's job is to report on the amount of time spent in
each section of code as a program is executing, which can often
be used to find performance bottlenecks in the code. The built-in
profiler writes the profile information to a file called <TT>java.prof</TT>,
which is a text file. The profile information consists of how
many times each method was called and the relative amount of time
spent in the method during each call. The larger the latter number
is, the more costly the method in terms of processor overhead.
You can easily use this information as a guide to determine the
code on which to focus your code optimization efforts.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Since the runtime interpreter, and therefore the built-in profiler, can only be used with textual Java programs and standalone applications, you may be wondering how to profile Java applets. Fortunately, you can use the profiler in the runtime interpreter 
in conjunction with the Java applet viewer. You'll learn how to do this a little later today when you find out about the applet viewer.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Every thread in the Java runtime system is given two stacks: one
for Java code and one for C/C++ code. The presence of two stacks
reflects the native code support in Java. The <TT>-ss
<I>x</I></TT> option allows you to alter the maximum stack
size used by C code in a thread. The default C stack size is 128KB
(<TT>-ss 128k</TT>). The <TT><I>x</I></TT>
parameter specifies the new maximum size in bytes of the C stack,
which must be greater than 1000 bytes. You can also specify <TT><I>x</I></TT>
in either kilobytes or megabytes by appending the letter <TT>k</TT>
or <TT>m</TT> (respectively) onto
the value. Keep in mind that this option applies to all threads
created during program execution.
<P>
Similar to the <TT>-ss <I>x</I></TT>
option, the <TT>-oss</TT> option allows
you to set the maximum stack size that can be used by the Java
code in a thread. The default Java code stack size is 400KB (<TT>-oss
400k</TT>). The <TT><I>x</I></TT>
parameter specifies the new maximum size in bytes of the Java
stack, which must be greater than 1000 bytes.
<P>
The <TT>-t</TT> option prints a trace
of the bytecode instructions executed. This option only works
with the non-optimized version of the Java interpreter, <TT>java_g</TT>.
(You'll learn about the non-optimized interpreter in a moment.)
The <TT>-t</TT> option generates a
great deal of information that can give you a lot of insight into
what is happening within a program, provided you are good at following
raw bytecodes!
<P>
The <TT>-verbose</TT> option causes
the interpreter to print a message to standard output each time
a Java class is loaded. Similarly, the <TT>-verbosegc</TT>
option causes the interpreter to print a message each time a garbage
collection is performed. A garbage collection is performed by
the runtime system to clean up unneeded objects and to free memory.
<P>
The opposite of the <TT>-noverify</TT>
option, the <TT>-verify</TT> option
causes the interpreter to run the bytecode verifier on all code
loaded into the runtime environment. The default function of the
verifier is to only verify code loaded into the system using a
class loader. This default behavior can also be explicitly specified
using the <TT>-verifyremote</TT> option.
<P>
The <TT>-D</TT> option allows you
to redefine system property values. <TT><I>PropertyName</I></TT>
specifies the name of the system property you want to change,
and <TT><I>NewValue</I></TT> specifies
the new value you want to assign to it.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>System properties</I> are global system variables that reflect the state of the Java runtime system. For example, the version of the Java runtime system is stored in the <TT>java.version</TT> system property.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheNonOptimizedInterpreter">The Non-Optimized Interpreter</A></H3>
<P>
Some distributions of the Java Developer's Kit include an alternate
Java interpreter called <TT>java_g</TT>.
This is a non-optimized version of the Java interpreter that executes
Java bytecodes in a manner more suitable for debugging. If this
interpreter is in your JDK distribution, be sure to use it when
you are executing code within the Java debugger.
<H2><A NAME="TheCompiler"><FONT SIZE=5 COLOR=#FF0000>
The Compiler</FONT></A></H2>
<P>
The Java compiler (<TT>javac</TT>)
is used to compile Java source code files into executable Java
bytecode classes. In Java, source code files have the extension
<TT>.java</TT>. As you've seen throughout
this book, Java source code files are standard ASCII text files,
much like the source code files for other popular programming
languages like C++. It is the job of the Java compiler to process
Java source code files and create executable Java bytecode classes
from them. Executable bytecode class files have the extension
<TT>.class</TT> and represent a Java
class in its usable form.
<P>
Java class files are generated on a one-to-one basis with the
classes defined in the source code. In other words, the Java compiler
generates exactly one <TT>.class</TT>
file for each class you create. Since it is technically possible
to define more than one class in a single source file, it is therefore
possible for the compiler to generate multiple class files from
a single source file. When this happens, it means that the source
file contains multiple class definitions.
<P>
You may have heard something about just-in-time compilers in relationship
to Java. It's important not to get these compilers confused with
the Java compiler and the role it plays. The Java compiler is
responsible for turning Java source code into Java bytecodes that
can be executed within the Java runtime system. The Java virtual
machine, which is a component of the runtime system, is responsible
for interpreting the bytecodes and making the appropriate system
level calls to the native platform. It is at this point where
platform independence is achieved by Java; the bytecodes are in
a generic form that is only converted to a native form when processed
by the virtual machine.
<P>
Just-in-time compilers remove the role of the runtime interpreter
by converting Java bytecodes to native code on-the-fly before
executing a Java program. In this way, just-in-time Java compilers
work more like the back end of traditional language compilers
in that they generate code for a native platform. Similarly, the
Java compiler works more like the front end of a traditional compiler
in that it parses Java source code and generates internally useful
bytecode classes.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Both Netscape Navigator 3.0 and Microsoft Internet Explorer 3.0 include just-in-time Java compilers.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Keep in mind that Java executables are still centered around the
bytecode class format. Even with just-in-time compilers in the
picture, all you must be concerned with as a developer is generating
the appropriate bytecode classes using the Java compiler. If no
just-in-time compiler is present on a user's system, the bytecode
classes will be processed and executed by the runtime interpreter.
On the other hand, if a just-in-time compiler happens to exist
on the system, the bytecode classes will be converted to native
code and then executed. Either way, the key to executing Java
programs is the bytecode classes, which are created by the Java
compiler.
<H3><A NAME="Usage2">Usage</A></H3>
<P>
The Java compiler is a command-line tool whose syntax follows:
<BLOCKQUOTE>
<PRE>
javac <I>Options Filename</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>Filename</I></TT> argument
specifies the name of the source code file you want to compile.
The compiler will generate bytecode classes for all classes defined
in this file. Likewise, the compiler will also generate bytecode
classes for any dependent classes that haven't been compiled yet.
In other words, if you are compiling class <TT>A</TT>,
which is derived from class <TT>B</TT>,
and class <TT>B</TT> has not yet been
compiled, the compiler will notice the dependency and go ahead
and compile both classes.
<H3><A NAME="TheOptionsArgument2">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> compiler
argument specifies options related to how the compiler creates
the executable Java classes. Following is a list of the compiler
options:
<BLOCKQUOTE>
<PRE>
-classpath <I>Path
</I>-d <I>Dir
</I>-g
-nowarn
-O
-verbose
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-classpath</TT> option tells
the compiler to override the <TT>CLASSPATH</TT>
environment variable with the path specified by <TT><I>Path</I></TT>.
This causes the compiler to look for user-defined classes in the
path specified by <TT><I>Path</I></TT>.
<TT><I>Path</I></TT> is a colon-delimited
list of directory paths taking the following form:
<BLOCKQUOTE>
<PRE>
.;<I>YourPath</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
An example of a specific usage of <TT>-classpath</TT>
follows:
<BLOCKQUOTE>
<PRE>
javac -classpath .;\dev\animate\classes;\dev\render\classes A.java
</PRE>
</BLOCKQUOTE>
<P>
In this case, the compiler is using a user-defined class path
to access any classes it needs while compiling the source code
file <TT>A.java</TT>. The <TT>-classpath</TT>
option is sometimes useful when you want to try compiling something
without taking the trouble to modify the <TT>CLASSPATH</TT>
environment variable.
<P>
The <TT>-d</TT> option determines
the root directory where compiled classes are stored. This is
important because many times classes are organized in a hierarchical
directory structure. With the <TT>-d</TT>
option, the directory structure will be created beneath the directory
specified by <TT><I>Dir</I></TT>.
<P>
The <TT>-g</TT> compiler option causes
the compiler to generate debugging tables for the Java classes.
Debugging tables are used by the Java debugger and contain information
such as local variables and line numbers. The default action of
the compiler is to only generate line numbers.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>debugging table</I> is a collection of information about a program that is used internally by a debugger. Debugging tables are built directly into executable classes during compilation.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you are going to be using the Java debugger to debug the classes generated by the compiler, you must use the <TT>-g</TT> option. Additionally, for debugging make sure you don't use the <TT>-O</TT> option, which optimizes the code.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>-nowarn</TT> option turns
off compiler warnings. Warnings are printed to standard output
during compilation to inform you of potential problems with the
source code. It is generally a good idea to keep warnings enabled
because they often signal problem areas in your code. However,
you may run into a situation where warnings are getting in the
way, in which case the <TT>-nowarn</TT>
option might be useful.
<P>
The <TT>-O</TT> option causes the
compiler to optimize the compiled code. In this case, optimization
simply means that static, final, and private methods are compiled
inline. When a method is compiled inline, it means that the entire
body of the method is included in place of each call to the method.
This speeds up execution because it eliminates the method call
overhead. Optimized classes are usually larger in size to accommodate
the duplicate code. The <TT>-O</TT>
optimization option also suppresses the default creation of line
numbers by the compiler. Keep in mind that the <TT>-O</TT>
option should not be used when you plan on debugging the compiled
code using the Java debugger.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Method inlining</I> is the process of replacing each call to a method with the actual method code. Inlining often increases the size of the resulting class file, but it can help improve performance.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>-verbose</TT> option has somewhat
of an opposite effect as the <TT>-nowarn</TT>
option-it prints out extra information about the compilation process.
You can use <TT>-verbose</TT> to see
exactly what source files are being compiled and what class files
are being loaded.
<H3><A NAME="TheNonOptimizingCompiler">The Non-Optimizing Compiler</A></H3>
<P>
Some distributions of the Java Developer's Kit include an alternate
Java compiler called <TT>javac_g</TT>.
This version of the Java compiler generates code without some
of the internal optimizations performed by the standard <TT>javac</TT>
compiler. If this compiler is in your JDK distribution, be sure
to use it when you are compiling code for debugging. Otherwise,
stick with the <TT>javac</TT> compiler
for all release code.
<H2><A NAME="TheAppletViewer"><FONT SIZE=5 COLOR=#FF0000>
The Applet Viewer</FONT></A></H2>
<P>
The typical method of executing a Java applet is from within a
Web browser that has a Web page loaded containing the applet.
This is the typical scenario in which most Web users come into
contact with Java applets. As a Java developer, you have another
option for running Java applets that doesn't involve the use of
a Web browser. This option is the Java applet viewer, which serves
as a minimal test bed for Java applets. At times you may not want
to hassle with using a full-blown Web browser to test an applet,
in which case the applet viewer is an ideal alternative.
<P>
Even though the applet viewer logically takes the place of a Web
browser, it functions very differently from a Web browser. The
applet viewer operates on HTML documents, but it only looks for
embedded applet tags; it ignores any other HTML code in the document.
Each time the applet viewer encounters an applet tag in an HTML
document, it launches a separate applet viewer window containing
the respective applet.
<P>
The only drawback to using the applet viewer is that it doesn't
show you how an applet will run within the confines of a real
Web setting. Since the applet viewer ignores all HTML codes except
applet tags, it doesn't even attempt to display any other information
contained in the HTML document. So once you've tested your applet
using the applet viewer, be sure to also test it using a Web browser
just to make sure it works in the context of a real Web page.
<H3><A NAME="Usage3">Usage</A></H3>
<P>
The Java applet viewer is a command-line tool, meaning that it
is invoked from a command prompt. The syntax for the applet viewer
follows:
<BLOCKQUOTE>
<PRE>
appletviewer <I>Options</I> </FONT><I>URL</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>URL</I></TT> argument specifies
a document URL containing an HTML page with an embedded Java applet.
The applet viewer launches a separate window for each applet embedded
in the HTML document. If the document doesn't contain any embedded
applets, the applet viewer will simply exit. Figure 22.1 shows
the applet viewer in action.
<P>
Figure 22.1 shows the Animator demo applet, which comes with the
Java Developer's Kit, running in the applet viewer. You run the
applet by changing to the directory containing the Animator bytecode
class and embedded HTML file and then executing the following
statement at the command prompt:
<P>
<A HREF="http://docs.rinet.ru/J21/f22-1.gif"><B>Figure 22.1 : </B><I>The Animator applet running in the Java
applet viewer</I>.</A>
<BLOCKQUOTE>
<PRE>
appletviewer example1.html
</PRE>
</BLOCKQUOTE>
<P>
<TT>example1.html</TT> is the HTML
file containing the embedded Java applet. As you can see, there's
nothing complicated about running Java applets using the applet
viewer. The applet viewer is a useful and easy-to-use tool for
testing Java applets in a simple environment.
<H3><A NAME="TheOptionsArgument3">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
to the applet viewer specifies how to run the Java applet. There
is currently only one option supported by the applet viewer, <TT>-debug</TT>.
The <TT>-debug</TT> option starts
the applet viewer in the Java debugger, which allows you to debug
applets. You'll learn more about using the Java debugger a little
later in today's lesson.
<H3><A NAME="Commands1">Commands</A></H3>
<P>
The applet viewer has a drop-down menu called Applet containing
a group of commands, as shown in Figure 22.2.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-2.gif"><B>Figure 22.2 :</B> <I>The Java applet viewer with commands available
in the drop-down menu</I>.</A>
<P>
The <TT>Restart</TT> command restarts
the currently loaded applet, resulting in a call to the <TT>start</TT>
method for the applet. The <TT>Restart</TT>
command does not reload the applet, however. Similar to <TT>Restart</TT>,
the <TT>Reload</TT> command reloads
the applet and then starts it. <TT>Reload</TT>
is often a better command to use to restart applets as it ensures
that an applet is completely reinitialized.
<P>
The <TT>Clone</TT> command launches
another instance of the applet viewer executing the same applet.
This command is useful when you want to run multiple copies of
an applet. For example, a multiuser network applet might support
multiple instances that can communicate with each other. You could
load one instance of the applet and then use the <TT>Clone</TT>
command to start other instances.
<P>
The <TT>Tag</TT> command displays
a window showing the HTML applet tag for the executing applet.
The Applet HTML Tag window is shown in Figure 22.3.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-3.gif"><B>Figure 22.3 : </B><I>The Applet HTML Tag window displayed by
the </I><TT>Tag</TT><I> command</I>.</A>
<P>
The <TT>Info</TT> command displays
a window showing information about the executing applet, including
general applet information and information relating to the parameters
used by the applet. This information is returned by the <TT>getAppletInfo</TT>
and <TT>getParameterInfo</TT> methods
of the <TT>Applet</TT> class. The
Applet Info window is shown in Figure 22.4.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-4.gif"><B>Figure 22.4 : </B><I>The Applet Info window displayed by the
</I><TT>Info</TT><I> command</I>.</A>
<P>
The <TT>Edit</TT> command is disabled
in the current release of the applet viewer. It will presumably
be activated in a future release of the applet viewer, in which
case it will probably provide a way to alter the applet parameters
in the HTML document containing the applet tag.
<P>
The <TT>Properties</TT> command displays
a window with access options relating to HTTP and firewall proxies
and servers, along with network and class access options. The
AppletViewer Properties window is shown in Figure 22.5.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-5.gif"><B>Figure 22.5 : </B><I>The Applet Viewer Properties window displayed
by the <TT>Properties</TT>    
command</I>.</A>
<P>
Finally, the <TT>Close</TT> and <TT>Quit</TT>
commands perform the same function, which is shutting down the
applet viewer. It's not clear why there are two different commands
for closing the applet viewer-it's presumably an oversight.
<H3><A NAME="ProfilingJavaApplets">Profiling Java Applets</A></H3>
<P>
You learned a little earlier today about the profiler built into
the Java runtime interpreter. You learned that you can't profile
applets using the runtime interpreter alone because you can't
even run applets using the interpreter. However, you can profile
applets by running the interpreter's profiler in conjunction with
the applet viewer. In this case, the applet viewer is launched
from within the runtime interpreter, like this:
<BLOCKQUOTE>
<PRE>
java -prof sun.applet.AppletViewer <I>URL</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
<TT><I>URL</I></TT> specifies the
name of the HTML file containing an applet tag (or tags). Notice
that the applet viewer is referenced using its fully qualified
class name, <TT>AppletViewer</TT>.
When you finish running the applet, the interpreter writes a text
file named <TT>java.prof</TT> to the
current directory. This file contains profile information for
the applet you just ran. Refer to the earlier discussion of the
profiler in the section &quot;The Runtime Interpreter&quot; for
information regarding the meaning of the contents of this file.
<H2><A NAME="TheDebugger"><FONT SIZE=5 COLOR=#FF0000>
The Debugger</FONT></A></H2>
<P>
The Java debugger (<TT>jdb</TT>) is
a command-line utility that enables you to debug Java programs.
The Java debugger uses the Java Debugger API to provide debugging
support within the Java runtime interpreter. Although the debugger
is a command-line tool, it still provides a wide range of standard
debugging features such as setting breakpoints and single-stepping
through code.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>breakpoint</I> is a line of code you specify that halts the execution of a program.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<I>Single-stepping</I> is the process of executing your code one line at a time (in single steps).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Before you can use <TT>jdb</TT>, you
must compile your code so that it includes debugging information.
The Java compiler switch for doing this is <TT>-g</TT>,
which causes the compiler to generate debugging tables containing
information about line numbers and variables.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Some distributions of the JDK also include an alternative Java compiler called <TT>javac_g</TT>. If you have this compiler in your distribution (look in the <TT>java/bin</TT> directory), use it, because it compiles code without using some of the internal 
optimizations performed by the <TT>javac</TT> compiler.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Because debugging is a very broad subject, I've tried to keep
this discussion focused on the Java debugger and the basics of
how it is used. For a more hands-on look at Java debugging, you
may want to check out Sun's online Java debugger tutorials, which
are located on Sun's Java Web site at <TT><A HREF="http://www.javasoft.com/products/JDK/debugging/">http://www.javasoft.com/products/JDK/debugging/</A></TT>.
<H3><A NAME="Usage4">Usage</A></H3>
<P>
The syntax for using the Java debugger follows:
<BLOCKQUOTE>
<PRE>
jdb <I>Options &lt;Classname&gt;</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>Classname</I></TT> argument
is optional and specifies the name of the class you want to execute.
The fact that <TT><I>Classname</I></TT>
is optional brings up an interesting point regarding the usage
of the debugger: There are two different ways to go about using
the debugger, depending on whether you are debugging an application
or an applet. For applications, you simply execute <TT>jdb</TT>
directly and provide the name of the main class in the <TT><I>Classname</I></TT>
argument, as the previous syntax shows. If you are debugging an
applet, however, you must execute the debugger within the applet
viewer, like this:
<BLOCKQUOTE>
<PRE>
appletviewer -debug <I>URL</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
In this case, <TT><I>URL</I></TT>
refers to a document URL containing an HTML page with the applet
to be debugged. Instead of directly executing the class, the applet
viewer launches the debugger and allows you to debug the applet.
Technically, there are three ways to use the Java debugger. The
third technique involves attaching the debugger to an application
that is already running in the interpreter. You'll learn a little
more about this debugging approach in the next section.
<H3><A NAME="TheOptionsArgument4">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
is used to specify different settings regarding how a debugging
session is started. Following is a list of the debugging options:
<BLOCKQUOTE>
<PRE>
-host Hostname
-password Password
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-host</TT> option is used
to specify the name of the host machine where an existing Java
interpreter is running. In this case, the debugger attaches itself
to the interpreter so the currently executing application can
be debugged. You specify the name of the host machine in the <TT><I>Hostname</I></TT>
argument.
<P>
The <TT>-password</TT> option is also
used when attaching the debugger to an existing interpreter session.
When the interpreter is started with the <TT>-debug</TT>
option, a password is displayed that must be used when initiating
the debugging session. You specify this password to the debugger
via the <TT>-password</TT> option
and the <TT><I>Password</I></TT> argument.
<H3><A NAME="Commands2">Commands</A></H3>
<P>
When the debugger is up and running, you control it through commands
that are entered at a command-line prompt. The debugger command-line
prompt is a <TT>&gt;</TT> prompt by
default, similar to DOS or UNIX shell prompts. This prompt specifies
that there is no default thread running. The thread that is currently
executing in the debugger is displayed in the command prompt itself,
so the <TT>&gt;</TT> prompt signifies
that no thread is currently being debugged. When you are debugging
a thread, the command prompt changes to a thread name followed
by the current position of the stack frame, which is enclosed
in square brackets. An example of a thread prompt is <TT>main[1]</TT>,
which signifies that the <TT>main</TT>
thread is running and you are at the topmost position (<TT>1</TT>)
in the stack frame.
<P>
Following is a list of some of the most useful debugging commands:
<BLOCKQUOTE>
<PRE>
help
locals
print <I>Object
</I>dump <I>Object
</I>methods <I>Class
</I>classes
stop in <I>Classname</I>.<I>Methodname
</I>stop at <I>Classname</I>.<I>LineNumber
</I>step
cont
clear &lt;<I>Classname</I>.<I>LineNumber</I>&gt;
</PRE>
</BLOCKQUOTE>
<P>
Possibly the most important command in <TT>jdb</TT>
is the <TT>help</TT> command, which
prints out a listing of all the available commands and what they
do. The next three commands are all related to printing information
about objects. The <TT>locals</TT>
command displays the current value of all the objects in the current
scope (stack frame). The <TT>print</TT>
and <TT>dump</TT> commands are both
used on objects independent of the current scope. The <TT>print</TT>
command is used to print both entire objects and individual member
variables; you simply specify the name of the object or member
variable in the <TT><I>Object</I></TT>
argument. Similar to <TT>print</TT>,
the <TT>dump</TT> command also prints
objects or member variables, but it prints more detailed information
such as an object's inheritance.
<P>
The <TT>methods</TT> command is used
to list all the methods defined in the class specified by <TT><I>Class</I></TT>.
The <TT>classes</TT> command lists
all the classes that are currently loaded into memory. The list
generated by the <TT>classes</TT>
command is often pretty large since many different classes end
up being loaded behind the scenes even in simple Java programs.
<P>
Now that you have an idea how to look at the values of different
things in the debugger, let's move on to some commands that are
a little more exciting. The <TT>stop in</TT>
and <TT>stop at</TT> commands are
used to set breakpoints in methods and at specific lines of source
code, respectively. For example, to set a breakpoint in the <TT>mouseDown</TT>
method of an applet called <TT>Groovy</TT>,
you would type the following command at the debugger command line:
<BLOCKQUOTE>
<PRE>
stop in Groovy.mouseDown
</PRE>
</BLOCKQUOTE>
<P>
When you click the mouse button in the applet window, the debugger
will halt the applet at the beginning of the <TT>mouseDown</TT>
method. To begin single-stepping through the method, you use the
<TT>step</TT> command. The debugger
executes one line of code for each <TT>step</TT>
command issued. When you find out the information you need and
are ready to get things running at full speed again, you use the
<TT>cont</TT> command, which continues
the normal execution of the program. Likewise, you can clear any
breakpoints you set with the <TT>clear</TT>
command.
<P>
That sums up the basics of using the Java debugger. Like any powerful
tool, you'll gain confidence with the debugger by simply tinkering
with it. I suggest running the debugger on a simple program and
getting acquainted with some of the commands before trying to
take on a serious debugging project.
<H2><A NAME="TheClassFileDisassembler"><FONT SIZE=5 COLOR=#FF0000>
The Class File Disassembler</FONT></A></H2>
<P>
The Java class file disassembler (<TT>javap</TT>)
is used to disassemble a class file, which means the executable
class file is resolved into a list of public data, methods, or
raw bytecode instructions. The disassembler's default output consists
of the public data and methods for a class. The class file disassembler
is useful in cases where you don't have the source code for a
class but you'd like to know something about how it is implemented.
<H3><A NAME="Usage5">Usage</A></H3>
<P>
The syntax for the disassembler follows:
<BLOCKQUOTE>
<PRE>
javap <I>Options ClassNames</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>ClassNames</I></TT> argument
specifies the names of one or more classes to be disassembled.
<H3><A NAME="TheoptionsArgument5">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
specifies how the classes are to be disassembled. The disassembler
supports the following options:
<BLOCKQUOTE>
<PRE>
-c
-p
-h
-classpath <I>Path
</I>-verify
-version
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-c</TT> option tells the disassembler
to output the actual bytecodes for each method. The <BR>
<TT>-p</TT> option tells the disassembler
to also include private variables and methods in its output. Without
this option, the disassembler only outputs the public member variables
and methods. The <TT>-h</TT> option
specifies that information be created that can be used in C header
files. This is useful when you are attempting to interface C code
to a Java class for which you don't have the source code.
<P>
The <TT>-classpath</TT> option informs
the disassembler to override <TT>CLASSPATH</TT>
with the path specified by <TT><I>Path</I></TT>
when looking for the input class or classes. The <TT>-verify</TT>
option tells the disassembler to run the verifier on the class
and output debugging information. Finally, the <TT>-version</TT>
option causes the disassembler to print its version number.
<H2><A NAME="TheHeaderandStubFileGenerator"><FONT SIZE=5 COLOR=#FF0000>
The Header and Stub File Generator</FONT></A></H2>
<P>
The Java header and stub file generator (<TT>javah</TT>)
is used to generate C header and source files for implementing
Java methods in C. The files generated can be used to access member
variables of an object from C code. The header and stub file generator
accomplishes this by generating a C structure whose layout matches
that of the corresponding Java class.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You learned how to use the <TT>javah</TT> header and stub file generator on <A HREF="ch20.htm">Day 20</A>, &quot;Using Native Methods and Libraries.&quot; You can think of today's coverage as more of a reference for the <TT>javah</TT> tool itself since you 
learn about all the options supported by <TT>javah</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Usage6">Usage</A></H3>
<P>
The syntax for using the header and stub file generator follows:
<BLOCKQUOTE>
<PRE>
javah <I>Options ClassName</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>ClassName</I></TT> argument
is the name of the class to generate C source files from.
<H3><A NAME="TheOptionsArgument6">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
specifies how the source files are to be generated. Following
are the options supported by the stub file generator:
<BLOCKQUOTE>
<PRE>
-o OutputFile
-d <I>Dir
</I>-td <I>Dir
</I>-stubs
-verbose
-classpath <I>Path</I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-o</TT> option is used to
concatenate the resulting header and source files when multiple
classes are being operated on. When used, the <TT>-o</TT>
option results in the concatenated information being stored in
the file specified by <TT><I>OutputFile</I></TT>.
<P>
The <TT>-d</TT> option determines
the root directory where the generated header and source files
are stored. Along with writing the header and source files, the
header and stub file generator also writes its own temporary files.
The <TT>-td</TT> option specifies
the directory where these temporary files are stored. By default,
temporary files are stored in the directory specified by the <TT>%TEMP%</TT>
environment variable; the <TT>-td</TT>
option overrides this directory with <TT><I>Dir</I></TT>.
<P>
The <TT>-stubs</TT> option is probably
the most important option supported by the header and stub file
generator. The <TT>-stubs</TT> option
causes C declarations to be generated from the specified Java
class or classes. Without the <TT>-stubs</TT>
option, only header files are generated. When you use the <TT>-stubs</TT>
option, the header and stub file generator creates both header
and stub files, which are both typically required to incorporate
native C code with Java.
<P>
The <TT>-verbose</TT> option causes
the header and stub file generator to print a message to standard
output regarding the status of files as they are being generated.
Finally, the <TT>-classpath</TT> option
informs the header and stub file generator to override <TT>CLASSPATH</TT>
with the path specified by <TT><I>Path</I></TT>
when looking for the input class.
<H2><A NAME="TheDocumentationGenerator"><FONT SIZE=5 COLOR=#FF0000>
The Documentation Generator</FONT></A></H2>
<P>
The Java documentation generator (<TT>javadoc</TT>)
is a useful tool for generating programming documentation directly
from Java source code. The documentation generator parses through
Java source files and generates HTML pages based on the declarations
and comments. Sun's online Java API documentation was created
using the documentation generator, which attests to the practicality
of this tool.
<H3><A NAME="Usage7">Usage</A></H3>
<P>
The syntax for using the documentation generator follows:
<BLOCKQUOTE>
<PRE>
javadoc <I>Options FileName</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT><I>FileName</I></TT> argument
specifies either a package or a Java source code file. For source
code files, the documentation generator creates HTML pages based
on the special documentation comments (<TT>/**</TT>
and <TT>*/</TT>) used throughout the
code. The documentation generator reformats and includes all public
and protected declarations for classes, interfaces, methods, and
variables. You can include special documentation tags within the
documentation comments that allow you a little more power and
flexibility over the resulting documentation. You'll learn about
these tags in a moment.
<P>
The <TT><I>FileName</I></TT> parameter
to the documentation generator can also refer to a package name,
in which case documentation is created for all the classes contained
in the package. This is an easy way to crank out documentation
for a large set of classes with one easy command.
<H3><A NAME="TheOptionsArgument7">The <TT><I>Options</I></TT>Argument</FONT></A></H3>
<P>
The <TT><I>Options</I></TT> argument
enables you to change the default behavior of <TT>javadoc</TT>.
Following are the options supported by the documentation generator:
<BLOCKQUOTE>
<PRE>
-d <I>Dir
</I>-classpath <I>Path</I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT>-d</TT> option specifies where
the generated HTML documents are stored. The <TT>-classpath</TT>
option informs the documentation generator to override <TT>CLASSPATH</TT>
with the path specified by <TT><I>Path</I></TT>
when looking for the Java source files.
<H3><A NAME="DocumentationTags">Documentation Tags</A></H3>
<P>
The documentation generator supports special tags for adding extra
information to the generated HTML documents. All the tags begin
with an <TT>@</TT> symbol and must
appear at the beginning of a line. Following are the tags related
to the generation of class documentation:
<BLOCKQUOTE>
<PRE>
@see Classname
@see FullyQualifiedClassname
@see Classname.Methodname
@version Version
@author AuthorName
</PRE>
</BLOCKQUOTE>
<P>
The <TT>@see</TT> tags all add a &quot;see
also&quot; hyperlink to the HTML document that refers to a class
or method within a class. This is an easy way to provide associations
between classes in the documentation. Sun's Java API makes great
use of the <TT>@see</TT> tag to provide
cross-references between classes.
<P>
The <TT>@version</TT> tag allows you
to include version information with the class, as specified by
<TT><I>Version</I></TT>. <TT><I>Version</I></TT>
can contain any text you choose relating to the version of the
code. The <TT>@author</TT> tag lets
you provide the name of the author or authors of the source code,
as specified by <TT><I>AuthorName</I></TT>.
<P>
Following is an example of source code making use of the class
documentation tags:
<BLOCKQUOTE>
<PRE>
/**
 * A class for modeling precious gems.
 *
 * @see      Object
 * @see      gemology.Rock
 * @version  2.0  Dec 5, 1996
 * @author   Brett Weir
 */
class Gem extends Rock {
  // class definition
}
</PRE>
</BLOCKQUOTE>
<P>
Notice that the class documentation comment and tags appear just
before the class definition. This is important because the documentation
generator associates this comment with the <TT>Gem</TT>
class. You can also associate comments with variables and methods
in a similar way. For variables, you are limited to using the
<TT>@see</TT> tag. For methods, however,
you can use a few other tags:
<BLOCKQUOTE>
<PRE>
@param ParamName Description
@return <I>Description
</I>@exception<I> Classname Description</I>
</PRE>
</BLOCKQUOTE>
<P>
The <TT>@param</TT> tag is used to
add the method's parameters to the <TT>Parameters</TT>
section generated in the HTML document. The <TT>Parameters</TT>
section is an HTML section that lists the parameters required
of a method. <TT><I>ParamName</I></TT>
refers to the name of the parameter as defined by the method,
and <TT><I>Description</I></TT> is
a text description of the parameter.
<P>
The <TT>@return</TT> tag adds a <TT>Returns</TT>
section to the HTML document that brings attention to the return
value of the method. You simply provide a description of the return
value in <TT><I>Description</I></TT>.
<P>
Finally, the <TT>@exception</TT> tag
adds a <TT>Throws</TT> section to
the HTML document, which lists the exceptions potentially thrown
by the method. You specify the exception in <TT><I>Classname</I></TT>
along with a description of what circumstances result in the exception
being thrown in <BR>
<TT><I>Description</I></TT>. You can
use multiple exception tags. The documentation generator automatically
creates a hyperlink to the documentation for the exception class
referenced.
<P>
Following is an example of source code that uses the method tags:
<BLOCKQUOTE>
<PRE>
/**
 * Determines an estimate of the gem's value.
 *
 * @param      weight   The weight of the gem in carats.
 * @param      color    The color of the gem (0 -&gt; 1.0).
 * @param      clarity  The clarity of the gem (0 -&gt; 1.0).
 * @return     The estimated value of the gem.
 * @exception  NumberFormatException  When the color or clarity isn't
 *             in the range 0 -&gt; 1.0.
*/
public int estimateValue(float weight, float color, float clarity) {
  // method definition
}
</PRE>
</BLOCKQUOTE>
<H2><A NAME="VisualDevelopmentTools"><FONT SIZE=5 COLOR=#FF0000>
Visual Development Tools</FONT></A></H2>
<P>
Even though the JDK tools are powerful and certainly adequate
for serious Java programming, few people will argue the benefits
of using visual development tools. Along with providing feature-packed
source code editors, most visual tools combine many of the standard
Java programming tools within one environment. For example, from
one development environment you can typically edit, compile, run,
and debug Java programs. This seemingly simple merger of tools
can really help save precious development time.
<P>
Although providing visual versions of the standard Java command-line
tools is a benefit in and of itself, visual development tools
rarely stop there. Most visual tools also include sophisticated
project-management facilities as well as code-generation tools
for creating applet templates with complete source code that performs
a certain type of core functionality. Some visual tools even go
a step further and eliminate much of the programming. These tools
focus on harnessing prebuilt components that allow you to develop
Java programs without actually writing Java code. These types
of tools are typically a little more limited because of their
high-level design, but they can save enormous amounts of time
and energy in certain cases.
<P>
The rest of today's lesson focuses on some of the more popular
Java visual development tools that are currently available. My
intention isn't to rate the tools or persuade you to try one over
another. My goal is simply to let you know what's out there so
you can investigate what type of tool might suit your needs. Many
of the tools have evaluation versions that you can download for
free from an associated Web site, so you can very easily try them
out for yourself and come to your own conclusions. Have fun!
<H3><A NAME="SunsJavaWorkShop">Sun's Java WorkShop</A></H3>
<P>
Sun's Java WorkShop is a visual development tool written entirely
in Java. This is an interesting tool because its design is very
Web-centric, meaning that much of the tool itself is comprised
of Java applets embedded in HTML pages. Java WorkShop is currently
available for Windows and Solaris systems. You can check it out
at <TT><A HREF="http://www.sun.com/sunsoft/Developer-products/java/">http://www.sun.com/sunsoft/Developer-products/java/</A></TT>,
which is Sun's Java WorkShop Web site (see Figure 22.6).
<P>
<A HREF="http://docs.rinet.ru/J21/f22-6.gif"><B>Figure 22.6 : </B><I>Sun's Java WorkShop Web site</I>.</A>
<H3><A NAME="SymantecCafeacute">Symantec Caf&eacute;</A></H3>
<P>
Symantec Caf&eacute; is a visual Java development environment
based on Symantec's popular C++ development environment. It was
one of the first visual Java tools available and currently supports
both Windows and Macintosh platforms. You can get the latest information
about Caf&eacute; at Symantec's Caf&eacute; Web site (see Figure
22.7), which is located at <TT><A HREF="http://cafe.symantec.com/">http://cafe.symantec.com/</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-7.gif"><B>Figure 22.7 : </B><I>The Symantec CafeWeb site</I>.</A>
<H3><A NAME="MicrosoftVisualJ">Microsoft Visual J++</A></H3>
<P>
Microsoft finally decided to enter the Java development foray
in full force with Visual J++, which is a visual Java tool similar
to their popular Visual C++ development environment. Visual J++
currently is available only for the Windows platform. You can
check out Visual J++ at Microsoft's Visual J++ Web site (see Figure
22.8), which is located at <TT><A HREF="http://198.105.232.5/visualj/">http://198.105.232.5/visualj/</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-8.gif"><B>Figure 22.8 : </B><I>The Microsoft Visual J++ Web site</I>.</A>
<H3><A NAME="NaturalIntelligencesRoaster">Natural Intelligence's Roaster</A></H3>
<P>
Natural Intelligence's Roaster is the first Java development environment
targeted specifically for the Macintosh platform. For information
about Roaster, check out Natural Intelligence's Roaster Web site
(see Figure 22.9) at <TT><A HREF="http://www.natural.com/pages/products/roaster/">http://www.natural.com/pages/products/roaster/</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-9.gif"><B>Figure 22.9 : </B><I>Natural Intelligence's Roaster Web site</I>.</A>
<H3><A NAME="RogueWaveSoftwaresJFactory">Rogue Wave Software's JFactory</A></H3>
<P>
Rogue Wave Software's JFactory Java development tool is aimed
more at rapid application development with a minimal amount of
programming. This visual application generator is currently available
for the Windows platform. You can get more information about JFactory
from Rogue Wave Software's JFactory Web site (see Figure 22.10),
which is located at <TT><A HREF="http://www.roguewave.com/products/jfactory/jfactory.html">http://www.roguewave.com/products/jfactory/jfactory.html</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-10.gif"><B>Figure 22.10:  </B><I>Rogue Wave Software's JFactory Web site</I>.</A>
<H3><A NAME="PenumbraSoftwaresMojo">Penumbra Software's Mojo</A></H3>
<P>
Penumbra Software's Mojo development tool offers a programming
environment based largely on reusable components. Granted, this
is a trend common among many of the visual tools, but Mojo makes
a big attempt to minimize custom coding whenever possible. Mojo
is currently available for the Windows platform. You can check
out Mojo at Penumbra Soft-ware's Web site (see Figure 22.11),
which is located at <TT><A HREF="http://www.penumbrasoftware.com/">http://www.penumbrasoftware.com/</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-11.gif"><B>Figure 22.11: </B><I>Penumbra Software's Mojo Web site</I>.</A>
<H3><A NAME="AimtechsJamba">Aimtech's Jamba</A></H3>
<P>
Aimtech's Jamba is one of the first offerings in the area of high-level
visual Java tools. Jamba is aimed at Internet developers who want
to harness the power of Java without any programming or scripting.
Jamba is currently available for the Windows platform. You can
get the scoop on Jamba by taking a stroll through Aimtech's Jamba
Web site (see Figure 22.12), which is located at <TT><A HREF="http://www.aimtech.com/prodjahome.html">http://www.aimtech.com/prodjahome.html</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-12.gif"><B>Figure 22.12: </B><I>Animtech's Jamba Web site</I>.</A>
<H3><A NAME="KinetixsHyperwire">Kinetix's Hyperwire</A></H3>
<P>
The last of the visual tools is Kinetix's Hyperwire, which is
another high-level tool somewhat similar to Jamba. Unlike Jamba,
however, Hyperwire's emphasis is largely placed on creating highly
graphical Java applets, including 3D graphics. Hyperwire is currently
available for the Windows platform. You can get more information
about Hyperwire from Kinetix's Hyperwire Web site (see Figure
22.13), which is located at <TT><A HREF="http://www.ktx.com/products/hyperwire/">http://www.ktx.com/products/hyperwire/</A></TT>.
<P>
<A HREF="http://docs.rinet.ru/J21/f22-13.gif"><B>Figure 22.13: </B><I>Kinetix's Hyperwire Web site</I>.</A><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
High-level tools such as Jamba and Hyperwire are sometimes referred to as <I>authoring tools</I> because they involve little or no programming.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Even though Java is easier to use than some other programming
languages, becoming a proficient Java programmer still presents
a number of hurdles to most of us. One way to lower these hurdles
a little is to become well acquainted with the development tools
you are using. Possibly even more important is your initial choice
of development tools, which can greatly affect your effectiveness
as a Java programmer. Today's lesson addresses both of these concerns
by presenting you with an in-depth look at the standard JDK tools,
along with showing you some other options in the form of visual
development tools.
<P>
Ultimately, your selection of a development tool or tools will
depend on your level of expertise and your development style.
Regardless of what type of tool you gravitate toward, be sure
to take the time to learn all you can about it. If you are still
unsure about what kind of development tool to use, stick with
the JDK for a while, since it is guaranteed to meet the basic
requirements necessary to build Java programs. Besides, understanding
Java programming from the perspective of the standard JDK tools
will ultimately give you more insight into the &quot;big picture&quot;
of Java development.
<P>
You're probably tired of hearing me ramble on about tools by now.
That's OK, because tomorrow you shift gears and head straight
back into programming by learning about data structures in Java.
I'm sure you can't wait!
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>What is the significance of the profiler built into the runtime interpreter?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The profiler is useful in assessing the relative execution times of different parts of a Java program, which is crucial in situations in which you are trying to improve the performance of a 
Java program. With the information generated by the profiler, you can target specific sections of code to focus optimization efforts.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How do I compile multiple classes within a single source code file? I keep getting compiler errors!</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Even though you can compile multiple classes that are defined in one source code file, only one of the classes can be public. Furthermore, the source file must be named after the class that is 
public. The purpose here is to allow you to include support classes in the same file with public classes. However, you are only allowed one public class per source code file.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>When do I use the class file disassembler?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The class file disassembler, although powerful in its own right, isn't necessarily a tool you will find yourself using a lot. Its primary purpose is dissecting Java classes for which you don't 
have the source code. Using the disassembler, you can look at all the public methods and member variables for a class, which can help a lot when you're trying to figure out how the class works. If you have a knack for details and a lot of Tylenol, you can 
also use the disassembler to look at the raw bytecodes for classes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I still don't quite understand the distinction between development environments and authoring tools. What's the deal?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Both of these types of tools qualify as visual tools, but there is a distinct difference between them. Development environments essentially replace the standard command-line JDK tools with 
integrated visual versions, while sometimes also adding some extra features like project management and simple code generation. Authoring tools, on the other hand, completely move away from the idea of writing source code by providing you with a means to 
build programs purely by assembling preexisting components. The main difference, then, is that development environments target Java programmers, while authoring tools are readily accessible to nonprogrammers as well.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch21.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch23.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
