<HTML>
<HEAD>
<TITLE>appendix D -- Bytecodes Reference</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>appendix&nbsp;D</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Bytecodes Reference</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheTTFONTSIZEFACECourierquickFONTTTFONTSIZEBytecodesFONT">
The <TT>_quick</TT>
Bytecodes</FONT></A>
</UL>

<HR>
<P>
Let's look at a (progressively less and less) detailed description
of each class of bytecodes.
<P>
For each bytecode, some brief text describes its function and
a textual &quot;picture&quot; of the stack, both before and after
the bytecode has been executed, is shown. This text picture will
look like the following:
<BLOCKQUOTE>
<PRE>
..., value1, value2 =&gt; ..., value3
</PRE>
</BLOCKQUOTE>
<P>
This means that the bytecode expects two operands-<TT>value1</TT>
and <TT>value2</TT>-to be on the top
of the stack, pops them both off the stack, operates on them to
produce <TT>value3</TT>, and pushes
<TT>value3</TT> back onto the top
of the stack. You should read each stack from right to left, with
the rightmost value being the top of the stack. The <TT>...</TT>
is read as &quot;the rest of the stack below,&quot; which is irrelevant
to the current bytecode. All operands on the stack are 32 bits
wide.
<P>
Because most bytecodes take their arguments from the stack and
place their results back there, the brief text descriptions that
follow only say something about the source or destination of values
if they are <I>not</I> on the stack. For example, the description
<TT>&quot;Load integer from local variable.&quot;</TT>
means that the integer is loaded onto the stack, and <TT>&quot;Integer
add.&quot;</TT> intends its integers to be taken from-and
the result returned to-the stack.
<P>
Bytecodes that don't affect control flow simply move the <TT>pc</TT>
onto the next bytecode that follows in sequence. Those that do
affect the <TT>pc</TT> say so explicitly.
Whenever you see <TT>byte1</TT>, <TT>byte2</TT>,
and so forth, it refers to the first byte, second byte, and so
on, that follow the opcode byte itself. After such a bytecode
is executed, the <TT>pc</TT> automatically
advances over these operand bytes to start the next bytecode in
sequence.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The next few sections are in &quot;reference manual style,&quot; presenting each bytecode separately in all its (often redundant) detail; each bytecode is presented as an operation followed by an explanation. Later sections begin to collapse and coalesce 
this verbose style into something shorter and more readable. The verbose form is shown at first because the online reference manuals will look more like it, and because it drives home the point that each bytecode &quot;function&quot; comes in many, nearly 
identical bytecodes, one for each primitive type in Java.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Pushing Constants onto the Stack</H4>
<BLOCKQUOTE>
<PRE>
bipush        ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Push 1-byte signed integer. <TT>byte1</TT>
is interpreted as a signed 8-bit value. This <TT>value</TT>
is expanded to an <TT>int</TT> and
pushed onto the operand stack.
<BLOCKQUOTE>
<PRE>
sipush        ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Push 2-byte signed integer. <TT>byte1</TT>
and <TT>byte2</TT> are assembled into
a signed 16-bit value. This <TT>value</TT>
is expanded to an <TT>int</TT> and
pushed onto the operand stack.
<BLOCKQUOTE>
<PRE>
ldc1          ... =&gt; ..., item
</PRE>
</BLOCKQUOTE>
<P>
Push <TT>item</TT> from constant pool.
<TT>byte1</TT> is used as an unsigned
8-bit index into the constant pool of the current class. The <TT>item</TT>
at that index is resolved and pushed onto the stack.
<BLOCKQUOTE>
<PRE>
ldc2          ... =&gt; ..., item
</PRE>
</BLOCKQUOTE>
<P>
Push <TT>item</TT> from constant pool.
<TT>byte1</TT> and <TT>byte2</TT>
are used to construct an unsigned 16-bit index into the constant
pool of the current class. The <TT>item</TT>
at that index is resolved and pushed onto the stack.
<BLOCKQUOTE>
<PRE>
ldc2w         ... =&gt; ..., constant-word1, constant-word2
</PRE>
</BLOCKQUOTE>
<P>
Push <TT>long</TT> or <TT>double</TT>
from constant pool. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an unsigned 16-bit index into the constant pool of the current
class. The two-word constant at that index is resolved and pushed
onto the stack.
<BLOCKQUOTE>
<PRE>
aconst_null   ... =&gt; ..., null
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>null</TT> object reference
onto the stack.
<BLOCKQUOTE>
<PRE>
iconst_m1     ... =&gt; ..., -1
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>int -1</TT> onto the
stack.
<BLOCKQUOTE>
<PRE>
iconst_&lt;I&gt;    ... =&gt; ..., &lt;I&gt;
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>int &lt;I&gt;</TT> onto
the stack. There are six of these bytecodes, one for each of the
integers 0-5: <TT>iconst_0</TT>, <TT>iconst_1</TT>,
<TT>iconst_2</TT>, <TT>iconst_3</TT>,
<TT>iconst_4</TT>, and <TT>iconst_5</TT>.
<BLOCKQUOTE>
<PRE>
lconst_&lt;L&gt;    ... =&gt; ..., &lt;L&gt;-word1, &lt;L&gt;-word2
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>long &lt;L&gt;</TT> onto
the stack. There are two of these bytecodes, one for each of the
integers 0 and 1: <TT>lconst_0</TT>
and <TT>lconst_1</TT>.
<BLOCKQUOTE>
<PRE>
fconst_&lt;F&gt;    ... =&gt; ..., &lt;F&gt;
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>float &lt;F&gt;</TT>
onto the stack. There are three of these bytecodes, one for each
of the integers 0-2: <TT>fconst_0</TT>,
<TT>fconst_1</TT>, and <TT>fconst_2</TT>.
<BLOCKQUOTE>
<PRE>
dconst_&lt;D&gt;    ... =&gt; ..., &lt;D&gt;-word1, &lt;D&gt;-word2
</PRE>
</BLOCKQUOTE>
<P>
Push the <TT>double &lt;D&gt;</TT>
onto the stack. There are two of these bytecodes, one for each
of the integers 0 and 1: <TT>dconst_0</TT>,
and <TT>dconst_1</TT>.
<H4>Loading Local Variables onto the Stack</H4>
<BLOCKQUOTE>
<PRE>
iload         ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>int</TT> from local variable.
Local variable <TT>byte1</TT> in the
current Java frame must contain an <TT>int</TT>.
The <TT>value</TT> of that variable
is pushed onto the operand stack.
<BLOCKQUOTE>
<PRE>
iload_&lt;I&gt;     ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>int</TT> from local variable.
Local variable <TT>&lt;I&gt;</TT>
in the current Java frame must contain an <TT>int</TT>.
The <TT>value</TT> of that variable
is pushed onto the operand stack. There are four of these bytecodes,
one for each of the integers 0-3: <TT>iload_0</TT>,
<TT>iload_1</TT>, <TT>iload_2</TT>,
and <TT>iload_3</TT>.
<BLOCKQUOTE>
<PRE>
lload         ... =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>long</TT> from local variable.
Local variables <TT>byte1</TT> and
<TT>byte1 + 1</TT> in the current
Java frame must together contain a long integer. The values contained
in those variables are pushed onto the operand stack.
<BLOCKQUOTE>
<PRE>
lload_&lt;L&gt;     ... =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>long</TT> from local variable.
Local variables <TT>&lt;L&gt;</TT>
and <TT>&lt;L&gt; + 1</TT> in the
current Java frame must together contain a long integer. The value
contained in those variables is pushed onto the operand stack.
There are four of these bytecodes, one for each of the integers
0-3: <TT>lload_0</TT>, <TT>lload_1</TT>,
<TT>lload_2</TT>, and <TT>lload_3</TT>.
<BLOCKQUOTE>
<PRE>
fload         ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>float</TT> from local variable.
Local variable <TT>byte1</TT> in the
current Java frame must contain a single-precision floating-point
number. The <TT>value</TT> of that
variable is pushed onto the operand stack.
<BLOCKQUOTE>
<PRE>
fload_&lt;F&gt;     ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>float</TT> from local variable.
Local variable <TT>&lt;F&gt;</TT>
in the current Java frame must contain a single-precision floating-point
number. The value of that variable is pushed onto the operand
stack. There are four of these bytecodes, one for each of the
integers 0-3: <TT>fload_0</TT>, <TT>fload_1</TT>,
<TT>fload_2</TT>, and <TT>fload_3</TT>.
<BLOCKQUOTE>
<PRE>
dload         ... =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>double</TT> from local variable.
Local variables <TT>byte1</TT> and
<TT>byte1 + 1</TT> in the current
Java frame must together contain a double-precision floating-point
number. The value contained in those variables is pushed onto
the operand stack.
<BLOCKQUOTE>
<PRE>
dload_&lt;D&gt;     ... =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>double</TT> from local variable.
Local variables <TT>&lt;D&gt;</TT>
and <TT>&lt;D&gt; + 1</TT> in the
current Java frame must together contain a double-precision floating-point
number. The value contained in those variables is pushed onto
the operand stack. There are four of these bytecodes, one for
each of the integers 0-3: <TT>dload_0</TT>,
<TT>dload1</TT>, <TT>dload_2</TT>,
and <TT>dload_3</TT>.
<BLOCKQUOTE>
<PRE>
aload         ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load object reference from local variable. Local variable <TT>byte1</TT>
in the current Java frame must contain a return address or reference
to an object or array. The value of that variable is pushed onto
the operand stack.
<BLOCKQUOTE>
<PRE>
aload_&lt;A&gt;     ... =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load object reference from local variable. Local variable <TT>&lt;A&gt;</TT>
in the current Java frame must contain a return address or reference
to an object. The value of that variable is pushed onto the operand
stack. There are four of these bytecodes, one for each of the
integers 0-3: <TT>aload_0</TT>, <TT>aload_1</TT>,
<TT>aload_2</TT>, and <TT>aload_3</TT>.
<H4>Storing Stack Values into Local Variables</H4>
<BLOCKQUOTE>
<PRE>
istore        ..., value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>int</TT> into local variable.
<TT>value</TT> must be an <TT>int</TT>.
Local variable <TT>byte1</TT> in the
current Java frame is set to <TT>value</TT>.
<BLOCKQUOTE>
<PRE>
istore_&lt;I&gt;    ..., value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>int</TT> into local variable.
<TT>value</TT> must be an <TT>int</TT>.
Local variable <TT>&lt;I&gt;</TT>
in the current Java frame is set to <TT>value</TT>.
There are four of these bytecodes, one for each of the integers
0-3: <TT>istore_0</TT>, <TT>istore_1</TT>,
<TT>istore_2</TT>, and <TT>istore_3</TT>.
<BLOCKQUOTE>
<PRE>
lstore        ..., value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>long</TT> into local variable.
<TT>value</TT> must be a long integer.
Local variables <TT>byte1</TT> and
<TT>byte1 + 1</TT> in the current
Java frame are set to <TT>value</TT>.
<BLOCKQUOTE>
<PRE>
lstore_&lt;L&gt;    ..., value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>long</TT> into local variable.
<TT>value</TT> must be a long integer.
Local variables <TT>&lt;L&gt;</TT>
and <TT>&lt;L&gt; + 1</TT> in the
current Java frame are set to <TT>value</TT>.
There are four of these bytecodes, one for each of the integers
0-3: <TT>lstore_0</TT>, <TT>lstore_1</TT>,
<TT>lstore_2</TT>, and <TT>lstore_3</TT>.
<BLOCKQUOTE>
<PRE>
fstore        ..., value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>float</TT> into local variable.
<TT>value</TT> must be a single-precision
floating-point number. Local variable <TT>byte1</TT>
in the current Java frame is set to <TT>value</TT>.
<BLOCKQUOTE>
<PRE>
fstore_&lt;F&gt;    ..., value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>float</TT> into local variable.
<TT>value</TT> must be a single-precision
floating-point number. Local variable <TT>&lt;F&gt;</TT>
in the current Java frame is set to <TT>value</TT>.
There are four of these bytecodes, one for each of the integers
0-3: <TT>fstore_0</TT>, <TT>fstore_1</TT>,
<TT>fstore_2</TT>, and <TT>fstore_3</TT>.
<BLOCKQUOTE>
<PRE>
dstore        ..., value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>double</TT> into local variable.
<TT>value</TT> must be a double-precision
floating-point number. Local variables <TT>byte1</TT>
and <TT>byte1 + 1</TT> in the current
Java frame are set to <TT>value</TT>.
<BLOCKQUOTE>
<PRE>
dstore_&lt;D&gt;    ..., value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store <TT>double</TT> into local variable.
<TT>value</TT> must be a double-precision
floating-point number. Local variables <TT>&lt;D&gt;</TT>
and <TT>&lt;D&gt; + 1</TT> in the
current Java frame are set to <TT>value</TT>.
There are four of these bytecodes, one for each of the integers
0-3: <TT>dstore_0</TT>, <TT>dstore_1</TT>,
<TT>dstore_2</TT>, and <TT>dstore_3</TT>.
<BLOCKQUOTE>
<PRE>
astore        ..., handle =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store object reference into local variable. <TT>handle</TT>
must be a return address or a reference to an object. Local variable
<TT>byte1</TT> in the current Java
frame is set to <TT>value</TT>.
<BLOCKQUOTE>
<PRE>
astore_&lt;A&gt;    ..., handle =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store object reference into local variable. <TT>handle</TT>
must be a return address or a reference to an object. Local variable
<TT>&lt;A&gt;</TT> in the current
Java frame is set to <TT>value</TT>.
There are four of these bytecodes, one for each of the integers
0-3: <TT>astore_0</TT>, <TT>astore_1</TT>,
<TT>astore_2</TT>, and <TT>astore_3</TT>.
<BLOCKQUOTE>
<PRE>
iinc          -no change-
</PRE>
</BLOCKQUOTE>
<P>
Increment local variable by constant. Local variable <TT>byte1</TT>
in the current Java frame must contain an <TT>int</TT>.
Its value is incremented by the value <TT>byte2</TT>,
where <TT>byte2</TT> is treated as
a signed 8-bit quantity.
<H4>Managing Arrays</H4>
<BLOCKQUOTE>
<PRE>
newarray        ..., size =&gt; result
</PRE>
</BLOCKQUOTE>
<P>
Allocate new array. <TT>size</TT>
must be an <TT>int</TT>; it represents
the number of elements in the new array. <TT>byte1</TT>
is an internal code that indicates the type of array to allocate.
Possible values for <TT>byte1</TT>
are as follows: <TT>T_BOOLEAN</TT>
(<TT>4</TT>), <TT>T_chAR</TT>
(<TT>5</TT>), <TT>T_FLOAT</TT>
(<TT>6</TT>), <TT>T_DOUBLE</TT>
(<TT>7</TT>), <TT>T_BYTE</TT>
(<TT>8</TT>), <TT>T_SHORT</TT>
(<TT>9</TT>), <TT>T_INT</TT>
(<TT>10</TT>), and <TT>T_LONG</TT>
(<TT>11</TT>).
<P>
An attempt is made to allocate a new array of the indicated type,
capable of holding <TT>size</TT> elements.
This will be the <TT>result</TT>.
If <TT>size</TT> is less than zero,
a <TT>NegativeArraySizeException</TT>
is thrown. If there is not enough memory to allocate the array,
an <TT>OutOfMemoryError</TT> is thrown.
All elements of the array are initialized to their default values.
<BLOCKQUOTE>
<PRE>
anewarray       ..., size =&gt; result
</PRE>
</BLOCKQUOTE>
<P>
Allocate new array of objects. <TT>size</TT>
must be an <TT>int</TT>; it represents
the number of elements in the new array. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index is resolved. The resulting entry must be a class.
<P>
An attempt is made to allocate a new array of the indicated class
type, capable of holding <TT>size</TT>
elements. This will be the <TT>result</TT>.
If <TT>size</TT> is less than <TT>0</TT>,
a <TT>NegativeArraySizeException</TT>
is thrown. If there is not enough memory to allocate the array,
an <TT>OutOfMemoryError</TT> is thrown.
All elements of the array are initialized to <TT>null</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>anewarray</TT> is used to create a single dimension of an array of objects. For example, the request new <TT>Thread[7]</TT> generates the following bytecodes:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;bipush 7<BR>
&nbsp;&nbsp;&nbsp;&nbsp;anewarray &lt;Class &quot;java.lang.Thread&quot;&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>anewarray</TT> can also be used to create the outermost dimension of a multidimensional array. For example, the array declaration <TT>new int[6][]</TT> generates this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;bipush 6<BR>
&nbsp;&nbsp;&nbsp;&nbsp;anewarray &lt;Class &quot;[I&quot;&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
(See the section &quot;Method Signatures&quot; for more information on strings such as <TT>&quot;[I&quot;</TT>.)
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
multianewarray  ..., size1 size2...sizeN =&gt; result
</PRE>
</BLOCKQUOTE>
<P>
Allocate new multidimensional array. Each <TT>size&lt;I&gt;</TT>
must be an <TT>int</TT>; each represents
the number of elements in a dimension of the array. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index is resolved. The resulting entry must be an array
class of one or more dimensions.
<P>
<TT>byte3</TT> is a positive integer
representing the number of dimensions being created. It must be
less than or equal to the number of dimensions of the array class.
<TT>byte3</TT> is also the number
of elements that are popped off the stack. All must be <TT>int</TT>s
greater than or equal to zero. These are used as the sizes of
the dimensions. An attempt is made to allocate a new array of
the indicated class type, capable of holding <TT>size&lt;1&gt;
* size&lt;2&gt; * ... * &lt;sizeN&gt;</TT> elements. This
will be the <TT>result</TT>. If any
of the <TT>size&lt;I&gt;</TT> arguments
on the stack is less than zero, a <TT>NegativeArraySizeException</TT>
is thrown. If there is not enough memory to allocate the array,
an <TT>OutOfMemoryError</TT> is thrown.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>new int[6][3][]</TT> generates these bytecodes:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;bipush 6<BR>
&nbsp;&nbsp;&nbsp;&nbsp;bipush 3<BR>
&nbsp;&nbsp;&nbsp;&nbsp;multianewarray &lt;Class &quot;[[[I&quot;&gt; 2</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
It's more efficient to use <TT>newarray</TT> or <TT>anewarray</TT> when creating arrays of single dimension.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
arraylength     ..., array =&gt; ..., length
</PRE>
</BLOCKQUOTE>
<P>
Get length of array. <TT>array</TT>
must be a reference to an array object. The <TT>length</TT>
of the array is determined and replaces <TT>array</TT>
on the top of the stack. If <TT>array</TT>
is null, a <TT>NullPointerException</TT>
is thrown.
<BLOCKQUOTE>
<PRE>
iaload          ..., array, index =&gt; ..., value
laload          ..., array, index =&gt; ..., value-word1, value-word2
faload          ..., array, index =&gt; ..., value
daload          ..., array, index =&gt; ..., value-word1, value-word2
aaload          ..., array, index =&gt; ..., value
baload          ..., array, index =&gt; ..., value
caload          ..., array, index =&gt; ..., value
saload          ..., array, index =&gt; ..., value
</PRE>
</BLOCKQUOTE>
<P>
Load <TT>&lt;<I>type</I>&gt;</TT>
from array. <TT>array</TT> must be
an array of <TT>&lt;<I>type</I>&gt;</TT>s.
<TT>index</TT> must be an <TT>int</TT>.
The <TT>&lt;<I>type</I>&gt; value</TT>
at position number <TT>index</TT>
in <TT>array</TT> is retrieved and
pushed onto the top of the stack. If <TT>array</TT>
is <TT>null</TT>, a <TT>NullPointerException</TT>
is thrown. If <TT>index</TT> is not
within the bounds of <TT>array</TT>,
an <TT>ArrayIndexOutOfBoundsException</TT>
is thrown. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, <TT>double</TT>,
object reference, <TT>byte</TT>, <TT>char</TT>,
and <TT>short</TT>. <TT>&lt;<I>type</I>&gt;</TT>s
<TT>long</TT> and <TT>double</TT>
have two word <TT>value</TT>s, as
you've seen in previous <TT>load</TT>
bytecodes.
<BLOCKQUOTE>
<PRE>
iastore         ..., array, index, value =&gt; ...
lastore         ..., array, index, value-word1, value-word2 =&gt; ...
fastore         ..., array, index, value =&gt; ...
dastore         ..., array, index, value-word1, value-word2 =&gt; ...
aastore         ..., array, index, value =&gt; ...
bastore         ..., array, index, value =&gt; ...
castore         ..., array, index, value =&gt; ...
sastore         ..., array, index, value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Store into <TT>&lt;<I>type</I>&gt; array</TT>.
<TT>array</TT> must be an array of
<TT>&lt;<I>type</I>&gt;</TT>s, <TT>index</TT>
must be an <TT>int</TT>, and <TT>value</TT>
a <TT>&lt;<I>type</I>&gt;</TT>. The
<TT>&lt;<I>type</I>&gt;</TT> <TT>value</TT>
is stored at position <TT>index</TT>
in <TT>array</TT>. If <TT>array</TT>
is <TT>null</TT>, a <TT>NullPointerException</TT>
is thrown. If <TT>index</TT> is not
within the bounds of array, an <TT>ArrayIndexOutOfBoundsException</TT>
is thrown. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, <TT>double</TT>,
object reference, <TT>byte</TT>, <TT>char</TT>,
and <TT>short</TT>. <TT>&lt;<I>type</I>&gt;</TT>s
<TT>long</TT> and <TT>double</TT>
have two word <TT>value</TT>s, as
you've seen in previous <TT>store</TT>
bytecodes.
<H4>Stack Operations</H4>
<BLOCKQUOTE>
<PRE>
nop        -no change-
</PRE>
</BLOCKQUOTE>
<P>
Do nothing.
<BLOCKQUOTE>
<PRE>
pop        ..., any =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Pop the top word from the stack.
<BLOCKQUOTE>
<PRE>
pop2       ..., any2, any1 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Pop the top two words from the stack.
<BLOCKQUOTE>
<PRE>
dup        ..., any =&gt; ..., any, any
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top word on the stack.
<BLOCKQUOTE>
<PRE>
dup2       ..., any2, any1 =&gt; ..., any2, any1, any2,any1
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top two words on the stack.
<BLOCKQUOTE>
<PRE>
dup_x1     ..., any2, any1 =&gt; ..., any1, any2,any1
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top word on the stack and insert the copy two words
down in the stack.
<BLOCKQUOTE>
<PRE>
dup2_x1    ..., any3, any2, any1 =&gt; ..., any2, any1, any3,any2,any1
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top two words on the stack and insert the copies
two words down in the stack.
<BLOCKQUOTE>
<PRE>
dup_x2     ..., any3, any2, any1 =&gt; ..., any1, any3,any2,any1
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top word on the stack and insert the copy three
words down in the stack.
<BLOCKQUOTE>
<PRE>
dup2_x2    ..., any4, any3, any2, any1 =&gt; ..., any2, any1, any4,any3,any2,any1
</PRE>
</BLOCKQUOTE>
<P>
Duplicate the top two words on the stack and insert the copies
three words down in the stack.
<BLOCKQUOTE>
<PRE>
swap       ..., any2, any1 =&gt; ..., any1, any2
</PRE>
</BLOCKQUOTE>
<P>
Swap the top two elements on the stack.
<H4>Arithmetic Operations</H4>
<BLOCKQUOTE>
<PRE>
iadd       ..., v1, v2 =&gt; ..., result
ladd       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
fadd       ..., v1, v2 =&gt; ..., result
dadd       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>&lt;<I>type</I>&gt;</TT>s.
The <TT>v</TT>s are added and are
replaced on the stack by their <TT>&lt;<I>type</I>&gt;</TT>
sum. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BLOCKQUOTE>
<PRE>
isub       ..., v1, v2 =&gt; ..., result
lsub       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
fsub       ..., v1, v2 =&gt; ..., result
dsub       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>&lt;type&gt;</TT>s. <TT>v2</TT>
is subtracted from <TT>v1</TT>, and
both <TT>v</TT>s are replaced on the
stack by their <TT>&lt;<I>type</I>&gt;</TT>
difference. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BLOCKQUOTE>
<PRE>
imul       ..., v1, v2 =&gt; ..., result
lmul       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
fmul       ..., v1, v2 =&gt; ..., result
dmul       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>&lt;<I>type</I>&gt;</TT>s.
Both <TT>v</TT>s are replaced on the
stack by their <TT>&lt;<I>type</I>&gt;</TT>
product. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BLOCKQUOTE>
<PRE>
idiv       ..., v1, v2 =&gt; ..., result
ldiv       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
fdiv       ..., v1, v2 =&gt; ..., result
ddiv       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>&lt;<I>type</I>&gt;</TT>s.
<TT>v2</TT> is divided by <TT>v1</TT>,
and both <TT>v</TT>s are replaced
on the stack by their <TT>&lt;<I>type</I>&gt;</TT>
quotient. An attempt to divide by zero results in an <TT>ArithmeticException</TT>
being thrown. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BLOCKQUOTE>
<PRE>
irem       ..., v1, v2 =&gt; ..., result
lrem       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
frem       ..., v1, v2 =&gt; ..., result
drem       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>&lt;<I>type</I>&gt;</TT>s.
<TT>v2</TT> is divided by <TT>v1</TT>,
and both <TT>v</TT>s are replaced
on the stack by their <TT>&lt;<I>type</I>&gt;</TT>
remainder. An attempt to divide by zero results in an <TT>ArithmeticException</TT>
being thrown. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BLOCKQUOTE>
<PRE>
ineg       ..., value =&gt; ..., result
lneg       ..., value-word1, value-word2 =&gt; ..., result-word1, result-word2
fneg       ..., value =&gt; ..., result
dneg       ..., value-word1, value-word2 =&gt; ..., result-word1, result-word2
</PRE>
</BLOCKQUOTE>
<P>
<TT>value</TT> must be a <TT>&lt;<I>type</I>&gt;</TT>.
It is replaced on the stack by its arithmetic negation. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Now that you're familiar with the look of the bytecodes, the summaries that follow will become shorter and shorter (for space reasons). You can always get any desired level of detail from the full virtual machine specification in the latest Java 
release.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Logical Operations</H4>
<BLOCKQUOTE>
<PRE>
ishl       ..., v1, v2 =&gt; ..., result
lshl       ..., v1-word1, v1-word2, v2 =&gt; ..., r-word1, r-word2
ishr       ..., v1, v2 =&gt; ..., result
lshr       ..., v1-word1, v1-word2, v2 =&gt; ..., r-word1, r-word2
iushr      ..., v1, v2 =&gt; ..., result
lushr      ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
For types <TT>int</TT> and <TT>long</TT>:
arithmetic shift left, shift right, and logical shift right.
<BLOCKQUOTE>
<PRE>
iand       ..., v1, v2 =&gt; ..., result
land       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
ior        ..., v1, v2 =&gt; ..., result
lor        ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
ixor       ..., v1, v2 =&gt; ..., result
lxor       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., r-word1, r-word2
</PRE>
</BLOCKQUOTE>
<P>
For types <TT>int</TT> and <TT>long</TT>:
bitwise <TT>AND</TT>, <TT>OR</TT>,
and <TT>XOR</TT>.
<H4>Conversion Operations</H4>
<BLOCKQUOTE>
<PRE>
i2l         ..., value =&gt; ..., result-word1, result-word2
i2f         ..., value =&gt; ..., result
i2d         ..., value =&gt; ..., result-word1, result-word2
l2i         ..., value-word1, value-word2 =&gt; ..., result
l2f         ..., value-word1, value-word2 =&gt; ..., result
l2d         ..., value-word1, value-word2 =&gt; ..., result-word1, result-word2
f2i         ..., value =&gt; ..., result
f2l         ..., value =&gt; ..., result-word1, result-word2
f2d         ..., value =&gt; ..., result-word1, result-word2
d2i         ..., value-word1, value-word2 =&gt; ..., result
d2l         ..., value-word1, value-word2 =&gt; ..., result-word1, result-word2
d2f         ..., value-word1, value-word2 =&gt; ..., result

int2byte    ..., value =&gt; ..., result
int2char    ..., value =&gt; ..., result
int2short   ..., value =&gt; ..., result
</PRE>
</BLOCKQUOTE>
<P>
These bytecodes convert from a <TT>value</TT>
of type <TT>&lt;<I>lhs</I>&gt;</TT>
to a <TT>result</TT> of type <TT>&lt;<I>rhs</I>&gt;</TT>.
<TT>&lt;<I>lhs</I>&gt;</TT> and <TT>&lt;<I>rhs</I>&gt;</TT>
can be any of <TT>i</TT>, <TT>l</TT>,
<TT>f</TT>, and <TT>d</TT>,
which represent <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>,
respectively. The final three bytecodes convert types that are
self-explanatory.
<H4>Transfer of Control</H4>
<BLOCKQUOTE>
<PRE>
ifeq        ..., value =&gt; ...
ifne        ..., value =&gt; ...
iflt        ..., value =&gt; ...
ifgt        ..., value =&gt; ...
ifle        ..., value =&gt; ...
ifge        ..., value =&gt; ...

if_icmpeq   ..., value1, value2 =&gt; ...
if_icmpne   ..., value1, value2 =&gt; ...
if_icmplt   ..., value1, value2 =&gt; ...
if_icmpgt   ..., value1, value2 =&gt; ...
if_icmple   ..., value1, value2 =&gt; ...
if_icmpge   ..., value1, value2 =&gt; ...

ifnull      ..., value =&gt; ...
ifnonnull   ..., value =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
When <TT>value &lt;<I>rel</I>&gt; 0</TT>
is <TT>true</TT> in the first set
of bytecodes, <TT>value1</TT> <TT>&lt;<I>rel</I>&gt;
value2</TT> is <TT>true</TT>
in the second set, or <TT>value</TT>
is <TT>null</TT> (or not <TT>null</TT>)
in the third, <TT>byte1</TT> and <TT>byte2</TT>
are used to construct a signed 16-bit offset. Execution proceeds
at that offset from the <TT>pc</TT>.
Otherwise, execution proceeds at the bytecode following. <TT>&lt;<I>rel</I>&gt;</TT>
is one of <TT>eq</TT>, <TT>ne</TT>,
<TT>lt</TT>, <TT>gt</TT>,
<TT>le</TT>, and <TT>ge</TT>,
which represent equal, not equal, less than, greater than, less
than or equal, and greater than or equal, respectively.
<BLOCKQUOTE>
<PRE>
lcmp        ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., result

fcmpl       ..., v1, v2 =&gt; ..., result
dcmpl       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., result

fcmpg       ..., v1, v2 =&gt; ..., result
dcmpg       ..., v1-word1, v1-word2, v2-word1, v2-word2 =&gt; ..., result
</PRE>
</BLOCKQUOTE>
<P>
<TT>v1</TT> and <TT>v2</TT>
must be <TT>long</TT>, <TT>float</TT>,
or <TT>double</TT>. They are both
popped from the stack and compared. If <TT>v1</TT>
is greater than <TT>v2</TT>, the <TT>int</TT>
value <TT>1</TT> is pushed onto the
stack. If <TT>v1</TT> is equal to
<TT>v2</TT>, <TT>0</TT>
is pushed onto the stack. If <TT>v1</TT>
is less than <TT>v2</TT>, <TT>-1</TT>
is pushed onto the stack. For floating-point, if either <TT>v1</TT>
or <TT>v2</TT> is <TT>NaN</TT>,
<TT>-1</TT> is pushed onto the stack
for the first pair of bytecodes, <TT>+1</TT>
for the second pair.
<BLOCKQUOTE>
<PRE>
if_acmpeq   ..., value1, value2 =&gt; ...
if_acmpne   ..., value1, value2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Branch if object references are equal/not equal. <TT>value1</TT>
and <TT>value2</TT> must be references
to objects. They are both popped from the stack. If <TT>value1</TT>
is equal/not equal to <TT>value2</TT>,
<TT>byte1</TT> and <TT>byte2</TT>
are used to construct a signed 16-bit offset. Execution proceeds
at that offset from the <TT>pc</TT>.
Otherwise, execution proceeds at the bytecode following.
<BLOCKQUOTE>
<PRE>
goto        -no change-
goto_w      -no change-
</PRE>
</BLOCKQUOTE>
<P>
Branch always. <TT>byte1</TT> and
<TT>byte2</TT> (plus <TT>byte3</TT>
and <TT>byte4</TT> for <TT>goto_w</TT>)
are used to construct a signed 16-bit (32-bit) offset. Execution
proceeds at that offset from the <TT>pc</TT>.
<BLOCKQUOTE>
<PRE>
jsr         ... =&gt; ..., return-address
jsr-w       ... =&gt; ..., return-address
</PRE>
</BLOCKQUOTE>
<P>
Jump subroutine. The address of the bytecode immediately following
the <TT>jsr</TT> is pushed onto the
stack. <TT>byte1</TT> and <TT>byte2</TT>
(plus <TT>byte3</TT> and <TT>byte4</TT>
for <TT>goto_w</TT>) are used to construct
a signed 16-bit (32-bit) offset. Execution proceeds at that offset
from the <TT>pc</TT>.
<BLOCKQUOTE>
<PRE>
ret         -no change-
ret2_w      -no change-
</PRE>
</BLOCKQUOTE>
<P>
Return from subroutine. Local variable <TT>byte1</TT>
(plus <TT>byte2</TT> for <TT>ret_w</TT>
are assembled into a 16-bit index) in the current Java frame must
contain a return address. The contents of that local variable
are written into the <TT>pc</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>jsr</TT> pushes the address onto the stack, and <TT>ret</TT> gets it out of a local variable. This asymmetry is intentional. The <TT>jsr</TT> and <TT>ret</TT> bytecodes are used in the implementation of Java's <TT>finally</TT> keyword.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Method Return</H4>
<BLOCKQUOTE>
<PRE>
return      ... =&gt; [empty]q
</PRE>
</BLOCKQUOTE>
<P>
Return (<TT>void</TT>) from method.
All values on the operand stack are discarded. The interpreter
then returns control to its caller.
<BLOCKQUOTE>
<PRE>
ireturn     ..., value =&gt; [empty]
lreturn     ..., value-word1, value-word2 =&gt; [empty]
freturn     ..., value =&gt; [empty]
dreturn     ..., value-word1, value-word2 =&gt; [empty]
areturn     ..., value =&gt; [empty]
</PRE>
</BLOCKQUOTE>
<P>
Return <TT>&lt;<I>type</I>&gt;</TT>
from method. <TT>value</TT> must be
a <TT>&lt;<I>type</I>&gt;</TT>. The
<TT>value</TT> is pushed onto the
stack of the previous execution environment. Any other values
on the operand stack are discarded. The interpreter then returns
control to its caller. <TT>&lt;<I>type</I>&gt;</TT>
is, in turn, <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, <TT>double</TT>,
and object reference.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The stack behavior of the &quot;return&quot; bytecodes may be confusing to anyone expecting the Java operand stack to be just like the C stack. Java's operand stack actually consists of a number of noncontiguous segments, each corresponding to a method 
call. A return bytecode empties the Java operand stack segment corresponding to the frame of the returning call, but does not affect the segment of any parent calls.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Table Jumping</H4>
<BLOCKQUOTE>
<PRE>
tableswitch   ..., index =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
<TT>tableswitch</TT> is a variable-length
bytecode. Immediately after the <TT>tableswitch</TT>
opcode, zero to three <TT>0</TT> bytes
are inserted as padding so that the next byte begins at an address
that is a multiple of four. After the padding are a series of
signed 4-byte quantities: <TT>default-offset</TT>,
<TT>low</TT>, <TT>high</TT>,
and then (<TT>high - low + 1)</TT>
further signed 4-byte offsets. These offsets are treated as a
<TT>0</TT>-based jump table.
<P>
The <TT>index</TT> must be an <TT>int</TT>.
If <TT>index</TT> is less than <TT>low</TT>
or <TT>index</TT> is greater than
<TT>high</TT>, <TT>default-offset</TT>
is added to the <TT>pc</TT>. Otherwise,
the <TT>(index - low)</TT>th element
of the jump table is extracted and added to the <TT>pc</TT>.
<BLOCKQUOTE>
<PRE>
lookupswitch  ..., key =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
<TT>lookupswitch</TT> is a variable-length
bytecode. Immediately after the <TT>lookupswitch</TT>
opcode, zero to three <TT>0</TT> bytes
are inserted as padding so that the next byte begins at an address
that is a multiple of four. Immediately after the padding is a
series of pairs of signed 4-byte quantities. The first pair is
special; it contains the <TT>default-offset</TT>
and the number of pairs that follow. Each subsequent pair consists
of a <TT>match</TT> and an <TT>offset</TT>.
<P>
The <TT>key</TT> on the stack must
be an <TT>int</TT>. This <TT>key</TT>
is compared to each of the <TT>match</TT>es.
If it is equal to one of them, the corresponding <TT>offset</TT>
is added to the <TT>pc</TT>. If the
<TT>key</TT> does not match any of
the <TT>match</TT>es, the <TT>default-offset</TT>
is added to the <TT>pc</TT>.
<H4>Manipulating Object Fields</H4>
<BLOCKQUOTE>
<PRE>
putfield      ..., handle, value =&gt; ...
putfield      ..., handle, value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Set field in object. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The constant
pool item is a field reference to a class name and a field name.
The item is resolved to a field block pointer containing the field's
width and offset (both in bytes).
<P>
The field at that offset from the start of the instance pointed
to by <TT>handle</TT> will be set
to the <TT>value</TT> on the top of
the stack. The first stack picture is for 32-bit, and the second
for 64-bit-wide fields. This bytecode handles both. If <TT>handle</TT>
is <TT>null</TT>, a <TT>NullPointerException</TT>
is thrown. If the specified field is a <TT>static</TT>
field, an <TT>IncompatibleClassChangeError</TT>
is thrown.
<BLOCKQUOTE>
<PRE>
getfield      ..., handle =&gt; ..., value
getfield      ..., handle =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Fetch field from object. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The constant
pool item will be a field reference to a class name and a field
name. The item is resolved to a field block pointer containing
the field's width and offset (both in bytes).
<P>
<TT>handle</TT> must be a reference
to an object. The <TT>value</TT> at
offset into the object referenced by <TT>handle</TT>
replaces <TT>handle</TT> on the top
of the stack. The first stack picture is for 32-bit, and the second
for 64-bit-wide fields. This bytecode handles both. If the specified
field is a <TT>static</TT> field,
an <TT>IncompatibleClassChangeError</TT>
is thrown.
<BLOCKQUOTE>
<PRE>
putstatic     ..., value =&gt; ...
putstatic     ..., value-word1, value-word2 =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Set static field in class. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The constant
pool item will be a field reference to a static field of a class.
That field will be set to have the <TT>value</TT>
on the top of the stack. The first stack picture is for 32-bit,
and the second for 64-bit-wide fields. This bytecode handles both.
If the specified field is not a static field, an <TT>IncompatibleClassChangeError</TT>
is thrown.
<BLOCKQUOTE>
<PRE>
getstatic     ..., =&gt; ..., value_
getstatic     ..., =&gt; ..., value-word1, value-word2
</PRE>
</BLOCKQUOTE>
<P>
Get static field from class. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The constant
pool item will be a field reference to a static field of a class.
The <TT>value</TT> of that field is
placed on the top of the stack. The first stack picture is for
32-bit, and the second for 64-bit-wide fields. This bytecode handles
both. If the specified field is not a static field, an <TT>IncompatibleClassChangeError</TT>
is thrown.
<H4>Method Invocation</H4>
<BLOCKQUOTE>
<PRE>
invokevirtual     ..., handle, [arg1, [arg2, ...]], ... =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Invoke instance method based on runtime type. The operand stack
must contain a reference to an object and some number of arguments.
<TT>byte1</TT> and <TT>byte2</TT>
are used to construct an index into the constant pool of the current
class. The item at that index in the constant pool contains the
complete method signature. A pointer to the object's method table
is retrieved from the object reference. The method signature is
looked up in the method table. The method signature is guaranteed
to exactly match one of the method signatures in the table.
<P>
The result of the lookup is an index into the method table of
the named class that's used to look in the method table of the
object's runtime type, where a pointer to the method block for
the matched method is found. The method block indicates the type
of method (<TT>native</TT>, <TT>synchronized</TT>,
and so on) and the number of arguments (<TT>nargs</TT>)
expected on the operand stack.
<P>
If the method is marked <TT>synchronized</TT>,
the monitor associated with <TT>handle</TT>
is entered.
<P>
The base of the local variables array for the new Java stack frame
is set to point to <TT>handle</TT>
on the stack, making <TT>handle</TT>
and the supplied arguments (<TT>arg1</TT>,
<TT>arg2</TT>, and so on) the first
<TT>nargs</TT> local variables of
the new frame. The total number of local variables used by the
method is determined, and the execution environment of the new
frame is pushed after leaving sufficient room for the locals.
The base of the operand stack for this method invocation is set
to the first word after the execution environment. Finally, execution
continues with the first bytecode of the matched method.
<P>
If <TT>handle</TT> is <TT>null</TT>,
a <TT>NullPointerException</TT> is
thrown. If during the method invocation a stack overflow is detected,
a <TT>StackOverflowError</TT> is thrown.
<BLOCKQUOTE>
<PRE>
invokenonvirtual  ..., handle, [arg1, [arg2, ...]], ... =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Invoke instance method based on compile-time type. The operand
stack must contain a reference (<TT>handle</TT>)
to an object and some number of arguments. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index in the constant pool contains the complete method
signature and class. The method signature is looked up in the
method table of the class indicated. The method signature is guaranteed
to exactly match one of the method signatures in the table.
<P>
The result of the lookup is a method block. The method block indicates
the type of method (<TT>native</TT>,
<TT>synchronized</TT>, and so on)
and the number of arguments (<TT>nargs</TT>)
expected on the operand stack. (The last three paragraphs are
identical to the previous bytecode.)
<BLOCKQUOTE>
<PRE>
invokestatic      ..., , [arg1, [arg2, ...]], ... =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Invoke class (<TT>static</TT>) method.
The operand stack must contain some number of arguments. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index in the constant pool contains the complete method
signature and class. The method signature is looked up in the
method table of the class indicated. The method signature is guaranteed
to match one of the method signatures in the class's method table
exactly.
<P>
The result of the lookup is a method block. The method block indicates
the type of method (<TT>native</TT>,
<TT>synchronized</TT>, and so on)
and the number of arguments (<TT>nargs</TT>)
expected on the operand stack.
<P>
If the method is marked <TT>synchronized</TT>,
the monitor associated with the class is entered. (The last two
paragraphs are identical to those in <TT>invokevirtual</TT>,
except that no <TT>NullPointerException</TT>
can be thrown.)
<BLOCKQUOTE>
<PRE>
invokeinterface   ..., handle, [arg1, [arg2, ...]], ...=&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Invoke interface method. The operand stack must contain a reference
(<TT>handle</TT>) to an object and
some number of arguments. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index in the constant pool contains the complete method
signature. A pointer to the object's method table is retrieved
from the object reference. The method signature is looked up in
the method table. The method signature is guaranteed to exactly
match one of the method signatures in the table.
<P>
The result of the lookup is a method block. The method block indicates
the type of method (<TT>native</TT>,
<TT>synchronized</TT>, and so on)
but, unlike the other &quot;invoke&quot; bytecodes, the number
of available arguments (<TT>nargs</TT>)
is taken from <TT>byte3</TT>; <TT>byte4</TT>
is reserved for future use. (The last three paragraphs are identical
to those in <TT>invokevirtual</TT>.)
<H4>Exception Handling</H4>
<BLOCKQUOTE>
<PRE>
Sathrow            ..., handle =&gt; [undefined]
</PRE>
</BLOCKQUOTE>
<P>
Throw exception. <TT>handle</TT> must
be a handle to an exception object. That exception, which must
be an instance of <TT>Throwable</TT>
(or a subclass), is thrown. The current Java stack frame is searched
for the most recent <TT>catch</TT>
clause that handles the exception. If a matching &quot;catch list&quot;
entry is found, the <TT>pc</TT> is
reset to the address indicated by the catch-list pointer, and
execution continues there.
<P>
If no appropriate <TT>catch</TT> clause
is found in the current stack frame, that frame is popped and
the exception is rethrown, starting the process all over again
in the parent frame. If <TT>handle</TT>
is <TT>null</TT>, a <TT>NullPointerException</TT>
is thrown instead.
<H4>Miscellaneous Object Operations</H4>
<BLOCKQUOTE>
<PRE>
new               ... =&gt; ..., handle
</PRE>
</BLOCKQUOTE>
<P>
Create new object. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The item
at that index should be a class name that can be resolved to a
class pointer. A new instance of that class is then created and
a reference (<TT>handle</TT>) for
the instance is placed on the top of the stack.
<BLOCKQUOTE>
<PRE>
checkcast         ..., handle =&gt; ..., [handle | ...]
</PRE>
</BLOCKQUOTE>
<P>
Make sure object is of given type. <TT>handle</TT>
must be a reference to an object. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The string
at that index of the constant pool is presumed to be a class name
that can be resolved to a class pointer.
<P>
<TT>checkcast</TT> determines whether
<TT>handle</TT> can be cast to a reference
to an object of that class. (A <TT>null</TT>
<TT>handle</TT> can be cast to any
class.) If <TT>handle</TT> can be
legally cast, execution proceeds at the next bytecode, and the
<TT>handle</TT> remains on the stack.
If not, a <TT>ClassCastException</TT>
is thrown and the stack is emptied.
<BLOCKQUOTE>
<PRE>
instanceof        ..., handle =&gt; ..., result
</PRE>
</BLOCKQUOTE>
<P>
Determine whether object is of given type. <TT>handle</TT>
must be a reference to an object. <TT>byte1</TT>
and <TT>byte2</TT> are used to construct
an index into the constant pool of the current class. The string
at that index of the constant pool is presumed to be a class name
that can be resolved to a class pointer.
<P>
If <TT>handle</TT> is <TT>null</TT>,
the <TT>result</TT> is <TT>0</TT>
(<TT>false</TT>). Otherwise, <TT>instanceof</TT>
determines whether <TT>handle</TT>
can be cast to a reference to an object of that class. The <TT>result</TT>
is <TT>1</TT> (<TT>true</TT>)
if it can, and <TT>0</TT> (<TT>false</TT>)
otherwise.
<H4>Monitors</H4>
<BLOCKQUOTE>
<PRE>
monitorenter      ..., handle =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Enter monitored region of code. <TT>handle</TT>
must be a reference to an object. The interpreter attempts to
obtain exclusive access via a lock mechanism to <TT>handle</TT>.
If another thread already has <TT>handle</TT>
locked, the current thread waits until the <TT>handle</TT>
is unlocked. If the current thread already has <TT>handle</TT>
locked, execution continues normally. If <TT>handle</TT>
has no lock on it, this bytecode obtains an exclusive lock. (A
<TT>null</TT> in either bytecode throws
<TT>NullPointerException</TT>.)
<BLOCKQUOTE>
<PRE>
Smonitorexit       ..., handle =&gt; ...
</PRE>
</BLOCKQUOTE>
<P>
Exit monitored region of code. <TT>handle</TT>
must be a reference to an object. The lock on <TT>handle</TT>
is released. If this is the last lock that this thread has on
that <TT>handle</TT> (one thread is
allowed to have multiple locks on a single <TT>handle</TT>),
other threads that are waiting for <TT>handle</TT>
are allowed to proceed. (A <TT>null</TT>
in either bytecode throws <TT>NullPointerException</TT>.)
<H4>Debugging</H4>
<BLOCKQUOTE>
<PRE>
breakpoint        -no change-
</PRE>
</BLOCKQUOTE>
<P>
Call breakpoint handler. The breakpoint bytecode is used to overwrite
a bytecode to force control temporarily back to the debugger prior
to the effect of the overwritten bytecode. The original bytecode's
operands (if any) are not overwritten, and the original bytecode
is restored when the breakpoint bytecode is removed.
<H3><A NAME="TheTTFONTSIZEFACECourierquickFONTTTFONTSIZEBytecodesFONT">
The <TT>_quick</TT>
Bytecodes</FONT></A></H3>
<P>
The following discussion, straight out of the Java virtual machine
documentation, shows you an example of the cleverness mentioned
earlier that's needed to make a bytecode interpreter fast:
<BLOCKQUOTE>
The following set of pseudo-bytecodes, suffixed by <TT>_quick</TT>,
are all variants of standard Java bytecodes. They are used by
the runtime to improve the execution speed of the bytecode interpreter.
They aren't officially part of the virtual machine specification
and are invisible outside a Java virtual machine implementation.
However, inside that implementation they have proven to be an
effective op-timization.
</BLOCKQUOTE>
<BLOCKQUOTE>
First, you should know that the <TT>javac</TT>
Java compiler still generates only non-<TT>_quick
</TT>bytecodes. Second, all bytecodes that have a <TT>_quick</TT>
variant reference the constant pool. When<TT>
_quick</TT> optimization is turned on, each non-<TT>_quick</TT>
bytecode (that has a <TT>_quick</TT>
variant) resolves the specified item in the constant pool, signals
an error if the item in the constant pool could not be resolved
for some reason, turns itself into the <TT>_quick</TT>
variant of itself, and then performs its intended operation.
</BLOCKQUOTE>
<BLOCKQUOTE>
This is identical to the actions of the non-<TT>_quick</TT>
bytecode, except for the step of overwriting itself with its <TT>_quick</TT>
variant. The <TT>_quick</TT> variant
of a bytecode assumes that the item in the constant pool has already
been resolved, and that this resolution did not produce any errors.
It simply performs the intended operation on the resolved item.
</BLOCKQUOTE>
<P>
Thus, as your bytecodes are being interpreted, they are automatically
getting faster and faster! Here are all the <TT>_quick</TT>
variants in the current Java runtime:
<BLOCKQUOTE>
<PRE>
ldc1_quick
ldc2_quick
ldc2w_quick

anewarray_quick
multinewarray_quick

putfield_quick
putfield2_quick
getfield_quick
getfield2_quick
putstatic_quick
putstatic2_quick
getstatic_quick
getstatic2_quick

invokevirtual_quick
invokevirtualobject_quick
invokenonvirtual_quick
invokestatic_quick
invokeinterface_quick

new_quick
checkcast_quick
instanceof_quick
</PRE>
</BLOCKQUOTE>
<P>
If you'd like to go back in this appendix and look at what each
of these does, you can find the name of the original bytecode
on which a <TT>_quick</TT> variant
is based  simply by removing the <TT>_quick</TT>
from its name. The bytecodes <TT>putstatic</TT>,
<TT>getstatic</TT>, <TT>putfield</TT>,
and <TT>getfield</TT> have two <TT>_quick</TT>
variants each, one for each stack picture in their original descriptions.
<TT>invokevirtual</TT> has two variants:
one for objects and one for arrays (to do fast lookups in <TT>java.lang.Object</TT>).
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
One last note on the <TT>_quick</TT> optimization, regarding the unusual handling of the constant pool (for detail fanatics only): When a class is read in, an array <TT>constant_pool[]</TT> of size <TT>nconstants</TT> is created and assigned to a field in 
the class. <TT>constant_pool[0]</TT> is set to point to a dynamically allocated array that indicates which fields in the <TT>constant_pool</TT> have already been resolved. <TT>Constant_pool[1]</TT> through <TT>constant_pool[nconstants - 1]</TT> are set to 
point at the &quot;type&quot; field that corresponds to this constant item.
</BLOCKQUOTE>
<BLOCKQUOTE>
When a bytecode is executed that references the constant pool, an index is generated, and <TT>constant_pool[0]</TT> is checked to see whether the index has already been resolved. If so, the value of <TT>constant_pool[index]</TT> is returned. If not, the 
value of <TT>constant_pool[index]</TT> is resolved to be the actual pointer or data, and overwrites whatever value was already in <TT>constant_pool[index]</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch31.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch33.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
