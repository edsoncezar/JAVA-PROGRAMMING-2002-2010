<HTML>
<HEAD>
<TITLE>Day 10 -- Simple Animation and Threads</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;10</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Simple Animation and Threads</FONT>
</H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#CreatingAnimationinJava">
Creating Animation in Java</A>
<UL>
<LI><A HREF="#PaintingandRepainting">
Painting and Repainting</A>
<LI><A HREF="#StartingandStoppinganAppletsExecution">
Starting and Stopping an Applet's Execution</A>
<LI><A HREF="#TheMissingLinkThreads">
The Missing Link: Threads</A>
<LI><A HREF="#PuttingItTogether">
Putting It Together</A>
</UL>
<LI><A HREF="#ThreadsWhatTheyAreandWhyYouNeedThem">
Threads: What They Are and Why You Need Them</A>
<UL>
<LI><A HREF="#WritingAppletswithThreads">
Writing Applets with Threads</A>
<LI><A HREF="#AnotherLookattheDigitalClock">
Another Look at the Digital Clock</A>
</UL>
<LI><A HREF="#ReducingAnimationFlicker">
Reducing Animation Flicker</A>
<UL>
<LI><A HREF="#FlickerandHowtoAvoidIt">
Flicker and How to Avoid It</A>
<LI><A HREF="#HowtoOverrideTTFONTFACECourierupdateFONTTT">
How to Override <TT>update()</TT>
</A>
<LI><A HREF="#SolutionOneDontCleartheScreen">
Solution One: Don't Clear the Screen</A>
<LI><A HREF="#SolutionTwoRedrawOnlyWhatYouHaveTo">
Solution Two: Redraw Only What You Have To</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
The first thing I ever saw Java do was an animation: a large red
<TT>Hi there!</TT> that ran across
the screen from the right to left. Even that simple form of animation
was enough to make me stop and think, &quot;this is really cool.&quot;
<P>
That sort of simple animation takes only a few methods to implement
in Java, but those few methods are the basis for any Java applet
that you want to update the screen dynamically-for something as
simple as flashy animation applets, or for more complex applets
that may need to be updated based on data they get from the user,
from databases connected to over the network, or from any other
source. 
<P>
Animation in Java is accomplished through various interrelated
parts of the Java Abstract Windowing Toolkit (awt). Today you'll
learn the fundamentals of animation in Java: how the various parts
of the system all work together so that you can create moving
figures and dynamically updatable applets. Specifically, you'll
explore the following:
<UL>
<LI>How to create animation in Java-the <TT>paint()</TT>
and <TT>repaint()</TT> methods, starting
and stopping dynamic applets, and how to use and override these
methods in your own applets
<LI>Threads-what they are and how they can make your applets more
well-behaved with other applets and with other parts of the awt
<LI>Reducing animation flicker, which is a common problem with
animation in Java
</UL>
<P>
Throughout today, you'll also work with lots of examples of real
applets that create animation or perform some kind of dynamic
movement.
<H2><A NAME="CreatingAnimationinJava"><FONT SIZE=5 COLOR=#FF0000>
Creating Animation in Java</FONT></A></H2>
<P>
Animation in Java involves two basic steps: constructing a frame
of animation, and then asking Java to paint that frame. You repeat
these steps as necessary to create the illusion of movement. The
basic, static graphical applets that you created yesterday taught
you how to accomplish the first part; all that's left is how to
tell Java to paint a frame.
<H3><A NAME="PaintingandRepainting">
Painting and Repainting</A></H3>
<P>
The <TT>paint()</TT> method, as you
learned yesterday, is called whenever an applet needs to be painted-when
the applet is initially drawn, when the window containing it is
moved, or when another window is moved from over it. You can also,
however, ask Java to repaint the applet at a time you choose.
So, to change the appearance of what is on the screen, you construct
the image or &quot;frame&quot; you want to paint, and then ask
Java to paint this frame. If you do this repeatedly, and fast
enough, you get animation inside your Java applet. That's all
there is to it.
<P>
Where does all this take place? Not in the <TT>paint()</TT>
method itself. All <TT>paint()</TT>
does is put dots on the screen. <TT>paint()</TT>,
in other words, is responsible only for the current frame of the
animation. The real work of changing what <TT>paint()</TT>
does, of modifying the frame for an animation, actually occurs
somewhere else in the definition of your applet.
<P>
In that &quot;somewhere else,&quot; you construct the frame (set
variables for <TT>paint()</TT> to
use, create <TT>Color</TT> or <TT>Font</TT>
or other objects that <TT>paint()</TT>
will need), and then call the <TT>repaint()</TT>
method. <TT>repaint()</TT> is the
trigger that causes Java to call <TT>paint()</TT>
and causes your frame to get drawn.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Because a Java applet can contain many different components that all need to be painted (as you'll learn later this week), and in fact, applets  can be embedded inside a larger Java application that also paints to the screen in similar ways, when you call 
<TT>repaint()</TT> (and therefore <TT>paint()</TT>) you're not actually immediately drawing to the screen as you do in other window or graphics toolkits. Instead, <TT>repaint()</TT> is a request</FONT> for Java to repaint your applet as soon as it can. 
Also, if too many <TT>repaint()</TT> requests are made in a short amount of time, the system may only call <TT>repaint()</TT> once for all of them. Much of the time, the delay between the call and the actual repaint is negligible. However, for very tight 
loops, the awt may collapse several calls to <TT>repaint()</TT> into one. Keep this in mind as you create your own animation.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="StartingandStoppinganAppletsExecution">
Starting and Stopping an Applet's Execution</A></H3>
<P>
Remember <TT>start()</TT> and <TT>stop()</TT>
from <A HREF="ch8.htm">Day 8</A>, &quot;Java Applet Basics&quot;? These are the methods
that trigger your applet to start and stop running. You didn't
use <TT>start()</TT> and <TT>stop()</TT>
yesterday because the applets on that day did nothing except paint
once. With animation and other Java applets that are actually
processing and running over time, you'll need to make use of <TT>start()</TT>
and <TT>stop()</TT> to trigger the
start of your applet's execution, and to stop it from running
when you leave the page that contains that applet. For many applets,
you'll want to override <TT>start()</TT>
and <TT>stop()</TT> for just this
reason.
<P>
The <TT>start()</TT> method triggers
the execution of the applet. You can either do all the applet's
work inside that method, or you can call other object's methods
in order to do so. Usually, <TT>start()</TT>
is used to create and begin execution of a thread so the applet
can run in its own time.
<P>
<TT>stop()</TT>, on the other hand,
suspends an applet's execution so when you move off the page on
which the applet is displaying, it doesn't keep running and using
up system resources. Most of the time when you create a <TT>start()</TT>
method, you should also create a corresponding <TT>stop()</TT>.
<H3><A NAME="TheMissingLinkThreads">
The Missing Link: Threads</A></H3>
<P>
There's one more part to the animation mix that you'll have to
know about, and that's threads. I'm going to discuss threads in
a lot greater detail later on in this lesson (and in even more
detail on <A HREF="ch18.htm">Day 18</A>, &quot;Multithreading&quot;) but for now here's
the basic idea: Anything you do in a Java program that runs continually
and takes up a lot of processing time should run in its own thread.
Animation is one of these things. To accomplish animation in Java,
therefore, you use the <TT>start()</TT>
method to start a thread, and then do all your animation processing
inside the thread's <TT>run()</TT>
method. This allows the animation to run on its own without interfering
with any other parts of the program.
<H3><A NAME="PuttingItTogether">
Putting It Together</A></H3>
<P>
Explaining how to do Java animation is more of a task than actually
showing you how it works in code. An example will help make the
relationship between all these methods clearer.
<P>
Listing 10.1 shows a sample applet that uses basic applet animation
techniques to display the date and time and constantly updates
it every second, creating a very simple animated digital clock
(a frame from that clock is shown in Figure 10.1). 
<P>
<A HREF="http://docs.rinet.ru/J21/f10-1.gif"><B>Figure 10.1 : </B><I>The digital clock</I>.</A>
<P>
This applet uses the <TT>paint()</TT>,
<TT>repaint()</TT>, <TT>start()</TT>,
and <TT>stop()</TT> methods. It also
uses threads. For this discussion, we'll focus on the animation
parts of the applet and won't worry so much about how the threads
work. We'll take another look at this applet later, after we've
discussed threads in greater detail.
<HR>
<BLOCKQUOTE>
<B>Listing 10.1. The </B><TT><B>DigitalClock</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Font;
 3: import java.util.Date;
 4:
 5: public class DigitalClock extends java.applet.Applet 
 6:   implements Runnable {
 7: 
 8:   Font theFont = new Font(&quot;TimesRoman&quot;,Font.BOLD,24);
 9:  Date theDate;
10:   Thread runner;
11: 
12:   public void start() {
13:     if (runner == null) {
14:       runner = new Thread(this);
15:       runner.start();
16:     }
17:   }
18:
19:   public void stop() {
20:     if (runner != null) {
21:       runner.stop();
21:       runner = null;
22:     }
23:   }
24:  
25:   public void run() {
26:     while (true) {
27:       theDate = new Date();
28:       repaint();
29:      try { Thread.sleep(1000); }
30:       catch (InterruptedException e) { }
31:     }
32:   }
33: 
34:   public void paint(Graphics g) {
35:     g.setFont(theFont);
36:     g.drawString(theDate.toString(),10,50);
37:   }
38:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
We'll look at this applet from the perspective of the actual animation parts in this section, and deal with the parts that manage threads later on.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Lines 7 and 8 define two basic instance variables: <TT>theFont</TT>
and <TT>theDate</TT>, which hold objects
representing the current font and the current date, respectively.
You'll learn more about these later.
<P>
The <TT>start()</TT> and <TT>stop()</TT>
methods here start and stop a thread; the bulk of the applet's
work goes on in the <TT>run()</TT>
methods (lines 25 to 32).
<P>
Inside <TT>run()</TT> is where the
animation actually takes place. Note the <TT>while</TT>
loop inside this method (line 26); given that the test <TT>(true)</TT>
always returns <TT>true</TT>, the
loop never exits. A single animation frame is constructed inside
that <TT>while</TT> loop, with the
following steps:
<UL>
<LI>The <TT>Date</TT> class represents
a date and time (<TT>Date</TT> is
part of the <TT>java.util</TT> package-note
that it was specifically imported in line 3). Line 27 creates
a new instance of the <TT>Date</TT>
class, which holds the current date and time, and assigns it to
the <TT>theDate</TT> instance variable.
<LI>The <TT>repaint()</TT> method
is called (line 28) to repaint the applet.
<LI>Lines 14 and 15, as complicated as they look, do nothing except
pause for <TT>1000</TT> milliseconds
(1 second) before the loop repeats. The <TT>sleep()</TT>
method there, part of the <TT>Thread</TT>
class, is what causes the applet to pause. Without a specific
<TT>sleep()</TT> method, the applet
would run as fast as it possibly could, which, for most computer
systems, would be too fast for the eye to see. The <TT>sleep()</TT>
method controls exactly how fast the animation takes place. The
<TT>try</TT> and <TT>catch</TT>
stuff around it enables Java to manage errors if they occur. <TT>try</TT>
and <TT>catch</TT> handle exceptions
and are described on <A HREF="ch17.htm">Day 17</A>, &quot;Exceptions.&quot;
</UL>
<P>
On to the <TT>paint()</TT> method
in lines 34 through 37. Here, inside <TT>paint()</TT>,
all that happens is that the current font (in the variable <TT>theFont</TT>)
is set, and the date itself is printed to the screen (note that
you have to call the <TT>toString()</TT>
method to convert the date to a string). Because <TT>paint()</TT>
is called repeatedly with whatever value happens to be in <TT>theDate</TT>,
the string is updated every second to reflect the new date.
<P>
There are a few things to note about this example. First, you
might think it would be easier to create the new <TT>Date</TT>
object inside the <TT>paint()</TT>
method. That way you could use a local variable and not need an
instance variable to pass the <TT>Date</TT>
object around. Although doing things that way creates cleaner
code, it also results in a less efficient program. The <TT>paint()</TT>
method is called every time a frame needs to be changed. In this
case, it's not that important, but in an animation that needs
to change frames very quickly, the <TT>paint()</TT>
method has to pause to create that new object every time. By leaving
<TT>paint()</TT> to do what it does
best-painting the screen-and calculating new objects beforehand,
you can make painting as efficient as possible. This is precisely
the same reason why the <TT>Font</TT>
object is also in an instance variable.
<H2><A NAME="ThreadsWhatTheyAreandWhyYouNeedThem"><FONT SIZE=5 COLOR=#FF0000>
Threads: What They Are and Why You Need Them</FONT></A></H2>
<P>
So what are these threads all about? Why are they important to
animation? 
<P>
Threads are a very important part of Java and of programming Java.
The larger your Java programs get and the more things they do,
the more likely it is that you'll want to use threads. Depending
on your experience with operating systems and with environments
within those systems, you may or may not have run into the concept
of threads, so let's start from the beginning.
<P>
First, the analogy. A group of students is on a bus, on a field
trip somewhere. To pass the time, the teachers are leading a sing-along.
As the trip progresses, the students sing one song, then when
that song is done, they sing another song. While different parts
of the bus could sing different songs, it wouldn't sound very
good, so the singing of one song monopolizes the time until its
done, at which time another song can start.
<P>
Now let's say you have two busses; both are on the same route
to the field trip, both are going at the same speed, and both
are full of students singing songs. But the songs being sung by
the students in the second bus don't interfere with the songs
being sung in the first bus; in this way you can get twice as
many songs sung in the same amount of time by singing them in
parallel.
<P>
Threads are like that. In a regular single-threaded program, the
program starts executing, runs its initialization code, calls
methods or procedures, and continues running and processing until
it's complete or until the program is exited. That program runs
in a single thread-it's the one bus with all the students.
<P>
Multithreading, as in Java, means that several different parts
of the same program can run at the same time, in parallel, without
interfering with each other. Multiple threads, each running by
itself, are like multiple busses with different things going on
in each bus.
<P>
Here's a simple example. Suppose you have a long computation near
the start of a program's execution. This long computation may
not be needed until later in the program's execution-it's actually
tangential to the main point of the program, but it needs to get
done eventually. In a single-threaded program, you have to wait
for that computation to finish before the rest of the program
can continue running. In a multithreaded system, you can put that
computation into its own thread, and the rest of the program can
continue to run independently.
<P>
Animation is an example of the kind of task that needs its own
thread. Take, for example, that digital clock applet, which has
an endless <TT>while()</TT> loop.
If you didn't use threads, <TT>while()</TT>
would run in the default Java system thread, which is also responsible
for handling painting the screen, dealing with user input like
mouse clicks, and keeping everything internally up- to-date. Unfortunately,
however, if you run that <TT>while()</TT>
loop in the main system thread, it will monopolize all Java's
resources and prevent anything else-including painting-from happening.
You'd never actually see anything on the screen because Java would
be sitting and waiting for the <TT>while()</TT>
loop to finish before it did anything else. And that's not what
you want. 
<P>
Using threads in Java, you can create parts of an applet (or application)
that run in their own threads, and those parts will happily run
all by themselves without interfering with anything else. Depending
on how many threads you have, you may eventually tax the system
so that all of them will run slower, but all of them will still
run independently.
<P>
Even if you don't use lots of them, using threads in your applets
is a good Java programming practice. The general rule of thumb
for well-behaved applets: Whenever you have any bit of processing
that is likely to continue for a long time (such as an animation
loop, or a bit of code that takes a long time to execute), put
it in a thread.
<H3><A NAME="WritingAppletswithThreads">
Writing Applets with Threads</A></H3>
<P>
Creating applets that use threads is very easy. In fact, many
of the basic things you need to do to use threads are just boilerplate
code that you can copy and paste from one applet to another. Because
it's so easy, there's almost no reason not</FONT>
to use threads in your applets, given the benefits.
<P>
There are four modifications you need to make to create an applet
that uses threads:
<UL>
<LI>Change the signature of your applet class to include the words
<TT>implements Runnable</TT>.
<LI>Include an instance variable to hold the applet's thread object.
<LI>Create a <TT>start()</TT> method
that does nothing but create a thread and start it running.
<LI>Create a <TT>stop()</TT> method
that stops the thread.
<LI>Create a <TT>run()</TT> method
that contains the actual code that controls the applet.
</UL>
<P>
The first change is to the first line of your class definition.
You've already got something like this:
<BLOCKQUOTE>
<PRE>
public class MyAppletClass extends java.applet.Applet {
...
}
</PRE>
</BLOCKQUOTE>
<P>
You need to change it to the following:
<BLOCKQUOTE>
<PRE>
public class MyAppletClass extends java.applet.Applet  implements Runnable {
...
}
</PRE>
</BLOCKQUOTE>
<P>
What does this do? It includes support for the <TT>Runnable</TT>
interface in your applet. If you think way back to <A HREF="ch2.htm">Day 2</A>, &quot;Object-Oriented
Programming and Java,&quot; you'll remember that interfaces are
a way to collect method names common to different classes, which
can then be mixed in and implemented inside different classes
that need to implement that behavior. Here, the <TT>Runnable</TT>
interface defines the behavior your applet needs to run a thread;
in particular, it gives you a default definition for the <TT>run()</TT>
method. By implementing <TT>Runnable</TT>,
you tell others that they can call the <TT>Run()</TT>
method on your instances.
<P>
The second step is to add an instance variable to hold this applet's
thread. Call it anything you like; it's a variable of the type
<TT>Thread</TT> (<TT>Thread</TT>
is a class in <TT>java.lang</TT>,
so you don't have to import it):
<BLOCKQUOTE>
<PRE>
Thread runner;
</PRE>
</BLOCKQUOTE>
<P>
Third, add a <TT>start()</TT> method
or modify the existing one so that it does nothing but create
a new thread and start it running. Here's a typical example of
a <TT>start()</TT> method:
<BLOCKQUOTE>
<PRE>
public void start() {
   if (runner == null) {
       runner = new Thread(this);
       runner.start();
   }
}
</PRE>
</BLOCKQUOTE>
<P>
If you modify <TT>start()</TT> to
do nothing but spawn a thread, where does the code that drives
your applet go? It goes into a new method, <TT>run()</TT>,
which looks like this:
<BLOCKQUOTE>
<PRE>
public void run() {
    // what your applet actually does
}
</PRE>
</BLOCKQUOTE>
<P>
Your <TT>run()</TT> method actually
overrides the default version of <TT>run()</TT>,
which you get when you include the <TT>Runnable</TT>
interface with your applet. <TT>run()</TT>
is one of those standard methods, like <TT>start()</TT>
and <TT>paint()</TT>, that you override
in your own classes to get standard behavior.
<P>
<TT>run()</TT> can contain anything
you want to run in the separate thread: initialization code, the
actual loop for your applet, or anything else that needs to run
in its own thread. You also can create new objects and call methods
from inside <TT>run()</TT>, and they'll
also run inside that thread. The <TT>run()</TT>
method is the real heart of your applet.
<P>
Finally, now that you've got threads running and a <TT>start()</TT>
method to start them, you should add a <TT>stop()</TT>
method to suspend execution of that thread (and therefore whatever
the applet is doing at the time) when the reader leaves the page.
<TT>stop()</TT>, like <TT>start()</TT>,
is usually something along these lines:
<BLOCKQUOTE>
<PRE>
public void stop() {
  if (runner != null) {
      runner.stop();
      runner = null;
  }
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>stop()</TT> method here does
two things: It stops the thread from executing and also sets the
thread's variable <TT>runner</TT>
to <TT>null</TT>. Setting the variable
to <TT>null</TT> makes the <TT>Thread</TT>
object it previously contained available for garbage collection
so that the applet can be removed from memory after a certain
amount of time. If the reader comes back to this page and this
applet, the <TT>start()</TT> method
creates a new thread and starts up the applet once again.
<P>
And that's it! Four basic modifications, and now you have a well-behaved
applet that runs in its own thread.
<H3><A NAME="AnotherLookattheDigitalClock">
Another Look at the Digital Clock</A></H3>
<P>
Let's take another look at that <TT>DigitalClock</TT>
applet, this time from the standpoint of threads. Listing 10.2
shows that applet's code once again.
<HR>
<BLOCKQUOTE>
<B>Listing 10.2. The </B><TT><B>DigitalClock</B></TT><B>
applet, revisited.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Font;
 3: import java.util.Date;
 4:
 5: public class DigitalClock extends java.applet.Applet 
 6:   implements Runnable {
 7: 
 8:   Font theFont = new Font(&quot;TimesRoman&quot;,Font.BOLD,24);
 9:  Date theDate;
10:   Thread runner;
11: 
12:   public void start() {
13:     if (runner == null) {
14:       runner = new Thread(this);
15:       runner.start();
16:     }
17:   }
18:
19:   public void stop() {
20:     if (runner != null) {
21:       runner.stop();
21:       runner = null;
22:     }
23:   }
24:  
25:   public void run() {
26:     while (true) {
27:       theDate = new Date();
28:       repaint();
29:      try { Thread.sleep(1000); }
30:       catch (InterruptedException e) { }
31:     }
32:   }
33: 
34:   public void paint(Graphics g) {
35:     g.setFont(theFont);
36:     g.drawString(theDate.toString(),10,50);
37:   }
38:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Let's look at the lines of this applet that create and manage threads. First, look at the class definition itself in lines 5 and 6; note that the class definition includes the <TT>Runnable</TT> interface. Any classes you create that use threads must 
include <TT>Runnable</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Line 10 defines a third instance variable for this class called
<TT>runner</TT> of type <TT>Thread</TT>,
which will hold the thread object for this applet.
<P>
Lines 12 through 23 define the boilerplate <TT>start()</TT>
and <TT>stop()</TT> methods that do
nothing except create and destroy threads. These method definitions
can essentially be exactly the same from class to class because
all they do is set up the infrastructure for the thread itself.
<P>
And, finally, the bulk of your applet's work goes on inside the
<TT>run()</TT> method in lines 25
through 32, as we already discussed the last time we looked at
this applet. Inside this method is the endless <TT>while</TT>
loop, the calls to <TT>repaint()</TT>,
and the <TT>sleep()</TT> method, which
pauses things so they only run once a second.
<H2><A NAME="ReducingAnimationFlicker"><FONT SIZE=5 COLOR=#FF0000>
Reducing Animation Flicker</FONT></A></H2>
<P>
If you've been following along with this lesson and trying the
examples as you go, rather than reading this book on an airplane
or in the bathtub, you may have noticed that when the digital
clock program runs, every once in a while there's an annoying
flicker in the animation. (Not that there's anything wrong with
reading this book in the bathtub, but you won't see the flicker
if you do that, so just trust me-there's a flicker.) This isn't
a mistake or an error in the program; in fact, that flicker is
a side effect of creating animation in Java. Because it is really
annoying, you'll learn how to reduce flicker in this part of today's
lesson so that your animations run cleaner and look better on
the screen.
<H3><A NAME="FlickerandHowtoAvoidIt">
Flicker and How to Avoid It</A></H3>
<P>
Flicker is caused by the way Java paints and repaints each frame
of an applet. At the beginning of today's lesson, you learned
that when you call the <TT>repaint()</TT>
method, <TT>repaint()</TT> calls <TT>paint()</TT>.
That's not precisely true. A call to <TT>paint()</TT>
does indeed occur in response to a <TT>repaint()</TT>,
but what actually happens are the following steps:
<OL>
<LI>The call to <TT>repaint()</TT>
results in a call to the method <TT>update()</TT>.
<LI>The <TT>update()</TT> method clears
the screen of any existing contents (in essence, fills it with
the current background color), and then calls <TT>paint()</TT>.
<LI>The <TT>paint()</TT> method then
draws the contents of the current frame.
</OL>
<P>
It's step 2, the call to <TT>update()</TT>,
that causes animation flicker. Because the screen is cleared between
frames, the parts of the screen that don't change alternate rapidly
between being painted and being cleared. Hence, flickering.
<P>
There are two major ways to avoid flicker in your Java applets:
<UL>
<LI>Override <TT>update()</TT> either
not to clear the screen at all, or to clear only the parts of
the screen you've changed.
<LI>Override both <TT>update()</TT>
and <TT>paint()</TT>, and use double-buffering.
</UL>
<P>
If the second way sounds complicated, that's because it is. Double-buffering
involves drawing to an offscreen graphics surface and then copying
that entire surface to the screen. Because it's more complicated,
you'll explore that one tomorrow. Today let's cover the easier
solution: overriding <TT>update()</TT>.
<H3><A NAME="HowtoOverrideTTFONTFACECourierupdateFONTTT">
How to Override <TT>update()</TT>
</A></H3>
<P>
The cause of flickering lies in the <TT>update()</TT>
method. To reduce flickering, therefore, override <TT>update()</TT>.
Here's what the default version of <TT>update()</TT>
does (comes from the <TT>Component</TT>
class, is part of the awt, and is one of the superclasses of the
applet class. You'll learn more about it on <A HREF="ch13.htm">Day 13</A>, &quot;Creating
User Interfaces with the awt&quot;):
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
    g.setColor(getBackground());
    g.fillRect(0, 0, width, height);
    g.setColor(getForeground());
    paint(g);
}
</PRE>
</BLOCKQUOTE>
<P>
Basically, <TT>update()</TT> clears
the screen (or, to be exact, fills the applet's bounding rectangle
with the background color), sets things back to normal, and then
calls <TT>paint()</TT>. When you override
<TT>update()</TT>, you have to keep
these two things in mind and make sure that your version of <TT>update()</TT>
does something similar. In the next two sections, you'll work
through some examples of overriding <TT>update()</TT>
in different cases to reduce flicker.
<H3><A NAME="SolutionOneDontCleartheScreen">
Solution One: Don't Clear the Screen</A></H3>
<P>
The first solution to reducing flicker is not to clear the screen
at all. This works only for some applets, of course. Here's an
example of an applet of this type. The <TT>ColorSwirl</TT>
applet prints a single string to the screen (<TT>&quot;All
the Swirly Colors&quot;</TT>), but that string is presented
in different colors that fade into each other dynamically. This
applet flickers terribly when it's run. Listing 10.3 shows the
initial source for this applet, and Figure 10.2 shows the result.
<P>
<A HREF="http://docs.rinet.ru/J21/f10-2.gif"><B>Figure 10.2 : </B><I>The </I><TT>ColorSwirl</TT><I>
applet</I>.</A>
<HR>
<BLOCKQUOTE>
<B>Listing 10.3. The </B><TT><B>ColorSwirl</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:  import java.awt.Graphics;
 2:  import java.awt.Color;
 3:  import java.awt.Font;
 4: 
 5: public class ColorSwirl extends java.applet.Applet
 6:     implements Runnable {
 7:
 8:    Font f = new Font(&quot;TimesRoman&quot;,Font.BOLD,48);
 9:    Color colors[] = new Color[50];
10:    Thread runThread;
11:
12:    public void start() {
13:        if (runThread == null) {
14:            runThread = new Thread(this);
15:            runThread.start();
16:        }
17:    }
18:
19:    public void stop() {
20:        if (runThread != null) {
21:            runThread.stop();
22:            runThread = null;
23:        }
24:    }
25:
26:    public void run() {
27:
28:        // initialize the color array
29:        float c = 0;
30:        for (int i = 0; i &lt; colors.length; i++) {
31:            colors[i] =
32:            Color.getHSBColor(c, (float)1.0,(float)1.0);
33:            c += .02;
34:        }
35:
36:        // cycle through the colors
37:        int i = 0;
38:        while (true) {
39:            setForeground(colors[i]);
40:            repaint();
41:            i++;
42:            try { Thread.sleep(50); }
43:            catch (InterruptedException e) { }
44:            if (i == colors.length ) i = 0;
45:        }
46:    }
47:
48:    public void paint(Graphics g) {
49:        g.setFont(f);
50:        g.drawString(&quot;All the Swirly Colors&quot;, 15, 50);
51:    }
52: }]<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There are three new things to note about this applet that might look strange to you:</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<UL>
<LI>Line 9 defines an instance variable <TT>Colors</TT>,
which is an array of 50 elements. When the applet starts, the
first thing you do in the <TT>run()</TT>
method (in lines 28 through 34) is to fill up that array with
color objects. By creating all the colors beforehand, you can
then jusxt draw text in that color, one at a time; it's easier
to precompute all the colors at once (and, in fact, this <TT>for</TT>
loop might make more sense in an <TT>init()</TT>
method because it only needs to happen once). Note that I arbitrarily
picked the number 50 for the number of colors we'll be using;
we could just as easily cycle through 20 or 250 colors.
<LI>To create the different color objects, we used a method in
the <TT>Color</TT> class called <TT>getHSBColor()</TT>,
rather than just using new with various RGB values. The <TT>getHSBColor()</TT>
class method creates a color object based on values for hue, saturation,
and brightness, rather than the standard red, green, and blue.
HSB is simply a different way of looking at colors, and by incrementing
the hue value and keeping saturation and brightness constant,
you can create a range of colors without having to know the RGB
for each one. If you don't understand this, don't worry about
it; it's just a quick and easy way to create the color array.
<LI>To create the animation, the applet cycles through the array
of colors, setting the foreground color to each color object in
turn and calling <TT>repaint()</TT>.
When it gets to the end of the array, it starts over again (line
44), so the process repeats over and over ad infinitum.
</UL>
<P>
Now that you understand what the applet does, let's fix the flicker.
Flicker here results because each time the applet is painted,
there's a moment where the screen is cleared. Instead of the text
cycling neatly from red to a nice pink to purple, it's going from
red to gray, to pink to gray, to purple to gray, and so on-not
very nice looking at all.
<P>
Because the screen clearing is all that's causing the problem,
the solution is easy: Override <TT>update()</TT>
and remove the part where the screen gets cleared. It doesn't
really need to get cleared anyhow, because nothing is changing
except the color of the text. With the screen clearing behavior
removed from <TT>update()</TT>, all
update needs to do is call <TT>paint()</TT>.
Here's what the <TT>update()</TT>
method looks like in this applet (you'll want to add it after
the <TT>paint()</TT> method after
line 51):
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
   paint(g);
}
</PRE>
</BLOCKQUOTE>
<P>
With that-with one small three-line addition-no more flicker.
Wasn't that easy?<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you're following along with the examples on the CD, the <TT>ColorSwirl.java</TT> file contains the original applet with the flicker; <TT>ColorSwirl2.java</TT> has the fixed version.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="SolutionTwoRedrawOnlyWhatYouHaveTo">
Solution Two: Redraw Only What You Have To</A></H3>
<P>
For some applets, it won't be quite as easy as just not clearing
the screen. With some kinds of animation, clearing the screen
is necessary for the animation to work properly. Here's another
example. In this applet, called <TT>Checkers</TT>,
a red oval (a checker piece) moves from a black square to a white
square, as if on a checkerboard. Listing 10.4 shows the code for
this applet, and Figure 10.3 shows the applet itself.
<P>
<A HREF="http://docs.rinet.ru/J21/f10-3.gif"><B>Figure 10.3 : </B><I>The </I><TT>Checkers</TT><I>
applet</I>.</A>
<HR>
<BLOCKQUOTE>
<B>Listing 10.4. The </B><TT><B>Checkers</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:   import java.awt.Graphics;
 2:     import java.awt.Color;
 3: 
 4:   public class Checkers extends java.applet.Applet
 5:       implements Runnable {
 6: 
 7:       Thread runner;
 8:       int xpos;
 9: 
10:       public void start() {
11:          if (runner == null) {
12:              runner = new Thread(this);
13:              runner.start();
14:          }
15:      }
16: 
17:      public void stop() {
18:          if (runner != null) {
19:              runner.stop();
20:              runner = null;
21:          }
22:      }
23:  
24:  public void run() {
25:      setBackground(Color.blue);
26:      while (true) {
27:          for (xpos = 5; xpos &lt;= 105; xpos+=4) {
28:              repaint();
29:              try { Thread.sleep(100); }
30:              catch (InterruptedException e) { }
31:          }
32:          xpos = 5;
33:      }
34:  }
35: 
36:      public void paint(Graphics g) {
37:          // Draw background
38:          g.setColor(Color.black);
39:         g.fillRect(0, 0, 100, 100);
40:          g.setColor(Color.white);
41:          g.fillRect(101, 0, 100, 100);
42: 
43:          // Draw checker
44:          g.setColor(Color.red);
45:          g.fillOval(xpos, 5, 90, 90);
46:     }
47:  }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Here's a quick run-through of what this applet does: An instance variable, <TT>xpos</TT>, keeps track of the current starting position of the checker (because it moves horizontally, the <TT>y</TT> stays constant and only the <TT>x</TT> changes; we don't 
need to keep track of the <TT>y</TT> position). In the <TT>run()</TT> method, you change the value of <TT>x</TT> and repaint, waiting 100 milliseconds between each move. The checker then appears to move from the left side of the screen to the right, 
resetting back at its original position once it hits the right side of the screen.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In the actual <TT>paint()</TT> method,
the background squares are painted (one black and one white),
and then the checker is drawn at its current position.
<P>
This applet, like the <TT>ColorSwirl</TT>
applet, also has a terrible flicker. (In line 25, I changed the
background color to blue to emphasize it, so if you run this applet,
you'll definitely see the flicker.)
<P>
However, the solution to solving the flicker problem for this
applet is more difficult than for the last one, because you actually
do want to clear the screen before the next frame is drawn. Otherwise,
the red checker won't have the appearance of leaving one position
and moving to another; it'll just leave a red smear from one side
of the checkerboard to the other.
<P>
How do you get around this? You still clear the screen, in order
to get the animation effect, but, rather than clearing the entire
screen each time, you clear only the part that has actually changed
from one frame to the next. By limiting the redraw to only a small
area, you can eliminate some of the flicker you get from redrawing
the entire screen.
<P>
To limit what gets redrawn, you need a couple things. First, you
need a way to restrict the drawing area so that each time <TT>paint()</TT>
is called, only the part that needs to get redrawn actually gets
redrawn. Fortunately, this is easy by using a mechanism called
clipping. Clipping</FONT>, part
of the graphics class, enables you to restrict the drawing area
to a small portion of the full screen; although the entire screen
may get instructions to redraw, only the portions inside the clipping
area are actually drawn.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Clipping</FONT> restricts the drawing area to some smaller portion of the screen.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The second thing you need is a way to keep track of the actual
area to redraw. Both the left and right edges of the drawing area
change for each frame of the animation (one side to draw the new
oval, the other to erase the bit of the oval left over from the
previous frame), so to keep track of those two <TT>x</TT>
values, you need instance variables for both the left side and
the right.
<P>
With those two concepts in mind, let's start modifying the <TT>Checkers</TT>
applet to redraw only what needs to be redrawn. First, you'll
add instance variables for the left and right edges of the drawing
area. Let's call those instance variables <TT>ux1</TT>
and <TT>ux2</TT> (<TT>u</TT>
for update), where <TT>ux1</TT> is
the left side of the area to draw and <TT>ux2</TT>
the right:
<BLOCKQUOTE>
<PRE>
int ux1,ux2;
</PRE>
</BLOCKQUOTE>
<P>
Now let's modify the <TT>run()</TT>
method so that it keeps track of the actual area to be drawn,
which you would think is easy-just update each side for each iteration
of the animation. Here, however, things can get complicated because
of the way Java uses <TT>paint()</TT>
and <TT>repaint()</TT>.
<P>
The problem with updating the edges of the drawing area with each
frame of the animation is that for every call to <TT>repaint()</TT>
there may not be an individual corresponding <TT>paint()</TT>.
If system resources get tight (because of other programs running
on the system or for any other reason), <TT>paint()</TT>
may not get executed immediately and several calls to <TT>paint()</TT>
may queue up waiting for their turn to change the pixels on the
screen. In this case, rather than trying to make all those calls
to <TT>paint()</TT> in order (and
be potentially behind all the time), Java catches up by executing
only the most recent</FONT> call
to <TT>paint()</TT> and skips all
the others.
<P>
This poses a difficult problem in the <TT>Checkers</TT>
applet. If you update the edges of the drawing area with each
call to <TT>repaint(),</TT> and a
couple calls to <TT>paint()</TT> are
skipped, you end up with bits of the drawing surface not being
updated at all or bits of the oval (colloquially called &quot;turds&quot;)
left behind. Because of how <TT>repaint()</TT>
and <TT>paint()</TT> work in Java,
you cannot guarantee that every single clipping region will eventually
get painted-some may be skipped. The way to solve this is not
to reset the clipping region to something new every single pass,
but instead to reset the region only if that region was indeed
updated. This way, if a couple of calls to <TT>paint()</TT>
get skipped, the area to be updated will get larger for each frame,
and when <TT>paint()</TT> finally
gets caught up, everything will get repainted correctly.
<P>
Yes, this is horrifyingly complex. If  I could have written this
applet more simply, I would have (and, in fact, I did make it
as simple as I could after much rewriting), but without this mechanism
the applet will not get repainted correctly (my first try at this
applet left turds all over the place). Let's step through it slowly
in the code so you can get a better grasp of what's going on at
each step. 
<P>
Let's start with <TT>run()</TT>, where
each frame of the animation takes place. Here's where you calculate
each side of the clipping area based on the old position of the
oval and the new position of the oval. The value of <TT>ux1</TT>
(the left side of the drawing area) is the previous oval's x position
(<TT>xpos</TT>), and the value of
<TT>ux2</TT> is the x position of
the current oval plus the width of that oval (90 pixels in this
example). 
<P>
Here's what the old <TT>run()</TT>
method looked like:
<BLOCKQUOTE>
<PRE>
public void run() {
    setBackground(Color.blue);
    while (true) {
        for (xpos = 5; xpos &lt;= 105; xpos += 4) {
            repaint();
            try { Thread.sleep(100); }
            catch (InterruptedException e) { }
        }
        xpos = 5;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
For each step in which the oval moves toward the right, you first
update <TT>ux2</TT> (the right edge
of the drawing area):
<BLOCKQUOTE>
<PRE>
ux2 = xpos + 90;
</PRE>
</BLOCKQUOTE>
<P>
Then, after the <TT>repaint()</TT>
has occurred, you can update <TT>ux1</TT>
to reflect the old x position of the oval. However, you want to
update this value only</FONT> if
the paint actually happened, so you don't end up skipping bits
of the screen. How can you tell if the paint actually happened?
You can reset <TT>ux1</TT> in <TT>paint()</TT>
to a given value (say <TT>0</TT>),
and then test inside <TT>run()</TT>
to see whether you can update that value or whether you have to
wait for the <TT>paint()</TT> to occur:
<BLOCKQUOTE>
<PRE>
if (ux1 == 0) ux1 = xpos;
</PRE>
</BLOCKQUOTE>
<P>
Finally, there's one other change to make. When the oval reaches
the right side of the screen and resets back to its original position,
there's one frame where you want to redraw the whole screen rather
than create a clipping region (otherwise, the image of the oval
would remain on the right side of the screen). So, in this one
case, you want to set <TT>ux2</TT>
to be the full width of the applet. Here we'll modify the line
we just put in to set the value of <TT>ux2</TT>,
using an <TT>if</TT> statement to
test to see if the oval is at the left side of the screen:
<BLOCKQUOTE>
<PRE>
if (xpos == 5) ux2 = size().width;
else ux2 = xpos + 90;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>size()</TT> method is used
to get the dimensions of the applet; <TT>size().width</TT>
gives the full width of the applet so that the entire drawing
surface will be updated.
<P>
Here's the new version of <TT>run()</TT>
with those changes in place: 
<BLOCKQUOTE>
<PRE>
public void run() {
    setBackground(Color.blue);
    while (true) {
      for (xpos = 5; xpos &lt;= 105; xpos+=4) {
         if (xpos == 5) ux2 = size().width;
         else ux2 = xpos + 90;
         repaint();
         try { Thread.sleep(100); }
         catch (InterruptedException e) { }
         if (ux1 == 0) ux1 = xpos;
      }
      xpos = 5;
    }
  }
</PRE>
</BLOCKQUOTE>
<P>
Those are the only modifications <TT>run()</TT>
needs. Let's override <TT>update()</TT>
to limit the region that is being painted to the left and right
edges of the drawing area that you set inside <TT>run().</TT>
To clip the drawing area to a specific rectangle, use the <TT>clipRect()</TT>
method. <TT>clipRect()</TT>, like
<TT>drawRect()</TT>, <TT>fillRect()</TT>,
and <TT>clearRect()</TT>, is defined
for <TT>Graphics</TT> objects and
takes four arguments: <TT>x</TT> and
<TT>y</TT> starting positions, and
the width and height of the region.
<P>
Here's where <TT>ux1</TT> and <TT>ux2</TT>
come into play. <TT>ux1</TT> is the
x point of the top corner of the region; then use <TT>ux2</TT>
to get the width of the region by subtracting <TT>ux1</TT>
from that value. The y values are the standard y values for the
oval, which don't vary at all (the oval starts at y position 5
and ends at 95). Finally, to finish <TT>update()</TT>,
you call <TT>paint()</TT>:
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
   g.clipRect(ux1, 5, ux2 - ux1, 95);
   paint(g);
 }
</PRE>
</BLOCKQUOTE>
<P>
Note that with the clipping region in place, you don't have to
do anything to the actual <TT>paint()</TT>
method. <TT>paint()</TT> goes ahead
and draws to the entire screen each time, but only the areas inside
the clipping region actually get changed onscreen. 
<P>
You will need to make one change to <TT>paint()</TT>,
however. You need to update the trailing edge of each drawing
area inside <TT>paint()</TT> in case
several calls to <TT>paint()</TT>
were skipped. Because you are testing for a value of <TT>0</TT>
inside <TT>run()</TT>, inside<TT>
paint()</TT> you can merely reset <TT>ux1</TT>
and <TT>ux2</TT> to <TT>0</TT>
after drawing everything:
<BLOCKQUOTE>
<PRE>
ux1 = ux2 = 0;
</PRE>
</BLOCKQUOTE>
<P>
Those are the only changes you have to make to this applet in
order to draw only the parts of the applet that changed (and to
manage the case where some frames don't get updated immediately).
Although this doesn't totally eliminate flickering in the animation,
it does reduce it a great deal. Try it and see. Listing 10.5 shows
the final code for the <TT>Checkers</TT>
applet (called <TT>Checkers2.java</TT>).
<HR>
<BLOCKQUOTE>
<B>Listing 10.5. The final </B><TT><B>Checkers</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Color;
 3: 
 4: public class Checkers2 extends java.applet.Applet implements Runnable {
 5: 
 6:     Thread runner;
 7:     int xpos;
 8:     int ux1,ux2;
 9: 
10:     public void start() {
11:         if (runner == null) {
12:             runner = new Thread(this);
13:             runner.start();
14:         }
15:     }
16:
17:     public void stop() {
18:         if (runner != null) {
19:             runner.stop();
20:             runner = null;
21:         }
22:     }
23:
24:     public void run() {
25:        setBackground(Color.blue);
26:        while (true) {
27:          for (xpos = 5; xpos &lt;= 105; xpos+=4) {
28:             if (xpos == 5) ux2 = size().width;
29:             else ux2 = xpos + 90;
30:             repaint();
31:             try { Thread.sleep(100); }
32:             catch (InterruptedException e) { }
33:             if (ux1 == 0) ux1 = xpos;
34:          }
35:          xpos = 5;
36:        }
37:    }
38: 
39:     public void update(Graphics g) {
40:         g.clipRect(ux1, 5, ux2 - ux1, 95);
41:         paint(g);
42:     }
43: 
44:     public void paint(Graphics g) {
45:         // Draw background
46:         g.setColor(Color.black);
47:         g.fillRect(0, 0, 100, 100);
48:         g.setColor(Color.white);
49:         g.fillRect(101, 0, 100, 100);
50: 
51:         // Draw checker
52:         g.setColor(Color.red);
53:         g.fillOval(xpos, 5, 90, 90);
54:
55:         // reset the drawing area
56:         ux1 = ux2 = 0;
57:     }
58:}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Congratulations on getting through <A HREF="ch10.htm">Day 10</A>! This day was a bit
rough; you've learned a lot, and it all might seem overwhelming.
You learned about a plethora of methods to use and override-<TT>start()</TT>,
<TT>stop()</TT>, <TT>paint()</TT>,
<TT>repaint()</TT>, <TT>run()</TT>,
and <TT>update()</TT>-and you got
a basic foundation in creating and using threads. Other than handling
bitmap images, which you'll learn about tomorrow, you now have
the basic background to create just about any animation you want
in Java.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Why all the indirection with <TT><B>paint()</B></TT>, <TT><B>repaint(),</B></TT> <TT><B>update()</B></TT>, and all that? Why not have a simple paint method that puts stuff on the screen when 
you want it there?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The Java awt enables you to nest drawable surfaces within other drawable surfaces. When a <TT>paint()</TT> takes place, all the parts of the system are redrawn, starting from the outermost 
surface and moving downward into the most nested one. Because the drawing of your applet takes place at the same time everything else is drawn, your applet doesn't get any special treatment. Your applet will be painted when everything else is painted. 
Although with this system you sacrifice some of the immediacy of instant painting, it enables your applet to coexist with the rest of the system more cleanly.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Are Java threads like threads on other systems?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Java threads have been influenced by other thread systems, and if you're used to working with threads, many of the concepts in Java threads will be very familiar to you. You learned the basics 
today; you'll learn more next week on <A HREF="ch18.htm">Day 18</A>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>When an applet uses threads, I just have to tell the thread to start and it starts, and tell it to stop and it stops? That's it? I don't have to test anything in my loops or keep track of 
its state? It just stops?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>It just stops. When you put your applet into a thread, Java can control the execution of your applet much more readily. By causing the thread to stop, your applet just stops running, and then 
resumes when the thread starts up again. Yes, it's all automatic. Neat, isn't it?
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>The <TT><B>ColorSwirl</B></TT> applet seems to display only five or six colors, which isn't very swirly. What's going on here?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>This is the same problem you ran into yesterday. On some systems, there might not be enough colors available to be able to display all of them reliably. If you're running into this problem, 
besides upgrading your hardware, you might try quitting other applications running on your system that use color. Other browsers or color tools in particular might be hogging colors that Java wants to be able to use.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Even with the changes you made, the <TT><B>Checkers</B></TT> applet still flickers.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>And, unfortunately, it will continue to do so. Reducing the size of the drawing area by using clipping does reduce</FONT> the flickering, but it doesn't stop it entirely. For many applets, 
using either of the methods described today may be enough to reduce animation flicker to the point where your applet looks good. To get totally flicker-free animation, you'll need to use a technique called double-buffering, which you'll learn about 
tomorrow.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch11.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
