<HTML>
<HEAD>
<TITLE>Day 4 -- Working with Objects</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;4</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Working with Objects</FONT></H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#CreatingNewObjects">
Creating New Objects</A>
<UL>
<LI><A HREF="#UsingTTFONTSIZEFACECouriernewFONTTT">
Using <TT>new</TT></A>
<LI><A HREF="#WhatTTFONTSIZEFACECouriernewFONTTTFONTSIZEDoesFONT">
What <TT>new</TT>
Does</FONT></A>
<LI><A HREF="#ANoteonMemoryManagement">
A Note on Memory Management</A>
</UL>
<LI><A HREF="#AccessingandSettingClassandInstanceVariables">
Accessing and Setting Class and Instance Variables</A>
<UL>
<LI><A HREF="#GettingValues">
Getting Values</A>
<LI><A HREF="#ChangingValues">
Changing Values</A>
<LI><A HREF="#ClassVariables">
Class Variables</A>
</UL>
<LI><A HREF="#CallingMethods">
Calling Methods</A>
<UL>
<LI><A HREF="#ClassMethods">
Class Methods</A>
</UL>
<LI><A HREF="#ReferencestoObjects">
References to Objects</A>
<LI><A HREF="#CastingandConvertingObjectsandPrimitiveTypes">
Casting and Converting Objects and Primitive Types</A>
<UL>
<LI><A HREF="#CastingPrimitiveTypes">
Casting Primitive Types</A>
<LI><A HREF="#CastingObjects">
Casting Objects</A>
<LI><A HREF="#ConvertingPrimitiveTypestoObjectsandViceVersa">
Converting Primitive Types to Objects and Vice Versa</A>
</UL>
<LI><A HREF="#OddsandEnds">
Odds and Ends</A>
<UL>
<LI><A HREF="#ComparingObjects">
Comparing Objects</A>
<LI><A HREF="#DeterminingtheClassofanObject">
Determining the Class of an Object</A>
</UL>
<LI><A HREF="#ClassandObjectReflectionJava">
Class and Object Reflection (Java 1.1)</A>
<LI><A HREF="#TheJavaClassLibrary">
The Java Class Library</A>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Let's start today's lesson with an obvious statement: Because
Java is an object-oriented language, you're going to be dealing
with a lot of objects. You'll create them, modify them, move them
around, change their variables, call their methods, combine them
with other objects-and, of course, develop classes and use your
own objects in the mix.
<P>
Today, therefore, you'll learn all about the Java object in its
natural habitat. Today's topics include
<UL>
<LI>Creating instances of classes
<LI>Testing and modifying class and instance variables in your
new instance
<LI>Calling methods in that object
<LI>Casting (converting) objects and other data types from one
class to another
<LI>Other odds and ends about working with objects
<LI>An overview of the Java class libraries
</UL>
<H2><A NAME="CreatingNewObjects"><FONT SIZE=5 COLOR=#FF0000>
Creating New Objects</FONT></A></H2>
<P>
When you write a Java program, you define a set of classes. As
you learned on <A HREF="ch2.htm">Day 2</A>, &quot;Object-Oriented Programming and Java,&quot;
classes are templates for objects; for the most part, you merely
use the class to create instances and then work with those instances.
In this section, therefore, you'll learn how to create a new object
from any given class.
<P>
Remember strings from yesterday? You learned that using a string
literal-a series of characters enclosed in double-quotes-creates
a new instance of the class <TT>String</TT>
with the value of that string.
<P>
The <TT>String</TT> class is unusual
in that respect-although it's a class, there's an easy way to
create instances of that class using a literal. The other classes
don't have that shortcut; to create instances of those classes
you have to do so explicitly by using the <TT>new</TT>
operator.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
What about the literals for numbers and characters? Don't they create objects, too? Actually, they don't. The primitive data types for numbers and characters create numbers and characters, but for efficiency, they aren't actually objects. You can put 
object wrappers around them if you need to treat them like objects (you'll learn how to do this in &quot;Casting and `Converting Objects and Primitive Types&quot;).</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="UsingTTFONTSIZEFACECouriernewFONTTT">
Using <TT>new</TT></A></H3>
<P>
To create a new object, you use the <TT>new</TT>
operator with the name of the class you want to create an instance
of, then parentheses after that. The following examples create
new instances of the classes <TT>String</TT>,
<TT>Random</TT>, and <TT>Motorcycle</TT>,
and store those new instances in variables of the appropriate
types:
<BLOCKQUOTE>
<PRE>
String str = new String();

Random r = new Random();

Motorcycle m2 = new Motorcycle();
</PRE>
</BLOCKQUOTE>
<P>
The parentheses are important; don't leave them off. The parentheses
can be empty (as in these examples), in which case the most simple,
basic object is created; or the parentheses can contain arguments
that determine the initial values of instance variables or other
initial qualities of that object:
<BLOCKQUOTE>
<PRE>
Date dt = new Date(90, 4, 1, 4, 30);

Point pt = new Point(0,0);
</PRE>
</BLOCKQUOTE>
<P>
The number and type of arguments you can use inside the parentheses
with <TT>new</TT> are defined by the
class itself using a special method called a constructor (you'll
learn more about constructors later today). If you try and create
a new instance of a class with the wrong number or type of arguments
(or if you give it no arguments and it needs some), then you'll
get an error when you try to compile your Java program. 
<P>
Here's an example of creating several different types of objects
using different numbers and types of arguments. The <TT>Date</TT>
class, part of the <TT>java.util</TT>
package, creates objects that represent the current date. Listing
4.1 is a Java program that shows three different ways of creating
a <TT>Date</TT> object using <TT>new</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 4.1. Laura's </B><TT><B>Date</B></TT><B>
program.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.util.Date;
 2: 
 3: class CreateDates {
 4: 
 5:     public static void main(String args[]) {
 6:         Date d1, d2, d3;
 7: 
 8:         d1 = new Date();
 9:         System.out.println(&quot;Date 1: &quot; + d1);
10: 
11:         d2 = new Date(71, 7, 1, 7, 30);
12:         System.out.println(&quot;Date 2: &quot; + d2);
13: 
14:         d3 = new Date(&quot;April 3 1993 3:24 PM&quot;);
15:         System.out.println(&quot;Date 3: &quot; + d3);
16:     }
17: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Date 1: Tue Feb 13 09:36:56 PST 1996
Date 2: Sun Aug 01 07:30:00 PDT 1971
Date 3: Sat Apr 03 15:24:00 PST 1993<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In this example, three different date objects are created using different arguments to the class listed after <TT>new</TT>. The first instance (line 8) uses <TT>new Date()</TT> with no arguments, which creates a <TT>Date</TT> object for today's date (the 
first line of the output shows a sample; your output will, of course, read the current date and time for you).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The second <TT>Date</TT> object you
create in this example has five integer arguments. The arguments
represent a date: year, month, day, hours, and minutes. And, as
the output shows, this creates a <TT>Date</TT>
object for that particular date: Sunday, August 1, 1971, at 7:30
a.m.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java numbers months starting from 0. So although you might expect the seventh month to be July, month 7 in Java is indeed August.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The third version of <TT>Date</TT>
takes one argument, a string, representing the date as a text
string. When the <TT>Date</TT> object
is created, that string is parsed, and a <TT>Date</TT>
object with that date and time is created (see the third line
of output). The date string can take many different formats; see
the API documentation for the <TT>Date</TT>
class (part of the <TT>java.util</TT>
package) for information about what strings you can use.
<H3><A NAME="WhatTTFONTSIZEFACECouriernewFONTTTFONTSIZEDoesFONT">
What <TT>new</TT>
Does</FONT></A></H3>
<P>
When you use the <TT>new</TT> operator,
the new instance of the given class is created, and memory is
allocated for it. In addition (and most importantly), a special
method defined in the given class is called to initialize the
object and set up any initial values it needs. This special method
is called a constructor. Constructors</FONT>
are special methods, defined in classes, that create and initialize
new instances of classes.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Constructors</FONT> are special methods that initialize a new object, set its variables, create any other objects that object needs, and generally perform any other operations the object needs to initialize itself. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Multiple constructor definitions in a class can each have a different
number or type of arguments-then, when you use <TT>new</TT>,
you can specify different arguments in the argument list, and
the right constructor for those arguments will be called. That's
how each of those different versions of <TT>new</TT>
that you used in the <TT>CreateDates</TT>
class can create different <TT>Date</TT>
objects.
<P>
When you create your own classes, you can define as many constructors
as you need to implement that class's behavior. You'll learn how
to create constructors on <A HREF="ch7.htm">Day 7</A>, &quot;More About Methods.&quot;
<H3><A NAME="ANoteonMemoryManagement">
A Note on Memory Management</A></H3>
<P>
Memory management in Java is dynamic and automatic. When you create
a new object in Java, Java automatically allocates the right amount
of memory for that object in the heap. You don't have to allocate
any memory for any objects explicitly; Java does it for you.
<P>
What happens when you're finished with that object? How do you
de-allocate the memory that object uses? The answer, again, is
that memory management is automatic. Once you're done with an
object, you reassign all the variables that might hold that object
and remove it from any arrays, thereby making the object unusable.
Java has a &quot;garbage collector&quot; that looks for unused
objects and reclaims the memory that those objects are using.
You don't have to do any explicit freeing of memory; you just
have to make sure you're not still holding onto an object you
want to get rid of. You'll learn more specific details about the
Java garbage collector and how it works on <A HREF="ch21.htm">Day 21</A>, &quot;Under
the Hood.&quot;<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A garbage collector</FONT> is a special thing built into the Java environment that looks for unused objects. If it finds any, it automatically removes those objects and frees the memory those objects were using. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="AccessingandSettingClassandInstanceVariables"><FONT SIZE=5 COLOR=#FF0000>
Accessing and Setting Class and Instance Variables</FONT></A></H2>
<P>
Now you have your very own object, and that object may have class
or instance variables defined in it. How do you work with those
variables? Easy! Class and instance variables behave in exactly
the same ways as the local variables you learned about yesterday;
you just refer to them slightly differently than you do regular
variables in your code.
<H3><A NAME="GettingValues">
Getting Values</A></H3>
<P>
To get to the value of an instance variable, you use an expression
in what's called dot notation</FONT>.
With dot notation, the reference to an instance or class variable
has two parts: the object on the left side of the dot and the
variable on the right side of the dot.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Term</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Dot notation</FONT> is an expression used to get at instance variables and methods inside a given object.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
For example, if you have an object assigned to the variable <TT>myObject</TT>,
and that object has a variable called <TT>var</TT>,
you refer to that variable's value like this:
<BLOCKQUOTE>
<PRE>
myObject.var;
</PRE>
</BLOCKQUOTE>
<P>
This form for accessing variables is an expression (it returns
a value), and both sides of the dot can also be expressions. This
means that you can nest instance variable access. If that <TT>var</TT>
instance variable itself holds an object and that object has its
own instance variable called <TT>state</TT>,
you could refer to it like this:
<BLOCKQUOTE>
<PRE>
myObject.var.state;
</PRE>
</BLOCKQUOTE>
<P>
Dot expressions are evaluated left to right, so you start with
<TT>myObject</TT>'s variable <TT>var</TT>,
which points to another object with the variable <TT>state</TT>.
You end up with the value of that <TT>state</TT>
variable after the entire expression is done evaluating.
<H3><A NAME="ChangingValues">
Changing Values</A></H3>
<P>
Assigning a value to that variable is equally easy-just tack an
assignment operator on the right side of the expression:
<BLOCKQUOTE>
<PRE>
myObject.var.state = true;
</PRE>
</BLOCKQUOTE>
<P>
Listing 4.2 is an example of a program that tests and modifies
the instance variables in a <TT>Point</TT>
object. <TT>Point</TT> is part of
the <TT>java.awt</TT> package and
refers to a coordinate point with an <TT>x</TT>
and a <TT>y</TT> value.
<HR>
<BLOCKQUOTE>
<B>Listing 4.2. The </B><TT><B>TestPoint</B></TT><B>
Class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Point;
 2: 
 3: class TestPoint {
 4: public static void main(String args[]) {
 5:     Point thePoint = new Point(10,10);
 6:
 7:     System.out.println(&quot;X is &quot; + thePoint.x);
 8:     System.out.println(&quot;Y is &quot; + thePoint.y);
 9:
10:     System.out.println(&quot;Setting X to 5.&quot;);
11:     thePoint.x = 5;
12:     System.out.println(&quot;Setting Y to 15.&quot;);
13:     thePoint.y = 15;
14:
15:     System.out.println(&quot;X is &quot; + thePoint.x);
16:     System.out.println(&quot;Y is &quot; + thePoint.y);
17:
18:  }
19:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
X is 10
Y is 10
Setting X to 5.
Setting Y to 15.
X is 5
Y is 15<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In this example, you first create an instance of <TT>Point</TT> where <TT>X</TT> and <TT>Y</TT> are both <TT>10</TT> (line 6). Lines 8 and 9 print out those individual values, and you can see dot notation at work there. Lines 11 through 14 change the 
values of those variables to <TT>5</TT> and <TT>15</TT>, respectively. Finally, lines 16 and 17 print out the values of <TT>X</TT> and <TT>Y</TT> again to show how they've changed.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="ClassVariables">
Class Variables</A></H3>
<P>
Class variables, as you've already learned, are variables that
are defined and stored in the class itself. Their values, therefore,
apply to the class and to all its instances.
<P>
With instance variables, each new instance of the class gets a
new copy of the instance variables that class defines. Each instance
can then change the values of those instance variables without
affecting any other instances. With class variables, there is
only one copy of that variable. Every instance of the class has
access to that variable, but there is only one value. Changing
the value of that variable changes it for all the instances of
that class.
<P>
You define class variables by including the <TT>static</TT>
keyword before the variable itself. You'll learn more about this
on <A HREF="ch6.htm">Day 6</A>, &quot;Creating Classes and Applications in Java.&quot;
For example, take the following partial class definition:
<BLOCKQUOTE>
<PRE>
class FamilyMember {
    static String surname = &quot;Johnson&quot;;
    String name;
    int age;
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
Instances of the class <TT>FamilyMember</TT>
each have their own values for name and age. But the class variable
<TT>surname</TT> has only one value
for all family members. Change <TT>surname</TT>,
and all the instances of <TT>FamilyMember</TT>
are affected.
<P>
To access class variables, you use the same dot notation as you
do with instance variables. To get or change the value of the
class variable, you can use either the instance or the name of
the class on the left side of the dot. Both of the lines of output
in this example print the same value:
<BLOCKQUOTE>
<PRE>
FamilyMember dad = new FamilyMember();
System.out.println(&quot;Family's surname is: &quot; + dad.surname);
System.out.println(&quot;Family's surname is: &quot; + FamilyMember.surname);
</PRE>
</BLOCKQUOTE>
<P>
Because you can use an instance to change the value of a class
variable, it's easy to become confused about class variables and
where their values are coming from (remember that the value of
a class variable affects all the instances). For this reason,
it's a good idea to use the name of the class when you refer to
a class variable-it makes your code easier to read and strange
results easier to debug.
<H2><A NAME="CallingMethods"><FONT SIZE=5 COLOR=#FF0000>
Calling Methods</FONT></A></H2>
<P>
Calling a method is similar to referring to an object's instance
variables: Method calls to objects also use dot notation. The
object itself whose method you're calling is on the left side
of the dot; the name of the method and its arguments are on the
right side of the dot:
<BLOCKQUOTE>
<PRE>
myObject.methodOne(arg1, arg2, arg3);
</PRE>
</BLOCKQUOTE>
<P>
Note that all calls to methods must have parentheses after them,
even if that method takes no arguments:
<BLOCKQUOTE>
<PRE>
myObject.methodNoArgs();
</PRE>
</BLOCKQUOTE>
<P>
If the method you've called returns an object that itself has
methods, you can nest methods as you would variables. This next
example calls the <TT>getName()</TT>
method, which is defined in the object returned by the <TT>getClass()</TT>
method, which was defined in <TT>myObject</TT>.
Got it?
<BLOCKQUOTE>
<PRE>
myObject.getClass().getName();
</PRE>
</BLOCKQUOTE>
<P>
You can combine nested method calls and instance variable references
as well (in this case you're calling the methodTwo() method, which
is defined in the object stored by the <TT>var</TT>
instance variable, which in turn is part of the <TT>myObject</TT>
object):
<BLOCKQUOTE>
<PRE>
myObject.var.methodTwo(arg1, arg2);
</PRE>
</BLOCKQUOTE>
<P>
<TT>System.out.println()</TT>, the
method you've been using through the book this far to print out
bits of text, is a great example of nesting variables and methods.
The <TT>System</TT> class (part of
the <TT>java.lang</TT> package) describes
system-specific behavior. <TT>System.out</TT>
is a class variable that contains an instance of the class <TT>PrintStream</TT>
that points to the standard output of the system. <TT>PrintStream</TT>
instances have a <TT>println()</TT>
method that prints a string to that output stream. 
<P>
Listing 4.3 shows an example of calling some methods defined in
the <TT>String</TT> class. Strings
include methods for string tests and modification, similar to
what you would expect in a string library in other languages.
<HR>
<BLOCKQUOTE>
<B>Listing 4.3. Several uses of </B><TT><B>String</B></TT><B>
methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class TestString {
 2: 
 3:     public static void main(String args[]) {
 4:         String str = &quot;Now is the winter of our discontent&quot;;
 5: 
 6:         System.out.println(&quot;The string is: &quot; + str);
 7:         System.out.println(&quot;Length of this string: &quot;
 8:                 + str.length());
 9:         System.out.println(&quot;The character at position 5: &quot;
10:                 + str.charAt(5));
11:         System.out.println(&quot;The substring from 11 to 17: &quot;
12:                 + str.substring(11, 17));
13:         System.out.println(&quot;The index of the character d: &quot;
14:                 + str.indexOf('d'));
15:         System.out.print(&quot;The index of the beginning of the &quot;);
16:         System.out.println(&quot;substring \&quot;winter\&quot;: &quot;
17:                 + str.indexOf(&quot;winter&quot;));
18:         System.out.println(&quot;The string in upper case: &quot;
19:                 + str.toUpperCase());
20:     }
21: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
The string is: Now is the winter of our discontent
Length of this string: 35
The character at position 5: s
The substring from positions 11 to 17: winter
The index of the character d: 25
The index of the beginning of the substring &quot;winter&quot;: 11
The string in upper case: NOW IS THE WINTER OF OUR DISCONTENT
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In line 4, you create a new instance of <TT>String</TT> by using a string literal (it's easier that way than using <TT>new</TT> and then putting the characters in individually). The remainder of the program simply calls different string methods to do 
different operations on that string:
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<UL>
<LI>Line 6 prints the value of the string we created in line 4:
<TT>&quot;Now is the winter of our discontent&quot;</TT>.
<LI>Line 7 calls the <TT>length()</TT>
method in the new <TT>String</TT>
object. This string has 35 characters.
<LI>Line 9 calls the <TT>charAt()</TT>
method, which returns the character at the given position in the
string. Note that string positions start at <TT>0</TT>,
so the character at position <TT>5</TT>
is <TT>s</TT>.
<LI>Line 11 calls the <TT>substring()</TT>
method, which takes two integers indicating a range and returns
the substring at those starting and ending points. The <TT>substring()</TT>
method can also be called with only one argument, which returns
the substring from that position to the end of the string.
<LI>Line 13 calls the <TT>indexOf()</TT>
method, which returns the position of the first instance of the
given character (here, <TT>'d'</TT>).
<LI>Line 15 shows a different use of the <TT>indexOf()</TT>
method, which takes a string argument and returns the index of
the beginning of that string.
<LI>Finally, line 19 uses the <TT>toUpperCase()</TT>
method to return a copy of the string in all uppercase.
</UL>
<H3><A NAME="ClassMethods">
Class Methods</A></H3>
<P>
Class methods, like class variables, apply to the class as a whole
and not to its instances. Class methods are commonly used for
general utility methods that may not operate directly on an instance
of that class, but fit with that class conceptually. For example,
the <TT>String</TT> class contains
a class method called <TT>valueOf()</TT>,
which can take one of many different types of arguments (integers,
booleans, other objects, and so on). The <TT>valueOf()</TT>
method then returns a new instance of <TT>String</TT>
containing the string value of the argument it was given. This
method doesn't operate directly on an existing instance of <TT>String</TT>,
but getting a string from another object or data type is definitely
a <TT>String</TT>-like operation,
and it makes sense to define it in the <TT>String</TT>
class.
<P>
Class methods can also be useful for gathering general methods
together in one place (the class). For example, the <TT>Math</TT>
class, defined in the <TT>java.lang</TT>
package, contains a large set of mathematical operations as class
methods-there are no instances of the class <TT>Math</TT>,
but you can still use its methods with numeric or boolean arguments.
For example, the class method <TT>Math.max()</TT>
takes two arguments and returns the larger of the two. You don't
need to create a new instance of <TT>Math</TT>;
just call the method anywhere you need it, like this:
<BLOCKQUOTE>
<PRE>
in biggerOne = Math.max(x, y);
</PRE>
</BLOCKQUOTE>
<P>
To call a class method, you use dot notation as you do with instance
methods. As with class variables, you can use either an instance
of the class or the class itself on the left site of the dot.
However, for the same reasons noted in the discussion on class
variables, using the name of the class for class methods makes
your code easier to read. The last two lines in this example produce
the same result (the string <TT>&quot;5&quot;</TT>):
<BLOCKQUOTE>
<PRE>
String s, s2;
s = &quot;foo&quot;;
s2 = s.valueOf(5);
s2 = String.valueOf(5);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="ReferencestoObjects"><FONT SIZE=5 COLOR=#FF0000>
References to Objects</FONT></A></H2>
<P>
As you work with objects, one important thing going on behind
the scenes is the use of references to those objects. When you
assign objects to variables, or pass objects as arguments to methods,
you are passing references to those objects, not the objects themselves
or copies of those objects.
<P>
An example should make this clearer. Examine Listing 4.4, which
shows a simple example of how references work.
<HR>
<BLOCKQUOTE>
<B>Listing 4.4. A references example.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Point;
 2:
 3: class ReferencesTest {
 4:     public static void main (String args[]) {
 5:        Point pt1, pt2;
 6:         pt1 = new Point(100, 100);
 7:         pt2 = pt1;
 8: 
 9:         pt1.x = 200;
10:         pt1.y = 200;
11:         System.out.println(&quot;Point1: &quot; + pt1.x + &quot;, &quot; + pt1.y);
12:         System.out.println(&quot;Point2: &quot; + pt2.x + &quot;, &quot; + pt2.y);
13:     }
14: }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
Point1: 200, 200
Point2: 200, 200<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In the first part of this program, you declare two variables of type <TT>Point </TT>(line 5), create a new <TT>Point</TT> object to <TT>pt1</TT> (line 6), and finally, assign the value of <TT>pt1</TT> to <TT>pt2</TT> (line 7).
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now, here's the challenge. After changing <TT>pt1</TT>'s
<TT>x</TT> and <TT>y</TT>
instance variables in lines 9 and 10, what will <TT>pt2</TT>
look like?
<P>
As you can see, <TT>pt2</TT>'s x and
y instance variables were also changed, even though you never
explicitly changed them. When you assign the value of <TT>pt1</TT>
to <TT>pt2</TT>, you actually create
a reference from <TT>pt2</TT> to the
same object to which <TT>pt1</TT>
refers (see Figure 4.1). Change the object that <TT>pt2</TT>
refers to, and you also change the object that <TT>pt1</TT>
points to, because both are references to the same object.
<P>
<A HREF="http://docs.rinet.ru/J21/f4-1.gif"><B>Figure 4.1 : </B><I>References to objects</I>.</A><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you actually do want <TT>pt1</TT> and <TT>pt2</TT> to point to separate objects, you should use new <TT>Point()</TT> for both lines to create separate objects.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The fact that Java uses references becomes particularly important
when you pass arguments to methods. You'll learn more about this
later today, but keep these references in mind.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There are no explicit pointers or pointer arithmetic in Java as there are in C-like languages-just references. However, with these references, and with Java arrays, you have most of the capabilities that you have with pointers without the confusion and 
lurking bugs that explicit pointers can create.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="CastingandConvertingObjectsandPrimitiveTypes"><FONT SIZE=5 COLOR=#FF0000>
Casting and Converting Objects and Primitive Types</FONT></A></H2>
<P>
Sometimes in your Java programs you may have a value stored somewhere
that is the wrong type for what you want to do with it. Maybe
it's an instance of the wrong class, or perhaps it's a <TT>float</TT>
and you want it to be an <TT>int</TT>.
To convert the value of one type to another, you use casting.
Casting is a programming term that means, effectively, converting
a value or an object from one type to another. The result of a
cast is a new value or object; casting does not change the original
object or value. <BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>New Time</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Casting</FONT> converts the value of an object or primitive type into another type.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Although the concept of casting is a simple one, the rules for
what types in Java can be converted to what other types are complicated
by the fact that Java has both primitive types (<TT>int</TT>,
<TT>float</TT>, <TT>boolean</TT>),
and object types (<TT>String</TT>,
<TT>Point</TT>, <TT>Window</TT>,
and so on). There are three forms of casts and conversions to
talk about in this section:
<UL>
<LI>Casting between primitive types: <TT>int</TT>
to <TT>float</TT> or <TT>float</TT>
to <TT>double</TT>
<LI>Casting between object types: an instance of a class to an
instance of another class
<LI>Converting primitive types to objects and then extracting
primitive values back out of those objects
</UL>
<H3><A NAME="CastingPrimitiveTypes">
Casting Primitive Types</A></H3>
<P>
Casting between primitive types allows you to &quot;convert&quot;
the value of one type to another primitive type-for example, to
assign a number of one type to a variable of another type. Casting
between primitive types most commonly occurs with the numeric
types; boolean values cannot be cast to any other primitive type.
<P>
Often, if the type you are casting to is &quot;larger&quot; than
the type of the value you're converting, you may not have to use
an explicit cast. You can often automatically treat a byte or
a character as an <TT>int</TT>, for
example, or an <TT>int</TT> as a <TT>long</TT>,
an <TT>int</TT> as a <TT>float</TT>,
or anything as a <TT>double</TT> automatically.
In most cases, because the larger type provides more precision
than the smaller, no loss of information occurs when the value
is cast. The exception is casting integers to floating-point values;
casting an <TT>int</TT> or a <TT>long</TT>
to a <TT>float</TT> or a <TT>long</TT>
to a <TT>double</TT> may cause some
loss of precision.
<P>
To convert a large value to smaller type, you must use an explicit
cast, because converting that value may result in a loss of precision.
Explicit casts look like this:
<BLOCKQUOTE>
<PRE>
(<I>typename</I>)</FONT><I>value</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
In this form, <TT><I>typename</I></TT>
is the name of the type you're converting to (for example: <TT>short</TT>,
<TT>int</TT>, <TT>float</TT>,
<TT>boolean</TT>), and <TT><I>value</I></TT>
is an expression that results in the value you want to convert.
So, for example, in this expression the value of <TT>x</TT>
is divided by the value of <TT>y</TT>
and the result is cast to an <TT>int</TT>:
<BLOCKQUOTE>
<PRE>
(int) (x / y);
</PRE>
</BLOCKQUOTE>
<P>
Note that because the precedence of casting is higher than that
of arithmetic, you have to use parentheses here; otherwise, the
value of <TT>x</TT> would be cast
first and then divided by <TT>y</TT>
(which might very well be a very different result).
<H3><A NAME="CastingObjects">
Casting Objects</A></H3>
<P>
Instances of classes can also be cast to instances of other classes,
with one restriction: The class of the object you're casting and
the class you're casting it to must be related by inheritance;
that is, you can cast an object only to an instance of its class's
sub- or superclass-not to any random class.
<P>
Analogous to converting a primitive value to a larger type, some
objects may not need to be cast explicitly. In particular, because
subclasses contain all the same information as their superclass,
you can use an instance of a subclass anywhere a superclass is
expected. (Did you just have to read that sentence four times
before you understood it? I had to rewrite it a whole lot of times
before it became even that simple. Bear with me, its not that
bad. Let's try an example.) Suppose you have a method that takes
two arguments: one of type <TT>Object</TT>,
and one of type <TT>Number</TT>. You
don't have to pass instances of those particular classes to that
method. For the <TT>Object</TT> argument,
you can pass any subclass of <TT>Object</TT>
(any object, in other words), and for the <TT>Number</TT>
argument you can pass in any instance of any subclass of <TT>Number</TT>
(<TT>Integer</TT>, <TT>Boolean</TT>,
<TT>Float</TT>, and so on); you don't
have to explicitly convert them first. 
<P>
Casting downward in the class hierarchy is automatic, but casting
upward is not. Converting an instance of a subclass to an instance
of a superclass loses the information the original subclass provided
and requires an explicit cast. To cast an object to another class,
you use the same casting operation that you used for base types:
<BLOCKQUOTE>
<PRE>
(<I>classname</I>)</FONT><I>object</FONT></I>
</PRE>
</BLOCKQUOTE>
<P>
In this case, <TT><I>classname</I></TT>
is the name of the class you want to cast the object to, and <TT><I>object</I></TT>
is a reference to the object you're casting. Note that casting
creates a reference to the old object of the type <TT><I>classname</I></TT>;
the old object still continues to exist as it did before.
<P>
Here's a (fictitious) example of a cast of an instance of the
class <TT>GreenApple</TT> to an instance
of the class <TT>Apple</TT> (where
<TT>GreenApple</TT> is theoretically
a subclass of <TT>Apple</TT> with
more information to define the apple as green): 
<BLOCKQUOTE>
<PRE>
GreenApple a;
Apple a2;
a = new GreenApple();
a2 = (Apple) a;
</PRE>
</BLOCKQUOTE>
<P>
In addition to casting objects to classes, you can also cast objects
to interfaces-but only if that object's class or one of its superclasses
actually implements that interface. Casting an object to an interface
means that you can call one of that interface's methods even if
that object's class does not actually implement that interface.
You'll learn more about interfaces in Week 3.
<H3><A NAME="ConvertingPrimitiveTypestoObjectsandViceVersa">
Converting Primitive Types to Objects and Vice Versa</A></H3>
<P>
Now you know how to cast a primitive type to another primitive
type and how to cast between classes. How can you cast one to
the other?
<P>
You can't! Primitive types and objects are very different things
in Java and you can't automatically cast or convert between the
two. However, the <TT>java.lang</TT>
package includes several special classes that correspond to each
primitive data type: <TT>Integer</TT>
for <TT>int</TT>s, <TT>Float</TT>
for <TT>float</TT>s, <TT>Boolean</TT>
for <TT>boolean</TT>s, and so on.
Note that the class names have an initial capital letter, and
the primitive types are lowercase. Java treats these names very
differently, so don't confuse them, or your methods and variables
won't behave the way you expect.
<P>
Using class methods defined in these classes, you can create an
object-equivalent for all the primitive types using <TT>new</TT>.
The following line of code creates an instance of the <TT>Integer</TT>
class with the value <TT>35</TT>:
<BLOCKQUOTE>
<PRE>
Integer intObject = new Integer(35);
</PRE>
</BLOCKQUOTE>
<P>
Once you have actual objects, you can treat those values as objects.
Then, when you want the primitive values back again, there are
methods for that as well-for example, the <TT>intValue()</TT>
method extracts an <TT>int</TT> primitive
value from an <TT>Integer</TT> object:
<BLOCKQUOTE>
<PRE>
int theInt = intObject.intValue();  // returns 35
</PRE>
</BLOCKQUOTE>
<P>
See the Java API documentation for these special classes for specifics
on the methods for converting primitives to and from objects.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In Java 1.0 there are special type classes for <TT>Boolean</TT>, <TT>Character</TT>, <TT>Double</TT>, <TT>Float</TT>, <TT>Integer</TT>, and <TT>Long</TT>. Java 1.1 adds classes for <TT>Byte</TT> and <TT>Short</TT>, as well as a special wrapper class for 
<TT>Void</TT>. The latter classes are used primarily for object reflection.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="OddsandEnds"><FONT SIZE=5 COLOR=#FF0000>
Odds and Ends</FONT></A></H2>
<P>
This section is a catchall for other information about working
with objects, particularly the following:
<UL>
<LI>Comparing objects
<LI>Finding out the class of any given object
<LI>Testing to see whether an object is an instance of a given
class
</UL>
<H3><A NAME="ComparingObjects">
Comparing Objects</A></H3>
<P>
Yesterday you learned about operators for comparing values: equals,
not equals, less than, and so on. Most of these operators work
only on primitive types, not on objects. If you try to use other
values as operands, the Java compiler produces errors.
<P>
The exception to this rule is with the operators for equality:
<TT>==</TT> (equal) and <TT>!=
</TT>(not equal). These operators, when used with objects,
test whether the two operands refer to exactly the same object
in memory.
<P>
What should you do if you want to be able to compare instances
of your class and have meaningful results? You have to implement
special methods in your class, and you have to call those methods
using those method names. <BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Java does not have the concept of operator overloading-that is, the ability to redefine the behavior of the built-in operators using methods in your own classes. The built-in operators remain defined only for numbers.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
A good example of this is the <TT>String</TT>
class. It is possible to have two strings, two independent objects
in memory with the same values-that is, the same characters in
the same order. According to the <TT>==</TT>
operator, however, those two <TT>String</TT>
objects will not be equal, because, although their contents are
the same, they are not the same object.
<P>
The <TT>String</TT> class, therefore,
defines a method called <TT>equals()</TT>
that tests each character in the string and returns <TT>true</TT>
if the two strings have the same values. Listing 4.5 illustrates
this.
<HR>
<BLOCKQUOTE>
<B>Listing 4.5. A test of string equality.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: class EqualsTest {
 2: public static void main(String args[]) {
 3:         String str1, str2;
 4:         str1 = &quot;she sells sea shells by the sea shore.&quot;;
 5:         str2 = str1;
 6:  
 7:        System.out.println(&quot;String1: &quot; + str1);
 8:         System.out.println(&quot;String2: &quot; + str2);
 9:         System.out.println(&quot;Same object? &quot; + (str1 == str2));
10:  
11:        str2 = new String(str1);
12:  
13:        System.out.println(&quot;String1: &quot; + str1);
14:         System.out.println(&quot;String2: &quot; + str2);
15:         System.out.println(&quot;Same object? &quot; + (str1 == str2));
16:         System.out.println(&quot;Same value? &quot; + str1.equals(str2));
17:     }
18:  }
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<IMG SRC="http://docs.rinet.ru/J21/output.gif" BORDER=0>
<BLOCKQUOTE>
<PRE>
String1: she sells sea shells by the sea shore.
String2: she sells sea shells by the sea shore.
Same object? true
String1: she sells sea shells by the sea shore.
String2: she sells sea shells by the sea shore.
Same object? false
Same value? true<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The first part of this program (lines 4 through 6) declares two variables <TT>(str1</TT> and <TT>str2</TT>) assigns the literal <TT>she sells sea shells by the sea shore.</TT> to <TT>str1</TT>, and then assigns that value to <TT>str2</TT>. As you learned 
earlier when we talked about object references, now <TT>str1</TT> and <TT>str2</TT> point to the same object, and the equality test at line 10 proves that.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In the second part, you create a new string object with the same
value as <TT>str1</TT> and assign
<TT>str2</TT> to that new string object.
Now you have two different string objects in <TT>str1</TT>
and <TT>str2</TT>, both with the same
value. Testing them to see whether they're the same object by
using the <TT>==</TT> operator (line
16) returns the expected answer (<TT>false</TT>-they
are not the same object in memory), as does testing them using
the <TT>equals()</TT> method (line
17) (<TT>true</TT>-they have the same
values).<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Why can't you just use another literal when you change <TT>str2</TT>, rather than using <TT>new</TT>? String literals are optimized in Java-if you create a string using a literal, and then use another literal with the same characters, Java knows enough to 
give you the first <TT>String</TT> object back. Both strings are the same objects-to create two separate objects you have to go out of your way.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="DeterminingtheClassofanObject">
Determining the Class of an Object</A></H3>
<P>
Want to find out the class of an object? Here's the way to do
it for an object assigned to the variable <TT>obj</TT>:
<BLOCKQUOTE>
<PRE>
String name = obj.getClass().getName();
</PRE>
</BLOCKQUOTE>
<P>
What does this do? The <TT>getClass()</TT>
method is defined in the <TT>Object</TT>
class, and as such is available for all objects. The result of
that method is a <TT>Class</TT> object
(where <TT>Class</TT> is itself a
class), which has a method called <TT>getName()</TT>.
<TT>getName()</TT> returns a string
representing the name of the class.
<P>
Another test that might be useful to you is the <TT>instanceof</TT>
operator. <TT>instanceof</TT> has
two operands: an object on the left and the name of a class on
the right. The expression returns <TT>true</TT>
or <TT>false</TT> based on whether
the object is an instance of the named class or any of that class's
subclasses:
<BLOCKQUOTE>
<PRE>
&quot;foo&quot; instanceof String // true
Point pt = new Point(10, 10);
pt instanceof String // false
</PRE>
</BLOCKQUOTE>
<P>
The <TT>instanceof</TT> operator can
also be used for interfaces; if an object implements an interface,
the <TT>instanceof</TT> operator with
that interface name on the right side returns <TT>true</TT>.
You'll learn all about interfaces in Week 3.
<H2><A NAME="ClassandObjectReflectionJava"><FONT SIZE=5 COLOR=#FF0000>
Class and Object Reflection (Java 1.1)</FONT></A></H2>
<P>
Reflection, also known as introspection, is a somewhat lofty term
to describe the ability to &quot;look inside&quot; a class or
an object and get information about that object's variables and
methods as well as actually set and get the values of those variables
and to call methods. Object reflection is useful for tools such
as class browsers or debuggers, where getting at the information
of an object on-the-fly allows you to explore what that object
can do, or for component-based programs such as Java Beans, where
the ability for one object to query another object about what
it can do (and then ask it to do something) is useful to building
larger applications.
<P>
The classes that support reflection of Java classes and objects
will be part of the core Java 1.1 API (they are not available
in the 1.0.2 version of the JDK). A new package, <TT>java.lang.reflect</TT>,
will contain new classes to support reflection, which include
the following:
<UL>
<LI><TT>Field</TT>, for managing and
finding out information about class and instance variables
<LI><TT>Method</TT>, for managing
class and instance methods
<LI><TT>Constructor</TT>, for managing
the special methods for creating new instances of classes (you'll
learn more about constructors on <A HREF="ch7.htm">Day 7</A>)
<LI><TT>Array</TT>, for managing arrays
<LI><TT>Modifier</TT>, for decoding
modifier information about classes, variables and methods (more
about modifiers on <A HREF="ch15.htm">Day 15</A>, &quot;Modifiers, Access Control, and
Class Design&quot;)
</UL>
<P>
In addition, there will be a number of new methods available in
the <TT>Class</TT> class to help tie
together the various reflection classes.
<P>
You can find out more about the new reflection classes and methods
from <TT><A HREF="http://java.sun.com/products/JDK/1.1/designspecs/reflection/">http://java.sun.com/products/JDK/1.1/designspecs/reflection/</A>.</TT>
<H2><A NAME="TheJavaClassLibrary"><FONT SIZE=5 COLOR=#FF0000>
The Java Class Library</FONT></A></H2>
<P>
To finish up today, let's look at the Java class library. Actually,
you've had some experience with some of the Java classes already,
so they shouldn't seem that strange.
<P>
The Java class library provides the set of classes that are guaranteed
to be available in any commercial Java environment (for example,
in any Java development environment or in browsers such as Netscape).
Those classes are in the <TT>java</TT>
package and include all the classes you've seen so far in this
book, plus a whole lot more classes you'll learn about later on
in this book (and more you may not learn about at all).
<P>
The Java Developer's Kit comes with documentation for all of the
Java class library, which includes descriptions of each class's
instance variables, methods, constructors, interfaces, and so
on. You can get to this documentation (called the Java Application
Programmer's Interface, or API) via the Web at <TT><A HREF="http://java.sun.com/products/JDK/CurrentRelease/api/packages.html">http://java.sun.com:80/products/JDK/CurrentRelease/api/packages.html</A></TT>.
A shorter summary of the Java API is in appendix C as well. Exploring
the Java class library and its methods and instance variables
is a great way to figure out what Java can and cannot do, as well
as how it can become a starting point for your own development.
<P>
Here are the class packages that are part of the Java class library:
<UL>
<LI><TT>java.lang</TT>-Classes that
apply to the language itself, including the <TT>Object</TT>
class, the <TT>String</TT> class,
and the <TT>System</TT> class. It
also contains the special classes for the primitive types (<TT>Integer</TT>,
<TT>Character</TT>, <TT>Float</TT>,
and so on). You'll get at least a glance at most of the classes
in this package in this first week.
<LI><TT>java.util</TT>-Utility classes,
such as <TT>Date</TT>, as well as
simple collection classes, such as <TT>Vector</TT>
and <TT>Hashtable</TT>. You'll learn
more about these classes in the Bonus Week.
<LI><TT>java.io</TT>-Input and output
classes for writing to and reading from streams (such as standard
input and output) and for handling files. <A HREF="ch19.htm">Day 19</A>, &quot;Streams
and I/O,&quot; describes the classes in this package.
<LI><TT>java.net</TT>-Classes for
networking support, including <TT>Socket</TT>
and <TT>URL</TT> (a class to represent
references to documents on the World Wide Web). You'll learn a
little about networking on <A HREF="ch14.htm">Day 14</A>, &quot;Windows, Networking,
and Other Tidbits,&quot; and then on <A HREF="ch26.htm">Day 26</A>, &quot;Client/Server
Networking in Java.&quot;
<LI><TT>java.awt</TT>-This is the
Abstract Windowing Toolkit. It contains classes to implement graphical
user interface features, including classes for <TT>Window</TT>,
<TT>Menu</TT>, <TT>Button</TT>,
<TT>Font</TT>, <TT>CheckBox</TT>,
and so on. It also includes mechanisms for managing system events
and for processing images (in the <TT>java.awt.Image</TT>
package). You'll learn all about the awt in Week 2.
<LI><TT>java.applet</TT>-Classes to
implement Java applets.
</UL>
<P>
In addition to the Java classes, your development environment
may also include additional classes that provide other utilities
or functionality. Although these classes may be useful, because
they are not part of the standard Java library, they may not be
available to other people trying to run your Java program unless
you explicitly include those classes with your program. This is
particularly important for applets, because applets are expected
to be able to run on any platform, using any Java-enabled browser.
Only classes inside the <TT>java</TT>
package are guaranteed to be available on all browsers and Java
environments.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Objects, objects everywhere. Today, you've learned all about how
to deal with objects: how to create them, how to find out and
change the values of their variables, and how to call their methods.
You have also learned how to copy and compare them and how to
convert them into other objects. Finally, you have learned a bit
about the Java class libraries-which give you a whole slew of
classes to play with in your own programs.
<P>
You now have the fundamentals of  how to deal with most simple
things in the Java language. All you have left are arrays, conditionals,
and loops, which you'll learn about tomorrow. Then you'll learn
how to define and use classes in Java applications on <A HREF="ch6.htm">Day 6</A>, and
launch directly into applets next week. With just about everything
you do in your Java programs, you'll always come back to objects.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I'm confused about the differences between objects and the primitive data types, such as <TT><B>int</B></TT> and <TT><B>boolean</B></TT>.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>The primitive types in the language (<TT>byte</TT>, <TT>short</TT>, <TT>int</TT>, <TT>long</TT>, <TT>float</TT>, <TT>double</TT>, <TT>boolean</TT>, and <TT>char</TT>) represent the smallest 
things in the language. They are not objects, although in many ways they can be handled like objects-they can be assigned to variables and passed in and out of methods. Most of the operations that work exclusively on objects, however, will not work with 
primitive types.
<P>
Objects are instances of classes and, as such, are usually much more complex data types than simple numbers and characters, often containing numbers and characters as instance or class variables.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q</FONT>:</B></CENTER>
</TD><TD><B>No pointers in Java? If you don't have pointers, how are you supposed to do something like linked lists, where you have a pointer from one nose to another so you can traverse them?</FONT></B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A</FONT>:</B></CENTER>
</TD><TD>Java doesn't have no pointers at all; it has no explicit</FONT> pointers. Object references are, effectively, pointers. So to create something like a linked list, you would create a class called <TT>Node</TT>, which would have an instance variable 
also of type <TT>Node</TT>. Then to link together node objects all you need to do is assign a node object to the instance variable of the object just before it in the list. Because object references are pointers, linked lists set up this way will behave as 
you would expect them to.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>In the section on calling methods, you had examples of calling a method with a different number of arguments each time-and it gave a different kind of result. How is that possible?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>That's called method overloading.</FONT> Overloading means that the same method can have different behavior based on the arguments it's called with-and the number and type of arguments can 
vary. When you define methods in your own classes, you define separate method signatures with different sets of arguments and different definitions. When a method is called, Java figures out which definition to execute based on the number and type of 
arguments with which you called it.
<P>
You'll learn all about this on <A HREF="ch6.htm">Day 6</A>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>No operator overloading in Java? Why not? I thought Java was based on C++, and C++ has operator overloading.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Java was indeed based on C++, but it was also designed to be simple, so many of C++'s features have been removed. The argument against operator overloading is that because the operator can be 
defined to mean anything; it makes it very difficult to figure out what any given operator is doing at any one time. This can result in entirely unreadable code. When you use a method, you know it can mean many things to many classes, but when you use an 
operator you would like to know that it always means the same thing. Given the potential for abuse, the designers of Java felt it was one of the C++ features that was best left out.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch5.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
