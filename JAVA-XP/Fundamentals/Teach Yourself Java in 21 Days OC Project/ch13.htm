<HTML>
<HEAD>
<TITLE>Day 13 -- Creating User Interfaces with the awt</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;13</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Creating User Interfaces with the
awt</FONT></H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#AnawtOverview">
An awt Overview</A>
<LI><A HREF="#TheBasicUserInterfaceComponents">
The Basic User Interface Components</A>
<UL>
<LI><A HREF="#Labels">
Labels</A>
<LI><A HREF="#Buttons">
Buttons</A>
<LI><A HREF="#CheckBoxes">
Check Boxes</A>
<LI><A HREF="#RadioButtons">
Radio Buttons</A>
<LI><A HREF="#ChoiceMenus">
Choice Menus</A>
<LI><A HREF="#TextFields">
Text Fields</A>
</UL>
<LI><A HREF="#PanelsandLayout">
Panels and Layout</A>
<UL>
<LI><A HREF="#LayoutManagersAnOverview">
Layout Managers: An Overview</A>
<LI><A HREF="#TheTTFONTSIZEFACECourierFlowLayoutFONTTTFONTSIZEClassFONT">
The <TT>FlowLayout</TT>
Class</FONT></A>
<LI><A HREF="#GridLayouts">
Grid Layouts</A>
<LI><A HREF="#BorderLayouts">
Border Layouts</A>
<LI><A HREF="#CardLayouts">
Card Layouts</A>
<LI><A HREF="#GridBagLayouts">
Grid Bag Layouts</A>
<LI><A HREF="#Insets">
Insets</A>
</UL>
<LI><A HREF="#HandlingUIActionsandEvents">
Handling UI Actions and Events</A>
<LI><A HREF="#NestingPanelsandComponents">
Nesting Panels and Components</A>
<UL>
<LI><A HREF="#NestedPanels">
Nested Panels</A>
<LI><A HREF="#EventsandNestedPanels">
Events and Nested Panels</A>
</UL>
<LI><A HREF="#MoreUIComponents">
More UI Components</A>
<UL>
<LI><A HREF="#TextAreas">
Text Areas</A>
<LI><A HREF="#ScrollingLists">
Scrolling Lists</A>
<LI><A HREF="#ScrollbarsandSliders">
Scrollbars and Sliders</A>
<LI><A HREF="#Canvases">
Canvases</A>
</UL>
<LI><A HREF="#MoreUIEvents">
More UI Events</A>
<LI><A HREF="#FunwithComponents">
Fun with Components</A>
<LI><A HREF="#ACompleteExampleRGBtoHSBConverter">
A Complete Example: RGB-to-HSB Converter</A>
<UL>
<LI><A HREF="#DesigningandCreatingtheAppletLayout">
Designing and Creating the Applet Layout</A>
<LI><A HREF="#DefiningtheSubpanels">
Defining the Subpanels</A>
<LI><A HREF="#HandlingtheActions">
Handling the Actions</A>
<LI><A HREF="#UpdatingtheResult">
Updating the Result</A>
<LI><A HREF="#TheCompleteSourceCode">
The Complete Source Code</A>
</UL>
<LI><A HREF="#UpandCominginJava">
Up and Coming in Java 1.1</A>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
For the past five days you've concentrated on creating applets
that do very simple things: display text, play an animation or
a sound, or interact with the user. When you get past that point,
however, you may want to start creating more complex applets that
behave like real applications embedded in a Web page-applets that
start to look like real GUI applications with buttons, menus,
text fields, and other elements.
<P>
It's this sort of real work in Java applets and applications for
which Java's <I>Abstract Windowing Toolkit</I>, or awt, was designed.
You've actually been using the awt all along, as you might have
guessed from the classes you've been importing. The <TT>Applet</TT>
class and most of the classes you've been using this week are
all integral parts of the awt.
<P>
The awt provides the following:
<UL>
<LI>A full set of user interface (UI) widgets and other components,
including windows, menus, buttons, check boxes, text fields, scrollbars,
and scrolling lists
<LI>Support for UI containers, which can contain other embedded
containers or UI widgets
<LI>An event system for managing system and user events among
parts of the awt
<LI>Mechanisms for laying out components in a way that enables
platform-<BR>
independent UI design
</UL>
<P>
Today you'll learn about how to use all these things in your Java
applets. Tomorrow you'll learn about creating windows, menus,
and dialog boxes, which enable you to pop up separate windows
from the browser window. In addition, you can use the awt in standalone
applications, so everything you've learned so far this week can
still be used. If you find the framework of the Web browser too
limiting, you can take your awt background and start writing full-fledged
Java applications.
<P>
Today, however, you'll continue focusing on applets.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This is by far the most complex lesson so far, and it's a long chapter as well. There's a lot to cover and a lot of code to go through today, so if it starts becoming overwhelming, you might want to take two days (or more) for this one.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="AnawtOverview"><FONT SIZE=5 COLOR=#FF0000>
An awt Overview</FONT></A></H2>
<P>
The basic idea behind the awt is that a graphical Java program
is a set of nested components, starting from the outermost window
all the way down to the smallest UI component. Components can
include things you can actually see on the screen, such as windows,
menu bars, buttons, and text fields, and they can also include
containers, which in turn can contain other components. Figure
13.1 shows how a sample page in a Java browser might include several
different components, all of which are managed through the awt.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-1.gif"><B>Figure 13.1 : </B><I>awt components</I>.</A>
<P>
This nesting of components within containers within other components
creates a hierarchy of components, from the smallest check box
inside an applet to the overall window on the screen. The hierarchy
of components determines the arrangement of items on the screen
and inside other items, the order in which they are painted, and
how events are passed from one component to another.
<P>
These are the major components you can work with in the awt:
<UL>
<LI><I>Containers.</I> Containers are generic awt components that
can contain other components, including other containers. The
most common form of container is the <I>panel</I>, which represents
a container that can be displayed onscreen. Applets are a form
of panel (in fact, the <TT>Applet</TT>
class is a subclass of the <TT>Panel</TT>
class).
<LI><I>Canvases.</I> A canvas is a simple drawing surface. Although
you can draw on panels (as you've been doing all along), canvases
are good for painting images or performing other graphics operations.
<LI><I>UI components.</I> These can include buttons, lists, simple
pop-up menus, check boxes, test fields, and other typical elements
of a user interface.
<LI><I>Window construction components.</I> These include windows,
frames, menu bars, and dialog boxes. They are listed separately
from the other UI components because you'll use these less often-particularly
in applets. In applets, the browser provides the main window and
menu bar, so you don't have to use these. Your applet may create
a new window, however, or you may want to write your own Java
application that uses these components. (You'll learn about these
tomorrow.)
</UL>
<P>
The classes inside the <TT>java.awt</TT>
package are written and organized to mirror the abstract structure
of containers, components, and individual UI components. Figure
13.2 shows some of the class hierarchy that makes up the main
classes in the awt. The root of most of the awt components is
the class <TT>Component</TT>, which
provides basic display and event-handling features. The classes
<TT>Container</TT>, <TT>Canvas</TT>,
<TT>TextComponent</TT>, and many of
the other UI components inherit from <TT>Component</TT>.
Inheriting from the <TT>Container</TT>
class are objects that can contain other awt components-the <TT>Panel</TT>
and <TT>Window</TT> classes, in particular.
Note that the <TT>java.applet.Applet</TT>
class, even though it lives in its own package, inherits from
<TT>Panel</TT>, so your applets are
an integral part of the hierarchy of components in the awt system.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-2.gif"><B>Figure 13.2 : </B><I>A Partial awt class Hierarchy</I>.</A>
<P>
A graphical user interface-based application that you write by
using the awt can be as complex as you like, with dozens of nested
containers and components inside each other. The awt was designed
so that each component can play its part in the overall awt system
without needing to duplicate or keep track of the behavior of
other parts in the system.
<P>
In addition to the components themselves, the awt also includes
a set of layout managers. Layout managers determine how the various
components are arranged when they are displayed onscreen, and
their various sizes relative to each other. Because Java applets
and applications that use the awt can run on different systems
with different displays, different fonts, and different resolutions,
you cannot just stick a particular component at a particular spot
on the window. Layout managers help you create UI layouts that
are dynamically arranged and can be displayed anywhere the applet
or application might be run.
<H2><A NAME="TheBasicUserInterfaceComponents"><FONT SIZE=5 COLOR=#FF0000>
The Basic User Interface Components</FONT></A></H2>
<P>
The simplest form of awt component is the basic UI component.
You can create and add these to your applet without needing to
know anything about creating containers or panels-your applet,
even before you start painting and drawing and handling events,
is already an awt container. Because an applet is a container,
you can put other awt components-such as UI components or other
containers-into it.
<P>
In this section, you'll learn about the basic UI components: labels,
buttons, check boxes, choice menus, and text fields. In each case,
the procedure for creating the component is the same-you first
create the component and then add it to the panel that holds it,
at which point it is displayed on the screen. To add a component
to a panel (such as your applet, for example), use the <TT>add()</TT>
method:
<BLOCKQUOTE>
<PRE>
public void init() {
    Button b = new Button(&quot;OK&quot;);
    add(b);
}
</PRE>
</BLOCKQUOTE>
<P>
Here the <TT>add()</TT> method refers
to the current applet-in other words, it means &quot;add this
element to me.&quot; You can also add elements to other containers,
as you'll learn later.
<P>
Note that where the component appears in the panel depends on
the layout manager that panel is defined to have. In these examples
I've used both flow layouts and grid layouts, depending on which
makes the applet look better. You'll learn more about panels and
layouts in the next section.
<P>
Note also that each of these components has an action associated
with it-that is, something that component does when it's activated.
<I>Actions</I> generally trigger events or other activities in
your applet (they are often called <I>callbacks</I> in other window
toolkits). In this section, you'll focus on creating the components
themselves; you'll learn about adding actions to them later in
today's lesson.
<P>
On to the components!
<H3><A NAME="Labels">
Labels</A></H3>
<P>
The simplest form of UI component is the label, which is, effectively,
a text string that you can use to label other UI components. Labels
are not editable; they just label other components on the screen.
<P>
The advantages that a label has over an ordinary text string (that
you'd draw using <TT>drawString()</TT>
in the <TT>paint()</TT> method) are
<UL>
<LI>You don't have to redraw labels yourself. Labels are an awt
element, and the awt keeps track of drawing them.
<LI>Labels follow the layout of the panel in which they're contained
and can be aligned with other UI components. Panel layout is determined
by the layout manager, which you'll learn about later, in the
section &quot;Panels and Layout.&quot;
</UL>
<P>
A <I>label</I> is an uneditable text string that acts as a description
for other awt components.
<P>
To create a label, use one of the following constructors:
<UL>
<LI><TT>Label()</TT> creates an empty
label, with its text aligned left.
<LI><TT>Label(<I>String</I>)</TT>
creates a label with the given text string, also aligned left.
<LI><TT>Label(<I>String</I>, <I>int</I>)</TT>
creates a label with the given text string and the given alignment.
The available alignment numbers are stored in class variables
in <TT>Label</TT>, making them easier
to remember: <TT>Label.RIGHT</TT>,
<TT>Label.LEFT</TT>, and <TT>Label.CENTER</TT>.
</UL>
<P>
You can change the label's font with the <TT>setFont()</TT>
method, either called on the label itself to change the individual
label, or on the enclosing component to change all the labels.
Here's some simple code to create a few labels in Helvetica Bold
(Figure 13.3 shows how this looks onscreen):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-3.gif"><B>Figure 13.3 : </B><I>Three labels with various alignments</I>.</A>
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This code uses the <TT>setLayout</TT> method to create a new layout manager. Don't worry about that line right now; you'll learn more about layout managers in the next section.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class LabelTest extends java.applet.Applet {

  public void init() {
    setFont(new Font (&quot;Helvetica&quot;, Font.BOLD, 14));
    setLayout(new GridLayout(3,1));
    add(new Label(&quot;aligned left&quot;, Label.LEFT));
    add(new Label(&quot;aligned center&quot;, Label.CENTER));
    add(new Label(&quot;aligned right&quot;, Label.RIGHT));
  }
}
</PRE>
</BLOCKQUOTE>
<P>
When you have a <TT>Label</TT> object,
you can use methods defined in the <TT>Label</TT>
class to get and set the values of the text, as shown in Table
13.1.<BR>
<P>
<CENTER><B>Table 13.1. Label methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=186><B>Method</B></TD><TD WIDTH=404><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>getText()</TT>
</TD><TD WIDTH=404>Returns a string containing this label's text
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>setText(String)</TT>
</TD><TD WIDTH=404>Changes the text of this label</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>getAlignment()</TT>
</TD><TD WIDTH=404>Returns an integer representing the alignment of this label:<BR>
<blockquote>
<TT>0</TT>&nbsp;&nbsp;&nbsp;&nbsp;is <TT>Label.LEFT</TT><BR>
<TT>1</TT>&nbsp;&nbsp;&nbsp;&nbsp;is <TT>Label.CENTER</TT><BR>
<TT>2</TT>&nbsp;&nbsp;&nbsp;&nbsp;is <TT>Label.RIGHT</TT>
</blockquote></TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>setAlignment(int)</TT>
</TD><TD WIDTH=404>Changes the alignment of this label to the given integer-use the class variables listed in the <TT>getAlignment()</TT> method
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Buttons">
Buttons</A></H3>
<P>
The second user interface component to explore is the button.
Buttons are simple UI components that trigger some action in your
interface when they are pressed. For example, a calculator applet
might have buttons for each number and operator, or a dialog box
might have buttons for OK and Cancel.
<P>
A <I>button</I> is a UI component that, when &quot;pressed&quot;
(selected) with the mouse, triggers some action.
<P>
To create a button, use one of the following constructors:
<UL>
<LI><TT>Button()</TT> creates an empty
button with no label.
<LI><TT>Button(String)</TT> creates
a button with the given string as a label.
</UL>
<P>
Once you have a <TT>Button</TT> object,
you can get the value of the button's label by using the <TT>getLabel()</TT>
method and set the label using the <TT>setLabel(String)</TT>
method.
<P>
Figure 13.4 shows some simple buttons, created using the following
code:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-4.gif"><B>Figure 13.4 : </B><I>Four buttons in Netscape</I>.</A>
<BLOCKQUOTE>
<PRE>
public class ButtonTest extends java.applet.Applet {

  public void init() {
    add(new Button(&quot;Rewind&quot;));
    add(new Button(&quot;Play&quot;));
    add(new Button(&quot;Fast Forward&quot;));
    add(new Button(&quot;Stop&quot;));
  }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CheckBoxes">
Check Boxes</A></H3>
<P>
<I>Check boxes</I> are user-interface components that have two
states: on and off (or checked and unchecked, selected and unselected,
true and false, and so on). Unlike buttons, check boxes usually
don't trigger direct actions in a UI, but instead are used to
indicate optional features of some other action.
<P>
Check boxes can be used in two ways:
<UL>
<LI>Nonexclusive: Given a series of check boxes, any of them can
be selected.
<LI>Exclusive: Given a series, only one check box can be selected
at a time.
</UL>
<P>
The latter kind of check boxes are called radio buttons or check
box groups, and are described in the next section.
<P>
<I>Check boxes</I> are UI components that can be selected or deselected
(checked or unchecked) to provide options. Nonexclusive check
boxes can be checked or unchecked independently of other check
boxes.
<P>
Exclusive check boxes, sometimes called <I>radio buttons</I>,
exist in groups; only one in the group can be checked at one time.
<P>
Nonexclusive check boxes can be created by using the <TT>Checkbox</TT>
class. You can create a check box using one of the following constructors:
<UL>
<LI><TT>Checkbox()</TT> creates an
empty check box, unselected.
<LI><TT>Checkbox(<I>String</I>)</TT>
creates a check box with the given string as a label.
<LI><TT>Checkbox(<I>String</I>, <I>null</I>,
<I>boolean</I>)</TT> creates a check box that is either
selected or deselected based on whether the boolean argument is
<TT>true</TT> or <TT>false</TT>,
respectively. (The <TT>null</TT> is
used as a placeholder for a group argument. Only radio buttons
have groups, as you'll learn in the next section.)
</UL>
<P>
Figure 13.5 shows a few simple check boxes (only <TT>Underwear</TT>
is selected) generated using the following code:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-5.gif"><B>Figure 13.5 : </B><I>Five check boxes, one selected</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class CheckboxTest extends java.applet.Applet {

  public void init() {
    setLayout(new FlowLayout(FlowLayout.LEFT));
    add(new Checkbox(&quot;Shoes&quot;));
    add(new Checkbox(&quot;Socks&quot;));
    add(new Checkbox(&quot;Pants&quot;));
    add(new Checkbox(&quot;Underwear&quot;, null, true));
    add(new Checkbox(&quot;Shirt&quot;));
  }

}
</PRE>
</BLOCKQUOTE>
<P>
Table 13.2 lists some of the check box methods.<BR>
<P>
<CENTER><B>Table 13.2. Check box methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=186><B>Method</B></TD><TD WIDTH=404><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>getLabel()</TT>
</TD><TD WIDTH=404>Returns a string containing this check box's label
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>setLabel(String)</TT>
</TD><TD WIDTH=404>Changes the text of the check box's label</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>getState()</TT>
</TD><TD WIDTH=404>Returns <TT>true</TT> or <TT>false</TT>, based on whether the check box is selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=186><TT>setState(boolean)</TT>
</TD><TD WIDTH=404>Changes the check box's state to selected (<TT>true</TT>) or unselected (<TT>false</TT>)
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="RadioButtons">
Radio Buttons</A></H3>
<P>
Radio buttons have the same appearance as check boxes, but only
one in a series can be selected at a time. To create a series
of radio buttons, first create an instance of <TT>CheckboxGroup</TT>:
<BLOCKQUOTE>
<PRE>
CheckboxGroup cbg = new CheckboxGroup();
</PRE>
</BLOCKQUOTE>
<P>
Then create and add the individual check boxes using the constructor
with three arguments (the first is the label, the second is the
group, and the third is whether that check box is selected). Note
that because radio buttons, by definition, have only one in the
group selected at a time, the last <TT>true</TT>
to be added will be the one selected by default:
<BLOCKQUOTE>
<PRE>
add(new Checkbox(&quot;Yes&quot;, cbg, true);
add(new Checkbox(&quot;No&quot;, cbg, false);
</PRE>
</BLOCKQUOTE>
<P>
Here's a simple example (the results of which are shown in Figure
13.6):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-6.gif"><B>Figure 13.6 : </B><I>Six radio buttons (exclusive check boxes),
one selected</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class CheckboxGroupTest extends java.applet.Applet {

  public void init() {
    setLayout(new FlowLayout(FlowLayout.LEFT));
    CheckboxGroup cbg = new CheckboxGroup();

    add(new Checkbox(&quot;Red&quot;, cbg, false));
    add(new Checkbox(&quot;Blue&quot;, cbg, false));
    add(new Checkbox(&quot;Yellow&quot;, cbg, false));
    add(new Checkbox(&quot;Green&quot;, cbg, true));
    add(new Checkbox(&quot;Orange&quot;, cbg, false));
    add(new Checkbox(&quot;Purple&quot;, cbg, false));
  }

}  
</PRE>
</BLOCKQUOTE>
<P>
All the check box methods shown in Table 13.2 in the previous
section can be used with <BR>
the check boxes in the group. In addition, you can use the <TT>getCheckboxGroup()</TT>
and <TT>setCheckboxGroup()</TT> methods
(defined in the <TT>Checkbox()</TT>
class) to access and change the group of any given check box.
<P>
Finally, the <TT>getCurrent()</TT>
and <TT>setCurrent(Checkbox)</TT>
methods, defined in <TT>CheckboxGroup</TT>,
can be used to get or set the currently selected check box.
<H3><A NAME="ChoiceMenus">
Choice Menus</A></H3>
<P>
The choice menu is a more complex UI component than labels, buttons,
or check boxes. Choice menus are pop-up (or pull-down) menus from
which you can select an item. The menu then displays that choice
on the screen. The function of a choice menu is the same across
platforms, but its actual appearance may vary from platform to
platform.
<P>
Note that choice menus can have only one item selected at a time.
If you want to be able to choose multiple items from the menu,
use a scrolling list instead (you'll learn more about scrolling
lists later today, in the section &quot;More UI Components&quot;).
<P>
<I>Choice menus</I> are pop-up menus of items from which you can
choose one item.
<P>
To create a choice menu, create an instance of the <TT>Choice</TT>
class and then use the <TT>addItem()</TT>
method to add individual items to it in the order in which they
should appear. Finally, add the entire choice menu to the panel
in the usual way. Here's a simple program that builds a choice
menu of fruits; Figure 13.7 shows the result (with the menu pulled
down):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-7.gif"><B>Figure 13.7 : </B><I>A choice menu</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class ChoiceTest extends java.applet.Applet {

  public void init() {
    Choice c = new Choice();

    c.addItem(&quot;Apples&quot;);
    c.addItem(&quot;Oranges&quot;);
    c.addItem(&quot;Strawberries&quot;);
    c.addItem(&quot;Blueberries&quot;);
    c.addItem(&quot;Bananas&quot;);

    add(c);
  }
}
</PRE>
</BLOCKQUOTE>
<P>
Even after your choice menu has been added to a panel, you can
continue to add items to that menu with the <TT>addItem()</TT>
method. Table 13.3 shows some other methods that may be useful
in working with choice menus.<BR>
<P>
<CENTER><B>Table 13.3. Choice menu methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=196><B>Method</B></TD><TD WIDTH=394><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>getItem(int)</TT>
</TD><TD WIDTH=394>Returns the string item at the given position (items inside a choice begin at <TT>0</TT>, just like arrays)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>countItems()</TT>
</TD><TD WIDTH=394>Returns the number of items in the menu</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>getSelectedIndex()</TT>
</TD><TD WIDTH=394>Returns the index position of the item that's selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>getSelectedItem()</TT> 
</TD><TD WIDTH=394>Returns the currently selected item as a string
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>select(int)</TT>
</TD><TD WIDTH=394>Selects the item at the given position</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>select(String)</TT>
</TD><TD WIDTH=394>Selects the item with the given string</TD>
</TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TextFields">
Text Fields</A></H3>
<P>
Unlike the UI components up to this point, which only enable you
to select among several options to perform an action, text fields
allow you to enter and edit text. Text fields are generally only
a single line and do not have scrollbars; text areas, which you'll
learn about later today, are better for larger amounts of text.
<P>
Text fields are different from labels in that they can be edited;
labels are good for just displaying text, text fields for getting
text input from the user.
<P>
<I>Text fields</I> provide an area where you can enter and edit
a single line of text.
<P>
To create a text field, use one of the following constructors:
<UL>
<LI><TT>TextField()</TT> creates an
empty <TT>TextField</TT> that is 0
characters wide (it will be resized by the current layout manager).
<LI><TT>TextField(int)</TT> creates
an empty text field. The integer argument indicates the minimum
number of characters to display.
<LI><TT>TextField(String)</TT> creates
a text field initialized with the given string. The field will
be automatically resized by the current layout manager.
<LI><TT>TextField(String, int)</TT>
creates a text field some number of characters wide (the integer
argument) containing the given string. If the string is longer
than the width, you can select and drag portions of the text within
the field, and the box will scroll left or right.
</UL>
<P>
For example, the following line creates a text field 30 characters
wide with the string <TT>&quot;Enter Your
Name&quot;</TT> as its initial contents:
<BLOCKQUOTE>
<PRE>
TextField tf = new TextField(&quot;Enter Your Name&quot;, 30);
add(tf);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Text fields include only the editable field itself. You usually need to include a label with a text field to indicate what belongs in that text field.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You can also create a text field that obscures the characters
typed into it-for example, for password fields. To do this, first
create the text field itself; then use the <TT>setEchoCharacter()</TT>
method to set the character that is echoed on the screen. Here
is an example:
<BLOCKQUOTE>
<PRE>
TextField tf = new TextField(30);
tf.setEchoCharacter('*');
</PRE>
</BLOCKQUOTE>
<P>
Figure 13.8 shows three text boxes (and labels) that were created
using the following code:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-8.gif"><B>Figure 13.8 : </B><I>Three text fields to allow input from the
user</I>.</A>
<BLOCKQUOTE>
<PRE>
add(new Label(&quot;Enter your Name&quot;));
add(new TextField(&quot;your name here&quot;, 45));
add(new Label(&quot;Enter your phone number&quot;));
add(new TextField(12));
add(new Label(&quot;Enter your password&quot;));
TextField t = new TextField(20);
t.setEchoCharacter('*');
add(t);
</PRE>
</BLOCKQUOTE>
<P>
The text in the first field (<TT>your</TT>
<TT>name</TT> <TT>here</TT>)
was initialized in the code; I typed the text in the remaining
two boxes just before taking the snapshot.
<P>
Text fields inherit from the class <TT>TextComponent</TT>
and have a whole suite of methods, both inherited from that class
and defined in their own class, that may be useful to you in your
Java programs. Table 13.4 shows a selection of those methods.
<BR>
<P>
<CENTER><B>Table 13.4. Text field methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=215><B>Method</B></TD><TD WIDTH=375><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>getText()</TT>
</TD><TD WIDTH=375>Returns the text this text field contains (as a string)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>setText(String)</TT>
</TD><TD WIDTH=375>Puts the given text string into the field</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>getColumns()</TT>
</TD><TD WIDTH=375>Returns the width of this text field</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>select(int, int)</TT>
</TD><TD WIDTH=375>Selects the text between the two integer positions (positions start from <TT>0</TT>)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>selectAll()</TT>
</TD><TD WIDTH=375>Selects all the text in the field</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>isEditable()</TT>
</TD><TD WIDTH=375>Returns <TT>true</TT> or <TT>false</TT> based on whether the text is editable
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>setEditable(boolean)</TT>
</TD><TD WIDTH=375><TT>true</TT> (the default) enables text to be edited; <TT>false</TT> freezes the text
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>getEchoChar()</TT>
</TD><TD WIDTH=375>Returns the character used for masking input
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=215><TT>echoCharIsSet()</TT>
</TD><TD WIDTH=375>Returns <TT>true</TT> or <TT>false</TT> based on whether the field has a masking character
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The descriptions of the <TT>getEchoChar()</TT> and <TT>echoCharIsSet()</TT> methods refer to masking user input. User input masking is a technique of limiting user input to a specific type, such as a number. Other types of user input masking include dates 
and phone numbers, where there are a specific number of numeric digits arranged in a constant format. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="PanelsandLayout"><FONT SIZE=5 COLOR=#FF0000>
Panels and Layout</FONT></A></H2>
<P>
awt panels can contain UI components or other panels. The question
now is how those components are actually arranged and displayed
onscreen.
<P>
In other windowing systems, UI components are often arranged using
hard-coded pixel measurements-put a text field at the position
<TT>10,30</TT>, for example-the same
way you used the graphics operations to paint squares and ovals
on the screen. In the  awt, your UI design may be displayed on
many different window systems on many different screens and with
many different kinds of fonts with different font metrics. Therefore,
you need a more flexible method of arranging components on the
screen so that a layout that looks nice on one platform isn't
a jumbled, unusable mess on another.
<P>
For just this purpose, Java has layout managers, insets, and hints
that each component can provide to help dynamically lay out the
screen.
<P>
Note that the nice thing about awt components and user-interface
items is that you don't have to paint them-the awt system manages
all that for you. If you have graphical components or images,
or you want to create animation inside panels, you still have
to do that by hand, but for most of the basic components, all
you have to do is put them on the screen and Java will handle
the rest.
<H3><A NAME="LayoutManagersAnOverview">
Layout Managers: An Overview</A></H3>
<P>
The actual appearance of the awt components on the screen is usually
determined by two things: how those components are added to the
panel that holds them (either the order or through arguments to
<TT>add()</TT>) and the layout manager
that panel is currently using to lay out the screen. The layout
manager determines how portions of the screen will be sectioned
and how components within that panel will be placed.
<P>
The <I>layout manager</I> determines how awt components are dynamically
arranged on the screen.
<P>
Each panel on the screen can have its own layout manager. By nesting
panels within panels, and using the appropriate layout manager
for each one, you can often arrange your UI to group and arrange
components in a way that is functionally useful and that looks
good on a variety of platforms and windowing systems. You'll learn
about nesting panels in a later section.
<P>
The awt provides five basic layout managers: <TT>FlowLayout</TT>,
<TT>GridLayout</TT>, <TT>BorderLayout</TT>,
<TT>CardLayout</TT>, and <TT>GridBagLayout</TT>.
To create a layout manager for a given panel, create an instance
of that layout manager and then use the <TT>setLayout()</TT>
method for that panel. This example sets the layout manager of
the entire enclosing applet panel:
<BLOCKQUOTE>
<PRE>
public void init() {
    setLayout(new FlowLayout());
}
</PRE>
</BLOCKQUOTE>
<P>
Setting the default layout manager, like creating user-interface
components, is best done during the applet's initialization, which
is why it's included here.
<P>
After the layout manager is set, you can start adding components
to the panel. The order in which components are added or the arguments
you use to add those components is often significant, depending
on which layout manager is currently active. Read on for information
about the specific layout managers and how they present components
within the panel to which they apply.
<P>
The following sections describe the five basic Java awt layout
managers.
<H3><A NAME="TheTTFONTSIZEFACECourierFlowLayoutFONTTTFONTSIZEClassFONT">
The <TT>FlowLayout</TT>
Class</FONT></A></H3>
<P>
The <TT>FlowLayout</TT> class is the
most basic of layouts. Using flow layout, components are added
to the panel one at a time, row by row. If a component doesn't
fit onto a row, it's wrapped onto the next row. The flow layout
also has an alignment, which determines the alignment of each
row. By default, each row is centered.
<P>
<I>Flow layout</I> arranges components from left to right in rows.
The rows are aligned left, right, or centered.
<P>
To create a basic flow layout with a centered alignment, use the
following line of code in your panel's initialization (because
this is the default pane layout, you don't need to include this
line if that is your intent):
<BLOCKQUOTE>
<PRE>
setLayout(new FlowLayout());
</PRE>
</BLOCKQUOTE>
<P>
With the layout set, the order in which you add elements to the
layout determines their position. The following code creates a
simple row of six buttons in a centered flow layout (Figure 13.9
shows the result):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-9.gif"><B>Figure 13.9 : </B><I>Six buttons, arranged using a flow layout
manager</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class FlowLayoutTest extends java.applet.Applet {

  public void init() {
    setLayout(new FlowLayout());
    add(new Button(&quot;One&quot;));
    add(new Button(&quot;Two&quot;));
    add(new Button(&quot;Three&quot;));
    add(new Button(&quot;Four&quot;));
    add(new Button(&quot;Five&quot;));
    add(new Button(&quot;Six&quot;));
  }
}
</PRE>
</BLOCKQUOTE>
<P>
To create a flow layout with an alignment other than centered,
add the <TT>FlowLayout.RIGHT</TT>
or <TT>FlowLayout.LEFT</TT> class
variable as an argument:
<BLOCKQUOTE>
<PRE>
setLayout(new FlowLayout(FlowLayout.LEFT));
</PRE>
</BLOCKQUOTE>
<P>
You can also set horizontal and vertical gap values by using flow
layouts. The <I>gap</I> is the number of pixels between components
in a panel; by default, the horizontal and vertical gap values
are three pixels, which can be very close indeed. Horizontal gap
spreads out components to the left and to the right; vertical
gap spreads them to the top and bottom of each component. Add
integer arguments to the flow layout constructor to increase the
gap. Figure 13.10 shows the result of adding a gap of 30 points
in the horizontal and 10 in the vertical directions, like this:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-10.gif"><B>Figure 13.10: </B><I>Flow layout with a gap of 10 points</I>.</A>
<BLOCKQUOTE>
<PRE>
setLayout(new FlowLayout(FlowLayout.LEFT, 30, 10));
</PRE>
</BLOCKQUOTE>
<H3><A NAME="GridLayouts">
Grid Layouts</A></H3>
<P>
<I>Grid layouts</I> offer more control over the placement of components
inside a panel. Using a grid layout, you portion off the display
area of the panel into rows and columns. Each component you then
add to the panel is placed in a <I>cell</I> of the grid, starting
from the top row and progressing through each row from left to
right (here's where the order of calls to the <TT>add()</TT>
method are very relevant to how the screen is laid out).
<P>
To create a grid layout, indicate the number of rows and columns
you want the grid to have when you create a new instance of the
<TT>GridLayout</TT> class. Here's
a grid layout with three rows and two columns (Figure 13.11 shows
the result):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-11.gif"><B>Figure 13.11: </B><I>Six buttons displayed using a grid layout
of three rows and two columns</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class GridLayoutTest extends java.applet.Applet {

  public void init() {
    setLayout(new GridLayout(3,2);
    add(new Button(&quot;One&quot;));
    add(new Button(&quot;Two&quot;));
    add(new Button(&quot;Three&quot;));
    add(new Button(&quot;Four&quot;));
    add(new Button(&quot;Five&quot;));
    add(new Button(&quot;Six&quot;));
  }
}
</PRE>
</BLOCKQUOTE>
<P>
Grid layouts can also have a horizontal and vertical gap between
components. To create gaps, add those pixel values:
<BLOCKQUOTE>
<PRE>
setLayout(new GridLayout(3, 3, 10, 30));
</PRE>
</BLOCKQUOTE>
<P>
Figure 13.12 shows a grid layout with a 10-pixel horizontal gap
and a 30-pixel vertical gap.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-12.gif"><B>Figure 13.12: </B><I>A grid layout with horizontal and vertical gaps</I>.</A>
<H3><A NAME="BorderLayouts">
Border Layouts</A></H3>
<P>
<I>Border layouts</I> behave differently from flow and grid layouts.
When you add a component to a panel that uses a border layout,
you indicate its placement as a geographic direction: north, south,
east, west, or center. (See Figure 13.13.) The components around
all the edges are laid out with as much size as they need; the
component in the center, if any, gets any space left over.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-13.gif"><B>Figure 13.13: </B><I>Where components go in a border layout</I>.</A>
<P>
To use a border layout, you create it as you do the other layouts;
then you add the individual components with a special <TT>add()</TT>
method that has two arguments. The first argument is a string
indicating the position of the component within the layout, and
the second is the component to add:
<BLOCKQUOTE>
<PRE>
add(&quot;North&quot;, new TextField(&quot;Title&quot;, 50));
</PRE>
</BLOCKQUOTE>
<P>
You can also use this form of <TT>add()</TT>
for the other layout managers; the string argument will just be
ignored if it's not needed.
<P>
Here's the code to generate the border layout shown in Figure
13.13:
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class BorderLayoutTest extends java.applet.Applet {

  public void init() {
    setLayout(new BorderLayout());
    add(&quot;North&quot;, new Button(&quot;One&quot;));
    add(&quot;East&quot;, new Button(&quot;Two&quot;));
    add(&quot;South&quot;, new Button(&quot;Three&quot;));
    add(&quot;West&quot;, new Button(&quot;Four&quot;));
    add(&quot;Center&quot;, new Button(&quot;Five&quot;));
    add(new Button(&quot;Six&quot;));
  }
}
</PRE>
</BLOCKQUOTE>
<P>
Border layouts can also have horizontal and vertical gaps. Note
that the north and south components extend all the way to the
edge of the panel, so the gap will result in less vertical space
for the east, right, and center components. To add gaps to a border
layout, include those pixel values in the constructor as with
the other layout managers:
<BLOCKQUOTE>
<PRE>
setLayout(new BorderLayout(10, 10));
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CardLayouts">
Card Layouts</A></H3>
<P>
<I>Card layouts</I> behave much differently from the other layouts.
When you add components to one of the other layout managers, all
those components appear on the screen at once. Card layouts are
used to produce slide shows of components, one at a time. If you've
ever used the HyperCard program on the Macintosh, or seen dialog
boxes on windows with several different tabbed pages, you've worked
with the same basic idea.
<P>
When you create a card layout, the components you add to the outer
panel will be other container components-usually other panels.
You can then use different layouts for those individual cards
so that each screen has its own look.
<P>
<I>Cards, </I>in a card layout, are different panels added one
at a time and displayed one at a time. If you think of a card
file, you'll get the idea; only one card can be displayed at once,
but you can switch between cards.
<P>
When you add each card to the panel, you can give it a name. Then,
to flip between the container cards, you can use methods defined
in the <TT>CardLayout</TT> class to
move to a named card, move forward or back, or move to the first
card or to the last card. Typically you'll have a set of buttons
that call these methods to make navigating the card layout easier.
<P>
Here's a simple snippet of code that creates a card layout containing
three cards:
<BLOCKQUOTE>
<PRE>
setLayout(new CardLayout());
//add the cards
Panel one = new Panel()
add(&quot;first&quot;, one);
Panel two = new Panel()
add(&quot;second&quot;, two);
Panel three = new Panel()
add(&quot;third&quot;, three);

// move around
show(this, &quot;second&quot;); //go to the card named &quot;second&quot;
show(this, &quot;third&quot;);   //go to the card named &quot;third&quot;
previous(this);       //go back to the second card
first(this);          // got to the first card
</PRE>
</BLOCKQUOTE>
<H3><A NAME="GridBagLayouts">
Grid Bag Layouts</A></H3>
<P>
I've saved grid bag layouts for last because although they are
the most powerful way of managing awt layout, they are also extremely
complicated.
<P>
Using one of the other four layout managers, it can sometimes
be difficult to get the exact layout you want without doing a
lot of nesting of panels within panels. Grid bags provide a more
general-purpose solution. Like grid layouts, <I>grid bag layouts</I>
allow you to arrange your components in a grid-like layout. However,
grid bag layouts also allow you to control the span of individual
cells in the grid, the proportions between the rows and columns,
and the arrangement of components inside cells in the grid.
<P>
To create a grid bag layout, you actually use two classes: <TT>GridBagLayout</TT>,
which provides the overall layout manager, and <TT>GridBagConstraints</TT>,
which defines the properties of each component in the grid-its
placement, dimensions, alignment, and so on. It's the relationship
between the grid bag, the constraints, and each component that
defines the overall layout.
<P>
In its most general form, creating a grid bag layout involves
the following steps:
<UL>
<LI>Creating a <TT>GridBagLayout</TT>
object and defining it as the current layout manager, as you would
any other layout manager
<LI>Creating a new instance of <TT>GridBagConstraints</TT>
<LI>Setting up the constraints for a component
<LI>Telling the layout manager about the component and its constraints
<LI>Adding the component to the panel
</UL>
<P>
Here's some simple code that sets up the layout and then creates
constraints for a single button (don't worry about the various
values for the constraints; I'll cover these later on in this
section):
<BLOCKQUOTE>
<PRE>
// set up layout
GridBagLayout gridbag = new GridBagLayout();
GridBagConstraints constraints = new GridBagConstraints();
setLayout(gridbag);

// define constraints for the button
Button b = new Button(&quot;Save&quot;);
constraints.gridx = 0;
constraints.gridy = 0;
constraints.gridwidth = 1;
constraints.gridheight = 1;
constraints.weightx = 30;
constraints.weighty = 30;
constraints.fill = GridBagConstraints.NONE;
constraints.anchor = GridBagConstraints.CENTER;

// attach constraints to layout, add button
gridbag.setConstraints(b, constraints);
add(b);
</PRE>
</BLOCKQUOTE>
<P>
By far, the most tedious part of this process is setting up the
constraints for each component (as you can see from this example,
you have to set all those constraints for every component you
want to add to the panel). In addition to the tedium, constraints
aren't all that easy to understand; they have many different values,
many of which are interrelated, which means that changing one
may have strange effects on others.
<P>
Given the numerous constraints, it helps to have a plan and to
deal with each kind of constraint one at a time. There are four
steps I like to follow in this process. Let's walk through each
of them.
<H4>Step One: Design the Grid</H4>
<P>
The first place to start in the grid bag layout is on paper. Sketching
out your UI design beforehand-before you write even a single line
of code-will help enormously in the long run with trying to figure
out where everything goes. So put your editor aside for a second,
pick up a piece of paper and a pencil, and let's build the grid.
<P>
Figure 13.14 shows the panel layout we'll be building in this
example. Figure 13.15 shows the same layout with a grid imposed
on top of it. Your layout will have a grid similar to this one,
with rows and columns forming individual cells.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-14.gif"><B>Figure 13.14: </B><I>A grid bag layout</I>.</A>
<P>
<A HREF="http://docs.rinet.ru/J21/f13-15.gif"><B>Figure 13.15: </B><I>The grid bag layout from Figure 13.14,
with grid imposed</I>.</A>
<P>
Keep in mind as you draw your grid that each component must have
its own cell. You cannot put more than one component into the
same cell. The reverse is not true, however; one component can
span multiple cells in the x or y directions (as in the OK button
in the bottom row, which spans two columns). Note in Figure 13.15
that the labels and text fields have their own grids and that
the button spans two column cells.
<P>
While you're still working on paper, something that will help
you later is to label the cells with their x and y coordinates.
These aren't pixel coordinates; rather, they're cell coordinates.
The top-left cell is <TT>0,0</TT>.
The next cell to the right of that in the top row is <TT>1,0</TT>.
The cell to the right of that is <TT>2,0</TT>.
Moving to the next row, the leftmost cell is <TT>1,0</TT>,
the next cell in the row is <TT>1,1</TT>,
and so on. Label your cells on the paper with these numbers; you'll
need them later when we do the code for this example. Figure 13.16
shows the numbers for each of the cells in this example.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-16.gif"><B>Figure 13.16: </B><I>The grid bag layout from Figure 13.14,
with cell coordinates</I>.</A>
<H4>Step Two: Create the Grid in Java</H4>
<P>
Let's go back to Java and start implementing the layout you've
just drawn on paper. Initially we're going to focus exclusively
on the layout-getting the grid and the proportions right. For
that, it helps to not work with actual UI elements. I like to
use buttons as placeholders for the actual elements in the layout
until I can get everything set up right, and then change the buttons
to the right elements.
<P>
To cut down on the amount of typing we have to do to set up all
those constraints, I'm going to start by defining a helper method
that takes several values and sets the constraints for those values.
<TT>buildConstraints()</TT> takes
seven arguments: a <TT>GridBagConstraints</TT>
object and six integers representing the <TT>GridBagConstraints</TT>
instance variables <TT>gridx</TT>,
<TT>gridy</TT>, <TT>gridwidth</TT>,
<TT>gridheight</TT>, <TT>weightx</TT>,
and <TT>weighty</TT>. You'll learn
what these actually do soon; for now, here's the code to the helper
method that we'll use further on in this example:
<BLOCKQUOTE>
<PRE>
void buildConstraints(GridBagConstraints gbc, int gx, int gy, 
  int gw, int gh, int wx, int wy) {
    gbc.gridx = gx;
    gbc.gridy = gy;
    gbc.gridwidth = gw;
    gbc.gridheight = gh;
    gbc.weightx = wx;
    gbc.weighty = wy;
  }
</PRE>
</BLOCKQUOTE>
<P>
Now let's move on to the <TT>init()</TT>
method, where all the layout actually occurs. Here's the basic
method definition, where we'll define the <TT>GridBagLayout</TT>
to be the initial layout manager and create a <TT>constraints</TT>
object (an instance of <TT>GridBagConstraints</TT>):
<BLOCKQUOTE>
<PRE>
public void init() {
    GridBagLayout gridbag = new GridBagLayout();
    GridBagConstraints constraints = new GridBagConstraints(); 
    setLayout(gridbag);

    constraints.fill = GridBagConstraints.BOTH;
}
</PRE>
</BLOCKQUOTE>
<P>
One more small note of explanation: That last line, which sets
the value of <TT>constraints.fill</TT>,
will be removed (and explained) later. It's there so that the
components will fill the entire cell in which they're contained,
which makes it easier to see what's going on. Add it for now and
you'll get a clearer idea of what it's for later.
<P>
Now we'll add the button placeholders to the layout (remember,
we're focusing on basic grid organization at the moment, so we'll
use buttons as placeholders for the actual UI elements you'll
add later). Let's start with a single button so you can get a
feel for setting its constraints. This code will go into the <TT>init()</TT>
method just after the <TT>setLayout</TT>
line:
<BLOCKQUOTE>
<PRE>
// Name label
buildConstraints(constraints, 0, 0, 1, 1, 100, 100);
Button label1 = new Button(&quot;Name:&quot;);
gridbag.setConstraints(label1, constraints);
add(label1);
</PRE>
</BLOCKQUOTE>
<P>
These four lines set up the constraints for an object, create
a new button, attach those constraints to that button, and then
add it to the panel. Note that constraints for a component are
stored in the <TT>GridBagConstraints</TT>
object, so the component doesn't even have to exist to set up
its constraints.
<P>
Now let's get down to details: Just what are the values for the
constraints that we've plugged into the helper method <TT>buildConstraints</TT>?
<P>
The first two integer arguments are the <TT>gridx</TT>
and <TT>gridy</TT> values of the constraints.
These are the cell coordinates of the cell that contains this
component. Remember how you wrote these down on the paper in step
one? With the cells nearly numbered on paper, all you have to
do is plug in the right values. Note that if you have a component
that spans multiple cells, the cell coordinates are those of the
cell in the top-left corner.
<P>
Here this button is in the top-left corner, so its <TT>gridx</TT>
and <TT>gridy</TT> (the first two
arguments to <TT>buildConstraints()</TT>)
are <TT>0</TT> and <TT>0</TT>,
respectively.
<P>
The second two integer arguments are the <TT>gridwidth</TT>
and <TT>gridheight</TT>. These are
not the pixel widths and heights of the cells; rather, they are
the number of cells this component spans: <TT>gridwidth</TT>
for the columns and <TT>gridheight</TT>
for the rows. Here this component spans only one cell, so the
values for both are <TT>1</TT>.
<P>
The last two integer arguments are for <TT>weightx</TT>
and <TT>weighty</TT>. These are used
to set up the proportions of the rows and columns-that is, how
wide or deep they will be. Weights can become very confusing,
so for now just set both values to <TT>100</TT>.
You'll deal with weights in step three.
<P>
After the constraints have been built, you can attach them to
an object using the <TT>setConstraints()</TT>
method. <TT>setConstraints90</TT>,
which is a method defined in <TT>GridBagLayout</TT>,
takes two arguments: the component (here a button) and the constraints
for that button. Finally, you can add the button to the panel.
<P>
After you've set and assigned the constraints to one component,
you can reuse that <TT>GridBagConstraints</TT>
object to set up the constraints for the next object. This effectively
means duplicating those four lines for each component in the grid,
with different values for the <TT>buildConstraints()</TT>
method. To save space, I'm just going to show you the <TT>buildConstraints()</TT>
methods for the last four cells.
<P>
The second cell we'll add is the one that will hold the text box
for the name. The cell coordinates for this one are <TT>1,0</TT>
(second column, first row); it too spans only one cell, and the
weights (for now) are also both <TT>100</TT>:
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 1, 0, 1, 1, 100, 100);
</PRE>
</BLOCKQUOTE>
<P>
The next two components, which will be a label and a text field,
are nearly exactly the same as the previous two; the only difference
is in their cell coordinates. The password label is at <TT>0,1</TT>
(first column, second row), and the password text field is at
<TT>1,1</TT> (second column, second
row):
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 1, 1, 1, 100, 100);
buildConstraints(constraints, 1, 1, 1, 1, 100, 100);
</PRE>
</BLOCKQUOTE>
<P>
And, finally, there is the OK button, which is a component that
spans two cells in the bottom row of the panel. Here the cell
coordinates are the left and topmost cell where the span starts
(<TT>0,2</TT>). Here, unlike the previous
components, we'll set <TT>gridwidth</TT>
and <TT>gridheight</TT> to be something
other than <TT>1</TT> because this
cell spans multiple columns. The <TT>gridweight</TT>
is <TT>2</TT> (it spans two cells),
and the <TT>gridheight</TT> is <TT>1</TT>
(it spans only one row):
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 2, 2, 1, 100, 100);
</PRE>
</BLOCKQUOTE>
<P>
Got it? Those are the placement constraints for all the components
that you'll add to the grid layout. You will also need to assign
each component's constraints to the layout manager and then add
each component to the panel. Figure 13.17 shows the result so
far. Note that you're not concerned about exact proportions here,
or about making sure everything lines up. What you should keep
track of at this point is making sure the grid is working, that
there are the right number of rows and columns, that the spans
are correct, and that nothing strange is going on (cells in the
wrong place, cells overlapping, that kind of thing).
<P>
<A HREF="http://docs.rinet.ru/J21/f13-17.gif"><B>Figure 13.17: </B><I>Grid bag layout, first pass</I>.</A>
<H4>Step Three: Determine the Proportions</H4>
<P>
The next step is to determine the proportions of the rows and
columns in relation to other rows and columns. For example, in
this case you'll want the labels (name and password) to take up
less space than the text boxes. And you might want the OK button
at the bottom to be only half the height of the two text boxes
above it. You arrange the proportions of the cells within your
layout using the <TT>weightx</TT>
and <TT>weighty</TT> constraints.
<P>
The easiest way to think of <TT>weightx</TT>
and <TT>weighty</TT> is that their
values are either percentages of the total width and height of
the panel, or <TT>0</TT> if the weight
or height has been set by some other cell. The values of <TT>weightx</TT>
and <TT>weighty</TT> for all your
components, therefore, should sum to <TT>100</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Technical Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Actually, the <TT>weightx</TT> and <TT>weighty</TT> values are not percentages; they're simply proportions-they can have any value whatsoever. When the proportions are calculated, all the values in a direction are summed so that each individual value is in 
proportion to that total (in other words, divided into the total to actually get a percentage). Because this is incredibly non-intuitive, I find it far easier to look at the weights as percentages and to make sure they all sum up to 100 to make sure it's 
all coming out right.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
So which cells get values and which cells get <TT>0</TT>?
Cells that span multiple rows or columns should always be <TT>0</TT>
in the direction they span. Beyond that, it's simply a question
of picking a cell to have a value, and then all the other cells
in that row or columns should be <TT>0</TT>.
<P>
Let's look at the five calls to <TT>buildConstraints()</TT>
we made in the last step:
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 0, 1, 1, 100, 100); //name
buildConstraints(constraints, 1, 0, 1, 1, 100, 100); //name text
buildConstraints(constraints, 0, 1, 1, 1, 100, 100); //password
buildConstraints(constraints, 1, 1, 1, 1, 100, 100); //password text
buildConstraints(constraints, 0, 2, 2, 1, 100, 100); //OK button
</PRE>
</BLOCKQUOTE>
<P>
We'll be changing those last two arguments in each call to <TT>buildConstraints</TT>
to be either a value or <TT>0</TT>.
Let's start with the x direction (the proportions of the columns),
which is the second-to-last argument in that list.
<P>
If you look back to Figure 13.15 (the picture of the panel with
the grid imposed), you'll note that the second column is much
larger than the first. If you were going to pick theoretical percentages
for those columns, you might say that the first is 10 percent
and the second is 90 percent (I'm making a guess here; that's
all you need to do as well). With those two guesses, let's assign
them to cells. We don't want to assign any values to the cell
with the OK button because that cell spans both columns, and percentages
there wouldn't work. So let's add them to the first two cells,
the name label and the name text field:
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 0, 1, 1, 10, 100); //name
buildConstraints(constraints, 1, 0, 1, 1, 90, 100); //name text
</PRE>
</BLOCKQUOTE>
<P>
And what about the values of the remaining two cells, the password
label and text field? Because the proportions of the columns have
already been set up by the name label and field, we don't have
to reset them here. We'll give both of these cells and the one
for the OK box <TT>0</TT> values:
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 1, 1, 1, 0, 100); //password
buildConstraints(constraints, 1, 1, 1, 1, 0, 100); //password text
buildConstraints(constraints, 0, 2, 2, 1, 0, 100); //OK button
</PRE>
</BLOCKQUOTE>
<P>
Note here that a <TT>0</TT> value
does <I>not</I> mean that the cell has 0 width. These are proportions,
not pixel values. A <TT>0</TT> simply
means that the proportion has been set somewhere else; all <TT>0</TT>
says is &quot;stretch it to fit.&quot;
<P>
Now that the totals of all the <TT>weightx</TT>
constraints are 100, let's move onto the <TT>weighty</TT>s.
Here there are three rows; glancing over the grid we drew, it
looks like the button has about 20 percent and the text fields
have the rest (40 percent each). As with the x values, we only
have to set the value of one cell per row (the two labels and
the button), with all the other cells having a <TT>weightx</TT>
of 0.
<P>
Here are the final five calls to <TT>buildConstraints()</TT>
with the weights in place:
<BLOCKQUOTE>
<PRE>
buildConstraints(constraints, 0, 0, 1, 1, 10, 40); //name
buildConstraints(constraints, 1, 0, 1, 1, 90, 0); //name text
buildConstraints(constraints, 0, 1, 1, 1, 0, 40); //password
buildConstraints(constraints, 1, 1, 1, 1, 0, 0); //password text
buildConstraints(constraints, 0, 2, 2, 1, 0, 20); //OK button
</PRE>
</BLOCKQUOTE>
<P>
Figure 13.18 shows the result with the correct proportions.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-18.gif"><B>Figure 13.18: </B><I>Grid bag layout second pass</I>.</A>
<P>
At this step, the goal here is to try to come up with some basic
proportions for how the rows and cells will be spaced on the screen.
You can make some basic estimates based on how big you expect
the various components to be, but chances are you're going to
use a lot of trial and error in this part of the process.
<H4>Step Four: Add and Arrange the Components</H4>
<P>
With the layout and the proportions in place, now you can replace
the button placeholders with actual labels and text fields. And
because you set everything up already, it should all work perfectly,
right? Well, almost. Figure 13.19 shows what you get if you use
the same constraints as before and replace the buttons with actual
components.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-19.gif"><B>Figure 13.19: </B><I>Grid bag layout, almost there</I>.</A>
<P>
It's close, but it's weird. The text boxes are too tall, and the
OK button stretches the width of the cell.
<P>
What's missing are the constraints that arrange the components
inside the cell. There are two of them: <TT>fill</TT>
and <TT>anchor</TT>.
<P>
The <TT>fill</TT> constraint determines,
for components that can stretch in either direction (like text
boxes and buttons), in which direction to stretch. <TT>fill</TT>
can have one of four values, defined as class variables in the
<TT>GridBagConstraints</TT> class:
<UL>
<LI><TT>GridBagConstraints.BOTH</TT>,
which stretches the component to fill the cell in both directions.
<LI><TT>GridBagConstraints.NONE</TT>,
which causes the component to be displayed in its smallest size.
<LI><TT>GridBagConstraints.HORIZONTAL</TT>,
which stretches the component in the horizontal direction.
<LI><TT>GridBagConstraints.VERTICAL</TT>,
which stretches the component in the vertical direction.
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Keep in mind that this is dynamic layout. You're not going to set up the actual pixel dimensions of any components; rather, you're telling these elements in which direction they can grow given a panel that can be of any size.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
By default, the <TT>fill</TT> constraint
for all components is <TT>NONE</TT>.
So why are those text fields and labels filling the cells? If
you remember way back to the start of the code for this example,
I added this line to the <TT>init()</TT>
method:
<BLOCKQUOTE>
<PRE>
constraints.fill = GridBagConstraints.BOTH;
</PRE>
</BLOCKQUOTE>
<P>
Now you know what it does. For the final version of this applet,
you'll want to remove that line and add <TT>fill</TT>
values for each independent component.
<P>
The second constraint that affects how a component appears in
the cell is <TT>anchor</TT>. This
constraint applies only to components that aren't filling the
whole cell, and it tells the awt where inside the cell to place
the component. The possible values for the <TT>anchor</TT>
constraint are <TT>GridBagConstraints.CENTER</TT>,
which aligns the component both vertically and horizontally inside
the cell, or one of eight direction values: <TT>GridBagConstraints.NORTH</TT>,
<TT>GridBagConstraints.NORTHEAST</TT>,
<TT>GridBagConstraints.EAST</TT>,
<TT>GridBagConstraints.SOUTHEAST</TT>,
<TT>GridBagConstraints.SOUTH</TT>,
<TT>GridBagConstraints.SOUTHWEST</TT>,
<TT>GridBagConstraints.WEST</TT>,
or <TT>GridBagConstraints.NORTHWEST</TT>.
The default value of <TT>anchor</TT>
is <TT>GridBagConstraints.CENTER</TT>.
<P>
You set these constraints in the same way you did all the other
ones: by changing instance variables in the <TT>GridBagConstraints</TT>
object. Here you can change the definition of <TT>buildConstraints()</TT>
to take two more arguments (they're <TT>int</TT>s),
or you could just set them in the body of the <TT>init()</TT>
method. I prefer the latter way.
<P>
Be careful with defaults. Keep in mind that because you're reusing
the same <TT>GridBagConstraints</TT>
object for each component, there may be some values left over
after you're done with one component. On the other hand, if a
<TT>fill</TT> or <TT>anchor</TT>
from one object is the same as the one before it, you don't have
to reset that object.
<P>
For this example, I'm going to make three changes to the <TT>fill</TT>s
and <TT>anchor</TT>s of the components:
<UL>
<LI>The labels will have no fill and will be aligned east (so
they hug the right side of the cell)
<LI>The text fields will be filled horizontally (so they start
one line high, but stretch to the width of the cell)
<LI>The button will have no fill and will be center aligned
</UL>
<P>
I'm not going to show you all the code for this here; the full
code for the example is at the end of this section. You can see
the changes I've made there.
<H4>Step Five: Futz with It</H4>
<P>
I added this step to the list because in my own experimentation
with grid bag layouts, I found that even by following all the
steps, usually the resulting layout wasn't <I>quite</I> right,
and I needed to do a considerable amount of tinkering and playing
with various values of the constraints in order to get it to come
out right (that's what <I>futzing</I> means) There's nothing wrong
with that; the goal of the previous three steps was to get things
fairly close to their final positions, not to come out with a
perfect layout each and every time.
<H4>The Code</H4>
<P>
Listing 13.1 shows the complete code for the panel layout we've
been building up in this section. If you had trouble following
the discussion up to this point, you might find it useful to go
through this code line by line to make sure you understand the
various bits.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. The panel with the final grid bag layout.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.awt.*;
 2:
 3:public class GridBagTestFinal extends java.applet.Applet {
 4:
 5:  void buildConstraints(GridBagConstraints gbc, int gx, int gy, 
 6:      int gw, int gh,
 7:      int wx, int wy) {
 8:      gbc.gridx = gx;
 9:      gbc.gridy = gy;
10:      gbc.gridwidth = gw;
11:      gbc.gridheight = gh;
12:      gbc.weightx = wx;
13:      gbc.weighty = wy;
14:  }
15:
16:  public void init() {
17:      GridBagLayout gridbag = new GridBagLayout();
18:      GridBagConstraints constraints = new GridBagConstraints();
19:      setLayout(gridbag);
20:      
21:      // Name label
22:      buildConstraints(constraints, 0, 0, 1, 1, 10, 40);
23:      constraints.fill = GridBagConstraints.NONE;
24:      constraints.anchor = GridBagConstraints.EAST;
25:      Label label1 = new Label(&quot;Name:&quot;, Label.LEFT);
26:      gridbag.setConstraints(label1, constraints);
27:      add(label1);
28:
29:      // Name text field
30:      buildConstraints(constraints, 1, 0, 1, 1, 90, 0);
31:      constraints.fill = GridBagConstraints.HORIZONTAL;
32:      TextField tfname = new TextField();
33:      gridbag.setConstraints(tfname, constraints);
34:      add(tfname);
35:
36:      // password label
37:      buildConstraints(constraints, 0, 1, 1, 1, 0, 40);
38:      constraints.fill = GridBagConstraints.NONE;
39:      constraints.anchor = GridBagConstraints.EAST;
40:      Label label2 = new Label(&quot;Password:&quot;, Label.LEFT);
41:      gridbag.setConstraints(label2, constraints);
42:      add(label2);
43:
44:      // password text field
45:      buildConstraints(constraints, 1, 1, 1, 1, 0, 0);
46:      constraints.fill = GridBagConstraints.HORIZONTAL;
47:      TextField tfpass = new TextField();
48:      tfpass.setEchoCharacter('*');
49:      gridbag.setConstraints(tfpass, constraints);
50:      add(tfpass);
51:
52:      // OK Button
53:      buildConstraints(constraints, 0, 2, 2, 1, 0, 20);
54:      constraints.fill = GridBagConstraints.NONE;
55:      constraints.anchor = GridBagConstraints.CENTER;
56:      Button okb = new Button(&quot;OK&quot;);
57:      gridbag.setConstraints(okb, constraints);
58:      add(okb);
59:  }
60:}
</PRE>
</BLOCKQUOTE>
<HR>
<H4><TT>ipadx</TT> and <TT>ipady</TT>
</H4>
<P>
Before finishing up with grid bag layouts (isn't it over <I>yet</I>?),
there are a two more constraints that deserve mentioning: <TT>ipadx</TT>
and <TT>ipady</TT>. These two constraints
control the <I>padding</I>-that is, the extra space around an
individual component. By default, no components have extra space
around them (which is easiest to see in components that fill their
cells).
<P>
<TT>ipadx</TT> adds space to either
side of the component, and <TT>ipady</TT>
adds it above and below.
<H3><A NAME="Insets">
Insets</A></H3>
<P>
Horizontal and vertical gap, created when you create a new layout
manager (using <TT>ipadx</TT> and
<TT>ipady</TT> in grid bag layouts),
are used to determine the amount of space between components in
a panel. <I>Insets</I>, however, are used to determine the amount
of space around the panel itself. The <TT>Insets</TT>
class includes values for the top, bottom, left, and right insets,
which are then used when the panel itself is drawn.
<P>
<I>Insets</I> determine the amount of space between the edges
of a panel and that panel's components. 
<P>
To include an inset, override the <TT>insets()</TT>
method in your class (your <TT>Applet</TT>
class or other class that serves as a panel). Inside the <TT>insets()</TT>
method, create a new <TT>Insets</TT>
object, where the constructor to the <TT>Insets</TT>
class takes four integer values representing the insets on the
top, left, bottom, and right of the panel. The <TT>insets()</TT>
method should then return that <TT>Insets</TT>
object. Here's some code to add insets for a grid layout, <TT>10</TT>
to the top and bottom, and <TT>30</TT>
to the left and right. (Figure 13.20 shows the inset):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-20.gif"><B>Figure 13.20: </B><I>A panel with insets of 10 pixels on the
top and bottom and 30 pixels to the left and right</I>.</A>
<BLOCKQUOTE>
<PRE>
public Insets insets() {
   return new Insets(10, 30, 10, 30);
}
</PRE>
</BLOCKQUOTE>
<P>
The arguments to the <TT>Insets</TT>
constructor provide pixel insets for the top, bottom, left, and
right edges of the panel, respectively. This particular example
provides an inset of 10 pixels on all four sides of the panel.
<H2><A NAME="HandlingUIActionsandEvents"><FONT SIZE=5 COLOR=#FF0000>
Handling UI Actions and Events</FONT></A></H2>
<P>
If you stopped reading today's lesson right now, you could go
out and create an applet that had lots of little UI components,
nicely laid out on the screen with the proper layout manager,
gap, and insets. If you did stop right here, however, your applet
would be really dull, because none of your UI components would
actually do anything when they were pressed, typed into, or selected.
<P>
For your UI components to do something when they are activated,
you need to hook up the UI's action with an operation. Actions
are a form of event, and testing for an action by a UI component
involves event management. Everything you learned yesterday about
events will come in handy here.
<P>
<I>UI actions</I> are events that occur when a UI component is
activated-pressed, selected, typed into, and so on.
<P>
To intercept an action event generated by any UI component, you
define an <TT>action()</TT> method
in your applet or class:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object arg) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>action()</TT> method should
look similar to the basic mouse and keyboard event methods. Like
those methods, it gets passed the event object that represents
this event. It also gets an extra object (in this code, the parameter
<TT>arg</TT>), which can be of any
class type.
<P>
What kind of object that second argument to the action method
is depends on the UI component that's generating the action. The
basic definition is that it's any arbitrary argument-when a component
generates an event, it can pass along any extra information that
might be useful for you to use in processing that action.
<P>
All the basic UI components (except for labels, which have no
action) have different actions and arguments:
<UL>
<LI>Buttons create actions when they are pressed and released
with the mouse, and a button's extra argument is the label string
of that button.
<LI>Check boxes, both exclusive and nonexclusive, generate actions
when a box is checked. The extra argument is always <TT>true</TT>.
<LI>Choice menus generate an action when a menu item is selected,
and the extra argument is the label string of that item.
<LI>Text fields create actions when the user presses Return or
Enter inside that text field. Note that if the user tabs to a
different text field or uses the mouse to change the input focus,
an action is <I>not</I> generated. Pressing Return or Enter is
the only thing that triggers the action.
</UL>
<P>
Note that with actions, unlike with ordinary events, you can have
many different kinds of objects generating the action event, as
opposed to a single movement (a mouse press) generating a single
event (such as a <TT>mouseDown)</TT>.
To deal with those different UI components and the actions they
generate, you have to test for the type of object that sent/created
the event in the first place inside the body of your <TT>action()</TT>
method. That object is stored in the event's <TT>target</TT>
instance variable, and you can use the <TT>instanceof</TT>
operator to find out what kind of UI component sent it:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object arg) {
    if (evt.target instanceof TextField)
        return handleText(evt.target);
    else if (evt.target instanceof Choice)
        return handleChoice(arg);
...
}
</PRE>
</BLOCKQUOTE>
<P>
Although you can handle UI actions in the body of the <TT>action()</TT>
method, it's much more common simply to define a special method
in your <TT>action()</TT> method and
call that method instead. Here, there are two special methods:
one to handle the action on the text field (<TT>handleText()</TT>)
and one to handle the action on the choice menu (<TT>handleChoice()</TT>).
Depending on the action you want to handle, you may also want
to pass on the argument from the action, the UI component that
sent it, or any other information that the event might contain.
<P>
As with the other event methods, <TT>action()</TT>
returns a boolean value. As with all the event methods, you should
return <TT>true</TT> if <TT>action()</TT>
itself deals with the method, or <TT>false</TT>
if it passes the method on somewhere else (or ignores it).
<P>
Listing 13.2 shows a simple applet that has five buttons labeled
with colors. The <TT>action()</TT>
method tests for a button action and then passes control to a
method called <TT>changeColor()</TT>,
which changes the background color of the applet based on which
button was pressed (see Figure 13.21 to see the applet in action).
<P>
<A HREF="http://docs.rinet.ru/J21/f13-21.gif"><B>Figure 13.21: </B><I>The </I><TT>ButtonAction</TT><I>
applet</I>.</A><BR>
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. The </B><TT><B>ButtonActionsTest</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.awt.*;
 2:
 3:public class ButtonActionsTest extends java.applet.Applet {
 4:
 5:  public void init() {
 6:    setBackground(Color.white);
 7:
 8:    add(new Button(&quot;Red&quot;));
 9:    add(new Button(&quot;Blue&quot;));
10:    add(new Button(&quot;Green&quot;));
11:    add(new Button(&quot;White&quot;));
12:    add(new Button(&quot;Black&quot;));
13:  }
14:
15:  public boolean action(Event evt, Object arg) {
16:    if (evt.target instanceof Button) {
17:      changeColor((String)arg);
18:      return true;
19:    } else return false;
20:  }
21:
22:  void changeColor(String bname) {
23:    if (bname.equals(&quot;Red&quot;)) setBackground(Color.red);
24:    else if (bname.equals(&quot;Blue&quot;)) setBackground(Color.blue);
25:    else if (bname.equals(&quot;Green&quot;)) setBackground(Color.green);
26:    else if (bname.equals(&quot;White&quot;)) setBackground(Color.white);
27:    else setBackground(Color.black);
28:
29:    repaint();
30:  }
31:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As with most awt-based applets, this one starts with an <TT>init()</TT>
method that initializes the applet's state and creates and adds
components to the layout. The <TT>init()</TT>
method defined in lines 8 through 13 here sets the applet's background
color to white and creates five new buttons with color labels.
Here we'll use the default layout manager, which is a <TT>FlowLayout</TT>.
The buttons will appear all in a row at the top of the screen.
<P>
With the buttons in place, the second step is to attach actions
to those buttons. The <TT>action()</TT>
method, defined in lines 15 through 20, does this. The first thing
to check is to make sure it's a button action that's been generated
(line 16) and, if so, to pass the extra argument (cast to a string)
to the <TT>changeColor()</TT> method,
which will do all the work to change the color. If the event is
indeed a button action, we'll return <TT>true</TT>
to intercept that event. Otherwise, we'll return <TT>false</TT>
and let some other component handle the event.
<P>
The <TT>changeColor()</TT> method
is where all the work goes on. Here we test for each of the button
labels in turn to see which button it was that was pressed and
to set the background to the appropriate color. A final repaint
at the end does the actual change (setting the background color
does not automatically trigger a repaint; you'll have to do it
yourself).
<H2><A NAME="NestingPanelsandComponents"><FONT SIZE=5 COLOR=#FF0000>
Nesting Panels and Components</FONT></A></H2>
<P>
Adding UI components to individual panels or applets is fun, but
working with the awt begins to turn into lots of fun when you
start working with nested panels. By nesting different panels
inside your applet, and panels inside those panels, you can create
different layouts for different parts of the overall applet area,
isolate background and foreground colors and fonts to individual
parts of an applet, and manage the design of your UI components
individually and in distinct groups. The more complex the layout
of your applet, the more likely you're going to want to use nested
panels.
<H3><A NAME="NestedPanels">
Nested Panels</A></H3>
<P>
Panels, as you've already learned, are components that can be
actually displayed onscreen; <TT>Panel</TT>'s
superclass <TT>Container</TT> provides
the generic behavior for holding other components inside it. The
<TT>Applet</TT> class, from which
your applets all inherit, is a subclass of <TT>Panel</TT>.
To nest other panels inside an applet, you merely create a new
panel and add it to the applet, just as you would add any other
UI component:
<BLOCKQUOTE>
<PRE>
setLayout(new GridLayout(1, 2, 10, 10));
Panel panel1 = new Panel();
Panel panel2 = new Panel();
add(panel1);
add(panel2);
</PRE>
</BLOCKQUOTE>
<P>
You can then set up an independent layout for those subpanels
and add awt components to them (including still more subpanels)
by calling the <TT>add()</TT> method
in the appropriate panel:
<BLOCKQUOTE>
<PRE>
panel1.setLayout(new FlowLayout());
panel1.add(new Button(&quot;Up&quot;));
panel1.add(new Button(&quot;Down&quot;));
</PRE>
</BLOCKQUOTE>
<P>
Although you can do all this in a single class, it's common in
graphical applets and applications that make heavy use of subpanels
to factor out the layout and behavior of the subpanels into separate
classes and to communicate between the panels by using methods.
You'll look at an extensive example of this later in today's lesson
in the section &quot;A Complete Example: RGB-to-HSB Converter.&quot;
<H3><A NAME="EventsandNestedPanels">
Events and Nested Panels</A></H3>
<P>
When you create applets with nested panels, those panels form
a hierarchy from the outermost panel (the applet, usually) to
the innermost UI component. This hierarchy is important to how
each component in the interface interacts with other components;
for example, the component hierarchy determines the order in which
those components are painted to the screen.
<P>
More importantly, however, the hierarchy also affects event handling,
particularly for user-input events such as mouse and keyboard
events.
<P>
Events are received by the innermost component in the component
hierarchy and passed up the chain to the applet's panel (or to
the root window in Java applications). Suppose, for example, that
you have an applet with a subpanel that can handle mouse events
(using the <TT>mouseDown()</TT> and
<TT>mouseUp()</TT> methods), and that
panel contains a button. Clicking the button means that the button
receives the event before the panel does; if the button isn't
interested in that <TT>mouseDown()</TT>,
the event gets passed to the panel, which can then process it
or pass it further up the hierarchy.
<P>
Remember the discussion about the basic event methods yesterday?
You learned that the basic event methods all return boolean values.
Those boolean values become important when you're talking about
handling events or passing them on.
<P>
An event-handling method, whether it is the set of basic event
methods or the more generic <TT>handleEvent()</TT>,
can do one of three things, given any random event:
<UL>
<LI>Ignore the event entirely, if the event doesn't match whatever
criteria the event-handling method set-for example, the <TT>mouseDown</TT>
wasn't in the right area, or the action wasn't a button action.
If this is the case, the event handler should return <TT>false</TT>
so the event is passed up the hierarchy until a component processes
it (or it is ignored altogether).
<LI>Intercept the event, process it, and return <TT>true</TT>.
In this case, the event stops with that event method.
<LI>Intercept the method, process it, and pass it on to another,
more specific event handler-for example, as <TT>handleEvent</TT>
passes events onto <TT>mouseDown()</TT>.
</UL>
<H2><A NAME="MoreUIComponents"><FONT SIZE=5 COLOR=#FF0000>
More UI Components</FONT></A></H2>
<P>
After you master the basic UI components and how to add them to
panels, organize their layout, and manage their events, you can
add more UI components. In this section, you'll learn about text
areas, scrolling lists, scrollbars, and canvases.
<P>
Note that most of the components in this section do not produce
actions, so you can't use the <TT>action()</TT>
method to handle their behavior. Instead, you have to use a generic
<TT>handleEvent()</TT> method to test
for specific events that these UI components generate. You'll
learn more about this in the next section.
<H3><A NAME="TextAreas">
Text Areas</A></H3>
<P>
Text areas are like text fields, except they have more functionality
for handling large amounts of text. Because text fields are limited
in size and don't scroll, they are better for one-line responses
and simple data entry; text areas can be any given width and height
and have scrollbars by default, so you can deal with larger amounts
of text more easily.
<P>
<I>Text areas</I> are larger, scrollable text-entry components.
Whereas text fields only provide one line of text, text areas
can hold any amount of editable text.
<P>
To create a text area, use one of the following constructors:
<UL>
<LI><TT>TextArea()</TT> creates an
empty text area 0 rows long and 0 characters wide (the text area
will be automatically resized based on the layout manager).
<LI><TT>TextArea(int, int)</TT> creates
an empty text area with the given number of rows and columns (characters).
<LI><TT>TextArea(String)</TT> creates
a text area displaying the given string, which will be sized according
to the current layout manager.
<LI><TT>TextArea(String, int, int)</TT>
creates a text area displaying the given string and with the given
dimensions.
</UL>
<P>
Figure 13.22 shows a simple text area generated from the following
code:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-22.gif"><B>Figure 13.22: </B><I>A text area</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class TextAreaTest extends java.applet.Applet {

  public void init() {
    String str = &quot;Once upon a midnight dreary, while I pondered, weak and weary,\n&quot; +
     &quot;Over many a quaint and curious volume of forgotten lore,\n&quot; +
     &quot;While I nodded, nearly napping, suddenly there came a tapping,\n&quot; +
     &quot;As of some one gently rapping, rapping at my chamber door.\n&quot; +
     &quot;\&quot;'Tis some visitor,\&quot; I muttered, \&quot;tapping at my chamber door-\n&quot; +
     &quot;Only this, and nothing more.\&quot;\n\n&quot;;
     // more text deleted for space

     add(new TextArea(str,10,50));
  } 
}
</PRE>
</BLOCKQUOTE>
<P>
Both text areas and text fields inherit from the <TT>TextComponent</TT>
class, so a lot of the behavior for text fields (particularly
getting and setting text and selections) is usable on text areas
as well (refer to Table 13.4). Text areas also have a number of
their own methods that you may find useful. Table 13.5 shows a
sampling of those methods.<BR>
<P>
<CENTER><B>Table 13.5. Text area methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=248><B>Method</B></TD><TD WIDTH=342><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=248><TT>getColumns()</TT> 
</TD><TD WIDTH=342>Returns the width of the text area, in characters or columns
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=248><TT>getRows() </TT>
</TD><TD WIDTH=342>Returns the number of rows in the text area (not the number of rows of text that the text area contains)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=248><TT>insertText(String, int)</TT> 
</TD><TD WIDTH=342>Inserts the string at the given position in the text (text positions start at <TT>0</TT>)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=248><TT>replaceText(String, int, int)</TT>
</TD><TD WIDTH=342>Replaces the text between the given integer positions with the new string
</TD></TR>
</TABLE>
</CENTER>
<H3><A NAME="ScrollingLists">
Scrolling Lists</A></H3>
<P>
Remember the choice menu, with which you could choose one of several
different options? A scrolling list is functionally similar to
a choice menu in that it lets you pick several options from a
list, but scrolling lists differ in two significant ways:
<UL>
<LI>Scrolling lists are not pop-up menus. They're displayed as
a list of items from which you can choose one or more items. If
the number of items is larger than the list box, a scrollbar is
automatically provided so that you can see the other items.
<LI>You can choose more than one item in the list (if the list
has been defined to allow it).
</UL>
<P>
<I>Scrolling lists</I> provide a menu of items that can be selected
or deselected. Unlike choice menus, scrolling lists are not pop-up
menus and can be defined to allow multiple selections.
<P>
To create a scrolling list, create an instance of the <TT>List</TT>
class and then add individual items to that list. The <TT>List</TT>
class has two constructors:
<UL>
<LI><TT>List()</TT> creates an empty
scrolling list that enables only one selection at a time.
<LI><TT>List(int, boolean)</TT> creates
a scrolling list with the given number of visible lines on the
screen (you're unlimited as to the number of actual items you
can add to the list). The boolean argument indicates whether this
list enables multiple selections (<TT>true</TT>)
or not (<TT>false</TT>).
</UL>
<P>
After creating a <TT>List</TT> object,
add items to it using the <TT>addItem()</TT>
method and then add the list itself to the panel that contains
it. Here's an example that creates a list five items high that
allows multiple selections (the result of this code is shown in
Figure 13.23):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-23.gif"><B>Figure 13.23: </B><I>A scrolling list</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class ListsTest extends java.applet.Applet {

  public void init() {
    List lst = new List(5, true);

    lst.addItem(&quot;Hamlet&quot;);
    lst.addItem(&quot;Claudius&quot;);
    lst.addItem(&quot;Gertrude&quot;);
    lst.addItem(&quot;Polonius&quot;);
    lst.addItem(&quot;Horatio&quot;);
    lst.addItem(&quot;Laertes&quot;);
    lst.addItem(&quot;Ophelia&quot;);
    
    add(lst);
  }
}
</PRE>
</BLOCKQUOTE>
<P>
Scrolling lists generate actions when the user double-clicks a
list item (single-clicking generates a <TT>LIST_SELECT</TT>
or <TT>LIST_DESELECT</TT> event ID;
you'll learn more about these in the section &quot;More UI Events&quot;).
A scrolling list action has the argument of the string of the
item that was double-clicked.
<P>
Table 13.6 shows some of the methods available to scrolling lists.
See the API documentation for a complete set.<BR>
<P>
<CENTER><B>Table 13.6. Scrolling list methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=208><B>Method</B></TD><TD WIDTH=382><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getItem(int)</TT>
</TD><TD WIDTH=382>Returns the string item at the given position
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>countItems()</TT>
</TD><TD WIDTH=382>Returns the number of items in the menu</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getSelectedIndex()</TT>
</TD><TD WIDTH=382>Returns the index position of the item that's selected (used for lists that allow only single selections)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getSelectedIndexes()</TT>
</TD><TD WIDTH=382>Returns an array of index positions (used for lists that allow multiple selections)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getSelectedItem()</TT>
</TD><TD WIDTH=382>Returns the currently selected item as a string
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getSelectedItems()</TT>
</TD><TD WIDTH=382>Returns an array of strings containing all the selected items
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>select(int)</TT>
</TD><TD WIDTH=382>Selects the item at the given position</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>select(String)</TT>
</TD><TD WIDTH=382>Selects the item with that string</TD></TR>
</TABLE>
</CENTER>
<H3><A NAME="ScrollbarsandSliders">
Scrollbars and Sliders</A></H3>
<P>
Text areas and scrolling lists come with their own scrollbars,
which are built into those UI components and enable you to manage
both the body of the area or the list and its scrollbar as a single
unit. You can also create individual scrollbars, or <I>sliders</I>,
to manipulate a range of values.
<P>
Scrollbars are used to select a value between a maximum and a
minimum value. To change the current value of that scrollbar,
you can use three different parts of the scrollbar (seeFigure
13.24):
<P>
<A HREF="http://docs.rinet.ru/J21/f13-24.gif"><B>Figure 13.24: </B><I>Scrollbar parts</I>.</A>
<UL>
<LI>Arrows on either end, which increment or decrement the values
by some small unit (<TT>1</TT> by
default).
<LI>A range in the middle, which increments or decrements the
value by a larger amount (<TT>10</TT>
by default).
<LI>A box in the middle, often called an <I>elevator</I> or <I>thumb</I>,
whose position shows where in the range of values the current
value is located. Moving this box with the mouse causes an absolute
change in the value, based on the position of the box within the
scrollbar.
</UL>
<P>
Choosing any of these visual elements causes a change in the scrollbar's
value; you don't have to update anything or handle any events.
All you have to do is give the scrollbar a maximum and minimum,
and Java will handle the rest.
<P>
A <I>scrollbar</I> is a visual UI element that allows you to choose
a value between some minimum and some maximum. Scrollbars are
sometimes called <I>sliders</I>.
<P>
To create a scrollbar, you can use one of three constructors:
<UL>
<LI><TT>Scrollbar()</TT> creates a
scrollbar with its initial maximum and minimum values both <TT>0</TT>,
in a vertical orientation.
<LI><TT>Scrollbar(int)</TT> creates
a scrollbar with its initial maximum and minimum values both <TT>0</TT>.
The argument represents an orientation, for which you can use
the class variables <TT>Scrollbar.HORIZONTAL</TT>
and <TT>Scrollbar.VERTICAL</TT>.
<LI><TT>Scrollbar(int, int, int, int, int)</TT>
creates a scrollbar with the following arguments (each one is
an integer, and they must be presented in this order):
<LI>The first argument is the orientation of the scrollbar: <TT>Scrollbar.HORIZONTAL</TT>
and <TT>Scrollbar.VERTICAL</TT>.
<LI>The second argument is the initial value of the scrollbar,
which should be a value between the scrollbar's maximum and minimum
values.
<LI>The third argument is the overall width (or height, depending
on the orientation) of the scrollbar's box. In user-interface
design, a larger box implies that a larger amount of the total
range is currently showing (applies best to things such as windows
and text areas).
<LI>The fourth and fifth arguments are the minimum and maximum
values for the scrollbar.
</UL>
<P>
Here's a simple example of a scrollbar that increments a single
value (see Figure 13.25). The label to the left of the scrollbar
is updated each time the scrollbar's value changes:
<P>
<A HREF="http://docs.rinet.ru/J21/f13-25.gif"><B>Figure 13.25: </B><I>A scrollbar</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class SliderTest extends java.applet.Applet {
  Label l;

  public void init() {
    setLayout(new GridLayout(1,2));
    l = new Label(&quot;0&quot;, Label.CENTER);
    add(l);
    add(new Scrollbar(Scrollbar.HORIZONTAL,0,0,1,100));
  }

  public Insets insets() {
    return new Insets(15,15,15,15);
  }

  public boolean handleEvent(Event evt) {
    if (evt.target instanceof Scrollbar) {
      int v = ((Scrollbar)evt.target).getValue();
      l.setText(String.valueOf(v));
      repaint();
      return true;
    } else return false;
  }

}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>Scrollbar</TT> class provides
several methods for managing the values within scrollbars. (See
Table 13.7.)<BR>
<P>
<CENTER><B>Table 13.7. Scrollbar methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=240><B>Method</B></TD><TD WIDTH=350><B>Action</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getMaximum()</TT>
</TD><TD WIDTH=350>Returns the maximum value.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getMinimum()</TT>
</TD><TD WIDTH=350>Returns the minimum value.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getOrientation()</TT>
</TD><TD WIDTH=350>Returns the orientation of this scrollbar:
<P>
<TT>0</TT> is <TT>Scrollbar.HORIZONTAL</TT>; <TT>1</TT> is <TT>Scrollbar.VERTICAL</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getValue()</TT>
</TD><TD WIDTH=350>Returns the scrollbar's current value.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>setValue(int)</TT>
</TD><TD WIDTH=350>Sets the current value of the scrollbar.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>setLineIncrement(int inc)</TT>
</TD><TD WIDTH=350>Change the increment for how far to scroll when the endpoints of the scrollbar are selected. The default is <TT>1</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getLineIncrement()</TT>
</TD><TD WIDTH=350>Returns the increment for how far to scroll when the endpoints of the scrollbar are selected.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>setPageIncrement(int inc)</TT>
</TD><TD WIDTH=350>Change the increment for how far to scroll when the inside range of the scrollbar is selected. The default is <TT>10</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>getPageIncrement()</TT>
</TD><TD WIDTH=350>Returns the increment for how far to scroll when the inside range of the scrollbar is selected.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Canvases">
Canvases</A></H3>
<P>
Although you can draw on most awt components such as panels using
the graphics methods you learned about on <A HREF="ch11.htm">Day 11</A>, &quot;More Animation,
Images, and Sound,&quot; canvases do little <I>except</I> let
you draw on them. They can't contain other components, but they
can accept events, and you can create animation and display images
on them. If you have a panel that doesn't need to do anything
except display images or animation, a canvas would make a lighter-weight
surface than a panel would.
<P>
A <I>canvas </I>is a component that you can draw on.
<P>
To create a canvas, use the <TT>Canvas</TT>
class and add it to a panel as you would any other component:
<BLOCKQUOTE>
<PRE>
Canvas can = new Canvas();
add(can);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="MoreUIEvents"><FONT SIZE=5 COLOR=#FF0000>
More UI Events</FONT></A></H2>
<P>
Yesterday, you learned about some basic event types that are generated
from user input to the mouse or the keyboard. These event types
are stored in the <TT>Event</TT> object
as the event ID, and can be tested for in the body of a <TT>handleEvent()</TT>
method by using class variables defined in <TT>Event</TT>.
For many basic events, such as <TT>mouseDown()</TT>
and <TT>keyDown()</TT>, you can define
methods for those events to handle the event directly. You learned
a similar mechanism today for UI actions where creating an <TT>action()</TT>
method handled a specific action generated by a UI component.
<P>
The most general way of managing events, however, continues to
be the <TT>handleEvent()</TT> method.
For events relating to scrollbars and scrolling lists, the only
way to intercept these events is to override <TT>handleEvent()</TT>.
<P>
To intercept a specific event, test for that event's ID. The available
IDs are defined as class variables in the <TT>Event</TT>
class, so you can test them by name. You learned about some of
the basic events yesterday; Table 13.8 shows additional events
that may be useful to you for the components you've learned about
today (or that you might find useful in general).<BR>
<P>
<CENTER><B>Table 13.8. Additional events.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=177><B>Event ID</B></TD><TD WIDTH=413><B>What It Represents</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>ACTION_EVENT</TT>
</TD><TD WIDTH=413>Generated when a UI component action occurs
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>GOT_FOCUS</TT>
</TD><TD WIDTH=413>Generated when the user clicks inside a text area
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>LOST_FOCUS</TT>
</TD><TD WIDTH=413>Generated when the user clicks anywhere outside a text area (after being inside one)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>LIST_DESELECT</TT>
</TD><TD WIDTH=413>Generated when an item in a scrolling list is deselected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>LIST_SELECT</TT>
</TD><TD WIDTH=413>Generated when an item in a scrolling list is selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>SCROLL_ABSOLUTE</TT>
</TD><TD WIDTH=413>Generated when a scrollbar's box has been moved
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>SCROLL_LINE_DOWN</TT>
</TD><TD WIDTH=413>Generated when a scrollbar's bottom or left endpoint (button) is selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>SCROLL_LINE_UP</TT>
</TD><TD WIDTH=413>Generated when a scrollbar's top or right endpoint (button) is selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>SCROLL_PAGE_DOWN</TT>
</TD><TD WIDTH=413>Generated when the scrollbar's field below (or to the left of) the box is selected
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT>SCROLL_PAGE_UP</TT>
</TD><TD WIDTH=413>Generated when the scrollbar's field above (or to the right of) the box is selected
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="FunwithComponents"><FONT SIZE=5 COLOR=#FF0000>
Fun with Components</FONT></A></H2>
<P>
The <TT>Component</TT> class is the
root of all the awt objects: all the UI elements, panels, canvases,
even applets. Just about everything you can display, lay out,
change the color of, draw to, or interact with using events in
the awt is a component.
<P>
Components have a set of methods that allow you to modify their
appearance or change their behavior. You've seen the use of a
few of these methods already (<TT>setBackground()</TT>,
<TT>setFont</TT>, <TT>size()</TT>),
applied specifically to applets. But the methods defined in <TT>Component</TT>
can be used with any component, allowing you to modify the appearance
or the behavior of just about any element in your program. You
can also create custom components (classes that inherit from <TT>Panel</TT>
or <TT>Canvas</TT>) to make your own
special awt elements or user interface widgets. 
<P>
Table 13.9 summarizes some of the methods you can use with individual
components. For more methods, check out the Java API documentation
for the class <TT>Component</TT>.
The JDK 1.0.2 documentation is online at
<BLOCKQUOTE>
<PRE>
<A HREF="http://java.sun.com/products/JDK/CurrentRelease/api/">http://java.sun.com:80/products/JDK/CurrentRelease/api/</A><BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 13.9. </B><TT><B>Component</B></TT><B>
methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=208><TT>getBackground()</TT>
</TD><TD WIDTH=382>Returns a <TT>Color</TT> object representing the component's background color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>setBackground(Color)</TT>
</TD><TD WIDTH=382>Sets the component's background color.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getForeground()</TT>
</TD><TD WIDTH=382>Returns a <TT>Color</TT> object representing the component's current foreground color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>setForeground(Color)</TT>
</TD><TD WIDTH=382>Sets the component's foreground color</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>getFont()</TT>
</TD><TD WIDTH=382>Returns a <TT>Font</TT> object representing the component's current font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>setFont(Font)</TT>
</TD><TD WIDTH=382>Changes the component's current font.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>size()</TT>
</TD><TD WIDTH=382>Returns a <TT>Dimension</TT> object representing the component's current size. You can then get to the individual width and height using <TT>size().width()</TT> and <TT>size().height()</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>minimumSize()</TT>
</TD><TD WIDTH=382>The component's smallest possible size as a <TT>Dimension</TT> object. <TT>minimumSize()</TT> is usually only used by layout managers to determine how small it can draw a component; if you create a custom component you'll want to 
override this method to return the minimum size of that component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>preferredSize()</TT>
</TD><TD WIDTH=382>The component's preferred size (usually equal to or larger than the component's <TT>minimumSize()</TT>) as a <TT>Dimension</TT> object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>resize(Dimension)</TT>
</TD><TD WIDTH=382>Changes the size of the applet to be the current size. For custom components you'll want to also call <TT>validate()</TT> after resizing the applet so that the layout can be redrawn.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>inside(x, y)</TT>
</TD><TD WIDTH=382>Returns <TT>true</TT> if the given x and y coordinates are inside the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>hide()</TT>
</TD><TD WIDTH=382>Hides the component. Hidden components do not show up onscreen.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>show()</TT>
</TD><TD WIDTH=382>Shows a component previously hidden.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>isVisible()</TT>
</TD><TD WIDTH=382>Returns <TT>true</TT> or <TT>false</TT> depending on whether this component is visible (not hidden).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>disable()</TT>
</TD><TD WIDTH=382>Disables the component-that is, stops generating events. Disabled components cannot be pressed, selected from, typed into, and so on.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>enable()</TT>
</TD><TD WIDTH=382>Enables a previously disabled object.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=208><TT>isEnabled()</TT>
</TD><TD WIDTH=382>Returns <TT>true</TT> or <TT>false</TT> depending on whether the component is enabled.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="ACompleteExampleRGBtoHSBConverter"><FONT SIZE=5 COLOR=#FF0000>
A Complete Example: RGB-to-HSB Converter</FONT></A></H2>
<P>
Let's take a break here from theory and smaller examples to create
a larger example that puts together much of what you've learned
so far. The following applet example demonstrates layouts, nesting
panels, creating user-interface components, and catching and handling
actions, as well as using multiple classes to put together a single
applet. In short, it's the most complex applet you've created
so far.
<P>
Figure 13.26 shows the applet you'll be creating in this example.
The <TT>ColorTest</TT> applet enables
you to pick colors based on RGB (red, green, and blue) and HSB
(hue, saturation, and brightness) values.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-26.gif"><B>Figure 13.26: </B><I>The </I><TT>ColorTest</TT><I>
applet</I>.</A><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A very quick summary in case you're not familiar with basic color theory: <I>RGB</I> color defines a color by its red, green, and blue values; some combination of these values can produce any color in the spectrum (red, green, and blue are called 
<I>additive colors</I>; that's how your monitor and your TV represent different colors).
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>HSB</I> stands for hue, saturation, and brightness and is a different way of indicating color. <I>Hue</I> is the actual color in the spectrum you're representing (think of it as values along a color wheel). <I>Saturation</I> is the amount of that color; 
low saturation results in pastels; high-saturation colors are more vibrant and &quot;colorful.&quot; <I>Brightness</I>, finally, is the lightness or darkness of the color. No brightness is black; full brightness is white.
</BLOCKQUOTE>
<BLOCKQUOTE>
A single color can be represented either by its RGB values or by its HSB values, and there are mathematical algorithms to convert between them. The <TT>ColorTest</TT> applet provides a graphical converter between the two.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>ColorTest</TT> applet has
three main parts: a colored box on the left side and two groups
of text fields on the right. The first group indicates RGB values;
the right, HSB. By changing any of the values in any of the text
boxes, the colored box is updated to the new color, as are the
values in the other group of text boxes.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you try this applet, be aware that you have to press Enter or Return after changing a number for the updating to occur. Using the Tab key to move between text fields or clicking with the mouse will not cause the applet to update.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This applet uses two classes:
<UL>
<LI><TT>ColorTest</TT>, which inherits
from <TT>Applet</TT>. This is the
controlling class for the applet itself.
<LI><TT>ColorControls</TT>, which
inherits from <TT>Panel</TT>. You'll
create this class to represent a group of three text fields and
to handle actions from those text fields. Two instances of this
class, one for the RGB values and one for the HSB ones, will be
created and added to the applet.
</UL>
<P>
Let's work through this step by step, because it's very complicated
and can get confusing. All the code for this applet will be shown
at the end of this section.
<H3><A NAME="DesigningandCreatingtheAppletLayout">
Designing and Creating the Applet Layout</A></H3>
<P>
The best way to start creating an applet that uses awt components
is to worry about the layout first and then worry about the functionality.
When dealing with the layout, you should start with the outermost
panel first and work inward.
<P>
Making a sketch of your UI design can help you figure out how
to organize the panels inside your applet or window to best take
advantage of layout and space. Paper designs are helpful even
when you're not using grid bag layouts, but doubly so when you
are (we'll be using a simple grid layout for this applet).
<P>
Figure 13.27 shows the <TT>ColorTest</TT>
applet with a grid drawn over it so that you can get an idea of
how the panels and embedded panels work.
<P>
<A HREF="http://docs.rinet.ru/J21/f13-27.gif"><B>Figure 13.27: </B><I>The ColorTest applet panels and components</I>.</A>
<P>
Let's start with the outermost panel-the applet itself. This panel
has three parts: the color box on the left, the RGB text fields
in the middle, and the HSB fields on the right.
<P>
Because the outermost panel is the applet itself, your <TT>ColorTest</TT>
class will be the applet class and will inherit from <TT>Applet</TT>.
You'll also import the awt classes here (note that because you
use so many of them in this program, it's easiest to just import
the entire package):
<BLOCKQUOTE>
<PRE>
import java.awt.*;

public class ColorTest extends java.applet.Applet {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
This applet has three main things to keep track of: the color
box and the two subpanels. The two subpanels each refer to different
things, but they're essentially the same panel and behave in the
same ways. Rather than duplicate a lot of code here in this class,
this is a perfect opportunity to create another class just for
the subpanels, use instances of that class here in the applet,
and communicate between everything using methods. In a bit we'll
define that new class, called <TT>ColorControls</TT>.
<P>
For now, however, we know we need to keep a handle to all three
parts of the applet so you can update them when they change. So
let's create three instance variables: one of type <TT>Canvas</TT>
for the color box, and the other two of type <TT>ColorControls</TT>
for the control panels:
<BLOCKQUOTE>
<PRE>
ColorControls RGBcontrols, HSBcontrols;
Canvas swatch;
</PRE>
</BLOCKQUOTE>
<P>
Now we'll move onto the <TT>init()</TT>
method, where all the basic initialization and layout of the applet
takes place. There are three steps to initializing this applet:
<OL>
<LI>Create the layout for the big parts of the panel. Although
a flow layout would work, a grid layout with one row and three
columns is a much better idea.
<LI>Create and initialize the three components of this applet:
a canvas for the color box and two subpanels for the text fields.
<LI>Add those components to the applet.
</OL>
<P>
Step one is the layout. Let's use a grid layout and a gap of 10
points to separate each of the components:
<BLOCKQUOTE>
<PRE>
setLayout(new GridLayout(1, 3, 5, 15));
</PRE>
</BLOCKQUOTE>
<P>
Step two is creating the components-the canvas first. You have
an instance variable to hold that one. Here we'll create the canvas
and initialize its background to black:
<BLOCKQUOTE>
<PRE>
swatch = new Canvas();
swatch.setBackground(Color.black);
</PRE>
</BLOCKQUOTE>
<P>
You need to create two instances of your as-of-yet nonexistent
<TT>ColorControls</TT> panels here
as well, but because we haven't created the class yet we don't
know what the constructors to that class will look like. Let's
put in some placeholder constructors here; we'll fill in the details
later:
<BLOCKQUOTE>
<PRE>
RGBcontrols = new ColorControls(...)
HSBcontrols = new ColorControls(...);
</PRE>
</BLOCKQUOTE>
<P>
Step three is adding all three components to the applet panel:
<BLOCKQUOTE>
<PRE>
add(swatch);
add(RGBcontrols);
add(HSBcontrols);
</PRE>
</BLOCKQUOTE>
<P>
While you're working on layout, let's add insets for the applet:
10 points along all the edges:
<BLOCKQUOTE>
<PRE>
public Insets insets() {
    return new Insets(10, 10, 10, 10);
}
</PRE>
</BLOCKQUOTE>
<P>
Got it so far? At this point you have three instance variables,
an <TT>init()</TT> method with two
incomplete constructors, and an <TT>insets()</TT>
method in your <TT>ColorTest</TT>
class. Let's move on now to creating the subpanel layout in the
<TT>ColorControls</TT> class so we
can fill in those constructors and finish up the layout.
<H3><A NAME="DefiningtheSubpanels">
Defining the Subpanels</A></H3>
<P>
The <TT>ColorControls</TT> class will
have behavior for laying out and handling the subpanels that represent
the RGB and HSB values for the color. <TT>ColorControls</TT>
doesn't need to be a subclass of <TT>Applet</TT>
because it isn't actually an applet; it's just a panel. Define
it to inherit from <TT>Panel</TT>:
<BLOCKQUOTE>
<PRE>
import java.awt.*

class ColorControls extends Panel {
    ...
}<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
I've put the <TT>ColorControls</TT> source code into its own file, called <TT>ColorControls.java</TT>. However, you can put the <TT>ColorControls</TT> class in the same file as the <TT>ColorTest</TT> class. Up to this point, you've only defined one class 
per file, with the filename the same name as the class. In Java you can have multiple class definitions in a file as long as only one of those classes is declared public (and the name of the source file is the same as that public class). In this case, the 
<TT>ColorTest</TT> class is public (it's an applet, so it has to be), but the <TT>ColorControls</TT> class isn't public, so it can be in the same source file. When you compile the file, Java will create the appropriate multiple class files for each class 
definition. You'll learn more about public classes on <A HREF="ch15.htm">Day 15</A>, &quot;Modifiers, Access Control, and Class Design,&quot; and <A HREF="ch16.htm">Day 16</A>, &quot;Packages and Interfaces.&quot;
</BLOCKQUOTE>
<BLOCKQUOTE>
In general, however, I prefer to use separate source files for my classes. It makes it easier for me to find the source for a particular class because I don't have to remember which file I defined it in.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>ColorControls</TT> class will
need a number of instance variables so that information from the
panel can get back to the applet. The first of these instance
variables is a hook back up to the applet class that contains
this panel. Because it's the outer applet class that controls
the updating of each panel, this panel will need a way to tell
the applet that something has changed. And to call a method in
that applet, you need a reference to that object. So, instance
variable number one is a reference an instance of the class <TT>ColorTest</TT>:
<BLOCKQUOTE>
<PRE>
ColorTest applet;
</PRE>
</BLOCKQUOTE>
<P>
If you figure that the applet class is the one that's going to
be updating everything, that class if going to be interested in
the individual text fields in this subpanel. We'll create instance
variables for those text fields:
<BLOCKQUOTE>
<PRE>
TextField tfield1, tfield2, tfield3;
</PRE>
</BLOCKQUOTE>
<P>
Now let's move on to the constructor for this class. Because this
class isn't an applet, we won't use <TT>init()</TT>
to initialize it; instead we'll use a constructor method.
<P>
Inside the constructor you'll do much of what you did inside <TT>init()</TT>:
create the layout for the subpanel, create the text fields, and
add them to the panel.
<P>
The goal here is to make the <TT>ColorControls</TT>
class generic enough so that you can use it for both the RGB fields
and the HSB fields. Those two panels differ in only one respect:
the labels for the text. That's three values to get before you
can create the object. You can pass those three values in through
the constructors in <TT>ColorTest</TT>.
You also need one more: that reference to the enclosing applet,
which you can get from the constructor as well.
<P>
You now have four arguments to the basic constructor for the <TT>ColorControls</TT>
class. Here's the signature for that constructor:
<BLOCKQUOTE>
<PRE>
ColorControls(ColorTest parent,
        String l1, String l2, String l3) {
}
</PRE>
</BLOCKQUOTE>
<P>
Let's start this constructor by first setting the value of <TT>parent</TT>
to the applet instance variable:
<BLOCKQUOTE>
<PRE>
applet = parent;
</PRE>
</BLOCKQUOTE>
<P>
Next, create the layout for this panel. You can also use a grid
layout for these subpanels, as you did for the applet panel, but
this time the grid will have three rows (one for each of the text
field and label pairs) and two columns (one for the labels and
one for the fields). We'll also define a 10-point gap between
the components in the grid:
<BLOCKQUOTE>
<PRE>
setLayout(new GridLayout(3,2,10,10));
</PRE>
</BLOCKQUOTE>
<P>
Now we can create and add the components to the panel. First,
we'll create the text field objects (initialized to the string
<TT>&quot;0&quot;</TT>), and assign
them to the appropriate instance variables:
<BLOCKQUOTE>
<PRE>
tfield1 = new TextField(&quot;0&quot;);
tfield2 = new TextField(&quot;0&quot;);  
tfield3 = new TextField(&quot;0&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Now we'll add those fields and the appropriate labels to the panel,
using the remaining three parameters to the constructor as the
text for the labels:
<BLOCKQUOTE>
<PRE>
add(new Label(l1, Label.RIGHT));
add(tfield1);
add(new Label(l2, Label.RIGHT));
add(tfield2);
add(new Label(l3, Label.RIGHT));
add(tfield3);
</PRE>
</BLOCKQUOTE>
<P>
That finishes up the constructor for the subpanel class <TT>ColorControls</TT>.
Are we done with the layout? Not quite. We'll also add an inset
around the subpanel-only on the top and bottom edges-to tinker
the layout. Add the inset here as you did in the <TT>ColorTest</TT>
class, using the <TT>insets()</TT>
method:
<BLOCKQUOTE>
<PRE>
public Insets insets() {
        return new Insets(10, 10, 0, 0);
 }
</PRE>
</BLOCKQUOTE>
<P>
You're almost there. You have 98 percent of the basic structure
in place and ready to go, but there's one step left: going back
to <TT>ColorTest</TT> and fixing those
placeholder constructors for the subpanel so they match the actual
constructors for <TT>ColorControls</TT>.
<P>
The constructor for <TT>ColorControls</TT>
that we just created now has four arguments: the <TT>ColorTest</TT>
object and three labels (strings). Remember back to when we created
the <TT>init()</TT> method for <TT>ColorTest</TT>:
We added two placeholders for creating new <TT>ColorControls</TT>
objects; we'll replace those placeholders with the correct versions
now. Make sure you add the four arguments that constructor needs
to work: the <TT>ColorTest</TT> object
and three strings. To pass the <TT>ColorTest</TT>
object to those constructors, we can use the <TT>this</TT>
keyword:
<BLOCKQUOTE>
<PRE>
RGBcontrols = new ColorControls(this, &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;);
HSBcontrols = new ColorControls(this, &quot;Hue&quot;, &quot;Saturation&quot;, &quot;Brightness&quot;);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note </B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
For the initial values of all the text fields in this example, I used the number 0 (actually, the string <TT>&quot;0&quot;</TT>). For the color black, both the RGB and the HSB values are <TT>0</TT>, which is why I can make this assumption. If you wanted to 
initialize the applet to be some other color, you might want to rewrite the <TT>ColorControls</TT> class to use initializer values as well as to initialize labels. This way made for a shorter example.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="HandlingtheActions">
Handling the Actions</A></H3>
<P>
With the layout done, its time to set up event handling and updating
between the various components so that when the user interacts
with the applet, the applet can respond.
<P>
The action of this applet occurs when the user changes a value
in any of the text fields and presses Enter. By causing an action
in a text field, the color changes, the color box updates to the
new color, and the values of the fields in the opposite subpanel
change to reflect the new color.
<P>
The <TT>ColorTest</TT> class is responsible
for actually doing the updating because it keeps track of all
the subpanels. Because the actual event occurs in the subpanel,
however, you'll need to track and intercept those events in that
subpanel using the <TT>action()</TT>
method in the <TT>ColorControls</TT>
class:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object arg) {
    if (evt.target instanceof TextField) {
      applet.update(this);
      return true;
    }
    else return false;
}
</PRE>
</BLOCKQUOTE>
<P>
In the <TT>action()</TT> method, you
test to make sure the action was indeed generated by a text field
(because there are only text fields available, that's the only
action you'll get, but it's a good idea to test for it anyhow).
If there was indeed a text field action, we'll call a method to
update all the subpanels. That method, which we'll call <TT>update()</TT>,
is defined in the enclosing class, so we'll call it using the
object stored in the applet instance variable (and pass along
a reference to the panel so that the applet can get at our values).
And, finally, we'll return either <TT>true</TT>
or <TT>false</TT> so that other actions
that might occur on this applet can be passed along to enclosing
panels or components.
<H3><A NAME="UpdatingtheResult">
Updating the Result</A></H3>
<P>
Now comes the hard part: actually doing the updating based on
the new values of whatever text field was changed. For this, you
define the <TT>update()</TT> method
in the <TT>ColorTest</TT> class. This
<TT>update()</TT> method takes a single
argument-the <TT>ColorControls</TT>
instance that contains the changed value (you get that argument
from the <TT>action()</TT> method
in the <TT>ColorControls</TT> object).
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Won't this <TT>update()</TT> method interfere with the system's <TT>update()</TT> method? Nope. Remember, methods can have the same name, but different signatures and definitions. Because this <TT>update()</TT> has a single argument of type 
<TT>ColorControls</TT>, it doesn't interfere with the other version of <TT>update()</TT>. Normally, all methods called <TT>update()</TT> should mean basically the same thing; it's not true here, but it's only an example.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>update()</TT> method is responsible
for updating all the panels in the applet. To know which panel
to update, you need to know which panel changed. You can find
out by testing to see whether the argument you got passed from
the panel is the same as the subpanels you have stored in the
<TT>RGBcontrols</TT> and <TT>HSBcontrols</TT>
instance variables:
<BLOCKQUOTE>
<PRE>
void update(ColorControls controlPanel) {

    if (controlPanel == RGBcontrols) {  // RGB has changed, update HSB
       ...
    } else {  // HSB has changed, update RGB
       ...
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This test is the heart of the <TT>update()</TT>
method. Let's start with that first case-a number has been changed
in the RGB text fields. So now, based on those new RGB values,
you have to generate a new <TT>Color</TT>
object and update the values on the HSB panel. To reduce some
typing, you create a few local variables to hold some basic values.
In particular, the values of the text fields are strings whose
values you can get to using the <TT>getText()</TT>
method defined in the <TT>TextField</TT>
objects of the <TT>ColorControls</TT>
object. Because most of the time in this method we'll want to
deal with those values as integers, we'll get those string values,
convert them to integers, and store them in local variables (<TT>value1</TT>,
<TT>value2</TT>, <TT>value3</TT>).
Here's the code to do this (it looks more complicated than it
actually is):
<BLOCKQUOTE>
<PRE>
int value1 = Integer.parseInt(controlPanel.tfield1.getText());
int value2 = Integer.parseInt(controlPanel.tfield2.getText());
int value3 = Integer.parseInt(controlPanel.tfield3.getText());
</PRE>
</BLOCKQUOTE>
<P>
While we're here defining local variables, we'll also need one
for the new <TT>Color</TT> object:
<BLOCKQUOTE>
<PRE>
Color c;
</PRE>
</BLOCKQUOTE>
<P>
OK. Let's assume one of the text fields in the RGB side of the
applet has changed and add the code to the <TT>if</TT>
part of the <TT>update()</TT> method.
We'll need to create a new <TT>Color</TT>
object and update the HSB side of the panel. That first part is
easy; given the three RGB values, you can create a new <TT>Color</TT>
object using those as arguments to the constructor:
<BLOCKQUOTE>
<PRE>
c = new Color(value1, value2, value3);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This part of the example isn't very robust; it assumes that the user has indeed entered integers from 0 to 255 into the text fields. A better version of this would test to make sure that no data-entry errors had occurred (I was trying to keep this example 
small).</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now we'll convert the RGB values to HSB. There are standard algorithms
to convert an RGB-based color to an HSB color, but we don't have
to go look them up. The <TT>Color</TT>
class has a class method we can use called <TT>RGBtoHSB()</TT>
that will do the work for us-or, at least, most of it. There are
two problems with the <TT>RGBtoHSB()</TT>
method, however:
<UL>
<LI>The <TT>RGBtoHSB()</TT> method
returns an array of the three HSB values, so we'll have to extract
those values from the array.
<LI>The HSB values are measured in floating-point values from
<TT>0.0</TT> to <TT>1.0</TT>.
I prefer to think of HSB values as integers, where the hue is
a degree value around a color wheel (<TT>0</TT>
through <TT>360</TT>), and saturation
and brightness are percentages from <TT>0</TT>
to <TT>100</TT>.
</UL>
<P>
Neither of these problems is insurmountable; it just means some
extra lines of code. Let's start by calling <TT>RGBtoHSB()</TT>
with the new RGB values we have. The return type of that method
is an array of floats, so we'll create a local variable (<TT>HSB</TT>)
to store the results of the <TT>RBGtoHSB()</TT>
method. (Note that you'll also need to create and pass in an empty
array of floats as the fourth argument to <TT>RGBtoHSB()</TT>):
<BLOCKQUOTE>
<PRE>
float[] HSB = Color.RGBtoHSB(value1, value2, value3, (new float[3]));
</PRE>
</BLOCKQUOTE>
<P>
Now we'll convert those floating-point values that range from
<TT>0.0</TT> to <TT>1.0</TT>
to values that range from <TT>0</TT>
and <TT>100</TT> (for the saturation
and brightness) and <TT>0</TT> to
<TT>360</TT> for the hue by multiplying
the appropriate numbers and reassigning the value back to the
array:
<BLOCKQUOTE>
<PRE>
HSB[0] *= 360;
HSB[1] *= 100;
HSB[2] *= 100;
</PRE>
</BLOCKQUOTE>
<P>
Now we have the numbers we want. The last part of the update is
to put those values back into the text fields. Of course, those
values are still floating-point numbers, so we'll have to cast
them to <TT>int</TT>s before turning
them into strings and storing them:
<BLOCKQUOTE>
<PRE>
HSBcontrols.tfield1.setText(String.valueOf((int)HSB[0]));
HSBcontrols.tfield2.setText(String.valueOf((int)HSB[1]));
HSBcontrols.tfield3.setText(String.valueOf((int)HSB[2]));
</PRE>
</BLOCKQUOTE>
<P>
You're halfway there. The next part of the applet is that part
that updates the RGB values where a text field on the HSB side
has changed. This is the <TT>else</TT>
in the big <TT>if</TT>-<TT>else</TT>
that defines this method and determines what to update, given
a change.
<P>
It's actually easier to generate values from HSB values than it
is to do it the other way around. There's a class method in the
<TT>Color</TT> class, called <TT>getHSBColor()</TT>,
that creates a new <TT>Color</TT>
object from three HSB values, and once you have a <TT>Color</TT>
object you can easily pull the RGB values out of there. The catch,
of course, is that <TT>getHSBColor</TT>
takes three floating-point arguments, and the values we have are
the integer values I prefer to use. So in the call to <TT>getHSBColor</TT>,
we'll have to cast the integer values from the text fields to
floats and divide them by the proper conversion factor. The result
of <TT>getHSBColor</TT> is a <TT>Color</TT>
object, so we can simply assign that object to our <TT>c</TT>
local variable so we can use it again later:
<BLOCKQUOTE>
<PRE>
c = Color.getHSBColor((float)value1 / 360, 
    (float)value2 / 100, (float)value3 / 100);
</PRE>
</BLOCKQUOTE>
<P>
With the <TT>Color</TT> object all
set, updating the RGB values involves extracting those values
from that <TT>Color</TT> object. The
<TT>getRed()</TT>, <TT>getGreen()</TT>
and <TT>getBlue()</TT> methods, defined
in the <TT>Color</TT> class, will
do just that:
<BLOCKQUOTE>
<PRE>
RGBcontrols.tfield1.setText(String.valueOf(c.getRed()));
RGBcontrols.tfield2.setText(String.valueOf(c.getGreen()));
RGBcontrols.tfield3.setText(String.valueOf(c.getBlue()));
</PRE>
</BLOCKQUOTE>
<P>
And finally, regardless of whether the RGB or HSB value has changed,
you'll need to update the color box on the left to reflect the
new color. Because we have a new <TT>Color</TT>
object stored in the variable <TT>c</TT>,
we can use the <TT>setBackground</TT>
method to change that color. Also note that <TT>setBackground</TT>
doesn't automatically repaint the screen, so you'll want to fire
off a <TT>repaint()</TT> as well:
<BLOCKQUOTE>
<PRE>
swatch.setBackground(c);
swatch.repaint();
</PRE>
</BLOCKQUOTE>
<P>
That's it! You're done. Compile both the <TT>ColorTest</TT>
and <TT>ColorControls</TT> classes,
create an HTML file to load the <TT>ColorTest</TT>
applet, and check it out.
<H3><A NAME="TheCompleteSourceCode">
The Complete Source Code</A></H3>
<P>
Listing 13.3 shows the complete source code for the applet class
<TT>ColorTest</TT>, and Listing 13.4
shows the source for the helper class <TT>ColorControls</TT>.
Often it's easier to figure out what's going on in an applet when
it's all in one place and you can follow the method calls and
how values are passed back and forth. Start with the <TT>init()</TT>
method in the <TT>ColorTest</TT> applet
and go from there.
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. The </B><TT><B>ColorTest</B></TT><B>
applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.awt.*;
 2:
 3:public class ColorTest extends java.applet.Applet {
 4:  ColorControls RGBcontrols, HSBcontrols;
 5:  Canvas swatch;
 6:
 7:  public void init() {   
 8:    setLayout(new GridLayout(1,3,5,15));
 9:    
10:    // The color swatch
11:    swatch = new Canvas();
12:    swatch.setBackground(Color.black);
13:    
14:    // the subpanels for the controls
15:    RGBcontrols = new ColorControls(this, &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;);
16:    HSBcontrols = new ColorControls(this, &quot;Hue&quot;, &quot;Saturation&quot;, &quot;Brightness&quot;);
17:
18:    //add it all to the layout
19:    add(swatch);
20:    add(RGBcontrols);
21:    add(HSBcontrols);
22:  }
23:
24:  public Insets insets() {
25:    return new Insets(10,10,10,10);
26:  }
27:
28:  void update(ColorControls controlPanel) {
29:    Color c;
30:    // get string values from text fields, convert to ints
31:    int value1 = Integer.parseInt(controlPanel.tfield1.getText());
32:    int value2 = Integer.parseInt(controlPanel.tfield2.getText());
33:    int value3 = Integer.parseInt(controlPanel.tfield3.getText());
34:
35:    if (controlPanel == RGBcontrols) {  // RGB has changed, update HSB
36:      c = new Color(value1, value2, value3);
37:
38:      // convert RGB values to HSB values
39:      float[] HSB = Color.RGBtoHSB(value1, value2, value3, (new float[3]));
40:      HSB[0] *= 360;
41:      HSB[1] *= 100;
42:      HSB[2] *= 100;
43:
44:      // reset HSB fields
45:      HSBcontrols.tfield1.setText(String.valueOf((int)HSB[0]));
46:      HSBcontrols.tfield2.setText(String.valueOf((int)HSB[1]));
47:      HSBcontrols.tfield3.setText(String.valueOf((int)HSB[2]));
48:   
49:    } else {  // HSB has changed, update RGB
50:      c = Color.getHSBColor((float)value1 / 360, 
51:        (float)value2 / 100, (float)value3 / 100);
52:
53:      // reset RGB fields
54:      RGBcontrols.tfield1.setText(String.valueOf(c.getRed()));
55:      RGBcontrols.tfield2.setText(String.valueOf(c.getGreen()));
56:      RGBcontrols.tfield3.setText(String.valueOf(c.getBlue()));
57:    }
58:
59:    //update swatch
60:    swatch.setBackground(c);
61: swatch.repaint();
62:}
63:}
</PRE>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 13.4. The </B><TT><B>ColorControls</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.awt.*;
 2:
 3:class ColorControls extends Panel {
 4:  TextField tfield1, tfield2, tfield3;
 5:  ColorTest applet;
 6:
 7:  ColorControls(ColorTest parent,
 8:        String l1, String l2, String l3) {
 9:
10:    // get hook to outer applet parent
11:    applet = parent;
12:
13:    //do layouts
14:    setLayout(new GridLayout(3,2,10,10));
15:    
16:    tfield1 = new TextField(&quot;0&quot;);
17:    tfield2 = new TextField(&quot;0&quot;);    
18:    tfield3 = new TextField(&quot;0&quot;);    
19:
20:    add(new Label(l1, Label.RIGHT));
21:    add(tfield1);
22:    add(new Label(l2, Label.RIGHT));
23:    add(tfield2);
24:    add(new Label(l3, Label.RIGHT));
25:    add(tfield3);
26:  }
27: 
28: public Insets insets() {
29:    return new Insets(10,10,0,0);
30:  }
31:
32:  public boolean action(Event evt, Object arg) {
33:    if (evt.target instanceof TextField) {
34:      applet.update(this);
35:      return true;
36:    } else return false;
37:  }
38:}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="UpandCominginJava"><FONT SIZE=5 COLOR=#FF0000>
Up and Coming in Java 1.1</FONT></A></H2>
<P>
Everything you've learned up to this point is available in the
1.0.2 Java API. Java 1.1, however, will add many more features
to the awt, as well as improve performance and robustness across
platforms. The goal for the awt is to move beyond the basics that
1.0.2 provided and make the awt more suitable for large-scale
application development. Note, also, that the 1.1 API will be
backward-compatible with the 1.0.2 features; none of the code
you write after reading this chapter will be obsolete in 1.1.
<P>
Explicit details about the changes to the awt for 1.1 were not
available at the time this book was being written. Sun has announced
the following teasers, however for new features in 1.1:
<UL>
<LI>New components for pop-up menus, buttons with images on top
of them, and menu accelerators
<LI>Support for clipboard operations (copy and paste), drag and
drop, and printing
<LI>The ability to set a cursor for each component (currently
you can have only one cursor per window; you'll learn about this
on <A HREF="ch14.htm">Day 14</A>, &quot;Windows, Networking, and Other Tidbits&quot;)
<LI>A new set of graphics primitives as part of the new 2D graphics
model; you'll learn more about this on <A HREF="ch27.htm">Day 27</A>, &quot;The Standard
Extension APIs&quot;
<LI>A new event model that delegates event actions to other objects,
as opposed to requiring special methods (<TT>mouseDown()</TT>,
<TT>action()</TT>, <TT>handleEvent()</TT>,
and so on) to be overridden in the component classes themselves.
Those action objects are often called callbacks in other event-driven
programming systems.
<LI>Performance enhancements: a complete rewrite for Windows 95
and NT, improvements in how components are laid out and painted,
better scrolling of components, and a &quot;number of bug fixes.&quot;
</UL>
<P>
For more information about the Java 1.1 changes to the awt, check
out the 1.1 preview page at <TT><A HREF="http://java.sun.com/products/JDK/1.1/designspecs/">http://java.sun.com/products/JDK/1.1/designspecs/</A></TT>.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
The Java awt, or Abstract Windowing Toolkit, is a package of Java
classes and interfaces for creating full-fledged access to a window-based
graphical user interface system, with mechanisms for graphics
display, event management, text and graphics primitives, user-interface
components, and cross-platform layout. Applets are also an integral
part of the awt.
<P>
Today has been a big day; the lesson has brought together everything
you've learned up to this point about simple applet management
and added a lot more about creating applets, panels, and user-interface
components and managing the interactions between all of them.
With the information you got today and the few bits you'll learn
tomorrow, you can create cross-platform Java applications that
do just about anything you want.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I really dislike working with layout managers; they're either too simplistic or too complicated (grid bag layout). Even with a whole lot of tinkering, I can never get my applets to look like 
I want them to. All I want to do is define the sizes of my components and put them at an x and y position on the screen. Can I do this?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>I'm going to tell you how to do this, but not without a lecture.<BR>
Java applications and the awt were designed such that the same graphical user interface could run equally well on different platforms and with different resolutions, different fonts, different screen sizes, and so on. Relying on pixel coordinates in this 
case is a really bad idea; variations from one platform to another or even from one Java environment to another on the same platform can mess up your careful layouts such that you can easily have components overlapping or obscuring each other, the edges of 
your applet cut off, or other layout disasters. Just as an example-I found significant differences in the layout of the same applet running in the JDK's <TT>appletviewer</TT> and in Netscape, both on Windows 95, side by side. Can you guarantee that your 
applet will always be run in precisely the same environment as the one in which you designed it? Layout managers, by dynamically placing elements on the screen, get around these problems. This does mean that your applet may end up looking not quite right 
on any platform-but at least it's usable on any platform. New versions of the awt promise to offer better layout and UI design controls.<BR>
Still not convinced? Well, then. To make a component a specific size and to place it at a particular position, use a null layout manager and the <TT>reshape()</TT> method:
<P>
<TT>setLayout(null);<BR>
Button myButton (new Button(&quot;OK&quot;);<BR>
mybutton.reshape(10, 10, 30, 15);</TT>
<P>
You can find out more about <TT>reshape()</TT> in the <TT>Component</TT> class.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I was exploring the awt classes, and I saw this subpackage called <TT><B>peer</B></TT>. There are also references to the peer classes sprinkled throughout the API documentation. What do 
peers do?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Peers are responsible for the platform-specific parts of the awt. For example, when you create a Java awt window, you have an instance of the <TT>Window</TT> class that provides generic window 
behavior, and then you have an instance of a class implementing <TT>WindowPeer</TT> that creates the very specific window for that platform-a motif window under X Window, a Macintosh-style window under the Macintosh, or a Windows 95 window under Windows 
95. These &quot;peer&quot; classes also handle communication between the window system and the Java window itself. By separating the generic component behavior (the awt classes) from the actual system implementation and appearance (the peer classes), you 
can focus on providing behavior in your Java application and let the Java implementation deal with the platform-specific details.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>There's a whole lot of functionality in the awt that you haven't talked about here. Why?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Given that even a basic introduction took this long, I figured that if I put in even more detail than I already have, this book would turn into Teach Yourself Java in 21 Days Plus a Few Extra 
for the awt Stuff.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=55><CENTER><B>&nbsp;</B></CENTER></TD><TD>As it is, I've left windows, menus, and dialog boxes until tomorrow, so you'll have to wait for those. But you can find out about a lot of the other features of awt merely by exploring the 
API documentation. Start with the <TT>Applet</TT> class and examine the sorts of methods you can call. Then look at <TT>Panel</TT>, from which <TT>Applet</TT> inherits-you have all that class's functionality as well. The superclass of <TT>Panel</TT> is 
<TT>Container</TT>, which provides still more interesting detail. <TT>Component</TT> comes next. Explore the API and see what you can do with it. You might find something interesting.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I have a new button class I defined to look different from the standard awt button objects. I'd like to implement callbacks on this button (that is, to execute an arbitrary function when the 
button is pressed), but I can't figure out how to get Java to execute an arbitrary method. In C++ I'd just have a pointer to a function. In Smalltalk I'd use <TT><B>perform:</B></TT>. How can I do this in Java?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>You can't; Java doesn't have this facility. This is why normal button actions are executed from the generic <TT>action()</TT> method rather than using a mechanism for actions attached to the 
button itself (which would be more object-oriented, easier to extend, and wouldn't require a whole lot of <TT>if...else</TT>s inside <TT>action()</TT>).
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch12.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch14.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
