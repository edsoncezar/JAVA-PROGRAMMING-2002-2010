<HTML>
<HEAD>
<TITLE>Day 12 -- Managing Simple Events and Interactivity
</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;12</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Managing Simple Events and Interactivity</FONT>
</H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#MouseClicks">
Mouse Clicks</A>
<UL>
<LI><A HREF="#MouseDownandMouseUpEvents">
Mouse Down and Mouse Up Events</A>
<LI><A HREF="#AnExampleSpots">
An Example: Spots</A>
<LI><A HREF="#DoubleClicks">
Double-Clicks</A>
</UL>
<LI><A HREF="#MouseMovements">
Mouse Movements</A>
<UL>
<LI><A HREF="#MouseDragandMouseMoveEvents">
Mouse Drag and Mouse Move Events</A>
<LI><A HREF="#MouseEnterandMouseExitEvents">
Mouse Enter and Mouse Exit Events</A>
<LI><A HREF="#AnExampleDrawingLines">
An Example: Drawing Lines</A>
<LI><A HREF="#KeyboardEvents">
Keyboard Events</A>
<LI><A HREF="#TheTTFONTSIZEFACECourierkeyDownFONTTTFONTSIZEandFONTTTFONTSIZEFACECourierkeyUpFONTTTFONTSIZEMethodsFONT">
The <TT>keyDown()</TT>
and </FONT><TT>keyUp()</TT>
Methods</FONT></A>
<LI><A HREF="#DefaultKeys">
Default Keys</A>
<LI><A HREF="#AnExampleEnteringDisplayingandMovingCharacters">
An Example: Entering, Displaying, and Moving Characters</A>
<LI><A HREF="#TestingforModifierKeysandMultipleMouseButtons">
Testing for Modifier Keys and Multiple Mouse Buttons</A>
</UL>
<LI><A HREF="#TheawtEventHandler">
The awt Event Handler</A>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Java events are part of the Java awt (Abstract Windowing Toolkit)
package. An event is the way that the awt communicates to you,
as the programmer, and to other Java awt components that <I>something</I>
has happened. That something can be input from the user (mouse
movements or clicks, keypresses), changes in the system environment
(a window opening or closing, the window being scrolled up or
down), or a host of other things that might, in some way, affect
the operation of the program.
<P>
In other words, whenever just about anything happens to a Java
awt component, including an applet, an event is generated. Some
events are handled by the awt or by the environment your applet
is running in (the browser) without you needing to do anything.
<TT>paint()</TT> methods, for example,
are generated and handled by the environment-all you have to do
is tell the awt what you want painted when it gets to your part
of the window. However, you may need to know about some events,
such as a mouse click inside the boundaries of your applet. By
writing your Java programs to handle these kinds of events, you
can get input from the user and have your applet change its behavior
based on that input.
<P>
Today you'll learn about managing simple events, including the
following basics:
<UL>
<LI>Mouse clicks
<LI>Mouse movements, including mouse dragging
<LI>Keyboard actions
</UL>
<P>
You'll also learn about the <TT>handleEvent()</TT>
method, which is the basis for collecting, handling, and passing
on events of all kinds from your applet to other components of
the window or of your applet itself. Tomorrow you'll learn how
to combine events with other awt components to create a complete
interface for your applet.
<H2><A NAME="MouseClicks"><FONT SIZE=5 COLOR=#FF0000>
Mouse Clicks</FONT></A></H2>
<P>
Let's start with the most common event you might be interested
in: mouse clicks. Mouse-click events occur when your user clicks
the mouse somewhere in the body of your applet. You can intercept
mouse clicks to do very simple things-for example, to toggle the
sound on and off in your applet, to move to the next slide in
a presentation, or to clear the screen and start over-or you can
use mouse clicks in conjunction with mouse movements to perform
more complex motions inside your applet.
<H3><A NAME="MouseDownandMouseUpEvents">
Mouse Down and Mouse Up Events</A></H3>
<P>
When you click the mouse once, the awt generates two events: a
mouse down event when the mouse button is pressed and a mouse
up event when the button is released. Why two individual events
for a single mouse action? Because you may want to do different
things for the &quot;down&quot; and the &quot;up.&quot; For example,
look at a pull-down menu. The mouse down extends the menu, and
the mouse up selects an item (with mouse drags between-but you'll
learn about that one later). If you have only one event for both
actions (mouse up and mouse down), you cannot implement that sort
of user interaction.
<P>
Handling mouse events in your applet is easy-all you have to do
is override the right method definition in your applet. That method
will be called when that particular event occurs. Here's an example
of the method signature for a mouse down event:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y) {
...
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>mouseDown()</TT> method (and
the <TT>mouseUp()</TT> method as well)
takes three parameters: the event itself and the x and y coordinates
where the mouse down or mouse up event occurred.
<P>
The <TT>evt</TT> argument is an instance
of the class <TT>Event</TT>. All system
events generate an instance of the <TT>Event</TT>
class, which contains information about where and when the event
took place, the kind of event it is, and other information that
you might want to know about this event. Sometimes having a handle
to that <TT>Event</TT> object is useful,
as you'll discover later in this section.
<P>
The x and the y coordinates of the event, as passed in through
the <TT>x</TT> and <TT>y</TT>
arguments to the <TT>mouseDown()</TT>
method, are particularly nice to know because you can use them
to determine precisely where the mouse click took place. So, for
example, if the mouse down event were over a graphical button,
you could activate that button.
<P>
For example, here's a simple method that prints out information
about a mouse down when it occurs:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y) {
    System.out.println(&quot;Mouse down at &quot; + x + &quot;,&quot; + y);
    return true;
</PRE>
</BLOCKQUOTE>
<P>
By including this method in your applet, every time your user
clicks the mouse inside your applet, this message will get printed.
The awt system calls each of these methods when the actual event
takes place.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Unlike with Java applications, where <TT>System.out.println()</TT> outputs to the screen, the output that appears in applets varies from system to system and browser to browser. Netscape has a special window called the <I>Java console</I> that must be 
visible for you to see the output. Internet Explorer logs Java output to a separate file. Check with your environment to see where Java output from applets is sent.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Note that this method, unlike the other system methods you've
studied this far, returns a boolean value instead of not returning
anything (<TT>void</TT>). This will
become important tomorrow when you create user interfaces and
then manage input to these interfaces; having an event handler
method return <TT>true</TT> or <TT>false</TT>
determines whether a given component can intercept an event or
whether it needs to pass it on to the enclosing component. The
general rule is that if your method intercepts and does something
with the event, it should return <TT>true</TT>.
If for any reason the method doesn't do anything with that event,
it should return <TT>false</TT> so
that other components in the system can have a chance to see that
event. In most of the examples in today's lesson, you'll be intercepting
simple events, so most of the methods here will return <TT>true</TT>.
Tomorrow you'll learn about nesting components and passing events
up the component hierarchy.
<P>
The second half of the mouse click is the <TT>mouseUp()</TT>
method, which is called when the mouse button is released. To
handle a mouse up event, add the <TT>mouseUp()</TT>
method to your applet: <TT>mouseUp()</TT>
looks just like <TT>mouseDown()</TT>:
<BLOCKQUOTE>
<PRE>
public boolean mouseUp(Event evt, int x, int y) {
    ....
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="AnExampleSpots">
An Example: Spots</A></H3>
<P>
In this section you'll create an example of an applet that uses
mouse events-mouse down events in particular. The Spots applet
starts with a blank screen and then sits and waits. When you click
the mouse on that screen, a blue dot is drawn. You can place up
to 10 dots on the screen. Figure 12.1 shows the Spots applet.
<P>
<A HREF="http://docs.rinet.ru/J21/f12-1.gif"><B>Figure 12.1 : </B><I>The Spots applet</I>.</A>
<P>
Let's start from the beginning and build this applet, starting
from the initial class definition:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Event;

public class Spots extends java.applet.Applet {

    final int MAXSPOTS = 10;
    int xspots[] = new int[MAXSPOTS];
    int yspots[] = new int[MAXSPOTS];
    int currspots = 0;

}
</PRE>
</BLOCKQUOTE>
<P>
This class uses three other awt classes: <TT>Graphics</TT>,
<TT>Color</TT>, and <TT>Event</TT>.
That last class, <TT>Event</TT>, needs
to be imported in any applets that use events. The class has four
instance variables: a constant to determine the maximum number
of spots that can be drawn, two arrays to store the x and y coordinates
of the spots that have already been drawn, and an integer to keep
track of the number of the current spot.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This class doesn't include the <TT>implements Runnable</TT> words in its definition. As you'll see later as you build this applet, it also doesn't have a <TT>run()</TT> method. Why not? Because it doesn't actually do anything on its own-all it does is wait 
for input and then do stuff when input happens. There's no need for threads if your applet isn't actively doing something all the time.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Let's start by adding the <TT>init()</TT>
method, which does only one thing: set the background color to
<TT>white</TT>:
<BLOCKQUOTE>
<PRE>
public void init() {
    setBackground(Color.white);
}
</PRE>
</BLOCKQUOTE>
<P>
We've set the background here in <TT>init()</TT>
instead of in <TT>paint()</TT> as
you have in past examples because you need to set the background
only once. Because <TT>paint()</TT>
is called repeatedly each time a new spot is added, setting the
background in the <TT>paint()</TT>
method unnecessarily slows down that method. Putting it here is
a much better idea.
<P>
The main action of this applet occurs with the <TT>mouseDown()</TT>
method, so let's add that one now:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y) {
    if (currspots &lt; MAXSPOTS) {
        addspot(x,y);
        return true;
    }
    else {
       System.out.println(&quot;Too many spots.&quot;);
       return false;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
When the mouse click occurs, the <TT>mouseDown()</TT>
method tests to see whether there are fewer than 10 spots. If
so, it calls the <TT>addspot()</TT>
method (which you'll write soon) and returns <TT>true</TT>
(the mouse down event was intercepted and handled). If not, it
just prints an error message and returns <TT>false</TT>.
<P>
What does <TT>addspot()</TT> do? It
adds the coordinates of the spot to the arrays that store the
coordinates, increments the <TT>currspots</TT>
variable, and then calls <TT>repaint()</TT>:
<BLOCKQUOTE>
<PRE>
void addspot(int x, int y) {
    xspots[currspots] = x;
    yspots[currspots] = y;
    currspots++;
    repaint();
}
</PRE>
</BLOCKQUOTE>
<P>
You may be wondering why you have to keep track of all the past
spots in addition to the current spot. It's because of <TT>repaint()</TT>:
Each time you paint the screen, you have to paint all the old
spots in addition to the newest spot. Otherwise, each time you
painted a new spot, the older spots would get erased. Now, on
to the <TT>paint()</TT> method:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {
    g.setColor(Color.blue);
    for (int i = 0; i &lt; currspots; i++) {
        g.fillOval(xspots[i] -10, yspots[i] - 10, 20, 20);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Inside <TT>paint()</TT>, you just
loop through the spots you've stored in the <TT>xspots</TT>
and <TT>yspots</TT> arrays, painting
each one (actually, painting them a little to the right and upward
so that the spot is painted around the mouse pointer rather than
below and to the right).
<P>
That's it! That's all you need to create an applet that handles
mouse clicks. Everything else is handled for you. You have to
add the appropriate behavior to <TT>mouseDown()</TT>
or <TT>mouseUp()</TT> to intercept
and handle that event. Listing 12.1 shows the full text for the
Spots applet.
<HR>
<BLOCKQUOTE>
<B>Listing 12.1. The Spots applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Color;
 3: import java.awt.Event;
 4:
 5: public class Spots extends java.applet.Applet {
 6:
 7:     final int MAXSPOTS = 10;
 8:     int xspots[] = new int[MAXSPOTS];
 9:     int yspots[] = new int[MAXSPOTS];
10:     int currspots = 0;
11:
12:     public void init() {
13:         setBackground(Color.white);
14:     }
15:
16:     public boolean mouseDown(Event evt, int x, int y) {
17:         if (currspots &lt; MAXSPOTS) {
18:             addspot(x,y);
19:             return true;
20:         }
21:         else {
22:            System.out.println(&quot;Too many spots.&quot;);
23:            return false;
24:         }
25:     }
26: 
27:     void addspot(int x,int y) {
28:          xspots[currspots] = x;
29:          yspots[currspots] = y;
30:          currspots++;
31:          repaint();
32:     }
33:     
34:     public void paint(Graphics g) {
35:         g.setColor(Color.blue);
36:         for (int i = 0; i &lt; currspots; i++) {
37:               g.fillOval(xspots[i] - 10, yspots[i] - 10, 20, 20);
38:        }
39:     }
40: }
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="DoubleClicks">
Double-Clicks</A></H3>
<P>
What if the mouse event you're interested in is more than a single
mouse click-what if you want to track double- or triple-clicks?
The Java <TT>Event</TT> class provides
a variable for tracking this information, called <TT>clickCount</TT>.
<TT>clickCount</TT> is an integer
representing the number of consecutive mouse clicks that have
occurred (where &quot;consecutive&quot; is usually determined
by the operating system or the mouse hardware). If you're interested
in multiple mouse clicks in your applets, you can test this value
in the body of your <TT>mouseDown()</TT>
method, like this:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y) {
    switch (evt.clickCount) {
      case 1:  // single-click
      case 2:  // double-click
      case 3:  // triple-click
      ....
    }
}
</PRE>
</BLOCKQUOTE>
<H2><A NAME="MouseMovements"><FONT SIZE=5 COLOR=#FF0000>
Mouse Movements</FONT></A></H2>
<P>
Every time the mouse is moved a single pixel in any direction,
a mouse move event is generated. There are two mouse movement
events: mouse drags, where the movement occurs with the mouse
button pressed down, and plain mouse movements, where the mouse
button isn't pressed.
<P>
To manage mouse movement events, use the <TT>mouseDrag()</TT>
and <TT>mouseMove()</TT> methods.
<H3><A NAME="MouseDragandMouseMoveEvents">
Mouse Drag and Mouse Move Events</A></H3>
<P>
The <TT>mouseDrag()</TT> and <TT>mouseMove()</TT>
methods, when included in your applet code, intercept and handle
mouse movement events. Mouse move and move drag events are generated
for every pixel change the mouse moves, so a mouse movement from
one side of the applet to the other may generate hundreds of events.
The <TT>mouseMove()</TT> method, for
plain mouse pointer movements without the mouse button pressed,
looks much like the mouse-click methods:
<BLOCKQUOTE>
<PRE>
public boolean mouseMove(Event evt, int x, int y) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>mouseDrag()</TT> method handles
mouse movements made with the mouse button pressed down (a complete
dragging movement consists of a mouse down event, a series of
mouse drag events for each pixel the mouse is moved, and a mouse
up when the button is released). The <TT>mouseDrag()</TT>
method looks like this:
<BLOCKQUOTE>
<PRE>
public boolean mouseDrag(Event evt, int x, int y) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
Note that for both the <TT>mouseMove()</TT>
and <TT>mouseDrag()</TT> methods,
the arguments for the x and y coordinates are the new location
of the mouse, not its starting location.
<H3><A NAME="MouseEnterandMouseExitEvents">
Mouse Enter and Mouse Exit Events</A></H3>
<P>
Finally, there are the <TT>mouseEnter() </TT>and
<TT>mouseExit()</TT> methods. These
two methods are called when the mouse pointer enters or exits
an applet or a portion of that applet. (In case you're wondering
why you might need to know this, it's more useful on awt components
that you might put inside an applet. You'll learn more about the
awt tomorrow.)
<P>
Both <TT>mouseEnter()</TT> and <TT>mouseExit()</TT>
have signatures similar to the mouse click methods-three arguments:
the event object and the x and y coordinates of the point where
the mouse entered or exited the applet. These examples show the
signatures for <TT>mouseEnter()</TT>
and <TT>mouseExit():</TT>
<BLOCKQUOTE>
<PRE>
public boolean mouseEnter(Event evt, int x, int y) {
    ...
}

public boolean mouseExit(Event evt, int x, int y) {
    ...
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="AnExampleDrawingLines">
An Example: Drawing Lines</A></H3>
<P>
Examples always help to make concepts more concrete. In this section
you'll create an applet that enables you to draw straight lines
on the screen by dragging from the startpoint to the endpoint.
Figure 12.2 shows the applet at work.
<P>
<A HREF="http://docs.rinet.ru/J21/f12-2.gif"><B>Figure 12.2 : </B><I>Drawing lines</I>.</A>
<P>
As with the Spots applet (on which this applet is based), let's
start with the basic definition and work our way through it, adding
the appropriate methods to build the applet. Here's a simple class
definition for the Lines applet, with a number of initial instance
variables and a simple <TT>init()</TT>
method:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Event;
import java.awt.Point;

public class Lines extends java.applet.Applet {

    final int MAXLINES = 10;
    Point starts[] = new Point[MAXLINES]; // starting points
    Point ends[] = new Point[MAXLINES];    // ending points
    Point anchor;    // start of current line
    Point currentpoint; // current end of line
    int currline = 0; // number of lines

    public void init() {
        setBackground(Color.white);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This applet adds a few more things than Spots. Unlike Spots, which
keeps track of individual integer coordinates, this one keeps
track of <TT>Point</TT> objects. Points
represent an x and a y coordinate, encapsulated in a single object.
To deal with points, you import the <TT>Point</TT>
class and set up a bunch of instance variables that hold points:
<UL>
<LI>The <TT>starts</TT> array holds
points representing the starts of lines already drawn.
<LI>The <TT>ends</TT> array holds
the endpoints of those same lines.
<LI><TT>anchor</TT> holds the starting
point of the line currently being drawn.
<LI><TT>currentpoint</TT> holds the
current endpoint of the line currently being drawn.
<LI><TT>currline</TT> holds the current
number of lines (to make sure you don't go over <TT>MAXLINES</TT>,
and to keep track of which line in the array to access next).
</UL>
<P>
Finally, the <TT>init()</TT> method,
as in the Spots applet, sets the background of the applet to <TT>white</TT>.
<P>
The three main events this applet deals with are <TT>mouseDown()</TT>,
to set the anchor point for the current line, <TT>mouseDrag()</TT>,
to animate the current line as it's being drawn, and <TT>mouseUp()</TT>,
to set the ending point for the new line. Given that you have
instance variables to hold each of these values, it's merely a
matter of plugging the right variables into the right methods.
Here's <TT>mouseDown()</TT>, which
sets the anchor point (but only if we haven't exceeded the maximum
number of lines):
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y) {
   if (currline &lt; MAXLINES) {
       anchor = new Point(x,y);
       return true;
  }
   else  {
      System.out.println(&quot;Too many lines.&quot;);
      return false;
   }
}
</PRE>
</BLOCKQUOTE>
<P>
While the mouse is being dragged to draw the line, the applet
animates the line being drawn. As you drag the mouse around, the
new line moves with it from the anchor point to the tip of the
mouse. The <TT>mouseDrag()</TT> event
contains the current point each time the mouse moves, so use that
method to keep track of the current point (and to repaint for
each movement so the line &quot;animates&quot;). Note that if
we've exceeded the maximum number of lines, we won't want to do
any of this. Here's the<TT> mouseDrag()</TT>
method to do all those things:
<BLOCKQUOTE>
<PRE>
public boolean mouseDrag(Event evt, int x, int y) {
   if (currline &lt; MAXLINES) {
       currentpoint = new Point(x,y);
       repaint();
       return true;
    }
   else return false;
}
</PRE>
</BLOCKQUOTE>
<P>
The new line doesn't get added to the arrays of old lines until
the mouse button is released. Here's <TT>mouseUp()</TT>,
which tests to make sure you haven't exceeded the maximum number
of lines before calling the <TT>addline()</TT>
method (described next):
<BLOCKQUOTE>
<PRE>
public boolean mouseUp(Event evt, int x, int y) {
     if (currline &lt; MAXLINES) {
         addline(x,y);
         return true;
     }
     else return false;
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>addline()</TT> method is where
the arrays of starting and ending points get updated and where
the applet is repainted to take the new line into effect:
<BLOCKQUOTE>
<PRE>
void addline(int x,int y) {
    starts[currline] = anchor;
    ends[currline] = new Point(x,y);
    currline++;
    currentpoint = null;
    anchor = null;
    repaint();
}
</PRE>
</BLOCKQUOTE>
<P>
Note that in this method you also set <TT>currentpoint</TT>
and <TT>anchor</TT> to <TT>null</TT>.
Why? Because the current line you were drawing is over. By setting
these variables<TT> </TT>to <TT>null</TT>,
you can test for that value in the <TT>paint()</TT>
method to see whether you need to draw a current line.
<P>
Painting the applet means drawing all the old lines stored in
the <TT>starts</TT> and <TT>ends</TT>
arrays, as well as drawing the current line in progress (whose
endpoints are in <TT>anchor</TT> and
<TT>currentpoint</TT>, respectively).
To show the animation of the current line, draw it in blue. Here's
the <TT>paint()</TT> method for the
Lines applet:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {

    // Draw existing lines
    for (int i = 0; i &lt; currline; i++) {
        g.drawLine(starts[i].x, starts[i].y,
            ends[i].x, ends[i].y);
    }

    // Draw current line
    g.setColor(Color.blue);
    if (currentpoint != null)
        g.drawLine(anchor.x, anchor.y,
            currentpoint.x, currentpoint.y);
}
</PRE>
</BLOCKQUOTE>
<P>
In <TT>paint()</TT>, when you're drawing
the current line, you test first to see whether <TT>currentpoint</TT>
is <TT>null</TT>. If it is, the applet
isn't in the middle of drawing a line, so there's no reason to
try drawing a line that doesn't exist. By testing for <TT>currentpoint</TT>
(and by setting <TT>currentpoint</TT>
to <TT>null</TT> in the <TT>addline()</TT>
method), you can paint only what you need.
<P>
That's it-just 60 lines of code and a few basic methods, and you
have a very basic drawing application in your Web browser. Listing
12.2 shows the full text of the Lines applet so that you can put
the pieces together.
<HR>
<BLOCKQUOTE>
<B>Listing 12.2. The Lines applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Color;
 3: import java.awt.Event;
 4: import java.awt.Point;
 5:
 6: public class Lines extends java.applet.Applet {
 7:
 8:     final int MAXLINES = 10;
 9:     Point starts[] = new Point[MAXLINES]; // starting points
10:     Point ends[] = new Point[MAXLINES];    // endingpoints
11:     Point anchor;    // start of current line
12:     Point currentpoint; // current end of line
13:     int currline = 0; // number of lines
14:
15:     public void init() {
16:         setBackground(Color.white);
17:     }
18:
19:     public boolean mouseDown(Event evt, int x, int y) {
20:        if (currline &lt; MAXLINES) {
21:            anchor = new Point(x,y);
22:            return true;
23:       }
24:        else  {
25:           System.out.println(&quot;Too many lines.&quot;);
26:           return false;
27:        }
28:     }
29: 
30:    public boolean mouseUp(Event evt, int x, int y) {
31:         if (currline &lt; MAXLINES) {
32:             addline(x,y);
33:             return true;
34:         }
35:         else return false;
36:    }
37: 
38:     public boolean mouseDrag(Event evt, int x, int y) {
39:        if (currline &lt; MAXLINES) {
40:            currentpoint = new Point(x,y);
41:            repaint();
42:            return true;
43:         }
44:        else return false;
45:     }
46:
47:     void addline(int x,int y) {
48:         starts[currline] = anchor;
49:         ends[currline] = new Point(x,y);
50:         currline++;
51:         currentpoint = null;
52:         anchor = null;
53:         repaint();
54:     }
55: 
56:     public void paint(Graphics g) {
57: 
58:         // Draw existing lines
59:         for (int i = 0; i &lt; currline; i++) {
50:             g.drawLine(starts[i].x, starts[i].y,
51:                  ends[i].x, ends[i].y);
52:         }
53: 
54:         // draw current line
55:         g.setColor(Color.blue);
56:         if (currentpoint != null)
57:             g.drawLine(anchor.x,anchor.y,
58:             currentpoint.x,currentpoint.y);
59:     }
60:}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="KeyboardEvents">
Keyboard Events</A></H3>
<P>
A keyboard event is generated whenever a user presses a key on
the keyboard. By using keyboard events, you can get hold of the
values of the keys the user pressed to perform an action or merely
to get character input from the users of your applet.
<H3><A NAME="TheTTFONTSIZEFACECourierkeyDownFONTTTFONTSIZEandFONTTTFONTSIZEFACECourierkeyUpFONTTTFONTSIZEMethodsFONT">
The <TT>keyDown()</TT>
and </FONT><TT>keyUp()</TT>
Methods</FONT></A></H3>
<P>
To capture a keyboard event, use the <TT>keyDown()</TT>
method:
<BLOCKQUOTE>
<PRE>
public boolean keyDown(Event evt, int key) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
The keys generated by key down events (and passed into <TT>keyDown()</TT>
as the <TT>key</TT> argument) are
integers representing Unicode character values, which include
alphanumeric characters, function keys, tabs, returns, and so
on. To use them as characters (for example, to print them), you
need to cast them to characters:
<BLOCKQUOTE>
<PRE>
currentchar = (char)key;
</PRE>
</BLOCKQUOTE>
<P>
Here's a simple example of a <TT>keyDown()</TT>
method that does nothing but print the key you just typed in both
its Unicode and character representation (it can be fun to see
which key characters produce which values):
<BLOCKQUOTE>
<PRE>
public boolean keyDown(Event evt, int key) {
    System.out.println(&quot;ASCII value: &quot; + key);
    System.out.println(&quot;Character: &quot; + (char)key);
    return true;
}
</PRE>
</BLOCKQUOTE>
<P>
As with mouse clicks, each key down event also has a corresponding
key up event. To intercept key up events, use the <TT>keyUp()</TT>
method:
<BLOCKQUOTE>
<PRE>
public booklean keyUp(Event evt, int key)  {
   ...
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="DefaultKeys">
Default Keys</A></H3>
<P>
The <TT>Event</TT> class provides
a set of class variables that refer to several standard nonalphanumeric
keys, such as the arrow and function keys. If your applet's interface
uses these keys, you can provide more readable code by testing
for these names in your <TT>keyDown()</TT>
method rather than testing for their numeric values (and you're
also more likely to be cross-platform if you use these variables).
For example, to test whether the up arrow was pressed, you might
use the following snippet of code:
<BLOCKQUOTE>
<PRE>
if (key == Event.UP) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
Because the values these class variables hold are integers, you
also can use the <TT>switch</TT> statement
to test for them.
<P>
Table 12.1 shows the standard event class variables for various
keys and the actual keys they represent.<BR>
<P>
<CENTER><B>Table 12.1. Standard keys defined by the </B><TT><B>Event</B></TT><B>
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=199><B>Class Variable</B></TD><TD WIDTH=204><B>Represented Key</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.HOME</TT>
</TD><TD WIDTH=204>The Home key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.END</TT>
</TD><TD WIDTH=204>The End key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.PGUP</TT>
</TD><TD WIDTH=204>The Page Up key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.PGDN</TT>
</TD><TD WIDTH=204>The Page Down key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.UP</TT>
</TD><TD WIDTH=204>The up arrow</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.DOWN</TT>
</TD><TD WIDTH=204>The down arrow</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.LEFT</TT>
</TD><TD WIDTH=204>The left arrow</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.RIGHT</TT>
</TD><TD WIDTH=204>The right arrow</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f1</TT>
</TD><TD WIDTH=204>The f1 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f2</TT>
</TD><TD WIDTH=204>The f2 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f3</TT>
</TD><TD WIDTH=204>The f3 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f4</TT>
</TD><TD WIDTH=204>The f4 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f5</TT>
</TD><TD WIDTH=204>The f5 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f6</TT>
</TD><TD WIDTH=204>The f6 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f7</TT>
</TD><TD WIDTH=204>The f7 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f8</TT>
</TD><TD WIDTH=204>The f8 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f9</TT>
</TD><TD WIDTH=204>The f9 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f10</TT>
</TD><TD WIDTH=204>The f10 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f11</TT>
</TD><TD WIDTH=204>The f11 key</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>Event.f12</TT>
</TD><TD WIDTH=204>The f12 key</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="AnExampleEnteringDisplayingandMovingCharacters">
An Example: Entering, Displaying, and Moving Characters</A></H3>
<P>
Let's look at an applet that demonstrates keyboard events. With
this applet, you type a character, and that character is displayed
in the center of the applet window. You then can move that character
around on the screen with the arrow keys. Typing another character
at any time changes the character as it's currently displayed.
Figure 12.3 shows an example.
<P>
<A HREF="http://docs.rinet.ru/J21/f12-3.gif"><B>Figure 12.3 : </B><I>The Keys applet</I>.</A><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To get this applet to work, you might have to click once with the mouse on it in order for the keys to show up. This is to make sure the applet has the keyboard focus (that is, that its actually listening when you type characters on the 
keyboard).</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This applet is actually less complicated than the previous applets
you've used. This one has only three methods: <TT>init()</TT>,
<TT>keyDown()</TT>, and <TT>paint()</TT>.
The instance variables are also simpler because the only things
you need to keep track of are the x and y positions of the current
character and the values of that character itself. Here's the
initial class definition:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;
import java.awt.Event;
import java.awt.Font;
import java.awt.Color;

public class Keys extends java.applet.Applet {

    char currkey;
    int currx;
    int curry;
}
</PRE>
</BLOCKQUOTE>
<P>
Let's start by adding an <TT>init()</TT>
method. Here, <TT>init()</TT> is responsible
for three things: setting the background color, setting the applet's
font (here, 36-point Helvetica bold), and setting the beginning
position for the character (the middle of the screen, minus a
few points to nudge it up and to the right):
<BLOCKQUOTE>
<PRE>
public void init() {
    currx = (size().width / 2) - 8;
    curry = (size().height / 2) - 16;
    setBackground(Color.white);
    setFont(new Font(&quot;Helvetica&quot;, Font.BOLD, 36));
}
</PRE>
</BLOCKQUOTE>
<P>
Because this applet's behavior is based on keyboard input, the
<TT>keyDown()</TT> method is where
most of the work of the applet takes place:
<BLOCKQUOTE>
<PRE>
public boolean keyDown(Event evt, int key) {
   switch (key) {
         case Event.DOWN:
             curry += 5;
             break;
         case Event.UP:
             curry -= 5;
             break;
         case Event.LEFT:
             currx -= 5;
             break;
         case Event.RIGHT:
             currx += 5;
             break;
         default:
             currkey = (char)key;
         }
         repaint();
         return true;
}
</PRE>
</BLOCKQUOTE>
<P>
In the center of the <TT>keyDown()</TT>
applet is a <TT>switch</TT> statement
that tests for different key events. If the event is an arrow
key, the appropriate change is made to the character's position.
If the event is any other key, the character itself is changed
(that's the default part of the <TT>switch</TT>).
The method finishes up with a <TT>repaint()</TT>
and returns <TT>true</TT>.
<P>
The <TT>paint()</TT> method here is
almost trivial; just display the current character at the current
position. However, note that when the applet starts up, there's
no initial character and nothing to draw, so you have to take
that into account. The <TT>currkey</TT>
variable is initialized to <TT>0</TT>,
so you paint the applet only if <TT>currkey</TT>
has an actual value:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {
    if (currkey != 0) {
        g.drawString(String.valueOf(currkey), currx,curry);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Listing 12.3 shows the complete source code for the Keys applet.
<HR>
<BLOCKQUOTE>
<B>Listing 12.3. The Keys applet. <BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Graphics;
 2: import java.awt.Event;
 3: import java.awt.Font;
 4: import java.awt.Color;
 5: 
 6: public class Keys extends java.applet.Applet {
 7: 
 8:     char currkey;
 9:     int currx;
10:    int curry;
11:
12:     public void init() {
13:         currx = (size().width / 2) -8;  // default
14:         curry = (size().height / 2) -16;
15:
16:         setBackground(Color.white);
17:         setFont(new Font(&quot;Helvetica&quot;,Font.BOLD,36));
18:     }
19:
20:     public boolean keyDown(Event evt, int key) {
21:         switch (key) {
22:         case Event.DOWN:
23:             curry += 5;
24:             break;
25:         case Event.UP:
26:             curry -= 5;
27:             break;
28:         case Event.LEFT:
29:             currx -= 5;
30:             break;
31:         case Event.RIGHT:
32:             currx += 5;
33:             break;
34:         default:
35:             currkey = (char)key;
36:         }
37:
38:         repaint();
39:         return true;
40:     }
41:
42:     public void paint(Graphics g) {
43:         if (currkey != 0) {
44:             g.drawString(String.valueOf(currkey), currx,curry);
45:         }
46:     }
47: }
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="TestingforModifierKeysandMultipleMouseButtons">
Testing for Modifier Keys and Multiple Mouse Buttons</A></H3>
<P>
Shift, Control (Ctrl), and Meta are modifier keys. They don't
generate key events themselves, but when you get an ordinary mouse
or keyboard event, you can test to see whether those modifier
keys were held down when the event occurred. Sometimes it may
be obvious-shifted alphanumeric keys produce different key events
than unshifted ones, for example. For other events, however-mouse
events in particular-you may want to handle an event with a modifier
key held down differently from a regular version of that event.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Meta key is commonly used on UNIX systems; it's usually mapped to Alt on pc keyboards and Command (apple) on Macintoshes.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>Event</TT> class provides
three methods for testing whether a modifier key is held down:
<TT>shiftDown()</TT>, <TT>metaDown()</TT>,
and <TT>controlDown()</TT>. All return
boolean values based on whether that modifier key is indeed held
down. You can use these three methods in any of the event- handling
methods (mouse or keyboard) by calling them on the event object
passed into that method:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y ) {
    if (evt.shiftDown())
         // handle shift-click
    else // handle regular click
}
</PRE>
</BLOCKQUOTE>
<P>
One other significant use of these modifier key methods is to
test for which mouse button generated a particular mouse event
on systems with two or three mouse buttons. By default, mouse
events (such as mouse down and mouse drag) are generated regardless
of which mouse button is used. However, Java events internally
map left and middle mouse actions to meta and Control (Ctrl) modifier
keys, respectively, so testing for the key tests for the mouse
button's action. By testing for modifier keys, you can find out
which mouse button was used and execute different behavior for
those buttons than you would for the left button. Use an <TT>if</TT>
statement to test each case, like this:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event evt, int x, int y ) {
    if (evt.metaDown())
         // handle a right-click
    else if (evt.controlDown())
        // handle a middle-click
    else // handle a regular click
}
</PRE>
</BLOCKQUOTE>
<P>
Note that because this mapping from multiple mouse buttons to
keyboard modifiers happens automatically, you don't have to do
a lot of work to make sure your applets or applications work on
different systems with different kinds of mouse devices. Because
left-button or right-button mouse clicks map to modifier key events,
you can use those actual modifier keys on systems with fewer mouse
buttons to generate exactly the same results. So, for example,
holding down the Ctrl key and clicking the mouse on Windows or
holding the Control key on the Macintosh is the same as clicking
the middle mouse button on a three-button mouse; holding down
the Command (apple) key and clicking the mouse on the Mac is the
same as clicking the right mouse button on a two- or three-button
mouse. 
<P>
Consider, however, that the use of different mouse buttons or
modifier keys may not be immediately obvious if your applet or
application runs on a system with fewer buttons than you're used
to working with. Consider restricting your interface to a single
mouse button or to providing help or documentation to explain
the use of your program in this case.
<H2><A NAME="TheawtEventHandler"><FONT SIZE=5 COLOR=#FF0000>
The awt Event Handler</FONT></A></H2>
<P>
The default methods you've learned about today for handling basic
events in applets are actually called by a generic event handler
method called <TT>handleEvent()</TT>.
The <TT>handleEvent()</TT> method
is how the awt generically deals with events that occur between
application components and events based on user input.
<P>
In the default <TT>handleEvent()</TT>
method, basic events are processed and the methods you learned
about today are called. To handle events other than those mentioned
here (for example, events for scrollbars or for other user interface
elements-which you'll learn about on <A HREF="ch13.htm">Day 13</A>, &quot;Creating User
Interfaces with the awt&quot;), to change the default event handling
behavior, or to create and pass around your own events, you need
to override <TT>handleEvent()</TT>
in your own Java programs. The <TT>handleEvent()</TT>
method looks like this:
<BLOCKQUOTE>
<PRE>
public boolean handleEvent(Event evt) {
    ...
}
</PRE>
</BLOCKQUOTE>
<P>
To test for specific events, examine the <TT>id</TT>
instance variable of the <TT>Event</TT>
object that gets passed in to <TT>handleEvent()</TT>.
The event ID is an integer, but fortunately the <TT>Event</TT>
class defines a whole set of event IDs as class variables whose
names you can test for in the body of <TT>handleEvent()</TT>.
Because these class variables are integer constants, a <TT>switch</TT>
statement works particularly well. For example, here's a simple
<TT>handleEvent()</TT> method to print
out debugging information about mouse events:
<BLOCKQUOTE>
<PRE>
public boolean handleEvent(Event evt) {
    switch (evt.id) {
    case Event.MOUSE_DOWN:
        System.out.println(&quot;MouseDown: &quot; +
                evt.x + &quot;,&quot; + evt.y);
        return true;
    case Event.MOUSE_UP:
        System.out.println(&quot;MouseUp: &quot; +
                evt.x + &quot;,&quot; + evt.y);
        return true;
    case Event.MOUSE_MOVE:
        System.out.println(&quot;MouseMove: &quot; +
                evt.x + &quot;,&quot; + evt.y);
        return true;
    case Event.MOUSE_DRAG:
        System.out.println(&quot;MouseDrag: &quot; +
                evt.x + &quot;,&quot; + evt.y);
        return true;
    default:
        return false;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
You can test for the following keyboard events:
<UL>
<LI><TT>Event.KEY_PRESS</TT> is generated
when a key is pressed (the same as the <TT>keyDown()</TT>
method).
<LI><TT>Event.KEY_RELEASE</TT> is
generated when a key is released.
<LI><TT>Event.KEY_ACTION</TT> and
<TT>Event.KEY_ACTION_RELEASE</TT>
are generated when an action key (a function key, an arrow key,
Page Up, Page Down, or Home) is pressed or released.
</UL>
<P>
You can test for these mouse events:
<UL>
<LI><TT>Event.MOUSE_DOWN</TT> is generated
when the mouse button is pressed (the same as the <TT>mouseDown()</TT>
method).
<LI><TT>Event.MOUSE_UP</TT> is generated
when the mouse button is released (the same as the <TT>mouseUp()</TT>
method).
<LI><TT>Event.MOUSE_MOVE</TT> is generated
when the mouse is moved (the same as the <TT>mouseMove()</TT>
method).
<LI><TT>Event.MOUSE_DRAG</TT> is generated
when the mouse is moved with the button pressed (the same as the
<TT>mouseDrag()</TT> method).
<LI><TT>Event.MOUSE_ENTER</TT> is
generated when the mouse enters the applet (or a component of
that applet). You can also use the <TT>mouseEnter()</TT>
method.
<LI><TT>Event.MOUSE_EXIT</TT> is generated
when the mouse exits the applet. You can also use the <TT>mouseExit()</TT>
method.
</UL>
<P>
In addition to these events, the <TT>Event</TT>
class has a whole suite of methods for handling awt components.
You'll learn more about these events tomorrow.
<P>
Note that if you override <TT>handleEvent()</TT>
in your class, none of the default event-handling methods you
learned about today will get called unless you explicitly call
them in the body of <TT>handleEvent()</TT>,
so be careful if you decide to do this. One way to get around
this is to test for the event you're interested in, and if that
event isn't it, call <TT>super.handleEvent()</TT>
so that the superclass that defines <TT>handleEvent()</TT>
can process things. Here's an example of how to do this:
<BLOCKQUOTE>
<PRE>
public boolean handleEvent(Event evt) {
    if (evt.id == Event.MOUSE_DOWN) {
        // process the mouse down
        return true;
    } else {
        return super.handleEvent(evt);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Also, note that like the individual methods for individual events,
<TT>handleEvent()</TT> also returns
a boolean. The value you return here is particularly important;
if you pass handling of the event to another method, you must
return <TT>false</TT>. If you handle
the event in the body of this method, return <TT>true</TT>.
If you pass the event up to a superclass, that method will return
<TT>true</TT> or <TT>false</TT>;
you don't have to yourself.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Handling events in Java's Abstract Windowing Toolkit is easy.
Most of the time all you need to do is stick the right method
in your applet code, and your applet intercepts and handles that
event at the right time. Here are some of the basic events you
can manage in this way:
<UL>
<LI>Mouse clicks-<TT>mouseUp()</TT>
and <TT>mouseDown()</TT> methods for
each part of a mouse click.
<LI>Mouse movements-<TT>mouseMove()</TT>
and <TT>mouseDrag()</TT> for mouse
movement with the mouse button released and pressed, respectively,
as well as <TT>mouseEnter()</TT> and
<TT>mouseExit()</TT> for when the
mouse enters and exits the applet area.
<LI><TT>keyDown()</TT> and <TT>keyUp()</TT>
for when a key on the keyboard is pressed.
</UL>
<P>
All events in the awt generate an <TT>Event</TT>
object; inside that object, you can find out information about
the event, when it occurred, and its x and y coordinates (if applicable).
You can also test that event to see whether a modifier key was
pressed when the event occurred, by using the <TT>shiftDown()</TT>,
<TT>controlDown()</TT>, and <TT>metaDown()</TT>
methods.
<P>
Finally, there is the <TT>handleEvent()</TT>
method, the &quot;parent&quot; of the individual event methods.
The <TT>handleEvent()</TT> method
is actually what the Java system calls to manage events; the default
implementation calls the individual method events where necessary.
To override how methods are managed in your applet, override <TT>handleEvent()</TT>.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>In the Spots applet, the spot coordinates are stored in arrays, which have a limited size. How can I modify this applet so that it will draw an unlimited number of spots?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>You can do one of a couple things:<BR>
The first thing to do is test, in your <TT>addspot()</TT> method, whether the number of spots has exceeded <TT>MAXSPOTS</TT>. Then create a bigger array, copy the elements of the old array into that bigger array (use the <TT>System.arraycopy()</TT> method 
to do that), and reassign the <TT>x</TT> and <TT>y</TT> arrays to that new, bigger array.
<BR>
The second thing to do is to use the <TT>Vector</TT> class. <TT>Vector</TT>, part of the <TT>java.util</TT> package, implements an array that is automatically growable-sort of like a linked list is in other languages. The disadvantage of <TT>Vector</TT> is 
that to put something into <TT>Vector</TT>, it has to be an actual object. This means you'll have to cast integers to <TT>Integer</TT> objects, and then extract their values from <TT>Integer</TT> objects to treat them as integers again. The <TT>Vector</TT> 
class allows you to access and change elements in the <TT>Vector</TT> just as you can in an array (by using method calls, rather than array syntax). Check it out.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>What's a Meta key?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>It's popular in UNIX systems, and often mapped to Alt on most keyboards (Option on Macs). Because Shift and Control (Ctrl) are much more popular and widespread, it's probably a good idea to 
base your interfaces on those modifier keys if you can.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How do I test to see whether the Return key has been pressed?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Return (line feed) is character 10; Enter (carriage return) is character 13. Note that different platforms may send different keys for the actual key marked Return. In particular, UNIX systems 
send line feeds, Macintoshes send carriage returns, and DOS systems send both. So to provide cross-platform behavior, you may want to test for both line feed and carriage return.
<BR>
The word from the Java team is that a Return is a Return is a Return, regardless of the platform. However, at the time of this writing, it is questionable whether this is currently true in the Java Developer's Kit. You may want to check the API 
documentation for the <TT>Event</TT> class to see whether this has changed in the interim.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I looked at the API for the <TT><B>Event</B></TT> class, and there are many more event types listed there than the ones you mention today.</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Yes. The <TT>Event</TT> class defines many different kinds of events, both for general user input, such as the mouse and keyboard events you learned about here, and also events for managing 
changes to the state of user interface components, such as windows and scrollbars. Tomorrow you'll learn about those other events.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch11.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch13.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
