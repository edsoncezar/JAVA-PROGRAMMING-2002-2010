<HTML>
<HEAD>
<TITLE>Day 19 -- Streams and I/O</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;19</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Streams and I/O</FONT></H1>
<P>
<I><B>by Charles L. Perkins and Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#WhatAreStreams">
What Are Streams?</A>
<LI><A HREF="#TheTTFONTSIZEFACECourierjavaioFONTTTFONTSIZEPackageFONT">
The <TT>java.io</TT>
Package</FONT></A>
<LI><A HREF="#InputStreams">
Input Streams</A>
<UL>
<LI><A HREF="#TheAbstractClassTTFONTSIZEFACECourierInputStreamFONTTT">
The Abstract Class <TT>InputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierByteArrayInputStreamFONTTT">
<TT>ByteArrayInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFileInputStreamFONTTT">
<TT>FileInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFilterInputStreamFONTTT">
<TT>FilterInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierPipedInputStreamFONTTT">
<TT>PipedInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierSequenceInputStreamFONTTT">
<TT>SequenceInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierStringBufferInputStreamFONTTT">
<TT>StringBufferInputStream</TT>
</A>
</UL>
<LI><A HREF="#OutputStreams">
Output Streams</A>
<UL>
<LI><A HREF="#TheAbstractClassTTFONTSIZEFACECourierOutputStreamFONTTT">
The Abstract Class <TT>OutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierByteArrayOutputStreamFONTTT">
<TT>ByteArrayOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFileOutputStreamFONTTT">
<TT>FileOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFilterOutputStreamFONTTT">
<TT>FilterOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierPipedOutputStreamFONTTT">
<TT>PipedOutputStream</TT>
</A>
</UL>
<LI><A HREF="#RelatedClasses">
Related Classes</A>
<LI><A HREF="#ObjectSerializationJava">
Object Serialization (Java 1.1)</A>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
The package <TT>java.io</TT>, part
of the standard Java class library, provides a large number of
classes designed for handling input and output to files, network
connections, and other sources. These I/O classes are known as
streams, and provide functionality for reading and writing data
in various ways. You got a glimpse of these classes on <A HREF="ch14.htm">Day 14</A>,
&quot;Windows, Networking, and Other Tidbits,&quot; when we opened
a network connection to a file and read the contents into an applet.
<P>
Today you'll explore Java's input and output classes:
<UL>
<LI>Input streams-and how to create, use, and detect the end of
them-and filtered input streams, which can be nested to great
effect
<LI>Output streams, which are mostly analogous to (but the inverse
of) input streams
</UL>
<P>
You'll also learn about two stream interfaces that make the reading
and writing of typed streams much easier (as well as about several
utility classes used to access the file system). 
<H2><A NAME="WhatAreStreams"><FONT SIZE=5 COLOR=#FF0000>
What Are Streams?</FONT></A></H2>
<P>
A <I>stream</I> is a path of communication between the source
of some information and its destination. This information can
come from a file, the computer's memory, or even from the Internet.
In fact, the source and destination of a stream are completely
arbitrary producers and consumers of bytes, respectively-you don't
need to know about the source of the information when reading
from a stream, and you don't need to know about the final destination
when writing to one.
<P>
A <I>stream</I> is a path of communication between a source of
information and its destination. For example, an input stream
allows you to read data from a source, and an output stream allows
you to write data to a destination.
<P>
General-purpose methods that can read from any source accept a
stream argument to specify that source; general-purpose methods
for writing accept a stream to specify the destination. Arbitrary
<I>processors</I> of data commonly have two stream arguments.
They read from the first, process the data, and write the results
to the second. These processors have no idea of either the source
<I>or</I> the destination of the data they are processing. Sources
and destinations can vary widely: from two memory buffers on the
same local computer, to the ELF (extremely low frequency) transmissions
to and from a submarine at sea, to the real-time data streams
of a NASA probe in deep space.
<P>
By decoupling the consuming, processing, or producing of data
from the sources and destinations of that data, you can mix and
match any combination of them at will as you write your program.
In the future, when new, previously nonexistent forms of source
or destination (or consumer, processor, or producer) appear, they
can be used within the same framework, with no changes to your
classes. In addition, new stream abstractions, supporting higher
levels of interpretation &quot;on top of&quot; the bytes, can
be written completely independently of the underlying transport
mechanisms for the bytes themselves.
<H2><A NAME="TheTTFONTSIZEFACECourierjavaioFONTTTFONTSIZEPackageFONT"><FONT SIZE=5 COLOR=#FF0000>
The <TT>java.io</TT>
Package</FONT></FONT></A></H2>
<P>
All the classes you will learn about today are part of the package
<TT>java.io</TT>. To use any of these
classes in your own programs, you will need to import each individual
class or to import the entire <TT>java.io</TT>
package, like this:
<BLOCKQUOTE>
<PRE>
import java.io.InputStream;
import java.io.FilteredInputStream;
import java.io.FileOutputStream;

import java.io.*;
</PRE>
</BLOCKQUOTE>
<P>
All the methods you will explore today are declared to throw <TT>IOException</TT>s.
This new subclass of <TT>Exception</TT>
conceptually embodies all the possible I/O errors that might occur
while using streams. Several subclasses of it define a few, more
specific exceptions that can be thrown as well. For now, it is
enough to know that you must either <TT>catch</TT>
an <TT>IOException</TT>, or be in
a method that can &quot;pass it along,&quot; to be a well-behaved
user of streams.
<P>
The foundations of this stream framework in the Java class hierarchy
are the two abstract classes, <TT>InputStream</TT>
and <TT>OutputStream</TT>. Inheriting
from these classes is a virtual cornucopia of categorized subclasses,
demonstrating the wide range of streams in the system, but also
demonstrating an extremely well-designed hierarchy of relationships
between these streams-one well worth learning from. Let's begin
with the parents, <TT>InputStream</TT>
and <TT>OutputStream</TT>, and then
work our way down this bushy tree.
<H2><A NAME="InputStreams"><FONT SIZE=5 COLOR=#FF0000>
Input Streams</FONT></A></H2>
<P>
Input streams are streams that allow you to read data from a source.
These include the root abstract class <TT>InputStream</TT>,
filtered streams, buffered streams, and streams that read from
files, strings, and byte arrays.
<H3><A NAME="TheAbstractClassTTFONTSIZEFACECourierInputStreamFONTTT">
The Abstract Class <TT>InputStream</TT>
</A></H3>
<P>
<TT>InputStream</TT> is an abstract
class that defines the fundamental ways in which a destination
(consumer) reads a stream of bytes from some source. The identity
of the source, and the manner of the creation and transport of
the bytes, is irrelevant. When using an input stream, you are
the destination of those bytes, and that's all you need to know.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
All input streams descend from <TT>InputStream</TT>. All share in common the few methods described in this section. Thus, the streams used in these examples can be any of the more complex input streams described in the next few sections.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4><TT>read()</TT></H4>
<P>
The most important method to the consumer of an input stream is
the one that reads bytes from the source. This method, <TT>read()</TT>,
comes in many flavors, and each is demonstrated in an example
in today's lesson.
<P>
Each of these <TT>read()</TT> methods
is defined to &quot;block&quot; (wait) until all the input requested
becomes available. Don't worry about this limitation; because
of multithreading, you can do as many other things as you like
while this one thread is waiting for input. In fact, it is a common
idiom to assign a thread to each stream of input (and for each
stream of output) that is solely responsible for reading from
it (or writing to it). These input threads might then &quot;hand
off&quot; the information to other threads for processing. This
naturally overlaps the I/O time of your program with its compute
time.
<P>
Here's the first form of <TT>read()</TT>:
<BLOCKQUOTE>
<PRE>
InputStream  s      = getAnInputStreamFromSomewhere();
byte[]       buffer = new byte[1024];   // any size will do

if (s.read(buffer) != buffer.length)
    System.out.println(&quot;I got less than I expected.&quot;);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Here and throughout the rest of today's lesson, assume that either an <TT>import java.io.*</TT> appears before all the examples or that you mentally prefix all references to <TT>java.io</TT> classes with the prefix <TT>java.io</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This form of <TT>read()</TT> attempts
to fill the entire buffer given. If it cannot (usually due to
reaching the end of the input stream), it returns the actual number
of bytes that were read into the buffer. After that, any further
calls to <TT>read()</TT> return <TT>-1</TT>,
indicating that you are at the end of the stream. Note that the
<TT>if</TT> statement still works
even in this case, because <TT>-1 != 1024</TT>
(this corresponds to an input stream with no bytes in it at all).
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Don't forget that, unlike in C, the <TT>-1</TT> case in Java is not used to indicate an error. Any I/O errors throw instances of <TT>IOException</TT> (which you're not catching yet). You learned on <A HREF="ch17.htm">Day 17</A>, &quot;Exceptions,&quot; 
that all uses of distinguished values can be replaced by the use of exceptions, and so they should. The <TT>-1</TT> in the last example is a bit of a historical anachronism. You'll soon see a better approach to indicating the end of the stream using the 
class <TT>DataInputStream</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You can also read into a &quot;slice&quot; of your buffer by specifying
the offset into the buffer, and the length desired, as arguments
to <TT>read()</TT>:
<BLOCKQUOTE>
<PRE>
s.read(buffer, 100, 300);
</PRE>
</BLOCKQUOTE>
<P>
This example tries to fill in bytes 100 through 399 and behaves
otherwise exactly the same as the previous <TT>read()</TT>
method.
<P>
Finally, you can read in bytes one at a time:
<BLOCKQUOTE>
<PRE>
InputStream  s = getAnInputStreamFromSomewhere(); 
byte         b;
int          byteOrMinus1;

while ((byteOrMinus1 = s.read()) != -1) {
     b = (byte) byteOrMinus1;
     . . .    // process the byte b
}
. . .    // reached end of stream<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Because of the nature of integer promotion in Java in general, and because in this case the <TT>read()</TT> method returns an <TT>int</TT>, using the <TT>byte</TT> type in your code may be a little frustrating. You'll find yourself constantly having to 
explicitly cast the result of arithmetic expressions, or of <TT>int</TT> return values, back to your size. Because <TT>read()</TT> really should be returning a <TT>byte</TT> in this case, we feel justified in declaring and using it as such (despite the 
pain)-it makes the size of the data being read clearer. In cases where you feel that the range of a variable is naturally limited to a <TT>byte</TT> (or a <TT>short</TT>) rather than an <TT>int</TT>, please take the time to declare it that way and pay the 
small price necessary to gain the added clarity. By the way, a lot of the Java class library code simply stores the result of <TT>read()</TT> in an <TT>int</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4><TT>skip()</TT></H4>
<P>
What if you want to skip over some of the bytes in a stream, or
start reading a stream from other than its beginning? A method
similar to <TT>read()</TT> does the
trick:
<BLOCKQUOTE>
<PRE>
if (s.skip(1024) != 1024)
    System.out.println(&quot;I skipped less than I expected.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This example skips over the next 1024 bytes in the input stream.
However, the implementation of <TT>skip()</TT>
in <TT>InputStream</TT> may skip fewer
bytes than the given argument, and so it returns a long integer
representing the number of bytes it actually skipped. In this
example, therefore, a message is printed if the actual number
of bytes skipped is less than 1024.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The API documentation for <TT>skip()</TT> in the <TT>InputStream</TT> class says that <TT>skip()</TT> behaves this way for &quot;a variety of reasons.&quot; Subclasses of <TT>InputStream</TT> should override this default implementation of <TT>skip()</TT> 
if they want to handle skipping more properly.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4><TT>available()</TT></H4>
<P>
If for some reason you would like to know how many bytes are in
the stream right now, you can ask the following:
<BLOCKQUOTE>
<PRE>
if (s.available() &lt; 1024)
    System.out.println(&quot;Too little is available right now.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This tells you the number of bytes that you can read without blocking.
Because of the abstract nature of the source of these bytes, streams
may or may not be able to tell you a reasonable answer to this
question. For example, some streams always return <TT>0</TT>.
Unless you use specific subclasses of <TT>InputStream</TT>
that you know provide a reasonable answer to this question, it's
not a good idea to rely on this method. Remember that multithreading
eliminates many of the problems associated with blocking while
waiting for a stream to fill again. Thus, one of the strongest
rationales for the use of <TT>available()</TT>
goes away.
<H4><TT>mark()</TT> and <TT>reset()</TT>
</H4>
<P>
Some streams support the notion of marking a position in the stream
and then later resetting the stream to that position to reread
the bytes there. Clearly, the stream would have to &quot;remember&quot;
all those bytes, so there is a limitation on how far apart in
a stream the mark and its subsequent reset can occur. There's
also a method that asks whether the stream supports the notion
of marking at all. Here's an example:
<BLOCKQUOTE>
<PRE>
InputStream  s = getAnInputStreamFromSomewhere();

if (s.markSupported()) {    // does s support the notion?
    . . .        // read the stream for a while
    s.mark(1024);
    . . .        // read less than 1024 more bytes
    s.reset();
    . . .        // we can now re-read those bytes
} else {
    . . .                   // no, perform some alternative
}
</PRE>
</BLOCKQUOTE>
<P>
When marking a stream, you specify the maximum number of bytes
you intend to allow to pass before resetting it. This allows the
stream to limit the size of its byte &quot;memory.&quot; If this
number of bytes goes by and you have not yet used <TT>reset()</TT>,
the mark becomes invalid, and attempting to use <TT>reset()</TT>
will throw an exception.
<P>
Marking and resetting a stream is most valuable when you are attempting
to identify the type of the stream (or the next part of the stream),
but to do so, you must consume a significant piece of it in the
process. Often, this is because you have several black-box parsers
that you can hand the stream to, but they will consume some (unknown
to you) number of bytes before making up their mind about whether
the stream is of their type. Set a large size for the limit in
<TT>mark()</TT>, and let each parser
run until it either throws an error or completes a successful
parse. If an error is thrown, use <TT>reset()</TT>
and try the next parser.
<H4><TT>close()</TT></H4>
<P>
Because you don't know what resources an open stream represents,
nor how to deal with them properly when you're finished reading
the stream, you should (usually) explicitly close down a stream
so that it can release these resources. Of course, garbage collection
and a finalization method can do this for you, but what if you
need to reopen that stream or those resources before they have
been freed by this asynchronous process? At best, this is annoying
or confusing; at worst, it introduces an unexpected, obscure,
and difficult-to-track-down bug. Because you're interacting with
the outside world of external resources, it's safer to be explicit
about when you're finished using them:
<BLOCKQUOTE>
<PRE>
InputStream  s = alwaysMakesANewInputStream();

try {
    . . .     // use s to your heart's content
} finally {
    s.close();
}
</PRE>
</BLOCKQUOTE>
<P>
Get used to this idiom (using <TT>finally</TT>);
it's a useful way to be sure something (such as closing the stream)
always gets done. Of course, you're assuming that the stream is
always successfully created. If this is not always the case, and
<TT>null</TT> is sometimes returned
instead, here's the correct way to be safe:
<BLOCKQUOTE>
<PRE>
InputStream  s = tryToMakeANewInputStream();

if (s != null) {
    try {
        . . .
    } finally {
        s.close();
    }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TTFONTSIZEFACECourierByteArrayInputStreamFONTTT">
<TT>ByteArrayInputStream</TT>
</A></H3>
<P>
The &quot;inverse&quot; of some of the previous examples would
be to create an input stream <I>from</I> an array of bytes. This
is exactly what <TT>ByteArrayInputStream</TT>
does:
<BLOCKQUOTE>
<PRE>
byte[]  buffer = new byte[1024];

fillWithUsefulData(buffer);

InputStream  s = new ByteArrayInputStream(buffer);
</PRE>
</BLOCKQUOTE>
<P>
Readers of the new stream <TT>s</TT>
see a stream 1024 bytes long, containing the bytes in the array
<TT>buffer</TT>. Just as <TT>read()</TT>
has a form that takes an offset and a length, so does this class's
constructor:
<BLOCKQUOTE>
<PRE>
InputStream  s = new ByteArrayInputStream(buffer, 100, 300);
</PRE>
</BLOCKQUOTE>
<P>
Here the stream is 300 bytes long and consists of bytes 100-399
from the array <TT>buffer</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Finally, you've seen your first examples of the creation</FONT> of a stream. These new streams are attached to the simplest of all possible sources of data: an array of bytes in the memory of the local computer.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>ByteArrayInputStream</TT>s simply
implement the standard set of methods that all input streams do.
Here, however, the <TT>available()</TT>
method has a particularly simple job-it returns <TT>1024</TT>
and <TT>300</TT>, respectively, for
the two instances of <TT>ByteArrayInputStream</TT>
you created previously, because it knows exactly how many bytes
are available. Finally, calling <TT>reset()</TT>
on a <TT>ByteArrayInputStream</TT>
resets it to the beginning of the stream (buffer), no matter where
the mark is set.
<H3><A NAME="TTFONTSIZEFACECourierFileInputStreamFONTTT">
<TT>FileInputStream</TT>
</A></H3>
<P>
One of the most common uses of streams, and historically the earliest,
is to attach them to files in the file system. Here, for example,
is the creation of such an input stream on a UNIX system:
<BLOCKQUOTE>
<PRE>
InputStream  s = new FileInputStream(&quot;/some/path/and/fileName&quot;);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Applets attempting to open, read, or write streams based on files in the file system will usually cause security exceptions to be thrown from the browser. If you're developing applets, you won't be able to depend on files at all, and you'll have to use 
your server to hold shared information. (Standalone Java programs have none of these problems, of course.)</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You also can create the stream from a previously opened file descriptor
(an instance of the <TT>FileDescriptor</TT>
class). Usually, you get file descriptors using the <TT>getFD()</TT>
method on <TT>FileInputStream</TT>
or <TT>FileOutputStream</TT> classes,
so, for example, you could use the same file descriptor to open
a file for reading and then reopen it for writing:
<BLOCKQUOTE>
<PRE>
FileDescriptor       fd = someFileStream.getFD();
InputStream  s  = new FileInputStream(fd);
</PRE>
</BLOCKQUOTE>
<P>
In either case, because it's based on an actual (finite length)
file, the input stream created can implement <TT>available()</TT>
precisely and can skip like a champ (just as <TT>ByteArrayInputStream</TT>
can, by the way). In addition, <TT>FileInputStream</TT>
knows a few more tricks:
<BLOCKQUOTE>
<PRE>
FileInputStream  aFIS = new FileInputStream(&quot;aFileName&quot;);

FileDescriptor  myFD = aFIS.getFD(); // get a file descriptor

 aFIS.finalize();   // will call close() when automatically called by GC
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To call these new methods, you must declare the stream variable <TT>aFIS</TT> to be of type <TT>FileInputStream</TT>, because plain <TT>InputStream</TT>s don't know about them.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The first is obvious: <TT>getFD()</TT>
returns the file descriptor of the file on which the stream is
based. The second, though, is an interesting shortcut that allows
you to create <TT>FileInputStream</TT>s
without worrying about closing them later. <TT>FileInputStream</TT>'s
implementation of <TT>finalize()</TT>,
a <TT>protected</TT> method, closes
the stream. Unlike in the contrived call in comments, you almost
never can nor should call a <TT>finalize()</TT>
method directly. The garbage collector calls it after noticing
that the stream is no longer in use, but before actually destroying
the stream. Thus, you can go merrily along using the stream, never
closing it, and all will be well. The system takes care of closing
it (eventually).
<P>
You can get away with this because streams based on files tie
up very few resources, and these resources cannot be accidentally
reused before garbage collection (these were the things worried
about in the previous discussion of finalization and <TT>close()</TT>).
Of course, if you were also <I>writing</I>  to the file, you would
have to be more careful. (Reopening the file too soon after writing
might make it appear in an inconsistent state because the <TT>finalize()</TT>-and
thus the <TT>close()</TT>-might not
have happened yet.) Just because you don't <I>have</I> to close
the stream doesn't mean you might not want to do so anyway. For
clarity, or if you don't know precisely what type of an <TT>InputStream</TT>
you were handed, you might choose to call <TT>close()</TT>
yourself.
<H3><A NAME="TTFONTSIZEFACECourierFilterInputStreamFONTTT">
<TT>FilterInputStream</TT>
</A></H3>
<P>
This &quot;abstract&quot; class simply provides a &quot;pass-through&quot;
for all the standard methods of <TT>InputStream</TT>.
(It's &quot;abstract,&quot; in quotes, because it's not technically
an <TT>abstract</TT> class; you can
create instances of it. In most cases, however, you'll use one
of the more useful subclasses of <TT>FilterInputStream</TT>
instead of <TT>FilterInputStream</TT>
itself.) <TT>FilterInputStream</TT>
holds inside itself another stream, by definition one further
&quot;down&quot; the chain of filters, to which it forwards all
method calls. It implements nothing new but allows itself to be
nested:
<BLOCKQUOTE>
<PRE>
InputStream        s  = getAnInputStreamFromSomewhere();
FilterInputStream  s1 = new FilterInputStream(s);
FilterInputStream  s2 = new FilterInputStream(s1);
FilterInputStream  s3 = new FilterInputStream(s2);

... s3.read() ...
</PRE>
</BLOCKQUOTE>
<P>
Whenever a read is performed on the filtered stream <TT>s3</TT>,
it passes along the request to <TT>s2</TT>,
then <TT>s2</TT> does the same to
<TT>s1</TT>, and finally <TT>s</TT>
is asked to provide the bytes. Subclasses of <TT>FilterInputStream</TT>
will, of course, do some nontrivial processing of the bytes as
they flow past. The rather verbose form of &quot;chaining&quot;
in the previous example can be made more elegant:
<BLOCKQUOTE>
<PRE>
s3 = new FilterInputStream(new FilterInputStream(new FilterInputStream(s)));
</PRE>
</BLOCKQUOTE>
<P>
You should use this idiom in your code whenever you can. It clearly
expresses the nesting of chained filters, and can easily be parsed
and &quot;read aloud&quot; by starting at the innermost stream
<TT>s</TT> and reading outward-each
filter stream applying to the one within-until you reach the outermost
stream <TT>s3</TT>.
<P>
Now let's examine each of the subclasses of <TT>FilterInputStream</TT>
in turn.
<H4><TT>BufferedInputStream</TT></H4>
<P>
This is one of the most valuable of all streams. It implements
the full complement of <TT>InputStream</TT>'s
methods, but it does so by using a buffered array of bytes that
acts as a cache for future reading. This decouples the rate and
the size of the &quot;chunks&quot; you're reading from the more
regular, larger block sizes in which streams are most efficiently
read (from, for example, peripheral devices, files in the file
system, or the network). It also allows smart streams to read
ahead when they expect that you will want more data soon.
<P>
Because the buffering of <TT>BufferedInputStream</TT>
is so valuable, and it's also the only class to handle <TT>mark()</TT>
and <TT>reset()</TT> properly, you
might wish that every input stream could somehow share its valuable
capabilities. Normally, because those stream classes do not implement
them, you would be out of luck. Fortunately, you already saw a
way that filter streams can wrap themselves &quot;around&quot;
other streams. Suppose that you would like a buffered <TT>FileInputStream</TT>
that can handle marking and resetting correctly. Et voil&agrave;:
<BLOCKQUOTE>
<PRE>
InputStream  s = new BufferedInputStream(new FileInputStream(&quot;foo&quot;));
</PRE>
</BLOCKQUOTE>
<P>
You have a buffered input stream based on the file <TT>foo</TT>
that can use <TT>mark()</TT> and <TT>reset()</TT>.
<P>
Now you can begin to see the power of nesting streams. Any capability
provided by a filter input stream (or output stream, as you'll
see soon) can be used by any other basic stream via nesting. Of
course, any <I>combination</I> of these capabilities, and in any
order, can be as easily accomplished by nesting the filter streams
themselves.
<H4><TT>DataInputStream</TT></H4>
<P>
All the methods that instances of this class understand are defined
in a separate interface, which both <TT>DataInputStream</TT>
and <TT>RandomAccessFile</TT> (another
class in <TT>java.io</TT>) implement.
This interface is general-purpose enough that you might want to
use it yourself in the classes you create. It is called <TT>DataInput</TT>.
<H5>The <TT>DataInput</TT> Interface
</H5>
<P>
When you begin using streams to any degree, you'll quickly discover
that byte streams are not a really helpful format into which to
force all data. In particular, the primitive types of the Java
language embody a rather nice way of looking at data, but with
the streams you've been defining thus far in this book, you could
not read data of these types. The <TT>DataInput</TT>
interface specifies a higher-level set of methods that, when used
for both reading and writing, can support a more complex, typed
stream of data. Here are the methods this interface defines:
<BLOCKQUOTE>
<PRE>
void  readFully(byte[]  buffer)                           throws IOException;
void  readFully(byte[]  buffer, int  offset, int  length) throws IOException;
int   skipBytes(int n)                                    throws IOException;

boolean  readBoolean()       throws IOException;
byte     readByte()          throws IOException;
int      readUnsignedByte()  throws IOException;
short    readShort()         throws IOException;
int      readUnsignedShort() throws IOException;
char     readChar()          throws IOException;
int      readInt()           throws IOException;
long     readLong()          throws IOException;
float    readFloat()         throws IOException;
double   readDouble()        throws IOException;

String   readLine()          throws IOException;
String   readUTF()           throws IOException;
</PRE>
</BLOCKQUOTE>
<P>
The first three methods are simply new names for <TT>skip()</TT>
and the two forms of <TT>read()</TT>
you've seen previously. Each of the next 10 methods reads in a
primitive type or its unsigned counterpart (useful for using every
bit efficiently in a binary stream). These latter methods must
return an integer of a wider size than you might think; because
integers are signed in Java, the unsigned value does not fit in
anything smaller. The final two methods read a newline (<TT>'\r'</TT>,
<TT>'\n'</TT>, or <TT>&quot;\r\n&quot;</TT>)
terminated string of characters from the stream-the first in ASCII,
and the second in Unicode.
<P>
Now that you know what the interface that <TT>DataInputStream</TT>
implements looks like, let's see it in action:
<BLOCKQUOTE>
<PRE>
DataInputStream  s = new DataInputStream(myRecordInputStream());

long  size = s.readLong();    // the number of items in the stream

while (size-- &gt; 0) {
    if (s.readBoolean()) {    // should I process this item?
        int     anInteger     = s.readInt();
        int     magicBitFlags = s.readUnsignedShort();
        double  aDouble       = s.readDouble();

        if ((magicBitFlags &amp; 0100000) != 0) {
            . . .    // high bit set, do something special
        }
        . . .    // process anInteger and aDouble
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Because the class implements an interface for all its methods,
you can also use the following interface:
<BLOCKQUOTE>
<PRE>
DataInput  d = new DataInputStream(new FileInputStream(&quot;anything&quot;));
String     line;

while ((line = d.readLine()) != null) {
    . . .     // process the line
}
</PRE>
</BLOCKQUOTE>
<H4><TT>EOFException</TT></H4>
<P>
One final point about most of <TT>DataInputStream</TT>'s
methods: When the end of the stream is reached, the methods throw
an <TT>EOFException</TT>. This is
tremendously useful and, in fact, allows you to rewrite all the
kludgey uses of <TT>-1</TT> you saw
earlier today in a much nicer fashion:
<BLOCKQUOTE>
<PRE>
DataInputStream  s = new DataInputStream(getAnInputStreamFromSomewhere());

try {
    while (true) {
        byte  b = (byte) s.readByte();
        . . .    // process the byte b
    }
} catch (EOFException e) {
    . . .    // reached end of stream
} finally {
  s.close();
}
</PRE>
</BLOCKQUOTE>
<P>
This works just as well for all but the last two of the <TT>read</TT>
methods of <TT>DataInputStream</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>skipBytes()</TT> does nothing at all on end of stream, <TT>readLine()</TT> returns <TT>null</TT>, and <TT>readUTF()</TT> might <TT>throw</TT> a <TT>UTFDataFormatException</TT>, if it notices the problem at all.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4><TT>LineNumberInputStream</TT>
</H4>
<P>
In an editor or a debugger, line numbering is crucial. To add
this valuable capability to your programs, use the filter stream
<TT>LineNumberInputStream</TT>, which
keeps track of line numbers as its stream &quot;flows through&quot;
it. It's even smart enough to remember a line number and later
restore it, during a <TT>mark()</TT>
and <TT>reset()</TT>. You might use
this class as follows:
<BLOCKQUOTE>
<PRE>
LineNumberInputStream  aLNIS;
aLNIS = new LineNumberInputStream(new FileInputStream(&quot;source&quot;));

DataInputStream  s = new DataInputStream(aLNIS);
String           line;

while ((line = s.readLine()) != null) {
    . . .    // process the line
    System.out.println(&quot;Did line number: &quot; + aLNIS.getLineNumber());
}
</PRE>
</BLOCKQUOTE>
<P>
Here, two filter streams are nested around the <TT>FileInputStream</TT>
actually providing the data-the first to read lines one at a time
and the second to keep track of the line numbers of these lines
as they go by. You must explicitly name the intermediate filter
stream, <TT>aLNIS</TT>, because if
you did not, you couldn't call <TT>getLineNumber()</TT>
later. Note that if you invert the order of the nested streams,
reading from <TT>DataInputStream</TT>
does not cause <TT>LineNumberInputStream</TT>
to &quot;see&quot; the lines.
<P>
You must put any filter streams acting as &quot;monitors&quot;
in the middle of the chain and &quot;pull&quot; the data from
the outermost filter stream so that the data will pass through
each of the monitors in turn. In the same way, buffering should
occur as far inside the chain as possible, because the buffered
stream won't be able to do its job properly unless most of the
streams that need buffering come after it in the flow. For example,
here's a silly order:
<BLOCKQUOTE>
<PRE>
new BufferedInputStream(new LineNumberInputStream(
            _new DataInputStream(new FileInputStream(&quot;foo&quot;));
</PRE>
</BLOCKQUOTE>
<P>
and here's a much better order:
<BLOCKQUOTE>
<PRE>
new DataInputStream(new LineNumberInputStream(
            _new BufferedInputStream(new FileInputStream(&quot;foo&quot;));
</PRE>
</BLOCKQUOTE>
<P>
<TT>LineNumberInputStream</TT>s can
also be told <TT>setLineNumber()</TT>,
for those few times when you know more than they do.
<H4><TT>PushbackInputStream</TT></H4>
<P>
The filter stream class <TT>PushbackInputStream</TT>
is commonly used in parsers, to &quot;push back&quot; a single
character in the input (after reading it) while trying to determine
what to do next-a simplified version of the <TT>mark()</TT>
and <TT>reset()</TT> utility you learned
about earlier. Its only addition to the standard set of <TT>InputStream</TT>
methods is <TT>unread()</TT>, which,
as you might guess, pretends that it never read the byte passed
in as its argument, and then gives that byte back as the return
value of the next <TT>read()</TT>.
<P>
Listing 19.1 shows a simple implementation of <TT>readLine()</TT>
using this class:
<HR>
<BLOCKQUOTE>
<B>Listing 19.1. A simple line reader.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:import java.io;
 2:
 3:public class  SimpleLineReader {
 4:    private FilterInputStream  s;
 5:
 6:    public  SimpleLineReader(InputStream  anIS) {
 7:        s = new DataInputStream(anIS);
 8:    }
 9:
10:    . . .    // other read() methods using stream s
11:
12:    public String  readLine() throws IOException {
13:        char[]  buffer = new char[100];
14:        int     offset = 0;
15:        byte    thisByte;
16:
17:        try {
18:loop:        while (offset &lt; buffer.length) {
19:                switch (thisByte = (byte) s.read()) {
20:                    case '\n':
21:                        break loop;
22:                    case '\r':
23:                        byte  nextByte = (byte) s.read();
24:
25:                        if (nextByte != '\n') {
26:                            if (!(s instanceof PushbackInputStream)) {
27:                                s = new PushbackInputStream(s);
28:                            }
29:                            ((PushbackInputStream) s).unread(nextByte);
30:                        }
31:                        break loop;
32:                    default:
33:                        buffer[offset++] = (char) thisByte;
34:                        break;
35:                }
36:            }
37:        } catch (EOFException e) {
38:            if (offset == 0)
39:                return null;
40:        }
41:          return String.copyValueOf(buffer, 0, offset);
42:     }
43:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This example demonstrates numerous things. For the purpose of
this example, the <TT>readLine()</TT>
method is restricted to reading the first 100 characters of the
line. In this respect, it demonstrates how <I>not</I>  to write
a general-purpose line processor (you should be able to read a
line of any size). This example does, however, show you how to
break out of an outer loop (using the <TT>loop</TT>
label in line 18 and the <TT>break</TT>
statements in lines 21 and 31), and how to produce a <TT>String</TT>
from an array of characters (in this case, from a &quot;slice&quot;
of the array of characters). This example also includes standard
uses of <TT>InputStream</TT>'s <TT>read()</TT>
for reading bytes one at a time, and of determining the end of
the stream by enclosing it in a <TT>DataInputStream</TT>
and catching <TT>EOFException</TT>.
<P>
One of the more unusual aspects of the example is the way <TT>PushbackInputStream</TT>
is used. To be sure that <TT>'\n'</TT>
is ignored following <TT>'\r'</TT>,
you have to &quot;look ahead&quot; one character; but if it is
not a <TT>'\n'</TT>, you must push
back that character. Look at the lines 26 through 29 as if you
didn't know much about the stream <TT>s</TT>.
The general technique used is instructive. First, you see whether
<TT>s</TT> is already an instance
of some kind of <TT>PushbackInputStream</TT>.
If so, you can simply use it. If not, you enclose the current
stream (whatever it is) inside a new <TT>PushbackInputStream</TT>
and use this new stream. Now, let's jump back into the context
of the example.
<P>
Line 29 following that <TT>if</TT>
statement in line 26 wants to call the method <TT>unread()</TT>.
The problem is that <TT>s</TT> has
a compile-time type of  <TT>FilterInputStream</TT>,
and thus doesn't understand that method. The previous three lines
(26) have guaranteed, however, that the runtime<I> type</I> of
the stream in <TT>s</TT> is <TT>PushbackInputStream</TT>,
so you can safely cast it to that type and then safely call <TT>unread()</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
This example was done in an unusual way for demonstration purposes. You could have simply declared a <TT>PushbackInputStream</TT> variable and always enclosed the <TT>DataInputStream</TT> in it. (Conversely, <TT>SimpleLineReader</TT>'s constructor could 
have checked whether its argument was already of the right class, the way <TT>PushbackInputStream</TT> did, before creating a new <TT>DataInputStream</TT>.) The interesting thing about this approach of wrapping a class only when needed is that it works for 
any <TT>InputStream</TT> that you hand it, and it does additional work only if it needs to. Both of these are good general design principles.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
All the subclasses of <TT>FilterInputStream</TT>
have now been described. It's time to return to the direct subclasses
of <TT>InputStream</TT>.
<H3><A NAME="TTFONTSIZEFACECourierPipedInputStreamFONTTT">
<TT>PipedInputStream</TT>
</A></H3>
<P>
This class, along with its brother class <TT>PipedOutputStream</TT>,
are covered later today (they need to be understood and demonstrated
together). For now, all you need to know is that together they
create a simple, two-way communication conduit between threads.
<H3><A NAME="TTFONTSIZEFACECourierSequenceInputStreamFONTTT">
<TT>SequenceInputStream</TT>
</A></H3>
<P>
Suppose you have two separate streams and you would like to make
a composite stream that consists of one stream followed by the
other (like appending two <TT>String</TT>s
together). This is exactly what <TT>SequenceInputStream</TT>
was created for:
<BLOCKQUOTE>
<PRE>
InputStream  s1 = new FileInputStream(&quot;theFirstPart&quot;);
InputStream  s2 = new FileInputStream(&quot;theRest&quot;);

InputStream  s  = new SequenceInputStream(s1, s2);

... s.read() ...   // reads from each stream in turn
</PRE>
</BLOCKQUOTE>
<P>
You could have &quot;faked&quot; this example by reading each
file in turn-but what if you had to hand the composite stream
<TT>s</TT> to some other method that
was expecting only a single <TT>InputStream</TT>?
Here's an example (using <TT>s</TT>)
that line-numbers the two previous files with a common numbering
scheme:
<BLOCKQUOTE>
<PRE>
LineNumberInputStream  aLNIS = new LineNumberInputStream(s);

... aLNIS.getLineNumber() ...<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Stringing together streams this way is especially useful when the streams are of unknown length and origin and were just handed to you by someone else.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
What if you want to string together more than two streams? You
could try the following:
<BLOCKQUOTE>
<PRE>
Vector  v = new Vector();
. . .   // set up all the streams and add each to the Vector
InputStream  s1 = new SequenceInputStream(v.elementAt(0), v.elementAt(1));
InputStream  s2 = new SequenceInputStream(s1, v.elementAt(2));
InputStream  s3 = new SequenceInputStream(s2, v.elementAt(3));
. . .<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <TT>Vector</TT> is a growable array of objects that can be filled, referenced (with <TT>elementAt()</TT>), and enumerated. 
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
However, it's much easier to use a different constructor that
<TT>SequenceInputStream</TT> provides:
<BLOCKQUOTE>
<PRE>
InputStream  s  = new SequenceInputStream(v.elements());
</PRE>
</BLOCKQUOTE>
<P>
This constructor takes one argument-an object of type <TT>Enumeration</TT>
(in this example, we got that object using <TT>Vector</TT>'s
<TT>elements()</TT> method). The resulting
<TT>SequenceInputStream</TT> object
contains all the streams you want to combine and returns a single
stream that reads through the data of each in turn.
<H3><A NAME="TTFONTSIZEFACECourierStringBufferInputStreamFONTTT">
<TT>StringBufferInputStream</TT>
</A></H3>
<P>
<TT>StringBufferInputStream</TT> is
exactly like <TT>ByteArrayInputStream</TT>,
but instead of being based on a byte array, it's based on an array
of characters (a <TT>String</TT>):
<BLOCKQUOTE>
<PRE>
String       buffer = &quot;Now is the time for all good men to come...&quot;;
InputStream  s      = new StringBufferInputStream(buffer);
</PRE>
</BLOCKQUOTE>
<P>
All comments that were made about <TT>ByteArrayInputStream</TT>
apply here as well.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>StringBufferInputStream</TT> is a bit of a misnomer because this input stream is actually based on a <TT>String</TT>. It should really be called <TT>StringInputStream</TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="OutputStreams"><FONT SIZE=5 COLOR=#FF0000>
Output Streams</FONT></A></H2>
<P>
An output stream is the reverse of an input stream; whereas with
an input stream you read data from the stream, with output streams
you write data to the stream. Most of the <TT>InputStream</TT>
subclasses you've already seen have their equivalent <TT>OutputStream</TT>
brother classes. If an <TT>InputStream</TT>
performs a certain operation, the brother <TT>OutputStream</TT>
performs the <I>inverse</I> operation. You'll see more of what
this means soon.
<H3><A NAME="TheAbstractClassTTFONTSIZEFACECourierOutputStreamFONTTT">
The Abstract Class <TT>OutputStream</TT>
</A></H3>
<P>
<TT>OutputStream</TT> is the abstract
class that defines the fundamental ways in which a source (producer)
writes a stream of bytes to some destination. The identity of
the destination, and the manner of the transport and storage of
the bytes, is irrelevant. When using an output stream, <I>you
</I>are the source of those bytes, and that's all you need to
know.
<H4><TT>write()</TT></H4>
<P>
The most important method to the producer of an output stream
is the one that writes bytes to the destination. This method,
<TT>write()</TT>, comes in many flavors,
each demonstrated in the following examples:<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Every one of these <TT>write()</TT> methods is defined to block until all the output requested has been written. You don't need to worry about this limitation-see the note under <TT>InputStream</TT>'s <TT>read()</TT> method if you don't remember why.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
OutputStream  s      = getAnOutputStreamFromSomewhere();
byte[]        buffer = new byte[1024];    // any size will do

fillInData(buffer);    // the data we want to output
s.write(buffer);
</PRE>
</BLOCKQUOTE>
<P>
You also can write a &quot;slice&quot; of your buffer by specifying
the offset into the buffer, and the length desired, as arguments
to <TT>write()</TT>:
<BLOCKQUOTE>
<PRE>
s.write(buffer, 100, 300);
</PRE>
</BLOCKQUOTE>
<P>
This example writes out bytes 100 through 399 and behaves otherwise
exactly the same as the previous <TT>write()</TT>
method.
<P>
Finally, you can write out bytes one at a time:
<BLOCKQUOTE>
<PRE>
while (thereAreMoreBytesToOutput()) {
    byte  b = getNextByteForOutput();

    s.write(b);
}
</PRE>
</BLOCKQUOTE>
<H4><TT>flush()</TT></H4>
<P>
Because you don't know what an output stream is connected to,
you might be required to &quot;flush&quot; your output through
some buffered cache to get it to be written (in a timely manner,
or at all). <TT>OutputStream</TT>'s
version of this method does nothing, but it is expected that subclasses
that require flushing (for example, <TT>BufferedOutputStream</TT>
and <TT>PrintStream</TT>) will override
this version to do something nontrivial.
<H4><TT>close()</TT></H4>
<P>
Just like for an <TT>InputStream</TT>,
you should (usually) explicitly close down an <TT>OutputStream</TT>
so that it can release any resources it may have reserved on your
behalf. (All the same notes and examples from <TT>InputStream</TT>'s
<TT>close()</TT> method apply here,
with the prefix <TT>In</TT> replaced
everywhere by <TT>Out</TT>.)
<P>
All output streams descend from the abstract class <TT>OutputStream</TT>.
All share the previous few methods in common.
<H3><A NAME="TTFONTSIZEFACECourierByteArrayOutputStreamFONTTT">
<TT>ByteArrayOutputStream</TT>
</A></H3>
<P>
The inverse of <TT>ByteArrayInputStream</TT>,
which creates an input stream from an array of bytes, is <TT>ByteArrayOutputStream</TT>,
which directs an output stream <I>into</I> an array of bytes:
<BLOCKQUOTE>
<PRE>
OutputStream  s = new ByteArrayOutputStream();

s.write(123);
. . .
</PRE>
</BLOCKQUOTE>
<P>
The size of the (internal) byte array grows as needed to store
a stream of any length. You can provide an initial capacity as
an aid to the class, if you like:
<BLOCKQUOTE>
<PRE>
OutputStream  s = new ByteArrayOutputStream(1024 * 1024);  // 1 Megabyte
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You've just seen your first examples  of the creation of an output stream. These new streams were attached to the simplest of all possible destinations of data, an array of bytes in the memory of the local computer.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Once the <TT>ByteArrayOutputStream</TT>
 object, stored in the variable <TT>s</TT>,
has been &quot;filled,&quot; it can be output to another output
stream:
<BLOCKQUOTE>
<PRE>
OutputStream           anotherOutputStream = getTheOtherOutputStream(); 
ByteArrayOutputStream  s = new ByteArrayOutputStream();

fillWithUsefulData(s);
s.writeTo(anotherOutputStream);
</PRE>
</BLOCKQUOTE>
<P>
It also can be extracted as a byte array or converted to a <TT>String</TT>:
<BLOCKQUOTE>
<PRE>
byte[]  buffer              = s.toByteArray();
String  bufferString        = s.toString();
String  bufferUnicodeString = s.toString(upperByteValue);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The last method allows you to &quot;fake&quot; Unicode (16-bit) characters by filling in their lower bytes with ASCII and then specifying a common upper byte (usually <TT>0</TT>) to create a Unicode <TT>String</TT> result.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>ByteArrayOutputStream</TT>s have
two utility methods: One simply returns the current number of
bytes stored in the internal byte array, and the other resets
the array so that the stream can be rewritten from the beginning:
<BLOCKQUOTE>
<PRE>
int  sizeOfMyByteArray = s.size();

s.reset();     // s.size() would now return 0
s.write(123);
. . .
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TTFONTSIZEFACECourierFileOutputStreamFONTTT">
<TT>FileOutputStream</TT>
</A></H3>
<P>
One of the most common uses of streams is to attach them to files
in the file system. Here, for example, is the creation of such
an output stream on a UNIX system:
<BLOCKQUOTE>
<PRE>
OutputStream  s = new FileOutputStream(&quot;/some/path/and/fileName&quot;);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Applets attempting to open, read, or write streams based on files in the file system will cause security violations. See the note under <TT>FileInputStream</TT> for more details.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As with <TT>FileInputStream</TT>,
you also can create the stream from a previously opened file descriptor:
<BLOCKQUOTE>
<PRE>
FileDescriptor           fd = someFileStream.getFD();
OutputStream  s  = new FileOutputStream(fd);
</PRE>
</BLOCKQUOTE>
<P>
<TT>FileOutputStream</TT> is the inverse
of <TT>FileInputStream</TT>, and it
knows the same tricks:
<BLOCKQUOTE>
<PRE>
FileOutputStream  aFOS = new FileOutputStream(&quot;aFileName&quot;);

FileDescriptor  myFD = aFOS.getFD(); // get a file descriptor

aFOS.finalize();  // will call close() when automatically called by GC
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To call the new methods, you must declare the stream variable <TT>aFOS </TT>to be of type <TT>FileOutputStream</TT>, because plain <TT>OutputStream</TT>s don't know about them.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The first is obvious: <TT>getFD()</TT>
simply returns the file descriptor for the file on which the stream
is based. The second, commented, contrived call to <TT>finalize()</TT>
is there to remind you that you may not have to worry about closing
this type of stream-it is done for you automatically. 
<H3><A NAME="TTFONTSIZEFACECourierFilterOutputStreamFONTTT">
<TT>FilterOutputStream</TT>
</A></H3>
<P>
This abstract class simply provides a &quot;pass-through&quot;
for all the standard methods of <TT>OutputStream</TT>.
It holds inside itself another stream, by definition one further
&quot;down&quot; the chain of filters, to which it forwards all
method calls. It implements nothing new but allows itself to be
nested:
<BLOCKQUOTE>
<PRE>
OutputStream        s  = getAnOutputStreamFromSomewhere();
FilterOutputStream  s1 = new FilterOutputStream(s);
FilterOutputStream  s2 = new FilterOutputStream(s1);
FilterOutputStream  s3 = new FilterOutputStream(s2);

... s3.write(123) ...
</PRE>
</BLOCKQUOTE>
<P>
Whenever a write is performed on the filtered stream <TT>s3</TT>,
it passes along the request to <TT>s2</TT>.
Then <TT>s2</TT> does the same to
<TT>s1</TT>, and finally <TT>s</TT>
is asked to output the bytes. Subclasses of <TT>FilterOutputStream</TT>,
of course, do some nontrivial processing of the bytes as they
flow past. This chain can be tightly nested-see its brother class,
<TT>FilterInputStream</TT>, for more.
<P>
Now let's examine each of the subclasses of <TT>FilterOutputStream</TT>
in turn.
<H4><TT>BufferedOutputStream</TT>
</H4>
<P>
<TT>BufferedOutputStream</TT> is one
of the most valuable of all streams. All it does is implement
the full complement of <TT>OutputStream</TT>'s
methods, but it does so by using a buffered array of bytes that
acts as a cache for writing. This decouples the rate and the size
of the &quot;chunks&quot; you're writing from the more regular,
larger block sizes in which streams are most efficiently written
(to peripheral devices, files in the file system, or the network,
for example).
<P>
<TT>BufferedOutputStream</TT> is one
of two classes in the Java library to implement <TT>flush()</TT>,
which pushes the bytes you've written through the buffer and out
the other side. Because buffering is so valuable, you might wish
that every output stream could somehow be buffered. Fortunately,
you can surround any output stream in such a way as to achieve
just that:
<BLOCKQUOTE>
<PRE>
OutputStream  s = new BufferedOutputStream(new FileOutputStream(&quot;foo&quot;));
</PRE>
</BLOCKQUOTE>
<P>
You now have a buffered output stream based on the file <TT>foo</TT>
that can be flushed.
<P>
Just as for filter input streams, any capability provided by a
filter output stream can be used by any other basic stream via
nesting, and any combination of these capabilities, in any order,
can be as easily accomplished by nesting the filter streams themselves.
<H4><TT>DataOutputStream</TT></H4>
<P>
All the methods that instances of this class understand are defined
in a separate interface, which both <TT>DataOutputStream</TT>
and <TT>RandomAccessFile</TT> implement.
This interface is general-purpose enough that you might want to
use it yourself in the classes you create. It is called <TT>DataOutput</TT>.
<H4>The <TT>DataOutput</TT> Interface</H4>
<P>
In cooperation with its brother inverse interface, <TT>DataInput</TT>,
<TT>DataOutput</TT> provides a higher-level,
typed-stream approach to the reading and writing of data. Rather
than dealing with bytes, this interface deals with writing the
primitive types of the Java language directly:
<BLOCKQUOTE>
<PRE>
void  write(int i)                                    throws IOException;
void  write(byte[]  buffer)                           throws IOException;
void  write(byte[]  buffer, int  offset, int  length) throws IOException;

void  writeBoolean(boolean b) throws IOException;
void  writeByte(int i)        throws IOException;
void  writeShort(int i)       throws IOException;
void  writeChar(int i)        throws IOException;
void  writeInt(int i)         throws IOException;
void  writeLong(long l)       throws IOException;
void  writeFloat(float f)     throws IOException;
void  writeDouble(double d)   throws IOException;

void  writeBytes(String s) throws IOException;
void  writeChars(String s) throws IOException;
void  writeUTF(String s)   throws IOException;
</PRE>
</BLOCKQUOTE>
<P>
Most of these methods have counterparts in the interface <TT>DataInput</TT>.
<P>
The first three methods mirror the three forms of <TT>write()</TT>
you saw previously. Each of the next eight methods writes out
a primitive type. The final three methods write out a string of
bytes or characters to the stream: the first one as 8-bit bytes;
the second, as 16-bit Unicode characters; and the last, as a special
Unicode stream (readable by <TT>DataInput</TT>'s
<TT>readUTF()</TT>).<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The unsigned read methods in <TT>DataInput</TT> have no counterparts here. You can write out the data they need via <TT>DataOutput</TT>'s signed methods because they accept <TT>int</TT> arguments and also because they write out the correct number of bits 
for the unsigned integer of a given size as a side effect of writing out the signed integer of that same size. It is the method that reads this integer that must interpret the sign bit correctly; the writer's job is easy.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now that you know what the interface that <TT>DataOutputStream</TT>
implements looks like, let's see it in action:
<BLOCKQUOTE>
<PRE>
DataOutputStream  s    = new DataOutputStream(myRecordOutputStream());
long              size = getNumberOfItemsInNumericStream();

s.writeLong(size);

for (int  i = 0;  i &lt; size;  ++i) {
    if (shouldProcessNumber(i)) {
        s.writeBoolean(true);     // should process this item
        s.writeInt(theIntegerForItemNumber(i));
        s.writeShort(theMagicBitFlagsForItemNumber(i));
        s.writeDouble(theDoubleForItemNumber(i));
    } else
        s.writeBoolean(false);
}
</PRE>
</BLOCKQUOTE>
<P>
This is the exact inverse of the example that was given for <TT>DataInput</TT>.
Together, they form a pair that can communicate a particular array
of structured primitive types across any stream (or &quot;transport
layer&quot;). Use this pair as a jumping-off point whenever you
need to do something similar.
<P>
In addition to the preceding interface, the class itself implements
one (self-explanatory) utility method:
<BLOCKQUOTE>
<PRE>
int  theNumberOfBytesWrittenSoFar = s.size();
</PRE>
</BLOCKQUOTE>
<H5>Processing a File</H5>
<P>
One of the most common idioms in file I/O is to open a file, read
and process it line-by-line, and output it again to another file.
Here's a prototypical example of how that would be done in Java:
<BLOCKQUOTE>
<PRE>
DataInput   aDI = new DataInputStream(new FileInputStream(&quot;source&quot;));
DataOutput  aDO = new DataOutputStream(new FileOutputStream(&quot;dest&quot;));
String      line;

while ((line = aDI.readLine()) != null) {
    StringBuffer  modifiedLine = new StringBuffer(line);

    . . .      // process modifiedLine in place
    aDO.writeBytes(modifiedLine.toString());
}
aDI.close();
aDO.close();
</PRE>
</BLOCKQUOTE>
<P>
If you want to process it byte-by-byte, use this:
<BLOCKQUOTE>
<PRE>
try {
    while (true) {
        byte  b = (byte) aDI.readByte();

        . . .      // process b in place
        aDO.writeByte(b);
    }
} finally {
    aDI.close();
    aDO.close();
}
</PRE>
</BLOCKQUOTE>
<P>
Here's a cute two-liner that just copies the file:
<BLOCKQUOTE>
<PRE>
try { while (true) aDO.writeByte(aDI.readByte()); }
finally { aDI.close(); aDO.close(); }<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Warning</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Many of the examples in today's lesson (as well as the last two) are assumed to appear inside a method that has <TT>IOException</TT> in its <TT>throws</TT> clause, so they don't have to worry about <TT>catch</TT>ing those exceptions and handling them more 
reasonably. Your code should be a little less cavalier.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4><TT>PrintStream</TT></H4>
<P>
You may not realize it, but you're already intimately familiar
with the use of two methods of the <TT>PrintStream</TT>
class. That's because whenever you use these method calls:
<BLOCKQUOTE>
<PRE>
System.out.print(. . .)
System.out.println(. . .)
</PRE>
</BLOCKQUOTE>
<P>
you are actually using a <TT>PrintStream</TT>
instance located in <TT>System</TT>'s
class variable <TT>out</TT> to perform
the output. <TT>System.err</TT> is
also a <TT>PrintStream</TT>, and <TT>System.in</TT>
is an <TT>InputStream</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
On UNIX systems, these three streams will be attached to standard output, standard error, and standard input, respectively.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>PrintStream</TT> is uniquely an
output stream class (it has no brother class). Because it is usually
attached to a screen output device of some kind, it provides an
implementation of <TT>flush()</TT>.
It also provides the familiar <TT>close()</TT>
and <TT>write()</TT> methods, as well
as a plethora of choices for outputting the primitive types and
<TT>String</TT>s of Java:
<BLOCKQUOTE>
<PRE>
public void  write(int b);
public void  write(byte[]  buffer, int  offset, int  length);
public void  flush();
public void  close();

public void  print(Object o);
public void  print(String s);
public void  print(char[]  buffer);
public void  print(char c);
public void  print(int i);
public void  print(long l);
public void  print(float f);
public void  print(double d);
public void  print(boolean b);

public void  println(Object o);
public void  println(String s);
public void  println(char[]  buffer);
public void  println(char c);
public void  println(int i);
public void  println(long l);
public void  println(float f);
public void  println(double d);
public void  println(boolean b);

public void  println();   // output a blank line
</PRE>
</BLOCKQUOTE>
<P>
<TT>PrintStream</TT> can also be wrapped
around any output stream, just like a filter class:
<BLOCKQUOTE>
<PRE>
PrintStream  s = new PrintStream(new FileOutputStream(&quot;foo&quot;));

s.println(&quot;Here's the first line of text in the file foo.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
If you provide a second argument to the constructor for <TT>PrintStream</TT>,
that second argument is a boolean that specifies whether the stream
should auto-flush. If <TT>true</TT>,
a <TT>flush()</TT> is sent after each
newline character is written.
<P>
Here's a simple sample program that operates like the UNIX command
<TT>cat</TT>, taking the standard
input, line-by-line, and outputting it to the standard output:
<BLOCKQUOTE>
<PRE>
import java.io.*;   // the one time in the chapter we'll say this

public class  Cat {
    public static void  main(String argv[]) {
        DataInput  d = new DataInputStream(System.in);
        String     line;

     try {  while ((line = d.readLine()) != null)
            System.out.println(line);
        } catch (IOException  ignored) { }
    }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TTFONTSIZEFACECourierPipedOutputStreamFONTTT">
<TT>PipedOutputStream</TT>
</A></H3>
<P>
Along with <TT>PipedInputStream</TT>,
this pair of classes supports a UNIX-pipe-like connection between
two threads, implementing all the careful synchronization that
allows this sort of &quot;shared queue&quot; to operate safely.
Use the following to set up the connection:
<BLOCKQUOTE>
<PRE>
PipedInputStream   sIn  = PipedInputStream();
PipedOutputStream  sOut = PipedOutputStream(sIn);
</PRE>
</BLOCKQUOTE>
<P>
One thread writes to <TT>sOut</TT>;
the other reads from <TT>sIn</TT>.
By setting up two such pairs, the threads can communicate safely
in both directions.
<H2><A NAME="RelatedClasses"><FONT SIZE=5 COLOR=#FF0000>
Related Classes</FONT></A></H2>
<P>
The other classes and interfaces in <TT>java.io</TT>
supplement the streams to provide a complete I/O system. Three
of them are described here.
<P>
The <TT>File</TT> class abstracts
files in a platform-independent way. Given a filename, it can
respond to queries about the type, status, and properties of a
file or directory in the file system.
<P>
A <TT>RandomAccessFile</TT> is created
given a file, a filename, or a file descriptor. It combines in
one class implementations of the <TT>DataInput</TT>
and <TT>DataOutput</TT> interfaces,
both tuned for &quot;random access&quot; to a file in the file
system. In addition to these interfaces, <TT>RandomAccessFile</TT>
provides certain traditional UNIX-like facilities, such as seeking
to a random point in the file.
<P>
Finally, the <TT>StreamTokenizer</TT>
class takes an input stream and produces a sequence of tokens.
By overriding its various methods in your own subclasses, you
can create powerful lexical parsers.
<P>
You can learn more about any and all of these other classes from
the full (online) API descriptions in your Java release.
<H2><A NAME="ObjectSerializationJava"><FONT SIZE=5 COLOR=#FF0000>
Object Serialization (Java 1.1)</FONT></A></H2>
<P>
A topic to streams, and one that will be available in the core
Java library with Java 1.1, is object serialization. <I>Serialization</I>
is the ability to write a Java object to a stream such as a file
or a network connection, and then read it and reconstruct that
object on the other side. Object serialization is crucial for
the ability to save Java objects to a file (what's called <I>object
persistence</I>), or to be able to accomplish network-based applications
that make use of Remote Method Invocation (RMI)-a capability you'll
learn more of on <A HREF="ch27.htm">Day 27</A>, &quot;The Standard Extension APIs.&quot;
<P>
At the heart of object serialization are two streams classes:
<TT>ObjectInputStream</TT>, which
inherits from <TT>DataInputStream</TT>,
and <TT>ObjectOutputStream</TT>, which
inherits from <TT>DataOutputStream</TT>.
Both of these classes will be part of the <TT>java.io</TT>
package and will be used much in the same way as the standard
input and output streams are. In addition, two interfaces, <TT>ObjectOutput</TT>
and <TT>ObjectInput</TT>, which inherit
from <TT>DataInput</TT> and <TT>DataOutput</TT>,
respectively, will provide abstract behavior for reading and writing
objects.
<P>
To use the <TT>ObjectInputStream</TT>
and <TT>ObjectOutputStream</TT> classes,
you create new instances much in the same way you do ordinary
streams, and then use the <TT>readObject()</TT>
and <TT>writeObject()</TT> methods
to read and write objects to and from those streams.
<P>
<TT>ObjectOutputStream</TT>'s <TT>writeObject()</TT>
method, which takes a single object argument, serializes that
object as well as any object it has references to. Other objects
written to the same stream are serialized as well, with references
to already-serialized objects kept track of and circular references
preserved.
<P>
<TT>ObjectInputStream</TT>'s <TT>readObject()</TT>
method takes no arguments and reads an object from the stream
(you'll need to cast that object to an object of the appropriate
class). Objects are read from the stream in the same order in
which they are written.
<P>
Here's a simple example from the object serialization specification
that writes a date to a file (actually, it writes a string label,
<TT>&quot;Today&quot;</TT>, and then
a <TT>Date</TT> object):
<BLOCKQUOTE>
<PRE>
FileOutputStream f = new FileOutputStream(&quot;tmp&quot;);
ObjectOutput  s  =  new  ObjectOutputStream(f);
s.writeObject(&quot;Today&quot;);
s.writeObject(new Date());
s.flush();
</PRE>
</BLOCKQUOTE>
<P>
To deserialize the object (read it back in again), use this code:
<BLOCKQUOTE>
<PRE>
FileInputStream in = new FileInputStream(&quot;tmp&quot;);
ObjectInputStream s = new ObjectInputStream(in);
String today = (String)s.readObject();
Date date = (Date)s.readObject();
</PRE>
</BLOCKQUOTE>
<P>
One other feature of object serialization to note is the <TT>transient</TT>
modifier. Used in instance variable declarations as other modifiers
are, the <TT>transient</TT> modifier
means that the value of that object should not be stored when
the object is serialized-that its value is temporary or will need
to be re-created from scratch once the object is reconstructed.
Use transient variables for environment-specific information (such
as file handles that may be different from one side of the serialization
to the other) or for values that can be easily recalculated to
save space in the final serialized object. 
<P>
To declare a transient variable, use the <TT>transient</TT>
modifier the way you do other modifiers such as <TT>public</TT>,
<TT>private</TT>, or <TT>abstract</TT>:
<BLOCKQUOTE>
<PRE>
public transient int transientValue = 4;
</PRE>
</BLOCKQUOTE>
<P>
At the time of this writing, object serialization is available
as an additional package for Java 1.0.2 as part of the RMI package.
You can find out more about it, including full specifications
and downloadable software, from the Java RMI Web site at <TT><A HREF="http://chatsubo.javasoft.com/current/">http://chatsubo.javasoft.com/current/</A></TT>.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Today you have learned about the general idea of streams and have
met input streams based on byte arrays, files, pipes, sequences
of other streams, and string buffers, as well as input filters
for buffering, typed data, line numbering, and pushing-back characters.
<P>
You have also met the analogous brother output streams for byte
arrays, files, and pipes,  output filters for buffering and typed
data, and the unique output filter used for printing.
<P>
Along the way, you have become familiar with the fundamental methods
all streams understand (such as <TT>read()</TT>
and <TT>write()</TT>), as well as
the unique methods many streams add to this repertoire. You have
learned about catching <TT>IOException</TT>s-especially
the most useful of them, <TT>EOFException</TT>.
<P>
Finally, the twice-useful <TT>DataInput</TT>
and <TT>DataOutput</TT> interfaces
formed the heart of <TT>RandomAccessFile</TT>,
one of the several utility classes that round out Java's I/O facilities.
<P>
Java streams provide a powerful base on which you can build multithreaded,
streaming interfaces of the most complex kinds, and the programs
(such as HotJava) to interpret them. The higher-level Internet
protocols and services of the future that your applets can build
on this base are really limited only by your imagination.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>

<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>In an early <TT><B>read()</B></TT> example, you did something with the variable <TT><B>byteOrMinus1</B></TT> that seemed a little clumsy. Isn't there a better way? If not, why recommend the 
cast later?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Yes, there is something a little odd about those statements. You might be tempted to try something like this instead:
<P>
<TT>while ((b = (byte) s.read()) != -1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;. . .&nbsp;&nbsp;&nbsp;&nbsp;// process the byte b<BR>
}</TT>
<P>
The problem with this shortcut occurs if <TT>read()</TT> returns the value <TT>0xFF (0377)</TT>. Because of the way values are cast, it will appear to be identical to the integer value <TT>-1</TT> that indicates end of stream. Only saving that value in a 
separate integer variable, and then casting it later, will accomplish the desired result. The cast to <TT>byte</TT> is recommended in the note for slightly different reasons than this, however-storing integer values in correctly sized variables is always 
good style (and besides, <TT>read()</TT> really should be returning something of <TT>byte</TT> size here and throwing an exception for end of stream).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>What input streams in <TT><B>java.io</B></TT> actually implement <TT><B>mark()</B></TT>, <TT><B>reset()</B></TT>, and <TT><B>markSupported()</B></TT>?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD><TT>InputStream</TT> itself does-and in their default implementations, <TT>markSupported()</TT> returns <TT>false</TT>, <TT>mark()</TT> does nothing, and <TT>reset()</TT> throws an exception. 
The only input stream in the current release that correctly supports marking is <TT>BufferedInputStream</TT>, which overrides these defaults. <TT>LineNumberInputStream</TT> actually implements <TT>mark()</TT> and <TT>reset()</TT>, but in the current 
release, it doesn't answer <TT>markSupported()</TT> correctly, so it looks as if it does not.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>Why is <TT><B>available()</B></TT> useful, if it sometimes gives the wrong answer? </B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>First, for many streams, it gives the right answer. Second, for some network streams, its implementation might be sending a special query to discover some information you couldn't get any other 
way (for example, the size of a file being transferred by <TT>ftp</TT>). If you are displaying a &quot;progress bar&quot; for network or file transfers, for example, <TT>available()</TT> will often give you the total size of the transfer, and when it does 
not-usually by returning <TT>0</TT>-it will be obvious to you (and your users).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>What's a good example of the use of the <TT><B>DataInput</B></TT>/<TT><B>DataOutput</B></TT> pair of interfaces?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>One common use of such a pair is when objects want to &quot;pickle&quot; themselves for storage or movement over a network. Each object implements read and write methods using these interfaces, 
effectively converting itself to a stream that can later be reconstituted &quot;on the other end&quot; into a copy of the original object.
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch18.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch20.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
