<HTML>
<HEAD>
<TITLE>appendix I -- java.io Package Reference</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>appendix&nbsp;I</FONT></H1>
<H1><FONT COLOR=#FF0000><TT>java.io</TT></FONT><FONT SIZE=6 COLOR=#FF0000>
Package Reference</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TTFONTSIZEFACECourierDataInputFONTTT">
<TT>DataInput</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierDataOutputFONTTT">
<TT>DataOutput</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierFilenameFilterFONTTT">
<TT>FilenameFilter</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierBufferedInputstreamFONTTT">
<TT>BufferedInputstream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierBufferedOutputStreamFONTTT">
<TT>BufferedOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierByteArrayInputStreamFONTTT">
<TT>ByteArrayInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierByteArrayOutputStreamFONTTT">
<TT>ByteArrayOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierDataInputStreamFONTTT">
<TT>DataInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierDataOutputStreamFONTTT">
<TT>DataOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFileFONTTT">
<TT>File</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierFileDescriptorFONTTT">
<TT>FileDescriptor</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFileInputStreamFONTTT">
<TT>FileInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFileOutputStreamFONTTT">
<TT>FileOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFilterInputStreamFONTTT">
<TT>FilterInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierFilterOutputStreamFONTTT">
<TT>FilterOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierInputStreamFONTTT">
<TT>InputStream</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierLineNumberInputStreamFONTTT">
<TT>LineNumberInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierOutputStreamFONTTT">
<TT>OutputStream</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierPipedInputStreamFONTTT">
<TT>PipedInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierPipedOutputStreamFONTTT">
<TT>PipedOutputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierPrintStreamFONTTT">
<TT>PrintStream</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierPushbackInputStreamFONTTT">
<TT>PushbackInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierRandomAccessFileFONTTT">
<TT>RandomAccessFile</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierSequenceInputStreamFONTTT">
<TT>SequenceInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierStreamTokenizerFONTTT">
<TT>StreamTokenizer</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierStringBufferInputStreamFONTTT">
<TT>StringBufferInputStream</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierEOFExceptionFONTTT">
<TT>EOFException</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierFileNotFoundExceptionFONTTT">
<TT>FileNotFoundException</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierIOExceptionFONTTT">
<TT>IOException</TT></A>
<LI><A HREF="#TTFONTSIZEFACECourierInterruptedIOExceptionFONTTT">
<TT>InterruptedIOException</TT>
</A>
<LI><A HREF="#TTFONTSIZEFACECourierUTFDataFormatExceptionFONTTT">
<TT>UTFDataFormatException</TT>
</A>
</UL>

<HR>
<P>
The <TT>java.io</TT> package provides
classes with support for reading and writing data to and from
different input and output devices, including files, strings,
and other data sources. The I/O package includes classes for inputting
streams of data, outputting streams of data, working with files,
and tokenizing streams of data.
<H2><A NAME="TTFONTSIZEFACECourierDataInputFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>DataInput</TT></FONT></A></H2>
<P>
This interface describes an input stream that can read input data
in a platform-independent manner.
<H4><TT>readBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public abstract boolean readBoolean()
throws IOException<BR>
</TT>This method reads a boolean value (byte) from the
input stream. A value of <TT>0</TT>
is interpreted as <TT>false</TT>,
while all other values are interpreted as <TT>true</TT>.
<BR>
<I><B>Returns: </B></I>The boolean value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readByte</TT></H4>
<BLOCKQUOTE>
<TT>public abstract byte readByte() throws
IOException<BR>
</TT>This method reads a signed byte (8-bit) value from
the input stream.<BR>
<I><B>Returns: </B></I>The byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readChar</TT></H4>
<BLOCKQUOTE>
<TT>public abstract char readChar() throws
IOException<BR>
</TT>This method reads a Unicode character (16-bit) value
from the input stream.<BR>
<I><B>Returns: </B></I>The Unicode character value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readDouble</TT></H4>
<BLOCKQUOTE>
<TT>public abstract double readDouble() throws
IOException<BR>
</TT>This method reads a double (64-bit) value from the
input stream.<BR>
<I><B>Returns: </B></I>The double value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFloat</TT></H4>
<BLOCKQUOTE>
<TT>public abstract float readFloat() throws
IOException<BR>
</TT>This method reads a float (32-bit) value from the
input stream.<BR>
<I><B>Returns: </B></I>The float value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void readFully(byte b[])
throws IOException<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the input stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the specified number
of bytes is read.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void readFully(byte b[],
int off, int len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the specified number
of bytes is read.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readInt</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int readInt() throws
IOException<BR>
</TT>This method reads an integer (32-bit) value from the
input stream.<BR>
<I><B>Returns: </B></I>The integer value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLine</TT></H4>
<BLOCKQUOTE>
<TT>public abstract String readLine() throws
IOException<BR>
</TT>This method reads a line of text from the input stream.
<BR>
<I><B>Returns: </B></I>A string containing the line of text read.
<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the line of text is
read.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLong</TT></H4>
<BLOCKQUOTE>
<TT>public abstract long readLong() throws
IOException<BR>
</TT>This method reads a long (64-bit) value from the input
stream.<BR>
<I><B>Returns: </B></I>The long value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readShort</TT></H4>
<BLOCKQUOTE>
<TT>public abstract short readShort() throws
IOException<BR>
</TT>This method reads a short (16-bit) value from the
input stream.<BR>
<I><B>Returns: </B></I>The short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedByte</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int readUnsignedByte()
throws IOException<BR>
</TT>This method reads an unsigned byte (8-bit) value from
the input stream.<BR>
<I><B>Returns: </B></I>The unsigned byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedShort</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int readUnsignedShort()
throws IOException<BR>
</TT>This method reads an unsigned short (16-bit) value
from the input stream.<BR>
<I><B>Returns: </B></I>The short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the value is read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUTF</TT></H4>
<BLOCKQUOTE>
<TT>public abstract String readUTF() throws
IOException<BR>
</TT>This method reads a string that has been encoded using
a modified UTF-8 format from the input stream.<BR>
<I><B>Returns: </B></I>The string read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before the string is read.
<BR>
<I><B>Throws: </B></I><TT>UTFDataFormatException</TT>
if the bytes read do not represent a valid UTF-8 encoding of a
string.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>skipBytes</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int skipBytes(int n)
throws IOException<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream, blocking until all bytes are
skipped.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before skipping the specified
number of bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierDataOutputFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>DataOutput</TT></FONT></A></H2>
<P>
This interface describes an output stream that can write output
data in a platform-independent manner.
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void write(byte b[])
throws IOException<BR>
</TT>This method writes <TT>b.length</TT>
bytes to the output stream from the byte array <TT>b</TT>,
blocking until all bytes are written.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void write(byte b[],
int off, int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are written.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void write(int b) throws
IOException<BR>
</TT>This method writes a byte value to the output stream,
blocking until the byte is written.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeBoolean(boolean
v) throws IOException<BR>
</TT>This method writes a boolean value to the output stream.
The boolean value <TT>true</TT> is
written as the byte value <TT>1</TT>,
whereas <TT>false</TT> is written
as the byte value <TT>0</TT>.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
boolean value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeByte</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeByte(int v)
throws IOException<BR>
</TT>This method writes a byte (8-bit) value to the output
stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBytes</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeBytes(String
s) throws IOException<BR>
</TT>This method writes a string to the output stream as
a sequence of bytes.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChar</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeChar(int v)
throws IOException<BR>
</TT>This method writes a character (16-bit) value to the
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
character value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChars</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeChars(String
s) throws IOException<BR>
</TT>This method writes a string to the output stream as
a sequence of characters.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as characters.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeDouble</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeDouble(double
v) throws IOException<BR>
</TT>This method writes a double (64-bit) value to the
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
double value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeFloat</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeFloat(float
v) throws IOException<BR>
</TT>This method writes a float (32-bit) value to the output
stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
float value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeInt</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeInt(int v)
throws IOException<BR>
</TT>This method writes an integer (32-bit) value to the
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
integer value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeLong</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeLong(long v)
throws IOException<BR>
</TT>This method writes a long (64-bit) value to the output
stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
long value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeShort</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeShort(int v)
throws IOException<BR>
</TT>This method writes a short (16-bit) value to the output
stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
short value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeUTF</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void writeUTF(String
str) throws IOException<BR>
</TT>This method encodes a string using a modified UTF-8
format and writes it to the output stream.<BR>
<I><B>Parameters: </B></I><TT>str</TT>-the
string to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFilenameFilterFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FilenameFilter</TT>
</FONT></A></H2>
<P>
This interface describes a filename filter used to filter directory
listings. Filename filters are used by the <TT>list</TT>
method defined in the <TT>File</TT>
class, as well as the awt's <TT>FileDialog</TT>
component.
<H4><TT>accept</TT></H4>
<BLOCKQUOTE>
<TT>public abstract boolean accept(File dir,
String name)<BR>
</TT>This method determines whether a file should be included
in a directory listing.<BR>
<I><B>Parameters: <BR>
</B></I><TT>dir</TT>-the directory
in which the file is located.<BR>
<TT>name</TT>-the filename.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file should be included in the directory list; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierBufferedInputstreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>BufferedInputstream</TT>
</FONT></A></H2>
<P>
<I><B>Extends: </B></I><TT>FilterInputStream</TT>
<P>
This class implements a buffered input stream, which allows you
to read data from a stream without causing a call to the underlying
system for each byte read. This is accomplished by reading blocks
of data into a buffer, where the data is readily accessible, independent
of the underlying stream. Subsequent reads are much faster since
they read from the buffer rather than the underlying input stream.
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
protected byte buf[]
</PRE>
</BLOCKQUOTE>
<P>
This is the buffer where data is stored.
<BLOCKQUOTE>
<PRE>
protected int count
</PRE>
</BLOCKQUOTE>
<P>
This is the number of bytes of data currently in the buffer.
<BLOCKQUOTE>
<PRE>
protected int marklimit
</PRE>
</BLOCKQUOTE>
<P>
This is the maximum number of bytes that can be read before the
marked position (<TT>markpos</TT>)
is invalidated.
<BLOCKQUOTE>
<PRE>
protected int markpos
</PRE>
</BLOCKQUOTE>
<P>
This is the position in the buffer of the current mark, which
provides a means to return to a particular location in the buffer
via the <TT>mark</TT> and <TT>reset</TT>
methods. The mark position is set to <TT>-1</TT>
if there is no current mark.
<BLOCKQUOTE>
<PRE>
protected int pos
</PRE>
</BLOCKQUOTE>
<P>
This is the current read position in the buffer.
<H4><TT>BufferedInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public BufferedInputStream(InputStream
in)<BR>
</TT>This constructor creates a new buffered input stream
with a default buffer size of 512 bytes to read data from the
<TT>in</TT> input stream.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to read data from.
</BLOCKQUOTE>
<H4><TT>BufferedInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public BufferedInputStream(InputStream
in, int size)<BR>
</TT>This constructor creates a new buffered input stream
with a buffer size of <TT>size</TT>
bytes to read data from the <TT>in</TT>
input stream.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to read data from.<BR>
<I><B>Parameters: </B></I><TT>size</TT>-the
buffer size.
</BLOCKQUOTE>
<H4><TT>availableBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the input stream without blocking. This value is
calculated by adding the number of free bytes in the buffer and
the number of bytes available in the input stream.<BR>
<I><B>Returns: </B></I>The number of available bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>markBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void mark(int readlimit)<BR>
</TT>This method marks the current read position in the
input stream. The <TT>reset</TT> method
can be used to reset the read position to this mark; subsequent
reads will read data beginning at the mark position. The mark
position is invalidated after <TT>readlimit</TT>
bytes have been read.<BR>
<I><B>Parameters: </B></I><TT>readlimit</TT>-the
maximum number of bytes that can be read before the mark position
becomes invalid.
</BLOCKQUOTE>
<H4><TT>markSupportedBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public boolean markSupported()<BR>
</TT>This method determines if the input stream supports
the <TT>mark</TT> and <TT>reset</TT>
methods.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the <TT>mark</TT> and <TT>reset</TT>
methods are supported; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>readBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the buffered input
stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the buffered input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>resetBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void reset() throws IOException
<BR>
</TT>This method resets the read position in the input
stream to the current mark position, as set by the <TT>mark</TT>
method.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if the stream has not been marked or if the mark is invalid.
</BLOCKQUOTE>
<H4><TT>skipBufferedInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public long skip(long n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierBufferedOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>BufferedOutputStream</TT>
</FONT></A></H2>
<P>
<I><B>Extends: </B></I><TT>FilterOutputStream</TT>
<P>
This class implements a buffered output stream, which allows you
to write data to a stream without causing a call to the underlying
system for each byte written. This is accomplished by writing
blocks of data into a buffer rather than directly to the underlying
output stream. The buffer is then written to the underlying output
stream when the buffer fills up or is flushed, or the stream is
closed.
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
protected byte buf[]
</PRE>
</BLOCKQUOTE>
<P>
This is the buffer where data is stored.
<BLOCKQUOTE>
<PRE>
protected int count
</PRE>
</BLOCKQUOTE>
<P>
This is the number of bytes of data currently in the buffer.
<H4><TT>BufferedOutputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public BufferedOutputStream(OutputStream
out)<BR>
</TT>This constructor creates a new buffered output stream
with a default buffer size of 512 bytes to write data to the <TT>out</TT>
output stream.<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
output stream to write data to.
</BLOCKQUOTE>
<H4><TT>BufferedOutputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public BufferedOutputStream(OutputStream
out, int size)<BR>
</TT>This constructor creates a new buffered output stream
with a buffer size of <TT>size</TT>
bytes to write data to the <TT>out</TT>
output stream.<BR>
<I><B>Parameters: <BR>
</B></I><TT>out</TT>-the output stream
to write data to.<BR>
<TT>size</TT>-the buffer size.
</BLOCKQUOTE>
<H4><TT>flushBufferedOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void flush() throws IOException
<BR>
</TT>This method flushes the output stream, resulting in
any buffered data being written to the underlying output stream.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBufferedOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the buffered output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBufferedOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the buffered output
stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierByteArrayInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>ByteArrayInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class implements an input stream whose data is
read from an array of bytes.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
protected byte buf[]
</PRE>
</BLOCKQUOTE>
<P>
This is the buffer where data is stored.
<BLOCKQUOTE>
<PRE>
protected int count
</PRE>
</BLOCKQUOTE>
<P>
This is the number of bytes of data currently in the buffer.
<BLOCKQUOTE>
<PRE>
protected int pos
</PRE>
</BLOCKQUOTE>
<P>
This is the current read position in the buffer.
<H4><TT>ByteArrayInputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public ByteArrayInputStream(byte b[])
<BR>
</TT>This constructor creates a new input stream from the
byte array <TT>b</TT>. Note that the
byte array is not copied to create the stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is read.
</BLOCKQUOTE>
<H4><TT>ByteArrayInputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public ByteArrayInputStream(byte b[],
int off, int len)<BR>
</TT>This constructor creates a new input stream of size
<TT>len</TT> from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array. Note that the byte array is not copied to create the
stream.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the maximum number of
bytes to read.
</BLOCKQUOTE>
<H4><TT>availableByteArrayInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int available()<BR>
</TT>This method determines the number of bytes that can
be read from the input stream.<BR>
<I><B>Returns: </B></I>The number of available bytes.
</BLOCKQUOTE>
<H4><TT>readByteArrayInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int read()<BR>
</TT>This method reads a byte value from the input stream.
<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.
</BLOCKQUOTE>
<H4><TT>readByteArrayInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len)<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.
</BLOCKQUOTE>
<H4><TT>resetByteArrayInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void reset()<BR>
</TT>This method resets the read position to the beginning
of the input stream.
</BLOCKQUOTE>
<H4><TT>skipByteArrayInputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public long skip(long n)<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierByteArrayOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>ByteArrayOutputStream</TT>
</FONT></A></H2>
<P>
<I><B>Extends: </B></I><TT>OutputStream</TT>
<P>
This class implements an output stream whose data is written to
an array of bytes. The byte array automatically grows as data
is written to it.
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
protected byte buf[]
</PRE>
</BLOCKQUOTE>
<P>
This is the buffer where data is stored.
<BLOCKQUOTE>
<PRE>
protected int count
</PRE>
</BLOCKQUOTE>
<P>
This is the number of bytes of data currently in the buffer.
<H4><TT>ByteArrayOutputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public ByteArrayOutputStream()<BR>
</TT>This constructor creates a new output stream with
a default buffer size of 32 bytes. The size of the buffer automatically
grows as data is written to it.
</BLOCKQUOTE>
<H4><TT>ByteArrayOutputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public ByteArrayOutputStream(int size)
<BR>
</TT>This constructor creates a new output stream with
an initial size of <TT>size</TT> bytes.
The size of the buffer automatically grows as data is written
to it.<BR>
<I><B>Parameters: </B></I><TT>size</TT>-the
initial size of the buffer.
</BLOCKQUOTE>
<H4><TT>resetByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void reset()<BR>
</TT>This method resets the contents of the underlying
byte array by setting the <TT>count</TT>
member variable to zero, resulting in the accumulated data being
discarded.
</BLOCKQUOTE>
<H4><TT>sizeByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public int size()<BR>
</TT>This method returns the current size of the buffer,
which is stored in the <TT>count</TT>
member variable.<BR>
<I><B>Returns: </B></I>The current size of the buffer.
</BLOCKQUOTE>
<H4><TT>toByteArrayByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public byte[] toByteArray()<BR>
</TT>This method creates a new byte array containing the
data currently stored in the underlying byte array associated
with the output stream.<BR>
<I><B>Returns: </B></I>A byte array containing the current data
stored in the output stream.
</BLOCKQUOTE>
<H4><TT>toStringByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public String toString()<BR>
</TT>This method creates a new string containing the data
currently stored in the underlying byte array associated with
the output stream.<BR>
<I><B>Returns: </B></I>A string containing the current data stored
in the output stream.
</BLOCKQUOTE>
<H4><TT>toStringByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public String toString(int hibyte)<BR>
</TT>This method creates a new string containing the data
currently stored in the underlying byte array associated with
the output stream, with the top 8 bits of each string character
set to <TT>hibyte</TT>.<BR>
<I><B>Parameters: </B></I><TT>hibyte</TT>-the
high byte value for each character.<BR>
<I><B>Returns: </B></I>A string containing the current data stored
in the output stream, with the high byte of each character set
to <TT>hibyte</TT>.
</BLOCKQUOTE>
<H4><TT>writeByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len)<BR>
</TT>This method writes <TT>len</TT>
bytes to the output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.
</BLOCKQUOTE>
<H4><TT>writeByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void write(int b)<BR>
</TT>This method writes a byte value to the output stream.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.
</BLOCKQUOTE>
<H4><TT>writeToByteArrayOutputStream</TT>
</H4>
<BLOCKQUOTE>
<TT>public void writeTo(OutputStream out)
throws IOException<BR>
</TT>This method writes the contents of the underlying
byte array to another output stream.<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
output stream to write to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierDataInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>DataInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>FilterInputStream
<BR>
</TT><I><B>Implements: </B></I><TT>DataInput
<BR>
</TT>This class implements an input stream that can read
Java primitive data types in a platform-independent manner.
</BLOCKQUOTE>
<H4><TT>DataInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public DataInputStream(InputStream in)
<BR>
</TT>This method creates a new data input stream to read
data from the <TT>in</TT> input stream.
<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to read data from.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public final int read(byte b[]) throws
IOException<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the data input stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public final int read(byte b[], int off,
int len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the data input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public final boolean readBoolean() throws
IOException<BR>
</TT>This method reads a boolean value (byte) from the
data input stream, blocking until the byte is read. A value of
<TT>0</TT> is interpreted as <TT>false</TT>,
and all other values are interpreted as <TT>true</TT>.
<BR>
<I><B>Returns: </B></I>The boolean value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readByte</TT></H4>
<BLOCKQUOTE>
<TT>public final byte readByte() throws IOException
<BR>
</TT>This method reads a signed byte (8-bit) value from
the data input stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>The byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readChar</TT></H4>
<BLOCKQUOTE>
<TT>public final char readChar() throws IOException
<BR>
</TT>This method reads a character (16-bit) value from
the data input stream, blocking until both bytes are read.<BR>
<I><B>Returns: </B></I>The character value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readDouble</TT></H4>
<BLOCKQUOTE>
<TT>public final double readDouble() throws
IOException<BR>
</TT>This method reads a double (64-bit) value from the
data input stream, blocking until all eight bytes are read.<BR>
<I><B>Returns: </B></I>The double value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFloat</TT></H4>
<BLOCKQUOTE>
<TT>public final float readFloat() throws
IOException<BR>
</TT>This method reads a float (32-bit) value from the
data input stream, blocking until all four bytes are read.<BR>
<I><B>Returns: </B></I>The float value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public final void readFully(byte b[])
throws IOException<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the data input stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the specified
number of bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public final void readFully(byte b[],
int off, int len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the data input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the specified
number of bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readInt</TT></H4>
<BLOCKQUOTE>
<TT>public final int readInt() throws IOException
<BR>
</TT>This method reads an integer (32-bit) value from the
data input stream, blocking until all four bytes are read.<BR>
<I><B>Returns: </B></I>The integer value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLine</TT></H4>
<BLOCKQUOTE>
<TT>public final String readLine() throws
IOException<BR>
</TT>This method reads a line of text from the data input
stream, blocking until either a newline character (<TT>'\n'</TT>)
or a carriage return character (<TT>'\r'</TT>)
is read.<BR>
<I><B>Returns: </B></I>A string containing the line of text read.
<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the line of
text.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLong</TT></H4>
<BLOCKQUOTE>
<TT>public final long readLong() throws IOException
<BR>
</TT>This method reads a long (64-bit) value from the data
input stream, blocking until all eight bytes are read.<BR>
<I><B>Returns: </B></I>The long value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readShort</TT></H4>
<BLOCKQUOTE>
<TT>public final short readShort() throws
IOException<BR>
</TT>This method reads a signed short (16-bit) value from
the data input stream, blocking until both bytes are read.<BR>
<I><B>Returns: </B></I>The short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedByte</TT></H4>
<BLOCKQUOTE>
<TT>public final int readUnsignedByte() throws
IOException<BR>
</TT>This method reads an unsigned byte (8-bit) value from
the data input stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>The unsigned byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedShort</TT></H4>
<BLOCKQUOTE>
<TT>public final int readUnsignedShort()
throws IOException<BR>
</TT>This method reads an unsigned short (16-bit) value
from the data input stream, blocking until both bytes are read.
<BR>
<I><B>Returns: </B></I>The unsigned short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUTF</TT></H4>
<BLOCKQUOTE>
<TT>public final String readUTF() throws
IOException<BR>
</TT>This method reads a string that has been encoded using
a modified UTF-8 format from the data input stream, blocking until
all bytes are read.<BR>
<I><B>Returns: </B></I>The string read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the string.
<BR>
<I><B>Throws: </B></I><TT>UTFDataFormatException</TT>
if the bytes read do not represent a valid UTF-8 encoding of a
string.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUTF</TT></H4>
<BLOCKQUOTE>
<TT>public final static String readUTF(DataInput
in) throws IOException<BR>
</TT>This method reads a string from the <TT>in</TT>
data input stream that has been encoded using a modified UTF-8
format, blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
data input stream to read the string from.<BR>
<I><B>Returns: </B></I>The string read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the string.
<BR>
<I><B>Throws: </B></I><TT>UTFDataFormatException</TT>
if the bytes read do not represent a valid UTF-8 encoding of a
string.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>skipBytes</TT></H4>
<BLOCKQUOTE>
<TT>public final int skipBytes(int n) throws
IOException<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the data input stream, blocking until all bytes
are skipped.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before skipping the specified
number of bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierDataOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>DataOutputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>FilterOutputStream
<BR>
</TT><I><B>Implements: </B></I><TT>DataOutput
<BR>
</TT>This class implements an output stream that can write
Java primitive data types in a platform-independent manner.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected int written<BR>
</TT>This is the number of bytes written to the output
stream thus far.
</BLOCKQUOTE>
<H4><TT>DataOutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public DataOutputStream(OutputStream
out)<BR>
</TT>This method creates a new data output stream to write
data to the <TT>out</TT> output stream.
<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
output stream to write data to.
</BLOCKQUOTE>
<H4><TT>flush</TT></H4>
<BLOCKQUOTE>
<TT>public void flush() throws IOException
<BR>
</TT>This method flushes the data output stream, resulting
in any buffered data being written to the underlying output stream.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>size</TT></H4>
<BLOCKQUOTE>
<TT>public final int size()<BR>
</TT>This method returns the number of bytes written to
the data output stream thus far, which is stored in the <TT>written</TT>
member variable.<BR>
<I><B>Returns: </B></I>The number of bytes written to the data
output stream thus far.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the data output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the data output
stream.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte value
to be written.<BR>
<TT>IOException</TT> if an I/O error
occurs.
</BLOCKQUOTE>
<H4><TT>writeBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeBoolean(boolean
v) throws IOException<BR>
</TT>This method writes a boolean value to the data output
stream. The boolean value <TT>true</TT>
is written as the byte value <TT>1</TT>,
where <TT>false</TT> is written as
the byte value <TT>0</TT>.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
boolean value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeByte</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeByte(int v) throws
IOException<BR>
</TT>This method writes a byte (8-bit) value to the data
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBytes</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeBytes(String s)
throws IOException<BR>
</TT>This method writes a string to the data output stream
as a sequence of bytes.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChar</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeChar(int v) throws
IOException<BR>
</TT>This method writes a character (16-bit) value to the
data output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
character value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChars</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeChars(String s)
throws IOException<BR>
</TT>This method writes a string to the data output stream
as a sequence of characters.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as characters.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeDouble</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeDouble(double
v) throws IOException<BR>
</TT>This method writes a double (64-bit) value to the
data output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
double value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeFloat</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeFloat(float v)
throws IOException<BR>
</TT>This method writes a float (32-bit) value to the data
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
float value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeInt</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeInt(int v) throws
IOException<BR>
</TT>This method writes an integer (32-bit) value to the
data output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
integer value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeLong</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeLong(long v) throws
IOException<BR>
</TT>This method writes a long (64-bit) value to the data
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
long value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeShort</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeShort(int v) throws
IOException<BR>
</TT>This method writes a short (16-bit) value to the data
output stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
short value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeUTF</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeUTF(String str)
throws IOException<BR>
</TT>This method encodes a string using a modified UTF-8
format and writes it to the data output stream.<BR>
<I><B>Parameters: </B></I><TT>str</TT>-the
string to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFileFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>File</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>This class implements a filename in a platform-independent
manner. The <TT>File</TT> class provides
the functionality necessary to work with filenames and directories
without having to deal with the complexities associated with filenames
on a particular platform.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
public final static String pathSeparator
</PRE>
</BLOCKQUOTE>
<P>
This is the platform-specific path separator string.
<BLOCKQUOTE>
<PRE>
public final static char pathSeparatorChar
</PRE>
</BLOCKQUOTE>
<P>
This is the platform-specific path separator character, which
separates filenames in a path list.
<BLOCKQUOTE>
<PRE>
public final static String separator
</PRE>
</BLOCKQUOTE>
<P>
This is the platform-specific file separator string.
<BLOCKQUOTE>
<PRE>
public final static char separatorChar
</PRE>
</BLOCKQUOTE>
<P>
This is the platform-specific file separator character, which
separates the file and directory components in a filename.
<H4><TT>File</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public File(File dir, String name)<BR>
</TT>This constructor creates a filename of an underlying
file based on the specified directory and filename. If no directory
is specified in the <TT>dir</TT> argument,
the constructor assumes the file is in the current directory.
<BR>
<I><B>Parameters: <BR>
</B></I><TT>dir</TT>-the directory
where the file is located.<BR>
<TT>name</TT>-the filename.
</BLOCKQUOTE>
<H4><TT>File</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public File(String path)<BR>
</TT>This constructor creates a filename of an underlying
file based on the specified file path.<BR>
<I><B>Parameters: </B></I><TT>path</TT>-the
file path.<BR>
<I><B>Throws: </B></I><TT>NullPointerException</TT>
if the file path is null.
</BLOCKQUOTE>
<H4><TT>File</TT> Constructor</H4>
<BLOCKQUOTE>
<TT>public File(String path, String name)
<BR>
</TT>This constructor creates a filename of an underlying
file based on the specified path and filename.<BR>
<I><B>Parameters: </B></I><TT>path</TT>-the
path where the file is located.<BR>
<I><B>Parameters: </B></I><TT>name</TT>-the
filename.
</BLOCKQUOTE>
<H4><TT>canRead</TT></H4>
<BLOCKQUOTE>
<TT>public boolean canRead()<BR>
</TT>This method determines if the underlying file can
be read from. In other words, if the file is readable <TT>canRead</TT>
determines if the file exists.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file can be read from; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>canWrite</TT></H4>
<BLOCKQUOTE>
<TT>public boolean canWrite()<BR>
</TT>This method determines if the underlying file can
be written to. In other words, if the file is writable <TT>canWrite</TT>
determines if the file exists.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file can be written to; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to the file.
</BLOCKQUOTE>
<H4><TT>delete</TT></H4>
<BLOCKQUOTE>
<TT>public boolean delete()<BR>
</TT>This method deletes the underlying file.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file is deleted; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have access to delete the file.
</BLOCKQUOTE>
<H4><TT>equals</TT></H4>
<BLOCKQUOTE>
<TT>public boolean equals(Object obj)<BR>
</TT>This method compares the pathname of the <TT>obj</TT>
<TT>File</TT> object to the pathname
of the underlying file.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to compare with.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the pathnames are equal; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>exists</TT></H4>
<BLOCKQUOTE>
<TT>public boolean exists()<BR>
</TT>This method determines if the underlying file exists
by opening it for reading and then clos-ing it.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file exists; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>getAbsolutePath</TT></H4>
<BLOCKQUOTE>
<TT>public String getAbsolutePath()<BR>
</TT>This method determines the platform-specific absolute
pathname of the underlying file.<BR>
<I><B>Returns: </B></I>The absolute pathname of the file.
</BLOCKQUOTE>
<H4><TT>getName</TT></H4>
<BLOCKQUOTE>
<TT>public String getName()<BR>
</TT>This method determines the filename of the underlying
file, which doesn't include any path information.<BR>
<I><B>Returns: </B></I>The filename of the file.
</BLOCKQUOTE>
<H4><TT>getParent</TT></H4>
<BLOCKQUOTE>
<TT>public String getParent()<BR>
</TT>This method determines the parent directory of the
underlying file, which is the immediate directory where the file
is located.<BR>
<I><B>Returns: </B></I>The parent directory of the file, or null
if the file is located in the root directory.
</BLOCKQUOTE>
<H4><TT>getPath</TT></H4>
<BLOCKQUOTE>
<TT>public String getPath()<BR>
</TT>This method determines the pathname of the underlying
file.<BR>
<I><B>Returns: </B></I>The pathname of the file.
</BLOCKQUOTE>
<H4><TT>hashCode</TT></H4>
<BLOCKQUOTE>
<TT>public int hashCode()<BR>
</TT>This method calculates a hash code for the underlying
file.<BR>
<I><B>Returns: </B></I>A hash code for the file.
</BLOCKQUOTE>
<H4><TT>isAbsolute</TT></H4>
<BLOCKQUOTE>
<TT>public boolean isAbsolute()<BR>
</TT>This method determines if this object represents an
absolute pathname for the underlying file. Note that absolute
pathnames are platform specific.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the pathname for the file is absolute; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>isDirectory</TT></H4>
<BLOCKQUOTE>
<TT>public boolean isDirectory()<BR>
</TT>This method determines if the underlying file is actually
a directory.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file is actually a directory; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>isFile</TT></H4>
<BLOCKQUOTE>
<TT>public boolean isFile()<BR>
</TT>This method determines if the underlying file is a
normal file; i.e. not a directory.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file is a normal file; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>lastModified</TT></H4>
<BLOCKQUOTE>
<TT>public long lastModified()<BR>
</TT>This method determines the last modification time
of the underlying file. Note that this time is system-specific
and is not absolute; in other words, only use the time to compare
against other times retrieved using this method.<BR>
<I><B>Returns: </B></I>The last modification time of the file,
or <TT>0</TT> if the file doesn't
exist.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>length</TT></H4>
<BLOCKQUOTE>
<TT>public long length()<BR>
</TT>This method determines the length in bytes of the
underlying file.<BR>
<I><B>Returns: </B></I>The length of the file in bytes.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>list</TT></H4>
<BLOCKQUOTE>
<TT>public String[] list()<BR>
</TT>This method builds a list of the filenames located
in the directory represented by this object. Note that the underlying
file must actually be a directory for this method to work.<BR>
<I><B>Returns: </B></I>An array containing the filenames located
in the directory.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>list</TT></H4>
<BLOCKQUOTE>
<TT>public String[] list(FilenameFilter filter)
<BR>
</TT>This method builds a list of the filenames located
in the directory represented by this object using the specified
filename filter. Note that the underlying file must actually be
a directory for this method to work.<BR>
<I><B>Parameters: </B></I><TT>filter</TT>-the
filename filter used to select the filenames.<BR>
<I><B>Returns: </B></I>An array containing the filtered filenames
located in the directory.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>mkdir</TT></H4>
<BLOCKQUOTE>
<TT>public boolean mkdir()<BR>
</TT>This method creates a directory based on the pathname
specified by this object.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the directory is created; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to the file.
</BLOCKQUOTE>
<H4><TT>mkdirs</TT></H4>
<BLOCKQUOTE>
<TT>public boolean mkdirs()<BR>
</TT>This method creates a directory based on the pathname
specified by this object, including all necessary parent directories.
<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the directory (or directories) is created; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to the file.
</BLOCKQUOTE>
<H4><TT>renameTo</TT></H4>
<BLOCKQUOTE>
<TT>public boolean renameTo(File dest)<BR>
</TT>This method renames the underlying file to the filename
specified by the <TT>dest</TT> file
object.<BR>
<I><B>Parameters: </B></I><TT>dest</TT>-the
new filename.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the file is renamed; <TT>false</TT>
otherwise.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to both the underlying
file and the file represented by the <TT>dest</TT>
file object.
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public String toString()<BR>
</TT>This method determines a string representation of
the pathname for the underlying file.<BR>
<I><B>Returns: </B></I>A string representing the pathname of the
file.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFileDescriptorFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FileDescriptor</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>This class implements a handle to a platform-specific
file or socket structure. <TT>FileDescriptor</TT>
objects are primarily used internally by the Java system and are
never created by an application directly.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
public final static FileDescriptor err
</PRE>
</BLOCKQUOTE>
<P>
This is a handle to the standard error stream.
<BLOCKQUOTE>
<PRE>
public final static FileDescriptor in
</PRE>
</BLOCKQUOTE>
<P>
This is a handle to the standard input stream.
<BLOCKQUOTE>
<PRE>
public final static FileDescriptor out
</PRE>
</BLOCKQUOTE>
<P>
This is a handle to the standard output stream.
<H4><TT>FileDescriptor</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileDescriptor()<BR>
</TT>This constructor creates a default <TT>FileDescriptor</TT>
object.
</BLOCKQUOTE>
<H4><TT>valid</TT></H4>
<BLOCKQUOTE>
<TT>public boolean valid()<BR>
</TT>This method determines whether this object represents
a valid open file or socket.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the underlying file or socket is valid; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFileInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FileInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class implements an input stream for reading
data from a file or file descriptor.
</BLOCKQUOTE>
<H4><TT>FileInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileInputStream(File file) throws
FileNotFoundException<BR>
</TT>This constructor creates a file input stream to read
data from the specified file.<BR>
<I><B>Parameters: </B></I><TT>file</TT>-the
file to be opened for reading.<BR>
<I><B>Throws: </B></I><TT>FileNotFoundException</TT>
if the file is not found.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>FileInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileInputStream(FileDescriptor
fdObj)<BR>
</TT>This constructor creates a file input stream to read
data from the file represented by the specified file descriptor.
<BR>
<I><B>Parameters: </B></I><TT>fdObj</TT>-the
file descriptor representing the file to be opened for reading.
<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>FileInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileInputStream(String name) throws
FileNotFoundException<BR>
</TT>This constructor creates a file input stream to read
data from the file with the specified filename.<BR>
<I><B>Parameters: </B></I><TT>name</TT>-the
filename of the file to be opened for reading.<BR>
<I><B>Throws: </B></I><TT>FileNotFoundException</TT>
if the file is not found.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the file input stream without blocking.<BR>
<I><B>Returns: </B></I>The number of available bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the file input stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>finalize</TT></H4>
<BLOCKQUOTE>
<TT>protected void finalize() throws IOException
<BR>
</TT>This method makes sure the <TT>close</TT>
method is called when the file input stream is cleaned up by the
Java garbage collector.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>getFD</TT></H4>
<BLOCKQUOTE>
<TT>public final FileDescriptor getFD() throws
IOException<BR>
</TT>This method determines the file descriptor associated
with the file input stream.<BR>
<I><B>Returns: </B></I>The file descriptor associated with the
stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the file input
stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[]) throws IOException
<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the file input stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the file input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>skip</TT></H4>
<BLOCKQUOTE>
<TT>public long skip(long n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the file input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFileOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FileOutputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>OutputStream<BR>
</TT>This class implements an output stream for writing
data to a file or file descriptor.
</BLOCKQUOTE>
<H4><TT>FileOutputStream</TT></H4>
<BLOCKQUOTE>
<TT>public FileOutputStream(File file) throws
IOException<BR>
</TT>This constructor creates a file output stream to write
data to the specified file.<BR>
<I><B>Parameters: </B></I><TT>file</TT>-the
file to be opened for writing.<BR>
<I><B>Throws: </B></I><TT>FileNotFoundException</TT>
if the file could not be opened for writing.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to the file.
</BLOCKQUOTE>
<H4><TT>FileOutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileOutputStream(FileDescriptor
fdObj)<BR>
</TT>This constructor creates a file output stream to write
data to the file represented by the specified file descriptor.
<BR>
<I><B>Parameters: </B></I><TT>fdObj</TT>-the
file descriptor representing the file to be opened for writing.
<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have write access to the file.
</BLOCKQUOTE>
<H4><TT>FileOutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public FileOutputStream(String name)
throws IOException<BR>
</TT>This constructor creates a file output stream to write
data to the file with the specified filename.<BR>
<I><B>Parameters: </B></I><TT>name</TT>-the
filename of the file to be opened for writing.<BR>
<I><B>Throws: </B></I><TT>FileNotFoundException</TT>
if the file is not found.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the application doesn't have read access to the file.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the file output stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>finalize</TT></H4>
<BLOCKQUOTE>
<TT>protected void finalize() throws IOException
<BR>
</TT>This method makes sure the <TT>close</TT>
method is called when the file output stream is cleaned up by
the Java garbage collector.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>getFD</TT></H4>
<BLOCKQUOTE>
<TT>public final FileDescriptor getFD() throws
IOException<BR>
</TT>This method determines the file descriptor associated
with the file output stream.<BR>
<I><B>Returns: </B></I>The file descriptor associated with the
stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[]) throws IOException
<BR>
</TT>This method writes <TT>b.length</TT>
bytes to the file output stream from the byte array <TT>b</TT>.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.<BR>
<TT>write<BR>
public void write(byte b[], int off, int len) throws IOException
<BR>
</TT>This method writes <TT>len</TT>
bytes to the file output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the file output
stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFilterInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FilterInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class defines an input stream filter that can
be used to filter data on an underlying input stream. Most of
the methods defined in <TT>FilterInputStream</TT>
simply call corresponding methods in the underlying input stream.
You simply override appropriate methods to provide the filtering
functionality. <TT>FilterInputStream</TT>
serves as the basis for all other input stream filter implementations.
Derived filtered input streams can be chained together to provide
complex filtering operations.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected InputStream in<BR>
</TT>This is the underlying input stream that is being
filtered.
</BLOCKQUOTE>
<H4><TT>FilterInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>protected FilterInputStream(InputStream
in)<BR>
</TT>This constructor creates a filtered input stream based
on the specified underlying input stream.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to be filtered.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the filtered input stream without blocking.<BR>
<I><B>Returns: </B></I>The number of available bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the filtered input stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>mark</TT></H4>
<BLOCKQUOTE>
<TT>public void mark(int readlimit)<BR>
</TT>This method marks the current read position in the
filtered input stream. The <TT>reset</TT>
method can be used to reset the read position to this mark; subsequent
reads will read data beginning at the mark position. The mark
position is invalidated after <TT>readlimit</TT>
bytes have been read.<BR>
<I><B>Parameters: </B></I><TT>readlimit</TT>-the
maximum number of bytes that can be read before the mark position
becomes invalid.
</BLOCKQUOTE>
<H4><TT>markSupported</TT></H4>
<BLOCKQUOTE>
<TT>public boolean markSupported()<BR>
</TT>This method determines if the filtered input stream
supports the <TT>mark</TT> and <TT>reset</TT>
methods.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the <TT>mark</TT> and <TT>reset</TT>
methods are supported; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the filtered input
stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[]) throws IOException
<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the filtered input stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the filtered input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>reset</TT></H4>
<BLOCKQUOTE>
<TT>public void reset() throws IOException
<BR>
</TT>This method resets the read position in the input
stream to the current mark position, as set by the <TT>mark</TT>
method.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if the stream has not been marked or if the mark is invalid.
</BLOCKQUOTE>
<H4><TT>skip</TT></H4>
<BLOCKQUOTE>
<TT>public long skip(long n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFilterOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FilterOutputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>OutputStream<BR>
</TT>This class defines an output stream filter that can
be used to filter data on an underlying output stream. Most of
the methods defined in <TT>FilterOutputStream</TT>
simply call corresponding methods in the underlying output stream.
You simply override appropriate methods to provide the filtering
functionality. <TT>FilterOutputStream</TT>
serves as the basis for all other output stream filter implementations.
Derived filtered output streams can be chained together to provide
complex filtering operations.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected OutputStream out<BR>
</TT>This is the underlying output stream that is being
filtered.
</BLOCKQUOTE>
<H4><TT>FilterOutputStream</TT></H4>
<BLOCKQUOTE>
<TT>public FilterOutputStream(OutputStream
out)<BR>
</TT>This constructor creates a filtered output stream
based on the specified underlying output stream.<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
output stream to be filtered.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the filtered output stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>flush</TT></H4>
<BLOCKQUOTE>
<TT>public void flush() throws IOException
<BR>
</TT>This method flushes the filtered output stream, resulting
in any buffered data being written to the underlying output stream.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[]) throws IOException
<BR>
</TT>This method writes <TT>b.length</TT>
bytes to the filtered output stream from the byte array <TT>b</TT>.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the filtered output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are written.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the buffered output
stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>InputStream</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>This class is an abstract class representing an input
stream of bytes. All input streams are based on <TT>InputStream</TT>.
</BLOCKQUOTE>
<H4><TT>InputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public InputStream()<BR>
</TT>This constructor creates a default input stream.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the input stream without blocking. This method should
be overridden in all subclasses, as it returns 0 in <TT>InputStream</TT>.
<BR>
<I><B>Returns: </B></I>The number of available bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the input stream, releasing any
resources associated with the stream. This method should usually
be overridden in subclasses, as it does nothing in <TT>InputStream</TT>.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>mark</TT></H4>
<BLOCKQUOTE>
<TT>public void mark(int readlimit)<BR>
</TT>This method marks the current read position in the
input stream. The <TT>reset</TT> method
can be used to reset the read position to this mark; subsequent
reads will read data beginning at the mark position. The mark
position is invalidated after <TT>readlimit</TT>
bytes have been read. This method should usually be overridden
in subclasses, as it does nothing in <TT>InputStream</TT>.
<BR>
<I><B>Parameters: </B></I><TT>readlimit</TT>-the
maximum number of bytes that can be read before the mark position
becomes invalid.
</BLOCKQUOTE>
<H4><TT>markSupported</TT></H4>
<BLOCKQUOTE>
<TT>public boolean markSupported()<BR>
</TT>This method determines if the input stream supports
the <TT>mark</TT> and <TT>reset</TT>
methods. This method should usually be overridden in subclasses,
as it always returns false in <TT>InputStream</TT>.
<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the <TT>mark</TT> and <TT>reset</TT>
methods are supported; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public abstract int read() throws IOException
<BR>
</TT>This method reads a byte value from the input stream,
blocking until the byte is read. This method must be overridden
in all subclasses, as it is defined as abstract in <TT>InputStream</TT>.
<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[]) throws IOException
<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the input stream into the byte array <TT>b</TT>,
blocking until all bytes are read. This method actually calls
the three-parameter version of <TT>read</TT>
passing <TT>b</TT>, <TT>0</TT>,
and <TT>b.length</TT> as the parameters.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read. This method actually
reads each byte by calling the <TT>read</TT>
method that takes no parameters. Subclasses should provide a more
efficient implementation of this method that isn't reliant on
the other <TT>read</TT> method if
possible.<BR>
<I><B>Parameters:<BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>reset</TT></H4>
<BLOCKQUOTE>
<TT>public void reset() throws IOException
<BR>
</TT>This method resets the read position in the input
stream to the current mark position, as set by the <TT>mark</TT>
method. This method should be overridden in subclasses requiring
mark/reset functionality, as it always throws an <TT>IOException</TT>
in <TT>InputStream</TT>; this is a
result of the fact that input streams don't support mark/reset
functionality by default.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if the stream has not been marked or if the mark is invalid.
</BLOCKQUOTE>
<H4><TT>skip</TT></H4>
<BLOCKQUOTE>
<TT>public long skip(long n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream. This method should usually
be overridden with a more efficient version in subclasses, as
it reads skipped data into a temporary byte array in <TT>InputStream</TT>.
<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierLineNumberInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>LineNumberInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>FilterInputStream
<BR>
</TT>This class implements an input stream that keeps track
of how many lines have passed through the stream. A line is defined
as a sequence of bytes followed by either a carriage return character
(<TT>'\r'</TT>), a newline character
(<TT>'\n'</TT>), or a carriage return
character immediately followed by a newline character. In all
three cases, the new line is interpreted as a single character.
</BLOCKQUOTE>
<H4><TT>LineNumberInputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public LineNumberInputStream(InputStream
in)<BR>
</TT>This constructor creates a line number input stream
that counts lines based on the specified input stream.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to count lines from.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the input stream without blocking. Note that this
number could be as little as half as large as that of the underlying
stream, since <TT>LineNumberInputStream</TT>
combines carriage return/newline character pairs into a single
new line byte.<BR>
<I><B>Returns: </B></I>The number of available bytes.
</BLOCKQUOTE>
<H4><TT>getLineNumber</TT></H4>
<BLOCKQUOTE>
<TT>public int getLineNumber()<BR>
</TT>This method determines the current line number for
the input stream, which is the count of how many lines the stream
has processed.<BR>
<I><B>Returns: </B></I>The current line number.
</BLOCKQUOTE>
<H4><TT>mark</TT></H4>
<BLOCKQUOTE>
<TT>public void mark(int readlimit)<BR>
</TT>This method marks the current read position in the
input stream. The <TT>reset</TT> method
can be used to reset the read position to this mark; subsequent
reads will read data beginning at the mark position. The mark
position is invalidated after <TT>readlimit</TT>
bytes have been read. <TT>mark</TT>
makes sure to store away the current line number so it isn't invalidated
by a subsequent call to reset.<BR>
<I><B>Parameters: </B></I><TT>readlimit</TT>-the
maximum number of bytes that can be read before the mark position
becomes invalid.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the input stream,
blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>reset</TT></H4>
<BLOCKQUOTE>
<TT>public void reset() throws IOException
<BR>
</TT>This method resets the read position in the input
stream to the current mark position, as set by the <TT>mark</TT>
method. The current line number is reset to the value it held
when the <TT>mark</TT> method was
called.
</BLOCKQUOTE>
<H4><TT>setLineNumber</TT></H4>
<BLOCKQUOTE>
<TT>public void setLineNumber(int lineNumber)
<BR>
</TT>This method sets the current line number to the specified
line number.<BR>
<I><B>Parameters: </B></I><TT>lineNumber</TT>-the
new line number to be set.
</BLOCKQUOTE>
<H4><TT>skip</TT></H4>
<BLOCKQUOTE>
<TT>public long skip(long n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>OutputStream</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>This class is an abstract class representing an output
stream of bytes. All output streams are based on <TT>OutputStream</TT>.
</BLOCKQUOTE>
<H4><TT>OutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public OutputStream()<BR>
</TT>This constructor creates a default output stream.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the output stream, releasing any
resources associated with the stream. This method should usually
be overridden in subclasses, as it does nothing in <TT>OutputStream</TT>.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>flush</TT></H4>
<BLOCKQUOTE>
<TT>public void flush() throws IOException
<BR>
</TT>This method flushes the output stream, resulting in
any buffered data being written to the underlying output stream.
This method should usually be overridden in subclasses, as it
does nothing in <TT>OutputStream</TT>.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[]) throws IOException
<BR>
</TT>This method writes <TT>b.length</TT>
bytes to the output stream from the byte array <TT>b</TT>.
This method actually calls the three-parameter version of <TT>write</TT>
passing <TT>b</TT>, <TT>0</TT>,
and <TT>b.length</TT> as the parameters.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array. This method actually writes each byte by calling the
<TT>write</TT> method that takes one
parameter. Subclasses should provide a more efficient implementation
of this method that isn't reliant on the other <TT>write</TT>
method if possible.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public abstract void write(int b) throws
IOException<BR>
</TT>This method writes a byte value to the output stream.
This method must be overridden in all subclasses, as it is defined
as abstract in <TT>OutputStream</TT>.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierPipedInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>PipedInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class implements a piped input stream, which
acts as the receiving end of a communications pipe. Piped input
streams must be connected to a piped output stream to receive
data. In other words, a piped output stream must be used to send
the data received by a piped input stream.
</BLOCKQUOTE>
<H4><TT>PipedInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PipedInputStream()<BR>
</TT>This constructor creates a piped input stream that
isn't connected to anything. The stream must be connected to a
piped output stream via the <TT>connect</TT>
method before it can be used.
</BLOCKQUOTE>
<H4><TT>PipedInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PipedInputStream(PipedOutputStream
src) throws IOException<BR>
</TT>This constructor creates a piped input stream that
is connected to the specified piped output stream.<BR>
<I><B>Parameters: </B></I><TT>src</TT>-the
piped output stream to connect to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the piped input stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>connect</TT></H4>
<BLOCKQUOTE>
<TT>public void connect(PipedOutputStream
src) throws IOException<BR>
</TT>This method connects the input stream to the specified
piped output stream.<BR>
<I><B>Parameters: </B></I><TT>src</TT>-the
piped output stream to connect to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the piped input
stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the piped input stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierPipedOutputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>PipedOutputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>OutputStream<BR>
</TT>This class implements a piped output stream, which
acts as the sending end of a communications pipe. Piped output
streams must be connected to a piped input stream to send data.
In other words, a piped input stream must be used to receive the
data sent by a piped output stream.
</BLOCKQUOTE>
<H4><TT>PipedOutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PipedOutputStream()<BR>
</TT>This constructor creates a piped output stream that
isn't connected to anything. The stream must be connected to a
piped input stream via the <TT>connect</TT>
method before it can be used.
</BLOCKQUOTE>
<H4><TT>PipedOutputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PipedOutputStream(PipedInputStream
snk) throws IOException<BR>
</TT>This constructor creates a piped output stream that
is connected to the specified piped input stream.<BR>
<I><B>Parameters: </B></I><TT>snk</TT>-the
piped input stream to connect to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the piped output stream, releasing
any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>connect</TT></H4>
<BLOCKQUOTE>
<TT>public void connect(PipedInputStream
snk) throws IOException<BR>
</TT>This method connects the output stream to the specified
piped input stream.<BR>
<I><B>Parameters: </B></I><TT>snk</TT>-the
piped input stream to connect to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the piped output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the piped output
stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierPrintStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>PrintStream</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>FilterOutputStream
<BR>
</TT>This class implements an output stream that has additional
methods for printing basic types of data. You can set up the stream
so that it is flushed every time a newline character (<TT>'\n'</TT>)
is written. Note that only the lower 8 bits of any 16-bit value
are printed to the stream.
</BLOCKQUOTE>
<H4><TT>PrintStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PrintStream(OutputStream out)
<BR>
</TT>This constructor creates a print stream that writes
data to the specified underlying output stream.<BR>
<I><B>Parameters: </B></I><TT>out</TT>-the
output stream to be written to.
</BLOCKQUOTE>
<H4><TT>PrintStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PrintStream(OutputStream out,
boolean autoflush)<BR>
</TT>This constructor creates a print stream that writes
data to the specified underlying output stream, with an option
of flushing its output each time a newline character (<TT>'\n'</TT>)
is encountered.<BR>
<I><B>Parameters: <BR>
</B></I><TT>out</TT>-the output stream
to be written to.<BR>
<TT>autoflush</TT>-a boolean value
specifying whether the stream is flushed when a newline character
is encountered.
</BLOCKQUOTE>
<H4><TT>checkError</TT></H4>
<BLOCKQUOTE>
<TT>public boolean checkError()<BR>
</TT>This method flushes the underlying output stream and
determines whether an error has occurred on the stream. Note that
errors are cumulative, meaning that once an error is encountered,
<TT>checkError</TT> will continue
to return true on all successive calls.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the print stream has ever encountered an error on the underlying
output stream; <TT>false</TT> otherwise.
<BR>
<TT>public void close()<BR>
</TT>This method closes the print stream, releasing any
resources associated with the underlying output stream.
</BLOCKQUOTE>
<H4><TT>flush</TT></H4>
<BLOCKQUOTE>
<TT>public void flush()<BR>
</TT>This method flushes the print stream, resulting in
any buffered data being written to the underlying output stream.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(boolean b)<BR>
</TT>This method prints the string representation of a
boolean value to the underlying output stream. If the boolean
value is true, the string <TT>&quot;true&quot;</TT>
is printed; otherwise, the string <TT>&quot;false&quot;</TT>
is printed.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
boolean value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(char c)<BR>
</TT>This method prints the lower 8 bits of a character
value to the underlying output stream.<BR>
<I><B>Parameters: </B></I><TT>c</TT>-the
character value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(char s[])<BR>
</TT>This method prints the lower 8 bits of each character
value in an array of characters to the underlying output stream.
<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
array of characters to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(double d)<BR>
</TT>This method prints the string representation of a
double value to the underlying output stream. Note that the string
representation is the same as that returned by the <TT>toString</TT>
method of the <TT>Double</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>d</TT>-the
double value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(float f)<BR>
</TT>This method prints the string representation of a
float value to the underlying output stream. Note that the string
representation is the same as that returned by the <TT>toString</TT>
method of the <TT>Float</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>f</TT>-the
float value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(int i)<BR>
</TT>This method prints the string representation of an
integer value to the underlying output stream. Note that the string
representation is the same as that returned by the <TT>toString</TT>
method of the <TT>Integer</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>i</TT>-the
integer value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(long l)<BR>
</TT>This method prints the string representation of a
long value to the underlying output stream. Note that the string
representation is the same as that returned by the <TT>toString</TT>
method of the <TT>Long</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>l</TT>-the
long value to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(Object obj)<BR>
</TT>This method prints the string representation of an
object to the underlying output stream. Note that the string representation
is the same as that returned by the <TT>toString</TT>
method of the object.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to be printed.
</BLOCKQUOTE>
<H4><TT>print</TT></H4>
<BLOCKQUOTE>
<TT>public void print(String s)<BR>
</TT>This method prints the lower 8 bits of each character
in a string to the underlying output stream. If the string is
null, the string <TT>&quot;null&quot;</TT>
is printed.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println()<BR>
</TT>This method prints the newline character (<TT>'\n'</TT>)
to the underlying output stream.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(boolean b)<BR>
</TT>This method prints the string representation of a
boolean value to the underlying output stream, followed by a newline
character (<TT>'\n'</TT>). If the
boolean value is true, the string <TT>&quot;true&quot;</TT>
is printed; otherwise, the string <TT>&quot;false&quot;</TT>
is printed.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
boolean value to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(char c)<BR>
</TT>This method prints the lower 8 bits of a character
value to the underlying output stream, followed by a newline character.
<BR>
<I><B>Parameters: </B></I><TT>c</TT>-the
character value to be printed
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(char s[])<BR>
</TT>This method prints the lower 8 bits of each character
value in an array of characters to the underlying output stream,
followed by a newline character.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
array of characters to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(double d)<BR>
</TT>This method prints the string representation of a
double value to the underlying output stream, followed by a newline
character. Note that the string representation is the same as
that returned by the <TT>toString</TT>
method of the <TT>Double</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>d</TT>-the
double value to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(float f)<BR>
</TT>This method prints the string representation of a
float value to the underlying output stream, followed by a newline
character. Note that the string representation is the same as
that returned by the <TT>toString</TT>
method of the <TT>Float</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>f</TT>-the
float value to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(int i)<BR>
</TT>This method prints the string representation of an
integer value to the underlying output stream, followed by a newline
character. Note that the string representation is the same as
that returned by the <TT>toString</TT>
method of the <TT>Integer</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>i</TT>-the
integer value to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(long l)<BR>
</TT>This method prints the string representation of a
long value to the underlying output stream, followed by a newline
character. Note that the string representation is the same as
that returned by the <TT>toString</TT>
method of the <TT>Long</TT> class.
<BR>
<I><B>Parameters: </B></I><TT>l</TT>-the
long value to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(Object obj)<BR>
</TT>This method prints the string representation of an
object to the underlying output stream, followed by a newline
character. Note that the string representation is the same as
that returned by the <TT>toString</TT>
method of the object.<BR>
<I><B>Parameters: </B></I><TT>obj</TT>-the
object to be printed.
</BLOCKQUOTE>
<H4><TT>println</TT></H4>
<BLOCKQUOTE>
<TT>public void println(String s)<BR>
</TT>This method prints the lower 8 bits of each character
in a string to the underlying output stream, followed by a newline
character. If the string is null, the string <TT>&quot;null&quot;</TT>
is printed.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be printed.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len)<BR>
</TT>This method writes <TT>len</TT>
bytes to the underlying output stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b)<BR>
</TT>This method writes a byte value to the underlying
output stream. The <TT>write</TT>
method of the underlying output stream is actually called to write
the byte value. Additionally, if the byte represents the newline
character (<TT>'\n'</TT>) and autoflush
is turned on, the <TT>flush</TT> method
is called.<BR>
If an <TT>IOException</TT> is thrown
while writing the byte, the exception is caught and an internal
error flag is set; this flag can be checked by calling the <TT>checkError</TT>
method. This technique is used to alleviate having to use a <TT>try</TT>-<TT>catch</TT>
clause every time you want to print something.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierPushbackInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>PushbackInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>FilterInputStream
<BR>
</TT>This class implements a input stream filter that provides
a one byte push back buffer. Using the <TT>PushbackInputStream</TT>
class, an application can push the last byte read back into the
stream so it will be re-read the next time the <TT>read</TT>
method is called. This functionality is sometimes useful in situations
where byte-delimited data is being read; the delimited bytes can
be pushed back into the stream so the next read operation will
read them.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<TT>protected int pushBack<BR>
</TT>This is the push back buffer containing the character
that was pushed back. A value of <TT>-1</TT>
indicates that the push back buffer is empty.
</BLOCKQUOTE>
<H4><TT>PushbackInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public PushbackInputStream(InputStream
in)<BR>
</TT>This constructor creates a push back input stream
using the specified underlying input stream.<BR>
<I><B>Parameters: </B></I><TT>in</TT>-the
input stream to use the push back filter on.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available() throws IOException
<BR>
</TT>This method determines the number of bytes that can
be read from the push back input stream without blocking.<BR>
<I><B>Returns: </B></I>The number of available bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>markSupported</TT></H4>
<BLOCKQUOTE>
<TT>public boolean markSupported()<BR>
</TT>This method determines if the push back input stream
supports the <TT>mark</TT> and <TT>reset</TT>
methods.<BR>
<I><B>Returns: </B></I><TT>true</TT>
if the <TT>mark</TT> and <TT>reset</TT>
methods are supported; <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the push back
input stream, blocking until the byte is read. The <TT>read</TT>
method actually returns the push back character if there is one,
and calls the underlying input stream's <TT>read</TT>
method if not.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte bytes[], int off,
int len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the buffered input stream into the byte array <TT>bytes</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>bytes</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>unread</TT></H4>
<BLOCKQUOTE>
<TT>public void unread(int ch) throws IOException
<BR>
</TT>This method pushes a character back into the stream
so that it is read the next time the <TT>read</TT>
method is called. Note that there can only be one push back character,
meaning that multiple calls to <TT>unread</TT>
without matching calls to <TT>read</TT>
will result in an <TT>IOException</TT>
being thrown.<BR>
<I><B>Parameters: </B></I><TT>ch</TT>-the
character to push back into the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an attempt is made to push back more than one character.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierRandomAccessFileFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>RandomAccessFile</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT><I><B>Implements: </B></I><TT>DataOutput</TT>,
<TT>DataInput<BR>
</TT>This class implements a random access file stream,
providing functionality for both reading from and writing to random
access files.
</BLOCKQUOTE>
<H4><TT>RandomAccessFile</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public RandomAccessFile(String name,
String mode) throws IOException<BR>
</TT>This constructor creates a random access file stream
based on the file with the specified filename and access mode.
There are two supported access modes: Mode <TT>&quot;r&quot;</TT>
is for read-only files and mode <TT>&quot;rw&quot;</TT>
is for read/write files.<BR>
<I><B>Parameters: <BR>
</B></I><TT>name</TT>-the filename
of the file to access.<BR>
<TT>mode</TT>-the access mode.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.<BR>
<I><B>Throws: </B></I><TT>IllegalArgumentException</TT>
if the access mode is not equal to <TT>&quot;r&quot;</TT>
or <TT>&quot;rw&quot;</TT>.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the access mode is <TT>&quot;r&quot;</TT>
and the application doesn't have read access to the file, or if
the access mode is <TT>&quot;rw&quot;</TT>
and the application doesn't have both read and write access to
the file.
</BLOCKQUOTE>
<H4><TT>RandomAccessFile</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public RandomAccessFile(File file, String
mode) throws IOException<BR>
</TT>This constructor creates a random access file stream
based on the specified file and access mode. There are two supported
access modes: mode <TT>&quot;r&quot;</TT>
is for read-only files and mode <TT>&quot;rw&quot;</TT>
is for read/write files.<BR>
<I><B>Parameters: <BR>
</B></I><TT>file</TT>-the file to
access.<BR>
<TT>mode</TT>-the access mode.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.<BR>
<I><B>Throws: </B></I><TT>IllegalArgumentException</TT>
if the access mode is not equal to <TT>&quot;r&quot;</TT>
or <TT>&quot;rw&quot;</TT>.<BR>
<I><B>Throws: </B></I><TT>SecurityException</TT>
if the access mode is <TT>&quot;r&quot;</TT>
and the application doesn't have read access to the file, or if
the access mode is <TT>&quot;rw&quot;</TT>
and the application doesn't have both read and write access to
the file.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the random access file stream,
releasing any resources associated with the stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>getFD</TT></H4>
<BLOCKQUOTE>
<TT>public final FileDescriptor getFD() throws
IOException<BR>
</TT>This method determines the file descriptor associated
with the random access file stream.<BR>
<I><B>Returns: </B></I>The file descriptor associated with the
stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>getFilePointer</TT></H4>
<BLOCKQUOTE>
<TT>public long getFilePointer() throws IOException
<BR>
</TT>This method determines the current read/write position
in bytes of the random access file stream, which is the offset
of the read/write position from the beginning of the stream.<BR>
<I><B>Returns: </B></I>The current read/write position of the
stream.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>length</TT></H4>
<BLOCKQUOTE>
<TT>public long length() throws IOException
<BR>
</TT>This method determines the length in bytes of the
underlying file.<BR>
<I><B>Returns: </B></I>The length of the underlying file.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the random access
file stream, blocking until the byte is read.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[]) throws IOException
<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the random access file stream into the byte array <TT>b</TT>,
blocking until at least one byte is available.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Returns: </B></I>The total number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the random access file stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until at least one byte is available.<BR>
<I><B>Parameters:<BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The total number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public final boolean readBoolean() throws
IOException<BR>
</TT>This method reads a boolean value (byte) from the
random access file stream. A value of <TT>0</TT>
is interpreted as <TT>false</TT>,
while all other values are interpreted as <TT>true</TT>.
<BR>
<I><B>Returns: </B></I>The boolean value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readByte</TT></H4>
<BLOCKQUOTE>
<TT>public final byte readByte() throws IOException
<BR>
</TT>This method reads a signed byte (8-bit) value from
the random access file stream, blocking until the byte is read.
<BR>
<I><B>Returns: </B></I>The byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readChar</TT></H4>
<BLOCKQUOTE>
<TT>public final char readChar() throws IOException
<BR>
</TT>This method reads a character (16-bit) value from
the random access file stream, blocking until both bytes are read.
<BR>
<I><B>Returns: </B></I>The character value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readDouble</TT></H4>
<BLOCKQUOTE>
<PRE>
public final double readDouble() throws IOException
</PRE>
</BLOCKQUOTE>
<BLOCKQUOTE>
This method reads a double (64-bit) value from the random access
file stream, blocking until all eight bytes are read.<BR>
<I><B>Returns: </B></I>The double value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFloat</TT></H4>
<BLOCKQUOTE>
<TT>public final float readFloat() throws
IOException<BR>
</TT>This method reads a float (32-bit) value from the
random access file stream, blocking until all four bytes are read.
<BR>
<I><B>Returns: </B></I>The float value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public final void readFully(byte b[])
throws IOException<BR>
</TT>This method reads up to <TT>b.length</TT>
bytes from the random access file stream into the byte array <TT>b</TT>,
blocking until all bytes are read.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array into which the data is read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readFully</TT></H4>
<BLOCKQUOTE>
<TT>public final void readFully(byte b[],
int off, int len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the random access file stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readInt</TT></H4>
<BLOCKQUOTE>
<TT>public final int readInt() throws IOException
<BR>
</TT>This method reads an integer (32-bit) value from the
random access file stream, blocking until all four bytes are read.
<BR>
<I><B>Returns: </B></I>The integer value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLine</TT></H4>
<BLOCKQUOTE>
<TT>public final String readLine() throws
IOException<BR>
</TT>This method reads a line of text from the random access
file stream, blocking until either a newline character (<TT>'\n'</TT>)
or a carriage return character (<TT>'\r'</TT>)
is read.<BR>
<I><B>Returns: </B></I>A string containing the line of text read.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readLong</TT></H4>
<BLOCKQUOTE>
<TT>public final long readLong() throws IOException
<BR>
</TT>This method reads a long (64-bit) value from the random
access file stream, blocking until all eight bytes are read.<BR>
<I><B>Returns: </B></I>The long value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readShort</TT></H4>
<BLOCKQUOTE>
<TT>public final short readShort() throws
IOException<BR>
</TT>This method reads a short (16-bit) value from the
random access file stream, blocking until both bytes are read.
<BR>
<I><B>Returns: </B></I>The short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedByte</TT></H4>
<BLOCKQUOTE>
<TT>public final int readUnsignedByte() throws
IOException<BR>
</TT>This method reads an unsigned byte (8-bit) value from
the random access file stream, blocking until the byte is read.
<BR>
<I><B>Returns: </B></I>The unsigned byte value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUnsignedShort</TT></H4>
<BLOCKQUOTE>
<TT>public final int readUnsignedShort()
throws IOException<BR>
</TT>This method reads an unsigned short (16-bit) value
from the random access file stream, blocking until both bytes
are read.<BR>
<I><B>Returns: </B></I>The unsigned short value read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the value.
<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>readUTF</TT></H4>
<BLOCKQUOTE>
<TT>public final String readUTF() throws
IOException<BR>
</TT>This method reads a string that has been encoded using
a modified UTF-8 format from the random access file stream, blocking
until all bytes are read.<BR>
<I><B>Returns: </B></I>The string read.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before reading the string.
<BR>
<I><B>Throws: </B></I><TT>UTFDataFormatException</TT>
if the bytes read do not represent a valid UTF-8 encoding of a
string.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>seek</TT></H4>
<BLOCKQUOTE>
<TT>public void seek(long pos) throws IOException
<BR>
</TT>This method sets the current stream position to the
specified absolute position. The position is absolute because
it is always relative to the beginning of the stream.<BR>
<I><B>Parameters: </B></I><TT>pos</TT>-the
absolute position to seek to.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>skipBytes</TT></H4>
<BLOCKQUOTE>
<TT>public int skipBytes(int n) throws IOException
<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the random access file stream, blocking until
all bytes are skipped.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.<BR>
<I><B>Throws: </B></I><TT>EOFException</TT>
if the end of the stream is reached before skipping the specified
number of bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[]) throws IOException
<BR>
</TT>This method writes <TT>b.length</TT>
bytes to the random access file stream from the byte array <TT>b</TT>.
<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte array from which the data is written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(byte b[], int off,
int len) throws IOException<BR>
</TT>This method writes <TT>len</TT>
bytes to the random access file stream from the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array.<BR>
<I><B>Parameters:<BR>
</B></I><TT>b</TT>-the byte array
from which the data is written.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be read from.<BR>
<TT>len</TT>-the number of bytes to
write.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>write</TT></H4>
<BLOCKQUOTE>
<TT>public void write(int b) throws IOException
<BR>
</TT>This method writes a byte value to the random access
file stream.<BR>
<I><B>Parameters: </B></I><TT>b</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBoolean</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeBoolean(boolean
v) throws IOException<BR>
</TT>This method writes a boolean value to the random access
file stream. The boolean value <TT>true</TT>
is written as the byte value <TT>1</TT>,
where <TT>false</TT> is written as
the byte value <TT>0</TT>.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
boolean value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeByte</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeByte(int v) throws
IOException<BR>
</TT>This method writes a byte (8-bit) value to the random
access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
byte value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeBytes</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeBytes(String s)
throws IOException<BR>
</TT>This method writes a string to the random access file
stream as a sequence of bytes.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as bytes.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChar</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeChar(int v) throws
IOException<BR>
</TT>This method writes a character (16-bit) value to the
random access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
character value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeChars</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeChars(String s)
throws IOException<BR>
</TT>This method writes a string to the random access file
stream as a sequence of characters.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
string to be written as characters.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeDouble</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeDouble(double
v) throws IOException<BR>
</TT>This method writes a double (64-bit) value to the
random access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
double value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeFloat</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeFloat(float v)
throws IOException<BR>
</TT>This method writes a float (32-bit) value to the random
access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
float value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeInt</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeInt(int v) throws
IOException<BR>
</TT>This method writes an integer (32-bit) value to the
random access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
integer value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeLong</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeLong(long v) throws
IOException<BR>
</TT>This method writes a long (64-bit) value to the random
access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
long value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeShort</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeShort(int v) throws
IOException<BR>
</TT>This method writes a short (16-bit) value to the random
access file stream.<BR>
<I><B>Parameters: </B></I><TT>v</TT>-the
short value to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>writeUTF</TT></H4>
<BLOCKQUOTE>
<TT>public final void writeUTF(String str)
throws IOException<BR>
</TT>This method encodes a string using a modified UTF-8
format and writes it to the random access file stream.<BR>
<I><B>Parameters: </B></I><TT>str</TT>-the
string to be written.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierSequenceInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>SequenceInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class implements an input stream that can combine
several input streams in a serial manner so that they function
together like a single input stream. Each input stream comprising
the sequence is read from in turn; the sequence input stream handles
closing streams as they finish and switching to the next one.
</BLOCKQUOTE>
<H4><TT>SequenceInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public SequenceInputStream(Enumeration
e)<BR>
</TT>This constructor creates a sequence input stream containing
the specified enumerated list of input streams.<BR>
<I><B>Parameters: </B></I><TT>e</TT>-the
list of input streams for the sequence.
</BLOCKQUOTE>
<H4><TT>SequenceInputStream</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public SequenceInputStream(InputStream
s1, InputStream s2)<BR>
</TT>This constructor creates a sequence input stream containing
the two specified input streams.<BR>
<I><B>Parameters: <BR>
</B></I><TT>s1</TT>-the first input
stream in the sequence.<BR>
<TT>s2</TT>-the second input stream
in the sequence.
</BLOCKQUOTE>
<H4><TT>close</TT></H4>
<BLOCKQUOTE>
<TT>public void close() throws IOException
<BR>
</TT>This method closes the sequence input stream, releasing
any resources associated with the stream. Additionally, this <TT>close</TT>
method calls the <TT>close</TT> method
for the substream currently being read from as well as the substreams
that have yet to be read from.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read() throws IOException
<BR>
</TT>This method reads a byte value from the currently
active substream in the sequence input stream, blocking until
the byte is read. If the end of the substream is reached, the
<TT>close</TT> method is called on
the substream and <TT>read</TT> begins
reading from the next substream.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int pos, int
len) throws IOException<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the currently active substream in the sequence input
stream into the byte array <TT>b</TT>
beginning <TT>off</TT> bytes into
the array, blocking until all bytes are read. If the end of the
substream is reached, the <TT>close</TT>
method is called on the substream and <TT>read</TT>
begins reading from the next substream.<BR>
<I><B>Parameters: <BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierStreamTokenizerFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>StreamTokenizer</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Object<BR>
</TT>This class implements a string tokenizer stream, which
parses an input stream into a stream of tokens. The <TT>StreamTokenizer</TT>
class provides a variety of methods for establishing how the tokens
are parsed. Each character read from the stream is evaluated as
having zero or more of the following attributes: whitespace, alphabetic,
numeric, string quote, or comment.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
public double nval
</PRE>
</BLOCKQUOTE>
<P>
This member variable holds a numeric token value whenever the
ttype member variable is set to TT_NUMBER.
<BLOCKQUOTE>
<PRE>
public String sval
</PRE>
</BLOCKQUOTE>
<P>
This member variable holds a string representation of a word token
whenever the ttype member variable is set to TT_WORD, or it holds
the body of a quoted string token when ttype is set to a quote
character.
<BLOCKQUOTE>
<PRE>
public int ttype
</PRE>
</BLOCKQUOTE>
<P>
This is the type of the current token, which can be one of the
following:
<UL>
<LI>Integer representation of a character for single character
tokens.
<LI>Quote character for quoted string tokens.
<LI><TT>TT_WORD</TT> for word tokens.
<LI><TT>TT_NUMERIC</TT> for numeric
tokens.
<LI><TT>TT_EOL</TT> if the end of
a line has been reached on the input stream.
<LI><TT>TT_EOF</TT> if the end of
the stream has been reached.
</UL>
<BLOCKQUOTE>
<PRE>
public final static int TT_EOF
</PRE>
</BLOCKQUOTE>
<P>
This is a constant token type representing the end-of-file token.
<BLOCKQUOTE>
<PRE>
public final static int TT_EOL
</PRE>
</BLOCKQUOTE>
<P>
This is a constant token type representing the end-of-line token.
<BLOCKQUOTE>
<PRE>
public final static int TT_NUMBER
</PRE>
</BLOCKQUOTE>
<P>
This is a constant token type identifying a numeric token; the
actual numeric value is stored in nval.
<BLOCKQUOTE>
<PRE>
public final static int TT_WORD
</PRE>
</BLOCKQUOTE>
<P>
This is a constant token type identifying a word token; the actual
word value is stored in sval.
<H4><TT>StreamTokenizer</TT> Constructor
</H4>
<BLOCKQUOTE>
<TT>public StreamTokenizer(InputStream I)
<BR>
</TT>This constructor creates a string tokenizer stream
that parses the specified input stream. By default, the string
tokenizer stream recognizes numbers, strings quoted with single
and double quotes, all alphabetic characters, and comments preceded
by a <TT>'/'</TT> character.<BR>
<I><B>Parameters: </B></I><TT>I</TT>-the
input stream to be parsed.
</BLOCKQUOTE>
<H4><TT>commentChar</TT></H4>
<BLOCKQUOTE>
<TT>public void commentChar(int ch)<BR>
</TT>This method establishes the specified character as
starting single line comments.<BR>
<I><B>Parameters: </B></I><TT>ch</TT>-the
new single line comment character.
</BLOCKQUOTE>
<H4><TT>eolIsSignificant</TT></H4>
<BLOCKQUOTE>
<TT>public void eolIsSignificant(boolean
flag)<BR>
</TT>This method establishes whether end-of-line characters
are recognized as tokens.<BR>
<I><B>Parameters: </B></I><TT>flag</TT>-a
boolean value specifying whether end-of-line characters are treated
as tokens; a value of <TT>true</TT>
means end-of-line characters are treated as tokens, whereas a
value of <TT>false</TT> means they
are treated as whitespace.
</BLOCKQUOTE>
<H4><TT>lineno</TT></H4>
<BLOCKQUOTE>
<TT>public int lineno()<BR>
</TT>This method determines the current line number of
the string tokenizer stream.<BR>
<I><B>Returns: </B></I>The current line number of the stream.
</BLOCKQUOTE>
<H4><TT>lowerCaseMode</TT></H4>
<BLOCKQUOTE>
<TT>public void lowerCaseMode(boolean flag)
<BR>
</TT>This method establishes whether word tokens (<TT>TT_WORD</TT>)
are forced to lowercase when they are parsed.<BR>
<I><B>Parameters: </B></I><TT>flag</TT>-a
boolean value specifying whether word tokens are forced to lowercase;
a value of <TT>true</TT> means word
tokens are forced to lowercase, whereas a value of <TT>false</TT>
means they are left unmodified.
</BLOCKQUOTE>
<H4><TT>nextToken</TT></H4>
<BLOCKQUOTE>
<TT>public int nextToken() throws IOException
<BR>
</TT>This method parses the next token from the underlying
input stream. After the token is parsed, the <TT>ttype</TT>
member variable is set to the type of the token, while the value
of some tokens is contained in either the <TT>nval</TT>
or <TT>sval</TT> member variables,
depending on the token type.<BR>
<I><B>Returns: </B></I>The type of the token.<BR>
<I><B>Throws: </B></I><TT>IOException</TT>
if an I/O error occurs.
</BLOCKQUOTE>
<H4><TT>ordinaryChar</TT></H4>
<BLOCKQUOTE>
<TT>public void ordinaryChar(int ch)<BR>
</TT>This method establishes that the specified character
is handled as an ordinary character by the tokenizer, meaning
that the character is not interpreted as a comment character,
word component, string delimiter, whitespace, or numeric character.
Ordinary characters are parsed as single character tokens.<BR>
<I><B>Parameters: </B></I><TT>ch</TT>-the
character to be set as ordinary.
</BLOCKQUOTE>
<H4><TT>ordinaryChars</TT></H4>
<BLOCKQUOTE>
<TT>public void ordinaryChars(int low, int
hi)<BR>
</TT>This method establishes that the characters in the
specified range are handled as ordinary characters by the tokenizer,
meaning that the characters are not interpreted as com-<BR>
ment characters, word components, string delimiters, whitespace,
or numeric characters. Ordinary characters are parsed as single
character tokens.<BR>
<I><B>Parameters: <BR>
</B></I><TT>low</TT>-the low end of
the ordinary character range.<BR>
<TT>hi</TT>-the high end of the ordinary
character range.
</BLOCKQUOTE>
<H4><TT>parseNumbers</TT></H4>
<BLOCKQUOTE>
<TT>public void parseNumbers()<BR>
</TT>This method establishes that numbers should be parsed.
When a number is parsed, the <TT>ttype</TT>
member variable is set to <TT>TT_NUMBER</TT>,
with the corresponding numeric value stored in <TT>nval</TT>.
</BLOCKQUOTE>
<H4><TT>pushBack</TT></H4>
<BLOCKQUOTE>
<TT>public void pushBack()<BR>
</TT>This method pushes the current token back into the
string tokenizer stream, meaning that the next call to <TT>nextToken</TT>
will result in this token being handled.
</BLOCKQUOTE>
<H4><TT>quoteChar</TT></H4>
<BLOCKQUOTE>
<TT>public void quoteChar(int ch)<BR>
</TT>This method establishes that matching pairs of the
specified character be used to delimit string constants. When
a string constant is parsed, the <TT>ttype</TT>
member variable is set to the delimiting character, with the corresponding
string body stored in <TT>sval</TT>.
<BR>
<I><B>Parameters: </B></I><TT>ch</TT>-the
new string delimiter character.
</BLOCKQUOTE>
<H4><TT>resetSyntax</TT></H4>
<BLOCKQUOTE>
<TT>public void resetSyntax()<BR>
</TT>This method resets the syntax table so that all characters
are considered ordinary. An ordinary character is a character
that isn't interpreted as a comment character, word component,
string delimiter, whitespace, or numeric character. Ordinary characters
are parsed as single character tokens.
</BLOCKQUOTE>
<H4><TT>slashSlashComments</TT></H4>
<BLOCKQUOTE>
<TT>public void slashSlashComments(boolean
flag)<BR>
</TT>This method establishes whether C++ style comments
(<TT>//</TT>) are recognized by the
parser. A C++ style comment is defined by two consecutive forward
slash characters, which starts a comment that extends to the end
of the line.<BR>
<I><B>Parameters: </B></I><TT>flag</TT>-a
boolean value specifying whether C++ style comments are recognized;
a value of <TT>true</TT> means C++
style comments are recognized, whereas a value of <TT>false</TT>
means they are not treated specially.
</BLOCKQUOTE>
<H4><TT>slashStarComments</TT></H4>
<BLOCKQUOTE>
<TT>public void slashStarComments(boolean
flag)<BR>
</TT>This method establishes whether C style comments (<TT>/*...*/</TT>)
are recognized by the parser. A C style comment is defined by
a forward slash character followed by an asterisk, which starts
a comment. The comment continues until a corresponding asterisk
followed by a forward slash character is reached.<BR>
<I><B>Parameters: </B></I><TT>flag</TT>-a
boolean value specifying whether C style comments are recognized;
a value of <TT>true</TT> means C style
comments are recognized, whereas a value of <TT>false</TT>
means they are not treated specially.
</BLOCKQUOTE>
<H4><TT>toString</TT></H4>
<BLOCKQUOTE>
<TT>public String toString()<BR>
</TT>This method determines the string representation of
the current token in the string tokenizer stream.<BR>
<I><B>Returns: </B></I>The string representation of the current
token.
</BLOCKQUOTE>
<H4><TT>whitespaceChars</TT></H4>
<BLOCKQUOTE>
<TT>public void whitespaceChars(int low,
int hi)<BR>
</TT>This method establishes that the characters in the
specified range are handled as whitespace by the tokenizer, meaning
that the characters serve only to separate tokens.<BR>
<I><B>Parameters: <BR>
</B></I><TT>low</TT>-the low end of
the whitespace character range.<BR>
<TT>hi</TT>-the high end of the whitespace
character range.
</BLOCKQUOTE>
<H4><TT>wordChars</TT></H4>
<BLOCKQUOTE>
<TT>public void wordChars(int low, int hi)
<BR>
</TT>This method establishes that the characters in the
specified range are handled as words by the tokenizer.<BR>
<I><B>Parameters: </B></I><TT>low</TT>-the
low end of the word character range.<BR>
<I><B>Parameters: </B></I><TT>hi</TT>-the
high end of the word character range.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierStringBufferInputStreamFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>StringBufferInputStream</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>InputStream<BR>
</TT>This class implements an input stream whose data is
fed by a string. Note that only the lower 8 bits of each character
in the string are used by this class.
</BLOCKQUOTE>
<H4>Member Variables</H4>
<BLOCKQUOTE>
<PRE>
protected String buffer
</PRE>
</BLOCKQUOTE>
<P>
This is the string buffer from which the data is read.
<BLOCKQUOTE>
<PRE>
protected int count
</PRE>
</BLOCKQUOTE>
<P>
This is the number of characters currently in the buffer.
<BLOCKQUOTE>
<PRE>
protected int pos
</PRE>
</BLOCKQUOTE>
<P>
This is the current read position in the buffer.
<H4><TT>StringBufferInputStream</TT>
Constructor</H4>
<BLOCKQUOTE>
<TT>public StringBufferInputStream(String
s)<BR>
</TT>This constructor creates a string buffer input stream
based on the specified string. Note that the string buffer is
not copied to create the input stream.<BR>
<I><B>Parameters: </B></I><TT>s</TT>-the
input string buffer.
</BLOCKQUOTE>
<H4><TT>available</TT></H4>
<BLOCKQUOTE>
<TT>public int available()<BR>
</TT>This method determines the number of bytes that can
be read from the string buffer input stream without blocking.
<BR>
<I><B>Returns: </B></I>The number of available bytes.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read()<BR>
</TT>This method reads a byte value from the string buffer
input stream, which is the lower 8 bits of the next character
in the underlying string buffer.<BR>
<I><B>Returns: </B></I>An integer representing the byte value
read, or <TT>-1</TT> if the end of
the stream is reached.
</BLOCKQUOTE>
<H4><TT>read</TT></H4>
<BLOCKQUOTE>
<TT>public int read(byte b[], int off, int
len)<BR>
</TT>This method reads up to <TT>len</TT>
bytes from the string buffer input stream into the byte array
<TT>b</TT> beginning <TT>off</TT>
bytes into the array. Note that each byte is actually the lower
8 bits of the corresponding character in the underlying string
buffer.<BR>
<I><B>Parameters:<BR>
</B></I><TT>b</TT>-the byte array
into which the data is read.<BR>
<TT>off</TT>-the starting offset into
the array for the data to be written to.<BR>
<TT>len</TT>-the maximum number of
bytes to read.<BR>
<I><B>Returns: </B></I>The actual number of bytes read, or <TT>-1</TT>
if the end of the stream is reached.
</BLOCKQUOTE>
<H4><TT>reset</TT></H4>
<BLOCKQUOTE>
<TT>public void reset()<BR>
</TT>This method resets the read position to the beginning
of the string buffer input stream.
</BLOCKQUOTE>
<H4><TT>skip</TT></H4>
<BLOCKQUOTE>
<TT>public long skip(long n)<BR>
</TT>This method skips <TT>n</TT>
bytes of data in the string buffer input stream.<BR>
<I><B>Parameters: </B></I><TT>n</TT>-the
number of bytes to skip.<BR>
<I><B>Returns: </B></I>The actual number of bytes skipped.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierEOFExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>EOFException</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>IOException<BR>
</TT>This exception class signals that an end-of-file (EOF)
has been reached unexpectedly during an input operation. This
exception is primarily used by data input streams, which typically
expect a binary file in a specific format, in which case an end-of-file
is an unusual condition.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierFileNotFoundExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>FileNotFoundException</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>IOException<BR>
</TT>This exception class signals that a file could not
be found.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierIOExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>IOException</TT></FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>Exception<BR>
</TT>This exception class signals that some kind of input/output
(I/O) exception has occurred.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierInterruptedIOExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>InterruptedIOException</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>IOException<BR>
</TT>This exception class signals that an input/output
(I/O) operation has been interrupted.
</BLOCKQUOTE>
<H2><A NAME="TTFONTSIZEFACECourierUTFDataFormatExceptionFONTTT"><FONT SIZE=5 COLOR=#FF0000>
<TT>UTFDataFormatException</TT>
</FONT></A></H2>
<BLOCKQUOTE>
<I><B>Extends: </B></I><TT>IOException<BR>
</TT>This exception class signals that a malformed UTF-8
string has been read in a data input stream.
</BLOCKQUOTE>
<HR>

<CENTER><P><A HREF="ch36.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch38.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
