<HTML>
<HEAD>
<TITLE>Day 9 -- Graphics, Fonts, and Color</TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT SIZE=6 COLOR=#FF0000>Day&nbsp;9</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Graphics, Fonts, and Color</FONT>
</H1>
<P>
<I><B>by Laura Lemay</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheTTFONTSIZEFACECourierGraphicsFONTTTFONTSIZEClassFONT">
The <TT>Graphics</TT>
Class</FONT></A>
<UL>
<LI><A HREF="#TheGraphicsCoordinateSystem">
The Graphics Coordinate System</A>
</UL>
<LI><A HREF="#DrawingandFilling">
Drawing and Filling</A>
<UL>
<LI><A HREF="#Lines">
Lines</A>
<LI><A HREF="#Rectangles">
Rectangles</A>
<LI><A HREF="#Polygons">
Polygons</A>
<LI><A HREF="#Ovals">
Ovals</A>
<LI><A HREF="#Arcs">
Arcs</A>
<LI><A HREF="#ASimpleGraphicsExample">
A Simple Graphics Example</A>
<LI><A HREF="#CopyingandClearing">
Copying and Clearing</A>
</UL>
<LI><A HREF="#TextandFonts">
Text and Fonts</A>
<UL>
<LI><A HREF="#CreatingFontObjects">
Creating Font Objects</A>
<LI><A HREF="#DrawingCharactersandStrings">
Drawing Characters and Strings</A>
<LI><A HREF="#FindingOutInformationAboutaFont">
Finding Out Information About a Font</A>
</UL>
<LI><A HREF="#Color">
Color</A>
<UL>
<LI><A HREF="#UsingColorObjects">
Using Color Objects</A>
<LI><A HREF="#TestingandSettingtheCurrentColors">
Testing and Setting the Current Colors</A>
<LI><A HREF="#ASimpleColorExample">
A Simple Color Example</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
<LI><A HREF="#QampABR">
Q&amp;A<BR>
</A>
</UL>

<HR>
<P>
Knowing the basics of how applets work is only the first step.
The next step is to become familiar with the capabilities Java
gives you for drawing to the screen, performing dynamic updating,
managing mouse and keyboard events, and creating user interface
elements. You'll do all these things this week. You'll start today
with how to draw to the screen-that is, how to produce lines and
shapes with the built-in graphics primitives, how to print text
using fonts, and how to use and modify color in your applets.
Today you'll learn, specifically, the following:
<UL>
<LI>How the graphics system works in Java: the <TT>Graphics</TT>
class, the coordinate system used to draw to the screen, and how
applets paint and repaint
<LI>How to use the Java graphics primitives, including drawing
and filling lines, rectangles, ovals, and arcs
<LI>How to create and use fonts, including how to draw characters
and strings and how to find out the metrics of a given font for
better layout
<LI>All about color in Java, including the <TT>Color</TT>
class and how to set the foreground (drawing) and background color
for your applet
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Today and for the rest of this week, you'll get an introduction to many of the classes that make up the Java class libraries, in particular the classes in the <TT>java.awt</TT> package. Keep in mind, however, that I only have the space to give you an 
introduction to these classes-there are many other capabilities available to you in these classes that you can use in your own programs, depending on what you're trying to accomplish. After you finish this book (and perhaps after each of these lessons), 
you'll want to familiarize yourself with the classes themselves and what they can do. Be sure to check out the Java API documentation for more details; you can find that API documentation on the Java Web site at <TT><A 
HREF="http://java.sun.com/products/JDK/1.0.2/api/packages.html">http://java.sun.com/products/JDK/1.0.2/api/packages.html</A></TT>.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheTTFONTSIZEFACECourierGraphicsFONTTTFONTSIZEClassFONT"><FONT SIZE=5 COLOR=#FF0000>
The <TT>Graphics</TT>
Class</FONT></FONT></A></H2>
<P>
With the basic graphics capabilities built into Java's class libraries,
you can draw lines, shapes, characters, and images to the screen
inside your applet. Most of the graphics operations in Java are
methods defined in the <TT>Graphics</TT>
class. You don't have to create an instance of <TT>Graphics</TT>
in order to draw something in your applet; in your applet's <TT>paint()</TT>
method (which you learned about yesterday), you are given a <TT>Graphics</TT>
object. By drawing on that object, you draw onto your applet and
the results appear onscreen.
<P>
The <TT>Graphics</TT> class is part
of the <TT>java.awt</TT> package,
so if your applet does any painting (as it usually will), make
sure you import that class at the beginning of your Java file:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyClass extends java.applet.Applet {
...
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheGraphicsCoordinateSystem">
The Graphics Coordinate System</A></H3>
<P>
To draw an object on the screen, you call one of the drawing methods
available in the <TT>Graphics</TT>
class. All the drawing methods have arguments representing endpoints,
corners, or starting locations of the object as values in the
applet's coordinate system-for example, a line starts at the point
<TT>10,10</TT> and ends at the point
<TT>20,20</TT>.
<P>
Java's coordinate system has the origin (<TT>0,0</TT>)
in the top-left corner. Positive <TT>x</TT>
values are to the right and positive <TT>y</TT>
values are down. All pixel values are integers; there are no partial
or fractional pixels. Figure 9.1 shows how you might draw a simple
square by using this coordinate system.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-1.gif"><B>Figure 9.1 : </B><I>The Java graphics coordinate system</I>.</A>
<P>
Java's coordinate system is different from that of many painting
and layout programs, which have their <TT>x</TT>
and <TT>y</TT> in the bottom left.
If you're not used to working with this upside-down graphics system,
it may take some practice to get familiar with it.
<H2><A NAME="DrawingandFilling"><FONT SIZE=5 COLOR=#FF0000>
Drawing and Filling</FONT></A></H2>
<P>
The <TT>Graphics</TT> class provides
a set of simple built-in graphics primitives for drawing, including
lines, rectangles, polygons, ovals, and arcs
<P>
.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Bitmap images, such as GIF files, can also be drawn by using the <TT>Graphics</TT> class. You'll learn about this tomorrow.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Lines">
Lines</A></H3>
<P>
To draw straight lines, use the <TT>drawLine()</TT>
method. <TT>drawLine()</TT> takes
four arguments: the <TT>x</TT> and
<TT>y</TT> coordinates of the starting
point and the <TT>x</TT> and <TT>y</TT>
coordinates of the ending point. So, for example, the following
<TT>MyLine</TT> class draws a line
from the point <TT>25,25</TT> to the
point <TT>75,75</TT>. Note that the
<TT>drawLine()</TT> method is defined
in the <TT>Graphics</TT> class (as
are all the other graphics methods you'll learn about today).
Here we're using that method for the current graphics context
stored in the variable <TT>g</TT>:
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyLine extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawLine(25,25,75,75);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Figure 9.2 shows how the simple <TT>MyLine</TT>
class looks in a Java-enabled browser such as Netscape.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-2.gif"><B>Figure 9.2 : </B><I>Drawing lines</I>.</A>
<H3><A NAME="Rectangles">
Rectangles</A></H3>
<P>
The Java graphics primitives provide not just one, but three kinds
of rectangles:
<UL>
<LI>Plain rectangles
<LI>Rounded rectangles, which are rectangles with rounded corners
<LI>Three-dimensional rectangles, which are drawn with a shaded
border
</UL>
<P>
For each of these rectangles, you have two methods to choose from:
one that draws the rectangle in outline form and one that draws
the rectangle filled with color.
<P>
To draw a plain rectangle, use either the <TT>drawRect()</TT>
or <TT>fillRect()</TT> methods. Both
take four arguments: the <TT>x</TT>
and <TT>y</TT> coordinates of the
top-left corner of the rectangle, and the width and height of
the rectangle to draw. For example, the following class (<TT>MyRect</TT>)
draws two squares: The left one is an outline and the right one
is filled (Figure 9.3 shows the result):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-3.gif"><B>Figure 9.3 : </B><I>Rectangles</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyRect extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawRect(20,20,60,60);
        g.fillRect(120,20,60,60);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Rounded rectangles are, as you might expect, rectangles with rounded
corners. The <TT>drawRoundRect()</TT>
and <TT>fillRoundRect()</TT> methods
to draw rounded rectangles are similar to regular rectangles except
that rounded rectangles have two extra arguments for the width
and height of the angle of the corners. Those two arguments determine
how far along the edges of the rectangle the arc for the corner
will start; the first for the angle along the horizontal plane,
the second for the vertical. Larger values for the angle width
and height make the overall rectangle more rounded; values equal
to the width and height of the rectangle itself produce a circle.
Figure 9.4 shows some examples of rounded corners.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-4.gif"><B>Figure 9.4 : </B><I>Rounded corners</I>.</A>
<P>
The following is a <TT>paint()</TT>
method inside a class called <TT>MyRRect</TT>
that draws two rounded rectangles: one as an outline with a rounded
corner <TT>10</TT> pixels square;
the other, filled, with a rounded corner <TT>20</TT>
pixels square (Figure 9.5 shows the resulting squares):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-5.gif"><B>Figure 9.5 : </B><I>Rounded rectangles</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyRRect extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawRoundRect(20,20,60,60,10,10);
        g.fillRoundRect(120,20,60,60,20,20);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Finally, there are three-dimensional rectangles. These rectangles
aren't really 3D; instead, they have a slight shadow effect that
makes them appear either raised or indented from the surface of
the applet. Three-dimensional rectangles have four arguments for
the <TT>x</TT> and <TT>y</TT>
of the start position and the width and height of the rectangle.
The fifth argument is a boolean indicating whether the 3D effect
is to raise the rectangle (<TT>true</TT>)
or indent it (<TT>false</TT>). As
with the other rectangles, there are also different methods for
drawing and filling: <TT>draw3DRect()</TT>
and <TT>fill3DRect()</TT>. The following
is a class called <TT>My3DRect</TT>,
which produces two 3D squares-the left one raised, the right one
indented (Figure 9.6 shows the result):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-6.gif"><B>Figure 9.6 : </B><I>Three dimensional rectangles</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class My3DRect extends java.applet.Applet {
    public void paint(Graphics g) {
        g.draw3DRect(20,20,60,60,true);
        g.draw3DRect(120,20,60,60,false);
    }
}<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The 3D rectangles in Figure 9.6 don't look very 3D, do they? In the current version of the Java Developer's Kit, it is extremely difficult to see the 3D effect on 3D rectangles, due to a very small line width. If you are having troubles with 3D rectangles, 
this may be why. Drawing 3D rectangles in any color other than black makes them easier to see.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Polygons">
Polygons</A></H3>
<P>
Polygons are shapes with an unlimited number of sides. To draw
a polygon, you need a set of <TT>x</TT>
and <TT>y</TT> coordinates. The polygon
is then drawn as a set of straight lines from the first point
to the second, the second to the third, and so on.
<P>
As with rectangles, you can draw an outline or a filled polygon
(using the <TT>drawPolygon()</TT>
and <TT>fillPolygon()</TT> methods,
respectively). You also have a choice of how you want to indicate
the list of coordinates-either as arrays of <TT>x</TT>
and <TT>y</TT> coordinates or as an
instance of the <TT>Polygon</TT> class.
<P>
Using the first way of drawing polygons, the <TT>drawPolygon()</TT>
and <TT>fillPolygon()</TT> methods
take three arguments:
<UL>
<LI>An array of integers representing <TT>x</TT>
coordinates
<LI>An array of integers representing <TT>y</TT>
coordinates
<LI>An integer for the total number of points
</UL>
<P>
The <TT>x</TT> and <TT>y</TT>
arrays should, of course, have the same number of elements.
<P>
Here's an example of drawing a polygon's outline using this method
(Figure 9.7 shows the result):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-7.gif"><B>Figure 9.7 : </B><I>A polygon</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyPoly extends java.applet.Applet {
    public void paint(Graphics g) {
        int exes[] = { 39,94,97,142,53,58,26 };
        int whys[] = { 33,74,36,70,108,80,106 };
        int pts = exes.length;

        g.drawPolygon(exes,whys,pts);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Note that Java does not automatically close the polygon; if you
want to complete the shape, you have to include the starting point
of the polygon at the end of the array. Drawing a filled polygon,
however, joins the starting and ending points.
<P>
The second way of calling <TT>drawPolygon()</TT>
and <TT>fillPolygon()</TT> is to use
a <TT>Polygon</TT> object to store
the individual points of the polygon. The <TT>Polygon</TT>
class is useful if you intend to add points to the polygon or
if you're building the polygon on-the-fly. Using the <TT>Polygon</TT>
class, you can treat the polygon as an object rather than having
to deal with individual arrays.
<P>
To create a polygon object, you can either first create an empty
polygon:
<BLOCKQUOTE>
<PRE>
Polygon poly = new Polygon();
</PRE>
</BLOCKQUOTE>
<P>
or create a polygon from a set of points using integer arrays,
as in the previous example:
<BLOCKQUOTE>
<PRE>
int exes[] = { 39,94,97,142,53,58,26 };
int whys[] = { 33,74,36,70,108,80,106 };
int pts = exes.length;
Polygon poly = new Polygon(exes,whys,pts);
</PRE>
</BLOCKQUOTE>
<P>
Once you have a polygon object, you can add points to the polygon
as you need to:
<BLOCKQUOTE>
<PRE>
poly.addPoint(20,35);
</PRE>
</BLOCKQUOTE>
<P>
Then, to draw the polygon, just use the polygon object as an argument
to <TT>drawPolygon()</TT> or <TT>fillPolygon()</TT>.
Here's that previous example, rewritten this time with a <TT>Polygon</TT>
object. You'll also fill this polygon rather than just drawing
its outline (Figure 9.8 shows the output):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-8.gif"><B>Figure 9.8 : </B><I>Another polygon</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyPoly2 extends java.applet.Applet {
    public void paint(Graphics g) {
        int exes[] = { 39,94,97,142,53,58,26 };
        int whys[] = { 33,74,36,70,108,80,106 };
        int pts = exes.length;
        Polygon poly = new Polygon(exes,whys,pts);
        g.fillPolygon(poly);
    }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Ovals">
Ovals</A></H3>
<P>
You use ovals to draw ellipses or circles. Ovals are just like
rectangles with overly rounded corners. You draw them using four
arguments: the <TT>x</TT> and <TT>y</TT>
of the top corner, and the width and height of the oval itself.
Note that because you're drawing an oval, the starting point is
some distance to the left and up from the actual outline of the
oval itself. Again, if you think of it as a rectangle, it's easier
to place.
<P>
As with the other drawing operations, the <TT>drawOval()</TT>
method draws an outline of an oval, and the <TT>fillOval()</TT>
method draws a filled oval.
<P>
The following example draws two ovals-a circle and an ellipse
(Figure 9.9 shows how these two ovals appear onscreen):
<P>
<A HREF="http://docs.rinet.ru/J21/f9-9.gif"><B>Figure 9.9 : </B><I>Ovals</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyOval extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawOval(20,20,60,60);
        g.fillOval(120,20,100,60);
    }
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Arcs">
Arcs</A></H3>
<P>
Of all the shapes you can construct using methods in the <TT>Graphics</TT>
class, arcs are the most complex to construct, which is why I
saved them for last. An arc is a part of an oval; in fact, the
easiest way to think of an arc is as a section of a complete oval.
Figure 9.10 shows some arcs.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-10.gif"><B>Figure 9.10: </B><I>Arcs</I>.</A>
<P>
The <TT>drawArc()</TT> method takes
six arguments: the starting corner, the width and height, the
angle at which to start the arc, and the degrees to draw it before
stopping. Once again, there is a <TT>drawArc</TT>
method to draw the arc's outline and the <TT>fillArc()</TT>
method to fill the arc. Filled arcs are drawn as if they were
sections of a pie; instead of joining the two endpoints, both
endpoints are joined to the center of the circle.
<P>
The important thing to understand about arcs is that you're actually
formulating the arc as an oval and then drawing only some of that.
The starting corner and width and height are not the starting
point and width and height of the actual arc as drawn on the screen;
they're the width and height of the full ellipse of which the
arc is a part. Those first points determine the size and shape
of the arc; the last two arguments (for the degrees) determine
the starting and ending points.
<P>
Let's start with a simple arc, a C shape on a circle, as shown
in Figure 9.11.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-11.gif"><B>Figure 9.11: </B><I>A C arc</I>.</A>
<P>
To construct the method to draw this arc, the first thing you
do is think of it as a complete circle. Then you find the <TT>x</TT>
and <TT>y</TT> coordinates and the
width and height of that circle. Those four values are the first
four arguments to the <TT>drawArc()</TT>
or <TT>fillArc()</TT> methods. Figure
9.12 shows how to get those values from the arc.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-12.gif"><B>Figure 9.12: </B><I>Constructing a circular arc</I>.</A>
<P>
To get the last two arguments, think in degrees around the circle,
going counterclockwise. Zero degrees is at 3 o'clock, 90 degrees
is at 12 o'clock, 180 at 9 o'clock, and 270 at 6 o'clock. The
start of the arc is the degree value of the start of the arc.
In this example, the starting point is the top of the C at 90
degrees; 90 is the fifth argument.
<P>
The sixth and last argument is another degree value indicating
how far around the circle to sweep and the direction to go in
(it's not</FONT> the ending degree
angle, as you might think). In this case, because you're going
halfway around the circle, you're sweeping 180 degrees-and 180
is therefore the last argument in the arc. The important part
is that you're sweeping 180 degrees counterclockwise, which is
in the positive direction in Java. If you are drawing a backwards
C, you sweep 180 degrees in the negative direction, and the last
argument is <TT>-180</TT>. See Figure
9.13 for the final illustration of how this works.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-13.gif"><B>Figure 9.13: </B><I>Arcs on circles</I>.</A><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
It doesn't matter which side of the arc you start with. Because the shape of the arc has already been determined by the complete oval it's a section of, starting at either endpoint will work.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Here's the code for this example; you'll draw an outline of the
C and a filled C to its right, as shown in Figure 9.14:
<P>
<A HREF="http://docs.rinet.ru/J21/f9-14.gif"><B>Figure 9.14: </B><I>Two circular arcs</I>.</A>
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyOval extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawArc(20,20,60,60,90,180);
        g.fillArc(120,20,60,60,90,180);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Circles are an easy way to visualize arcs on circles; arcs on
ellipses are slightly more difficult. Let's go through this same
process to draw the arc shown in Figure 9.15.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-15.gif"><B>Figure 9.15: </B><I>An elliptical arc</I>.</A>
<P>
Like the arc on the circle, this arc is a piece of a complete
oval, in this case, an elliptical oval. By completing the oval
that this arc is a part of, you can get the starting points and
the width and height arguments for the <TT>drawArc()</TT>
or <TT>fillArc()</TT> method (see
Figure 9.16).
<P>
<A HREF="http://docs.rinet.ru/J21/f9-16.gif"><B>Figure 9.16: </B><I>Arcs on ellipses</I>.</A>
<P>
Then all you need is to figure out the starting angle and the
angle to sweep. This arc doesn't start on a nice boundary such
as 90 or 180 degrees, so you'll need some trial and error. This
arc starts somewhere around 25 degrees, and then sweeps clockwise
about 130 degrees (see Figure 9.17).
<P>
<A HREF="http://docs.rinet.ru/J21/f9-17.gif"><B>Figure 9.17: </B><I>Starting and ending points</I>.</A>
<P>
With all portions of the arc in place, you can write the code.
Here's the Java code for this arc, both drawn and filled (note
in the filled case how filled arcs are drawn as if they were pie
sections):
<BLOCKQUOTE>
<PRE>
import java.awt.Graphics;

public class MyOval extends java.applet.Applet {
    public void paint(Graphics g) {
        g.drawArc(10,20,150,50,25,-130);
        g.fillArc(10,80,150,50,25,-130);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Figure 9.18 shows the two elliptical arcs.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-18.gif"><B>Figure 9.18: </B><I>Two elliptical arcs</I>.</A>
<P>
To summarize, here are the steps to take to construct arcs in
Java:
<OL>
<LI>Think of the arc as a slice of a complete oval.
<LI>Construct the full oval with the starting point and the width
and height (it often helps to draw the full oval on the screen
to get an idea of the right positioning).
<LI>Determine the starting angle for the beginning of the arc.
<LI>Determine how far to sweep the arc and in which direction
(counterclockwise indicates positive values, clockwise indicates
negative).
</OL>
<H3><A NAME="ASimpleGraphicsExample">
A Simple Graphics Example</A></H3>
<P>
Here's an example of an applet that uses many of the built-in
graphics primitives to draw a rudimentary shape. In this case,
it's a lamp with a spotted shade (or a sort of cubist mushroom,
depending on your point of view). Listing 9.1 has the complete
code for the lamp; Figure 9.19 shows the resulting applet.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-19.gif"><B>Figure 9.19: </B><I>The Lamp applet</I>.</A>
<HR>
<P>
<B>Listing 9.1. The </B><TT><B>Lamp</B></TT><B>
class.<BR>
</B>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.*;
 2: 
 3: public class Lamp extends java.applet.Applet {
 4: 
 5:    public void paint(Graphics g) {
 6:        // the lamp platform
 7:        g.fillRect(0,250,290,290);
 8:
 9:        // the base of the lamp
10:        g.drawLine(125,250,125,160);
11:        g.drawLine(175,250,175,160);
12: 
13:        // the lamp shade, top and bottom edges
14:         g.drawArc(85,157,130,50,-65,312);
15:         g.drawArc(85,87,130,50,62,58);
16: 
17:         // lamp shade, sides
18:         g.drawLine(85,177,119,89);
19:         g.drawLine(215,177,181,89);
20: 
21:         // dots on the shade
22:         g.fillArc(78,120,40,40,63,-174);
23:         g.fillOval(120,96,40,40);
24:         g.fillArc(173,100,40,40,110,180);
25:    }
26: }
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="CopyingandClearing">
Copying and Clearing</A></H3>
<P>
Once you've drawn a few things on the screen, you may want to
move them around or clear the entire applet. The <TT>Graphics</TT>
class provides methods for doing both these things.
<P>
The <TT>copyArea()</TT> method copies
a rectangular area of the screen to another area of the screen.
<TT>copyArea()</TT> takes six arguments:
the <TT>x</TT> and <TT>y</TT>
of the top corner of the rectangle to copy, the width and the
height of that rectangle, and the distance in the <TT>x</TT>
and <TT>y</TT> directions to which
to copy it. For example, this line copies a square area <TT>100</TT>
pixels on a side <TT>100</TT> pixels
directly to its right:
<BLOCKQUOTE>
<PRE>
g.copyArea(0,0,100,100,100,0);
</PRE>
</BLOCKQUOTE>
<P>
To clear a rectangular area, use the <TT>clearRect()</TT>
method. <TT>clearRect()</TT>, which
takes the same four arguments as the <TT>drawRect()</TT>
and <TT>fillRect()</TT> methods, fills
the given rectangle with the current background color of the applet
(you'll learn how to set the current background color later today).
<P>
To clear the entire applet, you can use the <TT>size()</TT>
method, which returns a <TT>Dimension</TT>
object representing the width and height of the applet. You can
then get to the actual values for width and height by using the
width and height instance variables:
<BLOCKQUOTE>
<PRE>
g.clearRect(0,0,size().width,size().height);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="TextandFonts"><FONT SIZE=5 COLOR=#FF0000>
Text and Fonts</FONT></A></H2>
<P>
Using the <TT>Graphics</TT> class,
you can also print text on the screen, in conjunction with the
<TT>Font</TT> class (and, sometimes,
the <TT>FontMetrics</TT> class). The
<TT>Font</TT> class represents a given
font-its name, style, and point size-and <TT>FontMetrics</TT>
gives you information about that font (for example, the actual
height or width of a given character) so that you can precisely
lay out text in your applet.
<P>
Note that the text here is drawn to the screen once and intended
to stay there. You'll learn about entering text from the keyboard
later this week.
<H3><A NAME="CreatingFontObjects">
Creating Font Objects</A></H3>
<P>
To draw text to the screen, first you need to create an instance
of the <TT>Font</TT> class. Font objects
represent an individual font-that is, its name, style (bold, italic),
and point size. Font names are strings representing the family
of the font, for example, <TT>&quot;TimesRoman&quot;</TT>,
<TT>&quot;Courier&quot;</TT>, or <TT>&quot;Helvetica&quot;</TT>.
Font styles are constants defined by the <TT>Font</TT>
class; you can get to them using class variables-for example,
<TT>Font.PLAIN</TT>, <TT>Font.BOLD</TT>,
or <TT>Font.ITALIC</TT>. Finally,
the point size is the size of the font, as defined by the font
itself; the point size may or may not be the height of the characters.
<P>
To create an individual font object, use these three arguments
to the <TT>Font</TT> class's <TT>new</TT>
constructor:
<BLOCKQUOTE>
<PRE>
Font f = new Font(&quot;TimesRoman&quot;, Font.BOLD, 24);
</PRE>
</BLOCKQUOTE>
<P>
This example creates a font object for the <TT>TimesRoman
BOLD</TT> font, in <TT>24</TT>
points. Note that like most Java classes, you have to import the
<TT>java.awt.Font</TT> class before
you can use it.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Font styles are actually integer constants that can be added to create combined styles; for example, <TT>Font.BOLD + Font.ITALIC</TT> produces a font that is both bold and italic.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The fonts you have available to you in your applets depend on
which fonts are installed on the system where the applet is running.
If you pick a font for your applet and that font isn't available
on the current system, Java will substitute a default font (usually
Courier). You can get an array of the names of the current fonts
available in the system using this bit of code:
<BLOCKQUOTE>
<PRE>
String[] fontslist = this.getToolkit().getFontList();
</PRE>
</BLOCKQUOTE>
<P>
From this list, you can then often intelligently decide which
fonts you want to use in your applet. For best results, however,
it's a good idea to stick with standard fonts such as <TT>&quot;TimesRoman&quot;</TT>,
<TT>&quot;Helvetica&quot;</TT>, and
<TT>&quot;Courier&quot;</TT>.
<H3><A NAME="DrawingCharactersandStrings">
Drawing Characters and Strings</A></H3>
<P>
With a font object in hand, you can draw text on the screen using
the methods <TT>drawChars()</TT> and
<TT>drawString()</TT>. First, though,
you need to set the current font to your font object using the
<TT>setFont()</TT> method.
<P>
The current font is part of the graphics state that is kept track
of by the <TT>Graphics</TT> object
on which you're drawing. Each time you draw a character or a string
to the screen, Java draws that text in the current font. To change
the font of the text, therefore, first change the current font.
The following <TT>paint()</TT> method
creates a new font, sets the current font to that font, and draws
the string <TT>&quot;This is a big font.&quot;</TT>,
at the point <TT>10,100</TT>:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {
    Font f = new Font(&quot;TimesRoman&quot;, Font.PLAIN, 72);
    g.setFont(f);
    g.drawString(&quot;This is a big font.&quot;, 10, 100);
}
</PRE>
</BLOCKQUOTE>
<P>
This should all look familiar to you; this is how the <TT>Hello
World</TT> and <TT>Hello Again</TT>
applets throughout this book were produced.
<P>
The latter two arguments to <TT>drawString()</TT>
determine the point where the string will start. The <TT>x</TT>
value is the start of the leftmost edge of the text; <TT>y</TT>
is the baseline for the entire string.
<P>
Similar to <TT>drawString()</TT> is
the <TT>drawChars()</TT> method that,
instead of taking a string as an argument, takes an array of characters.
<TT>drawChars()</TT> has five arguments:
the array of characters, an integer representing the first character
in the array to draw, another integer for the last character in
the array to draw (all characters between the first and last are
drawn), and the <TT>x</TT> and <TT>y</TT>
for the starting point. Most of the time, <TT>drawString()</TT>
is more useful than <TT>drawChars()</TT>.
<P>
Listing 9.2 shows an applet that draws several lines of text in
different fonts; Figure 9.20 shows the result.
<P>
<A HREF="http://docs.rinet.ru/J21/f9-20.gif"><B>Figure 9.20: </B><I>The output of the </I><TT>ManyFonts</TT><I>
applet</I>.</A>
<HR>
<BLOCKQUOTE>
<B>Listing 9.2. Many different fonts.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Font;
 2: import java.awt.Graphics;
 3:
 4: public class ManyFonts extends java.applet.Applet {
 5:
 6:    public void paint(Graphics g) {
 7:        Font f = new Font(&quot;TimesRoman&quot;, Font.PLAIN, 18);
 8:        Font fb = new Font(&quot;TimesRoman&quot;, Font.BOLD, 18);
 9:        Font fi = new Font(&quot;TimesRoman&quot;, Font.ITALIC, 18);
10:        Font fbi = new Font(&quot;TimesRoman&quot;, Font.BOLD + Font.ITALIC, 18);
11:
12:        g.setFont(f);
13:        g.drawString(&quot;This is a plain font&quot;, 10, 25);
14:        g.setFont(fb);
15:        g.drawString(&quot;This is a bold font&quot;, 10, 50);
16:        g.setFont(fi);
17:        g.drawString(&quot;This is an italic font&quot;, 10, 75);
18:        g.setFont(fbi);
19:        g.drawString(&quot;This is a bold italic font&quot;, 10, 100);
20:    }
21:
22: }
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="FindingOutInformationAboutaFont">
Finding Out Information About a Font</A></H3>
<P>
Sometimes you may want to make decisions in your Java program
based on the qualities of the current font-for example, its point
size and the total height of its characters. You can find out
some basic information about fonts and font objects by using simple
methods on <TT>Graphics</TT> and on
the <TT>Font</TT> objects. Table 9.1
shows some of these methods.<BR>
<P>
<CENTER><B>Table 9.1. Font methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=127><I>Method Name</I></TD><TD WIDTH=114><I>In Object</I>
</TD><TD WIDTH=349><I>Action</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>getFont()</TT>
</TD><TD WIDTH=114><TT>Graphics</TT> 
</TD><TD WIDTH=349>Returns the current font object as previously set by <TT>setFont()</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>getName()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns the name of the font as a string</TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>getSize()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns the current font size (an integer)</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>getStyle()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns the current style of the font (styles are integer constants: <TT>0</TT> is plain, <TT>1</TT> is bold, <TT>2</TT> is italic, <TT>3</TT> is bold italic)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>isPlain()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns <TT>true</TT> or <TT>false</TT> if the font's style is plain
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>isBold()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns <TT>true</TT> or <TT>false</TT> if the font's style is bold
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=127><TT>isItalic()</TT>
</TD><TD WIDTH=114><TT>Font</TT></TD>
<TD WIDTH=349>Returns <TT>true</TT> or <TT>false</TT> if the font's style is italic
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
For more detailed information about the qualities of the current
font (for example, the length or height of given characters),
you need to work with font metrics. The <TT>FontMetrics</TT>
class describes information specific to a given font: the leading
between lines, the height and width of each character, and so
on. To work with these sorts of values, you create a <TT>FontMetrics</TT>
object based on the current font by using the applet method <TT>getFontMetrics()</TT>:
<BLOCKQUOTE>
<PRE>
Font f = new Font(&quot;TimesRoman&quot;, Font.BOLD, 36);
FontMetrics fmetrics = getFontMetrics(f);
g.setfont(f);
</PRE>
</BLOCKQUOTE>
<P>
Table 9.2 shows some of the things you can find out using font
metrics. All these methods should be called on a <TT>FontMetrics</TT>
object.<BR>
<P>
<CENTER><B>Table 9.2. Font metrics methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><I>Method Name</I></TD><TD WIDTH=385><I>Action</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>stringWidth(string)</TT>
</TD><TD WIDTH=385>Given a string, returns the full width of that string, in pixels
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>charWidth(char)</TT>
</TD><TD WIDTH=385>Given a character, returns the width of that character
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>getAscent()</TT>
</TD><TD WIDTH=385>Returns the ascent of the font, that is, the distance between the font's baseline and the top of the characters
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>getDescent()</TT>
</TD><TD WIDTH=385>Returns the descent of the font-that is, the distance between the font's baseline and the bottoms of the characters (for characters such as p and q that drop below the baseline)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>getLeading()</TT>
</TD><TD WIDTH=385>Returns the leading for the font, that is, the spacing between the descent of one line and the ascent of another line
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>getHeight()</TT>
</TD><TD WIDTH=385>Returns the total height of the font, which is the sum of the ascent, descent, and leading value
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of the sorts of information you can use with font
metrics, Listing 9.3 shows the Java code for an applet that automatically
centers a string horizontally and vertically inside an applet.
The centering position is different depending on the font and
font size; by using font metrics to find out the actual size of
a string, you can draw the string in the appropriate place.
<P>
Figure 9.21 shows the result (which is less interesting than if
you actually compile and experiment with various applet and font
sizes).
<P>
<A HREF="http://docs.rinet.ru/J21/f9-21.gif"><B>Figure 9.21: </B><I>The centered text</I>.</A>
<HR>
<BLOCKQUOTE>
<B>Listing 9.3. Centering a string.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1: import java.awt.Font;
 2: import java.awt.Graphics;
 3: import java.awt.FontMetrics;
 4:
 5: public class Centered extends java.applet.Applet {
 6:
 7:    public void paint(Graphics g) {
 8:        Font f = new Font(&quot;TimesRoman&quot;, Font.PLAIN, 36);
 9:        FontMetrics fm = getFontMetrics(f);
10:        g.setFont(f);
11:
12:        String s = &quot;This is how the world ends.&quot;;
13:        int xstart = (size().width - fm.stringWidth(s)) / 2;
14:        int ystart = size().height / 2;
15:
16:        g.drawString(s, xstart, ystart);
17:    }
18:}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Note the <TT>size()</TT> method in lines 13 and 14, which returns the width and height of the overall applet area as a <TT>Dimension</TT> object. You can then get to the individual width and height using the <TT>width</TT> and <TT>height</TT> instance 
variables of that <TT>Dimension</TT>, here by chaining the method call and the variable name. Getting the current applet size in this way is a better idea than hard coding the size of the applet into your code; this code works equally well with an applet 
of any size.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Note also that the line of text, as shown in Figure 9.21, isn't
precisely vertically centered in the applet bounding box. This
example centers the baseline of the text inside the applet; using
the <TT>getAscent()</TT> and <TT>getDescent()</TT>
methods from the <TT>FontMetrics</TT>
class (to get the number of pixels from the baseline to the top
of the characters and the number of pixels from the baseline to
the bottom of the characters), you can figure out exactly the
middle of the line of text.
<H2><A NAME="Color"><FONT SIZE=5 COLOR=#FF0000>
Color</FONT></A></H2>
<P>
Drawing black lines and text on a gray background is all very
nice, but being able to use different colors is much nicer. Java
provides methods and behaviors for dealing with color in general
through the <TT>Color</TT> class,
and also provides methods for setting the current foreground and
background colors so that you can draw with the colors you created.
<P>
Java's abstract color model uses 24-bit color, wherein a color
is represented as a combination of red, green, and blue values.
Each component of the color can have a number between <TT>0</TT>
and <TT>255</TT>. <TT>0,0,0</TT>
is black, <TT>255,255,255</TT> is
white, and Java can represent millions of colors between as well.
<P>
Java's abstract color model maps onto the color model of the platform
Java is running on, which usually has only 256 or fewer colors
from which to choose. If a requested color in a color object is
not available for display, the resulting color may be mapped to
another or dithered, depending on how the browser viewing the
color implemented it, and depending on the platform on which you're
running. In other words, although Java gives the capability of
managing millions of colors, very few may actually be available
to you in real life.
<H3><A NAME="UsingColorObjects">
Using Color Objects</A></H3>
<P>
To draw an object in a particular color, you must create an instance
of the <TT>Color</TT> class to represent
that color. The <TT>Color</TT> class
defines a set of standard color objects, stored in class variables,
to quickly get a color object for some of the more popular colors.
For example, <TT>Color.red</TT> returns
a <TT>Color</TT> object representing
red (RGB values of <TT>255</TT>,<TT>
0</TT>, and <TT>0</TT>), <TT>Color.white</TT>
returns a white color (RGB values of <TT>255</TT>,
<TT>255</TT>, and <TT>255</TT>),
and so on. Table 9.3 shows the standard colors defined by variables
in the <TT>Color</TT> class.<BR>
<P>
<CENTER><B>Table 9.3. Standard colors.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=193><I>Color Name</I></TD><TD WIDTH=198><I>RGB Value</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.white</TT>
</TD><TD WIDTH=198><TT>255,255,255</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.black</TT>
</TD><TD WIDTH=198><TT>0,0,0</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.lightGray</TT>
</TD><TD WIDTH=198><TT>192,192,192</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.gray</TT>
</TD><TD WIDTH=198><TT>128,128,128</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.darkGray</TT>
</TD><TD WIDTH=198><TT>64,64,64</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.red</TT>
</TD><TD WIDTH=198><TT>255,0,0</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.green</TT>
</TD><TD WIDTH=198><TT>0,255,0</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.blue</TT>
</TD><TD WIDTH=198><TT>0,0,255</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.yellow</TT>
</TD><TD WIDTH=198><TT>255,255,0</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.magenta</TT>
</TD><TD WIDTH=198><TT>255,0,255</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.cyan</TT>
</TD><TD WIDTH=198><TT>0,255,255</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.pink</TT>
</TD><TD WIDTH=198><TT>255,175,175</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=193><TT>Color.orange</TT>
</TD><TD WIDTH=198><TT>255,200,0</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
If the color you want to draw in is not one of the standard <TT>Color</TT>
objects, fear not. You can create a color object for any combination
of red, green, and blue, as long as you have the values of the
color you want. Just create a new color object:
<BLOCKQUOTE>
<PRE>
Color c = new Color(140,140,140);
</PRE>
</BLOCKQUOTE>
<P>
This line of Java code creates a color object representing a dark
gray. You can use any combination of red, green, and blue values
to construct a color object.
<P>
Alternatively, you can create a color object using three floats
from <TT>0.0</TT> to <TT>1.0</TT>:
<BLOCKQUOTE>
<PRE>
Color c = new Color(0.55,0.55,0.55);
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TestingandSettingtheCurrentColors">
Testing and Setting the Current Colors</A></H3>
<P>
To draw an object or text using a color object, you have to set
the current color to be that color object, just as you have to
set the current font to the font in which you want to draw. Use
the <TT>setColor()</TT> method (a
method for <TT>Graphics</TT> objects)
to do this:
<BLOCKQUOTE>
<PRE>
g.setColor(Color.green);
</PRE>
</BLOCKQUOTE>
<P>
After you set the current color, all drawing operations will occur
in that color.
<P>
In addition to setting the current color for the graphics context,
you can also set the background and foreground colors for the
applet itself by using the <TT>setBackground()</TT>
and <TT>setForeground()</TT> methods.
Both of these methods are defined in the <TT>java.awt.Component</TT>
class, which <TT>Applet</TT>-and therefore
your classes-automatically inherits.
<P>
The <TT>setBackground()</TT> method
sets the background color of the applet, which is usually a light
gray (to match the default background of the browser). It takes
a single argument, a <TT>Color</TT>
object:
<BLOCKQUOTE>
<PRE>
setBackground(Color.white);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setForeground()</TT> method
also takes a single color as an argument, and it affects everything
that has been drawn on the applet, regardless of the color in
which it has been drawn. You can use <TT>setForeground()</TT>
to change the color of everything in the applet at once, rather
than having to redraw everything:
<BLOCKQUOTE>
<PRE>
setForeground(Color.black);
</PRE>
</BLOCKQUOTE>
<P>
In addition to the <TT>setColor()</TT>,
<TT>setForeground()</TT>, and <TT>setBackground()</TT>
methods, there are corresponding <TT>get</TT>
methods that enable you to retrieve the current graphics color,
background, or foreground. Those methods are <TT>getColor()</TT>
(defined in <TT>Graphics</TT> objects),
<TT>getForeground()</TT> (defined
in <TT>Applet</TT>), and <TT>getBackground()</TT>
(also in <TT>Applet</TT>). You can
use these methods to choose colors based on existing colors in
the applet:
<BLOCKQUOTE>
<PRE>
setForeground(g.getColor());
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ASimpleColorExample">
A Simple Color Example</A></H3>
<P>
Listing 9.4 shows the code for an applet that fills the applet's
drawing area with square boxes, each of which has a randomly chosen
color in it. It's written so that it can handle any size of applet
and automatically fill the area with the right number of boxes.
<HR>
<BLOCKQUOTE>
<B>Listing 9.4. Random color boxes.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 1:  import java.awt.Graphics;
 2:  import java.awt.Color;
 3:
 4:  public class ColorBoxes extends java.applet.Applet {
 5:
 6:      public void paint(Graphics g) {
 7:          int rval, gval, bval;
 8:
 9:          for (int j = 30; j &lt; (size().height -25); j += 30)
10:             for (int i = 5; i &lt; (size().width -25); i += 30) {
11:                 rval = (int)Math.floor(Math.random() * 256);
12:                 gval = (int)Math.floor(Math.random() * 256);
13:                 bval = (int)Math.floor(Math.random() * 256);
14:
15:                 g.setColor(new Color(rval,gval,bval));
16:                 g.fillRect(i, j, 25, 25);
17:                 g.setColor(Color.black);
18:                 g.drawRect(i-1, j-1, 25, 25);
19:             }
20:     }
21: }<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Analysis</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The two <TT>for</TT> loops are the heart of this example; the first one draws the rows, and the second draws the individual boxes within each row. When a box is drawn, the random color is calculated first, and then the box is drawn. A black outline is 
drawn around each box, because some of them tend to blend into the background of the applet.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Because this <TT>paint</TT> method
generates new colors each time the applet is painted, you can
regenerate the colors by moving the window around or by covering
the applet's window with another one (or by reloading the page).
Figure 9.22 shows the final applet (although given that this picture
is black and white, you can't get the full effect of the multicolored
squares).
<P>
<A HREF="http://docs.rinet.ru/J21/f9-22.gif"><B>Figure 9.22: </B><I>The random colors applet</I>.</A>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
You present something on the screen by painting inside your applet:
shapes, graphics, text, or images. Today you have learned the
basics of how to paint, including how to use the graphics primitives
to draw rudimentary shapes, how to use fonts and font metrics
to draw text, and how to use <TT>Color</TT>
objects to change the color of what you're drawing on the screen.
It's this foundation in painting that enables you to do animation
inside an applet (which basically involves just painting repeatedly
to the screen) and to work with images. These are topics you'll
learn about tomorrow.
<H2><A NAME="QampABR"><FONT SIZE=5 COLOR=#FF0000>
Q&amp;A<BR>
</FONT></A></H2>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>In all the examples you show, and in all the tests I've made, the graphics primitives, such as <TT><B>drawLine()</B></TT> and <TT><B>drawRect()</B></TT>, produce lines that are one pixel 
wide. How can I draw thicker lines?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>In the current state of the Java Graphics class, you can't; no methods exist for changing the default line width. If you really need a thicker line, you have to draw multiple lines one pixel 
apart to produce that effect.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I want to draw a line of text with a boldface word in the middle. I understand that I need two font objects-one for the regular font and one for the bold one-and that I'll need to reset the 
current font in between. The problem is that <TT><B>drawString()</B></TT> requires an <TT><B>x</B></TT> and a <TT><B>y</B></TT> position for the start of each string, and can't find anything that refers to &quot;current point.&quot; How can I figure out 
where to start the boldface word? </B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Java's text display capabilities are fairly primitive. There is no concept of the current point, so you'll have to manually figure out where the end of one string was so that you can begin the 
next string. The <TT>stringWidth()</TT> methods can help you with that, both to find out the width of the string you just drew and to add the space after it. 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>How do I use non-roman fonts such as kanji in Java?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Java's support for international fonts in the 1.0.2 version of the JDK is sketchy, beyond the encoding of the raw characters as Unicode. Your best bet is to wait for the 1.1 version of the JDK, 
which will offer much more flexibility in the way of Unicode character display, support for internationalization, and non-roman fonts.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I tried out the applet that draws boxes with random colors, but each time it draws, a lot of the boxes are the same color. If the colors are truly random, why is it doing this?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Two reasons. The first is that the random number generator I used in that code (from the <TT>Math</TT> class) isn't a very good random number generator; in fact, the documentation for that 
method says as much. For a better random number generator, use the <TT>Random</TT> class from the <TT>java.util</TT> package.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>&nbsp;</B></CENTER></TD><TD>The second, more likely, reason is that there just aren't enough colors available in your browser or on your system to draw all the colors that the applet is generating. If your system 
can't produce the wide range of colors available using the <TT>Color</TT> class, or if the browser has allocated too many colors for other things, you may end up with duplicate colors in the boxes, depending on how the browser and the system have been 
written to handle that. Usually your applet won't use quite so many colors, so you won't run into this problem quite so often.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>Q:</B></CENTER></TD><TD><B>I have a tiled background on my Web page. I can create images with transparent backgrounds so that the tiled page background shows through. Can I create transparent applets?</B>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=40><CENTER><B>A:</B></CENTER></TD><TD>Not with the 1.02 JDK (and perhaps not with 1.1 either). For applets, your best bet is to use a plain-colored background and set your applet's background to be that same color.
<P>
Another idea if you use a tile for the page background is to import that image and draw it as the background for your applet (you'll learn about images tomorrow). However, using that mechanism, it is unlikely that the edges of the tile will exactly match 
up. Unfortunately, there doesn't appear to be a good workaround for this problem. 
</TD></TR>
</TABLE>
</CENTER>
<HR>

<CENTER><P><A HREF="ch8.htm"><IMG SRC="http://docs.rinet.ru/J21/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/J21/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/J21/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch10.htm"><IMG SRC="http://docs.rinet.ru/J21/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
