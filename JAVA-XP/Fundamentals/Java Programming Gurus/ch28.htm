<HTML>

<HEAD>
   <TITLE>Chapter 28 -- Moving C and C++ Code to Java</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 28</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Moving C and C++ Code to Java</B></FONT>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#FileOrganization" >File Organization</A>
<LI><A HREF="#ThePreprocessor" >The Preprocessor</A>
<LI><A HREF="#StructuresandUnions" >Structures and Unions</A>
<LI><A HREF="#FunctionsandMethods" >Functions and Methods</A>
<LI><A HREF="#ProceduraltoOOpconversion" >Procedural-to-OOP Conversion</A>
<LI><A HREF="#OperatorOverloading" >Operator Overloading</A>
<LI><A HREF="#AutomaticCoercions" >Automatic Coercions</A>
<LI><A HREF="#CommandLineArguments" >Command-Line Arguments</A>
<LI><A HREF="#IOStreams" >I/O Streams</A>
<LI><A HREF="#Strings" >Strings</A>
<LI><A HREF="#Pointers" >Pointers</A>
<LI><A HREF="#MultipleInheritance" >Multiple Inheritance</A>
<LI><A HREF="#InheritanceSyntax" >Inheritance Syntax</A>
<LI><A HREF="#AccessModifiers" >Access Modifiers</A>
<LI><A HREF="#FriendsandPackages" >Friends and Packages</A>
<LI><A HREF="#Booleans" >Booleans</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Even though Java is catching on pretty rapidly as a powerful new
language with a lot of potential, there is a significant problem
in dealing with the large existing C and C++ code base. As a Java
programmer, you have two solutions to this problem: convert your
existing C/C++ code to Java or interface your Java code to the
C/C++ code. Although the latter solution is certainly a viable
option, especially in terms of development resources, this chapter
focuses on the former. If you're really bent on keeping your C/C++
code as it is, check out <A HREF="ch32.htm" >Chapter 32</A>, &quot;Interfacing
to Existing C and C++ Libraries.&quot;
<P>
The prospect of moving C/C++ code to Java might seem somewhat
daunting at first. However, the similarities in syntax between
the languages alone makes matters a little easier to handle. In
reality, you can isolate the differences between the languages
and form a strategy aimed at fixing trouble spots in the code.
<P>
This chapter takes on the challenge of converting C/C++ code to
Java code an issue at a time. You learn not only how to convert
C/C++ code to Java, but also why Java is different and requires
the changes in the first place. If you are following along attempting
to port your own code, try to make incremental changes as you
cover each section. You'll probably find that the task isn't as
bad as you originally thought. With that in mind, let's get started!
<H2><A NAME="FileOrganization"><B><FONT SIZE=5 COLOR=#FF0000>File
Organization</FONT></B></A></H2>
<P>
Before you even begin changing any source code, it's important
to understand a fundamental difference between source files in
Java and C/C++. In C and C++, most source files come in pairs
consisting of a header file (.h) and an implementation file (.c
or .cpp). The purpose of this file structure is to separate the
declarations of the functions and classes from the definitions.
This enables other programmers to understand code by viewing header
files, while keeping them out of the specific implementation details
found in the implementation files.
<P>
In Java, there is only one source file (.java) per logical code
structure. Java classes contain class declaration information
that can be easily extracted using the <TT>javap</TT>
class file disassembler tool that comes with the JDK. Because
of this, there is no need to maintain a header file with class
declaration information. All the code for a Java class goes in
the .java source file.
<P>
What does this mean to you? Well, it means you should get ready
to merge all your header and implementation files into .java files.
Once you've done that, you can move into modifying the code itself.
<H2><A NAME="ThePreprocessor"><B><FONT SIZE=5 COLOR=#FF0000>The
Preprocessor</FONT></B></A></H2>
<P>
All C/C++ compilers implement a stage of compilation known as
the preprocessor. The C++ preprocessor basically performs an intelligent
search and replace on identifiers that have been declared using
the <TT>#define</TT> directive or
<TT>typedef</TT>. Although most advocators
of C++ discourage the use of the preprocessor, which was inherited
from C, it is still widely used by most C++ programmers. Most
of the processor definitions in C++ are stored in header files,
which complement the actual source code (implementation) files.
<P>
The problem with the preprocessor approach is that it provides
an easy way for programmers inadvertently to add unnecessary complexity
to a program. Many programmers using <TT>#define</TT>
and <TT>typedef</TT> end up inventing
their own sublanguage within the confines of a particular project.
This results in other programmers having to go through the header
files and sort out all the <TT>#define</TT>
and <TT>typedef</TT> information to
understand a program, which makes code maintenance and reuse almost
impossible. An additional problem with the preprocessor approach
is that it is very weak when it comes to type checking and validation.
<P>
Java does not have a preprocessor. It provides similar functionality
(<TT>#define</TT>, <TT>typedef</TT>,
and so forth) to that provided by the C++ preprocessor, but with
far more control. Constant data members are used in place of the
<TT>#define</TT> directive, and class
definitions are used in lieu of <TT>typedef</TT>.
The end result is that Java source code is much more consistent
and easier to read than C++ source code. Additionally, as you
learned earlier, Java programs don't use header files; the Java
compiler builds class declarations directly from the source code
files, which contain both class declarations and method implementations.
<P>
Let's look at an example; Listing 28.1 shows a C++ header file
for a ball class.
<HR>
<BLOCKQUOTE>
<B>Listing 28.1. The C++ <TT>ball</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#define COLOR_RED 1<BR>
#define COLOR_YELLOW 2<BR>
#define COLOR_BLUE 3<BR>
#define MATERIAL_RUBBER 1<BR>
#define MATERIAL_LEATHER 2<BR>
<BR>
class ball {<BR>
&nbsp;&nbsp;float diameter;<BR>
</TT>&nbsp;<TT>&nbsp;int color;<BR>
&nbsp;&nbsp;int material;<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
To move this code to Java, the only change is to get rid of the
preprocessor <TT>#define</TT> directives
and the semicolon at the end of the class declaration. You get
rid of the <TT>#define</TT> directives
by declaring Java class members that are <TT>static</TT>
and <TT>final</TT>. For data members
in Java, the <TT>static</TT> keyword
means there is only one copy for the entire class, and the <TT>final</TT>
keyword means that they are constant, which is usually the motive
for using <TT>#define</TT> in C/C++
code. Listing 28.2 shows the resulting Java version of this class.
Keep in mind that the Java version is not stored in a header file,
because Java doesn't support header files; in Java, definitions
and declarations are combined in one place, the .java source file.
<HR>
<BLOCKQUOTE>
<B>Listing 28.2. The Java <TT>ball</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class ball {<BR>
&nbsp;&nbsp;// Constants<BR>
</TT>&nbsp;<TT>&nbsp;static final
int COLOR_RED = 1;<BR>
&nbsp;&nbsp;static final int COLOR_YELLOW = 2;<BR>
</TT>&nbsp;<TT>&nbsp;static final
int COLOR_BLUE = 3;<BR>
&nbsp;&nbsp;static final int MATERIAL_RUBBER = 1;<BR>
</TT>&nbsp;<TT>&nbsp;static final
int MATERIAL_LEATHER = 2;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Variables
<BR>
&nbsp;&nbsp;float diameter;<BR>
</TT>&nbsp;<TT>&nbsp;int color;<BR>
&nbsp;&nbsp;int material;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The Java version of <TT>ball</TT>
pulls all the constants inside the class definition as <TT>static
final</TT> integers. Within this class, you would then
refer to them just as you would the previous C++ versions. However,
outside this class they are inaccessible, because they have been
left at their default access type. To make them visible by other
classes, you simply declare their access type as <TT>public</TT>,
as shown in Listing 28.3. The statement about default access isn't
entirely true; you learn the whole scoop about access types later
in this chapter.
<HR>
<BLOCKQUOTE>
<B>Listing 28.3. The Java <TT>ball</TT>
class with public constants.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class ball {<BR>
&nbsp;&nbsp;// Constants<BR>
</TT>&nbsp;<TT>&nbsp;public static
final int COLOR_RED = 1;<BR>
&nbsp;&nbsp;public static final int COLOR_YELLOW = 2;<BR>
</TT>&nbsp;<TT>&nbsp;public static
final int COLOR_BLUE = 3;<BR>
&nbsp;&nbsp;public static final int MATERIAL_RUBBER = 1;<BR>
</TT>&nbsp;<TT>&nbsp;public static
final int MATERIAL_LEATHER = 2;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;// Variables
<BR>
&nbsp;&nbsp;float diameter;<BR>
</TT>&nbsp;<TT>&nbsp;int color;<BR>
&nbsp;&nbsp;int material;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In this version of <TT>ball</TT>,
the constants are readily available for other classes to use.
However, those classes must explicitly refer to the constants
using the <TT>ball</TT> class name:
<P>
<TT>int color = ball.COLOR_YELLOW;</TT>
<H2><A NAME="StructuresandUnions"><B><FONT SIZE=5 COLOR=#FF0000>Structures
and Unions</FONT></B></A></H2>
<P>
There are three types of complex data types in C/C++: classes,
structures (structs), and unions. Java supports only one of these
data types, classes. Java forces programmers to use classes when
the functionality of structures and unions is desired. Although
this sounds like more work for the programmer, it actually ends
up being more consistent, because classes can imitate structures
and unions with ease. Furthermore, supporting structs and unions
would have put a major hole in the whole concept of the Java language
being object-oriented. The Java designers really wanted to keep
the language simple, so it only made sense to eliminate aspects
of the language that overlapped.
<P>
Converting structs and unions to Java classes is pretty easy.
Take a look at Listing 28.4, which contains a polar coordinate
C struct.
<HR>
<BLOCKQUOTE>
<B>Listing 28.4. The C <TT>polar</TT>
struct.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>typedef struct polar {<BR>
&nbsp;&nbsp;float angle;<BR>
</TT>&nbsp;<TT>&nbsp;float magnitude
<BR>
} POLAR;</TT>
</BLOCKQUOTE>
<HR>
<P>
Notice that this struct uses a <TT>typedef</TT>
to establish the <TT>polar</TT> type.
As you learned earlier, <TT>typedef</TT>s
aren't necessary in Java, because everything is an object with
a unique type. Java doesn't support the concept of a struct either.
Listing 28.5 contains the Java version of the <TT>polar</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 28.5. The Java <TT>polar</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class polar {<BR>
&nbsp;&nbsp;float angle;<BR>
</TT>&nbsp;<TT>&nbsp;float magnitude
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In addition to changing the <TT>typedef struct</TT>
declaration to <TT>class</TT>, notice
that the Java <TT>polar</TT> class
isn't followed by a semicolon. This is a small, but often overlooked,
difference between Java and C++; semicolons aren't necessary in
Java<TT> class definitions</TT>.
<H2><A NAME="FunctionsandMethods"><B><FONT SIZE=5 COLOR=#FF0000>Functions
and Methods</FONT></B></A></H2>
<P>
In C, code is organized into functions, which are global subroutines
accessible to a program. C++ added classes and in doing so provided
class methods, which are functions that are connected to classes.
C++ class methods are very similar to Java class methods. However,
because C++ still supports C, there is nothing keeping C++ programmers
from using functions. This results in a mixture of function and
method use that makes for confusing programs.
<P>
Java has no functions. Being a purer object-oriented language
than C++, Java forces programmers to bundle all subroutines into
class methods. There is no limitation imposed by forcing programmers
to use methods instead of functions. As a matter of fact, implementing
subroutines as methods encourages programmers to organize code
better. Keep in mind that, strictly speaking, there is nothing
wrong with the procedural approach of using functions; it just
doesn't mix well with the object-oriented paradigm that defines
the core of Java.
<P>
Because almost all C/C++ code contains some degree of function
use, this is a particularly important issue when porting C/C++
code to Java. Fortunately, it's mostly an organizational change.
The whole point of functions is to move code into a logically
separate procedure that can be called from the main program or
other functions. You can easily recreate this scenario in Java
without having to &quot;objectify&quot; the code completely. The
solution is to move global C/C++ functions into method-only organizational
Java classes. Check out Listing 28.6, which contains a series
of string encryption/decryption function prototypes.
<HR>
<BLOCKQUOTE>
<B>Listing 28.6. The C string encryption/decryption function prototypes.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>char EncryptChar(char c, int key);<BR>
char DecryptChar(char c, int key);<BR>
char* EncryptString(const char* s, int key);<BR>
char* DecryptString(const char* s, int key);</TT>
</BLOCKQUOTE>
<HR>
<P>
These functions are global C functions that encrypt and decrypt
characters and strings. Of course, in C/C++ there is no pure concept
of a string; an array of characters is the best you get (more
on that later in this chapter). A straight function-to-method
port of these functions in Java is shown in Listing 28.7.
<HR>
<BLOCKQUOTE>
<B>Listing 28.7. The Java string encryption/decryption methods
encapsulated within the <TT>crypt</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class crypt {<BR>
&nbsp;&nbsp;public static char encryptChar(char c, int key) {
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
character encryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public static char decryptChar(char c, int key) {
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
character decryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public static String encryptString(String s, int key)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
string encryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public static String decryptString(String s, int key)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
string decryption code<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In Java, you have to package the functions as methods in a class,
<TT>crypt</TT>. By declaring them
as <TT>public static</TT>, you make
them readily available to the entire Java system. The key aspect
of the Java version of the functions is that their implementations
are defined in a Java class because Java doesn't support the header/source
file organization. All class information goes directly into the
class definition. Notice that the standard naming convention for
Java methods is to begin each method name with a lowercase character.<TT>
</TT>To use the Java methods, you have to reference them
with the <TT>crypt</TT> class name:
<P>
<TT>char c = crypt.encryptChar('a', 7);</TT>
<P>
The only other change to the C functions is the usage of <TT>String</TT>
objects rather than <TT>char</TT>
pointers because Java doesn't support pointers. You get into more
details surrounding strings and pointers a little later in this
chapter.
<H2><A NAME="ProceduraltoOOpconversion"><B><FONT SIZE=5 COLOR=#FF0000>Procedural-to-OOP
Conversion</FONT></B></A></H2>
<P>
Although the Java <TT>crypt</TT> class
provides working Java versions of the procedural C functions,
performing this type of conversion isn't always enough. The <TT>crypt</TT>
class provides a good example of how you can maintain a procedural
feel within a Java class. Java is an object-oriented language,
however, and you should design your code to fit into the object-oriented
paradigm whenever possible. The <TT>crypt</TT>
class is no exception to this rule.
<P>
Examining the <TT>crypt</TT> class
methods, it is apparent that some things could be modified to
make the class fit into a more object-oriented design. Listing
28.8 contains the source code for the revised, objectified <TT>crypt</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 28.8. The revised Java <TT>>crypt</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class crypt {<BR>
&nbsp;&nbsp;int key;<BR>
<BR>
&nbsp;&nbsp;crypt(int k) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;key
= k;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setKey(int k) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;key
= k;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;int getKey() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
key;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;char encryptChar(char c) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
character encryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;char decryptChar(char c) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
character decryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;String encryptString(String s) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
string encryption code<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;String decryptString(String s) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
string decryption code<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In this version of <TT>crypt</TT>,
the encryption key has been moved from a method parameter to a
data member of the class, <TT>key</TT>.
A constructor was added that accepts an encryption key when the
object is created, along with access methods for getting and setting
the key. The <TT>public static</TT>
declarations for the encrypt/decrypt methods have also been removed,
which requires you to have an instance of the <TT>crypt</TT>
class to use the methods. This makes sense, because the class
now has a data member (<TT>key</TT>)
that affects the methods.
<P>
This revised design of the crypt class makes much more sense from
a Java programming perspective. Of course, it won't run any faster
or perform better encryption, but that's not the point. The point
is that object-oriented design practices are a fundamental part
of the Java language and should be followed whenever possible.
<H2><A NAME="OperatorOverloading"><B><FONT SIZE=5 COLOR=#FF0000>Operator
Overloading</FONT></B></A></H2>
<P>
Operator overloading, which is considered a prominent feature
in C++, is not supported in Java. Although roughly the same functionality
can be implemented as methods in Java classes, the syntactic convenience
of operator overloading is still missing. However, in defense
of Java, operator overloading can sometimes get very tricky. The
Java developers decided not to support operator overloading to
keep the Java language as simple as possible.
<P>
Although operator overloading is a pretty useful feature in C++,
its usage is highly dependent on the types of C++ classes with
which you're dealing. For example, more fundamental C++ data structure
classes, such as string classes, make heavy use of operator overloading,
whereas others may not use it all. The amount of porting work
you have in front of you depends on how much your C++ code relies
on operator overloading.
<P>
The only way to convert overloaded C++ operators to Java is to
create equivalent Java methods with the same functionality. Keep
in mind that the Java methods will be called differently than
the C++ overloaded operators. This means you have to dissect your
code carefully to find out where each operator is used and then
convert the code to a method call.
<P>
Let's look at an example; Listing 28.9 contains a complex number
class with overloaded operators.
<HR>
<BLOCKQUOTE>
<B>Listing 28.9. The C++ <TT>Complex</TT>
class with overloaded operators.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Complex {<BR>
&nbsp;&nbsp;float real;<BR>
</TT>&nbsp;<TT>&nbsp;float imaginary;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;Complex(float
r, float i);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;Complex operator+(const
Complex&amp; c) const {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real + c.real, imaginary
+ c.imaginary);<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;Complex operator-(const
Complex&amp; c) const {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real - c.real, imaginary
- c.imaginary);<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
The C++ <TT>Complex</TT> number class
supports overloaded operators for addition and subtraction. The
following is an example of how this class is used:
<BLOCKQUOTE>
<TT>Complex c1(3.0, 4.0);<BR>
Complex c2(5.0, 2.5);<BR>
Complex c3 = c2 - c1;</TT>
</BLOCKQUOTE>
<P>
The subtraction of the <TT>Complex</TT>
objects is syntactically the same as subtracting two fundamental
data types. However, this capability adds a significant amount
of complexity to C++ that the Java architects wanted to avoid.
So, although you can't provide the same syntactic approach in
Java, you can provide methods with similar functionality. Listing
28.10 contains the Java version of the <TT>Complex</TT>
class, complete with method versions of the overloaded operators.
<HR>
<BLOCKQUOTE>
<B>Listing 28.10. The Java <TT>Complex</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Complex {<BR>
&nbsp;&nbsp;float real;<BR>
</TT>&nbsp;<TT>&nbsp;float imaginary;
<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;Complex(float
r, float i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;real = r;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;imaginary
= i;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Complex add(Complex c) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
(new Complex(real + c.real, imaginary + c.imaginary));<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Complex subtract(Complex c) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;return
(new Complex(real - c.real, imaginary - c.imaginary));<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The most obvious change in the Java version of <TT>Complex</TT>
is the renaming of the operator overloaded methods to <TT>add</TT>
and <TT>subtract</TT>. The Java <TT>Complex</TT>
class is used like this:
<BLOCKQUOTE>
<TT>Complex c1 = new Complex(3.0, 4.0);<BR>
Complex c2 = new Complex(5.0, 2.5);<BR>
Complex c3 = c2.subtract(c1);</TT>
</BLOCKQUOTE>
<P>
You can see how the subtraction operation isn't quite as intuitive
using the Java approach. Nevertheless, it does work. Notice also
that the <TT>Complex</TT> objects
are created using the <TT>new</TT>
operator. This is a result of the differences between memory management
in Java and C++, which you learn about when you get into pointers
a little later in this chapter.
<H2><A NAME="AutomaticCoercions"><B><FONT SIZE=5 COLOR=#FF0000>Automatic
Coercions</FONT></B></A></H2>
<P>
<I>Automatic coercion</I> refers to the implicit casting of data
types that sometimes occurs in C and C++. For example, in C++
you are allowed to assign a <TT>float</TT>
value to an <TT>int</TT> variable,
which can result in a loss of information. Java does not support
C++ style automatic coercions. In Java, if a coercion will result
in a loss of data, you must always explicitly cast the data element
to the <TT>new</TT> type.
<P>
The following is an example of an automatic coercion in C++:
<BLOCKQUOTE>
<TT>float f = 3.1412;<BR>
int i = f;</TT>
</BLOCKQUOTE>
<P>
Some C++ compilers may actually generate a warning for this code,
but it's not considered an error. In Java, on the other hand,
this code results in a compile error. It is easily fixed with
an explicit cast, such as this:
<BLOCKQUOTE>
<TT>float f = 3.1412;<BR>
int i = (int)f;</TT>
</BLOCKQUOTE>
<H2><A NAME="CommandLineArguments"><B><FONT SIZE=5 COLOR=#FF0000>Command-Line
Arguments</FONT></B></A></H2>
<P>
The command-line arguments passed from the system into a Java
program differ in a couple of ways from the command-line arguments
passed into a C++ program. First, the number of parameters passed
differs between the two languages. In C and C++, the system passes
two arguments to a program: <TT>argc</TT>
and <TT>argv</TT>. <TT>argc</TT>
specifies the number of arguments stored in <TT>argv</TT>.
<TT>argv</TT> is a pointer to an array
of character pointers containing the actual arguments. In Java,
the system passes a single value to a program: <TT>args</TT>.
<TT>args</TT> is an array of <TT>String</TT>
objects that contains the command-line arguments.
<P>
In C and C++, the command-line arguments passed into a program
include the name used to invoke the program. This name always
appears as the first argument, and it is rarely used. In Java,
you already know the name of the program because it is the same
name as the class, so there is no need to pass this information
as a command-line argument. Therefore, the Java runtime system
passes only the arguments following the name that invoked the
program.
<P>
Listing 28.11 contains a simple C++ program that prints out the
argument list.
<HR>
<BLOCKQUOTE>
<B>Listing 28.11. A C++ program to print the argument list.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>#include &lt;iostream.h&gt;<BR>
#include &lt;string.h&gt;<BR>
<BR>
void main(int argc, char* argv[])<BR>
{<BR>
&nbsp;&nbsp;for(int i = 1; i &lt; argc; i++)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;cout
&lt;&lt; argv[i] &lt;&lt; &quot;\n&quot;;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
This program simply iterates through each argument using a <TT>for</TT>
loop, printing each to the standard output stream. Notice that
the loop starts at <TT>1</TT> to avoid
printing the name of the program itself (the first argument).
Listing 28.12 contains the Java equivalent, the <TT>ArgPrint</TT>
application class.
<HR>
<BLOCKQUOTE>
<B>Listing 28.12. The Java <TT>ArgPrint</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class ArgPrint {<BR>
&nbsp;&nbsp;public static void main(String[] args) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;for
(int i = 0; i &lt; args.length; i</TT><STRIKE></TT>I</FONT></STRIKE><TT>++)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(args[i]);
<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ArgPrint</TT> class contains
one method, the <TT>main</TT> method.
This is the Java equivalent of the C/C++ <TT>main</TT>
function; it is called when the Java program is executed. Notice
that the <TT>main</TT> method takes
an array of <TT>String</TT> objects
as parameters. The usage of this array highlights another interesting
difference between Java and C++, arrays. All Java arrays have
a data member called <TT>length</TT>
that can be used to determine how many elements an array contains.
In this case, <TT>length</TT> is used
to iterate through the array of <TT>String</TT>
arguments.
<H2><A NAME="IOStreams"><B><FONT SIZE=5 COLOR=#FF0000>I/O Streams</FONT></B></A>
</H2>
<P>
You probably noticed the absence of the <TT>cout</TT>
standard output stream object in the Java <TT>ArgPrint</TT>
class. There's a good reason for this: Java doesn't implement
any of the standard C++ stream objects. However, it does contain
similar equivalents. The Java <TT>System</TT>
class implements three stream objects that are very similar to
the C++ standard stream objects: <TT>in</TT>,
<TT>out</TT>, and <TT>err</TT>.
You access these stream objects with the <TT>System</TT>
class.
<P>
The <TT>ArgPrint</TT> class showed
how to use the <TT>out</TT> stream
object to output text. The <TT>out</TT>
object is of type <TT>OutputStream</TT>,
and it contains a number of methods, such as <TT>println</TT>,
for outputting data to the standard output stream. Similarly,
the <TT>in</TT> and <TT>err</TT>
objects contain a variety of methods for performing stream input
and output. In most cases, you can convert standard C++ stream
I/O code to Java stream I/O code by simply changing the references
from <TT>cin</TT> to <TT>System.in</TT>,
and so forth. Because Java doesn't support operator overloading,
you also need to change any <TT>&lt;&lt;</TT>
or <TT>&gt;&gt;</TT> operations to
the equivalent Java method calls.
<H2><A NAME="Strings"><B><FONT SIZE=5 COLOR=#FF0000>Strings</FONT></B></A>
</H2>
<P>
C and C++ have no built-in support for text strings. The standard
technique adopted among C and C++ programmers is that of using
null-terminated arrays of characters to represent strings. In
Java, strings are implemented as first class objects (<TT>String</TT>
and <TT>StringBuffer</TT>), meaning
that they are at the core of the Java language. Java's implementation
of strings as objects provides several advantages:
<UL>
<LI>The manner in which you create strings and access the elements
of strings is consistent across all strings on all systems.
<LI>Because the Java string classes are defined as part of the
Java language, and not part of some extraneous extension, Java
strings function predictably every time.
<LI><FONT COLOR=#000000>The Java string classes perform extensive
runtime checking, which helps eliminate troublesome runtime errors.</FONT>
</UL>
<P>
Although it's easy to see the advantages of Java strings, converting
C++ code to Java that makes heavy use of null-terminated character
arrays is another issue. Next to pointers, string code is probably
the most troublesome code to convert to Java. You simply must
get dirty with the details and figure out exactly what is happening
to be able to change the code to use Java string objects. The
other problem is that character arrays are used extensively in
almost every C/C++ program.
<P>
Listing 28.13 contains a simple C++ function that manipulates
null-terminated character strings, <TT>ReverseIt</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 28.13. The C++ <TT>ReverseIt</TT>
function.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>char* ReverseIt(const char* szText) {
<BR>
&nbsp;&nbsp;int len = strlen(szText);<BR>
</TT>&nbsp;<TT>&nbsp;char* dest =
new char[len];<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;for (i = (len
- 1); i &gt;</TT><STRIKE></TT>&lt;</FONT></STRIKE><TT>=
0; i--)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dest[len - i - 1] = szText[i];<BR>
</TT>&nbsp;<TT>&nbsp;return dest;
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>ReverseIt</TT> function takes
an array of characters and returns an array of characters that
is the reverse of the original. It simply creates a new array
and copies each character from the original array in reverse order.
Notice, however, that there is nothing stopping you from writing
code that overruns an array bound, or even from manipulating the
character pointers. Even though this code works fine, the very
nature of C++ makes it prone to potentially dangerous pitfalls
implemented at the programmer's discretion. Take a look at the
Java version of the same function, <TT>reverseIt</TT>,
which is now a method in the <TT>Reverse</TT>
class in Listing 28.14.
<HR>
<BLOCKQUOTE>
<B>Listing 28.14. The Java <TT>Reverse</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Reverse {<BR>
&nbsp;&nbsp;String reverseIt(String s) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;int
i, len = s.length();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer dest = new StringBuffer(len);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i = (len - 1); i &gt;= 0; i--)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dest.append(s.charAt(i));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return dest.toString();<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The Java <TT>reverseIt</TT> method
has no mention or use of arrays. In Java, strings are first class
citizens implemented by the <TT>String</TT>
and <TT>StringBuffer</TT> classes;
they are genuine data types that can be manipulated like integers
or floating-point numbers. All modifications to Java strings must
take place through the class methods defined in the <TT>String</TT>
and <TT>StringBuffer</TT> classes,
as you can see in the <TT>reverseIt</TT>
method.
<H2><A NAME="Pointers"><B><FONT SIZE=5 COLOR=#FF0000>Pointers</FONT></B></A>
</H2>
<P>
Most developers agree that the misuse of pointers causes the majority
of bugs in C/C++ programming. Put simply, when you have pointers,
you have the ability to trash memory. C++ programmers regularly
use complex pointer arithmetic to create and maintain dynamic
data structures. In return, C++ programmers spend a lot of time
hunting down complex bugs caused by their complex pointer arithmetic.
<P>
The Java language does not support pointers. Java provides similar
functionality by making heavy use of references. Java passes all
arrays and objects by reference. This approach prevents common
errors due to pointer mismanagement. It also makes programming
easier in a lot of ways, because the correct usage of pointers
is easily misunderstood by all but the most seasoned programmers.
<P>
You may be thinking that the lack of pointers in Java will keep
you from being able to implement many data structures, such as
dynamically growable arrays. The reality is that any pointer task
can be carried out just as easily and more reliably with objects
and references. You then benefit from the security provided by
the Java runtime system; it performs boundary checking on all
array indexing operations.
<P>
Pointers are no doubt the most difficult aspect of moving C/C++
code to Java, because most C/C++ programs are riddled with pointer
use. The first line of attack in converting pointer code is to
convert all character arrays to Java strings. Once you do this,
you'll probably be surprised at how much pointer-dependent code
was weeded out.
<P>
The next phase of pointer conversion is object creation/destruction.
In C++, the typical way objects are used is to create a pointer
to an object variable and then use the <TT>new</TT>
operator to create a new object and assign it to the variable.
Once you finish with the object, you call <TT>delete</TT>
on the pointer variable to clean up things. This procedure isn't
all that different in Java; it's just missing the final step.
<P>
In Java, objects no longer being used are automatically cleaned
up by the Java garbage collection system, which is typically implemented
as a low-priority system thread. Because the Java system itself
handles cleaning up unused objects, you don't have to worry about
cleaning up after yourself. This may be your one opportunity to
make a mess and not have to clean up after yourself, so take advantage
of it! To better understand the differences between working with
objects and pointers in C++ and Java, let's look at an example.
Listing 28.15 contains a C++ class with a member object pointer.
<HR>
<BLOCKQUOTE>
<B>Listing 28.15. The C++ <TT>Rocket</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Rocket {<BR>
&nbsp;&nbsp;Booster* booster = 0;<BR>
<BR>
&nbsp;&nbsp;Rocket() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;booster
= new Booster();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;~Rocket() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(booster != 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete booster;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;booster
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;}<BR>
};</TT>
</BLOCKQUOTE>
<HR>
<P>
The constructor for <TT>Rocket</TT>
initializes the <TT>booster</TT> member
variable by creating a new object. Then the destructor for <TT>Rocket</TT>
cleans up the <TT>booster</TT> member
by deleting it and setting it to <TT>0</TT>.
This is a painfully simple example, but it helps to learn things
in small doses. Listing 28.16 contains the Java version of this
same class.
<HR>
<BLOCKQUOTE>
<B>Listing 28.16. The Java <TT>Rocket</TT>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>class Rocket {<BR>
&nbsp;&nbsp;Booster booster;<BR>
<BR>
&nbsp;&nbsp;Rocket() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;booster
= new Booster();<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The Java code is much more simpler, even in this case where there
is relatively little happening with the C++ pointers. Notice that
the <TT>booster</TT> member variable
isn't initialized to <TT>0</TT> in
the Java version of <TT>Rocket</TT>.
This highlights a subtle feature in Java; all member variables
are set to <TT>0</TT> or <TT>null</TT>
if they are created without being initialized. Notice also the
absence of a destructor in the Java code; the Java garbage collector
takes care of cleaning up the <TT>booster</TT>
object when it is no longer in use.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Java actually supports a method very similar to a C++ destructor, the <TT>finalize</TT> method. The <TT>finalize</TT> method is called whenever an object is destroyed by the garbage collector. However, due to the nature of the garbage collector itself, 
Java does not guarantee that the <TT>finalize</TT> method will get called for all objects. In other words, don't rely on it getting called in your code!
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
If you're concerned about how Java gets by without using pointers,
keep in mind that the Java system is certainly using pointers
under the hood. The trick is that you are forced to do everything
under the guise of references. This may seem like a pretty big
limitation at first, but once you get in the habit of using references
you'll see that you aren't really missing anything. Knowing this,
another phase of porting C++ code to Java is converting pointers
to references in the C++ code before you even start fooling with
Java. Try converting some C++ code to being entirely reference-based
and then take a stab at moving it to Java. You'll be in for a
much smaller headache if you take this route.
<H2><A NAME="MultipleInheritance"><B><FONT SIZE=5 COLOR=#FF0000>Multiple
Inheritance</FONT></B></A></H2>
<P>
<I>Multiple inheritance</I> is a feature of C++ that enables you
to derive a class from multiple parent classes. Although multiple
inheritance is indeed powerful, it is complicated to use correctly
and causes lots of problems otherwise. It is also very complicated
to implement from the compiler perspective.
<P>
Java takes the high road and provides no direct support for multiple
inheritance. You can implement functionality similar to multiple
inheritance by using interfaces in Java. Java interfaces provide
object method descriptions, but contain no implementations. Let's
take a look at an example of C++ code that uses multiple inheritance:
<BLOCKQUOTE>
<TT>class InputDevice : public Clickable,
public Draggable {<BR>
&nbsp;&nbsp;// class definition<BR>
};</TT>
</BLOCKQUOTE>
<P>
The C++ <TT>InputDevice</TT> class
is derived both from the <TT>Clickable</TT>
and <TT>Draggable</TT> classes. This
means that <TT>InputDevice</TT> inherits
all the data members and methods implemented in both of these
classes. The closest you can get to this in Java is to make <TT>Clickable</TT>
and <TT>Draggable</TT> interfaces,
which can contain method definitions but no actual method code
or data members. The <TT>InputDevice</TT>
class can implement these interfaces using the <TT>implements</TT>
keyword:
<BLOCKQUOTE>
<TT>class InputDevice implements Clickable,
Draggable {<BR>
&nbsp;&nbsp;// class definition<BR>
}</TT>
</BLOCKQUOTE>
<P>
As you can see, you may have your work cut out for you if you
are trying to move C++ code to Java that relies on lots of multiply
inherited classes. Even so, the Java interface approach is not
all that bad; you just have to juggle the actual method bodies
and possibly implement more derived classes to contain them. Nevertheless,
the primary goal of uniting separate logical organizations into
a more derived one will still be attained.
<H2><A NAME="InheritanceSyntax"><B><FONT SIZE=5 COLOR=#FF0000>Inheritance
Syntax</FONT></B></A></H2>
<P>
The multiple inheritance example brings up another important difference
between C++ and Java: inheritance syntax. In C++, you specify
inheritance by using a colon after the newly derived class, followed
by the parent class or classes:
<BLOCKQUOTE>
<TT>class B : public A {<BR>
&nbsp;&nbsp;// class definition<BR>
};</TT>
</BLOCKQUOTE>
<P>
In Java, the <TT>extends</TT> and
<TT>implements</TT> keywords are used
to indicate inheritance:
<BLOCKQUOTE>
<TT>class B extends A {<BR>
&nbsp;&nbsp;// class definition<BR>
}</TT>
</BLOCKQUOTE>
<P>
Fortunately, this change can be made in your C++ code as a simple
search and replace, for the most part. The only hangup will be
changing the syntax for classes using multiple inheritance, in
which case you have to do some real work anyway.
<H2><A NAME="AccessModifiers"><B><FONT SIZE=5 COLOR=#FF0000>Access
Modifiers</FONT></B></A></H2>
<P>
Access modifiers are supported in both C++ and Java, but the methods
of declaring them are different in each. In C++, you declare access
modifiers as a label above a group of class members:
<BLOCKQUOTE>
<TT>class A {<BR>
public:<BR>
</TT>&nbsp;<TT>&nbsp;int x, y;<BR>
private:<BR>
</TT>&nbsp;<TT>&nbsp;float v;<BR>
};</TT>
</BLOCKQUOTE>
<P>
In Java, you can do the same thing, but you apply the access modifiers
a little differently. You set them for each individual declaration:
<BLOCKQUOTE>
<TT>class A {<BR>
&nbsp;&nbsp;public int x, y;<BR>
</TT>&nbsp;<TT>&nbsp;private float
v;<BR>
}</TT>
</BLOCKQUOTE>
<P>
In this way, Java access modifiers aren't labels at all; they
really are modifiers. Converting access modifiers in C++ code
is pretty simple; just go through and remove each label, adding
the appropriate modifier to each variable declaration or method
following the original label.
<H2><A NAME="FriendsandPackages"><B><FONT SIZE=5 COLOR=#FF0000>Friends
and Packages</FONT></B></A></H2>
<P>
Java has no friends! To prove it to you, Java doesn't have any
concept of a friend class, whereas C++ does. A <I>friend</I> class
in C++ is one that has access to all the data and methods in another
class, regardless of the visibility of the member data. Java has
no exact equivalent to the friend concept, but it does have an
access type that enables a specific group of classes access to
member data, which is somewhat similar to the friend idea.
<P>
This Java access type is often referred to as the <I>default</I>
type, because there is no keyword used to apply it. You may also
see it referred to as the <I>friendly</I> access modifier.<TT>
</TT>It has the effect of giving classes in the same package
as the class in question access to the member variable or method
declared with default access. To give a member variable or method
default access, you simply don't use an access modifier, like
this:
<BLOCKQUOTE>
<TT>class A {<BR>
&nbsp;&nbsp;public int k;<BR>
</TT>&nbsp;<TT>&nbsp;private int h;
<BR>
&nbsp;&nbsp;int i, j;<BR>
}</TT>
</BLOCKQUOTE>
<P>
In this example code, <TT>k</TT> and
<TT>h</TT> take on the specific access
modifiers they are declared with, and <TT>i</TT>
and <TT>j</TT> assume default, or
package, access. To convert friendly C++ code to Java, you should
be able to combine friend classes together in the same package
and declare many of their shared members with default access.
<H2><A NAME="Booleans"><B><FONT SIZE=5 COLOR=#FF0000>Booleans</FONT></B></A>
</H2>
<P>
In C++, there is no real boolean type; boolean values (true and
false) are usually implemented as integers, with zero being interpreted
as false and nonzero being interpreted as true. This usage resulted
in somewhat of a half-hearted attempt by C/C++ programmers to
use booleans in their code. Take a look at this example:
<BLOCKQUOTE>
<TT>if (--numLives)<BR>
&nbsp;&nbsp;isDead = 1;</TT>
</BLOCKQUOTE>
<P>
There are a couple of assumptions being made here that don't sit
well from a purist programming perspective. First, <TT>if</TT>
statements should always be based on a boolean value. However,
as this example shows, programmers often exploit the fact that
C/C++ <TT>if</TT> statements (and
other conditional statements) operate on values either being zero
or nonzero, rather than true or false. The <TT>isDead</TT>
variable, which clearly has a boolean meaning, uses <TT>1</TT>
to represent true.
<P>
Unlike C/C++, Java supports boolean values as a type all their
own. As a matter of fact, this example wouldn't work in Java because
Java <TT>if</TT> statements fully
expect boolean types, not integers parading as booleans. The Java
version would look like this:
<BLOCKQUOTE>
<TT>if (--numLives &lt;= 0)<BR>
&nbsp;&nbsp;isDead = true;</TT>
</BLOCKQUOTE>
<P>
The <TT>if</TT> statement has been
changed to result in a boolean outcome. This outcome was implied
in the C++ code, but it is made clearer and more consistent in
the Java version. The <TT>isDead</TT>
variable has been changed to a boolean type. Notice that <TT>true</TT>
and <TT>false</TT> are legitimate
Java keywords (as is <TT>null</TT>).
<P>
Most C/C++ code contains this &quot;integer as boolean&quot; approach
and will therefore have to be fixed in a Java port. However, these
changes are pretty simple and shouldn't take too much time.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter, you learned about the different challenges you
are faced with when porting C and C++ code to Java. Even though
Java is a close cousin to C++, you saw how there are enough differences
to make any conversion process a decent amount of work. On the
other hand, the final benefits of moving your existing code base
to Java can far outweigh the potential difficulties you encounter
while moving it.
<P>
The goal of this chapter isn't to bog you down with hundreds of
detailed examples of complex code conversions, but rather to highlight
the primary problem areas where the bulk of the code conversion
will take place. If you take it a step at a time, you'll find
that moving C/C++ code to Java isn't all that hard. (If it makes
you feel any better, I was able to convert a complex set of sprite
classes from C++ to Java in a couple of days.) Just be patient
and think about how cool your code will be running live on the
Web!
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch27.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch29.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

