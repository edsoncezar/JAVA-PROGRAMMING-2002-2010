<HTML>

<HEAD>
   <TITLE>Chapter 13 -- Animation Techniques</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 13</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Animation Techniques</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#WhatIsAnimation" >What Is Animation?</A>
<LI><A HREF="#TypesofAnimation" >Types of Animation</A>
<LI><A HREF="#ImplementingFrameAnimation" >Implementing Frame Animation</A>
<LI><A HREF="#EliminatingFlicker" >Eliminating Flicker</A>
<LI><A HREF="#ImplementingSpriteAnimation" >Implementing Sprite Animation</A>
<LI><A HREF="#TestingtheSpriteClasses" >Testing the Sprite Classes</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Animation is perhaps one of the most popular uses of the Java
language thus far. Even if few people have realized the full potential
of using Java to solve problems on the Web, most can see the benefits
of using Java to animate Web content. Java is indeed the ideal
technology to bring animation to the Web. In this chapter, you
learn all about animation as it applies to Java, including the
different types of fundamental animation techniques.
<P>
Throughout this chapter, you learn about animation by developing
real applets that demonstrate the animation techniques discussed.
You also learn optimization tips to minimize flicker and get the
best performance out of Java animations. The chapter concludes
with a fully functioning set of sprite classes for creating Java
applets with multiple, interactive animated objects.
<H2><A NAME="WhatIsAnimation"><FONT SIZE=5 COLOR=#FF0000>What
Is Animation?</FONT></A></H2>
<P>
What is animation? To put it simply, animation is the illusion
of movement. When you watch television, you see lots of things
moving around. You are really being tricked into believing that
you are seeing movement. In the case of television, the illusion
of movement is created by displaying a rapid succession of images
with slight changes in the content. The human eye perceives these
changes as movement because of its low visual acuity. The human
eye can be tricked into perceiving movement with as low as 12
frames of movement per second. It should come as no surprise that
frames per second (fps) is the standard unit of measure for animation.
It should also be no surprise that computers use the same animation
technique as television sets to trick us into seeing movement.
<P>
Although 12 fps is enough technically to make animation work,
the animations sometimes look jerky. Most professional animations
therefore use a higher frame rate. Television uses 30 fps, and
motion pictures use about 24 fps. Although the number of frames
per second is a good measure of the animation quality, it isn't
always the bottom line. Professional animators have the ability
to create their animations with a particular frame rate in mind
so that they can alleviate some of the jerkiness at slower speeds.
<P>
When you program animation in Java, you typically have the ability
to manipulate the frame rate a fair amount. The obvious limitation
on frame rate is the speed at which the computer can generate
and display the animation frames. There is usually some give and
take between establishing a frame rate low enough to yield a smooth
animation, while not bogging down the processor and slowing the
system. You learn more about all that later. For now, keep in
mind that when programming animation in Java, you are acting as
a magician creating the illusion of movement for the users of
your applet.
<H2><A NAME="TypesofAnimation"><FONT SIZE=5 COLOR=#FF0000>Types
of Animation</FONT></A></H2>
<P>
Before jumping into writing Java code, you need some background
on the different types of animation. Armed with this knowledge,
you can then pick and choose which approach suits your animation
needs best.
<P>
There are many different types of animation, all useful in different
instances. However, for implementing animation in Java, animation
can be broken down into two basic types: frame-based animation
and cast-based animation.
<H3>Frame-Based Animation</H3>
<P>
<I>Frame-based</I> <I>animation </I>is the simpler of the animation
techniques. It involves simulating movement by displaying a sequence
of static frames. A movie is a perfect example of frame-based
animation; each frame of the film is a frame of animation. When
the frames are shown in rapid succession, they create the illusion
of movement. In frame-based animation, there is no concept of
an object distinguishable from the background; everything is reproduced
on each frame. This is an important point, because it distinguishes
frame-based animation from cast-based animation.
<P>
The number of images used in the Count applets in the last chapter
would make a good frame-based animation. By treating each image
as an animation frame and displaying them all over time, you can
create counting animations. As a matter of fact, you do this exact
thing a little later in this chapter.
<H3>Cast-Based Animation</H3>
<P>
<I>Cast-based</I> <I>animation</I>, which also is called <I>sprite</I>
<I>animation</I>, is a very popular form of animation and has
seen a lot of usage in games. Cast-based animation involves objects
that move independently of the background. At this point, you
may be a little confused by the use of the word &quot;object&quot;
when referring to parts of an image. In this case, an object is
something that logically can be thought of as a separate entity
from the background of an image. For example, in the animation
of a forest, the trees might be part of the background, but a
deer would be a separate object moving independently of the background.
<P>
Each object in a cast-based animation is referred to as a <I>sprite</I>,
and can have a changing position. Almost every video game uses
sprites to some degree. For example, every object in the classic
<I>Asteroids</I> game is a sprite moving independently of the
other objects. Sprites generally are assigned a position and a
velocity, which determine how they move.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Speaking of <I>Asteroids</I>, <A HREF="ch14.htm" >Chapter 14</A>, &quot;Writing 2D Games,&quot; takes you through developing a complete <I>Asteroids</I> game in Java.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Going back to the example involving the number images, if you
want to create an animation with numbers floating around on the
screen, you would be better off using cast-based animation. Remember,
frame-based animation is useful for counting (changing the number
itself). However, cast-based animation is better when the number
has to be able to change position; the number in this case is
acting as a sprite.
<H4>Transparency</H4>
<P>
Because bitmapped images are rectangular by nature, a problem
arises when sprite images aren't rectangular in shape-which is
usually the case. The problem is that the areas of the rectangular
image surrounding the sprite hide the background when the sprite
is displayed. The solution is transparency, which enables you
to specify that a particular color in the sprite is not to be
displayed. This color is known as the transparent color.
<P>
Lucky for you, transparency is already supported in Java by way
of the GIF 89a image format. In the GIF 89a image format, you
specify a color of the GIF image that serves as the transparent
color. When the image is drawn, pixels matching the transparent
color are skipped over and left undrawn, leaving the background
pixels unchanged.
<H4>Z-Order</H4>
<P>
The depth of sprites on the screen is referred to as <I>Z-order</I>.
It is called Z-order because it works like another dimension,
a z axis. You can think of sprites moving around on the screen
in the x,y axis. Similarly, the z axis can be thought of as another
axis projected out of the screen that determines how the sprites
overlap each other; it determines their depth within the screen.
Even though you're now thinking in terms of three axes, Z-order
can't really be considered 3D, because it only specifies how objects
hide each other.
<H4>Collision Detection</H4>
<P>
There is one final topic to cover regarding sprite animation:
collision detection. <I>Collision detection</I> is simply the
method of determining whether sprites have collided with each
other. Although collision detection doesn't directly play a role
in creating the illusion of movement, it is nevertheless tightly
linked to sprite animation.
<P>
Collision detection defines how sprites physically interact with
each other. In an <I>Asteroids</I> game, for example, if the ship
sprite collides with an asteroid sprite, the ship is destroyed.
Similarly, a molecular animation might show atoms bouncing off
each other; the atom sprites bounce in response to a collision
detection. Because a lot of animations have many sprites moving
around, collision detection can get very tricky.
<P>
There are many approaches to handling collision detection. The
simplest approach is to compare the bounding rectangles of each
sprite with the bounding rectangles of all the other sprites.
This method is very efficient, but if you have objects that are
nonrectangular, there will be a certain degree of error when the
objects brush by each other. This is because the corners might
overlap and indicate a collision when really only the transparent
areas are intersecting. The more irregular the shape of the sprites,
the more error there usually is. Figure 13.1 shows how simple
rectangle collision works.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-1.gif" ><B>Figure 13.1 : </B><I>Collision detection using simple rectangle collision.</I></A>
<P>
In Figure 13.1, the areas determining the collision detection
are shaded. You can see how simple rectangle collision detection
isn't all that accurate. An improvement on this technique is to
shrink the collision rectangles a little, which reduces the corner
error. This method improves things a little, but might cause error
in the other direction and enable the sprites to overlap in some
cases without signaling a collision. Figure 13.2 shows how shrinking
the collision rectangles can improve the error on simple rectangle
collision detection. You use this approach later in this chapter
when you develop a sprite class in Java.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-2.gif" ><B>Figure 13.2 : </B><I>Collision detection using shrunken rectangle collision</I></A><I>.</I>
<P>
Another solution is to detect collision based on the sprite image
data and to see whether transparent parts of the image or the
image itself are overlapping. In this case, you get a collision
only if the actual sprite images are overlapping. This is the
ideal technique for detecting collision because it is exact and
enables objects of any shape to move by each other without error.
Figure 13.3 shows collision detection using the sprite image data.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-3.gif" ><B>Figure 13.3 : </B><I>Collision detection using sprite image data.</I></A>
<P>
Unfortunately, this technique requires far more overhead than
rectangle collision detection and sometimes can be a major bottleneck
in performance. Considering the fact that getting decent animation
performance is already a challenge in Java, it's safe to forget
about this approach for the time being.
<H2><A NAME="ImplementingFrameAnimation"><FONT SIZE=5 COLOR=#FF0000>Implementing
Frame Animation</FONT></A></H2>
<P>
The most common animation used in Java applets is simple frame
animation. This type of animation involves displaying a series
of image frames that create the effect of motion and draw attention
to certain parts of a Web page. For this reason, you first learn
how to implement frame animation before moving on to the more
complicated sprite animation. The Counter1 applet shown in Figure
13.4 shows a very basic implementation of frame animation.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-4.gif" ><B>Figure 13.4 : </B><I>The Counter 1 basic frame animation applet.</I></A>
<P>
In Counter1, a series of ten number images are used to animate
a count from zero to ten. The source code for Counter1 is shown
in Listing 13.1.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. The Counter1 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Counter1 Class<BR>
// Counter1.java<BR>
<BR>
// Imports<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
<BR>
public class Counter1 extends Applet implements Runnable {<BR>
&nbsp;&nbsp;Image[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numbers
= new Image[10];<BR>
&nbsp;&nbsp;Thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate;
<BR>
&nbsp;&nbsp;MediaTracker&nbsp;&nbsp;tracker;<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
frame = 0;<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Load and track the images<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker = new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numbers[i] = getImage(getDocumentBase(),
&quot;Res/&quot; + i + &quot;.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(numbers[i],
0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (animate == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate = new Thread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (animate != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (++frame &gt; 9)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.ERRORED)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the error rectangle
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0, 0, size().width,
size().height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.COMPLETE)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the frame image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(numbers[frame],
0, 0, this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the loading message
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font
= new Font(&quot;Helvetica&quot;, Font.PLAIN, 16);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = g.getFontMetrics(font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str
= new String(&quot;Loading images...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(font);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(str, (size().width
- fm.stringWidth(str)) / 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((size().height
- fm.getHeight()) / 2) + fm.getAscent());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Even though Counter1 is a basic animation example, you're probably
thinking it contains a lot of code. The reason is that it takes
a decent amount of code to get even a simple animation up and
running. Just take it a step at a time and you'll see that it's
not so bad.
<P>
The number images used in the animation are stored in the member
variable <TT>numbers</TT>, which is
an array of <TT>Image</TT>. There
are also member variables for an animation thread, a media tracker,
and the current frame of animation. An animation thread is necessary
because animations perform much better within their own thread
of execution. The media tracker, as you learned in the previous
chapter, is used to determine when all the images have been loaded.
<P>
The <TT>init</TT> method loads all
the images and registers them with the media tracker. The <TT>start</TT>
and <TT>stop</TT> methods are standard
thread handler methods. The <TT>run</TT>
method first waits for the images to finish loading by calling
the <TT>waitForID</TT> method of the
<TT>MediaTracker</TT> object. Once
the images have finished loading, an infinite <TT>while</TT>
loop is entered that handles incrementing the animation frame
and forcing the applet to repaint itself. By forcing a repaint,
you are causing the applet to draw the next frame of animation.
<P>
The frames are actually drawn in the <TT>paint</TT>
method, which looks a lot like the <TT>paint</TT>
method from the Count2 applet in the previous chapter. The only
significant difference is the line of code that actually draws
the frame image, which follows:
<BLOCKQUOTE>
<TT>g.drawImage(numbers[frame], 0, 0, this);</TT>
</BLOCKQUOTE>
<P>
Notice that the correct frame is drawn by indexing into the image
array with the current frame. It's as simple as that!
<P>
Although the Counter1 applet may seem much simpler after closer
inspection, it is lacking in many ways. The most obvious problem
with it is that there is no control over the speed of the animation
(frame rate). Animations can hardly be effective if they're zipping
by too fast to keep up with. Another problem with Counter1 is
the obvious flicker when the animation frames are drawn. Although
the flicker may be fairly tolerable with this animation, because
the frame images themselves are fairly small, it would be much
worse with larger images. It's safe to say that this problem should
be solved.
<P>
Actually, both of these problems will be dealt with in a variety
of ways. The next few sections of this chapter deal with improving
this applet by solving these problems incrementally. The end result
is a powerful, high-performance frame animation applet that you
can use in your own Web pages.
<H3>Establishing a Frame Rate</H3>
<P>
Arguably, the biggest problem with Counter1 is the lack of control
over the speed of the animation. The Counter2 applet fixes this
problem quite nicely. I'd love to show you a nice figure displaying
the difference between the two applets, but unfortunately frame
rate is difficult to communicate on a printed page. You'll have
to resort to the CD-ROM and run the applets yourself to see the
difference.
<P>
Even so, by learning the programmatic differences between the
two applets, you should form a good understanding of how Counter2
solves the frame rate problem. The first change made in Counter2
is the addition of an integer member variable, <TT>delay</TT>.
This member variable determines the delay, in milliseconds, between
each successive animation frame. The inverse of this delay value
is the frame rate of the animation. The <TT>delay</TT>
member variable is initialized in Counter2 as follows:
<BLOCKQUOTE>
<TT>int delay = 200; // 5 fps</TT>
</BLOCKQUOTE>
<P>
You can tell by the comment that the inverse of 200 milliseconds
is 5 fps. So, a value of 200 for <TT>delay</TT>
yields a frame rate of 5 frames per second. That's pretty slow
by most animation standards, but you want to be able to count
the numbers as they go by, so it's a good frame rate for this
example.
<P>
The code that actually uses the <TT>delay</TT>
member variable to establish the frame rate is located in the
<TT>run</TT> method. Listing 13.2
contains the source code for the <TT>run</TT>
method in Counter2.
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. The </B><TT><B></TT>run()</FONT></B></TT><B>
method in the Counter2 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public void run() {<BR>
&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Update everything<BR>
&nbsp;&nbsp;long t = System.currentTimeMillis();<BR>
&nbsp;&nbsp;while (Thread.currentThread() == animate) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (++frame &gt; 9)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t += delay;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(Math.max(0, t
- System.currentTimeMillis()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The first interesting line of code in the <TT>run</TT>
method is the call to <TT>currentTimeMillis</TT>.
This method returns the current system time in milliseconds. You
aren't really concerned with what absolute time this method is
returning you, because you are going to use it here only to measure
relative time. First, the frame is incremented and the <TT>repaint</TT>
method called as in Counter1.
<P>
The <TT>delay</TT> value is then added
to the current time. At this point, you have updated the frame
and calculated a time value that is <TT>delay</TT>
milliseconds into the future. The next step is to tell the animation
thread to sleep an amount of time equal to the difference between
the future time value you just calculated and the present time.
The <TT>sleep</TT> method is used
to make a thread sleep for a number of milliseconds, as determined
by the value passed in its only parameter. You may be thinking
you could just pass <TT>delay</TT>
to <TT>sleep</TT> and things would
be fine. This approach technically would work, but it would have
a certain amount of error, because a finite amount of time passes
between updating the frame and putting the thread to sleep. Without
accounting for this time, the actual delay between frames wouldn't
be equal to the value of <TT>delay</TT>.
The solution is to check the time before and after the frame is
updated and reflect the difference in the delay passed to the
<TT>sleep</TT> method.
<P>
With that, the frame rate is under control. You simply change
the value of the <TT>delay</TT> member
variable to alter the frame rate. You should try running the applet
at different frame rates to see the effects. You'll quickly learn
that the frame rate will max out at a certain value, in which
case increasing it won't help anymore. At this point, the applet
is eating all the processor time with the animation thread.
<H2><A NAME="EliminatingFlicker"><FONT SIZE=5 COLOR=#FF0000>Eliminating
Flicker</FONT></A></H2>
<P>
Now that the frame rate issue is behind you, it's time to tackle
the remaining problem plaguing the Counter2 applet: flicker. Unlike
the frame rate problem, there are two different ways to approach
the flicker problem. The first is very simple, but is less effective
and applies only to a limited range of animations. The second
is more complicated, but is very powerful and absolutely essential
in creating quality animations. You're going to learn about both
of these approaches.
<H3>Overriding the <TT><FONT SIZE=4 >update()</TT><FONT SIZE=4>
Method</FONT></FONT></H3>
<P>
The simplest solution to eliminating the flicker problem in animations
is to override the <TT>update</TT>
method in your applet. To see how an overridden version of <TT>update</TT>
might help, take a look at the source code for the standard <TT>update</TT>
method, as contained in the Java 1.0 release:
<BLOCKQUOTE>
<TT>public void update(Graphics g) {<BR>
&nbsp;&nbsp;g.setColor(getBackground());<BR>
&nbsp;&nbsp;g.fillRect(0, 0, width, height);<BR>
&nbsp;&nbsp;g.setColor(getForeground());<BR>
&nbsp;&nbsp;paint(g);<BR>
}</TT>
</BLOCKQUOTE>
<P>
Notice that <TT>update</TT> performs
an update of the graphics context by first erasing it and then
calling the <TT>paint</TT> method.
It's the erasing part that causes the flicker. With every frame
of animation, there is an erase followed by a paint. When this
process occurs repeatedly and rapidly, as in animations, the erase
results in a visible flicker. If you could just paint without
erasing, the flicker would be eliminated. That's exactly what
you need to do.
<P>
The Counter3 applet is functionally equivalent to the Counter2
applet except for the addition of an overridden <TT>update</TT>
method. The <TT>update</TT> method
in Counter3 looks like this:
<BLOCKQUOTE>
<TT>public void update(Graphics g) {<BR>
&nbsp;&nbsp;paint(g);<BR>
}</TT>
</BLOCKQUOTE>
<P>
This <TT>update</TT> method is a pared-down
version of the original method that only calls <TT>paint</TT>.
By eliminating the erase part of the update, you put an end to
the flicker problem. In this case, however, there is a side effect.
Check out Counter3 in action in Figure 13.5 to see what I mean.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-5.gif" ><B>Figure 13.5 : </B><I>The Counter3 frame animation applet.</I></A>
<P>
It's pretty obvious that the background is not being erased because
you can see the remains of the <TT>Loading
images...</TT> message behind the animation. This brings
up the primary limitation of this solution to the flicker problem:
it only works when your animation takes up the entire applet window.
Otherwise, the parts of the applet window outside the animation
never get erased.
<P>
Another limitation not readily apparent in this example is that
this solution applies only to animations that use images. What
about animations that are based on AWT graphics primitives, such
as lines and polygons? In this case, you <I>want</I> the background
to be erased between each frame so that the old lines and polygons
aren't left around. What then?
<H3>Double Buffering</H3>
<P>
Double buffering is the cure-all for many problems associated
with animation. By using double buffering, you eliminate flicker
and allow speedy animations involving both images and AWT graphics
primitives. <I>Double buffering</I> is the process of maintaining
an extra, offscreen buffer image onto which you draw the next
frame of animation. Rather than drawing directly to the applet
window, you draw to the intermediate, offscreen buffer. When it's
time to update the animation frame, you simply draw the entire
offscreen buffer image to the applet window and then start the
process over by drawing the next frame to the buffer. Figure 13.6
contains a diagram showing how double buffering works.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-6.gif" ><B>Figure 13.6 : </B><I>The basics of double buffered animation.</I></A>
<P>
The Counter4 applet is an improved Counter3 with full double buffering
support. Although double buffering is certainly more complex than
overriding the <TT>update</TT> method
with a single call to <TT>paint</TT>,
it's still not too bad. As a matter of fact, the majority of the
changes in Counter4 are in the <TT>update</TT>
method, which is shown in Listing 13.3. Before you look at that,
check out the two member variables that have been added to the
Counter4 applet:
<BLOCKQUOTE>
<TT>Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offImage;
<BR>
Graphics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offGrfx;</TT>
</BLOCKQUOTE>
<P>
The <TT>offImage</TT> member variable
contains the offscreen buffer image used for drawing intermediate
animation frames. The <TT>offGrfx</TT>
member variable contains the graphics context associated with
the offscreen buffer image.
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. The </B><TT><B></TT>update()</FONT></B></TT><B>
method in the Counter4 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public void update(Graphics g) {<BR>
&nbsp;&nbsp;// Create the offscreen graphics context<BR>
&nbsp;&nbsp;Dimension dim = size();<BR>
&nbsp;&nbsp;if (offGrfx == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offImage = createImage(dim.width, dim.height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offGrfx = offImage.getGraphics();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Erase the previous image<BR>
&nbsp;&nbsp;offGrfx.setColor(getBackground());<BR>
&nbsp;&nbsp;offGrfx.fillRect(0, 0, dim.width, dim.height);<BR>
&nbsp;&nbsp;offGrfx.setColor(Color.black);<BR>
<BR>
&nbsp;&nbsp;// Draw the frame image<BR>
&nbsp;&nbsp;offGrfx.drawImage(numbers[frame], 0, 0, this);<BR>
<BR>
&nbsp;&nbsp;// Draw the image onto the screen<BR>
&nbsp;&nbsp;g.drawImage(offImage, 0, 0, null);<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>update</TT> method in Counter4
handles almost all the details of supporting double buffering.
First, the size of the applet window is determined with a call
to the <TT>size</TT> method. The offscreen
buffer is then created as an <TT>Image</TT>
object whose dimensions match those of the applet window. It is
important to make the offscreen buffer the exact size of the applet
window. The graphics context associated with the buffer is then
retrieved using the <TT>getGraphics</TT>
method of <TT>Image</TT>.
<P>
Because you are now working on an offscreen image, it's safe to
erase it without worrying about flicker. As a matter of fact,
erasing the offscreen buffer is an important step in the double-buffered
approach. After erasing the buffer, the animation frame is drawn
to the buffer, just as it was drawn to the applet window's graphics
context in the <TT>paint</TT> method
in Counter3. The offscreen buffer is now ready to be drawn to
the applet window. This is simply a matter of calling <TT>drawImage</TT>
and passing the offscreen buffer image.
<P>
Notice that the <TT>paint</TT> method
isn't even called from <TT>update</TT>.
This a further optimization to eliminate the overhead of calling
<TT>paint</TT> and going through the
checks to see whether the images have loaded successfully. At
the point that <TT>update</TT> gets
called, you already know the images have finished loading. However,
this doesn't mean you can ignore <TT>paint</TT>;
you must still implement <TT>paint</TT>
because it gets called at other points in the AWT framework. Counter4's
version of <TT>paint</TT> is very
similar to Counter3's <TT>paint</TT>,
with the only difference being the line that draws the offscreen
buffer:
<BLOCKQUOTE>
<TT>g.drawImage(offImage, 0, 0, null);</TT>
</BLOCKQUOTE>
<P>
This is the same line of code found at the end of <TT>update</TT>,
which shouldn't be too surprising to you by now.
<H3>Working with Tiled Image Frames</H3>
<P>
The last modification you're going to learn about in regard to
the Counter applets is that of using a single tiled image rather
than individual images for the animation frames.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A tiled image is an image containing multiple sub-images called tiles. A good way to visualize a tiled image is to think of a reel of film for a movie; the film can be thought of as a big tiled image with lots of image tiles. The movie is animated by 
displaying the image tiles in rapid succession.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
In all the Counter applets until now, the animation frames have
come from individual images. Counter5 is a modified Counter4 that
gets its frame images from a single image containing tiled subimages.
The image Numbers.gif is used in Counter5 (see Figure 13.7).
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-7.gif" ><B>Figure 13.7 : </B><I>The Numbers.gif tiled animation image used in Counter5.</I></A>
<P>
As you can see, the individual number images are tiled horizontally
from left to right in Numbers.gif. To see how Counter5 manages
to draw each frame using this image, check out Listing 13.4, which
contains the <TT>update</TT> method.
<HR>
<BLOCKQUOTE>
<B>Listing 13.4. The </B><TT><B></TT>update()</FONT></B></TT><B>
method in the Counter5 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public void update(Graphics g) {<BR>
&nbsp;&nbsp;// Create the offscreen graphics context<BR>
&nbsp;&nbsp;Dimension dim = size();<BR>
&nbsp;&nbsp;if (offGrfx == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offImage = createImage(dim.width, dim.height);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offGrfx = offImage.getGraphics();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;// Erase the previous image<BR>
&nbsp;&nbsp;offGrfx.setColor(getBackground());<BR>
&nbsp;&nbsp;offGrfx.fillRect(0, 0, dim.width, dim.height);<BR>
&nbsp;&nbsp;offGrfx.setColor(Color.black);<BR>
<BR>
&nbsp;&nbsp;// Draw the frame image<BR>
&nbsp;&nbsp;int w = numbers.getWidth(this) / 10,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = numbers.getHeight(this);
<BR>
&nbsp;&nbsp;offGrfx.clipRect(0, 0, w, h);<BR>
&nbsp;&nbsp;offGrfx.drawImage(numbers, -(frame * w), 0, this);
<BR>
<BR>
&nbsp;&nbsp;// Draw the image onto the screen<BR>
&nbsp;&nbsp;g.drawImage(offImage, 0, 0, null);<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The only part of <TT>update</TT> that
is changed is the part where the frame image is drawn to the offscreen
buffer. The width and height of the frame to be drawn are first
obtained. Notice that the width of a single frame is calculated
by getting the width of the entire image and dividing it by the
number of tiles (in this case <TT>10</TT>).
Then, the offscreen graphics context is clipped around the rectangle
where the frame is to be drawn. This clipping is crucial, because
it limits all drawing to the specified rectangle, which is the
rectangle for the single frame of animation. The entire image
is then drawn to the offscreen buffer at a location specifically
calculated so that the correct frame will appear in the clipped
region of the offscreen buffer. To better understand what is going
on, take a look at Figure 13.8.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-8.gif" ><B>Figure 13.8 : </B><I>Using a clipping region to draw a single frame of a tiled image.</I></A>
<P>
The best way to understand what is happening is to imagine the
offscreen buffer as a piece of paper. The clipping rectangle is
a rectangular section of the paper that has been removed. So,
you have a piece of paper with a rectangular section that you
can see through. Now, imagine the tiled image as another piece
of paper that you are going to hold up behind the first piece.
By lining up a tiled frame on the image piece of paper with the
cutout on the first piece, you are able to view that frame by
itself. Pretty tricky!
<P>
It is faster to transmit a single tiled image than it is to transmit
a series of individual images. Because any potential gain in transmission
speed has to be made whenever possible, the tiled image approach
is often valuable. The only problem with it is that it won't work
for sprite animation, which you learn about next.
<P>
At this point, you have a very powerful and easy-to-use animation
applet, Counter5, to use as a template for your own animation
applets. Counter5 contains everything you need to include high-performance,
frame-based animations in your Web pages. If, however, your needs
go beyond frame-based animation, read on to learn all about implementing
sprite animation.
<H2><A NAME="ImplementingSpriteAnimation"><FONT SIZE=5 COLOR=#FF0000>Implementing
Sprite Animation</FONT></A></H2>
<P>
As you learned earlier in this chapter, sprite animation involves
the movement of individual graphic objects called sprites. Unlike
simple frame animation, sprite animation involves considerably
more overhead. More specifically, it is necessary not only to
develop a sprite class, but also a sprite management class for
keeping up with all the sprites. This is necessary because sprites
need to be able to interact with each other through a common interface.
<P>
In this section, you learn how to implement sprite animation in
Java by creating two sprite classes: <TT>Sprite</TT>
and <TT>SpriteVector</TT>. The <TT>Sprite</TT>
class models a single sprite and contains all the information
and methods necessary to get a single sprite up and running. However,
the real power of sprite animation is harnessed by combining the
<TT>Sprite</TT> class with the <TT>SpriteVector</TT>
class, which is a container class that keeps up with multiple
sprites.
<H3>The <TT><FONT SIZE=4 >Sprite</TT><FONT SIZE=4>
Class</FONT></FONT></H3>
<P>
Although sprites can be implemented simply as movable images,
a more powerful sprite includes support for frame animation. A
frame-animated sprite is basically a sprite with multiple frame
images. The <TT>Sprite</TT> class
you develop here supports frame animation, which comes in the
form of an array of images that can be displayed in succession.
Using this approach, you end up with a <TT>Sprite</TT>
class that supports both fundamental types of animation.
<P>
Enough general talk about the <TT>Sprite</TT>
class-you're probably ready to get into the details of how to
implement it. However, before jumping into the Java code, take
a moment to think about what information a <TT>Sprite</TT>
class needs. The following list contains the key information the
<TT>Sprite</TT> class needs to include:
<UL>
<LI>Array of frame images
<LI>Current frame
<LI>x,y position
<LI>Z-order
<LI><FONT COLOR=#000000>Velocity</FONT>
</UL>
<P>
The array of frame images is necessary to carry out the frame
animations. Even though the support is there for multiple animation
frames, a sprite requires only a single image. The current frame
keeps up with the current frame of animation. In a typical frame-animated
sprite, the current frame gets incremented to the next frame when
the sprite is updated. The x,y position stores the position of
the sprite in the applet window. The Z-order represents the depth
of the sprite in relation to other sprites. Ultimately, the Z-order
of a sprite determines its drawing order (more on that a little
later). Finally, the velocity of a sprite represents the speed
and direction of the sprite.
<P>
Now that you understand the basic information required by the
<TT>Sprite</TT> class, it's time to
get into the specific Java implementation. Take a look at Listing
13.5, which contains the source code for the <TT>Sprite</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 13.5. The </B><TT><B></TT>Sprite</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Sprite Class<BR>
// Sprite.java<BR>
<BR>
// Imports<BR>
import java.awt.*;<BR>
import java.awt.image.*;<BR>
<BR>
public class Sprite {<BR>
&nbsp;&nbsp;Component component;<BR>
&nbsp;&nbsp;Image[]&nbsp;&nbsp;&nbsp;image;<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frameInc,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frameDelay,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frameTrigger;
<BR>
&nbsp;&nbsp;Rectangle position,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collision;
<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zOrder;<BR>
&nbsp;&nbsp;Point&nbsp;&nbsp;&nbsp;&nbsp; velocity;<BR>
<BR>
&nbsp;&nbsp;Sprite(Component comp, Image img, Point pos, Point
vel, int z) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;component = comp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;image = new Image[1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;image[0] = img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frame = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frameInc = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frameDelay = frameTrigger = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;velocity = vel;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;zOrder = z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setPosition(pos);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Sprite(Component comp, Image[] img, int f, int fi,
int fd,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Point pos, Point vel, int z) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;component = comp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;image = img;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frame = f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frameInc = fi;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frameDelay = frameTrigger = fd;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;velocity = vel;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;zOrder = z;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setPosition(pos);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Image[] getImage() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return image;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;int getFrameInc() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return frameInc;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setFrameInc(int fi) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;frameInc = fi;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;int getFrame() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return frame;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void incFrame() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((frameDelay &gt; 0) &amp;&amp; (--frameTrigger
&lt;= 0))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Reset the frame trigger
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frameTrigger = frameDelay;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Increment the frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame += frameInc;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (frame &gt;= image.length)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (frame &lt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame = image.length
- 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Rectangle getPositionRect() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return position;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setPosition(Rectangle pos) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;position = pos;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcCollisionRect();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setPosition(Point pos) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;position = new Rectangle(pos.x, pos.y,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image[0].getWidth(component),
image[0].getHeight(component));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcCollisionRect();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Rectangle getCollisionRect() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return collision;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;int getZOrder() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return zOrder;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Point getVelocity() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return velocity;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setVelocity(Point vel)<BR>
&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;velocity = vel;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void update() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Update the position and collision rects
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int w = component.size().width,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h = component.size().height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;position.translate(velocity.x, velocity.y);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((position.x + position.width) &lt;
0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x = w;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else if (position.x &gt; w)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x = -position.width;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((position.y + position.height) &lt;
0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.y = h;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else if (position.y &gt; h)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.y = -position.height;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;calcCollisionRect();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Increment the frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;incFrame();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void draw(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw the current frame<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(image[frame], position.x,
position.y, component);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;protected boolean testCollision(Sprite test) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Check for collision with another sprite
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (this != test)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (collision.intersects(test.getCollisionRect()))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;protected void calcCollisionRect() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Calculate the collision rect<BR>
&nbsp;&nbsp;&nbsp;&nbsp;collision = new Rectangle(position.x +
4, position.y + 4,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.width - 8, position.height
- 8);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
It looks like a lot of code for a simple <TT>Sprite</TT>
class, but take it a method at a time and it's not too bad. First,
notice from the member variables that the appropriate sprite information
is maintained by the <TT>Sprite</TT>
class. You may also notice a few member variables that aren't
related to the core sprite information discussed earlier. The
<TT>Component</TT> member variable
is necessary because an <TT>ImageObserver</TT>
object is necessary to retrieve information about an image. What
does <TT>Component</TT> have to do
with <TT>ImageObserver</TT>? The <TT>Component</TT>
class implements the <TT>ImageObserver</TT>
interface. Furthermore, the <TT>Applet</TT>
class is derived from <TT>Component</TT>.
A <TT>Sprite</TT> object gets its
image information from the Java applet itself, which is used to
initialize the <TT>component</TT>
member variable.
<P>
The <TT>frameInc</TT> member variable
is used to provide a means to change the way the animation frames
are updated. For example, there may be instances where you want
the frames to be displayed in the reverse order. You can easily
do this by setting <TT>frameInc</TT>
to <TT>-1</TT> (its typical value
is <TT>1</TT>). The <TT>frameDelay</TT>
and <TT>frameTrigger</TT> member variables
are used to provide a means of varying the speed of the frame
animation. You see how the speed of animation is controlled in
a moment when you learn about the <TT>incFrame</TT>
method.
<P>
The last member variable in question is <TT>collision</TT>,
which is a <TT>Rectangle</TT> object.
This member variable is used to support shrunken rectangle collision
detection, where a smaller rectangle is used in collision detection
tests. You see how <TT>collision</TT>
is used a little later when you learn about the <TT>testCollision</TT>
and <TT>calcCollisionRect</TT> methods.
<P>
The <TT>Sprite</TT> class has two
constructors. The first constructor creates a <TT>Sprite</TT>
without frame animations, meaning that it uses a single image
to represent the sprite. This constructor takes an image, position,
velocity, and Z-order as parameters. The second constructor takes
an array of images and some additional information about the frame
animations. The additional information includes the current frame,
frame increment, and frame delay.
<P>
<TT>Sprite</TT> contains a few access
methods, which are simply interfaces to get and set certain member
variables. These methods consist of one or two lines of code and
are pretty self-explanatory. Let's move on to the juicier methods!
<P>
The <TT>incFrame</TT> method is the
first method with any real substance. <TT>incFrame</TT>
is used to increment the current animation frame. It first checks
the <TT>frameDelay</TT> and <TT>frameTrigger</TT>
member variables to see whether the frame should indeed be incremented.
This check is what enables you to vary the speed of animation,
which is done by changing the value of <TT>frameDelay</TT>.
Larger values for <TT>frameDelay</TT>
result in a slower animation. The current frame is incremented
by adding <TT>frameInc</TT> to <TT>frame</TT>.
<TT>frame</TT> is then checked to
make sure its value is within the bounds of the image array.
<P>
The <TT>setPosition</TT> methods set
the position of the sprite. Even though the sprite position is
stored as a rectangle, the <TT>setPosition</TT>
methods enable you to specify the sprite position as either a
rectangle or a point. In the latter version, the rectangle is
calculated based on the dimensions of the sprite image. After
the sprite position rectangle is calculated, the collision rectangle
is set with a call to <TT>calcCollisionRect</TT>.
<P>
The method that does most of the work in <TT>Sprite</TT>
is the <TT>update</TT> method. <TT>update</TT>
handles the task of updating the position and animation frame
of the sprite. The position of the sprite is updated by translating
the position rectangle based on the velocity. You can think of
the position rectangle as being slid a distance determined by
the velocity. The position of the sprite is then checked against
the dimensions of the applet window to see whether it needs to
be wrapped around to the other side. Finally, the frame is updated
with a call to <TT>incFrame</TT>.
<P>
The <TT>draw</TT> method simply draws
the current frame to the <TT>Graphics</TT>
object that is passed in. Notice that the <TT>drawImage</TT>
method requires the image, x,y position, and component (<TT>ImageObserver</TT>)
to carry this out.
<P>
The <TT>testCollision</TT> method
is used to check for collisions between sprites. The sprite to
test is passed in the <TT>test</TT>
parameter. The test simply involves checking to see whether the
collision rectangles intersect. If so, <TT>testCollision</TT>
returns <TT>true</TT>. <TT>testCollision</TT>
isn't all that useful within the context of a single sprite, but
it will come in very handy when you put together the <TT>SpriteVector</TT>
class a little later in this chapter.
<P>
The last method of interest in <TT>Sprite</TT>
is <TT>calcCollisionRect</TT>, which
calculates the collision rectangle from the position rectangle.
In this case, the collision rectangle is simply calculated as
a smaller version of the position rectangle. However, you could
tailor this rectangle to match the images of specific sprites
more closely. In this case, you would derive a new sprite class
and then override the <TT>calcCollisionRect</TT>
method. A further enhancement could even include an array of collision
rectangles that correspond to each animation frame. With this
enhancement, you could tighten up the error inherent in rectangle
collision detection.
<H3>The <TT><FONT SIZE=4 >SpriteVector</TT><FONT SIZE=4>
Class</FONT></FONT></H3>
<P>
Now you have a <TT>Sprite</TT> class
with some pretty neat features, but you are still missing a key
ingredient-the capability of managing multiple sprites and allowing
them to interact with each other. The <TT>SpriteVector</TT>
class, shown in Listing 13.6, is exactly what you need.
<HR>
<BLOCKQUOTE>
<B>Listing 13.6. The </B><TT><B></TT>SpriteVector</FONT></B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// SpriteVector Class<BR>
// SpriteVector.java<BR>
<BR>
// Imports<BR>
import java.awt.*;<BR>
import java.util.*;<BR>
<BR>
public class SpriteVector extends Vector {<BR>
&nbsp;&nbsp;Component component;<BR>
&nbsp;&nbsp;Image&nbsp;&nbsp;&nbsp;&nbsp; background;<BR>
<BR>
&nbsp;&nbsp;SpriteVector() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;super(50, 10);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;SpriteVector(Component comp, Image bg) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;super(50, 10);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;component = comp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;background = bg;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Image getBackground() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return background;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void setBackground(Image back) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;background = back;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void update() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Sprite&nbsp;&nbsp;&nbsp;&nbsp;s, hit;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Rectangle old;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size = size();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Iterate through sprites, updating each
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; size; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = (Sprite)elementAt(i);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old = s.getPositionRect();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.update();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hit = testCollision(s);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hit != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.setPosition(old);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collision(s, hit);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;void draw(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (background != null)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw background image<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(background, 0,
0, component);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Erase background<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension dim = component.size();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(component.getBackground());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0, 0, dim.width,
dim.height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.black);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Iterate through sprites, drawing each
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int size = size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; size; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Sprite)elementAt(i)).draw(g);
<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;int add(Sprite s) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Use a binary search to find the right
location to insert the<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// new sprite (based on z-order)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;l = 0, r = size(),
x = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;z = s.getZOrder(),
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zTest
= z + 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (r &gt; l) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = (l + r) / 2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zTest = ((Sprite)elementAt(x)).getZOrder();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (z &lt; zTest)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l = x + 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (z == zTest)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (z &gt;= zTest)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;insertElementAt(s, x);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return x;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;Sprite testCollision(Sprite test) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Check for collision with other sprites
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp; size = size();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Sprite&nbsp;&nbsp;s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; size; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = (Sprite)elementAt(i);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s == test)&nbsp;&nbsp;//
don't check itself<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (test.testCollision(s))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return null;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;protected void collision(Sprite s, Sprite hit) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Swap velocities (bounce)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Point swap = s.getVelocity();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;s.setVelocity(hit.getVelocity());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hit.setVelocity(swap);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
<TT>SpriteVector</TT> has only two
member variables, which consist of a background <TT>Image</TT>
object and a <TT>Component</TT> object
for working with the image. There are two constructors for <TT>SpriteVector</TT>:
one with no background and one that supports a background image.
The background image serves as a backdrop behind the sprites and
can be used to jazz up the animation with little effort.
<P>
The <TT>SpriteVector</TT> class is
derived from <TT>Vector</TT>, which
is a container class (similar to an array) that can grow. You
may have noticed that both constructors call the <TT>Vector</TT>
superclass constructor and set the default storage capacity and
amount to increment the storage capacity should the <TT>Vector</TT>
need to grow.
<P>
As in <TT>Sprite</TT>, <TT>update</TT>
is the key method in <TT>SpriteVector</TT>
because it handles updating all the sprites. This <TT>update</TT>
method iterates through the sprites, calling <TT>update</TT>
on each one. It then calls <TT>testCollision</TT>
to see whether a collision has occurred between sprites. If a
collision has occurred, the old position of the collided sprite
is restored and the <TT>collision</TT>
method called.
<P>
The <TT>draw</TT> method handles drawing
all the sprites, as well as drawing the background if one exists.
The <TT>background</TT> member variable
is first checked to see whether the background image should be
drawn. If not, the background color of the applet window is used
to erase the graphics context. The sprites are then drawn by iterating
through the list and calling the <TT>draw</TT>
method for each.
<P>
The <TT>add</TT> method is probably
the trickiest method in the <TT>SpriteVector</TT>
class. The <TT>add</TT> method handles
adding new sprites to the sprite list. The catch is that the sprite
list must always be sorted according to Z-order. Why? Remember
that Z-order is the depth at which sprites appear on the screen.
The illusion of depth is established by the order in which the
sprites are drawn. This works because sprites drawn later are
drawn on top of other sprites, and therefore they appear to be
at a higher depth. Sorting the sprite list by Z-order and then
drawing them in that order is an effective way to provide the
illusion of depth. The <TT>add</TT>
method uses a binary search to find the right spot to add new
sprites so that the sprite list remains sorted by Z-order.
<P>
The <TT>testCollision</TT> method
is used to test for collisions between a sprite and the rest of
the sprites in the sprite list. The sprite to be tested is passed
in the <TT>test</TT> parameter. The
sprites are then iterated through and the <TT>testCollision</TT>
method called for each. If a collision is detected, the <TT>Sprite</TT>
object that has been hit is returned from <TT>testCollision</TT>.
<P>
Finally, the <TT>collision</TT> method
is used to handle collisions between two sprites. The action here
is to simply swap the velocities of the collided <TT>Sprite</TT>
objects, which results in a bouncing effect. This method is where
you could provide specific collision actions. For example, in
a game you might want some sprites to explode upon collision.
<P>
That wraps up the <TT>SpriteVector</TT>
class. You now not only have a powerful <TT>Sprite</TT>
class, but also a <TT>SpriteVector</TT>
class for managing and providing interactivity between sprites.
All that's left is putting these classes to work in a real applet.
<H2><A NAME="TestingtheSpriteClasses"><FONT SIZE=5 COLOR=#FF0000>Testing
the Sprite Classes</FONT></A></H2>
<P>
You didn't come this far with the sprite stuff not to see some
action. Figure 13.9 shows a screen shot of the SpriteTest applet,
which shows off the sprite classes you've toiled so hard over.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f13-9.gif" ><B>Figure 13.9 : </B><I>The SpriteTest sample applet.</I></A>
<P>
The SpriteTest applet uses a <TT>SpriteVector</TT>
object to manage five <TT>Sprite</TT>
objects, two of which use frame animation. Listing 13.7 contains
the source code for the SpriteTest applet.
<HR>
<BLOCKQUOTE>
<B>Listing 13.7. The SpriteTest sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// SpriteTest Class<BR>
// SpriteTest.java<BR>
<BR>
// Imports<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
<BR>
public class SpriteTest extends Applet implements Runnable {<BR>
&nbsp;&nbsp;Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offImage,
back, ball;<BR>
&nbsp;&nbsp;Image[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numbers
= new Image[10];<BR>
&nbsp;&nbsp;Graphics&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offGrfx;
<BR>
&nbsp;&nbsp;Thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate;
<BR>
&nbsp;&nbsp;MediaTracker&nbsp;&nbsp;tracker;<BR>
&nbsp;&nbsp;SpriteVector&nbsp;&nbsp;sv;<BR>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
delay = 83; // 12 fps<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Load and track the images<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker = new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;back = getImage(getDocumentBase(), &quot;Res/Back.gif&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(back, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ball = getImage(getDocumentBase(), &quot;Res/Ball.gif&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(ball, 0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numbers[i] = getImage(getDocumentBase(),
&quot;Res/&quot; + i + &quot;.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(numbers[i],
0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (animate == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate = new Thread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (animate != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animate = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create and add the sprites<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv = new SpriteVector(this, back);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.add(new Sprite(this, numbers, 0, 1,
5, new Point(0, 0),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(1, 3), 1));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.add(new Sprite(this, numbers, 0, 1,
20, new Point(0, 100),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(-1, 5), 2));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.add(new Sprite(this, ball, new Point(100,
100),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(-3, 2), 3));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.add(new Sprite(this, ball, new Point(50,
50),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(1, -2), 4));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.add(new Sprite(this, ball, new Point(100,
0),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(4, -3), 5));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Update everything<BR>
&nbsp;&nbsp;&nbsp;&nbsp;long t = System.currentTimeMillis();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (Thread.currentThread() == animate)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sv.update();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t += delay;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(Math.max(0,
t - System.currentTimeMillis()));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Create the offscreen graphics context
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Dimension dim = size();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (offGrfx == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offImage = createImage(dim.width,
dim.height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offGrfx = offImage.getGraphics();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw the sprites<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sv.draw(offGrfx);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Draw the image onto the screen<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(offImage, 0, 0, null);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.ERRORED)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the error rectangle
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0, 0, size().width,
size().height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.COMPLETE)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the offscreen image
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(offImage, 0, 0,
null);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the loading message
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font
= new Font(&quot;Helvetica&quot;, Font.PLAIN, 18);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = g.getFontMetrics(font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str
= new String(&quot;Loading images...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(font);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(str, (size().width
- fm.stringWidth(str)) / 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((size().height
- fm.getHeight()) / 2) + fm.getAscent());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
You may notice a lot of similarities between SpriteTest and the
Counter5 sample applet developed earlier in this chapter. SpriteTest
is very similar to Counter5 because a lot of the same animation
support code is required by the sprite classes. Let's look at
the aspects of SpriteTest that facilitate the usage of the <TT>Sprite</TT>
and <TT>SpriteVector</TT> classes;
you've already covered the rest.
<P>
The first thing to notice is the <TT>SpriteVector</TT>
member variable <TT>sv</TT>. There
are also some extra member variables for a background image and
a ball sprite image. The only other change with member variables
is the value of the <TT>delay</TT>
member variable. It is set to <TT>83</TT>,
which results in a frame rate of 12 fps. This faster frame rate
is required for more fluid animation, such as sprite animation.
<P>
The <TT>SpriteVector</TT> is created
in the <TT>run</TT> method using the
constructor that supports a background image. Five different <TT>Sprite</TT>
objects are then created and added to the sprite vector. The first
two sprites use the number images as their animation frames. Notice
that these two sprites are created with different frame delay
values. You can see the difference when you run the applet because
one of the sprites &quot;counts&quot; faster than the other. The
<TT>run</TT> method also updates the
sprite vector by calling the <TT>update</TT>
method.
<P>
The <TT>update</TT> method for SpriteTest
looks almost like the one in Counter5. The only difference is
the call to the <TT>SpriteVector</TT>'s
<TT>draw</TT> method, which draws
the background and all the sprites.
<P>
Using the sprite classes is as easy as that! You've now seen for
yourself how the sprite classes encapsulate all the functionality
required to manage both cast- and frame-based animation, as well
as providing support for interactivity among sprites via collision
detection.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Although it covered a lot of material, this chapter added a significant
array of tools and techniques to your bag of Java tricks. You
learned all about animation, including the two major types of
animation: frame-based and cast-based. Following up this theory,
you saw a frame-based animation applet evolve from a simple example
to a powerful and reusable animation template.
<P>
Although the frame-based animation example applets are interesting
and useful, you learned that sprite animation is where the fun
really begins. You saw firsthand how to develop a powerful duo
of sprite classes for implementing sprite animation. You then
put them to work in a sample applet that involved very little
additional overhead.
<P>
More than anything, you learned in this chapter that Java animation
is both powerful and easy to implement. Using what you learned
here, you should be able to add many cool animations to your own
Web creations.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch12.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch14.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

