
<HTML>

<HEAD>
   <TITLE>Chapter 2 -- Using the Media Tracker</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 2</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using the Media Tracker</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#JavaMediaObjectsandtheInternet" >Java Media Objects and the Internet</A>
<LI><A HREF="#KeepingUpwithMediaObjects" >Keeping Up with Media Objects</A>
<LI><A HREF="#TheMediaTrackerClass" >The MediaTracker Class</A>
<LI><A HREF="#TrackingImageswiththeMediaTracker" >Tracking Images with the Media Tracker</A>
<LI><A HREF="#TrackingOtherTypesofMedia" >Tracking Other Types of Media</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
It's hard to talk about Java without the subject of multimedia
popping up. Indeed, Java is the ideal technology to bring multimedia
content to the Web. Knowing this, the Java architects have had
to deal with a common problem associated with distributed media,
transmission delay. Transmission delay refers to the amount of
time it takes to transfer a media object across a network connection,
and therefore how much time a Java applet must wait for images,
sounds, and other media objects to be transferred.
<P>
The Java media tracker is a Java object that helps deal with the
transmission delay problem by keeping up with when media objects
have been successfully transmitted. Although the media tracker
doesn't alleviate the delay in transmitting media objects, it
does provide information regarding when objects have been transferred.
In this chapter, you learn all about the Java media tracker, including
how the media tracker is used to track media objects. You then
get to see the benefits of the media tracker by implementing an
applet both with and without media tracker support.
<H2><A NAME="JavaMediaObjectsandtheInternet"><FONT SIZE=5 COLOR=#FF0000>Java
Media Objects and the Internet</FONT></A></H2>
<P>
One of the most important features of Java is its support for
images and sound. No matter how many multimedia features Java
provides, however, the problem of transmitting multimedia content
over a limited bandwidth still exists. This means that the speed
at which multimedia content is transferred over a Web connection
often causes a noticeable delay in a Java applet reliant on media
objects.
<P>
Of course, there isn't much that can be done in software to alleviate
the physical transmission speed limitations of a network connection.
However, there is a standard technique for dealing with transmission
delay as it affects static images. You've no doubt seen this technique
at work in your Web browser when viewing images in Web pages.
The technique is known as <I>interlacing</I> and results in images
appearing blurry until they have been completely transferred.
To make use of interlacing, images must be stored in an interlaced
format (usually GIF version 89a), which means that the image data
is arranged in such a way that the image can be displayed before
it is completely transmitted. Interlacing is a good approach to
dealing with transmission delays for static images, because it
enables you to see the image as it is being transferred. Without
interlacing, you have to wait until the entire image has been
transferred before seeing it at all.
<P>
Before you get too excited about interlacing, keep in mind that
it's only useful for static images. This has to do with the fact
that animations (dynamic images) rely on rapidly displaying a
sequence of images over time, all of which must be available to
create the effect of movement successfully. For more information
about how animation works, look at <A HREF="ch13.htm" >Chapter 13</A>,
&quot;Animation Techniques.&quot; An animation sequence just wouldn't
look right using interlacing, because some of the images would
be transferred before others. At this point, you may be thinking
that a good solution would be to wait until all the images have
been transferred before displaying the animation. Now you're thinking!
But how do you know when the images have all been transferred?
Enter the Java media tracker.
<P>
Think about how the transmission delay problem affects sound and
music. Similar to animation, there isn't an interlacing workaround
for sound and music. This is because sound is based on the passing
of time, which means that there is no way to incrementally improve
the sound quality without playing the sound. Once a sound is played,
its time has passed. The same situation exists for music. Therefore,
the media tracker presents a solution useful not only for animations,
but also for sound and music. The drawback, as you'll learn later
in this chapter, is that the media tracker currently supports
only images.
<H2><A NAME="KeepingUpwithMediaObjects"><FONT SIZE=5 COLOR=#FF0000>Keeping
Up with Media Objects</FONT></A></H2>
<P>
You've arrived at the logical conclusion that the best way to
manage transmission delay effects on media objects is to simply
keep up with when the objects have been successfully transferred.
The Java media tracker is an object that performs this exact function.
Using the media tracker, you can keep up with any number of media
objects and query for when they have finished being transmitted.
<P>
For example, suppose you have an animation with four images. Using
the media tracker, you would register each of these images and
then wait until they have all been transferred before displaying
the animation. The media tracker keeps up with the load status
of each image. When the media tracker reports that all the images
have been successfully loaded, you are guaranteed that your animation
has all the necessary images to display correctly.
<H2><A NAME="TheMediaTrackerClass"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 >MediaTracker</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></A></H2>
<P>
Not surprisingly, the Java media tracker is implemented as a class.
The Java <TT>MediaTracker</TT> class
is part of the AWT package and contains a variety of members and
methods for tracking media objects. Unfortunately, the <TT>MediaTracker</TT>
class that ships with release 1.0 of the Java Development Kit
supports only the tracking of images. Future versions of Java
are expected to add support for other types of media objects,
such as sound, music, and animation.
<H3>Members</H3>
<P>
The <TT>MediaTracker</TT> class provides
member flags for representing various states associated with tracked
media objects. These flags are returned by many of the member
functions of <TT>MediaTracker</TT>.
Here are the <TT>MediaTracker</TT>
member flags:
<UL>
<LI><TT>final static int LOADING</TT>
<LI><TT>final static int ABORTED</TT>
<LI><TT>final static int ERRORED</TT>
<LI><TT>final static int COMPLETE</TT>
</UL>
<P>
The <TT>LOADING</TT> flag indicates
that a media object is currently in the process of being loaded.
The <TT>ABORTED</TT> flag indicates
that the loading of a media object has been aborted. The <TT>ERRORED</TT>
flag indicates that some type of error occurred while trying to
load a media object, and the <TT>COMPLETE</TT>
flag indicates that a media object has been successfully loaded.
<H3>Methods</H3>
<P>
The <TT>MediaTracker</TT> class provides
the following methods for helping to track media objects:
<UL>
<LI><TT>MediaTracker(Component comp)</TT>
<LI><TT>void addImage(Image image, int id)</TT>
<LI><TT>synchronized void addImage(Image
image, int id, int w, int h)</TT>
<LI><TT>boolean checkID(int id)</TT>
<LI><TT>synchronized boolean checkID(int
id, boolean load)</TT>
<LI><TT>boolean checkAll()</TT>
<LI><TT>synchronized boolean checkAll(boolean
load)</TT>
<LI><TT>void waitForID(int id)</TT>
<LI><TT>synchronized boolean waitForID(int
id, long ms)</TT>
<LI><TT>void waitForAll()</TT>
<LI><TT>synchronized boolean waitForAll(long
ms)</TT>
<LI><TT>int statusID(int id, boolean load)</TT>
<LI><TT>int statusAll(boolean load)</TT>
<LI><TT>synchronized boolean isErrorID(int
id)</TT>
<LI><TT>synchronized boolean isErrorAny()</TT>
<LI><TT>synchronized Object[] getErrorsID(int
id)</TT>
<LI><TT>synchronized Object[] getErrorsAny()</TT>
</UL>
<P>
The constructor for <TT>MediaTracker</TT>
takes a single parameter of type <TT>Component</TT>.
This parameter specifies the <TT>Component</TT>
object on which tracked images will eventually be drawn. This
parameter reflects the current limitation of only being able to
track images with the <TT>MediaTracker</TT>
class.
<P>
The <TT>addImage</TT> methods add
an image to the list of images currently being tracked. Both methods
take as their first parameter an <TT>Image</TT>
object and as their second parameter an identifier that uniquely
identifies the image. If you want to track a group of images together,
you can use the same identifier for each. The second <TT>addImage</TT>
method has additional parameters for specifying the width and
height of a tracked image. This version of <TT>addImage</TT>
is used for tracking images that you are going to scale; you pass
the width and height that you want to use for the scaled image.
<P>
Once images have been added to the <TT>MediaTracker</TT>
object, you are ready to start checking their status. The <TT>checkID</TT>
methods are used to check whether images matching the passed identifier
have finished loading. Both versions of <TT>checkID</TT>
return <TT>false</TT> if the images
have not finished loading and <TT>true</TT>
otherwise. This means that they return <TT>true</TT>
even if the loading has been aborted or if an error has occurred.
You must call the appropriate error checking methods to see whether
an error occurred. You'll learn about the error checking methods
a little later in this section.
<P>
The only difference between the two <TT>checkID</TT>
methods is how the loading of images is handled. The first version
of <TT>checkID</TT> does not load
an image if it has not already begun loading. The second version,
on the other hand, enables you to specify that the image be loaded
if it hasn't already started loading. You specify this by passing
<TT>true</TT> in the <TT>load</TT>
parameter.
<P>
The <TT>checkAll</TT> methods are
very similar to the <TT>checkID</TT>
methods, except they apply to all images and not just those matching
a certain identifier. Similar to the <TT>checkID</TT>
methods, the <TT>checkAll</TT> methods
come in two versions. The first version doesn't load any images
that haven't already begun loading, and the second version enables
you to indicate that images start loading if they haven't started
already.
<P>
The <TT>waitForID</TT> methods are
used to begin loading images with a certain identifier. Both versions
of <TT>waitForID</TT> are synchronous,
meaning that they do not return until all the specified images
have finished loading or an error occurs. The second version of
<TT>waitForID</TT> enables you to
specify a time-out period, in which case the load will end, and
<TT>waitForID</TT> will return <TT>true</TT>.
You specify the time-out period in milliseconds by using the <TT>ms</TT>
parameter.
<P>
The <TT>waitForAll</TT> methods are
very similar to the <TT>waitForID</TT>
methods, except they operate on all images. Like the <TT>waitForID</TT>
methods, there are versions of <TT>waitForAll</TT>
both with and without time-out support.
<P>
The <TT>statusID</TT> method is used
to determine the status of images matching the identifier passed
in the <TT>id</TT> parameter. <TT>statusID</TT>
returns the bitwise <TT>OR</TT> of
the status flags related to the images. The possible flags are
<TT>LOADING</TT>, <TT>ABORTED</TT>,
<TT>ERRORED</TT>, and <TT>COMPLETE</TT>.
To check for a particular status flag, you simply mask the flag
out of the return value of <TT>statusID</TT>:
<BLOCKQUOTE>
<TT>if (tracker.statusID(0, true) &amp; MediaTracker.ERRORED)
{<BR>
&nbsp;&nbsp;// there was an error!<BR>
}</TT>
</BLOCKQUOTE>
<P>
The second parameter to <TT>statusID</TT>,
<TT>load</TT>, should be familiar
to you by now. It specifies whether you want the images to start
loading if they haven't started already. This functionality is
very similar to that provided by the second version of the <TT>checkID</TT>
and <TT>waitForID</TT> methods.
<P>
The <TT>statusAll</TT> method is very
similar to the <TT>statusId</TT> method,
with the only difference being that <TT>statusAll</TT>
returns the status of all the images being tracked, rather than
those matching a specific identifier.
<P>
Finally, you arrive at the error checking methods mentioned earlier.
The <TT>isErrorID</TT> and <TT>isErrorAny</TT>
methods check the error status of images being tracked. The only
difference is that the former checks on images with a certain
identifier, and the latter checks on all images. Both of these
methods basically check the status of each image for the <TT>ERRORED</TT>
flag. Note that both methods will return <TT>true</TT>
if any of the images have errors; it's up to you to determine
which specific images have errors.
<P>
If you use <TT>isErrorID</TT> or <TT>isErrorAny</TT>
and find out that there are load errors, you then need to find
out which images had errors. You do this by using the <TT>getErrorsID</TT>
and <TT>getErrorsAny</TT> methods.
These two methods return an array of <TT>Object</TT>s
containing the media objects that have load errors. In the current
implementation of the <TT>MediaTracker</TT>,
this array is always filled with <TT>Image</TT>
objects. If there are no errors, these methods return <TT>null</TT>.
Similar to the <TT>isErrorID</TT>
and <TT>isErrorAny</TT> methods, <TT>getErrorsID</TT>
and <TT>getErrorsAny</TT> differ only
by the images that they check; the former returns errored images
matching the passed identifier, and the latter returns all errored
images.
<P>
That wraps up the description of the <TT>MediaTracker</TT>
class. Now that you know the details about the class, you're ready
to see it in action. Read on!
<H2><FONT SIZE=5 COLOR=#FF0000>Using Images Without the Media
Tracker</FONT></H2>
<P>
Tracking images with the <TT>MediaTracker</TT>
class is pretty easy, and you'll learn how to do it soon enough.
However, to better illustrate the impact of using the media tracker,
you will first write an applet that doesn't use it. After seeing
how the images are loaded and how the applet responds, you'll
have more insight into why the media tracker is important. Figure
2.1 contains a screen shot of the Count1 applet.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f2-1.gif" ><B>Figure 2.1 : </B><I>The Count1 applet with images fully loaded.</I></A>
<P>
The Count1 applet displays a series of ten images horizontally
one after the next. In an environment where the images are readily
available, they would immediately be drawn when the applet is
first run. However, with Java you are typically dealing with distributed
applets, where the media objects used by an applet must be downloaded
at runtime. This results in an appreciable delay between when
the applet is run and when the images are available for display.
(As you may have guessed, the screen shot of Count1 in Figure
2.1 was taken a few seconds after the applet had been run, meaning
that I gave it time to finish loading the images. What I saw in
the meantime is shown in Figure 2.2.)
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f2-2.gif" ><B>Figure 2.2 : </B><I>The Count1 applet with images partially loaded.</I></A>
<P>
It's clear from Figure 2.2 that the images are in the middle of
loading. Although the resulting effect is tolerable in this applet
because the images are displayed statically, imagine what the
effect would be if the applet were attempting to count to nine
using the images. In this case, the images would be part of an
animation and would yield very unpredictable results depending
on the speed of the animation and the speed at which the applet
was counting.
<P>
Before you learn how to resolve this problem, it's important to
understand what is happening in Count1. Take a look at the source
code for the Count1 applet in Listing 2.1.
<HR>
<BLOCKQUOTE>
<B>Listing 2.1. The Count1 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Count1 Class<BR>
// Count1.java<BR>
<BR>
// Imports<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
<BR>
public class Count1 extends Applet {<BR>
&nbsp;&nbsp;Image img[] = new Image[10];<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img[i] = getImage(getDocumentBase(),
&quot;Res/&quot; + i + &quot;.gif&quot;);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(img[i], i * 48,
0, this);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Count1 has an array of ten <TT>Image</TT>
objects as its only member variable, <TT>img</TT>.
This array holds the ten number images that Count1 draws. The
image array is initialized in the <TT>init</TT>
method by loading each image in a <TT>for</TT>
loop. The <TT>getImage</TT> method
is used to load each image. Notice in the call to <TT>getImage</TT>
that the images are expected to be stored in the Res subdirectory
under the directory where the applet was launched.
<P>
In Count1, the <TT>update</TT> method
is overridden so that there is no flicker when drawing the images.
This is evident by the fact that this <TT>update</TT>
method only calls <TT>paint</TT>.
The original <TT>update</TT> method
clears the background before calling <TT>paint</TT>.
This is a pretty standard approach to eliminating flicker in simple
Java applets. You learn about more powerful flicker reducing techniques
in <A HREF="ch13.htm" >Chapter 13</A>.
<P>
Finally, the images are drawn using the <TT>paint</TT>
method. Drawing the images is as simple as iterating through the
image array and calling the <TT>drawImage</TT>
method for each image.
<H2><A NAME="TrackingImageswiththeMediaTracker"><FONT SIZE=5 COLOR=#FF0000>Tracking
Images with the Media Tracker</FONT></A></H2>
<P>
Now that you have an idea how an applet works without the help
of the media tracker, it's time to take a look at how the media
tracker improves things. By using the media tracker, you know
exactly when certain images have been transferred and are ready
to use. This enables you to display alternate output based on
whether the images have finished transferring. Figure 2.3 shows
the Count2 applet while the images are still being loaded.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f2-3.gif" ><B>Figure 2.3 : </B><I>The Count2 applet with images partially loaded.</I></A>
<P>
As you can see, the images aren't displayed at all until they
have all been successfully transferred. Instead, a text message
is displayed informing the user that the images are still in the
process of loading. This is a pretty simple enhancement to the
applet, but one that makes the applet look much more professional.
By displaying a simple message while media objects are loading,
you solve the problem of drawing partially transferred images.
Furthermore, you provide the user with more information about
what is happening. If users have to wait for something, they are
usually much more satisfied if you give them details about what
they are waiting for.
<P>
Take a look at the source code for Count2 in Listing 2.2.
<HR>
<BLOCKQUOTE>
<B>Listing 2.2. The Count2 sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// Count2 Class<BR>
// Count2.java<BR>
<BR>
// Imports<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
<BR>
public class Count2 extends Applet implements Runnable {<BR>
&nbsp;&nbsp;Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img[]
= new Image[10];<BR>
&nbsp;&nbsp;Thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread;
<BR>
&nbsp;&nbsp;MediaTracker&nbsp;&nbsp;tracker;<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tracker = new MediaTracker(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;img[i] = getImage(getDocumentBase(),
&quot;Res/&quot; + i + &quot;.gif&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.addImage(img[i], 0);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread = new Thread(this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread.start();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;thread = null;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tracker.waitForID(0);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException e) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.ERRORED)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.red);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0, 0, size().width,
size().height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ((tracker.statusID(0, true) &amp; MediaTracker.COMPLETE)
!= 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10;
i++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(img[i],
i * 48, 0, this);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font
= new Font(&quot;Helvetica&quot;, Font.PLAIN, 18);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = g.getFontMetrics(font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str
= new String(&quot;Loading images...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(font);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(str, (size().width
- fm.stringWidth(str)) / 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((size().height
- fm.getHeight()) / 2) + fm.getAscent());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
It looks like a lot more code than Count1, but the extra code
required to add media tracker support is really very simple. A
lot of the extra code in Count2 is to draw the various outputs
if the images aren't loaded.
<P>
The first thing you probably noticed in Count2 is the addition
of two member variables, <TT>thread</TT>
and <TT>tracker</TT>. The <TT>thread</TT>
member is a <TT>Thread</TT> object
that is used to provide the media tracker with its own stream
of execution. This allows the media tracker to wait for the images
to load without halting execution of the applet itself. The <TT>tracker</TT>
member is the <TT>MediaTracker</TT>
object used to track the images.
<P>
In the <TT>init</TT> method, the <TT>MediaTracker</TT>
object is created by passing <TT>this</TT>
as the only parameter to its constructor. If you recall from the
discussion of the <TT>MediaTracker</TT>
constructor earlier in this chapter, this parameter is of type
<TT>Component</TT>, and it represents
the component on which the tracked images will be drawn. All <TT>Applet</TT>s
are derived from <TT>Component</TT>,
so passing the <TT>Applet</TT> object
(<TT>this</TT>) correctly initializes
the media tracker.
<P>
Also notice that the images are added to the media tracker in
the <TT>Init</TT> method. This is
accomplished by calling the <TT>addImage</TT>
method of <TT>MediaTracker</TT> and
passing the <TT>Image</TT> object
and an identifier. Notice that <TT>0</TT>
is passed as the identifier for all the images. This means that
you are tracking them as a group.
<P>
The <TT>start</TT> and <TT>stop</TT>
methods are used to manage the creation and destruction of the
<TT>Thread</TT> member object. These
are pretty standard implementations for adding basic multithreading
support to an applet.
<P>
The <TT>run</TT> method is where the
tracking actually starts taking place. The <TT>waitForID</TT>
method of <TT>MediaTracker</TT> is
called within a <TT>try</TT>-<TT>catch</TT>
clause. It must be placed in this exception handling clause because
an <TT>InterruptedException</TT> will
be thrown if another thread interrupts this thread. Recall that
<TT>waitForID</TT> is synchronous,
meaning that it won't return until all the images with the specified
identifier have been loaded. This means that the call to <TT>repaint</TT>
will not occur until the images have all been loaded.
<P>
To understand why this works, you need to look at the last method
in Count2, <TT>paint</TT>. The <TT>paint</TT>
method begins by checking to see whether an error has occurred
loading the images. It does this by calling <TT>statusID</TT>
and checking the result against the <TT>ERRORED</TT>
flag. If an error has occurred, <TT>paint</TT>
fills the applet window with the color red to indicate an error.
Figure 2.4 shows what Count2 looks like when an error occurs.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f2-4.gif" ><B>Figure 2.4 : </B><I>The Count2 applet with an error in loading the images.</I></A>
<P>
The next check performed by <TT>paint</TT>
is to see whether the images have finished loading. It does this
by calling <TT>statusID</TT> and comparing
the result with the <TT>COMPLETE</TT>
flag. If the images have finished loading, the image array is
iterated through and each image drawn on the applet window. The
resulting output is the same as Count1, which you already saw
in Figure 2.1. If the images have not finished loading, the text
message <TT>Loading images...</TT>
is displayed. You may be curious about the font calculations that
are made before drawing the text. These calculations are necessary
to make sure the text is drawn centered in the applet window.
<H2><A NAME="TrackingOtherTypesofMedia"><FONT SIZE=5 COLOR=#FF0000>Tracking
Other Types of Media</FONT></A></H2>
<P>
Now that you have a good idea how the media tracker is used to
track images, you may be wondering what to do about other types
of media, such as audio. Unfortunately, release 1.0 of Java doesn't
provide media tracker support for any media types other than images.
The reason for this is that few media types have been well-defined
in this version of Java.
<P>
As of this writing, Sun has promised a future release of Java
with more extensive support for other media types. Until then,
you are pretty much left with tracking images only. It is technically
possible to extend the media tracker yourself to support tracking
audio clips, but it would require writing a fair amount of code
that will ultimately be outdated when Sun provides its own implementations
in the future. For more information on what the future audio support
in Java might look like, check out <A HREF="ch4.htm" >Chapter 4</A>,
&quot;Using Java's Audio Classes.&quot;
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned about a problem inherent in transmitting
media objects over the Internet, transmission delay. Because the
Web is largely dependent on media objects, transmission delay
is a very important issue that Java applets must be able to handle.
Although there isn't really anything software can do to alleviate
the physical transmission delays inherent in a particular network
connection, there are suitable workarounds. One workaround that
applies to static images is interlacing.
<P>
Although interlacing works well with static images, you learned
in this chapter that the Java media tracker provides a universal
solution to transmission delays as they apply to all media objects.
Using the Java media tracker, you can be informed when media objects
have finished transferring and are available for use. You saw
a practical usage of the media tracker by writing a sample applet
both with and without media tracker support. Finally, you learned
that in its current release, the Java media tracker works only
with images.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch1.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
