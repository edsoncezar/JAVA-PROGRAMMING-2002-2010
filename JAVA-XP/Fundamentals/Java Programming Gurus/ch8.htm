<HTML>

<HEAD>
   <TITLE>Chapter 8 -- All About GridBaglayout and Other Layout managers</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 8</FONT></H1>
<H2><B><FONT SIZE=5 COLOR=#FF0000>All About </FONT><TT><FONT SIZE=5 COLOR=#FF0000>GridBaglayout</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
and Other Layout managers</FONT></B>
</H2>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#AutomatedLayoutandtheAWTLayoutMana" >Automated Layout and the AWT Layout Manager</A>
<LI><A HREF="#BasicLayoutClasses" >Basic Layout Classes</A>
<LI><A HREF="#TheGridBagLayoutClass" >The GridBagLayout Class</A>
<LI><A HREF="#CreatingYourOwnLayoutManager" >Creating Your Own Layout Manager</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
The AWT library includes classes for automated layout management
of windows. The <I>layout manager</I> classes are a set of classes
that lay out widgets on forms and windows. Moreover, these classes
recompute the layout when the user resizes a window. You might
be asking yourself why an automated layout manager is needed.
Why not just use a layout editor to position widgets on the window?
The answer is that the layout manager not only helps you create
an initial layout. If you are developing a Java program where
the user must be allowed to resize windows, the layout manager
classes can minimize your work, because you don't have to write
your own code for recomputing the layout after resize events.
For static, nonresizeable windows, you might be better off using
a layout editor (such as a layout editor provided by a Java development
environment).
<P>
The most powerful layout manager is the <TT>GridBagLayout</TT>
class. This manager provides advanced functions for specifying
widget resizing and repositioning as the window size changes.
Before you explore the <TT>GridBagLayout</TT>
class and other layout manager classes, let's first examine the
concept of automated layout.
<H2><A NAME="AutomatedLayoutandtheAWTLayoutMana"><FONT SIZE=5 COLOR=#FF0000>Automated
Layout and the AWT Layout Manager</FONT></A></H2>
<P>
Although you can use static layouts defined with, for instance,
layout editors for windows of fixed size, there are still reasons
for taking the layout manager approach. Because Java is designed
to be platform-independent, it can be difficult to find a layout
that is acceptable on every platform. Components look somewhat
different on each platform because the AWT uses native widgets
in the window system of the platform. Layout managers can assist
you in creating well-designed user interfaces on every platform
by recomputing the layout dynamically.
<P>
Selecting an appropriate layout manager is sometimes difficult.
The AWT includes a set of standard layout managers, which you
can configure to a certain extent. The best strategy often is
to use the simplest layout manager that is sufficient for your
layout task.
<P>
To take advantage of a layout manager, you should instantiate
a layout manager class, such as <TT>FlowLayout</TT>,
<TT>GridBagLayout</TT>, and so on.
The next step is to associate it with the container on which it
should operate. The method <TT>setLayout(LayoutManager)</TT>
sets the layout manager for a container. For some layout managers,
you can specify the layout strategy by providing parameters to
the constructor of the layout manager or by setting parameters
in the layout manager.
<P>
Once you have set the layout manager for a container, the latter
will invoke the layout manager just before the components are
drawn. Resizing windows and adding components to the container
will cause the layout manager to recompute the layout. If one
of the basic layout classes in AWT is sufficient, you may want
to use it instead of <TT>GridBagLayout</TT>.
If you need a more sophisticated layout than what is provided
by a single layout manager, it is possible to use a combination
of several layout managers, where components of an overall layout
are themselves containers with their own layout managers.
<H2><A NAME="BasicLayoutClasses"><FONT SIZE=5 COLOR=#FF0000>Basic
Layout Classes</FONT></A></H2>
<P>
In addition to <TT>GridBagLayout</TT>,
the AWT includes four basic layout managers: <TT>FlowLayout</TT>,
<TT>BorderLayout</TT>, <TT>GridLayout</TT>,
and <TT>CardLayout</TT>. These layout
managers are simpler to use, but less powerful than <TT>GridBagLayout</TT>.
<H3><TT><FONT SIZE=4 FACE="Courier">FlowLayout</FONT></TT></H3>
<P>
The <TT>FlowLayout</TT> class is a
straightforward layout manager that lays out components linewise
from left to right. When a line of components is filled, <TT>FlowLayout</TT>
creates a new line and continues laying out components on the
next line. The layout strategy is similar to the way a word processor
wraps text on a page. Use the <TT>FlowLayout</TT>
class in situations where it is important to line up components
horizontally and where you want the layout manager to wrap the
lines for you. Figure 8.1 shows a sample layout produced by <TT>FlowLayout</TT>.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-1.gif"><B>Figure 8.1 : </B><I>Sample </I>FlowLayout.</A>
<P>
The constructors for <TT>FlowLayout</TT>
allow several layout options. You can control the alignment of
components by specifying an alignment code (which is defined as
a constant in the <TT>FlowLayout</TT>
class). The possible alignments are <TT>FlowLayout.CENTER</TT>,
<TT>FlowLayout.LEFT</TT>, and <TT>FlowLayout.RIGHT</TT>.
You also can specify the horizontal and vertical gaps between
components. Use the constructor <TT>FlowLayout()</TT>
to create a <TT>FlowLayout</TT> with
a centered alignment. The constructor <TT>FlowLayout(int
align)</TT> creates a <TT>FlowLayout</TT>
with the specified alignment, and the constructor <TT>FlowLayout(int
align, int hgap, int vgap)</TT> creates a <TT>FlowLayout</TT>
with the specified alignment, horizontal gap, and vertical gap,
respectively.
<H3><TT><FONT SIZE=4 FACE="Courier">BorderLayout</FONT></TT></H3>
<P>
The <TT>BorderLayout</TT> class enables
you to specify where on the border of a container each component
should be placed. By naming the component members <TT>North</TT>,
<TT>South</TT>, <TT>West</TT>,
<TT>East</TT>, and <TT>Center</TT>,
you can control the location of the components. Specify the component
names with the <TT>add()</TT> method
when you add components to the container. The <TT>BorderLayout</TT>
class lays out the <TT>North</TT>,
<TT>South</TT>, <TT>West</TT>,
and <TT>East</TT> components using
their preferred sizes. <TT>BorderLayout</TT>
resizes the <TT>Center</TT> component
to fill the remaining center space. Use <TT>BorderLayout</TT>
when you need to group components on the borders of a container,
such as positioning scrollbars on the bottom and right side of
a container. Figure 8.2 shows a sample layout generated by <TT>BorderLayout</TT>.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-2.gif"><B>Figure 8.2 : </B><I>Sample </I>Borderlayout.</A>
<P>
There are two constructors for <TT>BorderLayout</TT>:
<TT>BorderLayout()</TT> and <TT>BorderLayout(int
hgap, int vgap)</TT>. The first constructor creates a basic
<TT>BorderLayout</TT>, and the second
creates a <TT>BorderLayout</TT> with
horizontal and vertical gaps.
<H3><TT><FONT SIZE=4 FACE="Courier">GridLayout</FONT></TT></H3>
<P>
The <TT>GridLayout</TT> class lays
out components as a matrix according to a grid. <TT>GridLayout</TT>
places a component on each position in the grid. The order in
which you add components to the container is important, because
<TT>GridLayout</TT> fills the grid
from left to right and from top to bottom. Use the <TT>GridLayout</TT>
when you need a matrix-like layout, such as a matrix of <TT>TextFields</TT>.
Figure 8.3 shows a sample <TT>GridLayout</TT>.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-3.gif"><B>Figure 8.3 : </B><I>Sample </I>GridLayout.</A>
<P>
<TT>GridLayout</TT> has the constructors
<TT>GridLayout(int rows, int cols)</TT>
and <TT>GridLayout(int rows, int cols, int
hgap, int vgap)</TT>. The first creates a <TT>GridLayout</TT>
with the specified number of rows and columns. The second enables
you also to specify the horizontal and vertical gaps. Specifying
the number of columns is important, because <TT>GridLayout</TT>
uses this information when placing components on the grid.
<H3><TT><FONT SIZE=4 FACE="Courier">CardLayout</FONT></TT></H3>
<P>
The <TT>CardLayout</TT> class enables
you to define a set of alternative cards that are displayed in
the container. Each card is typically a container that can include
several components. Unlike other layout mangers, <TT>CardLayout</TT>
does not lay out components geometrically. It shows and hides
the appropriate components but does not change the location of
them. Use the <TT>CardLayout</TT>
class when you need to display alternative sets of components
on a panel, such as when you are implementing slide-show applets
and preference panels with several alternative forms.
<P>
Because <TT>CardLayout</TT> shows
and hides containers, you must inform the layout manager when
you want to change the current card. For this purpose, <TT>CardLayout</TT>
provides several methods for controlling the cards programmatically.
Table 8.1 shows the control methods that <TT>CardLayout</TT>
supports. You can create a panel of buttons that control the panel
by calling these methods.<BR>
<P>
<CENTER><B>Table 8.1. </B><TT><B></TT>CardLayout</FONT></B></TT><B>
methods.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 80%>
<TR><TD WIDTH=236><B>Layout Manager Method</B></TD><TD WIDTH=174><B>Description</B>
</TD><TD WIDTH=181><B>Parameters</B></TD></TR>
<TR><TD WIDTH=236><TT>first(Container)</TT>
</TD><TD WIDTH=174>Show the first card</TD><TD WIDTH=181>The parent container
</TD></TR>
<TR><TD WIDTH=236><TT>last(Container)</TT>
</TD><TD WIDTH=174>Show the last card</TD><TD WIDTH=181>The parent container
</TD></TR>
<TR><TD WIDTH=236><TT>next(Container)</TT>
</TD><TD WIDTH=174>Show the next card</TD><TD WIDTH=181>The parent container
</TD></TR>
<TR><TD WIDTH=236><TT>previous(Container)</TT>
</TD><TD WIDTH=174>Show the previous card</TD><TD WIDTH=181>The parent container
</TD></TR>
<TR><TD WIDTH=236><TT>show(Container, String)</TT>
</TD><TD WIDTH=174>Show a named card</TD><TD WIDTH=181>The parent container and the name of the card
</TD></TR>
</TABLE></CENTER>
<P>
<H3>A Layout Manager Example</H3>
<P>
Let's consider an example of how we can use basic layout managers.
By combining several layout managers, we can achieve quite complex
layouts. Figure 8.4 shows a sample window layout, which is produced
by a combination of four layout managers.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-4.gif" ><B>Figure 8.4 : </B><I>A sample layout created by a combination of layout managers.</I></A>
<P>
Here is the code that creates this window:
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.util.*;<BR>
import java.applet.Applet;<BR>
public class ComboEx extends Applet {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use BorderLayout
as the overall layout */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(new
BorderLayout());<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Add the table
of name, e-mail, and URL */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panel t = new
Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.setLayout(new
GridLayout(4,3));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add column
headers...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.add(new Label(&quot;Name&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.add(new Label(&quot;E-mail&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.add(new Label(&quot;URL&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add nine text
fields...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1;
i &lt;= 9; i++) t.add(new TextField());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;Center&quot;,t);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Add the ranking
numbers to the left */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panel r = new
Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.setLayout(new
GridLayout(4,1));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.add(new Label(&quot;No.&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.add(new Label(&quot;1&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.add(new Label(&quot;2&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.add(new Label(&quot;3&quot;));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;West&quot;,r);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Add control
buttons at the bottom */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Panel control
= new Panel();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.setLayout(new
FlowLayout());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.add(new
Button(&quot; OK &quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.add(new
Button(&quot;Cancel&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control.add(new
Button(&quot;Revert&quot;));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(&quot;South&quot;,
control);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frame f = new Frame(&quot;Layout
Combination Example&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ComboEx ce = new ComboEx();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ce.init();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.add(&quot;Center&quot;,
ce)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.pack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.resize(f.preferredSize());
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.show();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Note that <TT>BorderLayout</TT> controls
the overall layout of the window. The <I>left</I> position of
this layout is a <TT>GridLayout</TT>
with the <TT>&quot;No.&quot;</TT>
label and the numbers <TT>1</TT>-<TT>3</TT>.
The <I>center</I> position is a second <TT>GridLayout</TT>
with the column labels and nine text-entry fields. Finally, the
<I>south</I> position is a <TT>FlowLayout</TT>
with the control buttons for the <TT>&quot;OK&quot;</TT>,
<TT>&quot;Cancel&quot;</TT>, and <TT>&quot;Revert&quot;</TT>
operations.
<H2><A NAME="TheGridBagLayoutClass"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">GridBagLayout</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Class</FONT></A></H2>
<P>
The <TT>GridBagLayout</TT> class is
a powerful layout manager that lays out components based on a
grid. You can think of <TT>GridBagLayout</TT>
as an advanced version of <TT>GridLayout</TT>.
The major difference between <TT>GridLayout</TT>
and <TT>GridBagLayout</TT> is that
<TT>GrigBagLayout</TT> supports components
of different sizes, and you can specify layout options for each
component. Use the <TT>GridBagLayout</TT>
when you need tabular layouts (or layouts that can be thought
of as matrices) and when it is important to specify the resizing
behavior of each component.
<H3>Basic Concepts</H3>
<P>
<TT>GridBagLayout</TT> supports a
rectangular grid of cells. Each component of a <TT>GridBagLayout</TT>
can occupy one or more cells. Because <TT>GridBagLayout</TT>
enables you to specify layout properties for each component, you
must associate components managed by <TT>GridBagLayout</TT>
with instances of the class <TT>GridBagConstraints</TT>.
These instances specify how <TT>GridBagLayout</TT>
should lay out components in the matrix. Let's examine how you
can set up a <TT>GridBagLayout</TT>.
The constructor <TT>GridBagLayout()</TT>
creates a <TT>GridBagLayout</TT> instance.
You can then use the method <TT>setConstraints(Component,
GridBagConstraints)</TT> to associate components with constraints.
In addition to the <TT>setConstraints(Component,
GridBagConstraints)</TT> method, <TT>GridBagLayout</TT>
provides a set of methods to manage constraints. Table 8.2 shows
the constraint management methods.<BR>
<P>
<CENTER><B>Table 8.2. Constraint management methods for </B><TT><B></TT>GridBagLayout</FONT></B></TT><B>.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 80%>
<TR><TD WIDTH=197><B>Layout Manager Method</B></TD><TD WIDTH=197><B>Description</B>
</TD><TD WIDTH=197><B>Parameters</B></TD></TR>
<TR><TD WIDTH=197><TT>setConstraints(Component, GridBagConstraints)</TT>
</TD><TD WIDTH=197>Associate constraints with a component</TD>
<TD WIDTH=197>The component andthe constraints</TD></TR>
<TR><TD WIDTH=197><TT>getConstraints(Component)</TT>
</TD><TD WIDTH=197>Get the constraints for a component (a copy of the <TT>GridBagConstraints </TT>instance is returned)
</TD><TD WIDTH=197>The component to get constraints from</TD>
</TR>
<TR><TD WIDTH=197><TT>lookupConstraints(Component)</TT>
</TD><TD WIDTH=197>Get the constraints for a component (the actual <TT>GridBagConstraints </TT>instance is returned)
</TD><TD WIDTH=197>The component to get constraints from</TD>
</TR>
</TABLE></CENTER>
<P>
<P>
Typically, you set up instances of the <TT>GridBagConstraints</TT>
class before associating them with the components using the <TT>setConstraints(Component,
GridBagConstraints)</TT> method.
<H3><TT><FONT SIZE=4 FACE="Courier">GridBagConstraints</FONT></TT>
</H3>
<P>
The <TT>GridBagConstraints</TT> class
enables you to specify constraints for <I>each</I> component of
the container. The <TT>GridBagConstraints</TT>
class provides several options for specifying the behavior of
member components. You specify the constraints by setting instance
variables of the <TT>GridBagConstraints</TT>
object. <TT>GridBagConstraints</TT>
has three major <I>variable categories</I> that execute the following:
<UL>
<LI>Control the position and size of a component on the grid
<LI>Specify the size and location of the component in its display
area
<LI><FONT COLOR=#000000>Add padding to components and display
areas</FONT>
</UL>
<P>
The variables <TT>gridx</TT> and <TT>gridy</TT>
control the component position on the grid (the cell in which
the component is placed). The variables <TT>gridwidth</TT>
and <TT>gridheight</TT> determine
the component size in terms of grid cells. The variables <TT>fill</TT>
and <TT>anchor</TT> control the position
of a component within its display area. The variables <TT>ipadx</TT>,
<TT>ipady</TT>, and <TT>insets</TT>
specify the padding. Finally, the variables <TT>weightx</TT>
and <TT>weighty</TT> control the distribution
of space among cells. Here is a detailed description of each variable:
<P>
<TT><B></TT>gridx, gridy</FONT></B></TT>
<P>
Use these variables to specify explicitly where on the grid the
layout manager should place the component. The upper-left cell
is the origin, which has the location <TT>gridx
= 0</TT>, <TT>gridy = 0</TT>.
The default value is <TT>GridBagConstraints.RELATIVE</TT>,
which specifies that the component should be placed at the next
location relative to the last component added to the container.
(In this case, the next location is just to the right, or just
below, the previous component.)
<P>
<TT><B></TT>gridwidth, gridheight</FONT></B></TT>
<P>
Use <TT>gridwidth</TT> and <TT>gridheight</TT>
to specify the size of the components display area. You specify
this size in number of grid cells. For example, the values <TT>gridwidth
= 2</TT> and <TT>gridheight = 1</TT>
mean that the component display area is two cells wide and one
cell high in the grid. The default value of <TT>gridwidth</TT>
and <TT>gridheight</TT> is <TT>1</TT>.
To specify that a component is the last one in its row or column,
you can set <TT>gridwidth</TT> and
<TT>gridheight</TT> to <TT>GridBagConstraints.REMAINDER</TT>.
You can use the value <TT>GridBagConstraints.RELATIVE</TT>
to indicate that the component is next to the last one in the
row or column.
<P>
<TT><B></TT>fill</FONT></B></TT>
<P>
Use <TT>fill</TT> to specify how <TT>GridBagLayout</TT>
should resize components when the display area is larger than
the component. Set <TT>fill</TT> to
<TT>GridBagConstraints.HORIZONTAL</TT>
to make the component sufficiently wide to fill its display area
(without changing the component height). Set <TT>fill</TT>
to <TT>GridBagConstraints.VERTICAL</TT>
to make the component sufficiently tall to fill its display area
(without changing the component width). Set <TT>fill</TT>
to <TT>GridBagConstraints.BOTH</TT>
to make the component fill the display area completely. Thus,
the value <TT>GridBagConstraints.BOTH</TT>
is a combination of <TT>GridBagConstraints.HORIZONTAL</TT>
and <TT>GridBagConstraints.VERTICAL</TT>.
The default value of <TT>fill</TT>
is <TT>GridBagConstraints.NONE</TT>,
which specifies no fill for the component.
<P>
<TT><B></TT>anchor</FONT></B></TT>
<P>
Use <TT>anchor</TT> to specify where
a component should be placed if it is smaller than the display
area. <TT>GridBagLayout</TT> attaches
the component to the specified location. The following are the
possible values:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;GridBagConstraints.CENTER
(default)<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.NORTH<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.NORTHEAST<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.EAST<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.SOUTHEAST<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.SOUTH<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.SOUTHWEST<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.WEST<BR>
&nbsp;&nbsp;&nbsp;GridBagConstraints.NORTHWEST</TT>
</BLOCKQUOTE>
<P>
<TT><B></TT>ipadx, ipady</FONT></B></TT>
<P>
Use <TT>ipadx</TT> and <TT>ipady</TT>
to enlarge the minimum size of components. <TT>GridBagLayout</TT>
adds <TT>ipadx</TT> pixels to the
left and right of the minimum size of the component. Similarly,
<TT>GridBagLayout</TT> adds <TT>ipady</TT>
pixels to the bottom and top of the minimum size of the component.
Thus, <TT>GridBagLayout</TT> increases
the minimum width and height by <TT>ipadx*2</TT>
and <TT>ipady*2</TT> pixels, respectively.
<P>
<TT><B></TT>Insets</FONT></B></TT>
<P>
Use <TT>Insets</TT> to specify the
minimum border between the component and its display area. The
value must be an instance of the class <TT>Insets</TT>.
You can use the constructor <TT>Insets(int,
int, int, int)</TT> to create an <TT>Insets</TT>
instance with top, left, bottom, and right insets. <TT>GridBagLayout</TT>
then inserts the specified space between the edges of the component
and its display area.
<P>
<TT><B></TT>weightx, weighty</FONT></B></TT>
<P>
Use <TT>weightx</TT> and <TT>weighty</TT>
to specify how <TT>GridBagLayout</TT>
should distribute space. You can use numeric values for <TT>weightx</TT>
and <TT>weighty</TT> to distribute
space among columns (<TT>weightx</TT>)
and rows (<TT>weighty</TT>). These
weights determine how much extra space a row (or column) will
get when the container expands. By setting the <TT>weightx</TT>
and <TT>weighty</TT> values, you control
how rows and columns scale. Rows (columns) with larger weights
will grow faster than rows (columns) with smaller weights. Typically,
<TT>weightx</TT> and <TT>weighty</TT>
have values between <TT>0.0</TT> and
<TT>1.0</TT>. The default weight is
zero (<TT>0.0</TT>), which means no
growth. When all weights are zero, <TT>GridBagLayout</TT>
places the components together at the center of the container.
Thus, <TT>GridBagLayout</TT> puts
space between the grid and the edges of the container. Note that
the actual weight for each row (column) is a combination of the
weights of each of the components in the row (column).
<P>
You may find the task of setting up these variables difficult.
If you start modifying the values without a clear idea of how
they affect the layout, you may find it difficult to get the layout
and resizing behavior you want. The key to successful layout creation
is to plan ahead and to design the layout before specifying it.
<P>
Make a mock-up on paper or draw it using a drawing program. Once
you are satisfied with the mock-up design, you can proceed with
creating a grid on top of the layout. Use this grid as the basis
for assigning components to cells and adding components to correct
cell positions. Determine how you want each component to behave
inside its display area. Do you want the component to fill the
area horizontally, vertically, or both? Do you want the component
to attach to a certain side or corner of the area? Do you want
to enlarge the size of components or to add space between components
and the edges of their display areas? When you have answered these
questions, you can determine the correct values for the <TT>GridBagConstraints</TT>
variables. After you implement the initial version of your layout
specification, you can then redesign your layout incrementally
by modifying the variable values.
<H3>A <TT><FONT SIZE=4 FACE="Courier">GridBagLayout</FONT></TT><FONT SIZE=4>
Example</FONT></H3>
<P>
As you learned in the previous section, taking advantage of <TT>GridBagLayout</TT>
and <TT>GridBagConstraints</TT> is
a matter of setting appropriate values for variables. By studying
layout examples, you can learn more about how to set the layout
variables correctly. Because comprehensive examples of the use
of <TT>GridBagLayout</TT> often get
confusing, let's look at a minimal layout for a window with two
buttons. Once you understand how the variables in <TT>GridBagConstraints</TT>
work, you can easily use this knowledge to create containers with
many components.
<P>
You will first examine the source code and the resulting window
and then learn how you can modify different <TT>GridBagConstraints</TT>
variables to get alternative layouts and resizing behavior. Here
is the code for the <TT>MinimalGridBag</TT>
class:
<BLOCKQUOTE>
<TT>import java.awt.*;<BR>
import java.util.*;<BR>
import java.applet.Applet;<BR>
public class MinimalGridBag extends Applet {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;protected void makebutton(String name,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout
gridbag,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints
c) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button button
= new Button(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridbag.setConstraints(button,
c);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(button);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagLayout
gridbag = new GridBagLayout();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GridBagConstraints
c = new GridBagConstraints();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setLayout(gridbag);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weightx = 1.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.weighty = 1.0;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makebutton(&quot;Button
1&quot;, gridbag, c);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.fill = GridBagConstraints.BOTH;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makebutton(&quot;Button
2&quot;, gridbag, c);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; Frame f = new Frame(&quot;Minimal GridBag
Layout Example&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinimalGridBag mgb = new MinimalGridBag();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mgb.init();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.add(&quot;Center&quot;, mgb);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.pack();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.resize(f.preferredSize());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.show();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Figure 8.5 shows the resulting window from the <TT>MinimalGridBag</TT>
example. Initially, <TT>GridBagLayout</TT>
sizes the container (window) to accommodate buttons 1 and 2. The
buttons line up horizontally in a 2-by-1 grid.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-5.gif" ><B>Figure 8.5 : </B><I>The layout generated by the </I>MinimalGridBag<I> example (before resizing by the user).</I></A>
<P>
When the user enlarges the window, <TT>GridBagLayout</TT>
regenerates the layout based on the <TT>GridBagConstraints</TT>
specification. Figure 8.6 shows the enlarged window. The size
of button 1 remains the same because the <TT>fill</TT>
is <TT>GridBagConstraints.NONE</TT>
(the default value). However, <TT>GridBagLayout</TT>
expands button 2 to fill its display area, because <TT>fill</TT>
is set to <TT>GridBagConstraints.BOTH</TT>.
Note that <TT>weightx</TT> and <TT>weighty</TT>
are set to <TT>1.0</TT> in this example.
It is necessary to set them to a nonzero value to enable the grid
cells to grow.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-6.gif" ><B>Figure 8.6 : </B><I>The layout after the user has enlarged the window.</I></A>
<P>
As this example illustrates, it is easy to set up a minimal layout
that uses <TT>GridBagLayout</TT>.
The best way to learn more about how the <TT>GridBagConstraints</TT>
variables work is to modify this example yourself and play with
different settings. Because you may not currently have access
to a computer running Java or have the time to perform these experiments,
this chapter presents some of the possible modifications and their
result.
<P>
Let's consider what happens to the layout if you change some of
the variable values (by modifying the code, for example). In the
remainder of this example, you make some controlled experiments
with the variable values where you start with the previous code
and vary the value of only one or two variables simultaneously.
Figure 8.7 shows what happens if you change <TT>fill</TT>
to <TT>GridBagConstraints.HORIZONTAL</TT>
for button 2 and rerun the example. Button 2 now expands horizontally.
(The original version used the value <TT>GridBagConstraints.BOTH</TT>,
which makes the button 2 fill both horizontally and vertically.)
Likewise, you can set <TT>fill</TT>
to <TT>GridBagConstraints.VERTICAL</TT>
for button 2. Figure 8.8 shows what happens. You can use different
settings for <TT>fill</TT> to make
components, such as lists of items and text fields, expand to
accommodate more information as the user enlarges the window.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-7.gif" ><B>Figure 8.7 : </B><I>Enlarged window with fill set to </I>GridBagConstraints<I>. HORIZONTAL for button 2.</I></A>
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-8.gif" ><B>Figure 8.8 :</B><I> Enlarged window with fill set to </I>GridBagConstraints<I>. VERTICAL for button 2</I></A><I>.</I>
<P>
The <TT>anchor</TT> variable controls
where in the display area a component should be placed. Because
the default value for <TT>anchor</TT>
is <TT>GridBagConstraints.CENTER</TT>,
<TT>GridBagLayout</TT> centers 1 and
2 in the previous examples. Figure 8.9 shows what happens if you
set <TT>anchor</TT> to <TT>GridBagConstraints.WEST</TT>
for button 1 and enlarge the window. (Note that you start from
the original example where <TT>fill</TT>
is <TT>GridBagConstraints.BOTH</TT>.)
If you want, you can try other values for anchor to place button
1 on other sides and in one of the corners.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-9.gif" ><B>Figure 8.9 : </B><I>Enlarged window with </I>anchor<I> set to </I>GridBagConstraints.WEST<I> for Button 1.</I></A>
<P>
Understanding how <TT>weightx</TT>
and <TT>weighty</TT> work can sometimes
be difficult, especially if you start with a complex layout. However,
it is much easier if you consider a small example. Basically,
the variables <TT>weightx</TT> and
<TT>weighty</TT> control how cells
in the grid scale when the container is resized. By using different
values for <TT>weightx</TT> for the
buttons in the example, you can control how the display areas
scale when you resize the window.
<P>
Until now, you set <TT>weightx</TT>
to <TT>1.0</TT> for buttons 1 and
2 to ensure that the display areas will scale. (You also set <TT>weighty</TT>
to <TT>1.0</TT> to ensure vertical
scaling.) Figure 8.10 shows what happens if you set <TT>weightx</TT>
to <TT>0.8</TT> for button 1 and <TT>0.2</TT>
for button 2 and then enlarge the window. Note that, because button
1 has more weight than button 2, the area for button 1 scales
more rapidly than the area for button 2. However, the scaling
for cells in grids with multiple rows is more complex than this
example shows, because the weight for a column is calculated from
the weight of all the cells in the column.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-10.gif" ><B>Figure 8.10 : </B><I>Enlarged window with weightx set to </I>0.8<I> for button 1 and </I>0.2<I> for button 2.</I></A>
<P>
<TT>GridBagConstraints</TT> provides
variables for adding to the size of components and to add padding
space around components. Let's examine what happens if you change
these variables. The variables <TT>ipadx</TT>
and <TT>ipady</TT> specify how much
<TT>GridBagLayout</TT> should add
to the size of a component. Figure 8.11 shows the result of adding
internal padding to buttons 1 and 2 by setting <TT>ipadx</TT>
and <TT>ipady</TT> to <TT>50</TT>.
<TT>GridBagLayout</TT> expands the
cell size of the grid to accommodate the buttons. Figure 8.12
shows the result of enlarging the window in Figure 8.11. Button
1 keeps its size, and button 2 fills its display area.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-11.gif" ><B>Figure 8.11 : </B><I>Layout with ipadx set to 50 pixels for buttons 1 and 2 (before enlargement of the window by the user)</I></A><I>.</I>
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-12.gif" ><B>Figure 8.12 : </B><I>Enlarged window with ipadx set to </I>50<I> pixels for buttons 1 and 2.</I></A>
<P>
In addition to adding to the size of widgets, you can instruct
<TT>GridBagLayout</TT> to add external
padding to the components. <TT>GridBagLayout</TT>
will then maintain a minimum amount of space around the component.
Figure 8.13 shows the result of setting <TT>insets</TT>
to <TT>new Insets(20,20,20,20)</TT>.
<TT>GridBagLayout</TT> inserts 20
pixels of space between the component and its display area. In
this case, <TT>GridBagLayout</TT>
expands the cell size to accommodate the padded components. When
the user enlarges the window, <TT>GridBagLayout</TT>
maintains the padding space when adjusting the component sizes.
Figure 8.14 shows the layout after enlargement of the window.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-13.gif" ><B>Figure 8.13 : </B><I>Layout with </I>insets<I> set to </I>20<I> pixels on a each side of buttons 1 and 2 (before enlargement of the window by the user).</I></A>
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-14.gif" ><B>Figure 8.14 : </B><I>Enlarged window with </I>insets<I> set to </I>20<I> pixels on each side of buttons 1 and 2.</I></A>
<P>
Once you learn how to use the variables of <TT>GridBagConstraints</TT>,
creating larger layouts is straightforward. To succeed in specifying
larger layouts, however, you must carefully plan and design the
layout before you begin assigning values to variables of <TT>GridBagConstraints</TT>.
<H2><A NAME="CreatingYourOwnLayoutManager"><FONT SIZE=5 COLOR=#FF0000>Creating
Your Own Layout Manager</FONT></A></H2>
<P>
In certain situations, you may want to create your own layout
manager. Fortunately, the AWT package enables programmers to implement
new layout managers. For instance, if none of the available standard
layout manager classes provide the functionality you need, you
can develop new layout managers that perform the required task.
Because the <TT>GridBagLayout</TT>
class is complex and somewhat difficult to use, you might have
some ideas for simple, yet powerful, layout managers that work
better for your layout job. You and others can then reuse these
layout managers in several applets and applications.
<P>
There are two basic strategies for creating a layout manager.
The first strategy is to subclass a preexisting layout manager.
Here, your subclass implements the required functionality by modifying
the behavior of the basic layout manager class. The second strategy
is to create a new layout manager from scratch. In this approach,
you develop your layout manager by creating a class that implements
the LayoutManager interface.
<P>
The advantage of subclassing a standard layout manager class is
that you can take advantage of the methods defined in the standard
layout manager by inheriting them. However, the design of these
standard classes is not very &quot;open.&quot; It is difficult
to reuse code in layout managers because a monolithic method,
<TT>layoutContainer(Container)</TT>,
is responsible for performing the layout calculations. Basically,
you have to rewrite this method for each layout manager you develop
by subclassing standard layout managers.
<P>
Given the difficulties of modifying the behavior of layout classes
by subclassing them, you might as well develop a new layout manager
class that implements the LayoutManager interface. Using this
strategy, you can even create your own hierarchy of layout manager
classes, which inherit properties among each other.
<P>
The LayoutManager interface specifies methods for adding named
components to the layout, removing components from the layout,
calculating minimum and preferred layout sizes, and computing
the layout. Table 8.3 describes the methods in the LayoutManager
interface. Note that the LayoutManager is an interface with abstract
methods; therefore, you must define them in your layout manager.
<BR>
<P>
<CENTER><B>Table 8.3. LayoutManager methods.</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 80%>
<TR><TD WIDTH=202><B>LayoutManager Method</B></TD><TD WIDTH=186><B>Description</B>
</TD><TD WIDTH=202><B>Parameters</B></TD></TR>
<TR><TD WIDTH=202><TT>addLayoutComponent<BR>(String, Component)</TT>
</TD><TD WIDTH=186>Adds a new component to the layout</TD><TD WIDTH=202>A string describing the component name and the component
</TD></TR>
<TR><TD WIDTH=202><TT>layoutContainer<BR>(Container)</TT>
</TD><TD WIDTH=186>Lays out a container</TD><TD WIDTH=202>The container to lay out
</TD></TR>
<TR><TD WIDTH=202><TT>minimumLayoutSize<BR>(Container)</TT>
</TD><TD WIDTH=186>Calculates the minimum size</TD><TD WIDTH=202>The container in question
</TD></TR>
<TR><TD WIDTH=202><TT>preferredLayoutSize<BR>(Container)</TT>
</TD><TD WIDTH=186>Calculates the preferred size</TD><TD WIDTH=202>The container in question
</TD></TR>
<TR><TD WIDTH=202><TT>removeLayoutComponent<BR>(Component)</TT>
</TD><TD WIDTH=186>Removes a component from the layout</TD><TD WIDTH=202>The component to remove
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Here's an example of how you can create a layout manager that
lays out components diagonally:
<BLOCKQUOTE>
<TT>class DiagonalLayout extends Object implements
LayoutManager {<BR>
<BR>
&nbsp;&nbsp;public void addLayoutComponent(String name, Component
comp) {<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void removeLayoutComponent(Component comp)
{<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public Dimension preferredLayoutSize(Container parent)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int l = parent.countComponents();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Rectangle r = parent.getComponent(l-1).bounds();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return new Dimension(r.x + r.width, r.y
+ r.height);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public Dimension minimumLayoutSize(Container parent)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return preferredLayoutSize(parent);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void layoutContainer(Container parent) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int l = parent.countComponents();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; l; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component c = parent.getComponent(i);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.move(50*i,50*i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
In this layout manager, the <TT>layoutContainer</TT>
method iterates over the components and moves each component to
the appropriate location (which is determined by the component
index). The layout manager calculates the preferred size by getting
the lower-right corner of the last component (which is the same
as the size). Figure 8.15 shows the resulting layout for a container
with seven buttons. Although this layout manager does not change
the layout dynamically as the user resizes the window, you can
easily modify it to do so.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f8-15.gif" ><B>Figure 8.15 : </B><I>Layout generated by </I>DiagonalLayout.</A>
<P>
As you have seen, implementing a new layout manager is also a
straightforward task. What is more difficult, however, is to design
a layout manager that is both powerful and easy to use. The advantage
of the AWT design is that once you have developed an appropriate
layout manager, it is easy to reuse it for many situations.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Layout managers automate the layout task by calculating window
layouts dynamically. The AWT provides predefined managers that
you can configure to get the window resizing behavior you want.
For simple layout tasks, the <TT>FlowLayout</TT>,
<TT>BorderLayout</TT>, <TT>GridLayout</TT>,
and <TT>CardLayout</TT> managers work
best. For advanced layout tasks, the powerful and general <TT>GridBagLayout</TT>
manager is better than the basic layout managers. If these layout
managers are insufficient for your task, the AWT enables you to
define new layout managers.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch7.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

