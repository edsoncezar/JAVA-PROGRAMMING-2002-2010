<HTML>

<HEAD>
   <TITLE>Chapter 29 -- Using Tcl with Java</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 29</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using Tcl with Java</B></FONT></H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT SIZE=2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></H3>

<UL>
<LI><A HREF="#IntroductiontoTcl" >Introduction to Tcl</A>
<LI><A HREF="#WhatDoesThisHavetoDowithJava" >What Does This Have to Do with Java?</A>
<LI><A HREF="#TheTclJavaAPI" >The TclJava API</A>
<LI><A HREF="#UserMenuConfiguration" >User Menu Configuration</A>
<LI><A HREF="#OtherUsefulRolesforTcl" >Other Useful Roles for Tcl</A>
<LI><A HREF="#TclExtensionPackages" >Tcl Extension Packages</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Many applications, both large and small, provide some sort of
customization or configuration language. Such languages are used
for storing user preferences, defining toolbars or configurable
menus, writing macros, or even writing custom extensions. In many
cases, these auxiliary languages are hidden from users by configuration
dialogs, and they may not even be documented, but they are still
there behind the scenes. These application configuration and customization
languages are examples of scripting languages. Examples you may
be familiar with include AppleScript, its predecessor HyperTalk
(the language behind Apple's HyperCard system), various incarnations
of LotusScript (used for macros or more extensive extensions in
several Lotus programs, including 1-2-3, Word Pro, and Notes),
WordBasic (Microsoft Word's macro language), and the DOS batch-file
language.
<P>
This chapter explains how to use one particular scripting language,
Tcl, with your Java applications. Tcl was chosen for four reasons:
<UL>
<LI>It is freely available and well supported.
<LI>A reasonable interface between Tcl and Java exists.
<LI>Like Java, Tcl runs on Windows, Macintosh, and UNIX platforms.
<LI><FONT COLOR=#000000>It was designed to be a reusable, application-independent
scripting language.</FONT>
</UL>
<P>
Other scripting languages such as JavaScript or Python might also
work well with Java, but none share all these characteristics
as of this writing. Additionally, although other scripting languages
might excel at particular kinds of tasks, I believe that Tcl strikes
the best balance among the several different roles that scripting
languages are often asked to fill. However, many of the general
statements in this chapter about the benefits of using a reusable
scripting language will apply to other such languages (<A HREF="ch27.htm" >see Chapter 27</A>,
&quot;Alternatives to Java,&quot; for a discussion of several
other scripting languages).
<P>
The version of the TclJava API described here is version 0.1.
Obviously, the interface will change and grow. Rather than spending
too much time documenting every detail of an early beta release
of the API, this chapter concentrates on the general approach
of using Tcl (and scripting languages in general) with Java and
the benefits of that approach.
<H2><A NAME="IntroductiontoTcl"><B><FONT SIZE=5 COLOR=#FF0000>Introduction
to Tcl</FONT></B></A></H2>
<P>
It's common for configuration or command languages to be custom-designed
for individual applications. This has several disadvantages:
<UL>
<LI>Because the developers are primarily interested in the application
functionality rather than the language, the languages are usually
quirky and nearly always weak and inflexible.
<LI>The developers spend a lot of time designing and developing
the new language, when they could be devoting that time to making
the application better.
<LI><FONT COLOR=#000000>Because each new application a user encounters
has its own unique language, users either must spend a lot of
time learning and relearning a slew of application scripting languages
or (far more likely) give up and learn none of them, thereby sacrificing
some of the power of their applications.</FONT>
</UL>
<P>
Tcl was designed as a solution to these problems. The name stands
for &quot;tool command language,&quot; and Tcl was designed from
the start for that role. It was intended to be a reusable, application-neutral
language that could be used by a wide variety of applications
as a configuration, customization, extension, or command language.
The author and designer, John Ousterhout, had been involved in
the design of several applications and had grown increasingly
frustrated by the distraction of having to design new languages
for each of them, by the inadequacies of the resulting languages,
and by the burden that the proliferation of languages placed on
end users. Tcl is his answer.
<P>
Tcl is a simple language, oriented around strings and commands.
Rather than having several different data types, Tcl represents
all values as character strings, and instead of the usual combination
of statements, procedures, functions, and expressions, Tcl code
consists almost entirely of commands. Even control structures
such as <TT>for</TT> and <TT>while</TT>
loops are simply commands. In these respects, Tcl is reminiscent
of the UNIX shells or the DOS batch-file language, but it is superior
in many ways.
<P>
Tcl is implemented as a library, so applications written in languages
such as C or Java can embed Tcl and use it as a scripting language.
An important part of that embedding process is creating new, application-specific
Tcl commands that can be used by Tcl scripts to control the application
or query its current state.
<P>
One crucial aspect of Tcl's design is that application-specific
extensions exist on an equal footing with the built-in Tcl facilities,
instead of being &quot;second-class citizens.&quot; This gives
the application developer maximum freedom in designing the interface
between the application and Tcl. It's possible to provide application-specific
control structures that iterate over some part of the application's
data or structure in some useful way. The application also can
create &quot;magic&quot; Tcl variables that directly represent
portions of the application's state (the Tcl interpreter ties
such variables either to C variables or to C accessor functions
that are responsible for getting and setting the value).
<P>
Like Java, Tcl is a secure language. Tcl enables you to create
&quot;padded room&quot; environments in which all potentially
dangerous commands have been removed or replaced by safe alternatives.
Such environments can be used to execute Tcl code that comes from
untrusted sources.
<P>
Many applications (including a growing number of commercial programs)
make use of Tcl for a wide range of tasks, including site-wide
configuration, user configuration and customization, third-party
extensions, data storage, and user interface development. Recent
releases of Tcl work on Windows, Macintosh, and UNIX platforms.
<P>
The Tcl home page is at the following address:
<BLOCKQUOTE>
<TT><A HREF="http://www.smli.com/research/tcl/">http://www.smli.com/research/tcl/</A></TT>
</BLOCKQUOTE>
<H2><A NAME="WhatDoesThisHavetoDowithJava"><B><FONT SIZE=5 COLOR=#FF0000>What
Does This Have to Do with Java?</FONT></B></A></H2>
<P>
Because Java is an interpreted, cross-platform language, and especially
because it's a relatively high-level language (with sophisticated
string handling and built-in data structures, for example), some
have reached the conclusion that there's no point in using a scripting
language in conjunction with Java. Depending on the details of
their applications, they may be right. But in most cases, a scripting
language such as Tcl can still be extremely useful in a Java application,
because Java has several characteristics that make it ideal for
application development, but not so great for the kinds of things
at which scripting languages excel.
<P>
Variable declarations, static type checking, classes, and packages
all make it easier for developers to manage the complexity of
a large software project, but such features get in the way when
you just want to write a 40-line convenience script or when writing
something (such as a user interface prototype) that will be changed
numerous times to try different approaches. Java code is compiled
in the interest of performance, but that compilation step is a
nuisance when performance of the code isn't really a priority.
(Site administrators hate having to compile a configuration file
after every edit when they are trying to get an application's
configuration just right!)
<P>
Finally, Java is a complex language and somewhat unusual for most
users. Users are not programmers, and they are usually not interested
in becoming programmers. Many application users have some familiarity
with simple, command-oriented languages such as the following:
<BLOCKQUOTE>
<TT>SET PATH = C:\DOS;C:\WINDOWS</TT>
</BLOCKQUOTE>
<P>
Scripting languages are usually much better languages than that,
but they are in the same simple spirit, and that's helpful to
application users.
<P>
If you're still skeptical about whether scripting languages really
have a place in the Java world, take a look at the following three
applets that make use of special-purpose scripting languages:
<UL>
<LI>LED Sign is a Java mock-up of those LED-based programmable
signs that you occasionally see in banks or lunch counters advertising
current special offers. To make things easier on authors who want
to use LED Sign in their Web pages, the applet provides its own
scripting language (written in Java) for specifying text to be
displayed, delays, colors, transition, and scrolling effects.
LED Sign is found at the following address:
</UL>
<BLOCKQUOTE>
<TT><A HREF="http://www.cs.hope.edu/~dbrown/java/LEDSign/WWW/LED.html">http://www.cs.hope.edu/~dbrown/java/LEDSign/WWW/LED.html</A></TT>
</BLOCKQUOTE>
<UL>
<LI>Clickboard is a reusable interactive animation applet that
animates objects against a static background. The animated objects
can be programmed to move in response to mouse events. The background,
animations, and responses to several different kinds of events
are specified using a special scripting language, supplied with
the applet. Clickboard is found at the following address:
</UL>
<BLOCKQUOTE>
<TT><A HREF="http://users.aimnet.com/~foureyes/clickboard/ClickBoard.html">http://users.aimnet.com/~foureyes/clickboard/ClickBoard.html</A></TT>
</BLOCKQUOTE>
<UL>
<LI>Movie is another programmable animation applet, with frame
rate, sequence, and other characteristics controlled through a
special scripting language rather than the usual array of HTML
<TT>PARAM</TT> tags. Movie is found
at the following address:
</UL>
<BLOCKQUOTE>
<TT><A HREF="http://www.cybercomm.net/~drz/java/movie/">http://www.cybercomm.net/~drz/java/movie/</A></TT>
</BLOCKQUOTE>
<P>
In each case, the applet-specific scripting language is just what
you might expect: weak and quirky, just enough to accomplish the
tasks the author had in mind with a minimum of implementation
effort and no more. The authors of those applets shouldn't be
blamed for that; their main interest was in writing the useful
applet, not in implementing a scripting language, and that's just
the way it should be. They should have been able to use an existing
scripting language rather than having to invent new ones.
<P>
Perhaps in response to applets such as these, another programmer
has implemented a reusable, generic scripting language in Java.
Yassl (yet another simple scripting language) is a much better
language than these specialized applet control languages, and
it might meet your needs quite well. It can be found at the following
address:
<BLOCKQUOTE>
<TT><A HREF="http://www.blackdown.org/~kbs/yassl/yassl.html">http://www.blackdown.org/~kbs/yassl/yassl.html</A></TT>
</BLOCKQUOTE>
<P>
Finally, Netscape's JavaScript language, although currently available
only as an integral part of Netscape's Navigator software, is
supposed to be available soon as a reusable, embeddable scripting
language that interfaces to Java.
<P>
That makes three specialized applet configuration languages and
two more general scripting languages (Yassl and JavaScript). At
the time of this writing, Java has been available to the public
for less than a year, and five new scripting languages have already
been designed to work with Java applets and applications. A common
scripting language available to Java applications would be a real
benefit.
<H2><A NAME="TheTclJavaAPI"><B><FONT SIZE=5 COLOR=#FF0000>The
TclJava API</FONT></B></A></H2>
<P>
The interface between Tcl and Java is quite small and easy to
understand. It will no doubt grow larger as it matures, enabling
Java programmers access to more of Tcl's special facilities, but
the central core of the API will probably always be simple, reflecting
the simplicity of Tcl itself. The important concepts of the interface
are represented by just two classes: <TT>Command</TT>
and <TT>Interp</TT>.
<H3><B>Commands and Interpreters</B></H3>
<P>
<TT>Command</TT> objects represent
Tcl commands. To write a new Tcl command in Java, create a subclass
of <TT>Command</TT> and override the
<TT>invoke</TT> method. Here's an
example of a command called <TT>Echo</TT>,
which simply writes its arguments to standard output:
<BLOCKQUOTE>
<TT>import tcl.*;<BR>
<BR>
public class<BR>
EchoCommand extends Command<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public int<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;invoke
(Interp mytcl, Value args[]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Skip args[0],
which is the command name ...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(int i=1; i &lt; args.length; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.print((i&gt;0 ? &quot; &quot; : &quot;&quot;) + args[i]);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_OK;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Instances of the <TT>Interp</TT> class
represent Tcl interpreters (it's possible, and often useful, to
have multiple distinct interpreters in a single application).
Upon creation, the interpreter will be automatically initialized
with the built-in Tcl commands. Once you create an interpreter
and implement a new subclass of <TT>Command</TT>,
you can install the command in the interpreter using the interpreter's
<TT>createCommand</TT> method, supplying
an instance of the command object along with the command name:
<BLOCKQUOTE>
<TT>Interp mytcl = new Interp();<BR>
mytcl.createCommand(&quot;echo&quot;, new EchoCommand());</TT>
</BLOCKQUOTE>
<P>
You can install any number of new commands in an interpreter.
<H3><B>Invoking the Interpreter</B></H3>
<P>
Creating an interpreter and installing new commands are just preparation,
of course. Once these are done, you have to supply some code for
the interpreter to execute. The interpreter's <TT>eval</TT>
method accepts Tcl code as a parameter (a string) and evaluates
it:
<BLOCKQUOTE>
<TT>Result result = new Result();<BR>
mytcl.eval(&quot;echo apple peaches mango kumquat&quot;, result);</TT>
</BLOCKQUOTE>
<P>
If the <TT>EchoCommand</TT> class
shown previously is installed correctly, it is invoked with four
arguments and prints them. Because it doesn't return a useful
result, the value in the <TT>result</TT>
variable can simply be ignored. (The value actually returned from
<TT>eval</TT> is an integer that indicates
whether the command executed successfully.)
<P>
Believe it or not, you've covered the basics of the TclJava API.
There are some things omitted, of course, including a way to add
the Tk user interface toolkit (a popular Tcl extension) into the
interpreter. We'll cover some of those details later, but you
now know the fundamental mechanisms for embedding Tcl in Java
applications.
<H3><B>What Next?</B></H3>
<P>
Taken together, the preceding code fragments seem rather pointless.
First a new Tcl command is created and then an interpreter. The
command is installed in the interpreter and then invoked. Why
bother with a scripting language if that's all you're going to
do with it?
<P>
Recall that the point of doing all this is to give users or site
administrators some control over the configuration or operation
of the program without requiring them to write Java code and modify
parts of the program itself. There are two ways in which the examples
so far are unrealistic:
<UL>
<LI>The new command has nothing to do with a particular Java application-it
doesn't provide any new application control mechanism at all.
<LI><FONT COLOR=#000000>There is no hook on which users can hang
their code. Users can write all the Tcl code they want, but it
won't do them any good if the application never invokes it.</FONT>
</UL>
<P>
The next section provides a more realistic example.
<H2><A NAME="UserMenuConfiguration"><B><FONT SIZE=5 COLOR=#FF0000>User
Menu Configuration</FONT></B></A></H2>
<P>
Many graphical applications provide a user-definable menu or toolbar,
permitting users to choose certain operations for easy access.
This is especially useful in very complicated applications where
some operations might appear three levels deep in cascaded menus,
for example.
<P>
Applications that provide such a facility might require the user
to build a menu definition file by hand, or they might provide
an interactive mechanism. In the first case, some comprehensible
file format is essential, and even in the second case it can be
useful. Just because you use Tcl doesn't mean you have to force
your users to learn it and build their own configuration files
by hand. Even if you provide thorough interactive configuration
dialogs, using Tcl as a storage format can save you trouble, and
you'll be surprised how often it comes in handy to have access
to a full-fledged scripting language in your configuration files.
<P>
This example shows how to add a menu definition facility to an
application. In the interest of keeping the example reasonably
short, the facility is restrictive: Users can only add items to
one menu that is set aside for their use (I've given it the label
&quot;Quick&quot;), and cascaded submenus are not allowed. However,
the example does support a simple extension facility, so a user
menu item can represent a composite of several built-in menu actions
performed in sequence.
<H3><B>The Menu Definition File</B></H3>
<P>
Before going into the details of the implementation, we should
decide what the menu definition file is going to look like. We
don't really have to design a syntax (Tcl takes care of that),
but we do need to know what new Tcl commands we should implement.
<P>
I've chosen to implement just one command, <TT>quickmenu</TT>,
with five subcommands to implement particular actions:<BR>

<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD WIDTH=109><TT>add</TT></TD>
<TD WIDTH=482>Adds a new item to the menu.</TD></TR>
<TR><TD WIDTH=109><TT>separator</TT>
</TD><TD WIDTH=482>Adds a separator bar to the menu to group related items visually.
</TD></TR>
<TR><TD WIDTH=109><TT>actions</TT>
</TD><TD WIDTH=482>Returns a list of all the actions that the application supports as menu items.
</TD></TR>
<TR><TD WIDTH=109><TT>script</TT>
</TD><TD WIDTH=482>Adds a new item that invokes a Tcl script when the menu item is selected.
</TD></TR>
<TR><TD WIDTH=109><TT>invoke</TT>
</TD><TD WIDTH=482>Adds nothing to the menu-instead, it immediately invokes one of the available actions. This is meant for use in procedures that are attached to the menu using <TT>script</TT>.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Here's an example of a menu definition file that uses all the
subcommands (although it doesn't do anything intelligent with
<TT>actions</TT>). The actions in
the example would be appropriate for a word processor:
<BLOCKQUOTE>
<TT># This is Tcl, not Java!<BR>
<BR>
# Add the &quot;Insert Date&quot; action to our menu:<BR>
quickmenu item &quot;Insert Date&quot;<BR>
<BR>
# Now add a separator bar.<BR>
quickmenu separator<BR>
<BR>
# Get the list of valid actions ...<BR>
set actionlist [quickmenu actions]<BR>
# ... but don't bother to do anything with it.<BR>
<BR>
# Add a custom menu item which invokes the notepar proc, defined
below.<BR>
quickmenu script Note notepar<BR>
<BR>
# Here's the notepar proc.&nbsp;&nbsp;It formats the current paragraph
<BR>
# specially: right aligned and bold.<BR>
proc notepar {} {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;quickmenu
invoke &quot;Select paragraph&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;quickmenu invoke &quot;Align right&quot;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;quickmenu
invoke &quot;Bold&quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;quickmenu invoke &quot;Unselect&quot;
<BR>
}</TT>
</BLOCKQUOTE>
<H3><B>Implementing the </B><TT><B><FONT SIZE=4 >quickmenu</FONT></B></TT><B><FONT SIZE=4>
Command</FONT></B></H3>
<P>
The next job is to implement and install the <TT>quickmenu</TT>
command. In order to do its job, the command needs to know about
the menu object it can add items to and the list of actions that
the application supports, so we put those in instance variables.
<P>
The list of actions will be primarily used for <TT>item</TT>
and <TT>invoke</TT> subcommands; the
implementation needs to see whether the specified action is valid
before carrying out the request. If many actions are supported,
such checks will be much more efficient if the list is stored
as a hash table, rather than a simple array or vector of strings.
For this purpose, it's not important what values are stored with
the keys in the hash table; the only thing you care about is whether
a particular key is in the table.
<P>
The list will also be used to implement the <TT>actions</TT>
subcommand. That will be a slower operation using a hash table,
but it's reasonable to expect <TT>item</TT>
and <TT>invoke</TT> to be much more
frequent operations than <TT>actions</TT>,
so a hash table seems like a reasonable trade-off.
<P>
With those decisions made, we can write the basic form of the
<TT>QuickMenuCommand</TT> class as
shown in Listing 29.1.
<HR>
<BLOCKQUOTE>
<B>Listing 29.1. QuickMenuCommand overview (QuickMenuCommand.java
part 1).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*<BR>
&nbsp;* QuickMenuCommand.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.0 96/03/25 Glenn Vanderburg<BR>
</TT>&nbsp;<TT>*/<BR>
<BR>
package COM.MCP.Samsnet.tjg;<BR>
<BR>
import java.awt.*;<BR>
import java.util.*;<BR>
import tcl.*;<BR>
<BR>
/**<BR>
&nbsp;* An example Tcl command. Provides facilities for users
to<BR>
</TT>&nbsp;<TT>* define a special,
customizable menu in an application.<BR>
&nbsp;*<BR>
</TT>&nbsp;<TT>* Although this class
is complete, it requires special support<BR>
&nbsp;* in an application to work properly.<BR>
</TT>&nbsp;<TT>*<BR>
&nbsp;* @version&nbsp;&nbsp;&nbsp;&nbsp; 1.0, 25 Mar 1996<BR>
</TT>&nbsp;<TT>* @author&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glenn
Vanderburg<BR>
&nbsp;*/<BR>
<BR>
public<BR>
class QuickMenuCommand extends Command<BR>
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
The menu we can modify<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Menu quickmenu;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
The set of valid actions for the menu<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Hashtable actions;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
* Creates a new QuickMenuCommand instance<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param qm the menu for the command
to modify<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
* @param actions the set of valid actions for the menu<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;QuickMenuCommand(Menu qm, Hashtable actions)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickmenu
= qm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.actions =
actions;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// It may be useful to provide alternate
constructors which<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
take the action list as an array or vector of strings.<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
</TT><FONT FACE="MCPdigital-I">Method: public int invoke(Interp
interp, Value args[])&nbsp;&nbsp;&nbsp;&nbsp; Listing 29.2<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">Method:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
args_error(String msg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Listing
29.3<BR>
</FONT><TT>}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>invoke</TT> method is where
the work of the command takes place. It is fairly straightforward,
but because it has to provide for five different subcommands,
it's somewhat long.  Listing 29.2 shows the <TT>invoke</TT>
method.
<HR>
<BLOCKQUOTE>
<B>Listing 29.2. QuickMenuCommand invoke method (QuickMenuCommand.java
part 2).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/**<BR>
&nbsp;* Processes the command.&nbsp;&nbsp;Determines the subcommand,
<BR>
</TT>&nbsp;<TT>* validates parameters,
and performs appropriate actions.<BR>
&nbsp;* @param interp the Tcl interpreter<BR>
</TT>&nbsp;<TT>* @param args the arguments
to the command<BR>
&nbsp;*/<BR>
public int<BR>
invoke(Interp interp, Value args[]) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (args.length == 1) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, NO_SUBCOMMAND);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(&quot;item&quot;.equals(args[1])) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (args.length
!= 3) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, WRONG_ITEM);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(actions.containsKey(args[2].toString())) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickmenu.add(new
MenuItem(args[2].toString()));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_OK;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interp.setResult(new
Value(&quot;invalid item: &quot; + args[2]));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_ERROR;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else if (&quot;separator&quot;.equals(args[1]))
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(args.length != 2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, WRONG_SEPARATOR);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickmenu.addSeparator();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_OK;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
if (&quot;actions&quot;.equals(args[1])) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (args.length
!= 2) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, WRONG_ACTIONS);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Build a Tcl list of the actions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String list =
&quot;{ &quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
(&nbsp;&nbsp;&nbsp;&nbsp;Enumeration keys = actions.keys();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
keys.hasMoreElements();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list
+= &quot;{&quot; + keys.nextElement() + &quot;} &quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list += &quot;}&quot;;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interp.setResult(new
Value(list));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Interp.TCL_OK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else if (&quot;script&quot;.equals(args[1]))
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(args.length != 4) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, WRONG_SCRIPT);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We use a special
MenuItem for this (see below)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickmenu.add(new
TclScriptMenuItem(args[2].toString(),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs
p;&nbsp;args[3].toString()));
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_OK;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
if (&quot;invoke&quot;.equals(args[1])) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (args.length
!= 3) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
args_error(interp, WRONG_INVOKE);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(actions.containsKey(args[2].toString())) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
To pull this off, we have to generate a fake event.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Furthermore, since the requested action isn't required<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
to be an item on the menu (just a valid action) we must<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
create a MenuItem which will only last long enough to<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
serve as the trigger for this invocation.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event
evt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evt
= new Event(new MenuItem(args[2].toString()),<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event.ACTION_EVENT,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[2].toString());
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickmenu.postEvent(evt);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_OK;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interp.setResult(new
Value(&quot;invalid action: &quot; + args[2]));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Interp.TCL_ERROR;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return args_error(interp,
BAD_SUBCOMMAND);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The only really tricky part about that code is the implementation
of the <TT>invoke</TT> subcommand.
In a real application, there would almost certainly be a cleaner
way to execute an action than by faking a menu invocation.
<P>
Before moving on to the <TT>TclScriptMenuItem</TT>
class (used in the implementation of the <TT>script</TT>
subcommand), let's finish <TT>QuickMenuCommand</TT>
by supplying the <TT>args_error</TT>
method, shown in Listing 29.3. Its only purpose is to supply the
appropriate Tcl result in event of an error, to keep the code
for the <TT>invoke</TT> method a little
cleaner.
<HR>
<BLOCKQUOTE>
<B>Listing 29.3. QuickMenuCommand args_error method (QuickMenuCommand.java
part 3).<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>static final String NO_SUBCOMMAND =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu subcommand ...\&quot;&quot;;
<BR>
static final String WRONG_ITEM =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu item itemname\&quot;&quot;;<BR>
static final String WRONG_SEPARATOR =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu separator\&quot;&quot;;<BR>
static final String WRONG_ACTIONS =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu actions\&quot;&quot;;<BR>
static final String WRONG_SCRIPT =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu script label scriptstring\&quot;&quot;;
<BR>
static final String WRONG_INVOKE =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;wrong #
args: should be \&quot;quickmenu invoke itemname\&quot;&quot;;
<BR>
static final String BAD_SUBCOMMAND =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;invalid
subcommand: should be one of &quot;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+
&quot;item, separator, actions, command, invoke&quot;;<BR>
<BR>
/**<BR>
&nbsp;* Performs error handling for the &quot;invoke&quot; method.
<BR>
</TT>&nbsp;<TT>* Sets an appropriate
message in the interpreter result,<BR>
&nbsp;* and returns an error code.<BR>
</TT>&nbsp;<TT>* @param msg the message
describing the error.<BR>
&nbsp;*/<BR>
int<BR>
args_error(Interp interp, String msg) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;interp.setResult(new
Value(msg));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return Interp.TCL_ERROR;<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Now there's just one more thing before we can wrap up the <TT>quickmenu</TT>
command and install it: the <TT>TclScriptMenuItem</TT>
class that we used in the implementation of the <TT>script</TT>
subcommand. It's really just an extension of <TT>MenuItem</TT>
that maintains a Tcl script string as an instance variable. The
main application menu handling code takes care of the rest (see
the next section). Listing 29.4 shows the <TT>TclScriptMenuItem</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 29.4. TclScriptMenuItem.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*<BR>
&nbsp;* TclScriptMenuItem.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.0 96/03/25 Glenn Vanderburg<BR>
</TT>&nbsp;<TT>*/<BR>
<BR>
package COM.MCP.Samsnet.tjg;<BR>
<BR>
import java.awt.*;<BR>
import tcl.*;<BR>
<BR>
/**<BR>
</TT>&nbsp;<TT>* An extension of MenuItem
which causes a Tcl script to be run when invoked.<BR>
&nbsp;*<BR>
</TT>&nbsp;<TT>* @version&nbsp;&nbsp;&nbsp;&nbsp;
1.0, 25 Mar 1996<BR>
&nbsp;* @author&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Glenn Vanderburg
<BR>
</TT>&nbsp;<TT>*/<BR>
<BR>
public<BR>
class TclScriptMenuItem extends MenuItem<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// The script to be run for this menu
item.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
String script;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;/**
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * Creates a new TclScriptMenuItem.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
* @param label the label string for the menu item<BR>
&nbsp;&nbsp;&nbsp;&nbsp; * @param script the Tcl script to be
run when this menu item is invoked.<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
*/<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;TclScriptMenuItem(String
label, String script) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(label);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.script
= script;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/**<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;
* Returns the Tcl script associated with this menu item.<BR>
&nbsp;&nbsp;&nbsp;&nbsp; */<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
String<BR>
&nbsp;&nbsp;&nbsp;&nbsp;getScript() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
script;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
Now the <TT>quickmenu</TT> command
is done and ready to be installed. During application initialization,
after the <TT>Menu</TT> object for
the quick menu and the hash table with all the valid actions have
been created, the application should create a Tcl interpreter,
create an instance of <TT>QuickMenuCommand</TT>,
and install it as a new Tcl command:
<BLOCKQUOTE>
<TT>Interp tcl = new Interp();<BR>
tcl.createCommand(&quot;quickmenu&quot;, new QuickMenuCommand(quickmenu,
actions));</TT>
</BLOCKQUOTE>
<H3><B>Application Support for </B><TT><B><FONT SIZE=4 >quickmenu</FONT></B></TT>
</H3>
<P>
The <TT>QuickMenuCommand</TT> class
provides the support we need for the menu definition file-actually
defining the menu and providing a way to learn what actions are
allowable in it. However, the command mostly just stores information
and modifies the state of the menu. Other parts of the application
must cooperate to make it all work.
<P>
First, of course, the application must create the menu and install
it in the menu bar. It might start out empty, or it might have
a small number of predefined entries (possibly including a &quot;What's
this?&quot; entry that explains what the menu is and how to customize
it). The application must also create the hash table of valid
actions. We'll return to that soon.
<P>
The largest part of the application's responsibility is actually
invoking the menu actions when a user chooses them. All the details
of menu handling are not explained here, but typically, menu selections
are processed by the <TT>action</TT>
method of some component that contains the menu. When a menu item
is selected, an action event is posted to that component, which
passes the event to the <TT>action</TT>
method, along with the event's argument (in the case of menu items,
the argument is usually the item's label string). In simple applications,
the <TT>action</TT> method examines
the label string to decide what action to take. If we only supported
the built-in actions, that would be easy, but the user-definable
actions that invoke Tcl scripts make things a little more complicated.
You need to check for those specially, before processing built-in
actions. Here's a simplified example of an <TT>action</TT>
method that could be used for the application frame that contains
the quick menu:
<BLOCKQUOTE>
<TT>public boolean<BR>
action(Event evt, Object arg)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// For simplicity, assume that the &quot;tcl&quot;
package is imported<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Handle TclScriptMenuItems specially
...<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(evt.target instanceof TclScriptMenuItem) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Result result
= new Result();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Assume we have
the Tcl interpreter available as &quot;tcl&quot;,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
and use it to invoke the script ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int code = tcl.eval(evt.target.getScript(),
result);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(code != Interp.TCL_OK) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
</TT><FONT FACE="MCPdigital-I">code to indicate that the
script had an error<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
if (&quot;Align right&quot;.equals(arg)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code
to process &quot;Align right&quot; action<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else if (&quot;Bold&quot;.equals(arg))
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
</TT><FONT FACE="MCPdigital-I">code to process &quot;Bold&quot;
action<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else
if (&quot;Insert Date&quot;.equals(arg)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code
to process &quot;Insert Date&quot; action<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">...
and so on for all valid actions<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;else {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code
to signal an invalid action<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You may have noticed that the sample <TT>action</TT> method will be very inefficient if there are a lot of actions. Because this chapter is not really about menu and event processing, I wanted to keep the code simple and obvious. For the curious, here's 
one idea for improving the efficiency of the method.
</BLOCKQUOTE>
<BLOCKQUOTE>
For the <TT>quickmenu</TT> command, we have to prepare a hash table of valid actions. The command doesn't use the values in the hash table, however; it uses only the keys. Therefore, we can make use of the hash table, too. For each valid action, we can 
define a <TT>static</TT> <TT>final</TT> <TT>int</TT> code in some appropriate class (let's assume the class is called <TT>SpiffyApp</TT>) and store the matching integer code in the hash table along with the action label:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>actions.put(&quot;Align right&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Integer(SpiffyApp.ALIGN_RIGHT_ACTION));</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Then, instead of comparing the event argument against all the valid actions until we get a match, we can just switch on the value in the hash table:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Integer action_code = actions.get(arg);<BR>
if (action_code != null) {</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;switch (action_code.intValue()) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SpiffyApp.ALIGN_RIGHT_ACTION:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code to process &quot;Align right&quot; action
<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SpiffyApp.BOLD_ACTION:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code to process &quot;Bold&quot; action
<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SpiffyApp.INSERT_DATE_ACTION:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code to process &quot;Insert Date&quot; action
<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">... and so on for all valid actions
<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;default:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// something went wrong!&nbsp;&nbsp;There's an action in the list<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that we don't understand.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">Throw some exception here.
<BR>
</FONT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code to signal an invalid action
<BR>
</FONT><TT>}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This approach is much more efficient. If we choose to go this route, however, we should make one more change and give the <TT>QuickMenuCommand</TT> instance a copy of our hash table rather than the original.  This will protect us in case a future change to 
<TT>QuickMenuCommand</TT> requires that it change its hash table:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>tcl.createCommand(&quot;quickmenu&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new QuickMenuCommand(quickmenu,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions.clone()));</TT
>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now that the application can handle our menu items correctly,
we're finally finished adding a user-definable menu facility to
our application. Well, almost. There's just one more thing.
<H3><B>Finding and Running the Definition File</B></H3>
<P>
When I presented the first small example using the <TT>echo</TT>
command, I mentioned that there were two ways in which it was
unrealistic: The command didn't really have anything to do with
the special functionality of the application, and there was no
way for users to supply custom Tcl code. Everything we've done
so far for the <TT>quickmenu</TT>
facility has addressed the first problem. All of that is worthless
unless the user's definition file actually gets loaded. Fortunately,
solving the second problem is much easier. Executing the file
is not difficult at all, but finding it can be a little complicated,
and the means by which you find the file depends on the particular
application and its target market, among other things. You may
have a conventional filename that you use, or you may allow one
to be specified as an application parameter. You may also want
to support two definition files: a site-wide file and a user-specific
file.
<P>
Here's one way to do it, based on a conventional filename in the
user's home directory. System properties are used to locate the
home directory:
<BLOCKQUOTE>
<TT>// Assume that tcl.* and java.io.* are
imported,<BR>
// and that the Tcl interpreter is available as &quot;tcl&quot;
<BR>
<BR>
// Find file &quot;spiffymenu.tcl&quot; in the user's home directory
<BR>
File menufile = new File(System.getProperty(&quot;user.home&quot;),
&quot;spiffymenu.tcl&quot;);<BR>
if (menufile.canRead()) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
If it's readable, load it<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;Result
result = new Result();<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;//
The Tcl command &quot;source&quot; evaluates the Tcl code in a
file:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int code = tcl.eval(&quot;source &quot;
+ menufile.getPath(), result);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
(code != Interp.TCL_OK) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </TT><FONT FACE="MCPdigital-I">code
to indicate that the script had an error<BR>
</FONT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Now we really are done. Any of our application's users can create
a file called <TT>spiffymenu.tcl</TT>
in their home directory and put Tcl code in that file to define
their own menus, and their special menus will be created each
time they run the application.
<P>
When you read the code in fragments like this, in a book, it seems
like a lot of work. To put it into perspective, it has taken well
under 300 lines of code (including blank lines and comments) to
add this facility to the hypothetical application. There might,
of course, be a few more complications in a real application (in
particular, I've glossed over certain error situations with comments),
but it's still a large benefit for a small cost.
<H3><B>Adding More Functionality</B></H3>
<P>
Even the small amount of configurability afforded by the <TT>quickmenu</TT>
command will be useful to many, but it's very simple and restricted;
more general scripting facilities would be even better. There
are several ways to build on what's been shown so far to provide
even more useful facilities. Although the example was presented
in the context of a word processing program, these ideas are useful
for many different kinds of applications.
<P>
The <TT>quickmenu</TT> facility enables
users to place commonly used actions onto an easily accessed menu,
and those actions can be user-defined composite actions. Because
of this focus on menus, actions aren't allowed to take parameters.
Many more useful things would be possible in both the user menu
and the user-defined actions if operations like these were available:
<UL>
<LI>Forward 5 characters
<LI>Forward 3 paragraphs
<LI>Indent 0.5 inches
<LI>Insert &quot;new text&quot;
<LI><FONT COLOR=#000000>Font PalatinoBold</FONT>
</UL>
<P>
The facility also would be much more useful if it weren't so focused
on actions. It's difficult for programs (including scripts) to
do useful and intelligent things if they can't learn about their
environment. Tcl scripts should be allowed to make queries to
learn important things about the application's state. In the word
processor example, possibilities include the following:
<UL>
<LI>The current insertion position
<LI>The text at a certain position (or formatting attributes)
<LI>The selected text
<LI><FONT COLOR=#000000>The document name</FONT>
</UL>
<P>
There are many other pieces of information that would be useful
to scripts. The ability to learn such information would permit
user-defined actions to make complicated decisions, automating
frequent (but user-specific) operations.
<P>
Of course, once you start providing full-fledged extension facilities
like these, you're providing much more than a menu definition
facility, so the command name <TT>quickmenu</TT>
and the filename <TT>spiffymenu.tcl</TT>
aren't really appropriate any more. A slightly different structure
should be used instead.
<P>
This chapter uses a menu definition facility, rather than a toolbar
definition facility, so that the AWT-related code won't overwhelm
the Tcl-related code in the example, but a toolbar facility would
probably be more useful for many applications.
<H2><A NAME="OtherUsefulRolesforTcl"><B><FONT SIZE=5 COLOR=#FF0000>Other
Useful Roles for Tcl</FONT></B></A></H2>
<P>
In addition to convenience scripting for users, Tcl is suitable
for other roles in an application, some of them extremely important.
<P>
Elsewhere in this book, we talk about the importance of allowing
users (or at least site administrators) to configure the security
rules of an application (see Part 6, &quot;Security&quot;). This
is a situation where it is particularly useful to use a scripting
language, for several reasons:
<UL>
<LI>Different organizations have different security policies,
and it's extremely difficult (and perhaps impossible) to design
a fixed set of configuration options that can accommodate all
cases. Some sort of programmatic control over security rules can
permit organizations to use applications they might otherwise
have to abandon.
<LI>Because security is such an important issue, potential sources
of errors should be eliminated as much as possible. A common language
for defining security rules, used by many Java applications, would
help reduce complexity for site administrators.
<LI><FONT COLOR=#000000>Another potential source of errors is
the implementation of the security configuration facility itself.
Using an existing language implementation to parse and evaluate
the configuration file greatly reduces the potential for bugs
in that portion of your application.</FONT>
</UL>
<P>
The security configuration facility could provide simple rules
to decide when particular types of access should be allowed or
denied. For complicated cases, Tcl scripts could be invoked to
make the decisions. Here is one simple possibility for the style
of a Tcl-based security configuration file:
<BLOCKQUOTE>
<TT># This is Tcl, not Java!<BR>
<BR>
# allow my company's applets to read my calendar and work diary
files<BR>
allow read {calendar diary} {www.myco.com intranet.myco.com}<BR>
<BR>
# also allow my company's internal applets to connect to any host
<BR>
allow connect * {intranet.myco.com}<BR>
<BR>
# allow an applet to execute a couple of harmless system commands.
<BR>
# be careful here!!!<BR>
allow exec -script checkexec<BR>
proc checkexec {commandstring} {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;if
{[string match &quot;date *&quot; commandstring]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||
[string match &quot;cd ..&quot; commandstring]} {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
allow<BR>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
deny<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<P>
Naturally, a security configuration language should be designed
with a lot of care, and this example is not really appropriate
for the task. A reusable scripting language would make a good
basis for such a facility, however.
<P>
User interfaces need to be flexible, and a scripting language
might be a good way to provide some of that flexibility, allowing
users to adjust default colors, fonts, and sizes to fit their
own preferences, unusual hardware, or special needs. (Color-blind
users, for example, sometimes find the capability of changing
default colors particularly important.) Providing even more interface
flexibility through a scripting language may prove to be a benefit
to the application developers as well, making it easier to adjust
the interface in response to user feedback, or even permitting
more radical changes, such as adapting a graphical interface for
the visually impaired.
<P>
Many application developers go so far as to implement most of
their applications in a scripting language, using a lower-level
language such as Java or C only for the small portions of the
applications that might otherwise be very slow or complicated
or that have low-level system dependencies. Such a strategy can
be extremely fruitful for a developer, and the resulting application
will also be very powerful and flexible for users-perhaps too
flexible. When user scripts can override or modify application
internals, they can introduce their own bugs into the center of
the application, greatly complicating the job of supporting the
application. Tcl's security features can be used to solve that
problem. User scripts can be executed in a secure environment
where they can access only application commands that have been
explicitly exported for users, rather than having access to application
internals.
<P>
Because many scripting languages deal easily with strings, they
make good &quot;glue&quot; languages: They can be used to connect
two applications in certain situations, even if those applications
are written in different languages. Communication via strings
is important for building large systems out of smaller systems,
as the builders of the Internet have learned. (Human-readable,
string-oriented protocols are preferred over binary protocols
when efficiency isn't a primary concern, because they are easier
to build and debug.)
<P>
In short, if you wish to make your application flexible, configurable,
customizable, extensible, or useful in unanticipated contexts,
either for your users' benefit or your own, integrating a scripting
language is the way to go.
<H2><A NAME="TclExtensionPackages"><B><FONT SIZE=5 COLOR=#FF0000>Tcl
Extension Packages</FONT></B></A></H2>
<P>
Tcl is extensible primarily so that applications can add specialized
functionality, but many general-purpose extensions have been written
as well. Recent versions of Tcl support dynamic loading of extension
packages, making them convenient to use. This section describes
a few of the most popular and useful Tcl extensions. Many of them
currently run only on UNIX systems, where Tcl originated, but
some do run on other platforms, and more will soon. You might
find some of these packages useful; additionally, there are many
more Tcl extensions besides those mentioned here.
<P>
Tk is the most important Tcl extension. It was also designed and
implemented by John Ousterhout, and many Tcl users were first
drawn to Tcl because of the availability of Tk. Tk is a graphical
user interface toolkit that provides a rich suite of user interface
widgets, including general-purpose text and graphics widgets that
have far more functionality than the Java equivalents currently
do. Tk is also extensible, so new widgets can be provided, and
many extension widgets have been written. Quite a few commercial
applications have been built using Tk, including hospital administration
applications and the UNIX version of the game SimCity. Tk was
recently ported to work on Macintosh and Windows systems, and
it strives for uniformity by supplying missing capabilities on
some platforms (as opposed to the AWT's current least-common-denominator
approach). Tk currently provides the UNIX Motif user interface
style on all platforms, but work is underway to support the native
look and feel for Windows and Macintosh systems. More information
about Tk is available on the Tcl/Tk home page:
<BLOCKQUOTE>
<TT><A HREF="http://www.smli.com/research/tcl/">http://www.smli.com/research/tcl/</A></TT>
</BLOCKQUOTE>
<P>
Several graphical user interface builders for Tk are either currently
available or in development. One called SpecTcl (by Stephen Uhler
of Sun) is particularly easy to use, and it has been adapted to
generate Java code for AWT interfaces as well.
<P>
Extended Tcl (also known as TclX) deserves mention because it
has been influential in the development of Tcl itself; many of
the facilities now in the Tcl core first appeared in TclX. This
package extends Tcl with many conveniences and higher-level facilities,
and it also provides access to some low-level UNIX facilities.
It is available at the following address:
<BLOCKQUOTE>
<TT><A HREF="ftp://ftp.neosoft.com/pub/tcl/tclx-distrib/">ftp://ftp.neosoft.com/pub/tcl/tclx-distrib/</A></TT>
</BLOCKQUOTE>
<P>
Tix consists of a library of C routines that make it easier to
build new Tk widgets and a large suite of widgets built using
that library. The Tix package includes Windows-style comboboxes,
tabbed notebooks, and common dialogs (such as file selection dialogs).
Tix is currently being ported to Windows systems. It was originally
written by Ioi Kim Lam, and it is now a supported product from
Expert Interface Technologies. For more information, check out
this address:
<BLOCKQUOTE>
<TT><A HREF="http://www.xpi.com/tix/">http://www.xpi.com/tix/</A></TT>
</BLOCKQUOTE>
<P>
<TT>[incr Tcl]</TT> is an object-oriented
Tcl extension by Michael McLennan of Bell Laboratories (the unusual
name is a Tcl pun on the name C++). It provides namespaces, classes,
inheritance, and the capability of composing Tk widgets into &quot;megawidgets.&quot;
More information is available at the following address:
<BLOCKQUOTE>
<TT><A HREF="http://www.tcltk.com/itcl/">http://www.tcltk.com/itcl/</A></TT>
</BLOCKQUOTE>
<P>
A group at DSC Technologies uses <TT>[incr
Tcl]</TT>, and they have built another library of widgets
using that package. They call their package <TT>[incr
Widgets]</TT>, and it is available from this address:
<BLOCKQUOTE>
<TT><A HREF="http://www.tcltk.com/iwidgets/">http://www.tcltk.com/iwidgets/</A></TT>
</BLOCKQUOTE>
<P>
Tcl-DP is a package for distributed programming using Tcl. It
provides a Tcl-based remote procedure call, a high-level distributed
object facility, and a service location server. Tcl-DP is available
at this address:
<BLOCKQUOTE>
<TT><A HREF="ftp://mm-ftp.cs.berkeley.edu/pub/multimedia/Tcl-DP/">ftp://mm-ftp.cs.berkeley.edu/pub/multimedia/Tcl-DP/</A></TT>
</BLOCKQUOTE>
<P>
The Continuous Media Toolkit is a Tk extension for building multimedia
applications, especially using audio and video. One fascinating
aspect of this package is the support of Tcl scripts as a media
type, used for controlling and synchronizing other media streams.
The home page is at the following address:
<BLOCKQUOTE>
<TT><A HREF="http://www.bmrc.berkeley.edu/cmt/">http://www.bmrc.berkeley.edu/cmt/</A></TT>
</BLOCKQUOTE>
<P>
George Howlett from Bell Laboratories has written a package of
Tk widgets he calls BLT. It includes table and graph widgets,
and it is available from the following address:
<BLOCKQUOTE>
<TT><A HREF="ftp://ftp.neosoft.com/pub/tcl/NEW/BLT2.1.tar.gz">ftp://ftp.neosoft.com/pub/tcl/NEW/BLT2.1.tar.gz</A></TT>
</BLOCKQUOTE>
<P>
Expect is a Tcl extension by Don Libes, designed for controlling
interactive, character-based applications. It can be used to write
test suites for such applications or to automate complicated interactions.
It also is useful in conjunction with Tk to build graphical interfaces
to existing character applications. For more information, see
this page:
<BLOCKQUOTE>
<TT><A HREF="http://elib.cme.nist.gov/pub/expect/">http://elib.cme.nist.gov:80/pub/expect/</A></TT>
</BLOCKQUOTE>
<P>
GroupKit is a groupware toolkit based on Tcl and Tk. It comes
with many example groupware applications, including &quot;electronic
spaces&quot; with group awareness, as well as collaborative editors,
drawing tools, and meeting tools. GroupKit information is at this
address:
<BLOCKQUOTE>
<TT><A HREF="http://www.cpsc.ucalgary.ca/projects/grouplab/groupkit/">http://www.cpsc.ucalgary.ca/projects/grouplab/groupkit/</A></TT>
</BLOCKQUOTE>
<P>
The Visualization toolkit is a 3D graphics and scientific visualization
toolkit written in C++ with an interface to Tcl and Tk. Here is
Vtk's home page:
<BLOCKQUOTE>
<TT><A HREF="http://www.cs.rpi.edu/~martink/">http://www.cs.rpi.edu/~martink/</A></TT>
</BLOCKQUOTE>
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
Most applications, even small ones, need some sort of customization
or configuration language. As applications mature, the demands
placed on such scripting languages can grow far beyond what the
developers anticipated. Several scripting languages, most notably
Tcl, were designed to make it easy for developers to include a
full-featured scripting language in their applications from the
very beginning.
<P>
Scripting languages are just as useful for Java applications as
they are for C and C++ applications, and an interface between
Java and Tcl has been developed. Tcl can be used to make Java
applications much more versatile and flexible for the benefit
of users, administrators, and developers.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch28.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch30.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

