<HTML>

<HEAD>
   <TITLE>Chapter 4 -- Using Java's Audio Classes</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 4</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using Java's Audio Classes</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#DigitalAudioFundamentals" >Digital Audio Fundamentals</A>
<LI><A HREF="#JavaAudioSupport" >Java Audio Support</A>
<LI><A HREF="#PlayingAudioInJava" >Playing Audio In Java</A>
<LI><A HREF="#TheFutureofJavaAudio" >The Future of Java Audio</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Audio is an area of multimedia that has stirred up a lot of excitement
on the Web. It still isn't clear how far audio will permeate the
Web world, but there is little doubt that it will play a vital
role in the future of Java. As a Web communication tool, audio
is extremely engaging and can often grab your attention even when
visual cues fall short. Unfortunately, the audio support in Java
1.0 is still in its infancy. Java 1.0 is currently limited to
playing audio clips in the Sun AU file format.
<P>
In this chapter, you learn the basics about digital audio, along
with how the current version of Java provides audio support. You
then put together a pretty neat sample applet and finish with
a glimpse at where future Java audio extensions might be headed.
<H2><A NAME="DigitalAudioFundamentals"><FONT SIZE=5 COLOR=#FF0000>Digital
Audio Fundamentals</FONT></A></H2>
<P>
When a microphone converts sound waves to voltage signals, the
resulting signal is an analog (or continuous) signal. Because
computers are digital machines, it is necessary to convert this
analog signal to a digital signal for a computer to process. Analog
to digital (A/D) converters handle the task of converting analog
signals to digital signals, which is also referred to as <I>sampling</I>.
The process of converting an analog signal to a digital signal
doesn't always yield exact results. How similarly a digital wave
matches its analog counterpart is determined by the frequency
at which it is sampled, as well as the amount of information stored
at each sample.
<P>
To sample a sound, you store the amplitude of the sound wave at
regular intervals. Figure 4.1 shows how an analog sound wave is
converted to a digital wave by sampling the sound at regular intervals.
Notice in Figure 4.1 that the digital representation of the analog
sound wave is not a very good one. By taking samples at more frequent
intervals, the digital signal will come closer to approximating
the analog signal.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f4-1.gif" ><B>Figure 4.1 : </B><I>An analog sound wave and its digital representation.</I></A>
<P>
When sampling sounds, the rate (frequency) at which the sound
is sampled is very important, as well as how much data is stored
for each sample. The unit of measurement for frequency is Hertz
(Hz), which specifies how many samples are taken per second. In
Java 1.0, the only supported sound frequency is 8000 Hz, which
means that there are 8000 samples per second. Although it sounds
like a lot, this frequency actually results in a fairly low-quality
sound. To understand why, consider the fact that the frequency
for CD quality audio is 44000 Hz.<p>

<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 width=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The limitations on sound quality imposed by Java are really a reflection of the underlying AU sound format, which is discussed in a moment. When Java widens its support for other sound formats, these limitations will likely disappear.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The amount of data stored per sample determines the number of
discrete amplitudes that a digital signal can represent. Obviously,
the wider range of amplitudes represented by the digital signal,
the closer the original wave is approximated. In Java 1.0, the
sample data width is limited to 8 bits. A wave sampled at 8 bits
has 256 discrete amplitude levels (2 ^ 8).
<H2><A NAME="JavaAudioSupport"><FONT SIZE=5 COLOR=#FF0000>Java
Audio Support</FONT></A></H2>
<P>
The current audio support in Java comes in the form of a single
class, <TT>AudioClip</TT>, which is
part of the applet package. The <TT>AudioClip</TT>
class models a digital audio sound clip in the AU file format,
which provides support for 8000 Hz mono 8-bit &#181;Law encoded
audio clips. This is a fairly low-quality sound format and severely
limits Java in providing professional audio capabilities. However,
in the current context of the Web, just being able to play AU
audio clips in Java is plenty for many applets.<p>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 width=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
&#181;Law is the name of a sound data encoding mechanism that provides a 2:1 compression ratio. &#181;Law has very strong cross-platform support, which is probably one of the reasons Sun chose the AU sound format as Java's first supported 
format.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>AudioClip</TT> class is an
abstract class, so you can't directly create instances of it.
You create <TT>AudioClip</TT> objects
by calling the <TT>getAudioClip</TT>
method of the <TT>Applet</TT> class.
You'll learn more about that in a moment, but first take a look
at the methods in the <TT>AudioClip</TT>
class:
<UL>
<LI><TT>public abstract void play()</TT>
<LI><TT>public abstract void loop()</TT>
<LI><TT>public abstract void stop()</TT>
</UL>
<P>
As you can see, these methods are very high-level and quite simplistic.
It doesn't get much easier than just calling <TT>play</TT>
to play an audio clip. You may be a little intrigued by the <TT>loop</TT>
method, which plays an audio clip repeatedly in a loop until you
explicitly call <TT>stop</TT> to stop
it. The <TT>loop</TT> method is useful
in cases where you have a clip that needs to be repeated, such
as a helicopter rotor sound or a music clip.<p>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 width=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
When using looped sounds, it's important to make sure that the sound begins and ends in a such a way that it isn't noticeable when the looping occurs. For example, using the helicopter rotor sound as an example, the sound itself might just be one 
&quot;chop&quot; of the rotor blades. To get the desired effect of a continuous rotor sound, you need to loop the sound repeatedly. However, if the end of the sound doesn't blend well with the beginning, there will be a noticeable pop when the looping 
takes place. Considering the fact that the looping is probably occurring very rapidly, the end result is that it probably doesn't sound like a helicopter. The only real solution to this problem is carefully hand editing the sound and using a 
trial-and-error approach.</BLOCKQUOTE>
<BLOCKQUOTE>
One particularly neat usage of looped audio is playing music. Because Java currently provides no support for music sound formats such as MIDI, you often must play music as looped sounds. The looping aspect comes about because you usually will want to avoid 
creating long sound files-they take up so much space and therefore take too long to load. Rather, you can create smaller music sounds that can be looped to give the effect of a longer piece of music. Again, you must be very careful to make the loop 
transition unnoticeable, or the effect will be ruined.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
I'd love to give you more juicy details about the <TT>AudioClip</TT>
class, but there just isn't any more to it. By understanding the
three methods implemented by the <TT>AudioClip</TT>
class, you are practically already a Java audio guru.
<P>
The missing link, however, is how to create <TT>AudioClip</TT>
objects. Recall that you use the <TT>Applet</TT>
class's <TT>getAudioClip</TT> method
to get an <TT>AudioClip</TT> object.
Actually, there are two versions of <TT>getAudioClip</TT>,
which are defined as the following:
<UL>
<LI><TT>public AudioClip getAudioClip(URL
url)</TT>
<LI><TT>public AudioClip getAudioClip(URL
url, String name)</TT>
</UL>
<P>
The only difference between these two methods is whether or not
the URL parameter contains the name of the audio clip. In the
first version, it is assumed that the URL contains the complete
name; the second version requires a separate <TT>name</TT>
parameter. You typically will use the second version, because
you can easily retrieve the URL of the applet or the HTML document
in which the applet is embedded. You do this by using either the
<TT>getCodeBase</TT> or <TT>getDocumentBase</TT>
methods of <TT>Applet</TT>, like this:
<BLOCKQUOTE>
<TT>AudioClip clip1 = getAudioClip(getCodeBase(),
&quot;sound1.au&quot;);<BR>
AudioClip clip2 = getAudioClip(getDocumentBase(), &quot;sound2.au&quot;);</TT>
</BLOCKQUOTE>
<P>
You do not need to use an <TT>AudioClip</TT>
object to play sounds; you are required to create an <TT>AudioClip</TT>
object only if you want to play <I>looped</I> sounds. For normal
sounds, you also have the option of using one of the <TT>play</TT>
methods in the <TT>Applet</TT> class:
<UL>
<LI><TT>public void play(URL url)</TT>
<LI><TT>public void play(URL url, String
name)</TT>
</UL>
<P>
These <TT>play</TT> methods take the
same parameters as the <TT>getAudioClip</TT>
methods. In fact, the <TT>play</TT>
methods in <TT>Applet</TT> simply
call <TT>getAudioClip</TT> to get
an <TT>AudioClip</TT> object, followed
by a call to the audio clip's <TT>play</TT>
method. This is evident in Listing 4.1, which shows the Java 1.0
source code for the Applet <TT>play</TT>
methods.
<HR>
<BLOCKQUOTE>
<B>Listing 4.1. The Java 1.0 Applet </B><TT><B></TT>play()</FONT></B></TT><B>
methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public void play(URL url) {<BR>
&nbsp;&nbsp;AudioClip clip = getAudioClip(url);<BR>
&nbsp;&nbsp;if (clip != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip.play();<BR>
&nbsp;&nbsp;}<BR>
}<BR>
<BR>
public void play(URL url, String name) {<BR>
&nbsp;&nbsp;AudioClip clip = getAudioClip(url, name);<BR>
&nbsp;&nbsp;if (clip != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip.play();<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="PlayingAudioInJava"><FONT SIZE=5 COLOR=#FF0000>Playing
Audio In Java</FONT></A></H2>
<P>
Even though it looks simple, and you could probably turn out your
own Java audio applet at this point, let's look at how Java audio
can be used to create an interesting applet. Figure 4.2 shows
a screen shot of the OnTheFarm applet, which uses the Java <TT>AudioClip</TT>
class to generate some entertaining, if not rustic, results.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f4-2.gif" ><B>Figure 4.2 : </B><I>The OnTheFarm sample applet.</I></A>
<P>
The screen shot of OnTheFarm doesn't quite convey the real purpose
of the applet, so at this point you should run it for yourself
off the CD-ROM to get the real effect. In case you want to cut
to the chase and skip the farm experience, OnTheFarm plays a looped
music sound clip along with randomly playing various farm animal
sounds. Listing 4.2 contains the complete source code for OnTheFarm.
<HR>
<BLOCKQUOTE>
<B>Listing 4.2. The OnTheFarm sample applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>// OnTheFarm Class<BR>
// OnTheFarm.java<BR>
<BR>
// Imports<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import java.util.Random;<BR>
<BR>
public class OnTheFarm extends Applet implements Runnable {<BR>
&nbsp;&nbsp;AudioClip clip[] = new AudioClip[8];<BR>
&nbsp;&nbsp;Thread&nbsp;&nbsp;&nbsp;&nbsp;thread;<BR>
&nbsp;&nbsp;Random&nbsp;&nbsp;&nbsp;&nbsp;rand = new Random(System.currentTimeMillis());
<BR>
<BR>
&nbsp;&nbsp;public void init() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// Load the sounds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[0] = getAudioClip(getDocumentBase(),
&quot;Res/Hillbilly.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[1] = getAudioClip(getDocumentBase(),
&quot;Res/Cow.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[2] = getAudioClip(getDocumentBase(),
&quot;Res/Duck.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[3] = getAudioClip(getDocumentBase(),
&quot;Res/Goat.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[4] = getAudioClip(getDocumentBase(),
&quot;Res/Hen.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[5] = getAudioClip(getDocumentBase(),
&quot;Res/Horse.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[6] = getAudioClip(getDocumentBase(),
&quot;Res/Pig.au&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;clip[7] = getAudioClip(getDocumentBase(),
&quot;Res/Rooster.au&quot;);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void start() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (thread == null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread = new Thread(this);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void stop() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (thread != null) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.stop();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread = null;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void run() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (Thread.currentThread() == thread)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Loop the music sound<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clip[0].loop();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (true) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Wait three
seconds<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(3000);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (InterruptedException
e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Play an animal
sound<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clip[(rand.nextInt()
% 3) + 4].play();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Font&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font
= new Font(&quot;TimesRoman&quot;, Font.PLAIN, 20);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;FontMetrics fm = g.getFontMetrics(font);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str
= new String(&quot;On the farm...&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(font);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(str, (size().width - fm.stringWidth(str))
/ 2,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((size().height - fm.getHeight())
/ 2) + fm.getAscent());<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
OnTheFarm has three member variables: an array of <TT>AudioClip</TT>
objects, a <TT>Thread</TT> object,
and a <TT>Random</TT> object. The
<TT>AudioClip</TT> objects are used
to hold each different sound. The <TT>Thread</TT>
object is used to manage the main applet thread, which handles
looping the music sound and playing the random animal sounds.
Finally, the <TT>Random</TT> object
is used to generate random numbers that determine which animal
sounds are played.<p>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 width=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A thread is necessary here because you want the music sound to be looped continuously. The only way to guarantee that the looping is getting enough attention is to give it its own thread. This is a standard technique for looping sounds in 
Java.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>init</TT> method handles loading
the audio clips by way of the <TT>getAudioClip</TT>
method. The <TT>start</TT> and <TT>stop</TT>
methods are standard thread management methods. All the action
takes place in the <TT>run</TT> method,
where the music sound is first looped. The random animal sounds
are then played inside an infinite <TT>while</TT>
loop. Notice that the thread is put to sleep for three seconds
between sounds, which keeps the sounds from overlapping too much
and makes them easier to hear. The infinite <TT>while</TT>
loop is automatically terminated when the thread is destroyed,
which occurs when the applet terminates.<p>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 width=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
There's something taking place in the OnTheFarm sample applet that you may be taking for granted: sound mixing. The sound support in Java 1.0 has built-in sound mixing, which enables you to play multiple sounds at once. Java handles all the details of 
overlaying and playing multiple sounds, which is no small feat. Although you have learned about the downside of the current audio support in regard to its simplicity and limitations, built-in sound mixing is a big benefit.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The only other method in OnTheFarm is <TT>paint</TT>,
which simply draws the message <TT>On the
farm...</TT> centered in the applet window. That's all
there is to creating a virtual audio farm in Java.
<H2><A NAME="TheFutureofJavaAudio"><FONT SIZE=5 COLOR=#FF0000>The
Future of Java Audio</FONT></A></H2>
<P>
There is no arguing the limitations of audio in the current release
of Java. It is very clear that the Java architects focused on
more critical aspects of the language and class libraries in this
first release, which is just as well. As nice as it would be to
have fancy audio support right now, I would certainly rather opt
for stronger security and portability at this stage, which is
apparently the same logic used by Sun.
<P>
Knowing the current limitations of Java audio, what might the
future hold? Sun has promised more complete audio features in
a future release of Java that will include support for MPEG and
CD quality audio. There will also no doubt be additional sound
formats supported, such as Windows WAV files.
<P>
As far as future Java audio classes go, it is likely that Sun
will introduce a stream-based set of audio classes. In this scenario,
an audio clip would correspond to a stream of audio data. To play
an audio stream, you would simply write the stream of data to
an audio channel. An audio device, which corresponds to your audio
hardware, would contain multiple audio channels.
<P>
Sun already uses this same approach in the low-level classes that
support the <TT>AudioClip</TT> class.
These low-level classes are currently undocumented and unsupported,
but it is likely that they will form the basis of future Java
audio classes. If you want to check these classes out for yourself,
they can be found in the Classes\Sun\audio directory under your
main Java directory. You may have to expand the compressed Classes
file to install these classes. You can then use the <TT>javap</TT>
tool to look at the data and methods for these classes. For more
information on how to use the <TT>javap</TT>
tool to examine Java classes, check out <A HREF="ch25.htm" >Chapter 25</A>,
&quot;Class Organization and Documentation Tools.&quot;
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned all about audio in Java, including
the fundamentals of digital audio and the means by which Java
enables you to play it. You learned about the <TT>AudioClip</TT>
class and how to use it to play audio files in the AU format.
You also learned that although it is limited in its current state,
audio in Java is nevertheless available and quite usable. Even
more importantly, you saw how adding audio to Java applets is
simple, consisting of only a couple of method calls.
<P>
This chapter concluded with a brief discussion of what the future
might hold for Java audio. It isn't clear yet how Sun will supplement
Java audio in the future, but it has shown a definite intent.
A more powerful Java audio is on the horizon. Until then, you
should try to make the most of AU sounds and the <TT>AudioClip</TT>
class. You saw in the OnTheFarm sample applet how you can still
have fun with Java audio as it is-so go have some!
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch5.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

