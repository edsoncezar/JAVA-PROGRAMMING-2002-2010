<HTML>

<HEAD>
   <TITLE>Chapter 18 -- Developing Database Applications
and Applets</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">










<H1><FONT COLOR=#FF0000>Chapter 18</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Developing Database Applications
and Applets</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#StoringDatafortheWeb" >Storing Data for the Web</A>
<LI><A HREF="#ProvidingAccesstoData" >Providing Access to Data</A>
<LI><A HREF="#TheJDBCAPI" >The JDBC API</A>
<LI><A HREF="#SimpleDatabaseAccessUsingtheJDBCIn" >Simple Database Access Using the JDBC Interfaces</A>
<LI><A HREF="#ResultSetsandtheMetaDataInterfaces" >Result Sets and the Meta-Data Interfaces</A>
<LI><A HREF="#OtherJDBCFunctionality" >Other JDBC Functionality</A>
<LI><A HREF="#BuildingaJDBCImplementation" >Building a JDBC Implementation</A>
<LI><A HREF="#ExtendingJDBC" >Extending JDBC</A>
<LI><A HREF="#DesigningaDatabaseApplication" >Designing a Database Application</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Business users have long benefited from the ability to store data
in a central location for access by many different users. By connecting
the millions of once-isolated home computers on a common network,
the Internet has empowered developers to bring the advantages
of client/server computing into the home. Until Java, such Web
applications have primarily used CGI for connecting to databases.
<P>
For a few years now, the business solution to client/server development
has been rapid application development tools such as Borland Delphi,
Sybase PowerBuilder, and Microsoft Visual Basic. These applications
provide both rapid GUI development through the use of drag-and-drop
screen painting as well as a library of tools for accessing data
housed in relational databases. Unfortunately, these applications
are not well suited to Internet development, where platform independence,
security, and distribution are all imperative.
<P>
A major strength of rapid application development products is
their database connectivity. The Java specification as well as
the original release of the JDK made no provisions for Java database
access. In March 1996, Sun began to address this need with the
draft release of the Java Database Connectivity specification,
JDBC. This chapter addresses the problem of database access in
Java and demonstrates how to write code that conforms to and enhances
the JDBC interface.
<H2><A NAME="StoringDatafortheWeb"><FONT SIZE=5 COLOR=#FF0000>Storing
Data for the Web</FONT></A></H2>
<P>
Simple applets rarely need to perform database access. They are
generally executed as on-off programs without the need to save
any state information across executions. As Java developers move
their work out of the realm of the simple applet, they can find
a need to access some sort of data store. A popular, yet simple,
example is the ubiquitous page counter. A page counter is simply
an applet or CGI script that keeps track of how many times a particular
page has been hit and displays that number on the page (see Figure
18.1).
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f18-1.gif"><B>Figure 18.1 : </B><I>A Web page running a counter applet.</a></I>
<P>
At the other extreme in complexity are the search engines that
enable you to perform keyword searches to find the most trivially
related pages of information existing on the Internet. No matter
how complex the application, the basic data management needs are
the same. Many users need to gain access to the same piece of
information requiring an application be built in such a way that
it can access and/or modify centrally stored data. The developer
must then take the following steps to provide users with access
to data:
<UL>
<LI>Selecting and installing a database management system (DBMS)
<LI>Building data processing logic
<LI><FONT COLOR=#000000>Building a user interface</FONT>
</UL>
<H2><A NAME="ProvidingAccesstoData"><FONT SIZE=5 COLOR=#FF0000>Providing
Access to Data</FONT></A></H2>
<P>
Whether Java or some other language is used to build these pieces,
the DBMS being used will have a direct impact on the implementation.
A detailed discussion of database management systems is well beyond
the scope of this book. When choosing among the various technologies,
however, it is important to keep your needs (and your wallet)
in mind while resisting the dazzle of technology. Three basic
data storage technologies exist that serve various needs:
<UL>
<LI>Object-oriented database (OODBMS)
<LI>Relational database (RDBMS)
<LI>Object-relational database (OORDBMS)
</UL>
<P>
With the advent of the high multimedia content data storage needs
of the Internet, developers have been more open to the idea of
using object databases. In addition to being better suited to
the unusual demands of storing multimedia data, object databases
also help provide a true object paradigm all the way across from
data store to client application.
<P>
Accessing a pure object database with any front-end tool is a
challenge. Because the JDBC specification revolves around ANSI
SQL-2 compliance and few object databases have SQL support, accessing
an object database through Java will prove to be doubly challenging.
<P>
For developers not faced with the need to store complex data,
any traditional relational databases should do exactly what is
needed. The grand trick in doing Java programming with a relational
database, or doing any object programming against a relational
database, is the mapping between the dynamic realm of objects
and the static realm of pure data.
<P>
Paving the road between these two seemingly disparate technologies
are the object-relational databases. For developers with complex
data modeling needs, an object-relational database can provide
the object modeling power of an object database, while maintaining
the ease of data access afforded by traditional relational systems.
<H2><A NAME="TheJDBCAPI"><FONT SIZE=5 COLOR=#FF0000>The JDBC API</FONT></A>
</H2>
<P>
In order to provide a common base API for accessing data, Sun,
with support from a number of independent software vendors, developed
JDBC. JDBC defines a number of Java interfaces to enable developers
to access data independent of the actual database product being
used to store the data. In theory, an application written against
the basic JDBC API using only SQL-2 can function against any database
technology that supports SQL-2.
<H3>Database Requirements</H3>
<P>
Data may be stored in a wide variety of formats using various
technologies. In addition to the three major modern database management
systems, there are other things to consider, such as hierarchical
databases and file systems. Any low-level API even trying to find
a least common denominator among these data storage methods would
end up with the null set. JDBC, however, mandates no specific
requirements on the underlying DBMS. Rather than dictating what
sort of DBMS an application must have in order to support JDBC,
the specification places all its requirements on the JDBC implementation.
<P>
The JDBC specification primarily mandates that a JDBC implementation
support at least ANSI SQL-2 Entry Level. Because most common RDBMS
and OORDBMS systems support SQL-2, this requirement provides a
reasonable baseline from which to build database access. In addition,
because SQL-2 is required only at the JDBC implementation level,
that implementation can provide its own SQL-2 wrapper around non-SQL
data stores. Writing such a wrapper, though, would likely prove
to be a huge task.
<H3>The JDBC Interfaces</H3>
<P>
JDBC defines eight interfaces that must be implemented in order
to be JDBC-compliant:
<UL>
<LI><TT>java.sql.Driver</TT>
<LI><TT>java.sql.Connection</TT>
<LI><TT>java.sql.Statement</TT>
<LI><TT>java.sql.PreparedStatement</TT>
<LI><TT>java.sql.CallableStatement</TT>
<LI><TT>java.sql.ResultSet</TT>
<LI><TT>java.sql.ResultSetMetaData</TT>
<LI><TT>java.sql.DatabaseMetaData</TT>
</UL>
<P>
Figure 18.2 shows these interfaces and how they interact in the
full JDBC object model.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f18-2.gif"><B>Figure 18.2 : </B><I>The JDBC object model.</a></I>
<P>
The central object around which the whole concept revolves is
the <TT>java.sql.DriverManager</TT>
object. It is responsible for keeping track of the various JDBC
implementations that may exist for an application. If, for example,
a system were aware of Sybase and Oracle JDBC implementations,
the <TT>DriverManager</TT> would be
responsible for tracking those implementations. Any time an application
desires to connect to a database, it asks the <TT>DriverManager</TT>
to give it a database connection, using a database URL through
the <TT>DriverManager.getConnection()</TT>
method. Based on this URL, the <TT>DriverManager</TT>
searches for a <TT>Driver</TT> implementation
that accepts the URL. It then gets a <TT>Connection</TT>
implementation from that <TT>Driver</TT>
and returns it to the application.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
What is a database URL? In order to enable an application to specify the database to which it wants to connect, JDBC uses the Internet standard Universal Resource Locator system. A JDBC URL c onsists of the following pieces: 
<TT>jdbc:&lt;subprotocol&gt;:&lt;subname&gt;</TT>. As with URLs you have seen all over the Internet, the first element is the resource protocol-in this case, a JDBC data source. The subprotocol is specific to the JDBC implementation. In many cases, it will 
likely be the DBMS name and version, for example <TT>syb10</TT> might indicate Sybase System 10. The subname element is any information specific to the DBMS that tells it where it needs to connect. For mSQL, the JDBC URL is in the format of 
<TT>jdbc:msql://hostname:port/database</TT>. JDBC itself does not much care what a database URL looks like. The important thing is simply that a desired JDBC implementation can recognize the URL and get the information it needs to connect to a database 
from that URL.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>DriverManager</TT> is the
only instantiated class provided by JDBC other than exception
objects and a few specialized subclasses of <TT>java.util.Date</TT>.
Additional calls made by an application are written against the
JDBC interfaces that are implemented for specific DBMSs.
<H4><TT>java.sql.Driver</TT></H4>
<P>
A <TT>Driver</TT> is essentially a
<TT>Connection</TT> factory. The <TT>DriverManager</TT>
uses it to determine whether it can handle a given URL. If it
can handle the URL, it should create a <TT>Connection</TT>
object and return it to the <TT>DriverManager</TT>.
Because an application only indirectly references a <TT>Driver</TT>
through the <TT>DriverManager</TT>,
applications are rarely concerned with this class.
<H4><TT>java.sql.Connection</TT></H4>
<P>
A <TT>Connection</TT> is a single
database session. As such, it stores state information about the
database session it manages and provides the application with
<TT>Statement</TT>, <TT>PreparedStatement</TT>,
or <TT>CallableStatement</TT> objects
for making calls during the session.
<H4><TT>java.sql.Statement</TT></H4>
<P>
A <TT>Statement</TT> is an unbound
SQL call to the database. It is generally a simple <TT>UPDATE</TT>,
<TT>DELETE</TT>, <TT>INSERT</TT>,
or <TT>SELECT</TT> where no columns
need to be bound to Java data. It provides methods for making
such calls and returns to the application the results of any <TT>SELECT</TT>
statements or the number of rows affected by an <TT>UPDATE</TT>,
<TT>DELETE</TT>, or <TT>INSERT</TT>.
<P>
Statement has the subclass <TT>PreparedStatement</TT>,
which is in turn subclassed by <TT>CallableStatement</TT>.
A <TT>PreparedStatement</TT> is a
precompiled database call that requires parameters to be bound.
An example of a <TT>PreparedStatement</TT>
might be a stored procedure call that has no <TT>OUT</TT>
or <TT>INOUT</TT> parameters. For
stored procedures with <TT>OUT</TT>
or <TT>INOUT</TT> parameters, an application
should use the <TT>CallableStatement</TT>
interface.
<H4><TT>java.sql.ResultSet</TT></H4>
<P>
An application gets data returned by a <TT>SELECT</TT>
query through the implementer of this interface. Specifically,
the <TT>ResultSet</TT> object enables
an application to retrieve sequentially rows of data returned
from a prior <TT>SELECT</TT> call.
It provides a multitude of methods that enable you to retrieve
a given row as any data type to which it makes sense to convert
it. For example, if you have a date stored in the database as
a <TT>datetime</TT>, you can retrieve
it through the <TT>getString()</TT>
method to use it as a <TT>String</TT>.
<H4>The Meta-Data Interfaces</H4>
<P>
Meta-data is data about data. Specifically, it is a set of data
that gives you information on the database and data retrieved
from the database. Java provides two meta-data interfaces, <TT>java.sql.ResultSetMetaData</TT>
and <TT>java.sql.DatabaseMetaData</TT>.
The <TT>ResultSetMetaData</TT> provides
a means for getting information about a particular <TT>ResultSet</TT>.
For example, among other things, it provides information on the
number of columns in the result set, the name of a column, and
its type. The <TT>DatabaseMetaData</TT>
interface, on the other hand, gives the application information
on the database in general, such as what levels of support it
has, its name, version, and other bits.
<H2><A NAME="SimpleDatabaseAccessUsingtheJDBCIn"><FONT SIZE=5 COLOR=#FF0000>Simple
Database Access Using the JDBC Interfaces</FONT></A></H2>
<P>
An application for which database independence is paramount should
be written to the JDBC specification, using no database specific
calls and making use of no SQL that is not part of the ANSI SQL-2
standard. In such code, no reference should be made to a specific
implementation of JDBC. Writing a simple database application
using only JDBC calls involves the following steps:
<OL>
<LI>Ask the <TT>DriverManager</TT>
for a <TT>Connection</TT> implementation.
<LI>Ask the <TT>Connection</TT> for
a <TT>Statement</TT> or subclass of
<TT>Statement</TT> to execute your
SQL.
<LI>For subclasses of <TT>Statement</TT>,
bind any parameters to be passed to the prepared statement.
<LI>Execute the statement.
<LI>For queries, process the result set returned from the query.
Do this for each result set (if you have multiple result sets)
until there are none left.
<LI>For other statements, check the return value for number of
rows affected.
<LI>Close the statement.
<LI>Process any number of such statements and then close the connection.
</OL>
<H3>The Counter Applet Example</H3>
<P>
The counter applet discussed earlier in this chapter provides
a simple example of JDBC programming. Using the JDBC interfaces,
this applet connects to a database, determines how many times
the page on which it appears has been hit, updates the page to
reflect the new hit, and finally displays the number of hits.
In order to use this example, you need a database engine to run
your database and a JDBC driver to access that database engine.
If you do not have a database engine, download mSQL and JDBC,
which are both free for noncommercial use. Links to mSQL and the
JDBC class may be found through <TT><A HREF="http://www.imaginary.com/Java/">http://www.imaginary.com/Java/</A></TT>.
 In addition, you need to create a table called <TT>t_counter</TT>
with the fields <TT>counter_file (chAR(100),
PRIMARY KEY)</TT> and <TT>counter_num
(INT, NOT NULL)</TT>. The following mSQL script creates
the table:
<BLOCKQUOTE>
<TT>DROP TABLE t_counter\p\g<BR>
<BR>
CREATE TABLE t_counter(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter_file&nbsp;&nbsp;&nbsp;&nbsp;chAR(100)&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY
KEY,<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter_num&nbsp;&nbsp;&nbsp;&nbsp;
INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOT
NULL<BR>
)\p\g</TT>
</BLOCKQUOTE>
<P>
The applet consists of two classes, <TT>Counter</TT>
and <TT>Database</TT>. The <TT>Counter</TT>
class is the subclass of applet that provides the user interface
to the applet. It contains two instance variables. One, <TT>count</TT>,
is the number this applet is supposed to display, the number of
page hits. The other, <TT>database</TT>,
is an instance of the <TT>Database</TT>
class that provides wrappers for the JDBC access needed by the
applet.
<P>
<TT>Counter</TT> does not define any
new methods; rather, it simply overrides the <TT>java.applet.Applet.init()</TT>
and <TT>java.applet.Applet.paint()</TT>
methods. The <TT>init()</TT> method
is used to create a <TT>Database</TT>
instance and find out from it what the page hit count is for display.
The <TT>paint()</TT> method displays
the page hit count.
<P>
The interesting JDBC-related work is all encapsulated inside the
<TT>Database</TT> class. It has a
single instance variable, <TT>connection</TT>,
which is an instance of a JDBC <TT>Connection</TT>
implementation. The <TT>connection</TT>
variable is initialized in the <TT>Database</TT>
class constructor:
<BLOCKQUOTE>
<TT>public Database(String url, String user,
String pass)<BR>
&nbsp;throws java.sql.SQLException&nbsp;&nbsp;{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;connection
=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DriverManager.getConnection(url,
user, pass);<BR>
}</TT>
</BLOCKQUOTE>
<P>
By getting an instantiated <TT>Connection</TT>
object, the applet is ready to do whatever database access it
needs to do.<BR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Tip</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
As of the printing of this book, the <TT>java.sql</TT> package has not been incorporated into Java browsers such as Netscape. Due to a security feature of such browsers, which prevents the loading of classes in the <TT>java.*</TT> namespace, the applet 
examples in this chapter will not work properly. So how do I know they work at all? To get an applet using the <TT>java.sql</TT> classes to work, simply rename your <TT>java.sql</TT> packages to something else and recompile them. That moves them from the 
<TT>java.*</TT> namespace so that such browsers can load them. This problem does not affect standalone applications, and it will not apply once the JDBC specification is finalized and <TT>java.sql</TT> classes are incorporated into the browser releases.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The applet uses the <TT>getCount()</TT>
method to figure out how many page hits this particular access
to the Web page represents. That seemingly benign query actually
represents several steps:
<OL>
<LI>Create a <TT>Statement</TT> object.
<LI>Formulate and execute the <TT>SELECT</TT>
query.
<LI>Process the result.
<LI>Increment the hit count.
<LI>Format and execute an <TT>UPDATE</TT>
or <TT>INSERT</TT> statement.
<LI>Close the <TT>Statement</TT> and
<TT>Connection</TT> objects.
</OL>
<P>
Creating the <TT>Statement</TT> is
done through the JDBC call:
<BLOCKQUOTE>
<TT>java.sql.Statement statement = connection.createStatement();</TT>
</BLOCKQUOTE>
<P>
For this query, you want the number of hits for this page from
the <TT>t_counter</TT> table:
<BLOCKQUOTE>
<TT>sql = &quot;SELECT counter_num FROM t_counter
&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE counter_file =
'&quot; + page + &quot;'&quot;;<BR>
result_set = statement.executeQuery(sql);</TT>
</BLOCKQUOTE>
<P>
The <TT>result_set</TT> variable now
holds the results of the query. For queries that return multiple
rows, an application would loop through the <TT>next()</TT>
method in the result set until no more rows existed. This query,
however, should only be returning one row with one column, unless
the page has never been hit. If the page has never been hit, the
query will not find any rows and the <TT>count</TT>
variable should be set to <TT>0</TT>:
<BLOCKQUOTE>
<TT>if( !result_set.next() ) count = 0;</TT>
</BLOCKQUOTE>
<P>
Otherwise, you need to retrieve that row into the <TT>count</TT>
variable as an integer:
<BLOCKQUOTE>
<TT>else count = result_set.getInt(1);</TT>
</BLOCKQUOTE>
<P>
After incrementing the count to reflect this new hit, you close
out the <TT>Statement</TT> object
and get a new one in order to prepare for the <TT>UPDATE</TT>:
<BLOCKQUOTE>
<TT>count++;<BR>
statement.close();<BR>
statement = connection.createStatement();</TT>
</BLOCKQUOTE>
<P>
If this is the first time the page is being hit, the applet needs
to <TT>INSERT</TT> a new row into
the database. Otherwise, it should <TT>UPDATE</TT>
the existing row:
<BLOCKQUOTE>
<TT>if( count == 1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sql = &quot;INSERT INTO t_counter &quot;
+<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;(counter_file, counter_num) &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES
('&quot; + file + &quot;', &quot; + count + &quot;)&quot;;<BR>
}<BR>
else {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;sql
= &quot;UPDATE t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
counter_num = &quot; + count + &quot; &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;WHERE counter_file = '&quot; + file + &quot;'&quot;;<BR>
}<BR>
statement.executeUpdate(sql);</TT>
</BLOCKQUOTE>
<P>
The method then cleans up and returns the hit count. Listing 18.1
puts the whole applet together.
<HR>
<BLOCKQUOTE>
<B>Listing 18.1. The Counter applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.sql.Connection;<BR>
import java.sql.DriverManager;<BR>
import java.sql.ResultSet;<BR>
import java.sql.Statement;<BR>
<BR>
public class Counter extends java.applet.Applet {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;Database
db;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String count;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
driver = getParameter(&quot;driver&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String url = getParameter(&quot;url&quot;);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
user = getParameter(&quot;user&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String pass =
getParameter(&quot;password&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
page = getParameter(&quot;page&quot;);<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class.forName(driver).newInstance();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db
= new Database(url, user, pass);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= db.getCount(page);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( java.sql.SQLException
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= &quot;Database exception&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( Exception
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= &quot;Unable to load driver&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(java.awt.Graphics g)
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(new
java.awt.Font(getParameter(&quot;font&quot;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.awt.Font.BOLD,
14));<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(count,
5, 15);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
<BR>
class Database {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Connection connection;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Database(String url, String user,
String pass)<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;throws
java.sql.SQLException {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection =<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DriverManager.getConnection(url,
user, pass);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
public String getCount(String page) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
count = 0;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.Statement
statement =<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.createStatement();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.ResultSet
result_set;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
sql;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;SELECT counter_num FROM t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
counter_file = '&quot; + page + &quot;'&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_set
= statement.executeQuery(sql);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
!result_set.next() ) count = 0;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
count = result_set.getInt(1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement
= connection.createStatement();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
count == 1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;INSERT INTO t_counter &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(counter_file,
counter_num) &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES
('&quot; + page + &quot;', &quot; +count+ &quot;)&quot;;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;UPDATE t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
counter_num = &quot; + count + &quot; &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
counter_file = '&quot; + page + &quot;'&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.executeUpdate(sql);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.close();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
java.sql.SQLException e ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (&quot;&quot;
+ count);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P><CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Note</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
How do drivers get registered with the <TT>DriverManager</TT>? In the previous example, it was done by specifically loading the driver passed into the program through the <TT>driver</TT> parameter. A JDBC-compliant driver must tell the 
<TT>DriverManager</TT> about its existence when it gets instantiated. The preferred method of listing multiple JDBC drivers for the <TT>DriverManager</TT> is through the <TT>jdbc.drivers</TT> property.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="ResultSetsandtheMetaDataInterfaces"><FONT SIZE=5 COLOR=#FF0000>Result
Sets and the Meta-Data Interfaces</FONT></A></H2>
<P>
In simple applications such as the counter applet, there is no
need to perform any tricks with the results from a query. The
data is simply retrieved sequentially and processed. More commonly,
however, an application will need to process the data in a more
complex fashion. For example, a set of classes might want to deal
with data on a more abstract level than the <TT>Database</TT>
class from the counter example. Instead, such classes might not
know exactly what data is being retrieved. They can query the
meta-data interfaces to intelligently process such data that they
would otherwise not know. Listing 18.2 shows a generic database
view class that gets populated with database objects based on
a result set.
<HR>
<BLOCKQUOTE>
<B>Listing 18.2. A generic database view class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.sql.ResultSet;<BR>
import java.sql.ResultSetMetaData;<BR>
import java.util.Hashtable;<BR>
import java.util.Vector;<BR>
<BR>
public class View {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;private
Vector objects;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;public
void populate(ResultSet result_set, String cl) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSetMetaData
meta_data;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
i, maxi;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects
= new Vector();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta_data
= result_set.getMetaData();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxi
= meta_data.getColumnCount();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(
result_set.next() ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable
row = new Hashtable();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataObject
obj;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=1;
i&lt;=maxi; i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
key;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object
value;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
t;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key
= meta_data.getColumnLabel(i);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t
= meta_data.getColumnType(i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value
= result_set.getObject(i, t);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.put(key,
value);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj
= (DataObject)Class.forName(cl);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.restore(row);
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects.addElement(obj);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( java.sql.SQLException
e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects
= new Vector();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In the <TT>View</TT> class, reference
is made to a <TT>DataObject</TT> class
that implements a <TT>restore(java.util.Hashtable)</TT>
method not listed.
<P>
Because this is a generic class to be reused by many applications,
it knows nothing about the queries it is executing. Instead, it
takes any random result set and assumes that each row corresponds
to an instance of the class named by the second parameter to <TT>populate()</TT>.
<P>
In order to get the information it needs for performing the data
retrievals, the <TT>populate()</TT>
method first gets the meta-data object for this result set. This
method is specifically interested in knowing how many columns
are in the result set as well as the names of the columns. In
order to store the columns in a <TT>Hashtable</TT>
object that the <TT>DataObject</TT>
object can use for restoring itself, all data must be in the form
of objects. Thus, for each column in the result set, it finds
its data type from the meta-data and retrieves the column as an
object. The final step is to store it in the <TT>Hashtable</TT>.
<H2><A NAME="OtherJDBCFunctionality"><FONT SIZE=5 COLOR=#FF0000>Other
JDBC Functionality</FONT></A></H2>
<P>
JDBC provides a lot of functionality beyond the commonly used
methods already discussed:
<UL>
<LI>Transaction management
<LI>Cursor support
<LI>Stored procedure support
<LI><FONT COLOR=#000000>Multiple result set processing</FONT>
</UL>
<H3>Transaction Management</H3>
<P>
JDBC implementations should default automatically to committing
transactions unless the application otherwise requests that transactions
require an explicit commit. An application may toggle the automatic
commit of the JDBC implementation it is using through the <TT>Connection.setAutoCommit()</TT>
method. Here is an example:
<BLOCKQUOTE>
<TT>connection.setAutoCommit(false);</TT>
</BLOCKQUOTE>
<P>
Of course, by not setting the <TT>AutoCommit</TT>
attribute or by setting it to <TT>true</TT>,
the JDBC implementation will make certain that the DBMS commits
after each statement you send to the database. When set to <TT>false</TT>,
however, the JDBC implementation requires specific commits from
the application before a transaction is committed to the database.
A series of statements executed as a single transaction would
look like this:
<BLOCKQUOTE>
<TT>public void add_comment(String comment)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statement
s;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet r;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
comment_id;<BR>
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.setAutoCommit(false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = connection.createStatement();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r
= s.executeQuery(&quot;SELECT next_id &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;FROM
t_id &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
id_name = 'comment_id'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( !r.next()
) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new SQLException(&quot;No comment id exists &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;in t_id table.&quot;);<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comment_id = r.getInt(1)
+ 1;<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = connection.createStatement();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.executeUpdate(&quot;UPDATE
t_id &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
comment_id = &quot; + comment_id + &quot; &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
next_id = 'comment_id'&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= connection.createStatement();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.executeUpdate(&quot;INSERT
INTO t_comment &quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;(comment_id, comment_text) &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&quot;VALUES(&quot; + comment_id + &quot;, '&quot; +<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comment
+ &quot;')&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.commit();
<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( SQLException e ) {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.rollback();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
</TT>&nbsp;<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(
SQLException e2 ) System.exit(-1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
This method is used to add a comment to a comment table for some
applications. In order to insert the new comment, it needs to
generate a new <TT>comment_id</TT>
and then update the table for generating id's so that the next
one will be one greater than this one. Once it has an id for this
comment, it then inserts the comment into the database and commits
the entire transaction. If an error occurs at any time, the entire
transaction is rolled back.
<P>
JDBC currently has no support for a two-phase commit. Applications
written against distributed databases require extra support to
allow for a two-phase commit.
<H3>Cursor Support</H3>
<P>
JDBC provides limited cursor support. It enables an application
to get a cursor associated with a result set through the <TT>ResultSet.getCursorName()</TT>
method. The application can then use the cursor name to perform
positioned <TT>UPDATE</TT> or <TT>DELETE</TT>
statements.
<H3>Stored Procedures</H3>
<P>
Stored procedures are precompiled SQL statements stored in the
database that enable faster execution of SQL. JDBC supports stored
procedures through the <TT>CallableStatement</TT>
class. In the counter applet, a stored procedure could have been
used to update the page hit count in the following way:
<BLOCKQUOTE>
<TT>CallableStatement s = connection.prepareCall(&quot;{call
sp_upd_hit_count[?, ?]}&quot;);<BR>
s.setStringParameter(1, &quot;file&quot;);<BR>
s.setIntParameter(2, count);<BR>
s.executeUpdate();</TT>
</BLOCKQUOTE>
<H3>Multiple Result Sets</H3>
<P>
In some cases, especially with stored procedures, an application
can find a statement returning multiple result sets. JDBC handles
this through the method <TT>Statement.getMoreResults()</TT>.
Although there are result sets left to be processed, this method
returns <TT>true</TT>. The application
can then get the next <TT>ResultSet</TT>
object by calling <TT>Statement.getResultSet()</TT>.
Processing multiple result sets simply involves looping through
as long as <TT>Statement.getMoreResults()</TT>
returns <TT>true</TT>.
<H2><A NAME="BuildingaJDBCImplementation"><FONT SIZE=5 COLOR=#FF0000>Building
a JDBC Implementation</FONT></A></H2>
<P>
Building a JDBC implementation requires a lot more in-depth knowledge
of both your DBMS and the JDBC specification than does simply
coding to it. Most people will never encounter the need to roll
their own implementation, because database vendors will logically
want to make them available for their product. Understanding the
inner workings of JDBC, however, can help advance your application
programming.
<P>
JDBC is a low-level interface. It provides direct SQL-level access
to the database. Most business applications and class libraries
will want to abstract from that SQL-level access to provide such
things as object persistence and business-aware database access.
A narrow example of such an abstraction is the <TT>Database</TT>
class from the counter example.
<P>
The ideal object method of accomplishing these goals is to reuse
existing JDBC implementations for the DBMS in question and add
custom interfaces on top of those. If the DBMS is an oddball DBMS,
or perhaps if concerns about the available implementations exist,
writing one from scratch makes sense.
<H3>Implementing the Interfaces</H3>
<P>
The first concern of any JDBC implementation is how it is going
to talk to the database. Figure 18.3 illustrates the architecture
of three possible JDBC implementations. Depending on the design
goals in question, one of these methods will suit any JDBC implementation:
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f18-3.gif"><B>Figure 18.3 : </B><I>Possible JDBC implementation architectures.</a></I>
<UL>
<LI>A native C library
<LI>A socket interface
<LI><FONT COLOR=#000000>Extending a vendor JDBC implementation</FONT>
</UL>
<P>
Extending a vendor JDBC implementation, of course, is not really
the same as building a JDBC implementation. Because a key to any
object-oriented project is reusing code instead of building from
scratch, however, it is listed here.
<P>
With all three architectures, the application is apparently isolated
from the actual communication mechanism. In truth, however, the
native C library method places severe restrictions on any application
using a JDBC implementation built on top of it. Because it uses
native calls, it is naturally not portable across operating systems.
In addition, due to virtual machine restrictions on most browsers,
native calls are either fully restricted or severely limited.
<P>
Using one of these mechanisms for database communication, you
need to construct the four basic interfaces: <TT>java.sql.Driver</TT>,
<TT>java.sql.Connection</TT>, <TT>java.sql.Statement</TT>,
and <TT>java.sql.ResultSet</TT>. These
will provide minimum functionality so that testing against simple
queries and updates can be done. Once these are functional, the
implementation needs the meta-data interfaces as well as the <TT>Statement</TT>
subclasses in order to be complete and JDBC-compliant.
<H2><A NAME="ExtendingJDBC"><FONT SIZE=5 COLOR=#FF0000>Extending
JDBC</FONT></A></H2>
<P>
Nothing requires an application to use the JDBC interface to access
a database. In fact, before JDBC, developers were programming
to Java classes written specifically to go against several major
database engines. JDBC isolates the database access behind a single
interface. This isolation can provide developers with the ability
to write database access in Java without having to know which
database engine their application is actually hitting. With a
single prevalent database API, finding people with experience
programming against it proves much simpler than finding people
to program against a proprietary API. JDBC is, however, a low-level
specification that requires developers to write both SQL code
as well as Java code.
<P>
Both examples in this chapter demonstrate two different ways in
which you can extend JDBC. In the counter applet, a database class
was created as a wrapper around the JDBC implementation. The applet
itself was divided into a representational portion, the <TT>Counter</TT>
class, and a functional portion, the <TT>Database</TT>
class. If changes are made to the visual representation, such
as making the hit count appear through an odometer graphic, no
changes will need to be made to the functional logic, because
it is isolated in a separate class. In fact, if the applet were
more complex, requiring multiple developers, all the SQL is still
isolated in a class specifically interested in the functional
behavior of the application. This reduces the amount of people
needing to write SQL code.
<P>
The <TT>View</TT> class example was
a more abstract way of extending JDBC. The <TT>View</TT>
class assumes that rows in result sets translate into business
objects. In an application using this class, <TT>View</TT>
objects are created whose purpose is to make JDBC calls and populate
the applications with meaningful objects.
<P>
Another manner in which JDBC can be extended is to take advantage
of database-specific features. Although it is prudent to question
the need to make use of any proprietary features of a given DBMS,
it is equally important that you do not ignore the extra power
a specific DBMS gives you. It is, after all, very rare that an
application actually needs to switch database engines.
<H2><A NAME="DesigningaDatabaseApplication"><FONT SIZE=5 COLOR=#FF0000>Designing
a Database Application</FONT></A></H2>
<P>
Knowing the JDBC API and coding cute applets are naturally just
the start to database programming in Java. In order to harness
the advantages of Java, application designers need to be able
to address the design issues raised by Java. The entire Java paradigm
empowers developers to write database applications and applets
using architectures that before were either very complex or simply
not supported by other tools. Two such buzzwords that have been
flying around the client/server world for a while are distributed
objects and three-tier client/server.
<H3>Security Issues</H3>
<P>
Before going off the edge into the deep end, Java does put some
restrictions on applets for security reasons which can appear
to be particularly limiting to the database developer. The following
are two particular applet restrictions that affect database programmers:
<UL>
<LI>Limited access to native calls
<LI><FONT COLOR=#000000>Limited network access</FONT>
</UL>
<P>
The native call limitation affects programmers who need to use
some sort of C- or operating system-level library in order to
design an applet. This is especially troublesome to applet writers
who need to take advantage of a database-specific feature not
supported outside of native calls.
<P>
To veteran client/server developers, however, the most troubling
idea is likely that your Web server must be on the same machine
your applet is connecting to for database access. Specifically,
most Java virtual machines restrict applets from connecting to
any machine except the host that served the applet. The applet
therefore cannot connect directly to any local or third-machine
databases. As limiting as this particular restriction seems, a
three-tier architecture provides a liberating solution.
<H3>Constructing a Three-Tier Application</H3>
<P>
Two-tier applications tend to push a lot of processing onto the
client machines. This architecture poses several problems:
<UL>
<LI>Client-side resource requirements balloon with the extra processing
needs. It is not uncommon to find business applications requiring
Pentiums with 32M of RAM.
<LI>User interface and business processing tend to get rolled
together, especially with the rapid application development tools
on the market. With the user interface so closely tied to business
processing, changes to one end up having a direct impact on the
other, making maintenance a headache.
<LI><FONT COLOR=#000000>With all this redundant processing occurring
on many client machines rather than in a central location, new
applications are forced to reinvent the wheel when dealing with
the same business processing.</FONT>
</UL>
<P>
With the guaranteed execution environment of the Java virtual
machine and an easy-to-use Internet socket interface, Java is
actually well-suited to the implementation of three-tier systems.
A <I>three-tier application</I> is one where a third application
layer exists between the client and server layers of traditional
two-tier client/server development. This middle layer has a wide
variety of uses depending on the application in question.
<P>
The three-tier architecture uses the middle layer to separate
business processing from the visual representation of data. This
layer, called the <I>application server</I>, is responsible for
knowing how to find and manipulate business data. The client evolves
into a much leaner application responsible only for retrieving
information from the application server and displaying it on the
screen.
<P>
In addition to removing a huge processing burden from client machines,
this application server can be used to consolidate enterprise-wide
business rules. Where business rules had to be rewritten for each
two-tier application thrust upon the desktop, application servers
process business rules in a single place for use by multiple applications.
When the business rules change, a change to the application server
takes care of that change for all the applications being run by
the business.
<P>
Of specific interest to Java developers is the ability to hide
any knowledge of the database server from the client. Because
Internet clients view the applet or application as interfacing
with a single application server, you can use that application
server to determine such things as where the data really exists.
Additionally, this back-end independence enables applications
to scale much easier across CPUs. Figure 18.4 shows a three-tier
architecture.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f18-4.gif"><B>Figure 18.4 : </B><I>A three-tier Java applet or application.</a></I>
<H3>A Three-Tier Bug Tracking System</H3>
<P>
The application server forms the core of a three-tier architecture.
In it, the business rules are defined and processed. Implementing
the counter using a three-tier architecture would naturally be
massive overkill. Instead, the ideal application for a three-tier
design is one where some manipulation of data occurs, or where
the data can be viewed in multiple fashions (or even better, by
multiple applications). The first step in building an application
server would thus be to identify the data processing needs of
the application.
<H3>Implementing a Three-Tier Application with Java</H3>
<P>
Figure 18.5 shows a bug tracking application implemented as a
three-tier Java application.
<P>
<A HREF="http://docs.rinet.ru/JaTricks/f18-5.gif"><B>Figure 18.5 : </B><I>A bug tracking system using a three-tier
architecture.</a></I>
<P>
The only processing done on the client is the painting of GUI
widgets and user data entry. On the other end, the database server
is running on a machine otherwise inaccessible to the client applet.
Bridging this gap is the application server that finds desired
data, maps it from its relational state into objects, and performs
operations on those objects.
<P>
With any three-tier architecture, one of the greatest programming
challenges is getting the three layers to communicate with one
another. JDBC or some similar set of database access classes should
handle the application server-to-database server communication
in a manner transparent to the application developer. The client-to-application
server solution is still left wanting.
<P>
The two best methods for providing such communication in Java
are Java sockets or distributed objects. Compared to sockets from
other languages, Java sockets are quite simple to use. Sockets,
however, force the developer to make esoteric decisions as to
exactly what it is that is being communicated between client and
application server, because method calls and object passing are
better handled by the distributed objects solution. A socket solution
generally best fits an application where the scope of communication
is limited and well defined. The bug tracking system would be
best implemented in this manner.
<P>
Distributed objects provide the more elegant solution. From the
developer's point of view, the application server objects appear
to be part of the same application as the client, just residing
on a central server and available to other applications simultaneously.
The developer handles communication simply through method calls.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Although the original Java release did not address the issue of
database access, the JDBC specification attempts to address this
issue by defining a set of interfaces that can give applications
access to data independent of the DBMS being used to store that
data. Though this back-end independence can be very liberating,
it is important to balance it with the advantages of the DBMS
being used.
<P>
Many books exist that cover only the subjects of database application
design and programming. This chapter does not attempt to delve
into those matters; instead, it focuses on the application of
Java to database programming. Programmers interested in using
Java to write database applications should become familiar with
the general subject matter.
<P>
In spite of the vastness of the subject matter, this chapter should
whet your appetite for database programming and prepare you at
least enough to write simple applets and applications. Much of
the Java experience you already have translates into many of the
issues specific to Java database programming. For example, applets
written to use a database must work around the strict security
limitations of Java virtual machines. Using the basics of a three-tier
architecture can help an applet get around this limitation while
giving it greater functionality. It is, however, important not
to overdesign a simple applet just for the sake of doing a three-tier
design.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch17.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/pc.gif" BORDER=0 HEIGHT=88
WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/JaTricks/cc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="index.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/hb.gif" BORDER=0
HEIGHT=88 WIDTH=140></A><A HREF="ch19.htm"><IMG SRC="http://docs.rinet.ru/JaTricks/nc.gif" BORDER=0
HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

