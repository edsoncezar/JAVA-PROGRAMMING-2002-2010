<HTML>
<HEAD>
<TITLE>Chapter 8 -- Debugging with the Visual J++ Debugger</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;8</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Debugging with the Visual J++ Debugger</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ControllingtheExecution">
Controlling the Execution</A>
<UL>
<LI><A HREF="#SuccessfulBuild">
Successful Build</A>
<LI><A HREF="#Breakpoints">
Breakpoints</A>
<LI><A HREF="#WhereDoYouGofromHere">
Where Do You Go from Here?</A>
</UL>
<LI><A HREF="#WhatDoYouSee">
What Do You See?</A>
<UL>
<LI><A HREF="#Variables">
Variables</A>
</UL>
<LI><A HREF="#Exceptions">
Exceptions</A>
<LI><A HREF="#Threads">
Threads</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Because the majority of us write perfect code on our first attempt,
you probably won't need this chapter. But, just in case there
is a late night where a couple of those pesky bugs slip into your
code, this chapter explains some of the features of the Visual
J++ Debugger, including controlling the flow of your application
line-by-line, inspecting variables in various ways, and covering
how the debugger can help when exceptions are thrown and when
dealing with multithreaded applications.
<H2><A NAME="ControllingtheExecution"><FONT SIZE=5 COLOR=#FF0000>
Controlling the Execution</FONT></A></H2>
<P>
One of the most important aspects of debugging a program is getting
a successful build. From there you can start setting breakpoints
to instruct the debugger where you want to walk through your code.
Finally, you have control of where you are walking.
<H3><A NAME="SuccessfulBuild">
Successful Build</A></H3>
<P>
Before you even think about debugging an application, you must
first successfully build your application. When a compile-time
error is encountered while building your applications, Visual
J++ places all the necessary information into the Build tab of
the output window. Each error line shows the location in the file
where the error occurred, the line and column, and the error found.
Figure 8.1 shows a sample compile-time error.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-1.gif"><B> Figure 8.1 : </B><I>Output window showing a compile error.
</I></A><P>
<P>
The example <TT>EX08A</TT> shown was created using the AppletWizard
with all the bells and whistles turned on. For more information
on creating applications and using the Applet Wizard, see Chapter
2, &quot;Creating Your First Applet with Applet Wizard,&quot;
and <A HREF="ch3.htm" >Chapter 3</A> &quot;Using the Developer Studio.&quot;
<P>
While reviewing the code that was generated by the Applet Wizard,
a character in the file was inadvertently deleted. When the application
was then built, Visual J++ showed the compile-time errors in the
Output window. By highlighting the line in the Output window,
Visual J++ shows the source code line in error in the right pane
of the Project Workspace and places a small blue arrow next to
the line in error. In addition, the full error message is displayed
in the status bar. For this example, it is clear that the name
of the class is <TT>EX08AFrame</TT>, not <TT>EX08AFram</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you need more information about the compile error shown in the Output window, simply place the cursor on the error number (<TT>J0049</TT> in the previous example) and press F1. An InfoView topic shows more information about the error and how it can be 
corrected.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Once you have successfully built your application free of compile-time
errors, you are ready to start debugging. The next section covers
how to set breakpoints.
<H3><A NAME="Breakpoints">
Breakpoints</A></H3>
<P>
The first step in debugging your application is being able to
start and stop execution of the source. To stop the execution
of the application at a particular location in your program you
must set a breakpoint. Breakpoints can be set on a specific source
code line, at the entrance to or exit from a method, by examining
the call stack, or at a specific memory address.
<P>
One of the most useful places to set a breakpoint is at a particular
line of source code. To do this, simply place the cursor in the
right pane of the Project View on the line of source where you
want to stop. Then, use the Edit | Breakpoints command to bring
up the Breakpoints dialog of Figure 8.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-2.gif"><B> Figure 8.2 : </B><I>Setting a breakpoint using the Breakpoints dialog.
</I></A><P>
<P>
You can easily set a breakpoint on the source code line by pressing
the button to the right of the edit box and selecting the choice
displayed. Once you have set the breakpoint at the line, you can
conditionally stop execution based on an expression. Pressing
the Condition button brings up the dialog shown in Figure 8.3.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-3.gif"><B> Figure 8.3 : </B><I>Adding conditions to the breakpoint.
</I></A><P>
<P>
The breakpoint will not stop execution until the expression entered
into the first edit evaluates to true (if a Boolean expression
is entered), or when the expression changes.
<P>
Some pesky bugs have a habit of hiding the first time (or several
times) around during execution. The last edit on the Breakpoint
Condition dialog enables the user to specify the number of times
for which the expression evaluates to true before the execution
stops. In this way, the user does not have to keep track of the
number of times a breakpoint has stopped if he or she knows the
error does not surface until the tenth iteration through a loop.
<P>
The list at the bottom of the Breakpoints dialog shows all current
breakpoints for the project. You will notice that that there is
a check mark in a small box next to each breakpoint. This indicates
that the breakpoint is enabled. If you want to leave a breakpoint
in the project but don't stop on it because you may have debugged
that section of code, simply disable the breakpoint. To do this,
click the small check mark next to the breakpoint. This disables
the breakpoint, while leaving it in the system. The Remove button
to the right of the list enables the user to delete the currently
selected breakpoint from the list.
<P>
As a visual indication of the breakpoint, you will notice that
a small red dot is placed next to the line of source in the right
pane of the Project Workspace. When the breakpoint is disabled,
the dot is changed to a red circle.
<H3><A NAME="WhereDoYouGofromHere">
Where Do You Go from Here?</A></H3>
<P>
Once you have established your breakpoints, you need to actually
start debugging. To start the execution of a program in the debugger,
use the Build | Debug | Go command. This will start executing
the program. Make sure that the application will run in the stand-alone
interpreter using the Debug tab of the Build | Settings dialog.
<P>
Once a breakpoint is encountered, Visual J++ stops execution of
the program and displays Project Workspace with an arrow showing
where the current execution point is in the source code. Figure
8.4 shows an example of this.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-4.gif"><B> Figure 8.4 : </B><I>Current execution point of a stopped application.
</I></A><P><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
All breakpoints and current line indicators show the line about to be executed. Therefore, you should not expect values changing on the current line to have changed until after you execute the line.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The Debug toolbar shown in Figure 8.4 contains a number of options
at your disposal. Table 8.1 contains a listing of the commands
available on the Debug toolbar.<BR>
<P>
<CENTER><B>Table 8.1. Debug toolbar command descriptions.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=144><I>Command</I></TD><TD WIDTH=432><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Restart</TD><TD WIDTH=432>Restart the application, clearing the values of all variables.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Stop Debugging</TD><TD WIDTH=432>Stop running the application in the debugger.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Step Into</TD><TD WIDTH=432>Execute the current instruction, stepping into any methods encountered.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Step Over</TD><TD WIDTH=432>Execute the current instruction, without stepping into any methods encountered.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Step Out</TD><TD WIDTH=432>Execute instructions until the first instruction is encountered after the call to the current method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Run to Cursor</TD><TD WIDTH=432>Execute instructions until the line with the cursor is encountered.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>QuickWatch</TD><TD WIDTH=432>Display the QuickWatch window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Watch</TD><TD WIDTH=432>Display the Watch window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Variables</TD><TD WIDTH=432>Display the Variables window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Registers </TD><TD WIDTH=432>Display the Registers window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Memory </TD><TD WIDTH=432>Display the Memory window.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Call Stack</TD><TD WIDTH=432>Display the Call Stack.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Disassembly</TD><TD WIDTH=432>Display the current source in the disassembled bytecode instructions.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Starting Program Execution</H4>
<P>
Let's stop for a second and go back to how to start the execution
of the application. There are three processes involved and they
all have shortcut keys associated with F5.
<P>
When in the debugger, you can just start the application executing
instructions from the current instruction until a breakpoint is
encountered using the Debug | Go command or by using F5. This
is basically letting the program execute because you either want
to see how the program completes execution or you have a breakpoint
set somewhere later in the flow of execution.
<P>
Alternatively, you might want to restart the execution of the
application from the start. Debug | Restart, or Shift+F5 clears
all the contents of the variables, resets the current instruction
to the start of the application, and executes a Go command. Again,
this assumes that breakpoints have been set and enabled to stop
the execution of the application at the appropriate locations.
<P>
Lastly, if you have seen what you were looking for, Debug | Stop
Debugging, or Alt+F5, terminates the application and stops the
execution of the debugger.
<H4>Watch Your Step</H4>
<P>
When you have stopped at a breakpoint, you are likely to want
to see or control the flow of execution of instructions in your
application. This is commonly referred to as stepping through
your application. There are several possibilities when stepping.
<P>
Consider the following line of code:
<BLOCKQUOTE>
<PRE>
double classicPrice = myClassic.CalculateSalePrice();
</PRE>
</BLOCKQUOTE>
<P>
This line calls the <TT>CalculateSalePrice</TT> method of the
<TT>myClassic</TT> instance of the <TT>ClassicCar</TT> class and
stores the result in <TT>classicPrice</TT>. For this example,
the definition of the class is irrelevant, but a possible definition
can be found in Appendix A, &quot;A Whirlwind Tour of the Java
Language.&quot;
<P>
Assume this line is contained in the current method of an executing
application and is the current instruction. Using the Debug |
Step Into command, or F8, the current instruction will be the
first line of the <TT>CalculateSalePrice</TT> method. In other
words, you are stepping into the contents of the function being
called. This is quite useful when the function being called is
yours and you want to see how the function behaves when it is
being called from different sources or you want to see which class
is being called for an overridden function.
<P>
When stepping into functions, remember that flow of control is
passed to the next logical method called. Therefore, if there
are embedded method calls, the first one executed will be stepped
into first. What if the calculated sales price of the car is no
longer based on the car but is instead based on the markup of
the dealership selling the car? The following line of code might
be encountered:
<BLOCKQUOTE>
<PRE>
double classicPrice = myClassic.CalculateSalePrice(myDealer.GetMarkup());
</PRE>
</BLOCKQUOTE>
<P>
If this is the current line and F8 is pressed, the first method
stepped into would be the call to <TT>GetMarkup</TT>. If F8 is
pressed on the return of that method, <TT>CalculateSalePrice</TT>
would then be entered.
<P>
If you are not interested in stepping into a function, you should
use Debug | Step Over or F10. This steps over the call to the
function and simply executes the current instruction and moves
to the next instruction in the current method. For this command,
it makes no difference the number of functions being called in
the current instruction. Therefore, in both of the previous examples,
the next instruction will always be the next instruction in the
current method.
<P>
You might find yourself in a method where only the initial instructions
of the method are in question and you really want to know how
the result of this method affects the calling method. To step
out of the current method, use the Debug | Step Out command (or
Shift+F7). This command moves the currently executing instruction
to the instruction immediately following the call to the current
method.
<P>
The Debug | Run to Cursor command, or F7, is used to start execution
and break when the line with the cursor is encountered. The same
effect can be accomplished by setting a breakpoint on the current
line, using the Debug | Go command to start execution and removing
the breakpoint once the execution has stopped on the current line.
Obviously, F7 is much easier to use.
<H4>Interrupting Your Program</H4>
<P>
A nice little feature of Visual J++ is the capability to stop
the execution of your application. The Debug | Break command stops
the execution of the application. This is very useful for those
situations where you either forgot to set a breakpoint and started
executing a long series of steps to get to a piece of code intended
to be debugged, or your application slipped into an infinite loop.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
While the ability to interrupt your application is quite nice, it can also be very dangerous. The interruption occurs at a very low level. Therefore, where it will be interrupted is unpredictable. The best way to use this capability is to do the following:

<OL>
<LI>Interrupt the application being debugged using the Debug | Break command.
<LI>Once the application has stopped, set a breakpoint where it will be encountered when the application is started back up.
<LI>Start the application back up with the Debug | Go command and let the breakpoint stop execution at a known location.
</OL></BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="WhatDoYouSee"><FONT SIZE=5 COLOR=#FF0000>
What Do You See?</FONT></A></H2>
<P>
So far, you have learned how to set breakpoints and control what
is being executed. Although this accomplishes quite a bit, a much
more useful tool is the capability to look at the state of the
application. This section covers how to inspect the values of
variables several different ways and how to take a look at the
Call Stack of the application.
<H3><A NAME="Variables">
Variables</A></H3>
<P>
One the of the most useful features of a debugger is to look at
the values of the variables in applications. The Visual J++ Debugger
allows several different ways, including automatically displaying
values using DataTips, an immediate inspection of variables using
the QuickWatch dialog, placing variables on a Watch window which
is automatically updated when values change, and by examining
the Variables window which always contains variables at differing
levels.
<H4>DataTips</H4>
<P>
A very quick and handy tool to use when inspecting values of variables
is to simply place the mouse over the variable to be inspected.
Figure 8.5 shows DataTips in action.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-5.gif"><B> Figure 8.5 : </B><I>Current execution point of a stopped application.
</I></A><P>
<P>
This is a quick and painless way to quickly glance at a value.
Expressions can also be inspected by simply highlighting the expression
and waiting for DataTips. Invalid expressions and variables not
in the current scope will not bring up DataTips.
<H4>QuickWatch</H4>
<P>
A more thorough inspection of the value of a variable is handled
with the QuickWatch window. Figure 8.6 shows the QuickWatch window.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-6.gif"><B> Figure 8.6 : </B><I>Example of the QuickWatch window.
</I></A><P>
<P>
The first edit window lets the user type in the expression that
is to be inspected. The bottom window shows the current value.
The user can examine the value and modify any values available
by simply clicking the value next to the item to be modified.
<P>
The value being displayed may have a small plus symbol (+) next
to the name in the name column. Visual J++ automatically detects
whether the expression being inspected is an object that contains
objects in itself. By pressing the plus symbol, additional lines
are added to the current value list representing the contained
objects. Typical examples of this are when inspecting arrays or
class instances. Figure 8.7 shows an example of inspecting the
current class instance.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-7.gif"><B> Figure 8.7 : </B><I>Inspecting the current instance.
</I></A><P>
<P>
You can change the expression and repopulate the current value
list by pressing the Recalculate button.
<P>
If the expression is a good one, you can add the expression as
a Watch by using the Watch button.
<H4>Watch</H4>
<P>
The Watch window is used to monitor values. The values of the
items being watched are updated when the values change. Therefore,
you can always see the current value of the item. Figure 8.8 shows
the Watch window.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-8.gif"><B> Figure 8.8 : </B><I>The Project Workspace showing the Watch window.
</I></A><P>
<P>
Again, Visual J++ detects objects that contain objects and indicates
the expandability of the objects with a small plus (+) symbol.
You can expand or collapse an item by pressing on the + or - symbols
next to the items.
<P>
You might have noticed that there are four tabs on the Watch window.
Watches can be logically collected together on each of the four
tabs. In this way, you can inspect the group of variables that
is most applicable to the area being debugged.
<P>
You can add a watch to the current table in a variety of ways:
<UL>
<LI>Through the Watch button of the QuickWatch dialog.
<LI>Select the item to be watched in the source and use the right
mouse button to drag the item to the Watch window.
<LI>Type the name of the item directly into the Watch window.
</UL>
<P>
Variables can be displayed using a variety of different formats
when displayed in the Watch window. To specify the format to display
a value, follow the name of the variable with a comma and a format
specification from Table 8.2. (This table can also be found in
the online Visual J++ documentation.)<BR>
<P>
<CENTER><B>Table 8.2. Format specifiers for displaying variables.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=96><I>Specifier</I></TD><TD WIDTH=480><I>Type of value displayed</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>d,i</TD><TD WIDTH=480>Signed decimal integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>u</TD><TD WIDTH=480>Unsigned decimal integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>o</TD><TD WIDTH=480>Unsigned octal integer</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=96>x,X</TD><TD WIDTH=480>Hexadecimal integer (non-numeric digits are displayed in the same case as the specifier)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>l,h</TD><TD WIDTH=480>Long or short prefix, respectively, for integer specifiers
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>f</TD><TD WIDTH=480>Signed floating point</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=96>e</TD><TD WIDTH=480>Signed scientific notation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>g</TD><TD WIDTH=480>Shorter version of either f or e
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>c</TD><TD WIDTH=480>Single character</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>s</TD><TD WIDTH=480>String</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>su</TD><TD WIDTH=480>Unicode string</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You can get additional information about a watched item by selecting
that item in the Watch window. Use the right mouse button to display
the pop-up menu and select the properties command. This will display
the dialog of Figure 8.9 showing the name, type, and value of
the item.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-9.gif"><B> Figure 8.9 : </B><I>The properties of a  watched item showing  the type of the item.
</I></A><P>
<H4>Variable Window</H4>
<P>
The Variable window is similar to the Watch window as seen in
Figure 8.10.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-10.gif"><B> Figure 8.10 : </B><I>The Project Workspace showing the Auto tab of  the Variable window.
</I></A><P>
<P>
The difference between the Variable window and the Watch window
is that the user cannot add variables to this window. Instead,
a variety of items are automatically added to various tabs as
shown in Table 8.3.<BR>
<P>
<CENTER><B>Table 8.3. Variable window tab contents.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=96><I>Tab</I></TD><TD WIDTH=480><I>Contents of the tab</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>Auto</TT></TD><TD WIDTH=480>Variables referenced in the current or previously executed instruction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>Local</TT></TD><TD WIDTH=480>All local variables defined in the current method
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>this</TT></TD><TD WIDTH=480>Object reference by <TT>this</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The values for the items in the Variable window are displayed
the same way as the Watch and QuickWatch windows. To modify the
values, simply double-click the value to be modified and start
typing. To show the type of an item, choose the item from the
window and use the pop-up menu to select the Properties command.
<P>
The context of the variables being displayed can be selected using
the combobox at the top of the Variable window. The combobox contains
the list of method calls that has led up to the execution of the
current method. The content of context combobox is also contained
in the Call Stack window.
<H4>Call Stack Window</H4>
<P>
The Call Stack window contains a logical mapping of the calls
made to get to the currently executing method. Every time a call
is made by a method, the calling method name is pushed onto the
top of the stack. When the called method returns, the name is
popped off the stack. The net result is a listing of methods called
to get to the current method. Figure 8.11 shows an example of
a Call Stack.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-11.gif"><B> Figure 8.11 : </B><I>The Project Workspace showing the Call Stack window.
</I></A><P><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You can move the Call Stack window by simply dragging the title bar of the window-normal window functionality. However, because the window is a dockable window, if you move it to a dockable area, say the bottom of the dialog, it might try to dock, even if 
that is not your intention. To prevent the docking from taking place, press the Ctrl key before releasing the window.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Each line in the Call Stack contains the line used to call the
method. In addition, the parameters types and value used in making
the call to the method are displayed.
<H2><A NAME="Exceptions"><FONT SIZE=5 COLOR=#FF0000>
Exceptions</FONT></A></H2>
<P>
Visual J++ supports debugging into exceptions through the use
of the Exceptions dialog of Fig-ure 8.12.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-12.gif"><B> Figure 8.12 : </B><I>Exceptions dialog.
</I></A><P>
<P>
To view the Exceptions dialog, execute the Debug | Exceptions
command. This dialog enables the user to specify an exception
and the action to be taken if the exception is thrown. Both system-
and user-defined exceptions can be handled.
<P>
The two actions that can occur when an exception is thrown is
to stop immediately or stop if the exception is not handled. One
advantage of stopping immediately is that the debugger will stop
as soon as the exception has been generated. The advantage of
this is that the user has the chance to examine the source code
in the state that caused the exception to occur and possibly fix
the cause of the exception, if it can be fixed by modifying the
value of a variable or a similar modification. Once the remedy
is in place, the user can restart the application, at which point
the user will be prompted if they would like the exception handlers
to be called. If the problem has been remedied, the user should
reply no.
<P>
The second action is notification that an exception was not handled
by the exception-handling routines. With this option, the user
will simply be notified that an unhandled exception occurred.
<H2><A NAME="Threads"><FONT SIZE=5 COLOR=#FF0000>
Threads</FONT></A></H2>
<P>
A thread is like a mini-process within an application. A process
can be made up of one to many threads with each thread performing
an individual task. The Visual J++ Debugger supports being able
to choose the thread to be debugged using the dialog shown in
Figure 8.13.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f8-13.gif"><B> Figure 8.13 : </B><I>Threads dialog.
</I></A><P>
<P>
This dialog shows that each thread in a process contains an identifying
id, a suspend quantity, a priority (which for Java threads will
always be normal), and the currently executing location. The location
can be displayed either in terms of method currently being executed
or in terms of address.
<P>
To learn more about multithreaded applications, see <A HREF="ch12.htm" >Chapter 12</A>,
&quot;Moving Up to Multithreading.&quot;
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Although you might  possibly never read this chapter, it is nice
to know that the Visual J++ Debugger enables the user extensive
control over setting breakpoints to stop the execution of an application,
lets the user to step in, and over, method calls, and allows for
easy inspection and modification of all the variables being used
by the application. In addition, support is provided to stop execution
of the application when exceptions are thrown and to specify the
thread that is to be debugged for multithreaded applications.
<HR>

<CENTER><P><A HREF="ch7.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
