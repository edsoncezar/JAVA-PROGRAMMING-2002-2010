<HTML>
<HEAD>
<TITLE>Chapter 5 -- Java's User Interface Components</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;5</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Java's User Interface Components</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ElementsofanAppletsInterface">
Elements of an Applet's Interface</A>
<UL>
<LI><A HREF="#EverythingIsaComponent">
Everything Is a Component</A>
<LI><A HREF="#Buttons">
Buttons</A>
<LI><A HREF="#TextFieldsandAreas">
Text Fields and Areas</A>
<LI><A HREF="#Labels">
Labels</A>
<LI><A HREF="#CheckboxesandCheckboxGroups">
Checkboxes and Checkbox Groups</A>
<LI><A HREF="#ListsandChoices">
Lists and Choices</A>
<LI><A HREF="#Scrollbars">
Scrollbars</A>
</UL>
<LI><A HREF="#LayingOutControls">
Laying Out Controls</A>
<UL>
<LI><A HREF="#LayoutManagersandtheResourceWizard">
Layout Managers and the Resource Wizard</A>
<LI><A HREF="#FlowLayout">
FlowLayout</A>
<LI><A HREF="#BorderLayout">
BorderLayout</A>
<LI><A HREF="#CardLayout">
CardLayout</A>
<LI><A HREF="#GridLayout">
GridLayout</A>
<LI><A HREF="#GridBagLayout">
GridBagLayout</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Back in the days before the graphical browser, the World Wide
Web was dominated by boring, text-only pages, and the only people
using the Web were researchers, programmers, and some college
students. The graphical browser changed all that by presenting
more visually appealing pages. Suddenly, everyone is surfing the
Web. Clearly, the change to an appealing, graphical user interface
has much to do with the growth in popularity of the Web. The information
in this chapter teaches you how to create an appealing user interface
for your Java applets. Without an appealing, intuitive, easy-to-use
user interface, it is very likely your Java applets will not have
the success you desire for them.
<H2><A NAME="ElementsofanAppletsInterface"><FONT SIZE=5 COLOR=#FF0000>
Elements of an Applet's Interface</FONT></A></H2>
<P>
In Java, an applet's user interface is created mostly by combining
classes that represent the following elements:
<UL>
<LI>Buttons
<LI>Text fields
<LI>Text areas
<LI>Labels
<LI>Checkboxes
<LI>Lists
<LI>Choices
<LI>Scrollbars
</UL>
<P>
These visual elements can be combined in any manner to create
the user interface your applet needs. For example, Figure 5.1
shows a Web-based applet that enables golfers to enter their scores
and submit them to a remote server.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-1.gif"><B> Figure 5.1 : </B><I>The Golf Scorekeeper applet illustrates most user interface components.
</I></A><P>
<P>
This figure shows all the common elements of a Java user interface.
The golfer's name is collected in a text field. The number of
holes played (9 or 18) is a Checkbox group. A List is used for
the course and a <TT>Choice</TT> is used for the time of day.
The score can be entered directly into a text field or can be
increased or decreased by using the adjacent scrollbar. The amenities
(<TT>Golf Cart</TT> and <TT>Caddy</TT>) are checkboxes. The comment
area is a multiline text area. The use of each of these user interface
elements is explained in detail in the following sections.
<H3><A NAME="EverythingIsaComponent">
Everything Is a Component</A></H3>
<P>
You were introduced to the <TT>Component</TT> class in Chapter
4, &quot;Applet Programming Fundamentals,&quot; because of its
importance in passing events from one subclass of <TT>Component</TT>
to another. <TT>Component</TT> serves as the base class for most
of Java's user interface classes.
<P>
As the base class for Java's user interface classes, <TT>Component</TT>
does much more than provide a common set of event handlers for
each user interface object. <TT>Component</TT> is a very large
class that makes over 70 methods available to its subclasses.
The most important or frequently used of these are shown in Table
5.1.<BR>
<P>
<CENTER><B>Table 5.1. Some useful public members of Component.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=157><I>Method</I></TD><TD WIDTH=433><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>action</TT></TD><TD WIDTH=433>An event-handling method called when action events occur.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>disable</TT></TD><TD WIDTH=433>Disables the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>enable</TT></TD><TD WIDTH=433>Enables the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getBackground</TT></TD><TD WIDTH=433>Returns the background color of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getFont</TT></TD><TD WIDTH=433>Returns the font in use on the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getFontMetrics</TT></TD><TD WIDTH=433>Returns the font metrics (character height, width, and so on) of the component's font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getForeground</TT></TD><TD WIDTH=433>Returns the foreground color of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getGraphics</TT></TD><TD WIDTH=433>Gets a reference to the graphics object for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>getParent</TT></TD><TD WIDTH=433>Gets the component's parent.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>gotFocus</TT></TD><TD WIDTH=433>An event-handling method called when the component receives the focus.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>handleEvent</TT></TD><TD WIDTH=433>A generic event-handling method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>hide</TT></TD><TD WIDTH=433>Makes the component invisible.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>inside</TT></TD><TD WIDTH=433>Determines whether a position given by x, y coordinates is inside the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>isEnabled</TT></TD><TD WIDTH=433>Returns true if the component is enabled.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>isVisible</TT></TD><TD WIDTH=433>Returns true if the component is visible.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>lostFocus</TT></TD><TD WIDTH=433>An event-handling method called when the component loses the focus.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>minimumSize</TT></TD><TD WIDTH=433>Returns the minimum size required by the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseDown</TT></TD><TD WIDTH=433>An event-handling method called when the mouse button is pressed down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseDrag</TT></TD><TD WIDTH=433>An event-handling method called when the mouse is moved while the button is held down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseEnter</TT></TD><TD WIDTH=433>An event-handling method called when the mouse enters the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseExit</TT></TD><TD WIDTH=433>An event-handling method called when the mouse exits the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseMove</TT></TD><TD WIDTH=433>An event-handling method called when the mouse is moved without holding the button down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>mouseUp</TT></TD><TD WIDTH=433>An event-handling method called when the mouse button is released.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>move</TT></TD><TD WIDTH=433>Relocates the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>nextFocus</TT></TD><TD WIDTH=433>Gives focus to the next component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>paint</TT></TD><TD WIDTH=433>Paints the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>preferredSize</TT></TD><TD WIDTH=433>Returns the preferred dimensions of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>repaint</TT></TD><TD WIDTH=433>Causes the component to be repainted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>resize</TT></TD><TD WIDTH=433>Changes the dimensions of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>setBackground</TT></TD><TD WIDTH=433>Sets the background color of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>setFont</TT></TD><TD WIDTH=433>Sets the font that will be used by the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>setForeground</TT></TD><TD WIDTH=433>Sets the foreground color of the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=157><TT>show</TT></TD><TD WIDTH=433>Makes the component visible.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Buttons">
Buttons</A></H3>
<P>
Buttons are one of the simplest Java user interface classes and
are therefore a good starting point. To create a button you can
use either of the constructors shown in Table 5.2. Of course,
you'll find the constructor that takes a label as a parameter
much more useful than the one that does not, unless you want users
to have to guess what a button does.<BR>
<P>
<CENTER><B>Table 5.2. Button constructors.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=180><I>Constructor</I></TD><TD WIDTH=320><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=180><TT>Button()</TT></TD><TD WIDTH=320>Creates a button without a label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=180><TT>Button(String label)</TT></TD><TD WIDTH=320>Creates a button with the specified label.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of how to construct and use a button, consider <TT>EX05A
</TT>as shown in Listing 5.1. This is a no-frills example of placing
a button on an applet and then displaying a message when the button
is pressed. After the button is created the <TT>add</TT> method
is used to add the button to the applet. Because <TT>add</TT>
is defined in <TT>java.awt.Container</TT> and <TT>Applet</TT>
is a subclass of <TT>Container</TT>, the button is added to the
applet and will be displayed when the applet is run. The results
of running this applet can be seen in Figure 5.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-2.gif"><B> Figure 5.2 : </B><I>EX05A after the button has been pushed.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 5.1. EX05A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05A extends Applet
{
    Button myButton;

    public void init()
    {
        resize(320, 240);

        myButton = new Button(&quot;Push me!&quot;);
        add(myButton);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Push me!&quot;.equals(obj)) {
            getGraphics().drawString(&quot;You pushed it!&quot;, 20, 20);
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>Handling Button Events</H4>
<P>
In <A HREF="ch4.htm" >Chapter 4</A> you learned how to process mouse and keyboard events.
Although a button may be pushed as a result of the user clicking
a mouse button, Java provides a different message-handling method
for use when a button has been pushed. In Listing 5.1, you may
have noticed the inclusion of the <TT>action</TT> method, a method
that hasn't been mentioned so far. The <TT>action</TT> method
is used to handle a variety of events such as button presses,
checkbox selection, or menu selection.
<P>
The <TT>action</TT> method is passed the event that has occurred
and the object to which the event happened. In Listing 5.1 the
<TT>equals</TT> method is used to compare the <TT>Object </TT>parameter
and the button's label. If equal, the object was the button. In
this example a message is displayed.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In Listing 5.1, the allocated button was stored in a member variable. However, because the button can later be referenced by its label (for example, &quot;Push me!&quot;) and because Java supports automatic memory management, this is not necessary. The 
<TT>Button</TT> constructor can return the new button directly as a parameter to the <TT>add</TT> method (or any other method) as shown in the following
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<BLOCKQUOTE>
<PRE>
   public void init()
   {
   resize(320, 240);
   add(new Button(&quot;Push me!&quot;));
   }
</PRE>
</BLOCKQUOTE>
<H4>Public Button Methods</H4>
<P>
In addition to its constructors and to the methods available to
it as a subclass of <TT>Component</TT>, the <TT>Button</TT> class
provides the public member methods shown in Table 5.3.<BR>
<P>
<CENTER><B>Table 5.3. Public member methods of the Button class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=150><I>Method</I></TD><TD WIDTH=308><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>addNotify()</TT></TD><TD WIDTH=308>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>getLabel()</TT></TD><TD WIDTH=308>Returns the button's current label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>paramString()</TT></TD><TD WIDTH=308>Returns the button's parameter string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=150><TT>SetLabel(String)</TT></TD><TD WIDTH=308>Sets the button's label to the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>EX05B</TT> is a more involved example of how to use the <TT>Button</TT>
class and is shown in Listing 5.2. In this example, two buttons
are created, one of which is disabled. This is shown in Figure
5.3.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-3.gif"><B> Figure 5.3 : </B><I>EX05B before any buttons are pushed.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 5.2. EX05B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05B extends Applet
{
    int count = 0;
    Button button2 = new Button(&quot;Now push me&quot;);

    public void init()
    {
        resize(320, 240);

        add(new Button(&quot;Push me!&quot;));

        button2.disable();
        add(button2);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Push me!&quot;.equals(obj)) {
            count++;

            switch(count) 
            {
            case 1:
                button2.setLabel(&quot;almost&quot;);
                break;
            case 2:
                button2.setLabel(&quot;Now push me&quot;);
                button2.enable();
                break;
            }
            result = true;
        }
        else if(&quot;Now push me&quot;.equals(obj)) {
            getGraphics().drawString(&quot;Thank you&quot;, 20, 60);
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When <TT>EX05B</TT> starts running only the button labeled Push
me! is enabled. Pushing this button will invoke the applet's <TT>action</TT>
method, which keeps track of how many times the button has been
pushed. If it has been pushed once, the second button's label
is changed to Almost. If it has been pushed twice, the second
button's label is reset to Now push me, and the button is enabled.
Once the Now push me button is pushed, it displays a Thank you
message as shown in Figure 5.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-4.gif"><B> Figure 5.4 : </B><I>EX05B after pushing  the Now push  me button.
</I></A><P>
<H3><A NAME="TextFieldsandAreas">
Text Fields and Areas</A></H3>
<P>
A text field is a one-line area for data-entry. A text area is
multiline text field that includes scrollbars. There are various
ways of constructing a text field or text area, as can be seen
in the following examples:
<BLOCKQUOTE>
<PRE>
TextField tf1 = new TextField(25);
TextField tf2 = new TextField(&quot;This is a TextField&quot;);
TextArea ta1 = new TextArea(10, 50);
TextArea ta2 = new TextArea(&quot;This is a 10 x 50 TextArea&quot;, 10, 50);
</PRE>
</BLOCKQUOTE>
<P>
In this example, <TT>tf1</TT> is constructed as a 25-column, 1-row
text field; <TT>tf2</TT> is constructed as a text field wide enough
to hold the string &quot;<TT>This is a</TT> <TT>TextField</TT>&quot;.
Both text areas <TT>ta1</TT> and <TT>ta2</TT> will be 10 rows
by 50 columns, but <TT>ta2</TT> will contain the initial text
shown. There are additional constructors for text field and text
area beyond those demonstrated in these examples. Tables 5.4 and
5.5 show the constructors available for <TT>TextField</TT> and
<TT>TextAreaField</TT>, respectively.<BR>
<P>
<CENTER><B>Table 5.4. Constructors for the TextField class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Constructor</I></TD><TD WIDTH=356><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextField()</TT></TD><TD WIDTH=356>Creates a new, empty text field.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextField(int)</TT></TD><TD WIDTH=356>Creates a new text field with the specified number of columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextField(String)</TT></TD><TD WIDTH=356>Creates a new text field containing the specified <TT>String</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextField(String, int)</TT></TD><TD WIDTH=356>Creates a new text field with the specified number of columns and containing the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER><B>Table 5.5. Constructors for the TextAreaField class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Constructor</I></TD><TD WIDTH=356><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextArea()</TT></TD><TD WIDTH=356>Creates a new, empty text area.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextArea(int, int)</TT></TD><TD WIDTH=356>Creates a new text area with the specified number of rows and columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextArea(String)</TT></TD><TD WIDTH=356>Creates a new text area containing the specified <TT>String</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>TextArea(String,int,int)</TT></TD><TD WIDTH=356>Creates a new text area with the specified number of rows and columns and containing the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Both <TT>TextField</TT> and <TT>TextArea</TT> are subclasses of
the <TT>TextComponent</TT> class. This common base class provides
the public methods listed in Table 5.6.<BR>
<P>
<CENTER><B>Table 5.6. Public members of TextComponent.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Method</I></TD><TD WIDTH=356><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getSelectedText()</TT></TD><TD WIDTH=356>Returns the currently selected text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetSelectionEnd()</TT></TD><TD WIDTH=356>Returns the ending column number of the selected text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetSelectionStart()</TT></TD><TD WIDTH=356>Returns the starting column number of the selected text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getText()</TT></TD><TD WIDTH=356>Returns the text in <TT>TextComponent</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>IsEditable()</TT></TD><TD WIDTH=356>Returns true if <TT>TextComponent</TT> is editable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>ParamString()</TT></TD><TD WIDTH=356>Returns a parameter string for <TT>TextComponent</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>RemoveNotify()</TT></TD><TD WIDTH=356>Removes <TT>TextComponent's</TT> peer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>select(int, int)</TT></TD><TD WIDTH=356>Selects the text between the specified columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>SelectAll()</TT></TD><TD WIDTH=356>Selects all of the text.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>SetEditable(boolean)</TT></TD><TD WIDTH=356>Indicates whether <TT>TextComponent</TT> is editable by the user.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>setText(String)</TT></TD><TD WIDTH=356>Sets <TT>TextComponent</TT> to contain the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Beyond the methods shared through the <TT>TextComponent</TT> class,
<TT>TextField</TT> and <TT>TextArea</TT> each implements its own
additional member methods. These are listed in Tables 5.7 and
5.8.<BR>
<P>
<CENTER><B>Table 5.7. Public members of TextField.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Method</I></TD><TD WIDTH=356><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>addNotify()</TT></TD><TD WIDTH=356>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>EchoCharIsSet()</TT></TD><TD WIDTH=356>Returns true if an echo character has been set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetColumns()</TT></TD><TD WIDTH=356>Returns the number of columns for <TT>TextField</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>GetEchoChar()</TT></TD><TD WIDTH=356>Returns the echo character that will be used.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>MinimumSize(int)</TT></TD><TD WIDTH=356>Returns the minimum dimensions for <TT>TextField</TT> with the specified number of columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>MinimumSize()</TT></TD><TD WIDTH=356>Returns the minimum dimensions for <TT>TextField</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>ParamString()</TT></TD><TD WIDTH=356>Returns a parameter string for <TT>TextField</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>PreferredSize(int)</TT></TD><TD WIDTH=356>Returns the preferred dimensions for <TT>TextField</TT> with the specified number of columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>PreferredSize()</TT></TD><TD WIDTH=356>Returns the preferred dimensions for <TT>TextField</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>SetEchoCharacter(char)</TT></TD><TD WIDTH=356>Sets the echo character to the specified character.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER><B>Table 5.8. Public members of TextArea.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=234><I>Method</I></TD><TD WIDTH=356><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>addNotify()</TT></TD><TD WIDTH=356>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>appendText(String)</TT></TD><TD WIDTH=356>Appends the specified string to <TT>TextArea</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getColumns()</TT></TD><TD WIDTH=356>Returns the number of columns for <TT>TextArea</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>getRows()</TT></TD><TD WIDTH=356>Returns the number of rows for <TT>TextArea</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>insertText(String, int)</TT></TD><TD WIDTH=356>Inserts the specified String at the specified column.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>minimumSize(int, int)</TT></TD><TD WIDTH=356>Returns the minimum dimensions for <TT>TextArea</TT> with the specified number of rows and columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>minimumSize()</TT></TD><TD WIDTH=356>Returns the minimum dimensions for <TT>TextArea</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>paramString()</TT></TD><TD WIDTH=356>Returns a parameter string for <TT>TextArea</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>preferredSize(int, int)</TT></TD><TD WIDTH=356>Returns the preferred dimensions for <TT>TextArea</TT> with the specified number of rows and columns.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=234><TT>preferredSize()</TT></TD><TD WIDTH=356>Returns the preferred dimensions for <TT>TextArea</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>ReplaceText(String, int, int)</TT> Uses the specified string
to replace text between the specified columns.
<H4>A Text Field and Text Area Example</H4>
<P>
Listing 5.3 contains the <TT>EX05C</TT> class, which is a demonstration
of using text fields and text areas. In this case, two text fields
and two text areas are created. In the <TT>init</TT> method, each
of these components is resized to its preferred size and then
added to the applet. The first text field, <TT>tf1</TT>, uses
<TT>setEchoCharacter</TT> to set the asterisk character as the
character that will appear on the display regardless of what is
typed. A button is created that, when pushed, will copy the text
from each of the text fields into the text areas.
<HR>
<BLOCKQUOTE>
<B>Listing 5.3. EX05C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05C extends Applet
{
    TextField tf1 = new TextField(25);
    TextField tf2 = new TextField(&quot;This is a TextField&quot;);
    TextArea ta1 = new TextArea(10, 50);
    TextArea ta2 = new TextArea(&quot;This is a 10 x 50 TextArea&quot;, 10, 50);

    public void init()
    {
        resize(320, 400);

        tf1.resize(tf1.preferredSize());
        tf1.setEchoCharacter('*');
        add(tf1);

        ta1.resize(ta1.preferredSize());
        add(ta1);

        tf2.resize(tf2.preferredSize());
        add(tf2);


        ta2.resize(ta2.preferredSize());
        add(ta2);

        add(new Button(&quot;Update&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Update&quot;.equals(obj)) {
            ta1.appendText(tf1.getText() + &quot;\r\n&quot;);
            ta2.insertText(tf2.getText() + &quot;\r\n&quot;, 0);

            tf1.setText(&quot;&quot;);
            tf2.setText(&quot;&quot;);

            result = true;
            return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>action</TT> method of <TT>EX05C</TT> checks to see whether
the action was generated by the Update button. If so, <TT>tf1.getText</TT>
and <TT>ta1.appendText</TT> are used to copy the text from the
first text field, <TT>tf1</TT>, into the first text area, <TT>ta1</TT>.
Similar operations are performed on the second fields except that
the text is inserted into the beginning of the second text area,
<TT>ta2</TT>, instead of appended to its end. After the text has
been copied from the two <TT>TextField</TT> objects, each is set
to an empty string. The results of running <TT>EX05C </TT>are
shown in Figure 5.5. Notice that even though <TT>tf1</TT> uses
an echo character, the underlying text and not the echo character
is copied to <TT>ta1</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-5.gif"><B> Figure 5.5 : </B><I>EX05C after  several updates.
</I></A><P>
<H3><A NAME="Labels">
Labels</A></H3>
<P>
Of course, if you put a text field or text area on the screen,
you should probably tell your user what you expect him to enter.
You may have noticed that there is no capability to associate
a prompt directly with a text field or text area. Instead, in
Java, you use a different user interface class to create prompts:
<TT>Label</TT>. The <TT>Label</TT> class contains three constructors
as shown in Table 5.9.<BR>
<P>
<CENTER><B>Table 5.9. Constructors for the Label class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=196><I>Constructor</I></TD><TD WIDTH=394><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>Label()</TT></TD><TD WIDTH=394>Creates a label without a name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>Label(String)</TT></TD><TD WIDTH=394>Creates a new label with the specified <TT>String</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>Label(String, int)</TT></TD><TD WIDTH=394>Creates a new label using the specified <TT>String </TT>and alignment value.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The alignment values specify how the text on the label should
appear. Your choices are <TT>Label.LEFT</TT>, <TT>Label.RIGHT</TT>,
and <TT>Label.CENTER</TT>. The following two lines will create
two new labels:
<BLOCKQUOTE>
<PRE>
add(new Label(&quot;Social Security Number:&quot;, Label.RIGHT);
add(new Label(&quot;First Name:&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In addition to its constructors, the <TT>Label</TT> class provides
the public methods shown in Table 5.10. Among other things, these
methods enable you to change a label's text and alignment while
the applet is running. As an example of this, look at class <TT>EX05D</TT>
shown in Listing 5.4.<BR>
<P>
<CENTER><B>Table 5.10. Public methods of the Label class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=65%>
<TR VALIGN=TOP><TD WIDTH=170><I>Method</I></TD><TD WIDTH=345><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>addNotify()</TT></TD><TD WIDTH=345>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>GetAlignment()</TT></TD><TD WIDTH=345>Returns the alignment value for the label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>GetText()</TT></TD><TD WIDTH=345>Returns the text on the label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>ParamString()</TT></TD><TD WIDTH=345>Returns a parameter string for the label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>SetAlignment(int)</TT></TD><TD WIDTH=345>Sets the alignment value for the label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>SetText(String)</TT></TD><TD WIDTH=345>Sets the text of the label to the specified <TT>String</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>An Example</H4>
<P>
<TT>EX05D</TT> is an applet that could be the front end of a database
program that lets users search for people in the database by Social
Security number or name. When first loaded, the applet is ready
to search by Social Security number, as shown in Figure 5.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-6.gif"><B> Figure 5.6 : </B><I>Searching EX05D by Social Security number.
</I></A><P>
<P>
However, if the user doesn't know the Social Security number of
the person he is searching for, he can select the Change button.
This will change the search to be a name search, as shown in Figure
5.7.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-7.gif"><B> Figure 5.7 : </B><I>In EX05D, selecting Change enables you to search by name.
</I></A><P>
<P>
In class <TT>EX05D,</TT> a label displaying the applet's name
is constructed and added to the applet. In the <TT>init</TT> method,
an eponymously named label is constructed with the text <TT>Social
Security Number</TT>. After the label is added to the applet,
a text field and button are also added.
<HR>
<BLOCKQUOTE>
<B>Listing 5.4. EX05D.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05D extends Applet
{
    Label label;

    public void init()
    {
        resize(320, 240);

        add(new Label(&quot;Example EX05D: Labels and Buttons&quot;));

        label = new Label(&quot;Social Security Number:&quot;, Label.RIGHT);
        add(label);
        add(new TextField(25));
        add(new Button(&quot;Change&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Change&quot;.equals(obj)) {
            if(label.getText().equals(&quot;Name:&quot;))
                label.setText(&quot;Social Security Number:&quot;);
            else
                label.setText(&quot;Name:&quot;);
        }
            result = true;
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>action</TT> method looks to see whether the Change button
has been pressed. If so, it toggles the text on the label between
<TT>&quot;Name:&quot;</TT> and <TT>&quot;Social Security Number:&quot;</TT>.
When <TT>label</TT> was constructed, its alignment was set as
<TT>Label.RIGHT</TT>. Because of this, the shorter <TT>&quot;Name:&quot;</TT>
label will be right-aligned in the space initially used by <TT>&quot;Social
Security Number:&quot;</TT>. This can be seen in Figure 5.8. If
<TT>label</TT> had been constructed without specifying an alignment,
the text would have been left-aligned.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-8.gif"><B> Figure 5.8 : </B><I>Grouped and ungrouped checkboxes in action.
</I></A><P>
<H3><A NAME="CheckboxesandCheckboxGroups">
Checkboxes and Checkbox Groups</A></H3>
<P>
Java checkboxes come in two varieties: grouped and ungrouped.
Instances of the Java <TT>Checkbox</TT> classes are grouped using
the <TT>CheckboxGroup</TT> class. If a <TT>CheckboxGroup</TT>
contains more than one checkbox, only one of the checkboxes in
the group can be set at any given time. In other programming environments,
you may be used to referring to grouped checkboxes as radio buttons.
You can see an example of a <TT>CheckboxGroup</TT> in Figure 5.8.
The Male and Female buttons are grouped together and are therefore
mutually exclusive.
<P>
Ungrouped checkboxes, on the other hand, can be checked or unchecked
without regard to other checkboxes. In Figure 5.9 each of the
sports is associated with an ungrouped checkbox because a user
may need to mark more than one box.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-9.gif"><B> Figure 5.9 : </B><I>The results of running EX05E.
</I></A><P>
<P>
There are three constructors for the <TT>Checkbox</TT> class,
as shown in Table 5.11. Only one of the constructors assigns the
new <TT>Checkbox</TT> object to a <TT>CheckboxGroup</TT>. The
<TT>CheckboxGroup</TT> class has a single constructor that requires
no parameters. The easiest way to assign a <TT>Checkbox</TT> to
a <TT>CheckboxGroup</TT> is with the appropriate constructor.
In the following code, a two-item group is created and then three
ungrouped items are created:
<BLOCKQUOTE>
<PRE>
CheckboxGroup genderGroup = new CheckboxGroup();
add(new Checkbox(&quot;Male&quot;,   genderGroup, false));
add(new Checkbox(&quot;Female&quot;, genderGroup, true));

add(new Checkbox(&quot;Option 1&quot;));
add(new Checkbox(&quot;Option 2&quot;));
add(new Checkbox(&quot;Option 3&quot;));<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 5.11. Constructors for the Checkbox class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=137><I>Constructor</I></TD><TD WIDTH=317><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=137><TT>Checkbox()</TT></TD><TD WIDTH=317>Creates a checkbox without a label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=137><TT>Checkbox(String)</TT></TD><TD WIDTH=317>Creates a checkbox using the specified String.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Checkbox(String, CheckboxGroup, boolean) Creates a checkbox in
the specified group, using the specified String and set to the
specified default value.
<P>
In addition to their constructors, the Checkbox and CheckboxGroup
classes offer additional public methods, as shown in Tables 5.12
and 5.13.<BR>
<P>
<CENTER><B>Table 5.12. Public methods of the Checkbox class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=263><I>Method</I></TD><TD WIDTH=327><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>addNotify()</TT></TD><TD WIDTH=327>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>GetCheckboxGroup()</TT></TD><TD WIDTH=327>Returns the checkbox group to which the checkbox belongs.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>getLabel()</TT></TD><TD WIDTH=327>Returns the text on the checkbox.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>getState()</TT></TD><TD WIDTH=327>Returns true if the checkbox is selected.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>ParamString()</TT></TD><TD WIDTH=327>Returns a parameter string for the label.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>SetCheckboxGroup(CheckboxGroup)</TT></TD>
<TD WIDTH=327>Assigns the checkbox to the specified CheckboxGroup.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>setLabel(String)</TT></TD><TD WIDTH=327>Sets the text on the checkbox.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=263><TT>setState(boolean)</TT></TD><TD WIDTH=327>Checks or unchecks the checkbox.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>Table 5.13. Public methods of the CheckboxGroup class.</CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=167><I>Method</I></TD><TD WIDTH=423><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>getCurrent()</TT></TD><TD WIDTH=423>Returns the currently selected checkbox.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>SetCurrent(Checkbox)</TT></TD><TD WIDTH=423>Makes the specified checkbox the current selection for the group.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT>toString()</TT></TD><TD WIDTH=423>Returns a String showing the current values of the CheckboxGroup. Useful for debugging.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>An Example</H4>
<P>
As an example of using <TT>Checkbox</TT>es and <TT>CheckboxGroups</TT>,
consider class <TT>EX05E </TT>as shown in Listing 5.5. This class
creates the applet shown in Figure 5.8. The <TT>init</TT> method
adds two checkboxes to the gender <TT>CheckboxGroup</TT>, five
ungrouped checkboxes, a Save button, and a text area. When the
Save button is pushed, the value in each of the checked checkboxes
will be written to the text area.
<HR>
<BLOCKQUOTE>
<B>Listing 5.5. EX05E.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05E extends Applet
{
    CheckboxGroup genderGroup = new CheckboxGroup();
    Checkbox runCheckbox  = new Checkbox(&quot;Run&quot;);
    Checkbox bikeCheckbox = new Checkbox(&quot;Bike&quot;);
    Checkbox swimCheckbox = new Checkbox(&quot;Swim&quot;);
    Checkbox rowCheckbox  = new Checkbox(&quot;Row&quot;);
    Checkbox liftCheckbox = new Checkbox(&quot;Weight Lift&quot;);
    TextArea results = new TextArea(10, 25);


    public void init()
    {
        resize(320, 240);

        add(new Label(&quot;Gender: &quot;));
        add(new Checkbox(&quot;Male&quot;,   genderGroup, false));
        add(new Checkbox(&quot;Female&quot;, genderGroup, true));

        add(new Label(&quot;In your spare time, what sports do you participate in?&quot;));
        add(runCheckbox);
        add(bikeCheckbox);
        add(swimCheckbox);
        add(rowCheckbox);
        add(liftCheckbox);

        add(new Button(&quot;Save&quot;));

        add(results);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Save&quot;.equals(obj)) {
            // clear the results area
            results.setText(&quot;&quot;);

            // display the gender
            Checkbox current = genderGroup.getCurrent();
            results.appendText(current.getLabel() + &quot;\r\n&quot;);

            // check each of the sports
            if (swimCheckbox.getState() == true)
                results.appendText(&quot;Swim\r\n&quot;);
            if (bikeCheckbox.getState() == true)
                results.appendText(&quot;Bike\r\n&quot;);
            if (runCheckbox.getState() == true)
                results.appendText(&quot;Run\r\n&quot;);
            if (rowCheckbox.getState() == true)
                results.appendText(&quot;Row\r\n&quot;);
            if (liftCheckbox.getState() == true)
                results.appendText(&quot;Weight Lift\r\n&quot;);
            
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you've seen in other examples in this chapter, the <TT>action</TT>
method takes care of detecting when a button has been pushed.
In this case the text area, <TT>results</TT>, is cleared. The
current selection in <TT>genderGroup</TT> is then retrieved and
the label on the current <TT>genderGroup</TT> checkbox is written
to <TT>results</TT>. Finally, each of the ungrouped checkboxes
is checked and text is appended to <TT>results</TT> for each that
is checked. The results of this can be seen in Figure 5.9.
<H3><A NAME="ListsandChoices">
Lists and Choices</A></H3>
<P>
Checkboxes are not the only way to present options to your users.
You can also use Java's <TT>Choice</TT> and <TT>List</TT> classes.
In Java, a choice is a drop-down list from which the user may
make a single selection. A list is a variable sized region from
which the user may select one or more items. Figure 5.10 shows
a screen that makes use of a choice to gather a person's gender
and a list of sports, similar to what was done with <TT>Checkbox</TT>es
in example <TT>EX04E</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-10.gif"><B> Figure 5.10 : </B><I>A Gender choice and a Sports list.
</I></A><P>
<P>
When you want to place a list or a choice onto an applet (or other
Java container), you must take the following three steps:
<OL>
<LI>Construct the new <TT>List</TT> or <TT>Choice</TT> object.
<LI>Add items to the <TT>List</TT> or <TT>Choice</TT> object.
<LI>Place the <TT>List</TT> or <TT>Choice</TT> object onto the
applet.
</OL>
<P>
The following code illustrates these steps in creating a new choice:
<BLOCKQUOTE>
<PRE>
// create a Choice object
Choice genderChoice = new Choice();

// add items to the Choice
genderChoice.addItem(&quot;Male&quot;);
genderChoice.addItem(&quot;Female&quot;);

// then add the Choice to the applet
add(genderChoice);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>Choice</TT> class only has a single, no-parameter constructor.
An object of the <TT>List</TT> class, however, can be created
using either of the two constructors shown in Table 5.14. Usually
you will use the second constructor in order to specify the number
of visible rows and whether the user can select multiple items
in the <TT>List</TT>.<BR>
<P>
<CENTER><B>Table 5.14. Constructors for the List class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=156><I>Constructor</I></TD><TD WIDTH=420><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=156><TT>List()</TT></TD><TD WIDTH=420>Creates a new, empty list without any visible lines.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=156><TT>List(int, boolean)</TT></TD><TD WIDTH=420>Creates a new list with the specified number of visible lines. The <TT>boolean</TT> parameter specifies whether to allow multiple selections.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of creating a new list and adding five items to
it, consider the following:
<BLOCKQUOTE>
<PRE>
// create a List object
List sportList = new List(5, true);

// add items to the List
sportList.addItem(&quot;Swim&quot;);
sportList.addItem(&quot;Bike&quot;);
sportList.addItem(&quot;Run&quot;);
sportList.addItem(&quot;Row&quot;);
sportList.addItem(&quot;Weight Lift&quot;);

// then add the List to the applet
add(sportList);
</PRE>
</BLOCKQUOTE>
<H4>List and Choice Public Methods</H4>
<P>
Because of the many ways in which a user can interact with a list
or a choice, these Java classes include many public member methods.
The public methods of <TT>List</TT> are shown in Table 5.15, and
the public methods of choice are shown in Table 5.16.<BR>
<P>
<CENTER><B>Table 5.15. Public methods of the List class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=200><I>Method</I></TD><TD WIDTH=300><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD><TT>addItem(String)</TT></TD><TD>Adds the specified string to the bottom of the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>AddItem(String, int)</TT></TD><TD>Adds the specified string at the specified index in the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>AddNotify()</TT></TD><TD>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD><TT>AllowsMultipleSelection()</TT></TD><TD>Returns true if the user can select multiple list items.
</TD></TR>
<TR VALIGN=TOP><TD><TT>Clear()</TT></TD><TD>Removes all items from the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>CountItems()</TT></TD><TD>Returns the quantity of items in the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>DelItem(int)</TT></TD><TD>Deletes the item at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD><TT>DelItems(int, int)</TT></TD><TD>Deletes the specified range of items.
</TD></TR>
<TR VALIGN=TOP><TD><TT>Deselect(int)</TT></TD><TD>Deselects the item at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD><TT>GetItem(int)</TT></TD><TD>Returns the item string at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD><TT>GetRows()</TT></TD><TD>Returns the number of visible rows.
</TD></TR>
<TR VALIGN=TOP><TD><TT>GetSelectedIndex()</TT></TD><TD>Returns the index number of the selected item.
</TD></TR>
<TR VALIGN=TOP><TD><TT>GetSelectedIndexes()</TT></TD><TD>Returns the index numbers of the selected items.
</TD></TR>
<TR VALIGN=TOP><TD><TT>getSelectedItem()</TT></TD><TD>Returns the item string of the selected item.
</TD></TR>
<TR VALIGN=TOP><TD><TT>getSelectedItems()</TT></TD><TD>Returns the item string of the selected items.
</TD></TR>
<TR VALIGN=TOP><TD><TT>getVisibleIndex()</TT></TD><TD>Returns the index of the last item passed to <TT>makeVisible</TT>.
</TD></TR>
<TR VALIGN=TOP><TD><TT>isSelected(int)</TT></TD><TD>Returns true if the specified item is selected.
</TD></TR>
<TR VALIGN=TOP><TD><TT>makeVisible(int)</TT></TD><TD>Makes the specified item visible in the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>minimumSize(int)</TT></TD><TD>Returns the minimum dimensions for a list with the specified number of rows.
</TD></TR>
<TR VALIGN=TOP><TD><TT>minimumSize()</TT></TD><TD>Returns the minimum dimensions for the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>paramString()</TT></TD><TD>Returns a parameter string for the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>preferredSize(int)</TT></TD><TD>Returns the preferred dimensions for a list with the specified number of rows.
</TD></TR>
<TR VALIGN=TOP><TD><TT>preferredSize()</TT></TD><TD>Returns the preferred dimensions for the list.
</TD></TR>
<TR VALIGN=TOP><TD><TT>removeNotify()</TT></TD><TD>Remove the list's peer.
</TD></TR>
<TR VALIGN=TOP><TD><TT>ReplaceItem(String, int)</TT></TD><TD>Replaces the item at the specified index with the specified string.
</TD></TR>
<TR VALIGN=TOP><TD><TT>Select(int)</TT></TD><TD>Selects the specified item.
</TD></TR>
<TR VALIGN=TOP><TD><TT>SetMultipleSelection(boolean)</TT></TD>
<TD>Enables or disables the selection of multiple items in the list.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER><B>Table 5.16. Public methods of the Choice class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=70%>
<TR VALIGN=TOP><TD WIDTH=196><I>Method</I></TD><TD WIDTH=369><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>addItem(String)</TT></TD><TD WIDTH=369>Adds the specified string<TT> </TT>to the bottom of the choice.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>AddNotify()</TT></TD><TD WIDTH=369>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>CountItems()</TT></TD><TD WIDTH=369>Returns the quantity of items in the choice.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>GetItem(int)</TT></TD><TD WIDTH=369>Returns the item string at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>GetSelectedIndex()</TT></TD><TD WIDTH=369>Returns the index number of the selected item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>GetSelectedItem()</TT></TD><TD WIDTH=369>Returns the item string of the selected item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>ParamString()</TT></TD><TD WIDTH=369>Returns a parameter string for the choice.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>Select(int)</TT></TD><TD WIDTH=369>Selects the specified item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=196><TT>Select(String)</TT></TD><TD WIDTH=369>Selects the specified string in the choice.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>An Example</H4>
<P>
To see the use of the <TT>List</TT> and <TT>Choice</TT> classes
and some of their public member methods, consider <TT>EX05F</TT>,
shown in Listing 5.6. This example creates the applet window shown
in Figure 5.11.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-11.gif"><B> Figure 5.11 : </B><I>EX05F after adding and deleting some sports.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 5.6. EX05F.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05F extends Applet
{
    Choice genderChoice = new Choice();
    List sportList = new List(5, true);
    TextArea results = new TextArea(10, 25);
    TextField newSport = new TextField(15);

    public void init()
    {
        add(new Label(&quot;Gender: &quot;));

        genderChoice.addItem(&quot;Male&quot;);
        genderChoice.addItem(&quot;Female&quot;);
        add(genderChoice);

        add(new Label(&quot;Sports: &quot;));
        sportList.addItem(&quot;Swim&quot;);
        sportList.addItem(&quot;Bike&quot;);
        sportList.addItem(&quot;Run&quot;);
        sportList.addItem(&quot;Row&quot;);
        sportList.addItem(&quot;Weight Lift&quot;);
        add(sportList);

        add(new Label(&quot;New Sport: &quot;));
        add(newSport);
        add(new Button(&quot;Add&quot;));
        add(new Button(&quot;Delete&quot;));

        add(new Button(&quot;Save&quot;));

        add(results);

        resize(320, 240);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;
        int i;

        if(&quot;Save&quot;.equals(obj)) {
            // clear the results area
            results.setText(&quot;&quot;);

            // display the gender
            String gender = genderChoice.getSelectedItem();
            results.appendText(gender + &quot;\r\n&quot;);

            for(i=0;i&lt;sportList.countItems();i++) {
                if(sportList.isSelected(i))
                    results.appendText(sportList.getItem(i) + &quot;\r\n&quot;);
            }
            
            result = true;
        }
        else if(&quot;Add&quot;.equals(obj)) {
            String sport = newSport.getText();
            if(sport.length() &gt; 0) {
                sportList.addItem(sport);
                newSport.setText(&quot;&quot;);
            }
        }
        else if(&quot;Delete&quot;.equals(obj)) {
            for(i=sportList.countItems()-1; i&gt;=0; i-) {
                if(sportList.isSelected(i))
                    sportList.delItem(i);
            }
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>EX05F</TT> is similar to <TT>EX05E</TT> except that it uses
<TT>List</TT> and <TT>Choice</TT> objects instead of <TT>checkbox</TT>es,
and it supports the capability to add and delete sports. After
the user interface components are created in the <TT>init</TT>
method, they are manipulated by the <TT>action</TT> method whenever
the Save, Add, or Delete buttons are pushed. If the Save button
is pushed, a string indicating if the user is male or female is
created with <TT>genderChoice.getSelectedItem</TT>. This string
is written to the <TT>results</TT> text area. Next, the code loops
through the items in <TT>sportList</TT>. For each selected item
that is found, the <TT>getItem</TT> method is used to retrieve
the text of the selected item. This text is also added to the
<TT>results</TT> text area.
<P>
If the Add button is pushed instead, the text in the <TT>newSport</TT>
text field is retrieved. If this text field is not empty, <TT>sportList.addItem</TT>
is used to add the new sport to the bottom of the list.
<P>
Finally, if Delete is pushed, the code loops through <TT>sportList</TT>
using <TT>delItem</TT> to delete any selected items. Note that
the loop counts down from <TT>sportList.countItems()-1</TT> to
<TT>0</TT>. To have counted up would have possibly caused invalid
numbers to be passed to <TT>delItem</TT>.
<P>
The result of <TT>EX05F</TT> after having added and deleted a
few items is shown in Figure 5.11.
<H3><A NAME="Scrollbars">
Scrollbars</A></H3>
<P>
Scrollbars can be used to satisfy a number of user interface goals.
They are used on windows and lists to indicate that there is more
to the object than meets the eye. They can also be used to allow
a user to select a value from a range of values. For example,
if you were designing a user interface that represented a home
thermostat, a scrollbar would be an excellent choice. In Java,
scrollbars can be created by using the <TT>Scrollbar</TT> class.
The constructors for this class are shown in Table 5.17.<BR>
<P>
<CENTER><B>Table 5.17. Constructors for the Scrollbar class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=235><I>Constructor</I></TD><TD WIDTH=325><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=235><TT>Scrollbar()</TT></TD><TD WIDTH=325>Creates a vertical scrollbar.</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=235><TT>Scrollbar(int)</TT></TD><TD WIDTH=325>Creates a scrollbar in the specified orientation.</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=235><TT>Scrollbar(int,int,int,int,int)</TT></TD>
<TD WIDTH=325>Creates a scrollbar in the specified orientation, initial value, visible area, minimum, and maximum value.</I>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As you can see from Table 5.17, it is possible to construct a
scrollbar in more than one screen orientation. The values <TT>Scrollbar.HORIZONTAL</TT>
and <TT>Scrollbar.VERTICAL</TT> are defined in <TT>java.awt.Scrollbar</TT>.
By default, a scrollbar will be positioned vertically. To create
scrollbars using these constructors, consider the following examples:
<BLOCKQUOTE>
<PRE>
Scrollbar bar1 = new Scrollbar(Scrollbar.HORIZONTAL, 50, 10, 0, 100);
Scrollbar bar2 = new Scrollbar();
Scrollbar bar3 = new Scrollbar(Scrollbar.VERTICAL);
</PRE>
</BLOCKQUOTE>
<P>
In this case, <TT>bar1</TT> is created as a horizontal bar that
can accept values from 0 to 100. Initially, it will hold a value
of 50. The visible portion of <TT>bar1</TT> will be 10. In the
second example, <TT>bar2</TT> is created using the default constructor,
which means it will be oriented vertically. Finally, <TT>bar3</TT>
is created using the constructor that requires only a parameter
for the orientation. Because <TT>Scrollbar.VERTICAL</TT> is passed,
a vertical scrollbar will be created.
<P>
The <TT>Scrollbar</TT> class offers a number of public methods.
These are shown in Table 5.18.<BR>
<P>
<CENTER><B>Table 5.18. Public methods of the Scrollbar class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=230><I>Method</I></TD><TD WIDTH=340><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>addNotify()</TT></TD><TD WIDTH=340>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>getLineIncrement()</TT></TD><TD WIDTH=340>Returns the amount by which the scrollbar will change when moving one line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>getMaximum()</TT></TD><TD WIDTH=340>Returns the maximum value for the scrollbar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>getMinimum()</TT></TD><TD WIDTH=340>Returns the minimum value for the scrollbar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>getOrientation()</TT></TD><TD WIDTH=340>Returns the orientation of the scrollbar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>GetPageIncrement()</TT></TD><TD WIDTH=340>Returns the amount by which the scrollbar will change value when moving by a page.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>getValue()</TT></TD><TD WIDTH=340>Returns the current value of the scrollbar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>GetVisible()</TT></TD><TD WIDTH=340>Returns a value indicating how much of the scrollbar is visible.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>ParamString()</TT></TD><TD WIDTH=340>Returns a parameter string for <TT>Choice</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>SetLineIncrement()</TT></TD><TD WIDTH=340>Sets the amount by which to change the current value when moving one line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>SetPageIncrement()</TT></TD><TD WIDTH=340>Sets the amount by which to change the current value when moving one page.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>setValue()</TT></TD><TD WIDTH=340>Sets the current value of the scrollbar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>setValues(int,int,int,int)</TT></TD><TD WIDTH=340>Sets the current value, visible amount, minimum, and maximum values of the scrollbar.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>An Example</H4>
<P>
As an example of using the <TT>Scrollbar</TT> class in the user
interface of an applet, <TT>EX05G</TT> was created and is shown
in Listing 5.7. In this example, the user is asked to enter his
score for a round of golf using a scrollbar. The scrollbar is
associated with a read-only text field that displays the value
of the scrollbar. This can be seen in Figure 5.12.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-12.gif"><B> Figure 5.12 : </B><I>Entering a golf score of 79 in EX05G by using the scrollbar.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 5.7. EX05G.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05G extends Applet
{
    Scrollbar scoreBar = new Scrollbar(Scrollbar.HORIZONTAL, 72, 10, 50, 120);
    TextField score = new TextField(5);

    public void init()
    {
        resize(320, 240);

        add(new Label(&quot;Score: &quot;));
        
        score.setText(&quot;72&quot;);
        score.setEditable(false);
        add(score);

        add(scoreBar);
    }

    public boolean handleEvent(Event evt)
    {
        boolean result=false;
        int i;

        if(evt.target == scoreBar) {
            int value = scoreBar.getValue();
            String str = String.valueOf(value);

            score.setText(str);

            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The member variable <TT>scoreBar</TT> is used to represent the
scrollbar. Its constructor specifies horizontal alignment, an
initial value of 72, a visible region of 10, a minimum value of
50, and a maximum value of 120. If you can shoot better than 50
for a round of golf, you're too busy golfing to enter your scores
in my applet and if your score is over 120, I don't want to bother
tracking it. (Sorry, Ken.) The <TT>TextField</TT> <TT>score</TT>
will be used to always display the current value of the scrollbar.
<P>
In the <TT>init</TT> method, the components are added to the applet,
the initial text is written to the text field, and <TT>score.setEditable(false)</TT>
is used so that the user cannot change his score without using
the scrollbar.
<P>
In the previous examples in this chapter, event handling was performed
in the <TT>action</TT> method of the applet. To handle scrollbar
events, however, you can use <TT>handleEvent</TT>. In this example,
<TT>evt.target == scoreBar</TT> is used to determine whether the
event was generated by the scrollbar. If it was, <TT>getValue</TT>
is used to retrieve the value and the <TT>TextField score</TT>
is updated.
<H2><A NAME="LayingOutControls"><FONT SIZE=5 COLOR=#FF0000>
Laying Out Controls</FONT></A></H2>
<P>
You may have already noticed that you've been using the <TT>add</TT>
method to place user interface components on the applet and that
you've never had to tell Java where to place each component. Somehow
Java knew where each component belonged and placed it there. It
almost seems like magic but what was really happening was that
Java was making use of a <I>layout manager</I> to know how to
place each new component.
<P>
The Java Software Developer's Kit (SDK) supports five layout managers,
and you can write your own. A layout manager can be used by each
of the Java classes that can be used to hold user interface components:
<TT>Applet</TT>, <TT>Panel</TT>, <TT>Frame</TT>, and <TT>Dialog</TT>.
Each of these classes has a default layout manager associated
with it, as shown in Table 5.19. However, any layout manager can
be used with any of these classes.<BR>
<P>
<CENTER><B>Table 5.19. Default layout managers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=144><I>Class</I></TD><TD WIDTH=240><I>Default Layout Manager</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Applet</TT></TD><TD WIDTH=240><TT>FlowLayout</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Dialog</TT></TD><TD WIDTH=240><TT>BorderLayout</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Frame</TT></TD><TD WIDTH=240><TT>BorderLayout</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Panel</TT></TD><TD WIDTH=240><TT>FlowLayout</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="LayoutManagersandtheResourceWizard">
Layout Managers and the Resource Wizard</A></H3>
<P>
Layout managers can be a hassle to deal with. They keep you from
writing useful code and focus you on a boring, trivial aspect
of your applet: writing the user interface code. Fortunately,
the creators of Visual J++ noticed this and have provided a solution.
In addition to the layout managers included with the Java SDK,
Visual J++ provides you with a tool for visually designing and
laying out your controls. This process is identical to creating
a Windows resource file.
<P>
These controls are then processed by the Visual J++ Resource Wizard,
which creates code to add user interface components to an applet,
dialog, frame, or panel. Additionally, the Resource Wizard provides
you with a custom layout manager that will position your controls
for you in the locations you indicated while visually designing
your interface.
<P>
However, this doesn't mean you don't need to understand how the
layout managers provided with Java work. Just because you have
Visual J++ doesn't mean you can throw away the dozens of lines
of legacy Java code already in use in your workplace that were
written without Visual J++.
<H3><A NAME="FlowLayout">
FlowLayout</A></H3>
<P>
The <TT>FlowLayout</TT> control is the default layout manager
for the <TT>Applet</TT> class, so it has been used by default
in all of the examples so far in this chapter. What <TT>FlowLayout</TT>
does is to continue placing components on the same line until
no more will fit. If a component won't fit on the current line,
<TT>FlowLayout</TT> moves to the next line and places the component
there. Components are placed on the screen in the order they are
added to the applet.
<P>
Sometimes you can achieve desirable results this way, but you
may have to work at it a bit. For example, look back at Figure
5.6. This example shows a text field above a text area and then
another text field above another text area. I originally designed
this screen to have the two text areas on top of two side-by-side
text fields. Unfortunately, when I ran the applet, I discovered
that because of the sizes of the components, they didn't line
up the way I wanted them to. Although <TT>FlowLayout</TT> is not
a great layout manager if you have more than a handful of components
to display, it is an excellent choice for small quantities.
<P>
If you are working with a <TT>Dialog</TT> or <TT>Frame</TT> and
want to create and use an instance of <TT>FlowLayout</TT>   you
can do so with the <TT>setLayout</TT> method as follows:
<BLOCKQUOTE>
<PRE>
setLayout(new FlowLayout());
</PRE>
</BLOCKQUOTE>
<P>
This will create a new instance of <TT>FlowLayout</TT> and will
assign it to the object that executes this method.
<H3><A NAME="BorderLayout">
BorderLayout</A></H3>
<P>
The <TT>BorderLayout</TT> class is very useful when you have a
relatively small number of components to place and you want to
have more control over how they are placed than is available with
<TT>FlowLayout</TT>. A <TT>BorderLayout</TT> can control up to
five components. Each component is placed in one of the following
areas:
<UL>
<LI><TT>North</TT>
<LI><TT>South</TT>
<LI><TT>East</TT>
<LI><TT>West</TT>
<LI><TT>Center</TT>
</UL>
<P>
When you add a component using a <TT>BorderLayout</TT>, you specify
the location in which to place the component. For example, the
following code places a button in the <TT>North</TT> and a button
in the <TT>South</TT>:
<BLOCKQUOTE>
<PRE>
add(&quot;North&quot;, new Button(&quot;OK&quot;));
add(&quot;South&quot;, new Button(&quot;Cancel&quot;));
</PRE>
</BLOCKQUOTE>
<P>
As you would expect, the <TT>North</TT> is the top of a container,
the <TT>South</TT> is the bottom, the <TT>East</TT> is the right,
and the <TT>West</TT> is the left. The <TT>Center</TT> is everything
else. Usually this means that a component placed in the <TT>Center</TT>
will be larger than other components. For example, look at Figure
5.13. This figure illustrates an applet that created five buttons,
one in each position. Notice how the <TT>Center</TT> button grew
to fill the available space in much the same manner as my waist
grows to fill the last available hole in my belt.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-13.gif"><B> Figure 5.13 : </B><I>An applet using the BorderLayout layout manager.
</I></A><P>
<P>
Listing 5.8 contains the code that created <TT>EX05H</TT>, which
was shown in Figure 5.13. Notice that <TT>setLayout(new BorderLayout())</TT>
was used to assign the <TT>BorderLayout</TT> to the applet.
<HR>
<BLOCKQUOTE>
<B>Listing 5.8. EX05H.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05H extends Applet
{
    public void init()
    {
        setLayout(new BorderLayout());

        add(&quot;North&quot;, new Button(&quot;North&quot;));
        add(&quot;South&quot;, new Button(&quot;South&quot;));

        add(&quot;East&quot;, new Button(&quot;East&quot;));
        add(&quot;West&quot;, new Button(&quot;West&quot;));

        add(&quot;Center&quot;, new Button(&quot;Center&quot;));

        resize(320, 240);
    }

}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="CardLayout">
CardLayout</A></H3>
<P>
The <TT>CardLayout</TT> class is useful for presenting a user
interface in which components can come and go. For example, you
could use <TT>CardLayout</TT> to create an interface that included
property pages or tabbed dialogs. Each page would be a separate
card in this layout manager's lexicon. Using the methods of <TT>CardLayout,</TT>
you can allow a user the freedom to switch between cards. As an
example, consider the code in Listing 5.9.
<HR>
<BLOCKQUOTE>
<B>Listing 5.9. EX05I.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05I extends Applet
{
    CardLayout layout;
    public void init()
    {
        resize(320, 240);
        layout = new CardLayout();
        setLayout(layout);
        add(&quot;Page1&quot;, new Button(&quot;Go to Page 2&quot;));
        add(&quot;Page2&quot;, new Button(&quot;Go to Page 3&quot;));
        add(&quot;Page3&quot;, new Button(&quot;Go to Page 4&quot;));
        add(&quot;Page4&quot;, new Button(&quot;Go to Page 1&quot;));
    }
   

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Go to Page 1&quot;.equals(obj)) {
            layout.show(this, &quot;Page1&quot;);
            result = true;
        }
        else if(&quot;Go to Page 2&quot;.equals(obj)) {
            layout.next(this);
            result = true;
        }
        else if(&quot;Go to Page 3&quot;.equals(obj)) {
            layout.show(this, &quot;Page3&quot;);
            result = true;
        }
        else if(&quot;Go to Page 4&quot;.equals(obj)) {
            layout.last(this);
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, the goal is to create an applet that displays
a page with a button on it. Pressing the button will move the
user to another page with another button. When the user reaches
the final page, he or she can press a button that will return
him or her to the first page where it all starts again. Hopefully,
the user will figure out that the cycle is repeating itself and,
unlike Sisyphus, will stop before repeating the process too many
times. An example of the first page of the example is shown in
Figure 5.14.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-14.gif"><B> Figure 5.14 : </B><I>An example of the first  page of a CardLayout.
</I></A><P>
<P>
In <TT>EX05I,</TT> an instance of a <TT>CardLayout</TT> is created
and stored in <TT>layout</TT>. This is assigned as the applet's
layout manager using <TT>setLayout</TT>. Next, four buttons are
created and added to the applet. As each button is added, it is
given a name; for example, Page1 is the name given to the first
button.
<P>
The action method takes care of displaying the proper page. If
the button labeled Go to Page 1 is pushed, the <TT>layout.show</TT>
method is passed the name (Page1) of the page to display. This
updates the display with the appropriate button. A similar piece
of code switches from page two to three. However, to demonstrate
an alternate approach, the move from page one to two is done using
<TT>layout.next</TT>, and <TT>layout.last</TT> is used to move
to the fourth page.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
One potentially disconcerting fact about <TT>CardLayout</TT> is that each card, or page, can contain only one component. This is the reason why only a single button was placed on each card in class <TT>EX05I</TT>. However, this limitation is not a real 
concern because Java includes a <TT>Panel</TT> class. You can place multiple components on an instance of <TT>Panel</TT> and then place a single <TT>Panel</TT> on a card. The <TT>Panel</TT> class is described in the next chapter, and an example is given of 
how to manipulate <TT>Panels</TT> on a <TT>CardLayout</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="GridLayout">
GridLayout</A></H3>
<P>
The <TT>GridLayout</TT> class is useful when you have a set of
controls you want to place that are all the same size. For example,
Figure 5.15 shows class <TT>EX05J</TT>, which has created a three-row
by three- column grid. Each of the grid's components-eight buttons
and a text field-are made the same size by <TT>GridLayout</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-15.gif"><B> Figure 5.15 : </B><I>Using GridLayout  in EX05J.
</I></A><P>
<P>
As you can see in Listing 5.10, using <TT>GridLayout</TT> is as
simple as using <TT>FlowLayout</TT>. In creating a new instance
of <TT>GridLayout</TT>, you can specify the number of desired
rows and columns as in <TT>new GridLayout(3,3)</TT>. As with the
other layout managers, you then use <TT>setLayout</TT> to associate
the layout manager with the applet. Finally, you can use <TT>add</TT>
to assign new components to the applet.
<HR>
<BLOCKQUOTE>
<B>Listing 5.10. EX05J.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05J extends Applet
{
    public void init()
    {
        resize(320, 240);

        setLayout(new GridLayout(3,3));

        add(new Button(&quot;1,1&quot;));
        add(new Button(&quot;1,2&quot;));
        add(new Button(&quot;1,3&quot;));
        add(new Button(&quot;2,1&quot;));
        add(new TextField(&quot;This is a TextField&quot;));
        add(new Button(&quot;2,3&quot;));
        add(new Button(&quot;3,1&quot;));
        add(new Button(&quot;3.2&quot;));
        add(new Button(&quot;3,3&quot;));

    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="GridBagLayout">
GridBagLayout</A></H3>
<P>
The final layout manager, <TT>GridBagLayout</TT>, is the most
involved to use but also gives you the most flexibility in placing
your components. When using this layout manager, you also create
an instance of <TT>GridBagConstraints</TT>. You then repeat a
pattern of defining constraints (&quot;this component should be
the last one on the line,&quot; &quot;this component should be
twice as tall as other components,&quot; and so on), constructing
a new component, and then applying the constraints to the component.
The results can be worth the effort as this enables you to create
complex screens, as shown in Figure 5.16.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f5-16.gif"><B> Figure 5.16 : </B><I>GridBagLayout can be used to create complex screens.
</I></A><P>
<P>
The code that creates the screen shown in Figure 5.16 is from
example <TT>EX05K</TT> given in Listing 5.11.
<P>

<HR>
<BLOCKQUOTE>
<B>Listing 5.11. EX05K.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX05K extends Applet
{
    public void init()
    {
        GridBagLayout layout = new GridBagLayout(); 
        GridBagConstraints gbc = new GridBagConstraints(); 

        setLayout(layout); 

        // add the first button
        gbc.fill = GridBagConstraints.BOTH; 
        Button button = new Button(&quot;Top Left&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // add a button to the same row
        gbc.gridwidth = GridBagConstraints.RELATIVE; 
        button = new Button(&quot;Top Center&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // place a final button on the first row
        gbc.gridwidth = GridBagConstraints.REMAINDER; 
        button = new Button(&quot;Top Right&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // create a  button the width of the applet
        gbc.weighty = 1.0;
        button = new Button(&quot;Full Row&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // create a tall button along the left side
        gbc.gridwidth = 1;                   
        gbc.gridheight = 2; 
        gbc.weighty = 1.0; 
        button = new Button(&quot;Tall, Left Side&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // create a skinny button to the right edge
        gbc.weighty = 0.0;                   
        gbc.gridwidth = GridBagConstraints.REMAINDER; 
        gbc.gridheight = 1;                 
        button = new Button(&quot;Skinny Wide Button&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // create a button in the middle of the bottom
        gbc.gridwidth = GridBagConstraints.RELATIVE; 
        button = new Button(&quot;Bottom Middle&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        // create a button at the bottom right
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        button = new Button(&quot;Bottom Right&quot;); 
        layout.setConstraints(button, gbc); 
        add(button); 

        resize(320, 240);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, new layout and constraint objects are constructed.
The first button to be added to the screen is then created with
the following code:
<BLOCKQUOTE>
<PRE>
gbc.fill = GridBagConstraints.BOTH; 
Button button = new Button(&quot;Top Left&quot;); 
layout.setConstraints(button, gbc); 
add(button); 
</PRE>
</BLOCKQUOTE>
<P>
The <TT>fill</TT> member of the <TT>GridBagConstraints</TT> object,
<TT>gbc</TT>, is set to <TT>BOTH,</TT> which means the component
will stretch both vertically and horizontally to fill the display
area of the applet. Next the button is created, and <TT>layout.setConstraints</TT>
is used to apply the constraints in <TT>gbc</TT> to the newly
constructed button. 
<P>
The second button is created by using the same <TT>GridBagConstraints</TT>
object, <TT>gbc</TT>, so the same constraints will apply. Additionally,
a new constraint, <TT>gbc.gridwidth = GridBagConstraints.RELATIVE,</TT>
is added. This means that the component will be the next to the
last component on a line. Similarly, when the third component
is added the constraint <TT>gbc.gridwidth= GridBagConstraints.REMAINDER</TT>
is used. This will make that component the last component on the
line. The next item after an item with the <TT>REMAINDER </TT>constraint
will begin a new line in the layout.
<P>
Other buttons are added in similar manners. Throughout the rest
of <TT>EX05K</TT>, other member values of the constraint instance
are set to demonstrate their effects.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter covered a lot of territory. Along the way, you learned
that the <TT>Component </TT>class is the base class for many of
the Java user interface classes. You learned about the <TT>Button</TT>,
<TT>TextField</TT>, <TT>TextArea</TT>, <TT>Label</TT>, <TT>Checkbox</TT>,
<TT>List</TT>, <TT>Choice</TT>, and <TT>Scrollbar </TT>classes
and how you can use them to create an applet's user interface.
You were also introduced to layout manager and saw how to use
a layout manager to control the placement of components. In the
next chapter, you will continue learning about Java user interface
programming by looking at windows, frames, dialogs, and menus.
<HR>

<CENTER><P><A HREF="ch4.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch6.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
