<HTML>
<HEAD>
<TITLE>Appendix A -- A Whirlwind Tour of the Java Language</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Appendix&nbsp;A</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>A Whirlwind Tour of the Java Language</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheStructureofaJavaFile">
The Structure of a Java File</A>
<LI><A HREF="#Comments">
Comments</A>
<LI><A HREF="#JavaKeywords">
Java Keywords</A>
<LI><A HREF="#PrimitiveTypes">
Primitive Types</A>
<UL>
<LI><A HREF="#IntegerTypes">
Integer Types</A>
<LI><A HREF="#FloatingPointTypes">
Floating-Point Types</A>
<LI><A HREF="#OtherPrimitiveTypes">
Other Primitive Types</A>
<LI><A HREF="#DefaultValues">
Default Values</A>
<LI><A HREF="#CastingBetweenPrimitiveTypes">
Casting Between Primitive Types</A>
</UL>
<LI><A HREF="#Literals">
Literals</A>
<UL>
<LI><A HREF="#IntegerLiterals">
Integer Literals</A>
<LI><A HREF="#FloatingPointLiterals">
Floating-Point Literals</A>
<LI><A HREF="#BooleanLiterals">
Boolean Literals</A>
<LI><A HREF="#CharacterLiterals">
Character Literals</A>
<LI><A HREF="#StringLiterals">
String Literals</A>
</UL>
<LI><A HREF="#Arrays">
Arrays</A>
<UL>
<LI><A HREF="#Allocation">
Allocation</A>
<LI><A HREF="#Initialization">
Initialization</A>
<LI><A HREF="#ArrayAccess">
Array Access</A>
</UL>
<LI><A HREF="#Operators">
Operators</A>
<UL>
<LI><A HREF="#OperatorsonIntegers">
Operators on Integers</A>
<LI><A HREF="#OperatorsonFloatingPointValues">
Operators on Floating-Point Values</A>
<LI><A HREF="#OperatorsonBooleanValues">
Operators on Boolean Values</A>
</UL>
<LI><A HREF="#ControllingYourProgram">
Controlling Your Program</A>
<UL>
<LI><A HREF="#Selection">
Selection</A>
<LI><A HREF="#Iteration">
Iteration</A>
<LI><A HREF="#Jumping">
Jumping</A>
</UL>
<LI><A HREF="#JavaClasses">
Java Classes</A>
<UL>
<LI><A HREF="#FieldDeclarations">
Field Declarations</A>
</UL>
<LI><A HREF="#ClassInheritance">
Class Inheritance</A>
<UL>
<LI><A HREF="#OverridingMemberMethods">
Overriding Member Methods</A>
<LI><A HREF="#ThesuperVariable">
The super Variable</A>
<LI><A HREF="#ClassModifiers">
Class Modifiers</A>
<LI><A HREF="#ImplementingInterfaces">
Implementing Interfaces</A>
</UL>
<LI><A HREF="#ExceptionHandling">
Exception Handling</A>
<UL>
<LI><A HREF="#TryingandCatching">
Trying and Catching</A>
<LI><A HREF="#UsingafinallyBlock">
Using a finally Block</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
If you are an experienced programmer already comfortable with
an object-oriented language but don't know Java, or if you have
already started learning Java but need a quick refresher, this
appendix is for you. This appendix outlines the core syntax and
constructs of the Java language. You learn how to declare Java
variables and write Java functions. You will see how Java's minimal
set of primitive types can be combined with its rich object model
to fulfill the goals of object-oriented programming. You will
also learn how to make use of exception handling to trap errors.
<H2><A NAME="TheStructureofaJavaFile"><FONT SIZE=5 COLOR=#FF0000>
The Structure of a Java File</FONT></A></H2>
<P>
This appendix presents the Java language by starting with its
smallest pieces-reserved words, operators, and primitive types.
Building on this foundation you'll learn how to control the flow
of a Java program and then how to create new Java classes. However,
to augment this bottom-up approach, it is useful to start by examining
an example of a Java class in its entirety. This overview will
help place the rest of this appendix in context.
<P>
The following code is the complete definition of a Java class
named <TT>MyClass</TT>:
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.Graphics;

public class MyClass extends Applet
{
    private String aString;
    private int xPosition;

    public void init()
    {
        xPosition = 32;
        aString = &quot;This is a string&quot;;
    }

    public void paint(Graphics g)
    {
        g.drawString(aString, xPosition, 10);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
The statement <TT>public class MyClass extends Applet</TT> creates
a new class named <TT>MyClass</TT>. This class <TT>extends Applet</TT>,
meaning that <TT>MyClass</TT> inherits the properties of the class
named <TT>Applet</TT> but that <TT>MyClass</TT> extends <TT>Applet</TT>
by adding additional functionality or modifying the functionality
of <TT>Applet</TT>. If a class did not extend the functionality
of the class on which it is based, there would be little reason
for defining the new class.
<P>
Within the class, its member variables and methods are defined.
In the case of <TT>MyClass</TT>, it includes a variable named
<TT>aString</TT> of type <TT>String</TT> and a variable named
<TT>xPosition</TT> that is of type <TT>int</TT>. Each of these
variables is defined as <TT>private</TT>, indicating that the
variable cannot be accessed from outside the class.
<P>
Next within the class is the definition of a method called <TT>init</TT>.
This method is defined as <TT>public</TT> and <TT>void</TT>. The
<TT>public</TT> keyword indicates that the method can be accessed
outside the current class while <TT>void</TT> indicates that the
method has no return value. The <TT>init</TT> method sets the
initial values of the <TT>aString</TT> and <TT>xPosition</TT>
variables.
<P>
Finally, the <TT>paint</TT> function, also declared as <TT>public</TT>
and <TT>void</TT>, is presented. Unlike <TT>init</TT>, <TT>paint</TT>
is passed a parameter. The parameter is named <TT>g</TT> and is
of type <TT>Graphics</TT>. The code within <TT>paint</TT> invokes
the <TT>drawString</TT> method of the <TT>Graphics</TT> class
to draw the string stored in <TT>aString</TT> on the screen.
<P>
At the top of this sample class were the following lines:
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.Graphics;
</PRE>
</BLOCKQUOTE>
<P>
In Java, classes are collected into packages. Classes and packages
may then be reused in other programs by using the <TT>import</TT>
statement. The first import line in this example is used to instruct
Java to import all the classes stored in the package identified
by the name <TT>java.applet</TT>. The <TT>.*</TT> at the end of
the import statement indicates that all classes in this package
are to be imported. Instead, a specific class name could have
been listed, as with the second line of this example.
<H2><A NAME="Comments"><FONT SIZE=5 COLOR=#FF0000>
Comments</FONT></A></H2>
<P>
Missing in the example class you just saw were comments. I'd like
to correct that right now so that code samples throughout the
rest of this appendix can include comments. Java supports three
types of comment delimiters-the traditional <TT>/*</TT> and <TT>*/</TT>
of C, the <TT>//</TT> of C++, and a new variant that starts with
<TT>/**</TT> and ends with <TT>*/</TT>.
<P>
The <TT>/*</TT> and <TT>*/</TT> delimiters are used to enclose
text that is to be treated as a comment by the compiler. These
delimiters are useful when you want to designate a lengthy piece
of code as a comment, as shown in the following:
<BLOCKQUOTE>
<PRE>
/* This is a comment that will span multiple
source code lines. */
</PRE>
</BLOCKQUOTE>
<P>
The <TT>//</TT> comment delimiter is borrowed from C++ and is
used to indicate that the rest of the line is to be treated as
a comment by the Java compiler. This type of comment delimiter
is particularly useful for adding comments adjacent to lines of
code, as shown in the following:
<BLOCKQUOTE>
<PRE>
Date today = new Date();      // create an object with today's date
System.out.println(today);    // display the date
</PRE>
</BLOCKQUOTE>
<P>
Finally, the <TT>/**</TT> and <TT>*/</TT> delimiters are new to
Java and are used to indicate that the enclosed text is to be
treated as a comment by the compiler, but that the text is also
part of the automatic class documentation that can be generated
using JavaDoc. JavaDoc is fully described in <A HREF="ch9.htm" >Chapter 9</A> &quot;Documenting
Your Visual J++ Code.&quot; These delimiters can be used to enclose
multiple lines of text, identically to how <TT>/*</TT> and <TT>*/</TT>
behave, as follows:
<BLOCKQUOTE>
<PRE>
/** The NeuralNetwork class implements a back-propagation
network and ... */
</PRE>
</BLOCKQUOTE>
<P>
The Java comment delimiters are summarized in Table A.1.<BR>
<P>
<CENTER><B>Table A.1. Java comment delimiters.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=96><I>Start</I></TD><TD WIDTH=96><I>End</I></TD>
<TD WIDTH=384><I>Purpose</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>/*</TT></TD><TD WIDTH=96><TT>*/</TT></TD>
<TD WIDTH=384>The enclosed text is treated as a comment.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>//</TT></TD><TD WIDTH=96>(none)</TD><TD WIDTH=384>The rest of the line is treated as a comment.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>/**</TT></TD><TD WIDTH=96><TT>*/</TT></TD>
<TD WIDTH=384>The enclosed text is treated as a comment by the compiler but is used by JavaDoc to automatically generate documentation.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You cannot nest comments in Java source code. Therefore, <TT>/*</TT> and <TT>*/</TT> appearing within a <TT>//</TT> comment are ignored as is the pattern <TT>//</TT> appearing within <TT>/*</TT> or <TT>/**</TT> comments. Comments cannot be placed within 
quoted strings, and if comment delimiters occur within a quoted string, they will be considered part of the quoted string.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="JavaKeywords"><FONT SIZE=5 COLOR=#FF0000>
Java Keywords</FONT></A></H2>
<P>
The following is a list of Java keywords:
<P>
<CENTER><I><B>Java Keywords</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><TT>abstact</TT></TD><TD WIDTH=144><TT>float</TT>
</TD><TD WIDTH=144><TT>public</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>boolean</TT></TD><TD WIDTH=144><TT>for</TT>
</TD><TD WIDTH=144><TT>return</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>break</TT></TD><TD WIDTH=144><TT>if</TT>
</TD><TD WIDTH=144><TT>short</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>byte</TT></TD><TD WIDTH=144><TT>implements</TT>
</TD><TD WIDTH=144><TT>static</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>case</TT></TD><TD WIDTH=144><TT>import</TT>
</TD><TD WIDTH=144><TT>super</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>catch</TT></TD><TD WIDTH=144><TT>instanceof</TT>
</TD><TD WIDTH=144><TT>switch</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>char</TT></TD><TD WIDTH=144><TT>int</TT>
</TD><TD WIDTH=144><TT>synchronized</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>class</TT></TD><TD WIDTH=144><TT>interface</TT>
</TD><TD WIDTH=144><TT>this</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>continue</TT></TD><TD WIDTH=144><TT>long</TT>
</TD><TD WIDTH=144><TT>throw</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>default</TT></TD><TD WIDTH=144><TT>native</TT>
</TD><TD WIDTH=144><TT>throws</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>do</TT></TD><TD WIDTH=144><TT>new</TT>
</TD><TD WIDTH=144><TT>transient</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>double</TT></TD><TD WIDTH=144><TT>null</TT>
</TD><TD WIDTH=144><TT>try</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>else</TT></TD><TD WIDTH=144><TT>operator</TT>
</TD><TD WIDTH=144><TT>void</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>extends</TT></TD><TD WIDTH=144><TT>package</TT>
</TD><TD WIDTH=144><TT>volatile</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>final</TT></TD><TD WIDTH=144><TT>private</TT>
</TD><TD WIDTH=144><TT>while</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>finally</TT></TD><TD WIDTH=144><TT>protected</TT>
</TD><TD WIDTH=144><TT>&nbsp;</TT></TD>
</TR>
</TABLE>
</CENTER>
<P>
<P>
The Java specification reserves additional keywords that will
be used in the future but are not part of the current language
specification. The following is a list of reserved Java keywords
that are not currently used:
<P>
<CENTER><I><B>Reserved Java Keywords</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><TT>byvalue</TT></TD><TD WIDTH=144><TT>generic</TT>
</TD><TD WIDTH=144><TT>outer</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>cast</TT></TD><TD WIDTH=144><TT>goto</TT>
</TD><TD WIDTH=144><TT>rest</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>const</TT></TD><TD WIDTH=144><TT>inner</TT>
</TD><TD WIDTH=144><TT>var</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>future</TT></TD><TD WIDTH=144><TT>operator</TT>
</TD><TD WIDTH=144>&nbsp;</TD>
</TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You may have noticed that <TT>true</TT> and <TT>false</TT> are missing from the list of Java keywords. These are actually Boolean literals, but can be thought of as keywords.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="PrimitiveTypes"><FONT SIZE=5 COLOR=#FF0000>
Primitive Types</FONT></A></H2>
<P>
A language's primitive types are the building blocks from which
more complicated types, such as classes, are built. Java supports
a set of eight primitive types, which are shown in Table A.2.
<BR>
<P>
<CENTER><B>Table A.2. Java primitive types.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><I>Type</I></TD><TD WIDTH=240><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>byte</TT></TD><TD WIDTH=240>8-bit signed integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>short</TT></TD><TD WIDTH=240>16-bit signed integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>int</TT></TD><TD WIDTH=240>32-bit signed integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>long</TT></TD><TD WIDTH=240>64-bit signed integer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>float</TT></TD><TD WIDTH=240>32-bit floating-point number
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>double</TT></TD><TD WIDTH=240>64-bit floating-point number
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>char</TT></TD><TD WIDTH=240>16-bit Unicode characters
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>boolean</TT></TD><TD WIDTH=240>Can hold <TT>true</TT> or <TT>false</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Because most of the machines that will run Java programs will
do so in a 32-bit environment, the sizes of the primitive types
have been defined with 32-bit optimization in mind. This means
that some Java primitives may use more storage space than you
are accustomed to if you come to Java from a 16-bit programming
background.
<P>
In Java you declare a variable by giving its type followed by
its name, as in the following examples:
<BLOCKQUOTE>
<PRE>
int x;
float LifeRaft;
short people;
long TimeNoSee;
double amountDue, amountPaid;
</PRE>
</BLOCKQUOTE>
<P>
In the preceding code, <TT>x</TT> is declared as an <TT>int</TT>
(integer), <TT>LifeRaft</TT> is declared as a floating-point variable,
<TT>people</TT> is declared as a short integer, <TT>TimeNoSee</TT>
is declared as a long integer, and <TT>amountDue</TT> and <TT>amountPaid</TT>
are declared as double-precision floating-point values.
<P>
<TT>C++ NOTE:</TT>
<P>
From this list, you can tell that Java adds both the <TT>byte</TT>
and <TT>boolean</TT> types. Some recent C++ compilers have added
support for the new C++ <TT>boolean</TT> type, so you may already
be using it in your code. Because Java provides Unicode support,
you should notice that its <TT>char</TT> type is 16 bits wide.
This is also why the 8-bit <TT>byte</TT> type is included as a
primitive type. In C++, you have probably been emulating a byte
type with something similar to the following:
<BLOCKQUOTE>
<PRE>
type unsigned char byte;
</PRE>
</BLOCKQUOTE>
<P>
There are a couple of other extremely important differences between
the Java and C++ primitive types. The Java primitives are each
of a known and guaranteed size. This is critical to Java because
of its goal of portability across hardware and operating systems.
If an <TT>int</TT> is 16 bits on one platform and 32 bits on another
platform, a program is asking for trouble if it expects to be
run on both platforms. C++ guarantees certain relationships among
its primitive types. For example, a C++ <TT>long</TT> is guaranteed
to be at least as big as a C++ <TT>int</TT>. Java takes this further
and prescribes an exact size for each primitive. You should take
care to notice the sizes of the Java primitives. In particular,
you should notice that a Java <TT>int</TT> is 32 bits and a Java
<TT>long</TT> is 64 bits.
<P>
Also worth pointing out is that all Java primitive types are signed.
This means that C++ declarations like the following are not allowed
in Java:
<BLOCKQUOTE>
<PRE>
unsigned long bigLong;     // not legal in Java
unsigned double salary;    // not legal in Java
</PRE>
</BLOCKQUOTE>
<P>
Finally, the Java <TT>boolean</TT> primitive can be set to a value
of <TT>true</TT> or <TT>false</TT>. In traditional C and C++ programming,
<TT>true</TT> and <TT>false</TT> were defined by using the preprocessor
to be equal to <TT>1</TT> and <TT>0</TT>, respectively.
<H3><A NAME="IntegerTypes">
Integer Types</A></H3>
<P>
Java consists of four integer types: <TT>byte</TT>, <TT>short</TT>,
<TT>int</TT>, and <TT>long</TT>, which are defined as 8-, 16-,
32- and 64-bit signed values as summarized in Table A.3.<BR>
<P>
<CENTER><B>Table A.3. The Java integer primitive types.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=130><I>Type</I></TD><TD WIDTH=130><I>Bit Size</I>
</TD><TD WIDTH=220><I>Minimum Value</I></TD><TD WIDTH=220><I>Maximum Value</I>
</TD></TR>
<TR VALIGN=TOP><TD>byte</TD><TD>8</TD><TD><TT>-256</TT>
</TD><TD><TT>255</TT></TD></TR>
<TR VALIGN=TOP><TD>short</TD><TD>16</TD><TD><TT>-32,768</TT>
</TD><TD><TT>32,767</TT></TD></TR>
<TR VALIGN=TOP><TD>int</TD><TD>32</TD><TD><TT>-2,147,483,648</TT>
</TD><TD><TT>2,147,483,647</TT></TD></TR>
<TR VALIGN=TOP><TD>long</TD><TD>64</TD><TD><TT>-9,223,372,036,854,775,808</TT>
</TD><TD><TT>9,223,372,036,854,775,807</TT></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The operations that may be performed on integer primitives are
shown in Table A.4. A more detailed discussion of the Java operators
is deferred until later in this appendix.<BR>
<P>
<CENTER><B>Table A.4. Operators on integer primitives.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=240><I>Operation</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>=</TT></CENTER></TD><TD WIDTH=240>Equality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>!=</TT></CENTER></TD><TD WIDTH=240>Inequality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;</TT></CENTER></TD><TD WIDTH=240>Greater than
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;</TT></CENTER></TD><TD WIDTH=240>Less than
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;=</TT></CENTER></TD><TD WIDTH=240>Greater than or equal to
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;=</TT></CENTER></TD><TD WIDTH=240>Less than or equal to
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>+</TT></CENTER></TD><TD WIDTH=240>Addition
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Subtraction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>*</TT></CENTER></TD><TD WIDTH=240>Multiplication
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>/</TT></CENTER></TD><TD WIDTH=240>Division
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>%</TT></CENTER></TD><TD WIDTH=240>Modulus
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>++</TT></CENTER></TD><TD WIDTH=240>Increment
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>--</TT></CENTER></TD><TD WIDTH=240>Decrement
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>~</TT></CENTER></TD><TD WIDTH=240>Bitwise logical negation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&amp;</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>AND</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>|</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>OR</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>^</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>XOR</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;&lt;</TT></CENTER></TD><TD WIDTH=240>Left shift
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;&gt;</TT></CENTER></TD><TD WIDTH=240>Right shift
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;&gt;&gt;</TT></CENTER></TD>
<TD WIDTH=240>Right shift with zero fill</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
If either or both of the operands is of type <TT>long</TT>, the
result of the operation will be a 64-bit long. If either operand
is not a <TT>long</TT>, it will be cast to a <TT>long</TT> prior
to the operation. If neither operand is a <TT>long</TT>, the operation
will be performed with the 32-bit precision of an <TT>int</TT>.
Any <TT>byte</TT> or <TT>short</TT> operands will be cast to <TT>int</TT>
prior to the operation.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In Java, you cannot cast between an integer type and a Boolean type.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="FloatingPointTypes">
Floating-Point Types</A></H3>
<P>
Support for floating-point numbers in Java is provided through
two primitive types-<TT>float</TT> and <TT>double</TT>, which
are 32- and 64-bit values, respectively. The operators available
for use on these primitives types are shown in Table A.5.<BR>
<P>
<CENTER><B>Table A.5. Operators on floating-point primitives.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=240><I>Operation</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>=</TT></CENTER></TD><TD WIDTH=240>Equality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>!=</TT></CENTER></TD><TD WIDTH=240>Inequality
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;</TT></CENTER></TD><TD WIDTH=240>Greater than
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;</TT></CENTER></TD><TD WIDTH=240>Less than
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;=</TT></CENTER></TD><TD WIDTH=240>Greater than or equal to
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;=</TT></CENTER></TD><TD WIDTH=240>Less than or equal to
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>+</TT></CENTER></TD><TD WIDTH=240>Addition
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Subtraction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>*</TT></CENTER></TD><TD WIDTH=240>Multiplication
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>/</TT></CENTER></TD><TD WIDTH=240>Division
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>%</TT></CENTER></TD><TD WIDTH=240>Modulus
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>++</TT></CENTER></TD><TD WIDTH=240>Increment
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>--</TT></CENTER></TD><TD WIDTH=240>Decrement
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Java floating-point numbers will behave as specified in IEEE Standard
754. Java variables of type <TT>float</TT> and <TT>double</TT>
can be cast to other numeric types but cannot be cast to be of
the <TT>boolean</TT> type.
<P>
If either or both of the operands is a floating-point type, the
operation is considered to be a floating-point operation. If either
of the operands is a <TT>double</TT>, each will be treated as
a <TT>double</TT> with the necessary casts being performed. If
neither operand is a <TT>double</TT>, each operand will be treated
as a <TT>float</TT> and cast as necessary.
<P>
Floating-point numbers can take on any of the following values:
<UL>
<LI>Negative infinity
<LI>Negative, finite values
<LI>Negative zero
<LI>Positive zero
<LI>Positive, finite values
<LI>Positive infinity
<LI>NaN, or &quot;not a number&quot;
</UL>
<P>
This last value, NaN, is used to indicate values that do not fit
within the scale of negative infinity to positive infinity. For
example, the following will produce a value of NaN:
<BLOCKQUOTE>
<PRE>
0.0f / 0.0f
</PRE>
</BLOCKQUOTE>
<P>
The inclusion of NaN as a floating-point value can cause some
unusual effects when floating-point values are compared with the
relational operators. Because NaN does not fit within the scale
of negative infinity through positive infinity, comparing against
it will always result in <TT>false</TT>. For example, both<TT>
5.3f &gt; NaN</TT> and <TT>5.3f &lt; NaN</TT> are <TT>false</TT>.
In fact, when NaN is compared to itself with <TT>==</TT>, the
result is <TT>false</TT>.
<P>
On the other hand, although negative and positive zero may sound
like different values, comparing them with <TT>==</TT> will result
in <TT>true</TT>.
<H3><A NAME="OtherPrimitiveTypes">
Other Primitive Types</A></H3>
<P>
In addition to the integer and floating-point primitive types,
Java includes two additional primitive types-Boolean and character.
Variables of type <TT>boolean</TT> can hold either <TT>true</TT>
or <TT>false</TT>, while variables of type <TT>char</TT> can hold
a single Unicode character.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE:</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Remember, a Java <TT>boolean</TT> variable is not a 1 or 0 in disguise as it is C and C++. Because of this, you cannot cast between <TT>boolean</TT> and numeric types.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<H3><A NAME="DefaultValues">
Default Values</A></H3>
<P>
One common source of programming errors is the use of an uninitialized
variable. Frequently, this type of bug shows itself in a program
that behaves erratically. Sometimes the program does what it's
supposed to; other times it reformats your hard drive, overwrites
your CMOS, declares war on a foreign country, or manifests some
other undesirable side effect. It does this because an uninitialized
variable may take on the value of whatever random garbage is in
its memory location when the program runs. Java circumvents this
problem, and possibly prevents World War III, by assigning a default
value to any uninitialized variables. Default values are assigned
based on the type of the variable, as shown in Table A.6.<BR>
<P>
<CENTER><B>Table A.6. Standard default values for Java primitive
types.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=192><I>Primitive</I></TD><TD WIDTH=192><I>Default</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>byte</TT></TD><TD WIDTH=192><TT>0</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>short</TT></TD><TD WIDTH=192><TT>0</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>int</TT></TD><TD WIDTH=192><TT>0</TT></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>long</TT></TD><TD WIDTH=192><TT>0L</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>float</TT></TD><TD WIDTH=192><TT>0.0f</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>double</TT></TD><TD WIDTH=192><TT>0.0d</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>char</TT></TD><TD WIDTH=192><TT>null</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>boolean</TT></TD><TD WIDTH=192><TT>false</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192>all references</TD><TD WIDTH=192><TT>null</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
It's certainly convenient and beneficial that Java will take care of assigning default values to uninitialized variables, but it is not wise to rely on this. Good programming practice suggests that you should initialize every variable you declare, without 
relying on default values. Although it is very unlikely that the default values would change (for example, the Boolean default of <TT>false</TT> is unlikely to change to <TT>true</TT>), other side effects are possible.
</BLOCKQUOTE>
<BLOCKQUOTE>
In a C program, I once spent hours tracking down a bug that was caused by my reliance on the compiler defaulting a global integer to <TT>0</TT>. The compiler did its job correctly; unfortunately, another programmer saw my bad practice of using an 
uninitialized global and corrected it by initializing it for me-to <TT>1</TT>. When I was reassigned to the maintenance of the program, I had no idea the change had been made.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="CastingBetweenPrimitiveTypes">
Casting Between Primitive Types</A></H3>
<P>
Sometimes you have a variable that is of one type and you want
to use it as another. For example, one of the first programs I
wrote was used to predict the final scores in baseball games based
on a huge number of input statistics. It would come up with results
like the Chicago Cubs beating the San Diego Padres with scores
like 3.2 to 2.7. Because it was clearly impossible in real life
to score a partial run, the results needed to be converted from
floating-point to integer values. This is known as <I>casting</I>
a variable. In Java, you can cast a variable of one type to another
as follows:
<BLOCKQUOTE>
<PRE>
float fRunsScored = 3.2f;
int iRunsScored = (int)fRunsScored;
</PRE>
</BLOCKQUOTE>
<P>
In this case, the floating-point value 3.2 that is stored in <TT>fRunsScored</TT>
will be cast into an integer and placed in <TT>iRunsScored</TT>.
When cast into an integer, the nonwhole portion of the <TT>fRunsScored</TT>
will be truncated so that <TT>iRunsScored</TT> will equal 3.
<P>
This is an example of what is known as a <I>narrowing conversion</I>.
A narrowing conversion may lose information about the overall
magnitude or precision of a numeric value, as you saw in this
case. You should always be careful when writing a narrowing conversion
because of this potential for data loss.
<P>
The other type of conversion is called a <I>widening conversion</I>.
A widening conversion may lose information about precision in
the least significant bits of the value, but it will not lose
information about the magnitude of the value. In general, widening
conversions are much safer. Table A.7 shows the widening conversions
that are possible between Java primitive types.<BR>
<P>
<CENTER><B>Table A.7. Available widening conversions among Java
primitive types.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=96><I>From</I></TD><TD WIDTH=336><I>To</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>byte</TT></TD><TD WIDTH=336><TT>short</TT>, <TT>int</TT>, <TT>long</TT>, <TT>float</TT>, or <TT>double</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>short</TT></TD><TD WIDTH=336><TT>int</TT>, <TT>long</TT>, <TT>float</TT>, or <TT>double</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>char</TT></TD><TD WIDTH=336><TT>int</TT>, <TT>long</TT>, <TT>float</TT>, or <TT>double</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>int</TT></TD><TD WIDTH=336><TT>long</TT>, <TT>float</TT>, or <TT>double</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>long</TT></TD><TD WIDTH=336><TT>float</TT> or <TT>double</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>float</TT></TD><TD WIDTH=336><TT>double</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE:</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Related to casting is the concept of <I>automatic coercion</I>. Automatic coercion occurs when a compiler <I>coerces</I>, or casts, a variable of one type into another automatically. For example, consider the following C++ code:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>long aLong = 65536L;<BR>
unsigned int justAnInt;<BR>
justAnInt = aLong;<BR>
printf(&quot;%d&quot;, justAnInt);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
In this example, the 65,536 stored in <TT>aLong</TT> is also placed into <TT>justAnInt</TT>. Because no explicit cast is performed, an automatic coercion from a <TT>long</TT> to an <TT>unsigned int</TT> is performed. Unfortunately, on a 16-bit platform, 
this will result in an error because the value in <TT>aLong</TT> is too large to fit in <TT>justAnInt</TT>. The automatic coercion will place 0 into <TT>justAnInt</TT> instead of the desired 65,536.
</BLOCKQUOTE>
<BLOCKQUOTE>
Because Java does not perform automatic coercions, you may need to slightly alter your thinking about some of your C++ programming habits. For example, in C++ you could write the following loop:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>int count=10;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>while (count) {</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>    // use count to do something</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>    count--;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
In C++, the <TT>while</TT> loop will execute as long as <TT>count</TT> is nonzero. However, a Java <TT>while</TT> loop must be formed according to the following syntax:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>while (booleanExpression)<BR>
    statement</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
What this means is that statements like <TT>while(count)</TT> do not work in Java because there is no automatic coercion of an integer (such as <TT>count</TT>) to the <TT>boolean</TT> that a Java <TT>while</TT> loop expects. You need to rewrite the C++ 
code fragment to work in Java as follows:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>int count=10;<BR>
while (count &gt; 0) {<BR>
    // use count to do something<BR>
    count--;<BR>
}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This creates a Boolean expression that is evaluated on each pass through the loop. You will need to make similar adjustments with the Java <TT>for</TT> and <TT>do...while</TT> loops, as well.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="Literals"><FONT SIZE=5 COLOR=#FF0000>
Literals</FONT></A></H2>
<P>
A literal is an explicit value that is used by a program. For
example, your program may include a literal value of <TT>3.1415</TT>
that is used whenever the value of <I>pi</I> is necessary, or
it may include <TT>65</TT> as the mandatory retirement age. These
values, <TT>3.1415</TT> and <TT>65</TT>, are both literals.
<H3><A NAME="IntegerLiterals">
Integer Literals</A></H3>
<P>
Integer literals can be specified in decimal, hexadecimal, or
octal notation. To specify a decimal value, simply use the number
as normal. To indicate that a literal value is a long, you can
append either <TT>L</TT> or <TT>l</TT> to the end of the number.
Hexadecimal values are given in base 16 and include the digits
0-9 and the letters A-F. To specify a hexadecimal value, use <TT>0x</TT>
followed the digits and letters that comprise the value. Similarly,
an octal value is identified by a leading <TT>0</TT> symbol.
<P>
For examples of specifying integer literals, see Table A.8.<BR>
<P>
<CENTER><B>Table A.8. Examples of integer literals.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><I>Integer</I></CENTER></TD><TD WIDTH=96><CENTER><I>Long</I></CENTER>
</TD><TD WIDTH=96><CENTER><I>Octal</I></CENTER></TD><TD WIDTH=115><CENTER><I>Hexadecimal</I></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>0</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>0L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>0</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0x0</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>1</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>1L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>01</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0x1</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>10</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>10L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>012</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0xA</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>15</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>15L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>017</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0XF</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>16</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>16L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>020</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0x10</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>100</TT></CENTER></TD><TD WIDTH=96><CENTER><TT>100L</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>0144</TT></CENTER></TD><TD WIDTH=115><CENTER><TT>0x64</TT></CENTER>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="FloatingPointLiterals">
Floating-Point Literals</A></H3>
<P>
Similar to integer literals are Java's floating-point literals.
Floating-point literals can be specified in either the familiar
decimal notation (for example, <TT>3.1415</TT>) or exponential
notation (for example, <TT>6.02e23</TT>). To indicate that a literal
is to be treated as a single precision float, append either <TT>f</TT>
or <TT>F</TT>. To indicate that it is to be treated as a double
precision value, append either <TT>d</TT> or <TT>D</TT>.
<P>
Java includes predefined constants, <TT>POSITIVE_INFINITY</TT>,
<TT>NEGATIVE_INFINITY</TT>, and <TT>NaN</TT>, to represent the
infinity and Not-a-Number values.
<P>
The following list shows some valid floating-point literals:
<BLOCKQUOTE>
<TT>43.3F<BR>
3.1415d<BR>
-12.123f<BR>
6.02e+23f<BR>
6.02e23d<BR>
6.02e-23f<BR>
6.02e23d</TT>
</BLOCKQUOTE>
<H3><A NAME="BooleanLiterals">
Boolean Literals</A></H3>
<P>
Java supports two Boolean literals-<TT>true</TT> and <TT>false</TT>.
<H3><A NAME="CharacterLiterals">
Character Literals</A></H3>
<P>
A character literal is a single character or an escape sequence
enclosed in single quotes, for example, <TT>'b'</TT>. Escape sequences
are used to indicate special characters or actions, such as line
feed, form feed, or carriage return. The available escape sequences
are shown in Table A.9. For examples of character literals, consider
the following:
<BLOCKQUOTE>
<TT>'b'<BR>
'\n'<BR>
\u15e'<BR>
'\t'<BR>
</TT>
</BLOCKQUOTE>
<P>
<CENTER><B>Table A.9. Escape sequences.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Sequence</I></CENTER></TD><TD WIDTH=192><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\b</CENTER></TD><TD WIDTH=192>Backspace
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\t</CENTER></TD><TD WIDTH=192>Horizontal tab
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\n</CENTER></TD><TD WIDTH=192>Line feed
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\f</CENTER></TD><TD WIDTH=192>Form feed
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\r</CENTER></TD><TD WIDTH=192>Carriage return
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\&quot;</CENTER></TD><TD WIDTH=192>Double quote
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\'</CENTER></TD><TD WIDTH=192>Single quote
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\\</CENTER></TD><TD WIDTH=192>Backslash
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER>\uxxxx</CENTER></TD><TD WIDTH=192>Unicode character
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="StringLiterals">
String Literals</A></H3>
<P>
Although there is no string primitive type in Java, you can include
string literals in your programs. Most applications and applets
will make use of some form of string literal, probably at least
for error messages. A string literal consists of zero or more
characters (including the escape sequences shown in Table A.9)
enclosed in double quotes. As examples of string literals, consider
the following:
<BLOCKQUOTE>
<TT>&quot;A String&quot;<BR>
&quot;Column 1\tColumn 2&quot;<BR>
&quot;First Line\r\nSecond Line&quot;<BR>
&quot;First Page\fSecond Page&quot;<BR>
&quot;&quot;</TT>
</BLOCKQUOTE>
<P>
Because Java does not have a string primitive type, each use of
a string literal causes an object of the <TT>String</TT> class
to be created behind the scenes. However, because of Java's automatic
memory management, your program doesn't need to do anything special
to free or release the memory used by the literal or string once
you are finished with it.
<H2><A NAME="Arrays"><FONT SIZE=5 COLOR=#FF0000>
Arrays</FONT></A></H2>
<P>
In Java you declare an array using enclosing square bracket symbols
(<TT>[]</TT>).
<P>
For example, consider the following array declarations:
<BLOCKQUOTE>
<PRE>
int intArray[];
float floatArray[];
double [] doubleArray;
char charArray[];
</PRE>
</BLOCKQUOTE>
<P>
Notice that the brackets can be placed before or after the variable
name. Placing the <TT>[]</TT> after the variable name follows
the conventions of C, and if you are coming to Java from C or
C++, you may want to continue that tradition. However, there is
an advantage to placing the brackets before the variable name.
By placing the brackets in front of the variable name, you can
more easily declare multiple arrays. For example, consider the
following declarations:
<BLOCKQUOTE>
<PRE>
int [] firstArray, secondArray;
int thirdArray[], justAnInt;
</PRE>
</BLOCKQUOTE>
<P>
On the first line both <TT>firstArray</TT> and <TT>secondArray</TT>
are arrays. On the second line, <TT>thirdArray</TT> is an array
but <TT>justAnInt</TT> is, as its name implies, a lone integer.
The ability to declare singleton variables and arrays in the same
statement, as on the second line in the preceding example, is
the source of many problems in other programming languages. Java
helps prevent this type of problem by providing an easy, alternative
syntax for declaring arrays.
<H3><A NAME="Allocation">
Allocation</A></H3>
<P>
Once an array is declared, it must be allocated. You probably
noticed that the size of the arrays have not been specified in
the examples so far. This is because, in Java, all arrays must
be allocated with <TT>new</TT>. Declaring the following array
would have resulted in a compile-time error:
<BLOCKQUOTE>
<PRE>
int intArray[10];   // this is an error
</PRE>
</BLOCKQUOTE>
<P>
To allocate an array you use <TT>new</TT>, as shown in the following
examples:
<BLOCKQUOTE>
<PRE>
int intArray[] = new int[100];
float floatArray[];
floatArray = new float[100];
long [] longArray = new long[100];
double [][] doubleArray = new double[10][10];
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Initialization">
Initialization</A></H3>
<P>
An alternative way of allocating a Java array is to specify a
list of element initializers when the array is declared. This
is done as follows:
<BLOCKQUOTE>
<PRE>
int intArray[] = {1,2,3,4,5};
char [] charArray = {'a', 'b', 'c'};
String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;, &quot;Array&quot;};
</PRE>
</BLOCKQUOTE>
<P>
In this case, <TT>intArray</TT> will be a five-element array holding
the values <TT>1</TT> through <TT>5</TT>. The three-element array
<TT>charArray</TT> will hold the characters <TT>'a'</TT>, <TT>'b'</TT>,
and <TT>'c'</TT>. Finally, <TT>stringArray</TT> will hold the
strings shown.
<H3><A NAME="ArrayAccess">
Array Access</A></H3>
<P>
Items in a Java array are known as the <TT>components</TT> of
the array. You can access a component at runtime by enclosing
the component number you want to access with brackets as shown
in the following:
<BLOCKQUOTE>
<PRE>
int intArray[] = {100, 200, 300, 400, 500};

int a = intArray[0];        // a will be equal to 100
int b = intArray[1];        // b will be equal to 200
int c = intArray[2];        // c will be equal to 300
int d = intArray[3];        // d will be equal to 400
int e = intArray[4];        // e will be equal to 500
</PRE>
</BLOCKQUOTE>
<P>
Java arrays are numbered from 0 to one less than the number of
components in the array. Attempting to access an array beyond
the bounds of the array (for example, <TT>intArray[42]</TT> in
the preceding example) will result in a runtime exception, <TT>ArrayIndexOutOfBoundsException</TT>.
<H2><A NAME="Operators"><FONT SIZE=5 COLOR=#FF0000>
Operators</FONT></A></H2>
<P>
A language's operators can be used to combine or alter a program's
values. Java contains a very rich set of operators. The complete
list of Java operators is as follows:
<P>
<CENTER><I><B>A Complete List of Java Operators</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>=</CENTER></TD><TD WIDTH=96><CENTER>&gt;</CENTER>
</TD><TD WIDTH=96><CENTER>&lt;</CENTER></TD><TD WIDTH=96><CENTER>!</CENTER>
</TD><TD WIDTH=96><CENTER>~</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>?</CENTER></TD><TD WIDTH=96><CENTER>:</CENTER>
</TD><TD WIDTH=96><CENTER>==</CENTER></TD><TD WIDTH=96><CENTER>&lt;=</CENTER>
</TD><TD WIDTH=96><CENTER>&gt;=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>|=</CENTER></TD><TD WIDTH=96><CENTER>&amp;&amp;</CENTER>
</TD><TD WIDTH=96><CENTER>||</CENTER></TD><TD WIDTH=96><CENTER>++</CENTER>
</TD><TD WIDTH=96><CENTER>--</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>+</CENTER></TD><TD WIDTH=96><CENTER>-</CENTER>
</TD><TD WIDTH=96><CENTER>*</CENTER></TD><TD WIDTH=96><CENTER>/</CENTER>
</TD><TD WIDTH=96><CENTER>&amp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>|</CENTER></TD><TD WIDTH=96><CENTER>^</CENTER>
</TD><TD WIDTH=96><CENTER>%</CENTER></TD><TD WIDTH=96><CENTER>&lt;&lt;</CENTER>
</TD><TD WIDTH=96><CENTER>&gt;&gt;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>&gt;&gt;&gt;</CENTER></TD><TD WIDTH=96><CENTER>+=</CENTER>
</TD><TD WIDTH=96><CENTER>-=</CENTER></TD><TD WIDTH=96><CENTER>*=</CENTER>
</TD><TD WIDTH=96><CENTER>/=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>&amp;=</CENTER></TD><TD WIDTH=96><CENTER>|=</CENTER>
</TD><TD WIDTH=96><CENTER>^=</CENTER></TD><TD WIDTH=96><CENTER>%=</CENTER>
</TD><TD WIDTH=96><CENTER>&lt;&lt;=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>&gt;&gt;=</CENTER></TD><TD WIDTH=96><CENTER>&gt;&gt;&gt;=</CENTER>
</TD><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96>&nbsp;</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="OperatorsonIntegers">
Operators on Integers</A></H3>
<P>
The bulk of the Java operators work on integer values. The binary
operators (those that require two operands) are shown in Table
A.10. The unary operators (those that require a single operand)
are shown in Table A.11. Each table gives an example of the use
of each operator.<BR>
<P>
<CENTER><B>Table A.10. Binary operators on integers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=240><I>Operation</I>
</TD><TD WIDTH=144><CENTER><I>Example</I></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>=</TT></CENTER></TD><TD WIDTH=240>Assignment
</TD><TD WIDTH=144><CENTER><TT>a = b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>==</TT></CENTER></TD><TD WIDTH=240>Equality
</TD><TD WIDTH=144><CENTER><TT>a == b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>!=</TT></CENTER></TD><TD WIDTH=240>Inequality
</TD><TD WIDTH=144><CENTER><TT>a != b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;</TT></CENTER></TD><TD WIDTH=240>Less than
</TD><TD WIDTH=144><CENTER><TT>a &lt; b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;=</TT></CENTER></TD><TD WIDTH=240>Less than or equal to
</TD><TD WIDTH=144><CENTER><TT>a &lt;= b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;=</TT></CENTER></TD><TD WIDTH=240>Greater than or equal to
</TD><TD WIDTH=144><CENTER><TT>a &gt;= b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;</TT></CENTER></TD><TD WIDTH=240>Greater than
</TD><TD WIDTH=144><CENTER><TT>a &gt; b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>+</TT></CENTER></TD><TD WIDTH=240>Addition
</TD><TD WIDTH=144><CENTER><TT>a + b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Subtraction
</TD><TD WIDTH=144><CENTER><TT>a - b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>*</TT></CENTER></TD><TD WIDTH=240>Multiplication
</TD><TD WIDTH=144><CENTER><TT>a * b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>/</TT></CENTER></TD><TD WIDTH=240>Division
</TD><TD WIDTH=144><CENTER><TT>a / b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>%</TT></CENTER></TD><TD WIDTH=240>Modulus
</TD><TD WIDTH=144><CENTER><TT>a % b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;&lt;</TT></CENTER></TD><TD WIDTH=240>Left shift
</TD><TD WIDTH=144><CENTER><TT>a &lt;&lt; b</TT></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;&gt;</TT></CENTER></TD><TD WIDTH=240>Right shift
</TD><TD WIDTH=144><CENTER><TT>a &gt;&gt; b</TT></CENTER></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;&gt;&gt;</TT></CENTER></TD>
<TD WIDTH=240>Right shift with zero fill</TD><TD WIDTH=144><CENTER><TT>a &gt;&gt;&gt; b</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&amp;</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>AND</TT>
</TD><TD WIDTH=144><CENTER><TT>a &amp; b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>|</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>OR</TT>
</TD><TD WIDTH=144><CENTER><TT>a | b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>^</TT></CENTER></TD><TD WIDTH=240>Bitwise <TT>XOR</TT>
</TD><TD WIDTH=144><CENTER><TT>a ^ b</TT></CENTER></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER><B>Table A.11. Unary operators on integers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=240><I>Operation</I>
</TD><TD WIDTH=144><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Unary negation
</TD><TD WIDTH=144><TT>-a</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>~</TT></CENTER></TD><TD WIDTH=240>Bitwise logical negation
</TD><TD WIDTH=144><TT>~a</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>++</TT></CENTER></TD><TD WIDTH=240>Increment
</TD><TD WIDTH=144><TT>a++</TT> or <TT>++a</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>--</TT></CENTER></TD><TD WIDTH=240>Decrement
</TD><TD WIDTH=144><TT>a--</TT> or <TT>-a</TT></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In addition to the operators shown in Tables A.10 and A.11, Java
also includes an assortment of assignment operators that are based
on the other operators. These operators will operate on an operand
and store the resulting value back in the same operand. For example,
to increase the following of a variable <TT>x</TT>, you could
do the following:
<BLOCKQUOTE>
<PRE>
x += 3;
</PRE>
</BLOCKQUOTE>
<P>
This is equal to the more verbose <TT>x = x + 3</TT>. Each of
the specialized Java assignment operators performs its normal
function on the operand and then stores the value in the operand.
The following assignment operators are available:
<P>
<CENTER><I><B>Integer Assignment Operators</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>+=</CENTER></TD><TD WIDTH=96><CENTER>-=</CENTER>
</TD><TD WIDTH=96><CENTER>*=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>/=</CENTER></TD><TD WIDTH=96><CENTER>&amp;=</CENTER>
</TD><TD WIDTH=96><CENTER>|=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>^=</CENTER></TD><TD WIDTH=96><CENTER>%=</CENTER>
</TD><TD WIDTH=96><CENTER>&lt;&lt;=</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><CENTER>&gt;&gt;=</CENTER></TD><TD WIDTH=96><CENTER>&gt;&gt;&gt;=</CENTER>
</TD><TD WIDTH=96>&nbsp;</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE:</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You may have noticed that operator overloading is not mentioned in this discussion of operators. Initially, operator overloading was an exciting feature of C++ that promised to enable programmers to treat all data types, whether primitive or not, 
equivalently. The reasoning went that if there was a logically intuitive action that should be performed by an operator, the language should support overloading the operator to perform that action. Unfortunately, reality intervened, and many uses of 
operator overloading in C++ have led to unnecessary bugs. Because of the potential for introducing bugs through operator overloading, the developers of Java wisely chose to leave it out.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="OperatorsonFloatingPointValues">
Operators on Floating-Point Values</A></H3>
<P>
The Java operators on floating-point values are a subset of those
available to Java integer types. The operators on floats and doubles
are shown in Table A.12, which also gives examples of their use.
<BR>
<P>
<CENTER><B>Table A.12. Binary operators on integers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><I>Operator</I></CENTER></TD><TD WIDTH=240><I>Operation</I>
</TD><TD WIDTH=144><CENTER><I>Example</I></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>=</TT></CENTER></TD><TD WIDTH=240>Assignment
</TD><TD WIDTH=144><CENTER><TT>a = b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>==</TT></CENTER></TD><TD WIDTH=240>Equality
</TD><TD WIDTH=144><CENTER><TT>a == b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>!=</TT></CENTER></TD><TD WIDTH=240>Inequality
</TD><TD WIDTH=144><CENTER><TT>a != b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;</TT></CENTER></TD><TD WIDTH=240>Less than
</TD><TD WIDTH=144><CENTER><TT>a &lt; b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&lt;=</TT></CENTER></TD><TD WIDTH=240>Less than or equal to
</TD><TD WIDTH=144><CENTER><TT>a &lt;= b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;=</TT></CENTER></TD><TD WIDTH=240>Greater than or equal to
</TD><TD WIDTH=144><CENTER><TT>a &gt;= b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>&gt;</TT></CENTER></TD><TD WIDTH=240>Greater than
</TD><TD WIDTH=144><CENTER><TT>a &gt; b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>+</TT></CENTER></TD><TD WIDTH=240>Addition
</TD><TD WIDTH=144><CENTER><TT>a + b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Subtraction
</TD><TD WIDTH=144><CENTER><TT>a - b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>*</TT></CENTER></TD><TD WIDTH=240>Multiplication
</TD><TD WIDTH=144><CENTER><TT>a * b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>/</TT></CENTER></TD><TD WIDTH=240>Division
</TD><TD WIDTH=144><CENTER><TT>a / b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>%</TT></CENTER></TD><TD WIDTH=240>Modulus
</TD><TD WIDTH=144><CENTER><TT>a % b</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>-</TT></CENTER></TD><TD WIDTH=240>Unary negation
</TD><TD WIDTH=144><CENTER><TT>-a</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>++</TT></CENTER></TD><TD WIDTH=240>Increment
</TD><TD WIDTH=144><CENTER><TT>a++</TT> or <TT>++a</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><CENTER><TT>--</TT></CENTER></TD><TD WIDTH=240>Decrement
</TD><TD WIDTH=144><CENTER><TT>a--</TT> or <TT>-a</TT></CENTER>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="OperatorsonBooleanValues">
Operators on Boolean Values</A></H3>
<P>
The Java Boolean operators are summarized in Table A.13. If you
are coming to Java from a C or C++ background, you are probably
already familiar with these. If not, however, the conditional
operator will be a new experience.
<P>
<CENTER><B>Table A.13. Operators on Boolean values.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=144><I>Operator</I></TD><TD WIDTH=144><I>Operation</I>
</TD><TD WIDTH=144><I>Example</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>!</TT></TD><TD WIDTH=144>Negation</TD><TD WIDTH=144><TT>!a</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>&amp;&amp;</TT></TD><TD WIDTH=144>Conditional <TT>AND</TT>
</TD><TD WIDTH=144><TT>a &amp;&amp; b</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>||</TT></TD><TD WIDTH=144>Conditional <TT>OR</TT>
</TD><TD WIDTH=144><TT>a || b</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>==</TT></TD><TD WIDTH=144>Equality</TD>
<TD WIDTH=144><TT>a == b</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>!=</TT></TD><TD WIDTH=144>Inequality</TD>
<TD WIDTH=144><TT>a != b</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>?:</TT></TD><TD WIDTH=144>Conditional</TD>
<TD WIDTH=144><TT>a ? expr1 : expr2</TT></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The conditional operator is Java's only ternary (three-operand)
operator and has the following syntactic form:
<BLOCKQUOTE>
<PRE>
booleanExpr ? expr1 : expr2
</PRE>
</BLOCKQUOTE>
<P>
The value of <TT>booleanExpr</TT> is evaluated and if <TT>true</TT>,
the expression <TT>expr1</TT> is executed; if <TT>false</TT>,
expression <TT>expr2</TT> is executed. This makes the conditional
operator a convenient shorthand for the following:
<BLOCKQUOTE>
<PRE>
if(booleanExpression)
    expr1
else
    expr2<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
In Java, unlike C++, Boolean operators operate only on Boolean expressions. For example, consider the following C++ fragment:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>int x = 1;<BR>
int y = 7;<BR>
if (x &amp;&amp; y) {<BR>
    // do something<BR>
}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This same code is illegal in Java. Because the <TT>&amp;&amp;</TT> operator expects two <TT>boolean</TT> operands and there is no automatic coercion from an integer, the Java compiler does not know how to interpret this statement. In Java, it needs to be 
rewritten as follows:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>int x = 1;<BR>
int y = 7;<BR>
if (x != 0 &amp;&amp; y != 0) {<BR>
    // do something<BR>
}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
In this case, the two integer values have been converted into explicit tests. Because these tests are Boolean expressions, the code can now be compiled.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="ControllingYourProgram"><FONT SIZE=5 COLOR=#FF0000>
Controlling Your Program</FONT></A></H2>
<P>
The Java keywords for controlling program flow are nearly identical
to C and C++. This is one of the most obvious ways in which Java
shows its legacy as a derivative of these two languages. In this
section, you will see how to use Java's control flow commands
to write methods.
<H3><A NAME="Selection">
Selection</A></H3>
<P>
The Java language provides two alternative structures-<TT>if</TT>
statements and <TT>switch</TT> statements-for selecting among
alternatives. Although it would be possible to spend your entire
Java programming career using only one of these at the expense
of the other, each has its definite advantages.
<H4>The if Statement</H4>
<P>
A Java <TT>if</TT> statement is a test of any Boolean expression.
If the Boolean expression evaluates to <TT>true</TT>, the statement
following the <TT>if</TT> is executed. On the other hand, if the
Boolean expression evaluates to <TT>false</TT>, the statement
following the <TT>if</TT> is not executed. For example, consider
the following code fragment:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
if (today.getDay == 0) then
    System.out.println(&quot;It is Sunday.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This code uses the java.Util.Date package and creates a variable
named <TT>today</TT> that will hold the current date. The <TT>getDay</TT>
member method is then applied to <TT>today</TT> and the result
compared to <TT>0</TT>. A return value of <TT>0</TT> for <TT>getDay</TT>
indicates that the day is Sunday, so if the Boolean expression
<TT>today.getDay == 0</TT> is true, a message is displayed. If
today isn't Sunday, no action occurs.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you are coming to Java from a C or C++ background, you may have been tempted to rewrite the preceding example as follows:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.util.Date;<BR>
Date today = new Date();<BR>
if (!today.getDay) then<BR>
    System.out.println(&quot;It is Sunday.&quot;);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
In C and C++, the expression !today.getDay would evaluate to 1 whenever today.getDay evaluated to 0 (indicating Sunday). In Java the expression used within an if statement must evaluate to a Boolean. Therefore, this code doesn't work because !today.getDay 
will evaluate to 0 or 1, depending on which day of the week it is. And, as you learned earlier in this chapter, integer values cannot be cast to Boolean values. This is, of course, an example where Java's nuances may take a little getting used to for C and 
C++ programmers. Once you're accustomed to the change, however, you will find your code more readable, reliable, and maintainable.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Of course, an <TT>if</TT> statement without an <TT>else</TT> is
as incomplete as a Labrador Retriever without a bandanna around
his neck. Not wanting to be accused of cruelty to animals or programmers,
the Java developers included an <TT>else</TT> statement that can
be executed whenever an <TT>if</TT> statement evaluates to <TT>false</TT>.
This can be seen in the following sample code:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
if (today.getDay == 0) then
    System.out.println(&quot;It is Sunday.&quot;);
else
    System.out.println(&quot;It is NOT Sunday.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In this case, the same message will be displayed whenever it is
Sunday, but a different message will be displayed whenever it
is not Sunday. Both examples so far have only shown the execution
of a single statement within the <TT>if</TT> or the <TT>else</TT>
cases. By enclosing the statements within curly braces, you can
execute as many lines of code as you'd like. This can be seen
in the following example that makes some suggestions about how
to spend each day of the week:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
if (today.getDay == 0) then {
    System.out.println(&quot;It is Sunday.&quot;);
    System.out.println(&quot;And a good day for golf.&quot;);
}
else {
    System.out.println(&quot;It is NOT Sunday.&quot;);
    System.out.println(&quot;But still a good day for golf.&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
Because it's possible to execute whatever code you desire in the
<TT>else</TT> portion of an <TT>if...else</TT> block, you may
have already reasoned that it is possible to execute another <TT>if</TT>
statement inside the <TT>else</TT> statement of the first <TT>if</TT>
statement. This is commonly known as an <TT>if...else if...else</TT>
block, an example of which follows:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
if (today.getDay == 0) then
    System.out.println(&quot;It is Sunday.&quot;);
else if (today.getDay == 1) then
    System.out.println(&quot;It is Monday.&quot;);
else if (today.getDay == 2) then
    System.out.println(&quot;It is Tuesday.&quot;);
else if (today.getDay == 3) then
    System.out.println(&quot;It is Wednesday.&quot;);
else if (today.getDay == 4) then
    System.out.println(&quot;It is Thursday.&quot;);
else if (today.getDay == 5) then
    System.out.println(&quot;It is Friday.&quot;);
else
    System.out.println(&quot;It must be Saturday.&quot;);
</PRE>
</BLOCKQUOTE>
<H4>The switch Statement</H4>
<P>
As you can see from the previous code sample, a lengthy series
of <TT>if...else if...else</TT> statements can get convoluted
and hard to read as the number of cases increases. Fortunately,
you can avoid this problem by using Java's <TT>switch</TT> statement.
Like its C and C++ cousins, the Java <TT>switch</TT> statement
is ideal for testing a single expression against a series of possible
values and executing the code associated with the matching <TT>case</TT>
statement, as shown in the following example:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
switch (today.getDay) {
    case 0:    // Sunday
        System.out.println(&quot;It is Sunday.&quot;);
        break;
    case 1:    // Monday
        System.out.println(&quot;It is Monday.&quot;);
        break;
    case 2:    // Tuesday
        System.out.println(&quot;It is Tuesday.&quot;);
        break;
    case 3:    // Wednesday
        System.out.println(&quot;It is Wednesday.&quot;);
        break;
    case 4:    // Thursday
        System.out.println(&quot;It is Thursday.&quot;);
        break;
    case 5:    // Friday
        System.out.println(&quot;It is Friday.&quot;);
        System.out.println(&quot;Have a nice weekend!&quot;);
        break;
    default:   // Saturday
        System.out.println(&quot;It must be Saturday.&quot;);
}
System.out.println(&quot;All done!&quot;);
</PRE>
</BLOCKQUOTE>
<P>
You should have noticed that each day has its own <TT>case</TT>
within the <TT>switch</TT>. The Saturday case (where <TT>today.getDay</TT>
<TT>= 6</TT>) is not explicitly given but is instead handled by
the <TT>default</TT> case. Any <TT>switch</TT> block may include
an optional <TT>default</TT> case that will handle any values
not caught by an explicit <TT>case</TT>.
<P>
Within each <TT>case</TT>, there can be multiple lines of code.
The block of code that will execute for the Friday <TT>case</TT>,
for example, contains three lines. The first two lines will simply
display informational messages, but the third is a <TT>break</TT>
statement. The keyword <TT>break</TT> is used within a <TT>case</TT>
statement to indicate that the flow of the program should move
to the first line following the <TT>switch</TT> block. In this
example, <TT>break</TT> appears as the last statement in each
case except the default and will cause program execution to move
to the line that prints <TT>&quot;All done!&quot;</TT>. The <TT>break</TT>
statement was left out of the default block because by that point
in the code, the <TT>switch</TT> block was ending, and there was
no point in using an explicit command to exit the <TT>switch</TT>.
<P>
If, as the previous example seems to imply, you always need to
include a <TT>break</TT> statement at the end of each block, why
not just leave <TT>break</TT> out and have Java assume that after
a block executes, control should move outside the <TT>switch</TT>
block? The answer is that there are times when you do not want
to break out of the <TT>switch</TT> statement after executing
the code for a specific case value. For example, consider the
following code that could be used as a scheduling system for physicians:
<BLOCKQUOTE>
<PRE>
import java.util.Date;
Date today = new Date();
switch (today.getDay) {
    case 0:      // Sunday
    case 3:      // Wednesday
    case 6:      // Saturday
        System.out.println(&quot;It's Golf Day!&quot;);
        break;
    case 2:      // Tuesday
        System.out.println(&quot;Tennis at 8:00 am&quot;);
    case 1:      // Monday
    case 4:      // Thursday
    case 5:      // Friday
        System.out.println(&quot;Office Hours: 10:00 - 5:00&quot;);
        break;
}
System.out.println(&quot;All done!&quot;);
</PRE>
</BLOCKQUOTE>
<P>
This example illustrates a couple of key concepts about <TT>switch</TT>
statements. First, you'll notice that it is possible to have multiple
cases execute the same block of code, as follows:
<BLOCKQUOTE>
<PRE>
case 0:      // Sunday
case 3:      // Wednesday
case 6:      // Saturday
    System.out.println(&quot;It's Golf Day!&quot;);
    break;
</PRE>
</BLOCKQUOTE>
<P>
This code will result in the message <TT>&quot;It's Golf Day&quot;</TT>
being displayed if the current day is Wednesday, Saturday, or
Sunday. If you collect the three cases together without any intervening
<TT>break</TT> statements, each will execute the same code. But
consider what happens on Tuesday when the following code executes:
<BLOCKQUOTE>
<PRE>
case 2:      // Tuesday
    System.out.println(&quot;Tennis at 8:00 am&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Certainly a reminder about the message match will be displayed,
but this case doesn't end with a <TT>break</TT> statement. Because
Tuesday's code doesn't end with a <TT>break</TT> statement, the
program will continue executing the code in the following cases
until a <TT>break</TT> is encountered. This means that Tuesday's
code flows into the code used for Monday, Thursday, and Friday
as shown in the following:
<BLOCKQUOTE>
<PRE>
case 2:      // Tuesday
    System.out.println(&quot;Tennis at 8:00 am&quot;);
case 1:      // Monday
case 4:      // Thursday
case 5:      // Friday
    System.out.println(&quot;Office Hours: 10:00 - 5:00&quot;);
    break;
</PRE>
</BLOCKQUOTE>
<P>
This will result in the following messages being displayed every
Tuesday:
<BLOCKQUOTE>
<PRE>
Tennis at 8:00 am
Office Hours: 10:00 - 5:00
</PRE>
</BLOCKQUOTE>
<P>
On Monday, Thursday, and Friday, only the latter message will
display.
<P>
In addition to writing <TT>switch</TT> statements that use integer
cases, you can use character values as shown in the following
example:
<BLOCKQUOTE>
<PRE>
switch (aChar) {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        System.out.println(&quot;It's a vowel!&quot;);
        break;
    default:
        System.out.println(&quot;It's a consonant!&quot;);
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Iteration">
Iteration</A></H3>
<P>
Iteration is an important concept in any computer language. Without
the capability to loop or iterate through a set of values, our
ability to solve real-world problems would be severely limited.
Java's iteration statements are nearly identical to those found
in C and C++ and include <TT>for</TT> loops, <TT>while</TT> loops,
and <TT>do...while</TT> loops.
<H4>The for Statement</H4>
<P>
The syntax of the Java <TT>for</TT> statement is very powerful
and concise. The first line of a <TT>for</TT> loop enables you
to specify a starting value for a loop counter, specify the test
condition that will exit the loop, and indicate how the loop counter
should be incremented after each pass through the loop. This is
definitely a statement that offers a lot of bang for the buck.
The syntax of a Java <TT>for</TT> statement is as follows:
<BLOCKQUOTE>
<PRE>
for (initialization; testExpression; incremement)
    statement
</PRE>
</BLOCKQUOTE>
<P>
For example, a sample <TT>for</TT> loop may appear as follows:
<BLOCKQUOTE>
<PRE>
int count;
for (count=0; count&lt;100; count++)
    System.out.println(&quot;Count = &quot; + count);
</PRE>
</BLOCKQUOTE>
<P>
In this example, the initialization statement of the <TT>for</TT>
loop sets <TT>count</TT> to <TT>0</TT>. The test expression, <TT>count
&lt; 100</TT>, indicates that the loop should continue as long
as <TT>count</TT> is less than <TT>100</TT>. Finally, the increment
statement increments the value of <TT>count</TT> by one. As long
as the test expression is <TT>true</TT>, the statement following
the <TT>for</TT> loop setup will be executed, as follows:
<BLOCKQUOTE>
<PRE>
System.out.println(&quot;Count = &quot; + count);
</PRE>
</BLOCKQUOTE>
<P>
Of course, you probably need to do more than one thing inside
the loop. This is as easy to do as using curly braces to indicate
the scope of the <TT>for</TT> loop, as shown in the following:
<BLOCKQUOTE>
<PRE>
int count;
for (count=0; count&lt;100; count++) {
    YourMethod(count);
    System.out.println(&quot;Count = &quot; + count);
}
</PRE>
</BLOCKQUOTE>
<P>
One nice shortcut that can be taken with a Java <TT>for</TT> loop
is to declare and initialize the variable used in the loop. For
example, in the following code, the variable <TT>count</TT> is
declared directly within the <TT>for</TT> loop:
<BLOCKQUOTE>
<PRE>
for (int count=0; count&lt;100; count++)
    System.out.println(&quot;Count = &quot; + count);
</PRE>
</BLOCKQUOTE>
<P>
It may look like an inconsequential difference whether you declare
a variable before a <TT>for</TT> loop or within the loop. However,
there are advantages to declaring the variable within the loop.
First, it makes your intention to use the variable within the
loop clear. If the variable is declared above the <TT>for</TT>
loop, how will you remember (and how will future programmers know)
that the variable was intended for use only <I>within</I> the
loop? Second, a variable declared within the <TT>for</TT> loop
will go out of scope at the end of the loop. This means you could
not write the following code:
<BLOCKQUOTE>
<PRE>
for (int count=0; count&lt;100; count++)
    System.out.println(&quot;Count = &quot; + count);
System.out.println(&quot;Loop exited with count = &quot; + count);
</PRE>
</BLOCKQUOTE>
<P>
The last line cannot find a variable named <TT>count</TT> because
<TT>count</TT> goes out of scope when the <TT>for</TT> loop terminates.
This means that, in addition to making the intended purpose of
the variable more clear, it is also impossible to accidentally
bypass that intent and use the variable outside the loop.
<P>
You can also leave out portions of the first line of a <TT>for</TT>
loop. In the following example, the increment statement has been
left out:
<BLOCKQUOTE>
<PRE>
for (int count=0; count&lt;100; ) {
    count += 2;
    System.out.println(&quot;Count = &quot; + count);
}
</PRE>
</BLOCKQUOTE>
<P>
Of course, leaving the increment statement out of the <TT>for</TT>
loop declaration in this example doesn't achieve any useful purpose
because <TT>count</TT> is incremented inside the loop.
<P>
It is possible to get even fancier with a Java <TT>for</TT> loop
by including multiple statements or conditions. For example, consider
the following code:
<BLOCKQUOTE>
<PRE>
for (int up=0, down = 20; up &lt; down; up++, down -= 2 ) {
    System.out.println(&quot;Up = &quot; + up + &quot;\tDown = &quot; + down);
}
</PRE>
</BLOCKQUOTE>
<P>
This loop starts the variable <TT>up</TT> at <TT>0</TT> and increments
it by <TT>1</TT>. It also starts the variable <TT>down</TT> at
<TT>20</TT> and decrements it by <TT>2</TT> for each pass through
the loop. The loop continues until <TT>up</TT> has been incremented
enough that it is equal to or greater than the variable <TT>down</TT>.
<P>
The test expression portion of a Java <TT>for</TT> loop can be
any Boolean expression. Because of this, it does not need to be
a simple test (<TT>x &lt; 10</TT>) as shown in the preceding examples.
The test expression can be a method call, a method call combined
with a value test, or anything that can be phrased as a Boolean
expression. For example, suppose you want to write a method that
will display a message indicating the first year since World War
II that the Chicago Cubs appeared in the World Series. You could
do this as follows:
<BLOCKQUOTE>
<PRE>
public boolean DidCubsPlayInWorldSeries(int year) {
    boolean retval;

    switch(year) {
        case 1907:             // these are years the Cubs won
        case 1908:
            retval = true;
            break;
        case 1906:             // these are years the Cubs lost
        case 1910:
        case 1918:
        case 1929:
        case 1932:
        case 1935:
        case 1938:
        case 1945:
            retval = true;
            break;
        default:
            retval = false;
    }
    return retval;
}

public void FindFirstAfterWWII() {
    for (int year=1946; DidCubsPlayInWorldSeries(year)==false; year++) {
        System.out.println(&quot;The Cubs didn't play in &quot; + year);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
The method <TT>DidCubsPlayInWorldSeries</TT> is passed an integer
value indicating the year and returns a Boolean value that indicates
whether or not the Cubs made it to the World Series in that year.
This method is an example of the <TT>switch</TT> statement shown
earlier in this chapter.
<P>
The method <TT>FindFirstAfterWWII</TT> uses a <TT>for</TT> loop
to find a year in which the Cubs played in the World Series. The
loop starts <TT>year</TT> with 1946 and increments <TT>year</TT>
by one for each pass through the loop. The test expression for
the loop will allow the loop to continue as long as the method
<TT>DidCubsPlayInWorldSeries</TT> returns <TT>false</TT>. This
is a useful example because it shows that a method can be called
within the test expression of a <TT>for</TT> loop. Unfortunately,
it is a bad example in that the Cubs haven't won the World Series
since the goose step was popular in Berlin, and there is no sign
of that changing in the near future. In other words, a loop that
looks for a Cubs World Series appearance after 1945 is an infinite
loop.
<H4>The while Statement</H4>
<P>
Related to the <TT>for</TT> loop is the <TT>while</TT> loop. The
syntax for a <TT>while</TT> loop is as follows:
<BLOCKQUOTE>
<PRE>
while (booleanExpression)
    statement
</PRE>
</BLOCKQUOTE>
<P>
As you can tell from the simplicity of this, the Java <TT>while</TT>
loop does not have the built-in support for initializing and incrementing
variables that its <TT>for</TT> loop does. Because of this, you
need to be careful to initialize loop counters prior to the loop
and increment them within the body of the <TT>while</TT> loop.
For example, the following code fragment will display a message
five times:
<BLOCKQUOTE>
<PRE>
int count = 0;
while (count &lt; 5) {
    System.out.println(&quot;Count = &quot; + count);
    count++;
}
</PRE>
</BLOCKQUOTE>
<H4>The do...while Statement</H4>
<P>
The final looping construct in Java is the <TT>do...while</TT>
loop. The syntax for a <TT>do...while</TT> loop is as follows:
<BLOCKQUOTE>
<PRE>
do {
    statement
} while (booleanExpression);
</PRE>
</BLOCKQUOTE>
<P>
This is similar to a <TT>while</TT> loop except that a <TT>do...while</TT>
loop is guaranteed to execute at least once. It is possible that
a <TT>while</TT> loop may not execute at all depending on the
test expression used in the loop. For example, consider the following
method:
<BLOCKQUOTE>
<PRE>
public void ShowYears(int year) {
    while (year &lt; 2000) {
        System.out.println(&quot;Year is &quot; + year);
        year++;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This method is passed a year value, and then loops over the year
displaying a message as long as the year is less than 2000. If
<TT>year</TT> starts at 1996, messages will be displayed for the
years 1996, 1997, 1998, and 1999. However, what happens if <TT>year</TT>
starts at 2010? Because the initial test, <TT>year &lt; 2000</TT>,
will be <TT>false</TT>, the <TT>while</TT> loop will never be
entered. Fortunately, a <TT>do...while</TT> loop can solve this
problem. Because a <TT>do...while</TT> loop performs its expression
testing after the body of the loop has executed for each pass,
it will always be executed at least once. This is a very valid
distinction between the two types of loop, but it can also be
a potential source of errors. Whenever you use a <TT>do...while</TT>
loop, you should be careful to consider the first pass through
the body of the loop.
<H3><A NAME="Jumping">
Jumping</A></H3>
<P>
Of course, it is not always easy to write all your <TT>for</TT>,
<TT>while</TT>, and <TT>do...while</TT> loops so that they are
easy to read and yet terminate on exactly the right pass through
the loop. Java makes it easier to jump out of loops and to control
other areas of program flow with its <TT>break</TT> and <TT>continue</TT>
statements.
<H4>The break Statement</H4>
<P>
Earlier in this chapter, you saw how the <TT>break</TT> statement
is used to exit a <TT>switch</TT> statement. In a similar manner,
<TT>break</TT> can be used to exit a loop. This can be seen in
Figure A.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-1.gif"><B> Figure 25.1 : </B><I>Flow of control with a break statement.
</I></A><P>
<P>
As Figure A.1 illustrates, if the <TT>break</TT> statement is
encountered, execution will continue with <TT>statement4</TT>.
As an example of this, consider the following code:
<BLOCKQUOTE>
<PRE>
int year = 1909;
while (DidCubsWinTheWorldSeries(year) == false) {
    System.out.println(&quot;Didn't win in &quot; + year);
    if (year &gt;= 3000) {
        System.out.println(&quot;Time to give up. Go White Sox!&quot;);
        break;
    }
}
System.out.println(&quot;Loop exited on year &quot; + year);
</PRE>
</BLOCKQUOTE>
<P>
This example shows a <TT>while</TT> loop that will continue to
execute until it finds a year that the Chicago Cubs won the World
Series. Because they haven't won since 1908 and the loop counter
<TT>year</TT> starts with 1909, it has a lot of looping to do.
For each year they didn't win, a message is displayed. However,
even die-hard Cubs fans will eventually give up and change allegiances
to the Chicago White Sox. In this example, if the year is 3000
or later, a message is displayed and then a <TT>break</TT> is
encountered. The <TT>break</TT> statement will cause program control
to move to the first statement after the end of the <TT>while</TT>
loop. In this case, that will be the following line:
<BLOCKQUOTE>
<PRE>
System.out.println(&quot;Loop exited on year &quot; + year);
</PRE>
</BLOCKQUOTE>
<H4>The continue Statement</H4>
<P>
Just as a <TT>break</TT> statement can be used to move program
control to immediately after the end of a loop, the <TT>continue</TT>
statement can be used to force program control back to the top
of a loop. This can be seen in Figure A.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-2.gif"><B> Figure 25.2 : </B><I>Flow of control with a continue statement.
</I></A><P>
<P>
Suppose you want to write a method that will count and display
the number of times the Cubs have won the World Series this century.
One way to do this would be to first see if the Cubs played in
the World Series and then see if they won. This could be done
as follows:
<BLOCKQUOTE>
<PRE>
int timesWon = 0;
for (int year=1900; year &lt;= 2000; year++) {
    if (DidCubsPlayInWorldSeries(year) = false)
        continue;
    if (DidCubsWinWorldSeries(year)) {
        System.out.println(&quot;Cubbies won in &quot; + year + &quot;!&quot;);
        timesWon++;
    }
}
System.out.println(&quot;The Cubs won &quot; + timesWon + &quot; times.&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In this case, a <TT>for</TT> loop is used to iterate through the
years from 1900 to 2000. The first line within the loop tests
to see if the Cubs played in the World Series. If they didn't,
the <TT>continue</TT> statement is executed. This moves program
control back to the <TT>for</TT> loop. At that point, <TT>year</TT>
is incremented and the expression <TT>year &lt;= 2000</TT> is
retested. If <TT>year</TT> is less than or equal to <TT>2000</TT>,
the loop continues. If, however, <TT>DidCubsPlayInWorldSeries</TT>
equals <TT>true</TT>, the <TT>continue</TT> statement is skipped,
and the next test is performed to see if the Cubs won that year.
<H4>Using Labels</H4>
<P>
Java does not include a <TT>goto</TT> statement. However, the
fact that <TT>goto</TT> is a reserved word indicates that it may
be added in a future version. Instead of <TT>goto</TT>, Java enables
you to combine <TT>break</TT> and <TT>continue</TT> with a label.
This has an effect similar to a <TT>goto</TT> in that it allows
a program to reposition control. In order to understand the use
of labels with <TT>break</TT> and <TT>continue</TT>, consider
the following example:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g) {
    int line=1;

    outsideLoop:
    for(int out=0; out&lt;3; out++) {
        g.drawString(&quot;out = &quot; + out, 5, line * 20);
        line++;

        for(int inner=0;inner &lt; 5; inner++) {
            double randNum = Math.random();
            g.drawString(Double.toString(randNum), 15, line * 20);
            line++;
            if (randNum &lt; .10) {
                g.drawString(&quot;break to outsideLoop&quot;, 25, line * 20);
                line++;
                break outsideLoop;
            }
            if (randNum &lt; .60) {
                g.drawString(&quot;continue to outsideLoop&quot;, 25, line * 20);
                line++;
                continue outsideLoop;
           }
        }
    }
    g.drawString(&quot;all done&quot;, 50, line * 20);
}
</PRE>
</BLOCKQUOTE>
<P>
This example includes two loops. The first loops on the variable
<TT>out</TT>, and the second loops on the variable <TT>inner</TT>.
The outer loop has been labeled by the following line:
<BLOCKQUOTE>
<PRE>
outsideLoop:
</PRE>
</BLOCKQUOTE>
<P>
This statement will serve as a placeholder and as a name for the
outer loop. A random number between 0 and 1 is generated for each
iteration through the inner loop. This number is displayed on
the screen. If the random number is less than 0.10, the statement
<TT>break outsideLoop</TT> is executed. A normal <TT>break</TT>
statement in this position would break out of the inner loop.
However, because this is a labeled <TT>break</TT> statement, it
has the effect of breaking out of the loop identified by the name.
In this case, program control passes to the line that displays
<TT>&quot;all done&quot;</TT> because that is the first line after
<TT>outsideLoop</TT>.
<P>
On the other hand, if the random number is not less than 0.10,
the number is compared to 0.60. If it is less than this, the statement
<TT>continue outsideLoop</TT> is executed. A normal, unlabeled
<TT>continue</TT> statement at this point would have the effect
of transferring program control back to the top of the inner loop.
Because this is a labeled <TT>continue</TT> statement, program
control is transferred to the start of the named loop. A sample
run of this method, as captured in the Java Applet Viewer, is
shown in Figure A.3.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-3.gif"><B> Figure 25.3 : </B><I>Sample results demonstrating the use of labels.
</I></A><P>
<P>
As you can see in Figure A.3, the first pass through the outer
loop resulted in four passes through the inner loop. When the
value <TT>0.518478</TT> was generated, it caused the <TT>continue
outsideLoop</TT> to execute because the number is less than 0.60.
The next pass through the outer loop was similar except that it
did a <TT>continue</TT> of the outer loop after only one iteration
through the inner loop. Finally, on the third pass through the
outer loop, the program generated a value lower than 0.10, which
caused the program to break to the outer loop. You can see that,
at this point, the next line of code to be executed was the first
line of code after the outer loop (the line that prints the message
<TT>&quot;all done&quot;</TT>).
<H2><A NAME="JavaClasses"><FONT SIZE=5 COLOR=#FF0000>
Java Classes</FONT></A></H2>
<P>
Now that you've seen most of the low-level details of the Java
language, it's time to turn your attention to Java classes and
see how Java is able to live up to its claim of being an object-oriented
language. A Java class is a compile-time concept that represents
a runtime object. In other words, a class is a definition or template
for an object that will exist within the program. For example,
if you have a class called <TT>Car</TT>, you may have a particular
instance of that class that is a 1966 Volkswagen Beetle. The instances
(1966 Volkswagen Beetle) of a class <TT>(Car</TT>) are known as
objects. In order to define a class in Java, you would do something
similar to the following:
<BLOCKQUOTE>
<PRE>
class Car {
    // member variables
    // member methods
}<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>C++ NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The design of Java's object model and its support for classes was certainly influenced by C++. However, Java classes borrow less from C++ than do many other aspects of Java and its syntax. Although classes are undeniably important in C++, classes are 
mandatory and central to everything you do in Java. In Java, there are no free-standing variables or functions. Everything must be encapsulated within a class. Further, every class in Java can trace back through its inheritance hierarchy and find itself a 
descendant of the Object class.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="FieldDeclarations">
Field Declarations</A></H3>
<P>
<TT>Car</TT> is now an empty class. In order to make it usable
and useful, you need to add some fields to the class. A field
can be either a member variable or a member method. To declare
member variables, all you need to do is identify the variable
by type and name in the class definition, as shown in the following:
<BLOCKQUOTE>
<PRE>
class Car {
    // these are member variables
    String manufacturer;
    String model;
    int year;
    int passengers;
}
</PRE>
</BLOCKQUOTE>
<P>
In this example, <TT>Car</TT> has been extended to include string
variables for manufacturer and model, and integer variables for
the year it was built and the number of passengers it can hold.
From this class definition, it is then possible to create instances,
or objects, at runtime, as shown in Figure A.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-4.gif"><B> Figure 25.4 : </B><I>The Car class and objects.
</I></A><P>
<H4>Field Access</H4>
<P>
One of the principal advantages of object-oriented programming
is <I>encapsulation</I>. Encapsulation is the capability to define
classes that hide their implementation details from other classes,
exposing only their public interfaces to those other classes.
Support for encapsulation in Java comes from the three keywords
<TT>public</TT>, <TT>private</TT>, and <TT>protected</TT>. When
you are defining a class, these field access modifiers are used
to control who has access to each field in the class. By declaring
a field as <TT>public</TT>, you are indicating that it is entirely
accessible to all other classes. Continuing with the <TT>Car</TT>
class example, to declare all the fields as <TT>public</TT>, do
the following:
<BLOCKQUOTE>
<PRE>
class Car {
    public String manufacturer;
    public String model;
    public int year;
    public int passengers;
}
</PRE>
</BLOCKQUOTE>
<P>
Of course, declaring everything as <TT>public</TT> doesn't exactly
achieve the goal of encapsulation because it lets other classes
directly access variables in the <TT>Car</TT> class. Consider
what would happen if you needed to create an instance of this
class for a 1964-and-a-half Mustang. Because <TT>year</TT> only
holds integer values, it would have to be changed to a <TT>float</TT>
so that it could hold <TT>1964.5</TT>. If code in other classes
directly accessed <TT>year</TT>, that code could conceivably break.
<P>
To restrict access to a field, use the keyword <TT>private</TT>.
A class cannot access the private fields of another class. Suppose
the <TT>Car</TT> class is intended for use in a used car sales
application. In this case, you may want to define <TT>Car</TT>
as follows in order to hide your cost for a car from potential
buyers:
<BLOCKQUOTE>
<PRE>
class Car {
    public String manufacturer;
    public String model;
    public int year;
    public int passengers;
    private float cost;
}
</PRE>
</BLOCKQUOTE>
<P>
Finally, the keyword <TT>protected</TT> is used to indicate that
fields are accessible within the current class and all classes
derived from the class but not to other classes. The capability
to derive a class from another class will be discussed later in
this appendix.
<H4>Setting Initial Values</H4>
<P>
One extremely nice aspect of Java class declarations is the capability
to specify initial values for member variables in the variable
declaration. For example, because most cars will hold four passengers,
it may be reasonable to default the <TT>passengers</TT> member
variable to <TT>4</TT>, as shown in the following code:
<BLOCKQUOTE>
<PRE>
class Car {
    public String manufacturer;
    public String model;
    public int year;
    public int passengers = 4;
    private float cost;
}
</PRE>
</BLOCKQUOTE>
<H4>Static Members</H4>
<P>
In addition to <TT>private</TT>, <TT>protected</TT>, and <TT>public</TT>
members, a Java class can also have <TT>static</TT> members. A
static member is one that belongs to the class itself, not to
the instances of the class. Regardless of how many instances of
a class have been created by a program at runtime, there will
exist exactly one instance of each <TT>static</TT> member. Declaring
a static member is done by adding the keyword <TT>static</TT>
to any of the other field access modifiers, as shown in the following:
<BLOCKQUOTE>
<PRE>
class Car {
    public String manufacturer;
    public String model;
    public int year;
    public int passengers = 4;
    private float cost;
    public static int tireQty = 4;
}
</PRE>
</BLOCKQUOTE>
<P>
In this case, the variable <TT>tireQty</TT> has been added and
is set to <TT>4</TT>. Because every car will have four tires,
<TT>tireQty</TT> was declared as <TT>static</TT>. Also, because
we want <TT>tireQty</TT> to be accessible to other classes, it
has been declared <TT>public</TT>.
<P>
It is also possible to declare member methods as static, as will
be shown later in this appendix.
<H4>Member Methods</H4>
<P>
In addition to member variables, most classes will also have member
methods. Because member methods, like member variables, are fields,
access to them can be controlled with the <TT>public</TT>, <TT>protected</TT>,
and <TT>private</TT> modifiers. A member method is declared according
to the following syntax, in which elements enclosed in square
brackets &quot;[...]&quot; are optional:
<BLOCKQUOTE>
<PRE>
[methodModifiers] resultType methodName [throws exceptionList] {
    // method body
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>methodModifiers</TT> are the familiar <TT>public</TT>,
<TT>protected</TT>, and <TT>private</TT> keywords you've already
seen as well as some additional modifiers. The method modifiers
are described in Table A.14.<BR>
<P>
<CENTER><B>Table A.14. Method modifiers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=144><I>Modifier</I></TD><TD WIDTH=432><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>public</TT></TD><TD WIDTH=432>Accessible outside the class in which it is declared
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>protected</TT></TD><TD WIDTH=432>Accessible by the class in which it is declared and by subclasses of that class
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>private</TT></TD><TD WIDTH=432>Accessible only by the class in which it is declared
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>static</TT></TD><TD WIDTH=432>A method of the class rather than of a particular instance of the class
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>final</TT></TD><TD WIDTH=432>Cannot be overriden in subclasses
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>native</TT></TD><TD WIDTH=432>A platform-dependent implementation of the method in another language, typically C or assembly
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>Synchronized</TT></TD><TD WIDTH=432>Used to indicate a critical method that will lock the object to prevent execution of other methods while the synchronized method executes
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>resultType</TT> of a method declaration can be one of
the primitive types (for example, <TT>int</TT>, <TT>float</TT>,
<TT>char</TT>), another class, or <TT>void</TT>. A <TT>resultType</TT>
of <TT>void</TT> indicates that no result is passed back to the
caller of the method. After the method name is given, a list of
exceptions throwable by the method is given. If no exceptions
are thrown by the method, this list is not necessary. Exception
handling is discussed in full later in this appendix.
<P>
As an example of adding a method to the <TT>Car</TT> class, consider
the following sample code:
<BLOCKQUOTE>
<PRE>
class Car {
    public String manufacturer;
    public String model;
    public int year;
    public int passengers;
    public float CalculateSalePrice() {
        return cost * 1.5;
    }
    private float cost;
}
</PRE>
</BLOCKQUOTE>
<P>
In this case, the <TT>Car</TT> class has had a public member method,
<TT>CalculateSalePrice</TT>, added. The method returns a <TT>float</TT>,
and the body of the method calculates this return value. To calculate
the sale price of a car, the private member variable <TT>cost</TT>
is multiplied by 1.5, reflecting a markup of 50 percent over the
amount for which the car was purchased.
<H4>Overloaded Methods</H4>
<P>
The capability to overload methods is one of the biggest advantages
to working in an object-oriented language, and Java certainly
doesn't disappoint. Overloading a method means to use the same
method name for more than one method. For example, the <TT>Car</TT>
class can include two <TT>CalculateSalePrice</TT> methods, as
follows:
<BLOCKQUOTE>
<PRE>
public float CalculateSalePrice() {
    return cost * 1.5;
}

public float CalculateSalePrice(double margin) {
    return cost * (1 + margin);
}
private float cost;
</PRE>
</BLOCKQUOTE>
<P>
In this case, the first version of <TT>CalculateSalePrice</TT>
is not passed any parameters and bases the sale price on the cost
plus 50 percent (<TT>cost * 1.5</TT>). The second version is passed
a margin by which the car should be marked up in determining the
car's sale price.
<P>
At runtime, Java is able to distinguish between these methods
by the parameters passed to each. Because of this you can overload
a method as many times as you want as long as the parameter lists
of each version are unique. In other words, you could not do the
following:
<BLOCKQUOTE>
<PRE>
public float CalculateSalePrice() {
    return cost * 1.5;
}

public float CalculateSalePrice(double margin) {
    return cost * (1 + margin);
}

// this method declaration conflicts with the preceding method
public float CalculateSalePrice(double multiplier) {
    return cost * margin;
}
private float cost;
</PRE>
</BLOCKQUOTE>
<P>
In this situation, the last two declarations are in conflict because
each is passed a <TT>double</TT>. Different parameter names are
insufficient to distinguish between two versions of the same overloaded
function. They must differ by at least one parameter type.
<H4>Constructors</H4>
<P>
A special type of member method is known as a <I>constructor</I>.
A constructor is used to create new instances of a class. You
can identify a constructor because it will have the same name
as the class. Like any other method, a constructor can be overloaded
as long as the versions are distinguishable by the parameter types
passed to each. Typically, a constructor will set the member variables
of an object to values appropriate for that instance. As an example,
consider the following variation on the <TT>Car</TT> class:
<BLOCKQUOTE>
<PRE>
public class Car {
    String manufacturer;
    String model;
    int year;
    int passengers;
    float cost;

    // calculate the sale price of a car based on its cost
    public double CalculateSalePrice() {
        return cost * 1.5;
    }

    // a public constructor
    public Car(String madeBy, String name, int yr, int pass,
            float cst) {
        manufacturer = madeBy;
        model = name;
        year = yr;
        passengers = pass;
        cost = cst;
    }

    // create and return a string with the basic details about
    // this particular car
    public String GetStats() {
        return new String(year + &quot; &quot; + manufacturer + &quot; &quot; + model);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
A constructor, <TT>Car</TT>, has been added to this version of
the <TT>Car</TT> class. The constructor is passed five parameters
that will be used as initial values for the instance variables
<TT>manufacturer</TT>, <TT>model</TT>, <TT>year</TT>, <TT>passengers</TT>,
and <TT>cost</TT>. The code for the constructor simply sets the
five instance variables. The <TT>Car</TT> class has also received
a new public member, <TT>GetStats</TT>, that creates a string
that contains the basic facts about the car. By using the constructor
and the new <TT>GetStats</TT> method, you can now display some
information about a car. For example, the following code will
display <TT>&quot;1967 VW Bug&quot;</TT>:
<BLOCKQUOTE>
<PRE>
Car myCar = new Car(&quot;VW&quot;, &quot;Bug&quot;, 1967, 4, 3000);
String str = myCar.GetStats();
System.out.println(str);
</PRE>
</BLOCKQUOTE>
<P>
The new instance of the class <TT>Car</TT> was created with the
following line:
<BLOCKQUOTE>
<PRE>
Car myCar = new Car(&quot;VW&quot;, &quot;Bug&quot;, 1967, 4, 3000);
</PRE>
</BLOCKQUOTE>
<P>
The use of the Java keyword <TT>new</TT> instructs Java to create
a new object of type <TT>Car</TT> by allocating memory for it
and to invoke the constructor for <TT>Car</TT> whose signature
matches the parameter list. In this case, <TT>Car</TT> has only
one constructor, so it is invoked and will set the instance variables
to the values of the parameters. Once the variable <TT>myCar</TT>
goes out of scope at the end of the function in which it is declared,
the automatic memory management features of Java will detect that
the memory that was allocated by <TT>new</TT> is no longer referenced,
and it will be released.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If a class does not specifically include a constructor, Java will provide a default constructor that takes no parameters. This constructor will enable you to create new instances of a class and will set all member variables to their Java system default 
values. However, it is a dangerous and unwise practice to rely on the existence of a Java default constructor. In general, you should always provide at least one constructor for each class you define.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>The this Variable</H4>
<P>
All Java classes contain a hidden member variable named <TT>this</TT>.
The <TT>this</TT> member can be used at runtime to reference the
object itself. One excellent use of <TT>this</TT> is in constructors.
It is very common to have a set of instance variables in a class
that must be set to values that are passed to a constructor. When
you are doing this, it would be nice to have code that was similar
to the following:
<BLOCKQUOTE>
<PRE>
year = year;
</PRE>
</BLOCKQUOTE>
<P>
Ideally the variable on the left could be the instance variable,
and the variable on the right could be the parameter passed to
the constructor. Unfortunately, I don't know of any languages
that would be able to make this distinction. The typical solution
most programmers have settled on is similar to the following:
<BLOCKQUOTE>
<PRE>
public class Car {
    String manufacturer;
    String model;
    int year;
    int passengers;

    // a public constructor
    public Car(String madeBy, String name, int yr, int pass,
            float cst) {
        manufacturer = madeBy;
        model = name;
        year = yr;
        passengers = pass;
        cost = cst;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Here, we've had to come up with two names for each concept: The
best variable names (<TT>manufacturer</TT>, <TT>model</TT>, and
so on) are used as the instance variables in the class declaration.
The less satisfactory names are passed as parameters so as to
distinguish them from the instance variables. The assignment statements
are then very readable by Java but seem a little contrived to
human readers. Java's <TT>this</TT> keyword provides a very effective
solution to this problem in that the constructor can be written
as follows:
<BLOCKQUOTE>
<PRE>
public class Car {
    String manufacturer;
    String model;
    int year;
    int passengers;
    float cost;

    // calculate the sale price of a car based on its cost
    public double CalculateSalePrice() {
        return cost * 1.5;
    }

    // a public constructor
    public Car(String manufacturer, String model, int year,
            int passengers, float cost) {
        this.manufacturer = manufacturer;
        this.model = model;
        this.year = year;
        this.passengers = passengers;
        this.cost = cost;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
In this case, the variables like <TT>this.year</TT> refer to the
instance variables, whereas the unqualified variables like <TT>year</TT>
refer to the constructor's parameters.
<P>
Of course, this is only one example of how you can use <TT>this</TT>.
It is also frequently used as a parameter to other functions from
within member methods.
<H2><A NAME="ClassInheritance"><FONT SIZE=5 COLOR=#FF0000>
Class Inheritance</FONT></A></H2>
<P>
In Java, every class you declare will be derived from another
class. You can specify the class to derive from by using the <TT>extends</TT>
keyword as follows:
<BLOCKQUOTE>
<PRE>
public class ClassicCar extends Car {
    // member methods and variables
}
</PRE>
</BLOCKQUOTE>
<P>
As you probably noticed, <TT>extends</TT> was left out of all
the prior examples in this chapter. This is because if a class
is not declared as being derived from a specific class, it is
assumed to be derived from the Java base class, <TT>Object</TT>.
This means that the following two class declarations are equivalent:
<BLOCKQUOTE>
<PRE>
public class Car {
    // member methods and variables
}

public class Car extends Object {
    // member methods and variables
}
</PRE>
</BLOCKQUOTE>
<P>
Because <TT>Object</TT> is the class from which all other Java
classes are ultimately derived, this provides a common set of
functionality among all Java classes. Most notably, garbage collection
is possible because all classes will ultimately trace their lineage
back to <TT>Object</TT> as shown in Figure A.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-5.gif"><B> Figure 25.5 : </B><I>Everything is (eventually) derived from Object.
</I></A><P>
<P>
A derived class is commonly referred to as a <I>subclass</I>,
while the class it is derived from is commonly referred to as
a <I>superclass</I>. The term <I>immediate superclass</I> is used
to describe the class from which a subclass is directly derived.
In Figure A.5, for example, <TT>ClassicCar</TT> is a subclass
of both <TT>Car</TT> and <TT>Object</TT>. <TT>Car</TT> and <TT>Object</TT>
are both superclasses of <TT>ClassicCar</TT>, but only <TT>Car</TT>
is the immediate superclass of <TT>ClassicCar</TT>.
<H3><A NAME="OverridingMemberMethods">
Overriding Member Methods</A></H3>
<P>
When you create a subclass, you inherit all the functionality
of its superclass, and then you can add or change this functionality
as desired. As an example of this, consider the altered declaration
of the <TT>Car</TT> class in the following code:
<BLOCKQUOTE>
<PRE>
public class Car {
    private int year;
    private float originalPrice;

    // calculate the sale price of a car based on its cost
    public double CalculateSalePrice() {
        double salePrice;
        if (year &gt; 1994)
            salePrice = originalPrice * 0.75;
        else if (year &gt; 1990)
            salePrice = originalPrice * 0.50;
        else
            salePrice = originalPrice * 0.25;
        return salePrice;
    }

    // a public constructor
    public Car(int year, float originalPrice) {
        this.year = year;
        this.originalPrice = originalPrice;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This version of the <TT>Car</TT> class holds information about
the year and the original purchase price of the car. It has a
member method, <TT>CalculateSalePrice</TT>, that determines the
price for which to sell the car based on its age. Depending upon
the age of the car, it can sell for either 75, 50, or 25 percent
of its original price.
<P>
Although very simplistic, this is a good start for most cars.
However, it is completely inadequate for classic, old cars. This
algorithm would indicate that a 1920 Model T would be worth only
25 percent of its original 1920 price. A slight improvement on
this would be to assume that every <TT>ClassicCar</TT> is worth
$10,000. To do this, <TT>ClassicCar</TT> is derived from <TT>Car</TT>,
as follows:
<BLOCKQUOTE>
<PRE>
public class ClassicCar extends Car {
    // calculate the sale price of a car based on its cost
    public double CalculateSalePrice() {
        return 10000;
    }

    // a public constructor
    public ClassicCar(int year, float originalPrice) {
        super(year, originalPrice);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Because <TT>ClassicCar</TT> is derived from <TT>Car</TT>, it inherits
all the functionality of <TT>Car</TT>, including its member variables
<TT>year</TT> and <TT>originalPrice</TT>. The function <TT>CalculateSalePrice</TT>
appears in both class declarations. This means that the occurrence
of this function in <TT>ClassicCar</TT> overrides the occurrence
of it in <TT>Car</TT> for object instances of <TT>ClassicCar</TT>.
As an example of how this works, consider the following:
<BLOCKQUOTE>
<PRE>
ClassicCar myClassic = new ClassicCar(1920, 1400);
double classicPrice = myClassic.CalculateSalePrice();

Car myCar = new Car(1990, 12000);
double price = myCar.CalculateSalePrice();
</PRE>
</BLOCKQUOTE>
<P>
The variable <TT>myClassic</TT> is of type <TT>ClassicCar</TT>
and is constructed using that class's constructor, which is passed
an original price for the car of $1,400. The sale price of this
car is calculated and stored in <TT>classicPrice</TT>. Because
<TT>myClassic</TT> is a <TT>ClassicCar</TT>, the sale price will
be $10,000. Next, <TT>myCar</TT> is constructed as a new object
of type <TT>Car</TT> with an original cost of $12,000. Its sale
price is determined and stored in <TT>price</TT>. Because <TT>myCar</TT>
is a <TT>Car</TT>, its sale price will be based on the year it
was made (1990) and will be 25 percent of $12,000, or $3,000.
<H3><A NAME="ThesuperVariable">
The super Variable</A></H3>
<P>
In the preceding declaration for <TT>ClassicCar</TT>, you may
have noticed that the constructor made use of a variable named
<TT>super</TT>. Just as each object has a <TT>this</TT> variable
that references itself, each object (other than those of type
<TT>Object</TT> itself) has a <TT>super</TT> variable that represents
the parent class. In this case, <TT>super(year, originalPrice)</TT>
invokes the constructor of the superclass <TT>Car</TT>.
<H3><A NAME="ClassModifiers">
Class Modifiers</A></H3>
<P>
Classes that are created in Java can be modified by class modifiers.
The Java class modifiers are <TT>public</TT>, <TT>final</TT>,
and <TT>abstract</TT>. If no class modifier is used, then the
class may only be used within the package in which it is declared.
A <TT>public</TT> class is a class that can be accessed from other
packages. A class that is declared as <TT>final</TT> cannot be
derived from, meaning it cannot have subclasses.
<H4>abstract Classes</H4>
<P>
Sometimes you may want to declare a class and yet not know how
to define all the methods that belong to that class. For example,
you may want to declare a class called <TT>Mammal</TT> and include
in it a member method called <TT>MarkTerritory</TT>. However,
you don't know how to write <TT>MarkTerritory</TT> because it
is different for each type of <TT>Mammal</TT>. Of course, you
plan to handle this by deriving subclasses of <TT>Mammal</TT>,
such as <TT>Dog</TT> and <TT>Human</TT>. But what code do you
put in the <TT>MarkTerritory</TT> function of <TT>Mammal</TT>
itself?
<P>
In Java you can declare the <TT>MarkTerritory</TT> function of
<TT>Mammal</TT> as an <TT>abstract</TT> method. Doing so lets
you to declare the method without writing any code for it in that
class. However, you can write code for the method in the subclass.
If a method is declared <TT>abstract</TT>, then the class must
also be declared as <TT>abstract</TT>. For <TT>Mammal</TT> and
its subclasses, this means they would appear as follows:
<BLOCKQUOTE>
<PRE>
abstract class Mammal {
    abstract void MarkTerritory();
}

public class Human extends Mammal {
    public void MarkTerritory() {
        // mark territory by building a fence
    }
}

public class GangMember extends Mammal {
    public void MarkTerritory() {
        // mark territory with graffiti
    }
}

public class Dog extends Mammal {
    public void MarkTerritory() {
        // mark territory by doing what dogs do
    }
}
</PRE>
</BLOCKQUOTE>
<P>
In the preceding declarations, the <TT>Mammal</TT> class contains
no code for <TT>MarkTerritory</TT>. The <TT>Human</TT> class could
contain code that would mark territory by building a fence around
it, while the <TT>GangMember</TT> class could contain code that
would mark territory by spray-painting graffiti. The <TT>Dog</TT>
class would mark territory by raising the dog's leg and doing
what dogs do to mark territory.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A method that is private or static cannot also be declared abstract. Because a private method cannot be overridden in a subclass, a private abstract method would not be usable. Similarly, because all static methods are implicitly final, static methods 
cannot be overridden.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="ImplementingInterfaces">
Implementing Interfaces</A></H3>
<P>
Typically, an abstract class will have some methods that are declared
as <TT>abstract</TT> and some that are not. If you find yourself
declaring a class that is entirely abstract, you are probably
declaring what is known in Java as an <I>interface</I>. An interface
is an entirely abstract class. You can derive subclasses from
an interface in a manner completely analogous to deriving a subclass
from another class.
<P>
As an example, suppose you are building an application that must
display the hour of the day. Users will have two options for getting
this information. They can get it from either a watch or a cuckoo
clock. This could be implemented as follows:
<BLOCKQUOTE>
<PRE>
interface Clock {
    public String GetTime(int hour);
}

class Cuckoo implements Clock  {
    public String GetTime(int hour) {
        StringBuffer str = new StringBuffer();
        for (int i=0; i &lt; hour; i++)
            str.append(&quot;Cuckoo &quot;);
        return str.toString();
    }
}

class Watch implements Clock  {
    public String GetTime(int hour) {
        return new String(&quot;It is &quot; + hour + &quot;:00&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
In this example, <TT>Clock</TT> is an interface that provides
a single function, <TT>GetTime</TT>. What this means is that any
class that is derived from (or, in other words, <I>implements</I>
the <TT>Clock</TT> interface) must provide a <TT>GetTime</TT>
function. <TT>Cuckoo</TT> is an example of a class that implements
<TT>Clock</TT>, and you'll notice that instead of the <TT>class
Cuckoo extends Clock</TT> syntax that would have been used if
<TT>Clock</TT> were an abstract class, it is instead declared
with class <TT>Cuckoo implements Clock</TT>.
<P>
Because <TT>Cuckoo</TT> implements the <TT>Clock</TT> interface,
it provides a <TT>GetTime</TT> function. In this case, a string
is created that will hold as many Cuckoos as specified by the
<TT>hour</TT> parameter. The class <TT>Watch</TT> also implements
<TT>Clock</TT> and provides a <TT>GetTime</TT> function. Its version
is a simple message stating the hour.
<P>
Interfaces and superclasses are not mutually exclusive. A new
class can be derived from a superclass and one or more interfaces.
This could be done as follows for a class that implements two
interfaces and has one superclass:
<BLOCKQUOTE>
<PRE>
class MySubClass extends MySuperClass implements FirstInterface,
        SecondInterface {
    // class implementation
}
</PRE>
</BLOCKQUOTE>
<P>
Because it is possible for one class to implement more than one
interface, interfaces are a very convenient method for implementing
a form of multiple inheritance.
<H2><A NAME="ExceptionHandling"><FONT SIZE=5 COLOR=#FF0000>
Exception Handling</FONT></A></H2>
<P>
When something goes wrong inside a Java method, the method can
<I>throw an exception</I>. Throwing an exception refers to generating
an instance of a class that represents an error or warning and
passing the object back to the calling code. Exception handling
can streamline the code you must write to handle errors or unlikely
conditions.
<H3><A NAME="TryingandCatching">
Trying and Catching</A></H3>
<P>
In Java, exception handling is performed through the use of <TT>try...catch</TT>
blocks. The code within a <TT>try</TT> block is executed, and
if an exception occurs, execution is transferred to a <TT>catch</TT>
block if one is provided that handles the type of exception that
occurred. As an example, consider the following code:
<BLOCKQUOTE>
<PRE>
public class MyClass extends Applet
{
    public void paint(Graphics g)
    {
        String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;, &quot;Array&quot;};

        try {
            for(int i=0;i&lt;5;i++)
                g.drawString(stringArray[i], 10, 30+10*i);
        }
        catch (ArrayIndexOutOfBoundsException e) {
            g.drawString(&quot;oops: array too small&quot;, 10, 10);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<P>
In this example, a <TT>try</TT> block surrounds a <TT>for</TT>
loop. The <TT>for</TT> loop will iterate one time too many through
a four-element array. This will generate the exception <TT>ArrayIndexOutOfBoundsException</TT>,
which is caught by a <TT>catch</TT> block.
<P>
Sometimes a block of code can generate more than one possible
exception. In these cases you can use multiple <TT>catch</TT>
blocks, one for each of the possible exceptions, as shown in the
following code:
<BLOCKQUOTE>
<PRE>
public class MyClass extends Applet
{

    public void paint(Graphics g)
    {
        String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;, &quot;Array&quot;};

        try {
            for(int i=0;i&lt;4;i++)
                g.drawString(stringArray[i], 10, 30+10*i);

            char ch = stringArray[0].charAt(43);
        }
        catch (ArrayIndexOutOfBoundsException e) {
            g.drawString(&quot;oops: array too small&quot;, 10, 10);
        }
        catch (StringIndexOutOfBoundsException e) {
            g.drawString(&quot;oops: string index error&quot;, 10, 10);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<P>
In this case, the program loops through the four items in the
array and then uses <TT>charAt</TT> to get the character at position
43 in a one character string. This generates the <TT>StringIndexOutOfBoundsException</TT>
that is handled by the second <TT>catch</TT> block.
<H3><A NAME="UsingafinallyBlock">
Using a finally Block</A></H3>
<P>
In addition to <TT>try</TT> and <TT>catch</TT> blocks, Java also
enables you to specify a <TT>finally</TT> block that will execute,
regardless of any exceptions that may have occurred. As an example
of a <TT>finally</TT> block, consider the following class:
<BLOCKQUOTE>
<PRE>
public class MyClass extends Applet
{

    public void paint(Graphics g)
    {
        String [] stringArray = {&quot;A&quot;, &quot;Four&quot;, &quot;Element&quot;, &quot;Array&quot;};

        try {
            for(int i=0;i&lt;5;i++)
                g.drawString(stringArray[i], 10, 30+10*i);
        }
        catch (ArrayIndexOutOfBoundsException e) {
            g.drawString(&quot;oops: array too small&quot;, 10, 10);
        }
        finally {
            g.drawString(&quot;in the finally&quot;, 10, 100);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<P>
Here, an exception will be thrown when the loop attempts to access
the fifth item in the four-item array. The exception is caught
and handled by displaying a message on the screen; then the <TT>finally</TT>
block is executed, and another message is displayed. Executing
this class will display the messages shown in Figure A.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f25-6.gif"><B> Figure 25.6 : </B><I>Catching thrown exceptions and executing a finally block.
</I></A><P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter covered a great deal of information. You were introduced
to Java's primitive types and the operators that are available
for these types. Next, you learned how to control the flow of
a Java program through its selection statements (<TT>if</TT>,
<TT>switch</TT>, and <TT>case</TT>), its iteration statements
(<TT>for</TT>, <TT>while</TT>, and <TT>do...while</TT>), and jumping
(<TT>break</TT> and <TT>continue</TT>). You learned how to put
all of this together and create new classes by deriving them from
existing classes or interfaces. Finally, you learned how to effectively
handle errors with exception handling.
<HR>

<CENTER><P><A HREF="ch24.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch26.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
