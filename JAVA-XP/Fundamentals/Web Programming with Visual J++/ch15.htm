<HTML>
<HEAD>
<TITLE>Chapter 15 -- Multimedia Programming with Java</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;15</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Multimedia Programming with Java</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#Animation">
Animation</A>
<UL>
<LI><A HREF="#UsingtheMediaTrackerClasstoLoadMultipleImages">
Using the MediaTracker Class to Load Multiple Images</A>
<LI><A HREF="#BasicAnimation">
Basic Animation</A>
<LI><A HREF="#ImageManipulation">
Image Manipulation</A>
</UL>
<LI><A HREF="#Sounds">
Sounds</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Multimedia is a powerful technique that can be used to really
intrigue your users into spending hours in front of their computers.
With intense graphics and sounds, your users can be captivated.
<P>
The preceding chapter covered how to use the <TT>Graphics</TT>
class to draw various shapes and images in programs. This chapter
goes farther and discusses how to start to animate the graphics
and images and how to add sound to your programs.
<H2><A NAME="Animation"><FONT SIZE=5 COLOR=#FF0000>
Animation</FONT></A></H2>
<P>
Animation is the process by which images are displayed over time,
giving the appearance of movement. This task can be accomplished
in several ways. This section covers using the <TT>MediaTracker</TT>
class to load multiple images into a program, some techniques
to polish animations, and an alternative method of animation using
a single image.
<H3><A NAME="UsingtheMediaTrackerClasstoLoadMultipleImages">
Using the MediaTracker Class to Load Multiple Images</A></H3>
<P>
The <TT>MediaTracker</TT> class can be used to load various media.
This sounds good, but, unfortunately, like most things in life,
it sounds better than it is. Currently, the only media it tracks
is images. It does a really good job, though.
<P>
Why would a <TT>MediaTracker</TT> instance be used? If you did
not use <TT>MediaTracker</TT>, every program written would have
to implement an ImageObserver. <TT>MediaTracker</TT> uses an internal
ImageObserver to monitor the loading of images.
<H4>The MediaTracker Class</H4>
<P>
The <TT>MediaTracker</TT> constructor takes a single argument:
<BLOCKQUOTE>
<PRE>
public MediaTracker(Component comp)
</PRE>
</BLOCKQUOTE>
<P>
The <TT>Component</TT> parameter is the component for which the
images are being loaded. Since <TT>Applet</TT> is derived from
<TT>Component</TT>, <TT>this</TT> is typically passed to a <TT>MediaTracker</TT>
instance inside of an <TT>Applet</TT> derived class.
<P>
After an instance has been allocated, images can be added. To
add an image, one of the following methods is used:
<BLOCKQUOTE>
<PRE>
public void addImage(Image, int)
public void addImage(Image, int, int, int)
</PRE>
</BLOCKQUOTE>
<P>
Both <TT>addImage</TT> methods take an image and an identifier.
The image is created via <TT>Applet.getImage</TT>. The following
code illustrates the use of this method, which is a code fragment
from the preceding chapter:
<BLOCKQUOTE>
<PRE>
myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The identifier passed as the second argument is used to identify
and track either a single image or a group of images. The value
of the identifier indicates the priority given to the loading
of the images. Images with a lower value have a higher priority
when loading. If several images are given the same identifier,
all references to that identifier apply to all the images with
that identifier. Therefore, when the status of the images is referred
to, that is, by using <TT>statusID</TT>, the value returned should
be applied to all images with that identifier.
<P>
After an image, or group of images, has been added, the status
of the loading of the image can be monitored with the following
methods:
<BLOCKQUOTE>
<PRE>
public int statusID(int, boolean)
public int statusAll(boolean)
</PRE>
</BLOCKQUOTE>
<P>
These methods both return a value that is the combination of the
following flags found in the <TT>MediaTracker</TT> class:
<BLOCKQUOTE>
<TT>ABORTED<BR>
COMPLETE<BR>
ERRORED<BR>
LOADING</TT>
</BLOCKQUOTE>
<P>
<TT>statusID</TT> is used to return the status associated with
a single identifier. Alternatively, <TT>statusAll</TT> is used
to return the overall status of all the images being monitored.
After adding an image, the <TT>MediaTracker</TT> class does nothing
to initiate the actual loading of the images. Both of these methods,
along with several other methods of the class, take an additional
Boolean parameter. This parameter indicates that the images should
be loaded, if they haven't been already.
<P>
Table 15.1 shows additional methods of the <TT>MediaTracker</TT>
class that can be used to monitor the loading progress.<BR>
<P>
<CENTER><B>Table 15.1. MediaTracker class methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Member</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkAll()</TT></TD><TD WIDTH=384>Returns <TT>TRUE</TT> if all images associated with the <TT>MediaTracker</TT> instance have been loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkAll(boolean)</TT></TD><TD WIDTH=384>Returns <TT>TRUE</TT> if all images associated with the <TT>MediaTracker</TT> instance have been loaded. Optionally initiates the loading of the images.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkID(int)</TT></TD><TD WIDTH=384>Returns <TT>TRUE</TT> if all images associated with the identifier have been loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkID(int, boolean)</TT> </TD><TD WIDTH=384>Returns <TT>TRUE</TT> if all images associated with the identifier have been loaded. Optionally initiates the loading of the images.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getErrorsAny()</TT></TD><TD WIDTH=384>Returns an array of objects associated with the <TT>MediaTracker</TT> instance that have encountered an error.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getErrorsID()</TT></TD><TD WIDTH=384>Returns an array of objects associated with the identifier that have encountered an error.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isErrorAny()</TT></TD><TD WIDTH=384>Returns <TT>TRUE</TT> if there are any objects associated with the <TT>MediaTracker</TT> instance that encountered an error.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isErrorID(int)</TT></TD><TD WIDTH=384>Returns <TT>TRUE</TT> if there are any objects associated with the identifier that encountered an error.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>statusID(int, boolean)</TT></TD><TD WIDTH=384>Returns a combined status of all of the objects associated with the identifier. Optionally initiates the loading of the images.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>statusAll(boolean)</TT></TD><TD WIDTH=384>Returns a status of the load process for all objects associated with the identifier.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>waitForAll()</TT></TD><TD WIDTH=384>Blocking method that waits for all images associated with the <TT>MediaTracker</TT> instance to be loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>waitForAll(long)</TT></TD><TD WIDTH=384>Blocking method that waits for all images associated with the <TT>MediaTracker</TT> instance to be loaded. Times out after the specified number of milliseconds.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>waitForID(int)</TT></TD><TD WIDTH=384>Blocking method that waits for all images associated with the identifier to be loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>waitForID(int, long)</TT></TD><TD WIDTH=384>Blocking method that waits for all images associated with the identifier to be loaded. Times out after the specified number of milliseconds.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>A MediaTracker Example</H4>
<P>
As an example of using the <TT>MediaTracker</TT> class, consider
displaying several images. Listing 15.1 contains the <TT>Applet</TT>
code used for example <TT>EX15A</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 15.1. The Applet class used for example EX15A.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
public class EX15A extends Applet implements Runnable
{
 protected ImageCanvas Images[];
 protected MediaTracker ImageTracker;
 protected Thread ImageThread;
 public void init()
 {
 // If you use a ResourceWizard-generated &quot;control creator&quot; class to
 // arrange controls in your applet, you may want to call its
 // CreateControls() method from within this method. Remove the following
 // call to resize() before adding the call to CreateControls();
 // CreateControls() does its own resizing.
 //----------------------------------------------------------------------
 resize(500, 300);
 // create a tracker to monitor image loading
 ImageTracker = new MediaTracker(this);
 // create a place to put the image controls
 Images = new ImageCanvas[3];
 // add the images to be tracked
 for (int index = 0; index &lt; 3; index++) {
 Images[index] = new ImageCanvas(ImageTracker,
 getImage(getCodeBase(),
 &quot;images\\Christopher&quot; +
 Integer.toString(index + 1) + &quot;.jpg&quot;));
 add(Images[index]);
 }
 }
 public void start()
 {
 if (ImageThread == null) {
 ImageThread = new Thread(this);
 ImageThread.start();
 }
 }
 public void stop()
 {
 if (ImageThread != null) {
 ImageThread.stop();
 ImageThread = null;
 }
 }

 public void run()
 {
 // wait for all of the images to be loaded
 for (int index = 0; index &lt; 3; index++)
 Images[index].WaitForImage();
 }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first step performed in the <TT>init</TT> method is to create
the <TT>MediaTracker</TT> instance. Because <TT>Applet</TT> is
derived from <TT>Component</TT>, <TT>this</TT> is passed to the
constructor. The next task performed is to add the controls that
will be used to display the images. A new class, <TT>ImageCanvas</TT>,
is defined in this file, which is used to do the actual displaying
of the image. The following code fragment does several things
to instantiate an <TT>ImageCanvas</TT> for each image to be displayed:
<BLOCKQUOTE>
<PRE>
Images[index] = new ImageCanvas(ImageTracker,
 getImage(getCodeBase(),
 &quot;images\\Christopher&quot; +
 Integer.toString(index + 1) + &quot;.jpg&quot;));
</PRE>
</BLOCKQUOTE>
<P>
This code uses <TT>getImage</TT> to retrieve the image. The image's
location can be found by using the code's URL and the string created,
with the knowledge that the image is in an image subdirectory
and is a JPEG file named <TT>christopherx.jpg</TT>, in which <TT>x</TT>
indicates the image number. The image is then passed to the <TT>ImageCanvas</TT>
constructor, along with the <TT>MediaTracker</TT> used to monitor
the loading of the image.
<P>
The remaining code in the <TT>Applet</TT> class is concerned primarily
with instantiating a thread that will be used with the <TT>MediaTracker</TT>
instance to monitor the loading of the images. For more information
on using threads, see <A HREF="ch12.htm" >Chapter 12</A>, &quot;Moving Up to Multithreading.&quot;
Because monitoring the loading of images usually involves sleeping,
this should always be in a user-allocated thread. This allows
threads that are allocating and controlling the <TT>Applet</TT>
classes to continue to do their jobs.
<P>
<TT>ImageCanvas</TT> was added to this example to show that you
do not always have to handle displaying information in the <TT>Applet.paint</TT>
method. Listing 15.2 shows the code for the <TT>ImageCanvas</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 15.2. The ImageCanvas class of example EX15A.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class ImageCanvas extends Canvas
{
 // NextImageId is used to give each image a unique id
 protected static int NextImageId = 1;
 protected MediaTracker ImageTracker;
 protected Image TheImage;
 protected int LocalImageId;
 protected boolean ImageIsLoaded = false;
 protected boolean LoadError = false;
 ImageCanvas(MediaTracker ImageTracker, Image TheImage)
 {
 // use the next available image id and increment the next id
 LocalImageId = NextImageId;
 NextImageId++;
 // save the passed in info
 this.ImageTracker = ImageTracker;
 this.TheImage = TheImage;
 // resize the canvas to a known size
 resize(200, 140);
 // add the image to the media tracker
 ImageTracker.addImage(TheImage, LocalImageId,
 size().width, size().height);
 }
 public void paint(Graphics g)
 {
 if (ImageIsLoaded) {
 if (LoadError)
 g.drawString(&quot;Error loading image.&quot;, 10, 10);
 else
 g.drawImage(TheImage, 0, 0, this);
 }
 else {
 g.drawString(&quot;Loading&quot;, 10, 10);
 }
 }
 public void WaitForImage()
 {
 try {
 ImageTracker.waitForID(LocalImageId);
 }
 catch (InterruptedException e) {}
 // set state flags
 ImageIsLoaded = true;
 LoadError = ImageTracker.isErrorID(LocalImageId);
 // force the component to be updated
 repaint();
 }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This class has several protected members used to hold information
about the image it is displaying (<TT>ImageTracker</TT>, <TT>TheImage</TT>,
<TT>LocalImageId</TT>, <TT>ImageIsLoaded</TT>, and <TT>LoadError</TT>).
<P>
The first step in the class constructor is to assign a unique
ID for the current image, using the value of the static <TT>NextImageId</TT>
and then incrementing the value for the next instance. Additionally,
information is saved in the class, and the component is resized
to a reasonable size. Finally, the image is added to the <TT>MediaTracker</TT>
with the local identifier and the size of the <TT>Canvas</TT>
on which the image will be displayed.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The implementation of example <TT>EX15A</TT> uses unique identifiers for each image being monitored. This was just to show the use of unique identifiers; the example could easily be modified to use a single identifier for all instances of the 
<TT>ImageCanvas</TT> class
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>paint</TT> method is straightforward, displaying a string
if the image is being loaded or if there was an error loading
the image, or displaying the image itself if it was successfully
loaded.
<P>
Use <TT>WaitForImage</TT> if you want to wait until the image
is loaded and ready to be displayed. <TT>MediaTracker.WaitForID</TT>
is used to have the <TT>MediaTracker</TT> instance wait until
the image is loaded. After the image is loaded, the state members
are set to tell <TT>paint</TT> the appropriate action to take.
Finally, <TT>repaint</TT> is called for the component to update
the look of the component.
<P>
The result of running example <TT>EX15A</TT> is shown in Figure
15.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f15-1.gif"><B> Figure 15.1 : </B><I>Example EX15A.
</I></A><P>
<P>
Note that the third image was intentionally named incorrectly
on the disc to show the error condition being displayed.
<H3><A NAME="BasicAnimation">
Basic Animation</A></H3>
<P>
In the preceding section, it was shown how <TT>MediaTracker</TT>
could be used to monitor the loading of multiple images. This
mechanism can be used in creating animation. Animation can be
performed by displaying an image, pausing, and then displaying
the next image. If the images are closely related, movement can
be successfully simulated.
<P>
A banner is the displaying of a message such that the image scrolls
by a &quot;window.&quot; It appears to be a continuous image.
A banner is a good way to explore animation, because the implementation
is easy to follow, and the same basic techniques can be applied
to more complicated animation.
<H4>Creating a Banner</H4>
<P>
One type of animation is exemplified by the use of a banner. A
banner gives the impression that a wide image is being shown to
the user in a scrolling fashion. Because the banner repeats, it
gives the impression that the image makes a big loop and one end
is tied to the other. Figure 15.2 shows example <TT>EX15B</TT>
displaying a banner.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f15-2.gif"><B> Figure 15.2 : </B><I>A banner being displayed with example EX15B.
</I></A><P>
<P>
The implementation of animation is straightforward. The process
is to display an image, pause for a short amount of time (typical
computer animation is 10 to 20 frames per second), and then display
another image that is only slightly different from the preceding
image. The quality of animation is determined by the quality of
the images being displayed and the amount of delay between each
image. That is, the smaller the differential between images, the
faster they need to be displayed. Of course, you pay a price for
having a large number of images. Download time must be considered,
because all the images need to be downloaded, which can be quite
costly when you are accessing a slow server or using a slower
machine. A happy medium must be achieved for successful animation.
<P>
Twenty images are loaded with example <TT>EX15B</TT>. Six of those
images are displayed at a time. The <TT>init</TT> method is very
similar to the preceding example. Because the sole purpose of
the applet is to display the banner, however, the images are loaded
and monitored directly in the <TT>Applet</TT> derived class. Similarly,
the monitoring of the loading of the images is done in a user-declared
thread. The <TT>start</TT> and <TT>stop</TT> methods are used
to allocate and stop the thread appropriately.
<P>
The heart of the applet is in the <TT>paint</TT> and <TT>run</TT>
methods. Listing 15.3 shows the <TT>paint</TT> method.
<HR>
<BLOCKQUOTE>
<B>Listing 15.3. The paint method of example EX15B.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
// if all the images haven't been loaded, don't do anything
if (LoadedCount &gt;= ImageCount) {
int currentId = CurrentImageId;
for (int index = 0; index &lt; 6; index++) {
// assume images have a width of 50
g.drawImage(Images[currentId - ImageIdBase],
index * 50, 0, this);
currentId = GetNextId(currentId);
}
}
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first thing to notice is that the animation is not even started
unless all images have been loaded. Because the amount of time
required to download the images is potentially so much greater
than the amount of time required to cycle through the animation,
it is always a good idea to not start the animation until all
the images have been loaded.
<P>
If the images have been loaded, <TT>paint</TT> simply draws six
images using the <TT>Graphics</TT> instance, <TT>g</TT>. Using
the assumption that all the images are the same width, the location
for each image is calculated, based on the index of the image
being drawn and its width. Because the banner will continue indefinitely,
<TT>GetNextId</TT> is used to get the ID of the next image to
display.
<P>
<TT>GetNextId</TT> is a simple, protected function used to cycle
through the IDs of the images used for the banner:
<BLOCKQUOTE>
<PRE>
protected int GetNextId(int currentId)
{
int nextId = currentId + 1;
if (nextId &gt;= ImageCount + ImageIdBase)
nextId = ImageIdBase;
return nextId;
}
</PRE>
</BLOCKQUOTE>
<P>
Listing 15.4 shows the next major player in this animation game.
<HR>
<BLOCKQUOTE>
<B>Listing 15.4. The run method of example EX15B.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void run()
{
int id = ImageIdBase;
while (id &lt;= ImageIdBase + ImageCount - 1) {
if ((ImageTracker.statusID(id, true) &amp; MediaTracker.COMPLETE)
== MediaTracker.COMPLETE) {
IncrementImageCount();
id++;
}
else {
try {
Thread.sleep(250);
} catch (InterruptedException e) {}
}
}
ProgressMessage.hide(); // don't show progress any more
while (true) {
repaint();
try {
Thread.sleep(750);
} catch (InterruptedException e) {}
CurrentImageId = GetNextId(CurrentImageId);
}
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The thread used to monitor the loading of the images was passed
<TT>this</TT> as the parameter to the constructor. Therefore,
the <TT>run</TT> method of the applet is called when the thread
is started. The first step in the thread is to cycle through the
IDs of the images being loaded, checking for a completion status.
If the image has completed the loading process, <TT>IncrementImageCount</TT>
is called to increment <TT>LoadedCount</TT> and update the message
being displayed. Listing 15.5 shows the implementation of the
<TT>IncrementImageCount</TT> method. If the loading of the image
has not completed, the thread sleeps for a quarter of a second.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Remember that the identifier associated with the images of a <TT>MediaTracker</TT> instance also indicates the priority of the image to be loaded. Therefore, your application can successfully track the loading of the images, as seen by the <TT>while</TT> 
loop in the <TT>run</TT> method of example <TT>EX15B</TT>, which is used to wait for all the images to be loaded
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
After all the images have been loaded, the label that is used
to show the progress is hidden so that the banner can be displayed.
The second <TT>while</TT> loop in this method is the typical endless
loop found in user-defined threads. The loop consists of a call
to the <TT>repaint</TT> method to paint the first, and subsequent,
blocks of the banner. Because that was so hard, a little snooze
is now in order. Finally, the current image ID is cyclically incremented
using <TT>GetNextId</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 15.5. The IncrementImageCount method of example EX15B.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
protected synchronized void IncrementImageCount()
{
LoadedCount++;
// inform the user what is happening
ProgressMessage.setText(&quot;Loaded &quot; +
Integer.toString(LoadedCount) + &quot; of the &quot; +
Integer.toString(ImageCount) + &quot; images...&quot;);
ProgressMessage.resize(ProgressMessage.preferredSize());
// tell the layout manager to do its job
validate();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
That covers the basics of animation. The techniques covered here
are all that are needed to start investigating simple to complex
animations. The following sections cover techniques that can be
used to improve the look and performance of animations in general.
<H4>Improving the Paint</H4>
<P>
Due to the frequency with which animations are drawn, one of the
biggest enemies of animations is flicker. A couple of things can
be done to reduce the amount of flicker that occurs in the drawing
of animations.
<P>
<TT>paint</TT> has to be a very generic method to handle the variety
of tasks it might have to do. It has to be able to handle everything
from drawing text to drawing like Gauguin. When <TT>repaint</TT>
is called to update the screen, you are not really calling a method
that calls <TT>paint</TT>, but telling the applet to paint the
screen when it has time. Additionally, the function that really
calls the <TT>paint</TT> method is <TT>update</TT>. The default
implementation for <TT>update</TT> is something like:
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
 g.setColor(getBackground());
 g.fillRect(0, 0, width, height);
 g.setColor(getForeground());
 paint(g);
}
</PRE>
</BLOCKQUOTE>
<P>
The first thing that happens is that the background color is selected
into the <TT>Graphics</TT> and the background is filled. Guess
where the main cause of the flicker is generated from. Because
animations typically redraw the entire area that is being animated,
a simple enhancement would be to override the <TT>update</TT>
function and simply call the <TT>paint</TT> method. Here's an
example:
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
 paint(g);
}
</PRE>
</BLOCKQUOTE>
<P>
Consider the previous banner example. Because the same area is
always rendered in the <TT>paint</TT> method, this simple <TT>update</TT>
goes a long way to reduce the flicker. This new <TT>update</TT>
method was added to example <TT>EX15B</TT> and is on the accompanying
CD as example <TT>EX15C</TT>.
<P>
The second method to improve the painting of animations is to
actually reduce the amount of what is being painted. This can
be easily accomplished by letting the <TT>update</TT> method do
a little more work and setting the clipping region in the <TT>Graphics</TT>
instance that is passed to <TT>paint</TT>.
<P>
Due to the fact that the simplified <TT>update</TT> was so effective
in the banner example, the clipping region does not have any effect
for that example. Instead, consider a classic example of animation:
the bouncing ball in front of a complicated background. Figure
15.3 shows a sketch of two sequential positions of the ball.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f15-3.gif"><B> Figure 15.3 : </B><I>A sketch of two sequential positions of a bouncing ball.
</I></A><P>
<P>
Assume that the circle labeled P1 in the figure was the original
location of the ball and the circle labeled P2 in the figure is
the current location of the ball. Realize that this is a very
exaggerated diagram of two sequential positions of the ball, to
illustrate what the clipping region is.
<P>
Up to this point, the approach would be to draw the entire background
and then add the ball at the new position. Depending on the size
of the graphics boundary, this might or might not be an acceptable
approach. A larger area, however, would take quite a while to
draw, and our friend flicker would be back. When the image is
being updated, a large portion of the image will not change from
one position to the next. What will change is mainly the area
between the two positions of the ball. Therefore, if we restrict
the painting to only the region defined by the perimeter of the
balls, also known as the clipping region, the painting task becomes
much simpler, based only on the amount of painting being done.
<P>
To determine the clipping region, the following function could
be used:
<BLOCKQUOTE>
<PRE>
Rectangle GetClippingRegion(int x1, int y1, int x2, int y2, int width, int height)
{
 int clipX, clipY, clipWidth, clipHeight;
 // determine the leftmost x coordinates and subsequently the
 // clipping region width
 clipX = min(x1, x2);
 clipWidth = abs(x2 - x1) + width;
 // determine the uppermost y coordinates and subsequently the
 // clipping region height
 clipY = min(y1, y2);
 clipHeight = abs(y2 - y1) + height;
 return new Rectangle(clipX, clipY, clipWidth, clipHeight);
}
</PRE>
</BLOCKQUOTE>
<P>
This function assumes that the point (x1, y1) defines the origin
of the rectangular region that completely encloses the ball at
position P1 and that (x2, y2) defines the origin of the rectangular
region that completely encloses the ball at position P2. Additionally,
because the ball is theoretically the same ball, it will be the
same size at P1 and P2.
<P>
The preceding clipping region could now be utilized in a new <TT>update</TT>
method:
<BLOCKQUOTE>
<PRE>
public void update(Graphics g) {
 Rectangle rect = GetClippingRegion(previousX, previousY,
 currentX, currentY, ballWidth, ballHeight);
 g.clipRec(rect.x, rect.y, rect.width, rect.height);
 paint(g);
 previousX = currentX;
 previousY = currentY;
}
</PRE>
</BLOCKQUOTE>
<P>
This method determines the region that needs to be updated, based
on the previous position and the current position, and then sets
the clipping rectangle of the <TT>Graphics</TT> that is passed
to the <TT>paint</TT> method. Finally, the current position is
saved as the previous position.
<P>
You might wonder how we now utilize that clipping region in the
<TT>paint</TT> function. Well, we don't have to worry about that.
Because the <TT>paint</TT> method makes calls to the <TT>Graphics</TT>
to do any type of output, the <TT>Graphics</TT> worries about
the clipping regions and simply ignores any updates to the regions
outside the clipping rectangle.
<P>
These methods will reduce the amount of flickering associated
with animation to a somewhat reasonable amount. Eliminating the
background redraw stops unnecessary updates while defining a clipping
region localized to what is being redrawn.
<H4>Double Buffering</H4>
<P>
Perhaps one of the best general enhancements that can be done
to animations and graphics renderings in general is to use a second
buffer to draw the image. After the image is complete, it is copied
to the main image in one fell swoop. This is commonly referred
to as <I>double buffering</I>.
<P>
If the preceding clipping region example just showed how advantageous
it is to reduce the area that is being rendered, how can double
buffering help us, if we just have to copy the entire image at
the end of the process? The answer is that the complicated images
often are composed of several operations (that is, drawing the
background images, drawing foreground images that were obscured
by a main image, and then drawing a new version of the main image).
By performing these drawing operations to an &quot;in memory&quot;
buffer instead of the program's screen, you prevent the user from
seeing the multiple operations. Additionally, when Java does perform
the copy, the virtual machine can typically take advantage of
block copy routines implemented in the native language that copies
larger portions of images.
<P>
Let's revisit the banner example and add double buffering to help
out the animation. The only difference between example <TT>EX15C</TT>
and example <TT>EX15D</TT> is the <TT>update</TT> method found
in Listing 15.6.
<HR>
<BLOCKQUOTE>
<B>Listing 15.6. The double-buffering update method of example
EX15D.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void update(Graphics g)
{
 // create an off-screen image if there isn't one
 if (OffScreenImage == null)
 OffScreenImage = createImage(size().width, size().height);
 // get a graphics that can be used with the off-screen image
 Graphics offScreenGraphics = OffScreenImage.getGraphics();
 // use the paint method to draw to the off-screen image
 paint(offScreenGraphics);
 // splat!! the new image over the current image
 g.drawImage(OffScreenImage, 0, 0, this);
 // release the resources associated with the off-screen image
 offScreenGraphics.dispose();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This method first allocates a new image, if one has not been allocated,
making it the size of the applet. Next, a <TT>Graphics</TT> instance
is retrieved from the image to be used to draw to the image. Now
comes the tricky part. Because you have likely developed the <TT>paint</TT>
method to perform any drawing that needs to be done, simply call
the <TT>paint</TT> method to draw to the off-screen image. When
the painting is completed, do a mass copy to the existing <TT>Graphics</TT>
and the image will be updated. Finally, release the graphics context,
because most operating systems have limited resources for drawing
among all of their processes.
<H3><A NAME="ImageManipulation">
Image Manipulation</A></H3>
<P>
As an alternative to displaying multiple images, you might want
to consider the manipulation of a single image. This cannot, however,
be applied to all animations. For example, consider the default
animated program generated by the Visual J++ Applet Wizard. For
more information on using the AppletWizard, see <A HREF="ch2.htm" >Chapter 2</A> &quot;Creating
Your First Applet with Applet Wizard.&quot;
<P>
The default example shows the Earth spinning on its normal North
Pole to South Pole axis. This could not be replicated using a
single image unless you could come up with a very odd perspective.
If, however, you want to totally change the entire ecosystem,
you could take a single view of the Earth and experiment with
rotating it on an axis that runs through the equator. In terms
of animation, this would mean taking a single image and spinning
the image.
<P>
Another example using a single image is the banner example. Figure
15.4 shows the entire banner used in the previous examples.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f15-4.gif"><B> Figure 15.4 : </B><I>The full banner contents.
</I></A><P>
<P>
This image is used to display the banner in the applet by taking
advantage of the clipping region and being able to specify a starting
location of the image being drawn that is outside the area of
the image. Listing 15.7 shows the relevant methods of example
<TT>EX15E</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 15.7. The scrolling-banner class EX15E methods using
a single image.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
// if the image hasn't been loaded, don't do anything
if (ImageLoaded) {
g.clipRect(0, 0, ImageDisplayWidth, ImageDisplayHeight);
// draw the first round of the image
g.drawImage(SingleImage, CurrentDisplayXValue, 0, this);
// calculate where the wrapping image starts
int wrapXLocation = CurrentDisplayXValue + ImageWidth;
// if the wrap image has started into the displayable
// range, draw the image again
if (wrapXLocation &lt; ImageDisplayWidth)
g.drawImage(SingleImage, wrapXLocation, 0, this);
}
}
public void run()
{
try {
ImageTracker.waitForID(ImageId);
}
catch (InterruptedException e) {}
ImageLoaded = true;
ProgressMessage.hide(); // don't show progress any more
while (true) {
repaint();
try {
Thread.sleep(ImageDelay);
} catch (InterruptedException e) {}
CurrentDisplayXValue = GetNextXValue(CurrentDisplayXValue);
}
}
protected int GetNextXValue(int currentXValue)
{
int nextXValue = currentXValue - ImageXDecrement;
if (nextXValue &lt; -ImageWidth)
nextXValue = -ImageXDecrement;
return nextXValue;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>paint</TT> method first clips the drawing region to the
area that is being displayed. The first image is drawn in the
graphics using <TT>CurrentDisplayXValue</TT>. This value is the
key to the scrollability of the image, and it ranges from 0 to
the negative width of the image (that is, -1000). Because the
clipping rectangle starts at (0, 0), nothing is displayed to the
left of the applet display area, as expected. The next operation
determines where the second drawing of the image needs to take
place to perform the wrapping function. This calculation is essentially
determining whether the end of the first image is within the display
area. If it is, the image is drawn for the second time within
the display area.
<P>
The <TT>run</TT> method is not atypical and should be pretty familiar.
<TT>GetNextXValue</TT> is used to determine the next starting
location for the first image. Notice that if the first image is
being drawn so that the entire image is outside the displayable
area, the image is reset to &quot;take over&quot; the scrolling
of the second image found in <TT>paint</TT>.
<P>
As you can see, this method is not applicable to every animation
situation. If it can be used, however, the savings in not having
to load multiple images will add up.
<H2><A NAME="Sounds"><FONT SIZE=5 COLOR=#FF0000>
Sounds</FONT></A></H2>
<P>
Sounds can easily be added to your program through the use of
the <TT>AudioClip</TT> class. The definition of <TT>AudioClip</TT>
is simple:
<BLOCKQUOTE>
<PRE>
public interface java.applet.AudioClip
{
 public abstract void loop();
 public abstract void play();
 public abstract void stop();
}
</PRE>
</BLOCKQUOTE>
<P>
As you can see from the code, <TT>AudioClip</TT> is an interface
and not a class. The reason for this is that an instance of this
class cannot be instantiated. Instead, the user must call a function
that will allocate a system-defined class that implements audio
suitable for the device being used by the user.
<P>
To obtain an <TT>AudioClip</TT>, the <TT>getAudioClip</TT> methods
of <TT>Applet</TT> can be called:
<BLOCKQUOTE>
<PRE>
public AudioClip getAudioClip(URL);
public AudioClip getAudioClip(URL, String);
</PRE>
</BLOCKQUOTE>
<P>
Both functions take URLs that indicate the location of the audio
clip. For the first function, the audio clip has to be completely
defined in the URL. The second function allows the additional
specification of where the audio clip is located, relative to
the URL.
<P>
Additionally, <TT>Applet</TT> provides &quot;shortcuts&quot; to
playing audio with the following methods:
<BLOCKQUOTE>
<PRE>
public void play(URL)
public void play(URL, String)
</PRE>
</BLOCKQUOTE>
<P>
The parameters to these methods are the same as those for <TT>getAudioClip</TT>,
mentioned previously.
<P>
The audio clips currently supported by Java are rather limited.
The only supported format is 8-bit, mlaw, 8000 Hz, mono channel,
Sun <TT>.au</TT> files. With a careful search on the Internet,
however, you can find conversion utilities to convert from various
types of audio files to .au files.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><BLOCKQUOTE>
<B>TIP</B>
</BLOCKQUOTE>
</TD>
</TR>
<TR VALIGN=TOP><TD><BLOCKQUOTE>
To add personalized audio to your programs when using Microsoft Windows, you can use the Sound Recorder and your multimedia hardware to record just about anything. This recording produces a standard Windows <TT>.wav</TT> file. From here, you can use a 
conversion utility to convert this file from a <TT>.wav</TT> file to an <TT>.au</TT> file. A good shareware utility I found on the Internet is GoldWave, which can be found a
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><A HREF="http://web.cs.mun.ca/-chris3/goldwave">http://web.cs.mun.ca/-chris3/goldwave</A></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
This utility not only allows you to convert the file types, but also supports various audio manipulations, including echoing, creating distortion, and adjusting the volume, to name a few.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Figure 15.5 shows the interface for example <TT>EX15F</TT>. This
interface allows the playing of three short audio clips and has
a background clip that continually loops after it has been loaded.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f15-5.gif"><B> Figure 15.5 : </B><I>Example EX15F.
</I></A><P>
<P>
The background audio clip is rather lengthy, so it is loaded in
a user-allocated thread. The <TT>run</TT> method of example <TT>EX15F</TT>
is shown in Listing 15.8.
<HR>
<BLOCKQUOTE>
<B>Listing 15.8. The run method of example EX15F.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void run()
{
HiHoo = getAudioClip(getCodeBase(), &quot;audio\\Heighho.au&quot;);
HiHoo.loop();
Work.setLabel(&quot;No Work&quot;);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>HiHoo</TT> is an <TT>AudioClip</TT> instance of the <TT>EX15F</TT>
class; it gets assigned using <TT>Applet.getAudioClip</TT>, using
the relative location of the method. Then, <TT>loop</TT> is used
to play the clip continuously.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If audio is being used to play longer selections, more than just warning beeps and whistles, the program should allow the user to disable the audio. Even the best sounds found by the programmer can be interpreted as annoying by others. Additionally, some 
user might be trapped with slow access connections and might not want to wait for the Internet traffic to download the audio</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Listing 15.9 shows how the <TT>action</TT> method of the <TT>EX15F</TT>
class does double duty in starting and stopping the background
clip, and it uses <TT>Applet.play</TT> to play the short clips.
<HR>
<BLOCKQUOTE>
<B>Listing 15.9. The action method of example EX15F.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
boolean retval = false;
// check to see if the audio should be turned off or on
if (&quot;Work&quot;.equals(obj)) {
HiHoo.loop(); // start the music
Work.setLabel(&quot;No Work&quot;);
retval = true;
}
else if (&quot;No Work&quot;.equals(obj)) {
HiHoo.stop(); // stop the music
Work.setLabel(&quot;Work&quot;);
retval = true;
}
// check to see if one of the simple sounds should be played
else if (&quot;Play&quot;.equals(obj)) {
Checkbox current = SimplerSounds.getCurrent();
play(getCodeBase(), &quot;audio\\&quot; + current.getLabel() + &quot;.au&quot;);
retval = true;
}
return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
In this chapter, you learned that going from graphics to animation
is a straightforward process. The <TT>MediaTracker</TT> class
makes it easy to load multiple images without having to add ImageObserver
overhead to every program. After images have been loaded, a thread
can handle showing an image, pausing, and then showing another
image to produce simple animation. A few techniques were introduced
to prevent animation flicker, including reducing background draws,
using clipping rectangles to reduce the overall amount of what
is being drawn, and finally using an in-memory image buffer to
implement image double buffering. As an alternative to using multiple
images, a single image could also be used that contains all the
images that contribute to the animation. Calculating drawing of
this single image can produce effective animations in certain
circumstances. Finally, Java's sound support was introduced, which
rounds out the multimedia topics.
<HR>

<CENTER><P><A HREF="ch14.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch16.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
