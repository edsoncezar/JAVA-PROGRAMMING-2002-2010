<HTML>
<HEAD>
<TITLE>Chapter 21 -- Using ActiveX Controls with Java</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;21</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Using ActiveX Controls with Java</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#CreatingtheJavaInterfaceClass">
Creating the Java Interface Class</A>
<UL>
<LI><A HREF="#RegisteringanActiveXTypeLibrary">
Registering an ActiveX Type Library</A>
<LI><A HREF="#CreatingtheJavaInterfaceClasses">
Creating the Java Interface Classes</A>
</UL>
<LI><A HREF="#UsingaCOMObject">
Using a COM Object</A>
<UL>
<LI><A HREF="#PassingCOMObjectReferences">
Passing COM Object References</A>
<LI><A HREF="#EventProcessing">
Event Processing</A>
<LI><A HREF="#NonvisualCOMObjects">
Nonvisual COM Objects</A>
</UL>
<LI><A HREF="#CreatingaCOMObjectwithJava">
Creating a COM Object with Java</A>
<UL>
<LI><A HREF="#GeneratingaUniversallyUniqueGlobalIdentificationUUID">
Generating a Universally Unique Global Identification (UUID)
</A>
<LI><A HREF="#DefininganObject">
Defining an Object</A>
<LI><A HREF="#CreatingaTypeLibrary">
Creating a Type Library</A>
<LI><A HREF="#RegisteringtheComponent">
Registering the Component</A>
<LI><A HREF="#CreatingtheJavaInterface">
Creating the Java Interface</A>
<LI><A HREF="#ImplementingtheJavaClass">
Implementing the Java Class</A>
<LI><A HREF="#UsingtheJavaComponent">
Using the Java Component</A>
</UL>
<LI><A HREF="#CreatingaSignedCABFile">
Creating a Signed CAB File</A>
<UL>
<LI><A HREF="#CABFiles">
CAB Files</A>
<LI><A HREF="#SigningaCABFile">
Signing a CAB File</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
What is ActiveX? The best definition is pretty vague at best:
an interface that is used to provide access to controls and code
from various sources. It is mainly targeted at providing access
to Internet applications. ActiveX was previously known as OLE.
Then again, it is also based on the COM and DCOM models. These
terms are often all used interchangeably.
<P>
There are several Visual J++ utilities that support creating the
interface used to call ActiveX controls and creating an ActiveX
control with Java. This chapter explores how ActiveX controls
can be integrated with Java.
<H2><A NAME="CreatingtheJavaInterfaceClass"><FONT SIZE=5 COLOR=#FF0000>
Creating the Java Interface Class</FONT></A></H2>
<P>
There are only a couple of steps required to create an interface
to a COM object: registering the component and creating the Java
interface class.
<H3><A NAME="RegisteringanActiveXTypeLibrary">
Registering an ActiveX Type Library</A></H3>
<P>
Registering a component involves putting some key information
into the Windows Registry. This information must be present in
the Registry to create a component.
<P>
Most installation programs automatically register a component
during the install process. If, however, you have an unregistered
component, you can use <TT>REGSVR32</TT>. This program must be
run from a command prompt and has the following options:
<BLOCKQUOTE>
<PRE>
regsvr32 [/u] [/s] dllname
</PRE>
</BLOCKQUOTE>
<P>
The <TT>/u</TT> option provides the capability to unregister a
DLL, and <TT>/s</TT> is used to run the program in silent mode.
<P>
To register components found in the file <TT>MYCONTROL.DLL</TT>,
for example, the following line would be entered at a command
prompt:
<BLOCKQUOTE>
<PRE>
regsvr32 mycontrol.dll
</PRE>
</BLOCKQUOTE>
<P>
Once a component is registered, a Java class can be generated
to interface with the component.
<H3><A NAME="CreatingtheJavaInterfaceClasses">
Creating the Java Interface Classes</A></H3>
<P>
To use a COM component, a Java class and interface for use with
the component must be generated. This can be accomplished by using
either the Java Type Library Wizard or the command-line equivalent.
<H4>Java Type Library Wizard</H4>
<P>
The Java Type Library Wizard is used to determine the interface
structure available to Java code that is used to interface to
COM components. To access the Java Type Library Wizard, use the
Tools | Java Type Library Wizard command. The dialog is displayed
in Figure 21.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-1.gif"><B> Figure 21.1 : </B><I>Java Type Library Wizard.
</I></A><P>
<P>
This dialog displays all of the type libraries that have been
registered. The dialog shows the name of the component. If a component
is highlighted, the name of the source file is displayed at the
bottom of the dialog. From the figure, you can see that the type
library with the name Microsoft DAO 3.0 Object Library is located
in the file <TT>C:\Program Files\Common Files\Microsoft</TT> <TT>Shared\DAO\Dao3032.DLL</TT>.
<P>
To create a class file and summary file for the COM object, click
in the box next to the object. Figure 21.2 shows the selection
of the Marquee object that is automatically installed with Internet
Explorer 3.0.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-2.gif"><B> Figure 21.2 : </B><I>Marquee object selection.
</I></A><P>
<P>
After the OK button is pressed and the wizard has completed its
tasks, you can see some very important information about the generated
class in the Java Type Library Wizard tab of the Output window,
as shown in Figure 21.3.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-3.gif"><B> Figure 21.3 : </B><I>Java Type Library Wizard tab of the Output window.
</I></A><P>
<P>
The first two lines contain the version of the wizard and let
you know where the conversion utility came from. Unless you are
a number cruncher, they will probably look fine. The next two
lines are the most important for the developer. The import line
is what needs to be added to the Java file where the COM object
is to be used:
<BLOCKQUOTE>
<PRE>
import marquee.*
</PRE>
</BLOCKQUOTE>
<P>
The next line shows the filename of a file that was produced to
show a summary of the objects created. Listing 21.1 shows the
summary file that was generated for the <TT>Marquee</TT> object.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
If you double-click the SUMMARY.TXT filename in the output window, Visual J++ will automatically display the contents of the summary file.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 21.1. Listing of SUMMARY.TXT for the Marquee object.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class marquee/Marquee extends java.lang.Object
{
}
public interface marquee/DMarqueeEvents extends com.ms.com.IUnknown
{
    public abstract void OnStartOfImage();
    public abstract void OnEndOfImage(int);
    public abstract void OnBounce(int);
    public abstract void OnLMouseClick();
    public abstract void OnScroll(int);
}
public interface marquee/IMarquee extends com.ms.com.IUnknown
{
    public abstract java.lang.String getScrollStyleY();
    public abstract void putScrollPixelsY(short);
    public abstract short getLoopsX();
    public abstract void putLoopsX(short);
    public abstract int getOffsetFromWndX();
    public abstract void putOffsetFromWndY(int);
    public abstract int getCurrentURL();
    public abstract void Resume();
    public abstract void putWidthOfPage(int);
    public abstract void Pause();
    public abstract java.lang.String getScrollStyleX();
    public abstract short getScrollPixelsY();
    public abstract void putScrollPixelsX(short);
    public abstract int getPageHeight();
    public abstract int getWidthOfPage();
    public abstract void putOffsetFromWndX(int);
    public abstract int getPageWidth();
    public abstract short getScrollPixelsX();
    public abstract int getWhiteSpace();
    public abstract void queryURLCount(int[]);
    public abstract void putScrollStyleY(java.lang.String);
    public abstract void putScrollDelay(short);
    public abstract void putDrawImmediately(short);
    public abstract short getPageFlippingOn();
    public abstract void insertURL(int, java.lang.String);
    public abstract void AboutBox();
    public abstract short getScrollDelay();
    public abstract void putCurrentURL(int);
    public abstract void deleteURL(int);
    public abstract void queryURL(int, java.lang.String[]);
    public abstract short getZoom();
    public abstract void putZoom(short);
    public abstract void putScrollStyleX(java.lang.String);
    public abstract void putBackgroundColor(int);
    public abstract short getDrawImmediately();
    public abstract void putPageFlippingOn(short);
    public abstract int getBackgroundColor();
    public abstract short getLoopsY();
    public abstract void putLoopsY(short);
    public abstract void putWhiteSpace(int);
    public abstract int getOffsetFromWndY();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This file contains what appears to be a Java class and two Java
interfaces. The <TT>marquee/</TT> prefixes to the class and interface
names are not quite correct Java syntax, but are added for clarity.
The class definition represents the COM object. Unfortunately,
there are not too many methods that can be called in this class.
However, the type wizard did provide two interface classes that
can be called to access the COM object. A restriction of COM is
that you cannot access the COM object directly for an instance
of the COM class. Instead, you must always use the interface class.
<P>
The content of the interface classes represents the methods available
in the COM object. Therefore, the documentation for the object
would need to be consulted for the functionality of each method.
For the <TT>Marquee</TT> example, visit the Microsoft Web page
at <TT>www.microsoft.com/activex/</TT> for more information. The
complete page is included on the accompanying CD for your convenience,
in example <TT>EX21A</TT>.
<P>
The Java Type Library Wizard generates the class information for
each type library in the same location. This location is determined
by the registry key <TT>HKEY_LOCAL_MACHINE\Software\Microsoft\Java
VM\TrustedLibsDirectory</TT>. Each library is stored in a subdirectory
off of this directory with the name of the type library.
<H4>JAVATLB</H4>
<P>
Another way to generate the class information for a COM object
is to use the command line equivalent of the Java Type Library
Wizard, JAVATLB. The command-line syntax is
<BLOCKQUOTE>
<PRE>
JAVATLB filename
</PRE>
</BLOCKQUOTE>
<P>
where <TT>filename</TT> is the name of the type library. Again,
the class information is stored off of the <TT>HKEY_LOCAL_MACHINE\Software\Microsoft\Java
VM\TrustedLibsDirectory</TT> directory with the class files, and
<TT>SUMMARY.TXT</TT> generated as if the Java Type Library Wizard
were used.
<P>
Once the interface for the object has been created, it can be
used by a Java applet.
<H2><A NAME="UsingaCOMObject"><FONT SIZE=5 COLOR=#FF0000>
Using a COM Object</FONT></A></H2>
<P>
Once an interface for a COM object has been generated, the object
becomes as simple to use as any other Java class. The one exception
is that when generating a COM interface, both a Java class and
a Java interface are created. A COM class instance must always
be allocated, but it must be accessed through the interface. This,
however, will not be hard to remember, since the methods for a
COM object are generated in the interface and the COM object class
is rather dull.
<P>
Java applets and COM objects can communicate through two avenues:
by passing a reference to a COM object directly to a Java applet
so that the applet can call object methods and by passing events
from a COM object to methods of a Java applet.
<H3><A NAME="PassingCOMObjectReferences">
Passing COM Object References</A></H3>
<P>
The method that gives the Java applet the most control of the
COM object is passing a reference to a COM object. This involves
using a scripting language on an HTML page to reference both the
COM object and the applet and then using the COM interface inside
the applet to control the object.
<H4>Scripting Access to the COM Object</H4>
<P>
One limitation when working with COM objects is that if a COM
object has a component that displays information, such as edit
boxes for collecting user input information or radio buttons that
allow the user to configure the use of an object, that COM object
can not be instantiated in a program. However, if there are no
interface components, an instance of a COM object can be instantiated
directly in a program, as will be seen later.
<P>
To be able to access a visual COM object, a reference must be
passed the program using a scripting language, such as VBScript
or JScript. Consider the HTML of example <TT>EX21A</TT>, as shown
in Listing 21.2.
<HR>
<BLOCKQUOTE>
<B>Listing 21.2. HTML source for example EX21A.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;EX21A&lt;/title&gt;
&lt;/head&gt;
&lt;script language=VBScript&gt;
&lt;!--
'Give the COM object to the applet
Sub window_onLoad
    document.EX21A.Load marquee
end sub
!--&gt;
&lt;/script&gt;
&lt;body&gt;
&lt;OBJECT
    align=CENTER
    classid=&quot;clsid:1a4da620-6217-11cf-be62-0080c72edd2d&quot;
    width=650 height=200 BORDER=1 HSPACE=5
    id=marquee
    &gt;
    &lt;PARAM NAME=&quot;ScrollStyleX&quot; VALUE=&quot;Circular&quot;&gt;
    &lt;PARAM NAME=&quot;ScrollStyleY&quot; VALUE=&quot;Circular&quot;&gt;
    &lt;PARAM NAME=&quot;szURL&quot; VALUE=&quot;marquee.html&quot;&gt;
    &lt;PARAM NAME=&quot;ScrollDelay&quot; VALUE=100&gt;
    &lt;PARAM NAME=&quot;LoopsX&quot; VALUE=-1&gt;
    &lt;PARAM NAME=&quot;LoopsY&quot; VALUE=-1&gt;
    &lt;PARAM NAME=&quot;ScrollPixelsX&quot; VALUE=0&gt;
    &lt;PARAM NAME=&quot;ScrollPixelsY&quot; VALUE=30&gt;
    &lt;PARAM NAME=&quot;DrawImmediately&quot; VALUE=1&gt;
    &lt;PARAM NAME=&quot;Whitespace&quot; VALUE=0&gt;
    &lt;PARAM NAME=&quot;PageFlippingOn&quot; VALUE=1&gt;
    &lt;PARAM NAME=&quot;Zoom&quot; VALUE=100&gt;
    &lt;PARAM NAME=&quot;WidthOfPage&quot; VALUE=640&gt;
&lt;/OBJECT&gt;
&lt;hr&gt;
&lt;applet
    code=EX21A.class
    id=EX21A
    width=650
    height=50 &gt;
&lt;/applet&gt;
&lt;hr&gt;
&lt;a href=&quot;EX21A.java&quot;&gt;The source.&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
There are three important components of this source to examine.
By examining the object from bottom to top, you see that the most
obvious and familiar is the applet definition:
<BLOCKQUOTE>
<PRE>
&lt;applet
    code=EX21A.class
    id=EX21A
    width=650
    height=50 &gt;
&lt;/applet&gt;
</PRE>
</BLOCKQUOTE>
<P>
These lines declare an applet on the page with the code contained
in <TT>EX21A.class</TT>. An <TT>id</TT> of <TT>EX21A</TT> is associated
with the applet so that the entity can be referred to elsewhere
from the page. Sizing of the applet is the last element of the
definition.
<P>
The next item is the <TT>OBJECT</TT> declaration. This object
is an instance of the <TT>Marquee</TT> object discussed earlier
in the chapter.
<BLOCKQUOTE>
<PRE>
&lt;OBJECT
align=CENTER
    classid=&quot;clsid:1a4da620-6217-11cf-be62-0080c72edd2d&quot;
    width=650 height=200 BORDER=1 HSPACE=5
    id=marquee
    &gt;
</PRE>
</BLOCKQUOTE>
<P>
Notice that there is something distinctly missing from this <TT>OBJECT</TT>
definition, namely, what it is. However, the <TT>classid</TT>
does define the <TT>CLSID</TT>, which is a component-specific
Universally Unique Global Identification (UUID) number. The Registry
(using <TT>REGEDT32.EXE</TT>) can be consulted to determine what
this component is. The following is some of a branch of the Registry
key that gives information about this component:
<BLOCKQUOTE>
<PRE>
HKEY_CLASSES_ROOT
    CLSID
        {1a4da620-6217-11cf-be62-0080c72edd2d}
            InprocSever32 = C:\WINDOWS\Sytem32\marquee.ocx
            Version = 1.0
</PRE>
</BLOCKQUOTE>
<P>
This is the <TT>Marquee</TT> object. Additional information can
be found in the HTML source that defines sizing of the object
and an identification of <TT>marquee</TT>. Finally, before the
<TT>OBJECT</TT> definition ends, there is a series of <TT>PARAM_NAME</TT>
and <TT>VALUE</TT> pairs. These define values for the initial
properties of the <TT>Marquee</TT>. Note that these parameters
do not need to be specified as shown in this example. There are
several options possible, including specifying the options in
the HTML (as shown), using the default values of object (as documented
in the <TT>Marquee</TT> documentation), or initializing the object
via the Java interface once the object has been loaded.
<P>
The final component is the scripting portion of the HTML. This
piece ties the applet and the COM object together.
<BLOCKQUOTE>
<PRE>
&lt;script language=VBScript&gt;
&lt;!--
'Give the COM object to the applet
Sub window_onLoad
    document.EX21A.Load marquee
end sub
!--&gt;
&lt;/script&gt;
</PRE>
</BLOCKQUOTE>
<P>
The script language tag indicates that this code is VBScript.
The only task completed in this script occurs in the <TT>window_onLoad</TT>
event, which is generated when the page has been loaded. The function
that is executed is the <TT>Load</TT> method of the <TT>EX21A</TT>
object. The parameter passed to this method is <TT>marquee</TT>.
Notice the reference to the two objects by their respective ids.
As you will see in the next section, the <TT>Load</TT> method
of the applet stores the reference to the object.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
To get more information on scripting VBScript or JScript, visit the Microsoft Web pages at <TT><A HREF="http://www.microsoft.com/vbscript">http://www.microsoft.com/vbscript</A></TT> or <TT><A 
HREF="http://www.microsoft.com/jscript">http://www.microsoft.com/jscript</A></TT>, respectively.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>Using the COM Object Interface</H4>
<P>
The previous section showed how the <TT>Marquee</TT> object was
passed to the applet using VBScript in the HTML page. Once the
object reference is loaded in the applet, example <TT>EX21A</TT>
shows what can be done.
<P>
The <TT>Load</TT> method couldn't be simpler:
<BLOCKQUOTE>
<PRE>
public void Load(Object marqueeObject)
{
    // save the reference to the object in the class
    MarqueeAccess = (IMarquee)marqueeObject;
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>marqueeObject</TT> passed into the method is assumed to
be the <TT>Marquee</TT> object. The reference to the object is
saved in the member variable <TT>MarqueeAccess</TT>. Because the
marquee is passed in as an object, a cast is done to the marquee
interface class, <TT>Imarquee</TT>.
<P>
Once the object reference has been saved in the class, the rest
of the program follows, as shown in Listing 21.3.
<HR>
<BLOCKQUOTE>
<B>Listing 21.3. Control methods and class definition of EX21A.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class EX21A extends Applet
{
    protected Button StateButton = new Button(&quot;Pause&quot;);
    protected IMarquee MarqueeAccess;
    public void init()
    {
        add(StateButton);               // provide control of marquee
        add(new Button(&quot;About&quot;));
    }
    public boolean action(Event evt, Object obj)
    {
        boolean retval = false;
        if (&quot;Pause&quot;.equals(obj)) {
            MarqueeAccess.Pause();      // stop the marquee
            StateButton.setLabel(&quot;Resume&quot;);
            retval = true;
        }
        else if (&quot;Resume&quot;.equals(obj)) {
            MarqueeAccess.Resume();     // crank it back up
            StateButton.setLabel(&quot;Pause&quot;);
            retval = true;
        }
        else if (&quot;About&quot;.equals(obj)) {
            MarqueeAccess.AboutBox();
            retval = true;
        }
        return retval;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The class contains two variables, <TT>StateButton</TT> and <TT>MarqueeAccess</TT>,
which are used to toggle the activity in the marquee and to hold
a reference to the marquee, respectively.
<P>
The <TT>init</TT> method adds the State button to the Java portion
of the page, which allows the user to control the starting and
stopping of the movement in the marquee, and an About button,
which is used to display a dialog containing version information
about the <TT>Marquee</TT> control. The <TT>action</TT> method
is similar to other examples throughout the book. If the Action
button is pressed when the text on the button reads Pause, the
<TT>Pause</TT> method of the marquee interface is called to stop
the marquee from rotating. If the Action button is pressed when
the text on the button reads Resume, the <TT>Resume</TT> method
is called to continue the marquee. Lastly, if the About button
is pressed, the <TT>AboutBox</TT> method is called to display
some version information. Figure 21.4 shows the applet at work.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-4.gif"><B> Figure 21.4 : </B><I>Example EX21A.
</I></A><P>
<P>
As shown in the example, once the script has passed the COM object
to the applet, the interface allows access to the COM object just
as if it were a normal Java class.
<H3><A NAME="EventProcessing">
Event Processing</A></H3>
<P>
The second method that can be used to communicate between the
COM object and the Java applet implements event handlers in the
applet. Again, scripting needs to be used as the interface between
the two components.
<P>
COM objects can generate events when the control is in predefined
states. The events can be caught by a HTML script and passed on.
Revisiting the script code of the HTML file for example <TT>EX21A</TT>:
<BLOCKQUOTE>
<PRE>
&lt;script language=VBScript&gt;
&lt;!--
'Give the COM object to the applet
Sub window_onLoad
    document.EX21A.Load marquee
end sub
!--&gt;
&lt;/script&gt;
</PRE>
</BLOCKQUOTE>
<P>
The subprogram is actually executed on an event when the window
is loaded. This is how the script language can be used to respond
to events. For this example, a predefined object was used to determine
where the event originated from, <TT>window</TT>. To use this
event processing for COM objects, simply reference the COM object
by ID and add the event. To clarify, the <TT>OnLMouseClick</TT>
event is generated by the marquee when the left mouse button is
clicked on the object. The subprogram used to process the event
would then be
<BLOCKQUOTE>
<PRE>
Sub marquee_OnLMouseClick
    document.EX21B.Play
end sub
</PRE>
</BLOCKQUOTE>
<P>
When the left mouse button is clicked on the marquee of <TT>EX21B</TT>,
the <TT>Play</TT> method of the applet is called:
<BLOCKQUOTE>
<PRE>
public void Play()
{
    // play the sound bite
    play(getCodeBase(), &quot;bounce.au&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
This method calls <TT>Applet.play</TT> to play a short sound bite.
<P>
Example <TT>EX21B</TT> illustrates how a two-way communication
channel can be established between a COM object and a Java applet.
First the object can be passed to the applet, which enables the
applet to call the object methods directly. Secondly, the Java
applet can respond to events generated by the COM object, with
the help of a scripting language.
<H3><A NAME="NonvisualCOMObjects">
Nonvisual COM Objects</A></H3>
<P>
Visual objects require that a COM object be declared in HTML on
the page. There are certain COM objects that do not require this.
If a COM object does not have a corresponding visual component,
an object does not have to be declared. Instead, an instance of
the class can be instanciated in a Java applet directly.
<P>
Example <TT>EX21C</TT> illustrates this type of COM interface
and shows how to implement a self-paging system. Figure 21.5 shows
the paging system interface.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-5.gif"><B> Figure 21.5 : </B><I>Example EX21C.
</I></A><P>
<P>
To create the COM interface, use the Tools | Java Type Library
Wizard in the MS Developer Studio. Select the Beeper 1.0 Type
Library, as shown in Figure 21.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-6.gif"><B> Figure 21.6 : </B><I>Type Library used for example EX21C.
</I></A><P>
<P>
This dynamic link library contains a control that generates a
beep, using the local machine's speaker. This is similar to generating
an interrupt <TT>0x07</TT> in the olden days. The Java Type Library
Wizard produces the summary file shown in Listing 21.4.
<HR>
<BLOCKQUOTE>
<B>Listing 21.4. SUMMARY.TXT for the Beeper object.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public interface beeper/IBeeper extends com.ms.com.IUnknown
{
    public abstract int getCount();
    public abstract void Beep();
    public abstract com.ms.com.IUnknown get_NewEnum();
    public abstract java.lang.String getItem(int);
}
public class beeper/Beeper extends java.lang.Object
{
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Of course, this control does not have a lot of options. Listing
21.5 shows the source for example <TT>EX21C</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 21.5. Example EX21C.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import beeper.*;
public class EX21C extends Applet
{
    protected IBeeper Motorola;
    public void init()
    {
        // add a button so that an action can be performed
        add(new Button(&quot;Page&quot;));
        // allocate a new COM object
        Motorola = (IBeeper)new Beeper();
    }
    public boolean action(Event evt, Object obj)
    {
        boolean retval = false;         // assume no action
        if (&quot;Page&quot;.equals(obj)) {
            Motorola.Beep();
            retval = true;
        }
        return retval;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The beeper interface is imported as usual. The <TT>init</TT> method
adds the single button to the applet. Additionally, the <TT>init</TT>
method allocates the COM object with the following line of code:
<BLOCKQUOTE>
<PRE>
Motorola = (IBeeper)new Beeper();
</PRE>
</BLOCKQUOTE>
<P>
Note that a class is allocated, since an interface instance cannot
be allocated. Then, the returned object is cast to the interface
object.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A runtime error will occur if you attempt to use a COM object directly in a Java application, such as with the following code:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Beeper Motoroler = new Beeper();<BR>
Motoroler.Beep();</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>action</TT> method in example <TT>EX21C</TT> responds
the push of the button by calling the <TT>Beep</TT> method of
the COM object to perform the page. I think I will recommend this
pager to my boss.
<H2><A NAME="CreatingaCOMObjectwithJava"><FONT SIZE=5 COLOR=#FF0000>
Creating a COM Object with Java</FONT></A></H2>
<P>
So far, the discussion has been targeted to how most ActiveX objects
will be used from Java applets and their interaction with Web
pages. An additional feature of Visual J++ is that ActiveX objects
can be generated. Follow these steps:
<OL>
<LI>Generate a UUID for the library and components of the library
using <TT>GUIDGEN.EXE.</TT>
<LI>Define the type library interface using the Object Definition
Language (ODL).
<LI>Create the type library from the ODL.
<LI>Register the new COM component.
<LI>Generate the Java Interface to the COM component.
<LI>Implement the Java class for the COM component.
</OL>
<P>
The following sections go over each step, developing a factorial
example.
<H3><A NAME="GeneratingaUniversallyUniqueGlobalIdentificationUUID">
Generating a Universally Unique Global Identification (UUID)
</A></H3>
<P>
The first step in creating a COM object is to establish a UUID
number for the type of control. <TT>GUIDGEN.EXE</TT> can be used
to create this number. Figure 21.7 shows this program in action.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-7.gif"><B> Figure 21.7 : </B><I>GUIDGEN.EXE.
</I></A><P>
<P>
This program guarantees that every number generated, no matter
when or on what computer it is run, will be unique. In this way,
every ActiveX object can be identified and verified with its UUID.
Additional UUIDs will be needed for each element in the type library,
as you will see in the next section.
<P>
Figure 21.7 shows that the number generated for the <TT>Factorial</TT>
object is
<BLOCKQUOTE>
<PRE>
{62133720-3022-11d0-BAF4-EC3AC9000000}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="DefininganObject">
Defining an Object</A></H3>
<P>
The next step in defining the COM object is to determine the interface
to the object. This is done using the Object Definition Language
(ODL). ODL takes a general form of
<BLOCKQUOTE>
<PRE>
[attributes] library libraryname {
    definitions
}
</PRE>
</BLOCKQUOTE>
<P>
The brackets ([]) and braces ({}) are part of the syntax and are
required. <TT>attributes</TT> is a comma-delimited list of ODL
attributes. Typical contents of the list that applies to libraries
include the UUID for the library, help information, and version
number. <TT>libraryname</TT> is the name of the type library.
<TT>definitions</TT> is the heart of the library and contains
the datatype, interfaces, and class contained in the type library.
<P>
Using the UUID from the previous step, the <TT>Factorial</TT>
object library for <TT>EX21D</TT> would then be
<BLOCKQUOTE>
<PRE>
[
    uuid (62133720-3022-11d0-BAF4-EC3AC9000000),
    helpstring(&quot;Factorial 1.0 Type Library&quot;),
    version(1.0)
]
library LFactorial
{
}
</PRE>
</BLOCKQUOTE>
<P>
The contents of the library can include preprocessor directives,
imported libraries, interfaces, and classes. The majority of these
have the same general form.
<BLOCKQUOTE>
<PRE>
[attributes] elementtype elementname {
    members
};
</PRE>
</BLOCKQUOTE>
<P>
Again, <TT>attributes</TT> is a comma-delimited list of ODL attributes.
This list contains UUIDs, help information, and a potentially
large list of other information for complex elements. <TT>elementtype</TT>
is one of the following keywords:
<BLOCKQUOTE>
<TT>module<BR>
dispinterface<BR>
interface<BR>
coclass</TT>
</BLOCKQUOTE>
<P>
<TT>elementname</TT> is the user-defined name given to the element.
The members of the element are dependent on the type of the element.
<P>
ODL is an extensive language used to define types for OLE automation.
What has been covered here is only enough to get your feet kind
of damp, so that a basic understanding of the ODL file can be
obtained.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Microsoft's Interface Definition Language (MIDL) compiler can be used to compile ODL files, since the MIDL syntax contains complete support for ODL syntax. For a complete reference on MIDL, refer to the MIDL Programmer's Guide and Reference in the WIN32 
SDK.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>Factorial</TT> object ODL is shown in Listing 21.6.
<HR>
<BLOCKQUOTE>
<B>Listing 21.6. FACTORIAL.ODL.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
[
    uuid (62133720-3022-11d0-BAF4-EC3AC9000000),
    helpstring(&quot;Factorial 1.0 Type Library&quot;),
    version(1.0)
]
library LFactorial
{
    // get the standard stuff
    importlib(&quot;stdole32.tlb&quot;);
    [
        uuid (62133721-3022-11d0-BAF4-EC3AC9000000),
        helpstring(&quot;Factorial Interface&quot;)
    ]
    dispinterface IFactorial
    {
        properties:
        methods:
            [id(1)]long GetFactorial([in]long base);
    };
    [
        uuid (62133722-3022-11d0-BAF4-EC3AC9000000),
        helpstring(&quot;Factorial Class&quot;)
    ]
    coclass Factorial
    {
        dispinterface IFactorial;
    };
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>Factorial</TT> object first imports the standard OLE objects
using <TT>importlib</TT>. The <TT>dispinterface</TT> is used to
define the properties and methods of the interface of the object.
Notice that a UUID is given to the interface. The interface contains
a single method, <TT>GetFactorial</TT>, that takes a number and
returns the factorial of the number. Finally, the top-level <TT>Factorial</TT>
class is defined with the <TT>coclass</TT> keyword. Again, a UUID
is assigned to the top-level class. The class is made up of the
single interface, <TT>IFactorial</TT>.
<H3><A NAME="CreatingaTypeLibrary">
Creating a Type Library</A></H3>
<P>
Once an ODL file has been created, that file needs to be compiled
into a type library. <TT>MKTYPLIB.EXE</TT> can be used. The syntax
for this command line program is
<BLOCKQUOTE>
<PRE>
MKTYPLIB [options] [inputfile]
</PRE>
</BLOCKQUOTE>
<P>
The options for the program are shown in Table 21.1.<BR>
<P>
<CENTER><B>Table 21.1. MKTYPLIB options.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Option</I></TD><TD WIDTH=384><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/help or /?</TT></TD><TD WIDTH=384>Display the options.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/tlb filename</TT></TD><TD WIDTH=384>Names the output filename to <TT>filename</TT>. The default is to use the input filename with the extension <TT>.tlb</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/h filename</TT></TD><TD WIDTH=384>Specifies the filename of the optionally generated <TT>.H</TT> file.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/system</TT></TD><TD WIDTH=384>Type of library that is to be made. <TT>system </TT>can be win16, win32, mac, mips, alpha, ppc, or ppc32.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/align #</TT></TD><TD WIDTH=384>Sets alignment to <TT>#</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/o filename</TT></TD><TD WIDTH=384>Causes program output to go to <TT>filename</TT> instead of screen.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/nologo</TT></TD><TD WIDTH=384>Disable display of copyright.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/w0</TT></TD><TD WIDTH=384>Disable warnings.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/nocpp</TT></TD><TD WIDTH=384>Disable the C preprocessor. Java library creators should always use this option if the C compiler is not installed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/cpp_cmd path</TT></TD><TD WIDTH=384>Causes the C preprocessor to use path.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/cpp_opt opt</TT></TD><TD WIDTH=384>Specifies options to be sent to the C preprocessor.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/Ddefine[=value]</TT></TD><TD WIDTH=384>Defines <TT>define</TT> for the preprocesser to an optional value of <TT>value</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>/I includepath</TT></TD><TD WIDTH=384>Specifies an include file path.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The majority of the options are offered when libraries are being
made for use when being called from C/C++ programs. This makes
the version used for Java options quite simple:
<BLOCKQUOTE>
<PRE>
mktyplib factorial.odl /nocpp
</PRE>
</BLOCKQUOTE>
<H3><A NAME="RegisteringtheComponent">
Registering the Component</A></H3>
<P>
Registering the component places important information about the
object in the Registry. The <TT>JAVAREG.EXE</TT> command-line
tool aides in registering Java COM objects. Figure 21.8 shows
the command-line options available.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-8.gif"><B> Figure 21.8 : </B><I>JAVAREG.EXE options.
</I></A><P>
<P>
The command issued to register the <TT>Factorial</TT> class specifies
the class name and the UUID, which will be used for the CLSID:
<BLOCKQUOTE>
<PRE>
javareg /register /class:Factorial /clsid:{62133722-3022-11d0-BAF4-EC3AC9000000}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CreatingtheJavaInterface">
Creating the Java Interface</A></H3>
<P>
Once the COM object is registered, the COM interface class is
generated. Once again, go to the Tools | Java Type Library Wizard,
as shown in Figure 21.9, to generate the class.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-9.gif"><B> Figure 21.9 : </B><I>Factorial Type Library selection.
</I></A><P>
<P>
The <TT>SUMMARY.TXT</TT> file is shown in Listing 21.7, with the
expected single <TT>GetFactorial</TT> method in the interface.
<HR>
<BLOCKQUOTE>
<B>Listing 21.7. SUMMARY.TXT for the Factorial COM object.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class factorial/Factorial extends java.lang.Object
{
}
public interface factorial/IFactorial extends com.ms.com.IUnknown
{
    public abstract int GetFactorial(int);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ImplementingtheJavaClass">
Implementing the Java Class</A></H3>
<P>
The final step in creating the Java Component is to implement
the Java class defined in the ODL file. To do this, simply implement
the interface class. Listing 21.8 contains the <TT>Factorial</TT>
class.
<HR>
<BLOCKQUOTE>
<B>Listing 21.8. Factorial class implementation.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import com.ms.com.*;
import factorial.*;
class Factorial implements IFactorial
{
    public int GetFactorial(int base)
    {
        int retval = 0;
        if (base &gt;= 1 &amp;&amp; base &lt;= 20)
        {
            retval = 1;
            while (base &gt; 1)
            {
                retval = retval * base;
                base-;
            }
        }
        return retval;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The class that implements the <TT>IFactorial</TT> interface could
have been named anything. There is not a direct correlation between
the <TT>Factorial</TT> <TT>coclass</TT> in the ODL file with this
<TT>Factorial</TT> class. It simply makes it easier for the programmer.
Notice that the <TT>Factorial</TT> interface of the COM component
is imported. The <TT>GetFactorial</TT> method calculates the factorial
for a number between 1 and 20, returning the factorial of the
number.
<P>
From this point, the Java class can be used from any application
that can activate an ActiveX component. As an example, the next
section will cover example <TT>EX21D</TT>, which is an applet
that will use this object.
<H3><A NAME="UsingtheJavaComponent">
Using the Java Component</A></H3>
<P>
Using a COM object implemented with Java is just like using any
other COM object. Figure 21.10 shows example <TT>EX21D</TT> and
the COM object in use.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-10.gif"><B> Figure 21.10 : </B><I>Example EX21D using the Factorial COM object.
</I></A><P>
<P>
Listing 21.9 shows the action method from example <TT>EX21D</TT>,
which illustrates the use of the COM object, <TT>iFac</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 21.9. action method of example EX21D.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
    boolean retval = false;
    if (&quot;Calculate&quot;.equals(obj))
    {
        try {
            int base = Integer.parseInt(BaseField.getText());
            int result = iFac.GetFactorial(base);
            if (result &gt; 0)
                ResultLabel.setText(Integer.toString(result));
            else
                ResultLabel.setText(&quot;Error!&quot;);
        }
        catch (NumberFormatException e)
        {
            ResultLabel.setText(&quot;Bad #!&quot;);
        }
        // make sure the label is dipslaying all of its text
        ResultLabel.resize(ResultLabel.preferredSize());
        // tell the layout manager to do it's job again
        validate();
        retval = true;
    }

    return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you can see, there are just a few steps to creating an ActiveX
object that can now be used in a number of situations. In addition,
there are several command-line utilities in the Visual J++ suite
that aide in completing these steps effortlessly. Once you have
a component that is to be distributed, you must enclose the component
in a signed CAB file so that a user can safely use the component
without the fear of a security risk.
<H2><A NAME="CreatingaSignedCABFile"><FONT SIZE=5 COLOR=#FF0000>
Creating a Signed CAB File</FONT></A></H2>
<P>
When distributing applets over the Internet, make sure that the
users that visit your site feel safe about using any COM objects
that have to be downloaded to their machine. After all, if the
user does not feel safe, he or she won't use the component or
visit the site. To accomplish a certain level confidence, and,
in the process, gain speed of download via compressing the classes
being used on your site, utilize signed cabinet files. Creating
a signed CAB file is a two-step process: creating a CAB file with
the classes needed for your applet and signing the file using
Microsoft's Authenticode technology.
<H3><A NAME="CABFiles">
CAB Files</A></H3>
<P>
Cabinet file support is included on the Visual J++ disks in the
<TT>\Cab&amp;Sign</TT> directory. They are not automatically installed
when installing Visual J++. To install the CAB file creation utility,
copy <TT>CABDEVKIT.EXE</TT> to a directory on your local drive.
Then execute the self-extracting file and follow the installation
steps.
<P>
There are two steps in using a CAB file: creating the file and
making use of the CAB file for your applet.
<H4>Creating a CAB File</H4>
<P>
Once the CAB Development kit has been installed, it is quite easy
to create a CAB file. In fact, there are two ways to create a
file: using the <TT>CABARC</TT> command or editing the sample
<TT>.DDF</TT> files and running <TT>DIAMOND</TT> directly.
<P>
The CABARC utility has the following syntax:
<BLOCKQUOTE>
<PRE>
CABARC [options] command cabfilename [filelist] [destdirectory]
</PRE>
</BLOCKQUOTE>
<P>
<TT>command</TT> is a single letter indicating the type of function
to perform: L (list), N (new CAB file), or X (extract). <TT>cabfilename</TT>
is the name of the CAB file; remember to add the <TT>.CAB</TT>
extension because it isn't automatically added. <TT>filelist</TT>
is the list of files to add to the archive.
<P>
There are several options that can confirm files, set the compression
type, and cause recursive inclusion of files in subdirectories
(as well as other options) that can be seen by typing only the
name of the command. One of the most important options is the
<TT>-s</TT> option, which allows the user to reserve space in
the archive for signing the CAB file.
<P>
As an example on the accompanying CD, the <TT>EX21E</TT> subdirectory
contains the CAB files for distributing the <TT>EX15A</TT> example.
The following command was used to create the CAB file:
<BLOCKQUOTE>
<PRE>
CABARC -s 6144 -r -p N ..\..\Chap21\EX21E\EX15AArc *.class *.jpg
</PRE>
</BLOCKQUOTE>
<P>
Unfortunately, this does expose an error that currently exists
with this version of the CAB file concept. This technology is
designed to have images and audio files included in the CAB files.
The CAB should be checked when loading an image using a URL that
is relative to the code base, as in the following snippet of code:
<BLOCKQUOTE>
<PRE>
getImage(getCodeBase(), &quot;images\\Christopher1.jpg&quot;);
</PRE>
</BLOCKQUOTE>
<P>
If the image file is not found in the CAB file, normal processing
should then dictate that the codebase is referenced for the file,
as usual. Currently, the images and audio clips are not loaded
from the CAB file at all. Therefore, for example <TT>EX21E</TT>,
there is an image subdirectory that contains the images for <TT>EX15A</TT>.
<P>
The alternative method to using CABARC is to run the cabinet generating
program, <TT>DIAMOND.EXE</TT>, explicitly. To do this, however,
the default DDF files need to be modified to handle the applet
classes explicitly. The default DDF files are heavily commented,
so the modifications are straightforward.
<P>
First, copy the files <TT>CLASSPCK.DDF</TT>, <TT>MASTER.DDF</TT>,
and <TT>MASTER.INF</TT> to the release directory so that these
files can be modified. Then, edit <TT>CLASSPCK.DDF</TT> to create
a CAB file that will contain the class files. Following the comment
in this file, modify the CAB filename that will be generated and
the class files that go into this CAB file. This is not the final
CAB file but only a CAB file that will contain the class files.
Create the CAB file with the command
<BLOCKQUOTE>
<PRE>
DIAMOND /f ClassPck.ddf
</PRE>
</BLOCKQUOTE>
<P>
Next, change the <TT>MASTER.INF</TT> file. Again following the
comments in the file, add the control's <TT>CLSID</TT> and some
identification information for the installed library. It might
be a good idea to change the name of this file to reflect the
product being distributed. Example <TT>EX21F</TT>, which contains
all of these files and represents a distribution of example <TT>EX21D</TT>,
changed the name of the master files to <TT>EX21DDiamond</TT>.
<P>
Finally, set the name of the final CAB file, name of the class
CAB file and the name of the <TT>.INF</TT> file in <TT>MASTER.DDF</TT>,
and create the CAB file with the final DDF file. For our example:
<BLOCKQUOTE>
<PRE>
DIAMOND /f EX21DDiamond.ddf
</PRE>
</BLOCKQUOTE>
<P>
As you can see, the first method is simpler while the second method
allows much more flexibility. Once the CAB files have been created,
they need to be used in the <TT>APPLET</TT> tags of the HTML.
<H4>Modifying the Applet Tag for CAB File Use</H4>
<P>
Using CAB files requires a simple modification to the HTML. A
single additional parameter can be specified in the <TT>APPLET</TT>
tag:
<BLOCKQUOTE>
<PRE>
&lt;APPLET
    code=EX15A.class
    id=EX15A
    width=500
    height=300 &gt;
&lt;PARAM NAME=&quot;cabbase&quot; VALUE=&quot;EX15AArc.CAB&quot;&gt;
&lt;/APPLET&gt;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>cabbase</TT> parameter instructs CAB-enabled browsers,
such as Internet Explorer 3.0, to use the specified CAB file for
class information.
<H3><A NAME="SigningaCABFile">
Signing a CAB File</A></H3>
<P>
Signing a CAB file is a process that attempts to secure some reliability
of code integrity through the use of public and private keys and
certification authorities for code that is distributed over a
virtually uncontrolled Internet. The process involves applying
for a public key through a certification process by which a business
shows the validity and stability of their company. Once that has
been established, a key is assigned to that company that allows
anyone to trace a file digitally signed with that key back to
the company.
<P>
Digital signing of files support is included on the Visual J++
disks in the <TT>\Cab&amp;Sign</TT> directory. It is not automatically
installed when installing Visual J++. To install the code signing
utility, copy <TT>CODESIGN.EXE</TT> to a directory on your local
drive. Then execute the self-extracting file and follow the installation
steps.
<P>
This section covers how to digitally sign a CAB file with the
test certificate supplied with the kit. You must contact a Certification
Authority to obtain an authentic certification before distributing
your CAB files. Visit <TT><A HREF="http://www.microsoft.com/intdev/signcode">http://www.microsoft.com/intdev/signcode</A></TT>
for more information on Authenticode.
<P>
To generate a test certificate, use the <TT>MAKECERT.EXE</TT>
utility. A possible invocation of this program to generate <TT>MATHWORKS.CER</TT>
is
<BLOCKQUOTE>
<PRE>
MAKECERT -k:MathWorks.pvk -n:CN=MathWorksInc -d:MathWorksInc MathWorks.cer
</PRE>
</BLOCKQUOTE>
<P>
Once a test certification file has been created, <TT>CERT2SPC.EXE</TT>
can be used to generate a SPC file:
<BLOCKQUOTE>
<PRE>
CERT2SPC root.cer MathWorks.cer MathWorks.spc
</PRE>
</BLOCKQUOTE>
<P>
The SPC file is the file that would normally be provided by the
Certification Authority. These utilities are simply provided to
test the process.
<P>
The SPC file is used to actually sign the CAB files. <TT>SIGNCODE.EXE</TT>
is used to add a digital signature to a file. The easiest way
to use this program is to simply enter name of the program without
parameters:
<BLOCKQUOTE>
<PRE>
SIGNCODE
</PRE>
</BLOCKQUOTE>
<P>
The Code Signing Wizard of Figure 21.11 will simplify the process.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f21-11.gif"><B> Figure 21.11 : </B><I>Code Signing Wizard.
</I></A><P>
<P>
Once a CAB file has been digitally signed with a valid SPC file,
it is ready to be distributed. There are two additional utilities
that can be used to test the signing of files: <TT>PESIGMGR.EXE</TT>
and <TT>CHKTRUST.EXE</TT>. These utilities can manipulate the
certificates used in signing a file and checking the validity
of a signed file, respectively. Remember that these will not work
with the test certification generated with MAKECERT and CERT2SPC.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter touched on several points involving the quickly changing
ActiveX world. It covered how to create a Java interface of an
ActiveX object using the Java Type Library Wizard for registered
components. After establishing the interface, the Java applet
can then be used to control the objects by calling the interface
methods made available for the component. In addition, the Java
applet could be used as an event handler. Combining these methods,
two-way communications can be established between the object and
the applet. Java can also be used to create an ActiveX object
that can be packaged in a signed CAB file for trusted use on your
favorite Web site.
<HR>

<CENTER><P><A HREF="ch20.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch22.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
