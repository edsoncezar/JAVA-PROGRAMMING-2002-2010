<HTML>
<HEAD>
<TITLE>Chapter 20 -- Keeping Out the Riff-Raff: Java Security
</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;20</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Keeping Out the Riff-Raff: Java
Security</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheSecurityPolicySettingLimits">
The Security Policy-Setting Limits</A>
<LI><A HREF="#TheJavaLanguage">
The Java Language</A>
<LI><A HREF="#TheCodeVerifier">
The Code Verifier</A>
<LI><A HREF="#TheClassLoader">
The ClassLoader</A>
<LI><A HREF="#TheSecurityManager">
The SecurityManager</A>
<LI><A HREF="#AppletsVersusApplications">
Applets Versus Applications</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Before Java applets arrived on the scene, the Web was primarily
composed of static content and was relatively safe. Of course,
CGI scripts and server-side includes opened up security concerns
on the server side of the equation-but with applets, the security
of the client is in question for the first time. Web developers
are now able to create active content that could be executed in
the client's address space. Needless to say, it is not acceptable
to give wholesale access to the client's system resources. As
illustrated in Figure 20.1, not only can applets originate from
unknown or untrusted hosts on the Internet, the applet's class
files must travel across an untrusted network before being executed
on the user's system. A bulletproof security scheme is needed
to allow users of the Web to run any applet without having to
worry about their local files being deleted or their system being
raided for sensitive information. This chapter discusses the security
measures of the Java language and runtime environment.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f20-1.gif"><B> Figure 20.1 : </B><I>The origins and paths of Java applets.
</I></A><P>
<H2><A NAME="TheSecurityPolicySettingLimits"><FONT SIZE=5 COLOR=#FF0000>
The Security Policy-Setting Limits</FONT></A></H2>
<P>
All Web browsers offer some level of control when it comes to
executing applets. Of course, browsers that cannot execute applets
offer the most security, but the others still allow users to customize
the level of security to suit their needs. Most of the time this
means simply enabling or disabling the execution of applets. However,
Sun's HotJava browser offers a finer level of control where access
to local files and network ports is fully configurable. Figure
20.2 displays the security configuration dialog for the Microsoft
Internet Explorer 3.0.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f20-2.gif"><B> Figure 20.2 : </B><I>The security dialog for Internet Explorer.
</I></A><P>
<P>
The challenge is to allow an applet to perform its intended tasks,
and at the same time isolate the applet from vital resources and
the other processes on the host system. This concept is often
referred to as the <I>sandbox approach.</I> In general, applets
must operate under the constraints listed in Table 20.1.<BR>
<P>
<CENTER><B>Table 20.1. Security constraints imposed on applets.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=173><I>Resource</I></TD><TD WIDTH=403><I>Constraint</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>File system</TD><TD WIDTH=403>Unless otherwise configured through the browser, applets are not allowed to read, write, or manipulate files on the host machine in any way.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>Network connections</TD><TD WIDTH=403>Connections can be made only back to the server from which the applet came (as specified by the <TT>CODEBASE</TT> parameter of the <TT>APPLET</TT> HTML tag) or the server hosting the Web 
page referencing the applet.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>Environment variables</TD><TD WIDTH=403>Unless otherwise configured through the browser, access to environment variables via <TT>System.getProperty()</TT> is prohibited.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>System calls</TD><TD WIDTH=403>Starting processes, executing programs, or loading libraries on the local machine is prohibited. Furthermore, applets cannot exit or terminate the browser through calls to <TT>System.exit()</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>Thread control</TD><TD WIDTH=403>Unauthorized manipulation of threads within the Java Virtual Machine is prohibited.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=173>Pop-up windows</TD><TD WIDTH=403>Although pop-up windows can be created with applets, they are tagged in some manner to indicate that they originated from an applet.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
To enforce the constraints listed in Table 20.1, the development
and runtime environments must work together. On the development
side, the language itself has many attributes that make it &quot;safe&quot;
and difficult to corrupt the runtime environment. Because the
browser actually runs applets, it has the most security measures.
Not only are the bytecodes of each class file verified, the loading
of each class is scrutinized as well as access attempts to critical
resources. The following sections discuss each of these areas
in detail.
<H2><A NAME="TheJavaLanguage"><FONT SIZE=5 COLOR=#FF0000>
The Java Language</FONT></A></H2>
<P>
The creators of Java knew that if the language was going to succeed
as a tool for developing active content for the Internet, the
language itself would have to be safe. In fact, many of the attributes
of Java that make it safe also protect programmers from the pitfalls
of other languages. Perhaps one of the most obvious of these is
the absence of pointers in Java. C and C++ programmers have had
a love/hate relationship with pointers for many years. On one
hand, pointers add flexibility and efficiency to a language. However,
it is the flexibility of pointers that can add hours of debugging
to a project when they are left uninitialized, pointing at deleted
objects, or used to reference objects of incompatible types. As
far as security is concerned, the elimination of pointers immediately
protects Java programs from using them to imitate objects, violate
encapsulation, and access protected areas of memory. In addition,
all array access is validated to prevent out-of-bounds conditions
that can lead to unauthorized access to memory.
<P>
As an alternative to pointers, Java uses strongly typed object
references that are policed by the compiler and runtime environment.
The compiler will flag casts between incompatible types, and all
seemingly legitimate casts undergo runtime checks for casting
violations. Illegal runtime casts generate <TT>ClassCastException</TT>s.
<P>
Memory management is also a vital ingredient to the security of
Java. The garbage collector ensures that objects are disposed
of only when they are no longer referenced. This prevents a program
from accidentally exhausting the resources of the host system,
thereby crashing or severely affecting the stability of the system.
Of course, this does not prevent an evil applet from purposefully
over-allocating resources to achieve the same end.
<P>
In addition, the Java compiler ensures that all class method and
variable controls are enforced. That is, protected methods and
variables are accessed internally only by a class or subclass
and private methods and variables are accessed internally by the
class. The <TT>final</TT> modifier also contributes to the security
of programs by preventing critical classes from being subclassed
to override or circumvent access controls.
<P>
So the language specification and compiler work together to produce
secure bytecodes in the form of <TT>.class</TT> files that can
then be interpreted by the Java runtime environment. Unfortunately,
a lot can happen to the bytecodes from the time they are constructed
to the time they are interpreted. They could be modified on the
file system where they reside or by a node on the Internet as
the bytecode passes by. Of course, with the proliferation of Java
compilers available today, the compiler itself could also produce
bytecodes with security flaws. What is needed is another measure
of security that ensures the bytecodes meet the same constraints
imposed by the development environment.
<H2><A NAME="TheCodeVerifier"><FONT SIZE=5 COLOR=#FF0000>
The Code Verifier</FONT></A></H2>
<P>
The purpose of the code verifier is to validate the bytecodes
of any class files loaded from outside the trusted domain of the
runtime environment. Typically this involves any classes loaded
from a network connection. Classes on the host's local disk are
considered trusted and thus are not subjected to the verifier.
Figure 20.3 shows the code verifier's position in the security
chain.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f20-3.gif"><B> Figure 20.3 : </B><I>Java's security scheme.
</I></A><P>
<P>
The verifier makes four passes over each class file. The first
pass involves validating the format of the class file. Each class
file includes the following components:
<UL>
<LI>A magic constant
<LI>Major and minor version information
<LI>The constant pool, including strings, class or interface names,
variable or method references, and numeric values
<LI>Class information including the name of the class and its
superclass
<LI>Variable and method information for the class
<LI>Debugging information for the class
</UL>
<P>
The first pass will calculate the magic number for the class file
and compare it against the magic number embedded in the file.
It will also do some basic validation to verify that all recognized
attributes have the correct length and the constant pool contains
the proper information.
<P>
The second pass looks a little closer at the class file and ensures
that final classes are not subclassed; final methods are not overridden,
every class has a superclass; and the names, classes, and type
signatures referenced in the constant pool are legal.
<P>
The third and most complex pass actually verifies the bytecodes
of each method. The stack, registers, method arguments, and opcodes
are all validated in this step.
<P>
Finally, the fourth pass completes the verification process by
completing tests that were deferred by the third pass as well
as performing some opcode optimization.
<P>
If the verifier approves a class file to be executed, the interpreter
can assume that the bytecodes possess the following qualities:
<UL>
<LI>All register access and stores are valid.
<LI>No stack overflows or underflows will occur.
<LI>All parameter and return types match and are valid.
<LI>There are no illegal casting or type conversions.
</UL>
<P>
Because the verifier ensures several runtime boundaries are maintained,
the interpreter is free to run verified code much faster. Runtime
checks that would ordinarily have to be done with the execution
of each instruction are now eliminated. However, this also illustrates
how vital the verifier is to the runtime environment. Just as
the security of bytecodes is the responsibility of the compiler,
the security and stability of the runtime environment is only
as good as the verifier of the browser used to run applets. Indeed,
browser vendors have had to enhance the effectiveness of their
Java runtime environments to close potential security holes opened
by the verifier.
<H2><A NAME="TheClassLoader"><FONT SIZE=5 COLOR=#FF0000>
The ClassLoader</FONT></A></H2>
<P>
Now that the bytecodes have been authorized to be safely interpreted,
the <TT>ClassLoader</TT> takes over to ensure that class boundaries
and namespaces are maintained. A hierarchical chain of namespaces
begins with the classes loaded in the local namespace and ends
with classes loaded from network connections. The local namespace
is composed of the core Java classes as referenced by the <TT>CLASSPATH</TT>
environment variable. Because these classes are trusted and implement
vital objects such as <TT>System</TT>, they cannot be replaced
by classes from any of the other namespaces. The class loader
also ensures that namespaces are maintained between classes loaded
from different applets from separate network sources.
<P>
This is where the package names and access modifiers come into
play. The class loader keeps the classes of each package isolated
and prioritized so applets cannot create their own versions of
classes by the same name in different packages. In addition, access
to classes that are not indicated as public by objects outside
of the package is prohibited.
<H2><A NAME="TheSecurityManager"><FONT SIZE=5 COLOR=#FF0000>
The SecurityManager</FONT></A></H2>
<P>
Now that all of the classes necessary to run an applet have been
verified by the verifier and separated into executable compartments
by the class loader, the security manager implements the security
policy of the runtime environment. This is where perfectly legitimate
requests under normal circumstances are denied by the browser.
Resources such as the file system and network are protected by
the security manager. Table 20.2 lists some of the methods of
the abstract <TT>SecurityManager</TT> class.<BR>
<P>
<CENTER><B>Table 20.2. Public methods of the SecurityManager class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkAccept(String, int)</TT></TD><TD WIDTH=384>Called prior to accepting a socket connection from the specified host on the specified port.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkAccess(Thread)</TT></TD><TD WIDTH=384>Called prior to performing any thread manipulation requests on the specified thread.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkAccess(ThreadGroup)</TT></TD><TD WIDTH=384>Called prior to performing any thread group manipulation requests on the specified thread group.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkConnect(String, int)</TT></TD><TD WIDTH=384>Called prior to opening a socket connection to the specified host and port.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkConnect(String, int, Object)</TT></TD>
<TD WIDTH=384>Called prior to opening a socket to the specified host and port for the given security context.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CheckCreateClassLoader()</TT></TD><TD WIDTH=384>Called to check whether a new <TT>ClassLoader</TT> object can be set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkDelete(String)</TT></TD><TD WIDTH=384>Called to determine whether the specified file is permitted to be deleted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkExec(String)</TT></TD><TD WIDTH=384>Called to determine whether a subprocess can be created for the specified command.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkExit(int)</TT></TD><TD WIDTH=384>Called to determine whether the current process can halt the Java Virtual Machine with the specified exit code.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkLink(String)</TT></TD><TD WIDTH=384>Called to determine whether the specified library is permitted to be dynamically loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkListen(int)</TT></TD><TD WIDTH=384>Called to determine whether the current process is permitted to listen for connections on the specified port.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CheckPackageAccess<BR>(String)</TT></TD><TD WIDTH=384>This method works with the class loader to determine whether the current process is permitted to access the specified package.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CheckPackageDefinition<BR>(String)</TT></TD>
<TD WIDTH=384>Determines whether the current process is permitted to define classes within the specified package.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CheckPropertiesAccess()</TT></TD><TD WIDTH=384>Called to determine whether system properties can be accessed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>CheckPropertyAccess<BR>(String)</TT></TD><TD WIDTH=384>Called to determine whether the current process is permitted to access the specified environment variable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkRead<BR>(FileDescriptor)</TT></TD><TD WIDTH=384>Called to determine whether the current process is permitted to read the file indicated by the <TT>FileDescriptor</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkRead(String)</TT></TD><TD WIDTH=384>Called to determine whether the current process is permitted to read the file by the specified name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkRead(String, Object)</TT></TD><TD WIDTH=384>Called to determine whether the specified file can be read within the given security context.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkSetFactory()</TT></TD><TD WIDTH=384>Called to determine whether the current process is permitted to set the socket or URL stream handler factory.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>boolean checkTopLevelWindow<BR>(Object)</TT>
</TD><TD WIDTH=384>Called to determine whether a top-level window can be displayed without display restrictions (like a warning indicator).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkWrite<BR>(FileDescriptor)</TT></TD><TD WIDTH=384>Called to determine whether the current process can write to the file indicated by the <TT>FileDescriptor</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>checkWrite(String)</TT></TD><TD WIDTH=384>Called to determine whether the current process can write to the file by the specified name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>boolean getInCheck()</TT></TD><TD WIDTH=384>Indicates whether a security check is currently in progress.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Object getSecurityContext()</TT></TD><TD WIDTH=384>Returns an object that contains information about the current execution environment to be used in subsequent security checks.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The implementation of the <TT>SecurityManager</TT> class is really
quite simple. In fact, most of the methods in Table 20.2 throw
only <TT>SecurityException</TT>s. The idea is that if you subclass
<TT>SecurityManager</TT> and install your own version using <TT>System.setSecurityManager()</TT>,
access to all of the resources under the security manager's control
are immediately denied. In fact, this is exactly what the Web
browser does (with some overridden behavior, of course). To prevent
applets from installing their own more lenient security managers,
the runtime system allows the security manager to be set only
once.
<P>
The security manager is prewired into many of Java's classes in
such a way that it cannot be bypassed. For example, before a <TT>Socket</TT>
object can be successfully created, the <TT>Socket</TT> class
checks to see whether a security manager has been set and if so
whether a socket to the specified host and port is allowed.
<BLOCKQUOTE>
<PRE>
SecurityManager security = System.getSecurityManager();
if (security != null) {
    security.checkConnect(address.getHostAddress(), port);
}
</PRE>
</BLOCKQUOTE>
<P>
In addition, calls to the security manager are embedded in classes
or methods that are declared <TT>final</TT> so they cannot be
overridden by subclasses.
<H2><A NAME="AppletsVersusApplications"><FONT SIZE=5 COLOR=#FF0000>
Applets Versus Applications</FONT></A></H2>
<P>
Up to this point, we have focused on the security constraints
used to control the execution of applets. However, Java applets
and applications are handled quite differently in regard to security.
Because applications are explicitly executed and are from a (hopefully)
trusted source, the security constraints imposed on applets are
relaxed for applications. However, applications can still benefit
from the built-in security features of the Java language itself
as already mentioned. Furthermore, because portions of the security
scheme used to monitor applets are controlled by Java classes,
applications can implement their own brand of security, if necessary.
The <TT>ClassLoader</TT> and <TT>SecurityManager</TT> classes
already covered can be subclassed and installed by applications
just as they are by the browser's Java Virtual Machine. A customized
<TT>ClassLoader</TT> could provide a class cache for a networked
application to cut down on the number of calls across a slow network
connection for classes it has already retrieved. Likewise, a subclass
of <TT>SecurityManager</TT> could be used to control what directories
or files they are allowed to work with.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
The security barriers imposed by Java are really quite formidable.
However, Java security is not infallible. In fact, there have
been some well-documented holes and back doors to the system.
But Sun has been quick to answer such claims and has refined the
language, compiler, bytecode verifier, class loader, and security
manager over the last several releases. Likewise, Sun, Netscape,
and Microsoft have also closed security holes in their browsers
related to Java applets over the last several months. In fact,
most of the security concerns that have been uncovered have dealt
with the implementation of the runtime environment in browsers
and not the language itself. By releasing Java and the source
code for its tools to the public domain, Sun has not only allowed
the world to peek into every crack and crevice of Java but has
also been able to rapidly solidify the language.
<P>
The future of security and active content on the Internet will
continue to evolve. With the increase in use of digital signatures
to authenticate the content of data, the security and confidence
of dealing with information will continue to improve. Java can
supplement its security model by also incorporating digital signatures.
Just as the structural integrity of class files are inspected
by the code verifier, it will not be long before a digital signature
may also be embedded within each class file. The end result is
that Web developers and users will be offered yet another level
of control to safely build, retrieve, and run active content on
their systems.
<HR>

<CENTER><P><A HREF="ch19.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch21.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
