<HTML>
<HEAD>
<TITLE>Chapter 22 -- Using the Data Access Objects</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;22</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Using the Data Access Objects</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#OverviewoftheDataAccessObjects">
Overview of the Data Access Objects</A>
<UL>
<LI><A HREF="#GeneratingtheClassFiles">
Generating the Class Files</A>
</UL>
<LI><A HREF="#UsingDBEngineObjects">
Using _DBEngine Objects</A>
<UL>
<LI><A HREF="#UsefulMethods">
Useful Methods</A>
</UL>
<LI><A HREF="#UsingDatabaseObjects">
Using Database Objects</A>
<UL>
<LI><A HREF="#ControllingTransactions">
Controlling Transactions</A>
<LI><A HREF="#OpenRecordset">
OpenRecordset</A>
<LI><A HREF="#Close">
Close</A>
</UL>
<LI><A HREF="#UsingFieldObjects">
Using Field Objects</A>
<LI><A HREF="#UsingRecordsetObjects">
Using Recordset Objects</A>
<UL>
<LI><A HREF="#ReadingRecordsSequentially">
Reading Records Sequentially</A>
<LI><A HREF="#UpdatingRecords">
Updating Records</A>
<LI><A HREF="#DeletingRecords">
Deleting Records</A>
<LI><A HREF="#AddingNewRecords">
Adding New Records</A>
<LI><A HREF="#FindingRecords">
Finding Records</A>
</UL>
<LI><A HREF="#UsingSQL">
Using SQL</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In this chapter you will learn how to use the Microsoft Data Access
Objects (DAO) in your Visual J++ programs. The DAO is an entire
database engine that includes a set of objects and methods capable
of performing just about any database operation you're likely
to need. While the native database to DAO is the Jet engine used
in Microsoft Access, DAO can also be used to access ODBC data
sources. DAO programming could be the topic of an entire book,
so this chapter will only scratch the surface. It will, however,
provide you with sufficient information to get you started, and
it includes examples of reading, updating, deleting, adding, and
searching.
<H2><A NAME="OverviewoftheDataAccessObjects"><FONT SIZE=5 COLOR=#FF0000>
Overview of the Data Access Objects</FONT></A></H2>
<P>
Microsoft's Data Access Objects and Jet Database engine get around
more than the Beach Boys do in that song of theirs. Jet was first
introduced in November, 1992 in Access 1.0. Since then, the Jet
engine and DAO have been used in Access, Visual Basic, Visual
Basic for Applications (including Word and Excel), and Visual
C++. Since DAO is used in so many other Microsoft products, it
should not be surprising that DAO can be useful in your Visual
J++ efforts.
<P>
The relationships among the Data Access Objects are shown in Figure
22.1. This figure does not show inheritance relationships. Instead
it shows container relationships. In other words, from this figure
you can tell that a Database contains recordsets and recordsets
contain Fields.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-1.gif"><B> Figure 22.1 : </B><I>The relationships among Data Access Objects.
</I></A><P>
<P>
As you can see from Figure 22.1, the DAO is made up of a large
number of objects. Because these are ActiveX objects, you will
access them from Visual J++ through Java interfaces. These interfaces
are created with the Java Type Library Wizard.
<H3><A NAME="GeneratingtheClassFiles">
Generating the Class Files</A></H3>
<P>
Before you can use DAO in your Java programs you must first create
the class files that will be linked into your programs. To do
this, select Java Type Library Wizard from the Tools menu in the
Developer Studio. You will be presented with a list of ActiveX
items installed on your system, similar to Figure 22.2. Select
Microsoft DAO 3.0 Object Library and press the OK button. This
will generate Java class files for your use. It will also create
a file named <TT>SUMMARY.TXT</TT>. This file contains a brief
list of each object and method that was generated. The file will
normally be placed in <TT>C:\WINDOWS\JAVA\TRUSTLIB\SUMMARY.TXT</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-2.gif"><B> Figure 22.2 : </B><I>You must run the Java Type Library Wizard to generate class files for DAO.
</I></A><P>
<H2><A NAME="UsingDBEngineObjects"><FONT SIZE=5 COLOR=#FF0000>
Using _DBEngine Objects</FONT></A></H2>
<P>
Although there are more than 30 DAO interfaces available to you,
you do not need to know or use all of them. In fact, in this chapter
you will focus on only a handful of them. Even so, you will be
able to add powerful database access to your Java programs.
<P>
The first object you need to know about is the <TT>_DBEngine</TT>
interface. This object is at the top of the DAO hierarchy and
is the first object you will construct when writing a program
that uses DAO. To construct a <TT>_DBEngine</TT> object you should
use the method <TT>DBEngine_create</TT> in the class <TT>dao_dbengine</TT>.
This class is shown in Listing 22.1 and is also provided with
Visual J++.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although <TT>dao_dbengine.java</TT> is included with Visual J++, it is installed only when you install the DAOSample applet. To install DAOSample, open the InfoView. First select Samples, then Microsoft Samples, and finally DAOSample. Follow the 
instructions that appear in the right pane of the InfoView.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 22.1. dao_dbengine.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
// Create a DAO DBEngine object with the license

import dao3032._DBEngine;
import com.ms.com.*;

public class dao_dbengine
{
    // The static public method creates the DBEngine object
    static public _DBEngine create()
    {
        // The return value
        _DBEngine result;

        // Create the License Manager object
        ILicenseMgr mgr = new LicenseMgr();

        // Use the License Manager to create the DBEngine
        result = (_DBEngine) mgr.createWithLic(

            // The license key for the DAO DBEngine
            &quot;mjgcqcejfchcijecpdhckcdjqigdejfccjri&quot;,

            // The CLSID for the DAO DBEngine
            &quot;{00025E15-0000-0000-C000-000000000046}&quot;,

            // The aggregation IUnknown* punkOuter
            null,

            // The ctxFlag to create in inproc server
            ComContext.INPROC_SERVER
            );

        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>DBEngine_create</TT> method uses the <TT>Java LicenseMgr</TT>
class to construct the new COM (Component Object Model) component.
To construct a <TT>_DBEngine</TT> object in your code, do the
following:
<BLOCKQUOTE>
<PRE>
_DBEngine dbengine = dao_dbengine.create();
</PRE>
</BLOCKQUOTE>
<H3><A NAME="UsefulMethods">
Useful Methods</A></H3>
<P>
There are many methods available for use with <TT>_DBEngine</TT>
objects; the following sections describe the most useful.
<H4>OpenDatabase</H4>
<P>
This method is used to open a new database. Its signature is as
follows:
<BLOCKQUOTE>
<PRE>
Database OpenDatabase(String dbname, Variant exclusive,
    Variant readonly, Variant source);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>dbname</TT> parameter is the filename of the database
being opened. The remaining three parameters are each variants.
The <TT>Variant</TT> class is used to pass data to COM objects
and each <TT>Variant</TT> object can be used to hold any type
of data-string, numeric, or Boolean. The exclusive parameter needs
to hold a Boolean value indicating whether this program requires
exclusive access to the database. The read-only parameter is a
Boolean indicating whether the database is to be opened in read-only
or read-write mode. The source parameter holds string data such
as <TT>PWD=ROSEBUD</TT> that can be used when opening an ODBC
data source. As an example of using <TT>OpenDatabase</TT>, consider
the following:
<BLOCKQUOTE>
<PRE>
// create Variants that will hold parameters that will be
// passed to OpenDatabase
Variant var1 = new Variant();
Variant var2 = new Variant();
Variant var3 = new Variant();

// set parameters for call to OpenDatabase
var1.putBoolean(false);
var2.putBoolean(false);
var3.putString(&quot;&quot;);

// Open the database for non-exclusive, read-write access
Database db = dbengine.OpenDatabase(filename, var1, var2, var3);
</PRE>
</BLOCKQUOTE>
<P>
In this case, three new variants are constructed. The first two
are set to false. The third is set to hold an empty string. <TT>OpenDatabase</TT>
is then called with this parameter and the database is opened
in non-exclusive, read-write mode.
<H4>getVersion</H4>
<P>
The <TT>getVersion</TT> method does not require any parameters
and will return a string representing the version of the Jet engine
in use. Table 22.1 shows the various Jet engine versions and the
versions of other Microsoft products with which they were released.
<BR>
<P>
<CENTER><B>Table 22.1. The versions of the Jet engine and the
products they were released with.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=115><I>Engine Version</I></TD><TD WIDTH=86><CENTER><I>Access</I></CENTER>
</TD><TD WIDTH=96><CENTER><I>Visual Basic</I></TD><TD WIDTH=86><CENTER><I>Excel</I></CENTER>
</TD><TD WIDTH=96><CENTER><CENTER><I>Visual C++</I></CENTER></TD><TD WIDTH=96><CENTER><CENTER><I>Visual J++</I></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>(1992)</TD><TD WIDTH=86><CENTER>1.0</CENTER>
</TD><TD WIDTH=96><CENTER>&nbsp;</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER></TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>(1993)</TD><TD WIDTH=86><CENTER>1.1</CENTER>
</TD><TD WIDTH=96><CENTER>3.0</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER></TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>(1994)</TD><TD WIDTH=86><CENTER>2.0</CENTER>
</TD><TD WIDTH=96><CENTER>&nbsp;</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER></TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>2.5 (1995)</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=96><CENTER>4.0 (16-bit)</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER></TD><TD WIDTH=96><CENTER><CENTER>&nbsp;</CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>3.0 (1995)</TD><TD WIDTH=86><CENTER>7.0</CENTER>
</TD><TD WIDTH=96><CENTER>4.0  (32-bit)</TD><TD WIDTH=86><CENTER>7.0</CENTER>
</TD><TD WIDTH=96><CENTER><CENTER>4.0</CENTER></TD><TD WIDTH=96><CENTER><CENTER>1.0</CENTER>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="UsingDatabaseObjects"><FONT SIZE=5 COLOR=#FF0000>
Using Database Objects</FONT></A></H2>
<P>
You have already seen how a <TT>Database</TT> object can be created
with the <TT>OpenDatabase</TT> method of <TT>_DBEngine</TT>. In
the following sections you learn about the most useful methods
for using database objects.
<H3><A NAME="ControllingTransactions">
Controlling Transactions</A></H3>
<P>
The three methods <TT>BeginTrans</TT>, <TT>CommitTrans</TT>, and
<TT>Rollback</TT> are used to manage transactions. Transactions
are useful because they assist in managing the integrity of a
database. Use <TT>BeginTrans</TT> to indicate the start of a transaction
block. Then use <TT>CommitTrans</TT> to commit the database activity
since the transaction began, or use <TT>Rollback</TT> to undo
the activity. These methods have the following signatures:
<BLOCKQUOTE>
<PRE>
void BeginTrans();
void CommitTrans();
void Rollback();
</PRE>
</BLOCKQUOTE>
<P>
Why would you want to do this? By thinking of your database activity
in terms of transactions instead of automatic events (inserts,
updates, and deletes) you can prevent some classes of data problems.
For example, suppose you are writing an order entry system that
will be used to take online orders. When a customer accesses your
Web page he fills in a spreadsheet with a column for the product
code and the quantity needed. He can order as many items as he
desires but must press a Submit button before the order is sent
to the shipping department.
<P>
If a customer indicates he wants 100 units of product ABC the
program should check the database for stock on hand and reduce
the available quantity by 100. When the customer presses the Submit
button, the transaction is committed to the database. However,
if the customer selects the Cancel button instead of Submit, the
transaction can be rolled back.
<H3><A NAME="OpenRecordset">
OpenRecordset</A></H3>
<P>
The <TT>OpenRecordset</TT> method creates a recordset. A <I>recordset</I>
is a collection of records. Recordset objects are among the most
important in DAO and will be discussed in detail in the section
&quot;Using Recordset Objects&quot; later in this chapter. The
signature for <TT>OpenRecordset</TT> is as follows:
<BLOCKQUOTE>
<PRE>
Recordset OpenRecordset(String source, Variant type,
    Variant options);
</PRE>
</BLOCKQUOTE>
<P>
The source parameter can hold either the name of the table in
the database or an SQL statement that returns a set of rows. The
type parameter must hold one of the following values:
<UL>
<LI><TT>dbOpenTable</TT>
<LI><TT>dbOpenDynaset</TT>
<LI><TT>dbOpenSnapshot</TT>
</UL>
<P>
Each of these parameters indicates a different type of recordset.
A table recordset corresponds to a single table in the underlying
database. Records may be added, updated, or deleted in a table
recordset. A dynaset recordset is the result of a query and may
include columns from more than one table. Records may be added,
updated, or deleted in a dynaset. Finally, a snapshot recordset
is a static copy of the records at the moment the recordset was
created. A snapshot may contain fields from more than one table
but additions, updates, and deletions are not allowed.
<P>
The options parameter can hold any of the values shown in Table
22.2.<BR>
<P>
<CENTER><B>Table 22.2. Valid values for the options parameter
to OpenRecordset.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=142><I>Value</I></TD><TD WIDTH=450><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbAppendOnly</TT></TD><TD WIDTH=450>Records may be added but not updated or deleted. Applies only to <TT>dbOpenDynaset</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbConsistent</TT></TD><TD WIDTH=450>When using a recordset created from joined tables only those fields not involved in the join can be updated. Applies only to <TT>dbOpenDynaset</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbDenyRead</TT></TD><TD WIDTH=450>Prevents other users from reading any records in the recordset. Applies only to <TT>dbOpenTable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbDenyWrite</TT></TD><TD WIDTH=450>Prevents other users from writing to any records in the recordset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbForwardOnly</TT></TD><TD WIDTH=450>The recordset only supports the <TT>MoveNext</TT> movement method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbInconsistent</TT></TD><TD WIDTH=450>When using a recordset created from joined tables all fields, including those involved in the join, can be updated. Applies only to <TT>dbOpenDynaset</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbReadOnly</TT></TD><TD WIDTH=450>No changes can be made to the recordset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbSeeChanges</TT></TD><TD WIDTH=450>Generates an error if another program attempts to make a change to the record that is being edited.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=142><TT>dbSQLPassThrough</TT></TD><TD WIDTH=450>When using an ODBC data source, passes SQL code directly to the server for execution.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of creating a table recordset consider Listing 22.2.
First a database is opened. Then, two variants, <TT>var4</TT>
and <TT>var5</TT>, are constructed. The values <TT>dbOpenTable</TT>
and <TT>dbReadOnly</TT> are placed into the variants and are passed
to <TT>OpenRecordset</TT>. The name Programmer is also passed
to <TT>OpenRecordset</TT>. This will cause the Programmer table
to be opened in read-only mode.
<HR>
<BLOCKQUOTE>
<B>Listing 22.2. Opening a table recordset.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
// create Variants that will hold parameters that will be
// passed to OpenDatabase
Variant var1 = new Variant();
Variant var2 = new Variant();
Variant var3 = new Variant();

// set parameters for call to OpenDatabase
var1.putBoolean(false);
var2.putBoolean(false);
var3.putString(&quot;&quot;);

// Open the database for non-exclusive access
Database db = dbengine.OpenDatabase(filename, var1, var2, var3);

// create Variants that will hold parameters that will be
// passed to OpenDatabase
Variant var4 = new Variant();
Variant var5 = new Variant();

var4.putShort(Constants.dbOpenTable);
var5.putShort(Constants.dbReadOnly);

// create the recordset
recordset = db.OpenRecordset(&quot;Programmer&quot;, var4, var5);
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Close">
Close</A></H3>
<P>
This method is used to close a database object. It requires no
parameters and has no return value.
<H2><A NAME="UsingFieldObjects"><FONT SIZE=5 COLOR=#FF0000>
Using Field Objects</FONT></A></H2>
<P>
The <TT>Field</TT> object is used to represent the individual
columns in a database table. Although there are many methods available
for use with <TT>Field</TT> objects, the two you will use most
frequently are <TT>putValue</TT> and <TT>getValue</TT>. These
methods are used to move data into and out of <TT>Field</TT> objects,
respectively. The signatures of these methods are as follows:
<BLOCKQUOTE>
<PRE>
Variant getValue();
void putValue(Variant);
</PRE>
</BLOCKQUOTE>
<P>
As an example of how to retrieve a value from a <TT>Field</TT>
object, consider the following:
<BLOCKQUOTE>
<PRE>
Variant value = new Variant();
value = salaryField.getValue();
int salary = value.toInt();
</PRE>
</BLOCKQUOTE>
<P>
First, a new <TT>Variant</TT> object is constructed. The <TT>getValue</TT>
method is then used to retrieve the value of <TT>salaryField</TT>.
Because <TT>value</TT> is a variant, it is converted to a more
useful data type. In this case, <TT>value.toInt</TT> is used to
load the integer variable, <TT>salary</TT>.
<P>
Moving data in the opposite direction-into a <TT>Field</TT> object-can
be done in a similar manner using <TT>putValue</TT>. For example,
the following code will double the value stored in the salary
field:
<BLOCKQUOTE>
<PRE>
Variant value = new Variant();
value.putInt(oldSalary * 2);
salaryField.putValue(value);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="UsingRecordsetObjects"><FONT SIZE=5 COLOR=#FF0000>
Using Recordset Objects</FONT></A></H2>
<P>
In the discussion of the <TT>Database</TT> object, you were introduced
to recordsets. In this section you learn how to use a recordset
to view, add, update, delete, and find records. The following
sections describe how to perform some of the most common operations
on recordsets.
<H3><A NAME="ReadingRecordsSequentially">
Reading Records Sequentially</A></H3>
<P>
To move through a recordset you can use the <TT>MoveFirst</TT>,
<TT>MoveNext</TT>, <TT>MovePrevious</TT>, and <TT>MoveLast</TT>
methods whose signatures are as follows:
<BLOCKQUOTE>
<PRE>
void MoveFirst();
void MoveNext();
void MovePrevious();
void MoveLast();
</PRE>
</BLOCKQUOTE>
<P>
Each of these methods will reposition the current record of the
recordset. As an example of how these methods are used, consider
Listing 22.3. This example iterates through all of the rows in
the Programmer table of the supplied Access database. Information
about each programmer is displayed in a <TT>TextArea</TT>, as
shown in Figure 22.3.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-3.gif"><B> Figure 22.3 : </B><I>The EX22A example displays information about each programmer in the database.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 22.3. The class EX22A demonstrates moving through a
recordset sequentially.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.net.*;
import dao_dbengine;
import dao3032.*;
import com.ms.com.Variant;

public class EX22A extends Applet
{
    Recordset recordset;
    TextArea output;
    Database db;

    public void init()
    {
        resize(500, 400);
        output = new TextArea(20, 50);
        add(output);
    }

    public void start()
    {
        OpenDatabase();
    }

    public void stop()
    {
        // Close the recordset and database
        recordset.Close();
        db.Close();
    }

    private boolean OpenDatabase()
    {
        URL dbURL;
        try {
            // otherwise generate it relative to the applet
            dbURL = new java.net.URL(getDocumentBase(), &quot;sample.mdb&quot;);
        }
        catch(Exception e) {
            showStatus(&quot;Error: &quot; + e.getMessage());
            return false;
        }

        // strip &quot;file:/&quot; from dbURL
        String filename = dbURL.getFile().substring(1);

        // create the database engine
        _DBEngine dbengine = dao_dbengine.create();

        // create Variants that will hold parameters that will be
        // passed to OpenDatabase
        Variant var1 = new Variant();
        Variant var2 = new Variant();
        Variant var3 = new Variant();

        // set parameters for call to OpenDatabase
        var1.putBoolean(false);
        var2.putBoolean(false);
        var3.putString(&quot;&quot;);

        // Open the database for non-exclusive access
        db = dbengine.OpenDatabase(filename, var1, var2, var3);

        // create Variants that will hold parameters that will be
        // passed to OpenDatabase
        Variant var4 = new Variant();
        Variant var5 = new Variant();

        var4.putShort(Constants.dbOpenTable);
        var5.putShort(Constants.dbReadOnly);

        // create the recordset
        recordset = db.OpenRecordset(&quot;Programmer&quot;, var4, var5);

        // display all the records in this dynaset
        DisplayAllRecords();

        return true;
    }

    private void DisplayAllRecords()
    {
        // create variants and assign the names of each column
        Variant varFirstName = new Variant();
        varFirstName.putString(&quot;FirstName&quot;);

        Variant varLastName = new Variant();
        varLastName.putString(&quot;LastName&quot;);

        Variant varSalary = new Variant();
        varSalary.putString(&quot;Salary&quot;);

        Variant varKnowsJava = new Variant();
        varKnowsJava.putString(&quot;KnowsJava&quot;);

        Variant varJobTitle = new Variant();
        varJobTitle.putString(&quot;JobTitle&quot;);

        // determine how many records in the recordset
        int count = recordset.getRecordCount();

        // position recordset at the first record
        recordset.MoveFirst();

        // loop through the recordset, displaying each record
        for(int recNum = 0; recNum &lt; count; recNum++)
        {
            // get the fields in this recordset
            Fields fields = recordset.getFields();
            _Field fld;

            // create a Variant that will hold each the value
            // read from each column
            Variant value;

            // get the LastName field
            fld = fields.getItem(varLastName);
            // get its value
            value = fld.getValue();
            // display the value
            output.appendText(value.toString() + &quot;, &quot;);

            // get the FirstName field
            fld = fields.getItem(varFirstName);
            // get its value
            value = fld.getValue();
            // display the value
            output.appendText(value.toString() + &quot;\r\n&quot;);

            // get the JobTitle field
            fld = fields.getItem(varJobTitle);
            // get its value
            value = fld.getValue();
            // display the value
            output.appendText(&quot;\t&quot; + value.toString() + &quot;\r\n&quot;);

            // get the Salary field
            fld = fields.getItem(varSalary);
            // get its value
            value = fld.getValue();
            // display the value
            output.appendText(&quot;\t&quot; + value.toString() + &quot;\r\n&quot;);

            // get the KnowsJava field
            fld = fields.getItem(varKnowsJava);
            // get its value
            value = fld.getValue();
            // display the value
            Boolean knowsJava = new Boolean (value.toBoolean());
            output.appendText(&quot;\tKnows Java: &quot; + knowsJava.toString() + &quot;\r\n&quot;);

            recordset.MoveNext();
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>init</TT> method of class <TT>EX22A</TT> simply resizes
the screen and then places a <TT>TextArea</TT> component on the
screen. The <TT>start</TT> method invokes the <TT>OpenDatabase</TT>
method. <TT>OpenDatabase</TT> constructs a URL from the document
base and name of the Access database file to be opened. Next,
<TT>dao_dbengine.create</TT> is used to create the database engine.
The database is opened using <TT>OpenDatabase</TT> and three variants.
Finally, the Programmer table is opened as a table recordset in
read-only mode. The <TT>DisplayAllRecords</TT> method is then
called to display the record contents.
<P>
<TT>DisplayAllRecords</TT> begins with a series of lines such
as the following:
<BLOCKQUOTE>
<PRE>
Variant varFirstName = new Variant();
varFirstName.putString(&quot;FirstName&quot;);
</PRE>
</BLOCKQUOTE>
<P>
These lines create a variant variable for each column in the Programmer
table and then store the name of the column in the variant. After
each of the variants is created, the number of records in the
recordset is retrieved with <TT>getRecordCount</TT>. The <TT>getRecordCount</TT>
method will always return the correct number of records in a table-type
recordset. For a dynaset or snapshot, <TT>getRecordCount</TT>
will return the correct value only after all records in the set
have been retrieved.
<P>
The recordset is initially positioned on the first record with
<TT>MoveFirst</TT>. At this point a loop begins that will iterate
through each of the records in the recordset based on the quantity
returned by <TT>getRecordCount</TT>. Each time through the loop
the contents of the row will be displayed. In order to get at
the fields stored in a recordset it is necessary to use the <TT>getFields</TT>
method. In Listing 22.3 this is done as follows:
<BLOCKQUOTE>
<PRE>
Fields fields = recordset.getFields();
</PRE>
</BLOCKQUOTE>
<P>
This will create a collection of fields. To get at an individual
item within the collection, use the <TT>getItem</TT> method. In
Listing 22.3 the contents of the <TT>LastName</TT> field are retrieved
with the following code:
<BLOCKQUOTE>
<PRE>
// get the LastName field
fld = fields.getItem(varLastName);
// get its value
value = fld.getValue();
// display the value
output.appendText(value.toString() + &quot;, &quot;);
</PRE>
</BLOCKQUOTE>
<P>
The method <TT>fields.getItem</TT> is passed the variant that
contains the string <TT>LastName</TT>. This will cause <TT>fld</TT>
to contain a reference to the specific field that contains data
from the LastName column of the database. Next, <TT>fld.getValue</TT>
is used to retrieve the value of this field and place it in the
variant <TT>value</TT>. Finally, <TT>value.toString</TT> is used
to convert the variant into a string that is passed to <TT>appendText</TT>.
This causes the contents of the LastName column to be added to
the TextArea on the applet.
<P>
After similar code is repeated for each of the columns in the
database-FirstName, LastName, JobTitle, Salary, and KnowsJava-the
<TT>MoveNext</TT> method is used to select a new current record.
After the user closes the applet, the <TT>stop</TT> method is
invoked and the recordset and database are closed.
<P>
The <TT>MoveLast</TT> and <TT>MovePrevious</TT> methods work in
an analogous manner. If you need to move backward through a recordset,
you can use these methods instead of <TT>MoveFirst</TT> and <TT>MoveNext</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You should notice from this example that it is necessary to use the following three import statements:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import dao_dbengine;<BR>
import dao3032.*;<BR>
import com.ms.com.Variant;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
These lines import the <TT>dao_dbengine</TT> class described earlier in the chapter, the DAO objects generated by the Java Type Library Wizard, and the <TT>Variant</TT> class that is used with all COM objects.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="UpdatingRecords">
Updating Records</A></H3>
<P>
Before the contents of a record can be updated with new values,
the record must be placed in edit mode. This is done with the
<TT>Edit</TT> method. Once in edit mode you can use the <TT>Resultset.getFields</TT>
and the <TT>_Field.putValue</TT> methods to alter the values in
a record. When the desired changes have been made, the record
can be updated with the <TT>Update</TT> method. After a record
is updated it is automatically taken out of edit mode. If instead
of updating a record you need to take a record out of edit mode
without committing any changes to the record, you can use <TT>CancelUpdate</TT>.
The signatures of these new methods are as follows:
<BLOCKQUOTE>
<PRE>
void Edit();
void Update();
void CancelUpdate();
</PRE>
</BLOCKQUOTE>
<P>
As an example of how to update the values in a record, consider
the <TT>GiveBonuses</TT> method shown in Listing 22.4. This method
is from the example <TT>EX22B</TT>, which is provided on the CD-ROM
that accompanies this book. The <TT>GiveBonuses</TT> method is
similar to <TT>DisplayAllRecords</TT> from the previous listing
in that it uses <TT>getRecordCount</TT>, <TT>MoveFirst</TT>, and
<TT>MoveNext</TT> to loop through the records in a resultset.
However, in this example, each programmer who knows Java will
have his or her salary doubled.
<HR>
<BLOCKQUOTE>
<B>Listing 22.4. Updating the salary of all Java programmers in
the database.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void GiveBonuses()
{
    // determine how many records in the recordset
    int count = recordset.getRecordCount();

    // create a variant for each column
    Variant varSalary = new Variant();
    Variant varKnowsJava = new Variant();

    // set the name of each column
    varSalary.putString(&quot;Salary&quot;);
    varKnowsJava.putString(&quot;KnowsJava&quot;);

    // position recordset at the first record
    recordset.MoveFirst();

    // loop through the recordset, displaying each record
    for(int recNum = 0; recNum &lt; count; recNum++)
    {
        // get the fields in this recordset
        Fields fields = recordset.getFields();
        _Field fld;

        // create a Variant that will hold each the value
        // read from each column
        Variant value;

        // get the KnowsJava field
        fld = fields.getItem(varKnowsJava);
        // get its value
        value = fld.getValue();

        // if the programmer knows Java, give a good raise
        if (value.toBoolean() == true)
        {
            // get the Salary field
            fld = fields.getItem(varSalary);
            // get its value
            value = fld.getValue();
            // store the salary
            int salary = value.toInt();

            // double the programmer's salary
            int newSalary = salary * 2;

            // put the recordset into edit mode
            recordset.Edit();

            // assign the new salary to the current record
            value.putInt(newSalary);
            fld.putValue(value);

            // update the recordset
            recordset.Update();

            // display the salary change
            DisplayRaise(fields, salary, newSalary);
        }
        else
            DisplayNoRaise(fields);

        recordset.MoveNext();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Inside the <TT>for</TT> loop of <TT>GiveBonuses</TT> the value
of the <TT>KnowsJava</TT> field is retrieved and converted to
a Boolean value. If this value is true, the salary field is retrieved
from the database and stored in the integer variable <TT>salary</TT>.
This value is doubled and then stored in <TT>newSalary</TT>. The
actual updating of the record in the database takes place with
the following lines:
<BLOCKQUOTE>
<PRE>
recordset.Edit();
value.putInt(newSalary);
fld.putValue(value);
recordset.Update();
</PRE>
</BLOCKQUOTE>
<P>
Depending on whether or not the programmer received a raise, either
the method <TT>DisplayRaise</TT> or <TT>DisplayNoRaise</TT> will
be called. These methods are as follows:
<BLOCKQUOTE>
<PRE>
private void DisplayRaise(Fields fields, int oldSalary, int newSalary)
{
    String firstName = GetField(fields, &quot;FirstName&quot;);
    String lastName  = GetField(fields, &quot;LastName&quot;);

    output.appendText(firstName + &quot; &quot; + lastName +
            &quot; got a raise from &quot; +
            String.valueOf(oldSalary) +
            &quot; to &quot; + String.valueOf(newSalary) + &quot;\r\n&quot;);
}

private void DisplayNoRaise(Fields fields)
{
    String firstName = GetField(fields, &quot;FirstName&quot;);
    String lastName  = GetField(fields, &quot;LastName&quot;);

    output.appendText(firstName + &quot; &quot; + lastName +
            &quot; didn't get a raise.\r\n&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
Rather than construct and manipulate their own variant variables,
each of these methods calls the <TT>GetField</TT> method. <TT>GetField</TT>
was written as follows:
<BLOCKQUOTE>
<PRE>
private String GetField(Fields fields, String fldName)
{
    // create a new Variant using fldName
    Variant var = new Variant();
    var.putString(fldName);

    // get the field
    _Field fld = fields.getItem(var);
    // get its value
    Variant value = fld.getValue();

    return value.toString();
}
</PRE>
</BLOCKQUOTE>
<P>
<TT>GetField</TT> works on a generic <TT>Fields</TT> container
and field name. A variant is constructed and set to hold the field
name. The corresponding field is then retrieved from the <TT>Fields</TT>
container and its value is then returned as a string.
<P>
The result of running <TT>EX22B</TT> is shown in Figure 22.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-4.gif"><B> Figure 22.4 : </B><I>Example EX22B doubles  the salary of all Java programmers.
</I></A><P>
<H3><A NAME="DeletingRecords">
Deleting Records</A></H3>
<P>
Deleting a record is as simple as calling the <TT>Delete</TT>
method when the record to be deleted is the current record in
the recordset. For example, Listing 22.5 shows the <TT>FireProgrammers</TT>
method from the example <TT>EX22C</TT>, which is included on the
CD-ROM. This method loops through all of the programmers in the
Programmer table examining the value of the KnowsJava column.
When a programmer is found who does not know Java, he is deleted
from the database.
<HR>
<BLOCKQUOTE>
<B>Listing 22.5. EX22C illustrates how to fire anyone who doesn't
know Java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void FireProgrammers()
{
    // determine how many records in the recordset
    int count = recordset.getRecordCount();

    // create a variant for the KnowsJava column
    Variant varKnowsJava = new Variant();
    varKnowsJava.putString(&quot;KnowsJava&quot;);

    // position recordset at the first record
    recordset.MoveFirst();

    // loop through the recordset, displaying each record
    for(int recNum = 0; recNum &lt; count; recNum++)
    {
        // get the fields in this recordset
        Fields fields = recordset.getFields();
        _Field fld;

        // create a Variant that will hold the values
        // read from the columns
        Variant value;

        // get the KnowsJava field
        fld = fields.getItem(varKnowsJava);
        // get its value
        value = fld.getValue();

        // fire the programmer if he doesn't know Java
        if (value.toBoolean() == false)
        {
            // display a message about the fired programmer
            DisplayFiring(fields);

            // delete the current record
            recordset.Delete();
        }

        recordset.MoveNext();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>Delete</TT> method does not automatically advance the
recordset to the next record. It is still necessary to use <TT>MoveNext</TT>
to advance to the next record in the set. The results of running
<TT>EX22C</TT> are shown in Figure 22.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-5.gif"><B> Figure 22.5 : </B><I>Example EX22C fires any programmers who do not know Java.
</I></A><P>
<H3><A NAME="AddingNewRecords">
Adding New Records</A></H3>
<P>
Adding a record is similar to editing a record. However, instead
of placing the database into edit mode with the <TT>Edit</TT>
method, the database is placed into add mode with the <TT>AddNew</TT>
method. The example <TT>EX22D</TT>, provided on the CD-ROM, shows
how to add a new programmer to the database. Listing 22.6 shows
the <TT>AddNewHire</TT> method from the <TT>EX22D</TT> class.
<HR>
<BLOCKQUOTE>
<B>Listing 22.6. EX22D shows how to add a new programmer to the
database.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void AddNewHire()
{
    // create a variant for each column
    Variant varFirstName = new Variant();
    Variant varLastName = new Variant();
    Variant varSalary = new Variant();
    Variant varKnowsJava = new Variant();
    Variant varJobTitle = new Variant();

    // set the name of each column
    varFirstName.putString(&quot;FirstName&quot;);
    varLastName.putString(&quot;LastName&quot;);
    varSalary.putString(&quot;Salary&quot;);
    varKnowsJava.putString(&quot;KnowsJava&quot;);
    varJobTitle.putString(&quot;JobTitle&quot;);

    // tell the recordset its about to get a new record
    recordset.AddNew();

    // retrieve the fields for this recordset
    Fields fields = recordset.getFields();
    _Field fld;

    // create a Variant to hold temporary values
    Variant value = new Variant();

    // set the FirstName field
    fld = fields.getItem(varFirstName);
    value.putString(&quot;Napoleon&quot;);
    fld.putValue(value);

    // set the LastName field
    fld = fields.getItem(varLastName);
    value.putString(&quot;Solo&quot;);
    fld.putValue(value);

    // set the Salary field
    fld = fields.getItem(varSalary);
    value.putInt(63000);
    fld.putValue(value);

    // set the KnowsJava field
    fld = fields.getItem(varKnowsJava);
    value.putBoolean(true);
    fld.putValue(value);

    // set the JobTitle field
    fld = fields.getItem(varJobTitle);
    value.putString(&quot;Lead Programmer&quot;);
    fld.putValue(value);

    // commit the new record to the recordset
    recordset.Update();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In order to add a new programmer, a variant is created for each
column in the database and <TT>AddNew</TT> is used to put the
database into add mode. The fields in the recordset are retrieved
with <TT>getFields</TT>. Then, for each column in the database
the following actions are taken:
<UL>
<LI>The field is retrieved by using the variant containing the
field name.
<LI>The <TT>value</TT> variant is loaded with the desired value.
<LI><TT>putValue</TT> is used to put the value into the field.
</UL>
<P>
Finally, <TT>Update</TT> is used is to commit the new record.
If an error had occurred or this was an interactive method and
the user changed his mind, <TT>CancelUpdate</TT> could be used
to cancel the new record. The results of running <TT>EX22D</TT>
are shown in Figure 22.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-6.gif"><B> Figure 22.6 : </B><I>Example EX22D shows how to add a new programmer to the database.
</I></A><P>
<H3><A NAME="FindingRecords">
Finding Records</A></H3>
<P>
Sometimes you've created a Resultset and need to scan through
it looking for one or more records that match certain criteria.
The DAO engine provides a set of methods for doing exactly this.
To find the first record that meets your criteria, you can use
the <TT>FindFirst</TT> method. Additionally, there are also <TT>FindNext</TT>,
<TT>FindPrevious</TT>, and <TT>FindLast</TT> methods. These methods
have the following signatures:
<BLOCKQUOTE>
<PRE>
void FindFirst(String);
void FindNext(String);
void FindPrevious(String);
void FindLast(String);
</PRE>
</BLOCKQUOTE>
<P>
The string parameter passed to these methods is the search criteria.
For example, the following two examples show valid search criteria:
<BLOCKQUOTE>
<PRE>
FindFirst(&quot;Salary &lt; 50000&quot;);
FindLast(&quot;FirstName = 'Savannah'&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In order to determine whether a record was found that matched
the search criteria, use the method <TT>getNoMatch</TT> whose
signature is as follows:
<BLOCKQUOTE>
<PRE>
boolean getNoMatch();
</PRE>
</BLOCKQUOTE>
<P>
This method will return true if no match was found, or false otherwise.
By combining these methods, it is possible to write code that
will loop through a resultset finding all records that match the
desired criteria. For example, consider the following <TT>FindProgrammers</TT>
method:
<BLOCKQUOTE>
<PRE>
private void FindProgrammers()
{
    // setup the search criteria
    String criteria = &quot;Salary &lt; 50000&quot;;

    // find the first matching record
    recordset.FindFirst(criteria);

    // while there are matching records keep going
    while (recordset.getNoMatch() == false)
    {
        // display the programmer's name
        DisplayProgrammer();

        // and search for another one
        recordset.FindNext(criteria);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This method is from the sample class <TT>EX22E</TT>, which is
included on the accompanying CD-ROM. <TT>FindProgrammers</TT>
searches for all programmers who make less than the specified
salary. For each record that matches, the <TT>DisplayProgrammer</TT>
method will be called. This method displays information about
the underpaid programmers, as shown in Figure 22.7.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-7.gif"><B> Figure 22.7 : </B><I>Example EX22E identifies underpaid programmers.
</I></A><P>
<P>
The <TT>FindFirst</TT> and other Find methods work only when the
database is opened as a dynaset. This means the <TT>OpenDatabase</TT>
method needs to specify <TT>dbOpenDynaset</TT> instead of <TT>dbOpenTable</TT>.
This is done with the following code fragment:
<BLOCKQUOTE>
<PRE>
Variant var4 = new Variant();
Variant var5 = new Variant();

var4.putShort(Constants.dbOpenDynaset);
var5.putShort(Constants.dbEditAdd);

// create the recordset
recordset = db.OpenRecordset(&quot;Programmer&quot;, var4, var5);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="UsingSQL"><FONT SIZE=5 COLOR=#FF0000>
Using SQL</FONT></A></H2>
<P>
One of the simplest ways to manipulate your database is with SQL.
SQL is a language that was designed specifically for querying
and modifying relational databases. Fortunately, DAO supports
the use of SQL. You can use SQL statements with DAO in the following
two ways:
<UL>
<LI>As a parameter to <TT>OpenRecordset</TT>.
<LI>As a parameter to the <TT>Execute</TT> method in the <TT>Database</TT>
class.
</UL>
<P>
In earlier examples in this chapter you passed the name of the
table to be opened to <TT>OpenRecordset</TT>. For example, the
following was used to open the Programmer table:
<BLOCKQUOTE>
<PRE>
recordset = db.OpenRecordset(&quot;Programmer&quot;, var4, var5);
</PRE>
</BLOCKQUOTE>
<P>
Instead of passing the name of a table, you can pass an SQL statement.
This means you can do the following:
<BLOCKQUOTE>
<PRE>
recordset=db.OpenRecordset(&quot;select * from Programmer&quot;,var4,var5);
</PRE>
</BLOCKQUOTE>
<P>
Because this SQL statement selects all rows, the result set it
creates will contain the same rows as the result set created by
using the table name. However, you could include any valid SQL
<TT>where</TT> clause to qualify the <TT>select</TT> statement.
Because an SQL statement creates a dynaset, you need to pass <TT>dbOpenDynaset</TT>
in the first variant passed to <TT>OpenRecordset</TT>. This can
be done as follows:
<BLOCKQUOTE>
<PRE>
Variant var1 = new Variant();
Variant var2 = new Variant();
var1.putShort(Constants.dbOpenDynaset);
var2.putShort(Constants.dbEditAdd);

// create the recordset
recordset=db.OpenRecordset(&quot;select * from Programmer&quot;,var1,var2);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The SQL language is a complex subject on its own. Therefore, this chapter doesn't attempt to teach SQL. For a thorough introduction to SQL, your best bet is <I>Understanding the New SQL: A Complete Guide</I> (1993) by Jim Melton and Alan Simon.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
SQL has other uses beyond just creating a record set. Sometimes
you just want to update rows in the database, delete a row, or
add a row. To do this you can use the <TT>Execute</TT> method
of the <TT>Database</TT> class. The signature of the <TT>Execute</TT>
method is as follows:
<BLOCKQUOTE>
<PRE>
void Execute(String sqlStr, Variant options);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>sqlStr</TT> parameter holds a valid SQL statement; the
<TT>options</TT> parameter is used to specify one of the values
in Table 22.3.<BR>
<P>
<CENTER><B>Table 22.3. Valid values for the options parameter
to Execute.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=130><I>Value</I></TD><TD WIDTH=450><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>dbConsistent</TT></TD><TD WIDTH=450>When using a recordset created from joined tables, only those fields not involved in the join can be updated.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>dbDenyWrite</TT></TD><TD WIDTH=450>Prevents other users from writing to any records in the recordset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>dbFailOnError</TT></TD><TD WIDTH=450>Rolls back any updates if an error occurs.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>dbInconsistent</TT></TD><TD WIDTH=450>When using a recordset created from joined tables, all fields, including those involved in the join, can be updated.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>DbSeeChanges</TT></TD><TD WIDTH=450>Generates an error if another program attempts to make a change to  a record that is being edited.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=130><TT>dbSQLPassThrough</TT></TD><TD WIDTH=450>When using an ODBC data source, it passes SQL code directly to the server for execution.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of using <TT>Execute</TT>, consider the following,
which sets every programmer's salary to $100,000:
<BLOCKQUOTE>
<PRE>
Variant var = new Variant();
var.putShort(Constants.dbFailOnError);
db.Execute(&quot;update Programmer set Salary = 100000&quot;, var);
</PRE>
</BLOCKQUOTE>
<P>
As a more complete example of using SQL with DAO, the example
<TT>EX22F</TT> is provided on the accompanying CD-ROM. This example
is similar to some of the non-SQL examples developed earlier in
this chapter. However, because <TT>EX22F</TT> uses SQL to manipulate
the database, you'll see how much easier it is. Listing 22.7 shows
the <TT>OpenDatabase</TT> method of <TT>EX22F</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 22.7. The OpenDatabase method of EX22F.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private boolean OpenDatabase()
{
    URL dbURL;
    try {
        // otherwise generate it relative to the applet
        dbURL = new java.net.URL(getDocumentBase(),
                &quot;sample.mdb&quot;);
    }
    catch(Exception e) {
        showStatus(&quot;Error: &quot; + e.getMessage());
        return false;
    }

    // strip &quot;file:/&quot; from dbURL
    String filename = dbURL.getFile().substring(1);

    // create the database engine
    _DBEngine dbengine = dao_dbengine.create();

    // create Variants that will hold parameters that
    // will be passed to OpenDatabase
    Variant var1 = new Variant();
    Variant var2 = new Variant();
    Variant var3 = new Variant();

    // set parameters for call to OpenDatabase
    var1.putBoolean(false);
    var2.putBoolean(false);
    var3.putString(&quot;&quot;);

    // Open the database for non-exclusive access
    db = dbengine.OpenDatabase(filename,var1,var2,var3);

    // create Variants that will hold parameters that
    // will be passed to OpenDatabase
    Variant var4 = new Variant();
    Variant var5 = new Variant();

    var4.putShort(Constants.dbOpenDynaset);
    var5.putShort(Constants.dbEditAdd);

    // create the recordset
    recordset=db.OpenRecordset(&quot;select * from Programmer&quot;,
            var4, var5);

    // display all the records in this dynaset
    DisplayAllRecords();

    // give raises to the Java programmers
    GiveRaises();
    HireNewProgrammer();

    // re-display all the records in this dynaset
    DisplayAllRecords();

    // requery the database
    Variant var6 = new Variant();
    var6.putNull();
    recordset.Requery(var6);

    // re-display all the records in this dynaset
    DisplayAllRecords();

    return true;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you can see, this version of <TT>OpenDatabase</TT> is similar
to the one used in <TT>EX22A</TT> that was shown in Listing 22.3.
The first difference occurs with the call to <TT>OpenRecordset</TT>,
which uses an SQL statement instead of a table name and specifies
<TT>dbOpenDynaset</TT> instead of <TT>dbOpenTable</TT>. After
the <TT>recordset</TT> is created the method <TT>DisplayAllRecords</TT>
is called. This method is the same as was shown in Listing 22.3,
so it is not repeated here. Next, the methods <TT>GiveRaises</TT>
and <TT>HireNewProgrammer</TT> are called. These methods are shown
in Listing 22.8.
<HR>
<BLOCKQUOTE>
<B>Listing 22.8. The GiveRaises and HireNewProgrammers methods
of EX22F. private void GiveRaises()<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
{
  Variant var = new Variant();
  var.putShort(Constants.dbFailOnError);

  db.Execute(&quot;update Programmer set Salary = &quot; +
          &quot;Salary * 2 where KnowsJava &lt;&gt; 0&quot;, var);

  output.appendText(&quot;\r\nRaises given: &quot; +
          String.valueOf(db.getRecordsAffected()) +
          &quot;\r\n\r\n&quot;);
}

private void HireNewProgrammer()
{
  Variant var = new Variant();
  var.putShort(Constants.dbFailOnError);

  String sqlStr = &quot;insert into Programmer (FirstName, &quot; +
  &quot;LastName, Salary, KnowsJava, JobTitle) &quot; +
  &quot;values (\&quot;Napoleon\&quot;, \&quot;Solo\&quot;, 63000, 0, \&quot;Lead\&quot;)&quot;;

  db.Execute(sqlStr, var);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Both <TT>GiveRaises</TT> and <TT>HireNewProgrammer</TT> create
a variant and load it with <TT>dbFailOnError</TT>. <TT>GiveRaises</TT>
uses an SQL <TT>update</TT> statement to double the salary of
every Java programmer in the database while <TT>HireNewProgrammer</TT>
uses <TT>insert</TT> to add a programmer to the database. In the
case of <TT>GiveRaises</TT>, the method <TT>getRecordsAffected</TT>,
a member of <TT>Database</TT>, is used to determine how many raises
were given. This method always returns the number of rows affected
by the last SQL statement.
<P>
After the <TT>OpenDatabase</TT> method has called <TT>GiveRaises</TT>
and <TT>HireNewProgrammer</TT>, <TT>DisplayAllRecords</TT> is
again used to show the effect of these methods. As you can see
in Figure 22.8, the raises are shown but Napoleon Solo does not
appear. Because you're using a dynaset the raises are automatically
reflected in the set; however, the new record for Napoleon Solo
is not added to the dynaset until the database is requeried. This
can be done by using the <TT>Requery</TT> method. <TT>Requery</TT>
takes a single null variant parameter and is executed as follows:
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-8.gif"><B> Figure 22.8 : </B><I>The output of EX22F before the database is requeried.
</I></A><P>
<BLOCKQUOTE>
<PRE>
// requery the database
Variant var6 = new Variant();
var6.putNull();
recordset.Requery(var6);
</PRE>
</BLOCKQUOTE>
<P>
This causes all record sets to be re-created and the final call
to <TT>DisplayAllRecords</TT> in <TT>OpenDatabase</TT> will now
display Napoleon's name as shown in Figure 22.9.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f22-9.gif"><B> Figure 22.9 : </B><I>The final output of EX22F.
</I></A><P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter introduced you to the Data Access Objects (DAO) and
showed you how to use them in your Java programs. You learned
about <TT>Database</TT>, <TT>Recordset</TT>, and <TT>Field</TT>
objects and how to combine these objects to perform useful tasks.
You saw examples of using DAO to browse a database, add new records,
update existing records, delete records, search for records, and
execute SQL. Armed with the information you learned in this chapter,
you are now prepared to write your own programs using the Data
Access Objects.
<HR>

<CENTER><P><A HREF="ch21.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch23.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
