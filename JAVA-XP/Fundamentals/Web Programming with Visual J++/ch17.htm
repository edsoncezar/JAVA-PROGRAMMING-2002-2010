<HTML>
<HEAD>
<TITLE>Chapter 17 -- Accessing URLs</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;17</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Accessing URLs</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#WhatIsaURL">
What Is a URL?</A>
<LI><A HREF="#TheURLClasses">
The URL Classes</A>
<UL>
<LI><A HREF="#URLClass">
URL Class</A>
<LI><A HREF="#URLStreamHandlerClass">
URLStreamHandler Class</A>
<LI><A HREF="#URLConnectionClass">
URLConnection Class</A>
<LI><A HREF="#URLStreamHandlerFactoryInterface">
URLStreamHandlerFactory Interface</A>
</UL>
<LI><A HREF="#ExtendingtheURLclassesSMTPClientApplication">
Extending the URL classes-SMTP Client Application</A>
<LI><A HREF="#InterfacingwithCGIScriptsandISAPIExtensions">
Interfacing with CGI Scripts and ISAPI Extensions</A>
<UL>
<LI><A HREF="#URLEncoderClass">
URLEncoder Class</A>
</UL>
<LI><A HREF="#ContentHandlers">
Content Handlers</A>
<UL>
<LI><A HREF="#ContentHandlerClass">
ContentHandler Class</A>
<LI><A HREF="#ContentHandlerFactoryInterface">
ContentHandlerFactory Interface</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Uniform Resource Locators (URLs) are perhaps the most noticeable
and least understood aspect of the Internet phenomenon. You would
be hard-pressed to find a magazine or television program today
that doesn't include the now familiar Web address of the company
paying for an advertisement. It is not uncommon to hear a newscaster
or radio personality confidently recite a URL on the air, &quot;h-t-t-p-colon-slash-slash....&quot;
Fortunately, all the public needs to know is that if they type
this odd-looking sequence of characters into their Web browser,
graphically presented information and, thanks to Java, active
content will fill the screen.
<P>
This chapter discusses the definition of a URL, tells how it can
be used to locate Web and other resources, and shows what classes
are provided by Java to allow you to seamlessly work with URLs
in your programs.
<H2><A NAME="WhatIsaURL"><FONT SIZE=5 COLOR=#FF0000>
What Is a URL?</FONT></A></H2>
<P>
Although the World Wide Web has dominated the Internet in recent
years, there are many other types of resources that provide a
diverse range of services on the Internet. For example, electronic
mail, file transfer, and search tools were among the first services
to be developed for the Internet. In fact, much of the success
of the Web is due to its capability to bring together many of
these resources into one interface. Indeed, the two most popular
Web browsers available today are able to perform file transfers,
send and receive electronic mail, and interact with news services
in addition to their normal Web duties. The URL is the key to
defining the method, location, and name of the many types of resources
available on the Internet.
<P>
The general format of a URL is composed of a protocol name, a
colon, and some protocol specific information about a resource:
<BLOCKQUOTE>
<PRE>
protocol name:protocol specific information
</PRE>
</BLOCKQUOTE>
<P>
A resource's protocol is the language used to interpret the data
that is shared across a network connection about that resource.
The protocol name portion is not case-sensitive and can include
letters, numbers, a plus sign (<TT>+</TT>), period (<TT>.</TT>),
and hyphen (<TT>-</TT>). The protocol-specific information portion
can include any character. However, non-printable, reserved, and
unsafe characters must be escaped, or encoded, to ensure the original
meaning of the URL is maintained. Once received by the server,
the URL is decoded before it is interpreted. Characters are escaped
by replacing them with the percent (<TT>%</TT>) sign and their
hexadecimal value. For example, if the less-than (<TT>&lt;</TT>)
character is to be used in a URL, it must be escaped to <TT>%3C</TT>
because it is one of the unsafe characters. The unsafe group of
characters includes <TT>&lt;</TT>, <TT>&gt;</TT>, <TT>&quot;</TT>,
<TT>#</TT>, <TT>%</TT>, <TT>{</TT>, <TT>}</TT>, <TT>[</TT>, <TT>]</TT>,
<TT>|</TT>, <TT>\</TT>, <TT>^</TT>, <TT>~</TT>, and <TT>'</TT>.
These characters have special meaning as part of the URL itself
or on the systems transporting or interpreting the URL. For example,
the tilde (<TT>~</TT>) is commonly used in a Web URL to designate
the path to a user's home directory on a server. A URL of <TT>http://www.jory.com/~james/homepage.html</TT>
points to my personal home page on my server located in my user
directory (<TT>/james</TT>). If I wanted to use a tilde as part
of my home page filename (<TT>home~page.html</TT>), the tilde
in the filename should be escaped to eliminate any confusion over
the tilde used to designate my user directory. The correct URL
would then be <TT>http://www.jory.com/~james/home%7Epage.html</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
See Request for Comments (RFC) 1738 for more information on URLs. The current library of RFCs can be found on the accompanying CD-ROM.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Table 17.1 lists some of the more common URLs for resources found
on the Internet.<BR>
<P>
<CENTER><B>Table 17.1. Common URLs found on the Internet.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=240><I>Resource</I></TD><TD WIDTH=336><I>Sample URL</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>Hypertext Transfer Protocol (HTTP)</TD><TD WIDTH=336><TT>http://somehost.com</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>Simple Mail Transfer Protocol (SMTP)</TD><TD WIDTH=336><TT>mailto:someone@somehost.com</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>File Transfer Protocol (FTP)</TD><TD WIDTH=336><TT>ftp://somehost.com/someplace/somefile.ext</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>Local file</TD><TD WIDTH=336><TT>file:/c:/someplace/somefile.ext</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>News (Usenet News)</TD><TD WIDTH=336><TT>news:some.news.group</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>Telnet (interactive session)</TD><TD WIDTH=336><TT>telnet://somehost.com</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240>Wide Area Information Server (WAIS)</TD><TD WIDTH=336><TT>wais://somehost.com/database?search</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The URLs with two slashes after the colon use a common syntax
for the protocol-specific information. These types of URLs are
used to access a resource on a specific host. The general format
for host-based resources is defined like this:
<BLOCKQUOTE>
<PRE>
protocol name://user:password@host:port/path
</PRE>
</BLOCKQUOTE>
<P>
The <TT>user</TT>, <TT>password</TT>, and <TT>port</TT> fields
are optional and if missing will cause the default behavior to
be used. For example, FTP URLs found on Web pages typically do
not include a user and password. In these cases, the Web browser
attempts to initiate an anonymous FTP session by logging on to
the FTP server on your behalf using <TT>anonymous</TT> as the
user ID and your electronic mail address as the password. Likewise,
if the port is missing from the URL, the default port is used
based on the specified protocol. For example, the HTTP protocol
uses port 80 by default.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A <I>port </I>represents the logical connection point between a client and server process communicating over a network connection. It is analogous to a channel on television or frequency on the radio. Port numbers up to and including <TT>1024</TT> are 
reserved for system use and when assigned are often referred to as well-known sockets, services, or ports. Port numbers above <TT>1024</TT> and below <TT>65535</TT> are unassigned and can be used for user applications. Ports and the underlying protocol 
suite used to transport data across the Internet are discussed in <A HREF="ch18.htm" >Chapter 18</A>, &quot;Networking with Datagrams and Sockets.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheURLClasses"><FONT SIZE=5 COLOR=#FF0000>
The URL Classes</FONT></A></H2>
<P>
Now that you have seen how URLs are used to identify resources
on the Internet, take a look at the classes provided by Java to
access them.
<H3><A NAME="URLClass">
URL Class</A></H3>
<P>
Encapsulating the inherent complexity and flexibility of all known
URL formats as well as those to come in a set of classes would
certainly be a daunting task. Fortunately, the Java implementers
have taken care of this for you. The java.net package includes
four URL-related classes and one interface. The <TT>URL</TT> class
drives the whole process and takes care of interacting with the
other classes. Adding support for new or custom URL formats is
also possible by subclassing the appropriate classes, which will
be shown later in this chapter.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Unfortunately, security constraints imposed by Web browsers limit the type of URLs and the hosts that you can communicate with in your applets. In general, you are limited to communicating with the host serving your applet or the HTML page containing your 
applet and only then using protocols supported and allowed by the browser's Java Virtual Machine. The current implementations of Netscape's Navigator and Microsoft's Internet Explorer limit your applets to working with HTTP URLs only. However, there are a 
few ways to get around this restriction. Of course, Java applications are not bound by the same constraints.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As a result of the restriction placed on applets to have access
only to Web URLs, the design of the URL classes were naturally
slanted toward HTTP resources. The default behavior is to expect
a Web URL, but these effects can be overcome through subclassing
and overriding the appropriate methods. Table 17.2 lists the methods
of interest from the <TT>URL</TT> class.<BR>
<P>
<CENTER><B>Table 17.2. URL methods of interest.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=210><I>Method</I></TD><TD WIDTH=377><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>URL(String, String, int, String)</TT></TD>
<TD WIDTH=377>Creates an absolute URL based on the protocol, host, port, and filename passed as parameters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>URL(String, String, String)</TT></TD><TD WIDTH=377>Creates an absolute URL based on the protocol, host, and filename passed as parameters. Because the port is not specified, the default port is used based on the protocol.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>URL(String)</TT></TD><TD WIDTH=377>Creates an absolute URL based on the unparsed string passed as a parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>URL(URL, String)</TT></TD><TD WIDTH=377>Creates a new URL relative to the URL passed as a parameter using the filename parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>int getPort()</TT></TD><TD WIDTH=377>Returns the port number of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>String getProtocol()</TT></TD><TD WIDTH=377>Returns the protocol name of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>String getHost()</TT></TD><TD WIDTH=377>Returns the host name of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>String getFile()</TT></TD><TD WIDTH=377>Returns the filename of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>String getRef()</TT></TD><TD WIDTH=377>Returns the reference of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>URLConnection openConnection()</TT></TD>
<TD WIDTH=377>Returns an instance of a <TT>URLConnection</TT> via an internal reference to a <TT>URLStreamHandler</TT> object. Depending on the protocol of the URL, an actual connection to the host may not be made at this time.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>InputStream openStream()</TT></TD><TD WIDTH=377>Opens a connection and returns an <TT>InputStream</TT> to the URL. If an <TT>InputStream</TT> is not supported by the URL, an <TT>UnknownServiceException</TT> is thrown.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>Object getContent()</TT></TD><TD WIDTH=377>Opens a connection and returns an object representing the contents of the URL.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>SetURLStreamHandlerFactory (URLStreamHandlerFactory)</TT>
</TD><TD WIDTH=377>A static method that sets the <TT>URLStreamHandlerFactory</TT> based on the parameter.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Each URL constructor will throw a <TT>MalformedURLException</TT>
if a <TT>URLStreamHandler</TT> could not be found for the URL's
protocol. Once constructed, access to the actual resource associated
with the URL can be obtained through the <TT>openConnection()</TT>,
<TT>openStream()</TT>, or <TT>getContent()</TT> methods. The method
used depends on the nature of the resource to which you are connecting.
If you need detailed information about the resource and want to
perform input and output operations, use <TT>openConnection()</TT>,
which provides the most control. The SMTP example applet discussed
later in this chapter uses this type of access. However, if you
just need read access to the resource (such as a text file), <TT>openStream()</TT>
will do the job. Finally, if a content handler is available for
the resource, <TT>getContent()</TT> will return an instance of
an <TT>Object</TT> that represents the resource. The current implementation
of Java includes content handlers for the following MIME types:
<TT>text/plain</TT>, <TT>image/gif</TT>, <TT>image/jpeg</TT>,
<TT>image/x_xbitmap</TT>, and <TT>image/x_xpixmap</TT>. Content
handlers will be discussed again later in this chapter.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The Multipurpose Internet Mail Extensions (MIME) standard was created to expand the type of data that could be delivered with electronic mail. Under MIME, non-text-based attachments to electronic mail notes are preceded by header information capable of 
describing the type of data in the attachment, the encoding scheme used, and even the application that should be used to interpret the data. The Content-type header field is the key to interpreting the resource. In its basic form, the content-type is 
composed of a type and subtype in the form <TT>type/subtype</TT>. For example, a content-type of <TT>text/html</TT> defines a resource (such as a Web page) that is text-based and in HTML format.
</BLOCKQUOTE>
<BLOCKQUOTE>
Because the nature of the resources found on the Web are also as diverse as the types of attachments to electronic mail, MIME was adopted for the Web and thus is supported by Java.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Unless you intend to open more than one connection to a resource, do not call <TT>openConnection()</TT>, <TT>openStream()</TT>, or <TT>getContent()</TT> more than once, because each call opens a new connection. Calling one of these methods and then another 
has the same effect because all three methods refer to the same resource.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="URLStreamHandlerClass">
URLStreamHandler Class</A></H3>
<P>
<TT>URLStreamHandler</TT> is an abstract base class used to create
connections to URL resources as well as provide parsing functionality
for URLs. To create handlers for new or currently unsupported
URLs, this class must be subclassed. The current implementation
of Java provides handlers for the HTTP, file, doc, and news URLs.
However, as mentioned, only http resources can be used by applets.
Table 17.3 lists the methods of interest for <TT>URLStreamHandler</TT>.
<BR>
<P>
<CENTER><B>Table 17.3. URLStreamHandler methods of interest.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=199><I>Method</I></TD><TD WIDTH=377><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>URLConnection openConnection(URL)</TT></TD>
<TD WIDTH=377>This abstract protected method is called by <TT>URL</TT> to create a connection to the specified URL. This method must be overridden by a subclass.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>parseURL(URL, String, int, int)</TT></TD>
<TD WIDTH=377><TT>URL</TT> objects created with and based on unparsed URLs will call this method to interpret the unparsed URL and give the <TT>URLStreamHandler</TT> an opportunity to interpret the URL based on its own format.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Remember from our discussion of the <TT>URL</TT> class that the
<TT>URL</TT> class was designed primarily with the HTTP protocol
and URL format in mind? Well, for protocols that have URL formats
different from HTTP, the <TT>URL</TT> class will call <TT>parseURL()</TT>
to give the <TT>URLStreamHandler</TT> an opportunity to parse
the URL in its intended context. Once successfully parsed, <TT>URLStreamHandler</TT>
sets the parsed URL values in the attached <TT>URL</TT> object
through the protected <TT>setURL()</TT> method.
<H3><A NAME="URLConnectionClass">
URLConnection Class</A></H3>
<P>
This is another abstract base class used in conjunction with the
<TT>URL</TT> and <TT>URLStreamHandler</TT> classes. It provides
more direct access to the resource than the <TT>URL</TT> class,
as well as detailed MIME information about the resource. Table
17.4 lists several methods from <TT>URLConnection</TT>.<BR>
<P>
<CENTER><B>Table 17.4. URLConnection methods of interest.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><I>Method</I></TD><TD WIDTH=371><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>connect()</TT></TD><TD WIDTH=371>This abstract protected method is called by <TT>URL</TT> to create a connection to the specified URL. This method must be overridden by a subclass.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>URL getURL()</TT></TD><TD WIDTH=371>Returns the <TT>URL</TT> object associated with this connection.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int getContentLength()</TT></TD><TD WIDTH=371>Returns the length of the resource in bytes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>String getContentType()</TT></TD><TD WIDTH=371>Returns the content-type for the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>String getContentEncoding()</TT></TD><TD WIDTH=371>Returns the content-encoding for the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>long getExpiration()</TT></TD><TD WIDTH=371>Returns the expiration of the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>long getDate()</TT></TD><TD WIDTH=371>Returns the sending date of the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>long getLastModified()</TT></TD><TD WIDTH=371>Returns the date that the resource was last modified.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Object getContent()</TT></TD><TD WIDTH=371>Returns an instance of an object representing the contents of the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>InputStream getInputStream()</TT></TD><TD WIDTH=371>Returns an input stream to the resource.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>OutputStream getOutputStream()</TT></TD>
<TD WIDTH=371>Returns an output stream to the resource.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>SetContentHandlerFactory (ContentHandlerFactory)</TT>
</TD><TD WIDTH=371>Sets the <TT>ContentHandlerFactory</TT> to the value passed as a parameter.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Depending on the type of resource and the level of detail available
in the MIME header for the resource, some of the methods listed
in Table 17.4 might not return valid information.
<H3><A NAME="URLStreamHandlerFactoryInterface">
URLStreamHandlerFactory Interface</A></H3>
<P>
Recall from the <TT>URL</TT> class that when a <TT>URL</TT> object
is created, a <TT>URLStreamHandler</TT> must be found that supports
the protocol of the resource. If not, a <TT>MalformedURLException</TT>
is thrown. Part of the process of finding a <TT>URLStreamHandler</TT>
for the resource involves consulting a reference to an object
that implements the <TT>URLStreamHandlerFactory</TT> interface.
If the <TT>URLStreamHandlerFactory</TT>'s <TT>createURLStreamHandler()</TT>
method does not support the requested protocol or a <TT>URLStreamHandlerFactory</TT>
was not set in <TT>URL</TT> via the <TT>URL.setURLStreamHandlerFactory()</TT>
method, <TT>URL</TT> will check the protocol against Java's built-in
protocol handlers as a last resort. Figure 17.1 illustrates the
process that <TT>URL</TT> goes through to find a <TT>URLStreamHandler</TT>
for a resource.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f17-1.gif"><B> Figure 17.1 : </B><I>URL's search for a URLStreamHandler.

</I></A><P><BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
After the <TT>URL.setURLStreamHandlerFactory()</TT> has been called once, it cannot be changed again. For applets, a default <TT>URLStreamHandlerFactory</TT> that only supports HTTP URLs is set when the applet's frame is initialized. This is the reason 
support for new or unsupported URL formats cannot be added to applets. However, default <TT>URLStreamHandler-Factory</TT> is not set for Java applications, so you are free to set your own.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Now that we have covered the main URL-related classes, let's subclass
them to create a basic Simple Mail Transfer Protocol (SMTP) client
application.
<H2><A NAME="ExtendingtheURLclassesSMTPClientApplication"><FONT SIZE=5 COLOR=#FF0000>
Extending the URL classes-SMTP Client Application</FONT></A></H2>
<P>
To illustrate how new or unsupported URL formats can be added
to Java applications, the following example will implement the
<TT>mailto</TT> URL. Three utility classes will be constructed
to complete the example: the <TT>SmtpURLConnection</TT>, <TT>SmtpURLStreamHandler</TT>,
and <TT>SmtpURLStreamHandlerFactory</TT> classes.
<P>
Let's start with the <TT>SmtpURLStreamHandlerFactory</TT> class.
Once it is set as the default <TT>URLStreamHandlerFactory</TT>
for the <TT>URL</TT> class, its <TT>createURLStreamHandler()</TT>
is called whenever a URL is created for a resource for which <TT>URL</TT>
does not already have a <TT>URLStreamHandler</TT>. Our handler
factory's job is to return an instance of <TT>SmtpURLStreamHandler</TT>
when a <TT>mailto</TT> URL is requested. Otherwise <TT>null</TT>
is returned, which causes <TT>URL</TT> to check the protocol against
the built-in types. Listing 17.1 shows the source code for <TT>SmtpURLStreamHandlerFactory</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 17.1. SmtpURLStreamHandlerFactory.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.net.*;
import SmtpURLStreamHandler;

public class SmtpURLStreamHandlerFactory implements URLStreamHandlerFactory
{
    public URLStreamHandler createURLStreamHandler(String protocol)
    {
        if (protocol.equalsIgnoreCase(&quot;mailto&quot;))
            return new SmtpURLStreamHandler();
        else
            return null;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The next class, <TT>SmtpURLStreamHandler</TT>, is a subclass of
<TT>URLStreamHandler</TT>. Its jobs are to parse the <TT>mailto</TT>
URL for the receiver's electronic mail ID and create a new <TT>SmtpURLConnection</TT>
object when the <TT>openConnection()</TT> method is called. Listing
17.2 lists the source code for this class.
<HR>
<BLOCKQUOTE>
<B>Listing 17.2. SmtpURLStreamHandler.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.net.*;
import java.io.*;

public class SmtpURLStreamHandler extends URLStreamHandler 
{
    String to;

    protected URLConnection openConnection(URL u) 
    {
        return new SmtpURLConnection(u, to);
    }

    protected void parseURL(URL u, String spec, int start, int limit)
    {
        String protocol = u.getProtocol();
        String host = u.getHost();

        int atSign = spec.indexOf('@', start);

        if (atSign == -1)
            to = &quot;&quot;;
        else
        {
            to = spec.substring(start, atSign - 1);
            host = spec.substring(atSign + 1, limit);
        }

        setURL(u, protocol, host, 25, &quot;&quot;, &quot;&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The last SMTP class is <TT>SmtpURLConnection</TT> and is a subclass
of <TT>URLConnection</TT>. It provides methods to set the from
and to address for the note as well as sending the note itself.
An output stream can also be retrieved from <TT>SmtpURLConnection</TT>
but not an input stream. The <TT>smtpClient</TT> private data
member, borrowed from the sun.net.smtp package, actually takes
care of reading and validating the responses from the SMTP server.
Listing 17.3 lists the source code for <TT>SmtpURLConnection</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 17.3. SmtpURLConnection.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.net.*;
import java.io.*;

public class SmtpURLConnection extends URLConnection 
{
    private sun.net.smtp.SmtpClient smtpClient;
    protected String to;
    protected String from;
    protected String smtpServer;

    public SmtpURLConnection(URL u, String to)
    {
        super(u);
        this.to = to;
        smtpClient = null;
    }

    public void setFrom(String from)
    {
        this.from = from;
    }

    public void setTo(String to)
    {
        this.to = to;
    }

    public void setSmtpServer(String smtpServer)
    {
        this.smtpServer = smtpServer;
    }

    public void sendIt() throws IOException
    {
        if (connected)
        {
            smtpClient.closeServer();
            connected = false;
        }
        else
            throw new IOException(&quot;nothing to send.&quot;);
    }

    public void closeServer() throws IOException
    {
        if (connected)
            smtpClient.closeServer();
    }

    protected void finalize()
    {
        try
        {
            closeServer();
        }
        catch (IOException e) {}
    }

    public void connect() throws IOException 
    {
        if (!connected) 
        {
            smtpClient = null;
            try 
            {
                smtpClient = new sun.net.smtp.SmtpClient(smtpServer);
            } 
            catch (Throwable e) 
            {
                if (smtpClient != null)
                    smtpClient.closeServer();
                if (e instanceof SecurityException) 
                {
                    throw (SecurityException)e;
                }
                throw (e instanceof IOException ? (IOException) e 
                        : new IOException(e.toString()));
            }
            if (smtpClient == null)
                throw new IOException(&quot;Couldn't connect to &quot; + smtpServer);

            connected = true;
            smtpClient.from(from);
            smtpClient.to(to + &quot;@&quot; + url.getHost());
        }
    }

    public OutputStream getOutputStream() throws IOException
    {
        if (!connected)
            connect();
        return smtpClient.startMessage();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Finally, the source for the SMTP client application is shown in
Listing 17.4, and a screen shot is shown in Figure 17.2. The bulk
of the code deals with setting up and managing the interface of
the application. The critical sections are the last line of the
constructor where the <TT>URL</TT> <TT>URLStreamHandlerFactory</TT>
is set to <TT>SmtpURLStreamHandlerFactory</TT>, and the <TT>send()</TT>
method where the mail is sent to the recipient.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f17-2.gif"><B> Figure 17.2 : </B><I>SMTP client application  in action.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.4. EX17A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.awt.*;
import java.net.*;
import java.io.*;
import SmtpURLConnection;
import SmtpURLStreamHandler;
import SmtpURLStreamHandlerFactory;

public class EX17A extends Frame
{
    TextField from, to, smtpServer, status;
    TextArea note;
    Button send, close;

    public EX17A(String caption)
    {
        super(caption);

        from = new TextField(20);
        to = new TextField(20);
        smtpServer = new TextField(40);
        note = new TextArea(10, 40);
        status = new TextField(40);
        status.setEditable(false);
        send = new Button(&quot;Send&quot;);
        close = new Button(&quot;Close&quot;);
        Label l;

        GridBagLayout gbag = new GridBagLayout();
        GridBagConstraints cons = new GridBagConstraints();
        cons.insets = new Insets(5, 5, 5, 5);

        setLayout(gbag);

        cons.anchor = GridBagConstraints.NORTHWEST;
        l = new Label(&quot;From:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.gridwidth = GridBagConstraints.REMAINDER;
        cons.fill = GridBagConstraints.HORIZONTAL;
        gbag.setConstraints(from, cons);
        add(from);

        cons.gridwidth = 1;
        cons.fill = GridBagConstraints.NONE;
        l = new Label(&quot;To:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.gridwidth = GridBagConstraints.REMAINDER;
        cons.fill = GridBagConstraints.HORIZONTAL;
        gbag.setConstraints(to, cons);
        add(to);

        cons.gridwidth = 1;
        cons.fill = GridBagConstraints.NONE;
        l = new Label(&quot;SMTP Server:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.gridwidth = GridBagConstraints.REMAINDER;
        cons.fill = GridBagConstraints.HORIZONTAL;
        gbag.setConstraints(smtpServer, cons);
        add(smtpServer);

        cons.fill = GridBagConstraints.NONE;
        cons.insets.bottom = 0;
        l = new Label(&quot;Note:&quot;);
        gbag.setConstraints(l, cons);
        add(l);
        cons.insets.bottom = 5;

        cons.weighty = 1.0;
        cons.fill = GridBagConstraints.BOTH;
        gbag.setConstraints(note, cons);
        add(note);

        cons.gridwidth = 1;
        cons.fill = GridBagConstraints.NONE;
        cons.weighty = 0;
        l = new Label(&quot;Status:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.gridwidth = GridBagConstraints.REMAINDER;
        cons.fill = GridBagConstraints.HORIZONTAL;
        cons.weightx = 1.0;
        gbag.setConstraints(status, cons);
        add(status);

        Panel buttons = new Panel();
        buttons.setLayout(new FlowLayout(FlowLayout.CENTER, 20, 5));
        buttons.add(send);
        buttons.add(close);
        cons.gridwidth = GridBagConstraints.REMAINDER;
        cons.fill = GridBagConstraints.NONE;
        cons.anchor = GridBagConstraints.CENTER;
        gbag.setConstraints(buttons, cons);
        add(buttons);
        
        pack();
        show();

        URL.setURLStreamHandlerFactory(new SmtpURLStreamHandlerFactory());
    }
    
    public boolean handleEvent(Event evt)
    {
        if (evt.target == send)
        {
            if (to.getText().length() &gt; 0 &amp;&amp; smtpServer.getText().length() &gt; 0)
                send();
            else
                status.setText(&quot;Enter destination address and SMTP Server.&quot;);
            return true;
        }
        else if (evt.target == close || evt.id == Event.WINDOW_DESTROY)
        {
            dispose();
            System.exit(0);
            return true;
        }
        else
            return super.handleEvent(evt);
    }

    protected void send()
    {
        SmtpURLConnection mailConn = null;
        status.setText(&quot;Sending note...&quot;);
        try
        {
            URL url = new URL(&quot;mailto:&quot; + to.getText());
            mailConn = (SmtpURLConnection)url.openConnection();
            mailConn.setFrom(from.getText());
            mailConn.setSmtpServer(smtpServer.getText());
            
            PrintStream os = new PrintStream(mailConn.getOutputStream());
            os.print(note.getText());
            mailConn.sendIt();

            status.setText(&quot;Note successfully sent to &quot; + to.getText());
        }
        catch (MalformedURLException e)
            status.setText(&quot;URL Error: &quot; + e);
        catch (UnknownHostException e)
            status.setText(&quot;Host could not be found.  Try again.&quot;);
        catch (IOException e)
            status.setText(&quot;Stream Error: &quot; + e);
        finally
        {
            if (mailConn != null)
            {
                try
                    mailConn.closeServer();
                catch (IOException e) {}
            }
        }
    }

    public static void main(String args[])
    {
        new EX17A(&quot;Java SMTP Client&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="InterfacingwithCGIScriptsandISAPIExtensions"><FONT SIZE=5 COLOR=#FF0000>
Interfacing with CGI Scripts and ISAPI Extensions</FONT></A></H2>
<P>
The Common Gateway Interface (CGI) and Internet Server Application
Programming Interface (ISAPI) are commonly used on Web sites to
get information from visitors. An HTML page can be created with
input controls such as edit fields, list boxes, and check boxes,
using the HTML <TT>FORM</TT>, <TT>INPUT</TT>, <TT>TEXTAREA</TT>,
and <TT>SELECT</TT> tags. When the form is submitted back to the
server by the user, the browser simply packages the responses
in a URL-encoded sequence of characters and either sends the output
on the end of the URL (<TT>GET</TT> method) or in a separate transaction
(<TT>POST</TT> method). The method used to send the responses
back to the server is specified in the Web page.
<P>
Using the classes already covered in this chapter plus the <TT>URLEncoder</TT>
class discussed below, you will see how Java applets can extend
the limited use of CGI scripts and ISAPI extensions by providing
a more robust and sophisticated interface.
<H3><A NAME="URLEncoderClass">
URLEncoder Class</A></H3>
<P>
<TT>URLEncoder</TT> is a utility class that cannot be instantiated
(the default constructor is declared private) but provides a static
method called <TT>encode()</TT> that returns an <TT>x-www-form-urlencoded</TT>
version of the string passed as an argument. The <TT>x-www-form-urlencoded</TT>
format has all unsafe, reserved, and non-printable characters
encoded, or escaped, within the string. See the section titled
&quot;What Is a URL?&quot; at the beginning of this chapter for
a more detailed description of URL encoding.
<P>
The applet shown in Figure 17.3 allows the user to search for
detailed information about a product by entering the name of the
product and pressing the Search button. The <TT>encode()</TT>
method is used to format the product name before it is sent back
to the Web server using an HTTP <TT>POST</TT> transaction. Since
the applet is using the HTTP protocol to communicate with the
server, it does not matter if the server processes the request
using a CGI script or ISAPI extension. Listing 17.4 includes the
source code for the applet.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f17-3.gif"><B> Figure 17.3 : </B><I>CGI or ISAPI from an applet.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 17.4. EX17B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.Applet;
import java.awt.*;
import java.net.*;
import java.io.*;

public class EX17B extends Applet
{
    TextField prodName;
    TextArea prodInfo;
    Button search;
    Label status;
    URL url;

    public void init()
    {
        prodName = new TextField(30);
        prodInfo = new TextArea(10, 30);
        prodInfo.setEditable(false);
        search = new Button(&quot;Search&quot;);
        status = new Label();
        Label l;

        GridBagLayout gbag = new GridBagLayout();
        GridBagConstraints cons = new GridBagConstraints();
        cons.insets = new Insets(5, 5, 5, 5);

        setLayout(gbag);

        l = new Label(&quot;World Distributors Product Information&quot;);
        l.setFont(new Font(&quot;Helvetica&quot;, Font.BOLD, 18));
        cons.gridwidth = GridBagConstraints.REMAINDER;
        gbag.setConstraints(l, cons);
        add(l);

        cons.anchor = GridBagConstraints.NORTHWEST;
        cons.gridwidth = 1;
        l = new Label(&quot;Product Name:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.fill = GridBagConstraints.HORIZONTAL;
        gbag.setConstraints(prodName, cons);
        add(prodName);

        cons.fill = GridBagConstraints.NONE;
        cons.gridwidth = GridBagConstraints.REMAINDER;
        gbag.setConstraints(search, cons);
        add(search);

        cons.fill = GridBagConstraints.HORIZONTAL;
        gbag.setConstraints(status, cons);
        add(status);

        l = new Label(&quot;Product Information:&quot;);
        gbag.setConstraints(l, cons);
        add(l);

        cons.fill = GridBagConstraints.BOTH;
        gbag.setConstraints(prodInfo, cons);
        add(prodInfo);

        resize(300, 400);
    }

    public boolean handleEvent(Event evt)
    {
        if (evt.target == search)
        {
            if (prodName.getText().length() &gt; 0)
                search();
            else
                status.setText(&quot;Please enter a product name.&quot;);
            return true;
        }
        else
            return super.handleEvent(evt);
    }

    public void start()
    {
        try
            url = new URL(&quot;http&quot;, getCodeBase().getHost(), 
                    getParameter(&quot;script&quot;));
        catch (MalformedURLException e)
        {
            status.setText(&quot;Error initializing URL to server.&quot;);
            url = null;
        }
    }

    public void search()
    {
        if (url == null)
        {
            status.setText(&quot;Unknown URL; cannot perform query.&quot;);
            return;
        }

        try
        {
            status.setText(&quot;Querying server...&quot;);
            URLConnection conn = url.openConnection();

            PrintStream os = new PrintStream(conn.getOutputStream());
            os.println(URLEncoder.encode(prodName.getText()));
            os.close();

            status.setText(&quot;Retrieving response...&quot;);
            DataInputStream is = new DataInputStream(conn.getInputStream());

            String line = is.readLine();
            prodInfo.setText(&quot;&quot;);

            while (line != null)
            {
                prodInfo.appendText(line + &quot;\n&quot;);
                line = is.readLine();
            }
            is.close();
            status.setText(&quot;&quot;);
        }
        catch (IOException e)
        {
            status.setText(&quot;Error processing query: &quot; + e);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Because the URL to the script will not change during the life
of the applet, the <TT>start()</TT> method creates the URL once.
To allow this applet to be reused without needing to be modified,
only the name of the CGI script or ISAPI extension in the HTML
page must be changed. The <TT>search()</TT> method is called each
time the user presses the Search button. Within <TT>search()</TT>,
a connection is made to the CGI script, an output stream is obtained
from the <TT>URLConnection</TT>, and the contents of the Product
Name field are encoded and sent to the script for processing.
To retrieve the results from the script, an input stream is obtained
from the connection and each line is read and appended to the
Product Information <TT>TextField</TT>.
<P>
Although this is a simple application of using a CGI script or
ISAPI extension with a Java applet, the advantages of using an
applet over a traditional HTML form are apparent. Not only can
client-side edits be performed with applets to eliminate unnecessary
submissions of requests to the server, but the look and feel of
the applet is much more interactive and sophisticated.
<H2><A NAME="ContentHandlers"><FONT SIZE=5 COLOR=#FF0000>
Content Handlers</FONT></A></H2>
<P>
Like <TT>URLStreamHandler</TT>s, content handlers can be used
to extend Java's built-in support for Internet resources. Whereas
<TT>URLStreamHandler</TT>s apply to URLs, content handlers are
used to wrap the content of resources into Java-based objects.
However, content handlers are much less restricted in applets
than <TT>URLStreamHandler</TT>s. Indeed, you are free to create
your own custom content handlers and content handler factories
in applications as well as applets.
<H3><A NAME="ContentHandlerClass">
ContentHandler Class</A></H3>
<P>
<TT>ContentHandler</TT> is an abstract base class that declares
the <TT>getContent()</TT> method called by <TT>URLConnection</TT>.
To define your own content handler, you must subclass <TT>ContentHandler</TT>
and provide a <TT>getContent()</TT> method to create an <TT>Object</TT>
instance representing your resource. Rather than create a custom
content handler or call <TT>Applet.getImage()</TT>, the applet
in Listing 17.5 invokes the content handler for an <TT>image/gif</TT>
resource by calling the <TT>getContent()</TT> method of <TT>URLConnection</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 17.5. EX17C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.net.*;
import java.io.*;
import sun.awt.image.URLImageSource;

public class EX17C extends Applet
{
    Image img;
    String error = &quot;&quot;;

    public void init()
    {
        resize(200, 100);
    }

    public void paint(Graphics g)
    {
        if (error.length() &gt; 0)
            g.drawString(error, 10, 10);
        else
            g.drawImage(img, 10, 10, getBackground(), this);
    }

    public void start()
    {
        try
        {
            URL url = new URL(&quot;http://www.jory.com/gifs/someimage.gif&quot;);
            URLImageSource imgsrc = (URLImageSource)url.getContent();
            img = Toolkit.getDefaultToolkit().createImage(imgsrc);
        }
        catch (MalformedURLException me)
            error = me.toString();
        catch (IOException e)
            error = e.toString();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Following along in the code in Listing 17.5, a URL to the image
is created as normal. However, instead of calling the <TT>getImage()</TT>
method of the <TT>Applet</TT> class, the <TT>URLImageSource</TT>
content handler is used. Once the content handler is created,
the image itself can be created by calling the toolkit's <TT>createImage()</TT>
method. Now the image can be displayed in the applet's <TT>paint()</TT>
method. In fact, this is the same process that <TT>getImage()</TT>
goes through to create images!  Of course, you would normally
use <TT>getImage()</TT> to load images in your applets, but this
example illustrates how content handlers are used for accessing
resources.  Before running the example, be sure to change the
URL to point to a valid image file either on a Web server or your
local hard disk.
<H3><A NAME="ContentHandlerFactoryInterface">
ContentHandlerFactory Interface</A></H3>
<P>
The <TT>ContentHandlerFactory</TT> functions exactly like the
<TT>URLStreamHandlerFactory</TT> interface, except for content
handlers. To create your own content handler factory, implement
the <TT>ContentHandlerFactory</TT> interface in a class and call
<TT>URLConnection.setContentHandlerFactory()</TT> to install your
factory. Only one content handler factory can be set for <TT>URLConnection</TT>,
though. Fortunately, the content handler factory is not automatically
set for applets like the <TT>URL</TT> stream handler factory in
<TT>URL</TT>.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
The URL classes and content handlers provide a powerful and extensible
framework for implementing handlers for your own resource and
MIME types. Hopefully, the security constraints that currently
limit the usefulness of URLs in applets will be lifted in the
future so that these classes can be used to their fullest potential.
<HR>

<CENTER><P><A HREF="ch16.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch18.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>