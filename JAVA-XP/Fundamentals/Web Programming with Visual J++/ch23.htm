<HTML>
<HEAD>
<TITLE>Chapter 23 -- Software Cost Estimator</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;23</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Software Cost Estimator</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheProjectOverview">
The Project Overview</A>
<UL>
<LI><A HREF="#TheCostEstimatorApplet">
The CostEstimator Applet</A>
</UL>
<LI><A HREF="#StoringCostDriversandRatings">
Storing Cost Drivers and Ratings</A>
<LI><A HREF="#ProgrammingtheUserInterface">
Programming the User Interface</A>
<UL>
<LI><A HREF="#CreatingtheImagemap">
Creating the Imagemap</A>
<LI><A HREF="#SelectingProjectAttributes">
Selecting Project Attributes</A>
<LI><A HREF="#TheResultsPanel">
The Results Panel</A>
<LI><A HREF="#CreatingtheButtonPanel">
Creating the Button Panel</A>
</UL>
<LI><A HREF="#TheCostEstimatorButtons">
The CostEstimator Buttons</A>
<UL>
<LI><A HREF="#ResettingDefaultValues">
Resetting Default Values</A>
<LI><A HREF="#EstimatingtheProjectSchedule">
Estimating the Project Schedule</A>
<LI><A HREF="#SummarizingProjectAttributes">
Summarizing Project Attributes</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
This chapter describes how to build an applet that enables you
to forecast the amount of time needed to develop software. This
chapter puts to use much of what you've learned throughout this
book, especially on the subject of user interface programming.
Additionally, you will learn some new tricks, such as how to create
and use an imagemap.
<H2><A NAME="TheProjectOverview"><FONT SIZE=5 COLOR=#FF0000>
The Project Overview</FONT></A></H2>
<P>
In this chapter you will build the CostEstimator applet. This
applet is essentially a COCOMO calculator. COCOMO, which stands
for Constructive Cost Model, is a method for estimating the amount
of time completing a software development project will take. In
COCOMO you assess a project based on 15 attributes, such as programmer
capability, required reliability, and product complexity. Each
of these attributes is rated on a scale from Very Low to Extra
High.
<P>
The effort of a project, as measured in person months, is calculated
in COCOMO with the following equation:
<P>
Effort = 3.0 * (KLOC)  <SUP>(1.12 * EAF)</SUP>
<P>
KLOC represents a measure of the number of thousands of lines
of code. For example, if you anticipate writing 10,500 lines of
code, KLOC is 10.5. EAF, which stands for Effort Adjustment Factor,
is calculated, as you'll see in a moment, based on the attributes
of the project being estimated. The magic numbers 3.0 and 1.12
were calculated by Boehm using a form of regression analysis.
These values are for what Boehm refers to as &quot;semi-detached&quot;
projects.
<P>
As mentioned earlier, in COCOMO a project is rated from Very Low
to Extra High, on 15 attributes. Because how a project is rated
on these attributes influences the cost of the project, the attributes
are known as cost drivers. The cost drivers and their associated
values for each rating are shown in Table 23.1.<BR>
<P>
<CENTER><B>Table 23.1. COCOMO cost drivers.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=115><I>Cost Drivers</I></TD><TD WIDTH=77><CENTER><I>Very Low</I></CENTER>
</TD><TD WIDTH=67><CENTER><I>Low</I></CENTER></TD><TD WIDTH=77><CENTER><I>Nominal</I></CENTER>
</TD><TD WIDTH=67><CENTER><I>High</I></CENTER></TD><TD WIDTH=86><CENTER><I>Very High</I></CENTER>
</TD><TD WIDTH=86><CENTER><I>Extra High</I></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Analyst capability</TD><TD WIDTH=77><CENTER>1.46</CENTER>
</TD><TD WIDTH=67><CENTER>1.19</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.86</CENTER></TD><TD WIDTH=86><CENTER>0.71</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Applications</TD><TD WIDTH=77><CENTER>1.29</CENTER>
</TD><TD WIDTH=67><CENTER>1.13</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.91</CENTER></TD><TD WIDTH=86><CENTER>0.82</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>experience</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>&nbsp;</CENTER></TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>&nbsp;</CENTER></TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Complexity</TD><TD WIDTH=77><CENTER>0.70</CENTER>
</TD><TD WIDTH=67><CENTER>0.85</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.15</CENTER></TD><TD WIDTH=86><CENTER>1.30</CENTER>
</TD><TD WIDTH=86><CENTER>1.65</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Database size</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>0.94</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.08</CENTER></TD><TD WIDTH=86><CENTER>1.16</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Execution time</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>&nbsp;</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.11</CENTER></TD><TD WIDTH=86><CENTER>1.30</CENTER>
</TD><TD WIDTH=86><CENTER>1.66</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Language experience</TD><TD WIDTH=77><CENTER>1.14</CENTER>
</TD><TD WIDTH=67><CENTER>1.07</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.95</CENTER></TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Modern practices</TD><TD WIDTH=77><CENTER>1.24</CENTER>
</TD><TD WIDTH=67><CENTER>1.10</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.91</CENTER></TD><TD WIDTH=86><CENTER>0.82</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Programmer capability</TD><TD WIDTH=77><CENTER>1.42</CENTER>
</TD><TD WIDTH=67><CENTER>1.17</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.86</CENTER></TD><TD WIDTH=86><CENTER>0.70</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Reliability</TD><TD WIDTH=77><CENTER>0.75</CENTER>
</TD><TD WIDTH=67><CENTER>0.88</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.15</CENTER></TD><TD WIDTH=86><CENTER>1.40</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Schedule constraint</TD><TD WIDTH=77><CENTER>1.23</CENTER>
</TD><TD WIDTH=67><CENTER>1.08</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.04</CENTER></TD><TD WIDTH=86><CENTER>1.10</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Software tools</TD><TD WIDTH=77><CENTER>1.24</CENTER>
</TD><TD WIDTH=67><CENTER>1.10</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.91</CENTER></TD><TD WIDTH=86><CENTER>0.83</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Storage constraint</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>&nbsp;</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.06</CENTER></TD><TD WIDTH=86><CENTER>1.21</CENTER>
</TD><TD WIDTH=86><CENTER>1.56</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Turnaround time</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>0.87</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.07</CENTER></TD><TD WIDTH=86><CENTER>1.15</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Virtual Machine experience</TD><TD WIDTH=77><CENTER>1.21</CENTER>
</TD><TD WIDTH=67><CENTER>1.10</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>0.90</CENTER></TD><TD WIDTH=86><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=115>Virtual Machine volatility</TD><TD WIDTH=77><CENTER>&nbsp;</CENTER>
</TD><TD WIDTH=67><CENTER>0.87</CENTER></TD><TD WIDTH=77><CENTER>1.00</CENTER>
</TD><TD WIDTH=67><CENTER>1.15</CENTER></TD><TD WIDTH=86><CENTER>1.30</CENTER>
</TD><TD WIDTH=86><CENTER>&nbsp;</CENTER></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The Effort Adjustment Factor used in the Effort equation is calculated
by taking the product of all 15 cost drivers. You should notice
from Table 23.1 that the Nominal value for each cost driver is
1.00. This means you can think of Nominal as the default value
for each cost driver. As an example of calculating the Effort
Adjustment Factor, assume that a project is rated Nominal for
everything except Programmer Capability (which is High) and Complexity
(which is Very High). This means that the Effort Adjustment Factor
for this project is as follows:
<P>
EAF = 1.00 <SUP>13 * 0.86 * 1.30</SUP>
<P>
Multiplying this out, you get EAF = 1.118. Assume that you are
developing an estimate for a project you expect will include 10,000
lines of code. These values can then be plugged into the Effort
equation as shown here:
<P>
Effort = 3.0 * (10)  <SUP>(1.12 * 1.118)</SUP>
<P>
As you'll be able to verify with the applet at the end of the
chapter, this results in Effort equaling 53 person months.
<P>
In addition to the Effort equation, COCOMO provides an equation
for calculating the duration in calendar months of a project.
The equation for duration is this:
<P>
Duration = 2.5 * (Effort  <SUP>0.35</SUP>)
<P>
The CostEstimator applet developed in this chapter calculates
both Effort and Duration.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
For a full description of COCOMO, see the book <I>Software Engineering Economics</I>, by Barry Boehm. This book, first published in 1981, remains valuable to this day and is one of the classics in our industry. If you have ever missed a deadline, been 
asked to give a deadline, met a deadline, or bet on a horse named Deadline, you should own a copy of Boehm's book.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheCostEstimatorApplet">
The CostEstimator Applet</A></H3>
<P>
The rest of this chapter describes how to program the CostEstimator
applet. The initial screen of this applet is shown in Figure 23.1.
At the top left of the applet is an imagemap that includes the
abbreviations PRD, CMP, PER, and PRJ. These stand for Product,
Computer, Personnel, and Project. When you click the mouse over
these areas on the imagemap, the applet displays a different set
of cost drivers to the right of the imagemap. In Figure 23.1,
the Product cost drivers are displayed because PRD has been selected
in the imagemap, as shown by the highlighting around it.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-1.gif"><B> Figure 23.1 : </B><I>The initial screen of CostEstimator while Product cost drivers  are being selected.
</I></A><P>
<P>
Selecting a different portion of the imagemap displays a different
set of fields related to different cost drivers. For example,
Figure 23.2 shows the Project attributes. In this case, two choice
fields and a checkbox group are used. The four categories of cost
drivers are shown in Table 23.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-2.gif"><B> Figure 23.2 : </B><I>Selecting Project cost drivers in the CostEstimator.
</I></A><P><BR>
<P>
<CENTER><B>Table 23.2. Cost drivers by category.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=133><I>Category</I></TD><TD WIDTH=210><I>Cost Driver</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>Product</TD><TD WIDTH=210>Reliability</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Database size</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Complexity</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>Computer</TD><TD WIDTH=210>Execution time</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Storage constraints
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>VM volatility</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Turnaround time</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>Personnel</TD><TD WIDTH=210>Analyst capability
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Applications experience
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Programmer capability
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>VM experience</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Language experience
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=133>Project</TD><TD WIDTH=210>Modern practices</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Software tools</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=133>&nbsp;</TD><TD WIDTH=210>Schedule constraints
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Figures 23.1 and 23.2 also show an area for entry of KLOC. As
you recall, KLOC is shorthand for Thousand lines of code. Non-editable
text fields are also provided. They will display the Effort Adjustment
Factor and the COCOMO-estimated number of person months and calendar
months. In these figures, numbers are shown for the example described
earlier in this chapter. This is a 10,000-line program that will
take 53 person months to complete.
<P>
Three buttons are also provided. The Summary button displays a
frame detailing the cost-driver selections that have been made.
The Recalc button performs the COCOMO calculations and updates
the non-editable fields. The Reset button restores all the cost-driver
selections to Nominal. This is useful for analyzing different
scenarios.
<H4>The Class Overview</H4>
<P>
The classes are used to write the CostEstimator applet. Classes
whose names are italicized are specific to this applet. Classes
without italicized names are standard Java classes that are used
as base classes for CostEstimator classes.
<P>
The <TT>CostEstimator</TT> class is, of course, the main class
and extends <TT>Applet</TT>. The <TT>CostDriverPanel</TT> class
is an abstract class that is implemented by <TT>ChoicePanel</TT>
and <TT>ProjectPanel</TT>. These classes control the area at the
top right of the applet where values for the cost drivers are
entered. The fields for each of the cost-driver categories are
collected into one of the subclasses of <TT>CostDriverPanel</TT>.
<P>
The <TT>Rating</TT> class is a low-level class that associates
a rating (for example, &quot;Low&quot;) with a value (1.19) within
a cost driver (&quot;Analyst capability&quot;). The <TT>CostDriver</TT>
class stores all information about the cost driver, including
its name and possible ratings.
<P>
The <TT>ImagemapRect</TT> and <TT>ImageCanvas</TT> classes are
used to create the imagemap. An imagemap is painted on the <TT>ImageCanvas</TT>.
An <TT>ImagemapRect</TT> indicates an area on the <TT>ImageCanvas</TT>
that causes the displayed <TT>CostDriverPanel</TT> to change.
<P>
Finally, the <TT>SummaryFrame</TT> class is used to provide a
frame that will appear in response to pressing the Summary button.
The <TT>SummaryFrame</TT> displays details on the values selected
for each cost driver.
<H2><A NAME="StoringCostDriversandRatings"><FONT SIZE=5 COLOR=#FF0000>
Storing Cost Drivers and Ratings</FONT></A></H2>
<P>
An instance of the <TT>CostDriver</TT> class, shown in Listing
23.1, is used to represent one of the 15 COCOMO cost drivers.
The constructor for <TT>CostDriver</TT> is passed the name of
the driver and a vector of ratings. This vector contains instances
of the <TT>Rating</TT> class, which is shown in Listing 23.2.
<HR>
<BLOCKQUOTE>
<B>Listing 23.1. CostDriver.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.util.*;
import Rating;
// This class stores the name of a cost driver (e.g.,
// &quot;Reliability&quot;) and the ratings (e.g., &quot;Low&quot;, &quot;Nominal&quot;,
// &quot;High&quot;) that can be selected for it.
class CostDriver extends Object
{
  public String name;    // the name of the driver, for
               // example, &quot;Reliability&quot;
  public Vector ratings;
  public CostDriver(String name, Vector ratings)
  {
    this.name = name;
    this.ratings = (Vector)ratings.clone();
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 23.2. Rating.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
// This class represents a rating that can be selected for a
// cost driver. It stores both the name of the rating (Low, High,
// etc.) and the multiplier to use if this rating is selected.
// For example, the High rating for Complexity implies a
// multiplier of 1.15.
public class Rating extends Object
{
  public String name;
  public float multiplier;
  Rating(String str, float value)
  {
    name = str;
    multiplier = value;
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>Rating</TT> class represents a paired name and multiplier.
For example, the Very Low rating for Reliability implies a multiplier
of 0.75. A new <TT>Rating</TT> object could be created with these
values as shown here:
<BLOCKQUOTE>
<PRE>
new Rating(&quot;Very low&quot;, 0.75F);
</PRE>
</BLOCKQUOTE>
<P>
To create a new instance of the <TT>CostDriver</TT> class, you
create a vector of <TT>Rating</TT> objects and pass this to the
<TT>CostDriver</TT> constructor. This could be carried out in
the following way:
<BLOCKQUOTE>
<PRE>
// create a vector of Reliability ratings
Vector relyRatings = new Vector(5);
relyRatings.addElement(new Rating(&quot;Very low&quot;,  0.75F));
relyRatings.addElement(new Rating(&quot;Low&quot;,    0.88F));
relyRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
relyRatings.addElement(new Rating(&quot;High&quot;,    1.15F));
relyRatings.addElement(new Rating(&quot;Very high&quot;, 1.40F));
// create the new cost driver
CostDriver cd = new CostDriver(&quot;Reliability&quot;, relyRatings);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="ProgrammingtheUserInterface"><FONT SIZE=5 COLOR=#FF0000>
Programming the User Interface</FONT></A></H2>
<P>
To create the user interface for the CostEstimator, you need to
use the <TT>GridBagLayout</TT> layout manager. The other layout
managers do not offer the flexibility necessary to create this
user interface. When you consider the main screen of the CostEstimator,
you realize that it is readily partitioned into four main areas:
an area for the imagemap, an area for entering values for the
cost drivers, an area for entering KLOC and viewing the results,
and an area containing the buttons. Figure 23.3 shows the main
screen of the CostEstimator but has been annotated with lines
that indicate the boundaries of these areas.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-3.gif"><B> Figure 23.3 : </B><I>The four main areas of  the CostEstimator  user interface.
</I></A><P>
<P>
To create this interface, the <TT>init</TT> method of <TT>CostEstimator</TT>
creates a new <TT>GridBagLayout</TT> layout manager and assigns
it to the applet. The <TT>init</TT> method then calls four worker
methods, each of which creates one of the areas shown in Figure
23.4. This can be seen in the <TT>init</TT> method, as shown here:
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-4.gif"><B> Figure 23.4 : </B><I>A ChoicePanel displaying personnel-related cost drivers.
</I></A><P>
<BLOCKQUOTE>
<PRE>
public void init()
{
  // Create a GridBagLayout and use it as the applet's
  // layout manager
  GridBagLayout layout = new GridBagLayout();
  setLayout(layout);
  // create each of the main areas of the user interface
  CreateImagemap(layout);
  CreateCardPanel(layout);
  CreateResultsPanel(layout);
  CreateButtonPanel(layout);
  resize(400, 320);
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="CreatingtheImagemap">
Creating the Imagemap</A></H3>
<P>
The first of the four areas on the applet user interface is an
imagemap. An imagemap is a bitmap that includes selectable areas
within it. In this case the imagemap is a bitmap showing abbreviations
for each of four groupings of COCOMO cost drivers. When the user
clicks the mouse over the PRD area of the imagemap, the product-related
cost drivers are displayed to the right of the imagemap. Similarly,
clicking the mouse over CMP displays the computer-related cost
drivers, PER displays personnel-related cost drivers, and PRJ
displays project-related cost drivers.
<P>
The method <TT>CreateImagemap</TT> is called from within <TT>init</TT>
and is as shown here:
<BLOCKQUOTE>
<PRE>
private void CreateImagemap(GridBagLayout parentLayout)
{
  // create the image
  Image image = getImage(getDocumentBase(), &quot;map.gif&quot;);
  // create a canvas on which the image will be displayed
  imageCanvas = new ImageCanvas(image);
  // place the canvas on the applet using the applet's
  // layout manager
  GridBagConstraints gbc = new GridBagConstraints();
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  gbc.fill = GridBagConstraints.BOTH;
  parentLayout.setConstraints(imageCanvas, gbc);
  add(imageCanvas);
}
</PRE>
</BLOCKQUOTE>
<P>
This method loads the image <TT>map.gif</TT> from the applet's
base directory. It then creates an image canvas based on the retrieved
image. The image canvas is then placed on the applet using the
<TT>parentLayout</TT> parameter. The <TT>ImageCanvas</TT> class
encapsulates the details of the imagemap. <TT>ImageCanvas</TT>
is shown in Listing 23.3.
<HR>
<BLOCKQUOTE>
<B>Listing 23.3. The ImageCanvas class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class ImageCanvas extends Canvas
{
  private Image image;
  private Vector rects;
  private ImagemapRect lastrect;
  // construct an image canvas based on the specified image
  // and the currently selected portion of the imagemap
  ImageCanvas(Image image)
  {
    resize(50,50);
    this.image=image;
    // allocate a vector to hold the ImagemapRects
    rects = new Vector();
    // all the ImagemapRects that describe the hotspots
    // on the imagemap
    rects.addElement(new ImagemapRect(0,  0, 50, 50,
        &quot;Product&quot;));
    rects.addElement(new ImagemapRect(49, 0, 50, 50,
        &quot;Computer&quot;));
    rects.addElement(new ImagemapRect(0, 49, 50, 50,
        &quot;Personnel&quot;));
    rects.addElement(new ImagemapRect(49, 49, 50, 50,
        &quot;Project&quot;));
    // store the last selected ImagemapRect
    lastrect = (ImagemapRect)rects.elementAt(0);
  }
  public void paint(Graphics g)
  {
    // paint the image
    g.drawImage(image, 0, 0, this);
    // highlight the selected location
    g.setXORMode(Color.red);
    g.drawRect(lastrect.x, lastrect.y, lastrect.width,
        lastrect.height);
    g.drawRect(lastrect.x+1, lastrect.y+1, lastrect.width-2,
        lastrect.height-2);
    g.drawRect(lastrect.x+2, lastrect.y+2, lastrect.width-4,
        lastrect.height-4);
  }
  // Determine if the mouse pointer was clicked over an area in
  // the imagemap that isn't already the current selection
  public boolean NewImageSelected(int x, int y,
      StringBuffer cardName)
  {
    boolean result = false;    // assume failure
    // normalize the coordinates relative to the ImageCanvas
    int xPos = x - bounds().x;
    int yPos = y - bounds().y;
    // determine which rectangle (if any) was selected
    ImagemapRect r = InWhichRect(xPos, yPos);
    // if a rectangle was selected and it isn't the same
    // one that is already selected, a new area has been
    // selected
    if (r != null &amp;&amp; r != lastrect)
    {
      lastrect = r;
      cardName.append(r.cardName);
      result = true;
    }
    return result;
  }
  // determine which ImageMapRect (if any) the mouse pointer
  // is in
  private ImagemapRect InWhichRect(int x, int y)
  {
    // use an enumeration to move through each ImagemapRect
    // until finding one which encloses the point (x, y)
    for (Enumeration enum = rects.elements();
        enum.hasMoreElements(); )
    {
      ImagemapRect r = (ImagemapRect)enum.nextElement();
      if (r.inside(x, y))
        return r;
    }
    return null;
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>ImageCanvas</TT> extends <TT>Canvas</TT> by drawing an image
on the canvas and by storing a vector of areas that represent
the selectable areas of the imagemap. The <TT>ImageCanvas</TT>
constructor is passed the image that will be displayed and stores
a reference to it. It then allocates a vector named <TT>rects</TT>
and uses <TT>addElement</TT> to add four new instances of the
<TT>ImageRect</TT> class to the vector.
<P>
The <TT>ImageRect</TT> class stores the location and dimensions
of a rectangle and a name representing that area. For example,
<TT>ImagemapRect(0, 49, 50, 50, &quot;Personnel&quot;)</TT> creates
an <TT>ImageRect</TT> named <TT>Personnel</TT> that begins at
0, 49 with both width and height of 50. The <TT>ImageRect</TT>
class is written as follows:
<BLOCKQUOTE>
<PRE>
class ImagemapRect extends Rectangle {
  String cardName;
  public ImagemapRect(int x, int y,int w,int h, String cardName)
  {
    super(x,y,w,h);
    this.cardName = cardName;
  }
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>paint</TT> method for <TT>ImageCanvas</TT> uses <TT>drawImage</TT>
to display the image. To indicate which area in the imagemap is
currently selected, a red border is drawn around the most recently
selected <TT>ImageRect</TT>. The member variable <TT>lastrect</TT>
always holds the most recently selected <TT>ImageRect</TT>, so
<TT>setXORMode</TT> and three calls to <TT>drawRect</TT> are used
to draw the red border.
<P>
The methods <TT>NewImageSelected</TT> and <TT>InWhichRect</TT>
are used to determine whether the user has clicked the mouse over
an <TT>ImageRect</TT> within the imagemap. <TT>NewImageSelected</TT>
is passed the x and y coordinates of the mouse click. It then
normalizes these relative to the coordinates of the canvas using
<TT>bounds</TT>. <TT>NewImageSelected</TT> then calls <TT>InWhichRect</TT>
to determine in which <TT>ImagemapRect</TT>, if any, the mouse
click occurred. If the mouse was clicked inside an <TT>ImagemapRect</TT>
that is not the same as <TT>lastrect</TT>, the new value is stored
in <TT>lastrect</TT> and the name of the selection is stored.
<P>
In the <TT>CostEstimator</TT> applet class it is necessary to
override the <TT>mouseDown</TT> method to look for mouse button
presses that occur when the mouse pointer is over the imagemap.
This is done as shown here:
<BLOCKQUOTE>
<PRE>
public boolean mouseDown(Event e, int x, int y)
{
  StringBuffer cardName = new StringBuffer();
  // if the button was pressed when the mouse pointer was
  // over the imagemap, get the name of the card to display
  // in the cardPanel.
  if (imageCanvas.NewImageSelected(x,y,cardName) == true) {
    cardLayout.show(cardPanel, cardName.toString());
    imageCanvas.repaint();
  }
  return true;
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="SelectingProjectAttributes">
Selecting Project Attributes</A></H3>
<P>
The second area on the applet user interface is for entering values
for the various cost drivers. The group of fields displayed in
this area is controlled by the user's selection in the imagemap.
Because this area is used to display different fields at different
times, a panel is placed over this entire area, and a <TT>CardLayout</TT>
is assigned as the panel's layout manager. Depending on the imagemap
selection, the appropriate card is displayed on the panel. This
can be seen in the following code:
<BLOCKQUOTE>
<PRE>
private void CreateCardPanel(GridBagLayout parentLayout)
{
  // create the panel
  cardPanel = new Panel();
  // place the panel on the applet using the applet's
  // layout manager
  GridBagConstraints gbc = new GridBagConstraints();
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  gbc.fill = GridBagConstraints.BOTH;
  gbc.weightx=1;
  parentLayout.setConstraints(cardPanel, gbc);
  add(cardPanel);
  // create a CardLayout and assign it to the panel
  cardLayout = new CardLayout();
  cardPanel.setLayout(cardLayout);
  // create a vector to hold the CostDriverPanels that
  // will be placed on cardPanel
  CostDriverPanelVector = new Vector(4);
  // create each of the panels that can be displayed
  // on this card
  CreateProductPanel();
  CreateComputerPanel();
  CreatePersonnelPanel();
  CreateProjectPanel();
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>CreateCardPanel</TT> method allocates a new <TT>Panel</TT>
instance named <TT>cardPanel</TT>. It then creates an instance
of <TT>GridBagConstraints</TT> and establishes constraints that
the panel is the last item on the line and that it should grow
in both directions. The panel is added to the applet using <TT>parentLayout</TT>,
the <TT>GridBagLayout</TT> layout manager that was allocated in
<TT>init</TT> to handle the applet's overall layout.
<P>
Next, a new <TT>CardLayout</TT> is constructed and assigned to
the panel. A four-element vector is then allocated. This vector
will be used to store each of the four panels that will be placed
on the <TT>CardPanel</TT> and that will be toggled using the imagemap.
Finally, each of the four methods at the end of <TT>CreateCardPanel</TT>
creates one of the panels displayed on <TT>CardPanel</TT>.
<H4>The CostDriverPanel Class</H4>
<P>
Each of the panels that will be placed on <TT>CardPanel</TT> will
be of type <TT>CostDriverPanel</TT>. <TT>CostDriverPanel</TT>,
however, is an abstract class. Two subclasses of <TT>CostDriverPanel</TT>,
<TT>ChoicePanel</TT> and <TT>ProjectPanel</TT>, are provided and
are concrete classes that can be constructed.
<P>
The <TT>CostDriverPanel</TT> class, as shown in Listing 23.4,
provides an overridden <TT>paint</TT> method that draws a border
around the panel. Additionally, three abstract methods (<TT>getMultiplier</TT>,
<TT>SetDefaults</TT>, and <TT>GetSummary</TT>) are declared. The
<TT>getMultiplier</TT> method is used to get the partial Effort
Adjustment Factor for the cost drivers on the panel. The <TT>SetDefaults</TT>
method is used to restore each of the cost drivers on the panel
to its default value. <TT>GetSummary</TT> is used to generate
a string summarizing the selections for the cost drivers on the
panel.
<HR>
<BLOCKQUOTE>
<B>Listing 23.4. CostDriverPanel.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;
// This is an abstract base class that can be extended
// for displaying cost drivers
public abstract class CostDriverPanel extends Panel
{
  public CostDriverPanel()
  {
    super();
  }
  public void paint(Graphics g)
  {
    // draw a rectangle around the panel
    Rectangle rect = bounds();
    g.drawRect(rect.x, rect.y, rect.x+rect.width-1,
        rect.y + rect.height-1);
  }
  // calculate the effort adjustment multiplier for
  // the cost drivers on this panel
  public abstract float getMultiplier();
  // set the default values for all cost drivers on this panel
  public abstract void SetDefaults();
  // return a String summarizing selections on this panel
  public abstract String GetSummary();
}
</PRE>
</BLOCKQUOTE>
<HR>
<H4>The ChoicePanel Class</H4>
<P>
The <TT>ChoicePanel</TT> class is a non-abstract subclass of <TT>CostDriverPanel</TT>.
A <TT>ChoicePanel</TT> can be used to automatically position and
display cost drivers. Each cost driver will be displayed as a
choice field. Figure 23.4 shows the <TT>ChoicePanel</TT> created
using the personnel cost drivers.
<P>
Each <TT>ChoicePanel</TT> object contains the following member
variables:
<BLOCKQUOTE>
<PRE>
Choice choiceArray[];
Vector costDrivers;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>choiceArray</TT> is an array of choice variables. One
item is allocated in the array for each of the cost drivers displayed
on the <TT>ChoicePanel</TT>. The <TT>costDrivers</TT> vector holds
instances of the <TT>CostDriver</TT> class that was described
earlier in this chapter. These variables are both used extensively
in the <TT>ChoicePanel</TT> constructor, which is shown in Listing
23.5.
<P>
The constructor is passed a vector of <TT>CostDriver</TT> objects,
and these are cloned into the <TT>costDrivers</TT> member variable.
The <TT>choiceArray</TT> is allocated based on the size of this
vector. Next, the layout manager for the <TT>ChoicePanel</TT>
is constructed and assigned to the object. Because we want to
place a <TT>Label</TT> and <TT>Choice</TT> objects on the same
lines, a <TT>GridBagLayout</TT> is used.
<HR>
<BLOCKQUOTE>
<B>Listing 23.5. The ChoicePanel constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public ChoicePanel(Vector drivers)
{
  super();    // construct the parent class
  // clone the drivers
  costDrivers = (Vector) drivers.clone();
  // allocate an array of Choice fields, each cost driver
  // will be entered in a Choice field
  choiceArray = new Choice[costDrivers.size()];
  // create and use a GridBagLayout layout manager
  GridBagLayout layout = new GridBagLayout();
  GridBagConstraints gbc = new GridBagConstraints();
  setLayout(layout);
  // use an enumeration to move through the cost drivers to
  // be displayed on this panel
  int i = 0;
  for (Enumeration e=costDrivers.elements();
      e.hasMoreElements(); i++)
  {
    CostDriver cd = (CostDriver)e.nextElement();
    // allocate a Choice for each cost driver
    choiceArray[i] = new Choice();
    // use an enumeration to move through the ratings
    // within each cost driver (e.g., Low, Nominal, High)
    for (Enumeration enum = cd.ratings.elements();
        enum.hasMoreElements() ;)
    {
      Rating r = (Rating)enum.nextElement();
      // add the name of the rating to the Choice
      choiceArray[i].addItem(r.name);
    }
    // select this item by default
    choiceArray[i].select(&quot;Nominal&quot;);
    // add the label to the panel
    gbc.gridwidth = 1;
    Label label = new Label(cd.name);
    gbc.anchor = GridBagConstraints.EAST;
    layout.setConstraints(label, gbc);
    add(label);
    // add the Choice field to the panel
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.anchor = GridBagConstraints.WEST;
    gbc.insets.left=5;
    layout.setConstraints(choiceArray[i], gbc);
    add(choiceArray[i]);
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Next, an enumeration is used to move through the elements in the
<TT>costDrivers</TT> vector. For each element, the <TT>CostDriver</TT>
is cast into a local variable, <TT>cd</TT>, and an item in the
<TT>choiceArray</TT> is allocated to hold the choice object that
will contain the selections for this cost driver. After the elements
are added to the choice, <TT>select(&quot;Nominal&quot;)</TT>
is used to set the default item. Finally, a label and the choice
are added to the panel.
<P>
Within the <TT>CostEstimator</TT> class, <TT>ChoicePanel</TT>
objects are constructed for the product, computer, and personnel
cost-estimator categories. The project category uses a different
subclass of <TT>CostDriverPanel</TT> to display its cost drivers.
These choice panels are created by the methods <TT>CreateProductPanel</TT>,
<TT>CreateComputerPanel</TT>, and <TT>CreatePersonnelPanel</TT>.
These methods are very similar. The <TT>CreatePersonnelPanel</TT>
method is shown in Listing 23.6.
<HR>
<BLOCKQUOTE>
<B>Listing 23.6. CreatePersonnelPanel in the CostEstimator class.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void CreatePersonnelPanel()
{
  // allocate a vector that will hold the cost drivers
  // that are displayed on this panel
  Vector costDrivers = new Vector(5);
  // create a vector of Analyst Capability ratings
  Vector acapRatings = new Vector(5);
  acapRatings.addElement(new Rating(&quot;Very low&quot;,  1.46F));
  acapRatings.addElement(new Rating(&quot;Low&quot;,    1.19F));
  acapRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  acapRatings.addElement(new Rating(&quot;High&quot;,    0.86F));
  acapRatings.addElement(new Rating(&quot;Very high&quot;, 0.71F));
  // create the Analyst Capability CostDriver and add it to
  // the vector
  costDrivers.addElement(new CostDriver(&quot;Analyst Capability&quot;,
      acapRatings));
  // create a vector of Applications Experience ratings
  Vector aexpRatings = new Vector(5);
  aexpRatings.addElement(new Rating(&quot;Very low&quot;,  1.29F));
  aexpRatings.addElement(new Rating(&quot;Low&quot;,    1.13F));
  aexpRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  aexpRatings.addElement(new Rating(&quot;High&quot;,    0.91F));
  aexpRatings.addElement(new Rating(&quot;Very high&quot;, 0.82F));
  // create the Applications Experience CostDriver and add
  // it to the vector
  costDrivers.addElement(new CostDriver(
      &quot;Applications Experience&quot;, aexpRatings));
  // create a vector of Programmer Capability ratings
  Vector pcapRatings = new Vector(5);
  pcapRatings.addElement(new Rating(&quot;Very low&quot;,  1.42F));
  pcapRatings.addElement(new Rating(&quot;Low&quot;,    1.17F));
  pcapRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  pcapRatings.addElement(new Rating(&quot;High&quot;,    0.86F));
  pcapRatings.addElement(new Rating(&quot;Very high&quot;, 0.70F));
  // create the Programmer Capability CostDriver and add
  // it to the vector
  costDrivers.addElement(new CostDriver(
      &quot;Programmer Capability&quot;, pcapRatings));
  // create a vector of Virtual Machine Experience ratings
  Vector vexpRatings = new Vector(4);
  vexpRatings.addElement(new Rating(&quot;Very low&quot;,  1.21F));
  vexpRatings.addElement(new Rating(&quot;Low&quot;,    1.10F));
  vexpRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  vexpRatings.addElement(new Rating(&quot;High&quot;,    0.90F));
  // create the Virtual Machine Experience CostDriver and
  // add it to the vector
  costDrivers.addElement(new CostDriver(
      &quot;Virtual Machine Experience&quot;, vexpRatings));
  // create a vector of Language Experience ratings
  Vector lexpRatings = new Vector(4);
  lexpRatings.addElement(new Rating(&quot;Very low&quot;,  1.14F));
  lexpRatings.addElement(new Rating(&quot;Low&quot;,    1.07F));
  lexpRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  lexpRatings.addElement(new Rating(&quot;High&quot;,    0.95F));
  // create the Language Experience CostDriver and add
  // it to the vector
  costDrivers.addElement(new CostDriver(
      &quot;Language Experience&quot;, lexpRatings));
  // create the new panel and add it to the card
  ChoicePanel personnelPanel = new ChoicePanel(costDrivers);
  cardPanel.add(&quot;Personnel&quot;, personnelPanel);

  // add this panel to the vector of all CostDriverPanels
  CostDriverPanelVector.addElement(personnelPanel);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>CreatePersonnelPanel</TT> allocates a vector, <TT>costDrivers</TT>,
that is used to hold the cost drivers that will be displayed when
the personnel area of the imagemap has been selected. For each
individual cost driver, a vector is allocated and <TT>addElement</TT>
is used to add new <TT>Rating</TT> objects. As you saw earlier
in this chapter, a <TT>Rating</TT> object is constructed with
the name and value for the rating. For example, a Very Low rating
for Language Experience is associated with an Effort Adjustment
Factor of 1.14. After each of the vectors is created and added
to <TT>costDrivers</TT>, a new choice panel is created and the
new choice panel is added to the vector of all <TT>ChoicePanels</TT>.
<P>
Because <TT>ChoicePanel</TT> is a subclass of <TT>CostDriverPanel</TT>,
it must provide implementations of the <TT>getMultiplier</TT>,
<TT>SetDefaults</TT>, and <TT>GetSummary</TT> methods. The <TT>getMultiplier</TT>
method of <TT>ChoicePanel</TT> is implemented as follows:
<BLOCKQUOTE>
<PRE>
public float getMultiplier()
{
  float value = 1.0f;
  int i = 0;
  // Use an enumeration to move through each of the cost
  // drivers on this panel.
  for (Enumeration e=costDrivers.elements();
      e.hasMoreElements(); i++)
  {
    // For each cost driver, get the rating associated
    // with the current selection in the Choice field.
    CostDriver cd = (CostDriver)e.nextElement();
    int index = choiceArray[i].getSelectedIndex();
    Rating r = (Rating)cd.ratings.elementAt(index);
    // multiply each of the multipliers together to
    // get the final result.
    value *= r.multiplier;
  }
  return value;
}
</PRE>
</BLOCKQUOTE>
<P>
To calculate the multiplier, a local variable, <TT>value</TT>,
is declared and set to 1.0 initially. An enumeration then steps
through each of the cost drivers on the choice panel. For each
cost driver, <TT>getSelectedIndex</TT> selects the item number
of the selection for each cost driver. The rating associated with
each item is then retrieved from <TT>cd.ratings.elementAt(index)</TT>.
As the enumeration proceeds through the cost drivers, the value
is updated by multiplying it with the <TT>multiplier</TT> member
in the <TT>Rating</TT> object, <TT>r</TT>.
<P>
The <TT>SetDefaults</TT> method is much simpler. All that is necessary
is to loop through the items in the array of <TT>Choice</TT> objects
using <TT>select</TT> to ensure that the item labeled Nominal
is selected for each choice. This is done as shown here:
<BLOCKQUOTE>
<PRE>
public void SetDefaults()
{
  int qty = costDrivers.size();
  for (int i=0; i &lt; qty; i++)
    choiceArray[i].select(&quot;Nominal&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>GetSummary</TT> method is used to generate a string that
summarizes the selections made on a choice panel. For example,
a string summarizing the personnel category of cost drivers could
appear as shown here:
<BLOCKQUOTE>
<PRE>
Analyst Capability
  Nominal
  1
Applications Experience
  Nominal
  1
Programmer Capability
  Nominal
  1
Virtual Machine Experience
  Nominal
  1
Language Experience
  High
  0.95
</PRE>
</BLOCKQUOTE>
<P>
The <TT>GetSummary</TT> method of <TT>ChoicePanel</TT> is written
like this:
<BLOCKQUOTE>
<PRE>
public String GetSummary()
{
  StringBuffer buf = new StringBuffer();
  // use an enumeration to move through each of the drivers
  int i=0;
  for (Enumeration e=costDrivers.elements();
      e.hasMoreElements(); i++)
  {
    // append the name of the driver
    CostDriver cd = (CostDriver)e.nextElement();
    buf.append(cd.name+&quot;\r\n&quot;);
    // append the name of the selected value
    buf.append(&quot;\t&quot; + choiceArray[i].getSelectedItem() +
        &quot;\r\n&quot;);
    // retrieve and then append the multiplier for the
    // selected value for this cost driver
    int index = choiceArray[i].getSelectedIndex();
    Rating r = (Rating)cd.ratings.elementAt(index);

    buf.append(&quot;\t&quot; + r.multiplier + &quot;\r\n&quot;);
  }
  return buf.toString();
}
</PRE>
</BLOCKQUOTE>
<P>
As with many other <TT>ChoicePanel</TT> methods, an enumeration
is used to move through the <TT>costDrivers</TT> vector. Because
this method will be dynamically building a string of unknown length,
a <TT>StringBuffer</TT>, rather than a <TT>String</TT>, is used
to hold the text under construction. First, the name of the cost
driver is added to the string buffer. Next, <TT>getSelectedItem</TT>
is used to get the name of the selection for the <TT>Choice</TT>
object. Finally, <TT>getSelectedIndex</TT> is used to get the
index number of the selected item, and this value is passed to
<TT>cd.ratings.elementAt</TT> to retrieve a <TT>Rating</TT> object.
From this object, the Effort Adjustment Factor is read from <TT>r.multiplier</TT>
and appended to the buffer.
<H4>The ProjectPanel Class</H4>
<P>
The <TT>ProjectPanel</TT> class, like <TT>ChoicePanel</TT>, is
a subclass of <TT>CostDriverPanel</TT>. The <TT>ProjectPanel</TT>
class is used only for displaying the project-related cost drivers.
It is similar to <TT>ChoicePanel</TT> in that it also uses <TT>Choice</TT>
objects to solicit user input. <TT>Choice</TT> objects, however,
are used only for the Modern Practices and Software Tools cost
drivers. Options for the Schedule Constraints cost driver are
shown as a checkbox group, as shown in Figure 23.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-5.gif"><B> Figure 23.5 : </B><I>The ProjectPanel display-ing the project-related  cost drivers.
</I></A><P>
<P>
Because the <TT>ProjectPanel</TT> uses both <TT>Choice</TT> and
<TT>Checkbox</TT> objects, the following member variables are
defined in <TT>ProjectPanel</TT>:
<BLOCKQUOTE>
<PRE>
Choice choiceArray[];
Vector costDrivers;
Vector cbVector;
CheckboxGroup cbGroup;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>choiceArray</TT> and <TT>costDrivers</TT> members are
used in the same way each was used in <TT>ChoicePanel</TT>. The
<TT>cbVector</TT> member holds the individual checkbox objects
that are placed on the panel. The variable <TT>cbGroup</TT> is
a <TT>CheckboxGroup</TT> that consists of all the checkboxes on
the panel.
<P>
The <TT>ProjectPanel</TT> constructor is shown in Listing 23.7.
After calling <TT>super</TT> to create the panel, the constructor
calls the method <TT>LoadCostDrivers</TT>. This method, shown
in Listing 23.8, is similar to the method <TT>CreatePersonnelPanel</TT>
that was shown in Listing 23.6. All that <TT>LoadCostDrivers</TT>
does is create the <TT>costDrivers</TT> vector that will be used
throughout <TT>ProjectPanel</TT>'s other methods.
<HR>
<BLOCKQUOTE>
<B>Listing 23.7. The ProjectPanel constructor.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public ProjectPanel()
{
  super();
  LoadCostDrivers();     // load values into costDrivers
  // allocate an array of Choice fields that will hold
  // all but one cost driver
  int qty = costDrivers.size();
  choiceArray = new Choice[qty - 1];
  // create and use a GridBagLayout layout manager
  GridBagLayout layout = new GridBagLayout();
  GridBagConstraints gbc = new GridBagConstraints();
  setLayout(layout);
  // Loop through the cost drivers, creating a Choice field
  // for each. Process all but the last one. The last one
  // will be displayed using Checkboxes instead of a Choice
  // field.
  int i = 0;
  for (i=0; i&lt;qty-1; i++)
  {
    CostDriver cd = (CostDriver)costDrivers.elementAt(i);
    // allocate a Choice for each cost driver
    choiceArray[i] = new Choice();
    // use an enumeration to move through the ratings
    // within each cost driver (e.g., Low, Nominal, High)
    for (Enumeration enum = cd.ratings.elements();
        enum.hasMoreElements() ;)
    {
      Rating r = (Rating)enum.nextElement();
      // add the name of the rating to the Choice
      choiceArray[i].addItem(r.name);
    }
    // select this item by default
    choiceArray[i].select(&quot;Nominal&quot;);
    // add the label to the panel
    gbc.gridwidth = 1;
    Label label = new Label(cd.name);
    gbc.anchor = GridBagConstraints.EAST;
    layout.setConstraints(label, gbc);
    add(label);
    // add the Choice field to the panel
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.anchor = GridBagConstraints.WEST;
    gbc.insets.left=5;
    layout.setConstraints(choiceArray[i], gbc);
    add(choiceArray[i]);
  }
  // use the last cost driver to make a CheckboxGroup
  CostDriver cd = (CostDriver)costDrivers.elementAt(qty-1);
  // create a vector to hold the Checkboxes
  cbVector = new Vector(6);
  // add the label for the Checkbox group
  gbc.gridwidth = 1;
  Label label = new Label(cd.name);
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  gbc.anchor = GridBagConstraints.WEST;
  layout.setConstraints(label, gbc);
  add(label);
  // keep track of how many items are on each line, so that
  // items can be properly positioned.
  int itemsOnLine=0;
  // create a new CheckboxGroup
  cbGroup = new CheckboxGroup();
  // all the checkbox items will be anchored on the west
  // side, so set this value before the loop
  gbc.anchor = GridBagConstraints.WEST;
  // use an enumeration to move through the ratings for the
  // cost driver
  for (Enumeration enum = cd.ratings.elements();
      enum.hasMoreElements(); itemsOnLine++)
  {
    Rating r = (Rating)enum.nextElement();
    // the &quot;Nominal&quot; item should be checked by default
    boolean checked = r.name.equals(&quot;Nominal&quot;);
    // if line is almost full of items, tell this item to
    // use the remainder of the space
    if (itemsOnLine == 2)
    {
      gbc.gridwidth = GridBagConstraints.REMAINDER;
      itemsOnLine = 0;
    }
    else
      gbc.gridwidth = 1;
    // create the new checkbox and add it to the screen
    Checkbox cb = new Checkbox(r.name, cbGroup, checked);
    layout.setConstraints(cb, gbc);
    add(cb);
    // then add it to the vector of checkboxes
    cbVector.addElement(cb);
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 23.8. The ProjectPanel.LoadCostDrivers method.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void LoadCostDrivers()
{
  // allocate a vector that will hold the cost drivers
  // that are displayed on this panel
  costDrivers = new Vector(3);
  // create a vector of Modern Practices ratings
  Vector modpRatings = new Vector(5);
  modpRatings.addElement(new Rating(&quot;Very low&quot;,  1.24F));
  modpRatings.addElement(new Rating(&quot;Low&quot;,    1.10F));
  modpRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  modpRatings.addElement(new Rating(&quot;High&quot;,    0.91F));
  modpRatings.addElement(new Rating(&quot;Very high&quot;, 0.82F));
  // create the Modern Practices CostDriver and add it to
  // the vector
  costDrivers.addElement(new CostDriver(&quot;Modern Practices&quot;,
      modpRatings));
  // create a vector of Software Tools ratings
  Vector toolRatings = new Vector(5);
  toolRatings.addElement(new Rating(&quot;Very low&quot;,  1.24F));
  toolRatings.addElement(new Rating(&quot;Low&quot;,    1.10F));
  toolRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  toolRatings.addElement(new Rating(&quot;High&quot;,    0.91F));
  toolRatings.addElement(new Rating(&quot;Very high&quot;, 0.83F));
  // create the Software Tools CostDriver and add it to
  // the vector
  costDrivers.addElement(new CostDriver(&quot;Software Tools&quot;,
      toolRatings));
  // create a vector of Schedule Constraints ratings
  Vector scedRatings = new Vector(5);
  scedRatings.addElement(new Rating(&quot;Very low&quot;,  1.23F));
  scedRatings.addElement(new Rating(&quot;Low&quot;,    1.08F));
  scedRatings.addElement(new Rating(&quot;Nominal&quot;,  1.00F));
  scedRatings.addElement(new Rating(&quot;High&quot;,    1.04F));
  scedRatings.addElement(new Rating(&quot;Very high&quot;, 1.10F));
  // create the Schedule Constraints CostDriver and add
  // it to the vector
  costDrivers.addElement(new CostDriver(
      &quot;Schedule Constraints&quot;,  scedRatings));
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
After the <TT>costDrivers</TT> vector has been loaded, a <TT>for</TT>
loop is used to iterate through all but the last cost driver on
this panel. The last driver is skipped because it will be displayed
using checkboxes. To do this, the last element in the <TT>costDrivers</TT>
vector is cast into the variable <TT>cd</TT> as shown here:
<BLOCKQUOTE>
<PRE>
CostDriver cd = (CostDriver)costDrivers.elementAt(qty-1);
</PRE>
</BLOCKQUOTE>
<P>
Next, <TT>cbVector</TT> is allocated to hold up to six elements,
the most required by any COCOMO cost driver. After adding a label
to the display, the variable <TT>itemsOnLine</TT> is set to <TT>0</TT>.
This variable will be used to count how many checkbox objects
have been placed on the current line so that the layout manager
can be correctly told when to move to the next line in the layout.
<P>
After a new <TT>CheckboxGroup</TT> object is constructed and placed
in <TT>cbGroup</TT>, the <TT>GridBagConstraints</TT> are set to
<TT>WEST</TT>. This means that items will be aligned along their
left edges. Because this constraint holds true for all the checkbox
items, the constraint is set outside the loop. The loop uses an
enumeration to move through the ratings associated with this cost
driver. Before each new checkbox is added, checks are made to
determine whether the current item is the default item (in which
case its name is <TT>Nominal</TT>) and to ensure that no more
than three checkboxes are on any line.
<P>
<TT>ProjectPanel</TT> is a subclass of <TT>CostDriverPanel</TT>,
and therefore it provides implementations of <TT>getMultiplier</TT>,
<TT>SetDefaults</TT>, and <TT>GetSummary</TT>. Each of these methods
is similar to the equivalent method in <TT>ChoicePanel</TT>, with
the addition of retrieving or setting a value in a checkbox. Because
these methods are so similar, they are not described here but
are included on the CD that accompanies this book.
<H3><A NAME="TheResultsPanel">
The Results Panel</A></H3>
<P>
The third area of the CostEstimator user interface is the results
panel. As you saw in Figure 23.4, the results panel is displayed
at the lower left of the applet's main screen. Creating the results
panel is a relatively straightforward process. To maintain precise
control over the placement of objects on the screen, however,
a <TT>GridBagLayout</TT> layout manager is used. This makes the
<TT>CreateResultsPanel</TT> method, shown in Listing 23.9, fairly
long.
<HR>
<BLOCKQUOTE>
<B>Listing 23.9. The CreateResultsPanel method in CostEstimator.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void CreateResultsPanel(GridBagLayout parentLayout)
{
  // create a panel and add it to the applet using the
  // applet's layout manager
  Panel p = new Panel();
  GridBagConstraints gbc = new GridBagConstraints();
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  gbc.fill = GridBagConstraints.BOTH;
  parentLayout.setConstraints(p, gbc);
  add(p);
  // create and assign a GridBagLayout as the layout manager
  // for this panel
  GridBagLayout layout = new GridBagLayout();
  p.setLayout(layout);
  // place some space at the top of the panel
  Panel space = new Panel();
  gbc.gridheight =3;
  gbc.weighty =1;
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  gbc.fill = GridBagConstraints.BOTH;
  layout.setConstraints(space, gbc);
  p.add(space);
  gbc.weighty = 0;
  // create a Label and TextField for KLOC
  Label klocLabel = new Label(&quot;KLOC:&quot;);
  gbc.gridheight = 1;
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  layout.setConstraints(klocLabel, gbc);
  p.add(klocLabel);
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  klocField = new TextField(5);
  layout.setConstraints(klocField, gbc);
  p.add(klocField);
  // create a Label and TextField for Effort Adjustment
  Label effortAdjustLabel = new Label(&quot;Effort Adjustment:&quot;);
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  layout.setConstraints(effortAdjustLabel, gbc);
  p.add(effortAdjustLabel);
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  effortAdjustmentField = new TextField(5);
  // make the field read-only
  effortAdjustmentField.setEditable(false);
  layout.setConstraints(effortAdjustmentField, gbc);
  p.add(effortAdjustmentField);
  // create a Label and TextField for Person Months
  Label personMonthsLabel = new Label(&quot;Person Months:&quot;);
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  layout.setConstraints(personMonthsLabel, gbc);
  p.add(personMonthsLabel);
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  personMonthsField = new TextField(5);
  // make the field read-only
  personMonthsField.setEditable(false);
  layout.setConstraints(personMonthsField, gbc);
  p.add(personMonthsField);
  // create a Label and TextField for Calendar Months
  Label calendarMonthsLabel = new Label(&quot;Calendar Months:&quot;);
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  layout.setConstraints(calendarMonthsLabel, gbc);
  p.add(calendarMonthsLabel);
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  calendarMonthsField = new TextField(5);
  // make the field read-only
  calendarMonthsField.setEditable(false);
  layout.setConstraints(calendarMonthsField, gbc);
  p.add(calendarMonthsField);
  // create some space at the bottom of the panel
  // so the fields above are properly located
  space = new Panel();
  gbc.gridheight =3;
  gbc.weighty =1;
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  gbc.fill = GridBagConstraints.BOTH;
  layout.setConstraints(space, gbc);
  p.add(space);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The key to understanding <TT>CreateResultsPanel</TT> is understanding
the various panels that are used. Overall, a panel is created
and added to the applet. This panel is the full size of the results
area of the user interface. Both this panel and the applet it
is placed on use <TT>GridBagLayout</TT> as their layout manager.
On this large panel, the following smaller panels are placed:
<UL>
<LI>An empty panel
<LI>A panel containing the labels and text fields
<LI>Another empty panel
</UL>
<P>
The empty panels are both created with the following <TT>GridBagConstraints</TT>:
<BLOCKQUOTE>
<PRE>
gbc.gridheight =3;
gbc.weighty =1;
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbc.fill = GridBagConstraints.BOTH;
</PRE>
</BLOCKQUOTE>
<P>
These constraints allow the empty panels to fill up the vertical
space evenly, thereby centering the panel that contains the labels
and text fields.
<H3><A NAME="CreatingtheButtonPanel">
Creating the Button Panel</A></H3>
<P>
The final part of the CostEstimator applet's user interface is
the set of three buttons at the bottom right of the applet's main
screen. As shown in Figure 23.4, the buttons are labeled Summary,
Recalc, and Reset. These buttons are created by the <TT>CreateButtonPanel</TT>
method shown in Listing 23.10.
<HR>
<BLOCKQUOTE>
<B>Listing 23.10. The CreateButtonPanel method in CostEstimator.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void CreateButtonPanel(GridBagLayout parentLayout)
{
  // create a panel and add it to the applet using the
  // applet's layout manager
  Panel p = new Panel();
  GridBagConstraints gbc = new GridBagConstraints();
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  parentLayout.setConstraints(p, gbc);
  add(p);
  // create and assign a GridBagLayout as the layout manager
  // for this panel
  GridBagLayout layout = new GridBagLayout();
  p.setLayout(layout);
  // place some space above the buttons
  Panel space = new Panel();
  gbc.gridheight =3;
  gbc.weighty =1;
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  gbc.fill = GridBagConstraints.BOTH;
  layout.setConstraints(space, gbc);
  p.add(space);
  // place some space to the left of the buttons
  space = new Panel();
  gbc.gridheight = 4;
  gbc.weighty = 1;
  gbc.gridwidth = GridBagConstraints.RELATIVE;
  gbc.weightx=1;
  layout.setConstraints(space, gbc);
  p.add(space);
  gbc.gridheight = 1;
  gbc.gridwidth = GridBagConstraints.REMAINDER;
  // add the Summary button
  gbc.fill = GridBagConstraints.HORIZONTAL;
  gbc.weightx =1;
  gbc.anchor = GridBagConstraints.EAST;
  Button b = new Button(&quot;Summary&quot;);
  layout.setConstraints(b, gbc);
  p.add(b);
  // add the Recalc button
  b = new Button(&quot;Recalc&quot;);
  layout.setConstraints(b, gbc);
  p.add(b);
  // add the Reset button
  b = new Button(&quot;Reset&quot;);
  layout.setConstraints(b, gbc);
  p.add(b);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>CreateButtonPanel</TT> works much like <TT>CreateResultsPanel</TT>.
First, a panel is constructed and placed onto the applet. Then
a panel named <TT>space</TT> is constructed and placed across
the top of the large panel. Next, another panel is constructed
and also stored in the <TT>space</TT> variable. This panel is
then assigned the following <TT>GridBagConstraints</TT>:
<BLOCKQUOTE>
<PRE>
gbc.gridheight = 4;
gbc.weighty = 1;
gbc.gridwidth = GridBagConstraints.RELATIVE;
gbc.weightx=1;
</PRE>
</BLOCKQUOTE>
<P>
These constraints will cause the panel to be aligned vertically
along the left edge of the panel, beginning just below the previously
placed panel. This is shown in Figure 23.6. After the empty panels
have been placed, the three buttons are constructed and added.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-6.gif"><B> Figure 23.6 : </B><I>Two empty panels are placed on a larger panel to create the Button panel.
</I></A><P>
<H2><A NAME="TheCostEstimatorButtons"><FONT SIZE=5 COLOR=#FF0000>
The CostEstimator Buttons</FONT></A></H2>
<P>
To respond to button presses, it is necessary to include an <TT>action</TT>
method in the <TT>CostEstimator</TT> class. In this case the <TT>action</TT>
method checks the label of the button and then simply calls an
appropriate method based on which button was pressed. This is
carried out in the following way:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
  boolean result=false;
  if(&quot;Reset&quot;.equals(obj))
  {
    DoReset();
    result = true;
  }
  else if(&quot;Recalc&quot;.equals(obj))
  {
    DoRecalc();
    result = true;
  }
  else if(&quot;Summary&quot;.equals(obj))
  {
    ShowSummary();
    result = true;
  }
  return result;
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ResettingDefaultValues">
Resetting Default Values</A></H3>
<P>
If the Reset button has been pressed, the <TT>DoReset</TT> method
is called. This method is written as follows:
<BLOCKQUOTE>
<PRE>
private void DoReset()
{
  // use an enumeration to move through the CostDriverPanels
  for (Enumeration enum = CostDriverPanelVector.elements();
      enum.hasMoreElements(); )
  {
    // for each panel, call SetDefaults
    CostDriverPanel p = (CostDriverPanel)enum.nextElement();
    p.SetDefaults();
  }
}
</PRE>
</BLOCKQUOTE>
<P>
<TT>DoReset</TT> uses the <TT>CostDriverPanelVector</TT> that
contains a reference to each of the <TT>CostDriverPanel</TT>s.
This vector includes three <TT>ChoicePanel</TT> objects (for the
product, computer, and personnel cost driver categories) and one
<TT>ProjectPanel</TT> object. An enumeration is used to move through
the vector, and for each item the <TT>SetDefaults</TT> method
is called. Because <TT>SetDefaults</TT> was declared as abstract
in <TT>CostDriverPanel</TT> and was overridden in <TT>ChoicePanel</TT>
and <TT>ProjectPanel</TT>, the implementations of <TT>SetDefaults</TT>
in these subclasses will be called.
<H3><A NAME="EstimatingtheProjectSchedule">
Estimating the Project Schedule</A></H3>
<P>
Selecting the Recalc button causes the <TT>DoRecalc</TT> method
to be executed. This method is shown in Listing 23.11. <TT>DoRecalc</TT>
reads the user's entry from the <TT>klocField</TT> text field.
This field should contain the number of lines of code in thousands.
Because <TT>klocField</TT> might be blank or contain non-numeric
entries, however, the call to <TT>Float.valueOf(klocField.getText())</TT>
is enclosed in a <TT>try...catch</TT> block that will catch the
exception <TT>NumberFormatException</TT> that could be thrown.
<HR>
<BLOCKQUOTE>
<B>Listing 23.11. The DoRecalc method in the CostEstimator class.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void DoRecalc()
{
  try
  {
    // make sure a number was entered in klocField
    Float kloc = Float.valueOf(klocField.getText());
    // for this level of semidetached COCOMO, start with
    // 1.12 as the base effort adjustment factor
    float effortAdjustment = 1.12F;
    // calculate the Effort Adjustment Factor by calling
    // getMultiplier for each CostDriverPanel
    for (Enumeration e=CostDriverPanelVector.elements();
        e.hasMoreElements(); )
    {
      CostDriverPanel p = (CostDriverPanel)e.nextElement();
      effortAdjustment *= p.getMultiplier();
    }
    // display the Effort Adjustment Factor
    effortAdjustmentField.setText(String.valueOf(
        effortAdjustment));
    // calculate and display the number of person months
    // on the project
    int personMonths=(int)(3.0D*(Math.pow(kloc.floatValue(),
        effortAdjustment)));
    personMonthsField.setText(String.valueOf(personMonths));
    // calculate and display the number of calendar months
    // on the project
    double calendarMonths=2.5*(Math.pow(personMonths, 0.35F));
    calendarMonthsField.setText(String.valueOf(Math.round(
        calendarMonths)));
  }
  catch (NumberFormatException e)
  {
    // if klocField doesn't contain a number, set all
    // the fields to blank
    effortAdjustmentField.setText(&quot;&quot;);
    personMonthsField.setText(&quot;&quot;);
    calendarMonthsField.setText(&quot;&quot;);
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Next, the Effort Adjustment Factor is calculated by setting the
variable <TT>effortAdjustment</TT> to 1.12 initially and then
multiplying <TT>effortAdjustment</TT> by the multiplier calculated
for each cost driver category. After the Effort Adjustment Factor
is calculated, it is displayed in the <TT>effortAdjustmentField</TT>
with the following code:
<BLOCKQUOTE>
<PRE>
effortAdjustmentField.setText(String.valueOf(effortAdjustment));
</PRE>
</BLOCKQUOTE>
<P>
After the Effort Adjustment Factor has been calculated, the estimated
person months and calendar months are calculated. These calculations
are performed according to the intermediate COCOMO equations described
earlier in this chapter. When calculated, each of these fields
is displayed using <TT>setText</TT>.
<H3><A NAME="SummarizingProjectAttributes">
Summarizing Project Attributes</A></H3>
<P>
The CostEstimator applet's final button is the Summary button.
Pressing this button causes a new instance of the <TT>SummaryFrame</TT>
class to be constructed and shown. This is achieved by the method
<TT>ShowSummary</TT>, which appears as shown here:
<BLOCKQUOTE>
<PRE>
private void ShowSummary()
{
  SummaryFrame frame=new SummaryFrame(CostDriverPanelVector);
  frame.show();
}
</PRE>
</BLOCKQUOTE>
<H4>The SummaryFrame Class</H4>
<P>
The <TT>SummaryFrame</TT> class is used to display text summarizing
the selections the user has made describing the project being
estimated. Figure 23.7 shows a sample SummaryFrame and examples
of the text that could appear within it. As you can see in this
figure, for each cost driver the name of the cost driver is given,
along with the user's selection and the multiplier associated
with that selection.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f23-7.gif"><B> Figure 23.7 : </B><I>A SummaryFrame summarizes the cost  driver selections.
</I></A><P>
<P>
The <TT>SummaryFrame</TT> class, shown in Listing 23.12, is a
subclass of <TT>Frame</TT>. The <TT>SummaryFrame</TT> constructor
is passed a vector named <TT>CostDriverPanelVector</TT>. This
is the vector that contains an element for each category panel.
An enumeration is used to move through each entry in this vector.
For each item the <TT>GetSummary</TT> method is invoked. The string
returned by <TT>GetSummary</TT> is appended to the text area that
is displayed on the SummaryFrame.
<HR>
<BLOCKQUOTE>
<B>Listing 23.12. The SummaryFrame class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class SummaryFrame extends Frame {
  private TextArea Summary; // text area for displaying results
  public SummaryFrame(Vector CostDriverPanelVector)
  {
    super(&quot;Attibute Summary&quot;);
    // create the TextArea for displaying the results
    Summary = new TextArea(10, 25);
    add(&quot;Center&quot;, Summary);
    // use an enumeration to move through each
    // CostDriverPanel
    for (Enumeration enum = CostDriverPanelVector.elements();
        enum.hasMoreElements(); )
    {
      // for each CostDriverPanel, use the GetSummary method
      // to retrieve a String summarizing the values on
// that panel
      CostDriverPanel p = (CostDriverPanel)enum.nextElement();
      Summary.appendText(p.GetSummary());
    }
    // create a panel and put a Close button on it at the
    // bottom of the frame
    Panel p = new Panel();
    p.add(new Button(&quot;Close&quot;));
    add(&quot;South&quot;, p);
    resize(250, 400);
  }
  public boolean action(Event evt, Object arg)
  {
    boolean result = false;
    // if the Close button is pressed, dispose of the frame
    if(&quot;Close&quot;.equals(evt.arg)) {
      dispose();
      result = true;
    }
    return result;
  }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
A Close button is added to the frame. The <TT>action</TT> method
of the <TT>SummaryFrame</TT> class watches for a press of this
button. When the Close button is detected, the SummaryFrame is
disposed of.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
In this chapter you combined much of what you learned in previous
chapters to create a useful real-world applet. The CostEstimator
involved some in-depth user interface programming and provided
opportunities to work with vectors and arrays. You also learned
about imagemaps and how to use an imagemap to control the appearance
of an applet.
<P>
You should not stop here, however. You could extend this applet
in many ways. For example, you could create a new subclass of
<TT>CostDriverPanel</TT> that allows data entry with scrollbars.
Or you could draw a pie graph showing the relative impact of each
cost driver. You could use the Data Access Objects to store projects
in a database and then support comparisons between different projects.
<HR>

<CENTER><P><A HREF="ch22.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch24.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
