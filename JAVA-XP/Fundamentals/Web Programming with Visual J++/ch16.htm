<HTML>
<HEAD>
<TITLE>Chapter 16 -- Sprucing Things Up with Colors and Fonts
</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;16</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Sprucing Things Up with Colors
and Fonts</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheBaseApplet">
The Base Applet</A>
<LI><A HREF="#SettingtheColor">
Setting the Color</A>
<UL>
<LI><A HREF="#TheColorClass">
The Color Class</A>
<LI><A HREF="#SetColorDialog">
Set Color Dialog</A>
<LI><A HREF="#CommunicatingwiththeSetColorDialog">
Communicating with the Set Color Dialog</A>
<LI><A HREF="#UsingtheSetColorDialog">
Using the Set Color Dialog</A>
</UL>
<LI><A HREF="#SettingtheFont">
Setting the Font</A>
<UL>
<LI><A HREF="#TheFontandFontMetricsClasses">
The Font and FontMetrics Classes</A>
<LI><A HREF="#SetFontDialog">
Set Font Dialog</A>
<LI><A HREF="#CommunicatingwiththeSetFontDialog">
Communicating with the Set Font Dialog</A>
<LI><A HREF="#UsingtheSetFontDialog">
Using the Set Font Dialog</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
So far, we have been using components in their default configuration.
We have moved them around, made them different sizes, and let
the layout managers place them for us. One of the changes we can
make to the components is to give them a little color and change
the font. With Java and Visual J++, this is an easy task that
you can use to dramatically change the look of your program.
<P>
In this chapter, a sample application that displays some text
will be used to illustrate the use of color and font. In addition,
two buttons will be added. The first button will bring up a dialog
that lets the user set the color of text to display. With this
dialog, the user will be able to use a preset default color, or
set a custom color. The second button will bring up a dialog that
lets the user select the font to be used for the text. This dialog
allows the selection of the type of font, the size of the font,
and optional attributes of bold and italic.
<H2><A NAME="TheBaseApplet"><FONT SIZE=5 COLOR=#FF0000>
The Base Applet</FONT></A></H2>
<P>
The best way to explore this topic is to dive right in. The base
application is shown in Figure 16.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f16-1.gif"><B> Figure 16.1 : </B><I>The base applet used to set the color and font.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 16.1 shows the source to this applet.<BR>
</B>
</BLOCKQUOTE>
<P>
<TT>Listing 16.1. EX16A.java.</TT>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX16A extends Applet
{
    protected Button SetColorButton = new Button(&quot;Set Color&quot;);
    protected Button SetFontButton = new Button(&quot;Set Font&quot;);
    protected String MyText = new String(&quot;This is the text being modified.&quot;);

    public void init()
    {
        add(SetColorButton);
        add(SetFontButton);
    }

    public void paint(Graphics g)
    {
        g.drawString(MyText, 20, 100);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The applet-derived class contains two buttons: SetColorButton
and SetFontButton. The <TT>init</TT> method is straightforward
and simply adds the components to the applet. In addition, <TT>MyText</TT>
is displayed in the <TT>paint</TT> method to have something to
operate on. Easy stuff.
<H2><A NAME="SettingtheColor"><FONT SIZE=5 COLOR=#FF0000>
Setting the Color</FONT></A></H2>
<P>
The basis for setting the color of a number of items is the <TT>Color</TT>
class. This section covers the definition of the <TT>Color</TT>
class, a generic dialog used to set the color, and an applet putting
it to use.
<H3><A NAME="TheColorClass">
The Color Class</A></H3>
<P>
The <TT>Color</TT> class is a simple class that can hold any color.
It does this by storing a color based on the concentration of
red, green, and blue.
<P>
To create a color, use one of the three <TT>Color</TT> constructors:
<BLOCKQUOTE>
<PRE>
public Color(float r, float g, float b);
public Color(int rgb); 
public Color(int r, int g, int b); 
</PRE>
</BLOCKQUOTE>
<P>
The first of these constructors takes the three parts in floating
point format. The concentration of each element expressed with
values ranging from 0 to 1.0. The next two constructors will probably
be used more often because their values are expressed as integer
values ranging from 0 to 255. The first of the integer constructors
has the values encoded in a single integer-bits 16-23 represents
red, 8-15 represents green, and 0-7 represents blue. The final
integer constructor simply has the values separated into three
manageable parts.
<P>
Here are some examples of declaring colors:
<BLOCKQUOTE>
<PRE>
Color black = new Color(0, 0, 0);
Color white = new Color(255, 255, 255);
Color coolPurple = new Color(0.345, 0, 0.5);
</PRE>
</BLOCKQUOTE>
<P>
The values for each color indicate the concentration of the color;
therefore, the lower the number, the lower the concentration.
And conversely, the higher the value, the higher the concentration.
The examples express this with <TT>black</TT> being an absence
of color, and <TT>white</TT> being a combination of all colors.
The rest of the colors fall somewhere in between.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Remember that colors are only as good as the device displaying them. Therefore, the following two colors might or might not be the same.</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Color coolPurple = new Color(102, 0, 128);<BR>
Color coolerPurple = new Color(68, 0, 128);</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
So that you are not completely on your own, the <TT>Color</TT>
class provides the following predefined colors, which are instances
of the <TT>Color</TT> class and can be used whenever a <TT>Color</TT>
class is used:<BR>
<BLOCKQUOTE>
<TABLE>
<TR VALIGN=TOP><TD WIDTH=111><TT>black</TT></TD><TD WIDTH=92><TT>magenta</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>blue</TT></TD><TD WIDTH=92><TT>orange</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>cyan</TT></TD><TD WIDTH=92><TT>pink</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>darkGray</TT></TD><TD WIDTH=92><TT>red</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>gray</TT></TD><TD WIDTH=92><TT>white</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>green</TT></TD><TD WIDTH=92><TT>yellow</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=111><TT>lightGray</TT></TD><TD WIDTH=92></TD></TR>
</TABLE>
</BLOCKQUOTE>
<P>
<P>
Once you have an instance of <TT>Color</TT>, there are a variety
of things that can be done with the color. The public methods
are described in Table 16.1.<BR>
<P>
<CENTER><B>Table 16.1. Public methods of the Color class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Member</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>brighter()</TT></TD><TD WIDTH=384>Returns a color brighter than the current color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>darker()</TT></TD><TD WIDTH=384>Returns a color darker than the current color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>equals(Object)</TT></TD><TD WIDTH=384>Compares two color objects for the same color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getBlue()</TT></TD><TD WIDTH=384>Returns the blue component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getColor(String)</TT></TD><TD WIDTH=384>Returns the color of the named system property.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getColor(String, Color)</TT></TD><TD WIDTH=384>Returns the color of the named system property, specifying a default if not found.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getColor(String, int)</TT></TD><TD WIDTH=384>Returns the color of the named system property, specifying a default if not found.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getGreen()</TT></TD><TD WIDTH=384>Returns the green component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getHSBColor(float, float, float) </TT></TD>
<TD WIDTH=384>Returns a color with the given hue, saturation, and brightness.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getRed()</TT></TD><TD WIDTH=384>Returns the red component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getRGB()</TT></TD><TD WIDTH=384>Returns the components combined in a single integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>hashCode()</TT></TD><TD WIDTH=384>Returns a hash code representing the color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>HSBtoRGB(float, float, float) </TT></TD>
<TD WIDTH=384>Returns an <TT>RGB</TT> value for a color specified by hue, saturation, and brightness.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>RGBtoHSB(int, int, int, float)</TT></TD>
<TD WIDTH=384>Returns values for hue, saturation, and brightness for a color specified by an <TT>RGB</TT> value.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>toString()</TT></TD><TD WIDTH=384>Returns a string representation of the color.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="SetColorDialog">
Set Color Dialog</A></H3>
<P>
Given the knowledge of how to construct a color given the components,
the task is to develop a dialog that enables the user to select
his own color. Figure 16.2 contains the dialog at work.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f16-2.gif"><B> Figure 16.2 : </B><I>Set Color dialog of EX16B.
</I></A><P>
<P>
With the dialog, the user can select a custom color by specifying
the color components using the scrollbars. Adjusting the scrollbars
with the arrows or by dragging the thumbnail will automatically
adjust the value to the right of each scrollbar. If the user selects
a default color from the choice list, this automatically adjusts
the scrollbar values to the appropriate values so that the user
can see what components make up the default values. A sample swatch
of the color is displayed in the box in the lower right of the
dialog.
<P>
The first step in creating this dialog was to use the Resource
Wizard to design and lay out the components of the class. For
more information on using the Resource Wizard, refer to Chapter
7, &quot;Saving Time with the Resource Wizard.&quot; This process
produced the resource file <TT>SetColor.rct</TT>. We then used
the Tools | Java Resource Wizard to produce the files <TT>DialogLayout.java</TT>
and <TT>SetColorControls.java</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
When using the Dialog Editor, be sure to only place controls on your container classes that have a direct translation to Java components. Refer to Table 7.1, in <A HREF="ch7.htm" >Chapter 7</A> for a list of available controls and the corresponding Java 
components.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>DialogLayout</TT> is a layout manager that is based on Dialog
Logical Units (DLUs). This class is used by the <TT>SetColorControls</TT>
class to place components at a specific location on the dialog
using DLUs. To learn more about layout managers, see <A HREF="ch5.htm" >Chapter 5</A>
&quot;Java's User Interface Components.&quot;
<P>
Listing 16.2 shows the contents of the <TT>SetColorControls</TT>
class generated by the Java Resource Wizard.
<HR>
<BLOCKQUOTE>
<B>Listing 16.2. SetColorControls.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.awt.*;
import DialogLayout;

public class SetColorControls
{
    Container    m_Parent       = null;
    boolean      m_fInitialized = false;
    DialogLayout m_Layout;

    // Control definitions
    //--------------------------------------------------------------------------
    Button        OkButton;
    Button        CancelButton;
    Scrollbar     RedScrollbar;
    Label         IDC_STATIC1;
    Label         IDC_STATIC2;
    Scrollbar     GreenScrollbar;
    Scrollbar     BlueScrollbar;
    Label         IDC_STATIC3;
    Label         IDC_STATIC4;
    Choice        StandardColorChoice;
    Label         RedValue;
    Label         GreenValue;
    Label         BlueValue;


    // Constructor
    //--------------------------------------------------------------------------
    public SetColorControls (Container parent)
    {
        m_Parent = parent;
    }

    // Initialization.
    //--------------------------------------------------------------------------
    public boolean CreateControls()--
    {
        // CreateControls should be called only once
        //----------------------------------------------------------------------
        if (m_fInitialized || m_Parent == null)
            return false;

        // m_Parent must be extended from the Container class
        //----------------------------------------------------------------------
        if (!(m_Parent instanceof Container))
           return false;

        // Since a given font may not be supported across all platforms, it
        // is safe to modify only the size of the font, not the typeface.
        //----------------------------------------------------------------------
        Font OldFnt = m_Parent.getFont();
        if (OldFnt != null)
        {
            Font NewFnt = new Font(OldFnt.getName(), OldFnt.getStyle(), 8);

            m_Parent.setFont(NewFnt);
        }

        // All position and sizes are in dialog logical units, so we use a
        // DialogLayout as our layout manager.
        //----------------------------------------------------------------------
        m_Layout = new DialogLayout(m_Parent, 220, 116);
        m_Parent.setLayout(m_Layout);
        m_Parent.addNotify();

        Dimension size   = m_Layout.getDialogSize();
        Insets    insets = m_Parent.insets();

        m_Parent.resize(insets.left + size.width  + insets.right,
                        insets.top  + size.height + insets.bottom);

        // Control creation
        //----------------------------------------------------------------------
        OkButton = new Button (&quot;OK&quot;);
        m_Parent.add(OkButton);
        m_Layout.setShape(OkButton, 111, 98, 50, 14);

        CancelButton = new Button (&quot;Cancel&quot;);
        m_Parent.add(CancelButton);
        m_Layout.setShape(CancelButton, 166, 98, 50, 14);

        RedScrollbar = new Scrollbar (Scrollbar.HORIZONTAL, 0, 1, 0, 99);
        m_Parent.add(RedScrollbar);
        m_Layout.setShape(RedScrollbar, 39, 10, 136, 11);

        IDC_STATIC1 = new Label (&quot;Red&quot;, Label.LEFT);
        m_Parent.add(IDC_STATIC1);
        m_Layout.setShape(IDC_STATIC1, 10, 11, 28, 8);

        IDC_STATIC2 = new Label (&quot;Green&quot;, Label.LEFT);
        m_Parent.add(IDC_STATIC2);
        m_Layout.setShape(IDC_STATIC2, 10, 24, 28, 8);

        GreenScrollbar = new Scrollbar (Scrollbar.HORIZONTAL, 0, 1, 0, 99);
        m_Parent.add(GreenScrollbar);
        m_Layout.setShape(GreenScrollbar, 39, 23, 136, 11);

        BlueScrollbar = new Scrollbar (Scrollbar.HORIZONTAL, 0, 1, 0, 99);
        m_Parent.add(BlueScrollbar);
        m_Layout.setShape(BlueScrollbar, 39, 36, 136, 11);

        IDC_STATIC3 = new Label (&quot;Blue&quot;, Label.LEFT);
        m_Parent.add(IDC_STATIC3);
        m_Layout.setShape(IDC_STATIC3, 10, 37, 28, 8);

        IDC_STATIC4 = new Label (&quot;Set Color To:&quot;, Label.LEFT);
        m_Parent.add(IDC_STATIC4);
        m_Layout.setShape(IDC_STATIC4, 11, 62, 50, 8);

        StandardColorChoice = new Choice ();
        m_Parent.add(StandardColorChoice);
        m_Layout.setShape(StandardColorChoice, 75, 60, 87, 52);

        RedValue = new Label (&quot;0&quot;, Label.LEFT);
        m_Parent.add(RedValue);
        m_Layout.setShape(RedValue, 190, 11, 18, 8);

        GreenValue = new Label (&quot;0&quot;, Label.LEFT);
        m_Parent.add(GreenValue);
        m_Layout.setShape(GreenValue, 190, 24, 18, 8);

        BlueValue = new Label (&quot;0&quot;, Label.LEFT);
        m_Parent.add(BlueValue);
        m_Layout.setShape(BlueValue, 190, 37, 18, 8);

        m_fInitialized = true;
        return true;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The member variable <TT>m_Parent</TT> holds the container class
in which the controls are placed. <TT>m_Layout</TT> is the layout
manager that is used to position the controls on the container.
Additionally, there is a component instance for each of the controls
placed on the dialog in the Dialog Editor.
<P>
The two member methods of this class are simple, yet effective.
The constructor saves the parent of all of the components. <TT>CreateControls</TT>
does some basic housekeeping to make sure the parent exists and
that it is a type of container. It then sets up the layout manager
for the parent. Finally, it places all the controls on the container,
based on the designed DLUs.
<P>
The next step is examining the class used for the dialog. This
dialog will contain an instance of the controls class mentioned
above and the desired code necessary to coordinate the activities
on the dialog. Listing 16.3 contains the <TT>SetColorDialog</TT>
class of <TT>EX16B</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 16.3. SetColorDialog class of EX16B.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class SetColorDialog extends Dialog
{
    protected Color selectedColor;
    protected ColorData cData;
    protected SetColorControls ctrls;
    protected Rectangle sampleRect;

    public SetColorDialog(Frame parent, ColorData cData)
    {
        super(parent, &quot;Set Color&quot;, true);

        setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 16));

        // don't let the user change the size
        setResizable(false);

        resize(220, 116);

        // create the controls for the dialog
        ctrls = new SetColorControls(this);
        ctrls.CreateControls();

        FillSetColorTo();
        SetupScrollbars();

        // save the data and start off with the current color
        this.cData = cData;
        selectedColor = new Color(cData.GetColor().getRGB());
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;         // asume no action

        if (&quot;OK&quot;.equals(evt.arg)) {
            cData.SetColor(selectedColor);
            dispose();                  // close the dialog
        }
        if (&quot;Cancel&quot;.equals(evt.arg))
            dispose();                  // close the dialog

        return result;
    }

    public boolean handleEvent(Event evt)
    {
        boolean result = false;         // assume no action

        // call the superclass for normal processing
        result = super.handleEvent(evt);

        // process the event here if not handled yet
        if (!result) {
            if (evt.target == ctrls.RedScrollbar) {
                handleScrollbarEvent(ctrls.RedScrollbar, ctrls.RedValue);
                result = true;
            }
            else if (evt.target == ctrls.GreenScrollbar) {
                handleScrollbarEvent(ctrls.GreenScrollbar, ctrls.GreenValue);
                result = true;
            }
            else if (evt.target == ctrls.BlueScrollbar) {
                handleScrollbarEvent(ctrls.BlueScrollbar, ctrls.BlueValue);
                result = true;
            }
            else if (evt.target == ctrls.StandardColorChoice) {
                handleChoiceEvent();
                result = true;
            }
        }

        return result;
    }

    public void paint(Graphics g)
    {
        super.paint(g);                 // let normal processing happen

        if (selectedColor != null) {
            if (sampleRect == null) {
                // determine where we can put the sample color
                sampleRect = ctrls.StandardColorChoice.bounds();
                sampleRect.x += sampleRect.width + 10;
                sampleRect.width = 20;
                sampleRect.height = 20;
            }

            g.setColor(selectedColor);

            g.drawRect(sampleRect.x, sampleRect.y, 
                    sampleRect.width, sampleRect.height);
            g.fillRect(sampleRect.x, sampleRect.y, 
                    sampleRect.width, sampleRect.height);
        }
    }

    protected void FillSetColorTo() 
    {
        ctrls.StandardColorChoice.addItem(&quot;black&quot;);
        ctrls.StandardColorChoice.addItem(&quot;blue&quot;);
        ctrls.StandardColorChoice.addItem(&quot;cyan&quot;);
        ctrls.StandardColorChoice.addItem(&quot;darkGray&quot;);
        ctrls.StandardColorChoice.addItem(&quot;gray&quot;);
        ctrls.StandardColorChoice.addItem(&quot;green&quot;);
        ctrls.StandardColorChoice.addItem(&quot;lightGray&quot;);
        ctrls.StandardColorChoice.addItem(&quot;magenta&quot;);
        ctrls.StandardColorChoice.addItem(&quot;orange&quot;);
        ctrls.StandardColorChoice.addItem(&quot;pink&quot;);
        ctrls.StandardColorChoice.addItem(&quot;red&quot;);
        ctrls.StandardColorChoice.addItem(&quot;white&quot;);
        ctrls.StandardColorChoice.addItem(&quot;yellow&quot;);
        ctrls.StandardColorChoice.addItem(&quot;custom&quot;);
    }

    protected void SetupScrollbars() 
    {
        ctrls.RedScrollbar.setValues(0, 10, 0, 255);
        ctrls.GreenScrollbar.setValues(0, 10, 0, 255);
        ctrls.BlueScrollbar.setValues(0, 10, 0, 255);
    }

    protected void handleScrollbarEvent(Scrollbar sBar, Label sBarValue)
    {
        int value = sBar.getValue();

        // set the text value according to the scroll bar
        sBarValue.setText(String.valueOf(value));

        // reset the actual sample
        SetSampleColor();

        // changing of the scroll bar means it is custom
        ctrls.StandardColorChoice.select(&quot;custom&quot;);
    }

    protected void handleChoiceEvent()
    {
        Color standardColor = null;     // holds found color
        String name = ctrls.StandardColorChoice.getSelectedItem();

        // check for each of the standard colors
        if (name == &quot;black&quot;)
            standardColor = new Color(Color.black.getRGB());
        else if (name == &quot;blue&quot;)
            standardColor = new Color(Color.blue.getRGB());
        else if (name == &quot;cyan&quot;)
            standardColor = new Color(Color.cyan.getRGB());
        else if (name == &quot;darkGray&quot;)
            standardColor = new Color(Color.darkGray.getRGB());
        else if (name == &quot;gray&quot;)
            standardColor = new Color(Color.gray.getRGB());
        else if (name == &quot;green&quot;)
            standardColor = new Color(Color.green.getRGB());
        else if (name == &quot;lightGray&quot;)
            standardColor = new Color(Color.lightGray.getRGB());
        else if (name == &quot;magenta&quot;)
            standardColor = new Color(Color.magenta.getRGB());
        else if (name == &quot;orange&quot;)
            standardColor = new Color(Color.orange.getRGB());
        else if (name == &quot;pink&quot;)
            standardColor = new Color(Color.pink.getRGB());
        else if (name == &quot;red&quot;)
            standardColor = new Color(Color.red.getRGB());
        else if (name == &quot;white&quot;)
            standardColor = new Color(Color.white.getRGB());
        else if (name == &quot;yellow&quot;)
            standardColor = new Color(Color.yellow.getRGB());

        // set the scrollbar if the color is not custom
        if (standardColor != null) {
            SetScrollbarValue(ctrls.RedScrollbar, 
                    ctrls.RedValue, standardColor.getRed());
            SetScrollbarValue(ctrls.GreenScrollbar, 
                    ctrls.GreenValue, standardColor.getGreen());
            SetScrollbarValue(ctrls.BlueScrollbar, 
                    ctrls.BlueValue, standardColor.getBlue());

            // reset the actual sample
            SetSampleColor();
        }
    }

    protected void SetScrollbarValue(Scrollbar sBar, 
            Label sBarValue, int value)
    {
        sBar.setValue(value);           // set the value

        // set the text value according to the new value
        sBarValue.setText(String.valueOf(value));
    }

    protected void SetSampleColor()
    {
        int red = ctrls.RedScrollbar.getValue();
        int green = ctrls.GreenScrollbar.getValue();
        int blue = ctrls.BlueScrollbar.getValue();

        selectedColor = new Color(red, green, blue);
        repaint();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Let's take a look at the constructor. It takes as its parameter
the parent frame, which is required by all dialogs, and a <TT>ColorData</TT>
class instance. The next section will cover the <TT>ColorData</TT>
class in detail. For now, it is enough to know that this is the
mechanism used to pass the initial color to the dialog and the
selected color back to the calling class.
<P>
Inside the constructor, the first step is to call the superclass
constructor. This call is required to be the first line in the
constructor. Next, the font is set for the dialog. This is always
a good idea since the controls class is based on the current font
of the container dialog. The call to <TT>setResizeable</TT> disables
the user from changing the size of the dialog. This is important
because a mechanism to resize the controls is not built into the
dialog. Next, create the controls using the classes previously
discussed. Finally, initialize some of the controls with <TT>FillSetColorTo</TT>
and <TT>SetupScrollbars</TT> method calls, and set the starting
color to the color passed in.
<P>
The <TT>SetColorControls</TT> class is concerned only with the
actual placement of the components on the dialog. It does not
take care of any configuration specific to the application or
initialization. <TT>FillSetColorTo</TT> loads the choice box for
the standard default colors. Notice how <TT>ctrls</TT>, the <TT>SetColorControl</TT>
class instance, is used to reference the choice component. In
addition to the standard colors, the choice of &quot;custom&quot;
is used when the scrollbars are modified directly. <TT>SetupScrollbars</TT>
is used to initialize the ranges for all the scrollbars from a
range of  0 to 255, which corresponds to the integer ranges from
the <TT>Color</TT> class.
<P>
The <TT>paint</TT> method is used to display the sample color
in the lower right of the dialog, using the currently selected
color. <TT>SetColor</TT>, of the <TT>Graphics</TT> instance <TT>g</TT>,
is called to set the color. Because <TT>Graphics</TT> contains
only a single color, that color is used for all subsequent drawings.
Thus, the sample color rectangle is filled with the currently
selected color. Later, you will see that when the color changes,
the dialog forces a redrawing of the dialog, using <TT>repaint</TT>,
to update the sample color.
<P>
The button presses are caught and acted upon in the <TT>action</TT>
method. If the OK button is pressed, the currently selected color
is saved in the <TT>ColorData</TT> class and the dialog resources
are disposed of, causing the dialog to close. If the Cancel button
is pressed, the dialog resources are also disposed of, once again
causing the dialog to close.
<P>
Perhaps the busiest of the methods is the <TT>handleEvent</TT>
method. The first thing this does is try to get out of doing anything
by calling the superclass with the current event. This allows
the <TT>action</TT> processing to occur. Then, if there is something
left to do with the event, this method checks to see whether the
event involves one of the scrollbars or the choice.
<P>
If the scrollbar was modified, <TT>handleScrollbarEvent</TT> updates
the label next to the scrollbar with the current scrollbar value,
updates the sample color being displayed by calling <TT>SetSampleColor</TT>,
and forces the selected item in the choice to be &quot;custom.&quot;
<TT>SetSampleColor</TT> takes the values from the three scrollbars
and creates a new color based on these values. It then forces
the sample rectangle to be redrawn with the newly selected color
by calling the <TT>repaint</TT> method of the dialog.
<P>
If a new item in the choice is selected, <TT>handleChoiceEvent</TT>
is called. Unfortunately, since <TT>switch</TT> does not work
on strings, the majority of this code is looking for the standard
color that was selected. If a standard color is found, <TT>SetScrollbarValue</TT>
is called for each of the components. In this way, the user can
see exactly what goes into making the standard colors. Then, <TT>SetSampleColor</TT>
is used to update the sample rectangle.
<P>
That wasn't too bad. You now have a reusable dialog that can be
used in a variety of situations in which you want to let the user
choose his own colors. The next section covers how the dialog
actually communicates with the instantiating class on what color
was selected, using the <TT>ColorData</TT> class.
<H3><A NAME="CommunicatingwiththeSetColorDialog">
Communicating with the Set Color Dialog</A></H3>
<P>
One of the hardest aspects of using dialogs to collect information
from users is relaying the collected information back to the calling
class. One option is to pass the calling class into the dialog
class and let the dialog call method(s) set the collected data
in the calling class. Let's take a quick look and consider <TT>EX16C</TT>,
shown in Listing 16.4.
<HR>
<BLOCKQUOTE>
<B>Listing 16.4. EX16C.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX16C extends Applet
{
    protected InputDialog IDialog;
    protected TextField MyField = new TextField(20);

    public void SetMyFieldText(String str)
    {
        MyField.setText(str);
    }

    public void init()
    {
        add(new Button(&quot;Set Text&quot;));
        add(MyField);

        // set up the frame for the dialog
        Frame frame = new Frame();
        frame.resize(250, 100);
        IDialog = new InputDialog(frame, this);
    }

    public boolean action(Event evt, Object obj) 
    {
        boolean result = false;         // asume no action

        if (&quot;Set Text&quot;.equals(obj)) {
           IDialog.show();
           result = true;
        }

        return result;
    }
}

class InputDialog extends Dialog
{
    protected TextField InputText;
    protected EX16C aplt;

    public InputDialog(Frame parent, EX16C aplt)
    {
        super(parent, &quot;Input into my field please...&quot;, true);

        this.aplt = aplt;

        InputText = new TextField();
        add(&quot;North&quot;, InputText);

        Panel p = new Panel();
        p.add(new Button(&quot;OK&quot;));
        p.add(new Button(&quot;Cancel&quot;));
        add(&quot;South&quot;, p);

        pack();
        resize(250, 100);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;         // asume no action

        if (&quot;OK&quot;.equals(evt.arg)) {
            aplt.SetMyFieldText(InputText.getText());
            dispose();                  // close the dialog
        }
        if (&quot;Cancel&quot;.equals(evt.arg))
            dispose();                  // close the dialog

        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When a button is pressed, this applet shows a dialog that gathers
the text that is displayed in the text field of the applet. The
importance of this applet is the fact that the dialog is passed
the applet in the constructor. When the buttons on the dialog
are pressed to close the dialog, the information collected is
put back into the applet (see <TT>InputDialog.action</TT>). This
concept is not very practical for generic dialogs because it has
very high coupling between the classes involved.
<P>
An alternate approach would be to use <TT>Observer</TT> and <TT>Observable</TT>
classes from the java.util package. For a complete description
of these classes along with other classes found in the java.util
package, see <A HREF="ch11.htm" >Chapter 11</A>, &quot;The Java Utility Classes.&quot;
<P>
Let's go back to the sample applet, <TT>EX16B</TT>. Listing 16.5
shows the observable data that is passed to the Set Color dialog.
<HR>
<BLOCKQUOTE>
<B>Listing 16.5. Observable Color data class of EX16B.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class ColorData extends Observable
{
    protected Color clr = new Color(Color.black.getRGB());

    public Color GetColor()
    {
        return clr;
    }

    public void SetColor(Color clr)
    {
        this.clr = clr;                 // save the color

        // flag the change an notify the on-lookers
        setChanged();
        notifyObservers();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The sole purpose of this class is to pass data from the applet
to the Set Color dialog. The single piece of data is the color
of the text. Obviously, more complicated dialogs would have more
data.
<P>
<TT>GetColor</TT> is just an access method to the color. Both
the applet and the dialog call this method-the applet to determine
the color of the text to be displayed, while the Set Color dialog
calls it to determine the starting color for the dialog. <TT>SetColor</TT>
is called by the Set Color dialog when the user presses the OK
button after making a selection. This method first saves the new
color, then makes the <TT>Observable</TT>-specific calls that
mark that the data has changed, then notifies all of the class's
observers that the data has changed.
<P>
The only thing that the applet needs to do is to implement the
<TT>Observer</TT> interface. Listing 16.6 shows the code from
the <TT>EX16B</TT> applet pertinent to being an <TT>Observer</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 16.6. Observer-specific code of EX16B applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class EX16B extends Applet implements Observer
{
    ...
    protected ColorData cData = new ColorData();
    ...

    public void init()
    {
        ...
        // let the applet observe the color
        cData.addObserver(this);
        ...
    }
    ...

    public void update(Observable o, Object arg)
    {
        // since the paint method already looks at cData, simply 
        //   force a repaint of the dialog to pick up the new color
        repaint();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The applet instantiates an instance of the <TT>Observable</TT>
color data that is used to paint the text. In <TT>init</TT>, it
tells <TT>Observable</TT> that it is an observer by making a call
to <TT>addObserver</TT> and passing the applet. <TT>update</TT>
is the only method in the <TT>Observer</TT> interface and must
be defined. This method is what gets notified when <TT>Observable</TT>
changes. Since we are the only observer of the color, all we have
to do is repaint the applet and the new color will take effect.
<P>
Why go through the overhead of using the <TT>Observer</TT>/<TT>Observable</TT>
relationship? That's easy. One of the problems with showing a
dialog is that the actual lifespan of the dialog is asynchronous
with respect to the actions of the applet. Therefore, this interface
is an easy way to get the dialog to tell the applet when it modifies
the common data. And, more importantly, this process decouples
the dialog and the applet so that the dialog can be used in any
applet for a variety of different color settings. Now, let's look
at the final part of the applet that uses the Set Color dialog.
<H3><A NAME="UsingtheSetColorDialog">
Using the Set Color Dialog</A></H3>
<P>
To use the Set Color dialog, we go back to the basic applet with
two buttons and some text that is being displayed. Listing 16.7
shows the applet class <TT>EX16B</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 16.7. Applet class EX16B.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class EX16B extends Applet implements Observer
{
    protected Button SetColorButton = new Button(&quot;Set Color&quot;);
    protected Button SetFontButton = new Button(&quot;Set Font&quot;);
    protected String MyText = new String(&quot;This is the text being modified.&quot;);
    protected Frame frame;
    protected ColorData cData = new ColorData();
    protected SetColorDialog SetColorDlg;

    public void init()
    {
        // set up the set color dialog frame
        frame = new Frame();
        frame.resize(1, 1);

        // let the applet observe the color
        cData.addObserver(this);

        // add the controls to the applet
        add(SetColorButton);
        add(SetFontButton);
    }

    public void paint(Graphics g)
    {
        // use the color data to set the text color
        g.setColor(cData.GetColor());

        g.drawString(MyText, 20, 100);
    }

    public boolean action(Event evt, Object obj) 
    {
        boolean result = false;         // asume no action

        if (&quot;Set Color&quot;.equals(obj)) {
            SetColorDlg = new SetColorDialog(frame, cData);
            SetColorDlg.show();

            result = true;
        }

        return result;
    }

    public void update(Observable o, Object arg)
    {
        // since the paint method already looks at cData, simply 
        //   force a repaint of the dialog to pick up the new color
        repaint();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>init</TT> method sets up the frame to use for the dialog,
sets up the data used for the dialog, and places the buttons on
the applet. <TT>paint</TT> actually uses the color by setting
the color in the <TT>Graphics</TT> and then calls <TT>DrawString</TT>
to do the drawing. Again, the <TT>Graphics</TT> instance will
use the color to do all subsequent actions. <TT>action</TT> is
a straightforward implementation of displaying the dialog in response
to a button click.
<P>
In this section, you have learned how a color is created and stored.
Along the way, a dialog that could be used in a number of situations
to let that user set that color was created. Once a color was
chosen, a <TT>Graphics</TT> instance used that color to change
the color of text on the applet. This, however, is not the only
location in which the resulting color can be used. Every component
has a foreground color and background color associated with it.
The following methods of <TT>Component</TT> can be used to access
these colors.
<BLOCKQUOTE>
<PRE>
public Color getBackground();
public void setBackground(Color);
public Color getForeground();
public void setForeground(Color);
</PRE>
</BLOCKQUOTE>
<P>
Because everything that is displayed is a component, these methods
can be used to change the color on virtually any item in your
applet.
<H2><A NAME="SettingtheFont"><FONT SIZE=5 COLOR=#FF0000>
Setting the Font</FONT></A></H2>
<P>
The font selection is encapsulated with the <TT>Font</TT> class.
Since fonts are very system-dependent, an additional class, <TT>FontMetrics</TT>
is used to retrieve specifics about how the font is actually laid
out on the output device. This section covers the <TT>Font</TT>
and <TT>FontMetrics</TT> classes, goes over a dialog used to select
a font, and puts that dialog to use in an extension of a previously
defined example.
<H3><A NAME="TheFontandFontMetricsClasses">
The Font and FontMetrics Classes</A></H3>
<P>
A font can be loaded by specifying a name and size of font desired.
This information can be passed to the single <TT>Font</TT> class
constructor:
<BLOCKQUOTE>
<PRE>
Font(String, int, int)
</PRE>
</BLOCKQUOTE>
<P>
This constructor takes a string that contains a name, such as
&quot;<TT>Dialog</TT>&quot; or &quot;<TT>Helvetica</TT>,&quot;
an integer containing style indications, and a point size. The
style can contain three values defined in the <TT>Font</TT> class:
<BLOCKQUOTE>
<TT>PLAIN<BR>
BOLD<BR>
ITALIC</TT>
</BLOCKQUOTE>
<P>
You can combine these values together by using a bitwise <TT>OR</TT>
operation or by adding them together to form a compound style.
Of course, <TT>PLAIN</TT> combined with anything has no effect
(especially since it is defined as 0), but used alone, it indicates
that the font will be displayed normally.
<P>
After you have created the font, Table 16.2 shows the public methods
that can be used to retrieve some general information about the
font.<BR>
<P>
<CENTER><B>Table 16.2. Public methods of the Font class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=199><I>Member</I></TD><TD WIDTH=377><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>equals(Object)</TT></TD><TD WIDTH=377>Compares two font objects for the same font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>GetFamily()</TT></TD><TD WIDTH=377>Returns a platform-specific name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getFont(String)</TT></TD><TD WIDTH=377>Returns the font of the named system property.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getFont(String, Font)</TT></TD><TD WIDTH=377>Returns the font of the named system property, returning the font as a default if not found.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getName()</TT></TD><TD WIDTH=377>Returns the font name.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getSize()</TT></TD><TD WIDTH=377>Returns the font point size.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getStyle()</TT></TD><TD WIDTH=377>Returns the font style.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>hashCode()</TT></TD><TD WIDTH=377>Returns a hash code representing the color.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>isBold()</TT></TD><TD WIDTH=377>Returns true if the bold style bit is set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>isItalic()</TT></TD><TD WIDTH=377>Returns true if the italic style bit is set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>isPlain()</TT></TD><TD WIDTH=377>Returns true if neither the bold nor italic style bits are set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>toString()</TT></TD><TD WIDTH=377>Returns a string representation of the font.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<TT>FontMetrics</TT> returns specific information about how a
particular font is rendered on the output device. This information
is typically used so that lines of text are properly spaced.
<P>
<TT>FontMetrics</TT> are based on a given <TT>Font</TT>. Therefore,
the constructor takes the font being examined:
<BLOCKQUOTE>
<PRE>
protected FontMetrics(Font)
</PRE>
</BLOCKQUOTE>
<P>
Notice that the constructor is not public, so a program cannot
instantiate an instance of this class. This is done because the
information retrieved is very device-specific. Therefore, you
must call a device-specific method, such as <TT>Component.getFontMetrics()</TT>
or <TT>Graphics.getFontMetrics()</TT>, to retrieve the information
about the font currently being rendered.
<P>
Table 16.3 shows the public methods of the <TT>FontMetrics</TT>
class.<BR>
<P>
<CENTER><B>Table 16.3. Public methods of the FontMetrics class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=199><I>Member</I></TD><TD WIDTH=377><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>bytesWidth(byte [], int, int)</TT></TD>
<TD WIDTH=377>Returns the width of the array of bytes.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>charsWidth(char [], int, int)</TT></TD>
<TD WIDTH=377>Returns the width of the array of characters.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>charWidth(char)</TT></TD><TD WIDTH=377>Returns the width of the single character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>charWidth(int)</TT></TD><TD WIDTH=377>Returns the width of the single character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getAscent()</TT></TD><TD WIDTH=377>Returns the standard distance from the baseline of the font to the top of the characters in the font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getDescent()</TT></TD><TD WIDTH=377>Returns the standard distance from the baseline of the font to the bottom of the characters in the font.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getFont()</TT></TD><TD WIDTH=377>Returns the font being analyzed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getHeight()</TT></TD><TD WIDTH=377>Returns the total size of a line; sum of leading, ascent, and descent.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getLeading()</TT></TD><TD WIDTH=377>Returns space required between lines.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getMaxAdvance()</TT></TD><TD WIDTH=377>Returns the maximum advance.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getMaxAscent()</TT></TD><TD WIDTH=377>Returns the maximum ascent.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getMaxDescent()</TT></TD><TD WIDTH=377>Returns the maximum descent.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>getWidths()</TT></TD><TD WIDTH=377>Returns an array of the widths of the first 256 characters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>stringWidth(String)</TT></TD><TD WIDTH=377>Returns the width of the string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You should never have to deal with <TT>FontMetrics</TT> unless
your program is handling the display of text directly to the output
devices. By using the components on your applets and dialogs,
you let the Java packages deal with these specifics.
<H3><A NAME="SetFontDialog">
Set Font Dialog</A></H3>
<P>
Developing a dialog that allows the user to select the font he
or she wants to use is an easy way to get familiar with the <TT>Font</TT>
class. Figure 16.3 shows the dialog in action.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f16-3.gif"><B> Figure 16.3 : </B><I>Set Font dialog of EX16D.
</I></A><P>
<P>
This dialog contains a choice for the font name and the font size.
In addition, the user can select the bold and italic attributes
of the font by using the appropriate checkboxes. As a courtesy,
a sample of the selected font is displayed. Listing 16.8 shows
the dialog class used for the Set Font dialog of example <TT>EX16D</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 16.8. SetFontDialog class of EX16D.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class SetFontDialog extends Dialog
{
    protected Font selectedFont;
    protected FontData fData;
    protected Choice NameChoice = new Choice();
    protected Choice SizeChoice = new Choice();
    protected Checkbox BoldCheckbox = new Checkbox(&quot;Bold&quot;);
    protected Checkbox ItalicCheckbox = new Checkbox(&quot;Italic&quot;);
    protected Label SampleLabel = new Label(&quot;AaBbCc&quot;, Label.CENTER);

    public SetFontDialog(Frame parent, FontData fData)
    {
        super(parent, &quot;Set Font&quot;, true);

        setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 12));
        setBackground(Color.lightGray);

        // don't let the user change the size
        setResizable(false);

        resize(300, 150);

        setBackground(Color.lightGray);

        // create the controls for the dialog
        Panel fontSelectionPanel = new Panel();
        fontSelectionPanel.add(NameChoice);
        fontSelectionPanel.add(SizeChoice);
        fontSelectionPanel.add(BoldCheckbox);
        fontSelectionPanel.add(ItalicCheckbox);
        add(&quot;North&quot;, fontSelectionPanel);

        Panel fontSamplePanel = new Panel();
        fontSamplePanel.add(new Label(&quot;Sample&quot;));
        fontSamplePanel.add(SampleLabel);
        add(&quot;Center&quot;, fontSamplePanel);

        Panel dialogClosePanel = new Panel();
        dialogClosePanel.add(new Button(&quot;OK&quot;));
        dialogClosePanel.add(new Button(&quot;Cancel&quot;));
        add(&quot;South&quot;, dialogClosePanel);

        // fill in the choice lists
        FillChoiceLists();

        // save the data and start off with the current font
        this.fData = fData;
        NameChoice.select(fData.GetFont().getName());
        SizeChoice.select(Integer.toString(fData.GetFont().getSize()));

        BoldCheckbox.setState(
                (fData.GetFont().getStyle() &amp; Font.BOLD) == Font.BOLD);
        ItalicCheckbox.setState(
                (fData.GetFont().getStyle() &amp; Font.ITALIC) == Font.ITALIC);

        GetSelectedFont(false);

        SampleLabel.setFont(selectedFont);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;         // asume no action

        if (&quot;OK&quot;.equals(evt.arg)) {
            fData.SetFont(selectedFont);
            dispose();                  // close the dialog
        }
        if (&quot;Cancel&quot;.equals(evt.arg))
            dispose();                  // close the dialog

        return result;
    }

    public boolean handleEvent(Event evt)
    {
        boolean result = false;         // assume no action

        // call the superclass for normal processing
        result = super.handleEvent(evt);

        // process the event here if not handled yet
        if (!result) {
            if ((evt.target == NameChoice) ||
                    (evt.target == SizeChoice) ||
                    (evt.target == BoldCheckbox) ||
                    (evt.target == ItalicCheckbox)) {
                GetSelectedFont(true);
                result = true;
            }
        }

        return result;
    }

    protected void FillChoiceLists()
    {
        String fonts[] = Toolkit.getDefaultToolkit().getFontList();

        for (int index = 0; index &lt; fonts.length; index++)
            NameChoice.addItem(fonts[index]);

        // there is no way to get the font sizes that are available
        //   on the host, so just add some to the listbox
        for (int index = 8; index &lt;= 36; index += 4)
            SizeChoice.addItem(Integer.toString(index));
    }

    protected void GetSelectedFont(boolean redisplay)
    {
        int style = Font.PLAIN;

        if (BoldCheckbox.getState())
            style |= Font.BOLD;

        if (ItalicCheckbox.getState())
            style |= Font.ITALIC;

        selectedFont = new Font(NameChoice.getSelectedItem(), style,
                Integer.parseInt(SizeChoice.getSelectedItem()));

        if (redisplay) {
            // apply the new font to the sample and make sure
            //   it fits in the dialog
            SampleLabel.setFont(selectedFont);
            SampleLabel.resize(SampleLabel.preferredSize());

            // tell the layout manager to do its job again
            validate();
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The class contains several components that will be referenced
later within the class to get the selected font and to set up
the sample of this selected font. The constructor does some initial
setting up of the dialog, including setting the dialog font to
a standard font (which is in itself a good example of how to set
the font directly) and the color of the background of the dialog
to a calm color. Next, the controls are placed on the dialog.
The controls are placed in three containers: One holds the selection
of the font controls, one holds the sample font controls, and
the last holds the controls used to get out of the dialog. All
three of these containers are placed on the dialog using the default
BorderLayout Manager. Finally, the possible choice values are
populated with a call to <TT>FillChoiceLists</TT> and the controls
are initialized with the font passed into the constructor via
<TT>fData</TT>.
<P>
<TT>action</TT> and <TT>handleEvent</TT> are straightforward and
are implemented very similar to the color dialog of <TT>EX16B</TT>,
shown previously.
<P>
<TT>FillChoiceLists</TT> is used to populate the choices. The
<TT>Toolkit</TT> class in java.awt contains a function that will
retrieve a list of fonts available to the applet. getFontList
was used to retrieve an array of strings containing the font names
available. Unfortunately, currently there is not a way to get
the font sizes available for each font. Therefore, this example
simply puts a variety of numbers into the size choice. This is
not a problem because fonts are similar to colors in that if a
requested font does not exist, a similar font will be returned
in its place<TT>.</TT>
<P>
<TT>GetSelectedFont</TT> is called to read the font currently
selected and to allocate a new <TT>Font</TT> instance. After a
new font has been generated, the sample is updated to use the
new font. Because we have the potential of drastically changing
the size required to display our sample string, <TT>resize</TT>
is called with the <TT>preferredSize</TT> of the label. This will
change the size of the label to accommodate the new string. Since
the layout manager is like most managers and never does anything
until told to do so, <TT>validate</TT> tells the dialog to reposition
its controls.
<H3><A NAME="CommunicatingwiththeSetFontDialog">
Communicating with the Set Font Dialog</A></H3>
<P>
Communication between the Set Font dialog and the applet is once
again utilizing the <TT>Observer</TT>/<TT>Observable</TT> approach.
Listing 16.9 shows the data class used to hold the font information
making the trip between the applet and the dialog.
<HR>
<BLOCKQUOTE>
<B>Listing 16.9. FontData class of EX16D.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
class FontData extends Observable
{
    protected Font fnt = new Font(&quot;Dialog&quot;, Font.PLAIN, 12);

    public Font GetFont()
    {
        return fnt;
    }

    public void SetFont(Font fnt)
    {
        this.fnt = fnt;                 // save the font

        I// flag the change and notify the on-lookers
        setChanged();
        notifyObservers();
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="UsingtheSetFontDialog">
Using the Set Font Dialog</A></H3>
<P>
Using the Set Font dialog is very similar to using the Set Color
dialog and the complete example using both dialogs can be found
on the accompanying CD as example <TT>EX16D</TT>. Figure 16.4
shows the resulting applet using one of my favorite colored fonts.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f16-4.gif"><B> Figure 16.4 : </B><I>Applet from EX16D.
</I></A><P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter covered the elements of an example where a couple
of very useful dialogs were created. The first dialog allowed
the user to choose a color from either a standard set of colors,
or allowed the user to create their own color by selecting the
concentrations of red, green, and blue. Once the color was selected,
this chapter showed how it was used to change the color of text
being drawn in the applet. As an aside, this chapter showed a
very useful example of the <TT>Observer</TT> and <TT>Observable</TT>
utility classes. The second dialog allowed the user to select
a font from one of the system fonts. This font was then applied
to the text being drawn in the applet.
<P>
The next section covers the networking aspects of the Java language.
Among other topics, accessing various URLs from within applets,
communication using both datagrams and sockets, and Java security
support are covered.
<HR>

<CENTER><P><A HREF="ch15.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch17.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
