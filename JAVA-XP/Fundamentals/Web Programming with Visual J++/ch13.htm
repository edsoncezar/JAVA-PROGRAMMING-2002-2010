<HTML>
<HEAD>
<TITLE>Chapter 13 -- Using Java Streams</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;13</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Using Java Streams</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#WhatIsaStream">
What Is a Stream?</A>
<LI><A HREF="#AbstractStreamClassesInputStreamandOutputStream">
Abstract Stream Classes-InputStream and OutputStream</A>
<UL>
<LI><A HREF="#InputStream">
InputStream</A>
<LI><A HREF="#OutputStream">
OutputStream</A>
</UL>
<LI><A HREF="#ByteArrayandStringStreams">
Byte Array and String Streams</A>
<UL>
<LI><A HREF="#ByteArrayInputStream">
ByteArrayInputStream</A>
<LI><A HREF="#ByteArrayOutputStream">
ByteArrayOutputStream</A>
<LI><A HREF="#StringBufferInputStream">
StringBufferInputStream</A>
</UL>
<LI><A HREF="#FileStreams">
File Streams</A>
<UL>
<LI><A HREF="#FileInputStream">
FileInputStream</A>
<LI><A HREF="#FileOutputStream">
FileOutputStream</A>
</UL>
<LI><A HREF="#FilterStreams">
Filter Streams</A>
<UL>
<LI><A HREF="#FilterInputStream">
FilterInputStream</A>
<LI><A HREF="#BufferedInputStream">
BufferedInputStream</A>
<LI><A HREF="#DataInputStream">
DataInputStream</A>
<LI><A HREF="#LineNumberInputStream">
LineNumberInputStream</A>
<LI><A HREF="#PushbackInputStream">
PushbackInputStream</A>
<LI><A HREF="#FilterOutputStream">
FilterOutputStream</A>
<LI><A HREF="#BufferedOutputStream">
BufferedOutputStream</A>
<LI><A HREF="#DataOutputStream">
DataOutputStream</A>
<LI><A HREF="#PrintStream">
PrintStream</A>
</UL>
<LI><A HREF="#PipeStreams">
Pipe Streams</A>
<UL>
<LI><A HREF="#PipedInputStream">
PipedInputStream</A>
<LI><A HREF="#PipedOutputStream">
PipedOutputStream</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
Java includes a well-designed collection of stream classes and
interfaces that make up most of the java.io package. This chapter
describes several uses for streams and how to take advantage of
them in your Java applets and applications. Because streams in
Java are an integral part of network programming, this chapter
will establish a foundation that is built upon in Part IV, &quot;Networking
with Java.&quot;
<H2><A NAME="WhatIsaStream"><FONT SIZE=5 COLOR=#FF0000>
What Is a Stream?</FONT></A></H2>
<P>
At the heart of every computer program is the concept of exchanging
data between two or more sources. This can be as simple as reading
data from or writing data to a buffer within the same program
or as seemingly complex as transferring data between two different
processes running on different systems located on opposite sides
of the world. The sources and destinations of data transfer are
also diverse. On the typical personal computer, input devices
include the keyboard and mouse, whereas output devices include
the monitor and printer. Devices capable of both input and output
include the disk drive, modem, and network interface card.
<P>
Streams were created to abstract the concept of exchanging information
between these various devices and provide a consistent interface
for programmers to interact with different sources of I/O in their
programs. The basic idea of a stream is that data enters one end
of a data channel in a particular sequence and comes out the other
end in the same sequence-a first-in-first-out (FIFO) scheme. The
very nature of streams is a perfect match for an object-oriented
language such as Java. In addition, the built-in Java stream classes
can be extended through inheritance to provide the same operations
as those used for the primitive data types for your own user-defined
types.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Depending on the capability of the source or destination of a stream to process the data being requested or written in a timely manner, your program might encounter situations where it has to wait for a device to process a request. This side effect of 
stream processing is known as blocking and most often occurs when hardware devices are involved, such as disk drives or network connections. The good news is that Java's stream classes and methods were designed with blocking in mind. The effects of 
blocking are mitigated by checking the stream for blocking before reading or writing, using buffers or caches, or running stream I/O requests in threads so that blocking does not affect the rest of your program</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="AbstractStreamClassesInputStreamandOutputStream"><FONT SIZE=5 COLOR=#FF0000>
Abstract Stream Classes-InputStream and OutputStream</FONT></A></H2>
<P>
Java's implementation of streams begins with two abstract classes:
<TT>InputStream</TT> and <TT>OutputStream</TT>. All specialized
streams for input and output operations are derived from these
two classes. In addition, java.io includes a few interfaces and
support classes that as a group provide a powerful framework for
your streaming needs.
<H3><A NAME="InputStream">
InputStream</A></H3>
<P>
<TT>InputStream</TT> includes several methods that provide the
basic input needs for all the input streams to come. Each of the
<TT>read()</TT> methods extract one or more bytes of data from
the stream and move the current position in the stream along according
to how many bytes are read. Each <TT>read()</TT> and <TT>skip()</TT>
method will also block until at least some data is available to
process. Table 13.1 lists the name and a brief description of
each <TT>public</TT> method.<BR>
<P>
<CENTER><B>Table 13.1. Public methods of InputStream.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><I><B>Method</B></I></TD><TD WIDTH=385><I><B>Description</B></I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int read()</TT></TD><TD WIDTH=385>Reads a single byte of data from the stream. The return value is the byte read as an <TT>int</TT> or <TT>-1</TT> if the end of the stream was reached.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int read(byte[])</TT></TD><TD WIDTH=385>Reads data into an array of bytes. The number of bytes read is determined by the length of the byte array passed as an argument. The return value is the number of bytes read or 
<TT>-1</TT> if the end of the stream was reached.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int read(byte[], int, int)</TT></TD><TD WIDTH=385>Reads data into an array of bytes starting at a specific location in the array for a certain number of bytes. The return value is the number of bytes read or <TT>-1</TT> if 
the end of the stream was reached.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>long skip(long)</TT></TD><TD WIDTH=385>Jumps over the specified number of bytes in the stream. The actual number of bytes skipped is returned from this method. Note that this implementation of <TT>skip()</TT> casts the 
<TT>long</TT> passed as a parameter to an <TT>int</TT> before the skip is performed. It is the job of derived classes to override the default implementation to support skipping larger increments.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int available()</TT></TD><TD WIDTH=385>Returns the number of bytes that can be read without blocking.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>mark(int)</TT></TD><TD WIDTH=385>Positions a placeholder at the current position in the stream that can be returned to later by calling <TT>reset()</TT> and sets the maximum number of bytes that can be read before the mark 
is invalidated. Because not all input streams support marking, <TT>markSupported()</TT> should be called first to determine whether marking is supported by the current input stream if the type of stream is unknown at runtime.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>boolean markSupported()</TT></TD><TD WIDTH=385>Returns an indication of the current input stream's capability to support marking.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>reset()</TT></TD><TD WIDTH=385>Returns the current position in the stream to the location set in the previous call to <TT>mark()</TT>. If the number of bytes read since the last <TT>mark()</TT> has exceeded the limit, an 
<TT>IOException</TT> is thrown.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>close()</TT></TD><TD WIDTH=385>Closes the input stream and releases any resources allocated by the stream.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Many of the methods in the java.io package throw exceptions when problems arise. Most stream exceptions are of the <TT>IOException</TT> variety, a class derived from <TT>Exception</TT>, which is used exclusively by java.io. Four other exception classes 
derived from <TT>IOException</TT> provide more specific types of exceptions. All the <TT>InputStream</TT> methods except <TT>mark()</TT> and <TT>markSupported()</TT> throw an <TT>IOException</TT> when I/O errors occur
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="OutputStream">
OutputStream</A></H3>
<P>
Like <TT>InputStream</TT>, the abstract class <TT>OutputStream</TT>
provides the fundamental methods used by all its derived stream
classes. Also like the <TT>InputStream</TT> <TT>read()</TT> methods,
the <TT>write()</TT> methods will block until the data is actually
written to the output object or device. An <TT>IOException</TT>
is thrown if any of the <TT>OutputStream </TT>methods encounter
an error. Table 13.2 lists the name and a brief description of
each <TT>public</TT> method.<BR>
<P>
<CENTER><B>Table 13.2. Public methods of OutputStream.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=199><I><B>Method</B></I></TD><TD WIDTH=391><I><B>Description</B></I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>write(int)</TT></TD><TD WIDTH=391>Writes a single byte to the stream.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>write(byte[])</TT></TD><TD WIDTH=391>Writes the entire length of an array of bytes to the stream.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>write(byte[], int, int)</TT></TD><TD WIDTH=391>Writes a portion of an array of bytes starting at a specific location in the array for a certain number of bytes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>flush()</TT></TD><TD WIDTH=391>If the output stream is buffered, this method will force any bytes in the buffer to be written to the stream.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199><TT>close()</TT></TD><TD WIDTH=391>Closes the output stream and releases any resources allocated by the stream.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="ByteArrayandStringStreams"><FONT SIZE=5 COLOR=#FF0000>
Byte Array and String Streams</FONT></A></H2>
<P>
Now that we have covered the primary base classes used by input
and output streams, let's cover some concrete stream classes.
First we'll discuss the input and output streams that can be used
with objects in memory, byte arrays, and <TT>String</TT> objects.
<H3><A NAME="ByteArrayInputStream">
ByteArrayInputStream</A></H3>
<P>
Derived from <TT>InputStream</TT>, a <TT>ByteArrayInputStream</TT>
object allows you to perform input stream style operations on
an ordinary byte array. This can be valuable when you are working
with a sequence of data in the form of a byte array and want to
read single or multiple bytes, skip, or jump around within the
array. Using streams in this fashion extends the built-in array
access methods of subscripting by providing a more powerful and
flexible framework.
<P>
<TT>ByteArrayInputStream</TT> offers two constructors: one that
takes a byte array as a parameter and the other that accepts a
byte array, an offset to the first byte to start reading, and
the length of the byte array as parameters.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
<TT>ByteArrayInputStream</TT> internally stores a reference to the byte array passed to the constructor as well as the length of the array. Therefore, the byte array is not duplicated within <TT>ByteArrayInputStream</TT>. However, be aware that any changes 
made directly to the byte array used by the <TT>ByteArrayInputStream</TT> will also affect the stream. Also, marking is not supported by this class, but the <TT>reset()</TT> method will reposition the stream to the beginning of the array
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The sample Java application found in Listing 13.1 illustrates
how a byte array can be accessed as an input stream and the effect
of manipulating the byte array after the <TT>ByteArrayInputStream</TT>
object has been created.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. EX13A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 

class EX13A
{
    void printInputStream(InputStream s)
    {
        try 
        {
            System.out.print(&quot;[&quot;);
            while (s.available() &gt; 0) 
            {
                System.out.print(s.read());
            }
            System.out.println(&quot;]&quot;);
            s.reset();
        } 
        catch (Exception e) 
        {
            System.err.println(&quot;Error displaying array: &quot; + e);
        }
    }

    public static void main(String args[])
    {
        byte buf1[] = { 1, 2, 3, 4, 5 };
        // Create an input stream based on buf1.
        InputStream is1 = new ByteArrayInputStream(buf1);
        EX13A example = new EX13A();
        example.printInputStream(is1);   // Print the stream as is. 
        buf1[0] = 0;                     // Modify the array outside of the stream. 
        example.printInputStream(is1);   // Print it again. 
        byte buf2[] = { 6, 7, 8, 9 };    // Create another array... 
        buf1 = buf2;                     // ... and assign it to buf1. 
        example.printInputStream(is1);   // Print it one last time. 
        // Create another input stream based on buf2 that works with
        // the last two bytes of the array only. 
        InputStream is2 = new ByteArrayInputStream(buf2, 2, buf2.length - 2);
        example.printInputStream(is2);   // Finally, print is2.
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This application produces the following output:
<BLOCKQUOTE>
<PRE>
[12345]
[02345]
[02345]
[89]
</PRE>
</BLOCKQUOTE>
<P>
Notice that when the array used by the stream is modified after
the stream is created, the change is reflected the next time the
stream is printed. However, also note that when the array used
by the stream is assigned to another array, the internal reference
to the original array is unaffected.
<H3><A NAME="ByteArrayOutputStream">
ByteArrayOutputStream</A></H3>
<P>
This class is the complement of <TT>ByteArrayInputStream</TT>
in that it allows you to write data into an array of bytes. Except
with this output version, the class internally creates and maintains
the byte array for you. In fact, it even will expand the byte
array as needed. Of course, it also has methods to retrieve the
internal byte array at any point as a byte array, string, or Unicode
string.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although all strings in Java are represented in Unicode format, the <TT>toString(int)</TT> method in <TT>ByteArrayOutputStream</TT> allows you to specify the value used for the upper byte of each 2-byte character represented in the string
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The following simple code segment illustrates how to create, write
to, and retrieve the contents of a <TT>ByteArrayOutputStream</TT>:
<BLOCKQUOTE>
<PRE>
// Create a stream with a starting internal buffer size of 1 byte.
ByteArrayOutputStream os = new ByteArrayOutputStream(1);
try
{   // Overflow initial allocated buffer size.
    os.write(72);     // &quot;H&quot;
    os.write(105);    // &quot;i&quot;
}
catch (IOException e)
{
    System.err.println(&quot;Error writing to byte stream: &quot; + e);
}
// Retrieve stream's internal buffer as a byte array.
byte buf[] = os.toByteArray();
// See how it grew...
System.out.println(&quot;Length of array is &quot; + buf.length + &quot;\n&quot; + os.toString());
</PRE>
</BLOCKQUOTE>
<H3><A NAME="StringBufferInputStream">
StringBufferInputStream</A></H3>
<P>
Like <TT>ByteArrayInputStream</TT>, <TT>StringBufferInputStream</TT>
allows you to interact with a memory-based object, namely a string,
in the context of a stream. However, because the <TT>String</TT>
class already provides a wealth of access methods, the use of
<TT>StringBufferInputStream</TT> solely for working with strings
does not add much value. But if your program is expected to handle
data from conventional stream sources (for example, files or network
connections) as well as strings, <TT>StringBufferInputStream</TT>
provides the necessary abstraction.
<H2><A NAME="FileStreams"><FONT SIZE=5 COLOR=#FF0000>
File Streams</FONT></A></H2>
<P>
Although file I/O in Java applets is usually denied or restricted
due to security constraints imposed by browsers, the java.io package
includes a complete set of stream classes for dealing with disk
files. Indeed, Java applications are not subject to the same security
constraints as applets and can include sophisticated file I/O
functionality.
<H3><A NAME="FileInputStream">
FileInputStream</A></H3>
<P>
From the input side, <TT>FileInputStream</TT> provides basic input
stream capabilities for dealing with files. A <TT>FileInputStream</TT>
object can be created using one of three constructors that accept
the name of a file, a <TT>File</TT> object, or a <TT>FileDescriptor</TT>
object, respectively.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although <TT>File</TT> and <TT>FileDescriptor</TT> are classes within the java.io package, they will not be discussed in detail here because they are not part of the stream family of classes. Suffice it to say that the <TT>File</TT> class is used to 
represent a file in terms of the notation used by the host file system and provides basic file and directory functions such as making directories, enumerating files in a directory, deleting files, and renaming files. The <TT>FileDescriptor</TT> class is 
simply used to represent a handle to an open file or socket. Sockets and their integration with streams will be covered in detail in Part IV, &quot;Networking with Java.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The example in Listing 13.2 prints the contents of a text file
named <TT>somefile.dat</TT> to the console.
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. EX13B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 

class EX13B
{
    public static void main(String args[])
    {
        try 
        {
            // Create a simple file input stream.
            FileInputStream fis = new FileInputStream(&quot;somefile.dat&quot;);

            // Read the entire contents of the file.
            while (fis.available() &gt; 0) 
            {
                System.out.print((char)fis.read());
            }
        } 
        catch (Exception e) 
        {
            System.err.println(&quot;Error reading file: &quot; + e);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="FileOutputStream">
FileOutputStream</A></H3>
<P>
The <TT>FileOutputStream</TT> class is very similar to <TT>FileInputStream</TT>
in that it can be created by either a filename passed as a string,
<TT>File</TT> object, or <TT>FileDescriptor</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Because <TT>FileOutputStream</TT> starts writing at the beginning of a file, any data in the file before it is opened will be lost. If you would like to append data to a file or begin writing at a specific location, the <TT>RandomAccessFile</TT> class can 
be used in conjunction with <TT>FileOutputStream</TT> to achieve the same results as shown in the following example
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The example in Listing 13.3 opens a file for reading and writing
using a <TT>RandomAccessFile</TT> object, binds an output stream
to it, and writes a string to the end of the file.
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. EX13C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 

class EX13C
{
    public static void main(String args[])
    {
        RandomAccessFile rf;
        try 
        {
            // Open a file for read and write access.
            rf = new RandomAccessFile(&quot;outfile.dat&quot;, &quot;rw&quot;);
            // Use the just opened file as the destination for a stream.
            of = new FileOutputStream(rf.getFD());
            // Attach a print stream to output stream.
            PrintStream pos = new PrintStream(new FileOutputStream(rf.getFD()));
            // Go to the end of the file...
            rf.seek(rf.length());
            // ... and write a string.
            pos.print(&quot;Tack this to the end of the file.&quot;);
        } 
        catch (IOException e) 
        {
            System.err.println(&quot;Error writing to file: &quot; + e);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="FilterStreams"><FONT SIZE=5 COLOR=#FF0000>
Filter Streams</FONT></A></H2>
<P>
As mentioned earlier, streams are simply a metaphor for data entering
one end of a data channel and exiting the other end in the same
order. What if you would like to modify the data as it travels
in or out of the data channel, without having to extend Java's
input and output streams? Filter streams not only provide the
capability to manipulate data as it passes through a stream but
they can also be chained together to create a combined effect
of several filters. This is perhaps the most powerful aspect of
Java's streams.
<P>
There are two base classes that input and output filter classes
are derived from: <TT>FilterInputStream</TT> and <TT>FilterOutputStream</TT>.
<H3><A NAME="FilterInputStream">
FilterInputStream</A></H3>
<P>
On the input stream side, <TT>FilterInputStream</TT> is the base
class for all the input stream filters. This class does not make
any modifications to the attached stream, but merely provides
the chaining functionality that will be exploited by its subclasses.
The <TT>FilterInputStream</TT> is attached to an input stream
by passing the input stream to the filter stream's constructor.
<BLOCKQUOTE>
<PRE>
InputStream is = new FileInputStream(&quot;somefile.dat&quot;);
FilterInputStream fis = new FilterInputStream(is);    // Meaningless filter attached.
</PRE>
</BLOCKQUOTE>
<H3><A NAME="BufferedInputStream">
BufferedInputStream</A></H3>
<P>
The <TT>BufferedInputStream</TT>'s contribution to its attached
stream is the addition of a buffer, or cache, to the stream. This
has the effect of improving the performance of some input streams,
especially those bound to slower sources like a file or network
connection.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The C++ stream library uses the subclasses of the abstract streambuf class to provide buffering to its streams. However, buffered streams in C++ encapsulate a pointer to a streambuf object rather than using Java's filter approach</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
You can specify the size of the buffer used by <TT>BufferedInputStream</TT>
when it is created or accept the default of 2048 bytes. It then
intercepts your calls to the <TT>read</TT> methods and attempts
to satisfy your request with data in its buffer. If the data in
the buffer is not sufficient, a read to the next input stream
in the chain is done to fill the buffer and return the data requested.
Anytime a read request can be satisfied from the buffer, you have
saved a potentially slow read from the attached stream. <TT>BufferedInputStream</TT>
also supports marking and ensures that the mark limit set remains
valid.
<P>
Because file access can sometimes be quite slow, let's enhance
the example in Listing 13.2 to use a <TT>BufferedInputStream</TT>.
The improved version is shown in Listing 13.4.
<HR>
<BLOCKQUOTE>
<B>Listing 13.4. EX13D.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 

class EX13D
{
    public static void main(String args[])
    {
        try 
        {
            // Create and attach a simple file input stream to a 
            // buffered filter, using the default buffer size of 2048 bytes.
            BufferedInputStream bis = new BufferedInputStream(new 				
			&aring;FileInputStream(&quot;somefile.dat&quot;));

            // Now read the buffered stream.
            while (bis.available() &gt; 0) 
            {
                System.out.print((char)bis.read());
            }
        } 
        catch (Exception e) 
        {
            System.err.println(&quot;Error reading file: &quot; + e);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Although it might not be obvious from this example, when the first
call to <TT>read()</TT> is made, the <TT>BufferedInputStream</TT>
reads in 2048 bytes (the default size of the buffer) and simply
returns 1 byte at a time from the buffer for subsequent reads.
There are certainly hardware and operating system caches involved
as well, but it is always going to be faster to satisfy a read
request from a memory location within the program than it is to
make a system call to the operating system. It would also be more
efficient to read more than one byte at a time from the stream,
especially if it is unbuffered, but as we will see in the next
section, some data types within a stream are only made up of a
few bytes, so the value of <TT>BufferedInputStream</TT> still
exists.
<H3><A NAME="DataInputStream">
DataInputStream</A></H3>
<P>
A stream of data, especially if it contains primitive data types,
is of little use unless it can be converted from a sequence of
bytes into its native type. Indeed, all the examples we have looked
at thus far have dealt with streams of text data that required
nothing more than casting each <TT>int</TT> returned to a character
before it was used.
<BLOCKQUOTE>
<PRE>
char c = (char)someinputstream.read();
</PRE>
</BLOCKQUOTE>
<P>
In real programs, the data being transferred through streams is
certainly going to be more complex and made up of several different
types. And for most primitive data types such as <TT>long</TT>,
<TT>float</TT>, and <TT>double</TT>, casting is not appropriate.
The task of converting data to its native type as it is received
is the perfect job for a filter stream. <TT>DataInputStream</TT>
is a subclass of <TT>FilterInputStream</TT> and is responsible
for filtering primitive data types from an input stream.
<H4>DataInput Interface</H4>
<P>
Because translating unknown pieces of machine-independent data
into primitive data types has meaning outside of input streams,
the <TT>DataInput</TT> interface was developed to create a generic
connection to its translation methods. <TT>DataInputStream</TT>
implements the <TT>DataInput</TT> interface.
<P>
Table 13.3 lists the name and description of each method of the
<TT>DataInput</TT> interface.<BR>
<P>
<CENTER><B>Table 13.3. Public methods of the DataInput interface.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><I><B>Method</B></I></TD><TD WIDTH=385><I><B>Description</B></I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>readFully(byte[])</TT></TD><TD WIDTH=385>Like <TT>read(byte[])</TT>, this method reads data into an array of bytes. The number of bytes read is determined by the length of the byte array passed as an argument.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>readFully(byte[], int, int)</TT></TD><TD WIDTH=385>Like <TT>read(byte[], int, int)</TT>, this method reads data into an array of bytes starting at a specific location in the array for a certain number of bytes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int skipBytes(int)</TT></TD><TD WIDTH=385>Like <TT>skip(long)</TT>, this method jumps over the specified number of bytes in the stream. The actual number of bytes skipped is returned from this method. Note that this 
<TT>skip()</TT> takes an <TT>int</TT> rather than a <TT>long</TT> as a parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>boolean readBoolean()</TT></TD><TD WIDTH=385>Reads and returns a Boolean.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>byte readByte()</TT></TD><TD WIDTH=385>Like <TT>read()</TT>, this method reads and returns a single byte of data but returns the byte as a <TT>byte</TT> rather than an <TT>integer.</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int readUnsignedByte()</TT></TD><TD WIDTH=385>Reads and returns an <TT>unsigned byte</TT> cast as a 32-bit integer to prevent possible truncation.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>short readShort()</TT></TD><TD WIDTH=385>Reads and returns a 16-bit <TT>short</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int readUnsignedShort()</TT></TD><TD WIDTH=385>Reads and returns an <TT>unsigned short</TT> cast as a 32-bit integer to prevent possible truncation.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>char readChar()</TT></TD><TD WIDTH=385>Reads and returns a 16-bit character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>int readInt()</TT></TD><TD WIDTH=385>Reads and returns a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>long readLong()</TT></TD><TD WIDTH=385>Reads and returns a 64-bit <TT>long</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>float readFloat()</TT></TD><TD WIDTH=385>Reads and returns a 32-bit <TT>float</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>double readDouble()</TT></TD><TD WIDTH=385>Reads and returns a 64-bit <TT>double</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>String readLine()</TT></TD><TD WIDTH=385>Reads a line of text until a <TT>\r</TT>, <TT>\n</TT>, or <TT>\r\n</TT> is found. The text is returned as a string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>String readUTF()</TT></TD><TD WIDTH=385>Like <TT>readLine()</TT>, this method reads a line of text from the stream. However, the text is read as a UTF-8 encoded string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Because the built-in Java integer types are all signed, they might not be large enough to hold their unsigned counterparts. For this reason, <TT>readUnsignedByte()</TT> and <TT>readUnsignedShort()</TT> return integers to prevent the value from possibly 
being truncated. Remember that because an integer in Java is 32 bits, it is more than capable of holding the largest possible <TT>unsigned byte</TT> or <TT>unsigned short</TT> values
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Rather than include an example of how to use <TT>DataInputStream</TT>
here, let's see how it works in conjunction with some of the other
filter streams. The example for <TT>LineNumberInputStream</TT>
(discussed next) and <TT>DataOutputStream</TT> both use <TT>DataInputStream</TT>.
<H3><A NAME="LineNumberInputStream">
LineNumberInputStream</A></H3>
<P>
The <TT>LineNumberInputStream</TT> is another input stream filter,
except its task is to count the number of lines that have been
read. It is most useful when you are reading several lines of
text from a source, typically a file, and want to keep track of
the current line number or total number of lines in a stream.
The methods <TT>setLineNumber()</TT> and <TT>getLineNumber()</TT>
enable you to set and get the internal line number count maintained
by <TT>LineNumberInputStream</TT>.
<P>
Consider the example in Listing 13.5 that implements a simple
text search program similar to UNIX's <TT>grep</TT> command.
<HR>
<BLOCKQUOTE>
<B>Listing 13.5. EX13E.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 

class EX13E
{
    public static void searchFile(String criteria, File file)
    {
        try
        {
            // Create a buffered line-number stream based on the target file.
            LineNumberInputStream linestream = 
                new LineNumberInputStream
                (new BufferedInputStream(new FileInputStream(file)));
            DataInputStream dis = new DataInputStream(linestream);

            while (dis.available() &gt; 0)
            {
                String line = dis.readLine();
                if (line.indexOf(criteria) != -1)
                {   // Found a match!
                    System.out.println(&quot;File &quot; + file.getName() + &quot;, line &quot; + 
                            linestream.getLineNumber() + &quot;:\n&quot; + line);
                }
            }
        }
        catch (IOException e)
        {
            System.err.println(&quot;Error reading &quot; + file.getName() + &quot;: &quot; + e);
        }
    }

    private static void usage()
    {
        System.err.println(&quot;Usage: grep searchtext target&quot;);
        System.err.println(&quot;Where target is a file or directory.&quot;);
    }

    public static void main(String args[])
    {
        if (args.length != 2)
        {
            System.err.println(&quot;Invalid number of arguments.&quot;);
            usage();
            return;
        }

        File target = new File(args[1]);

        if (target.isDirectory())
        {   // Retrieve a list of the files in the directory...
            String[] list = target.list();

            // ... and search each file for the search text.
            for (int i = 0; i &lt; list.length; i++)
            {
                searchFile(args[0], new File(target, list[i]));
            }
        }
        else if (target.isFile())
        {
            // Just one file so just pass it to the search routine.
            searchFile(args[0], target);
        }
        else
        {
            System.err.println(&quot;Target is not a file or directory.&quot;);
            usage();
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Notice how a <TT>BufferedInputStream</TT> is sandwiched between
the <TT>LineNumberInputStream</TT> and the <TT>FileInputStream</TT>
to provide I/O buffering for each file. It is critical that the
<TT>BufferedInputStream</TT> be attached first so that all the
other filter streams will leverage the buffering. It is also important
that the <TT>LineNumberInputStream</TT> be attached before the
<TT>DataInputStream</TT> so that calls to the <TT>DataInputStream</TT>
are sent through the <TT>LineNumberInputStream</TT>. Otherwise,
if <TT>LineNumberInputStream</TT> is attached to the <TT>DataInputStream</TT>,
each line will not be counted as it is read. Because we want to
read text from each file one line at a time, <TT>DataInputStream</TT>
was used for its <TT>readLine()</TT> method.
<H3><A NAME="PushbackInputStream">
PushbackInputStream</A></H3>
<P>
This input filter stream is somewhat unusual in that it puts a
character back into an input stream. It can be used if you are
expecting a certain sequence of characters and want to test the
next byte in the stream to see whether it maintains the sequence.
If the sequence is broken, <TT>PushbackInputStream</TT> has an
<TT>unread()</TT> method that stages a byte to be returned as
part of the next read of the stream. The <TT>readLine()</TT> method
of <TT>DataInputStream</TT> uses a <TT>PushbackInputStream</TT>
(if the host stream is not already a <TT>PushbackInputStream</TT>)
if the carriage-return line-feed (<TT>\r\n</TT>) sequence is broken.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>PushbackInputStream</TT> filter functions similar to the <TT>peek()</TT> member function of the <TT>iostream</TT> class in the C++ stream library. However, the <TT>PushbackInputStream</TT> returns a byte to the stream whereas the <TT>peek()</TT> 
member function in <TT>iostream</TT> allows you to preview the next character in the stream without removing it
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="FilterOutputStream">
FilterOutputStream</A></H3>
<P>
On the output stream side, <TT>FilterOutputStream</TT> forms the
basis for the output stream filters. Like <TT>FilterInputStream</TT>,
it does not make any modifications to stream data as it passes
by but only provides the chaining used by its subclasses. The
<TT>FilterOutputStream</TT> is attached to an output stream by
passing the output stream to the filter stream's constructor.
<H3><A NAME="BufferedOutputStream">
BufferedOutputStream</A></H3>
<P>
<TT>BufferedOutputStream</TT> provides the same performance gains
that <TT>BufferedInputStream</TT> does for input streams, but
its buffer is used for an output stream. The basic concept is
the same. Requests to write to an output stream are cached in
an internal buffer. When the internal buffer reaches capacity
it is flushed from the buffer to the output stream. The size of
the internal buffer defaults to 512 bytes but can be overridden
by calling the appropriate constructor with the desired size.
<P>
Because the use of a <TT>BufferedOutputStream</TT> is so similar
to that of <TT>BufferedInputStream</TT>, an example will not be
presented.
<H3><A NAME="DataOutputStream">
DataOutputStream</A></H3>
<P>
This filter provides methods that write primitive data types to
an output stream. Primitive data types are most often used when
working with files or network connections. Like <TT>DataInputStream</TT>,
this class implements the methods of an interface, <TT>DataOutput</TT>.
<H4>DataOutput Interface</H4>
<P>
The <TT>DataOutput</TT> interface defines the methods to write
Java's primitive data types to a source. Within the java.io package,
<TT>DataOutput</TT> is implemented by <TT>DataOutputStream</TT>
and <TT>RandomAccessFile</TT>. As already mentioned, <TT>DataOutputStream</TT>
implements <TT>DataOutput</TT> to write primitive types to an
output stream. <TT>RandomAccessFile</TT> implements <TT>DataOutput</TT>
to write primitive types solely to a disk file. Although a member
of the java.io package, <TT>RandomAccessFile</TT> will not be
discussed here because it is not a part of the stream hierarchy.
<P>
Table 13.4 lists the name and description of each method of the
<TT>DataOutput</TT> interface as it relates to <TT>DataOutputStream</TT>.
<BR>
<P>
<CENTER><B>Table 13.4. Public methods of the DataOutput interface.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=244><I><B>Method</B></I></TD><TD WIDTH=346><I><B>Description</B></I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>write(int)</TT></TD><TD WIDTH=346>Writes 1 byte as a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>write(byte[])</TT></TD><TD WIDTH=346>Writes an entire byte array. The number of bytes written is determined by the length of the byte array passed as an argument.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>write(byte[], int, int)</TT></TD><TD WIDTH=346>Writes the portion of a byte array starting at a specific location in the array for a certain number of bytes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeBoolean(boolean)</TT></TD><TD WIDTH=346>Writes an 8-bit <TT>Boolean</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeByte(int)</TT></TD><TD WIDTH=346>Like <TT>write(int)</TT>, this method writes a single byte as a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeShort(int)</TT></TD><TD WIDTH=346>Writes a <TT>short</TT> as a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeChar(int)</TT></TD><TD WIDTH=346>Writes a <TT>char</TT> as a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeInt(int)</TT></TD><TD WIDTH=346>Writes a 32-bit integer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeLong(long)</TT></TD><TD WIDTH=346>Writes a 64-bit <TT>long</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeFloat(float)</TT></TD><TD WIDTH=346>Writes a 32-bit <TT>float</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeDouble(double)</TT></TD><TD WIDTH=346>Writes a 64-bit <TT>double</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeBytes(String)</TT></TD><TD WIDTH=346>Writes a <TT>String</TT> as bytes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeChars(String)</TT></TD><TD WIDTH=346>Writes a <TT>String</TT> as chars.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT>writeUTF(String)</TT></TD><TD WIDTH=346>Writes a <TT>String</TT> as a UTF-8 encoded sequence of characters.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The C++ stream library uses operator overloading to write primitive data types to a stream. Although the syntax of operator overloading may appear more elegant, it can be difficult to program correctly and can be confusing to users of your classes. The 
creators of Java felt that this was too much of a price to pay</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The example shown in Listing 13.6 ties together several of the
stream classes and stream filters that we have already discussed
into one program. The basic idea of the program is to read statistics
about itself when it is started, update the statistics, and write
them back out. The statistics are stored in a file with the same
name as the class and the extension <TT>.dat</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 13.6. EX13F.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*; 
import java.util.Date;

class EX13F
{
    private Date dateLastUpdated;   // Date the last time the stats for this program 		
	&aring;were written.
    private String userLastUpdated; // User's name that performed the last update.
    private int executionCount;     // The number of times this program has been run.

    // This method reads the program stats from a file by the same name as the class.
    public void retrieveStats() throws IOException
    {
        try
        {
            // Create a data stream filter with a file input stream as the host 			
			&aring;stream.
            DataInputStream dis = new DataInputStream(new 					
			&aring;FileInputStream(getClass().getName() + &quot;.dat&quot;));

            // Initialize the data members with the values in the stat file.
            dateLastUpdated = new Date(dis.readLong());
            userLastUpdated = dis.readUTF();
            executionCount = dis.readInt();
        }
        catch (FileNotFoundException e) 
        {
            // Eat this exception since the file won't exist initially.
        }
    }

    // This method writes the program stats back out to the same file.
    public void saveStats() throws IOException
    {
        // Update date is now.
        Date today = new Date();

        // This time create an output data filter attached to a file output stream.
        DataOutputStream dos = new DataOutputStream(new 						
		&aring;FileOutputStream(getClass().getName() + &quot;.dat&quot;));

        // Write each value back out to the file.
        dos.writeLong(Date.parse(today.toGMTString()));
        if (userLastUpdated.length() == 0)
            userLastUpdated = &quot;Ace Programmer&quot;;
        dos.writeUTF(userLastUpdated);
        dos.writeInt(++executionCount);
    }

    public static void main(String args[])
    {
        EX13F example = new EX13F();  // Create an instance.

        try 
        {   // Read the stats in from the last run.
            example.retrieveStats();

            // And print them out.
            System.out.println(&quot;Program last update date: &quot; + 					
			&aring;example.dateLastUpdated);
            System.out.println(&quot;Last updated by: &quot; + example.userLastUpdated);
            System.out.println(&quot;Execution count: &quot; + example.executionCount);

            // Now prompt the user for their name to update the stat file.
            System.out.print(&quot;\nWhat is your name: &quot;);
            System.out.flush();

            // Use a data stream again so we can use readLine() 
            // to read from the console.
            DataInputStream stdin = new DataInputStream(System.in);
            example.userLastUpdated = stdin.readLine();

            // Finally, save the stats back out to the file.
            example.saveStats();
        } 
        catch (Exception e) 
        {
            System.err.println(&quot;Error processing stats file: &quot; + e);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, primitive data types are read and written from
a disk file using <TT>DataInputStream</TT> and <TT>DataOutputStream</TT>
filters. The current date is converted to a <TT>long</TT> before
being written to the file and is read back in as a <TT>long</TT>
and converted back into a date. The user's name is written out
as a <TT>String</TT> using <TT>writeUTF()</TT> to take advantage
of the fact that this method writes the string's length to the
stream prior to the actual characters. The <TT>readUTF()</TT>
method then reads the stream for the size of the string first
to determine the length of the string-a built-in variable length
string handler. Finally, the execution count of the program is
written and read as an integer.
<P>
This program also illustrates how to prompt for and retrieve user
input from the keyboard using a text-based application. The <TT>java.lang.System</TT>
class has three <TT>public</TT> <TT>static</TT> stream objects
representing the standard input, output, and error for the system.
The file system reserves file descriptors 0, 1, and 2 for standard
input, output, and error, respectively. Although these three file
descriptors are used most of the time for interacting with the
keyboard and console, they can also be redirected to files and
the standard input and output of other programs via unnamed pipes.
Therefore, the <TT>System.in</TT> object is a buffered input file
stream while <TT>System.out</TT> and <TT>System.err</TT> are buffered
print output file streams. The host operating system's command
interpreter, or shell, takes care of redirecting the standard
input, output, and error in the appropriate context each time
a program is run.
<H3><A NAME="PrintStream">
PrintStream</A></H3>
<P>
We have actually been using the <TT>PrintStream</TT> filter in
every sample program in this chapter. As mentioned in the previous
paragraph, the <TT>System.out</TT> and <TT>System.err</TT> objects
are <TT>FileOutputStream</TT>s that use a <TT>PrintStream</TT>
filter. This filter adds the capability to force the attached
stream to be flushed every time a newline (<TT>\n</TT>) character
is written. It also provides several overloaded versions of <TT>print()</TT>
and <TT>println()</TT> that write each of the primitive data types
to the attached stream as strings. In addition, each of the <TT>println()</TT>
methods also append a newline to each object written.
<H2><A NAME="PipeStreams"><FONT SIZE=5 COLOR=#FF0000>
Pipe Streams</FONT></A></H2>
<P>
Pipes have been an integral part of several operating systems
for many years. In general, pipes are used to provide a one-way
communication link between two processes. In Java, pipes can be
used to connect two threads or two applets. And since pipes were
implemented as streams, any of the stream filters can be attached
to a pipe to provide the same effects that we have already seen.
If a two-way communications link is needed, two pairs of pipes
can be constructed that flow in opposite directions.
<P>
Pipes are supported by two classes: <TT>PipedInputStream</TT>
and <TT>PipedOutputStream</TT>. They must be created in pairs
and connected to each other by using either class's <TT>connect()</TT>
method.
<H3><A NAME="PipedInputStream">
PipedInputStream</A></H3>
<P>
The receiving end of a piped stream is supported by <TT>PipedInputStream</TT>.
It contains a 1024-byte internal ring buffer that is used to hold
incoming data as it is received from its connected <TT>PipedOutputStream</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Physically, a ring buffer is like any other buffer in memory. However, where it differs from other buffers is in how it is used. Two offsets are used to manage a ring buffer: one represents the position of the last byte written to the buffer and the other 
represents the position of the last byte read. Once either offset reaches the end of the buffer, it is moved back to the beginning. As long as the write offset stays equal to or ahead of the read offset, a ring buffer maintains the illusion of an endless 
piece of memory. However, if the write offset wraps around and passes the read offset, data can be lost. Fortunately, <TT>PipedInputStream</TT> will block further writes to its ring buffer by <TT>PipedOutputStream</TT> until data is read
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
When data is written to an output pipe, <TT>PipedOutputStream</TT>
calls the <TT>receive()</TT> method of its attached <TT>PipedInputStream</TT>
to send data down the pipe. The <TT>receive()</TT> method will
write the data to its buffer if there is room. Otherwise, it will
block the output pipe until there is space in the buffer or the
pipe is broken. Likewise, when a read is performed on <TT>PipedInputStream</TT>
it will return data if it exists in the buffer. Otherwise, it
will block the caller to the <TT>read()</TT> method until the
data requested is received, the pipe is closed, or the pipe is
broken.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
A pipe is determined to be broken when the thread of either end of a pipe terminates</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="PipedOutputStream">
PipedOutputStream</A></H3>
<P>
The <TT>PipedOutputStream</TT> has an easier job. As described
above, once connected to a <TT>PipedInputStream</TT> object, it
simply calls the input pipe's <TT>receive()</TT> method to send
data down the pipe. One point to keep in mind is that calls to
the <TT>write()</TT> methods will block if the input pipe does
not have enough room in its internal buffer to hold the data being
sent. However, if you run your pipe I/O in separate threads, blocking
will not affect the responsiveness of your program.
<P>
The following example illustrates the use of pipes to communicate
between two applets running on the same Web page. One applet sits
in a loop spinning an animated globe. It also creates a thread
that is responsible for monitoring an input pipe for commands
from another applet that change the manner in which the globe
is animated. The second applet displays six pushbuttons that enable
the user to start and stop the animation, change the rotation
of the globe, and increase or decrease the speed of the animation.
When one of the buttons is pressed, a command is sent to the animation
applet through an output pipe. Figure 13.1 displays the Web page
and the two applets in action.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f13-1.gif"><B> Figure 13.1 : </B><I>The pipe stream example.

</I></A><P>
<P>
Listing 13.7 includes a portion of the source code for the first
applet and the thread class used to monitor the input pipe. The
basis for the animation in the applet may look familiar to you
because it is the default animation created by the Visual J++
Applet Wizard. A few enhancements were made to integrate the pipe
monitor thread and the custom animation. The complete source listing
can be found on the accompanying CD-ROM.
<HR>
<BLOCKQUOTE>
<B>Listing 13.7. EX13G.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.io.*;

public class EX13G extends Applet implements Runnable
{
    //...
    private PipedInputStream inputPipe;
    private PipeMonitor monitor;

    public EX13G()
    {   // Create input pipe and share with pipe monitor.
        inputPipe = new PipedInputStream();
        monitor = new PipeMonitor(inputPipe);
    }


    //...

    public void run()
    {
        if (!m_fAllLoaded)
        {   // Load all images first.
            if (!loadImages())
                return;
        }

        while (true)
        {   // Check to see if globe should be animated.
            if (monitor.isAnimated())
            {
                try
                {   // Display image and move on to next image.
                    displayImage(m_Graphics);
                    if (monitor.getRotation() == monitor.FORWARD)
                    {   // Move forward through image array.
                        if (++m_nCurrImage == NUM_IMAGES)
                            m_nCurrImage = 0;
                    }
                    else
                    {   // Move backwards through image array.
                        if (--m_nCurrImage &lt; 0)
                            m_nCurrImage = NUM_IMAGES - 1;
                    }               

                    // Rate of animation is controlled by sleep time.
                    Thread.currentThread().sleep(monitor.getSleepTime());
                }
                catch (InterruptedException e)
                {
                    stop();
                    monitor.stop();
                }
            }
        }
    }


    //...

    public void connectPipes(PipedOutputStream out) throws IOException
    {   // Called by controller applet to connect input &amp; output pipes.
        inputPipe.connect(out);
        // Only start pipe monitor if necessary.
        if (!monitor.isAlive())
            monitor.start();    // Waits for commands sent through pipe.
    }
}

class PipeMonitor extends Thread
{
    public final int FORWARD = 1;
    public final int REVERSE = 2;

    // Setup attributes with default values.
    private int rotation = FORWARD;
    private int sleepTime = 50;
    private boolean animated = true;
    private DataInputStream inputPipe;

    private PipeMonitor() {} // Hide default ctor.

    public PipeMonitor(PipedInputStream pi) 
    { 
        inputPipe = new DataInputStream(pi); 
    }

    // Access methods.
    public synchronized int getRotation() { return rotation; }
    public synchronized int getSleepTime() { return sleepTime; }
    public synchronized boolean isAnimated() { return animated; }

    public void run()
    {
        String cmd;
        while (true)
        {
            try
            {   // Wait for a ('\n' terminated) command from the pipe.
                do
                    cmd = inputPipe.readLine();
                while (cmd == null);

                // Interpret command and change settings.
                if (cmd.equalsIgnoreCase(&quot;FORWARD&quot;))
                    rotation = FORWARD;
                else if (cmd.equalsIgnoreCase(&quot;REVERSE&quot;))
                    rotation = REVERSE;
                else if (cmd.equalsIgnoreCase(&quot;START&quot;))
                    animated = true;
                else if (cmd.equalsIgnoreCase(&quot;STOP&quot;))
                    animated = false;
                else if (cmd.equalsIgnoreCase(&quot;FASTER&quot;))
                    sleepTime -= (sleepTime == 10 ? 0 : 10);
                else if (cmd.equalsIgnoreCase(&quot;SLOWER&quot;))
                    sleepTime += 10;
            }
            catch (IOException e) {}
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The source code for the second applet is shown in Listing 13.8.
The <TT>command()</TT> method is where the connection is made
with the animation applet and the commands are sent down the output
pipe. A <TT>DataOutputStream</TT> filter is attached to the pipe
to allow strings to be sent across the connection.
<HR>
<BLOCKQUOTE>
<B>Listing 13.8. EX13G2.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.io.*;
import EX13G;

public class EX13G2 extends Applet
{
private DataOutputStream outputPipe = null;

    public void init()
    {   // Add control buttons to manipulate globe.
        add(new Button(&quot;Start&quot;));
        add(new Button(&quot;Stop&quot;));
        add(new Button(&quot;Forward&quot;));
        add(new Button(&quot;Reverse&quot;));
        add(new Button(&quot;Faster&quot;));
        add(new Button(&quot;Slower&quot;));
    }

    public boolean action(Event event, Object obj)
    {
        boolean retval = false;

        if (event.target instanceof Button)
        {
            try
            {   // Send the appropriate command based
                // on the label of the button pressed.
                command(((Button)event.target).getLabel());
            }
            catch (IOException e)
            {
                // Add your exception logic here.
            }
            retval = true;
        }

        return retval;
    }

    public void command(String cmd) throws IOException
    {
        if (outputPipe == null)
        {   // Pipe needs to be created and connected to
            // the animated globe applet.

            // Get a reference to the animated globe applet.
            EX13G ex13g;
            ex13g = (EX13G)getAppletContext().getApplet(&quot;globe&quot;);

            if (ex13g == null)
            {
                throw new IOException(&quot;globe applet could not be found.&quot;);
            }

            // Setup output pipe.
            PipedOutputStream p = new PipedOutputStream();
            ex13g.connectPipes(p);
            outputPipe = new DataOutputStream(p);
        }

        outputPipe.writeBytes(cmd + &quot;\n&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The HTML used to run the two applets is shown in Listing 13.9.
It is critical that the name of the first applet be set correctly
so that the command applet can make the connection.
<HR>
<BLOCKQUOTE>
<B>Listing 13.9. EX13G.html.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Example 13g - Pipes&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H2&gt;Example 13g - Pipes&lt;/H2&gt;
&lt;HR&gt;
Applet 1 - Spinning Globe&lt;BR&gt;
&lt;APPLET CODE=EX13G.class WIDTH=300 HEIGHT=100 NAME=globe&gt;&lt;/APPLET&gt;
&lt;HR&gt;
Applet 2 - Globe Controller&lt;BR&gt;
&lt;APPLET CODE=EX13G2.class WIDTH=300 HEIGHT=30 NAME=controller&gt;&lt;/APPLET&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
Java's stream classes provide a flexible and powerful framework
for transferring data between objects. Receivers and senders of
data across a stream can range from in-memory byte arrays to files
on a disk drive. And as we will see in Part IV, streams serve
as the foundation for Java's impressive and easy-to-use networking
features.
<HR>

<CENTER><P><A HREF="ch12.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch14.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>