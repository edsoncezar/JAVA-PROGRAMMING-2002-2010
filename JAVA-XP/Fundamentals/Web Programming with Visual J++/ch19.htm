<HTML>
<HEAD>
<TITLE>chaptaer 19 -- Client/Server Programming</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;19</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Client/Server Programming</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheClientServerModel">
The Client/Server Model</A>
<LI><A HREF="#JavasContribution">
Java's Contribution</A>
<LI><A HREF="#ServerSocketClass">
ServerSocket Class</A>
<LI><A HREF="#ClientServerExampleInternetDictionary">
Client/Server Example: Internet Dictionary</A>
<LI><A HREF="#TheFutureofJavaClientServerDevelopment">
The Future of Java Client/Server Development</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
So far in Part IV, &quot;Networking  with Java,&quot; we have
discovered how Java's URL, datagram, and socket classes can be
used to perform some simple networking tasks. This chapter discusses
the larger world of client/server computing, how Java fits into
this world, and the future of Java related to the client/server
model. We will also cover one last Java networking class, <TT>ServerSocket</TT>,
that can be used to create sophisticated and robust server processes.
<H2><A NAME="TheClientServerModel"><FONT SIZE=5 COLOR=#FF0000>
The Client/Server Model</FONT></A></H2>
<P>
During the last few years, the term client/server has taken the
computing industry by storm. In companies around the world, technical
management has latched onto client/server as a revolutionary concept
that will propel their businesses into the next century. The truth
is, however, that the client/server model has existed in one form
or another in computer science for several decades. It exists
in the monolithic mainframe systems that have been criticized
for not delivering functionality that they were never designed
to provide-as well as in the applications and operating systems
running on your desktop. Boiled down to its most basic definition,
the term client/server refers to one process (a client) requesting
a service from another process (a server). The client and server
processes could be running within the same address space on the
same system or on separate systems separated by thousands of miles.
<P>
The recent trend has been to distribute computing resources and
responsibility across several platforms, each specializing in
providing a certain service. Although computing systems are better
leveraged and can take advantage of parallel processing in this
model, it does not come without a price. Specifically, the expense
and administrative effort involved in supporting these systems
is immense. System architects and administrators are faced with
several daunting challenges including interoperability, compatibility,
and configuration management.
<H2><A NAME="JavasContribution"><FONT SIZE=5 COLOR=#FF0000>
Java's Contribution</FONT></A></H2>
<P>
Java brings a refreshing option to the table. Because Java is
platform-independent, many of the compatibility issues that have
plagued traditional client applications are solved. Developers
no longer have to maintain and compile separate versions of the
client application, and users are not forced to use a standardized
client configuration. In addition, all or part of Java's executable
components can be distributed. Because Java bytecodes can be centrally
located but still executed in the client's address space, administrators
only have to update the bytecodes in one location instead of deploying
a newly compiled client application to every workstation. Of course,
traditionally compiled client applications can also be loaded
from a server but at the cost of slower load-time and increased
network traffic due to the size of their executable files. Java's
bytecode files (<TT>.class</TT> files) are designed to be safely
transported across a network, especially a wide area network where
bandwidth may be limited. <A HREF="ch20.htm" >Chapter 20</A>, &quot;Keeping Out the Riff-Raff:
JavaSecurity,&quot; discusses the security features of Java in
detail.
<P>
Another advantage of using Java for client/server development
is its capability to be seamlessly integrated with the World Wide
Web. This opens up the opportunity to quickly leverage the multimedia
features of the Web with the dynamic and active nature of Java.
<P>
Finally, there have been some recent initiatives that will allow
Java to become a serious player in significant client/server development
in the future. These developments, as well as plans for the future,
are discussed at the end of this chapter.
<H2><A NAME="ServerSocketClass"><FONT SIZE=5 COLOR=#FF0000>
ServerSocket Class</FONT></A></H2>
<P>
In <A HREF="ch18.htm" >Chapter 18</A>, &quot;Networking with Datagrams and Sockets,&quot;
you learned how to use the <TT>DatagramSocket</TT> class to originate
and accept datagram-based network connections. You also saw how
the <TT>Socket</TT> class can be used to initiate a socket or
streaming connection. However, the <TT>Socket</TT> class cannot
be used to listen for or accept connections originating from another
host. That is the job of the <TT>ServerSocket</TT> class.
<P>
The role of <TT>ServerSocket</TT> is to listen for connection
requests on a specific port from other hosts on the network. Once
a connection is established, the <TT>accept()</TT> method of <TT>ServerSocket</TT>
will create or spin off a <TT>Socket</TT> object to interact with
the remote host. So, <TT>ServerSocket</TT> is a doorman of sorts.
It waits for people to knock on a particular door, opens the door,
and lets them in. As shown in the Internet dictionary example
to follow, this design is the key to developing a robust socket
server. Table 19.1 lists several of the public methods of the
<TT>ServerSocket</TT> class.<BR>
<P>
<CENTER><B>Table 19.1. Public methods of interest from the ServerSocket
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ServerSocket(int)</TT></TD><TD WIDTH=384>Creates a server socket on the specified port. A default backlog of <TT>50</TT> is used.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ServerSocket(int, int)</TT></TD><TD WIDTH=384>Creates a server socket on the specified port with the specified backlog limit.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>InetAddress getInetAddress()</TT></TD><TD WIDTH=384>Returns an <TT>InetAddress</TT> object representing the host to which  this server socket is connected.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>int getLocalPort()</TT></TD><TD WIDTH=384>Returns the port number on the local host for this server socket.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Socket accept()</TT></TD><TD WIDTH=384>Accepts a connection on the local port and returns a Socket object that can be used to communicate over that connection.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>close()</TT></TD><TD WIDTH=384>Closes the server socket.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setSocketFactory,<BR>(SocketImplFactory)</TT>
</TD><TD WIDTH=384>Sets the system's socket factory that will be used to create all sockets.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In order for a <TT>ServerSocket</TT> object to be created, it
must be told what port to monitor. You can bind the server socket
to an anonymous port by specifying a port of <TT>0</TT>. Both
public constructors require the port number as a parameter but
the second constructor will also accept an integer representing
the number of queued connection requests that the server socket
will maintain before denying access. To extend the doorman analogy
used above, this parameter is functionally equivalent to limiting
the number of people that are allowed to stand in line waiting
for the doorman to let them in. Once this backlog limit is reached,
the server socket will cause the client socket to throw an <TT>IOException</TT>
indicating that the connection request was rejected. The default
connection backlog size is 50 requests.
<P>
When designing server programs, one of the primary goals is to
process incoming requests as quickly and efficiently as possible.
The last thing you want to do is force clients to wait in line
or deny their requests because your server is not robust enough.
At the same time, you do not want to limit the functionality of
your server just because you cannot turn requests around fast
enough. The following code fragment illustrates the challenges
just described:
<BLOCKQUOTE>
<PRE>
try
{
    	ServerSocket listen = new ServerSocket(1234);    // Create server socket on
		&aring;port 1234.
    	while (true)
    {
        Socket socket = listen.accept();    // Wait here for the next connect
		&aring;request.
        // Client has connected so get stream objects to communicate with.
        DataInputStream in = new DataInputStream(socket.getInputStream());
        DataOutputStream out = new DataOutputStream(socket.getOutputStream());
        // Do some useful processing... meanwhile other clients are being queued.
    }
}
catch (IOException e)
{
    // Exception handling logic.
}
</PRE>
</BLOCKQUOTE>
<P>
Once the server socket has been created, the logic enters a loop
where it waits for a client to connect so it can service its request.
The <TT>accept()</TT> method will not return until a client connects.
When the server is done working with the client, the loop wraps
around and waits for the next connection. If one or more clients
are waiting in the queue, <TT>accept()</TT> will grab the next
one in line and return a socket to it immediately. So it is clear
that if the tasks that the server must perform for each client
are significant and the server is repeatedly used by several clients,
each client will spend a lot of time waiting for the server to
accept each connection. In addition, if the nature of the connection
to the client is interactive or the duration is controlled by
the client, the server is essentially reduced to serving one client
at a time. By making the server multithreaded, the following example
shows how to design a robust server that solves these problems
and is capable of handling multiple connections quickly and efficiently.
<H2><A NAME="ClientServerExampleInternetDictionary"><FONT SIZE=5 COLOR=#FF0000>
Client/Server Example: Internet Dictionary</FONT></A></H2>
<P>
To illustrate a multithreaded Java server program, we will develop
a simple client/server example that implements an Internet dictionary.
The client can be run as an applet or application, as shown in
Figures 19.1 and 19.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f19-1.gif"><B> Figure 19.1 : </B><I>Internet Dictionary client  as an applet.

</I></A><P>
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f19-2.gif"><B> Figure 19.2 : </B><I>Internet Dictionary client as an application.

</I></A><P>
<P>
The server program is a Java application that must be run on the
same host as the client class files (as specified by the <TT>CODEBASE</TT>
HTML tag) if the client is run as an applet. Because applications
are not bound by the security constraints imposed on applets,
the server can be run on any host if the client is run as an application.
<P>
A portion of the source code for the client is shown in Listing
19.1. The user interface classes created by the Java Resource
Wizard are not shown here, but are included on the accompanying
CD-ROM.
<HR>
<BLOCKQUOTE>
<B>Listing 19.1. EX19A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.net.*;
import java.io.*;
public class EX19A extends Applet
{
    MainWinRes mainWin = null;
    Socket socket = null;
    static final int DICTIONARY_PORT = 2000;
    String host;
    public static void main(String args[])
    {   // Program being run as an application.
        EX19A applet = new EX19A();
        // Setup application frame for main window and start applet.
        Ex19aApplicationFrame frame = new Ex19aApplicationFrame(applet);
        applet.mainWin = frame.resource;
        applet.host = &quot;199.42.65.2&quot;;
        applet.start();
    }
    public void init()
    {   // Program being run as applet.
        mainWin = new MainWinRes(this);
        mainWin.CreateControls();
        mainWin.IDC_TITLE.setFont(new Font(&quot;Helvetica&quot;, Font.BOLD, 18));
        // Use host that applet was served from.
        host = getCodeBase().getHost();
    }
    public void start()
    {   // Initialize screen controls.
        mainWin.IDC_STATUS.setText(&quot;&quot;);
        mainWin.IDC_RESULTS.setEditable(false);
    }
    public void stop()
    {   // Close down socket if it's active.
        if (socket != null)
        {
            try
                socket.close();
            catch (IOException e) {}
        }
    }
    public boolean handleEvent(Event event)
    {
        boolean retval = false;
        if (event.target == mainWin.IDC_LOOKUP)
        {   // Make sure the user has entered something.
            String word = mainWin.IDC_WORD.getText();
            if (word.length() == 0)
                mainWin.IDC_STATUS.setText(&quot;Please enter a word to lookup.&quot;);
            else
                lookupWord(word);
            retval = true;
        }
        return retval;
    }
    // This method does the actual lookup of the word by sending a request
    // across the network to the dictionary server.
    protected void lookupWord(String word)
    {
        mainWin.IDC_RESULTS.setText(&quot;&quot;);
        mainWin.IDC_STATUS.setText(&quot;Performing lookup...&quot;);
        try
        {   // Create socket and setup buffered input/output streams to communicate.
            socket = new Socket(host, DICTIONARY_PORT);
            DataInputStream in = new DataInputStream(new 	
			&aring;BufferedInputStream(socket.getInputStream()));
            PrintStream out = new PrintStream(new 			
			&aring;BufferedOutputStream(socket.getOutputStream()), true);
            mainWin.IDC_STATUS.setText(&quot;Sending word...&quot;);
            out.println(&quot;LOOKUP=&quot; + word);    // Send lookup command to server.
            String line;
            mainWin.IDC_STATUS.setText(&quot;Waiting for response...&quot;);
            line = in.readLine();
            if (line.startsWith(&quot;DEFINITION=&quot;))
            {   // A definition was returned.
                // Strip off &quot;DEFINITION=&quot; response from first line of definition.
                line = line.substring(line.indexOf('=') + 1);
                // Read each line of definition from server.
                do
                    mainWin.IDC_RESULTS.appendText(line + &quot;\n&quot;);
                while ((line = in.readLine()) != null);
                mainWin.IDC_STATUS.setText(&quot;Response received.  Closing
				&aring;connection.&quot;);
            }
            else if (line.startsWith(&quot;ERROR=&quot;))
            {   // An error occurred at the server.
                // Strip off &quot;ERROR=&quot; response from first line of response.
                String error = line.substring(line.indexOf('=') + 1);
                if (error.equalsIgnoreCase(&quot;WordNotFound&quot;))
                    mainWin.IDC_STATUS.setText(&quot;The word '&quot; + word + &quot;' not found.  
					&aring;Try again.&quot;);
                else if (error.equalsIgnoreCase(&quot;DictionaryFileError&quot;))
                    mainWin.IDC_STATUS.setText(&quot;Dictionary not available.  Try again
					&aring;later.&quot;);
                else
                    mainWin.IDC_STATUS.setText(&quot;Error looking up word.&quot;);
            }
            in.close();
            out.close();
            socket.close();
        }
        catch (UnknownHostException e1)
            mainWin.IDC_STATUS.setText(&quot;Unable to resolve dictionary server's name.&quot;);
        catch (IOException e2)
        {
            mainWin.IDC_STATUS.setText(&quot;Error opening connection to dictionary server.
			Server may not be running.&quot;);
            if (socket != null)
            {   // Close down socket.
                try
                    socket.close();
                catch (IOException e) {}
            }
        }
        socket = null;
    }
}
// Frame used to wrap up main window when program is run as an application.
class Ex19aApplicationFrame extends Frame
{
    MainWinRes resource;
    MainMenuRes menu;
    Applet owner;
    public Ex19aApplicationFrame(Applet owner)
    {
        super(&quot;Internet Dictionary Client Application&quot;);
        this.owner = owner;
        // Since it's an application, give it a menu to allow user to exit.
        menu = new MainMenuRes(this);
        menu.CreateMenu();
        setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 8));
        resource = new MainWinRes(this);
        resource.CreateControls();
        resource.IDC_TITLE.setFont(new Font(&quot;Helvetica&quot;, Font.BOLD, 18));
        setResizable(false);    // Do not allow frame to be resized.
        show();
    }
    public boolean handleEvent(Event event)
    {   // Intercept frame messages and pass the others along to the applet.
        if (event.target == menu.ID_FILEEXIT || event.id == Event.WINDOW_DESTROY)
        {
            dispose();
            System.exit(0);
            return true;
        }
        else
            return owner.handleEvent(event);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When the user enters a word to look up and presses the Lookup
Word... button, the <TT>handleEvent()</TT> method receives the
event notification and calls the <TT>lookupWord()</TT> method.
This is where all of the interaction with the server occurs.
<P>
Once the socket to the server has been opened, buffered input
and output streams are created and the lookup request is sent
to the server. The format of the lookup request is <TT>LOOKUP=word
to lookup</TT>. Then the client waits for a response from the
server. The response can take on two forms: <TT>DEFINITION=definition
of word</TT> or <TT>ERROR=type of error</TT>. Because the definition
can be made up of multiple lines, the program keeps reading lines
from the input stream until the entire definition has been received.
Each line is added to the results text area control as it is received.
<P>
On the other side of the connection, the server application shown
in Figure 19.3 is responsible for looking up and returning definitions
to all of the clients.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f19-3.gif"><B> Figure 19.3 : </B><I>Internet Dictionary server application.

</I></A><P>
<P>
The server is composed of two parts. The application itself contains
the main loop that implements a server socket. As connections
are accepted in the <TT>run()</TT> method, a <TT>Lookup</TT> object
is created and is handed the socket that was returned by <TT>ServerSocket.accept()</TT>.
Because the <TT>Lookup</TT> class runs in its own thread, the
server thread is allowed to immediately return to accepting the
next connection. With this design, clients are serviced as fast
as possible regardless of the complexity of the service being
provided by the server.
<P>
The source code for the server is shown in Listing 19.2. Once
again, the user interface classes created by the Java Resource
Wizard are not shown here but are included on the accompanying
CD-ROM.
<HR>
<BLOCKQUOTE>
<B>Listing 19.2. EX19B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.awt.*;
import java.io.*;
import java.net.*;
public class EX19B extends Frame implements Runnable, LookupInterface
{
    static final int DICTIONARY_PORT = 2000;
    // Counts used to track server statistics.
    int currentConnections = 0;
    int totalConnections = 0;
    int wordsFound = 0;
    int wordsNotFound = 0;
    // Interface objects.
    MainMenuRes menu;
    MainWindowRes mainWin;
    // Server's primary thread and socket.
    Thread running = null;
    ServerSocket listen = null;
    public static void main(String args[])
    {
        new EX19B(&quot;Internet Dictionary Server&quot;);
    }
    public EX19B(String caption)
    {
        super(caption);
        // Create main menu built using Resource Wizard.
        menu = new MainMenuRes(this);
        menu.CreateMenu();
        // Setup font to use.
        setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 8));
        mainWin = new MainWindowRes(this);
        mainWin.CreateControls();
        // Initialize main window fields.
        mainWin.IDC_CURRENTCONNECTIONS.setText(&quot;0&quot;);
        mainWin.IDC_TOTALCONNECTIONS.setText(&quot;0&quot;);
        mainWin.IDC_WORDSFOUND.setText(&quot;0&quot;);
        mainWin.IDC_WORDSNOTFOUND.setText(&quot;0&quot;);
        setResizable(false);    // Do not allow frame to be resized.
        show();
        // Start up thread to listen for clients.
        running = new Thread(this);
        running.start();
    }
    public boolean handleEvent(Event event)
    {
        boolean retval = false;
        if (event.target == menu.ID_FILE_EXIT || event.id == Event.WINDOW_DESTROY)
        {   // Kill server thread if running.
            if (running != null)
                running.stop();
            dispose();
            System.exit(0);
            retval = true;
        }
        return retval;
    }
    public void run()
    {
        mainWin.IDC_ACTIVITY.addItem(&quot;Starting server socket...&quot;);
        try
        {   // Create primary thread.
            listen = new ServerSocket(DICTIONARY_PORT);
            while (true)
            {   // Wait for connection requests and spin off Lookup threads
                // to service each request.
                Socket socket = listen.accept();
                new Lookup(this, socket);
            }
        }
        catch (IOException e)
            mainWin.IDC_ACTIVITY.addItem(&quot;Server socket error: &quot; + e);
        // Close down the socket.
        try
            listen.close();
        catch (IOException e) {}
        listen = null;
    }
    // Called by each lookup thread to update server.
    public synchronized void connectionUpdate(String event)
    {
        mainWin.IDC_ACTIVITY.addItem(event);
    }
    // Called by each lookup thread to indicate it has started.
    public synchronized void connectionStart()
    {
        mainWin.IDC_CURRENTCONNECTIONS.setText(String.valueOf(++currentConnections));
        mainWin.IDC_TOTALCONNECTIONS.setText(String.valueOf(++totalConnections));
    }
    // Called by each lookup thread to indicate it has stopped.
    public synchronized void connectionStop()
    {
        mainWin.IDC_CURRENTCONNECTIONS.setText(String.valueOf(--currentConnections));
    }
    // Called by each lookup thread to indicate that the requested word has been found.
    public synchronized void wordFound()
    {
        mainWin.IDC_WORDSFOUND.setText(String.valueOf(++wordsFound));
    }
    // Called by each lookup thread to indicate that the requested word has not been found.
    public synchronized void wordNotFound()
    {
        mainWin.IDC_WORDSNOTFOUND.setText(String.valueOf(++wordsNotFound));
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As shown in Listing 19.3, the <TT>Lookup</TT> class extends the
<TT>Thread</TT> class to gain the capability to run in its own
thread. The constructor simply saves references to the interface
of the object that wants to be notified of lookup activity and
the socket accepted by the server, and then starts the thread.
<HR>
<BLOCKQUOTE>
<B>Listing 19.3. Lookup.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.io.*;
import java.net.*;
public class Lookup extends Thread
{
    static final String DICTIONARY_FILE = &quot;dictionary.dat&quot;;
    // Interface used to udpate server with lookup events.
    LookupInterface lookupUser;
    // Socket accepted from server to communicate with client.
    Socket socket;
    // Input/output streams connected to socket.
    DataInputStream in;
PrintStream out;
public Lookup(LookupInterface lookupUser, Socket socket)
{
    this.lookupUser = lookupUser;
    this.socket = socket;
    start();    // Kick-off thread.
}
public void run()
{
    lookupUser.connectionStart();
    try
    {   // Setup buffered streams to read/write over socket.
        in = new DataInputStream(new 							                 
		&aring;BufferedInputStream(socket.getInputStream()));
        out = new PrintStream(new BufferedOutputStream(socket.getOutputStream()), 		
		&aring;true);
        String request;
        while ((request = in.readLine()) != null)
        {   // Read until a LOOKUP command is received.
            if (request.startsWith(&quot;LOOKUP=&quot;))
            {   // Lookup word and then drop out of thread.
                wordSearch(request.substring(7));
                break;
            }
        }
    }
    catch (IOException e)
        lookupUser.connectionUpdate(&quot;I/O Error on socket: &quot; + e);
    // Close down the socket.
    try
        socket.close();
    catch (IOException e) {}
    lookupUser.connectionStop();
}
protected void wordSearch(String word)
{
    try
    {   // Create a buffered input stream to search dictionary file for word.
        DataInputStream dis = new DataInputStream(new BufferedInputStream(new
		&aring;FileInputStream(DICTIONARY_FILE)));
        String line;
        boolean found = false;
        while (!found &amp;&amp; (line = dis.readLine()) != null)
        {   // Keep reading until word is found or end of file is reached.
            int idx;
            if (line.startsWith(&quot;^&quot;) &amp;&amp;  (idx = line.indexOf('^', 1)) &gt; 0)
            {   // Format is &quot;^Word^Definition...&quot;.  Since definitions can occupy
                // multiple lines in file, &quot;^&quot; indicator is used to start each
				&aring;word
                // and definition sequence.
                String toMatch = line.substring(1, idx);
                if (word.equalsIgnoreCase(toMatch) &amp;&amp; word.length() == 		
				&aring;toMatch.length())
                {   // Build &quot;DEFINITION&quot; response to be sent back to client.
                    line = &quot;DEFINITION=&quot; + line.substring(idx + 1);
                    // Keep reading and sending lines until the end of file is 		
					&aring;reached
                        // or the next word in the file is reached.
                        do
                            out.println(line);
                        while ((line = dis.readLine()) != null &amp;&amp; 	
						&aring;!line.startsWith(&quot;^&quot;));
                        found = true;
                        lookupUser.wordFound();
                    }
                }
            }
            if (!found)
            {   // Send &quot;ERROR&quot; response back to client indicating word was not 	
			&aring;found.
                out.println(&quot;ERROR=WordNotFound&quot;);
                lookupUser.wordNotFound();
            }
        }
        catch (FileNotFoundException fe)
        {   // Update client and server.
            out.println(&quot;ERROR=DictionaryFileError&quot;);
            lookupUser.connectionUpdate(&quot;Dictionary file not found.&quot;);
        }
        catch (IOException e)
        {   // Update client and server.
            out.println(&quot;ERROR=DictionaryFileError&quot;);
            lookupUser.connectionUpdate(&quot;I/O Error reading dictionary file.&quot;);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>run()</TT> method creates buffered input and output streams
from the socket and waits for the <TT>LOOKUP</TT> command to arrive.
This method could easily be enhanced to process lookup requests
for multiple words and probably should employ a timer to drop
the connection after some period of inactivity.
<P>
Once the lookup command is received, the <TT>wordSearch()</TT>
method is called to actually look up the definition for the word.
To keep the example simple, the dictionary is stored in a text
file with just a few words that are sequentially searched by each
<TT>Lookup</TT> object. Of course, if we were searching a real
dictionary, this method would benefit from searching against some
sort of indexed database of words and definitions.
<P>
As shown in Figure 19.3, the server displays statistics covering
server activity. Because the bulk of the activity occurs in the
<TT>Lookup</TT> class, the <TT>LookupInterface</TT> interface
is used to communicate between each of the <TT>Lookup</TT> objects
and the server. Using an interface as opposed to direct calls
to the server de-couples the <TT>Lookup</TT> class from the object
that wants to know about lookup activity. For example, the <TT>LookupInterface</TT>
could have been implemented by a different class that wrote all
activity to a logfile, without modifying the <TT>Lookup</TT> class.
The <TT>LookupInterface</TT> interface is shown in Listing 19.4.
<HR>
<BLOCKQUOTE>
<B>Listing 19.4. LookupInterface.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
// Interface used allow lookup threads to update server of events.
public interface LookupInterface
{
    public void connectionUpdate(String event);
    public void connectionStart();
    public void connectionStop();
    public void wordFound();
    public void wordNotFound();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Although the Internet dictionary example is simple in function,
it illustrates how to design and develop robust server processes
in Java. By taking advantage of Java's multithreading capability,
the server is very fast, flexible, and efficient. However, programming
client/server solutions at the socket level still requires a great
deal of effort. Application-level protocols and states must be
maintained and synchronized between processes, which defeats many
of the advantages of the object-oriented aspects of Java. Fortunately,
recent initiatives in the world of Java will allow Java programmers
to take the next step in client/server development.
<H2><A NAME="TheFutureofJavaClientServerDevelopment"><FONT SIZE=5 COLOR=#FF0000>
The Future of Java Client/Server Development</FONT></A></H2>
<P>
Since its initial release, Java has certainly had a significant
impact on the Internet. Java applets are being deployed on more
and more Web sites every day. The Internet phenomenon has also
reached into private corporate intranets where Web servers and
Java applets are being used not only for disseminating company
information but also to assist in tasks such as administering
and supporting networks and corporate applications. However, in
order for Java to move from being used as a utility to supplement
Web pages to the primary language used to create mission critical
applications, it must garner the support of client/server platform
vendors as well as be supplemented by class libraries and bridging
technologies that have catapulted languages like C++ to the forefront
of client/server development. Although there has never been a
shortage of vendors jumping on the Java bandwagon, the tools and
add-ons to Java are beginning to reach the market and make Java
a player in significant client/server development. In addition,
Sun has created a business unit called JavaSoft that is dedicated
to developing applications, tools, and platforms to enhance Java
as a programming language. A few of these enhancements are discussed
below.
<UL>
<LI>Remote Method Invocation (RMI). Through Java RMI, developers
are able to truly distribute Java objects across a network. Method
calls to objects located on separate systems are handled automatically
and transparently. RMI is similar in concept to remote procedure
calls except in the context of Java objects.
<LI>Java Interface Definition Language (IDL). The Java IDL provides
a bridge between Java objects and the industry standard Object
Management Group's (OMG) Common Object Request Broker Architecture
(CORBA). The CORBA IDL provides a vendor- and language-independent,
distributed computing environment. Java objects are then able
to talk to other Java IDL servers as well as non-Java IDL servers.
<LI>Object Serialization. Through Java's object serialization
API, objects are serialized and can thus be read from or written
to a persistent source. Consider the possibilities of being able
to read and write Java objects across a stream.
<LI>Java Database Connectivity (JDBC). The JDBC API allows Java
objects to access relational databases located on the same system
or a remote server through structure query language (SQL) calls.
<LI>Java Beans. The purpose of the Java Beans initiative is to
develop a component architecture that is compatible with and portable
to other component models. Interoperability with component models
such as OpenDoc, ActiveX, and LiveConnect will be achieved by
implementing bridging technology. As you will see in <A HREF="ch21.htm" >Chapter 21</A>,
&quot;Using ActiveX Controls with Java,&quot; Microsoft has provided
a bridge of its own to interact with ActiveX controls.
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although the 1.0 release of Visual J++ does not support these initiatives out of the box, Microsoft has stated that it is committed to keeping Visual J++ current with the Java Developers Kit. Forthcoming compatibility with JDK 1.1 will then enable you to 
take advantage of these features. They are covered here to give you an idea of where Java client/server development is headed and hopefully to provide a preview of a subsequent release of Visual J++.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
One of Java's strengths is its capability to network. Combined
with the fact that Java programs can be run on several platforms
without source code modifications, it is no wonder that Java is
rapidly becoming a popular choice for client/server development.
The flexibility of Java is continuing to be enhanced. Whether
you need to delve into socket-based programming or step up to
interacting with distributed objects, Java provides the necessary
solutions.
<HR>

<CENTER><P><A HREF="ch18.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch20.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>