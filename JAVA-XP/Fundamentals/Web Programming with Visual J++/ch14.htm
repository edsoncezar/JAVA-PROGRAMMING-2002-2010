<HTML>
<HEAD>
<TITLE>Chapter 14 -- Incorporating Graphics</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;14</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Incorporating Graphics</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#DrawingFilledandOutlinedShapes">
Drawing Filled and Outlined Shapes</A>
<UL>
<LI><A HREF="#Lines">
Lines</A>
<LI><A HREF="#Rectangles">
Rectangles</A>
<LI><A HREF="#Arcs">
Arcs</A>
<LI><A HREF="#Ovals">
Ovals</A>
<LI><A HREF="#Polygons">
Polygons</A>
</UL>
<LI><A HREF="#Images">
Images</A>
<UL>
<LI><A HREF="#FilteringImages">
Filtering Images</A>
<LI><A HREF="#WritingYourOwnImageFilter">
Writing Your Own Image Filter</A>
<LI><A HREF="#TheImageObserverInterface">
The ImageObserver Interface</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In this chapter you will learn how to augment the appearance of
your Java program by using graphics. Java provides a complete
set of classes for drawing lines and geometric shapes such as
arcs, ovals, rectangles, and polygons. You will also learn how
to display and manipulate images. You will learn about Java's
classes for filtering, cropping, and modifying images. You will
also learn about the ImageObserver interface that allows an applet
to monitor the progress of an image that is being retrieved for
display.
<H2><A NAME="DrawingFilledandOutlinedShapes"><FONT SIZE=5 COLOR=#FF0000>
Drawing Filled and Outlined Shapes</FONT></A></H2>
<P>
In this section you will learn about the <TT>Graphics</TT> class
that is included in the <TT>java.awt</TT> package. You've already
seen the <TT>Graphics</TT> class used in many of the examples
in this book. For example, in <A HREF="ch2.htm" >Chapter 2</A> &quot;Creating Your First
Applet with Applet Wizard,&quot; the following code was used to
display &quot;Hello, World&quot; on the screen:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
    g.drawString(&quot;Hello, World&quot;, 10, 10);
}
</PRE>
</BLOCKQUOTE>
<P>
As you would expect of a class named <TT>Graphics</TT>, it can
be used to do much more than draw strings. The <TT>Graphics</TT>
class can be used to draw a variety of shapes. Figure 14.1 illustrates
a very simple screen that was created with member methods of the
<TT>Graphics</TT> class.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-1.gif"><B> Figure 14.1 : </B><I>A very simple example of drawing filled and outlined shapes.
</I></A><P>
<P>
The <TT>Graphics</TT> class includes methods for drawing both
filled and outlined shapes. An outlined shape is just the outline
of the shape; a filled shape is the outline plus the area bounded
by the outline. The bounded area is filled by painting it with
the current color.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The use of color is discussed in <A HREF="ch16.htm" >Chapter 16</A>, &quot;Sprucing Things Up with Colors and Fonts.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
A variety of shapes can be drawn using the <TT>Graphics</TT> class,
as shown in Table 14.1. As you can see from this table, all shapes
except a line can be drawn both filled and outlined. Because a
line always has a width of one, there is no need to draw filled
lines.<BR>
<P>
<CENTER><B>Table 14.1. Shapes that can be drawn by the Graphics
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=157><I>Shape</I></TD><TD WIDTH=113><CENTER><I>Filled</I></CENTER>
</TD><TD WIDTH=113><CENTER><I>Outlined</I></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Arc</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD>
<TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Line</TD><TD WIDTH=113><CENTER>No</CENTER></TD>
<TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Oval</TD><TD WIDTH=113><CENTER>Yes</CENTER>
</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Polygon</TD><TD WIDTH=113><CENTER>Yes</CENTER>
</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Rectangle</TD><TD WIDTH=113><CENTER>Yes</CENTER>
</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>Round Rectangle</TD><TD WIDTH=113><CENTER>Yes</CENTER>
</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=157>3-D Rectangle</TD><TD WIDTH=113><CENTER>Yes</CENTER>
</TD><TD WIDTH=113><CENTER>Yes</CENTER></TD></TR>
</TABLE>
</CENTER>
<P>
<P>
When you use any of these methods to draw a shape, you pass it
the coordinates at which the shape is to be drawn. As far as the
<TT>Graphics</TT> class is concerned, coordinate numbering starts
at 0,0 in the top left and increases down and to the right. This
can be seen in Figure 14.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-2.gif"><B> Figure 14.2 : </B><I>The Graphics coordinate system places 0,0 in the top left and increases down and to the right.
</I></A><P>
<H3><A NAME="Lines">
Lines</A></H3>
<P>
One of the simplest shapes to draw is a line. A line can be drawn
using the <TT>drawLine</TT> member of the <TT>Graphics</TT> class.
The signature of <TT>drawLine</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public abstract void drawLine(int x1, int y1, int x2, int y2);
</PRE>
</BLOCKQUOTE>
<P>
This method will draw a line between the points given by (x1,
y1) and (x2, y2). As an example, imagine you have been asked to
display the image shown in Figure 14.3. This drawing can be created
with the code shown in Listing 14.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-3.gif"><B> Figure 14.3 : </B><I>A simple figure created with drawLine.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.1. EX14A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX14A extends Applet
{
    public void init()
    {
        resize(320, 240);
    }

    public void paint(Graphics g)
    {
        // draw the three horizontal lines
        g.drawLine(20,  20, 220,  20);
        g.drawLine(20,  70, 220,  70);
        g.drawLine(20, 120, 220, 120);

        // draw the vertical lines at each end
        g.drawLine(20,  20,  20, 120);
        g.drawLine(220, 20, 220, 120);

        // draw the vertical line in the top half
        g.drawLine(120, 20, 120, 70);

        // draw two vertical lines in the bottom half
        g.drawLine( 86, 70,  86, 120);
        g.drawLine(154, 70, 154, 120);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Figure 14.3 was first presented to me in the form of a puzzle: Starting from a point inside or outside the figure, draw a single line that crosses each and every line segment of the figure exactly once. On a day when I must have been a particularly 
annoying seven-year-old, my dad drew this puzzle for me and offered me $20 if I could solve it. I couldn't, even though I occasionally returned to it for nearly 15 more years. It wasn't until college when I learned about Euler and the Bridges of 
K&#154;nigsberg that I discovered the puzzle was unsolvable. However, it did solve my dad's problem of keeping a seven-year-old quiet in the back of a car</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Rectangles">
Rectangles</A></H3>
<P>
There are more methods for drawing rectangles than I have fingers
on one hand. There are six. Fortunately, I could count them all
on two hands and didn't need to use my toes or this book would
have had an unpleasant odor. Of the six methods for drawing rectangles,
three draw filled rectangles and three draw outlined rectangles.
Methods whose names begin with <TT>draw</TT> are used to create
outlined rectangles; methods whose names begin with <TT>fill</TT>
are used to create filled rectangles. The following methods are
available:
<BLOCKQUOTE>
<PRE>
public void drawRect(int x, int y, int width, int height);
public abstract void fillRect(int x, int y, int width, int height);
public void draw3DRect(int x, int y, int width, int height,
        boolean raised);
public void fill3DRect(int x, int y, int width, int height, 
        boolean raised);
public abstract void drawRoundRect(int x, int y, int width, 
        int height, int arcWidth, int arcHeight);
public abstract void fillRoundRect(int x, int y, int width,
        int height, int arcWidth, int arcHeight);
</PRE>
</BLOCKQUOTE>
<P>
A simple rectangle, as drawn by <TT>drawRect</TT> and <TT>fillRect</TT>,
requires only parameters for the starting x and y coordinates
and the width and height of the rectangle. A three-dimensional
rectangle can be painted with <TT>draw3DRect</TT> or <TT>fill3DRect</TT>
by specifying an additional parameter that indicates whether the
rectangle should appear raised or lowered. The three-dimensional
effect is achieved by brightening or darkening the color of the
rectangle when it is drawn. Because of this, you must use <TT>setColor</TT>
prior to painting the rectangle or the three-dimensional effect
will not be apparent.
<P>
Finally, a rectangle with rounded corners can be painted with
<TT>drawRoundRect</TT> or <TT>fillRoundRect</TT>. These methods
require two additional parameters that specify the width and height
of the arc that is used to draw the corners. Larger values for
these parameters will create more rounded corners.
<P>
As an example of how these methods may be used, consider the code
in Listing 14.2. This code will create the screen shown in Figure
14.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-4.gif"><B> Figure 14.4 : </B><I>Examples of the various rectangle methods.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.2. EX14B.java illustrates how to draw rectangles.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX14B extends Applet
{
    public void paint(Graphics g)
    {
        // draw an outlined rectangle
        g.drawRect(10, 10, 200, 200);
        g.drawString(&quot;drawRect&quot;, 10, 225);

        // draw a filled rectangle
        g.fillRect(15, 15, 30, 60);
        g.drawString(&quot;fillRect&quot;, 15, 90);

        // set a color so that the 3D rectangles
        // are displayed as raised or indented
        g.setColor(Color.cyan);

        // draw an outlined 3D rectangle
        g.draw3DRect(60, 15, 40, 10, false);
        g.drawString(&quot;draw3DRect&quot;, 60, 40);

        // draw a filled 3D rectangle
        g.fill3DRect(140, 15, 30, 20, true);
        g.drawString(&quot;fill3DRect&quot;, 140, 50);

        // draw an outlined round rectangle
        g.drawRoundRect(20, 110, 40, 60, 20, 40);
        g.drawString(&quot;drawRoundRect&quot;, 20, 185);

        // draw a filled round rectangle
        g.fillRoundRect(120, 110, 60, 60, 20, 20);
        g.drawString(&quot;fillRoundRect&quot;, 120, 185);
    }

    public void init()
    {
        resize(320, 240);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Arcs">
Arcs</A></H3>
<P>
You've already used arcs to create the rounded corners of a rectangle
drawn with <TT>drawRoundRect</TT> or <TT>fillRoundRect</TT>. You
can also create an arc on its own. Arcs are created with the <TT>drawArc</TT>
or <TT>fillArc</TT> methods whose signatures are the following:
<BLOCKQUOTE>
<PRE>
public abstract void drawArc(int x, int y, int width, int height, 
        int startAngle, int arcAngle);
public abstract void fillArc(int x, int y, int width, int height,
        int startAngle, int arcAngle);
</PRE>
</BLOCKQUOTE>
<P>
As with the rectangle methods, the method whose name begins with
<TT>draw</TT> will paint an outlined shape, and the method whose
name begins with <TT>fill</TT> will paint a filled shape. To paint
an arc you specify the position and size of an imaginary rectangle
that bounds the arc. You also specify the starting angle of the
arc and the number of degrees in the arc. This can be seen in
Figure 14.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-5.gif"><B> Figure 14.5 : </B><I>An arc is specified by describing an imaginary rectangle surrounding it.
</I></A><P>
<P>
Figure 14.5 shows an arc and also uses <TT>drawRectangle</TT>
to explicitly paint the invisible rectangle that surrounds the
arc. The rectangle and arc of this example were created with the
following two statements:
<BLOCKQUOTE>
<PRE>
g.drawArc(60, 30, 100, 200, 45, 180);
g.drawRect(60, 30, 100, 200);
</PRE>
</BLOCKQUOTE>
<P>
The first four parameters to <TT>drawArc</TT> indicate a rectangle
that starts at (60, 30) is 100 pixels wide, and 200 pixels high.
These same four values are passed to <TT>drawRect</TT> to explicitly
draw the rectangle. The final two parameters to <TT>drawArc</TT>
indicate that the arc should begin at 45 degrees and end 180 degrees
later (at 225 degrees). As you can see in Figure 14.5, the 0 degree
position is at three o'clock. Because the final parameter is a
positive number, the arc will be drawn in a counter-clockwise
direction. A negative number causes the arc to be drawn in a clockwise
direction. This can be seen in Figure 14.6, which shows the same
arc when drawn in the opposite direction with the following code:
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-6.gif"><B> Figure 14.6 : </B><I>The same arc when drawn in a clockwise direction.
</I></A><P>
<BLOCKQUOTE>
<PRE>
g.drawArc(60, 30, 100, 200, 45, -180);
</PRE>
</BLOCKQUOTE>
<P>
Class <TT>EX14C</TT>, shown in Listing 14.3, demonstrates how
to use <TT>drawArc</TT> and <TT>fillArc</TT>. Three rows of arcs
are painted, as can be seen in Figure 14.7. The first row shows
four arcs drawn with counterclockwise angles. The second row shows
the same four arcs drawn in a clockwise direction. The final row
shows two filled arcs with starting angles other than 0.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-7.gif"><B> Figure 14.7 : </B><I>Sample arcs painted with drawArc and fillArc.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.3. EX14C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX14C extends Applet
{
    public void init()
    {
        resize(320, 240);
    }

    public void paint(Graphics g)
    {
        // draw arcs with counterclockwise angles
        g.drawArc(10, 60, 20, 50, 0, 90);
        g.drawArc(60, 60, 20, 50, 0, 180);
        g.drawArc(110, 60, 20, 50, 0, 270);
        g.drawArc(160, 60, 20, 50, 0, 360);

        // draw arcs with clockwise angles
        g.drawArc(10, 120, 20, 50, 0, -90);
        g.drawArc(60, 120, 20, 50, 0, -180);
        g.drawArc(110, 120, 20, 50, 0, -270);
        g.drawArc(160, 120, 20, 50, 0, -360);

        // draw filled arcs that don't start at 0
        g.fillArc(10, 180, 20, 50, 45, 180);
        g.fillArc(60, 180, 20, 50, 0, 135);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Ovals">
Ovals</A></H3>
<P>
Drawing an oval is very similar to drawing a regular rectangle.
An oval can be painted using either of the following methods:
<BLOCKQUOTE>
<PRE>
public abstract void drawOval(int x, int y,int width,int height);
public abstract void fillOval(int x, int y,int width,int height);
</PRE>
</BLOCKQUOTE>
<P>
As is consistent with the other member methods of <TT>Graphics</TT>,
<TT>drawOval</TT> paints an outlined oval and <TT>fillOval</TT>
paints a filled oval. As with arcs, the parameters passed to these
methods describe an imaginary rectangle surrounding the oval.
As an example of painting ovals, consider class <TT>EX14D</TT>,
shown in Listing 14.4. This class paints a large outlined oval
and then paints a smaller filled oval inside the larger oval.
The results of executing this class can be seen in Figure 14.8.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-8.gif"><B> Figure 14.8 : </B><I>Sample ovals painted with drawOval and fillOval.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.4. EX14D.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX14D extends Applet
{
    public void init()
    {
        resize(520, 400);
    }

    public void paint(Graphics g)
    {
        // draw an outlined oval
        g.drawOval(10, 10, 225, 300);
        g.drawString(&quot;drawOval&quot;, 102, 323);

        // draw a filled oval within the outlined oval
        g.fillOval(73, 120, 100, 100);
        g.drawString(&quot;fillOval&quot;, 105, 233);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Polygons">
Polygons</A></H3>
<P>
If what you really want to draw is a non-standard shape that can't
be painted with one of the methods described so far, you may be
able to use the polygon drawing methods. As usual, methods are
provided for painting outlined and filled shapes. The following
four methods can be used to paint polygons:
<BLOCKQUOTE>
<PRE>
public abstract void fillPolygon(int xPoints[], int yPoints[],
        int nPoints);
public abstract void drawPolygon(int xPoints[], int yPoints[],
        int nPoints);
public void fillPolygon(Polygon p);
public void drawPolygon(Polygon p);
</PRE>
</BLOCKQUOTE>
<P>
The first two of these methods are each passed two arrays that
represent the x and y positions of the points on the polygon and
an integer. As an example of how this works, consider the following:
<BLOCKQUOTE>
<PRE>
int xPoints[] = new int[4];
int yPoints[] = new int[4];

xPoints[0] = 150;
xPoints[1] = 150;
xPoints[2] = 250;
xPoints[3] = 150;

yPoints[0] = 150;
yPoints[1] = 250;
yPoints[2] = 250;
yPoints[3] = 150;

g.fillPolygon(xPoints, yPoints, 4);
</PRE>
</BLOCKQUOTE>
<P>
In this case two arrays are allocated to hold four items each.
The corners of the polygon are given by the matched pairs of the
arrays. For example, (<TT>xPoints[0], yPoints[0]</TT>) and (<TT>xPoints[1],
yPoints[1]</TT>) identify the first two of four corners on the
polygon.
<P>
The other two methods for drawing polygons are passed a polygon
as their lone parameter. These methods are more convenient if
you already have a <TT>Polygon</TT> object. The following code
is equivalent to the prior example but passes a <TT>Polygon</TT>
to <TT>fillPolygon</TT> instead of passing the arrays:
<BLOCKQUOTE>
<PRE>
int xPoints[] = new int[4];
int yPoints[] = new int[4];

xPoints[0] = 150;
xPoints[1] = 150;
xPoints[2] = 250;
xPoints[3] = 150;

yPoints[0] = 150;
yPoints[1] = 250;
yPoints[2] = 250;
yPoints[3] = 150;

Polygon p = new Polygon(xPoints, yPoints, 4);
g.fillPolygon(p);
</PRE>
</BLOCKQUOTE>
<P>
As a further example of how the <TT>fillPolygon</TT> and <TT>drawPolygon</TT>
methods may be used, consider example <TT>EX14E</TT>, which is
shown in Listing 14.5. This example draws three shapes, a four-sided
polygon, and two triangles, as shown in Figure 14.9.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-9.gif"><B> Figure 14.9 : </B><I>Sample polygons painted with drawPolygon and fillPolygon.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.5. EX14E.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX14E extends Applet
{
    public void init()
    {
        resize(520, 400);
    }

    public void paint(Graphics g)
    {
        drawFirstPolygon(g);
        drawSecondPolygon(g);
        drawThirdPolygon(g);
    }

    private void drawFirstPolygon(Graphics g)
    {
        int xPoints[] = new int[5];
        int yPoints[] = new int[5];

        xPoints[0] = 60;
        xPoints[1] = 100;
        xPoints[2] = 150;
        xPoints[3] = 110;
        xPoints[4] = 60;

        yPoints[0] = 10;
        yPoints[1] = 70;
        yPoints[2] = 30;
        yPoints[3] = 170;
        yPoints[4] = 10;

        g.drawPolygon(xPoints, yPoints, 5);
    }

    private void drawSecondPolygon(Graphics g)
    {
        int xPoints[] = new int[4];
        int yPoints[] = new int[4];

        xPoints[0] = 150;
        xPoints[1] = 150;
        xPoints[2] = 250;
        xPoints[3] = 150;

        yPoints[0] = 150;
        yPoints[1] = 250;
        yPoints[2] = 250;
        yPoints[3] = 150;

        g.fillPolygon(xPoints, yPoints, 4);
    }

    private void drawThirdPolygon(Graphics g)
    {
        int xPoints[] = new int[4];
        int yPoints[] = new int[4];

        xPoints[0] = 250;
        xPoints[1] = 300;
        xPoints[2] = 200;
        xPoints[3] = 250;

        yPoints[0] = 300;
        yPoints[1] = 350;
        yPoints[2] = 350;
        yPoints[3] = 300;

        Polygon p = new Polygon(xPoints, yPoints, 4);

        g.drawPolygon(p);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Images"><FONT SIZE=5 COLOR=#FF0000>
Images</FONT></A></H2>
<P>
In addition to geometric shapes and lines, you can also display
graphics images, such as JPG or GIF files. To do this you use
any of the four provided <TT>drawImage</TT> methods whose signatures
are as follows:
<BLOCKQUOTE>
<PRE>
public abstract boolean drawImage(Image img, int x, int y,
     ImageObserver observer);
public abstract boolean drawImage(Image img, int x, int y, 
     int width, int height, ImageObserver observer);
public abstract boolean drawImage(Image img, int x, int y,
     Color bgcolor, ImageObserver observer);
public abstract boolean drawImage(Image img, int x, int y,
     int width, int height,Color bgcolor,ImageObserver observer);
</PRE>
</BLOCKQUOTE>
<P>
The first of these methods is passed the image itself, the coordinates
of its top-left corner, and an ImageObserver. ImageObserver is
an interface that is implemented by the <TT>Component</TT> class.
Because <TT>Applet</TT> is a subclass of <TT>Component</TT> you
can use any class you derive from <TT>Applet</TT> as an ImageObserver.
ImageObservers are useful because they can be sent information
about the image as it is being loaded. Because <TT>Applet</TT>
implements the ImageObserver interface, you can pass <TT>this</TT>
as the ImageObserver parameter. This can be seen in the following
code fragment:
<BLOCKQUOTE>
<PRE>
public class MyClass extends Applet
{
    // ...other methods here
    public void paint(Graphics g)
    {
        g.drawImage(myImage, 100, 100, this);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
The second <TT>drawImage</TT> method is passed parameters for
width and height. This causes the image to be scaled so that it
appears in the specified rectangle. The final two <TT>drawImage</TT>
methods are the same as the first two with the addition of being
able to specify a background color for the image.
<P>
However, before you can use <TT>drawImage</TT> you must have an
<TT>Image</TT> object to draw. As you already learned in Chapter
4, &quot;Applet Programming Fundamentals,&quot; this can be done
with the <TT>getImage</TT> method of the <TT>Applet</TT> class.
Typically, this is done in the <TT>init</TT> method of the applet,
as follows:
<BLOCKQUOTE>
<PRE>
public class MyClass extends Applet
{
    Image myImage;

    // ...other methods here

    public void init()
    {
        myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
As an example of displaying images, consider <TT>EX14F</TT>, as
shown in Listing 14.6. Note that since the <TT>Image</TT> class
is in <TT>java.awt.image</TT>, this package must be imported.
In the <TT>init</TT> method of <TT>EX14F</TT>, <TT>getImage</TT>
is used to create the <TT>Image</TT> object, <TT>myImage</TT>.
In the <TT>paint</TT> method this image is displayed twice. The
first use of <TT>drawImage</TT> specifies a square from point
(0, 0) to point (150, 150). The image will be resized and displayed
in this area. This can be seen in Figure 14.10. The second use
of <TT>drawImage</TT> specifies only the coordinates of the top
left of the image.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-10.gif"><B> Figure 14.10 : </B><I>The same image displayed with two different drawImage methods.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.6. EX14F.java displays a simple image.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class EX14F extends Applet
{
    private Image myImage;

    public void init()
    {
        resize(620, 470);

        // create the image
        myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);
    }

    public void paint(Graphics g)
    {
        // paint the image in the specified rectangle
        g.drawImage(myImage, 0, 0, 150, 150, this);

        // paint the image on the screen
        g.drawImage(myImage, 160, 0, this);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="FilteringImages">
Filtering Images</A></H3>
<P>
It is also possible to create and use filters on images before
they are displayed. The class <TT>CropImageFilter</TT> is provided
in the <TT>java.awt.image</TT> package and is a useful filter
that enables you to display only a portion of the image. Class
<TT>EX14G</TT>, shown in Listing 14.7, illustrates how to use
<TT>CropImageFilter</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 14.7. EX14G.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class EX14G extends Applet
{
    private Image myImage;
    private Image croppedImage;

    public void init()
    {
        resize(630, 470);

        myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);

        // create a filter that will crop the image to the
        // area starting at point (195, 0) with a width of 140
        // and a height of 150
        CropImageFilter myCropFilter = new CropImageFilter(195,0,
                140, 150);

        // create a new image source based on the original image
        // and using the newly created filter
        FilteredImageSource imageSource = new 
                FilteredImageSource(myImage.getSource(), 
                myCropFilter);

        // create the cropped image
        croppedImage = createImage(imageSource);
    }

    public void paint(Graphics g)
    {
        // paint the cropped image
        g.drawImage(croppedImage, 0, 0, this);

        // paint the original image to the right of the cropped one
        g.drawImage(myImage, 160, 0, this);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
After using <TT>getImage</TT> to create the <TT>Image</TT> object,
the <TT>init</TT> method of <TT>EX14G</TT> constructs a new <TT>CropImageFilter</TT>
object named <TT>myCropFilter</TT>. This constructor is passed
the x and y coordinates, and the width and height of where to
start cropping the image. In this case, a rectangle 140 pixels
wide and 150 high will be cropped beginning at point (195, 0).
Next, the constructor for <TT>FilteredImageSource</TT> is used
to create a new image source. The image source is based on the
original image and <TT>myCropFilter</TT>. Finally, <TT>createImage</TT>
is used to return the actual <TT>Image</TT> object.
<P>
This work is put to use in the <TT>paint</TT> method. This method
uses <TT>drawImage</TT> first to display the cropped image and
then to display the original image for comparison. The results
can be seen in Figure 14.11.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-11.gif"><B> Figure 14.11 : </B><I>The CropImageFilter can be used to crop images.
</I></A><P>
<H3><A NAME="WritingYourOwnImageFilter">
Writing Your Own Image Filter</A></H3>
<P>
It is also possible to create your own filter. To do so you create
a subclass of either <TT>ImageFilter</TT> or <TT>RGBImageFilter</TT>
and override methods to provide the filtering you want. The <TT>RGBImageFilter</TT>
class is a subclass of <TT>ImageFilter</TT> and makes it very
easy to write a filter that manipulates the colors of the individual
pixels in an image.
<P>
As an example of how you can create your own filter based on <TT>RGBImageFilter</TT>,
imagine you needed to write a filter that will remove part of
an image. This could be very useful in a litigation support system
for processing documents. In this type of system it is important
to be able to redact, or black out, text. Or, as you'll see in
this example, a redaction filter is useful for hiding the eyes
of a Mafia informant.
<P>
Listing 14.8 shows <TT>EX14H</TT>. This example illustrates the
use of a redaction filter, as shown in Figure 14.12. The class
<TT>RedactFilter</TT> is defined as a subclass of <TT>RGBImageFilter</TT>.
Its constructor is passed values that indicate the area to be
redacted.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f14-12.gif"><B> Figure 14.12 : </B><I>The RedactFilter can be used to conceal the identity of a Mafia informant.
</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 14.8. EX14H.java illustrates the creation of a custom
filter.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

class RedactFilter extends RGBImageFilter
{
    int startX, startY, endX, endY;

    // the constructor is passed the coordinates of the area
    // to redact and stores these values
    public RedactFilter(int x, int y, int width, int height) 
    {
        startX = x;
        startY = y;
        endX   = startX + width;
        endY   = startY + height;
    }

    public int filterRGB(int x, int y, int rgb)
    {
        // if the (x,y) position is in the redacted area
        // return red, otherwise return the same color that
        // was passed in
        if (x &gt;= startX &amp;&amp; x &lt;= endX &amp;&amp; y &gt;= startY &amp;&amp; y &lt;= endY)
            return 0xff0000ff;
        else
            return rgb;
    }
}

public class EX14H extends Applet
{
    private Image myImage;
    private Image redactedImage;

    public void init()
    {
        resize(570, 470);

        // get the original image
        myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);

        // create a filter and specify the range to be redacted
        ImageFilter filter = new RedactFilter(220, 80, 80, 15);

        // create a new image source based on the original
        // image and the new filter
        FilteredImageSource imageSource=new FilteredImageSource(
                myImage.getSource(), filter);

        // create the redacted image from the image source
        redactedImage = createImage(imageSource);
    }

    public void paint(Graphics g)
    {
        // paint the redacted image
        g.drawImage(redactedImage, 0, 0, this);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The method <TT>filterRGB</TT> is an overridden member of <TT>RGBImageFilter</TT>.
This method is called once for each pixel in the image. Its <TT>x</TT>
and <TT>y</TT> parameters indicate the location of the pixel being
passed. Its <TT>rgb</TT> parameter indicates the current color
of the pixel. The value returned by <TT>filterRGB</TT> is the
color that will be displayed for this pixel. To alter the image,
return something different from the current value in <TT>rgb</TT>.
In this case, <TT>RedactFilter</TT> checks to see whether the
pixel is within the specified area. If so, red is returned. If
not, the unchanged <TT>rgb</TT> value is returned.
<P>
The <TT>RedactFilter</TT> is used very similarly to how <TT>CropImageFilter</TT>
was used in the prior example. In the <TT>init</TT> method of
<TT>EX14H</TT>, <TT>getImage</TT> is used to create the image.
Next, a new instance of <TT>RedactFilter</TT> is constructed and
a new image source is created based on the original image and
the filter. Finally, <TT>createImage</TT> is used to create the
redacted image from the image source. The <TT>paint</TT> method
uses <TT>drawImage</TT> as it would with any other image.
<H3><A NAME="TheImageObserverInterface">
The ImageObserver Interface</A></H3>
<P>
As you might recall, when the <TT>drawImage</TT> method was first
introduced you needed to pass <TT>this</TT> as the final parameter
to it, as in the following example:
<BLOCKQUOTE>
<PRE>
g.drawImage(redactedImage, 0, 0, this);
</PRE>
</BLOCKQUOTE>
<P>
This parameter represents an ImageObserver and since the <TT>Applet</TT>
class implements the ImageObserver interface through the <TT>Component</TT>
class, you can use the <TT>Applet</TT> <TT>this</TT> variable.
So far you've been asked to take this parameter on faith. Now
it's time to see what an ImageObserver can do.
<P>
The ImageObserver interface includes a single method. This method,
<TT>imageUpdate</TT>, is called whenever additional information
about an image becomes available. For example, it might take time
to retrieve a large image across the Internet. The ImageObserver
interface can monitor the progress of an image retrieval. An applet
could then possibly display a progress message, an estimated time
to complete, or take any other useful action. The signature of
<TT>imageUpdate</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public abstract boolean imageUpdate(Image img, int infoflags, 
        int x, int y, int width, int height);
</PRE>
</BLOCKQUOTE>
<P>
The first parameter represents the image being updated. The second
parameter represents a combination of various flags that give
information about the image. These flags are described in Table
14.2. The remaining parameters usually represent a rectangle indicating
the portion of the image that has been retrieved so far. Depending
on the values in the <TT>infoflags</TT> parameter, some of these
parameters might be invalid. The <TT>imageUpdate</TT> method should
return <TT>true</TT> if you want to continue receiving updates,
or <TT>false</TT> otherwise.
<P>
<CENTER><B>Table 14.2. Flags used in the imageUpdate method.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=144><I>Flag</I></TD><TD WIDTH=432><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ABORT</TT></TD><TD WIDTH=432>Retrieval of the image was aborted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ALLBITS</TT></TD><TD WIDTH=432>All bits of the image have been retrieved.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>ERROR</TT></TD><TD WIDTH=432>An error occurred while retrieving the image.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>FRAMEBITS</TT></TD><TD WIDTH=432>A frame that is part of a multi-frame image has been completely retrieved.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>HEIGHT</TT></TD><TD WIDTH=432>The <TT>height</TT> parameter now represents the final height of the image.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>PROPERTIES</TT></TD><TD WIDTH=432>The properties of the image have been retrieved.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>SOMEBITS</TT></TD><TD WIDTH=432>More bits have been retrieved.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>WIDTH</TT></TD><TD WIDTH=432>The <TT>width</TT> parameter now represents the final width of the image.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of how <TT>imageUpdate</TT> can be used, consider
<TT>EX14I</TT>, as shown in Listing 14.9. In this example, a text
area is created that will be used to display status messages.
The <TT>imageUpdate</TT> method compares the value in the <TT>infoflags</TT>
parameter against <TT>ImageObserver.ERROR</TT> and <TT>ImageObserver.ALLBITS</TT>.
When one of these flags is set, a message is appended to the text
area.
<HR>
<BLOCKQUOTE>
<B>Listing 14.9. EX14I.java illustrates the use of the ImageObserver
interface.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class EX14I extends Applet
{
    private Image myImage;
    TextArea status;

    public void init()
    {
        resize(520, 470);

        // create the image
        myImage = getImage(getDocumentBase(), &quot;savannah.jpg&quot;);

        // create a text area for displaying status information
        status = new TextArea(5, 20);
        add(status);
    }

    public void paint(Graphics g)
    {
        // paint the image in the specified rectangle
        g.drawImage(myImage, 0, 110, 350, 350, this);
    }


    public synchronized boolean imageUpdate(Image img, 
            int infoflags, int x, int y, int width, int height)
    {
        // if an error occurs, display the message
        if ((infoflags &amp; ImageObserver.ERROR) != 0)
            status.appendText(&quot;Error\r\n&quot;);

        // once all the bits have been received display 
        // a message and repaint the applet
        if ((infoflags &amp; ImageObserver.ALLBITS) != 0)
        {
            status.appendText(&quot;Allbits\r\n&quot;);
            repaint();
        }
        return true;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter gave you an in-depth look at the <TT>Graphics</TT>
class and how you can use the methods of this class to enhance
the appearance of your Java programs. In this chapter you learned
how to draw outlined and filled shapes such as lines, arcs, ovals,
rectangles, and polygons. You also learned about the <TT>Image</TT>
class. You learned how to filter, crop, and modify images prior
to display. Finally, you also saw how the ImageObserver interface
allows an <TT>Applet</TT> to monitor the progress of an image
that is being retrieved. In the next chapter you will learn how
to further improve your Java programs by using animation and sound.
<HR>

<CENTER><P><A HREF="ch13.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch15.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
