<HTML>
<HEAD>
<TITLE>Chapter 6 -- Working with Frames, Dialogs, and Menus</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;6</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Working with Frames, Dialogs, and
Menus</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#Containers">
Containers</A>
<UL>
<LI><A HREF="#ThePanelClass">
The Panel Class</A>
<LI><A HREF="#TheWindowClass">
The Window Class</A>
<LI><A HREF="#Frames">
Frames</A>
<LI><A HREF="#Dialogs">
Dialogs</A>
<LI><A HREF="#FileDialog">
FileDialog</A>
</UL>
<LI><A HREF="#Menus">
Menus </A>
<UL>
<LI><A HREF="#TheMenuBarClass">
The MenuBar Class</A>
<LI><A HREF="#TheMenuClass">
The Menu Class</A>
<LI><A HREF="#TheMenuItemClass">
The MenuItem Class</A>
<LI><A HREF="#AnExampleofAddingaMenutoaFrame">
An Example of Adding a Menu to a Frame</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In the prior chapter you learned all about the individual components
that make up a Java applet's user interface. In this chapter you
see how to effectively combine these components and place them
on panels, frames, and dialogs. Using a panel gives you more control
over how a group of components is placed on the screen. Frames
and dialogs enable you to display freestanding windows from within
an applet. Finally, you learn all about Java menus and how to
add a menu to a frame.
<H2><A NAME="Containers"><FONT SIZE=5 COLOR=#FF0000>
Containers</FONT></A></H2>
<P>
There are many occasions when it would be convenient to treat
more than one component (for example, a label and a set of checkboxes)
as a group. For example, instead of placing each component onto
the user interface one at a time, it would be nice to be able
to create a group of components and then place the group on the
user interface. Not only would this be convenient, it is necessary
due to some of the built-in limitations of some of Java's layout
managers.
<P>
As an example, think about the <TT>BorderLayout</TT> layout manager
that was introduced in <A HREF="ch5.htm" >Chapter 5</A> &quot;Java's User Interface
Components.&quot; This layout manager enables you to place a component
in the <TT>North</TT>, <TT>South</TT>, <TT>East</TT>, <TT>West</TT>,
or <TT>Center</TT>. If there are only five locations you can put
a component, where do you put a sixth?
<P>
Fortunately, Java provides a solution in the form of its <TT>Container</TT>
classes. A <TT>Container</TT> class can be used to hold components.
And because <TT>Container</TT> is a subclass of <TT>Component</TT>,
you can place a container on the user interface just like you'd
place a check box, text field, or any other component.
<P>
<TT>Container</TT> serves as a superclass for a number of other
classes, one of which is the familiar <TT>Applet</TT> class. Each
of the other subclasses of <TT>Container</TT> will be described
in the following sections.
<H3><A NAME="ThePanelClass">
The Panel Class</A></H3>
<P>
The <TT>Panel</TT> class is the simplest of the Java <TT>Container</TT>
classes. When an applet creates a panel, no new window is created
and the panel is unseen by the user. However, by using panels
you can exert more explicit control over the placement of components
in an applet's user interface. A new panel is created using a
simple constructor, as follows:
<BLOCKQUOTE>
<PRE>
Panel myPanel = new Panel();
</PRE>
</BLOCKQUOTE>
<P>
After a panel is created, you can add components to it. You then
add the panel to another container. Because <TT>Applet</TT> is
a container, you can add the panel directly to the <TT>Applet</TT>.
This is demonstrated in the following code:
<BLOCKQUOTE>
<PRE>
public class PanelSample extends Applet
{
    public void init()
    {
        Panel myPanel = new Panel();
        myPanel.add(new Button());
        add(myPanel);
    }
}
</PRE>
</BLOCKQUOTE>
<P>
After the new panel is created, a button is placed on the panel.
Finally, <TT>add</TT> is used to place the panel on the applet's
user interface. 
<P>
Each panel uses its own layout manager that is independent of
the container on which the panel is placed. By default, <TT>Panel</TT>
uses the <TT>FlowLayout</TT> manager. Because a panel can have
a different layout manager than its parent <TT>Container</TT>,
this enables you to create user interfaces that are as complex
and precise as you want.
<H4>A Panel Example</H4>
<P>
As an example of how you can use panels, class <TT>EX06A</TT>
is shown in Listing 6.1. This class illustrates a couple of important
concepts related to the use of panels, including the use of different
layout managers.
<HR>
<BLOCKQUOTE>
<B>Listing 6.1. EX06A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06A extends Applet
{
    public void init()
    {
        resize(320, 240);

        setLayout(new GridLayout(2,2));

        Panel p1 = new Panel();
        p1.add(new Button(&quot;Panel 1&quot;));
        add(p1);

        Panel p2 = new Panel();
        p2.add(new Button(&quot;Panel 2-1&quot;));
        p2.add(new TextField(8));
        add(p2);

        Panel p3 = new Panel();
        p3.setLayout(new GridLayout(2,2));
        p3.add(new Button(&quot;Panel 3-1&quot;));
        p3.add(new Button(&quot;Panel 3-2&quot;));
        p3.add(new Button(&quot;Panel 3-3&quot;));
        p3.add(new Button(&quot;Panel 3-4&quot;));
        add(p3);

        add(new Button(&quot;No Panel&quot;));
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When run, example <TT>EX06A</TT> creates the screen shown in Figure
6.1. To create this interface the applet uses <TT>setLayout(new
GridLayout(2, 2))</TT> to create a two-row by two-column layout.
The top two cells in the grid and the bottom, left cell are each
displaying a panel. These panels are displaying the components
placed on them.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-1.gif"><B> Figure 6.1 : </B><I>Running EX06A creates three panels and a panelless area with a large button.
</I></A><P>
<P>
Panel <TT>p1</TT> is created, and a new button is placed on it.
The statement <TT>add(p1)</TT> is then used to place the panel
onto the applet. Because no explicit layout manager was specified
for panel <TT>p1</TT>, the default <TT>FlowLayout</TT> will be
used. Next, a second panel, <TT>p2</TT>, is created. After adding
a button and a <TT>TextField</TT> to this panel, it is added to
the applet.
<P>
The third panel, <TT>p3</TT>, appears a little more complicated.
However, this is only because it does not use the default layout
manager. For <TT>p3</TT> a new <TT>GridLayout</TT> object is created
and four buttons are added to the panel. Then <TT>add(p3)</TT>
is used to add this panel to the applet.
<P>
Finally, another button is created. This last button is added
directly to the apple and is not first placed on a panel. Because
the applet is using a <TT>GridLayout</TT> layout manager, the
size of the button is increased so that it fills the entire grid
cell, as shown in Figure 6.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-2.gif"><B> Figure 6.2 : </B><I>EX06B illustrates the placement of a panel  on a panel.
</I></A><P>
<P>
You should take a moment to think about the different layout managers
that are in use in <TT>EX06A</TT>. The applet itself is being
laid out under the control of <TT>GridLayout</TT>. The first two
cells in this grid are using <TT>FlowLayout</TT>, because it is
the default for <TT>Panel</TT>. The third cell is again using
<TT>GridLayout</TT>. This means the third cell is placed on the
applet as part of a grid and that it will lay out its components
as part of a grid within the grid. Finally, the fourth cell of
the applet's <TT>GridLayout</TT> does not use a panel at all and
its button is placed directly on the applet.
<H4>Placing a Panel on a Panel</H4>
<P>
What if instead of the screen shown in Figure 6.1, you wanted
to create the screen shown in Figure 6.2? The only change here
is in the top right cell. Here, a label is displayed in the top
of the panel and a label and <TT>TextField</TT> are displayed
in the bottom of the panel. How can you create this look?
<P>
It's actually fairly simple. The answer lies in the capability
to put a panel on another panel, as shown in class <TT>EX06B</TT>
in Listing 6.2.
<HR>
<BLOCKQUOTE>
<B>Listing 6.2. EX06B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06B extends Applet
{
    public void init()
    {
        resize(320, 240);

        setLayout(new GridLayout(2,2));

        Panel p1 = new Panel();
        p1.add(new Button(&quot;Panel 1&quot;));
        add(p1);

        Panel p2 = new Panel();
        p2.setLayout(new BorderLayout());
        p2.add(&quot;North&quot;, new Label(&quot;This is a panel on a panel&quot;));

        Panel subPanel = new Panel();
        subPanel.add(new Label(&quot;Name:&quot;));
        subPanel.add(new TextField(8));
        p2.add(&quot;South&quot;, subPanel);
        add(p2);

        Panel p3 = new Panel();
        p3.setLayout(new GridLayout(2,2));
        p3.add(new Button(&quot;Panel 3-1&quot;));
        p3.add(new Button(&quot;Panel 3-2&quot;));
        p3.add(new Button(&quot;Panel 3-3&quot;));
        p3.add(new Button(&quot;Panel 3-4&quot;));
        add(p3);

        add(new Button(&quot;No Panel&quot;));
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>EX06B</TT> creates a new <TT>GridLayout</TT> instance and
creates the first cell in the same way as was done in <TT>EX06A</TT>.
The second panel, <TT>p2</TT>, is created and assigned a new instance
of <TT>BorderLayout</TT>. A label, &quot;This is a panel on a
panel,&quot; is created and placed in the <TT>North</TT> of the
panel.
<P>
Here is where things get interesting. A new panel, <TT>subPanel</TT>,
is created. No layout manager is specified so <TT>subPanel</TT>
will use the default <TT>FlowLayout</TT>. The <TT>Label</TT> and
<TT>TextField</TT> are added to <TT>subPanel</TT> and then <TT>subPanel</TT>
is added to the <TT>South</TT> of panel <TT>p2</TT>, creating
the desired look.
<H4>Using Panels with CardLayout</H4>
<P>
In <A HREF="ch5.htm" >Chapter 5</A> you learned about the <TT>CardLayout</TT> layout
manager. One shortcoming of this layout manager that was pointed
out then is that it only allows you to place a single component
on it. This sounds like the type of layout manager the federal
government would buy: a layout manager so powerful it can lay
out one component. Actually, <TT>CardLayout</TT> does serve a
very useful purpose, but normally only when combined with panels.
<P>
The code for class <TT>EX06C</TT>, shown in Listing 6.3, uses
<TT>CardLayout</TT> to enable the user to page between a sequence
of four panels. If you recall example <TT>EX05I</TT> from Chapter
5, one of the problems with it was that it is difficult for the
user to know which page he is currently on. Because <TT>CardLayout</TT>
allows only one component to be added to each card, it was impossible
to add both a label saying &quot;You're on page one&quot; and
a button saying &quot;Press here to go to page two.&quot; This
problem is solved using panels in <TT>EX06C,</TT> as you can see
in Figure 6.3.
<HR>
<BLOCKQUOTE>
<B>Listing 6.3. EX06C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06C extends Applet
{
    CardLayout layout;
    public void init()
    {
        resize(320, 240);
        layout = new CardLayout();
        setLayout(layout);

        Panel panel1 = new Panel();
        panel1.setLayout(new BorderLayout());
        panel1.add(&quot;North&quot;, new Label(&quot;This is page 1&quot;));
        panel1.add(&quot;Center&quot;, new Button(&quot;Go to Page 2&quot;));
        panel1.add(&quot;South&quot;, new Label(&quot;This entire card is a panel.&quot;));
        add(&quot;Page1&quot;, panel1);

        Panel panel2 = new Panel();
        panel2.setLayout(new BorderLayout());
        panel2.add(&quot;North&quot;, new Label(&quot;This is page 2&quot;));
        panel2.add(&quot;Center&quot;, new Button(&quot;Go to Page 3&quot;));
        add(&quot;Page2&quot;, panel2);

        Panel panel3 = new Panel();
        panel3.setLayout(new BorderLayout());
        panel3.add(&quot;North&quot;, new Label(&quot;This is page 3&quot;));
        panel3.add(&quot;Center&quot;, new Button(&quot;Go to Page 4&quot;));
        add(&quot;Page3&quot;, panel3);

        Panel panel4 = new Panel();
        panel4.setLayout(new BorderLayout());
        panel4.add(&quot;North&quot;, new Label(&quot;This is page 4&quot;));
        panel4.add(&quot;Center&quot;, new Button(&quot;Go to Page 1&quot;));
        add(&quot;Page4&quot;, panel4);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Go to Page 1&quot;.equals(obj)) {
            layout.show(this, &quot;Page1&quot;);
            result = true;
        }
        else if(&quot;Go to Page 2&quot;.equals(obj)) {
            layout.show(this, &quot;Page2&quot;);
            result = true;
        }
        else if(&quot;Go to Page 3&quot;.equals(obj)) {
            layout.show(this, &quot;Page3&quot;);
            result = true;
        }
        else if(&quot;Go to Page 4&quot;.equals(obj)) {
            layout.show(this, &quot;Page4&quot;);
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-3.gif"><B> Figure 6.3 : </B><I>EX06C shows how to combine panels with CardLayout.
</I></A><P>
<P>
In <TT>EX06C</TT>, a new instance of <TT>CardLayout</TT> is created
and assigned to the applet using <TT>setLayout</TT>. Next the
first panel, <TT>panel1</TT>, is created and is assigned to use
<TT>BorderLayout</TT>. Two labels and a button are then added
to <TT>panel1</TT>, and <TT>panel1</TT> is added to the applet
under the name <TT>&quot;Page1&quot;</TT> with <TT>add(&quot;Page1&quot;,
panel1)</TT>.
<P>
Three other panels are created in a similar manner, and the applet's
<TT>action</TT> method is written to catch the button presses
and to display the appropriate card.
<H3><A NAME="TheWindowClass">
The Window Class</A></H3>
<P>
Java's <TT>Window</TT> class is also a subclass of <TT>Container</TT>;
however, you will probably never use the <TT>Window</TT> class
directly. Instead, when you want to add a free-standing window
to your applet, use either <TT>Frame</TT> or <TT>Dialog</TT>.
These classes extend <TT>Window,</TT> and each adds unique functionality.
<H3><A NAME="Frames">
Frames</A></H3>
<P>
The <TT>Frame</TT> class extends <TT>Window</TT> and provides
a class that can be used whenever you want to create a free-standing
window that is not part of the browser in which the applet is
being run. Figure 6.4, for example, illustrates a simple frame
that has been moved outside the browser's borders.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-4.gif"><B> Figure 6.4 : </B><I>A frame exists outside the browser window.
</I></A><P>
<P>
Creating a frame is as simple as using one of the constructors
shown in Table 6.1. If you use the <TT>Frame()</TT> constructor,
a default title of <TT>&quot;Untitled&quot;</TT> will be used.
So, unless the frame will be used to display untitled books, you
probably want to use the <TT>Frame(String)</TT> constructor. As
examples of constructing new frames, consider the following:
<BLOCKQUOTE>
<PRE>
Frame untitledFrame = new Frame();
Frame noTitleFrame = new Frame(&quot;&quot;);
Frame titledFrame = new Frame(&quot;Hi Mom, Send Cash&quot;);
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 6.1. Constructors for the Frame class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=288><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Frame()</TT></TD><TD WIDTH=288>Creates a frame with no title.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Frame(String)</TT></TD><TD WIDTH=288>Creates a frame with the specified title.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Once a frame is constructed you can treat it like any other container.
By default, a frame uses the BorderLayout layout manager. You
can specify a different layout manager and can add components,
including Panels, using add. Of course Frame offers its own features
beyond those available to other containers. A frame can have a
menu, can use a variety of different cursors, and can have an
icon placed on its title bar. In addition to the menu that can
be added to the frame, each frame has a control menu located in
the top left of the frame, as shown in Figure 6.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-5.gif"><B> Figure 6.5 : </B><I>A frame with its control menu dropped down.
</I></A><P>
<P>
To support these features, the Frame class includes the nonprivate
member methods shown in Table 6.2.<BR>
<P>
<CENTER><B>Table 6.2. Nonprivate methods of the Frame class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>addNotify()</TT></TD><TD WIDTH=384>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>dispose()</TT></TD><TD WIDTH=384>Disposes of resources (for example, menu bars) in use by the frame.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getCursorType()</TT></TD><TD WIDTH=384>Returns the cursor type that is displayed when the mouse pointer is over the frame.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getIconImage()</TT></TD><TD WIDTH=384>Returns the image used as the frame's icon.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getMenuBar()</TT></TD><TD WIDTH=384>Gets the frame's menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getTitle()</TT></TD><TD WIDTH=384>Returns the frame's title.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isResizable()</TT></TD><TD WIDTH=384>Returns true if the frame is resizable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>paramString()</TT></TD><TD WIDTH=384>Returns the frame's parameter string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>remove(MenuComponent)</TT></TD><TD WIDTH=384>Removes the specified item from the frame's menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setCursor(int)</TT></TD><TD WIDTH=384>Sets the cursor that will be displayed when the mouse pointer is over the frame.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setIconImage(Image)</TT></TD><TD WIDTH=384>Sets the image to use as the frame's icon.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setMenuBar(MenuBar)</TT></TD><TD WIDTH=384>Sets the frame's menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setResizable(boolean)</TT></TD><TD WIDTH=384>Makes the frame resizable or not, depending on the specified parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setTitle(String)</TT></TD><TD WIDTH=384>Sets the dialog's title.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
When using a frame, you should take the following steps:
<OL>
<LI>Create the frame using <TT>new</TT>.
<LI>Place components (buttons, text fields, and so on) on the
frame.
<LI>Use <TT>resize</TT> to set the frame to the correct dimensions.
<LI>When done with the frame, call <TT>dispose</TT> to release
resources.
</OL>
<H4>A Frame Example</H4>
<P>
Listing 6.4 creates the sample frame that was shown in Figure
6.4. The <TT>EX06D</TT> class is derived from <TT>Applet</TT>.
In the <TT>init</TT> method, an instance of a new class called
<TT>MyFrame</TT> is allocated but not displayed. A button labeled
Show Frame is then added to the applet, and the <TT>action</TT>
method looks for a push of this button. If the button push is
detected, <TT>frame.show</TT> is used to display the instance.
<HR>
<BLOCKQUOTE>
<B>Listing 6.4. EX06D.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06D extends Applet
{
    MyFrame frame;

    public void init()
    {
        frame = new MyFrame();
        add(new Button(&quot;Show Frame&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result = false;

        if (&quot;Show Frame&quot;.equals(obj)) {
            frame.show();
            result = true;
        }
        return result;
    }
}

class MyFrame extends Frame {
    public MyFrame() 
    {
        add(&quot;Center&quot;, new Label(&quot;This is a frame&quot;));

        Panel p = new Panel();
        p.add(new Button(&quot;Close&quot;));
        add(&quot;South&quot;, p);

        resize(250, 250);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;

        if(&quot;Close&quot;.equals(evt.arg)) {
            dispose();
            result = true;
        }
        return result;
    }     
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>MyFrame</TT> class is defined as a subclass of <TT>Frame</TT>.
The constructor for <TT>MyFrame</TT> places a label on the frame
and then constructs a new panel. A Close button is then constructed
and placed on the panel, and the panel is added to the frame.
The frame is then resized. Don't forget to resize the frame, or
it will be made only large enough to display the title bar. The
<TT>action</TT> method of <TT>MyFrame</TT> watches for the <TT>Close</TT>
button and then calls <TT>dispose</TT> to tell the Java Virtual
Machine that the applet is done with this frame.
<H4>Controlling a Frame at Runtime</H4>
<P>
As Table 6.2 shows, there are a number of ways you can control
the appearance of a frame at runtime. <TT>EX06E</TT>, shown in
Listing 6.5, illustrates some of these.
<HR>
<BLOCKQUOTE>
<B>Listing 6.5. EX06E.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06E extends Applet
{
    MyFrame frame;

    public void init()
    {
        frame = new MyFrame();
        add(new Button(&quot;Show Frame&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result = false;

        if (&quot;Show Frame&quot;.equals(obj)) {
            frame.show();
            result = true;
        }
        return result;
    }
}

class MyFrame extends Frame {
    TextField title;
    Choice cursor;

    public MyFrame() 
    {
        setLayout(new GridLayout(3,1));

        // create a panel and controls for
        // setting the frame's title
        Panel panel1 = new Panel();
        panel1.add(new Label(&quot;Title:&quot;));
        title = new TextField(10);
        panel1.add(title);
        add(panel1);

        // create a panel and controls for
        // setting the frame's cursor
        Panel panel2 = new Panel();
        panel2.add(new Label(&quot;Cursor:&quot;));
        cursor = new Choice();
        cursor.addItem(&quot;Default&quot;);
        cursor.addItem(&quot;Crosshair&quot;);
        cursor.addItem(&quot;Hand&quot;);
        cursor.addItem(&quot;Move&quot;);
        cursor.addItem(&quot;Text&quot;);
        cursor.addItem(&quot;Wait&quot;);
        panel2.add(cursor);
        add(panel2);

        // create a panel with two buttons
        Panel panel3 = new Panel();
        panel3.add(new Button(&quot;Apply&quot;));
        panel3.add(new Button(&quot;Close&quot;));
        add(panel3);

        resize(250, 250);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;

        if(&quot;Close&quot;.equals(evt.arg)) {
            dispose();
            result = true;
        }
        else if(&quot;Apply&quot;.equals(evt.arg)) {
            setTitle(title.getText());

            int Cursors[]={DEFAULT_CURSOR, CROSSHAIR_CURSOR, 
                HAND_CURSOR, MOVE_CURSOR, TEXT_CURSOR, 
                WAIT_CURSOR };

            setCursor(Cursors[cursor.getSelectedIndex()]);
        }
        return result;
    }     
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, a frame is created that can be customized by
the user. The user can enter a string into a text field, select
a cursor type from a choice, and then select the Apply button
to see the results of his selections. This can be seen in Figure
6.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-6.gif"><B> Figure 6.6 : </B><I>Controlling the appearance of a frame at runtime.
</I></A><P>
<P>
To achieve this, the <TT>MyFrame</TT> constructor in <TT>EX06E</TT>
constructs a text field and a choice, and adds them to panels
to create a pleasant user interface. The action method of <TT>MyFrame</TT>
then traps for a press on the Apply button. When that is detected,
<TT>setTitle(title.getText)</TT> takes the string entered by the
user and makes it the title of the frame. Similarly, a call to
<TT>setCursor</TT> causes the frame to use the cursor selected
by the user in the <TT>cursor</TT> <TT>Choice</TT> member.
<H3><A NAME="Dialogs">
Dialogs</A></H3>
<P>
The Java <TT>Dialog</TT> class is similar to the <TT>Frame</TT>
class. Just like a frame, a dialog can hold components and accept
user input. A dialog can be constructed using either of the constructors
shown in Table 6.3.<BR>
<P>
<CENTER><B>Table 6.3. Constructors for the Dialog class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Dialog(Frame, boolean)</TT></TD><TD WIDTH=384>Creates a dialog with the specified parent frame and modality.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Dialog(Frame, String, boolean)</TT></TD>
<TD WIDTH=384>Creates a dialog with the specified parent frame, title <TT>String</TT>, and modality.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Unfortunately, you cannot just construct a dialog and toss it
directly onto the screen as you can with a frame. Every dialog
must have a frame as its parent. Because an applet is not a frame,
you cannot create a dialog with an applet as its parent. This
isn't much of an inconvenience, however, because it is simple
to create a frame, and you don't really need to do anything with
the frame other than use it as the dialog's parent in the dialog
constructor. For example, you can create and use a dummy frame
as follows:
<BLOCKQUOTE>
<PRE>
Frame dummyFrame = new Frame();
dummyFrame.resize(250, 250);
Dialog d = new Dialog(dummyFrame, false); 
</PRE>
</BLOCKQUOTE>
<P>
A key difference between a frame and a dialog is found in the
final parameter to each of the <TT>Dialog</TT> constructors. This
<TT>boolean</TT> parameter specifies the modality of the dialog.
A dialog can be either <I>modal</I> or <I>modeless</I>. A modal
dialog forces users to respond to it before they can continue
working with other parts of the applet. Because of this, a modal
dialog is perfect for displaying error messages or for gathering
user input that is necessary before continuing further. A modeless
dialog does not require that the user close the dialog before
continuing.
<P>
Another difference between a frame and a dialog is that a menu
can only be attached directly to a frame. Later in this chapter
you learn how to attach a menu to a frame.
<P>
Because a dialog is closely related to a frame, a dialog's set
of nonprivate methods should be familiar. These are shown in Table
6.4.<BR>
<P>
<CENTER><B>Table 6.4. Nonprivate methods of the Dialog class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=288><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>addNotify()</TT></TD><TD WIDTH=288>Creates a peer for the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getTitle()</TT></TD><TD WIDTH=288>Returns the dialog's title.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isModal()</TT></TD><TD WIDTH=288>Returns <TT>true</TT> if the dialog is modal.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isResizable()</TT></TD><TD WIDTH=288>Returns <TT>true</TT> if the dialog is resizable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>paramString()</TT></TD><TD WIDTH=288>Returns the dialog's parameter string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setResizable(boolean)</TT></TD><TD WIDTH=288>Makes the dialog resizable or not, depending on the specified parameter.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setTitle(String)</TT></TD><TD WIDTH=288>Sets the dialog's title.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>A Dialog Example</H4>
<P>
Class <TT>EX06F</TT> is an example of how to use a dialog in an
applet. It is similar to <TT>EX06E</TT> in that the applet's main
screen includes a button that activates the main part of the applet.
In the prior example, a frame was displayed. In <TT>EX06F</TT>,
pressing the Show Dialog button on the applet's main screen will
create and display the dialog shown in Figure 6.7.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-7.gif"><B> Figure 6.7 : </B><I>An initially unresizable dialog.
</I></A><P>
<P>
The dialog, as shown in Figure 6.7, includes a label telling us
that it cannot be resized, a Toggle button, and a Close button.
Selecting the Toggle button enables resizing for the dialog and
changes the label at the top of the dialog. Once the dialog is
resizable, it can be stretched along any of its sides as shown
in Figure 6.8.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-8.gif"><B> Figure 6.8 : </B><I>The same dialog after the Toggle button was pushed and the dialog was resized.
</I></A><P>
<P>
The code that creates this dialog is shown in Listing 6.6. This
class includes two classes: the <TT>applet</TT> class (<TT>EX06F)</TT>
and <TT>MyDialog</TT>, which extends <TT>Dialog</TT>. In the <TT>EX06F</TT>
class member <TT>dlg</TT> of <TT>MyDialog</TT> is stored. In the
<TT>init</TT> method for this class, you can see that a frame
is constructed, resized, and then passed to the constructor for
<TT>MyDialog</TT>. Notice that although the frame is constructed,
it is never displayed. A button labeled Show Dialog is created.
The <TT>action</TT> method looks for a push of this button and
then calls <TT>dlg.show</TT> to display the dialog.
<HR>
<BLOCKQUOTE>
<B>Listing 6.6. EX06F.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06F extends Applet
{
    MyDialog dlg;

    public void init()
    {
        Frame f = new Frame();
        f.resize(250, 250);
        dlg = new MyDialog(f, &quot;Howdy&quot;);
        add(new Button(&quot;Show Dialog&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result = false;

        if (&quot;Show Dialog&quot;.equals(obj)) {
            dlg.show();
            result = true;
        }
        return result;
    }
}

class MyDialog extends Dialog {
    Label resizeLabel;
    String labelText [] = {
        &quot;Dialog is NOT resizable&quot;,
        &quot;Dialog is resizable&quot;
    };

    public MyDialog(Frame parent, String title) 
    {
        super(parent, title, false);
        setResizable(false);

        resizeLabel = new Label(labelText[0]);
        add(&quot;North&quot;, resizeLabel);

        Panel p = new Panel();
        p.add(new Button(&quot;Toggle&quot;));
        p.add(new Button(&quot;Close&quot;));
        add(&quot;South&quot;, p);

        pack();
        resize(250, 250);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;

        if(&quot;Toggle&quot;.equals(evt.arg)) {
            if (isResizable())
                resizeLabel.setText(labelText[0]);
            else
                resizeLabel.setText(labelText[1]);

            setResizable(!isResizable());
            result = true;
        }
        else if(&quot;Close&quot;.equals(evt.arg)) {
            dispose();
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>MyDialog</TT> class declares a label, <TT>resizeLabel</TT>,
and an array of strings that will be displayed in the label so
the user knows whether or not the dialog is currently resizable.
The constructor for <TT>MyDialog</TT> uses <TT>super</TT> to construct
the actual dialog. This is passed the undisplayed parent frame,
the title of the dialog, and <TT>false</TT> to indicate that the
dialog will be modeless.
<P>
Next, <TT>setResizable(false)</TT> is used to prevent the user
from resizing the dialog initially. The label indicating this
is constructed and placed on the dialog. The user interface is
completed by placing the Toggle and Close buttons on a panel,
which is then placed on the dialog.
<P>
The <TT>action</TT> method looks for a push of either the Toggle
or the Close button. If Close is pushed, <TT>dispose</TT> is used
to release the dialog. If Toggle is pushed, <TT>isResizable</TT>
determines the current state of the dialog and the text of the
label is changed appropriately. The code <TT>setResizable(!isResizable())</TT>
is used to toggle the resizable state of the dialog.
<H3><A NAME="FileDialog">
FileDialog</A></H3>
<P>
The final subclass of <TT>Container</TT> is the <TT>FileDialog</TT>
class. This class can be used for creating File Save or File Open
dialogs, as shown in Figure 6.9. This class is not available when
programming applets. Because applets cannot access files, there
is no need to open or close them. However, to complete this chapter's
coverage of the Java <TT>Container</TT> classes, a brief overview
of <TT>FileDialog</TT> is presented.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-9.gif"><B> Figure 6.9 : </B><I>The FileDialog in save mode under Windows 95.
</I></A><P>
<P>
An instance of <TT>FileDialog</TT> can be constructed using either
of two constructors, as shown in the following three examples:
<BLOCKQUOTE>
<PRE>
FileDialog dlg1 = new FileDialog(frame, &quot;Save&quot;);
FileDialog dlg2 = new FileDialog(frame, &quot;Save&quot;, FileDialog.SAVE);
FileDialog dlg3 = new FileDialog(frame, &quot;Open&quot;, FileDialog.OPEN);
</PRE>
</BLOCKQUOTE>
<P>
Each <TT>FileDialog</TT> is created in either open or save mode,
depending on whether it will be used to open an existing file
or write to a file. These modes are identified by <TT>FileDialog.SAVE</TT>
and <TT>FileDialog.OPEN</TT>. By default, a new instance of <TT>FileDialog</TT>
is created in save mode. Therefore, <TT>dlg1</TT> and <TT>dlg2</TT>
will be in save mode but <TT>dlg3</TT> will be in open mode.
<P>
Because <TT>FileDialog</TT> is a subclass of <TT>Dialog</TT>,
it is necessary for each <TT>FileDialog</TT> to have a parent
frame. The parent frame is passed as the first parameter to either
<TT>FileDialog</TT> constructor. As with other dialogs, it is
not necessary for the frame to be displayed.
<P>
Once constructed, a <TT>FileDialog</TT> is displayed with the
<TT>show</TT> method. Usually, the entire purpose of displaying
a <TT>FileDialog</TT> is to get a filename from the user. Naturally,
there are member methods in <TT>FileDialog</TT> that enable you
to retrieve this information after the user has entered it. The
<TT>getDirectory</TT> method can be used to retrieve the directory
name selected by the user. Similarly, <TT>getFile</TT> will return
the filename. Combined, they give you the fully qualified filename.
<P>
As an example, the following code creates a <TT>FileDialog</TT>
in save mode, displays it, and then prints the full path and filename
entered by the user:
<BLOCKQUOTE>
<PRE>
Frame f = new Frame();
f.resize(250, 250);

FileDialog d = new FileDialog(f, &quot;Save a File&quot;, FileDialog.SAVE);
d.show();

System.out.println(&quot;Picked: &quot; + d.getDirectory() + d.getFile());
</PRE>
</BLOCKQUOTE>
<H2><A NAME="Menus"><FONT SIZE=5 COLOR=#FF0000>
Menus </FONT></A></H2>
<P>
The final subject in this chapter's discussion on user interface
programming is menus. The hierarchy of Java classes involved in
creating menus is shown in Figure 6.10. The <TT>MenuComponent</TT>
class serves as an abstract base class for <TT>MenuBar</TT> and
<TT>MenuItem</TT>; as such, you will never construct an actual
instance of <TT>MenuComponent</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-10.gif"><B> Figure 6.10 : </B><I>The Java Menu classes.
</I></A><P>
<P>
Menus in Java are created by combining three items: a menubar,
one or more menus, and one or more menu items on each of the menus.
Each of these items is labeled in Figure 6.11, which is a sample
menu that will be built in the next section.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-11.gif"><B> Figure 6.11 : </B><I>The items which comprise  a Java menu.
</I></A><P>
<H3><A NAME="TheMenuBarClass">
The MenuBar Class</A></H3>
<P>
The <TT>MenuBar</TT> class represents the top-most level of a
menu. After creating a menubar, you can create <TT>Menu</TT> objects
and assign the <TT>Menu</TT> objects to the menubar. A menubar
is created as follows:
<BLOCKQUOTE>
<PRE>
MenuBar bar = new MenuBar();
</PRE>
</BLOCKQUOTE>
<P>
In addition to its constructor, the <TT>MenuBar</TT> class includes
the methods listed in Table 6.5.<BR>
<P>
<CENTER><B>Table 6.5. Nonprivate methods of the MenuBar class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=190><I>Method</I></TD><TD WIDTH=400><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>add(Menu)</TT></TD><TD WIDTH=400>Adds a menu to this menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>addNotify()</TT></TD><TD WIDTH=400>Creates a peer for the object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>countMenus()</TT></TD><TD WIDTH=400>Returns the number of menus on this menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>getHelpMenu()</TT></TD><TD WIDTH=400>Returns the menu that has been identified as the Help menu for this menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>getMenu(int)</TT></TD><TD WIDTH=400>Returns the menu at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>remove(int)</TT></TD><TD WIDTH=400>Removes the menu at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>remove(MenuComponent)</TT></TD><TD WIDTH=400>Removes the specified menu component from this menubar.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>removeNotify()</TT></TD><TD WIDTH=400>Removes the object's peer.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>setHelpMenu(Menu)</TT></TD><TD WIDTH=400>Indicates the Help menu for this menubar.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In Java, menus are added to a class that implements the <TT>MenuContainer</TT>
interface. In most cases this will be a class you define and base
on <TT>Frame</TT> because <TT>Frame</TT> is the only Java container
to implement <TT>MenuContainer</TT>. The following code adds a
menubar to a frame:
<BLOCKQUOTE>
<PRE>
MenuBar bar = new MenuBar();
// add menus to the MenuBar
myFrame.setMenuBar(bar);
</PRE>
</BLOCKQUOTE>
<H3><A NAME="TheMenuClass">
The Menu Class</A></H3>
<P>
A menubar without any menus is as worthless as a pizza without
any pepperoni. This can be easily rectified by creating <TT>Menu</TT>
objects. To create a new menu, simply provide the name of the
menu to the constructor, as follows:
<BLOCKQUOTE>
<PRE>
Menu catMenu = new Menu(&quot;Cats&quot;);
Menu dogMenu = new Menu(&quot;Dogs&quot;);
</PRE>
</BLOCKQUOTE>
<P>
After creating a menu, you must add it to the menubar. Menus will
be displayed across the menubar in the order they are added to
it. For example, the following code will create a Cats menu followed
by a Dogs menu:
<BLOCKQUOTE>
<PRE>
Menu catMenu = new Menu(&quot;Cats&quot;);
menuBar.add(catMenu);
Menu dogMenu = new Menu(&quot;Dogs&quot;);
menuBar.add(dogMenu);
</PRE>
</BLOCKQUOTE>
<P>
A second <TT>Menu</TT> constructor is provided that is passed
a string and a Boolean value indicating whether the menu is a
tear-off menu. In addition to these constructors, the <TT>Menu</TT>
class includes the methods listed in Table 6.6.<BR>
<P>
<CENTER><B>Table 6.6. Nonprivate methods of the Menu class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=220><I>Method</I></TD><TD WIDTH=400><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>add(MenuItem)</TT></TD><TD WIDTH=400>Adds the specified menu item to the menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>add(String)</TT></TD><TD WIDTH=400>Adds an item with the specified label to the menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>addNotify()</TT></TD><TD WIDTH=400>Creates a peer for the object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>addSeparator()</TT></TD><TD WIDTH=400>Adds a separator line to the menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>countItems()</TT></TD><TD WIDTH=400>Returns the number of items in the menu.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>getItem(int)</TT></TD><TD WIDTH=400>Returns the menu item at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>isTearOff()</TT></TD><TD WIDTH=400>Returns <TT>true</TT> if the menu can be torn off.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>remove(int)</TT></TD><TD WIDTH=400>Removes the menu item at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>remove(MenuComponent)</TT></TD><TD WIDTH=400>Removes the specified menu component from the menu .
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=220><TT>removeNotify()</TT></TD><TD WIDTH=400>Removes the object's peer.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheMenuItemClass">
The MenuItem Class</A></H3>
<P>
The menu still isn't useful, however, because no menu items have
been added. A new menu item can be created by passing a string
to the menu item constructor. For example, the following code
illustrates all that is needed to create a menubar, a Dogs menu
on the menubar, and three items on the Dogs menu:
<BLOCKQUOTE>
<PRE>
MenuBar menuBar = new MenuBar();
Menu dogMenu = new Menu(&quot;Dogs&quot;);
dogMenu.add(new MenuItem(&quot;Labrador&quot;));
dogMenu.add(new MenuItem(&quot;Poodle&quot;));
dogMenu.add(new MenuItem(&quot;Spaniel&quot;));
menuBar.add(dogMenu);
myFrame.setMenuBar(menuBar);
</PRE>
</BLOCKQUOTE>
<P>
By default, <TT>MenuItem</TT>s are <I>enabled</I>. This means
that the user can select them from the menu on which they appear.
It is possible to disable a <TT>MenuItem</TT>. This can be done
using either the <TT>disable</TT> method or by passing <TT>false</TT>
to the <TT>enable</TT> method. A <TT>MenuItem</TT> can be enabled
by passing <TT>true</TT> to <TT>enable</TT> or by using <TT>enable</TT>
without any parameters. These methods are illustrated in the following:
<BLOCKQUOTE>
<PRE>
MenuItem item = new MenuItem(&quot;Big Dog&quot;);
item.disable();        // disable the MenuItem
item.enable();         // enable the MenuItem
item.enable(false);    // disable the MenuItem
item.enable(true);     // enable the MenuItem
</PRE>
</BLOCKQUOTE>
<P>
The <TT>enable</TT> and <TT>disable</TT> methods are not the only
ones available for a <TT>MenuItem</TT>. Table 6.7 describes each
of the nonprivate members of <TT>MenuItem</TT>.<BR>
<P>
<CENTER><B>Table 6.7. Nonprivate methods of the MenuItem class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>addNotify()</TT></TD><TD WIDTH=384>Creates a peer for the object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>disable()</TT></TD><TD WIDTH=384>Disables selection of this menu item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>enable()</TT></TD><TD WIDTH=384>Enables selection of this menu item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>enable(boolean)</TT></TD><TD WIDTH=384>Enables or disables selection of the menu item based on the specified Boolean.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getLabel()</TT></TD><TD WIDTH=384>Returns the label for this menu item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>IsEnabled()</TT></TD><TD WIDTH=384>Returns <TT>true</TT> if the menu item is selectable.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>paramString()</TT></TD><TD WIDTH=384>Returns a parameter string for this menu item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setLabel(String)</TT></TD><TD WIDTH=384>Sets the label of the menu item to the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>The CheckboxMenuItem Class</H4>
<P>
The <TT>CheckboxMenuItem</TT> class is a subclass of <TT>MenuItem</TT>
that can be used to display a check mark next to the item when
desired. A <TT>CheckboxMenuItem</TT> is used almost identically
to a regular <TT>MenuItem</TT>. It provides the additional <TT>getState</TT>
and <TT>setState(boolean)</TT> methods, but is constructed and
added to a menu as though it were a <TT>MenuItem</TT>. For example,
the following code will create a new <TT>CheckboxMenuItem </TT>with
the menu text<TT> &quot;Checkbox&quot;</TT>, set it to its checked
state, and then add it to the menu:
<BLOCKQUOTE>
<PRE>
CheckboxMenuItem checkbox = new CheckboxMenuItem(&quot;Checkbox&quot;);
checkbox.setState(true);
menu.add(checkbox);
</PRE>
</BLOCKQUOTE>
<P>
In addition to its constructor, the <TT>CheckboxMenuItem</TT>
class includes the methods listed in Table 6.8.<BR>
<P>
<CENTER><B>Table 6.8. Nonprivate methods of the CheckboxMenuItem
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>addNotify()</TT></TD><TD WIDTH=384>Creates a peer for the object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getState()</TT></TD><TD WIDTH=384>Returns <TT>true</TT> if the <TT>CheckboxMenuItem</TT> is checked or <TT>false</TT> otherwise.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>paramString()</TT></TD><TD WIDTH=384>Returns a parameter <TT>String</TT> for this menu item.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetState(boolean)</TT></TD><TD WIDTH=384>Checks or unchecks the <TT>CheckboxMenuItem</TT> depending on the specified Boolean.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="AnExampleofAddingaMenutoaFrame">
An Example of Adding a Menu to a Frame</A></H3>
<P>
In this example you will create a frame and attach a menubar to
it. The menubar includes menus for Dogs, Cats, and Food. These
menus are created by <TT>EX06G</TT>, which is shown in Listing
6.7. The <TT>Applet</TT> class in this example simply displays
a button and waits for the user to push the button before displaying
the frame with the menu on it.
<HR>
<BLOCKQUOTE>
<B>Listing 6.7 EX06G.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX06G extends Applet
{
    MyFrame frame;

    public void init()
    {
        frame = new MyFrame();
        add(new Button(&quot;Show Frame&quot;));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result = false;

        if (&quot;Show Frame&quot;.equals(obj)) {
            frame.show();
            result = true;
        }
        return result;
    }
}

class MyFrame extends Frame {
    TextArea info;

    public MyFrame() 
    {
        MenuBar menuBar = new MenuBar();

        // create a menu of dog breeds
        Menu dogMenu = new Menu(&quot;Dogs&quot;);
        dogMenu.add(new MenuItem(&quot;Labrador&quot;));
        dogMenu.add(new MenuItem(&quot;Poodle&quot;));
        dogMenu.add(new MenuItem(&quot;Spaniel&quot;));
        // add the menu to the menu bar
        menuBar.add(dogMenu);

        // create a menu of cat breeds
        Menu catMenu = new Menu(&quot;Cats&quot;);
        catMenu.add(new MenuItem(&quot;Persian&quot;));
        catMenu.add(new MenuItem(&quot;Maine Coon&quot;));
        // separate house cats from wild cats
        catMenu.addSeparator();
        catMenu.add(new MenuItem(&quot;Cougar&quot;));
        catMenu.add(new MenuItem(&quot;Leopard&quot;));
        // add the menu to the menu bar
        menuBar.add(catMenu);

        // create a menu of pet foods
        Menu foodMenu = new Menu(&quot;Food&quot;);
        // create a CheckboxMenuItem for dog food
        CheckboxMenuItem dogFood = new CheckboxMenuItem(&quot;Dog Chow&quot;);
        dogFood.setState(true);
        foodMenu.add(dogFood);        
        // there are two types of cat food so 
        // create a sub menu
        Menu catFoodMenu = new Menu(&quot;Cat Food&quot;);
        catFoodMenu.add(new MenuItem(&quot;Tuna&quot;));
        catFoodMenu.add(new MenuItem(&quot;Cat Chow&quot;));
        // add the sub menu to the menu
        foodMenu.add(catFoodMenu);
        // add the menu to the menu bar
        menuBar.add(foodMenu);

        // add a Close button on a panel
        Panel p = new Panel();
        p.add(new Button(&quot;Close&quot;));
        add(&quot;South&quot;, p);

        Panel p2 = new Panel();
        info = new TextArea(3, 20);
        p2.add(info);
        add(&quot;Center&quot;, p2);

        // set the frame's menu bar to the new menu
        setMenuBar(menuBar);

        resize(250, 250);
    }

    public boolean action(Event evt, Object arg) 
    {
        boolean result = false;

        if(&quot;Close&quot;.equals(evt.arg)) {
            dispose();
            result = true;
        }
        else if (&quot;Persian&quot;.equals(evt.arg)) {
            info.setText(&quot;A big furry cat\r\n&quot;);
            info.appendText(&quot;that I'm allergic to.&quot;);            
            result = true;
        }
        else if (&quot;Maine Coon&quot;.equals(evt.arg)) {
            info.setText(&quot;A really ferocious cat that\r\n&quot;);
            info.appendText(&quot;my Grandmother thinks is\r\n&quot;);
            info.appendText(&quot;a house cat.&quot;);            
            result = true;
        }
        return result;
    }     
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The class <TT>MyFrame</TT> is where all the action is. In the
constructor for this class, you can see that first a menubar,
<TT>menuBar</TT>, is constructed. Next, <TT>dogMenu</TT> is constructed
and three <TT>MenuItems</TT> are added to <TT>dogMenu</TT> before
<TT>dogMenu</TT> is added to the menubar.
<P>
The second menu, <TT>catMenu</TT>, is created in a similar manner
except that the <TT>addSeparator</TT> method is used to create
a separating line between the first two domestic cats and the
later two wild cats. Figure 6.11 shows the effect of adding the
separator.
<P>
A third menu, <TT>foodMenu</TT>, is constructed. This menu is
more involved than the first two menus because it includes both
a <TT>CheckboxMenuItem</TT> and a submenu. This can be seen in
Figure 6.12. After the <TT>CheckboxMenuItem</TT> is constructed
and added to <TT>foodMenu</TT>, a new menu, <TT>catFoodMenu</TT>,
is constructed. The Tuna and Cat Chow items are added to this
menu. Then <TT>foodMenu.add(catFoodMenu)</TT> is used to add the
<TT>catFoodMenu</TT> submenu to the <TT>Food</TT> menu. This is
possible because <TT>Menu</TT> is a subclass of <TT>MenuItem</TT>.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-12.gif"><B> Figure 6.12 : </B><I>The Food menu has a CheckboxMenuItem and a submenu.
</I></A><P>
<P>
After the menus are created, a Close button and a text area are
placed on panels on the frame. The text area will be used to display
information about items from the <TT>Cat</TT> menu if they are
selected by the user. Finally, the menubar is attached to the
frame with <TT>setMenuBar(menuBar)</TT>.
<P>
Of course, just putting a menu on a frame doesn't do anything
unless you also trap the events generated by a user selecting
the menu items. In this example, this is done in the <TT>action</TT>
method. The only events handled are when the user selects Persian
or Maine Coon from the Cats menu. Whenever one of these items
is selected, an appropriate informational message about the selected
breed of cat is written to the text area on the frame. This can
be seen in Figure 6.13.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f6-13.gif"><B> Figure 6.13 : </B><I>Selecting Maine Coon from the Cats menu displays information about this breed.
</I></A><P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter presented you with a lot of information about Java's
<TT>Container</TT> classes <TT>Panel</TT>, <TT>Frame</TT>, <TT>Dialog</TT>,
and <TT>FileDialog</TT>. You learned how to create and place panels
on other containers in order to group components. You saw how
panels can be combined with the <TT>CardLayout</TT> class to create
a dynamic user interface. You learned how to use the <TT>Frame</TT>
and <TT>Dialog</TT> classes to create windows that are not part
of the browser's window. Additionally, you saw how to control
a frame's cursor. Finally, you learned about Java's menu classes:
<TT>MenuBar</TT>, <TT>Menu</TT>, <TT>MenuItem</TT>, and <TT>CheckboxMenuItem</TT>.
You learned how to combine these to create menus and submenus
that can be attached to a frame.
<P>
In the next chapter you will see how to simplify some of work
involved in these tasks by using the Resource Wizard of Visual
J++.
<HR>

<CENTER><P><A HREF="ch5.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch7.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
