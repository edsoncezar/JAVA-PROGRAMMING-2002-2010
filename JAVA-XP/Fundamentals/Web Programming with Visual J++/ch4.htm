<HTML>
<HEAD>
<TITLE>Chapter 4 -- Applet Programming Fundamentals</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;4</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Applet Programming Fundamentals</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheAppletClass">
The Applet Class</A>
<UL>
<LI><A HREF="#TheLifeandDeathofanApplet">
The Life and Death of an Applet</A>
</UL>
<LI><A HREF="#EventHandling">
Event Handling</A>
<UL>
<LI><A HREF="#TheComponentClass">
The Component Class</A>
<LI><A HREF="#TheEventClass">
The Event Class </A>
<LI><A HREF="#HandlingAnyEvent">
Handling Any Event</A>
<LI><A HREF="#EventHandlingfortheMouse">
Event Handling for the Mouse</A>
<LI><A HREF="#KeyboardEventHandling">
Keyboard Event Handling</A>
</UL>
<LI><A HREF="#UsingAppletParameters">
Using Applet Parameters</A>
<UL>
<LI><A HREF="#EmbeddingParametersinHTML">
Embedding Parameters in HTML</A>
<LI><A HREF="#ReadingAppletParameters">
Reading Applet Parameters</A>
</UL>
<LI><A HREF="#WorkingwithURLsandGraphics">
Working with URLs and Graphics</A>
<UL>
<LI><A HREF="#AccessingaURL">
Accessing a URL</A>
<LI><A HREF="#AnExampleofDisplayinganImage">
An Example of Displaying an Image </A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In this chapter you learn the fundamentals of Java applet programming.
You learn about the four methods that control the life span of
an applet. You also learn how to write code to respond to events
generated by an applet's graphical user interface. In this chapter
you also see how to use applet parameters to control the behavior
of a program. Finally, you learn about Uniform Resource Locators
(URLs) and how to display simple graphics.
<H2><A NAME="TheAppletClass"><FONT SIZE=5 COLOR=#FF0000>
The Applet Class</FONT></A></H2>
<P>
To create your own applets, you derive a class from Java's <TT>Applet</TT>
class and then add the desired functionality. The <TT>Applet</TT>
class contains methods for actions such as interacting with the
browser environment in which it is running, for retrieving images,
for playing sound files, and for resizing its host window. In
this section you learn about the most frequently used methods
in this important class.
<H3><A NAME="TheLifeandDeathofanApplet">
The Life and Death of an Applet</A></H3>
<P>
On a typical Java-enhanced Web page, Java applets start and stop
frequently as the user switches among pages. As pages are loaded
into the browser, viewed and then left, applets are started and
terminated in response to messages passed to the <TT>Applet</TT>
class. The four most important methods in the life of an applet
are <TT>init</TT>, <TT>start</TT>, <TT>stop</TT>, and <TT>destroy</TT>.
They are described in Table 4.1.<BR>
<P>
<CENTER><B>Table 4.1. Important methods over the life of an applet.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=96><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>init</TT></TD><TD WIDTH=384>Called when the applet is initially loaded.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>start</TT></TD><TD WIDTH=384>Called each time the user loads the host Web page.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>stop</TT></TD><TD WIDTH=384>Called each time the user leaves the host Web page.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96><TT>destroy</TT></TD><TD WIDTH=384>Called to release resources allocated by the applet.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>The init Method </H4>
<P>
When an applet is first loaded by either a browser or a stand-alone
interpreter such as is provided with Visual J++, the <TT>init</TT>
method is called. This allows the applet to execute any startup
code that is necessary. Usually an applet will resize itself at
this point. The applet may also acquire and load resources such
as images or sound at this point. The <TT>init</TT> method will
be called only once for each time the applet is loaded.
<H4>The destroy Method</H4>
<P>
The <TT>destroy</TT> method is called when the browser is closing
an applet. Ideally this method should be used to release any resources
that have been allocated during the life of the applet; however,
because Java performs garbage collection, it is not necessary
to release resources.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Although you do not need to explicitly release resources, it is generally a good practice to do so. By explicitly releasing a resource, rather than waiting for Java's garbage detection to notice a resource has been released, your program will be able to 
reuse the resource sooner</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>The start and stop Methods</H4>
<P>
The <TT>start</TT> method is similar to <TT>init</TT> except that
<TT>start</TT> is called each time the Web page in which the applet
is embedded is loaded. The most frequent use of the <TT>start</TT>
method is to create a new thread. Similarly, the <TT>stop</TT>
method is called whenever the browser moves off the Web page that
hosts the applet.
<P>
The distinction between a method that gets called when an applet
is first loaded and when its host page is first loaded might seem
like a fine distinction, but understanding this distinction enables
you to write more efficient applets. In Netscape Navigator 3 and
Microsoft Internet Explorer 3, when a page containing a Java applet
is first loaded, the <TT>init</TT> and <TT>start</TT> methods
are called. Following a link from the page calls the applet's
<TT>stop</TT> method. Backing up to the page calls the applet's
<TT>start</TT> method, but not its <TT>init</TT> method.
<P>
In Netscape Navigator, reloading a page that contains an applet
will stop and then start the applet. Performing the equivalent
function in Microsoft Internet Explorer, however, causes the <TT>stop</TT>,
<TT>destroy</TT>, <TT>init</TT>, and <TT>start</TT> methods all
to be invoked in that order. For convenience, this information
is summarized in Table 4.2.<BR>
<P>
<CENTER><B>Table 4.2. Applet method calls under Navigator and
Internet Explorer.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=175><I>What</I></TD><TD WIDTH=127><I>Navigator</I>
</TD><TD WIDTH=266><I>Internet Explorer</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=175>Page first loaded</TD><TD WIDTH=127><TT>init</TT> + <TT>start</TT>
</TD><TD WIDTH=266><TT>init</TT> + <TT>start</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=175>Forward then backward</TD><TD WIDTH=127><TT>stop</TT> + <TT>start</TT>
</TD><TD WIDTH=266><TT>stop</TT> + <TT>start</TT></TD></TR>
<TR VALIGN=TOP><TD WIDTH=175>Reload/Refresh</TD><TD WIDTH=127><TT>stop</TT> + <TT>start</TT>
</TD><TD WIDTH=266><TT>stop</TT> + <TT>destroy</TT> + <TT>init</TT> + <TT>start</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H4>An Example</H4>
<P>
The best way to understand how the <TT>init</TT>, <TT>start</TT>,
<TT>stop</TT>, and <TT>destroy</TT> methods interact is to build
an applet to demonstrate their use. Listing 4.1 shows a class
that does exactly this. The class <TT>EX04A</TT> includes a private
string member named <TT>history</TT> that is empty initially.
As the various methods are called, text is added to this string
to indicate the sequence in which the methods were called. Parentheses
are placed around the start and stop messages to improve readability.
<HR>
<BLOCKQUOTE>
<B>Listing 4.1. EX04A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04A extends Applet
{
    private String history = &quot;&quot;;


    public EX04A()
    {
    }

    public void init()
    {
        history = history + &quot;init &quot;;
        resize(320, 240);
    }

    public void start()
    {
        history = history + &quot;(start &quot;;
    }
    
    public void stop()
    {
        history = history + &quot;stop) &quot;;
    }

    public void destroy()
    {
        history = history + &quot;destroy &quot;;
    }

    public void paint(Graphics g)
    {
        g.drawString(history, 10, 10);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Even though the code in the <TT>destroy</TT> method of Listing 4.1 will execute, the results of adding this text will not be apparent. Because the <TT>history</TT> string is displayed only by the <TT>paint</TT> method and <TT>paint</TT> is not called after 
<TT>destroy</TT>, you will not be able to see the destroy message. You've got two options: Either trust me or run <TT>EX04A</TT> in the debugger after setting a breakpoint in <TT>destroy</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The result of a sample run of <TT>EX04A</TT> is shown in Figure
4.1. In this case, Netscape Navigator was used to run this applet.
After the applet was loaded, the Reload button was pressed repeatedly.
This had the effect of stopping and starting the applet each time,
as you can see in Figure 4.1. Closing Navigator will stop the
applet and then destroy it.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-1.gif"><B> Figure 4.1 : </B><I>Example of reloading an applet in Netscape Navigator.

</I></A><P>
<P>
Unlike Navigator, Microsoft Internet Explorer does not simply
stop and start an applet when refreshing a page. Figure 4.2 shows
Internet Explorer while running <TT>EX04A</TT> after the Refresh
button was pressed repeatedly. As you can see, only <TT>init</TT>
and <TT>start</TT> have been used. This is because Internet Explorer
completely reloads an applet when refreshing it. This causes the
<TT>history</TT> string to be reset each time the applet is reloaded.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-2.gif"><B> Figure 4.2 : </B><I>Example of reloading an applet in Microsoft  Intenet Explorer.

</I></A><P>
<H2><A NAME="EventHandling"><FONT SIZE=5 COLOR=#FF0000>
Event Handling</FONT></A></H2>
<P>
The Java Virtual Machine works by sending messages to Java applets
whenever specific events occur. For example, if the user presses
a key, a message named <TT>KEY_PRESS</TT> is passed to the applet.
If a Java applet wants to respond in a particular way to a message,
a <I>handler</I> for that message is written. The complete list
of Java messages follows:
<P>
<CENTER><I><B>Java messages</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>
<TR VALIGN=TOP><TD WIDTH=226>WINDOW_DESTROY</TD><TD WIDTH=210>MOUSE_DRAG
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>WINDOW_EXPOSE</TT></TD><TD WIDTH=210><TT>SCROLL_LINE_UP</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>WINDOW_ICONIFY</TT></TD><TD WIDTH=210><TT>SCROLL_LINE_DOWN</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>WINDOW_DEICONIFY</TT></TD><TD WIDTH=210><TT>SCROLL_PAGE_UP</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>WINDOW_MOVED</TT></TD><TD WIDTH=210><TT>SCROLL_PAGE_UP</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>KEY_PRESS</TT></TD><TD WIDTH=210><TT>SCROLL_ABSOLUTE</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>KEY_RELEASE</TT></TD><TD WIDTH=210><TT>LIST_SELECT</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>KEY_ACTION</TT></TD><TD WIDTH=210><TT>LIST_DESELECT</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>KEY_ACTION_RELEASE</TT></TD><TD WIDTH=210><TT>ACTION_EVENT</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>MOUSE_DOWN</TT></TD><TD WIDTH=210><TT>LOAD_FILE</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>MOUSE_UP</TT></TD><TD WIDTH=210><TT>SAVE_FILE</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>MOUSE_MOVE</TT></TD><TD WIDTH=210><TT>GOT_FOCUS</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>MOUSE_ENTER</TT></TD><TD WIDTH=210><TT>LOST_FOCUS</TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=226><TT>MOUSE_EXIT</TT></TD><TD WIDTH=210><TT>&nbsp;</TT>
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheComponentClass">
The Component Class</A></H3>
<P>
In Java, events are generated in response to a user's interaction
with the graphical user interface (GUI) of a program. As events
are generated, they are sent to the component in or over which
they occurred. The <TT>Component</TT> class is an abstract class,
so instances of it cannot be created directly. However, it serves
as the superclass for almost all parts of a program's user interface.
This allows events to be sent to the specific part of the user
interface that will be best able to interpret the message.
<P>
For example, if the user presses the mouse button down while the
mouse pointer is over a button, the <TT>MOUSE_DOWN</TT> event
is sent to the button object. This works because <TT>Button</TT>
is a subclass of <TT>Component</TT>. If the button object chooses
not to handle the event, it can be passed up to the object on
which the button is located, usually a <TT>Window</TT> or <TT>Dialog</TT>
object. That object will then have the option of handling the
event, ignoring it, or passing it up to a higher level. Figure
4.3 shows a class hierachy of the subclasses of <TT>Component</TT>,
which is a very active superclass.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-3.gif"><B> Figure 4.3 : </B><I>The descendants of Component.

</I></A><P>
<H3><A NAME="TheEventClass">
The Event Class </A></H3>
<P>
When an event occurs, it is passed to the event handling methods
of a component as an instance of the <TT>Event</TT> class. This
class is defined in the java.awt package. At the time the event
occurs, an instance of <TT>Event</TT> is created and member variables
are used to store information about the event and the state of
the system at the time. For example, if a <TT>KEY_PRESS</TT> event
occurs, it may be useful to know whether the Shift key was being
held down at the time. Similarly, when the mouse is clicked, it
is usually important to know the <I>x</I> and <I>y</I> coordinates
of the mouse pointer when the click occurred. All relevant information
about an event is stored in the member variables of the <TT>Event</TT>
class, as shown in Table 4.3.<BR>
<P>
<CENTER><B>Table 4.3. The member variables of Event.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=119><I>Member</I></TD><TD WIDTH=471><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>arg</TT></TD><TD WIDTH=471>Contains arbitrary, event-specific data.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>ClickCount</TT></TD><TD WIDTH=471>The number of consecutive mouse clicks. (For example, <TT>2</TT> indicates a double-click.)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>evt</TT></TD><TD WIDTH=471>The next event.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>Id</TT></TD><TD WIDTH=471>A number representing the type of event.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>Key</TT></TD><TD WIDTH=471>The key that was pressed if this is a keyboard event.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>Modifiers</TT></TD><TD WIDTH=471>Indicates the state of the modifier keys (Shift, Ctrl, and so on).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>Target</TT></TD><TD WIDTH=471>The target component for the event.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>When</TT></TD><TD WIDTH=471>The time at which the event occurred expressed in seconds since midnight January 1, 1970 (GMT).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>X</TT></TD><TD WIDTH=471>The <I>x</I> coordinate where the event occurred.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT>Y</TT></TD><TD WIDTH=471>The <I>y</I> coordinate where the event occurred.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In addition to the member variables shown in Table 4.3, the <TT>Event</TT>
class includes some public methods you will find useful in handling
events. These are shown in Table 4.4. Many of these public variables
and methods are described in detail and used in examples in the
following sections of this chapter where mouse and keyboard event
handling are covered.<BR>
<P>
<CENTER><B>Table 4.4. The public, nonconstructor member methods
of Event.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><I>Member</I></TD><TD WIDTH=385><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>boolean controlDown</TT></TD><TD WIDTH=385>Returns <TT>true</TT> if the Ctrl key was down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>boolean metaDown</TT></TD><TD WIDTH=385>Returns <TT>true</TT> if the meta key was down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>boolean shiftDown</TT></TD><TD WIDTH=385>Returns <TT>true</TT> if the Shift key was down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>String toString</TT></TD><TD WIDTH=385>Returns a formatted string showing information about the event, which can be useful for display while debugging.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>void translate</TT></TD><TD WIDTH=385>Translates the <I>x</I> and <I>y</I> coordinates of an event relative to a component.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="HandlingAnyEvent">
Handling Any Event</A></H3>
<P>
Java provides a single method, <TT>handleEvent</TT> in the <TT>java.awt.Component</TT>
class that can be used to process all events. This method is passed
an <TT>Event</TT> object that contains all of the information
necessary to handle the event. As an example, consider the code
for <TT>EX04B</TT>, shown in Listing 4.2.
<HR>
<BLOCKQUOTE>
<B>Listing 4.2. EX04B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04B extends Applet
{
    private int xPosStart=0, xPosEnd=0;
    private int yPosStart=0, yPosEnd=0;
    private boolean drawing = false;

    public void init()
    {
        resize(320, 240);
    }


    public void paint(Graphics g)
    {
        if (drawing)
            g.drawLine(xPosStart, yPosStart, xPosEnd, yPosEnd);
    }

    public boolean handleEvent(Event event) {
        boolean result;

        switch (event.id) {
        case Event.MOUSE_DOWN:
            drawing = true;
            xPosStart = event.x;
            yPosStart = event.y;
            xPosEnd   = xPosStart;
            yPosEnd   = yPosStart;
            repaint();
            result = true;
            break;
        case Event.MOUSE_UP:
            drawing = false;
            repaint();
            result = true;
            break;
        case Event.MOUSE_DRAG:
            xPosEnd = event.x;
            yPosEnd = event.y;
            repaint();
            result = true;
            break;
        default:
            result = super.handleEvent(event);
            break;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This example includes a <TT>handleEvent</TT> method that uses
a <TT>switch </TT>statement to act on the <TT>MOUSE_DOWN</TT>,
<TT>MOUSE_UP</TT>, and <TT>MOUSE_DRAG</TT> events. This applet
implements a very simple drawing program in which a line is drawn
from the location where the mouse button is pressed to the mouse
pointer's current location while the mouse is being dragged. When
the mouse button is released, the drawing stops.
<P>
When the <TT>MOUSE_DOWN</TT> event occurs, a private member variable,
<TT>drawing</TT>, is set to <TT>true </TT>to indicate that the
user wants to draw a line while the mouse button is held down.
The current location of the mouse pointer is retrieved from the
<TT>x</TT> and <TT>y</TT> members of <TT>event</TT> and stored
in private member variables. These will serve as the starting
and ending points for the line that the applet will draw.
<P>
The <TT>MOUSE_DRAG</TT> event is caught and also retrieves values
from <TT>event.x</TT> and <TT>event.y</TT>. This time, however,
these values indicate the end of the line being drawn. After being
stored, the <TT>repaint</TT> method is called to tell the applet
to redisplay itself. This causes the <TT>paint</TT> method to
be invoked. The <TT>paint</TT> method of <TT>EX04B </TT>is written
so that it will draw a line between the stored locations if the
value of <TT>drawing</TT> is <TT>true</TT>. Because <TT>drawing</TT>
was set to <TT>true</TT> when the mouse button was pushed down,
the line will be drawn and updated as long as the mouse button
remains depressed. This can be seen in Figure 4.4. When a <TT>MOUSE_UP</TT>
event is caught, it sets drawing to <TT>false</TT> to indicate
that the user is done drawing the line and then repaints the screen.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-4.gif"><B> Figure 4.4 : </B><I>The results of running EX04B.

</I></A><P>
<P>
You may have noticed in Listing 4.2 that <TT>handleEvent</TT>
is a <TT>boolean</TT> method. In order to indicate that the event
has been successfully dealt with, <TT>handleEvent</TT> must return
<TT>true</TT>. If an event is received that <TT>handleEvent</TT>
would prefer not to deal with, but would rather pass up to its
parent, <TT>false</TT> can be returned.
<H3><A NAME="EventHandlingfortheMouse">
Event Handling for the Mouse</A></H3>
<P>
While <TT>handleEvent</TT> provides a very flexible and powerful
way of catching and acting on Java events, it is sometimes tedious
to have to look inside the supplied <TT>Event</TT> object for
the necessary values. Because mouse and keyboard events are so
common, Java includes a simple set of methods customized for use
with these events. Mouse event handling is made simpler by the
methods listed in Table 4.5.<BR>
<P>
<CENTER><B>Table 4.5. Methods for handling mouse events directly.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=125><I>Member</I></TD><TD WIDTH=451><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseDown</TT></TD><TD WIDTH=451>Called when the mouse button is pressed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseDrag</TT></TD><TD WIDTH=451>Called when the mouse pointer is dragged while the button is held down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseEnter</TT></TD><TD WIDTH=451>Called for a component when the mouse pointer is moved over the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseExit</TT></TD><TD WIDTH=451>Called for a component when the mouse pointer moves off the component.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseMove</TT></TD><TD WIDTH=451>Called when the mouse pointer is moved while the button is not held down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=125><TT>mouseUp</TT></TD><TD WIDTH=451>Called when the mouse button is released.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The signature for each of these methods is the same. For example,
the signature for <TT>mouseDrag</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public boolean mouseDrag(Event evt, int x, int y)
</PRE>
</BLOCKQUOTE>
<P>
In handling a mouse event, the first thing a method usually looks
at is the location of the mouse pointer (as given by its x and
y coordinates) when the event occurred. Because these values are
so frequently used, they are passed directly to the mouse event-handling
methods. There is an additional advantage to using the event-specific
methods instead of the generic <TT>handleEvent</TT>. By using
these functions, you can reduce the clutter that is caused by
involving many case statements inside <TT>handleEvent</TT>.
<P>
As a simple example of how to use one of the mouse event methods,
consider the code for class <TT>EX04C</TT> in Listing 4.3. <TT>EX04C</TT>
is similar to <TT>EX04B</TT> in allowing the user to draw a line
on the screen. However, <TT>EX04C</TT> differs in a few small
ways:
<UL>
<LI><TT>EX04C</TT> uses point <TT>0,0</TT> as the start of each
line.
<LI>A line is always drawn by the <TT>paint</TT> method, even
if it is between <TT>0,0</TT> and <TT>0,0</TT>.
<LI>The line is not cleared when the mouse button is released.
</UL>
<HR>
<BLOCKQUOTE>
<B>Listing 4.3. EX04C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04C extends Applet
{
    private int xPos=0, yPos=0;

    public EX04C()
    {
    }

    public void init()
    {
        resize(320, 240);
    }

    public void paint(Graphics g)
    {
        g.drawLine(0, 0, xPos, yPos);
    }

    public boolean mouseDrag(Event evt, int x, int y)
    {
        xPos = x;
        yPos = y;
        repaint();
        return true;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Because of the simplifications to the applet, <TT>EX04C </TT>requires
only the use of the <TT>mouseDrag</TT> method. Similar to the
<TT>MOUSE_DRAG</TT> case of <TT>handleEvent</TT>, <TT>mouseDrag</TT>
stores the location of the mouse pointer and then repaints the
applet. Of course, because <TT>x</TT> and <TT>y</TT> have been
provided as parameters they are used directly instead of <TT>evt.x</TT>
and <TT>evt.y</TT>.
<P>
The simplifications of <TT>EX04C</TT> are removed in <TT>EX04D</TT>,
which is shown in Listing 4.4. In this case, <TT>mouseDown</TT>,
<TT>mouseUp</TT>, and <TT>mouseDrag</TT> are all used. The applet
will respond by drawing a line from the location where the mouse
button was pushed down, to its current location while the mouse
is dragged, and then remove the line once the mouse button is
released.
<HR>
<BLOCKQUOTE>
<B>Listing 4.4. EX04D.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04D extends Applet
{
    private int xPosStart=0, xPosEnd=0;
    private int yPosStart=0, yPosEnd=0;
    private boolean drawing = false;

    public EX04D()
    {
    }

    public void init()
    {
        resize(320, 240);
    }

    public void paint(Graphics g)
    {
        if (drawing)
            g.drawLine(xPosStart, yPosStart, xPosEnd, yPosEnd);
    }

    public boolean mouseDown(Event evt, int x, int y)
    {
        drawing = true;
        xPosStart = x;
        yPosStart = y;
        xPosEnd   = xPosStart;
        yPosEnd   = yPosStart;
        return true;
    }

    public boolean mouseUp(Event evt, int x, int y)
    {
        drawing = false;
        repaint();
        return true;
    }

    public boolean mouseDrag(Event evt, int x, int y)
    {
        xPosEnd = x;
        yPosEnd = y;
        repaint();

        return true;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="KeyboardEventHandling">
Keyboard Event Handling</A></H3>
<P>
Directly handling keyboard events is similar to handling mouse
events. Two methods, <TT>keyDown</TT> and <TT>keyUp</TT>, are
provided. These methods are summarized in Table 4.6. The signature
for each method is the same and is as follows:
<BLOCKQUOTE>
<PRE>
public boolean keyDown(Event evt, int key)<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 4.6. Methods for directly handling keyboard events.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=96><I>Member</I></TD><TD WIDTH=288><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>keyDown</TD><TD WIDTH=288>Called when a key is pressed down.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=96>keyUp</TD><TD WIDTH=288>Called when a key is released.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In addition to the keys that generate displayable characters,
Java supports the usual set of navigational and function keys.
The Event class defines values for the following special keys:
<P>
<CENTER><I><B>Values for Java keys</B></I></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>
<TR VALIGN=TOP><TD WIDTH=97><TT>HOME</TT></TD><TD WIDTH=108><CENTER><TT>RIGHT</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F7</TT></CENTER></TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>END</TT></TD><TD WIDTH=108><CENTER><TT>F1</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F8</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>PGUP</TT></TD><TD WIDTH=108><CENTER><TT>F2</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F9</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>PGDN</TT></TD><TD WIDTH=108><CENTER><TT>F3</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F10</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>UP</TT></TD><TD WIDTH=108><CENTER><TT>F4</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F11</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>DOWN</TT></TD><TD WIDTH=108><CENTER><TT>F5</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>F12</TT></CENTER>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=97><TT>LEFT</TT></TD><TD WIDTH=108><CENTER><TT>F6</TT></CENTER>
</TD><TD WIDTH=96><CENTER><TT>&nbsp;</TT></CENTER>
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Each of these values can be accessed through the <TT>event </TT>class.
For example, <TT>Event.LEFT</TT> represents the left arrow key
on the keyboard.
<H4>The Shift, Control, and Meta Modifiers </H4>
<P>
Sometimes a key is augmented by the use of shift, control, or
other modifiers. In Java you can distinguish between an unmodified
key and one combined with the Shift or Ctrl key.
<P>
Earlier in this chapter you learned that the <TT>Event</TT> class
contains a member named <TT>modifiers</TT>. When an event is generated,
<TT>modifiers</TT> holds the state of the Shift, Ctrl, and meta
keys. To discern the state of these keys, you can either look
directly at <TT>modifiers</TT> or you can use the provided utility
methods <TT>controlDown</TT>, <TT>shiftDown</TT>, and <TT>metaDown</TT>.
<H4>An Example of Keyboard Event Handling</H4>
<P>
As an example of keyboard event handling, consider class <TT>EX04E</TT>
in Listing 4.5. This example uses the <TT>keyDown</TT> method
to trap for the up, down, left arrow, and the alphabetic (upper-
and lowercase) keys.
<HR>
<BLOCKQUOTE>
<B>Listing 4.5. EX04E.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04E extends Applet
{
    int    yRow = 1;

    public void init()
    {
        resize(320, 240);
    }

    public void paint(Graphics g)
    {
    }

    public boolean keyDown(Event event, int key) {
        boolean result = false;

        Graphics g = getGraphics();

        switch(key) {
        case Event.UP:
            g.drawString(&quot;the up key&quot;, 10, yRow++ * 10);
            result = true;
            break;
        case Event.DOWN:
            g.drawString(&quot;the down key&quot;, 10, yRow++ * 10);
            result = true;
            break;
        case Event.LEFT:
            StringBuffer str = new StringBuffer(&quot;you pressed: &quot;);
            if (event.controlDown())
                str.append(&quot;control + &quot;);
            if (event.shiftDown())
                str.append(&quot;shift + &quot;);

            str.append(&quot;left&quot;);
            
            g.drawString(str.toString(), 10, yRow++ * 10);
            result = true;
            break;
        default:
            if((key &gt;= 65 &amp;&amp; key &lt;= 90) ||          // upper case
                    (key &gt;= 97 &amp;&amp; key &lt;= 122)) {    // lower case
                Character ch = new Character((char)key);
                g.drawString(ch.toString(), 10, yRow++ * 10);
                result = true;
            }
            break;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this example, the applet will write a message to the display
describing the key that is pressed. Class <TT>EX04E</TT> starts
by defining a member variable, <TT>yRow</TT>, that will be used
to keep track of the number of rows written so that each call
to <TT>g.drawString</TT> can write at a higher y coordinate, so
the messages appear to move down the applet's window. This can
be seen in Figure 4.5, which was created after several keys had
been pressed. Before the applet window will receive the keypress
messages, the browser window needs to have focus. Click the mouse
while the pointer is over the applet area.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-5.gif"><B> Figure 4.5 : </B><I>The results of running EX04E.

</I></A><P>
<P>
In the <TT>keyDown</TT> method of <TT>EX04E</TT>, a <TT>switch</TT>
statement is used to distinguish between the keys. If the up or
down arrow is pressed, a simple message is displayed on the screen.
However, if the left arrow is pressed, the applet uses the <TT>controlDown</TT>
and <TT>shiftDown</TT> methods to determine which keys were down
when the left arrow key was pressed. A string is created to display
the modifier information and then the string is displayed.
<P>
In the default case, the value of <TT>key</TT> is checked. If
the key is an upper- or lowercase letter, the key is converted
from an integer and displayed.
<H2><A NAME="UsingAppletParameters"><FONT SIZE=5 COLOR=#FF0000>
Using Applet Parameters</FONT></A></H2>
<P>
In the traditional, non-Java programming world, it is common to
write a program that uses command-line parameters to modify its
behavior. For example, the grep program searches for string patterns
in files. To search for <TT>java.awt</TT> in all files with a
Java extension, you would use the following command line:
<BLOCKQUOTE>
<PRE>
grep java.awt *.java
</PRE>
</BLOCKQUOTE>
<P>
Without command-line parameters, the grep program would be useless
because it wouldn't know either the pattern to look for or the
files to search. Because Java applets are not run from a command
line, as is grep, an applet cannot be passed a parameter in this
fashion. However, a Java applet is embedded in a host HTML file,
and parameters to the applet can be embedded in the HTML file.
<H3><A NAME="EmbeddingParametersinHTML">
Embedding Parameters in HTML</A></H3>
<P>
To embed a parameter in a host HTML document you use the <TT>&lt;param
name&gt;</TT> tag. For each parameter you create with this tag,
you specify a name and a value. For example, Listing 4.6 is the
host HTML file for <TT>EX04F</TT>. It describes three parameters:
<TT>message</TT>, <TT>xPos</TT>, and <TT>yPos</TT>. The <TT>message</TT>
parameter will be displayed in the browser window by the applet
and is set to <TT>&quot;Hello, World&quot;</TT>. The <TT>xPos</TT>
and <TT>yPos</TT> parameters indicate the coordinates at which
the message will be displayed.
<HR>
<BLOCKQUOTE>
<B>Listing 4.6. EX04F.html.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;EX04F&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;hr&gt;
&lt;applet
    code=EX04F.class
    id=EX04F
    width=320
    height=240 &gt;
    &lt;param name=message value=&quot;Hello, World&quot;&gt;
    &lt;param name=xPos value=30&gt;
    &lt;param name=yPos value=40&gt;
&lt;/applet&gt;
&lt;hr&gt;
&lt;a href=&quot;EX04F.java&quot;&gt;The source.&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ReadingAppletParameters">
Reading Applet Parameters</A></H3>
<P>
An applet can read parameters from its host HTML file by using
the <TT>getParameter</TT> method of the <TT>Applet</TT> class.
The signature of <TT>getParameter</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public String getParameter(String name)
</PRE>
</BLOCKQUOTE>
<P>
The <TT>getParameter</TT> method is passed the name of the parameter
to read, and it returns the value of that parameter as a string.
Although all parameters are read as string values, they can easily
be converted to integers or any other more appropriate data type.
This is illustrated in Listing 4.7, which shows the class <TT>EX04F</TT>.
This applet reads the message, <TT>xPos</TT>, and <TT>yPos</TT>
parameters that were embedded in the HTML file of Listing 4.6.
An example of running this applet is shown in Figure 4.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-6.gif"><B> Figure 4.6 : </B><I>EX04F displays a parameter from its host HTML file.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 4.7. EX04F.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;

public class EX04F extends Applet
{
    private String message = &quot;&quot;;
    private int xPos = 10;
    private int yPos = 10;

    public void init()
    {
        String param;

        param = getParameter(&quot;message&quot;);
        if (param != null)
            message = param;

        param = getParameter(&quot;xPos&quot;);
        if (param != null)
            xPos = Integer.parseInt(param);

        param = getParameter(&quot;yPos&quot;);
        if (param != null)
            yPos = Integer.parseInt(param);

        resize(320, 240);
    }

    public void paint(Graphics g)
    {
        g.drawString(message, xPos, yPos);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
You can use the Applet Wizard to simplify the use of parameters. The fourth step of the Applet Wizard lets you enter parameter names, types, and default values. When the wizard generates the applet, it will generate class member variables to hold the 
parameter values and will place code in the <TT>init</TT> method to retrieve the values
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="WorkingwithURLsandGraphics"><FONT SIZE=5 COLOR=#FF0000>
Working with URLs and Graphics</FONT></A></H2>
<P>
One of the most common things for a Web page to do is display
a graphic. Because of this, the <TT>Applet</TT> class includes
a method for retrieving an image from a URL (a Uniform Resource
Locator, the way in which files are addressed on the Internet).
The signature for <TT>getImage</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public Image getImage(URL url)
</PRE>
</BLOCKQUOTE>
<H3><A NAME="AccessingaURL">
Accessing a URL</A></H3>
<P>
Because <TT>getImage</TT> loads an image from a URL, you must
first create an instance of a URL. This can be done by using the
following URL constructor:
<BLOCKQUOTE>
<PRE>
public URL(String spec) throws MalformedURLException
</PRE>
</BLOCKQUOTE>
<P>
This constructor is simply passed to the URL as a string, as in
the following example:
<BLOCKQUOTE>
<PRE>
myURL = new URL(&quot;http://mtngoat/java/test.jpg&quot;);
</PRE>
</BLOCKQUOTE>
<P>
However, because the constructor can throw a <TT>MalformedURLException</TT>
exception, the constructor must be enclosed in a <TT>try...catch</TT>
block that catches the exception. This could be done as follows:
<BLOCKQUOTE>
<PRE>
try {
    myURL = new URL(&quot;http://mtngoat/java/test.jpg&quot;);
}
catch (MalformedURLException e) {
    // handle error
}
</PRE>
</BLOCKQUOTE>
<H3><A NAME="AnExampleofDisplayinganImage">
An Example of Displaying an Image </A></H3>
<P>
The <TT>getImage</TT> method retrieves an image from a URL but
does not display it. To display the retrieved image, use the <TT>Graphics.drawImage</TT>
method in the <TT>paint</TT> method of the applet. This can be
seen in <TT>EX04G</TT>, which is shown in Listing 4.8.
<HR>
<BLOCKQUOTE>
<B>Listing 4.8. EX04G.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.net.*;


public class EX04G extends Applet
{
    private Image m_image;
    private URL m_URL;
    private String error = &quot;&quot;;

    public void init()
    {
        resize(600, 440);

        try {
          m_URL = new 
            URL(&quot;http://spider.innercite.com/~lcohn/savannah.jpg&quot;);
          m_image = getImage(m_URL);        
        }
        catch (MalformedURLException e) {
          error = &quot;Image is unavailable.&quot;;
        }
    }

    public void paint(Graphics g)
    {
        g.drawString(&quot;Here's a cute baby:&quot;, 10,10);

        if (error.length() == 0)
            g.drawImage(m_image, 10, 30, this);
        else
            g.drawString(error, 20, 30);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This example creates a <TT>URL</TT> object and then uses that
object as a parameter to <TT>getImage</TT>. If an exception occurs,
the image is not loaded but an error message is formatted. The
<TT>paint</TT> method displays a string above the image and then
displays either the image or the error message. The results of
running this applet can be seen in Figure 4.7.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f4-7.gif"><B> Figure 4.7 : </B><I>Displaying a graphic  loaded from a URL.

</I></A><P>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter covered a lot of ground. You learned how an applet's
<TT>init</TT>, <TT>start</TT>, <TT>stop</TT>, and <TT>destroy</TT>
methods are executed over the life of an applet. Because understanding
event handling is critical to applet development, this chapter
presented numerous examples of how to handle events. You learned
about generic event handling with the <TT>handleEvent</TT> method
as well as how to handle events with mouse- and keyboard-specific
methods. This chapter also demonstrated how to customize the behavior
of an applet by using applet parameters embedded in the host HTML
file. Finally, you got a quick introduction into loading a graphics
resource from a URL and displaying it in an applet. In the next
chapter, you will turn your attention to enhancing applets by
using windows and dialogs.
<HR>

<CENTER><P><A HREF="ch3.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch5.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>