<HTML>
<HEAD>
<TITLE>Chapter 11 - The Java Utility Classes</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;11</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>The Java Utility Classes</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheBitSetClass">
The BitSet Class</A>
<UL>
<LI><A HREF="#AnExample1">
An Example</A>
</UL>
<LI><A HREF="#TheDateClass">
The Date Class</A>
<LI><A HREF="#TheHashtableClass">
The Hashtable Class</A>
<LI><A HREF="#ThePropertiesClass">
The Properties Class</A>
<LI><A HREF="#TheRandomClass">
The Random Class</A>
<LI><A HREF="#ObserversandObservables">
Observers and Observables</A>
<UL>
<LI><A HREF="#TheObservableClass">
The Observable Class</A>
<LI><A HREF="#TheObserverInterface">
The Observer Interface</A>
<LI><A HREF="#AnExample2">
An Example</A>
</UL>
<LI><A HREF="#TheVectorClass">
The Vector Class</A>
<LI><A HREF="#TheStackClass">
The Stack Class</A>
<LI><A HREF="#TheStringTokenizerClass">
The StringTokenizer Class</A>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In this chapter you learn about the java.util package. This package
provides some of the most useful Java classes that you will come
to rely on. It introduces the following nonabstract classes:
<BLOCKQUOTE>
<TT>BitSet<BR>
Date<BR>
Hashtable<BR>
Properties<BR>
Observable<BR>
Random<BR>
Vector<BR>
Stack<BR>
StringTokenizer</TT>
</BLOCKQUOTE>
<P>
The <TT>BitSet</TT> class is useful for storing and manipulating
arbitrarily long sets of bits. The <TT>Date</TT> class can be
used to represent dates and times, and provides methods for converting
dates to and from strings. The <TT>Hashtable</TT> class can be
used for creating an array of keys and values and allowing elements
to be looked up by either key or value. The <TT>Properties</TT>
class extends <TT>Hashtable</TT> by allowing elements to be streamed
into or out of the class. The <TT>Observable</TT> class can be
extended, and enables you to create new classes that will notify
other classes when they change. It works in conjunction with the
<TT>Observer</TT> interface, which is also part of the <TT>java.util</TT>
package.
<P>
The <TT>Random</TT> class is a pseudo-random number generator
that can return integer, floating-point, or Gaussian-distributed
values. The <TT>Stack</TT> class is an extension of <TT>Vector</TT>
and supplies a last-in-first-out (LIFO) data structure. The <TT>Vector</TT>
class can be used for storing any objects and can store objects
of more than one type in the same vector. The <TT>StringTokenizer</TT>
class provides a flexible mechanism for parsing strings.
<H2><A NAME="TheBitSetClass"><FONT SIZE=5 COLOR=#FF0000>
The BitSet Class</FONT></A></H2>
<P>
The <TT>BitSet</TT> class represents a dynamically sized set of
bits. Two constructors are provided, one that creates an empty
set of unspecified size and one that creates a set of a specified
size. The <TT>set</TT> method can be used to set an individual
bit or <TT>clear</TT> can be used to clear an individual bit.
The first bit in a <TT>BitSet</TT> is the zero bit so that <TT>myBitset.set(0)</TT>
is a valid statement.
<P>
The logical functions <TT>and</TT>, <TT>or</TT>, and <TT>xor</TT>
are all supported and will combine the <TT>BitSet</TT> with another
set. <TT>BitSet</TT>s can be compared for equality using <TT>equals</TT>
and can be converted to strings using <TT>toString</TT>. For the
purpose of converting a <TT>BitSet</TT> to a string, a set bit
is represented by the value 1 and a clear bit is represented by
0.
<P>
The available constructor and nonprivate methods for <TT>BitSet</TT>
are shown in Table 11.1.<BR>
<P>
<CENTER><B>Table 11.1. Public constructors and methods of BitSet.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Member</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>BitSet()</TT></TD><TD WIDTH=384>Constructs an empty bit set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>BitSet(int)</TT></TD><TD WIDTH=384>Constructs an empty bit set with the specified number of bits.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>And(BitSet)</TT></TD><TD WIDTH=384>Logically <TT>AND</TT>s two bit sets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Clear(int)</TT></TD><TD WIDTH=384>Clears the specified bit.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Clone()</TT></TD><TD WIDTH=384>Creates a duplicate copy of the <TT>BitSet</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Equals(Object)</TT></TD><TD WIDTH=384>Returns <TT>true</TT> if two <TT>BitSet</TT>s are equal.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Get(int)</TT></TD><TD WIDTH=384>Returns the value of the specified bit.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>HashCode()</TT></TD><TD WIDTH=384>Returns a hash code for the bit set.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Or(BitSet)</TT></TD><TD WIDTH=384>Logically <TT>OR</TT>s two bit sets.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Set(int)</TT></TD><TD WIDTH=384>Sets the specified bit.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Size()</TT></TD><TD WIDTH=384>Returns the size of the bit set in bits.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToString()</TT></TD><TD WIDTH=384>Formats the <TT>BitSet</TT> as a string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Xor(BitSet)</TT></TD><TD WIDTH=384>Logically <TT>XOR</TT>s two bit sets.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="AnExample1">
An Example</A></H3>
<P>
As an example of how to use <TT>BitSet</TT> consider class <TT>EX11A</TT>,
shown in Listing 11.1. In this example, the method <TT>BitSetTest</TT>
is invoked as the result of the user pressing a button. As various
operations on <TT>BitSet</TT>s are performed, a <TT>TextArea</TT>
is updated to display the results of the operations.
<HR>
<BLOCKQUOTE>
<B>Listing 11.1. EX11A.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11A extends Applet
{
    TextArea results = new TextArea(10, 20);

    public void init()
    {

        add(new Button(&quot;Start&quot;));
        add(results);

        resize(320, 240);
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Start&quot;.equals(obj)) {
            BitSetTest();
            result = true;
        }
        return result;
    }

    void BitSetTest()
    {
        // create a BitSet and set items 1 and 4
        BitSet bits1 = new BitSet(10);
        bits1.set(1);
        bits1.set(4);

        // create a BitSet and set items 4 and 5
        BitSet bits2 = new BitSet(10);
        bits2.set(4);
        bits2.set(5);

        // display the contents of these two BitSets
        results.appendText(&quot;Bits 1=&quot; + bits1.toString() + &quot;\r\n&quot;);
        results.appendText(&quot;Bits 2=&quot; + bits2.toString() + &quot;\r\n&quot;);

        // test for equality of the two BitSets
        if(bits1.equals(bits2))
            results.appendText(&quot;bits1 == bits2\r\n&quot;);
        else
            results.appendText(&quot;bits1 != bits2\r\n&quot;);

        // create a clone and then test for equality
        BitSet clonedBits = (BitSet)bits1.clone();
        if(bits1.equals(clonedBits))
            results.appendText(&quot;bits1 == clonedBits\r\n&quot;);
        else
            results.appendText(&quot;bits1 != clonedBits\r\n&quot;);

        // logically AND the first two BitSets 
        bits1.and(bits2);
        results.appendText(&quot;ANDing bits1 and bits2\r\n&quot;);
        // and display the resulting BitSet
        results.appendText(&quot;bits1=&quot; + bits1.toString() + &quot;\r\n&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In the <TT>BitSetTest</TT> method, two <TT>BitSet</TT>s are constructed.
The first, <TT>bits1</TT>, has bits 1 and 4 set. The second, <TT>bits2</TT>,
has bits 4 and 5 set. The <TT>toString</TT> method is used to
display the contents of the <TT>BitSet</TT>s. The <TT>BitSet</TT>s
are then compared using <TT>equals</TT>. Next, a clone of <TT>bits1</TT>
is created. To show that the <TT>clone</TT> method was successful,
the <TT>BitSet</TT>s are compared and a message is displayed.
Finally, the <TT>and</TT> method is used to logically <TT>AND</TT>
two <TT>BitSet</TT>s and the result is displayed using <TT>toString</TT>.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Because the <TT>BitSet</TT> class is contained in the package java.util, be sure to import java.util, as done on the third line of Listing 11.1
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheDateClass"><FONT SIZE=5 COLOR=#FF0000>
The Date Class</FONT></A></H2>
<P>
The <TT>Date</TT> class stores a representation of a date and
time, and provides methods for manipulating the date and time
components. As summarized in Table 11.2, constructors are provided
that will create a new <TT>Date</TT> instance based on the current
date and time, the number of milliseconds since midnight on January
1, 1970, a string, or from integers representing the year, month,
day, hours, minutes, and seconds.<BR>
<P>
<CENTER><B>Table 11.2. Constructors for the Date class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=398><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date()</TT></TD><TD WIDTH=398>Creates a <TT>Date</TT> using today's date.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date(long)</TT></TD><TD WIDTH=398>Creates a <TT>Date</TT> using the specified number of milliseconds since January 1, 1970.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date(int,int,int)</TT></TD><TD WIDTH=398>Creates a <TT>Date</TT> using the specified year, month, and day.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date(int,int,int,int,<BR>int)</TT></TD><TD WIDTH=398>Creates a <TT>Date</TT> using the specified year, month, day, hours, and minutes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date(int,int,int,int,<BR>int,int)</TT></TD>
<TD WIDTH=398>Creates a <TT>Date</TT> using the specified year, month, day, hours, minutes, and seconds.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Date(String)</TT></TD><TD WIDTH=398>Creates a <TT>Date</TT> using the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As examples of how these constructors can be used to create new
<TT>Date</TT> objects, consider the following:
<BLOCKQUOTE>
<PRE>
Date date1 = new Date(); 
Date date2 = new Date(95, 10, 14);
Date date3 = new Date(95, 10, 14, 13, 16, 45);
Date date4 = new Date(&quot;14 November 1995 13:16:45&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In this case, <TT>date1</TT> will be set to the current date and
time. The <TT>date2</TT> variable will be set to November 14,
1995. Months are zero-based in the <TT>Date</TT> class, so 10
is passed as a parameter to indicate the eleventh month. The third
example adds more exactness to the second example. While <TT>date2</TT>
will represent the stroke of midnight on November 14, 1995, <TT>date3</TT>
is explicitly set to 13:16: 45 (45 seconds after 1:16 p.m.). Finally,
<TT>date4</TT> creates the same time as <TT>date3</TT>, but does
so from a string.
<P>
Many methods are also provided for manipulating <TT>Date</TT>
instances. For example, dates can be compared with the <TT>before</TT>,
<TT>after</TT>, and <TT>equals</TT> methods. Methods are also
provided for converting a <TT>Date</TT> into various formatted
strings. The nonprivate instance methods of the <TT>Date</TT>
class are shown in Table 11.3.<BR>
<P>
<CENTER><B>Table 11.3. Nonprivate instance methods of the Date
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>after(Date)</TT></TD><TD WIDTH=384>Returns true if the <TT>Date</TT> occurs after the specified <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Before(Date)</TT></TD><TD WIDTH=384>Returns true if the <TT>Date</TT> occurs before the specified <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Equals(Object)</TT></TD><TD WIDTH=384>Returns true if two <TT>Date</TT>s are equal.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetDate()</TT></TD><TD WIDTH=384>Returns the day (1-31) portion of the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetDay()</TT></TD><TD WIDTH=384>Returns the day of the week (Sunday is 0)indicated by the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetHours()</TT></TD><TD WIDTH=384>Returns the hours (0-23) portion of the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetMinutes()</TT></TD><TD WIDTH=384>Returns the minutes (0-59) portion of the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetMonth()</TT></TD><TD WIDTH=384>Returns the month (0-11) portion of the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetSeconds()</TT></TD><TD WIDTH=384>Returns the seconds (0-59) portion of the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetTime()</TT></TD><TD WIDTH=384>Returns the number of milliseconds since midnight on January 1, 1970.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetTimezoneOffset()</TT></TD><TD WIDTH=384>Returns the offset in minutes for the current timezone from UTC (Coordinated Universal Time, similar to GMT, Greenwich Mean Time).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>GetYear()</TT></TD><TD WIDTH=384>Returns the year after 1900.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>HashCode()</TT></TD><TD WIDTH=384>Returns a hash code for the <TT>Date</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetDate(int)</TT></TD><TD WIDTH=384>Sets the day of the month.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetHours(int)</TT></TD><TD WIDTH=384>Sets the hours.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetMinutes(int)</TT></TD><TD WIDTH=384>Sets the minutes.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetMonth(int)</TT></TD><TD WIDTH=384>Sets the month.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetSeconds(int)</TT></TD><TD WIDTH=384>Sets the seconds.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetTime(long)</TT></TD><TD WIDTH=384>Sets the time to the specified number of milliseconds since midnight January 1, 1970.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetYear(int)</TT></TD><TD WIDTH=384>Sets the year after 1900.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToGMTString()</TT></TD><TD WIDTH=384>Returns a formatted string of the <TT>Date</TT> in the GMT time zone.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToLocaleString()</TT></TD><TD WIDTH=384>Returns a formatted string of the <TT>Date</TT> in the current time zone.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToString()</TT></TD><TD WIDTH=384>Returns a formatted string of the <TT>Date</TT> including the day of the week.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In addition to the instance methods shown in Table 11.3, the <TT>Date</TT>
class includes two static methods. Static methods can be invoked
without an instance of the class. The static methods of the <TT>Date</TT>
class can be used to determine the number of seconds since midnight
on January 1, 1970 based on a string or integer values representing
the date and time. These are summarized in Table 11.4;  examples
of their use are as follows:
<BLOCKQUOTE>
<PRE>
long temp = Date.parse(&quot;14 November 1996&quot;);
Date date1 = new Date(temp);
temp = Date.UTC(96, 10, 14, 13, 16, 45);
Date date2 = new Date(temp);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 11.4. Static methods of the Date class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>UTC(int,int,int,int,<BR>int,int)</TT></TD><TD WIDTH=384>Returns the milliseconds since midnight January 1, 1970 based on the year, month, day, hours, minutes, and seconds parameters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Parse(String)</TT></TD><TD WIDTH=384>Returns the milliseconds since midnight January 1, 1970 based on parsing the supplied string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of the use of the Date class, consider example EX11B,
as shown in Listing 11.2. The init method of this class displays
a TextArea and then creates a Date object based on the current
date. The toString, toLocaleString, and toGMTString methods are
used to display the current date in various formats. An instance
named BastilleDay is then constructed using the date of that holiday.
Next, the year value for BastilleDay is set to the current year
using the setYear and getYear methods. Finally, after is used
to determine whether Bastille Day has already occurred this year,
or if there is still time to shop for presents for your French
friends. The results of executing this class are shown in Figure
11.1.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-1.gif"><B> Figure 11.1 : </B><I>The results of executing EX11B after Bastille Day.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 11.2. EX11B.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11B extends Applet
{
    TextArea results = new TextArea(10, 50);

    public void init()
    {
        add(results);

        Date today = new Date(); // today

        // display the current date in a couple of different formats
        results.appendText(&quot;Today is:&quot; + today.toString() + &quot;\r\n&quot;);
        results.appendText(&quot;Locale Time:&quot; + today.toLocaleString() + &quot;\r\n&quot;);
        results.appendText(&quot;GMT:&quot; + today.toGMTString() + &quot;\r\n&quot;);

        // store Bastille Day (July 14th) in an instance
        Date BastilleDay = new Date(96, 6, 14);    // 7-14-96

        // set Bastille Day to be in the current year
        BastilleDay.setYear(today.getYear());

        // see if we've already missed Bastille Day
        if (today.after(BastilleDay))
            results.appendText(&quot;You missed Bastille Day!\r\n&quot;);
        else
            results.appendText(&quot;Bastille Day is coming!\r\n&quot;);

        resize(320, 240);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheHashtableClass"><FONT SIZE=5 COLOR=#FF0000>
The Hashtable Class</FONT></A></H2>
<P>
The <TT>Hashtable</TT> class extends the abstract <TT>Dictionary</TT>
class that is also defined in the java.util package. A <TT>Hashtable</TT>
is used for mapping keys to values. For example, it could be used
to map names to ages, programmers to projects, job titles to salaries,
and so on.
<P>
A <TT>Hashtable</TT> will expand in size as elements are added
to it. When creating a new <TT>Hashtable</TT> you can specify
an initial capacity and a load factor. The <TT>Hashtable</TT>
will increase in size whenever adding a new element would move
the <TT>Hashtable</TT> past its threshold. A <TT>Hashtable</TT>'s
threshold is its capacity multiplied by its load factor. For example,
a <TT>Hashtable</TT> with a capacity of 100 and a load factor
of 0.75 would have a threshold of 75 items. The constructors for
<TT>Hashtable</TT> are shown in Table 11.5.<BR>
<P>
<CENTER><B>Table 11.5. Constructors for the Hashtable class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Hashtable(int)</TT></TD><TD WIDTH=384>Constructs a new <TT>Hashtable</TT> with the specified initial capacity.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Hashtable(int, float)</TT></TD><TD WIDTH=384>Constructs a new <TT>Hashtable</TT> with the specified initial capacity and load factor.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Hashtable()</TT></TD><TD WIDTH=384>Constructs a new <TT>Hashtable</TT> using default values for initial capacity and load factor.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of how to construct a new <TT>Hashtable</TT>, consider
the following:
<BLOCKQUOTE>
<PRE>
Hashtable hash1 = new Hashtable(500, .80);
</PRE>
</BLOCKQUOTE>
<P>
In this case a <TT>Hashtable</TT> is constructed that will hold
500 elements. When the <TT>Hashtable</TT> becomes 80 percent full
(a load factor of .80), its maximum size will be increased.
<P>
Each element in a <TT>Hashtable</TT> consists of a key and value.
Elements are added to a <TT>Hashtable</TT> using the <TT>put</TT>
method and are retrieved using <TT>get</TT>. Elements may be deleted
from a <TT>Hashtable</TT> with <TT>remove</TT>. The <TT>contains</TT>
and <TT>containsKey</TT> methods can be used to look up a value
or key in the <TT>Hashtable</TT>. These and other <TT>Hashtable</TT>
methods are summarized in Table 11.6.<BR>
<P>
<CENTER><B>Table 11.6. Nonprivate methods of the Hashtable class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>clear()</TT></TD><TD WIDTH=384>Removes all elements from the <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>clone()</TT></TD><TD WIDTH=384>Creates a clone of the <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>contains(Object)</TT></TD><TD WIDTH=384>Returns true if the <TT>Hashtable</TT> contains the specified object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>containsKey(Object)</TT></TD><TD WIDTH=384>Returns true if the <TT>Hashtable</TT> contains the specified key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>elements()</TT></TD><TD WIDTH=384>Returns an enumeration of the elements in the <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>get(Object)</TT></TD><TD WIDTH=384>Retrieves the object associated with the specified key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>isEmpty()</TT></TD><TD WIDTH=384>Returns true if the <TT>Hashtable</TT> is empty.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>keys()</TT></TD><TD WIDTH=384>Returns an enumeration of the keys in the <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>put(Object, Object)</TT></TD><TD WIDTH=384>Adds a new element to the <TT>Hashtable</TT> using the specified key and value.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>rehash()</TT></TD><TD WIDTH=384>Rehashes the <TT>Hashtable</TT> into a larger <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>remove(Object)</TT></TD><TD WIDTH=384>Removes the object given by the specified key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>size()</TT></TD><TD WIDTH=384>Returns the number of elements in the <TT>Hashtable</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>toString()</TT></TD><TD WIDTH=384>Returns a formatted string representing the <TT>Hashtable</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Class <TT>EX11C</TT>, shown in Listing 11.3, demonstrates how
to use the <TT>Hashtable</TT> class. In this example a new <TT>Hashtable</TT>,
<TT>ht</TT>, is constructed and is used to store the five best
albums released by Pink Floyd. The <TT>Hashtable</TT> is displayed
to a <TT>TextArea</TT> using <TT>toString</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 11.3. EX11C.java.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11C extends Applet
{
    TextArea results = new TextArea(10, 75);

    public void init()
    {
        add(results);

        // create a new Hashtable
        Hashtable ht = new Hashtable();

        // add Pink Floyd's best albums
        ht.put(&quot;Pulse&quot;, new Integer(1995));
        ht.put(&quot;Dark Side of the Moon&quot;, new Integer(1973));
        ht.put(&quot;Wish You Were Here&quot;, new Integer(1975));
        ht.put(&quot;Animals&quot;, new Integer(1977));
        ht.put(&quot;Ummagumma&quot;, new Integer(1969));

        // display the Hashtable
        results.appendText(&quot;Initailly: &quot;+ht.toString() + &quot;\r\n&quot;);

        // test for any album from 1969
        if (ht.contains(new Integer(1969)))
            results.appendText(&quot;An album from 1969 exists\r\n&quot;);

        // test for the Animals album
        if (ht.containsKey(&quot;Animals&quot;))
            results.appendText(&quot;Animals was found\r\n&quot;);

        // find out what year Wish You Were Here was released
        Integer year = (Integer)ht.get(&quot;Wish You Were Here&quot;);
        results.appendText(&quot;Wish You Were Here was released in &quot; +
                year.toString() + &quot;\r\n&quot;);

        // remove an album
        results.appendText(&quot;Removing Ummagumma\r\n&quot;);
        ht.remove(&quot;Ummagumma&quot;);

        // move through an enumeration of all keys in the table
        results.appendText(&quot;Remaining:\r\n&quot;);
        for (Enumeration enum=ht.keys(); enum.hasMoreElements() ;)
            results.appendText((String)enum.nextElement()+&quot;\r\n&quot;);

        // and resize the applet window
        resize(500, 240);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
In this <TT>Hashtable</TT>, the names of the albums are the keys
and the years are the elements. Therefore, <TT>contains</TT> is
used to look up the integer element 1969 to see whether the list
contains any albums from 1969. Similarly, <TT>containsKey</TT>
is used to search for the key <TT>&quot;Animals&quot;</TT> to
see if that album made the list. Next, the <TT>get</TT> method
is used to see whether <TT>&quot;Wish You Were Here&quot;</TT>
is in the <TT>Hashtable</TT>. Because <TT>get</TT> returns the
element associated with the key, both the name and year are displayed
at this point. This can be seen in Figure 11.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-2.gif"><B> Figure 11.2 : </B><I>The results of executing EX11C.

</I></A><P>
<P>
Next, I had some second thoughts about including &quot;Ummagumma&quot;
in a list of best albums and used <TT>remove</TT> to delete it
from the <TT>Hashtable</TT>. Finally, the <TT>keys</TT> method
is used to create an Enumeration of the keys stored in the <TT>Hashtable</TT>.
The applet then iterates through the enumeration using <TT>enum.hasMoreElements</TT>
and <TT>enum.nextElement</TT>.
<H2><A NAME="ThePropertiesClass"><FONT SIZE=5 COLOR=#FF0000>
The Properties Class</FONT></A></H2>
<P>
The <TT>Properties</TT> class extends <TT>Hashtable</TT> and adds
the capability to read and write a <TT>Hashtable</TT> to a stream.
Because an applet cannot access files, the <TT>Properties</TT>
class is useful only for applications.
<P>
Like <TT>Hashtable</TT>, this class can be used to store keys
and associated values. Through its <TT>save</TT> and <TT>load</TT>
methods, <TT>Properties</TT> can be written to disk. This makes
this class an excellent mechanism for storing configuration information
between runs of a program. An example of a <TT>Properties</TT>
file written by the <TT>save</TT> method is as follows:
<BLOCKQUOTE>
<PRE>
#This is a header comment
#Sat Sep 14 15:55:15 Pacific Daylight Time 1996
prop3=put three
prop2=put two
prop1=put one
</PRE>
</BLOCKQUOTE>
<P>
Because <TT>Properties</TT> is a subclass of <TT>Hashtable</TT>,
new key/value pairs are added using the <TT>put</TT> method of
<TT>Hashtable</TT>. The constructors and nonprivate methods of
<TT>Properties</TT> are shown in Table 11.7.<BR>
<P>
<CENTER><B>Table 11.7. Nonprivate constructors and methods of
Properties class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=210><I>Member</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>Properties()</TT></TD><TD WIDTH=384>Creates a new <TT>Properties</TT> object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>Properties(Properties)</TT></TD><TD WIDTH=384>Creates a new <TT>Properties</TT> object based on the specified default values.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>GetProperty(String)</TT></TD><TD WIDTH=384>Returns the property value associated with the specified key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>GetProperty(String,String)</TT></TD><TD WIDTH=384>Returns the property value associated with the specified key. If the key is not found, the specified default is returned.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>List(PrintStream)</TT></TD><TD WIDTH=384>Lists all of the properties to the specified <TT>PrintStream</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>Load(InputStream)</TT></TD><TD WIDTH=384>Reads a set of properties from the specified <TT>InputStream</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>PropertyNames()</TT></TD><TD WIDTH=384>Returns an Enumeration of all property names.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=210><TT>Save(OutputStream, String)</TT></TD><TD WIDTH=384>Saves the <TT>Properties</TT> and a header string to the specified <TT>OutputStream</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Example <TT>EX11D</TT>, shown in Listing 11.4, shows how to create
an instance, put three properties into it, save it, and then reload
the keys and values into a different instance.
<HR>
<BLOCKQUOTE>
<B>Listing 11.4. EX11D.java demonstrates the Properties class.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.awt.*;
import java.io.*;
import java.util.*;

public class EX11D
{

    public static void main(String[] args)
    {
        // create a new instance
        Properties props1 = new Properties();

        // put three properties into it
        props1.put(&quot;prop1&quot;, &quot;put one&quot;);
        props1.put(&quot;prop2&quot;, &quot;put two&quot;);
        props1.put(&quot;prop3&quot;, &quot;put three&quot;);

        // retrieve each of the three properties
        String prop1 = props1.getProperty(&quot;prop1&quot;, &quot;one&quot;);
        String prop2 = props1.getProperty(&quot;prop2&quot;, &quot;two&quot;);
        String prop3 = props1.getProperty(&quot;prop3&quot;);

        // save the properties to a file
        try 
        {
            props1.save(new FileOutputStream(&quot;test.ini&quot;), &quot;My header&quot;);
        }
        catch (IOException e) {
            return;
        }

        // create a new instance and read the file in from the file
        Properties props2 = new Properties();
        try
        {
            FileInputStream inStr = new FileInputStream(&quot;test.ini&quot;);
            props2.load(inStr);
        }
        catch (IOException e) {
            return;
        }

        // retrieve a property from the second instance
        String prop = props2.getProperty(&quot;prop2&quot;, &quot;two&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheRandomClass"><FONT SIZE=5 COLOR=#FF0000>
The Random Class</FONT></A></H2>
<P>
This class represents a pseudo-random number generator. Two constructors
are provided, one taking a seed value as a parameter and the other
taking no parameters and using the current time as a seed. Constructing
a random number generator with a seed value is a good idea unless
you want the random number generator to always generate the same
set of values. On the other hand, sometimes it is useful to generate
the same sequence of &quot;random&quot; numbers. This is frequently
useful while debugging a program.
<P>
Once the random number generator is created, a value can be retrieved
from it using any of the following methods:
<BLOCKQUOTE>
<TT>nextDouble<BR>
nextFloat<BR>
nextGaussian<BR>
nextInt<BR>
nextLong</TT>
</BLOCKQUOTE>
<P>
The constructors and methods of <TT>Random</TT> are summarized
in Table 11.8. Use of the <TT>Random</TT> class is very simple,
so no example is presented here. However, example <TT>EX11E</TT>,
shown in the following discussion of the <TT>Observer</TT> class,
also uses <TT>Random</TT>.<BR>
<P>
<CENTER><B>Table 11.8. Nonprivate constructors and methods of
Random class. </B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=120><I>Method</I></TD><TD WIDTH=470><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>Random()</TT></TD><TD WIDTH=470>Creates a new random number generator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>Random(long)</TT></TD><TD WIDTH=470>Creates a new random number generator based on the specified seed value.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>nextDouble()</TT></TD><TD WIDTH=470>Returns the next double value between <TT>0.0D</TT> and <TT>1.0D</TT> from the random number generator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>nextFloat()</TT></TD><TD WIDTH=470>Returns the next float value between <TT>0.0F</TT> and <TT>1.0F</TT> from the random number generator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>NextGaussian()</TT></TD><TD WIDTH=470>Returns the next Gaussian-distributed double from the random number generator. Generated Gaussian values will have a mean of <TT>0</TT> and a standard deviation of <TT>1.0</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>nextInt()</TT></TD><TD WIDTH=470>Returns the next integer value from the random number generator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>nextLong()</TT></TD><TD WIDTH=470>Returns the next long value from the random number generator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=120><TT>setSeed(long)</TT></TD><TD WIDTH=470>Sets the seed value for the random number generator.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="ObserversandObservables"><FONT SIZE=5 COLOR=#FF0000>
Observers and Observables</FONT></A></H2>
<P>
An <TT>Observable</TT> class is a class that may be watched or
monitored by another class that implements the <TT>Observer</TT>
interface. Associated with each <TT>Observable</TT> instance is
a list of <TT>Observers</TT>. Whenever the<TT> Observable</TT>
instance changes it can notify each of its <TT>Observers</TT>.
By using <TT>Observable</TT> and <TT>Observer</TT> classes you
can achieve a better partitioning of your code by decreasing the
reliance of one class or another.
<H3><A NAME="TheObservableClass">
The Observable Class</A></H3>
<P>
The <TT>Observable</TT> class includes a single constructor that
takes no parameters. It also includes a number of methods for
managing its list of <TT>Observers</TT>. These are summarized
in Table 11.9.<BR>
<P>
<CENTER><B>Table 11.9. Nonprivate constructors and methods of
Observer class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=190><I>Member</I></TD><TD WIDTH=380><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>Observable()</TT></TD><TD WIDTH=380>Creates a new <TT>Observable</TT> instance.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>addObserver(Observer)</TT></TD><TD WIDTH=380>Adds an <TT>Observer</TT> to the list of objects observing this instance.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>clearChanged()</TT></TD><TD WIDTH=380>Clears the internal flag used to indicate that an <TT>Observable</TT> object has changed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>countObservers()</TT></TD><TD WIDTH=380>Returns the number of <TT>Observers</TT> of this object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>deleteObserver(Observer)</TT></TD><TD WIDTH=380>Deletes an <TT>Observer</TT> from the list of <TT>Observers</TT> of this object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>deleteObservers()</TT></TD><TD WIDTH=380>Deletes all <TT>Observers</TT> of this object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>hasChanged()</TT></TD><TD WIDTH=380>Returns true if the object has changed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>notifyObservers()</TT></TD><TD WIDTH=380>Notifies all <TT>Observers</TT> that a change has occurred in the <TT>Observable</TT> object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>notifyObservers(Object)</TT></TD><TD WIDTH=380>Notifies all <TT>Observers</TT> that a change has occurred and passes them the specified argument.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=190><TT>setChanged()</TT></TD><TD WIDTH=380>Sets the internal flag to indicate that a change has occurred.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TheObserverInterface">
The Observer Interface</A></H3>
<P>
The <TT>Observer</TT> interface defines an <TT>update</TT> method
that is invoked by an <TT>Observable</TT> object whenever the
<TT>Observable</TT> object has changed and wants to notify its
<TT>Observers</TT>. The signature of <TT>update</TT> is as follows:
<BLOCKQUOTE>
<PRE>
public abstract void update(Observable o, Object arg);
</PRE>
</BLOCKQUOTE>
<P>
This method is called whenever an <TT>Observable</TT> instance
that is being observed invokes either of its <TT>notifyObservers</TT>
methods. It is passed the <TT>Observable</TT> object that changed
and an optional additional parameter.
<H3><A NAME="AnExample2">
An Example</A></H3>
<P>
As an example of how <TT>Observable</TT> can be used, consider
the declaration of the <TT>Obsable</TT> class in Listing 11.5.
The <TT>Obsable</TT> class stores a secret number that is generated
by a random number generator. Whenever the secret number changes,
all <TT>Observers</TT> are notified.
<HR>
<BLOCKQUOTE>
<B>Listing 11.5. EX11E.java demonstrates Observable and Observer.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

// define a class that stores a secret number
class Obsable extends Observable {
    private int secretNumber;
    private Random generator;

    public Obsable(int seed) {
        // create a random number generator that will
        // make the &quot;secret numbers&quot;
        generator = new Random(seed);
    }

    public void GenerateNumber() {
        // generate a new secret number
        secretNumber = generator.nextInt();
        // indicate to Observable that the instance has changed
        setChanged();
        // notify all of the observers and pass the new number
        notifyObservers(new Integer(secretNumber));
    }
}


public class EX11E extends Applet implements Observer
{
    Integer secretNumber;
    Obsable obs;
    TextField tf;

    public EX11E() 
    {
        // create a new instance of the observable class
        obs = new Obsable(12);
        // indicate that &quot;this&quot; is an observer
        obs.addObserver(this);

        // create a read-only TextField
        tf = new TextField(10);
        tf.setEditable(false);
    }

    public void init() {
        add(new Label(&quot;Secret Number:&quot;));
        add(tf);
        add(new Button(&quot;Change&quot;));
        resize(320, 240);
    }

    // this method is invoked when the observable object
    // notifies its observers
    public void update(Observable o, Object arg) {
        // store the secret number and display it
        secretNumber = (Integer)arg;
        tf.setText(String.valueOf(secretNumber));
    }

    public boolean action(Event evt, Object obj)
    {
        boolean result=false;

        if(&quot;Change&quot;.equals(obj)) {
            obs.GenerateNumber();
            result = true;
        }
        return result;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
No <TT>Observable</TT> class is complete without an <TT>Observer</TT>,
so Listing 11.5 also includes class <TT>EX11E</TT>, which extends
<TT>Applet</TT> and implements the <TT>Observer</TT> interface.
The results of executing this applet are shown in Figure 11.3.
The constructor for <TT>EX11E</TT> creates an instance of <TT>Obsable</TT>,
the <TT>Observable</TT> class defined previously and adds the
applet as an observer of the <TT>Observable</TT> object. The <TT>init</TT>
method places a label, <TT>TextField</TT>, and button on the screen.
The <TT>TextField</TT> will be used to display the current value
of the secret number.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-3.gif"><B> Figure 11.3 : </B><I>The result of executing EX11E.

</I></A><P>
<P>
The <TT>EX11E</TT> class contains an <TT>update</TT> method that
is part of the <TT>Observer</TT> interface. This method is passed
an <TT>Observable</TT> item and an <TT>Object</TT> as parameters.
As shown in the declaration of <TT>Obsable</TT>, the <TT>Object</TT>
is an integer. Therefore, <TT>update</TT> casts the <TT>Object</TT>
into an <TT>Integer</TT>, stores it in the instance variable <TT>secretNumber</TT>,
and then updates the <TT>TextField</TT>.
<P>
The action method traps pushes of the <TT>Change</TT> button and
then calls <TT>obs.GenerateNumber</TT> to generate a new random
number. Each time <TT>GenerateNumber</TT> changes the secret number,
the <TT>update</TT> method in the observer will be called. In
this case, this will update the display with each newly generated
random number.
<H2><A NAME="TheVectorClass"><FONT SIZE=5 COLOR=#FF0000>
The Vector Class</FONT></A></H2>
<P>
One of the problems with an array is that you must know how big
it must be when you create it. This is not always practical and
is rarely easy. Imagine what would have happened if the founding
fathers of the United States were programmers and they used a
13-element array to hold the names of all the states. Even if
the lead programmer on this project (Thomas Jefferson, if I remember
my eighth grade history correctly) had the foresight to double
or triple the array size to allow for future growth, it still
would not have been enough.
<P>
The Java <TT>Vector</TT> class solves this problem by providing
a form of resizable array that can grow as more elements are added
to it. A <TT>Vector</TT> stores items of type <TT>Object</TT>
so that it can be used to store instances of any Java class. A
single <TT>Vector</TT> may store different elements that are instances
of different classes.
<P>
At any point in time a <TT>Vector</TT> has the capacity to hold
a certain number of elements. When a <TT>Vector</TT> reaches its
capacity, its capacity is incremented by an amount specific to
that <TT>Vector</TT>. The <TT>Vector</TT> class provides three
different constructors that enable you to specify the initial
capacity and increment quantity of a <TT>Vector</TT> when it is
created. These constructors are summarized in Table 11.10.<BR>
<P>
<CENTER><B>Table 11.10. Constructors for the Vector class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Vector(int)</TT></TD><TD WIDTH=384>Creates a new <TT>Vector</TT> with the specified initial capacity.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Vector(int, int)</TT></TD><TD WIDTH=384>Creates a new <TT>Vector</TT> with the specified initial capacity and increment quantity.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Vector()</TT></TD><TD WIDTH=384>Creates a new <TT>Vector</TT> with defaults for the initial capacity and increment quantity.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
An item is added to a <TT>Vector</TT> using <TT>addElement</TT>.
Similarly, an element can be replaced using <TT>setElementAt</TT>.
A <TT>Vector</TT> can be searched using the <TT>contains</TT>
method, which simply looks for an occurrence of an <TT>Object</TT>.
The <TT>elements</TT> method is useful because it returns an enumeration
of the <TT>Object</TT>s stored in the <TT>Vector</TT>. These and
other member methods of <TT>Vector</TT> are summarized in Table
11.11.<BR>
<P>
<CENTER><B>Table 11.11. Nonprivate methods of the Vector class.
</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=240><I>Method</I></TD><TD WIDTH=336><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>addElement(Object)</TT></TD><TD WIDTH=336>Inserts the specified element into the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>capacity()</TT></TD><TD WIDTH=336>Returns the number of elements that will fit into the currently allocated portion of the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>clone()</TT></TD><TD WIDTH=336>Clones the vector, but not its elements.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>contains(Object)</TT></TD><TD WIDTH=336>Returns true if the <TT>Vector</TT> contains the specified <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>copyInto(Object [])</TT></TD><TD WIDTH=336>Copies the elements of the <TT>Vector</TT> into the specified array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>elementAt(int)</TT></TD><TD WIDTH=336>Retrieves the element located at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>elements()</TT></TD><TD WIDTH=336>Returns an enumeration of the elements in the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>ensureCapacity(int)</TT></TD><TD WIDTH=336>Ensures that the <TT>Vector</TT> can hold at least the specified minimum capacity.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>firstElement()</TT></TD><TD WIDTH=336>Returns the first element in the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>indexOf(Object)</TT></TD><TD WIDTH=336>Searches the <TT>Vector</TT> and returns the zero-based index of the first matching <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>indexOf(Object, int)</TT></TD><TD WIDTH=336>Searches the <TT>Vector</TT> beginning at the specified index number and returns the zero-based index of the next matching <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>insertElementAt(Object, int)</TT></TD><TD WIDTH=336>Adds the specified <TT>Object</TT> at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>isEmpty()</TT></TD><TD WIDTH=336>Returns true if the <TT>Vector</TT> has no elements.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>LastElement()</TT></TD><TD WIDTH=336>Returns the last element in the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>lastIndexOf(Object)</TT></TD><TD WIDTH=336>Searches the <TT>Vector</TT> and returns the zero-based index of the last matching <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>lastIndexOf(Object, int)</TT></TD><TD WIDTH=336>Searches the <TT>Vector</TT> beginning at the specified index number and returns the zero-based index of the prior matching <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>removeAllElements()</TT></TD><TD WIDTH=336>Removes all elements from the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>removeElement(Object)</TT></TD><TD WIDTH=336>Removes the specified <TT>Object</TT> from the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>removeElementAt(int)</TT></TD><TD WIDTH=336>Removes the <TT>Object</TT> at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>setElementAt(Object, int)</TT></TD><TD WIDTH=336>Replaces the <TT>Object</TT> at the specified index with the specified <TT>Object</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>setSize(int)</TT></TD><TD WIDTH=336>Sets the size of the <TT>Vector</TT> to the specified new size.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>size()</TT></TD><TD WIDTH=336>Returns the number of elements currently in the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>toString()</TT></TD><TD WIDTH=336>Returns a formatted string representing the contents of the <TT>Vector</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>trimToSize()</TT></TD><TD WIDTH=336>Removes any excess capacity in the <TT>Vector</TT> by resizing it.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As an example of using <TT>Vector</TT> consider example class
<TT>EX11F</TT>, shown in Listing 11.6. This example again uses
a <TT>TextArea</TT> to display the results of various operations.
In this example, a <TT>Vector</TT>, <TT>v1</TT>, is constructed.
Initially, enough space is reserved for 10 elements and the <TT>Vector</TT>
will increase its capacity by four whenever there is no room for
a new element.
<HR>
<BLOCKQUOTE>
<B>Listing 11.6. EX11F.java demonstrates the Vector class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11F extends Applet
{
    TextArea results = new TextArea(10, 75);

    public void init()
    {
        resize(500, 240);
        add(results);

        // create a new Vector to hold 10 elements
        // and to increase by 4 each time it's necessary
        Vector v1 = new Vector(10, 4);

        // add elements, both Integer and String, to the Vector
        v1.addElement(new Integer(1));
        v1.addElement(new Integer(2));
        v1.addElement(new Integer(3));
        v1.addElement(&quot;Four&quot;);
        v1.addElement(new Integer(5));

        // display the entire Vector
        results.appendText(v1.toString() + &quot;\r\n&quot;);

        // see if the Vector contains this Integer
        if (v1.contains(new Integer(2)))
            results.appendText(&quot;It contains 2\r\n&quot;);

        // see if the Vector contains this String
        if (v1.contains(&quot;Four&quot;))
            results.appendText(&quot;It contains Four\r\n&quot;);

        // Display the capacity of the Vector
        int capacity = v1.capacity();
        results.appendText(&quot;Can hold &quot; +
                String.valueOf(capacity) + &quot;\r\n&quot;);

        // Display the element at index number 3
        results.appendText(&quot;ElementAt 3 = &quot; +
                (String)v1.elementAt(3) + &quot;\r\n&quot;);

        // clear out the Vector
        v1.removeAllElements();

        // add the names of Pink Floyd's first five albums
        v1.addElement(&quot;Piper At The Gates of Dawn&quot;);
        v1.addElement(&quot;Saucerful of Secrets&quot;);
        v1.addElement(&quot;Ummagumma&quot;);
        v1.addElement(&quot;Meddle&quot;);
        v1.addElement(&quot;The Dark Side of the Moon&quot;);

        // use an enumeration to display each of the album titles
        for (Enumeration enum = v1.elements();
                enum.hasMoreElements(); )
            results.appendText((String)enum.nextElement()+&quot;\r\n&quot;);
    }

}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Initially, five elements-four integers and one string-are added
to the <TT>Vector</TT>. This illustrates the capability to store
objects of different types in the same <TT>Vector</TT>. Next,
the <TT>toString</TT> method is used to display the entire <TT>Vector</TT>.
This, along with the other messages displayed by <TT>EX11F</TT>,
can be seen in Figure 11.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-4.gif"><B> Figure 11.4 : </B><I>The result of executing EX11F.

</I></A><P>
<P>
Next, the <TT>contains</TT> method is used to determine if the
<TT>Vector</TT> contains the <TT>Integer</TT> 2 and the string
<TT>&quot;Four&quot;</TT>. The capacity of the <TT>Vector</TT>
is then displayed and the item at index number three is retrieved
and displayed. Because <TT>Vector</TT> is zero-based this will
retrieve the fourth element in the <TT>Vector</TT>.
<P>
The method <TT>removeAllElements</TT> is then used to remove the
current elements. The names of Pink Floyd's first five albums
are then added to the <TT>Vector</TT>. Finally, the <TT>elements</TT>
method is used to return an Enumeration of the elements. The <TT>hasMoreElements</TT>
and <TT>nextElement</TT> method are used in a loop that displays
each of the album titles.
<H2><A NAME="TheStackClass"><FONT SIZE=5 COLOR=#FF0000>
The Stack Class</FONT></A></H2>
<P>
The <TT>Stack</TT> class extends <TT>Vector</TT> and implements
a simple last-in-first-out stack. An item is stored on a stack
by &quot;pushing&quot; it onto the stack. An item may subsequently
be &quot;popped&quot; off the stack and used. The item popped
off a stack will always be the most recently pushed item. 
<P>
Because <TT>Stack</TT> extends the <TT>Vector</TT> class, no size
is associated with a <TT>Stack</TT> instance. The <TT>Stack</TT>
will continue to grow in size as new items are pushed onto it.
In addition to methods to push and pop items, a <TT>peek</TT>
method is provided for looking at the next item, a <TT>search</TT>
method is provided for scanning the <TT>Stack</TT> for a specific
item, and an <TT>empty</TT> method is provided determining whether
more items are stored in the <TT>Stack</TT>.
<P>
The single constructor as well as the nonprivate methods of <TT>Stack</TT>
are summarized in Table 11.12.<BR>
<P>
<CENTER><B>Table 11.12. Constructors and nonprivate methods of
the Stack class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Member</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Stack()</TT></TD><TD WIDTH=384>Creates a new <TT>Stack</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>empty()</TT></TD><TD WIDTH=384>Returns true if the <TT>Stack</TT> is empty.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>peek()</TT></TD><TD WIDTH=384>Returns the last <TT>Object</TT> added to the <TT>Stack</TT> but does not remove it from the <TT>Stack</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>pop()</TT></TD><TD WIDTH=384>Returns the last <TT>Object</TT> added to the <TT>Stack</TT> and removes it.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>push(Object)</TT></TD><TD WIDTH=384>Adds the specified <TT>Object</TT> to the <TT>Stack</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>search(Object)</TT></TD><TD WIDTH=384>Searches for the specified <TT>Object</TT> in the <TT>Stack</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
An example of using <TT>Stack</TT> is provided in example <TT>EX11G</TT>,
shown in Listing 11.7. In this example a <TT>Stack</TT> is created
and three items are added to it. The <TT>toString</TT> method
is used to display the <TT>Stack</TT>'s initial contents. The
<TT>peek</TT> method is used to look at the last object added
to the <TT>Stack</TT> but does not actually remove the object.
Next, <TT>search</TT> is used to look for an occurrence of <TT>&quot;2&quot;</TT>
within the <TT>Stack</TT>. Finally, <TT>pop</TT> is used to remove
an object from the <TT>Stack</TT> and <TT>toString</TT> is used
to redisplay its contents. The results of executing this applet
are shown in Figure 11.5.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-5.gif"><B> Figure 11.5 : </B><I>The result of executing EX11G.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 11.7. EX11G.java demonstrates the Stack class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11G extends Applet
{
    TextArea results = new TextArea(10, 30);

    public void init()
    {
        resize(320, 240);
        add(results);

        // create a new Stack
        Stack stk = new Stack();

        // add three items to the Stack
        stk.push(&quot;1&quot;);
        stk.push(&quot;2&quot;);
        stk.push(&quot;3&quot;);

        // display the entire Stack
        results.appendText(&quot;Stack=&quot; + stk.toString() + &quot;\r\n&quot;);

        // peek at what's next off the stack
        String str = (String)stk.peek();
        results.appendText(&quot;Peeked at: &quot; + str + &quot;\r\n&quot;);

        // see if there's a &quot;2&quot; anywhere in the Stack
        if (stk.search(&quot;2&quot;) != -1)
            results.appendText(&quot;Found 2\r\n&quot;);

        // pop an item off the Stack
        str = (String)stk.pop();
        results.appendText(&quot;Popped: &quot; + str + &quot;\r\n&quot;);

        // display the entire Stack
        results.appendText(&quot;Stack=&quot; + stk.toString() + &quot;\r\n&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheStringTokenizerClass"><FONT SIZE=5 COLOR=#FF0000>
The StringTokenizer Class</FONT></A></H2>
<P>
A <TT>StringTokenizer</TT> can be used to parse a string into
its constituent tokens. For example, each word in a sentence could
be considered a token. However, the <TT>StringTokenizer</TT> class
goes beyond the parsing of sentences. You can create a fully customized
tokenizer by specifying the set of token delimiters when the <TT>StringTokenizer</TT>
is created. For parsing text, the default whitespace delimiters
are usually sufficient. However, you could use the set of arithmetic
operators (<TT>+</TT>, <TT>*</TT>, <TT>/</TT>, and <TT>-</TT>)
if parsing an expression.
<P>
The delimiter characters can be specified when a new <TT>StringTokenizer</TT>
object is constructed. Table 11.13 summarizes the three available
constructors. Examples of using these constructors are the following:
<BLOCKQUOTE>
<PRE>
StringTokenizer st1 = new StringTokenizer(&quot;A stream of words&quot;);
StringTokenizer st2 = new StringTokenizer(&quot;4*3/2-1+4&quot;, &quot;*+/-&quot;, true);
StringTokenizer st3 = new StringTokenizer(&quot;aaa,bbbb,ccc&quot;, &quot;,&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In the first example, the <TT>st1</TT> <TT>StringTokenizer</TT>
will be constructed using the supplied string and the default
delimiters. The default delimiters are the space, tab, newline,
and carriage return characters. These delimiters are useful when
parsing text, as with <TT>st1</TT>. The second example constructs
a <TT>StringTokenizer</TT> for tokenizing arithmetic expressions
using the <TT>*</TT>, <TT>+</TT>, <TT>/</TT>, and <TT>-</TT> symbols
as supplied. Finally, the third <TT>StringTokenizer</TT>, <TT>st3</TT>,
will tokenize the supplied string using only the comma character
as a delimiter.<BR>
<P>
<CENTER><B>Table 11.13. Constructors for the StringTokenizer class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=240><I>Constructor</I></TD><TD WIDTH=336><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>StringTokenizer(String)</TT></TD><TD WIDTH=336>Creates a new <TT>StringTokenizer</TT> based on the specified string to be tokenized.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>StringTokenizer(String, String)</TT></TD>
<TD WIDTH=336>Creates a new <TT>StringTokenizer</TT> based on the specified string to be tokenized and set of delimiters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=240><TT>StringTokenizer(String,String,<BR>boolean)</TT>
</TD><TD WIDTH=336>Creates a new <TT>StringTokenizer</TT> based on the specified string to be tokenized, set of delimiters, and a flag that indicates if delimiters should be returned as tokens.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Because <TT>StringTokenizer</TT> implements the enumeration interface
it includes the <TT>hasMoreElements</TT> and <TT>nextElement</TT>
methods. Additionally, the methods <TT>hasMoreTokens</TT> and
<TT>nextToken</TT> are provided and perform the same operations.
The nonprivate methods of <TT>StringTokenizer</TT> are summarized
in Table 11.14.<BR>
<P>
<CENTER><B>Table 11.14. Nonprivate methods of the StringTokenizer
class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>countTokens()</TT></TD><TD WIDTH=384>Returns the number of remaining tokens.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>hasMoreElements()</TT></TD><TD WIDTH=384>Returns true if there are more elements in the string being tokenized. It is identical to <TT>hasMoreTokens</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>hasMoreTokens()</TT></TD><TD WIDTH=384>Returns true if there are more tokens in the string being tokenized. It is identical to <TT>hasMoreElements</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>nextElement()</TT></TD><TD WIDTH=384>Returns the next element in the string. It is identical to <TT>nextToken</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>nextToken()</TT></TD><TD WIDTH=384>Returns the next token in the string. It is identical to <TT>nextElement</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>nextToken(String)</TT></TD><TD WIDTH=384>Changes the set of delimiters to the specified string and then returns the next token in the string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Class <TT>EX11H</TT> is an example of how to use the <TT>StringTokenizer</TT>
class and is shown in Listing 11.8. In this example two <TT>StringTokenizer</TT>
objects are created. The first, <TT>st1</TT>, is used to parse
an arithmetic expression. The second, <TT>st2</TT>, parses a line
of comma-delimited fields. For both tokenizers, <TT>hasMoreTokens</TT>
and <TT>nextToken</TT> are used to iterate through the set of
tokens, displaying each token in a <TT>TextArea</TT>. The results
of executing <TT>EX11H</TT> are shown in Figure 11.6.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f11-6.gif"><B> Figure 11.6 : </B><I>The result of executing EX11H.

</I></A><P>
<HR>
<BLOCKQUOTE>
<B>Listing 11.8. EX11H.java demonstrates the StringTokenizer class.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
import java.applet.*;
import java.awt.*;
import java.util.*;

public class EX11H extends Applet
{
    TextArea results = new TextArea(14, 25);

    public void init()
    {
        resize(320, 240);
        add(results);

        // put an arithmetic expression in a string
        // and create a tokenizer for the string
        String mathExpr = &quot;4*3+2/4&quot;;
        StringTokenizer st1 = new StringTokenizer(mathExpr, 
                &quot;*+/-&quot;, true);

        // while there are tokens left, display each token
        results.appendText(&quot;Tokens of mathExpr:\r\n&quot;);
        while (st1.hasMoreTokens()) 
            results.appendText(st1.nextToken() + &quot;\r\n&quot;);

        // create a String of comma-delimited fields
        // and create a tokenizer for the string
        String commas = &quot;field1,field2,field3,and field 4&quot;;
        StringTokenizer st2=new StringTokenizer(commas,&quot;,&quot;,false);

        // while there are tokens left, display each token
        results.appendText(&quot;Comma-delimited tokens:\r\n&quot;);
        while (st2.hasMoreTokens()) 
            results.appendText(st2.nextToken() + &quot;\r\n&quot;);
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter gave you a thorough overview of the classes in the
java.util package. You learned how to use the <TT>BitSet</TT>
class to store large amounts of Boolean data, how to manipulate
dates and times with the <TT>Date</TT> class, how to generate
random numbers, and how to tokenize strings. You learned how the
<TT>Observable</TT> class works in conjunction with the <TT>Observer</TT>
interface to allow you to decouple your code. The <TT>Hashtable</TT>
class was described and you learned how the <TT>Properties</TT>
class can be used in applications to stream data to and from files.
Finally, you learned how the <TT>Vector</TT> class can be used
as a resizable array and how the <TT>Stack</TT> class extends
<TT>Vector</TT>.
<HR>

<CENTER><P><A HREF="ch10.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch12.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>