<HTML>
<HEAD>
<TITLE>Chapter 24 -- Development Request Online</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;24</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Development Request Online</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ProjectOverview">
Project Overview</A>
<UL>
<LI><A HREF="#DevRequestApplet">
DevRequest Applet</A>
</UL>
<LI><A HREF="#AccesstotheData">
Access to the Data</A>
<UL>
<LI><A HREF="#Request">
Request</A>
<LI><A HREF="#Operator">
Operator</A>
<LI><A HREF="#Department">
Department</A>
</UL>
<LI><A HREF="#UserInterface">
User Interface</A>
<UL>
<LI><A HREF="#CommonClasses">
Common Classes</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
This chapter develops a sample applet that can be used to submit
Development Request forms to a database server and to track their
progress. It covers many of the aspects that have been covered
throughout this book, with an added emphasis on storing the collected
information in an Access database.
<H2><A NAME="ProjectOverview"><FONT SIZE=5 COLOR=#FF0000>
Project Overview</FONT></A></H2>
<P>
This chapter features the creation of an applet that replaces
a typical office form with a Web site. Any form from any office
can be put on a Web site, allowing universal access. This enables
a variety of users, from marketing geeks to programmers to managers,
to quickly get an idea of the state of certain requests. Figure
24.1 shows an example of a Development Request form.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-1.gif"><B> Figure 24.1 : </B><I>Example of a request form to be put online.
</I></A><P>
<P>
For the sake of brevity, only a few of the possible fields were
added to this example. However, I encourage developers to enhance
this applet so that it contains all of the fields required to
take that next step toward a paperless office.
<H3><A NAME="DevRequestApplet">
DevRequest Applet</A></H3>
<P>
The DevRequest applet has three basic screens, as described in
Table 24.1.<BR>
<P>
<CENTER><B>Table 24.1. DevRequest screens.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=144><I>Screen</I></TD><TD WIDTH=432><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Login</TD><TD WIDTH=432>Enables the user to log into the system with a username and password.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Control</TD><TD WIDTH=432>The main screen of the applet, used to enter and review requests in the system.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144>Administration</TD><TD WIDTH=432>Enables an administrator of the system to enter and modify both users and departments tracked by the system.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The login screen simply enables the user to access the system
by entering a username and the associated password. It is assumed
that the first administrator entry is entered by another means
(for example, using Microsoft Access). However, a &quot;back door&quot;
could have easily been incorporated into DevRequest. Figure 24.2
shows the login screen.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-2.gif"><B> Figure 24.2 : </B><I>The DevRequest login screen.
</I></A><P>
<P>
The main screen of the applet is displayed immediately after the
user has logged in. Figure 24.3 shows the control screen.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-3.gif"><B> Figure 24.3 : </B><I>The DevRequest control screen.
</I></A><P>
<P>
Using this screen, the user can see a list of all requests in
the system by tracking ID and title in the list at the left of
the screen. In addition, if a request is highlighted in the list,
the user can select the Details button, displaying all of the
information about the request on the right side of the screen.
This information includes the title and complete description of
the request, when and by whom the request was submitted, the budget
in which the resources to complete the request are allocated,
and the current status of the request. If the New button is pressed,
the currently displayed details will be cleared and the controls
will be readied for a new request to be entered. Any modifications
that are made to either an existing or new request can be saved
to the database by using the Save button located at the bottom
of the details form.
<P>
When the user is an administrator, the Administration button will
bring up the screen in Figure 24.4.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-4.gif"><B> Figure 24.4 : </B><I>The DevRequest administration screen.
</I></A><P>
<P>
This screen is used to update both the operator and department
tables. An operator is simply a user of the system. The department
indicates through which budget requests are funded. All of the
pertinent information about each of these entities can be updated,
or new entities can be added, using this screen.
<H4>Class Overview</H4>
<P>
The classes used in the <TT>DevRequest</TT> applet are diagrammed
in Figure 24.5. Classes whose names are italicized are specific
to this applet. Classes without italicized names are standard
Java classes used as base classes for <TT>DevRequest</TT> classes.
A short summary for each class can be found in Table 24.2.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-5.gif"><B> Figure 24.5 : </B><I>DevRequest class overview.
</I></A><P><BR>
<BLOCKQUOTE>
<CENTER><B>Table 24.2. DevRequest class summary.</B></CENTER>
</BLOCKQUOTE>

<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=170><I>Class</I></TD><TD WIDTH=134><I>Extends</I>
</TD><TD WIDTH=340><I>Description</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>DevRequest</TT></TD><TD WIDTH=134><TT>Applet</TT>
</TD><TD WIDTH=340>Main class of the applet that contains the login, control, and administration screens.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>UserInformation</TT></TD><TD WIDTH=134>&nbsp;
</TD><TD WIDTH=340>Utility class that holds information about the current user. Provides a mechanism to control the flow of the screens.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>StatusPanel</TT></TD><TD WIDTH=134><TT>Panel</TT>
</TD><TD WIDTH=340>Base class for panels in the system providing basic messaging capabilities.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>LoginPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to log into the system.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>ControlPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to display and modify requests in the system.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>RequestPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to display the detail information of a request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>Request</TT></TD><TD WIDTH=134>&nbsp;</TD>
<TD WIDTH=340>Holds information about a single request. Also used to read and write request information from and to the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>AdministrationPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to perform administration duties on the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>OperatorPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to display a list and details of the operators of the system.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>Operator</TT></TD><TD WIDTH=134>&nbsp;</TD>
<TD WIDTH=340>Holds information about a single operator. Also used to read and write operator information from and to the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>DepartmentPanel</TT></TD><TD WIDTH=134><TT>StatusPanel</TT>
</TD><TD WIDTH=340>Contains the controls used to display a list and details of the departments of the system.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>Department</TT></TD><TD WIDTH=134>&nbsp;
</TD><TD WIDTH=340>Holds information about a single department. Also used to read and write department information from and to the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>ListData</TT></TD><TD WIDTH=134><TT>List</TT>
</TD><TD WIDTH=340>Associates a data item with each item in the list.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=170><TT>ChoiceData</TT></TD><TD WIDTH=134><TT>Choice</TT>
</TD><TD WIDTH=340>Associates a data item with each item in the drop-down list.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The DevRequest applet uses a <TT>CardLayout</TT> to display each
of the three main screens of the system. The information in <TT>UserInformation</TT>
is used to track who is logged onto the system. It controls which
of the cards is currently being displayed and what is to be displayed
next. Each panel of the <TT>CardLayout</TT> contains either just
controls, or displays its information in additional panels so
as to help divide the display functionality into logical groupings.
All database access is contained within the low-level entity classes:
<TT>Request</TT>, <TT>Operator</TT>, and <TT>Department</TT>.
Additional utility classes are provided to aid in displaying messages
to the user and associate database information with list items.
<H4>Database Schema</H4>
<P>
The storage of all of the collected information is in a Microsoft
Access database. There are three tables involved, as can been
seen in Table 24.3.<BR>
<P>
<CENTER><B>Table 24.3. Types of storage tables.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=144><I>Table</I></TD><TD WIDTH=432><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>REQUEST</TT></TD><TD WIDTH=432>Contains all of the information stored for each request, such as title, submission date, and so on.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>OPERATOR</TT></TD><TD WIDTH=432>Contains all of the information stored for each operator (user) of the system, such as username, password, access level, and so on.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=144><TT>DEPARTMENT</TT></TD><TD WIDTH=432>Contains all of the information stored for each department, such as department code and name.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Figure 24.6 contains that physical database model. The arrows
on the drawing represent referential integrity constraints. This
means that the column from which the arrow originates must exist
as a primary key of the table to which it points. For the DevRequest
model, the relationship exists that each requester must be an
operator in the system. Additionally, the approved budget must
come from a department registered in the system.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-6.gif"><B> Figure 24.6 : </B><I>DevRequest physical database model.
</I></A><P>
<P>
That covers the basics of the applet. The remaining sections of
this chapter cover the implementation details.
<H2><A NAME="AccesstotheData"><FONT SIZE=5 COLOR=#FF0000>
Access to the Data</FONT></A></H2>
<P>
All of the data for this applet is stored in a Microsoft Access
database consisting of three tables: <TT>REQUEST</TT>, <TT>OPERATOR</TT>,
and <TT>DEPARTMENT</TT>. The information will be retrieved using
the Microsoft Data Access Objects (DAO). For more information
on the nuts and bolts of DAO, see <A HREF="ch22.htm" >Chapter 22</A>, &quot;Using the
Data Access Object.&quot; In this applet, the information retrieved
can be logically grouped based on the tables from which it is
being retrieved. Therefore, there are three corresponding Java
classes that handle access to these tables: <TT>Request</TT>,
<TT>Operators</TT>, and <TT>Departments</TT>.
<H3><A NAME="Request">
Request</A></H3>
<P>
<TT>Request</TT> is used to hold and access database information
about a single request. This is one of the key classes in the
database. There are several members of the class that hold the
request information:
<BLOCKQUOTE>
<PRE>
public int TrackingId;
public Operator Requestor;
public String Title;
public String Description;
public Date SubmissionDate;
public Date CompletionDate;
public String Status;
public Department ApprovedBudget;
</PRE>
</BLOCKQUOTE>
<P>
Each of the fields corresponds directly to a column in the <TT>REQUEST</TT>
table.
<P>
Additionally, two sets of constant values are defined. The first
set is for general use and contains values that indicate the state
of the object:
<BLOCKQUOTE>
<PRE>
public final static Date DATE_NOT_SET = new Date(0);
public final static int NEW_REQUEST_ID = -1;
</PRE>
</BLOCKQUOTE>
<P>
<TT>DATE_NOT_SET</TT> is used to indicate that a date has not
been assigned a value. Because this is a <TT>Date</TT> instance,
it is pretty hard to store a flag in the class to show a special
kind of date. However, it is pretty safe to assume that there
never will be a submission date or completion date before January
1, 1970, which is the value to which this constant is set. <TT>NEW_REQUEST_ID</TT>
is used to flag that a request is a new request; all existing
requests will have an ID greater than 0.
<P>
The status of a request can be one of four predefined values.
The values that are stored in the database are given by the following
constants strings:
<BLOCKQUOTE>
<PRE>
public final static String SUBMITTED = &quot;S&quot;;
public final static String APPROVED = &quot;A&quot;;
public final static String COMPLETED = &quot;C&quot;;
public final static String POSTPONED = &quot;P&quot;;
</PRE>
</BLOCKQUOTE>
<P>
There are three key methods in the class: <TT>read</TT>, <TT>write</TT>,
and <TT>readAll</TT>. <TT>read</TT> is used to read the details
of a request. It assumes that the tracking ID of the desired request
is set when this method is called. Listing 24.1 contains this
method.
<HR>
<BLOCKQUOTE>
<B>Listing 24.1. The read method of class Request.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public boolean read(Database db)
{
    boolean retval = false;         // assume database error
    String command = &quot;select * from REQUEST where TRACKING_ID = &quot; +
            Integer.toString(TrackingId);
    Variant type = new Variant();
    Variant options = new Variant();
    Variant fieldName = new Variant();
    Variant fieldValue = new Variant();
    type.putShort(Constants.dbOpenDynaset);
    options.putShort(Constants.dbReadOnly);
    // create the recordset and get the number of records returned
    Recordset recordset = db.OpenRecordset(command, type, options);
    int recordCount = recordset.getRecordCount();
    // retrieve the first row
    if (recordCount &gt; 0) {
        recordset.MoveFirst();
        // get the fields of the row
        Fields fields = recordset.getFields();
        _Field field;
        // retrieve all of the information and store it
        fieldName.putString(&quot;TITLE&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        Title = fieldValue.toString();
        fieldName.putString(&quot;DESCRIPTION&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        Description = fieldValue.toString();
        fieldName.putString(&quot;REQUESTOR&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        Requestor.setUserName(fieldValue.toString());
        fieldName.putString(&quot;SUBMISSION_DATE&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        SubmissionDate = new Date(fieldValue.toString());
        fieldName.putString(&quot;COMPLETION_DATE&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        if (fieldValue.getvt() != Variant.VariantNull)
            CompletionDate = new Date(fieldValue.toString());
        fieldName.putString(&quot;STATUS&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        Status = fieldValue.toString();
        fieldName.putString(&quot;APPROVED_BUDGET&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        ApprovedBudget.setCode(fieldValue.toString());
        retval = true;
    }
    if (retval)
    {
        retval = Requestor.read(db);
        if (retval)
            retval = ApprovedBudget.read(db);
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The first task is to determine the defining mechanism for the
recordset to be returned. This is accomplished with the following
SQL statement, which returns all <TT>REQUEST</TT> columns for
the request with the given ID:
<BLOCKQUOTE>
<PRE>
String command = &quot;select * from REQUEST where TRACKING_ID = &quot; +
        Integer.toString(TrackingId);
</PRE>
</BLOCKQUOTE>
<P>
Next, a recordset that contains the information selected by the
SQL statement is opened. Since the ID is the primary key of the
table, only a single row is returned. Therefore, the record count
returned is used to flag the success of the record set retrieval.
The next rather large section of code is used to retrieve the
individual fields of the row. The process is common throughout
the applet and consists of the following steps:
<OL>
<LI>Load the name of the field in the field name <TT>Variant</TT>.
<LI>Get the field from the fields of the record.
<LI>Get the value of the field returned.
<LI>Convert the value of the <TT>Variant</TT> value returned to
a usable type and store that information.
</OL>
<P>
The final task to be completed in the <TT>read</TT> method is
to read in the requester information and the approved budget-department
information.
<P>
The <TT>write</TT> method is used to insert a new request into
the database or update an existing request. This method assumes
that the fields of the current instance of the <TT>Request</TT>
class have been updated with the latest information. Notice that
this class has very little, if any, coupling with any interface
components being used to gather this information. This allows
this class to have the potential of being reused in a number of
situations. 
<P>
Listing 24.2 contains the <TT>write</TT> method.
<HR>
<BLOCKQUOTE>
<B>Listing 24.2. The write method of class Request.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void write(Database db)
{
    StringBuffer command = new StringBuffer();
    // set completion date if needed
    if (Status.equals(COMPLETED) &amp;&amp; CompletionDate.equals(DATE_NOT_SET))
        CompletionDate = new Date();
    if (TrackingId == NEW_REQUEST_ID)
    {
        command.append(&quot;insert into REQUEST(TITLE,DESCRIPTION,&quot;);
        command.append(&quot;REQUESTOR,SUBMISSION_DATE,COMPLETION_DATE,&quot;);
        command.append(&quot;STATUS,APPROVED_BUDGET) values(&quot;);
        command.append(&quot;'&quot; + Title + &quot;',&quot;);
        command.append(&quot;'&quot; + Description + &quot;',&quot;);
        command.append(&quot;'&quot; + Requestor.UserName + &quot;',&quot;);
        command.append(&quot;'&quot; + SubmissionDate.toLocaleString() + &quot;',&quot;);
        command.append((CompletionDate != DATE_NOT_SET) ?
                &quot;'&quot; + CompletionDate.toLocaleString() + &quot;',&quot; : &quot;NULL,&quot;);
        command.append((Status != null) ? &quot;'&quot; + Status + &quot;',&quot; : &quot;NULL,&quot;);
        command.append(&quot;'&quot; + ApprovedBudget.Code + &quot;')&quot;);
    }
    else
    {
        command.append(&quot;update REQUEST set &quot;);
        command.append(&quot;TITLE = '&quot; + Title + &quot;',&quot;);
        command.append(&quot;DESCRIPTION = '&quot; + Description + &quot;',&quot;);
        command.append(&quot;REQUESTOR = '&quot; + Requestor.UserName + &quot;',&quot;);
        command.append(&quot;SUBMISSION_DATE = '&quot; +
                SubmissionDate.toLocaleString() + &quot;',&quot;);
        command.append(&quot;COMPLETION_DATE = &quot;);
        command.append((CompletionDate != DATE_NOT_SET) ?
                &quot;'&quot; + CompletionDate.toLocaleString() + &quot;',&quot; : &quot;NULL,&quot;);
        command.append(&quot;STATUS = &quot;);
        command.append((Status != null) ? &quot;'&quot; + Status + &quot;',&quot; : &quot;NULL,&quot;);
        command.append(&quot;APPROVED_BUDGET = '&quot; + ApprovedBudget.Code + &quot;' &quot;);
        command.append(&quot;where TRACKING_ID = &quot; +
                Integer.toString(TrackingId));
    }
    Variant options = new Variant();
    options.putShort(Constants.dbFailOnError);
    db.Execute(command.toString(), options);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Because this is the last call before being written out to the
database, the completion date of the request is set, if necessary,
to the current time. Next, the ID is checked to see if this will
be an <TT>insert</TT> action or an <TT>update</TT> action. Probably
the most straightforward way to perform either of these actions
is to write a SQL statement to perform the action, embedding any
values necessary directly into the statement. In this way, <TT>Variant</TT>
instances for each field are avoided. The <TT>write</TT> method
creates either an <TT>insert</TT> statement or <TT>update</TT>
statement based on the value of the ID. Next, the <TT>Datebase.Execute</TT>
method is used to carry out the action.
<P>
Finally, the <TT>readAll</TT> method is used to return a stripped-down
version of each request. This is done to minimize the amount of
data returned so as not to jeopardize performance. Listing 24.3
contains this method.
<HR>
<BLOCKQUOTE>
<B>Listing 24.3. The readAll method of class Request.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public static boolean readAll(Database db, Vector requestList)
{
    boolean retval = false;         // assume database error
    String command = &quot;select TRACKING_ID, TITLE from REQUEST &quot; + &quot;
            order by TRACKING_ID&quot;;
    Variant type = new Variant();
    Variant options = new Variant();
    Variant fieldName = new Variant();
    Variant fieldValue = new Variant();
    type.putShort(Constants.dbOpenDynaset);
    options.putShort(Constants.dbReadOnly);
    // create the recordset and get the number of records returned
    Recordset recordset = db.OpenRecordset(command, type, options);
    int retrievedRecordCount = 0;
    // retrieve the first row
    if (recordset.getRecordCount() &gt; 0)
        recordset.MoveFirst();
    // read all of the records
    while (retrievedRecordCount &lt; recordset.getRecordCount())
    {
        int trackingId;
        String title;
        // get the fields of the row
        Fields fields = recordset.getFields();
        _Field field;
        // retrieve all of the information and store it
        fieldName.putString(&quot;TRACKING_ID&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        trackingId = fieldValue.toInt();
        fieldName.putString(&quot;TITLE&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        title = fieldValue.toString();
        // save the request
        requestList.addElement(new Request(trackingId, title));
        // move the element indexing
        recordset.MoveNext();
        retrievedRecordCount++;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Notice that this method is static. This is done so that the method
can be called before a <TT>Request</TT> instance has been allocated.
The SQL statement used shows only a limited number of columns
being returned:
<BLOCKQUOTE>
<PRE>
String command = &quot;select TRACKING_ID, TITLE from REQUEST order by TRACKING_ID&quot;;
<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>order by</TT> clause in the <TT>Request.readAll</TT> method tells Access to return the requests in the order in which the IDs were assigned. This most likely will be the same order in which they were submitted. However, it is much more efficient on 
larger databases to use the primary key as an ordering column.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>readAll</TT> method is very similar to the <TT>read</TT>
method with respect to the order in which things are accomplished.
The difference is in the <TT>while</TT> statement and the fact
that multiple rows are returned, thus cycling through all of the
rows.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
When retrieving the record count from a recordset, the value returned will always be accurate when dealing with a table-type recordset, and it will be accurate for a dynaset or snapshot only after all records have been returned. Even when moving 
sequentially through a dynaset, the count returned will not always be a sequentially incrementing count, as would be expected. To handle this, the following code from <TT>Request.readAll</TT> could be used:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Recordset recordset = db.OpenRecordset(command, type, options);<BR>
int retrievedRecordCount = 0;<BR>
// retrieve the first row<BR>
if (recordset.getRecordCount() &gt; 0)<BR>
    recordset.MoveFirst();<BR>
// read all of the records<BR>
while (retrievedRecordCount &lt; recordset.getRecordCount())<BR>
{<BR>
    // process the record...<BR>
    // move the element indexing<BR>
    recordset.MoveNext();<BR>
    retrievedRecordCount++;<BR>
}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
If the value returned after opening the recordset is greater than <TT>0</TT>, at least one record was returned. Then, as long as the number of records that have been read is less than the record count being returned, continue reading records.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The public methods of the Request are summarized in Table 24.4.
<BR>
<P>
<CENTER><B>Table 24.4. Public methods of class Request.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=202><I>Method</I></TD><TD WIDTH=374><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>Request()</TT></TD><TD WIDTH=374>Constructs a new request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>Request(int, String)</TT></TD><TD WIDTH=374>Constructs a request representing an existing request with the given ID and title.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>GetTrackingIdStr()</TT></TD><TD WIDTH=374>Returns the ID in a displayable string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>GetCompletionDate()</TT></TD><TD WIDTH=374>Returns the completion date in a displayable string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>ToString()</TT></TD><TD WIDTH=374>Returns a string representing this class, containing the ID and title of the request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>Clear()</TT></TD><TD WIDTH=374>Clears the current request. Upon return, the request looks like a &quot;new&quot; request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>set(Request)</TT></TD><TD WIDTH=374>Sets the values to the same as the passed in request.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>Read(Database)</TT></TD><TD WIDTH=374>Reads the details of an existing request from the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>Write(Database)</TT></TD><TD WIDTH=374>Writes the current request to the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=202><TT>ReadAll(Database)</TT></TD><TD WIDTH=374>Static method used to read the basics of all requests in the system.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Operator">
Operator</A></H3>
<P>
<TT>Operator</TT> is used to hold information about a single user
or operator of the system. The stored information about the operator
corresponds to the columns in the <TT>OPERATOR</TT> table:
<BLOCKQUOTE>
<PRE>
public String UserName;
public String Password;
public String FirstName;
public String LastName;
public String AccessLevel;
</PRE>
</BLOCKQUOTE>
<P>
The access level can be used to control the types of services
or fields accessible by each operator. The values stored in the
database are represented by the following constants in the <TT>Operator</TT>
class:
<BLOCKQUOTE>
<PRE>
public final static String ADMINISTRATOR = &quot;A&quot;;
public final static String EXECUTIVE = &quot;E&quot;;
public final static String MANAGER = &quot;M&quot;;
public final static String PROGRAMMER = &quot;P&quot;;
public final static String GUEST = &quot;G&quot;;
</PRE>
</BLOCKQUOTE>
<P>
Database access in the <TT>Operator</TT> class is found through
the <TT>read</TT>, <TT>insert</TT>, <TT>update</TT>, and <TT>readAll</TT>
methods.
<P>
The <TT>read</TT> method reads in the operator details for the
operator represented by the string found in the <TT>UserName</TT>
member. Listing 24.4 contains the <TT>read</TT> method.
<HR>
<BLOCKQUOTE>
<B>Listing 24.4. The read method of Operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public boolean read(Database db)
{
    boolean retval = false;            // assume database error
    String command = &quot;select * from OPERATOR where USER_NAME = '&quot; +
            UserName + &quot;'&quot;;
    Variant type = new Variant();
    Variant options = new Variant();
    type.putShort(Constants.dbOpenDynaset);
    options.putShort(Constants.dbReadOnly);
    // create the recordset and get the number of records returned
    Recordset recordset = db.OpenRecordset(command, type, options);
    int recordCount = recordset.getRecordCount();
    // retrieve the first row
    if (recordCount &gt; 0) {
        recordset.MoveFirst();
        // get the fields of the row
        getFields(recordset.getFields());
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Because the user name is the primary key of the <TT>OPERATOR</TT>
table, only a single row is returned from the SQL statement:
<BLOCKQUOTE>
<PRE>
String command = &quot;select * from OPERATOR where USER_NAME = '&quot; +
        UserName + &quot;'&quot;;
</PRE>
</BLOCKQUOTE>
<P>
Once again, even though a dynaset is being returned, because only
a single row is expected in the recordset, the record count can
be used as a flag to determine if a row was found in the table.
To read the values of the row returned, the private method <TT>getFields</TT>
is called. The code for <TT>getFields</TT> can be found in Listing
24.5.
<HR>
<BLOCKQUOTE>
<B>Listing 24.5. The getFields method of Operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
private void getFields(Fields fields)
{
    Variant fieldName = new Variant();
    Variant fieldValue = new Variant();
    _Field field;
    // retrieve all of the information and store it
    fieldName.putString(&quot;USER_NAME&quot;);
    field = fields.getItem(fieldName);
    fieldValue = field.getValue();
    UserName = fieldValue.toString();
    fieldName.putString(&quot;PASSWORD&quot;);
    field = fields.getItem(fieldName);
    fieldValue = field.getValue();
    Password = fieldValue.toString();
    fieldName.putString(&quot;FIRST_NAME&quot;);
    field = fields.getItem(fieldName);
    fieldValue = field.getValue();
    FirstName = fieldValue.toString();
    fieldName.putString(&quot;LAST_NAME&quot;);
    field = fields.getItem(fieldName);
    fieldValue = field.getValue();
    LastName = fieldValue.toString();
    fieldName.putString(&quot;ACCESS_LEVEL&quot;);
    field = fields.getItem(fieldName);
    fieldValue = field.getValue();
    AccessLevel = fieldValue.toString();
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This method takes the <TT>Fields</TT> instance returned for the
current record of the recordset. The same field retrieval steps
discussed in the previous section are used to retrieve the value
for each column and place it in the appropriate class member.
<P>
The <TT>insert</TT> and <TT>update</TT> methods, shown in Listing
24.6, embed the values being written to the database directly
in the SQL statement used to perform the action.
<HR>
<BLOCKQUOTE>
<B>Listing 24.6. The insert and update methods of Operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public void insert(Database db)
{
    write(db, &quot;insert into OPERATOR values('&quot; + UserName +
            &quot;','&quot; + Password + &quot;','&quot; + FirstName + &quot;','&quot; +
            LastName + &quot;','&quot; + AccessLevel + &quot;')&quot;);
}
public void update(Database db)
{
    write(db, &quot;update OPERATOR set PASSWORD = '&quot; + Password +
            &quot;', FIRST_NAME = '&quot; + FirstName +
            &quot;', LAST_NAME = '&quot; + LastName +
            &quot;', ACCESS_LEVEL = '&quot; + AccessLevel +
            &quot;' where USER_NAME = '&quot; + UserName + &quot;'&quot;);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Both of the functions use the private <TT>write</TT> method to
execute the SQL statement. This method simply passes the SQL statement
to the appropriate <TT>Database</TT> method.
<BLOCKQUOTE>
<PRE>
private void write(Database db, String command)
{
    Variant options = new Variant();
    options.putShort(Constants.dbFailOnError);
    db.Execute(command, options);
}
</PRE>
</BLOCKQUOTE>
<P>
Listing 24.7 shows that the <TT>readAll</TT> method is very similar
to <TT>Request.readAll</TT>. One of the differences is that all
of the rows of the table are being returned, so that an open table
is used instead of a dynaset. Additionally, <TT>getFields</TT>
is used to retrieve the contents of the fields of each record.
<HR>
<BLOCKQUOTE>
<B>Listing 24.7. The readAll method of Operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public static boolean readAll(Database db, Vector operatorList)
{
    boolean retval = false;            // assume database error
    Variant type = new Variant();
    Variant options = new Variant();
    type.putShort(Constants.dbOpenTable);
    options.putShort(Constants.dbReadOnly);
    // create the recordset and get the number of records returned
    Recordset recordset = db.OpenRecordset(&quot;OPERATOR&quot;, type, options);
    int recordCount = recordset.getRecordCount();
    // retrieve the first row
    if (recordCount &gt; 0)
        recordset.MoveFirst();
    // read all of the records
    while (recordCount &gt; 0)
    {
        Operator op = new Operator();
        // get the fields of the row
        op.getFields(recordset.getFields());
        // save the operator
        operatorList.addElement(op);
        // move the element indexing
        recordset.MoveNext();
        recordCount-;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The public methods of <TT>Operator</TT> are summarized in Table
24.5.<BR>
<P>
<CENTER><B>Table 24.5. Public methods of class Operator.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Operator()</TT></TD><TD WIDTH=384>Constructs a new operator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToString()</TT></TD><TD WIDTH=384>Returns a string representing this class, containing the name of the operator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Clear()</TT></TD><TD WIDTH=384>Clears the current operator. Upon return, the operator looks like a &quot;new&quot; operator.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>set(String, String, String, String, String)</TT>
</TD><TD WIDTH=384>Sets the values of the member variables to the parameters passed in.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>set(Operator)</TT></TD><TD WIDTH=384>Sets this operator to an operator with the given operator information.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetUserName(String)</TT></TD><TD WIDTH=384>Sets the username of the current operator to the parameter passed in.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>insert(Database)</TT></TD><TD WIDTH=384>Inserts a new row into the database table with the current information.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Update(Database)</TT></TD><TD WIDTH=384>Updates the row with the operator's information with the given username.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Read(Database)</TT></TD><TD WIDTH=384>Reads the details of an existing operator from the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ReadAll(Database)</TT></TD><TD WIDTH=384>Static method used to read all operators in the system.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Department">
Department</A></H3>
<P>
The final database-access class is used for the <TT>DEPARTMENT</TT>
table. This class is a simpler version of the <TT>Operator</TT>
class. The only information is stored in the two members:
<BLOCKQUOTE>
<PRE>
public String Code;
public String Name;
</PRE>
</BLOCKQUOTE>
<P>
The remainder of the class is very similar to the <TT>Operator</TT>
class, and the public methods are summarized in Table 24.6.<BR>
<P>
<CENTER><B>Table 24.6. Public methods of class Department.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Department()</TT></TD><TD WIDTH=384>Constructs a new department.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ToString()</TT></TD><TD WIDTH=384>Returns a string representing this class, containing the name of the department.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Clear()</TT></TD><TD WIDTH=384>Clears the current department. Upon return, the department looks like a &quot;new&quot; department.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>set(String, String)</TT></TD><TD WIDTH=384>Sets the values of the member variables to the parameters passed in.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>set(Department)</TT></TD><TD WIDTH=384>Sets this department to a department with the given information.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>SetCode(String)</TT></TD><TD WIDTH=384>Sets the code of the current department to the parameter passed in.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>insert(Database)</TT></TD><TD WIDTH=384>Inserts a new row into the database table with the current information.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Update(Database)</TT></TD><TD WIDTH=384>Updates the row with the department's information using the given department code.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>Read(Database)</TT></TD><TD WIDTH=384>Reads the details of an existing department from the database.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ReadAll(Database)</TT></TD><TD WIDTH=384>Static method used to read all departments in the system.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="UserInterface"><FONT SIZE=5 COLOR=#FF0000>
User Interface</FONT></A></H2>
<P>
The user interface is created with <TT>CardLayout</TT> to control
the displaying of the three screens in the DevRequest applet.
Each contains a single panel, which includes the more sophisticated
<TT>GribBagLayout</TT> to place various controls on the dialog.
<H3><A NAME="CommonClasses">
Common Classes</A></H3>
<P>
During the course of developing the DevRequest applet, it was
apparent that there was a need for several common classes. This
need included controls to associate a data element with each item
in both a Choice and List control, and a common <TT>Panel</TT>
class that provides messaging methods.
<H4>Data Aware Choice and List Controls</H4>
<P>
To display a list of options on a <TT>Panel</TT>, a Choice or
a List control might be used. When developing more involved applets,
there will often be times when the choice made in a Choice or
List will imply the use of not only the selected string, but also
the entity that that selected string represents. For example,
the DevRequest has the potential of displaying a list of all operators
in the system in a Choice control for selecting by whom the request
was generated. Additional fields could also be added to the DevRequest
applet to collect data on who reviewed the request, who approved
the request at every management level needed, among other locations
throughout the applet. For each of these situations, the logical
item to place in the Choice control is the name of the person.
However, the name is not what is used to uniquely identify operators.
Therefore, you would like to be able to associate the username
with each name in the list. Even more appropriate would be to
associate an <TT>Operator</TT> instance with each name in the
list.
<P>
A simple extension to the <TT>Choice</TT> class would be to add
a <TT>Vector</TT> that holds an object reference for each item
added to the list. Listing 24.8 contains the complete class implementation
for the <TT>ChoiceData</TT> class that associates a data element
with each item in the list.
<HR>
<BLOCKQUOTE>
<B>Listing 24.8. The ChoiceData class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
/*
 *
 * ChoiceData
 *
 * This class extends the choice control and adds the ability
 *   to associate a data element with each item in the choice
 *   list.
 */
public class ChoiceData extends Choice
{
    protected Vector Data = new Vector();
    public void addItemData(String item, Object obj)
    {
        addItem(item);                  // add item to choices
        Data.addElement(obj);           // add date to the data list
    }
    public void selectByData(Object obj)
    {
        // find the data in the data list
        int index = Data.indexOf(obj);
        // select the corresponding element
        select(index);
    }
    public Object getSelectedData()
    {
        return getSelectedIndex() &gt;= 0 ?
                Data.elementAt(getSelectedIndex()) : null;
    }
    public void load(Vector data)
    {
        // add each element to the choice list and the data list
        for (Enumeration enum = data.elements();
                enum.hasMoreElements();)
        {
            Object ob = enum.nextElement();
            addItemData(ob.toString(), ob);
        }
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<TT>ChoiceData</TT> now allocates a <TT>Vector</TT> instance,
<TT>Data</TT>, that will be a list of data items associated with
each item in the control. Because all of the items are added to
the end of the list in the control, the same can be done for the
respective data elements. Additionally, the control and the <TT>Vector</TT>
index their respective items with a zero relative offset. Both
of these facts enable an easy one-to-one correspondence between
the elements in the Choice control and the elements in the <TT>Vector</TT>.
<P>
A new set of data methods are added to the <TT>ChoiceData</TT>
class that operate on both items and data elements. <TT>addItemData
</TT>is used to add a string item to the control and an object
to the data list. Both entities are added to the end of their
respective lists so that index relationships are maintained. <TT>selectByData</TT>
uses this index relationship to find a data element in the data
list and select its corresponding item in the control. Similarly,
<TT>getSelectedData</TT> is used to return the data element associated
with the currently selected item in the control.
<P>
<TT>load</TT> is used to fill the control with a list of items
in a single method call. This method uses an <TT>Enumeration</TT>
to add each item of the <TT>Vector</TT> to the control. The <TT>toString</TT>
method of the list elements is used to determine the string displayed
in the control.
<P>
The corresponding <TT>ListData</TT> class contains all of the
methods described in the <TT>ChoiceData</TT> class. One additional
functionality that the list provides is the ability to clear the
list. The <TT>ListData</TT> equivalent simply has to clear both
the control and the data elements:
<BLOCKQUOTE>
<PRE>
public void clear()
{
    super.clear();                    // clear the list
    Data.removeAllElements();        // clear the data
}
</PRE>
</BLOCKQUOTE>
<H4>StatusPanel</H4>
<P>
The DevRequest applet contains a number of <TT>Panel</TT>-derived
classes that are used to logically group controls. There are a
couple of concepts used with the DevRequest panels that are not
possible with the standard Java classes. These include drawing
a border around the perimeter of the panel and displaying a message
to the applet status bar. Listing 24.9 contains the listing of
the <TT>StatusPanel</TT> class that provides these capabilities.
<HR>
<BLOCKQUOTE>
<B>Listing 24.9. The StatusPanel class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
/*
 *
 * StatusPanel
 *
 * This class provides a simple means to display a status message to
 *   the applet's status bar.
 */
public class StatusPanel extends Panel
{
    protected boolean hasBorder = false;
    public StatusPanel()
    {
        hasBorder = false;
    }
    public StatusPanel(boolean hasBorder)
    {
        this.hasBorder = hasBorder;
    }
    public void paint(Graphics g)
    {
        if (hasBorder)
        {
            // draw a rectangle around the panel
            Rectangle rect = bounds();
            g.drawRect(0, 0, rect.width - 1, rect.height - 1);
        }
    }
    protected void setStatus(String msg)
    {
        Applet applet = getAppletParent();
        applet.showStatus(msg);
    }
    protected void setStatus(ComException comE)
    {
        Applet applet = getAppletParent();
        if (applet instanceof DevRequest)
        {
            Variant comError = new Variant();
            comError.putShort((short)(comE.getHResult()));
            Errors errs = ((DevRequest)applet).dbEngine.getErrors();
            dao3032.Error err = errs.getItem(comError);
            applet.showStatus(&quot;DB Error: &quot; + err.getDescription());
        }
        else
            applet.showStatus(comE.getMessage());
    }
    private Applet getAppletParent()
    {
        java.awt.Container parent = getParent();
        while (!(parent instanceof Applet))
            parent = parent.getParent();
        return (Applet)parent;
    }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>hasBorder</TT> member is a flag used in the <TT>paint</TT>
method to draw a simple border around the perimeter of the panel.
It is defaulted to not have a border, but it can be modified by
passing a parameter to the constructor. The <TT>setStatus</TT>
method is used to place a message on the status bar of the browser
the applet is being run from. It uses the private <TT>getAppletParent</TT>
method to retrieve the applet from the parent container  of the
panel control. <TT>getAppletParent</TT> assumes that every control
eventually has an ancestor that is <TT>Applet</TT> derived. It
uses a <TT>while</TT> loop to traverse the parent chain and the
<TT>instanceof</TT> operator to find the applet where the panel
resides. The second version of the <TT>setStatus</TT> method takes
a COM exception raised by a DAO object and displays the error
message associated with the exception.
<H4>DevRequest</H4>
<P>
<TT>DevRequest</TT> is derived from the <TT>Applet</TT> class
and implements the <TT>Observer</TT> interface to monitor when
the user information has changed so that the appropriate screen
can be displayed. The <TT>init</TT> method first allocates the
database connection that will be used throughout the applet. This
is done with the following <TT>OpenDatabase</TT> method:
<BLOCKQUOTE>
<PRE>
protected boolean OpenDatabase()
{
    URL dbURL;
    try {
        // otherwise generate it relative to the applet
        dbURL = new java.net.URL(getDocumentBase(),
                &quot;DevDb.mdb&quot;);
    }
    catch(Exception e) {
        showStatus(&quot;Error: &quot; + e.getMessage());
        return false;
    }
    // strip &quot;file:/&quot; from dbURL
    String filename = dbURL.getFile().substring(1);
    // create the database engine
    dbEngine = dao_dbengine.create();
    // create Variants that will hold parameters that
    // will be passed to OpenDatabase
    Variant exclusive = new Variant();
    Variant readOnly = new Variant();
    Variant source = new Variant();
    // set parameters for call to OpenDatabase
    exclusive.putBoolean(false);
    readOnly.putBoolean(false);
    source.putString(&quot;&quot;);
    // open the database for non-exclusive access
    db = dbEngine.OpenDatabase(filename, exclusive, readOnly, source);
    return true;
}
</PRE>
</BLOCKQUOTE>
<P>
Next, <TT>init</TT> adds the applet to the observer list of the
<TT>UserInformation</TT> instance. This causes the <TT>update</TT>
method of the applet to be called every time the <TT>UserInformation</TT>
is updated. Finally, the <TT>CardLayout</TT> is allocated and
the panels are added to the applet with the <TT>AllocatePanels</TT>
method:
<BLOCKQUOTE>
<PRE>
protected void AllocatePanels()
    {
        // the main layout manager will be a card layout
        layout = new CardLayout();
        setLayout(layout);
        add(UserInformation.LOGIN, new LoginPanel(db, UserInfo));
        add(UserInformation.CONTROL, new ControlPanel(db, UserInfo));
        add(UserInformation.ADMINISTRATION, new AdministrationPanel(db, UserInfo));
    }
</PRE>
</BLOCKQUOTE>
<P>
Notice that the name used when adding the panel components is
defined as a constant in the <TT>UserInformation</TT> class. The
<TT>update</TT> method of <TT>DevRequest</TT> looks at the currently
logged-on user information for the next screen to be displayed:
<BLOCKQUOTE>
<PRE>
public void update(Observable o, Object arg)
{
    // if the user information has changed, assume login
    //   has been successful and go to control
    if (o instanceof UserInformation)
        layout.show(this, UserInfo.NextScreen);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>UserInformation</TT> class is used in conjunction with
the <TT>DevRequest</TT> class to control displaying of the screens
at various points in the application. There are two sets of constants
defined in the <TT>UserInformation</TT> class. The first set are
the names used for the screens of the dialog:
<BLOCKQUOTE>
<PRE>
public final static String LOGIN = &quot;Login&quot;;
public final static String CONTROL = &quot;Control&quot;;
public final static String ADMINISTRATION = &quot;Administration&quot;;
</PRE>
</BLOCKQUOTE>
<P>
These define the names of the dialogs and are used when signaling
the next screen to be displayed. The second set of constants is
used when associating the access level of the currently logged-on
user with a numerical value. This value can then be queried to
determine if certain elements are available to the user. The following
is the list of possible values:
<BLOCKQUOTE>
<PRE>
public final static int ADMINISTRATOR = 0;    // database level
public final static int EXECUTIVE = 1;
public final static int MANAGER = 2;
public final static int PROGRAMMER = 3;
public final static int GUEST = 4;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>setAccessLevel</TT> method takes an access-level string,
presumably read from the database, and associates one of the preceding
constants to the current user.
<P>
<TT>signalNextScreen</TT> and <TT>done</TT> are methods used to
notify the observers of this class that the next screen has been
changed and needs to be displayed. <TT>signalNextScreen</TT> is
used to control the order in which screens are displayed:
<BLOCKQUOTE>
<PRE>
// This method controls the order that the screens are displayed.
public void signalNextScreen()
{
    // if at the login or administration screens, then go back
    //   to the control; otherwise, go to the administration
    if ((NextScreen == LOGIN) || (NextScreen == ADMINISTRATION))
        NextScreen = CONTROL;
    else
        NextScreen = ADMINISTRATION;
    // notify on lookers for actual changing of the panels
    done();
}
</PRE>
</BLOCKQUOTE>
<P>
In the DevRequest applet, the order of the display of the screens
is straightforward and boils down to a simple <TT>if</TT> statement.
If the current screen is not the control screen, then the next
screen will be. Otherwise, go to the administration screen. The
private <TT>done</TT> method is used to call the <TT>Observable</TT>
class methods that notify the observers that a change has occurred.
<BLOCKQUOTE>
<PRE>
// This method is used to signal all observers that
//   this class is done changing.
private void done()
{
    setChanged();
    notifyObservers();
}
</PRE>
</BLOCKQUOTE>
<P>
The panels that are added to the applet correspond to the three
screens of the applet: Login, Control, and Administration.
<H4>LoginPanel</H4>
<P>
<TT>LoginPanel</TT> is a simple panel that displays text fields
to collect the username and password (see Figure 24.2). The layout
is performed with a <TT>GridBagLayout</TT> manager in the constructor:
<BLOCKQUOTE>
<PRE>
public LoginPanel(Database db, UserInformation UserInfo)
{
    super();
    // save the passed in information
    this.db = db;
    this.UserInfo = UserInfo;
    // make a grid bag layout for the panel
    GridBagLayout layout = new GridBagLayout();
    GridBagConstraints gbc = new GridBagConstraints();
    setLayout(layout);
    // put a little space above and below the controls
    gbc.insets.top = gbc.insets.bottom = 4;
    // create the controls for this panel
    gbc.weightx = 1.0;                // center 2 controls side-by-side
    gbc.anchor = GridBagConstraints.EAST;
    Label lbl = new Label(&quot;User Name:&quot;, Label.RIGHT);
    layout.setConstraints(lbl, gbc);
    add(lbl);
    // make the text field the last on the line
    gbc.anchor = GridBagConstraints.WEST;
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    layout.setConstraints(UserNameField, gbc);
    add(UserNameField);
    gbc.anchor = GridBagConstraints.EAST;
    gbc.gridwidth = 1;
    lbl = new Label(&quot;Password:&quot;, Label.RIGHT);
    layout.setConstraints(lbl, gbc);
    add(lbl);
    // make the text field the last on the line
    gbc.anchor = GridBagConstraints.WEST;
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    layout.setConstraints(PasswordField, gbc);
    PasswordField.setEchoCharacter('*');
    add(PasswordField);
    // add the button on its own line
    gbc.anchor = GridBagConstraints.CENTER;
    Button btn = new Button(&quot;Logon&quot;);
    layout.setConstraints(btn, gbc);
    add(btn);
    // put all of the space at the bottom
    gbc.fill = GridBagConstraints.BOTH;
    gbc.weighty = 1.0;
    Panel space = new Panel();
    layout.setConstraints(space, gbc);
    add(space);
}
</PRE>
</BLOCKQUOTE>
<P>
First, the passed-in information is stored in member variables
for use later on in the class. Next, a <TT>GridBagLayout</TT>
is allocated and set as the layout manager for the panel. To add
some format to this form, the sets of two controls are added so
that the inner sides are centered horizontally on the form. The
button is next placed on a line of its own and centered. So that
the buttons are not vertically centered, but rather at the top
of the form, an empty panel is added on the line following the
button. It was given the capability to grow in the vertical direction,
yet leave the vertical height of the rest of the controls the
same. Therefore, the <TT>space</TT> panel fills the area below
the button and above the bottom of the form.
<P>
The <TT>action</TT> method of the <TT>LoginPanel</TT> class processes
the pushing of the Logon button. It first assumes that both a
username and a password are required, so appropriate checks are
made. If either field is empty, a message is written to the status
bar. Next, the username and password are validated using the following
validation routine:
<BLOCKQUOTE>
<PRE>
protected boolean ValidateUser()
{
    boolean retval = false;            // assume no logon
    String command = &quot;select * from OPERATOR where USER_NAME = '&quot; +
            UserNameField.getText().toLowerCase() +
            &quot;' and PASSWORD = '&quot; +
            PasswordField.getText().toLowerCase() + &quot;'&quot;;
    Variant type = new Variant();
    Variant options = new Variant();
    type.putShort(Constants.dbOpenDynaset);
    options.putShort(Constants.dbEditAdd);
    // create the recordset
    Recordset recordset = db.OpenRecordset(command, type, options);
    // if there was a record returned, then get the user's info
    if (recordset.getRecordCount() &gt; 0)
    {
        Variant fieldName = new Variant();
        Variant fieldValue = new Variant();
        // retrieve the first (and only) row
        recordset.MoveFirst();
        // get the fields of the row
        Fields fields = recordset.getFields();
        _Field field;
        // retrieve all of the information and store it
        fieldName.putString(&quot;USER_NAME&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        UserInfo.UserName = fieldValue.toString();
        fieldName.putString(&quot;FIRST_NAME&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        UserInfo.FirstName = fieldValue.toString();
        fieldName.putString(&quot;LAST_NAME&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        UserInfo.LastName = fieldValue.toString();
        fieldName.putString(&quot;ACCESS_LEVEL&quot;);
        field = fields.getItem(fieldName);
        fieldValue = field.getValue();
        UserInfo.setAccessLevel(fieldValue.toString());
        retval = true;                // found an entry
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
This method is similar to the <TT>read</TT> method of the <TT>Operator</TT>
class. The distinguishing factor is that the row selected must
match both the username and the password, as evident in the SQL
statement:
<BLOCKQUOTE>
<PRE>
String command = &quot;select * from OPERATOR where USER_NAME = '&quot; +
        UserNameField.getText().toLowerCase() +
        &quot;' and PASSWORD = '&quot; +
        PasswordField.getText().toLowerCase() + &quot;'&quot;;
</PRE>
</BLOCKQUOTE>
<P>
The last task performed by the <TT>action</TT> processing of the
Logon button is to change to the next screen via the <TT>UserInformation</TT>
class.
<H4>ControlPanel</H4>
<P>
The <TT>ControlPanel</TT> is separated into three sections of
the screen: the button panel across the top enabling the user
to enter a new request, get detailed information about an existing
request, or go to the administration screen; a list of all of
the currently active requests; and a panel containing the detailed
information about the request. Once again, these controls are
placed on the dialog using a <TT>GridBagLayout</TT> manager allocated
in the constructor:
<BLOCKQUOTE>
<PRE>
public ControlPanel(Database db, UserInformation UserInfo)
{
    super();
    // save the passed in information
    this.db = db;
    this.UserInfo = UserInfo;
    // make a grid bag layout for the panel
    GridBagLayout layout = new GridBagLayout();
    GridBagConstraints gbc = new GridBagConstraints();
    setLayout(layout);
    // put a little space above and below the controls
    gbc.insets.top = gbc.insets.bottom = 2;
    // create the controls for this panel
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    AdministrationButton.hide();
    Panel p = new Panel();
    p.add(new Button(&quot;New&quot;));
    p.add(new Button(&quot;Details&quot;));
    p.add(AdministrationButton);
    layout.setConstraints(p, gbc);
    add(p);
    gbc.weightx = 1.0;                // equally space remaining
    gbc.weighty = 1.0;                // let list fill remaining space
    gbc.gridwidth = GridBagConstraints.RELATIVE;
    gbc.fill = GridBagConstraints.BOTH;
    layout.setConstraints(RequestList, gbc);
    add(RequestList);

    gbc.gridwidth = GridBagConstraints.REMAINDER;
    ReqPanel = new RequestPanel(this, db);
    layout.setConstraints(ReqPanel, gbc);
    add(ReqPanel);
    readRequests();
}
</PRE>
</BLOCKQUOTE>
<P>
The last task performed in the <TT>ControlPanel</TT> constructor
is the reading of the requests from the database using the <TT>readRequest</TT>
method:
<BLOCKQUOTE>
<PRE>
public void readRequests()
{
    // kill existing list
    RequestList.clear();
    Vector requests = new Vector();
    // query the database for all of the requests
    Request.readAll(db, requests);
    // load the list
    RequestList.load(requests);
    // clear the current panel
    ReqPanel.setRequest(new Request());
}
</PRE>
</BLOCKQUOTE>
<P>
Because this method can be called multiple times throughout the
life of the panel, the current contents of the list are cleared
before adding the new contents. <TT>Request.readAll</TT> is used
to read in all of the requests from the database. The <TT>ListData.load</TT>
method is used to bulk load the list. The last task performed
is to clear the contents of the <TT>Details</TT> panel.
<P>
The <TT>action</TT> method handles the button-press event by sending
a newly allocated request to the details panel, sending the data
item associated with the selected list item to the details panel,
or using the <TT>UserInformation</TT> class to go to the administration
screen.
<P>
The <TT>show</TT> method of the <TT>ControlPanel</TT> class selectively
shows the administration button if the user has the appropriate
access level. Notice that this check must be performed in the
<TT>show</TT> method, as opposed to the constructor, because the
<TT>UserInformation</TT> has not been filled in when the constructor
gets called.
<BLOCKQUOTE>
<PRE>
public void show()
{
    if (UserInfo.AccessLevel &lt;= UserInformation.ADMINISTRATOR)
        AdministrationButton.show();
    super.show();
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>RequestPanel</TT> class represents the detailed information
about a request. Figure 24.7 shows the bounds of the <TT>RequestPanel</TT>
class on the control screen.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-7.gif"><B> Figure 24.7 : </B><I>RequestPanel display on the control screen.
</I></A><P>
<P>
Once again, the placement of the controls on the panel becomes
an exercise on the use of a <TT>GridBagLayout</TT> manager in
the constructor of the <TT>RequestPanel</TT>. Additionally, in
the constructor, the following two methods are called to populate
the Choice controls with the operators and departments:
<BLOCKQUOTE>
<PRE>
private void loadOperators()
{
    Vector operators = new Vector();
    Operator.readAll(db, operators);
    RequestorChoice.load(operators);
}
private void loadDepartments()
{
    Vector depts = new Vector();
    Department.readAll(db, depts);
    ApprovedBudgetChoice.load(depts);
}
</PRE>
</BLOCKQUOTE>
<P>
Both of these methods use the bulk-loading capabilities of the
<TT>ChoiceData</TT> control.
<P>
To display a new request, the <TT>setRequest</TT> method is called.
This method simply saves the request class instance and populates
the controls:
<BLOCKQUOTE>
<PRE>
public void setRequest(Request req)
{
    // save the request as the current request
    CurrentRequest = req;
    TrackingIdField.setText(CurrentRequest.getTrackingIdStr());
    SubmissionDateField.setText(
            CurrentRequest.SubmissionDate.toLocaleString());
    CompletionDateField.setText(CurrentRequest.getCompletionDate());
    TitleField.setText(CurrentRequest.Title);
    DescriptionArea.setText(CurrentRequest.Description);
    RequestorChoice.select(CurrentRequest.Requestor.toString());
    StatusChoice.selectByData(CurrentRequest.Status);
    ApprovedBudgetChoice.select(CurrentRequest.ApprovedBudget.toString());
}
</PRE>
</BLOCKQUOTE>
<P>
To save any details that were modified, the <TT>action</TT> method
responds to the Save button:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
    boolean retval = false;            // assume no action
    if (&quot;Save&quot;.equals(obj))
    {
        if (validateFields())
        {
            try
            {
                CurrentRequest.write(db);
                conPanel.readRequests();
            }
            catch(ComException e)
            {
                setStatus(e);
            }
        }
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
Before the details are written to the database, the fields are
validated with a call to the <TT>validateFields</TT> method:
<BLOCKQUOTE>
<PRE>
private boolean validateFields()
{
    boolean retval = false;            // assume not enough info
    if (TitleField.getText().length() &gt; 0)
    {
        CurrentRequest.Title = TitleField.getText();
        CurrentRequest.Description = DescriptionArea.getText();
        CurrentRequest.Requestor =
                (Operator)RequestorChoice.getSelectedData();
        CurrentRequest.Status = (String)StatusChoice.getSelectedData();
        CurrentRequest.ApprovedBudget =
               (Department)ApprovedBudgetChoice.getSelectedData();
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
DevRequest requires that a title be specified for every request
entered in the system. Therefore, the length of the title is checked
to make sure one has been entered. If so, then the control information
is saved, gathered, and placed in the current request structure
before returning to the <TT>action</TT> method.
<P>
After the fields have been validated, the <TT>action</TT> method
writes the information to the database. If no exceptions were
raised, the list of the <TT>ControlPanel</TT> is updated to reflect
any changes that may have occurred as a result of saving the request.
<H4>AdministrationPanel</H4>
<P>
The final screen in the system is the Administration screen (see
Figure 24.8), which is composed of two panels displaying the operator
and department information, and a button used to return to the
<TT>ControlPanel</TT>. Once again, the <TT>GridBagLayout</TT>
manager is used in the constructor:
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-8.gif"><B> Figure 24.8 : </B><I>OperatorPanel display on the Administration screen.
</I></A><P>
<BLOCKQUOTE>
<PRE>
    public AdministrationPanel(Database db, UserInformation UserInfo)
    {
        super();
// save the passed in information
        this.db = db;
        this.UserInfo = UserInfo;
        // make a grid bag layout for the panel
        GridBagLayout layout = new GridBagLayout();
        GridBagConstraints gbc = new GridBagConstraints();
        setLayout(layout);
        gbc.weightx = 1.0;                // let list fill remaining space
        gbc.weighty = 1.0;                // let list fill remaining space
        gbc.gridwidth = 1;
        gbc.gridheight = 2;
        gbc.fill = GridBagConstraints.BOTH;
        OperatorPanel opPanel = new OperatorPanel(db);
        layout.setConstraints(opPanel, gbc);
        add(opPanel);
        gbc.gridheight = 1;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        DepartmentPanel deptPanel = new DepartmentPanel(db);
        layout.setConstraints(deptPanel, gbc);
        add(deptPanel);
        gbc.weightx = 0.0;
        gbc.weighty = 0.0;
        gbc.anchor = GridBagConstraints.EAST;
        gbc.fill = GridBagConstraints.NONE;
        Button btn = new Button(&quot;Done&quot;);
        layout.setConstraints(btn, gbc);
        add(btn);
    }
</PRE>
</BLOCKQUOTE>
<P>
You might be wondering why the <TT>GridBagLayout</TT> manager
is used so extensively. The reason is that this layout manager
is great at laying out controls relative to other controls. Because
the majority of controls have some type of relationship to other
controls being added to the container, this layout manager is
an excellent choice. Also, if additional controls are added later,
a lot of the positioning manipulation of existing controls is
eliminated-the layout manager takes care of it.
<P>
The only other method in <TT>AdministrationPanel</TT> is the <TT>action</TT>
method that handles the processing of the Done button click and
uses the <TT>UserInformation</TT> class to return to the control
screen.
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
    boolean retval = false;            // assume not processed
    if (&quot;Done&quot;.equals(obj))
    {
        UserInfo.signalNextScreen();
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
There are two panels added to the <TT>AdministrationPanel</TT>:
<TT>OperatorPanel</TT> and <TT>DepartmentPanel</TT>. As you might
have guessed, these panels display operator (Figure 24.8) and
department (Figure 24.9) information.
<P>
<A HREF="http://docs.rinet.ru/WebJPP/f24-9.gif"><B> Figure 24.9 : </B><I>DepartmentPanel display on the Administration screen.
</I></A><P>
<P>
The <TT>OperatorPanel</TT> uses a, you guessed it, <TT>GridBagLayout</TT>
manager to place an adjustable-height List control above a detail
panel and two side-by-side buttons on the panel:
<BLOCKQUOTE>
<PRE>
public OperatorPanel(Database db)
{
    super(true);
    // save the passed in information
    this.db = db;
    // make a grid bag layout for the panel
    GridBagLayout layout = new GridBagLayout();
    GridBagConstraints gbc = new GridBagConstraints();
    setLayout(layout);
    // put a little space above around the controls
    gbc.insets.left = gbc.insets.top =
            gbc.insets.right = gbc.insets.bottom = 2;
    gbc.weighty = 1.0;                // let list fill remaining space
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.fill = GridBagConstraints.BOTH;
    layout.setConstraints(OperatorList, gbc);
    add(OperatorList);
    gbc.weighty = 0.0;                // don't resize remaining controls
    StatusPanel opInfo = getOperatorInfoPanel();
    layout.setConstraints(opInfo, gbc);
    add(opInfo);
    // add two side-by-side buttons
    gbc.weightx = 1.0;                // equally space horizontally
    gbc.gridwidth = 1;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    Button btn = new Button(&quot;New&quot;);
    layout.setConstraints(btn, gbc);
    add(btn);
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    btn = new Button(&quot;Update&quot;);
    layout.setConstraints(btn, gbc);
    add(btn);
    // read in the operators from the database
    readOperators();
}
</PRE>
</BLOCKQUOTE>
<P>
Additionally, the <TT>readOperators</TT> method is called to populate
the list:
<BLOCKQUOTE>
<PRE>
private void readOperators()
{
    // kill existing list
    OperatorList.clear();
    Vector operators = new Vector();
    Operator.readAll(db, operators);
    OperatorList.load(operators);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>action</TT> method handles the processing of the buttons:
<BLOCKQUOTE>
<PRE>
public boolean action(Event evt, Object obj)
{
    boolean retval = false;            // assume not processed
    if (&quot;New&quot;.equals(obj))
    {
        if (validateFields())
        {
            try
            {
                CurrentOperator.insert(db);
                readOperators();
            }
            catch(ComException e)
            {
                setStatus(e);
            }
        }
        retval = true;
    }
    else if (&quot;Update&quot;.equals(obj))
    {
        if (validateFields())
        {
            try
            {
                CurrentOperator.update(db);
                readOperators();
            }
            catch(Exception e)
            {
                setStatus(&quot;DB Error: &quot; + e.getMessage());
            }
        }
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
If the New button is pressed, the fields are validated and moved
into the <TT>CurrentOperator</TT> instance using the <TT>validateFields</TT>
method. The operator is then written to the database as a new
row. If an operator is duplicated in the database, then an exception
will be raised and the error message will be displayed on the
status line of the browser. If the Update button is pressed, the
fields are again validated and placed in the <TT>CurrentOperator</TT>
class. The row in the database is then updated with the new information.
<P>
The fields are validated by making sure the username has been
entered and the two password entries are identical:
<BLOCKQUOTE>
<PRE>
private boolean validateFields()
{
    boolean retval = false;            // assume not enough info
    if ((UserNameField.getText().length() &gt; 0) &amp;&amp;
            (PasswordField.getText().equals(ConfirmPasswordField.getText())))
    {
        // move information to the current operator
        CurrentOperator.set(UserNameField.getText(),
                PasswordField.getText(),
                FirstNameField.getText(),
                LastNameField.getText(),
                (String)AccessLevelChoice.getSelectedData());
        retval = true;
    }
    return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
The final functionality provided in this class is to automatically
populate the details when an operator is selected from the list.
This is handled by overriding the <TT>handleEvent</TT> method.
<BLOCKQUOTE>
<PRE>
public boolean handleEvent(Event evt)
{
    boolean retval;
    switch(evt.id) {
    case Event.LIST_SELECT:
    case Event.LIST_DESELECT:
        fillCurrentOperator();
        retval = true;
        break;
   default:
        retval = super.handleEvent(evt);
        break;
   }
   return retval;
}
</PRE>
</BLOCKQUOTE>
<P>
When an item in a list is selected, an event is generated with
an ID of <TT>Event.LIST_SELECT</TT>. Similarly, when the item
is deselected, an <TT>Event.LIST_DESELECT</TT> event is generated.
By trapping both of these events and calling the <TT>fillCurrentOperator</TT>
method every time the selection changes, the details can be modified
to show the currently selected operator.
<P>
<TT>fillCurrentOperator</TT> simply queries the list for the selected
item and uses the data associated with that item to populate the
detail information controls. If there is no item selected, then
the List will generate an <TT>ArrayIndexOutOfBoundsException</TT>
exception. This method traps that exception and simply clears
the current operator so that the detail fields will be cleared.
<BLOCKQUOTE>
<PRE>
private void fillCurrentOperator()
{
    try
    {
        Operator op = (Operator)OperatorList.getSelectedData();
        CurrentOperator.set(op);
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
        CurrentOperator.clear();
    }
    UserNameField.setText(CurrentOperator.UserName);
    PasswordField.setText(CurrentOperator.Password);
    ConfirmPasswordField.setText(CurrentOperator.Password);
    FirstNameField.setText(CurrentOperator.FirstName);
    LastNameField.setText(CurrentOperator.LastName);
    AccessLevelChoice.selectByData(CurrentOperator.AccessLevel);
}
</PRE>
</BLOCKQUOTE>
<P>
<TT>DepartmentPanel</TT> is very similar to the <TT>OperatorPanel</TT>.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
This chapter took a first step toward developing an online request
system. It involved a multiscreen applet that displayed a number
of controls. In addition, the data collected was stored in a database
using Microsoft's DAO so that information could be stored for
later retrieval. As in any trip, there are many steps to follow,
which take you down a number of paths. This applet could be easily
modified to include additional controls specific to your needs.
Additional types of forms could be included along with the appropriate
routing mechanisms, and the database could be expanded or the
DAO modified to access existing databases.
<HR>

<CENTER><P><A HREF="ch23.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch25.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
