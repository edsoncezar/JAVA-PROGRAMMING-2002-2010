<HTML>
<HEAD>
<TITLE>Chapter 10 -- Working with Java Strings</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">








<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;10</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Working with Java Strings</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#TheStringClass">
The String Class</A>
<UL>
<LI><A HREF="#ConstructingNewStrings">
Constructing New Strings</A>
<LI><A HREF="#BasicStringMethods">
Basic String Methods</A>
<LI><A HREF="#ConvertingVariablestoStrings">
Converting Variables to Strings</A>
<LI><A HREF="#UsingOnlyPartofaString">
Using Only Part of a String</A>
<LI><A HREF="#ComparingStrings">
Comparing Strings</A>
<LI><A HREF="#SearchingStrings">
Searching Strings</A>
</UL>
<LI><A HREF="#TheStringBufferClass">
The StringBuffer Class</A>
<UL>
<LI><A HREF="#UsefulStringBufferMethods">
Useful StringBuffer Methods</A>
<LI><A HREF="#Appending">
Appending</A>
<LI><A HREF="#Inserting">
Inserting</A>
</UL>
<LI><A HREF="#Summary">
Summary</A>
</UL>
</UL>
<HR>
<P>
In this chapter you learn about the <TT>String</TT> and <TT>StringBuffer</TT>
classes, two of the classes you will use most in your Java programming
career. You learn how to convert other object types into strings
so they can be displayed. You also learn how to perform a number
of other operations on strings, including case conversion, searching
for characters or substrings, and comparing strings. You learn
how the <TT>StringBuffer</TT> class offers an alternative to the
<TT>String</TT> class and is more useful when working with text
that is likely to change. And finally, you learn how to use the
many methods for appending or inserting into a <TT>StringBuffer</TT>.
<H2><A NAME="TheStringClass"><FONT SIZE=5 COLOR=#FF0000>
The String Class</FONT></A></H2>
<P>
The Java <TT>String</TT> class, a part of the java.lang package,
is used to represent strings of characters. Unlike C and C++,
Java does not use an array of characters to represent a string.
The <TT>String</TT> class is used to represent a string that is
fairly static, changing infrequently if at all. This section describes
how to use this class and includes examples of many of the nearly
50 methods or constructors that are a part of this important class.
<H3><A NAME="ConstructingNewStrings">
Constructing New Strings</A></H3>
<P>
There are seven <TT>String</TT> constructors, as shown in Table
10.1. As examples of using these constructors, consider the following
code:
<BLOCKQUOTE>
<PRE>
String str1 = new String();
String str2 = new String(&quot;A New String&quot;);
char charArray[] = {'A', 'r', 'r', 'a', 'y' };
String str3 = new String(charArray);
String str4 = new String(charArray, 2, 3);
StringBuffer buf = new StringBuffer(&quot;buffer&quot;);
String str5 = new String(buf);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 10.1. Constructors for the String class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=230><I>Constructor</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String()</TT></TD><TD WIDTH=384>Creates an empty string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(String)</TT></TD><TD WIDTH=384>Creates a string from the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(char[])</TT></TD><TD WIDTH=384>Creates a string from an array of characters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(char[], int, int)</TT></TD><TD WIDTH=384>Creates a string from the specified subset of characters in an array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(byte[], int)</TT></TD><TD WIDTH=384>Creates a string from the specified byte array and Unicode upper byte.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(byte[],int,int,int)</TT></TD><TD WIDTH=384>Creates a string from the specified subset of bytes and Unicode upper byte.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=230><TT>String(StringBuffer)</TT></TD><TD WIDTH=384>Creates a string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
In the first example, str1 is created as an empty string. The
second string, str2, will hold the text &quot;A New String&quot;.
The next two examples, str3 and str4, are constructed from a character
array. In the case of str3, the entire array is placed in the
string. For str4, three characters starting in array position
two are copied into the string. Because Java arrays are zero-based,
this results in str4 containing &quot;ray&quot;. In the final
example, the string str5 is constructed from a StringBuffer, buf.
The StringBuffer class has much in common with String and is described
in detail later in this chapter.
<P>
In addition to these constructors, there are other ways to get
a String object. Many Java classes include a toString method that
can be used to generate a string representation of the object.
For example, consider the following:
<BLOCKQUOTE>
<PRE>
Long myLong = new Long(43);
String longStr = myLong.toString();
g.drawString(longStr + myLong.toString(), 10, 20);
</PRE>
</BLOCKQUOTE>
<P>
In this case, a <TT>Long</TT> object is created and set to hold
the value <TT>43</TT>. Note that this is an object of type <TT>Long</TT>,
not a primitive of type <TT>long</TT>. Because <TT>myLong</TT>
is an instance of a class, the <TT>toString</TT> method is used
to place a string directly into <TT>longStr</TT>. The call to
<TT>drawString</TT> illustrates that the converted string in <TT>longStr</TT>
can be used as a regular string as can an inline use of <TT>myLong.toString</TT>.
<P>
Finally, Java supports the use of automatic strings, as follows:
<BLOCKQUOTE>
<PRE>
g.drawString(&quot;This is an automatic string.&quot;, 10, 20);
</PRE>
</BLOCKQUOTE>
<P>
In this case, the <TT>drawString</TT> method expects to be passed
a string as its first parameter. To satisfy this expectation,
a new <TT>String</TT> object is constructed using the quoted text.
This happens behind the scenes automatically and requires no special
attention on your part.
<H3><A NAME="BasicStringMethods">
Basic String Methods</A></H3>
<P>
The basic methods for manipulating and examining a string are
shown in Table 10.2. The Java <TT>String</TT> class is meant to
hold text that does not change, so this table does not include
a lot of methods for adding and inserting text. It does, however,
include a simple <TT>concat</TT> method for adding one string
to the end of another and a <TT>replace</TT> method for swapping
one character for another.<BR>
<P>
<CENTER><B>Table 10.2. Basic string methods.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=160><I>Method</I></TD><TD WIDTH=420><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>concat(String)</TT></TD><TD WIDTH=420>Concatenates one string onto another.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>length()</TT></TD><TD WIDTH=420>Returns the length of the string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>replace(char, char)</TT></TD><TD WIDTH=420>Replaces all occurrences of one character with a different character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>toLowerCase()</TT></TD><TD WIDTH=420>Converts the entire string to lowercase.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>toUpperCase()</TT></TD><TD WIDTH=420>Converts the entire string to uppercase.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=160><TT>trim()</TT></TD><TD WIDTH=420>Trims both leading and trailing whitespace from the string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>concat</TT> method appends the specified string onto the
current string and returns the result as a new string. This can
be seen in the following, in which <TT>str3</TT> will contain
<TT>&quot;Hello World&quot;</TT>:
<BLOCKQUOTE>
<PRE>
String str1 = new String(&quot;Hello &quot;);
String str2 = new String(&quot;World&quot;);
String str3 = str1.concat(str2);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>replace</TT> method can be used to change all occurrences
of one character to a different character. The following example
changes <TT>&quot;Hi Mom&quot;</TT> to <TT>&quot;Hi Mum&quot;</TT>,
allowing the program to be run in England:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;Hi Mom &quot;);
String newStr = str.replace('o', 'u');
</PRE>
</BLOCKQUOTE>
<P>
Like <TT>concat</TT>, <TT>trim</TT> works by returning a new string.
In this case, all leading and trailing whitespace characters are
first removed from the returned string. The following example
will remove the tabs, carriage return, new line, and space characters
at both ends of the string:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;\t\t In The Middle \r\n&quot;);
String newStr = str.trim();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>length</TT> method simply returns the number of characters
in the string. In the following example, <TT>len</TT> will be
set to <TT>12</TT>:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;Length of 12&quot;);
int len = str.length();
</PRE>
</BLOCKQUOTE>
<P>
The <TT>toUpperCase</TT> and <TT>toLowerCase</TT> methods can
be used to change the case of an entire string. Each works by
returning a new string. In the following example, an uppercase
version and a lowercase version of the same string are created:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;This is MiXeD caSE&quot;);
String upper = str.toUpperCase();
String lower = str.toLowerCase();
</PRE>
</BLOCKQUOTE>
<H3><A NAME="ConvertingVariablestoStrings">
Converting Variables to Strings</A></H3>
<P>
Because most of the display methods of Java's user interface classes
use strings, it is important to be able to convert variables of
other types into strings. Naturally, Java includes methods for
doing this. The <TT>String</TT> class includes a set of static
<TT>valueOf</TT> methods that can be used to create strings from
other Java objects and primitive types. The <TT>valueOf</TT> methods
are shown in Table 10.3.<BR>
<P>
<CENTER><B>Table 10.3. Useful methods for converting strings.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(char)</TT></TD><TD WIDTH=384>Returns a string containing the one specified character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(char[])</TT></TD><TD WIDTH=384>Returns a string with the same text as the specified character array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(char[], int, int)</TT></TD><TD WIDTH=384>Returns a string with the same text as a subset of the specified character array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(boolean)</TT></TD><TD WIDTH=384>Returns a string containing either <TT>true</TT> or <TT>false</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(int)</TT></TD><TD WIDTH=384>Returns a string containing the value of the <TT>int</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(long)</TT></TD><TD WIDTH=384>Returns a string containing the value of the <TT>long</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(float)</TT></TD><TD WIDTH=384>Returns a string containing the value of the <TT>float</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>valueOf(double)</TT></TD><TD WIDTH=384>Returns a string containing the value of the <TT>double</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Each of these methods is passed the variable to convert and returns
a string representation of that variable. Because these methods
are static, they are invoked using the name of the class rather
than the name of an instance of the class. For example, consider
the following uses of <TT>valueOf</TT> to create strings from
numeric values:
<BLOCKQUOTE>
<PRE>
String intStr = String.valueOf(100);
String floatStr = String.valueOf(98.6F);
String doubleStr = String.valueOf(3.1416D);
</PRE>
</BLOCKQUOTE>
<P>
Each of these lines will result in the creation of a string containing
the number specified. Consider also the following examples of
non-numeric conversions:
<BLOCKQUOTE>
<PRE>
String boolStr = String.valueOf(true);
String charStr = String.valueOf('Y');
char charArray[] = {'A', 'r', 'r', 'a', 'y' };
String arrayStr1 = String.valueOf(charArray);
String arrayStr2 = String.valueOf(charArray, 2, 3);
</PRE>
</BLOCKQUOTE>
<P>
In the first case, <TT>boolStr</TT> will be set to <TT>true</TT>.
The variable <TT>charStr</TT> will be a string with a length of
<TT>1</TT>. The entire five-character array will be stored in
<TT>arrayStr1</TT>, but only <TT>ray</TT> will be stored in <TT>arrayStr2</TT>.
<H3><A NAME="UsingOnlyPartofaString">
Using Only Part of a String</A></H3>
<P>
Of course, sometimes the entire string is too much; you just need
a portion of the string. Fortunately, the Java <TT>String</TT>
class provides methods for accessing or creating a substring from
a longer string. Each of the methods listed in Table 10.4 can
be used to retrieve a portion of a string.<BR>
<P>
<CENTER><B>Table 10.4. Methods for using a substring.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>charAt(int)</TT></TD><TD WIDTH=384>Returns the character at the specified location.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getBytes(int, int, byte[], int)</TT></TD>
<TD WIDTH=384>Copies the specified number of characters from the specified location into the byte array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getChars(int, int, char[], int)</TT></TD>
<TD WIDTH=384>Copies the specified number of characters from the specified location into the char array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>substring(int)</TT></TD><TD WIDTH=384>Returns a substring beginning at the specified offset of the current string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>substring(int, int)</TT></TD><TD WIDTH=384>Returns a substring between the specified offsets of the current string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>charAt</TT> method retrieves the single character at the
index given. For example, the following will place the character
<TT>a</TT> in <TT>ch</TT>:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;This is a String&quot;);
char ch = str.charAt(8);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>getBytes</TT> and <TT>getChars</TT> methods are similar.
The first moves a substring into an array of bytes; the latter
moves a substring into an array of characters. As an example,
consider the following:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
    String str = new String(&quot;Wish You Were Here&quot;);
    char charArray[] = new char[25];
    str.getChars(5, 13, charArray, 0);
    g.drawChars(charArray, 0, 8, 10, 10);
}
</PRE>
</BLOCKQUOTE>
<P>
This code will extract <TT>You Were</TT> from <TT>str</TT> and
move it into the <TT>charArray</TT> variable. It is then displayed
using <TT>g.drawChars</TT>.
<P>
The two <TT>substring</TT> methods can be used to create new strings
that are extracted from the current string. To create a substring
from an offset to the end of the string, use the first version
of <TT>substring</TT>, as follows:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;This is a String&quot;);
String substr = str.substring(10);
</PRE>
</BLOCKQUOTE>
<P>
In this case <TT>substr</TT> will hold <TT>String</TT>. To create
a substring from the middle of a string, you can specify an ending
offset as an additional parameter to <TT>substring</TT>. The following
code will place <TT>You Were</TT> into <TT>substr</TT>:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;Wish You Were Here&quot;);
String substr = str.substring(5, 13);
</PRE>
</BLOCKQUOTE>
<P>
The character given by the beginning index will be included in
the new string, but the character given by the ending index will
not be.
<H3><A NAME="ComparingStrings">
Comparing Strings</A></H3>
<P>
As can be seen in Table 10.5, Java provides a number of methods
for comparing one string to another. The <TT>compareTo</TT> method
returns the difference between two strings by examining the first
two characters that differ in the strings. The difference between
the characters is returned. For example, the character <TT>a</TT>
differs from <TT>c</TT> by two characters, so <TT>2</TT> will
be returned if these are the first two characters that differ.
Depending on which string contains the higher valued character,
the return value could be positive or negative. For example, in
the following, <TT>result1</TT> will equal -<TT>2</TT> but <TT>result2</TT>
will be <TT>2</TT>.
<BLOCKQUOTE>
<PRE>
String str1 = new String(&quot;abc&quot;);
String str2 = new String(&quot;abe&quot;);

// compare str2 against str1
int result1 = str1.compareTo(str2);

// perform the same comparison but in the
// opposite direction (str1 against str2)
int result2 = str2.compareTo(str1);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER><B>Table 10.5. Methods for comparing strings.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>compareTo(String)</TT></TD><TD WIDTH=384>Compares two strings. Returns 0 if they are equal, a negative value if the specified string is greater than the string, or a positive value otherwise.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>endsWith(String)</TT></TD><TD WIDTH=384>Returns true if the string ends with the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>equalIgnoreCase</TT></TD><TD WIDTH=384>Returns true if, ignoring differences in capitalization, the string matches the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>equals(Object)</TT></TD><TD WIDTH=384>Returns true if the string matches the object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>equalTo(String)</TT></TD><TD WIDTH=384>Returns true if the string matches the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>regionMatches(int,<BR>String,int,int)</TT></TD>
<TD WIDTH=384>Returns true if the specified region of the string matches the specified region of a different string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>regionMatches(boolean,<BR>int,String,int,int)</TT>
</TD><TD WIDTH=384>Returns true if the specified region of the string matches the specified region of a different string optionally considering the case of the strings.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>startsWith(String)</TT></TD><TD WIDTH=384>Returns true if the string starts with the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>startsWith(String, int)</TT></TD><TD WIDTH=384>Returns true if the string starts with the specified string at the specified offset.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The equals and equalTo methods perform similar comparisons; however,
these each return a boolean value rather than a measure of how
the strings differ. These can be used to compare one string against
another string or against a string literal as shown in the following:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
    String str1 = new String(&quot;abc&quot;);

    // create str2 to have the same contents as str1
    String str2 = new String(str1);

    // compare str1 to the string made from it
    if (str1.equals(str2))
        g.drawString(&quot;str1 and str2 are equal&quot;, 10, 10);

    // compare str1 against a literal
    if (str1.equals(&quot;abc&quot;))
        g.drawString(&quot;str1 equals abc&quot;, 10, 30);
}
</PRE>
</BLOCKQUOTE>
<P>
In this case <TT>str1</TT> is equal to both <TT>str2</TT> and
the literal <TT>abc</TT>. To perform a case-insensitive comparison
use the <TT>equalIgnoreCase</TT> method, as follows:
<BLOCKQUOTE>
<PRE>
String str1 = new String(&quot;abc&quot;);
boolean result = str1.equalsIgnoreCase(&quot;ABC&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The <TT>endsWith</TT> method can be used to determine whether
a string ends with a given string. Usually more useful are the
two <TT>startsWith</TT> methods. These can be used to determine
whether the string starts with a given string or whether that
string appears at a specific location within the string. The <TT>endsWith</TT>
and <TT>startsWith</TT> methods can be used as shown in the following:
<BLOCKQUOTE>
<PRE>
// create two Strings
String str1 = new String(&quot;My favorite language is Java&quot;);
String str2 = new String(&quot;I like the Java language&quot;);

// see if str1 ends with &quot;Java&quot;
boolean result1 = str1.endsWith(&quot;Java&quot;);        // true

// see if str1 starts with &quot;My&quot;
boolean result2 = str1.startsWith(&quot;My&quot;);        // true

// see if starting in offset 11 str2 starts with &quot;Java&quot;
boolean result3 = str2.startsWith(&quot;Java&quot;, 11);  // true
</PRE>
</BLOCKQUOTE>
<P>
The two <TT>regionMatches</TT> methods can be used to see whether
a region in one string matches a region in a different string.
The second <TT>regionMatches</TT> method allows for case-insensitive
comparisons of this nature. As an example of using <TT>regionMatches</TT>,
consider the following:
<BLOCKQUOTE>
<PRE>
// create two longer Strings
String str1 = new String(&quot;My favorite language is Java&quot;);
String str2 = new String(&quot;I like the Java language&quot;);

// compare regions
// Start at offset 24 in str1 and compare against offset 11
// in str2 for 4 characters
boolean result = str1.regionMatches(24, str2, 11, 4);    // true
</PRE>
</BLOCKQUOTE>
<P>
In this case the strings are compared for a length of four characters
starting with index 24 in <TT>str1</TT> and index 11 in <TT>str2</TT>.
Because each of these substrings is <TT>&quot;Java&quot;</TT>,
<TT>result</TT> is set to <TT>true</TT>.
<H3><A NAME="SearchingStrings">
Searching Strings</A></H3>
<P>
In addition to comparing one string against another, you can also
search a string for the occurrence of a character or another string.
Unfortunately, you can do only a normal exact character search;
no regular expression or wildcard searching is possible. The methods
that can be used to search a string are shown in Table 10.6.<BR>
<P>
<CENTER><B>Table 10.6. Methods for searching a string.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>indexOf(int)</TT></TD><TD WIDTH=384>Searches for the first occurrence of the specified character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>indexOf(int, int)</TT></TD><TD WIDTH=384>Searches for the first occurrence of the specified character following the given offset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>indexOf(String)</TT></TD><TD WIDTH=384>Searches for the first occurrence of the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>indexOf(String, int)</TT></TD><TD WIDTH=384>Searches for the first occurrence of the specified string following the given offset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>lastIndexOf(int)</TT></TD><TD WIDTH=384>Searches backwards for the last occurrence of the specified character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>lastIndexOf(int, int)</TT></TD><TD WIDTH=384>Searches backwards for the last occurrence of the specified character preceding the given offset.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>lastIndexOf(String)</TT></TD><TD WIDTH=384>Searches backwards for the last occurrence of the specified string.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>lastIndexOf(String, int)</TT></TD><TD WIDTH=384>Searches backwards for the last occurrence of the specified string preceding the given offset.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
As you can see from Table 10.6, the search methods have various
signatures but are named either <TT>indexOf</TT> or <TT>lastIndexOf</TT>.
The <TT>indexOf</TT> methods search forward from the start of
a string to its end; the <TT>lastIndexOf</TT> methods search in
the opposite direction.
<P>
To search for a character from the beginning of the string, use
the <TT>indexOf(int)</TT> method. The following code illustrates
searching for the character <TT>'Y'</TT>:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;Wish You Were Here&quot;);
int index = str.indexOf('Y');
</PRE>
</BLOCKQUOTE>
<P>
In this case, a <TT>'Y'</TT> is found in index 5, so this value
is placed in <TT>index</TT>. This works well for finding the first
occurrence of a letter, but what if you need to find subsequent
occurrences of the same letter? This can be done by using the
<TT>indexOf(int, int)</TT> method. The additional parameter indicates
the offset from which to start the search. By setting this value
each time a matching character is found, a loop can be written
to easily find all occurrences of a letter. As an example, consider
the following code fragment:
<BLOCKQUOTE>
<PRE>
String str = new String(&quot;Wish You Were Here&quot;);

int fromIndex = 0;
while(fromIndex != -1)
{
    fromIndex = str.indexOf('W', fromIndex);
    if (fromIndex != -1)
    {
        // character was matched, use as desired
        fromIndex++;
    }
}
</PRE>
</BLOCKQUOTE>
<P>
This example starts with <TT>str</TT> containing <TT>&quot;Wish
You Were Here&quot;</TT> and uses a loop to find all <TT>'W'</TT>
characters. The variable <TT>fromIndex</TT> is initially set to
<TT>0</TT>. This causes the <TT>str.indexOf</TT> method call to
start at the beginning of the string on the first pass through
the loop. If <TT>fromIndex</TT> is not <TT>-1</TT>, this indicates
that the character was found. The value is appended to a <TT>results</TT>
string and <TT>fromIndex</TT> is incremented to move past the
matching character. In this case a <TT>W</TT> is found at indexes
0 and 9.
<P>
Searching for a string is just as simple as searching for a character.
The following example will search for the string <TT>&quot;er&quot;</TT>:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
    String str = new String(&quot;Wish You Were Here&quot;);
    int count = 0;

    int fromIndex = 0;
    while(fromIndex != -1)
    {
        fromIndex = str.indexOf(&quot;er&quot;, fromIndex);
        if (fromIndex != -1)
        {
            count++;
            fromIndex++;
        }
    }
    g.drawString(String.valueOf(count), 10, 10);
}
</PRE>
</BLOCKQUOTE>
<P>
This string will be found twice, once in <TT>Were</TT> and once
in <TT>Here</TT>.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>StringTokenizer</TT> class provides a very powerful mechanism for parsing a string. This class is fully described in <A HREF="ch11.htm" >Chapter 11</A>, &quot;The Java Utility Classes.&quot;
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheStringBufferClass"><FONT SIZE=5 COLOR=#FF0000>
The StringBuffer Class</FONT></A></H2>
<P>
The primary limitation of the <TT>string</TT> class is that once
the string is created you cannot change it. If you need to store
text that may need to be changed you should use the <TT>StringBuffer</TT>
class. The <TT>StringBuffer</TT> class includes methods for inserting
and appending text. Additionally, a <TT>StringBuffer</TT> object
may be easily converted into a <TT>String</TT> class when necessary.
<P>
To create a new string buffer, you can use any of the three constructors
shown in Table 10.7. Examples of using these constructors are
as follows:
<BLOCKQUOTE>
<PRE>
StringBuffer buf1 = new StringBuffer(25);
StringBuffer buf2 = new StringBuffer();
StringBuffer buf3 = new StringBuffer(&quot;This is a StringBuffer&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In the first case, <TT>buf1</TT> will be an empty <TT>StringBuffer</TT>
with an initial length of <TT>25</TT>. Similarly, <TT>buf2</TT>
will be an empty <TT>StringBuffer</TT> but <TT>buf3</TT> will
contain <TT>&quot;This is a StringBuffer&quot;.<BR>
</TT>
<P>
<CENTER><B>Table 10.7. StringBuffer constructors.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Constructor</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>StringBuffer()</TT></TD><TD WIDTH=384>Creates an empty <TT>StringBuffer</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>StringBuffer(int)</TT></TD><TD WIDTH=384>Creates an empty <TT>StringBuffer</TT> with the specified length.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>StringBuffer(String)</TT></TD><TD WIDTH=384>Creates a <TT>StringBuffer</TT> based on the specified string.
</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="UsefulStringBufferMethods">
Useful StringBuffer Methods</A></H3>
<P>
In addition to the methods for inserting and appending text, the
<TT>StringBuffer</TT> class contains other methods you will need
to be familiar with. These are shown in Table 10.8. The <TT>capacity</TT>
method can be used to determine the storage capacity of the string
buffer. Because each string buffer can grow as text is appended
or inserted, the capacity of the string buffer can exceed the
length of the text currently stored in it. While <TT>capacity</TT>
returns the amount of text that could be stored in the currently
allocated space of the string buffer, <TT>length</TT> returns
how much of that space is already used. As an example, consider
the following:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(25);
buf.append(&quot;13 Characters&quot;);
int len = buf.length();
int cap = buf.capacity();
</PRE>
</BLOCKQUOTE>
<P>
In this case, the constructor specifies a capacity of <TT>25</TT>
for <TT>buf</TT>. However, only thirteen characters are placed
in it with the <TT>append</TT> method. Because of this, the <TT>length</TT>
of <TT>buf</TT> is <TT>13</TT> while its <TT>capacity</TT> is
<TT>25</TT>. These values will be stored in <TT>len</TT> and <TT>cap</TT>,
respectively.<BR>
<P>
<CENTER><B>Table 10.8. Useful methods of the StringBuffer class.</B></CENTER>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=192><I>Method</I></TD><TD WIDTH=384><I>Purpose</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>capacity()</TT></TD><TD WIDTH=384>Returns the current capacity of the <TT>StringBuffer</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>charAt(int)</TT></TD><TD WIDTH=384>Returns the character located at the specified index.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>ensureCapacity(int)</TT></TD><TD WIDTH=384>Ensures the capacity of the <TT>StringBuffer</TT> is at least the specified amount.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>getChars(int,int,char[],<BR>int)</TT></TD><TD WIDTH=384>Copies the specified characters from the <TT>StringBuffer</TT> into the specified array.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>length()</TT></TD><TD WIDTH=384>Returns the length of the <TT>StringBuffer</TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setCharAt(int, char)</TT></TD><TD WIDTH=384>Sets the value at the specified index to the specified character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>setLength(int)</TT></TD><TD WIDTH=384>Sets the length of the <TT>StringBuffer</TT> to the specified value.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=192><TT>toString</TT></TD><TD WIDTH=384>Returns a string representing the text in the <TT>StringBuffer</TT>.
</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
The <TT>ensureCapacity</TT> method can be used to increase the
capacity of the string buffer and the <TT>setLength</TT> method
can be used to set the length of the buffer. If <TT>setLength</TT>
is used to reduce the length, the characters at the end of the
buffer are lost. If, instead, <TT>setLength</TT> is used to increase
the length of a string buffer, null characters are used to fill
the additional space at the end. This can be seen in the following
code:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(&quot;0123456789&quot;);
buf.setLength(5);
// buf now contains &quot;01234&quot;
buf.setLength(10);
// buf now contains &quot;01234&quot; followed by five null characters
</PRE>
</BLOCKQUOTE>
<P>
The <TT>toString</TT> method will be one of the <TT>StringBuffer</TT>
methods you will use most frequently. This method creates a string
representation of the text in the string buffer. This is useful
because so many of the Java library methods expect a string as
a parameter. For example, the following code illustrates how to
display the contents of a string buffer in an applet's <TT>paint</TT>
method:
<BLOCKQUOTE>
<PRE>
public void paint(Graphics g)
{
    StringBuffer buf = new StringBuffer(&quot;Hello, World&quot;);
    g.drawString(buf.toString(), 10, 10);
}
</PRE>
</BLOCKQUOTE>
<P>
The <TT>charAt</TT> and <TT>setCharAt</TT> methods can be used
to retrieve the character at a specific index and to set the character
at a specific index, respectively. This can be seen in the following:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(&quot;Hello&quot;);
char ch = buf.charAt(1);
buf.setCharAt(1, 'a');
</PRE>
</BLOCKQUOTE>
<P>
Because <TT>StringBuffers</TT> are zero-based, <TT>ch</TT> will
contain <TT>'e'</TT>. The <TT>setCharAt</TT> method replaces this
<TT>'e'</TT>, changing the string buffer to say <TT>&quot;Hallo&quot;</TT>.
The <TT>getChars</TT> method can be used to retrieve characters
from a string buffer and place them into a character array. The
<TT>getChars</TT> method has the following signature:
<BLOCKQUOTE>
<PRE>
public synchronized void getChars(int srcBegin, int srcEnd,
        char dst[], int dstBegin) ;
</PRE>
</BLOCKQUOTE>
<P>
The <TT>srcEnd</TT> parameter indicates the first character after
the desired end of the text. It will not be placed in the destination
array, so you should be careful to specify the proper value. In
the following example, <TT>getChars</TT> is used to place the
characters of <TT>String</TT> into the array:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(&quot;A String Buffer&quot;);
char array[] = new char[10];
buf.getChars(2,8, array, 0);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The <TT>getChars</TT> method will throw a <TT>StringIndexOutOfBoundsException</TT> if any of the parameters represents an invalid index.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="Appending">
Appending</A></H3>
<P>
Because the main distinction between the <TT>String</TT> and <TT>StringBuffer</TT>
classes is the capability of a <TT>StringBuffer</TT> instance
to increase in size, methods are provided for appending to a <TT>StringBuffer</TT>.
Each of the following methods can be used to append to a <TT>StringBuffer</TT>:
<UL>
<LI><TT>append(Object)</TT>
<LI><TT>append(String)</TT>
<LI><TT>append(char)</TT>
<LI><TT>append(char[])</TT>
<LI><TT>append(char[], int, int)</TT>
<LI><TT>append(boolean)</TT>
<LI><TT>append(int)</TT>
<LI><TT>append(long)</TT>
<LI><TT>append(float)</TT>
<LI><TT>append(double)</TT>
</UL>
<P>
Use of these methods is demonstrated by the following:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(&quot;Hello&quot;);
buf.append(&quot;, World&quot;);

StringBuffer buf2 = new StringBuffer(&quot;Revolution #&quot;);
buf2.append(9);

StringBuffer buf3 = new StringBuffer(&quot;My daughter is &quot;);
float ageSavannah = 10F/12F;
buf3.append(ageSavannah);
buf3.append(&quot; years old&quot;);
</PRE>
</BLOCKQUOTE>
<P>
In the first case <TT>buf</TT> is set to contain <TT>&quot;Hello&quot;</TT>
and then <TT>append(String)</TT> is used to create <TT>&quot;Hello,
World&quot;</TT>. The second case illustrates <TT>append(int)</TT>
to create the text <TT>&quot;Revolution #9&quot;</TT>. Finally,
<TT>buf3</TT> illustrates the use of <TT>append(float)</TT> combined
with <TT>append(String)</TT>.
<H3><A NAME="Inserting">
Inserting</A></H3>
<P>
Of course, sometimes the text you want to add to a string buffer
needs to go somewhere other than at the end. In these cases, <TT>append</TT>
is of no use and you need to use one of the provided <TT>insert</TT>
methods. A variety of <TT>insert</TT> methods is provided, as
follows:
<UL>
<LI><TT>insert(int, Object)</TT>
<LI><TT>insert(int, String)</TT>
<LI><TT>insert(int, char[])</TT>
<LI><TT>insert(int, boolean)</TT>
<LI><TT>insert(int, char)</TT>
<LI><TT>insert(int, int)</TT>
<LI><TT>insert(int, long)</TT>
<LI><TT>insert(int, float)</TT>
<LI><TT>insert(int, double)</TT>
</UL>
<P>
Each of these methods is passed the index at which to insert the
text and then an object to be inserted. For example, the following
code inserts the all-important half month into a child's age:
<BLOCKQUOTE>
<PRE>
StringBuffer buf = new StringBuffer(&quot;My daughter is 10 months old&quot;);
buf.insert(17, &quot;-and-a-half&quot;);
</PRE>
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>
Summary</FONT></A></H2>
<P>
In this chapter, you learned about the <TT>String</TT> and <TT>StringBuffer</TT>
classes, two of the most commonly used classes in Java programming.
You learned that the <TT>String</TT> class is intended to hold
nonchanging text. You saw many examples of using the member methods
of the <TT>String</TT> class, including changing the case of a
string, trimming whitespace, and accessing substrings. You learned
how to convert variables of other types into strings and how to
search and compare strings. Finally, you saw how the <TT>StringBuffer</TT>
class is a more useful class for dynamic strings because text
can be inserted and appended.
<HR>

<CENTER><P><A HREF="ch9.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="http://docs.rinet.ru/WebJPP/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="contents.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch11.htm"><IMG SRC="http://docs.rinet.ru/WebJPP/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
