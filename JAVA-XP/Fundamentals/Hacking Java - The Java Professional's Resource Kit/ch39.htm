<HTML>
<HEAD>
<TITLE>Chapter 39 -- Implementing a Multimedia Encyclopedia </TITLE>

<META>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter 39</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Implementing a Multimedia Encyclopedia
</FONT></H1>
<P>
<I><B>by George Menyhert</B></I>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#JavasSuitabilityforMultimediaApplications">
Java's Suitability for Multimedia Applications</A>
<UL>
<LI><A HREF="#JavaIsPortable">
Java Is Portable</A>
<LI><A HREF="#JavaIsCompact">
Java Is Compact</A>
<LI><A HREF="#JavaCanHandleStreamingData">
Java Can Handle Streaming Data</A>
<LI><A HREF="#JavaIsBasedontheClientServerModel">
Java Is Based on the Client/Server Model</A>
<LI><A HREF="#JavaSupportsPDAsEasily">
Java Supports PDAs Easily</A>
</UL>
<LI><A HREF="#UsingtheMultimediaEncyclopedia">
Using the Multimedia Encyclopedia</A>
<LI><A HREF="#AddingImagesandSoundtoApplets">
Adding Images and Sound to Applets</A>
<LI><A HREF="#TheOnLineMultimediaEncyclopediaInDepth">
The On-Line Multimedia Encyclopedia In-Depth</A>
<UL>
<LI><A HREF="#AppletArchitecture">
Applet Architecture</A>
<LI><A HREF="#IndexWindow">
Index Window</A>
<LI><A HREF="#TopicWindow">
Topic Window</A>
</UL>
<LI><A HREF="#Shortcomings">
Shortcomings</A>
<LI><A HREF="#NewFeatures">
New Features</A>
</UL>

<HR>
<P>
Knowledge is dynamic. Science and industry march on heedless of
the headaches that this evolving picture of the universe gives
publishers and authors around the world. Even information that
we think of as static does not rest peacefully. Discoveries are
made every day that change the way that we look upon historical
events. The Dead Sea Scrolls are unearthed; a meteorite from Mars
with tantalizing clues of life is discovered; the Titanic is raised
from the ocean's floor. Not only is knowledge dynamic but so is
language, teaching methodology, and culture. There are methods
of displaying information today that were not possible several
years ago.
<P>
Now, look at our feeble attempts to deal with dynamic information.
Reprinted books? CD-ROMs? Something is wrong. How do you update
the copy of Encarta that you've had on your machine for three
years? The <I>possibility</I> of solutions is only now starting
to emerge with increased use of the Internet, graphical browsers,
and portable, small, powerful software applets written in Java.
<H2><A NAME="JavasSuitabilityforMultimediaApplications"><FONT SIZE=5 COLOR=#FF0000>
Java's Suitability for Multimedia Applications</FONT></A></H2>
<P>
Java is useful for multimedia applications because it is portable,
is compact, can handle streaming data, and can provide encryption.
In addition, it is already based on the client/server model and
will support PDAs easily. Please see <A HREF="ch38.htm" >Chapter 38</A>, &quot;Creating
On-Demand Multimedia Services,&quot; for a more detailed discussion
of each of these topics.
<H3><A NAME="JavaIsPortable">
Java Is Portable</A></H3>
<P>
Java already runs on every popular computing platform. The same
code runs on PCs, Macintoshes, and UNIX workstations.
<H3><A NAME="JavaIsCompact">
Java Is Compact</A></H3>
<P>
The Multimedia Encyclopedia applet in this chapter is only 9K
in size. This is critically important when dealing with the small
bandwidth of phone lines (or an even smaller bandwidth for some
mobile applications).
<H3><A NAME="JavaCanHandleStreamingData">
Java Can Handle Streaming Data</A></H3>
<P>
Encyclopedias are huge and will only get bigger. Can you imagine
downloading a new version every day? Rather than downloading,
storing and then playing data, Java lets you <I>stream</I> data.
That is, the data flows through the device. You don't worry about
your radio storing enough sound to play continuously. Why should
your computer, or other digital devices, be any different?
<H3><A NAME="JavaIsBasedontheClientServerModel">
Java Is Based on the Client/Server Model</A></H3>
<P>
Ideally, you want your multimedia encyclopedia to be updated constantly.
This is not possible without adopting a client/server model. Fortunately,
that is the model used by Java. The distribution of data is a
nightmare using traditional media. If the distribution of data
is difficult, so is the distribution of more powerful indexing
or playback technologies. Using Java, the executable part of the
product can be updated as frequently as the data. I'm sure that
when folks look at Encarta's interface, they think it's kind of
clunky and wonder why it doesn't look more like Internet Explorer.
With Java, IUs are as easy to modify and distribute as the data.
<H3><A NAME="JavaSupportsPDAsEasily">
Java Supports PDAs Easily</A></H3>
<P>
Today, Java can run on PDAs; all you need is a <I>mini-browser</I>.
As an example, assume that you need to develop a Multimedia Tour
Book for an art museum that runs on a PDA. The application lets
visitors arrange a detailed personal tour and spend time at the
exhibits that are of particular interest to them. In this case,
you do not need a full commercial browser like Netscape; rather,
you need a browser that can handle text, hypertext, and multimedia.
This browser can be optimized for your specific requirements,
reducing code size and increasing performance. Because this application
is written in Java, tourists can take this same tour at home on
their PCs, either before or after their visit, simply by accessing
the museum's Web site.
<H2><A NAME="UsingtheMultimediaEncyclopedia"><FONT SIZE=5 COLOR=#FF0000>
Using the Multimedia Encyclopedia</FONT></A></H2>
<P>
This applet is designed as a public domain multimedia encyclopedia;
it provides all the features of a Multimedia Encyclopedia short
of video streaming. It is a good example of an application that
can be written in a few hours and still be very useful and easy
to improve in the future. Remember, the next time a user accesses
the encyclopedia, he or she could see a greatly improved user
interface, as well as better content.
<P>
To use the Multimedia Encyclopedia:
<OL>
<LI>Start your favorite Java-capable browser.
<LI>Open the file Chapter48/Encyc.html with your browser.<BR>
The text string, Applet Encyc running, displays on your browser's
status line when the applet is fully loaded (see Figure 39.1).
<LI>Double-click the name of the topic that you want to see.<BR>
An image of the topic appears (see Figure 39.2).
<LI>Click the Listen button to hear the associated audio clip.
<LI>Click the Index button to go back to the topics list.
</OL>
<P>
<A HREF="f39-1.gif"><B>Figure 39.1 : </B><I>The Multimedia's welcome screen and topics
list are loaded</I>.</A>
<P>
<A HREF="f39-2.gif"><B>Figure 39.2 : </B><I>An image of the topic along with the applet's
controls can be seen here</I>.</A>
<H2><A NAME="AddingImagesandSoundtoApplets"><FONT SIZE=5 COLOR=#FF0000>
Adding Images and Sound to Applets</FONT></A></H2>
<P>
Adding sound and pictures to Java applets is very simple. This
is also discussed in <A HREF="ch4.htm" >Chapter 4</A> &quot;Displaying Images,&quot;
and <A HREF="ch38.htm" >Chapter 38</A>, &quot;Creating On-Demand Multimedia Services.&quot;
Both media types are handled in similar ways. Simply obtain a
reference to an object of the correct media type; then display
the media. The media functionality is available only via the applet
class. Although it is possible to run an applet as an application,
there are many limitations to applets executed in this mode (including
media streaming). However, there are some available work-arounds.
See <A HREF="ch13.htm" >Chapter 13</A>, &quot;Running Applets as Applications,&quot; for
details on the techniques and limitations of running applets as
applications and ways of overcoming these limitations.
<P>
To select the source of a sound clip, call the method <TT>Applet.getAudioClip</TT>.
This method is overloaded and has two invocations. A sound file
can be referenced either by a base URL and a relative file path,
or by its absolute URL. To include audio in your applet, add the
following line:
<BLOCKQUOTE>
<PRE>
AudioClip sound =
myApplet.getAudioClip(getDocumentBase(), &quot;sound.au&quot;);
<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Getting the audio clip this way is usually very slow the first time it is done in an applet. This is due to dynamic class loading.</BLOCKQUOTE>
<BLOCKQUOTE>
When you are running these applets over the Internet, <FONT FACE="I Helvetica Oblique">each</FONT> instantiation of an <TT>AudioClip</TT> is extremely slow. This is because the <TT>AudioClip</TT> object does not truly stream the audio data. It downloads 
and buffers the data at the time of instantiation.
</BLOCKQUOTE>
<BLOCKQUOTE>
You need to give users some feedback so they don't cancel the operation. Try a call to <TT>showStatus</TT> that states something like, &quot;Initializing audio. Please wait&#133;&quot;. Changing the cursor to a wait state would be ideal, but is not 
possible in applets.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
This sample creates an object that references the sound file,
sound.au, in the same location as the applet's URL. To play the
sound clip, simply invoke the <TT>AudioClip.play</TT>
method. You can also stop and loop<TT><B>
</B></TT>(continually play back) the audio clip. The following
line shows how to play a sound:
<BLOCKQUOTE>
<PRE>
sound.play();<BR>

</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Using the loop functionality can be very helpful for background sounds.  Instead of downloading long sound files, you can loop short sound files. Looping a sound file will play it over and over without pause. This will shorten download time without 
sacrificing quality.</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
The supported list of audio file formats is extremely limited. Currently, you can use only 8-bit, 8000Hz, single-channel (mono) NEXT/Sun AU files with G711 <FONT FACE="Symbol">m</FONT>-law compression. Note that files with a higher sample rate may produce 

hissing on playback.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<P>
Adding images to your applet is very similar to adding audio.
The primary difference is that the image does not have a <TT>draw</TT>
method to display itself, whereas the audio clip contains its
own play method. To attach to a particular image, call the <TT>Applet.getImage</TT>
method. The URL (or a base URL and relative path) can be specified
just like the <TT>AudioClip</TT>,
as follows:
<BLOCKQUOTE>
<PRE>
Image thePicture = myApplet.getImage(getDocumentBase(), &quot;image.gif&quot;);</FONT>
</PRE>
</BLOCKQUOTE>
<P>
An image object can reference either JPEG (JFIF) or GIF images.
To display the image, add a call to <TT>Graphics.drawImage</TT>.
This is usually done in the applet's (or component's) overridden
<TT>paint</TT> method. The following
example explains how to display an image object. Note that the
call to <TT>myApplet.getGraphics</TT>
is made because only a <TT>Graphics</TT>
object can display an <TT>Image</TT>:
<BLOCKQUOTE>
<PRE>
Graphics g = myApplet.getGraphics();
g.drawImage(thePicture, 20, 40, myApplet);
</PRE>
</BLOCKQUOTE>
<P>
The method <TT>Graphics.drawImage</TT>
is overloaded and has four implementations. They vary based on
whether or not a default background or output resolution is specified.
If an output resolution is specified, the image is scaled as it
is rendered to the screen.
<P>
Images can also be created or altered by your applet, and they
can be rendered on or off screen. For more information, see Chapter
4, &quot;Displaying Images.&quot; Also, refer to the <TT>ImageProducer</TT>
class and the <TT>java.awt.image</TT>
package.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Unfortunately, images are not components in the Java libraries. This means that they cannot be added directly to a layout. If you want to add images to a display that contains components, you probably need to subclass <TT>Canvas</TT>. Your subclass must at 

least override the <TT>Component.paint</TT> method. Add the <TT>Graphics.drawImage</TT> method to the paint method. This is illustrated in the sample code <TT>ImageCanvas.java.</TT> To develop a more robust <TT>ImageCanvas</TT>, you should also override 
the <TT>Component.preferredSize</TT>, <TT>Component.minimumSize</TT>, and <TT>Component.size</TT> methods to return the actual image dimensions. This makes the resulting component the correct dimensions.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H2><A NAME="TheOnLineMultimediaEncyclopediaInDepth"><FONT SIZE=5 COLOR=#FF0000>
The On-Line Multimedia Encyclopedia In-Depth</FONT></A></H2>
<P>
We have discussed how to add sound and pictures to your applet;
an on-line multimedia encyclopedia is a simple extension of these
tools. The only thing to add is some descriptive text, an index,
and a few control buttons.
<H3><A NAME="AppletArchitecture">
Applet Architecture</A></H3>
<P>
To make the applet as flexible as possible, all of the display
options are specified as either applet parameters or in configuration
files. The encyclopedia cover page (image file name) and the index
file are specified in the applet parameter list. The topic configuration
filename is a field in the index file (associated with the index
listing), which references a file that contains fields specifying
an image filename, a sound filename, and a textual description
of the topic. Thus, the encyclopedia can be easily modified without
changing the underlying Java source code.
<P>
Due to the simplicity of this example, there is no need to create
a large set of new classes. However, due to their nature, <I>some</I>
new classes are straightforward, obvious, and well- behaved. These
classes are <TT>ImageCanvas</TT> and
<TT>FileParser</TT>. The <TT>FileParser</TT>
class was not actually created for this sample. It was originally
developed for the sample in <A HREF="ch38.htm" >Chapter 38</A>, &quot;Creating On-Demand
Multimedia Services.&quot; Follow good object practice here and
reuse it.
<P>
<TT>FileParser</TT> aids in configuration
file input, file and field parsing, and text region population
(loading the fields from the file into specified text regions).
<TT>ImageCanvas</TT> is a component
that displays an image within its body. The <TT>ImageCanvas</TT>
is required in order to include an image in a display that also
contains buttons and other widgets. The <TT>Canvas</TT>
allows an image to be displayed as part of a component. If the
image is not a component, no space is reserved for it by the Layout
Managers.  Listing 39.1 is an example of a basic <TT>ImageCanvas</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 39.1&nbsp;&nbsp;Implementing a Basic </B><TT><B>ImageCanvas
<BR>
</B></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
public class ImageCanvas extends Canvas {

 private Image theImage;

 // image canvas constructor
 public ImageCanvas(Image that) {
 theImage = that;
 }

 // draw the canvas
 public void paint(Graphics g) {
 // draw the image
 g.drawImage(theImage, 0, 0, this);
 }

}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="IndexWindow">
Index Window</A></H3>
<P>
The encyclopedia consists of two screens. The first is the index
screen; it contains a list of indexes and the encyclopedia cover
page (image). Double-clicking a list topic takes you to the topic
screen. Listing 39.2 shows the major steps required to display
an image in a <TT>Canvas</TT> on the
interface.
<HR>
<BLOCKQUOTE>
<B>Listing 39.2&nbsp;&nbsp;Creating the Cover Page Image Object
and Placing It in an </B><TT><B>ImageCanvas
<BR>
</B></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
...

// get the startup image
Image startUpImage = getImage(getDocumentBase(),imageFileName);

// create the intro image canvas component
introImage = new ImageCanvas(startUpImage);

//
// Create the GUI. Notice that the image canvas is a component and
// can be handled by the Layout Managers like any other component.
//
setLayout(new GridLayout(1,2));
add(indexPanel);
add(introImage);

...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
There is no need to explicitly draw the image, because its parent component <TT>ImageCanvas</TT> draws the image in its paint method.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<H3><A NAME="TopicWindow">
Topic Window</A></H3>
<P>
The topic window displays the topic's image, a text region containing
the topic information, a <I>Listen</I> button to play the sound
clip associated with the image, and an <I>Index</I> button that
takes you back to the original index screen.
<P>
Again, the <TT>ImageCanvas</TT> is
employed to place and display the image component. The <TT>AudioClip</TT>
object is created and tied to the Listen button.  Listing 39.3
shows the major steps required to create <TT>Image</TT>
and <TT>Audio</TT> objects. Listing
39.4 is an example of binding sound playback to a button action.
<HR>
<BLOCKQUOTE>
<B>Listing 39.3&nbsp;&nbsp;Creating Media Objects and Adding Them
to the Applet<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
...

//
// Create the image, image canvas, and audioclip objects.
// Sometimes the audio initialization takes some time, so post a
// message to the user.
//
showStatus(&quot;Initializing the audio. Please wait...&quot;);
sound = getAudioClip(getDocumentBase(), audioName);
Image theImage = getImage(getDocumentBase(), imageName);
ImageCanvas theCanvas = new ImageCanvas(theImage);
showStatus(&quot;&quot;);

// add the items to the applet
setLayout(new GridLayout(1,2));
add(theCanvas);
add(textPanel);

...
</PRE>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 39.4&nbsp;&nbsp;Play the Sound in Reaction to the Listen
Button<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
//
// watch for button events
//
public boolean action(Event event, Object arg) {

 // the listen button was pressed
 if(event.target == listenButton)
 sound.play();

 // didn't find anything of interest. see if my parent wants it.
 else
 return super.action(event,arg);

 return true;
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Shortcomings"><FONT SIZE=5 COLOR=#FF0000>
Shortcomings</FONT></A></H2>
<P>
Following are some shortcomings of Java for developing this multimedia
encyclopedia:
<UL>
<LI>Visual media types (images and video) should be subclasses
of components or should have containers that can accept them as
components.
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD>
<BLOCKQUOTE>
Until this happens, try subclassing <TT>Canvas</TT> and overriding the <TT>paint</TT> method. Also, override the <TT>minimumSize</TT>, <TT>preferredSize</TT>, and <TT>size</TT> method to make the panel conform to the image size.
</BLOCKQUOTE>

</TD></TR>
</TABLE>
</CENTER>
<P>
<UL>
<LI>Currently, the <TT>AudioClip</TT>
is limited to a very specific file format and even a specific
range of parameters within that format (Sun/NEXT audio file with
one channel, <FONT FACE="Symbol">m</FONT>-law compression, and
8KHz sample rate). This limitation should be removed.
<LI>Media streaming is available only via applets that are executed
in the environment of a robust Web browser (see <A HREF="ch13.htm" >Chapter 13</A>, &quot;Running
Applets as Applications,&quot; for details and work-arounds).
It is not possible to use the appletviewer to run or debug these
applets. The current debug method is a slow process of loading
your applet into a Web browser, checking it out, and then editing
your Java source. This in itself is not so bad, but some browsers
buffer your classes (even if you try to force a reload). You must
relaunch your browser each time you want to test another feature.
Also, it is difficult to get any debug feedback via <TT>System.out</TT>,
because some Web browsers do not supply a standard out.
<LI>Java needs to include video streaming.
<LI>Java should include 3-D world streaming for support of these
potentially important types for a multimedia encyclopedia.
<LI>Ultimately, the streams need to have more user feedback control.
For example, the user should be able to pause and scrub video
and audio clips.
<LI>True data streaming should be implemented to reduce initialization
delay times in the instantiation of objects. There may be some
room for compromise using built- in asynchronous transfers.
<LI>There is no way to synchronize graphical events with audio
playback. There should be a time-based synchronization method.
This will need to be easily integrated with video streaming.
</UL>
<H2><A NAME="NewFeatures"><FONT SIZE=5 COLOR=#FF0000>
New Features</FONT></A></H2>
<P>
Java is evolving; look for the following changes that will affect
the development of multimedia applications:
<UL>
<LI>Video implementation<BR>
Improvements will include both latency-sensitive and insensitive
video and will accommodate both streaming and stored video sources.
<LI>Enhanced audio<BR>
Enhancements will include support for sampled and synthesized
audio, as well as 3-D-spatial audio sources. Streaming and stored
audio sources will be supported.
<LI>MIDI support<BR>
Support will include timed event streams, loadable synthesizers,
and effects.
<LI>High-performance 2-D object animation<BR>
2-D support will include sprites with transparency, programmed
sprite behaviors, scrolling background images, aggregation and
hierarchical compositing, and image transformation effects.
<LI>Improvements to 2-D graphics and imaging<BR>
2-D graphics support will include affine transformations (translate,
rotate, skew, and so on) on points and paths; compositing, which
will allow overlays, blending, and transparency; image filters
including features such as table lookup, convolve, and sharpen;
paint enhancements, including gradients and patterns.
<LI>Addition of 3-D geometry and behavior<BR>
3-D geometry features will include immediate, retained, and compiled-retained
3-D graphics; high-level specification of behavior and control
of 3-D objects; a generalized morphing engine; and high-resolution
coordinate anchors.
<LI>A new Java object-the servlet<BR>
Servlets are Java objects that can be downloaded from the server
at runtime. These servlets provide increased capabilities for
communicating with the server. In a simple case, they can be used
to replace the rather awkward CGI scripts that are currently being
used.
</UL>
<HR>

<CENTER><P><A HREF="ch38.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch40.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
