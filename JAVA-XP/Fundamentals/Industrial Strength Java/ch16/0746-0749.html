<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Jeeves and Java Servlets:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0743-0745.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0750-0753.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-746"><P>Page 746</P></A>


<P>You do need to identify the type of data contained in the response by specifying
the MIME type; and you may optionally specify the content length. To write the content,
the servlet calls getOutputStream() to get a ServletOutputStream as follows:
</P>

<PRE>
res.setContentType(&quot;text/html&quot;);
ServletOutputStream out = res.getOutputStream();
</PRE>

<P>You can create your HTML either manually by using print() statements or by using
the HTML support package defined as part of the Servlet API. Use the
HTML classes and create a new HtmlPage. The information from the request is displayed as a table.
First, display the information available only through method calls:
</P>

<PRE>
HtmlPage page = new HtmlPage(&quot;HTTP Request Display&quot;);
page.add(&quot;HTTP Request Information&quot;, &quot;h1&quot;);

HtmlTable tbl = new HtmlTable(&quot;Border&quot;);
tbl.addHeader(&quot;Parameter&quot;);
tbl.addHeader(&quot;Value&quot;);
nextRow(tbl, &quot;Server name&quot;, req.getServerName());
nextRow(tbl, &quot;Server port&quot;, Integer.toString(req.getServerPort()));
nextRow(tbl, &quot;Client host&quot;, req.getRemoteHost());
nextRow(tbl, &quot;Client addr&quot;, req.getRemoteAddr());
nextRow(tbl, &quot;Method&quot;, req.getMethod());
nextRow(tbl, &quot;Request URI&quot;, req.getRequestURI());
nextRow(tbl, &quot;Path info&quot;, req.getPathInfo());
nextRow(tbl, &quot;Path Xlated&quot;, req.getPathTranslated());
nextRow(tbl, &quot;Query String&quot;, req.getQueryString());
</PRE>

<P>Next, get a Hashtable containing all of the HTTP request header parameters and
iterate through them, as follows:
</P>

<PRE>
  Hashtable params = req.getParameters();
  Enumeration enum = params.keys();
  while (enum.hasMoreElements()) {
    String name = (String) enum.nextElement();
    String value = (String) params.get(name);
    tbl.newRow();
    tbl.addData(&quot;&lt;strong&gt;&quot; + name + &quot;:&lt;/strong&gt;&quot;);
    tbl.addData(&quot;&lt;em&gt;&quot; + value + &quot;&lt;/em&gt;&quot;);
  }
</PRE>

<P>Finally, write the HTML for the page to the ServletOutputStream. The response
header that you create is automatically written to the ServletOutputStream before your first
write is handled. This code completes the service() method:
</P>


<A NAME="PAGENUM-747"><P>Page 747</P></A>


<PRE>
  page.add(tbl);
  page.write(out);
  }
</PRE>

<P>The nextRow() method formats each line of the response as follows:
</P>

<PRE>
  void nextRow(HtmlTable tbl, String name, String value) {
  tbl.newRow();
  tbl.addData(&quot;&lt;strong&gt;&quot; + name + &quot;:&lt;/strong&gt;&quot;);
  tbl.addData(&quot;&lt;em&gt;&quot; + value + &quot;&lt;/em&gt;&quot;);
  }
}
</PRE>

<P>This completes the SmpleServlet class definition. The servlet can also
use ServletResponse to return a standard error or redirect response.
</P>

<H4><A NAME="ch16_ 23">
Handling HTML Forms
</A></H4>

<P>Many of the functions performed by CGI programs center around
HTML forms handling. When using HTML forms, the browser extracts the information entered into the form
by the user and sends it to the server as either a GET or POST request. Because
form processing is such a common servlet activity, the
Servlet API includes a built-in Servlet class specific for forms handling: The
FormServlet extracts the form information from the query string for GET requests or from the content for POST requests. The
differences between GET and POST are invisible to your subclass of FormServlet.
</P>

<P>In the following example, FormServlet is subclassed to build a form-processing
servlet that simply reads and displays the contents of a form:
</P>

<PRE>
public class FormDisplayServlet extends FormServlet {
  public void FormDisplayServlet() {
  }
</PRE>

<P>FormServlet's service() method has already accomplished the following:
</P>

<UL>
<LI>     Verified the HTTP method as GET or POST
<LI>     Retrieved the form information from either the URL for a GET request or from
the content of the request for a POST
<LI>     Stored the form information as a Hashtable of name/value pairs
</UL>

<P>Your subclass should override the sendResponse() method to do any request processing
as follows:
</P>

<A NAME="PAGENUM-748"><P>Page 748</P></A>


<PRE>
public void sendResponse(HttpServletResponse res, Hashtable params)
  throws IOException {
ServletOutputStream out = res.getOutputStream();
</PRE>

<P>You must always specify the content-type on responses that include data. Allocate
a HtmlPage to help construct the HTML response page and add a level-one header as
shown in the following:
</P>

<PRE>
res.setContentType(&quot;text/html&quot;);
HtmlPage page = new HtmlPage(&quot;Form Display&quot;);
page.add(&quot;Form Display&quot;, &quot;h1&quot;);
</PRE>

<P>Because the FormServlet superclass has already stored the form information in
a Hashtable, performing forms handling is a simple matter of retrieving data from
the Hashtable and processing it. For this example, processing is simply formatting the
forms data as a table that is returned to the browser. Access the data using an Enumerator
and add a row to the table for each name/value pair in the form request as shown in
the following:
</P>

<PRE>
HtmlTable tbl = new HtmlTable(&quot;Border&quot;);
tbl.addHeader(&quot;Input Element&quot;);
tbl.addHeader(&quot;Value&quot;);
int count = 0;
Enumeration enum = params.keys();
while (enum.hasMoreElements()) {
  String name = (String) enum.nextElement();
  String value = (String) params.get(name);
  count++;
  tbl.newRow();
  tbl.addData(&quot;&lt;strong&gt;&quot; + name + &quot;&lt;/strong&gt;&quot;);
  tbl.addData(new HtmlText(value, &quot;em&quot;));
}
</PRE>

<P>Note the two different ways to include HTTP format information in the
table cells. 
The first involves manually creating a string that contains the desired HTML
commands. The second uses the HTML support classes to generate a text element that is added to
the table. The use of one approach instead of using the other is primarily a style issue,
except in two cases. The HTML classes are a simplification of the complete language; you
are required to manually create HTML code for attributes not supported by the
classes. Alternatively, when your HTML processing is structured or repeating as in this example,
it is easier to use the support classes because they reflect the hierarchical nature of HTML.
</P>


<A NAME="PAGENUM-749"><P>Page 749</P></A>


<P>After you finish building the table, write a summary of the form information, add the
table to the page, and then write the HTML for the complete page to the output stream. The
first write to the ServletOutputStream triggers a write of the HTTP response header to
the output stream. Even though the ServletOutputStream is buffered, you do not need to
call the flush() method; the server automatically calls the stream's flush() method.
The following code completes the sendResponse() method. Remember that the
&Acirc; symbol indicates a line that normally fits on the previous line.
</P>

<PRE>
  page.add(&quot;&lt;p&gt;This page contains &quot; + Integer.toString(count) + &quot; input
     &Acirc;elements.\n&quot;);
  page.add(tbl);
  page.write(out);
  }


}
</PRE>

<P>This completes the definition of the FormDisplayServlet class.
</P>

<H4><A NAME="ch16_ 24">
Extending the FormServlet
</A></H4>

<P>One limitation of the standard FormServlet is that the subclasses that implement the
forms processing do not have access to the request information contained in the HTTP
header. Only the name/value pairs from the form are provided to FormServlet subclasses
when performing form processing. The main reasons why the request information is needed is
to obtain state information from the client (using cookies), to verify the client's ability
to accept certain MIME types or to obtain the user's name when performing
additional access control checks. The following modified version of FormServlet passes
the HttpServletRequest information as an argument of the sendResponse() method:
</P>

<PRE>
public abstract class NewFormServlet extends HttpServlet {
  public void NewFormServlet() {
  }

  public void service (HttpServletRequest req, HttpServletResponse res)
    throws ServletException, IOException {
</PRE>

<P>First determine the HTTP method being used. For
GET requests, the form information is encoded into the URL after the servlet reference and can be obtained by
calling getQueryString(). For POST methods, the processing is a bit more complex; the
form information follows the request header and must be identified as being URL encoded.
The getContents() method, which follows, reads the request content and returns a
string.
</P>


<P><CENTER>
<a href="0743-0745.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0750-0753.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



