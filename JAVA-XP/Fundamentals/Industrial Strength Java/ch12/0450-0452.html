<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0447-0449.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0453-0456.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-450"><P>Page 450</P></A>


<P>
The point of this discussion is that there is no single optimum arrangement of
processing, storage, and networking links to suit every situation. It is up to the designer to make
a reasonable guess at the usage patterns and choose the best mix and deployment
of resources.
</P>

<H4><A NAME="ch12_ 3">
The Need For Transparency
</A></H4>

<P>One design principle that helps you plan a successful system is to design for flexibility.
If the components of the system can be rearranged, even after the system has been
deployed, then you can compensate for even major miscalculations in the analysis/design phase.
The key to achieving this flexibility is transparency. A good working definition of
transparency is &quot;the concealment from the user and the application programmer of the separation
of components in a distributed system so that the system is perceived as a whole rather than
a collection of independent components&quot; (Coulouris, Dollimore, Kindberg 1994).
</P>

<P>The ISO Reference Model for Open Distributed Processing identifies eight forms
of transparency as cited in CDK 1994:
</P>

<UL>
<LI>          Access
transparency. Identical operations are used to access remote and
local data.
<LI>          Location
transparency. Data is accessed without clients knowing its location.
<LI>          Concurrency
transparency. Multiple processes are able to access data
without concern for each others' existence.
<LI>          Replication
transparency. Multiple copies of data can be created to
increase availability and performance while presenting the appearance of a single copy
to clients.
<LI>          Failure
transparency. Parts of the implementation can fail while allowing
clients to continue their processing undisturbed.
<LI>          Migration
transparency. Data can move between and around the system
without clients being aware of the location change.
<LI>          Performance
transparency. The system configuration can change to
accommodate changing loads without affecting clients.
<LI>          Scaling
transparency. The system can expand in capacity and scale
without requiring structural changes to itself or its clients.
</UL>

<P>Transparency at various levels is an attempt at controlling the complexity of
distributed software systems and making them resilient in the face of change. By separating
concerns, designers can concentrate on each facet of operation without worrying about how it
might affect other aspects of the system.
</P>

<A NAME="PAGENUM-451"><P>Page 451</P></A>



<P>By now you might have realized that transparency in another guise is also a cornerstone
of object-oriented programming (OOP), where it is known as encapsulation.
</P>

<H4><A NAME="ch12_ 4">
Distributed Object Computing
</A></H4>

<P>Object orientation is currently the prevailing paradigm for new software development.
It offers several advantages over the structured approaches it builds upon, not the least
of which is encapsulation&#151;the hiding of implementation details from users of objects.
With distributed objects, even the geographical location of the implementation is hidden.
Object orientation makes a crucial distinction between an object's interface (what the object
does) and its implementation (how it does it). Users of an object see only the interface, and
all dialog with the object is performed via this interface.
</P>

<P>A real-world analogy might be where a modern small business uses an office service.
In this case the interface will be one or more telephone and facsimile numbers. To
potential clients, it appears as if the business has dedicated reception staff and all the amenities.
The real implementation is that the staff is serving dozens of other similar businesses. As
the business becomes established, it can afford to employ its own staff, and so the
implementation changes. Now the phone numbers connect to different people in a different
place, but this has no effect on the clients, who may remain completely unaware of the shift.
The interface remains constant, so even business stationery need not be reprinted.
</P>

<P>The fundamental support for encapsulation within object-oriented languages makes
them good tools for achieving the transparency required for successful distributed systems.
</P>

<H4><A NAME="ch12_ 5">
What Java Brings to the Party
</A></H4>

<P>The examples developed in Chapter 11, &quot;Advanced Networking,&quot; illustrate Java's
advantages over C or C++ in a networked environment.
</P>

<P>A particularly noteworthy asset of Java is that its standard library code supports
common Internet protocols, encapsulated within its java.net.URL and
java.net.URLConnection classes, as well as the lower level socket's interface.
</P>

<P>Although interpreted Java code may execute more slowly than its compiled C++
counterpart, network overhead is likely to be more significant in determining application
performance (especially if the link is a low-speed connection to the Internet). In many cases,
the user of the application would notice little if any difference in responsiveness between
a C++ and a Java implementation.
</P>

<A NAME="PAGENUM-452"><P>Page 452</P></A>


<P>
Java is especially powerful because a client machine may be running any operating
system that supports the Java environment. This requires only a single version of the
program. With a C++ implementation, a recompilation is necessary for each type of client
platform. Furthermore, incompatibilities between environments can require extensive
recoding&#151;a potentially very expensive proposition, given today's heterogeneous networks. In a
word, Java's edge is portability.
</P>

<H4><A NAME="ch12_ 6">
What Java Lacks
</A></H4>

<P>In a distributed application, it is the designer's responsibility to select the protocol used
to move data between client and server. Sometimes a well-known and supported
protocol may be available, such as FTP for transferring files. More often, with a custom
database application, for example, no such protocol exists, and it is necessary to both design
and build an application-specific protocol to connect both parts of the program.
</P>

<P>In this situation, Java itself offers no advantage over other languages. If
performance bottlenecks are discovered when the system is deployed, functionality will have to
migrate to rectify the problem. The protocol between client and server must change, and so
must the code which implements the protocol; in fact, it has to change for each
different arrangement, making empirical tuning an expensive business. In other words, Java
lacks support for location transparency.
</P>

<H4><A NAME="ch12_ 7">
A Glimmer of Light
</A></H4>

<P>So, what is to be done? How can Java be used to construct successful distributed
systems that are able to evolve to meet the changing demands placed upon them? The
transparency requirement is common to most distributed applications; creating a common
reusable architectural framework to support it should greatly aid the design and
implementation process.
</P>

<P>Do such frameworks and interoperability standards exist? The answer is a
qualified `yes'&#151; the qualification being that much of what is available is still in its early stages
of development, and where standards are mature, their adaptation to Java is still
undergoing refinement. The two main initiatives covered in this chapter are the Java Remote
Method Invocation (RMI) services from JavaSoft and the Common Object Request
Broker Architecture (CORBA) standard from the Object Management Group (OMG).
</P>

<P>As a prelude to understanding these initiatives, it is worthwhile to look at the
fundamentals on which these systems are built, particularly the Remote Procedure Call
(RPC) abstraction.
</P>
<P><CENTER>
<a href="0447-0449.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0453-0456.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



