<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0450-0452.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0457-0459.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-453"><P>Page 453</P></A>



<H3><A NAME="ch12_ 8">
Distributed Computing <BR>
Fundamentals
</A></H3>

<P>For basic TCP/IP network programming, C/C++ and Java programmers have an
interface provided by the libraries. The interface originated with Berkeley Unix (as did TCP/IP)
and is called the &quot;socket.&quot; Sockets are quite flexible and provide the functionality needed
for communicating between machines.
</P>

<P>However, as an abstraction, sockets are still very low-level constructs. Usually,
when programmers want to execute another section of code, they simply call it, passing
arguments and receiving a returned result. The question arises as to why it is so much harder
to call code that resides on another machine than code on the local machine. Certainly
there is more work to be done but it is the sort of work that should be automated and carried
out under the covers. This was the thought of some of the pioneers working on
distributed computing more than a decade ago; that it should be possible to provide a more
natural abstraction to the programmer. The result is known as the Remote Procedure Call,
where code on another machine can be called the same way as local code.
</P>

<H4><A NAME="ch12_ 9">
A Suitable Abstraction&#151;The RPC
</A></H4>

<P>It is instructive to examine how a local procedure call works before generalizing to
cover RPCs. A procedure call is considered local when the calling code and the called
procedure both reside in the same process.
</P>

<P>In this case the data required by the procedure being called is passed as a number
of arguments. These arguments are placed in memory, usually on a stack, along with
the return address where execution will resume on completion of the call. The thread
of execution passes to the called procedure by jumping to its location in memory.
</P>

<P>The called procedure retrieves the return address from the stack and makes a note of it.
It then gets the arguments off the stack and uses them to perform its computations,
before storing the results back onto the stack. Finally it returns to the calling procedure
by jumping to the return address; the caller reads the results and continues with its execution.
</P>

<P>From this description, you can see that calling a local procedure relies heavily on
both calling and called procedures sharing an address space. Both had to agree on locations
to jump to for controlling the flow of execution. Both required read/write access to
shared 
</P>


<A NAME="PAGENUM-454"><P>Page 454</P></A>

<P>
memory in order to pass arguments and return results. To implement an RPC
mechanism, the memory address-based approach must be replaced with one better suited to a
networked environment.
</P>

<H4><A NAME="ch12_ 10">
Implementing Transparency
</A></H4>

<P>A primary aim of RPC (and indeed distributed computing in general) is to
provide transparency; to reduce or eliminate the differences between local and remote calls
from the programmer's perspective.
</P>

<P>However, the fact that the two are different in a number of ways is somewhat
inescapable; it is up to the designer of the RPCs implementation to decide just how visible
those differences should be.
</P>

<P>There is a constant tension between providing transparency and providing
sufficient control to the programmer.
</P>

<P>Exception handling is one important area where this tension is apparent. Local calls
are extremely reliable, whereas networks are far less so. Packets may be lost, servers may
not be available, or may &quot;go down&quot; part way through an exchange. Calls may fail because
the caller had insufficient privileges to perform the operation. A reasonable compromise is
to provide sufficient transparency to hide the details of message passing and data
formatting, but to expose failure conditions, giving control over how to handle them to the user.
</P>

<P>Another area of difficulty is addressing: In the local model, the piece of code to be
called was specified by a memory address. The RPC has to provide a way of specifying both
the host machine on which the code resides, and which copy of the code to call, as there
may conceivably be several versions.
</P>

<P>There is no easy solution to all the issues that arise, and each implementation
makes compromises appropriate to its design goals.
</P>

<P>The steps that might be taken by an RPC implementation to map a local call to an
exchange of messages over a connection are shown in figure 12.1.
</P>

<P>There are three main tasks that must be accomplished by an RPC implementation:
</P>

<UL>
<LI>     Binding. Finding the location of the remote procedure or service
<LI>     Communications. Providing a reliable network connection that enables
the transmission of requests and responses
<LI>          Interface to user
code. Converting the procedure call to a block of data,
which can travel across the connection, and reassembling it at the other end
</UL>


<A NAME="PAGENUM-455"><P>Page 455</P></A>



<P><a href="images\ch12fg01.jpg"><img src="images\tn_ch12fg01.jpg"></a><BR>
Figure 12.1
The outline of a possible RPC implementation.
</P>

<P>
<B>
Binding
</B>
</P>

<P>With distributed systems, it would be very unusual for the location of the remote
portion of the code to be known when the code was written. The eventual users will expect to
be able to move server code between machines to suit their particular network. This makes
it necessary for clients to have a way to discover the location of the server portion of
the routines, preferably at run-time.
</P>

<P>A similar problem occurs on the Internet, where web servers may move between
hosts with different Internet protocol (IP) numbers, yet hotlists in browsers are not
automatically changed. Here it is solved by mechanisms such as the Domain Name Service
(DNS), which maps the host name part of the URL into an IP number.
</P>

<A NAME="PAGENUM-456"><P>Page 456</P></A>


<P>
For small intranets, it is possible to individually enter details of the server locations
into each client. For large systems, such as the Internet, such a static approach is not tenable.
A complete distributed naming service becomes necessary. Servers contact this service
and provide their details; clients contact the service and perform queries to find the
addresses of the servers that they need.
</P>

<B>
Communications
</B>

<P>After the host with the server code has been found, the code responsible for
communication has to support a &quot;circuit&quot; between client and server. Of course, in a
packet-based network, the circuit doesn't really exist, but it is a useful abstraction to insulate the rest
of the code from the realities of imperfect networks&#151;transparency at work once again.
In real networks, packets may travel across different routes and may get corrupted or
even lost.
</P>

<P>The code implementing the virtual circuit must perform operations such as
packet retransmission and reordering to compensate.
</P>

<B>
Interface To User Code&#151;Stubs and Skeletons
</B>

<P>Code is necessary at both the local and remote ends of the connection to maintain
the transparency perceived by users of the RPC. At the local end, a
stub procedure acts as a proxy for the remote procedure. It has the same signature (name, arguments, return
type) as the remote procedure, but its job is to package the arguments as a message and pass
the message on to the communications code. On completion of the remote call, the
message containing the results emerges from the communications code, and the stub extracts
the return value before passing it back to the caller.
</P>

<P>The counterpart of the stub, located on the server side, is termed a
skeleton. It converts incoming messages into arguments and calls the procedure's implementation. When
the code has finished executing, it converts the return value to a message and passes it on
to the communications code for return to the calling stub.
</P>

<B>
Marshaling the Arguments
</B>


<P>The stub collects together the arguments into a block for sending to the remote
machine. This packaging is known as marshaling the arguments. The converse operation,
of extracting individual data items, is called
unmarshaling.
</P>

<P>For arguments passed by value such as integers or Booleans it is a
straightforward operation to bundle them together. An issue arises, however, when an argument is
a reference to data rather than the data itself. The data referenced is in the local
machine, and if it is to be accessed or modified by the remote procedure, it also has to be
copied across
</P>
<P><CENTER>
<a href="0450-0452.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0457-0459.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



