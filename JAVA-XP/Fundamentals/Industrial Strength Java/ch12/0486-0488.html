<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0483-0485.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0489-0492.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-486"><P>Page 486</P></A>



<P>In a generally heterogenous CORBA system, an ORB will exist on each machine.
This situation is not strictly necessary if the architecture is an asymmetrical client-server,
where there are either no objects on the client or they are never accessed remotely. In this case,
a simpler layer of code that is able to forward requests to servers will suffice.
</P>

<P>Clients issue a request that identifies the target object, the operation, and a number
(this may be zero) of parameters. This request is processed by the local ORB and forwarded
to the appropriate implementation. If the object implementation is on a remote host, the
ORB communicates with its counterpart on that host to effect the call. If the call is
synchronous, the caller will wait for completion of the remote call and any resulting data to be
returned. Failure of the call causes an exception, which is handled by the caller. If the call
is asynchronous, the caller does not wait for completion.
</P>

<B>
Interfaces
</B>

<P>Objects Interfaces are defined using OMGs Interface Definition Language. As in the
RPC model examined earlier, these are used to generate stubs and skeletons in the
implementation languages. For instance, if an object were implemented in the Ada language, and
the client program were written in C, the client stubs generated from the IDL would be in
C and the implementation skeletons would be in Ada.
</P>

<P>In addition to stubs/skeletons, the IDL interface definitions are compiled to a
queryable form and stored in an interface
repository, providing a store of &quot;meta-data&quot; for use by
the ORB (see fig. 12.8).
</P>

<P><a href="images\ch12fg08.jpg"><img src="images\tn_ch12fg08.jpg"></a><BR>
Figure 12.8
Use of an interface repository.
</P>


<A NAME="PAGENUM-487"><P>Page 487</P></A>



<B>
Client-Side Invocation
</B>

<P>Two approaches to invoking operations on objects are supported by the ORB. One is
the conventional static approach, where the client uses compiled stubs, which are linked
into the client code. The second approach is dynamic where the entire call is constructed
at run-time. The dynamic interface is the same for all ORBs/objects, whereas the static
stubs will be specific to the interfaces of the objects being called.
</P>

<B>
Static Invocation
</B>


<P>Static binding is the approach used by both RPC and RMI. It is well-suited to the
traditional corporate intranet style of application development, where all aspects of
the applications, including the way their objects are distributed, are under the control of
one project or department. The IDL compiler generates the proxy stubs for the remote
objects, and skeletons for their implementations.
</P>

<P>Several advantages accrue from having all the information available at compile time:
</P>

<UL>
<LI>          Static type checking is possible, so programs are robust.
<LI>          Performance is also good because operations are requested with a single API call.
<LI>          A familiar model is presented to developers, hopefully leading to good
productivity and more readable code.
</UL>
<P>
<B>
Dynamic Invocation
</B>
</P>

<P>The alternative to static stubs and skeletons is to build the entire call dynamically.
This makes possible a whole range of applications which are difficult to build using only
static interfaces; applications such as Network Management tools and Application
Builders, which cannot have build time knowledge of all the objects they will be applied to.
</P>

<P>CORBA provides full support for a dynamic style of interface with its Dynamic
Invocation Interface (DII). The DII provides the same interface regardless of the program
objects it is accessing, unlike the static stubs, which are specific to a particular class.
</P>

<P>To discover the interface details so that a request can be built, the Interface
Repository (IR) provides a source of meta-data about objects. IR definitions are usually
generated from the IDL interfaces by similar tools to those that generate the stubs, although,
in keeping with the dynamic approach, the IR API includes calls to dynamically
create interface definitions, too. IRs are implemented as a set of persistent objects, which
hold the data that describes the interfaces. They are arranged in a containment hierarchy,
which is navigated by name.
</P>

<A NAME="PAGENUM-488"><P>Page 488</P></A>



<B>
Server-Side Function and Object Adapters
</B>

<P>Objects Adapters provide the bulk of server-side functionality.
They manage the server-side equivalent of Interface Repositories,
known as Implementation Repositories (and sadly both have
identical acronyms), which hold details of the object implementations
the server can use.
</P>

<P>New object implementations are installed on the server by
the Object Adapter, which registers their details in the
Implementation Repository.
</P>

<P>One type of Object Adapter is mandated for all CORBA
compliant ORBs&#151;the Basic Object Adapter (BOA). It is intended to be able
to handle most &quot;regular&quot; object implementations, but may be
replaced for special cases, such as where objects are being served from
an object-oriented database.
</P>

<P>Object Adapters have a number of responsibilities, including
the following:
</P>

<UL>
<LI>          Generation and interpretation of object references
<LI>          Activation and deactivation of object implementations
<LI>          Invocation of methods, using skeletons
<LI>          Advertising available services to the outside world
</UL>

<P>When requests arrive at the Object Adapter, they look
identical whether they were the result of a static invocation or built using DII.
</P>

<B>
Object Activation/Deactivation
</B>


<P>Activation is the process of readying objects to perform operations, and deactivation is
the converse process. When a request is made to an object's interface by a client, that
object may not be able to process the request immediately because it is not in memory at
the time; for instance, it may be a persistent object in a database, or its operation code may
be part of a dynamically linked library that is not currently loaded. It is the responsibility
of the BOA to load all necessary parts so the call may proceed.
</P>

<B>
Dynamic Skeleton Interface (DSI)
</B>
<P>An interesting server-side interface is the Dynamic Skeleton
Interface (DSI), which enables object implementations to be built without knowledge of the object type they
will implement. Its main practical use is for creating
bridges to non-CORBA environments, such as 
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The dynamic invocation approach is unique to CORBA across the
systems discussed in this chapter and is not currently supported
by RMI. However, the new Java Beans model for
component software (from Sun) implies the need for such
&quot;reflection&quot; about the components of a system,
prompting the development and inclusion of the
Java Reflection APIs in JDK v1.1. Likewise, the principal
procedural distributed framework, DCE (mentioned earlier), has no
similar facilities.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<P><CENTER>
<a href="0483-0485.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0489-0492.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



