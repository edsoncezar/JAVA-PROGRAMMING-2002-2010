<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0486-0488.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0493-0496.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-489"><P>Page 489</P></A>




<P>
Microsoft's ActiveX (formerly known as Object Linking and
Embedding&#151;OLE) or the Common Lisp Object System (CLOS). The code using the interface interprets
the requests and maps them to a form compatible with the foreign object system.
</P>

<B>
Interoperability and Inter-ORB Protocols
</B>

<P>Although the ORB model is useful for visualizing its operation from a
programmer's perspective, it is apparent that its functionality is actually distributed between
address spaces, and usually across machines. The client and server components of the ORB
must somehow be able to communicate. In the general case where an ORB exists on
each machine, the ORBs must be able to communicate with a common protocol. In the
original CORBA 1.x standard, exactly how this was to be achieved was never specified.
</P>

<P>To work in an open environment, it became apparent that not only must ORBs
facilitate communication between objects, but that different ORB implementations must be able
to interoperate. Without this capability, client objects would be restricted to hosting on
only one vendor's product. CORBA 2.0 specifies a set of common message formats and
data representations to enable communication between ORBs, called the General
Inter-ORB Protocol (GIOP). IDL data types are mapped into a Common Network
Representation (CNR) for transmission, taking into account byte ordering and alignment issues.
CNR plays the same role as Sun's XDR, which was mentioned previously in connection
with NFS.
</P>

<P>GIOP itself doesn't specify the communications protocol used to transfer its
messages. Instead, it uses a specific protocol appropriate to its application. One
communications protocol is mandated by the CORBA 2.0 standard: It is the Internet Inter-ORB
Protocol (IIOP), which uses TCP/IP as its transport.  Other protocols may be implemented by
a particular ORB for GIOP messaging, and these are referred to as
Environment-Specific Inter-ORB Protocols (ESIOPs). A prominent example is the Distributed
Computing Environment Common Inter-ORB Protocol DCE-CIOP, which allows for
interworking with existing DCE systems.
</P>

<H4><A NAME="ch12_ 27">
The Interface Definition Language (IDL)
</A></H4>

<P>IDL is a cornerstone of the whole OMG strategy. Because the various
specifications concentrate on specifying interfaces rather than prescribing implementations, the
language that expresses these interfaces is of primary importance.
</P>

<P>Compared with most languages, the structure of IDL is very straightforward. It
doesn't have to specify implementation, so it avoids control structures and the like, giving it
an entirely declarative style. Its syntax is much like Java's, with additional keywords
introduced to handle the additional semantics of distributed objects.
</P>

<A NAME="PAGENUM-490"><P>Page 490</P></A>


<P>
IDL, of course, is not directly encountered by the programmers who use the objects that
it describes. Instead, all the constructs are mapped to a target programming language by
an IDL compiler before being used. Despite its C/Java-like syntax, IDL is designed to
be effectively neutral with respect to its target languages, and it largely succeeds.
Currently, standard mappings exist not only to C and C++, but also to rather different
languages, such as Ada and Smalltalk. Mappings to Java and COBOL are currently passing
through the adoption process.
</P>

<P>The following discussion uses the OMG's terminology, which is different in places to
that used by a Java programmer. The following chart provides an approximate guide.
</P>


<TABLE>

<TR><TD>
IDL Term
</TD><TD>
Java Term
</TD></TR><TR><TD>
Module
</TD><TD>
Package
</TD></TR><TR><TD>
Attribute
</TD><TD>
Field
</TD></TR><TR><TD>
Operation
</TD><TD>
Method
</TD></TR><TR><TD>
Derived class
</TD><TD>
Subclass
</TD></TR><TR><TD>
Base class
</TD><TD>
Superclass
</TD></TR></TABLE>

<P>Rather than providing a complete reference for IDL, the following sections concentrate
on where it differs from Java or C, particularly in its structure and the new keywords it
adds. The aim is to present enough information to allow you to read IDL files. The full
reference for IDL is presented in Chapter 3 of the CORBA 2.0 specification.
</P>

<B>
The Preprocessor
</B>

<P>If you are familiar with C or C++ programming, you will have encountered the
C preprocessor. Its role is to handle issues that are not really part of the language but are
instead related to the development environment. Specifically, it performs tasks such as
including the contents of one file in another, hiding sections of code if certain conditions are
true (for example, hiding debug code for a release build), and textually replacing symbols
with other symbols (macro substitution). The preprocessor, as its name suggests, processes
the code before it is seen by the compiler or other tools.
</P>

<P>IDL uses the same preprocessing scheme as C/C++ to handle environmental
issues. Preprocessor directives (commands) appear in IDL source files preceded by a #
symbol. For example, the directive #include &quot;codex.idl&quot; would be replaced with the contents of
the codex.idl file before compilation. The directives supported by IDL are fully
compatible with the ANSI C/C++ preprocessor. In practice, there will unlikely be a separate
preprocessor tool, but instead its function will be implemented as the first pass of an
IDL compiler, as it is in many modern C/C++ environments.
</P>
<A NAME="PAGENUM-491"><P>Page 491</P></A>



<B>
The Structure of IDL
</B>

<P>The main entities contained in an IDL file (alongside their closest Java counterparts)
are listed in the following chart.
</P>

<TABLE>

<TR><TD>
IDL Term
</TD><TD>
Java Term
</TD></TR><TR><TD>
Modules
</TD><TD>
Packages
</TD></TR><TR><TD>
Interfaces
</TD><TD>
Interfaces
</TD></TR><TR><TD>
Attributes
</TD><TD>
Fields
</TD></TR><TR><TD>
Operations
</TD><TD>
Methods
</TD></TR><TR><TD>
Constants
</TD><TD>
Constants
</TD></TR><TR><TD>
Typedefs
</TD><TD>
Aliases for types&#151;no Java equivalent
</TD></TR><TR><TD>
Exceptions
</TD><TD>
Exceptions
</TD></TR></TABLE>

<P>At the risk of over-simplifying, IDL consists of a number of module definitions, each
of which contains interface definitions. Constants, typedefs, and exceptions may
appear almost anywhere, whereas operations and attributes are always part of an
interface definition. A pseudocode outline is shown in listing 12.9.
</P>

<P>Listing 12.9 IDL Pseudocode to Illustrate Structure
</P>
<PRE>
module marsupial {
    constants       // module specific
    typedefs
    exceptions

    interface kangaroo {
        constants   // interface specific
        typedefs
        exceptions

        attributes
        operations
    }

    interface platypus {
        ...
    }
}
</PRE>

<A NAME="PAGENUM-492"><P>Page 492</P></A>



<B>
Modules, Naming, and Scoping
</B>

<P>Modules in IDL have a similar function to the package mechanism of Java. They
don't have any effect on the code, but instead they are used to control the name space (scope)
of various other entities. Placing names in a scope means they will not conflict with others
in the system. Although only a short form of the name is specified, each named entity has
a full &quot;scoped&quot; name, allowing it to be referred to unambiguously when necessary. As
in Java, modules can be nested to form a naming hierarchy.
</P>

<P>Modules are not the only constructs that create a new scope; scopes are also created by:
</P>

<UL>
<LI>          Interfaces
<LI>          Structures
<LI>          Unions
<LI>          Operations
<LI>          Exceptions
</UL>

<P>Modules are different because they are solely concerned with naming issues, whereas
the other constructs imply additional semantics.
</P>

<P>The algorithm used to determine scoped names is simple. As the file containing the IDL
is read, a new scope is created whenever one of the above mentioned constructs is
encountered. The scoped name is generated by taking the name of the scope (module
name, interface name, and so on), appending the double colon (::) and prepending it to the
item being named. Items may appear at file scope, where there is no scope name defined.
In this case, only the &quot;::&quot; is prepended as shown in listing 12.10.
</P>

<P>Listing 12.10 An Example of Scoping
</P>

<PRE>
const short K = 3;

module wombat {
    const short K = 4;

    interface ears {
        const short K = 5;

        // at this point you have three definitions of K
        // just referencing K yields 5
        // whereas ::K is 3 and ::wombat::K is 4

...

    };
};
</PRE>


<P><CENTER>
<a href="0486-0488.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0493-0496.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



