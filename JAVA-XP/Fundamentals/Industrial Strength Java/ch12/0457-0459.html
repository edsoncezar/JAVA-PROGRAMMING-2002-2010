<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0453-0456.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0460-0464.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-457"><P>Page 457</P></A>


<P>and the reference seen by the remote code adjusted to reference the copy.
</P>

<P>Some implementations force the programmer to marshal reference arguments, but
provide library code to help. Others automatically marshal reference types they know about,
but limit the programmer to using only those types.
</P>

<B>
Remote Dispatch
</B>

<P>A mechanism is needed to determine the procedure to execute on the remote
machine. One approach is simply to number the procedures and to use these numbers to index
the implementations on the server. A more general solution is to generate a signature for
the procedure that is based on the name, argument types, and return types. The latter makes
it possible to perform typesafe calls.
</P>

<B>
Interface Definition
</B>

<P>Requiring the programmer to manually create the stub and skeleton code would
be counterproductive. Instead, tools are used to generate both the client-side stubs and
the server-side skeletons. The interface between the client and server is defined in one of
two ways:
</P>

<UL>
<LI>          In the same language as the implementation
<LI>          In a specialized Interface Definition Language (IDL) specifically designed for the task
</UL>

<P>Because IDLs are translated into the actual implementation language, they enable
the calling code and the remote procedure to be implemented in different languages. They
can also have a cleaner declarative syntax because they are specialized to the task of
interface definition. A disadvantage is that they present yet another language for the developer
to learn.
</P>

<H4><A NAME="ch12_ 11">
RPC in the Real World
</A></H4>

<P>Remote Procedure Calls provided the foundation for many previous distributed
systems. Their history dates back over 10 years to work at Xerox in the early eighties.
Sun's involvement with RPC mechanisms is also significant; they originated what is
probably the most widespread application based on RPCs, the Network File System (NFS).
One reason for the success of NFS is that it uses a standard &quot;wire&quot;-level format (called
XDR for External Data Representation) for data traveling across the network. By following
the standard, machines with different byte orderings can interoperate and cross mount
file systems.
</P>
<P>RPCs are also the fundamental building block of the Open Software Foundation's
(OSF)
</P>

<A NAME="PAGENUM-458"><P>Page 458</P></A>


<P>
Distributed Computing Environment (DCE), which is a currently available,
multiplatform, commercially distributed system. DCE has many similar aims to the CORBA
initiative, but is based on the procedural rather than object-oriented paradigm. To aid
implementation of distributed systems, it provided a Distributed File Service (DFS), a
Distributed Time Service, a Distributed Security Service (DSS), threads, and the Distributed
Directory Service for naming.
</P>

<P>As useful as it is, the RPC abstraction is based on the procedural programming
paradigm. With the increasing popularity of objects, the RPC has been evolved to handle
interactions between objects. Coverage of two such architectures form the remainder of this chapter.
</P>

<UL>
<LI>          JavaSoft's Remote Method Invocation is designed from the outset to be
Java specific. It is, therefore, very well integrated with the Java language.
<LI>          OMG's Common Object Request Broker Architecture (CORBA) is designed to
be language independent, allowing objects written in a variety of languages,
running on a range of machines, to interoperate seamlessly.
</UL>

<P>The types of applications you are writing determine which architecture you choose.
Both schemes have their costs and benefits. Although it is difficult to do justice to
either approach in these few pages, the following information should provide a foundation
for future exploration.
</P>

<P>Looking further ahead, it is quite possible that the differences between the two
approaches will become much less relevant for application programmers as improved tools
become available. When component-level technologies, such as Java Beans, begin to mature,
the glue connecting the components may become largely invisible.
</P>

<P>An interesting introductory paper on distributed computing from Sun Microsystems
can be obtained from
</P>

<PRE>
<a href="http://www.sunlabs.com/technical-reports/1994/abstract-29.html">
http://www.sunlabs.com/technical-reports/1994/abstract-29.html</A>
</PRE>

<P>It argues that complete location transparency can be disastrous. Failing to
distinguish between local and remote objects can produce detrimental results.
</P>

<H3><A NAME="ch12_ 12">
Java Remote Method Invocation
</A></H3>

<P>To provide a distributed object facility for Java applications and applets, the
JavaSoft division of Sun has released the Java Remote Method Invocation (RMI) package
with version 1.1 of the JDK.
</P>
<A NAME="PAGENUM-459"><P>Page 459</P></A>



<P>Along with Java Database Connectivity (JDBC) and the
Java Interface Definition Language, RMI forms part of the so-called
Java Enterprise API. Although it doesn't address all the issues of
deploying objects in a heterogeneous environment, it provides the
facilities needed by a wide range of distributed Java applications.
</P>

<P>By compromising on some generality, RMI has been designed
to retain the semantics of the Java object model and provide
close integration with the rest of the Java system. It allows objects in
one Java Virtual Machine (VM) to call methods on objects residing
in other Java VMs, with very little change in either the local or
remote code. The main difference from the user's perspective is the need
to handle the additional exceptions that may be generated by a
remote object, mostly related to issues of communication.
</P>

<H4><A NAME="ch12_ 13">
The Design of RMI
</A></H4>

<P>The aim of the RMI designers was to provide a &quot;native&quot; solution to the area of
distributed Java objects. As such they restricted their scope to objects implemented in Java,
rather than create a universal solution to allow communication with any object across
any protocol.
</P>

<P>The design objectives were as follows:
</P>

<UL>
<LI>          To make the process of invoking remote objects as similar as possible to that
of invoking local objects to clients of those objects
<LI>          To partially reveal  the location of objects, allowing client code to treat
them differently where appropriate
<LI>          To maintain the type safety and security of the native Java environment
<LI>          To be extensible, so future enhancements such as replicated objects fit neatly
into the overall architecture
</UL>

<P>The RMI implementation of JDK 1.1 has largely achieved these goals. How well
they have been achieved will become apparent as the Java development community gains
more experience with them.
</P>

<H4><A NAME="ch12_ 14">
Converting into a Distributed Application: An <BR>Example
</A></H4>

<P>Rather than discuss the way RMI is implemented and then develop an example,
this section takes the opposite approach of presenting the example first. From an initial
version 
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
This description of RMI is based on a beta release of
both the documentation and the tools. This was the latest
release at press time, but some details may have changed before
the final release.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<P><CENTER>
<a href="0453-0456.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0460-0464.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



