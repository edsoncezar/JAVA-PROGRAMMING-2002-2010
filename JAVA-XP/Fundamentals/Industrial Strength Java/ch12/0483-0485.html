<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0480-0482.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0486-0488.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-483"><P>Page 483</P></A>



<P>Late in 1995, the OMG extended the architecture slightly at the Common Facilities
level to account for the development of domain specific objects and frameworks. Realizing
the orthogonal nature of industry specific concerns, the architecture has a notion of
vertical divisions for different types of industry.
</P>

<P>The architecture is thus much more comprehensive than either of the approaches so
far considered: RPCs fall entirely within the bottom ORB layer, with RMI
additionally providing a minimal subset of the Common Services functionality.
</P>

<B>
The Standards
</B>

<P>Using the OMA for guidance, the OMG has been developing the standards in a
bottom-up manner. The Application Objects layer has no standards yet, though several
industry groups are actively discussing them. Sectors represented include business object
management, financial and accounting, medical and healthcare, and telecommunications.
</P>

<P>Likewise, the Common Facilities standards are still being developed; the areas covered
are user interfaces, information management, system management, and task management.
</P>

<P>The Common Services specifications, together known as CORBAservices, have
been adopted and published. The services are Naming, Event Management, Persistent
Objects, Lifecycle, Concurrency, Externalization, Relationships, Transactions, Query,
Licensing, Property, Security, and Time.
</P>

<P>As you can see, the range is very comprehensive. The base CORBA specification itself
is very mature. The first version was released in 1991, with the second major
version, CORBA 2.0, arriving in 1994. As a result there are many commercial
implementations. The CORBA specification makes a distinction between its core, which covers its
architecture and the syntax and semantics of its Interface Definition Language, and the
language bindings, which determine its &quot;APIs&quot; for various languages. To be CORBA-compliant,
an implementation must support the core specification and at least one language
binding. Bindings currently exist for C, C++, Smalltalk, and Ada'95. The Java binding is
currently being standardized (along with the COBOL binding) with a final version expected
mid 1997.
</P>

<P>The OMG recently made the full set of its adopted specifications available online via
the web. They are well-written and can be downloaded in Postscript (PS) or Portable
Document Format (PDF) from
</P>

<PRE>
<a href="http://www.omg.org/specindx.htm">
http://www.omg.org/specindx.htm</A>
</PRE>

<A NAME="PAGENUM-484"><P>Page 484</P></A>



<B>
The Object Model
</B>

<P>The Object Model is common to all OMG-compliant technologies. The Object
Model defines common object semantics, allowing objects to be represented in a form
independent of implementation. It concentrates on interfaces and forms a &quot;frame of reference&quot;
for all the other groups working under the OMG banner.
</P>

<P>To provide for extensibility, a Core Object Model is defined which must be supported
in any compliant system. Extensions are handled as &quot;extensions,&quot; which are not required
to be supported. Extensions are grouped into &quot;Profiles.&quot; Profiles will usually support
a particular area of application, such as Object Oriented Databases.
</P>

<B>
CORBA Terminology
</B>

<P>Although the concepts of object orientation are well understood, the paradigm has
been developed independently by many different groups, leading to a proliferation of names
for these concepts. Java and CORBA have different backgrounds and use different terms
for the same entities. The following discussion uses the OMG's terms, with references
to equivalent concepts in the Java world. The OMG terminology is shown in an
italicized typeface as it is introduced.
</P>

<P>Groups of objects, known as object systems, work together to provide
services to clients. Clients use services by issuing
requests. Objects are identified through their lifetime
by object identifiers.
</P>

<P>A request consists of an operation (analogous to a Java method), a set of
parameters (Java arguments), and an optional request context (no Java equivalent).
</P>

<P>In the CORBA model, a strong distinction is made between
interfaces and implementations. An object's interface lists the operations it can perform and its
attributes (the equivalent of Java's fields). Confusingly, the code that implements the operation is
termed a method. There is no notion of private or protected operations in an interface.
Interfaces may be composed using multiple inheritance as in Java.
</P>

<P>Each operation is characterized by a signature, consisting of its
identifier (name), the names and types of its parameters, a returned
result, and exceptions it can throw (like exceptions in Java). Parameters have
modes, which specify whether they are used for input, output, or both.
</P>

<P>Attributes may be read/write or read-only. They are logically equivalent to a pair of
Get() and Set() operations (or just a Get() operation in the case of read-only attributes).
</P>

<P>Not everything is an object, however. As in Java, there are
basic types, such as Booleans and integers, and constructed
types, such as sequences and arrays. Also, the
CORBA
</P>


<A NAME="PAGENUM-485"><P>Page 485</P></A>



<P>documentation often mentions pseudo-objects. These are not full objects, but are
a convenient way of representing composite data such as one might find in a request to
an object. In fact, the Object Request Broker (ORB) itself is considered a pseudo object.
</P>
<B>
Object References
</B>


<P>CORBA Objects are manipulated using Object references, whereas Java objects are
passed by value. This was a conscious design decision by the Java designers, as referencing
and dereferencing (implemented with pointers in C, Java's ancestor) were seen to be hard
to learn and one of the biggest sources of programming errors. Although there are
references in Java, they are hidden from the programmer. This is perhaps the most
fundamental difference between the Java Object Model and the CORBA one, as will become
apparent when the proposed Java language binding is discussed later.
</P>

<P>An Object Reference is created when an object is created and may be used to identify
an object for the purpose of requesting services during its lifetime. Object references
themselves are not portable across ORBs, which are at liberty to implement them in the
most convenient manner for the language/environment in which they will be used. Instead,
they may be stringized&#151;converted to a string and made persistent. The stringized
representation may be transmitted to other ORBs, then reconstituted into an Object Reference
which is valid for that ORB.
</P>

<H4><A NAME="ch12_ 26">
Object Request Brokers (ORBs)
</A></H4>

<P>The Common Object Request Broker Architecture is, as its name states, an architecture.
It has a number of components that act together to enable objects to communicate.
This collection is known as an Object Request Broker. ORBs may be implemented in a
number of ways, yet still remain fully CORBA-compliant because CORBA defines interfaces to
be provided rather than specifying implementation details. A flow chart of an ORB is
shown in figure 12.7.
</P>


<P><a href="images\ch12fg07.jpg"><img src="images\tn_ch12fg07.jpg"></a><BR>
Figure 12.7
Representation of an ORB.
</P>

<P><CENTER>
<a href="0480-0482.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0486-0488.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



