<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0489-0492.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0497-0499.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-493"><P>Page 493</P></A>



<P>Parameter lists also open a scope, so their names will not conflict with others. Items
that can have a scoped name follow:
</P>

<UL>
<LI>          Types
<LI>          Constants
<LI>          Enumeration values
<LI>          Exceptions
<LI>          Interfaces
<LI>          Attributes
<LI>          Operations
</UL>

<P>Names are case insensitive. For example Fox and FOX are considered the same name,
so cannot be used by different items in the same scope. However, references to a name
must use the same case as the definition.
</P>

<P>All names defined by CORBA are treated as if they appear in the module CORBA,
thus their scoped name is preceded by &quot;CORBA::&quot;.
</P>

<B>
Interfaces and Inheritance
</B>

<P>IDL interfaces are very similar to their Java counterparts. As with Java, they can
inherit from other interfaces. The terminology used by the OMG follows the C++ path:
Rather than super and sub classes, the terms are base and derived. Thus the interface from
which another interface is derived is called its base interface.
</P>

<P>IDL interfaces support multiple inheritance, though with slightly different semantics
than the Java interfaces. When discussing multiple inheritance, a diamond-shaped graph
is often used. Figure 12.9 shows four interfaces, A, B, C, and D, with the links between
them signifying inheritance.
</P>

<P>In IDL, this arrangement would be specified as follows:
</P>
<PRE>
interface A        {...}
interface B : A    {...}
interface C : A    {...}
interface D : B, C {...}
</PRE>

<P>The derived class is separated from its base class (or classes) by a single colon,
whereas multiple base classes are separated by commas.
</P>

<A NAME="PAGENUM-494"><P>Page 494</P></A>



<P><a href="images\ch12fg09.jpg"><img src="images\tn_ch12fg09.jpg"></a><BR>
Figure 12.9
The diamond-shaped representation of multiple inheritance.
</P>

<P>A is the base interface: It is a direct base of B and C, and it is an indirect base interface
of D. In OMG IDL it is illegal to inherit from two interfaces that have the same name for
an operation or attribute. It is also illegal to redefine operations or attributes in
derived interfaces. However, it is legal to redefine constants, types, and exceptions. Where there
is a conflict, the scoped name is used to eliminate ambiguity.
</P>

<P>In contrast, Java enables B and C to have methods (operations) with the same name. If
the signatures differ, then they are considered to be two different methods (the name
is overloaded). If they have identical signatures, then they can have only one
implementation. The problem of conflicting attributes does not arise because Java does not
allow attributes to be specified in its interfaces.
</P>

<P>In IDL, operations must all have distinct names within a scope (not just distinct
signatures), as they are used at runtime. There is no provision for Java/C++ style overloading
of method names.
</P>

<B>
IDL Data Types
</B>

<P>Basic data types in IDL correspond to the primitive types in Java and have a single
value of fixed size. Most of the basic types are very similar to their Java counterparts, but a
few details are different. IDL also has a set of composite types called
constructed types, which hold many values.
</P>
<A NAME="PAGENUM-495"><P>Page 495</P></A>


<B>
Basic Types
</B>

<P>There is no &quot;int&quot; keyword in IDL to denote integers, but instead, the two sizes of
integers are denoted by &quot;short&quot; (a 16-bit value) and &quot;long&quot; (a 32 bit value). Like C, and
unlike Java, IDL has the notion of signedness and unsignedness.
Unsigned values may take only positive values, that makes them useful for array indexes and the like, but liabilities
when it comes to arithmetic operations. The only advantage to unsigned values is that they
can represent numbers that are twice as large. Both shorts and longs in IDL can be
made unsigned by preceding them with the &quot;unsigned&quot; keyword.
</P>

<P>Floating point numbers in IDL (float, double) are the same as their Java namesakes,
as defined by the IEEE 754-1985 specification.
</P>

<P>Booleans are similar in IDL, with uppercased keywords used for &quot;TRUE&quot; and
&quot;FALSE&quot; values.
</P>

<P>Characters, denoted by the &quot;char&quot; keyword in IDL, are 8-bit quantities, in contrast to
the 16 bits used by Java. Thus they do not support Unicode. The value of characters may
be modified during transmission as long as their meaning stays the same, such as
when international character sets are used to replace the base ISO Latin-1 8859.1 character set.
</P>

<P>Octets, denoted by the &quot;octet&quot; keyword, are simply 8-bit values, and their contents
are guaranteed not to change during transmission.
</P>

<P>One type introduced by IDL is not so much a type, but it acts as a placeholder for a
type. Denoted by the &quot;any&quot; keyword, it can refer to any IDL defined type.
</P>

<P>Enumerations are ordered lists of identifiers, introduced by the &quot;enum&quot; keyword.
Their purpose is to act as named constants. Enumerations are part of C and C++ but not Java.
</P>

<B>
Constructed Types
</B>


<P>Structures are records, introduced by the keyword &quot;struct&quot;; they are structured collections
of fields without any associated behavior. In other words, they are classes without methods.
</P>

<P>Unions are variant records denoted by the &quot;union&quot; keyword. They are a name for
a collection of superimposed structure types. If a union is declared as type A or type B,
then the union could at any time hold data corresponding to type A OR to type B, but not
both at the same time. Unions in IDL are discriminated
unions, which means that they must contain a field that determines which of the possible structures they actually represent.
 Syntax here is similar to a Java switch statement, with the &quot;switch&quot; keyword
determining the discriminator, and a number of &quot;case&quot; keywords separating the possible
structure definitions.
</P>

<A NAME="PAGENUM-496"><P>Page 496</P></A>


<B>
Template Types
</B>

<P>A sequence is a one-dimensional array of objects with a size often fixed at compile
time and a length determined at run-time. Syntax is similar to the C++ approach to
declaring templates, using left and right angle brackets to enclose the type argument.
</P>

<PRE>
// a sequence of 32 bit values, maximum 10 values
sequence&lt;long,10&gt;
// a sequence of 32 bit values
sequence&lt;long&gt;
</PRE>

<P>Mapping this to a real language, the size determines the size of a buffer able to hold
items of this type. The length determines how many items are actually held in the sequence;
and thus in a call, how many of the items were to be transferred. Sequences can be nested as
in the following snippet.
</P>

<PRE>
sequence&lt;sequence&lt;long&gt; &gt;
</PRE>

<P>Strings are a special case of sequences: They are sequences of type char, but are
acknowledged as a separate type because many languages, including Java, have good support
built in to handle character strings. All 8-bit characters are allowed, except null.
</P>

<P>IDL supports multidimensional, fixed size arrays. When arrays are passed to a call,
the whole array is passed.
</P>

<B>
Exceptions
</B>

<P>Exceptions serve a similar purpose in both Java and IDL. In IDL they are not objects,
but separate types that can be declared to have structured data members. They are
introduced with the &quot;exception&quot; keyword.
</P>

<B>
Attributes
</B>

<P>The equivalent of Java's fields are IDL's attributes. However, Java does not permit fields
to appear in interfaces. In fact, exposing data members is a practice often frowned upon
by the object-oriented community, largely because it implies a dependency on a
certain implementation, and also because it is hard to ensure that the attribute is updated in
a controlled way.
</P>

<P>The confusion arises because in languages such as Java and C++, the implementation
and interfaces are specified in the same language. For example, consider the following:
</P>

<PRE>
attribute short length;
</PRE>

<P><CENTER>
<a href="0489-0492.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0497-0499.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



