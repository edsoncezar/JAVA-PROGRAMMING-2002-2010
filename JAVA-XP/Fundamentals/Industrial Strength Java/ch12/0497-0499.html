<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Distributed Computing with Java:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0493-0496.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0500-0502.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-497"><P>Page 497</P></A>



<P>In a single language this implies that length is implemented as a short integer,
which restricts derived interfaces. With IDL, an attribute definition is almost always mapped
into the implementation language as a pair of methods or operations, one to get the value
and another to set it; using the attribute keyword is considered a shorthand representation
for this pair of methods. IDL also allows you to specify that attributes cannot be set
explicitly, by specifying the &quot;readonly&quot; keyword:
</P>

<PRE>
readonly attribute short length;
</PRE>

<P>In this case, only the get() method is defined for this attribute in the
implementation language.
</P>

<B>
Operations
</B>

<P>Operations encapsulate the behavior of objects and are probably the most complex
items to declare. This complexity is especially true because they must also specify the
additional semantics that arise from being distributed. Two examples of operations are
</P>

<PRE>
string Fooey( in long inVal, out long outVal) raises (FooEx);
</PRE>

<P>and
</P>

<PRE>
oneway void Foo( in string Thingy);
</PRE>

<P>The syntax is similar to a Java method call with a few additions. Not only are the
names and types of parameters specified, but also their semantics (modes), using one of
the keywords &quot;in,&quot; &quot;out,&quot; or &quot;inout.&quot; These are used to specify which direction the
parameter is passed, as described in the following list
</P>

<UL>
<LI>          in. Parameter passes from client to server
<LI>          out. Parameter passes from server to client
<LI>          inout. Parameter passes in both directions
</UL>

<P>The exceptions which may occur as a result of performing the operation are specified as
a comma delimited list after the &quot;raises&quot; keyword.
</P>

<P>The &quot;oneway&quot; keyword specifies the semantics of the whole operation. It is optional
and its use implies best-effort semantics. In other words, there is no guarantee of
delivery. Otherwise, operations use at-most-once semantics. No exceptions are defined for
oneway operations, although they might raise standard exceptions.
</P>

<A NAME="PAGENUM-498"><P>Page 498</P></A>



<B>
The Pros and Cons of IDL
</B>

<P>The preceding sections covered most of what you'll need to know in order to read
IDL interface definitions. The syntax is quite similar to both Java and C, so any culture
shock should be minimal.
</P>

<P>Being designed specifically for interface definition has allowed IDL to remain simple
yet powerful enough to represent object interface semantics, even in a fully
distributed system.
</P>

<P>Describing interfaces in IDL ensures that they are &quot;clean&quot; and not reliant on a
particular implementation. From an IDL specification, all the language-specific code can be
generated by tools (except of course for the implementation!). Clients of objects with
IDL interfaces can be coded in any supported language, as can the implementations.
Furthermore, objects can take advantage of the wealth of functionality provided by CORBA
and the CORBAservices.
</P>

<P>Of course, having a separate language does increase the complexity of a
development environment somewhat. It's another language with which developers must
become familiar, and extra steps are required for the conversion between IDL and Java
sources. However, these are relatively minor disadvantages in the case of larger
development projects, where they will be greatly outweighed by the flexibility gained.
</P>

<H4><A NAME="ch12_ 28">
The JAVA IDL System and Tools
</A></H4>

<P>At the time of writing, Sun's support for Java IDL was at a fairly early stage of
development, and the toolkit was designated as an alpha release. Supplied as part of the
package were an IDL compiler, a portable ORB core, and a copy of the proposed mapping
between IDL and Java (along with a few samples and a little documentation).
</P>

<P>Objects to be accessed remotely supply their interfaces as IDL definitions. The
compiler, &quot;idlgen,&quot; compiles these IDL interfaces into Java client stubs and server skeletons.
Java applets and applications then use the stubs to call methods on the remote objects.
The stubs call the portable ORB core, which communicates with the remote ORB via
an available protocol.
</P>

<P>The alpha toolkit release did not support the standard IIOP protocol, but instead used
a lightweight proprietary protocol called the &quot;Door ORB&quot; protocol to communicate
with other Java based servers. IIOP is scheduled for delivery when Java IDL is
officially released. Also to be delivered is a module to connect Java IDL directly to SunSoft's
NEO range of CORBA products.
</P>
<A NAME="PAGENUM-499"><P>Page 499</P></A>



<H4><A NAME="ch12_ 29">
The Rear Mirror View
</A></H4>

<P>Hopefully, the preceding sections gave you a fair overview of the two main approaches
to distributed object support for Java. It is not entirely clear why Sun/JavaSoft have
provided two solutions to the same problem. Although it is true that RMI and Java IDL are aimed
at different market sectors, it seems that Sun is suffering from the same ailment that
plagues many other large fragmented corporations, such as IBM. Different divisions, each
required to be a &quot;profit center,&quot; have to look after their own interests ahead of those of other
groups within the company.
</P>

<P>Sun has been a long-time supporter of the OMG, with an existing range of
CORBA-based products. However, the Java developers were not closely allied with the CORBA
groups and, buoyed by the burgeoning success of Java technologies, obviously felt they
could provide a more elegant solution by making it Java specific. It's certainly true that
Java developers greatly outnumber their CORBA-experienced counterparts. It's also true
that RMI is an elegant solution, unhindered by any approval process by an external
body. However, CORBA has many undeniable advantages, and by focusing resources on
one approach, Sun could have provided a CORBA-based solution with most of the
advantages of RMI. Providing an ORB as part of the Java VM is just one possibility.
</P>

<P>There is no clear division between the RMI and CORBA approaches, with
considerable overlap in their areas of potential application. It seems that RMI is perhaps best suited
to smaller scale &quot;personal&quot; applications, especially those that use the Internet to some
extent. CORBA is probably better suited to heterogeneous corporate intranet environments,
where its capability to integrate with other languages and legacy systems is important.
</P>

<B>
Java in a Corporate Setting
</B>

<P>Java IDL-based CORBA solutions will be of most interest to corporate
developers building so-called mission critical, enterprise applications. The term &quot;middleware&quot;
is common in these environments, where it applies to software &quot;glue,&quot; such as CORBA
and DCE. To date, most CORBA products have been sold into corporate environments,
where multithousand dollar price tags and &quot;per seat&quot; run-time licenses are common.
</P>

<P>The forces that act to form the corporate computing environment are quite different
from those experienced in small offices and the home environment. A small saving in
hardware costs becomes significant when applied to thousands of user workstations. Even
relatively simple operations, such as installing software updates, become a major issue with
large numbers of machines.
</P>


<P><CENTER>
<a href="0493-0496.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0500-0502.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



