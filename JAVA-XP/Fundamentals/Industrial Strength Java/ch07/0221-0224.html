<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0217-0220.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0225-0228.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-221"><P>Page 221</P></A>







<P>service on a first-come-first-served basis, it sends the printer the

document that is at the top of its list. The queue will then &quot;bump-up&quot; each document in the queue. 

</P>



<P>For some reason the Java development team decided to not include support for queues

in the java.util package. They did, however, provide the java.util.Vector class, which you

can subclass to create a Queue class.

</P>



<H4><A NAME="ch07_ 15">

Required Methods for the Queue Class

</A></H4>



<P>The methods that Queue needs to support are very similar to

those required of Stack. They are:

</P>



<UL>

<LI>          put() adds an object to the end of the queue

<LI>          get() removes the top object on the queue and returns it to the

               user.

<LI>          peek() &quot;peeks&quot; at the top Object and returns it without

               removing it from the queue.

<LI>          empty() returns a Boolean true if the queue is empty and a

               Boolean false if there are items in the queue.

</UL>



<P>As stated at the beginning of this section, the Queue class

extends java.util.Vector and will subsequently be able to access all

of Vector's methods. In fact, because the support for Queue's

methods basically exists (under different names) in Vector, no method

in Queue will be more than three lines long! Table 7.2 provides a

side-by-side comparison of the method that Queue needs to support, and the methods in

Vector that offers that support. After you look over table 7.2, look at listing 7.11 where the

Queue is actually implemented.

</P>



<P>Table 7.2<BR>

The Methods in Vector that Help Implement Queue

</P>





<TABLE>



<TR><TD>

</TD><TD>

Method Needed

in Queue

</TD><TD>

Method Supported 

by Vector

</TD></TR><TR><TD>

Name

</TD><TD>

get()

</TD><TD>

removeElementAt(int index)

</TD></TR><TR><TD>

Purpose

</TD><TD>

Returns the top element

in the Queue. Also deletes

that element from the

Queue

</TD><TD>

Removes the element at the 

specified index. You will use

it to remove the 0th (or

top) element.

</TD></TR><TR><TD>

Name

</TD><TD>

put(Object obj)

</TD><TD>

addElement(Object obj)

addElement

</TD></TR></TABLE>




<PRE>
continues
</PRE>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Remember that stacks and queues do basic-     ally the same

thing, only in the reverse order. If you check the declaration

of java.util.Stack, you will note that this class extends

Vector. Logically, you can conclude that it would be rather easy to

write a queue class that extends Vector also.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-222"><P>Page 222</P></A>









<P>Table 7.2 <BR>

Continued

</P>





<TABLE>



<TR><TD>

</TD><TD>

Method Needed

in Queue

</TD><TD>

Method Supported

by Vector

</TD></TR><TR><TD>

Purpose

</TD><TD>

Adds a new object

onto the Queue

</TD><TD>

Adds a new Object as the

last item of the Vector

</TD></TR><TR><TD>

Name

</TD><TD>

peek()

</TD><TD>

firstElement()

</TD></TR><TR><TD>

Purpose

</TD><TD>

Returns the top element

without removing

it from the Queue.

</TD><TD>

Removes the top

element without removing it from the

Vector.

</TD></TR><TR><TD>

Name

</TD><TD>

empty()

</TD><TD>

isEmpty()

</TD></TR><TR><TD>

Purpose

</TD><TD>

Returns a Boolean true

if the Queue is empty.

Otherwise, returns a

Boolean false.

</TD><TD>

Returns a Boolean true if the 

Vector is empty. Otherwise,

returns a Boolean false.

</TD></TR></TABLE>



<P>Now that we know how we are going to write the Queue class, let's go forward and

code it. The class in listing 7.11 may just be the shortest

Queue you have ever implemented.

</P>



<P>Listing 7.11 Implementing a Queue in Java

</P>




<PRE>

package industrial;

import java.util.*;



public class Queue extends java.util.Vector {

     //get() returns the top object on the queue

     public Object get() {

          Object tempObject = super.firstElement();

          super.removeElementAt(0);

          return tempObject;

     }



     //pus() adds a new element to the bottom of the queue

     public void put(Object obj) {

          super.addElement(obj);

     }



     //peek() returns the top element on the queue

     public Object peek() {

          return super.firstElement();

     }



     //empty() allows us to check if the queue contains no elements.

     public boolean empty() {

</PRE>




<A NAME="PAGENUM-223"><P>Page 223</P></A>






<PRE>

          return super.isEmpty();

     }

}

</PRE>




<H3><A NAME="ch07_ 16">

Furthering the java.util Advantage

</A></H3>



<P>The fact that you are able to implement a Queue class in about ten lines of code is

a compelling reason to take advantage of jave.util. An added bonus is that not only can

you create the Queue based on the Vector class, but you can also create a large variety of

linear growable data-structures.

</P>



<H4><A NAME="ch07_ 17">

Double-Ended Linked Lists

</A></H4>



<P>If a queue and a stack ever got together and became one, you would have a

double-ended linked list. Where queues and stacks limit the &quot;end&quot; at which insertion and deletion

can occur, double-ended linked lists enable you to insert and delete an element at either end.

</P>



<P>As with any data structure, the big question is: What am I ever going to use this for? It

is cool to be able to lean back at a cocktail party and strike up a conversation on the

benefits of double-ended versus single-ended linked lists, but will this get you anything beyond

a date? Humor aside, a data structure is useless if you do not have concrete knowledge

of how it can benefit a solution that you need to put into place.

</P>



<B>

An Overview of a Semi-Sorted Linked List

</B>



<P>Although your use of double-ended linked lists is limited only by your imagination,

one common use is to keep a growing data set in some order so that your worst-case

search time is less than the number of elements in the list. For example, imagine a system

where you are rapidly collecting data and do not have the resources to sort this information

on the fly. Assuming random distribution of data, a solution for keeping tabs on the

data would be to insert larger elements at the end of the list and smaller elements at

the beginning of the list.

</P>



<P>Because the terms &quot;larger&quot; and &quot;smaller&quot; are completely relative, it is important to

decide what they will be relative to. As previously stated, incoming data is assumed to be

totally random, so it is logical to assume that any element can be picked as a point against

which all other elements are compared.

</P>





<A NAME="PAGENUM-224"><P>Page 224</P></A>







<P>Now that you have an understanding of the manner in which the semi-sorted link

list operates, it is important to discuss specifically how this operation is implemented.

You must first determine what the linked list needs to do to stay sorted, and then you

must learn how to create a double-ended linked list from the Vector class. <BR>

Furthering the java.util Advantage

</P>









<P>The final project involves two classes:

</P>



<UL>

<LI>          DoubleEndedLinkedList, which subclasses Vector

<LI>          SortedDoubleEndedLinkedList, which subclasses DoubleEndedLinkedList

</UL>



<P>To stay sorted, the linked list first picks a point to which all

greater than or less than comparisons are made. Based on the

previous assertion that random data allows us to pick any element as a

reference, it is a safe bet to pick the first element as the reference point.

As new elements enter the list, all elements larger than the reference

point are added to the end of the list. Conversely, all elements less than

the reference point are added to the beginning of the list.

</P>



<P>Knowing that the first element is less than the last element and

that all elements in between are in some sort of order has great

advantages when you are searching through that data later. By knowing at

which end to begin searching, you are able to have an average search

time of approximately the number of elements in the list divided by two.

</P>



<P>Figure 7.5 represents the SortedDoubleEndedLinkedList class. All the class methods <BR>

are somewhat obvious in nature; because this class subclasses

DoubleEndedLinkedList, however, it is not yet prudent to discuss how each method is implemented. Instead,

you 

</P>



<P><a href="images\ch07fg05.jpg"><img src="images\tn_ch07fg05.jpg"></a><BR>

Figure 7.5

An object diagram for SortedDouble EndedLinkedList.

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The method for keeping data sorted has the potential

for failing if incoming data is already sorted. At the close of this

chap-     ter, a test of your own skills would be

to write a more intelligent sorting method.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<P><CENTER>

<a href="0217-0220.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0225-0228.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







