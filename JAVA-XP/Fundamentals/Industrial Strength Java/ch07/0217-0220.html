<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0213-0216.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0221-0224.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-217"><P>Page 217</P></A>


<P>In listing 7.10b you complete the class begun in 7.10a by implementing hashCode()
and equals() methods.
</P>

<P>Listing 7.10b The hashCode() and equals() Methods
</P>
<PRE>
     public int hashCode() {
          return Integer.parseInt(this.getPhoneNumber().substring(9,
                     &Acirc;12));
     }

     public boolean equals(Object obj) {
          ContactBookEntry tempEntry = (ContactBookEntry)obj;
          boolean phoneBool =
                      &Acirc;this.getPhoneNumber().equals(tempEntry.getPhoneNumber());
          boolean fnameBool =
                      &Acirc;this.getFname().equals(tempEntry.getFname());
          boolean lnameBool =
                      &Acirc;this.getLname().equals(tempEntry.getLname());
          return ((phoneBool == fnameBool) == lnameBool);
     }
}
</PRE>

<P>In listing 7.10c is a small driver that creates a new hash table and adds to it a series
of ContactBookEntry objects. After a few objects have been added to the hash table, you
can play around with some of the other methods in java.util.Hashtable that allow you to
access the data stored in the table.
</P>

<P>Lisitng 7.10c Using a Driver to Create a New Hash Table
</P>

<PRE>
public class HashDemo {
     public     final          int          MAXCONTACTS = 10;
     public     Hashtable                theTable;
     public     ContactBookEntry     myContactBook[];

     public HashDemo() {
          theTable =      new Hashtable();
          myContactBook =  new ContactBookEntry[ MAXCONTACTS ];
          myContactBook[0] = new ContactBookEntry();
          myContactBook[0].setFname(&quot;Luke&quot;);
          myContactBook[0].setLname(&quot;Cassady-Dorion&quot;);
          myContactBook[0].setPhoneNumber(&quot;265-487-2201&quot;);

</PRE>
<PRE>
												continues
</PRE>

<A NAME="PAGENUM-218"><P>Page 218</P></A>



<P>Listing 7.10c Continued
</P>
<PRE>
          myContactBook[1] = new ContactBookEntry();
          myContactBook[1].setFname(&quot;Matt&quot;);
          myContactBook[1].setLname(&quot;Degen&quot;);
          myContactBook[1].setPhoneNumber(&quot;265-888-1234&quot;);
          myContactBook[2] = new ContactBookEntry();
          myContactBook[2].setFname(&quot;Gabe&quot;);
          myContactBook[2].setLname(&quot;Lavella&quot;);
          myContactBook[2].setPhoneNumber(&quot;265-367-4297&quot;);

          myContactBook[3] = new ContactBookEntry();
          myContactBook[3].setFname(&quot;Allison&quot;);
          myContactBook[3].setLname(&quot;DeYenno&quot;);
          myContactBook[3].setPhoneNumber(&quot;265-571-4498&quot;);

          for(int i=0; i&lt;=2; i++) {
               theTable.put(myContactBook[i], myContactBook[i]);
          }

          System.out.println(&quot;Hash Table: Full&quot;);

          if(theTable.containsKey(myContactBook[2])) {
               System.out.println(&quot;Hash Table: Contains
                                &Acirc;myContactBook[2]&quot;);
          }
          else {
               System.out.println(&quot;Hash Table: Does not contain
                                &Acirc;myContactBook[2]&quot;);
          }

          if(theTable.contains(myContactBook[3])) {
               System.out.println(&quot;Hash Table: Contains
                                &Acirc;myContactBook[3]&quot;);
          }
          else {
               System.out.println(&quot;Hash Table: Does not contain
                                 &Acirc;myContacBook[3]&quot;);
          }
     }

     public static void main(String args[]) {
          HashDemo myDemo = new HashDemo();
     }
}
</PRE>

<A NAME="PAGENUM-219"><P>Page 219</P></A>



<P>Although the application in 7.10c proves that the hashtable is actually working, figure
7.4 demonstrates what the hash table would look like after the various contacts have
been inserted. Note that because hashCode() returns an int, the range of the hash values is
the full range of int. Due to space (and logical) constraints, only the relevant range of
values that hashCode could return is displayed.
</P>



<P><a href="images\ch07fg04.jpg"><img src="images\tn_ch07fg04.jpg"></a><BR>
Figure 7.4
This is how the hash table would look after the
various contacts have been inserted.
</P>

<H4><A NAME="ch07_ 13">
Miscellaneous Hashtable Methods
</A></H4>

<P>So far, inserting and searching through a hashtable has been
covered. There are additional methods in the Hashtable class that you
will find useful. The additional methods present in the class were
not discussed because the methods are described relatively well by
their signatures. The constructors, however, definitely deserve
discussion. The first constructor, (Hashtable()), takes no parameters and
creates a default hash table. The first constructor was used in listing
7.10a because it is sufficient for small data sets. As your data set
grows, however, you will want to use the other two constructors
because they enable you to fine tune the performance of the hash table.
</P>

<P>As with any growable data structure, speed is sacrificed every
time that the data structure grows. For this reason you will want to
control both the initial size of the data structure and the rate at which
it grows. The second constructor, (Hashtable(int initialCapacity)), in listing 7.8 enables
you to pass in an initial capacity. If you know, for example, that your hash table is going
to have to hold 100,000 elements, then you should use this constructor because your
hash table will not have to grow while the 100,000 elements are being added. <BR>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Throughout this book, the term growable data
structure is used alternately with the term
dynamic data structure. Both represent the same concept, that of a
data structure able to hold an infinite amount of data.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-220"><P>Page 220</P></A>


<P>The third constructor (Hashtable(int initialCapacity,
float loadFactor)) supported by Hashtable enables you to control the
time at which rehashing occurs. This constructor enables you to pass
in two values, the initial size, and a number called
loadFactor. loadFactor&#151;which has a default setting of 0.75&#151;is the number
that affects the point at which a hash table resizes. You will want to
set this number somewhere between 0.0 and 1.0. The hash table
resizes whenever the number of items in the table increases to the
current capacity multiplied by the load factor. The amount that the
hash table resizes is not controllable by the programmer. It will
be somewhere around twice the size when resizing occurs, but could
be more or less.
</P>

<H3><A NAME="ch07_ 14">
Implementing a Queue Using Classes from java.util
</A></H3>

<P>Although java.util presents many useful data structures, this
chapter began by stating that these data structures are rarely enough for
a complete application. Chapter 8 details how to create your
own growable data structures without the need to use any parts of
the java.util package. Although java.util does not provide many
data structures in their final form, it does provide a series of
rather generic growable data structures that can be manipulated to
enable the creation of more developed data structures. One such
generic data structure is the Vector class. The next few pages contain
infor-     mation that demonstrates how the Vector class can be used to
form other data structures.
</P>

<P>In introductory data structure classes, around the same time
that stacks are introduced, queues are also introduced. Basically
the opposite of a stack, a queue enables manipulation
of objects in a First-In-First-Out manner. For example, a printer queue manages
an infinite number of incoming documents. As each document hits
the printer queue, it is appended to the bottom of an ever growing list. As the printer
finishes printing a document, it asks the printer queue for a new document to print. Because
the queue provides 
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The reason that the resizing is so gray is because a size that <BR>
is a prime number is most efficient. Thus, the VM attempts
to find a capacity that is a prime number.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
When a hash table grows, every element currently in the
table has to be rehashed. You will want to minimize the
number of times that rehashing occurs because rehashing is
extremely costly. In fact, it is a rare occurrence
when you would want to rehash beyond the initial hashing.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<P><CENTER>
<a href="0213-0216.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0221-0224.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



