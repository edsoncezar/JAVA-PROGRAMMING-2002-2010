<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0201-0204.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0209-0212.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-205"><P>Page 205</P></A>





<P>that you may need to use in an application of your own. As a side note, this section
shows not only how to implement an instance of java.util.Stack (which is designed to
handle objects only), but also how to manipulate Stack to work with base types also.
</P>

<B>
Programming with Types
</B>

<P>It is a well-known fact that with few exceptions, everything in Java is an object. As a
direct result , many classes in the java.util package are designed to operate on Objects. This
can be very useful because it provides for incredible flexibility for the developer; there
are situations, however, where it is desirable to program with types instead of with objects.
In order to facilitate the usage of types in an environment where objects are expected,
Java provides wrapper classes that engulf base types to enable the manipulation of types
as objects.
</P>

<P>Table 7.1 shows all Java base types along with their associated wrapper classes. Of
course, before you can begin to work with wrapper classes, you need to understand how to
convert from a type to a wrapper class and vice-versa. The third column of table 7.1 shows how
to use a wrapper class's constructor to convert a base type into an object. The fourth
column gives the method supported by the wrapper class for conversion back to its associated
base type.
</P>

<P>Table 7.1
</P>

<P>Wrapper Classes and Their Associated Base Types
</P>

<TABLE>

<TR><TD>
Base
Type
</TD><TD>
Wrapper
Class
</TD><TD>
Type&AElig;
Object
</TD><TD>
Object&AElig;     
Type
</TD></TR><TR><TD>
int     
</TD><TD>
java.lang.Integer
</TD><TD>
Integer newInteger =
</TD><TD>
newInteger.intValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
new Integer(42)
</TD><TD>
</TD></TR><TR><TD>
Boolean
</TD><TD>
java.lang.Boolean
</TD><TD>
Boolean myBoolean =
</TD><TD>
myBoolean.BooleanValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
new Boolean(true)
</TD><TD>
</TD></TR><TR><TD>
char
</TD><TD>
java.lang.Character
</TD><TD>
Character myCharacter =
</TD><TD>
myCharacter.charValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
new Character(`a')
</TD><TD>
</TD></TR><TR><TD>
float
</TD><TD>
java.lang.Float
</TD><TD>
Float myFloat =
</TD><TD>
myFloat.floatValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
new Float(3.0)
</TD><TD>
</TD></TR><TR><TD>
double
</TD><TD>
java.lang.Double
</TD><TD>
Double myDouble =
</TD><TD>
myDouble.doubleValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
new Double(7.0)
</TD><TD>
</TD></TR><TR><TD>
long
</TD><TD>
java.lang.Long
</TD><TD>
Long myLong
</TD><TD>
myLong.longValue()
</TD></TR><TR><TD>
</TD><TD>
</TD><TD>
= new Long(42)
</TD><TD>
</TD></TR></TABLE>

<A NAME="PAGENUM-206"><P>Page 206</P></A>


<P>As you can see, converting between a base type and a wrapper class is beyond
easy. Listing 7.6 uses the wrapper classes as well as the concept of inheritance to create a
class called IntStack that subclasses java.util.Stack to provide a Stack class that enables you
to manipulate ints in an environment traditionally dominated by Objects. To accomplish
this, do the following:
</P>

<OL>
<LI>          Create a class called IntStack that subclasses java.util.Stack.
<LI>     Add a method called Push() that is used to push ints onto the stack.
<LI>     In Push(), accept an int as a parameter, translate it to an Integer object, and pass
it to IntStack's parent.
<LI>     Create methods called Peek() and Pop(). These methods will return&#151;as an
int&#151;the top object on the stack.
<LI>     In Peek() and Pop(), call the respective method in IntStack's parent. Take
the Object return value from this method, first convert it to an Integer, then to an
int, and finally return it.
</OL>

<P>Listings 7.6a and 7.6b show the IntStack class and a driver that demonstrates the
functionality of the class.
</P>

<P>In listing 7.6a you create the IntStack class. The conversion between objects and
base types is rather obvious. If you have any trouble, refer to table 7.1.
</P>

<P>Listing 7.6a A Traditional Stack Data Structure that Can Be Used to <BR>
                  Manipulate ints
</P>
<PRE>
package industrial;
import java.util.*;
class IntStack extends java.util.Stack {

     public int Peek() {
          return ((Integer)super.peek()).intValue();
     }

     public int Pop() {
          return ((Integer)super.pop()).intValue();
     }

     public Object Push(int i) {
          return super.push(new Integer(i));
     }
</PRE>


<A NAME="PAGENUM-207"><P>Page 207</P></A>



<PRE>
     public int Search(int i) {
          return super.search(new Integer(i));
     }
}
</PRE>

<P>Listing 7.6b uses the IntStack class in a simple application. First some ints are
pushed onto the stack, then you search for one specific int, and finally you remove everything
on the stack.
</P>

<P> Listing 7.6b A Driver to Demonstrate the Functionality of the IntStack Class
</P>

<PRE>
public class StackDemo {
     IntStack myStack;

     public StackDemo() {
          myStack = new IntStack();
          int tempInt;

          //Push 100 integers onto the stack
          for(int i=0; i&lt;100; i++) {
               myStack.Push(i);
          }

          //Find the index of 42
          tempInt = myStack.Search(42);

          //Pop off all integers
          while(!myStack.empty()) {
               tempInt = myStack.Pop();
          }
     }

     public static void main(String args[]) {
          StackDemo myStackDemo = new StackDemo();
          System.out.println(&quot;Done&quot;);
     }
}
</PRE>

<H4><A NAME="ch07_ 8">
Real-World Stack Applications
</A></H4>

<P>It is easy to say that stacks are cool, but that is not a convincing argument for using
them. Why bother with dynamically sized, sequentially assessable data structures when
arrays
</P>

<A NAME="PAGENUM-208"><P>Page 208</P></A>


<P>are so much easier and faster to manipulate? It is not hard to find people willing to
argue either side of the dynamically sized versus statically sized data structure controversy.
</P>
<P>On one side of the coin, you will find proponents of static data structures. These types
of data structures are easy to maintain and are very predictable. When space limitations
are hardcoded into a class, however, that class often becomes one of a very single
purpose. One of the joys of Object Oriented Programming is code reuse. If you develop a class
that can manage an infinite data set that class will be usable
</P>

<P>Being able to write a class that treats data sets of all sizes in the same manner is
rather fantastic. Just think of how annoying it would be to have some useful code break if it
had to deal with a data set larger than some fixed quantity.
</P>

<P>The application in listing 7.7, which evaluates a
post-fix expression, demonstrates how a Stack enables you to write code that deals with any amount of data. Post-fix notation
is useful for representing a mathematical expression in an environment where rules
of precedence are not required. To convert from infix to postfix, you basically shove
all operands to the left of the equation, and all operators to the right. Then, when
evaluating the expression, you scan the input until an operator is reached and applies that operator
to the two previous operands.
</P>

<P>As an example, take the expression 3 + 4 in infix, which translates to 3 4 + in postfix.
To evaluate this expression by using a stack, you would push the operands 3 and 4 on
the stack. After you reached the operator +, you would pop off the 3 and 4 and apply
the operator and push the result back onto the stack. A slightly more complex example is
that the infix expression of ((3 + 2) - 5) * (6 / (1 - 9)) translates to 3 2 + 5 - 1 9 - 6 / *
in postfix. This expression can be evaluated by using the same formula used in the
previous example. First, 3 and 2 would be pushed onto the stack. When the first operator is
reached (+), the stack would be popped twice, and the result would be pushed back on. If
you follow through with this algorithm, pushing all operands on the stack and popping when
a operator is reached, you will end up with a final value of 0.
</P>

<P>Postfix expressions are incredibly easy to evaluate with a stack because you can scan
the expression left-to-right and, if the current token is an operand, push it onto the stack. If
the current token is an operator, you simply have to pop the top two tokens off the
stack, evaluate them using the current token, and push the result back onto the stack. After
you reach the end of the expression, you simply have to pop the stack to get the answer to
the expression. Listing 7.7 is the sample application that evaluates a post-fix
expression passed in as a command-line argument. Note that the application assumes the existence
of a method called eval, and also isOperand. eval(&quot;5,&quot; &quot;6,&quot; &quot;*&quot;) would return 30,
and isOperand(&quot;5&quot;) would return true.
</P>
<P><CENTER>
<a href="0201-0204.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0209-0212.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



