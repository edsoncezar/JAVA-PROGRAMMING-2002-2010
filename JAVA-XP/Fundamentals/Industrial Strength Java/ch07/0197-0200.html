<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="..\ch06\0194-0196.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0201-0204.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-197"><P>Page 197</P></A>


<H3><A NAME="ch07_ 1">
Chapter 7
</A></H3>

<H2>

Beginning Data <BR>
Structures: Taking <BR>
Advantage of java.util

</H2>

<P>In the broadest sense, the term data
structure applies to any means for storing and <BR>
retrieving data; it is a huge area studied in many university-level courses. This
chapter and Chapter 8, &quot;Advanced Data Structures,&quot; in no way attempt to teach how to build
every imaginable type of data structure, but teach you about developing data structures in
Java. These chapters focus on &quot;growable data structures&quot; as it is an area where developers
are often a bit unsure. Although most developers are familiar with the development
of growable data structures, this development has probably been in a language like C++
or Pascal where growable data structures are implemented with pointers. Java does not
use pointers, and building a dynamically sized data structure without pointers requires
a reorganization of your thought process.
</P>

<H3><A NAME="ch07_ 2">
Working in a Pointer-Free <BR>Enviroment
</A></H3>

<P>A common belief&#151;stemming from a heavy background in Pascal, C, or C++&#151;is that
to implement any sort of growable data structure, you must manipulate pointers. This
belief could not be further from the truth, as a look at the actual purpose of pointers
shows.
</P>


<A NAME="PAGENUM-198"><P>Page 198</P></A>


<P>Listing 7.1 illustrates an example of how you might insert a new node into a linked
list written in C.
</P>

<P>Listing 7.1 The C Function to Insert a New Value onto the End of a Linked List
</P>

<PRE>
/*     Function to insert an int &quot;toBeInserted&quot; at the end of a list
&Acirc;whose end is pointed to be *tailPtr. */
void insertAtEnd(struct list *tailPtr, int toBeInserted) {
       newPtr = (struct list *)malloc(sizeof(struct list));
       newPtr -&gt; info = toBeInserted;
       tailPtr -&gt; next = newPtr;
       newPtr -&gt; next = NULL;
}
</PRE>

<P>It is obvious in this code that pointers are totally necessary for the management of
the linked list. The real purpose served by pointers in listing 7.1 is not to allocate the
memory for the list dynamically, but rather to track dynamically allocated memory. The
follow-up statement is that the implementation of growable data structures requires only the
capability to dynamically allocate memory and to be able to track this memory. Java
provides these mechanisms without forcing a developer to deal with pointers.
</P>

<P>The realization that pointers are not at all necessary to implement growable data
structures comes as great news to anyone who has ever struggled with pointer manipulation.
What comes as even greater news is that Java takes care of most memory issues for
you; although garbage collection is by no means perfect, in rare cases you may want to
take care of garbage collection yourself.
</P>

<P>In addition to managing garbage collection and not requiring the use of pointers,
Java provides the &quot;java.util&quot; package that contains classes for many basic data structures.
This chapter focuses on the use of the java.util package. The focus of the next chapter shifts
to the development of your own data structures from scratch.
</P>

<H3><A NAME="ch07_ 3">
Introducing java.util
</A></H3>

<P>When beginning with a new language, you spend significant time building a library
of reusable code snippets. In the case of an object-oriented language like Java, a
flexible class library is critical to developing any application in a reasonable amount of time. <BR>
Many of these classes will not be a programming feat, but will still involve a large
time
</P>

<A NAME="PAGENUM-199"><P>Page 199</P></A>



<P>commitment. Fortunately, in the design of Java, the engineers at Sun have taken care
of many of these classes already. The java.util package implements a series of growable
data structures that you will find indispensable.
</P>

<P>Although you will no doubt find java.util indispensable, its usefulness is limited.
This limitation with the java.util package is that the coverage, although wide, is not very
deep. The data structures implemented are by no means advanced enough for large amounts
of information; they are all quite flexible, however, and it is easy to use them as
building blocks for larger data structures.
</P>

<H3><A NAME="ch07_ 4">
The Vector Class
</A></H3>

<P>The Vector class is basically a growable array. Where an array has a fixed
upperbound position, a Vector can grow indefinitely. The existence of this class is quite
exciting because any industrial strength application needs access to dynamic storage. By
making this dynamic storage part of the basic API, developers are saved time as they do not
have to implement it themselves.
</P>

<P>The Vector class, however, should not be taken for granted. As with C++ or
Pascal, growable data structures have significantly more overhead than those that are of fixed
size. The situation is basically a catch-22. You can use statically bounded arrays and
not dedicate any resources to allocation of additional memory; by doing so, however, you
are forced to work within predefined boundaries. Or you can allow for indefinite growth,
but deal with the overhead of on-the-fly memory allocation. The problem has been
pondered for years, and the Vector class does propose a &quot;happy medium&quot; that is quite elegant
when properly managed.
</P>

<P>Understanding memory allocation is integral to developing fast code using the
Vector class. This section begins by showing the various uses of the Vector class and
then continues with a discussion of why the code executes in the manner that it does.
</P>

<P>Listing 7.2 shows the Vector constructors as provided by the Java API. The first
constructor simply creates a Vector object with a default initial size. The second and third
constructors create Vector objects with different initial sizes. The third constructor, in addition
to affecting initial size, creates a Vector that grows by a user-defined factor.
</P>


<A NAME="PAGENUM-200"><P>Page 200</P></A>



<P>Listing 7.2 The Three Constructors Supported by the java.util.Vector Class
</P>

<PRE>
public Vector();
public Vector(int initialCapacity);
public Vector(int initialCapacity, int capacityIncrement);
</PRE>

<P>To see how the different constructors react to the steady insertion
of a series of Objects, consider a benchmarking application that
times the insertion of 100,000 Integer objects into first an empty
Vector, then into a Vector created to hold 100,000 Objects, and finally into
a Vector created to first hold 50,000 objects, but with
a capacityIncrement of 50,000.
</P>

<P>This benchmarking application is contained in listing 7.3a
through 7.3c and a test output is in listing 7.4.
</P>

<P>All variables are set up in listing 7.3a.
</P>

<P>Listing 7.3a Variables Used in the VectorBenchmarks Class
</P>

<PRE>
package industrial;
import java.util.*;

public class VectorBenchmarks {
     private     final          int          MAXELEMENTS = 100000;
     private     long           begin;
     private     long           end;
     private     Vector         slowVector;
     private     Vector         midVector;
     private     Vector         fastVector;
     private     Integer[]      integerArray;
     private     Integer        myInteger;
</PRE>

<P>The first part of the constructor for the VectorBenchmarks class is shown listing 7.3b.
Here the array and vectors are initialized, and you also create an integer object that will
be inserted into the objects. One final note on
thecapacityIncrement parameter in the Vector constructor (the third constructor in listing 7.2 uses this parameter) should be
mentioned. The variable causes the Vector to increase by capacityIncrement number of elements
every time the Vector is full. If you pass in a zero, however, the Vector doubles in size every
time it is full.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Depending on your choice of Java development platforms, your
actual results will vary. What you should note is
not the actual times, but rather the relationship between the times.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<P><CENTER>
<a href="..\ch06\0194-0196.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0201-0204.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



