<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0197-0200.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0205-0208.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-201"><P>Page 201</P></A>











<P>Listing 7.3b Initialization of Needed Variables

</P>




<PRE>

    public VectorBenchmarks() {

          //Integer object to be inserted

          myInteger = new Integer(42);



          //an array with space for MAXELEMENTS

          integerArray = new Integer[MAXELEMENTS];



          //a vector with default initial size

          slowVector = new Vector();



          //a vector with initial capacity of (1/2)*MAXELEMENTS and a

                    &Acirc;capacityIncrement of (1/10)*MAXELEMENTS

          midVector = new Vector(MAXELEMENTS/2, MAXELEMENTS/2);



          //a vector with initial capacity of MAXELEMENTS

          fastVector = new Vector(MAXELEMENTS);

</PRE>




<P>Listing 7.3c takes the newly initialized Vector and array objects and fills them with

Integer objects. After the insertion is complete, the time needed to complete the insertion is given.

</P>



<P>Listing 7.3c Filling the Array and Vector Objects with Integer Objects

</P>




<PRE>

         //insert MAXELEMENTS into slowVector

          begin = System.currentTimeMillis();

          for(int i=0; i&lt;MAXELEMENTS; i++) {

               slowVector.addElement(myInteger);

          }

          end = System.currentTimeMillis();

          System.out.println(&quot;Time to insert MAXELEMENTS into

                    &Acirc;slowVector: &quot;+ (end-begin) +&quot; milliseconds&quot;);



          //insert MAXELEMENTS into integerArray

          begin = System.currentTimeMillis();

          for(int i=0; i&lt;MAXELEMENTS; i++) {

               integerArray[i] = myInteger;

          }

          end = System.currentTimeMillis();

          System.out.println(&quot;Time to insert MAXELEMENTS into

                      &Acirc;integerArray: &quot;+ (end-begin) + &quot;milliseconds&quot;);

          //insert MAXELEMENTS into fastVector

          begin = System.currentTimeMillis();

          for(int i=0; i&lt;MAXELEMENTS; i++) {

</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-202"><P>Page 202</P></A>







<P>Listing 7.3c Continued

</P>




<PRE>

              fastVector.addElement(myInteger);

          }

          end = System.currentTimeMillis();

          System.out.println(&quot;Time to insert MAXELEMENTS into

                    &Acirc;fastVector: &quot;+ (end-begin) +&quot; milliseconds&quot;);





          //insert MAXELEMENTS into midVector

          begin = System.currentTimeMillis();

          for(int i=0; i&lt;MAXELEMENTS; i++) {

               midVector.addElement(myInteger);

          }

          end = System.currentTimeMillis();

          System.out.println(&quot;Time to insert MAXELEMENTS into midVector:

                    &Acirc;&quot;+ (end-begin) +&quot; milliseconds&quot;);

     }



     public static void main(String args[]) {

          VectorBenchmarks myVectorBenchmarks = new VectorBenchmarks();

     }

}

</PRE>




<P>Listing 7.4 gives the output generated by the benchmarking application. As you can

see, insertion into the array was fastest because are dealing with a pre-allocated

memory buffer. After you begin dealing with Vectors insertion time increases, however, as you

can see through proper planning, you are able to receive a fast insertion time in the

fastVector example.

</P>



<P>Listing 7.4 Output of the VectorBenchmarks Application

</P>




<PRE>

Time to insert MAXELEMENTS into slowVector: 5483 milliseconds

Time to insert MAXELEMENTS into integerArray: 1600 milliseconds

Time to insert MAXELEMENTS into fastVector: 3200 milliseconds

Time to insert MAXELEMENTS into midVector: 4216 milliseconds

</PRE>




<P>The huge differences in insertion times for the

benchmarking application above prove how important it is to calculate your space needs in advance. To properly calculate space

needs, you need not only an understanding of your application, but also an understanding of

the possibilities that Java presents.

</P>



<A NAME="PAGENUM-203"><P>Page 203</P></A>







<P>One purpose of this chapter and Chapter 8 is to teach you

about developing data structures in Java. In a broader sense, this

book teaches not only about the Java language, but more

importantly, stresses planning your application long before attempting to

write even one line of code. By planning your applications ahead of

time, you have a much better chance of writing memory-efficient code

the first time.

</P>



<H3><A NAME="ch07_ 5">

Implementing Stacks Using java.util

</A></H3>



<P>A Stack is a linear data structure to which new items are

always added and deleted from the same point. A stack is considered a <BR>

Last-In-First-Out (LIFO) data structure because the first item

to which you have access is the last one that you added to the stack.

If stacks are a new concept to you, you might be confused about

their implementation and purpose. Stacks are basically simple and

quite useful, as they allow an infinite amount of objects to be

manipluated in a logical manner.

</P>



<P>Look at figure 7.1, which illustrates a stack. The numbers 1, 2,

3, and 4 (in that order) have been pushed onto this stack. The

numbers 5, 6, and 7 are waiting to get pushed onto the stack.

</P>



<P>If you think back to all the trouble you might have had

learning pointer manipulation, you should be rather excited that stacks can

be implemented in Java without the need for pointers. In fact, it is

even possible to implement a stack in one line of code! The ease

with which you can implement a stack is due to Sun's provision of a

class called java.util.Stack, which does most of the work for you.

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Although it is crucial that you plan ahead for storage

requirements in your application, it is not always possible

to predict the optimal situation. You will often be forced

to recode parts of your application, testing for a variety of

storage situations. The fastest method might not always be the

most obvious, and only by extensively testing all situations can you

be assured that you have achieved optimal speeds.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

While learning about stacks, you need to pick up a few

key terms. The term push is used to indicate the action of adding

an item to the stack, and the term pop is used to indicate removing

an item from the stack. The term peek  indicates the action

of looking at the item that is next in line to be popped off the stack.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-204"><P>Page 204</P></A>









<P><a href="images\ch07fg01.jpg"><img src="images\tn_ch07fg01.jpg"></a><BR>

Figure 7.1

A pictorial representation of a stack.

</P>



<H4><A NAME="ch07_ 6">

The java.util.Stack Class

</A></H4>



<P>Note the Java API listing for java.util.Stack in listing 7.5.

The method list is rather small, and you should have little trouble

seeing how it is implemented.

</P>



<P>Listing 7.5 The Java API Listing for java.util.Stack

</P>




<PRE>

public class java.util.Stack extends java.util.Vector

 &Acirc;{

       public  boolean empty();

       public  Object peek();

       public  Object pop();

       public  Object push(Object item);

       public  int search(Object o);

}

</PRE>




<H4><A NAME="ch07_ 7">

Implementing the Stack Class

</A></H4>



<P>Coverage of the Stack class begins with the development of a

small application that shows proper usage of the different methods in the class. You then develop a practical

solution

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Chances are many of you thought about how easy it would

be to be able to implement a stack using the java.util.Vector

class. Well, you are by no means alone, Stack's parent is Vector,

and Sun obviously realized the same thing as you!

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<P><CENTER>

<a href="0197-0200.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0205-0208.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







