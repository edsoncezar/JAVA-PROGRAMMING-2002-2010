<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0209-0212.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0217-0220.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-213"><P>Page 213</P></A>




<P><a href="images\ch07fg03.jpg"><img src="images\tn_ch07fg03.jpg"></a><BR>
Figure 7.3
Before a hash table accepts a new object, the hash table
needs certain information.
</P>

<P>By now you should have a pretty good understanding of what needs to occur for an
object to get inserted into a hash table, but you now need to know how this insertion is
performed. This insertion is actually rather easy, and you should have little trouble
implementing it in your application.
</P>

<P>You can add the support to a class for hashing by overloading two methods in
the java.lang.Object class (remember that java.lang.Object is the &quot;universal parent&quot;).
These methods are
</P>

<PRE>
public native int hashCode()
</PRE>

<P>and
</P>

<PRE>
public boolean equals(Object obj)
</PRE>


<P>When you overload hashCode(), you need to return an integer
that can be used as a hash code; when you overload
equals(), you need to return a Boolean that indicates whether the object passed in is
equal to the current object. Listing 7.9 shows how a contact book
application might design these methods. The listing obviously does not
give all code for the contact book, but instead shows how support for
the hashCode() and equals() methods would be implemented in a
object that holds information for an individual contact. All methods that
are referenced are assumed to perform a duty that is made obvious
by their name.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The key to note in the preceding paragraph is that
implementing support for a hash code is easy. What
is not so easy is actually deciding what that hash code should be.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-214"><P>Page 214</P></A>

<P>Listing 7.9 An Object Must Know How to be Hashed and How to Tell Whether
It Is Equal to Other Objects
</P>


<PRE>
//return a hash code based on the phone number
public int hashCode() {
              return Integer.parseInt(this.getPhoneNumber().substring(9,
                             &Acirc;12));
 }

//return a boolean true if the object passed in contains identical
//contact information as the current object.
public boolean equals(Object obj) {
       ContactBookEntry tempEntry = (ContactBookEntry)obj;
       boolean phoneBool =
this.getPhoneNumber().equals(tempEntry.getPhoneNumber());
       boolean faxBool = this.getFaxNumber().
              &Acirc;equals(tempEntry.getFaxNumber());
       boolean emailBool = this.getEmail().
              &Acirc;equals(tempEntry.getEmail());
       boolean fnameBool = this.getFname().
              &Acirc;equals(tempEntry.getFname());
       boolean lnameBool = this.getLname().
              &Acirc;equals(tempEntry.getLname());
       boolean mnameBool = this.getMname().
              &Acirc;equals(tempEntry.getMname());
       boolean addressBool = this.getAddress().
              &Acirc;equals(getAddress());
       return ((phoneBool == faxBool) == (emailBool == fnameBool)
              &Acirc;  == (lnameBool == mnameBool) == addressBool);
}
</PRE>

<P>It is important to note the manner chosen to compute the hash code in listing 7.9 is by
no means the only hash code that would work. Choosing to use part of the phone number as
a hash code is one option; another possible idea would be to average the ASCII values of
the first three letters in the person's name.
</P>

<B>
Why It Is Required That We Overload hashCode()<BR>
and equals()
</B>

<P>The beginning of this section stated that you had to implement support for the
hashCode() and equals() methods; if you look at java.lang.Object, however, you will note that
those methods are not abstract and in fact are implemented at that level. The manner in
which
</P>
<A NAME="PAGENUM-215"><P>Page 215</P></A>



<P>java.lang.Object implements these methods is rarely desirable
for practical purposes, and if your hash table is going to show
any semblance of balancing, then you will want to overload the
methods yourself. In fact, you can take this one step further and state
that without overloading equals(), your hash table might not
function properly. In listing 7.9 we overloaded equals() to test if the
two objects being compared contain the same data. The
implementation of equals() in java.lang.Object only looks to see if the two
objects being compared reference the same value.
</P>

<P>In the contact book application in listing 7.9, equals() is
overloaded to return true if the two objects in question contain the same
data. With the contact book application, you rarely have a situation
where two references to the same object were entered. But chances are
you could have a situation where someone entered the information
twice. If someone creates two contact book entries for the same
person, then these entries might be treated as equal.
</P>

<P>The manner in which java.lang.Object generates a hash code is not
as clear as the manner in which it decides if two objects are equal.
You may find, however, that the hash code produced by
java.lang.Object&#151;although valid&#151;is rarely practical. A valid return value means that
it observes the following two rules that are defined in Javasoft's
online documentation at
</P>

<PRE>
<a href="http://java.sun.com/products/jdk/currentrelease/api/">
http://java.sun.com:80/products/JDK/CurrentRelease/api/</A>
java.lang.Object.html#6130.
</PRE>

<UL>
<LI>          Whenever invoked on the same object more than once during an execution of
a Java application, the hashCode() method must consistently return the same
integer. This integer need not remain consistent from one execution of an application
to another execution of the same application.
<LI>          If two objects are equal according to the equals method, then calling the
hashCode method on each of the two objects must produce the same integer result.
</UL>

<H4><A NAME="ch07_ 12">
Working with the Hashtable Class
</A></H4>

<P>You spent the beginning of this section delving into what is needed when developing
an optimal hash table, but you have not actually developed anything yet. You will finish
this 
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The manner in which equals() is overloaded is quite similar to
the manner that String overloads equals(). For example, if you
create two string objects (string1, and string2) and both hold
the word &quot;Smalltalk,&quot; then
string1.equals(string2) would return true. If you use the
form string1 == string2, however, the return is false because the
== comparison returns false if the two objects in question are
not references to the same object.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-216"><P>Page 216</P></A>


<P>section by developing a small application that hashes the contact book objects
discussed earlier. Due to space constraints, the contact book contains entries only for phone
number, first name, and last name. The code contained in listings 7.10a through 7.10c is
an example of the powerful prospects of hash tables, and also an example of how easy it
can be to create a hash table in Java.
</P>

<P>In listing 7.10a is the beginning class representing a single contact book entry. Here
basic variables are set up, and public getXXX() and
setXXX() methods are implemented to manipulate member data.
</P>

<P>Listing 7.10a A Sample Application that Performs Hashing on a Series of
Contact Book Entries
</P>

<PRE>
package industrial;
import java.util.*;
class ContactBookEntry  {
     private     String      phoneNumber;
     private     String      fname;
     private     String      lname;

     public ContactBookEntry() {}

     public void setPhoneNumber(String pnum) {
          phoneNumber = pnum;
     }
     public void setFname(String fnam) {
          fname = fnam;
     }

     public void setLname(String lnam) {
          lname = lnam;
     }

     public String getPhoneNumber() {
          return phoneNumber;
     }
     public String getFname() {
          return fname;
     }

     public String getLname() {
          return lname;
     }

</PRE>

<P><CENTER>
<a href="0209-0212.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0217-0220.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



