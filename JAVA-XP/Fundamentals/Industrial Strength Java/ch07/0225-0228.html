<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0221-0224.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0229-0230.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-225"><P>Page 225</P></A>

<P>will break from this discussion and discuss the implementation of
DoubleEnded-     LinkedList. After you have developed the code for DoubleEndedLinkedList you
will return to SortedDoubleEndedLinkedList and cover the implementation of each
method required by that class. Finally, you will put both the classes together, and you will be <BR>
&quot;ret-to-go!&quot;
</P>

<a href="images\ch07fg06.jpg"><img src="images\tn_ch07fg06.jpg"></a><BR>
Figure 7.6
An object diagram for DoubleEnded LinkedList.
</P>


<B>
The DoubleEndedLinkedList Class
</B>

<P>The methods in DoubleEndedLinkedList are slightly altered versions of the methods
in Vector (the parent class), and the study of this class is facilitated by a concrete
understanding of Vector. (Now is a good time to read the beginning of this chapter if you are
skipping around.) Looking at the object diagram in figure 7.6, you should note that because it is
a double-ended list, it needs to enable insertion at either end. 
</P>


<P>Contained within the Vector class are two methods for insertion:
</P>

<UL>
<LI>          addElement(). Accepts an object as a parameter and inserts it at the end of
the Vector.
<LI>          insertElementAt(). Accepts as parameters both an object and an index. The
object will be inserted into the Vector at the position dictated by the index.
</UL>

<P>It doesn't take Sherlock Holmes to determine that addElement() can be modified to act
as the insertAtEnd() method. Also, after you know that a Vector is zero indexed, you
probably won't have much trouble realizing that insertElementAt() can be passed an index
of zero to
</P>


<A NAME="PAGENUM-226"><P>Page 226</P></A>


<P>insert the element at the beginning of the Vector.
</P>

<P>According to figure 7.6, the only method that still needs a definition is
find(). This method is implemented by calling Vector's
indexOf() method with an identical parameter set. It
is reproduced in DoubleEndedLinkedList for clarity, and everything runs fine without
this method. (Of course, you would have to call indexOf() instead of find().) The source
code for DoubleEndedLinkedList is contained in listing 7.12. As you can see, everything
pretty much relies on Vector for execution.
</P>


<P>Listing 7.12 DoubleEndedLinkedList
</P>

<PRE>
package industrial;
import java.util.*;
/*    class DoubleEndedLinkedList
      extends Vector to isolate certain methods that will allow for
            &Acirc;adding at the end
      and at the beginning of a linked list
*/
class DoubleEndedLinkedList extends Vector {
      //adds to the beginning of the linked list. Used when the new
            //object is smaller than the middle object.
      protected void putAtBeginning(Object obj) {
            super.insertElementAt(obj, 0);
      }

      //adds to the end of the linked list. Used when the new object is
      //greater than the middle object.
      protected void putAtEnd(Object obj) {
            super.addElement(obj);
      }

      //returns the index of the object passed in. We also pass in a
            //starting index which will tell us whether to search the first
      //section or the second section.
      protected int find(Object obj, int startingIndex) {
            return super.indexOf(obj, startingIndex);
      }
}
</PRE>


<A NAME="PAGENUM-227"><P>Page 227</P></A>





<B>
The SortedDoubleEndedLinkedList Class
</B>

<P>Now that you have built SortedDoubleEndedLinkedList's parent, refer back to figure
7.5 and note that the earlier assertion that much of the support in
SortedDoubleEnded LinkedList comes from DoubleEndedLinkedList is completely correct.
</P>

<P>Unlike DoubleEndedLinkedList, which had to offer support for insertion at either
end, SortedDoubleEndedLinkedList needs to support only one public method for insertion.
Not because that insertion is only supported from one end, but because the user is not
involved with the end choice.
</P>




<P>SortedDoubleEndedLinkedList supports a method called
put() that accepts as a parameter an Integer object. The put() method
then performs one of the two options listed below.
</P>

<UL>
<LI>          First, put() tests to see whether any objects are currently in
               the linked list. If there are not, you mark this object as the
               center object, and insert it into the list.
<LI>          If an object is already in the list, however, test to see whether
               the new object belongs at the beginning or the end of the list
               and then call an appropriate method DoubleEndedLinkedList
               to insert the new object. Of course, you increment a counter
               that tracks the number of objects in the class.
</UL>

<P>In addition to adding a new object to the sorted list, you will want
to be able to find the index of an object currently in the list. You
will discover that keeping the list in some order speeds up the search
for that object. Insertion is not a complicated process, and neither
is searching. The necessary steps are outlined below:
</P>

<UL>
<LI>          Test to see whether the object for which you are searching
               occurs before or after the middle object.
<LI>          Call DoubleEndedLinkedList's
find() method with not only the current object as
a parameter, but also with a zero or the index of the middle object. If the object
you are searching for is less than the middle object, you pass in a 0. If the object
you are searching for is greater than the middle object, you pass in the middle
index. The integer that gets passed up acts as a starting point for your search. Thus, it
is 
</UL>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Although Double-     EndedLinkedList was designed to hold
any object, SortedDouble-     EndedLinkedList is built to simply
hold objects of type Integer. This occurs when you insert objects
larger than a reference at one end and smaller than a reference
at the other. It is required that we be able to compare objects. It
is easier to not worry about how various objects might
compare against each other.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-228"><P>Page 228</P></A>



<UL>
easy to see that you can usually eliminate half the number of element
comparisons when doing the search!
</UL>



<P>The final method that SortedDoubleEndedLinkedList needs to support is a manner
in which you can delete an object. In this method, you pass in an object to be
deleted. SortedDoubleEndedLinkedList then performs the following steps.
</P>

<P>getIndex() is called to find the index of the item for which we are searching.
</P>

<P>Then the removeElementAt() method (implemented in Vector) is called with the
newly discovered index.
</P>





<P>Listings 7.13a through 7.13c documents this class rather well. Take a look at the class
and then implement it in an application you are working on. You could, for example, write
an application that compares search time in the class to search time in a standard linked list.
</P>

<P>In listing 7.13a the SortedDoubleEndedLinkedList class is set up. Also implemented
here is the put() method that inserts a new object into the list. Notice how comparison
operators are used to deciding where the new object should be placed.
</P>

<P>Listing 7.13a The SortedDoubleEndedLinkedList Class
</P>

<PRE>
package industrial;
import java.util.*;
/*    class SortedDoubleEndedLinkedList
      extends DoubleEndedLinkedList to manage insertion and deletion of
            &Acirc;items keeping
      them in a semi-sorted fashion
 */
class SortedDoubleEndedLinkedList extends DoubleEndedLinkedList {

      private int      integerCount = 0;            //count of items in
            &Acirc;the list
      private int      middleValue;                 //the value of the
            &Acirc;middle object
      private int      middleIndex = 0;             //index of the
            &Acirc;middle element

      public void put(Integer theInt) {
            //do we already have objects in the linked list
            if(integerCount != 0) {
                  //should the new object go at the end of the list
                  if(theInt.intValue() &gt;= middleValue) {
                        super.putAtEnd(theInt);
</PRE>



<P><CENTER>
<a href="0221-0224.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0229-0230.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



