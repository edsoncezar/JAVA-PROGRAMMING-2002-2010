<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Beginning Data Structures: Taking Advantage of java.util:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0205-0208.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0213-0216.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-209"><P>Page 209</P></A>







<P>Figure 7.7 An Application that Uses a Stack to Evaluate a Post-Fix Expression

</P>




<PRE>

package industrial;

import java.util.*;

public class CalcDemo {

     Stack calcStack;



     public CalcDemo(String postString) {

          calcStack                     = new Stack();

          StringTokenizer stin     = new StringTokenizer(postString);

          String               theNextToken;



          while(stin.hasMoreTokens()) {

               try{

                    theNextToken = stin.nextToken();

                    System.out.println(&quot;theNextToken: &quot;+theNextToken);



                    //the current token is an operand, simply push onto

                    //the stack

                    if(this.isOperand(theNextToken)) {

                         calcStack.push(theNextToken);

                    }



                    //the current token is an operator, pop twice and eval

                    else {

                    System.out.println(&quot;0: &quot;+theNextToken);

                         calcStack.push(this.eval(calcStack.pop(),

                                                     &Acirc;calcStack.pop(), theNextToken));

                    }



                    //is the next token, the last token on the stack?

                    //if this is the last token, the it is our answer

                    if(!stin.hasMoreTokens()) {

                         System.out.println(&quot;answer: &quot;+calcStack.pop());

                    }

               }

               catch(EmptyStackException ese) { System.out.println(&quot;err:

                                &Acirc;&quot;+ ese); }

          }

     }



     public static void main(String args[]) {

          System.out.println(&quot;Post-Fix String: &quot;+ args[0]);

          CalcDemo myCalcDemo = new CalcDemo(args[0]);

     }

}

</PRE>




<A NAME="PAGENUM-210"><P>Page 210</P></A>







<H3><A NAME="ch07_ 9">

Storing Information in a <BR>

Hash Table

</A></H3>



<P>The way you store information in an application is rather important. You usually need

to have constant access to various parts of some information set, and, as this set grows,

speed becomes an important issue. You can store large information sets in many ways, but

the hash table data structure is one of the more popular. A

hash table works by dividing the large data set into small groups (hopefully of equal size). Each of these small groups

is stored sequentially. Assuming you know the manner in which the data set was divided,

it becomes a simple chore to find a specific part of that data set.

</P>



<P>For example, if you store the names of many people in a hash table, you can break up

the large group into smaller groups by developing categories based on the first letter of

their last name. Figure 7.2 illustrates how a group of names can be categorized in this manner.<BR>



</P>



<P><a href="images\ch07fg02.jpg"><img src="images\tn_ch07fg02.jpg"></a><BR>

Figure 7.2

Hashing a group of names based on the first letter of the

last name.

</P>





<P>One thing to note about figure 7.2 is that the data seems to group around a certain area.

In fact, the letter &quot;D&quot; has more than one name &quot;hashed&quot; to the same location. As you

can imagine, storing a huge collection of names with this system would be rather

impractical. You would end up with such large groupings around specific letters that searching

would take forever!

</P>

<A NAME="PAGENUM-211"><P>Page 211</P></A>







<P>You can achieve an optimal hash table by finding the perfect hash code. Because no <BR>

data set is the same, every data set should have its own hash code. For example,

the implementation in figure 7.2 is practical for a small group of names; if the names

being hashed are associated with members of the same family all having the same last

name, however, you would then have a less-than-optimal situation&#151;all names in the data

set would hash to the same location.

</P>



<P>Another key attribute in finding an optimal hash code is the time it takes to derive

that code from the data. Remember that you need to derive that key when you insert an

item into the table, and when you search for that item later on. Although you might find an

even distribution of data if you average the two's compliment of the number with

42,000 random integers, the time to derive this key would be more than is desirable.

</P>



<P>There are trade-offs that you have to make when deciding on a hash code, and often

you will have to experiment with various values. You usually find that the best manner to

go about deciding on a perfect hash code is to look at the full data set and identify

points where data seems to cluster. If you can minimize (and equalize) the size of all

clusters, chances are you have found a good hash code.

</P>



<H4><A NAME="ch07_ 10">

The java.util.Hashtable Class

</A></H4>



<P>Those who have been following the theme developed in this chapter will realize that

an implementation of a hash table coming from the java.util package will be used. In

fact, listing 7.8 contains the API listing for the

java.util.Hashtable class.

</P>



<P>Among the other premiums provided by java.util.* is a class called &quot;Hashtable.&quot; The

API listing for this class is provided in listing 7.8.

</P>



<P>Listing 7.8 The Java API Listing for java.util.Hashtable

</P>




<PRE>

public class java.util.Hashtable extends java.util.Dictionary implements

&Acirc;java.lang.Cloneable {

//Constructors

public Hashtable();

public Hashtable(int initialCapacity);

public Hashtable(int initialCapacity, float loadFactor);

//Methods

public void clear();

public Object clone();

public boolean contains(Object value);

public boolean containsKey(Object key);

</PRE>


<PRE>
continues
</PRE>




<A NAME="PAGENUM-212"><P>Page 212</P></A>







<P>Listing 7.8 Continued

</P>




<PRE>

public Enumeration elements():

public Object get(Object key);

public boolean isEmpty();

public Enumeration keys();

public Object put(Object key, Object value);

protected void rehash();

public Object remove();

public int size();

public String toString();

}

</PRE>




<H4><A NAME="ch07_ 11">

Telling the Hashtable How to Do its Job

</A></H4>



<P>Although many classes in the Java API are very intuitive, the Hashtable class presents

a question. The fact that each data set has its own hash code was established earlier in

this chapter. However, there is no method in java.util.Hashtable to set or change the hash

code. This obviously is not an oversight, but rather follows logically with other beliefs

surrounding object-oriented programming.

</P>



<P>Objects are meant to be self-contained &quot;entities.&quot; If programmed properly, they should

be able to function perfectly in any environment. For this reason, the Hashtable class is

not required to know the objects that it will house. Instead, every object in the hash table

is required to tell the hash table how to hash. The hash table object in figure 7.3 is asked

to insert some new object. For this process to happen, the following steps must occur:

</P>



<OL>

<LI>          After the hash table is asked to insert a new object, the hash table asks the

new object for its hash code.

<LI>     The new object responds by sending the return value of its hashCode() method.

<LI>     The hash table now asks the new object how to test for equivilance between

other instances of the same class.

<LI>     The new object tells the hash table about about the

equals() method contained within the new object.

<LI>     Using the new object's equals() and

hashCode() methods, the hash table inserts the new object in its proper position.

</OL>





<P><CENTER>

<a href="0205-0208.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0213-0216.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







