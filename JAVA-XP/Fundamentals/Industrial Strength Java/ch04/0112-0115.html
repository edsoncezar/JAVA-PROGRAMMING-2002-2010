<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Applets:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0109-0111.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0116-0118.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-112"><P>Page 112</P></A>


<P>Listing 4.6Continued
</P>

<PRE>
       //The paint method is called whenever your applet needs to paint
       //itself. Here you will place code that needs to draw images,
       //polygons, etc...
       public void paint(Graphics g) {
             //code
       }
        //The update method is automatically called when your applet
        //needs to repaint itself. Its usual purpose is to clear the
        //main screen and then call paint. Here we have overloaded it to
        //simply call paint. This will help to minimize screen &quot;flicker&quot;.
       public void update(Graphics g) {
             paint(g);
       }


       //The stop method is called when a user leaves your Web page. It
       //should take care to stop any intensive processing.
       public void stop() {
             //code
       }
       //The destroy method is called when a user quits his browser. It
       //should take care to free any non-memory dependent resources.
       //All memory dependent resources will be taken care of by the
       //garbage collector.
       public void destroy() {
             //code
       }

 }
</PRE>

<H4><A NAME="ch04_ 11">
Building a Multithreaded Applet Framework
</A></H4>

<P>Few applets are logically designed with a single thread of execution. You usually will
want to separate different tasks off into their own thread.
</P>

<P>Threads enable your applet to manage concurrent tasks. For example, a small applet
with three different animations happening at the same time should allow each animation
to occur on its own thread. Most computers can process only one task at a time. If a
machine deals with one animation, therefore, it cannot consider any others. If you place
each animation in its own thread, however, the VM grants each thread a slice of the
processor's time. This processor time-slicing occurs in a fair order, enabling each thread (or
animation, in this example) to appear as if it executes at the same time as all other threads.
</P>


<A NAME="PAGENUM-113"><P>Page 113</P></A>


<P><B>
Multithreading Support
</B></P>

<P>Multithreading sounds very cool, but it also sounds like a high level of operating
system knowledge is needed to properly manage threading. This is not the case at all. If
you program in a language such as C, you might spend a lot of time trying to properly
thread your application. However, Java offers built-in support for threads.
</P>

<P>This support comes in the form of a Thread class that your projects can extend, as well
as a Runnable interface that your projects can implement. Because Java does not
support multiple inheritance, and because all applets must extend java.applet.Applet, all
applets that need to be multithreaded must implement Runnable.
</P>

<P><B>
Migrating from Single-Threaded to Multithreaded Applets
</B></P>

<P>Moving the single-threaded framework to a multithreaded one is not that
difficult. Methods such as init(), paint(), stop(), and destroy() serve the same purpose. In fact,
the only method that includes a different purpose is
start(). An additional method&#151;run()&#151;will also need to be added; here the majority of the classes' processing will occur.
</P>

<P>The start() method in the single-threaded model holds the body of the applet code. In
the multithreaded model, you move the code from start() to run(), which grants start()
the capability to tell run() to begin processing. At this point, the situation becomes
more complex. The start() method does not directly tell run() to begin; instead, start()
creates and starts a new thread based on the current applet. This new thread executes a
method called run(), which your class implements. It is in this method that the bulk of
your procesing is done. Listing 4.7 illustrates the revised version of the start() method.
</P>

<P>Listing 4.7A Revised Version of start(), which Supports Multithreading
</P>

<PRE>
Thread appletThread = null;
public void start() {
       if(appletThread == null) {
             appletThread = new Thread(this);
             appletThread.start();
       }
}
</PRE>

<P><B>
Multithreaded Applet Code
</B></P>

<P>After rewriting start, our framework is basically complete. Remember to place the body
of the code in the run() method, however. Listing 4.8 contains the multithreaded framework:
</P>


<A NAME="PAGENUM-114"><P>Page 114</P></A>


<P>Listing 4.8A Mulithreaded Applet Framework
</P>


<PRE>
import java.applet.*;

public class &lt;applet name&gt; extends java.applet.Applet implements
Runnable {

       //The init method is called whenever the applet is loaded. Place
       //all initialization code here. Use this method as you would use
       //a constructor in any other class.
       public void init() {
             //code
       }


       //The start method will be called immediately after the init
       //method finished executing. The purpose of this method is to
       //create and start a new thread.
       Thread appletThread = null;
       public void start() {
             if(appletThread == null) {
                   appletThread = new Thread(this);
                   appletThread.start();
             }
       }


       //The run method will be called when the start method creates
       //and starts a new thread. It should contain the bulk of your
       //code.
       public void run() {
             //code
       }


       //The handleEvent method will allow your applet to respond to
       //user events. In case your applet is not event driven I have
       //added a call to pass the event to the applet's parent.
       public boolean handleEvent(Event e) {
        //remove this line if you wish to deal with the event yourself
        return super.handleEvent(e);
    }
</PRE>

<A NAME="PAGENUM-115"><P>Page 115</P></A>


<PRE>
       //The action method also allows your applet the ability to
       //respond to user actions. In case your applet is not event driven
       //I have added a call to pass the event to the applet's parent.
       //The decision to use eitherhandleEvent or action will be
       //dictated by your applet.
       public boolean action (Event evt, Object arg) {
             //remove this line if you wish to deal with the event
             //yourself
             return super.action(evt, arg);
       }


       //The paint method is called whenever your applet needs to paint
       //itself. Here you will place code that needs to draw images,
       //polygons, etc...
       public void paint(Graphics g) {
             //code
       }
        //The update method is automatically called when your applet
        //needs to repaint itself. Its usual purpose is to clear the
        //main screen and then call paint. Here we have overloaded it to
        //simply call paint. This will help to minimize screen &quot;flicker.&quot;
       public void update(Graphics g) {
             paint(g);
       }


       //The stop method is called when a user leaves your web page. It
       //should take care to stop any intensive processing.
       public void stop() {
             //code
       }
       //The destroy method is called when a user quits his browser. It
       //should take care to free any non-memory dependent resources.
       //All memory dependent resources will be taken care of by the
       //garbage collector.
       public void destroy() {
             //code
       }

 }
</PRE>


<P><CENTER>
<a href="0109-0111.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0116-0118.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



