<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Applets:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0104-0108.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0112-0115.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-109"><P>Page 109</P></A>


<P>handleEvent() if&#151;and only if&#151;the needed event is not passed to action(). This
logically concludes that it is commonplace for an applet to override action() and manage the
event through that method.
</P>

<P>Events passed to action() include events such as those that occur in buttons or
pull-down menus. One event not passed to action() that you will have to handle in handleEvent()
is WINDOW_DESTROY. The event is passed to handleEvent() when a window's close
box is clicked.
</P>

<P>In the ShakerNET applet, you will override both the action() and handleEvent() methods.
In action() you will process the events generated when a user clicks on a button.
However, in handleEvent(), you will process the event generated when a user clicks on the close box.
</P>

<P><B>
The paint() Method
</B></P>

<P>You should now understand how to create and run an applet, and you should
understand how to write applets that respond to user-generated actions. However, you must
also become familiar with the paint() method or the means by which an applet produces its <BR>
on-screen drawing.
</P>

<P>When the applet senses that it needs to be redrawn (or when you tell the applet to
redraw), the applet will pass the current Graphics object to the paint() method.
The Graphics object represents the available drawing area, and, in the paint method, does all of its drawing
on the Graphics object.
</P>

<P>Albeit counter-intuitive, proper protocol for telling an applet to redraw itself is not to
call paint() directly, due to the fact that housekeeping tasks need to be taken care of by
the browser before this method should be called. Additionally, the current Graphics
object needs to be discovered and passed to paint(). If you call repaint(), repaint() will
discover the current Graphics object and pass it to a method called update(), which clears
the screen and passes the Graphics object to paint() for painting. If you know that your
entire screen does not need to be redrawn, you will want to override update() to call only
call paint() and not perform any clearing of the screen. This can be done by incorporating
the following code into your application:
</P>

<PRE>
public void update(Graphics g) {
       paint(g);
}
</PRE>

<A NAME="PAGENUM-110"><P>Page 110</P></A>


<P><B>
Providing Closure for Your Applet
</B></P>

<P>This chapter now has covered everything your applet needs to start up, run a static
course of action, and run a user-defined course of action. The following sections detail
the process that must occur when the user finishes with your applet.
</P>

<P>There are two conditions that are satisfied with the word &quot;done.&quot; The first
condition occurs when a user leaves the web page that hosts your applet. In this situation, you
can anticipate that the user might return to your applet at some time in the very near future.
In this situation, you will usually not want to end all processes associated with the applet.
</P>

<P>If the user quits his browser, you can assume that the user will not be returning to
your applet, and you will institute more permanent closing of the applet.
</P>

<P><B>
The stop() Method
</B></P>

<P>The system calls an applet's stop() method every time that a user leaves your web page.
If you play music in the background, for example, you must stop that music in the
stop() method. If you do not, then the music continues playing as the user further explores
the web. In addition to stopping any obvious interference, you also should halt any
intensive processing that might slow the machine.
</P>

<P><B>
The destroy() Method
</B></P>

<P>The system calls the destroy() method when the browser shuts down, and with this
method you will want to release any resources that you have allocated to your applet. It is
often difficult to decide what aspects this method should encompass. Java does offer
automatic garbage collection, so any allocated memory-dependent resources will be taken care of
for you. If you allocate a resource, such as a window handle, that does not depend
on memory, you should dispose of it here.
</P>

<P><B>
Single-Threaded Applet Code
</B></P>

<P>As you have seen, applets follow a pretty static framework. From this statement, a
logical choice is to develop a set of standard frameworks that can be used when you
develop applets. To finish up coverage of applets, you will develop two applet frameworks. One
of a single-threaded model, and one of a multithreaded model.
</P>

<P>Threads are discussed further in Chapter 13, &quot;Thinking in Terms of Threads.&quot;
However, for now you should understand that a thread represents a single task executing at the
same time as n other tasks. The variable n can vary from 0, where your applet has but
one course of execution, to infinity (given infinite hardware), where multiple processes
occur at the same time.
</P>


<A NAME="PAGENUM-111"><P>Page 111</P></A>


<P>Our first framework is for a single-threaded applet (where n = 0).
</P>

<P>The code in listing 4.6 demonstrates the basic single-threaded applet framework
just discussed.
</P>

<P>Listing 4.6A Simple Framework for a Single-Threaded Applet
</P>

<PRE>
import java.applet.*;
public class &lt;applet name&gt; extends java.applet.Applet {

       //The init method is called whenever the applet is loaded. Place
       //all initialization code here. Use this method as you would use
       //a constructor in any other class.
       public void init() {
             //code
       }


       //The start method will be called immediately after the init
       //method finished executing. From here your applet is free
       //to branch to other methods and classes.
       public void start() {
             //code
       }


       //The handleEvent method will allow your applet to respond to
       //user events. In case your applet is not event driven I have
       //added a call to pass the event to the applet's parent.
       public boolean handleEvent(Event e) {
        //remove this line if you wish to deal with the event yourself
        return super.handleEvent(e);
    }

       //The action method also allows your applet the ability to
       //respond to user actions. In case your applet is not event driven
       //I have added a call to pass the event to the applet's parent.
       //The decision to use either handleEvent or action will be
       //dictated by your applet.
       public boolean action (Event evt, Object arg) {
             //remove this line if you wish to deal with the event yourself
             return super.action(evt, arg);
       }
</PRE>
<PRE>
                                                           continues
</PRE>


<P><CENTER>
<a href="0104-0108.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0112-0115.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



