<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Introducing Networking:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0344-0348.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0353-0356.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-349"><P>Page 349</P></A>









<P>Listing 10.21 echoClient.java Second of Three

</P>




<PRE>

address = InetAddress.getByName(args[0]);

socket = new DatagramSocket();

data = new byte[packetsize];

messageSend = new String(args[1]);

messageSend.getBytes(0, messageSend.length(), data, 0);

//remember datagrams hold bytes

packet = new DatagramPacket(data, data.length, address, serverPort);

</PRE>




<P>In the final section of code, shown in listing 10.22, the network connection occurs.

The client sends the DatagramPacket to the server. The DatagramPacket is then

reinitialized and used to receive the packet that is returned from the server. Finally, the data in

the returned packet is displayed on the screen.

</P>



<P>Listing 10.22 echoClient.java Third of Three

</P>


<PRE>

      try

      {

        socket.send(packet);

      }

      catch(IOException e)     // do catch exceptions here

                               // since error is possible due to

                               // non-code (network) problems

      {

        System.out.println(&quot;could not send packet&quot;);

        System.out.println(e);

        System.exit(0);

      }



      // packet is reinitialized because it will be

      // used for receiving instead of sending

      packet = new DatagramPacket(data, data.length);



      try

      {

        socket.receive(packet);

      }

      catch(IOException e)

      {

        System.out.println(&quot;could not receive a packet&quot;); 

        System.out.println(e);

        System.exit(0);

      }

</PRE>







<A NAME="PAGENUM-350"><P>Page 350</P></A>







<P>Listing 10.4 Continued

</P>




<PRE>

       //display the returned data on the client console

       messageReturn = new String(packet.getData(), 0);

       System.out.println(messageReturn + &quot; returned from server&quot;);

  }

}

</PRE>




<P>Listing 10.23 shows the server running on a machine

named studsys.mscs.mu.edu, whereas the client is running

on matt.brumbaugh.com. As you can see at the end of the example,

the server is still running, waiting for another connection, while

the execution of the client has halted. This is normal; when you

shut down a client connection, such as your web browser, you do

not expect the server to stop running.

</P>



<P>In the following two lists, the code on the left corresponds to

the server's screen, whereas the code on the right corresponds to

the client screen.

</P>



<P>Listing 10.23 The Server Running on studsys.mscs.mu.edu: The Client Running

on matt.brumbaugh.com

</P>






<PRE>

%java serverEcho              %java clientEcho studsys.mscs.mu.edu test

String: test              %Returned from server: test

From: matt.brumbaugh.com        %

</PRE>




<P>Listing 10.24 echoClient and echoServer Sample Run

</P>




<PRE>

%java serverEcho

                               %java clientEcho studsys.mscs.mu.edu test

String: test

From: matt.brumbaugh.com

                  %Returned from server: test

                 %

</PRE>




<P>The formatting in this example works nicely. The text is displayed cleanly on the

screen. Simple alterations of the echo program, however, may not appear as cleanly because

the data is always passed over the network as an array of bytes that holds 1024 bytes. To

keep things simple, the example did not dynamically resize the array. If extra characters at

the end of a string will affect your application, however, you will need to make sure that

each

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The term &quot;dynamically resize&quot; refers to

the ability to increment or decrement the size of the array while

the code is executing. Each packet could be &quot;just the right

size.&quot; For efficiency reasons, this is often necessary.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-351"><P>Page 351</P></A>





<P>

DatagramPacket contains an array of bytes without extra characters.

</P>





<H3><A NAME="ch10_ 18">

UDP versus TCP

</A></H3>



<P>You should now be comfortable using java.net.DatagramSocket and

java.net.Data-     gramPacket to transfer information across the network using UDP. Reliability was

not very important in listing 10.23; nor did the code repeatedly send data to the same

destination, making the echo service a prime example of when datagrams are used. In fact,

all standard Unix machines run an echo service on port 7. You are probably curious

about when else an unreliable network protocol might be the best method of implementing

a network application. The following is a listing of common network applications that

run on top of&#151;that is they use&#151;TCP.

</P>





<BLOCKQUOTE>

TCP Network Services<BR>

Telnet<BR>

File Transfer Protocol<BR>

Simple Mail Transfer Protocol<BR>

Network News Transfer Protocol

</BLOCKQUOTE>



<P>In a likewise manner, the following services, and the programs that take advantage

of them, rely on UDP.

</P>



<BLOCKQUOTE>

UDP Network Services<BR>

Domain Name Services<BR>

Trivial File Transfer Protocol<BR>

Network File System<BR>

Ping<BR>

daytime server (Unix)<BR>

echo (Unix)<BR>

talk (Unix)

</BLOCKQUOTE>



<P>UDP is most desirable when information is either sent or requested frequently from

a variety of sources. Some applications, such as telnet, demand a dedicated connection,

or socket. Other applications, such as SMTP, need a guarantee that the entire message

arrived and that it arrived in the correct order. Datagrams, however, should not be dismissed

as impractical. Every time your machine searches by host name for another machine on

the Internet, UDP is used. Although most of your applications (and most of the

</P>





<A NAME="PAGENUM-352"><P>Page 352</P></A>









<P>remainder of this chapter) focus on TCP and sockets, a good developer always considers

whether sockets or datagrams would be better suited for the task at hand.

</P>



<H3><A NAME="ch10_ 19">

Client Applets

</A></H3>



<P>So far, this chapter's examples have been applications. Everything that you have done could

be repeated in other programming languages, only with more difficulty. One of the

major advantages of using Java is your ability to create programs that are loaded by a

common browser and then executed on the client machine. The programs, or

applets, are ideal for writing client code.

</P>



<P>The fact that users do not have to download or install a client program on their

machine has two key advantages:

</P>



<UL>

<LI>          The server can be accessed by anybody with access to a Java-enabled web

browser, not just those who purchase or download the client application.

<LI>          The client program can be changed on a frequent basis, even daily, and the

end users do not have to reinstall the program or download patches&#151;a major

advantage for administrators of corporate intranets.

</UL>



<P>Java applets are often thought of as nifty web-based animations or flashing,

multicolored text. Yes, many applets are not much more than glitz; however, the java.applet package

can be used to implement powerful client applications that can be used to play games, access

a database, or communicate with a mainframe.

</P>



<H4><A NAME="ch10_ 20">

Applet Restrictions

</A></H4>



<P>As was mentioned previously, applets are limited in what they can

</P>



<P>do because the user does not necessarily choose to execute

applet code. These limitations affect how you may use the java.net

classes. Java applets can only create network connections to the host

from which they came. That is, if an applet is on a home page at a

mach-     ine named matt.brumbaugh.com, it can only open connections

to matt.brumbaugh.com. The security policy that restricts applets is

part of the browser the user is running, not part of Java itself. Also,

code exists that will bypass some security policies set by different

brow-     sers. These facts should not be interpreted to mean that the

security restrictions are merely recommendations. Any code written to

get around security issues can become out-of-date with a new

browser version or a tighter security policy. Also, bypassing security

policies can potentially violate the trust of the user. As a Java

programmer, you should treat the fact that you can 

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The user interfaces in the examples in this chapter have

been deliberately kept simple. This chapter does not address

the user interface issue. If you have any questions, however,

you should refer to the chapter on java.awt (Chapters 4 and 5).

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>





<P><CENTER>

<a href="0344-0348.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0353-0356.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







