<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Introducing Networking:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0336-0339.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0344-0348.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-340"><P>Page 340</P></A>







<P>receives DatagramPackets across the network. You can think of a DatagramPacket as

a letter and a DatagramSocket as the mailbox that the mailcarrier uses to pick up and

drop off your letters.

</P>



<B>

DatagramPacket

</B>



<P>A DatagramPacket is an object that can be transferred through DatagramSockets (see

table 10.13). It is much like an envelope; it holds data.

</P>



<P>Listing 10.13 java.net.DatagramPacket

</P>




<PRE>

public final class DatagramPacket extends Object {

  //Constructors

  public DatagramPacket(byte[] ibuf, int ilength);

  public DatagramPacket(byte[] ibuf, int ilength,

    InetAddress iaddr, int iport);

  //Methods

  public InetAddress getAddress();

  public byte[] getData();

  public int getLength();

  public int getPort();

}

</PRE>




<P>The DatagramPacket class provides the programmer with two constructors. The first

is used for DatagramPackets that receive information. This constructor needs to be

provided with an array to store the data and the amount of data to receive. The second is used

to create DatagramPackets that send data. The constructor needs the same two pieces

of information, plus the destination address and port. The methods are fairly

self-explanatory. The data itself or variables of the DatagramPacket can be accessed using the get methods.

</P>



<B>

DatagramSocket

</B>



<P>DatagramSockets are the mechanisms which will send and receive DatagramPackets (see

table 10.14). They are the mailboxes in which you drop off and pick up the letters you are transferring.

</P>



<P>Listing 10.14 java.net.DatagramSocket

</P>


<PRE>

public final class DatagramSocket extends Object {

  //Constructors

  public DatagramSocket() throws SocketException;

  public DatagramSocket(int port) throws SocketException;

  //Methods

  public synchronized void close();

  public int getLocalPort();

</PRE>




<A NAME="PAGENUM-341"><P>Page 341</P></A>






<PRE>

  public synchronized void receive(DatagramPacket p)

    throws IOException;

  public void send(DatagramPacket p) throws IOException;

  protected synchronized void finalize();

}

</PRE>




<P>Again, two constructors are provided by the class DatagramSocket. The programmer

can specify a port to use or allow the system to randomly assign one. The

getLocalPort() method can be used to determine the port if you allow the system to choose.

Because DatagramPackets contain a destination address, the DatagramSocket class does not

need to know where it is sending the packets. Continuing the previous analogy, your

mailbox does not need to be aware of where letters that are placed in it are supposed to be sent.

The receive() method waits for DatagramPackets to arrive and stores them. After you are

done using the socket, you should call the close() method to free the port. The finalize()

method is used to force the system to perform garbage collection.

</P>



<B>

Implementing Datagrams

</B>



<P>Datagrams are faster than streams-oriented network connections because there is

no overhead from error correction. In order to ensure reliability, however, sockets must

be used. Two examples of when datagrams might prove to be the best option are for

small, one-time messages sent across the network or for a game where the client and server

are frequently exchanging data. If a message fails to arrive, however, no serious

consequences arise. Table 10.6 shows what each class can do and how it does it:

</P>

<P>Table 10.6<BR>

Sending Information Across the Network

</P>





<TABLE>



<TR><TD>

Class

</TD><TD>

Direction

</TD><TD>

Protocol

</TD></TR><TR><TD>

Socket

</TD><TD>

Sends data

</TD><TD>

TCP (connection-based)

</TD></TR><TR><TD>

ServerSocket

</TD><TD>

Receives data

</TD><TD>

TCP (connection-based)

</TD></TR><TR><TD>

DatagramSocket

</TD><TD>

Sends and receives data

</TD><TD>

UDP (connectionless)

</TD></TR><TR><TD>

DatagramPacket

</TD><TD>

Sent and received by

</TD><TD>

UDP (connectionless)

</TD></TR><TR><TD>

</TD><TD>

DatagramSocket

</TD><TD>

</TD></TR></TABLE>



<H4><A NAME="ch10_ 12">

Low-Level java.net Classes

</A></H4>



<P>All of the major classes provided by java.net have now been introduced; however,

several classes remain that are called by the Java VM to do the dirty work. Most

applications never need to implement the interfaces provided by these classes. One of the major

classes is java.net.SocketImpl. It is called by java.net.Socket and java.net.ServerSocket

to implement the socket connection (see table 10.7). Although Java was designed with

the Internet and the TCP/IP protocol suite in mind, it is not limited to those

protocols.

</P>







<A NAME="PAGENUM-342"><P>Page 342</P></A>







<P>Subclasses of SocketImpl can implement sockets as needed by different network

environments. These classes could be utilized in code that was developed to run only behind

a firewall or on a network that was not running TCP/IP.

</P>





<P>Table 10.7

java.net Classes

</P>



<TABLE>



<TR><TD>

Class

</TD><TD>

Description

</TD></TR><TR><TD>

URL

</TD><TD>

Uniform Resource Locator

</TD></TR><TR><TD>

URLConnection

</TD><TD>

Downloads content from an URL object

</TD></TR><TR><TD>

URLEncoder

</TD><TD>

Translates from text to x-www-form-urlencoded

</TD></TR><TR><TD>

InetAddress

</TD><TD>

Host name and corresponding IP address

</TD></TR><TR><TD>

Socket

</TD><TD>

TCP socket for transmitting data

</TD></TR><TR><TD>

ServerSocket

</TD><TD>

TCP socket for listening for data

</TD></TR><TR><TD>

DatagramPacket

</TD><TD>

Data to be sent via a DatagramSocket

</TD></TR><TR><TD>

DatagramSocket

</TD><TD>

UDP socket for two-way communication

</TD></TR></TABLE>



<P>Many of these low-level classes contain Factory in their name. Classes such as

java.net-     .SocketImplFactory, java.net.URLStreamHandlerFactory, and

java.net.ContentHandler-     Factory are used to create the actual object referred to in their name. Again,

normal applications do not need to use the interfaces provided by these classes.

</P>



<H4><A NAME="ch10_ 13">

Applets versus Applications

</A></H4>



<P>The java.net classes provide access to remote machines; when combined with the fact

that web browsers often download and execute Java bytecode without the user being aware

of what is being executed, or the fact that a foreign program is running on her

machine, security issues arise. Applets are limited in what they can do because of these

factors. Applets can only open network connections to the machine from which they were

downloaded. Though all clients are not applets, applets are only used to create client

programs; servers must be implemented as applications. Although web browsers provide an

easy medium for enabling users to download an up-to-date client, clients can also be

implemented as applications.

</P>



<H4><A NAME="ch10_ 14">

java.net Wrap Up

</A></H4>



<P>The java.net package provides the programmer with a variety of methods for sending

and retrieving information across the network. The Java VM takes care of the extremely

low-level network access, enabling you to focus on writing a good application without

worrying about network inconveniences. Everything required to implement client and

</P>



<A NAME="PAGENUM-343"><P>Page 343</P></A>







<P>server applications is provided by the Java Development Kit. Client/Server programming

across networks that run on the TCP/IP protocol suite is not much more complicated

than developing applications that are designed to be executed on one machine. In the

next section, you will learn how to implement basic clients and servers. The examples

cover both TCP and UDP (sockets and datagrams).

</P>



<H3><A NAME="ch10_ 15">

&quot;First-Time&quot; java.net Programmer <BR>Examples

</A></H3>



<P>Client-Server applications today are nearly synonomous with networked applications.

The client and server in almost all cases split the work load in some fashion. When

writing client/server code, the first question asked is usually, &quot;Where do I begin?&quot; The first step

is to define how your client and server will communicate. Yes, you need to write your

own protocol for how your program will transmit data. After your protocol is defined, you

are free to develop either side. If you are working in a team, the two can be developed

simul-     taneously. As long as you follow the protocol you defined, the client and server can

be developed independently of each other.

</P>



<H4><A NAME="ch10_ 16">

Developing the Server Side

</A></H4>



<P>You will first learn how to implement a basic server application. The server,

when executed, waits for a connection on port 1976. After a client connects, the server prints

the IP address of the client and shuts down. No communication flows back to the client.

It does not get any more basic than this.

</P>



<P>You begin the server like any other Java application. You need to import the java.net.*

in order to use Socket and ServerSocket (see listing 10.15). The package java.io.* is

not actually used. It is a good idea to get used to including java.io when you use

java.net, however, because most real networking uses streams. The

main() method simply creates an instance of firstServ, which does the actual work for the server.

</P>



<P>Listing 10.15 socketServer.java

</P>


<PRE>

package industrial;



import java.net.*;

import java.io.*;

</PRE>


<PRE>
continues
</PRE>




<P><CENTER>

<a href="0336-0339.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0344-0348.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







