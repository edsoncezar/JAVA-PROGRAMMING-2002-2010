<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0285-0289.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0294-0296.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-290"><P>Page 290</P></A>



<PRE>
int size = myByteArray.size();
byte[] myByteArray = new byte[size];
myByteArray = myByteArrayOutputStream.toByteArray();
</PRE>
<P>
<B>
The toString() Method
</B>
</P>
<P>To retrieve the information as a String, you need to use either of the toString()
methods. By itself, toString() returns the contents of the current stream without alteration. Each
byte is converted to its respective character, and they are all concatenated onto the String.
</P>

<P>Using toString(int hibyte) returns the contents of the stream as a String where each
char-     acter is formed by combining the lower 8 bits of hibyte as the upper 8 bits of the
new character, and the byte in question forms the remaining bits of the new character.
The actual computation is performed using the following formula:
</P>

<PRE>
(char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (byte in question &amp; 0xff))
</PRE>

<P>From this formula, you can see that calling toString(0) has the same effect as
calling toString().
</P>

<B>
The writeTo() Method
</B>


<P>If, instead of getting the information as a byte array or String, you desire to pass
the information to another OutputStream, the writeTo() method will work for you.
This method takes an OutputStream as a parameter and fills it with the contents of the
current stream.
</P>

<B>
Finishing with a ByteArrayOutputStream
</B>

<P>As with all child classes of OutputStream, you will want to call
the close() method when you are finished with the stream, as it
forces the return of allocated system resources. If you will need a
Byte-     ArrayOutputStream later in your application, however, you
may want to hold off on letting the system have its resources back. Due
to the fact that allocating resources takes time, by using already
allo-     cated resources, your application places less of a strain on
the computer. Calling the reset() method contained in
ByteArray-     OutputStream effectively discards all stored data, yet does not
force you to reallocate system resources when a
ByteArrayOutputStream is again needed.
</P>

<P>The advantage of not &quot;closing&quot; the stream is that all system resources allocated to
the stream remain allocated. Because this
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The data is not actually discarded. Rather, an
internal variable&#151;count&#151;which indicates
the number of bytes in the stream, is set to 0, having the effect
of discarding the data. Space allocated to the buffer,
however, remains intact.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-291"><P>Page 291</P></A>



<P>includes memory allocated to the buffer, you
will find that recycling the current space and not discarding the current object saves a
great deal of time.
</P>

<H4><A NAME="ch09_ 12">
Using the ByteArrayInputStream Class
</A></H4>

<P>The ByteArrayInputStream class proves most useful when your application needs to
read in an existing data set in the form of a stream. This data set, in the form of an array
of bytes, is passed to the ByteArrayInputStream constructor and acts as a constant source
of input for the stream, as in listing 9.10.
</P>

<P>Listing 9.10 The API listing for java.io.ByteArrayInputStream
</P>
<PRE>
public class java.io.ByteArrayInputStream extends java.io.InputStream {
    //Fields
    protected byte buf[];
    protected int count;
    protected int pos;

    //Constructors
    public ByteArrayInputStream(byte buf[]);
    public ByteArrayInputStream(byte buf[], int offset, int length);

    //Methods
    public int available();
    public int read();
    public int read(byte b[], int off, int len);
    public void reset();
    public long skip(long n);
}
</PRE>
<P>
<B>
Reading from a ByteArrayInputStream
</B>
</P>

<P>The read() methods present in the ByteArrayInputStream class are similar to
those supplied by its parent (InputStream) and read either one byte (read()) or a series of
bytes directly into a byte array (read(byte b[],int off, int len)), where off indicates the
starting index that data is read into, and len indicates the maximum number of values that
should be read into the array.
</P>

<B>
Filling a ByteArrayInputStream
</B>

<P>Filling a ByteArrayInputStream is an interesting concept. When you create an instance
of
</P>



<A NAME="PAGENUM-292"><P>Page 292</P></A>


<P>the object, you pass it a byte array; however, the contents of the array are not
copied. Rather, the array is set up as a constant source of data for the stream. The stream
is considered full when b contains data from b[0] to b[ b.length - 1 ].
</P>

<B>
Moving Around the Stream
</B>

<P>If, while reading in data from the stream, you decide that you don't need sequential
access to the data, the skip(n) method enables you to skip over n bytes. If you attempt to
skip over more bytes than are available, you will skip directly to the last byte in the stream.
</P>

<B>
Finishing with the Stream
</B>

<P>As with ByteArrayOutputStream, ByteArrayInputStream supports both the close()
and reset() methods. The close() method will close the stream, and return any
resources allocated to it. However if this stream will be needed at some later point, simply
calling the reset() method is potentially a better idea. Remember that allocating resources
takes time, and that if a stream can be reused, the application's efficiency increases.
</P>

<H3><A NAME="ch09_ 13">
Writing to and from Files: <BR>FileInputStream and <BR>FileOutputStream
</A></H3>

<P>One of the most popular types of I/O that an application may need to perform is file
I/O. Files are used to store created documents, preference files, and just about any other type
of data imaginable. Java provides a variety of classes for file I/O; FileInputStream
and FileOutputStream are two of these classes.
</P>

<P>Later in this chapter, you will find a discussion of the RandomAccessFile class, which
can also be used for file I/O. Because file I/O is one of the first things that you usually learn
in a new language, you no doubt have had experience dealing with file I/O in other
languages. As you learn about these classes, think about how much easier file I/O in Java
is when compared to some other languages. As with all the discussions on streams,
API listings are provided ahead of time to enable you to get acquainted with the class. Take
a minute to study listings 9.11 and 9.12 and get ready to dive into file I/O!
</P>
<A NAME="PAGENUM-293"><P>Page 293</P></A>



<P>Listing 9.11 The FileOutputStream Class
</P>

<PRE>
public class java.io.FileOutputStream extends java.io.OutputStream {
    //Constructors
    public FileOutputStream(File file);
    public FileOutputStream(FileDescriptor fd);
    public FileOutputStream(String name);

    //Methods
    public void close();
    protected void finalize();
    public final FileDescriptor getFD();
    public void write(byte b[]);
    public void write(byte b[], int off, int len);
    public void write(int b);
}
</PRE>

<P>Listing 9.12 The API Code for java.io.FileInputStream
</P>
<PRE>
public class java.io.FileInputStream extends java.io.InputStream {
    //Constructors
    public FileInputStream(File file);
    public FileInputStream(FileDescriptor fd);
    public FileInputStream(String name);

    //Methods
    public int available();
    public close();
    protected void finalize();
    public final FileDescriptor getFD();
    public int read();
    public int read(byte b[]);
    public int read(byte b[]);
    public long skip(long n);
}
</PRE>

<H4><A NAME="ch09_ 14">
Sending Information to a File
</A></H4>

<P>When instantiated, the FileOutputStream class opens an output stream to a file; where
the file is passed as a parameter. The constructors accept either an instance of a File
or FileDescriptor object, or a String representing a system-dependent file path.
</P>


<P><CENTER>
<a href="0285-0289.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0294-0296.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



