<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0306-0310.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0316-0320.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-311"><P>Page 311</P></A>







<P>Stream. This application, contained in listing 9.22, performs the following steps:

</P>



<OL>

<LI>          Fills a byte array with 10,000 bytes.

<LI>     Records the time necessary to write those 10,000 bytes to a file using only

a FileOutputStream. This time is then printed to the screen.

<LI>     Records the time necessary to write those same 10,000 bytes to a file using

a BufferedOutputStream (with buffer size 5,000) on top of a FileOutputStream.

This time is then printed to the screen.

<LI>     Records the time necessary to write those same 10,000 bytes to a file using

a BufferedOutputStream (with buffer size 10,000) on top of a

FileOutputStream. This time is then printed to the screen.

</OL>



<P>Listing 9.22 The Buffered Stream Benchmark Test

</P>


<PRE>

import java.io.*;



public class BufferTest {



      public static void main(String args[]) throws IOException {

            FileOutputStream           fout       = new

                         &Acirc;FileOutputStream(&quot;data.txt&quot;);

            BufferedOutputStream       bout1      = new

                         &Acirc;BufferedOutputStream(fout, 5000);

            BufferedOutputStream       bout2      = new

                         &Acirc;BufferedOutputStream(fout, 10000);

            byte[]                     myArray    = new byte[ 10000 ];

            long                       begin      = 0l;

            long                       end        = 0l;



            for(int i=0; i&lt;10000; i++) {

                  myArray[i] = (byte)i;

            }



            begin = System.currentTimeMillis();

            for(int i=0; i&lt;10000; i++) {

                  fout.write(myArray[i]);

            }

            end = System.currentTimeMillis();

            System.out.println(&quot;FileOutputStream: &quot;+ (end-begin));



            begin = System.currentTimeMillis();

</PRE>


<PRE>
continues
</PRE>




<A NAME="PAGENUM-312"><P>Page 312</P></A>







<P>Listing 9.22 Continued

</P>




<PRE>

            for(int i=0; i&lt;10000; i++) {

                  bout1.write(myArray[i]);

            }

            end = System.currentTimeMillis();

            System.out.println(&quot;BufferedOutputStream1: &quot;+ (end-begin));



            begin = System.currentTimeMillis();

            for(int i=0; i&lt;10000; i++) {

                  bout2.write(myArray[i]);

            }

            end = System.currentTimeMillis();

            System.out.println(&quot;BufferedOutputStream2: &quot;+ (end-begin));

      }

}

</PRE>




<P>Listing 9.23 contains the output generated by the application

in listing 9.22. What is impressive to note about this output is

that when using a BufferedOutputStream with a buffer of size

5,000, output is almost 60 times faster than the FileOutputStream by

itself. When a BufferedOutputStream of size 10,000 is used, this speed

gap jumps to almost 73 times faster than the standard

FileOutputStream. Although it may not seem too important to worry about a few

thou-     sand milliseconds, it is important to note that in the above data

set, the data used is very small. Just image the time your

applications would save if they used BufferedOutputStreams to save 50 MB files!

</P>



<P>Listing 9.23 Output for the Benchmark Test

</P>


<PRE>

FileOutputStream: 10883

BufferedOutputStream1: 183

BufferedOutputStream2: 150

</PRE>




<H3><A NAME="ch09_ 29">

Using the PrintStream Class

</A></H3>



<P>If you have ever written an application that uses the line System.out.println(), you

have already used the class PrintStream. The PrintStream class is compromised&#151;for the

most part&#151;of a series of overloaded print() and println() methods, each of which accepts

a parameter and prints out the parameter accepted.<BR>

</P>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Obviously, timing results vary from machine to

machine. When examining the output for this application, do

not concentrate on actual times but rather on how the

times compare to each other.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>



<A NAME="PAGENUM-313"><P>Page 313</P></A>











<P>Listing 9.24 The Java API Listing for java.io.PrintStream

</P>




<PRE>

public class java.io.PrintStream extends java.io.FilterOutputStream {

    //Constructors

    public PrintStream(OuputStream out);

    public PrintStream(OutputStream out, boolean autoFlush);



    //Methods

    public boolean checkError();

    public void close();

    public void flush();

    public void print(boolean b);

    public void print(char c);

    public void print(char s[]);

    public void print(double d);

    public void print(float f);

    public void print(int i);

    public void print(long l);

    public void print(Object obj);

    public void print(String s);

    public void println();

    public void println(boolean b);

    public void println(char c);

    public void println(char s[]);

    public void println(double d);

    public void println(float f);

    public void println(int i);

    public void println(long l);

    public void println(Object obj);

    public void println(String s);

    public void write(byte b[], int off, int len);

    public void write(int b);

}

</PRE>




<P>Following the pattern set forth by the previous sections in this book, you probably

expect to see detailed notes on each method. This is unneccessary because a method in this

class can take only one of two actions:

</P>



<UL>

<LI>          Any method with the write() signature will write its parameter to the

underlying stream.

<LI>          Any method with the writeln() signature will write its parameter plus a newline

to the underlying stream.

</UL>



<A NAME="PAGENUM-314"><P>Page 314</P></A>







<P>Finally, it is important to discuss the two constructors supported by the PrintStream class:

</P>



<UL>

<LI>          PrintStream(OutputStream out) will simply print data to the stream out.

<LI>          PrintStream(OutputStream out, Boolean autoflush) will print data to the

stream out. Additionally if autoflush is true all buffered bytes will be forced to out

every time a newline is encountered. If autoflush is false, then buffered bytes will not

be forced to out.

</UL>



<P>The PrintStream class has no InputStream counterpart.

</P>



<H3><A NAME="ch09_ 30">

Using the LineNumberInputStream <BR>Class

</A></H3>



<P>When dealing with large quantities of data, you will often want to manage that data

one line at a time. For example, often when importing data into a database, newline

characters act as row deliminators. If you were writing code to take data from a stream and import

it into a database, you would want to read it in one line at a time. The

LineNumber-InputStream class sits on top of any InputStream, enabling you to read-in data from

that InputStream while keeping track of lines.

</P>



<P>The methods defined by LineNumberInputStream pretty much speak for themselves.

Look at listing 9.25.

</P>



<P>Listing 9.25 The Java API Listing for java.io.LineNumberInputStream

</P>




<PRE>

public class java.io.LineNumberInputStream extends

&Acirc;java.io.FilterInputStream {

    //Constructors

    public LineNumberInputStream(InputStream in);



    //Methods

    public int available();

    public int getLineNumber();

    public void mark(int readLimit);

    public int read();

    public int read(byte b[], int off, int len);

    public void reset();

    public void setLineNumber(int lineNumber);

    public long skip(long n);

}

</PRE>






<A NAME="PAGENUM-315"><P>Page 315</P></A>







<H4><A NAME="ch09_ 31">

LineNumberInputStream Overview

</A></H4>



<P>The methods in LineNumberInputStream bring many

enhancements to a standard InputStream. These methods include standard

read() methods which read in data one byte at a time, and also the

following helpful methods:

</P>



<UL>

<LI>          getLineNumber() which returns an int representing the                     current line number

<LI>          setLineNumber(int destination) which sets the current line                number in the file to destination

<LI>          skip(long n) which skips over n bytes of data in the stream

</UL>



<P>You will use these methods when the part of a stream

which contains the desired data set is nonlinear. Meaning that you

need only bits and pieces of a stream, and those bits and pieces are

not located next to each other.

</P>



<P>As an example of the capabilities of the

LineNumberInputStream class, take a look at listing 9.26, which shows a sample

application jump around a file using the methods discussed previously.

</P>



<P>Listing 9.26 A Demonstration of LineNumberInputStream

</P>


<PRE>

import java.io.*;



public class LineNumberTest {



      public static void main(String args[]) throws IOException {

            try{        FileInputStream           fin = new

                         &Acirc;FileInputStream(&quot;data.txt&quot;);

                        LineNumberInputStream     lin = new

                                                   &Acirc;LineNumberInputStream(fin);



                        //print the current line

                        System.out.println(&quot;Current Line: &quot; +

                                                   &Acirc;lin.getLineNumber());



                        //move ahead five lines

                        lin.setLineNumber(5);



                        //print the current line<BR>



</PRE>


<BR>

<P>



<CENTER>

<TABLE BGCOLOR="#FFFF99">

<TR><TD><B>

NOTE

</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

If are wondering what defines a line, don't feel alone.

Although the definition of a line may seem a bit gray,

it is not. A line is defined as a series of bytes ending with either

a carriage return (\r), a newline character (\n), or a combination

of both. In all cases, the end-of-line indicator

is read as a newline character.

</BLOCKQUOTE></TD></TR>

</TABLE></CENTER>

</P>


<PRE>
continues
</PRE>




<P><CENTER>

<a href="0306-0310.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0316-0320.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







