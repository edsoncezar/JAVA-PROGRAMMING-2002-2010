<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0290-0293.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0297-0301.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-294"><P>Page 294</P></A>


<P>To note about running applications that use FileOutputStreams, is that if the user
running the application does not have write privileges for a particular file, a SecurityException
will be thrown. Good code will test for this situation and display an error message if
the exception is thrown.
</P>

<P>After you have an instance of a FileOutputStream object, you are ready to begin
sending data. Assuming that you have been reading this chapter in a linear fashion, you will
have no trouble understanding the write() methods used by FileOutputStream; as they
are identical to those used in OutputStream. If you are looking for a recap, the methods are
as follows:
</P>

<UL>
<LI>          write(byte b[]), which writes the entire byte array to the file
<LI>          write(byte b[], int off, int len), which writes from b[off] to b[off+len} to the stream
<LI>          write(int b), which writes b as a byte to the stream
</UL>

<H4><A NAME="ch09_ 15">
Retrieving Information from a File
</A></H4>

<P>Because you need to read the information back from a file after you have written it to
that file, the FileInputStream class provides the necessary methods. As with
FileOutputStream, a new instance of FileOutputStream is created with either a File or FileDescriptor
object, or with a String representing a system-dependent file path.
</P>

<P>An instance of FileInputStream enables information to be read using the methods
defined in FileInputStream's parent class, InputStream. Again, if you have not been reading
this chapter in a linear fashion, a review of the read() methods defined in InputStream
are reviewed here:
</P>

<UL>
<LI>          read() which reads in one byte of information from the stream. This method
returns an int with the value of _1 if the stream is empty, or an int with the value of
the total number of bytes read if the stream is not empty.
<LI>          read(byte b[]) which will read data into b[] until the entire array is full. The
return value for this method is identical to the return value for read() listed above.
<LI>          read(byte b[], int off, int len) which will read data into b[] from b[off] to b[len].
If off+len is less than b.length, then len will default to b.length-1-off.
</UL>

<H4><A NAME="ch09_ 16">
Finishing Up with File I/O
</A></H4>

<P>Both FileInputStream and FileOutputStream support the close() method. The
close() method functions in a fashion similar to the other close() methods discussed in
this chapter, releasing allocated system resources.
</P>

<A NAME="PAGENUM-295"><P>Page 295</P></A>



<H4><A NAME="ch09_ 17">
Implementing File I/O Methods
</A></H4>

<P>Knowledge of FileInputStream and FileOutputStream is extremely important. Your
appli-     cations now have the capability not only to create data, but also to store that data. It is
hard to develop any form of powerful application without the aid of files.
</P>

<P>In conclusion to the section on FileInputStreams and FileOutputStreams, you will build
a text editor application. The application will make use of the application frame
work developed in Chapter 6, and will support the following features:
</P>

<UL>
<LI>          Creation of new files
<LI>          Saving of files
<LI>          Opening saved files
<LI>          Editing of an active file
</UL>

<P>When the application loads, it prompts the user with an empty text area, along with
File and Edit menus. At that point, the user can opt to either begin writing in the current
text area, open a saved text area, create a new blank text area, or quit the application.
</P>

<B>
Examining the Feature Set
</B>

<P>When the user wants to open a saved file, the following steps occur:
</P>
<OL>
<LI>          The user selects Open from the File menu.<BR>
<LI>     An Open File dialog box asks the user to select a file for opening.
<LI>     The user selects a file and clicks the OK button in the Open File dialog box.
<LI>     A new FileInputStream object is created with a reference to the selected file.
<LI>     The FileInputStream object streams in the contents of the file.
<LI>     The FileInputStream object takes the file's contents and uses it to create a
new editor window.
</OL>

<P>When the user wants to save the current file, the following steps occur:
</P>

<OL>
<LI>          The user selects Save from the File menu.
<LI>     A Save File dialog box asks the user to select a file name and path to be used
when saving the current editor.
<LI>     The user enters a file name, chooses the correct path, and clicks the OK button
in the Save File dialog box.
</OL>

<A NAME="PAGENUM-296"><P>Page 296</P></A>


<OL START="4">
<LI>          A new FileOutputStream object is created with a reference to the selected file.
<LI>     The FileOutputStream object streams the contents of the current editor to the
new file.
</OL>

<P>When the user wants to create a new editor window, the following steps occur:
</P>
<OL>
<LI>          The user selects New Frame from the File menu.
<LI>     A new instance of the editor class is created and displayed.
</OL>

<P>Due to the fact that you will be taking advantage of the application frame work
developed in Chapter 6, many aspects related to the application have already been developed.
These aspects include:
</P>

<UL>
<LI>          The menu structure
<LI>          Methods for creating Open and Save dialog boxes
<LI>          Event handling methods
</UL>
<P>
<B>
Deciding on the Class Structure
</B>
</P>
<P>Having covered the features present in the application, and also the manner in which
those features are implemented, let's take a look at the classes that will be developed.
</P>

<P>A class called TextEditor extends the FrameWork class developed in Chapter 6, and
adds functionality to complete the user interface (UI), and stream to and from the disk.
</P>

<P>A class called IndustrialEditor simply contains a main() method, and in that
method creates a new instance of the TextEditor class.
</P>

<P>In addition to the two new classes developed for this application, the FrameWork
and ModalOK classes are used. These classes are part of the application frame work
developed in Chapter 6, and are not reprinted in this chapter.
</P>
<B>
Implementing the TextEditor Class
</B>
</P>

<P>Listings 9.13a through 9.13n contain the code for the
TextEditor class. Note how you benefit from the FrameWork call in that little work is spent on the UI and event handling.
</P>

<P>The code present in listing 9.13a contains the two constructors supported by
the TextEditor class. Both accept a title to be displayed in the title bar of the new editor,
and the second accepts an additional parameter to be used as initial text for the editor.
This second constructor is used when opening a new file, and is passed the complete file
as String object.
</P>

<P><CENTER>
<a href="0290-0293.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0297-0301.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



