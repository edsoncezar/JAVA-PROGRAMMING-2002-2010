<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0294-0296.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0302-0305.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-297"><P>Page 297</P></A>







<P>Listing 9.13a Building a Basic Text Editor in Java

</P>


<PRE>

package industrial;



import java.awt.*;

import java.io.*;





//Class TextEditor a basic text editor which knows how to write itself

//to disk and also how to create a new instance of itself with data

//loaded from disk.

public class TextEditor extends FrameWork {

      //the TextArea where information will be entered

      private      TextArea      theArea;



      //Constructor creates a new empty TextEditor, with title &quot;title&quot;.

      public TextEditor(String title) {

            super(title);



            //create the text area

            theArea = new TextArea(30, 55);



            //build the screen

            this.setLayout(new BorderLayout());

            this.add(&quot;Center&quot;, theArea);



            //display the screen

            this.pack();

            this.show();

      }





      //Constructor creates a new TextEditor with contents initialText

         //(usually read from disk). And tittle matching the file path

      //(title).

      public TextEditor(String title, String initialText) {

            super(title);



            //create the text area

            theArea = new TextArea(initialText, 30, 55);



            //build the screen

            this.setLayout(new BorderLayout());

            this.add(&quot;Center&quot;, theArea);



</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-298"><P>Page 298</P></A>







<P>Listing 9.13a Continued

</P>




<PRE>

            //display the screen

            this.pack();

            this.show();

      }



</PRE>




<P>Listing 9.13b contains three methods&#151;createNewFrame(),

createSaveDialog(), and createOpenDialog()&#151;all of which override associated methods in the FrameWork

class, and are called when the user chooses either New Frame, Save, or Open from the

File menu.

</P>



<P>Listing 9.13b createNewFrame(), createSaveDialog(), and createOpenDialog()

</P>




<PRE>

      //createNewFrame() overrides createNewFrame() in FrameWork

      public void createNewFrame(String title) {

            System.out.println(&quot;does this ever get called\n&quot;);

            TextEditor myNewTextEditor = new TextEditor(&quot;Untitled&quot;);

      }





      //createSaveDialog() overrides createSaveDialog() in FrameWork,

      //however that method is still called via a super.xxx

      //reference. In FrameWork the is still called via a super.xxx

      //Here we take the selected file, create a full path to the file

      //and pass that path to saveTo() where the file is

      //actually streamed out.

      public void createSaveDialog() {

            super.createSaveDialog();

            String pathName = mySaveDialog.getDirectory();

            pathName +=  System.getProperty(&quot;file.separator&quot;);

            pathName += mySaveDialog.getFile();

            this.saveTo(pathName);

      }





      //createOpenDialog() overrides createOpenDialog() in FrameWork,

      //however that method is still called via a super.xxx reference.

      //In FrameWork the actual open dialog is created. Here we take the

      //selected file, create a full path to the file and pass that

      //path to openNew() where the file is actually streamed in.

      public void createOpenDialog() {

</PRE>






<A NAME="PAGENUM-299"><P>Page 299</P></A>






<PRE>

            super.createOpenDialog();

            String pathName = myOpenDialog.getDirectory();

            pathName += System.getProperty(&quot;file.separator&quot;);

            pathName += myOpenDialog.getFile();

            this.openNew(pathName);

      }



</PRE>




<P>Listing 9.13c contains two private helper methods called by createSaveDialog(),

or createOpenDialog(). The openNew() method (called by createOpenDialog()) is passed as

</P>



<P>a parameter a file path and creates a new editor which displays the contents of the

file located at the file path passed as a parameter. The

saveTo() method (called by createSaveDialog()) is passed as a parameter a file path, and saves the contents of

the current editor to that file. (Note that the &Acirc;

symbol indicates the line normally fits on the previous line.)

</P>



<P>Listing 9.13c Two Private Helper Methods Called by createSaveDialog() or

createOpenDialog()

</P>




<PRE>

      //is called by createSaveDialog(), and is passed a file path as a

      //parameter. The file path is used to create a new

      //FileOutputStream and the contents of the current editor are

      //written to the file

      private void openNew(String pathName) {

            try{      FileInputStream myFileStream = new

               &Acirc;FileInputStream(pathName);

                        DataInputStream myStream = new

                                  &Acirc;DataInputStream(myFileStream);



                        String newString = new String();

                        while(myStream.available() &gt; 0) {

                              newString += myStream.readLine();

                              newString += &quot;\n&quot;;

                        }



                        TextEditor newTextEditor = new TextEditor

                        &Acirc;(pathName,newString);

                              myStream.close();

                        myFileStream.close();

                  }

            catch(IOException ioe) {

                  ModalOK theModalOK = new ModalOK(this, &quot;Error, could

</PRE>


<PRE>
continues
</PRE>






<A NAME="PAGENUM-300"><P>Page 300</P></A>







<P>Listing 9.13c Continued

</P>




<PRE>

                not create new file&quot;);

            }

      }

      //is called by createOpenDialog(), and is passed a file path as a

      //parameter. The file path is used to create a new FileInputStream

      //and from that stream the contents of the file are read in and

      //used to create a new editor.

      private void saveTo(String pathName) {

            try{      FileOutputStream myFileStream = new

               &Acirc;FileOutputStream(pathName);

                        DataOutputStream myStream = new

                              &Acirc;DataOutputStream(myFileStream);



                        myStream.writeChars(theArea.getText());

                        myStream.close();

                        myFileStream.close();

                  }

            catch(IOException ioe) {

                  ModalOK theModalOK = new ModalOK(this, &quot;Error, could

                 &Acirc;not create new file&quot;);

            }

      }

}

</PRE>




<P>

<B>

Implementing the IndustrialEditor Class

</B>

</P>

<P>At this point you have already developed most of the application. All that is left to do

is write the IndustrialEditor class. This class simply contains a main method and creates

a new instance of the TextEditor class. The class is listed in listing 9.14.

</P>



<P>Listing 9.14 A Driver for the IndustrialEditor Application

</P>


<PRE>

import industrial.TextEditor;



public class IndustrialEditor {



      public static void main(String[] args) {

               TextEditor myTextEditor = new TextEditor(&quot;Untitled&quot;);

      }

}

</PRE>




<A NAME="PAGENUM-301"><P>Page 301</P></A>







<H3><A NAME="ch09_ 18">

Filtering Streams

</A></H3>



<P>Recall the statement from the beginning of the chapter that you often will want to

use more than one stream class to achieve optimal results. This section introduces two

stream classes, FilterInputStream and FilterOutputStream, that effectively sit on top of an

existing stream to enhance functionality. What occurs when a

filter stream (a child class of either FilterInputStream or FilterOutputStream) is used, is that the filter stream manipulates

the data heading towards the underlying stream. For example, the filter

stream LineNumberInputStream sits on top of any InputStream, and allows access to the data

in the underlying InputStream one line at a time.

</P>



<P>FilterInputStream and FilterOutputStream introduce little functionality

themselves, however seven child classes implement extensive functionality. The following

child classes are fully discussed in this section:

</P>



<UL>

<LI>          BufferedInputStream and BufferedOutputStream

<LI>          DataInputStream and DataOutputStream

<LI>          LineNumberInputStream

<LI>          PushBackInputStream

<LI>          PrintStream

</UL>



<P>First, however, FilterInputStream and FilterOutputStream are covered.

</P>



<P>If you take a look at the API listings in listings 9.15 and 9.16 for FilterInputStream

and FilterOutputStream, you will see the methods and constructors made available by

these classes. Of special note are not the methods (as nothing new is really provided) but

the constructors that accept a stream as a parameter. By providing a constructor which

accepts a stream as a parameter, that stream passed in becomes the underlying stream which

has its data manipulated by the filter stream.

</P>



<P>Listing 9.15 The Java API Listing for java.io.FilterOutputStream

</P>


<PRE>

public class java.io.FilterOutputStream extends java.io.OutputStream {

    //Fields

    protected OutputStream out;



    //Constructors

    public FilterOutputStream(OutputStream out);



</PRE>


<PRE>
continues
</PRE>






<P><CENTER>

<a href="0294-0296.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0302-0305.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







