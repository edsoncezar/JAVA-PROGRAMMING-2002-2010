<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0277-0280.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0285-0289.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-281"><P>Page 281</P></A>



<B>
Skipping Ahead
</B>

<P>The skip() method is useful if you need to read in only part of
a stream and want to parse out the useless data
while reading, instead of afterward. This method skips over
n number of bytes along the stream (where n is passed as a long). If
n + the current position is greater than b.length, then
n defaults to b.length&#151;the current position. In all cases, the return value is the actual number of
bytes actually skipped over.
</P>

<B>
Moving Back and Forth along a Stream
</B>

<P>You will find the mark and reset methods extremely useful.
Where the skip() method enables you to simply jump
n bytes in one direction, these methods enable you to return to a specific part of
the stream. Simply position yourself at a point along the stream
(using the read() or skip() methods), and then call the mark() method.
To return to that position, simply call the reset() method.
</P>

<P>Where the skip() method was stated to be useful when moving
past a set of unwanted data in a stream, often the data needed is
not placed in the stream in a linear fashion. For this reason, the
mark() and reset() methods allow you to read in parts of a stream, which
are not stored in a linear fashion.
</P>

<P>A demonstration of the mark() and reset() methods is provided
in the following listing. The code here will read
in data from one stream into two byte arrays. After all lines have been executed,
both arrays will contain identical data. Note that InputStream is
an abstract class, and the stream, in, used in this listing is understood
to be an instance of a class that extends InputStream. Listing 9.2
leaves b1 and b2 with the same information.
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If it has been a while since you played around with
arrays, remember that the variable &quot;length&quot;
is the total number of objects (or base types) that can be stored
in that array. Because arrays are zero indexed, the array
is bounded from 0 to length _1.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Not all stream classes provide an implementation of the
mark() and reset() methods. To test whether a specific class
sup-     ports this method, simply call the
markSupported() method which returns a Boolean true if
the mark() and reset() methods are supported. If for
some reason you are using a stream class which does not
support these two methods, and their functionality is needed, you
will have to subclass the stream and implement the methods yourself.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-282"><P>Page 282</P></A>



<P>Listing 9.2 Using the mark() and reset() Methods to Create Two Arrays with
Identical Data
</P>

<PRE>
//declare two arrays to house data
byte b1[] = new byte[MAXBYTES];
byte b2[] = new byte[MAXBYTES];

//move forward along the stream
in.skip(42);

//read in data
in.mark();
in.read(b1);
in.reset();
in.read(b2, 0, MAXBYTES);
</PRE>
<P>
<B>
Checking What's Left
</B>
</P>
<P>Just so you don't feel that it wasn't left out, coverage of the
available() method is provided. As its title implies, this method returns the total number of bytes that can be
read from the stream.
</P>

<B>
Returning Allocated Resources
</B>

<P>When you create an instance of a stream object, that stream is automatically
&quot;opened.&quot; Because Java supports automatic garbage collection, a logical conclusion would be
that after you are finished with the stream, the resources allocated to that stream are returned
to the system. This conclusion, although logical, unfortunately is untrue. The
garbage collector will at some point get around to calling a stream's
finalize() method, which releases allocated system resources. However, because the garbage collector runs on a
low priority thread, this &quot;return of allocated resources&quot; can take a very long time.
To ensure rapid return of allocated resources, call a stream's close() method after you are
finished with that stream.
</P>

<H4><A NAME="ch09_ 5">
OutputStream
</A></H4>

<P>The abstract class OutputStream acts as the complement to the abstract class
InputStream. It is subclassed by various classes to enable the writing of data to a stream. Listing
9.3 contains the API listing for the class, and full descriptions of the methods follow.
</P>


<A NAME="PAGENUM-283"><P>Page 283</P></A>



<P>Listing 9.3 Java API's java.io.OutputStream
</P>

<PRE>
public abstract class java.io.OutputStream extends java.lang.Object {
    //Constructors
    public OutputStream();

    //Methods
    public void close();
    public void flush();
    public void write(byte b[]);
    public void write(byte b[], int off, int len);
    public abstract void write(int b);
}
</PRE>
<P>
<B>
Writing to a Stream
</B>
</P>
<P>Just as InputStream provides three versions of read(), OutputStream provides
three methods for writing out data. Review the listing 9.3 and note that the three
write() methods are used for outputting data.
</P>

<B>
Writing One Byte at a Time
</B>
<P>All three write() methods write out data in the form of a byte; the method
write(b), however, accepts b as an int. This is not a bug, but a feature. Because many byte
operations render the byte an int, the method was designed this way. Of course, only the lower
8 bits of the int are passed along, and the upper 24 are discarded.
</P>
<B>
Writing Groups of Bytes
</B>

<P>The other two versions of write() output data passed in as a byte array; write(byte
b[]) outputs the entire b.length bytes to the stream; &quot;write(byte b[], int off, int len)&quot;
enables you to be more specific about which part of the array you want to output. The
method attempts to write from b[off] to b[off+len] (inclusive). If off+len is greater than
b.length, then len defaults to b.length - off.
</P>

<B>
Getting Rid of Unwanted Data
</B>

<P>The flush() method takes any bytes left in the buffer and writes them to the stream.
</P>

<B>
Returning Allocated Resources
</B>

<P>As with InputStream, the close() method, although often neglected, is a very
important method. If this method is not called on an OutputStream when you are finished with it,
the
</P>

<A NAME="PAGENUM-284"><P>Page 284</P></A>



<P>used resources remain in use for a while. At some point the garbage collector will
get around to freeing up those resources, but it could take a while. It is crucial when
writing an application to be frugal when using memory and associated system resources. If
you are not frugal, it is possible that your application will prematurely run out of
memory while running. Depending on the operating system, this could either cause the
application to shut down or crash the computer. Using the close() method after you are finished with
a stream helps to return memory to the application.
</P>

<H4><A NAME="ch09_ 6">
Extending InputStream and OutputStream
</A></H4>

<P>Having a grasp of the methods provided by the InputStream and OutputStream classes
is the key to understanding all other stream classes because most other stream
classes subclass InputStream or OutputStream.
</P>

<P>The following sections present discussions on the various stream classes that
subclass InputStream and OutputStream. Each section both discusses the manner in which the
child class manages the abstract methods in either InputStream or OutputStream, and also
new methods introduced by the child class.
</P>

<P>As was stated previously, many stream classes occur in pairs; one for input and one
for output. In some cases only one half of that pair is provided. The following sections
first present the classes that have I/O pairs, then the classes that stand alone. If you ever
feel that a discussion on a class does not cover a specific method, note that the coverage
is actually there, though it may be hidden. Classes often do not change the purpose
of inherited methods, and thus a definition of the method can be found among that
class's ancestors.
</P>

<H3><A NAME="ch09_ 7">
Using PipedOutputStream and <BR>PipedInputStream
</A></H3>

<P>Piped streams enable two threads to communicate with each other. A
PipedOutputStream fills a &quot;pipe&quot; with some information, then a PipedInputStream reads that data back
out. The term &quot;pipe&quot; refers to a common location in memory accessed by two different
classes. Listing 9.4 provides the API listing for PipedOutputStream. Listing 9.5 provides the
API listing for PipedInputStream. Each class is discussed in detail in the sections which
follow it.
</P>


<P><CENTER>
<a href="0277-0280.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0285-0289.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



