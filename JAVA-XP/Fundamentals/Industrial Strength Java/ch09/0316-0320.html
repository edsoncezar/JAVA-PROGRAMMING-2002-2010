<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0311-0315.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0321-0322.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-316"><P>Page 316</P></A>







<P>Listing 9.26 Continued

</P>


<PRE>

                        System.out.println(&quot;Current Line: &quot; +

                                                   &Acirc;lin.getLineNumber());

            }

           catch(FileNotFoundException fnfe) { System.out.println(&quot;err:&quot;

 &Acirc;+fnfe); }



      }

}

</PRE>




<P>Listing 9.27 contains the output generated by the application in listing 9.26.

</P>



<P>Listing 9.27 The LineNumberTest Application Output

</P>


<PRE><br>

Current Line: 0

Current Line: 5

</PRE>




<H3><A NAME="ch09_ 32">

Using the PushBackInputStream <BR>Class

</A></H3>



<P>The last filter class to get coverage is the PushBackInputStream class. This class

enables you to &quot;peek&quot; at a byte before you actually read it. This feature is helpful if (for

example) the desired set of data is marked by a particular identifying byte which precedes the

data set. Listing 9.28 shows the methods supported by this class.

</P>



<P>Listing 9.28 Java API's java.io.PushBackInputStream

</P>




<PRE>

public class java.io.PushBackInputStream extends

java.io.FilterInputStream

 {

    //Fields

    protected int pushBack;



    //Constructors

    public PushBackInputStream();

</PRE>






<A NAME="PAGENUM-317"><P>Page 317</P></A>






<PRE>

    //Methods

    public int available();

    public boolean markSupported();

    public int read();

    public int read(byte b[], int off, int len);

    public void unread(int n);

}

</PRE>




<P>Although all methods in the class PushBackInputStream are useful, the method

which makes this class stand out is unread(). unread() provides PushBackInputStream with

the ability to return a byte after deciding that the byte is not needed. For example, the

following code fragment will leave back the PushBackInputStream object, with the same data

it started with:

</P>




<PRE>

byte myByte = (byte)back.read();

back.unread(myByte);

</PRE>




<H3><A NAME="ch09_ 33">

Using the SequenceInputStream <BR>Class

</A></H3>



<P>Just as there are children of FilterInputStream that have no output counterparts, there

are children of InputStream that have no output counterparts, including

SequenceInputStream and StringBufferInputStream. As is the case with other streams not part of an I/O pair,

as the discussion below shows, the nature of the stream does not call for it to be part of an

I/O pair. This section discussed SequenceInputStream, and the following section

discusses StringBufferInputStream.

</P>



<P>SequenceInputStream enables you to &quot;chain&quot; together a series of InputStreams,

thus taking a disjoined set of input sources and combining them into one. Look at the Java

API listing for SequenceInputStream in listing 9.29. Notice that the two constructors accept

a series of InputStreams as parameters.

</P>



<P>Listing 9.29 Java API's java.io.SequenceInputStream

</P>




<PRE>

public class java.io.SequenceInputStream extends java.io.InputStream {

    //Constructors

    public SequenceInputStream(Enumeration e);

    public SequenceInputStream(InputStream is1, InputStream is2);

</PRE>


<PRE>
continues
</PRE>




<A NAME="PAGENUM-318"><P>Page 318</P></A>







<P>Listing 9.29 Continued

</P>




<PRE>

    //Methods

    public void close();

    public void read();

    public void read(byte b[], int pos, int len);

}

</PRE>




<P>As stated above, it is the constructors that make this class so useful. As shown below,

the constructors allow InputStream to be chained together.

</P>



<UL>

<LI>          SequenceInputStream(Enumeration e) accepts an Enumeration object, and

chains together all InputStreams contained within that object. The Enumeration

class&#151;contained in the java.util p