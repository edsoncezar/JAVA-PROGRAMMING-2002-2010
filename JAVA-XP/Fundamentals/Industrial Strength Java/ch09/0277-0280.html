<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="..\ch08\0275-0276.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0281-0284.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-277"><P>Page 277</P></A>

<H3><A NAME="ch09_ 1">
Chapter 9
</A></H3>

<H2>

Input/Output: Using <BR>Streams

</H2>

<P>All I/O in Java is handled through something called a stream. A
stream is a one-way path along which data may travel. Most stream classes come in pairs&#151;one for
input and one for output.
</P>

<P>One of the most attractive aspects of I/O in Java is that it is very easy to implement
and maintain, due to the following features of the language:
</P>

<UL>
<LI>          Separation of input and output methods into different classes
<LI>          Portability between different data sources and destinations
</UL>

<P>The separation of output methods from input methods aids I/O development in that
it ensures that potential errors are flagged as compile-time and not run-time errors. As
was stated previously, I/O classes exist as pairs; one half of that pair takes care of output,
and the other half takes care of input. Therefore any attempt to read data from an output
stream would result in a compile-time error, which is significantly easier to track down
when compared to a run-time error.
</P>

<P>The second manner in which Java facilitates I/O involves portability between one
communication source or destination and another. In many languages, I/O is defined in
very limited (and platform-dependent) terms. In a language where I/O is defined in such
strict
</P>


<A NAME="PAGENUM-278"><P>Page 278</P></A>


<P>terms, it can be difficult to alter the source or destination of an existing I/O
configuration. Not so in Java. In fact, it is amazingly easy to take a piece of code that reads in data from
a remote file and make some alterations so that same piece of code reads in data from
a remote database.
</P>

<H3><A NAME="ch09_ 2">
Visualizing Streams: Choosing the <BR>Right Stream for Your Application
</A></H3>

<P>Knowing the Java API inside and out is not enough if you want to develop
powerful applications. It is essential that you fully understand OOP and the minute details of
the Java language. Another key element is the ability to take your knowledge of OOP and
Java and apply that knowledge to solve a problem. Java provides streams as an easy I/O
tool, but also provides a wide variety of stream classes from which to choose. The phrase
&quot;wide variety&quot; translates to 22, and with so many to choose from, confusion is likely.
</P>

<P> A common problem when developing with streams is to misunderstand the stream
classes and to choose a stream class that is not optimal for your situation. This does not
necessarily imply that your application will produce incorrect results, but it does mean that you
are not choosing the easiest manner to solve a problem.
</P>

<P>As is implied by the previous paragraph, choosing the best stream is not always easy
to do. This chapter covers the use of each class and builds an application that
demonstrates their use. When you finish studying this chapter, you will have a detailed understanding
of all classes and have little trouble picking the correct one for your applications.
</P>

<H3><A NAME="ch09_ 3">
Starting at the Top: InputStream <BR>and OutputStream
</A></H3>

<P>As illustrated by figure 9.1, almost all stream classes extend either of the abstract
classes, InputStream and OutputStream.
</P>
<A NAME="PAGENUM-279"><P>Page 279</P></A>



<P><a href="images\ch09fg01.jpg"><img src="images\tn_ch09fg01.jpg"></a><BR>
Figure 9.1
The java.io
class tree.
</P>

<P>Note that all classes are part of the java.io package, and extend off InputStream
and OutputStream.
</P>

<H4><A NAME="ch09_ 4">
InputStream
</A></H4>

<P>The class InputStream is the abstract base class from which all input stream
classes extend. Listing 9.1 contains the API listing for the class, and full descriptions of
the methods follow.
</P>

<P>Listing 9.1 API's java.io.InputStream
</P>
<PRE>
public class java.io.InputStream extends java.lang.Object {
    //Constructors
    public InputSream();

    //Methods
    public int available();
    public void close();
    public void mark(int readlimit);
public boolean markSupported();
    public abstract int read();
    public int read(byte b[]);
    public int read(byte b[], int off, int len);
    public void reset();
    public long skip(long n);
}
</PRE>

<A NAME="PAGENUM-280"><P>Page 280</P></A>



<B>
Reading in Data
</B>

<P>It is relatively obvious in listing 9.1 that the three
read() methods facilitate the reading in of data. Although their names make their purpose obvious, their signatures can be
slightly puzzling. All read() methods read in data one byte at a time, and all have &quot;int
return value;&quot; where the return value is _1 when the end of stream is reached. Taking this
into account, the method defined as &quot;public int read()&quot; is rather confusing. If data is read in
as a byte, then why is that byte returned as an int? Because the range of values available
to bytes is 0 to 255 (inclusive), and the range of values available to ints is 2,147,483,648
to 2,147,483,647 (inclusive), int has enough &quot;room&quot; to contain the value of a byte. The
extra space needed for an int is used to allow the end-of-stream _1 return value. Therefore it
is true to state that the value of the int returned by the read() method will always be
between _1 and 255 (inclusive), with the value of _1 occurring only when the stream no
longer contains any data.
</P>

<B>
Reading Data One Byte at a Time
</B>

<P>Reading in data one byte at a time is handled by the method defined as &quot;public abstract <BR>
int read()&quot;. Often this method is used in a loop to read in all data present in a stream.
For example, the following code will read all data present in the stream &quot;incoming&quot; and
app-     end it to a String object.
</P>

<PRE>
int tempInt;
String total = new String();
while((tempInt = incoming.read()) != -1) {
    total += tempInt;
}
</PRE>

<P>Note that while in the InputStream class, this method is abstract&#151;any child class
will provide an implementation.
</P>

<B>
Reading Data Into an Array
</B>

<P>The read() methods defined with byte arrays in their signatures read in data directly to
the array defined as b. In the case of the first method (defined
as read(byte b[])), the method attempts to fill the entire array with bytes from the stream. If the end of stream is
reached before the array is filled, the call only fills the array until that end is reached. The
return value is the total number of bytes read into the buffer, or _1 if the end is reached
prematurely. The second read method (defined as &quot;read(byte b[], int off, int len)&quot;) reads data
into the array starting at b[off] and ending at b[off+len]. If off+len is greater than b.length,
len defaults to b.length-off (defined as &quot;read(byte b[], int off, int len)&quot;).
</P>


<P><CENTER>
<a href="..\ch08\0275-0276.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0281-0284.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



