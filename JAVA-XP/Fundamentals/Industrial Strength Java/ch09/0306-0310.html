<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0302-0305.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0311-0315.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-306"><P>Page 306</P></A>



<H4><A NAME="ch09_ 21">
Reading and Writing Chars
</A></H4>

<P>Reading and writing of the primitive type char is facilitated with the following methods:
</P>

<UL>
<LI>          readChar(),
which reads the next char in the stream and returns it
<LI>          writeChar(int v),
which writes v to the underlying stream
<LI>          writeChars(String s),
which writes the String s to the underlying stream
</UL>

<H4><A NAME="ch09_ 22">
Reading and Writing Booleans
</A></H4>

<P>The Boolean primitive type can have a value of either true or false, allowing
applications to perform logical computations. Reading and writing of Booleans using
the DataOutputStream and DataInputStream classes is handled by the following methods:
</P>

<UL>
<LI>          readBoolean(),
which reads a Boolean from the stream and uses that value as
its return value
<LI>          writeBoolean(Boolean v),
which writes v to the stream
</UL>

<H4><A NAME="ch09_ 23">
Reading and Writing the short, int, and long <BR>Primitive Types
</A></H4>

<P>The reading and writing of signed 2-byte short integers (short data type) is facilitated
by the following methods:
</P>

<UL>
<LI>          readShort(),
which reads in the next short and returns it as the method return value
<LI>          writeShort(short s),
which writes s to the underlying stream
</UL>

<P>The reading and writing of signed 32-bit integers (int data type) is facilitated by
the following methods:
</P>

<UL>
<LI>          readInt(),
which reads the next int in the stream and returns this int as the
method's return value
<LI>          writeInt(int n),
which writes n to the underlying stream
</UL>

<P>The reading and writing of signed 64-bit long integers (long data type) is facilitated by
the following methods:
</P>

<UL>
<LI>          readLong(),
which reads the next long in the stream and returns this int as
the method's return value
<LI>          writeLong(long n),
which writes n to the underlying stream
</UL>

<A NAME="PAGENUM-307"><P>Page 307</P></A>





<H4><A NAME="ch09_ 24">
Reading and Writing Floats and Doubles
</A></H4>

<P>The reading and writing of the float data type is handled by the following methods:
</P>

<UL>
<LI>          readFloat()
which reads the next float in the stream and returns that float as
the method return value
<LI>          writeFloat(float
f) which writes f to the underlying stream.
</UL>

<P>The reading and writing of double precision floating point numbers handled by
the following methods:
</P>

<UL>
<LI>          readDouble()
which reads the next double in the stream and returns that double
as the method return value
<LI>          writeDouble(double d)
which writes d to the underlying stream
</UL>

<H4><A NAME="ch09_ 25">
Reading and Writing Data in Unicode<BR>
Transmission Format
</A></H4>

<P>The Unicode Transmission Format (UTF) is a standard for encoding 16-bit
Unicode characters in 8-bit bytes. Even though the Unicode characters are represented with
16-bits inside the Virtual Machine, many Operating Systems do not allow for 16-bits storage.
For this reason, the UTF is often used to make Unicode data more portable.
</P>

<P>Reading and writing of data using the UTF is managed with the following methods:
</P>

<UL>
<LI>          readUTF(DataInput r)
which reads data from r, and returns it as a String object.
<LI>          writeUTF(String w)
which writes w to the underlying stream in UTF.
</UL>

<H4><A NAME="ch09_ 26">
Putting I/O Classes to Work
</A></H4>

<P>Having covered the DataInputStream and DataOutputStream, it is time to use the
material in an actual application. Actually, if you remember the text editor application developed
in listings 9.13 and 9.14, you will remember that although not discussed, these classes
were used in conjunction with FileInputStream and FileOutputStream.
</P>

<P>Listing 9.19 contains a small application that opens a file, writes an int to it, reads that
int back in, adds one to the int, and prints the result. In this application the readInt()
and writeInt() methods are used to access the ints.
</P>

<A NAME="PAGENUM-308"><P>Page 308</P></A>



<P>Listing 9.19 An Application that Demonstrates Filter Streams
</P>
<PRE>
import java.io.*;

public class filterDemo {

      public static void main(String args[]) throws IOException {
            try{
                  FileInputStream       fin        = new
                &Acirc;FileInputStream(&quot;data.txt&quot;);
                  FileOutputStream      fout       = new
                &Acirc;FileOutputStream(&quot;data.txt&quot;);

                  DataInputStream       din        = new
               &Acirc;DataInputStream(fin);
                  DataOutputStream      dout       = new
               &Acirc;DataOutputStream(fout);

                  int                   myInt      = 41;
                  int                   tempInt    = 0;

                  dout.writeInt(myInt);
                  tempInt = din.readInt();
                  tempInt++;

                  System.out.println(&quot;The meaning of life is: &quot;+
                                       &Acirc;tempInt);
            }
              catch(FileNotFoundException fnf)
                              &Acirc;{ System.out.println(&quot;err:&quot;+ fnf); }
      }
}
</PRE>

<H3><A NAME="ch09_ 27">
Using Buffered Streams
</A></H3>

<P>Two additional filter streams are BufferedInputStream and BufferedOutputStream
which work to help improve I/O efficiency. Often used with File streams, these streams
were designed as a work-around for slow read and write methods. They function by filling
a &quot;buffer&quot; with your data and by only reading or writing when that buffer is full. Your
data reaches its destination eventually, but only in big chunks rather than of byte by byte.
This is done because it is, for example, much faster to read and write 512 bytes at once than
it is 1 byte 512 times.
</P>

<A NAME="PAGENUM-309"><P>Page 309</P></A>



<P>As with all stream discussions, first you will have a moment to look over the API
listing for BufferedInputStream and BufferedOutputStream, then the manner in which the
class used is discussed. Listing 9.20 contains the Java API listing for BufferedOutputStream.
</P>

<P>Listing 9.20 The Java API Listing for java.io.BufferedOutputStream
</P>

<PRE>
public class java.io.BufferedOutputStream extends
 &Acirc;java.io.FilterOutputStream {
    //Fields
    protected byte buf[];
    protected int count;

    //Constructors
    public BufferedOutputStream(OutputStream out);
    public BufferedOutputStream(OutputStream out, int size);

    //Methods
    public void flush();
    public void write(byte b[], int off, int len);
    public void write(int b);
}
</PRE>

<P>Listing 9.21 contains the API listing for the class BufferedInputStream. This class
allows for data to be read in as one large &quot;chunk&quot; instead of byte by byte.
</P>

<P>Listing 9.21 The Java API Listing for java.io. BufferedInputStream
</P>

<PRE>
public class java.io.BufferedInputStream extends
 &Acirc;java.io.FilterInputStream{
    //Fields
    protected byte buf[];
    protected int count;
    protected int marklimit;
    protected int markpos;
    protected int pos;

    //Constructors
    public BufferedInputStream(InputStream in);
    public BufferedInputStream(InputStream in, int size);

    //Methods
    public int available();
    public boolean markSupported();
</PRE>
<PRE>
												continues
</PRE>

<A NAME="PAGENUM-310"><P>Page 310</P></A>



<P>Listing 9.21 Continued
</P>

<PRE>
    public int read();
    public int read(byte b[], int off, int len);
    public void reset();
    public long skip(long n);
}
</PRE>

<P>In learning about the BufferedInputStream and BufferedOutputStream classes, you
will have little difficulty getting to know these classes well because of the level of
parallelism employed between these classes and other classes, as is discussed in the chapter.
</P>

<H4><A NAME="ch09_ 28">
Working with BufferedInputStream and <BR>BufferedOutputStream
</A></H4>

<P>BufferedInputStream and BufferedOutputStream are nice because they're so easy to
learn. Although data is read in slightly differently when compared to other streams covered
in this chapter, the method signatures are quite familiar, which means that just
like InputStream and OutputStream themselves, data is manipulated using the standard
read() and write() methods. The only difference between the API for
BufferedInputStream/ BufferedOutputStream and InputStream/OutputStream exists in their constructors.
Being the smart reader you are, you have just guessed that it is in the constructors
for BufferedInputStream and BufferedOutputStream that the size of the internal data buffer
is set.
</P>

<P>The following constructors are used by BufferedInputStream and BufferedOutputStream.
</P>

<UL>
<LI>          BufferedInputStream(InputStream in), BufferedOutputStream(OutputStream out)
<LI>          BufferedInputStream(InputStream in, int
size), BufferedOutputStream(OutputStream out, int size)
</UL>

<P>Using the constructor for either class, which takes only one parameter, will allocate
a buffer to hold 512 bytes. However you desire to change the buffer size, simply use
the second constructor which accepts as an additional parameter, an int, and uses the value
of this int to allocate the buffer size.
</P>

<P>To demonstrate the difference between file access with a BufferedOutputStream, you
will develop an application which benchmarks writing to a file with simply
a FileOutputStream, and then with a BufferedOutputStream working with a
FileOutput-
</P>


<P><CENTER>
<a href="0302-0305.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0311-0315.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



