<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0281-0284.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0290-0293.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-285"><P>Page 285</P></A>


<P>
Listing 9.4 Java API's java.io.PipedOutputStream
</P>
<PRE>
public class java.io.PipedOutputStream extends java.io.OutputStream {
    //Constructors
    public PipedOutputStream();
    public PipedOutputStream(PipedInputStream snk);

    //Methods    public void close();
    public void connect(PipedInputStream snk);
    public void write(byte b[], int off, int len);
    public void write(int b);
}
</PRE>

<P>Where the class in listing 9.4 allows data to be written to a stream, PipedInputStream
in listing 9.5 will read it back out.
</P>

<P>Listing 9.5 Java API's java.io.PipedInputStream
</P>

<PRE>
public class java.io.PipedInputStream extends java.io.InputStream {
    //Constructors
    public PipedInputStream ();
    public PipedInputStream (PipedOutputStream src);

    //Methods
    public void close();
    public void connect(PipedOutputStream src);
    public int read(byte b[], int off, int len);
    public int read();
}
</PRE>

<H4><A NAME="ch09_ 8">
Forging a Connection
</A></H4>

<P>Because PipedInputStream and PipedOutputStream are reading and writing from the
same source, it is obvious that you need a connection between an instance of
PipedInputStream and an instance of PipedOutputStream. You can make the connection in two ways:
</P>

<UL>
<LI>          When instantiating the stream objects, using a constructor which accepts a
stream as a parameter
<LI>          After the stream objects are instantiated, using the connect() method
</UL>

<A NAME="PAGENUM-286"><P>Page 286</P></A>



<P>Listing 9.6 shows the different ways communication between a PipedOutputStream and
a PipedInputStream can be established. It should be noted that each example
produces exactly the same result.
</P>

<P>Listing 9.6 Two Ways to Establish a Connection between PipedStreams
</P>

<PRE>
//Establishing a connection using the constructors
PipedOutputStream out = new PipedOutputStream();
PipedInputStream in = new PipedInputStream(out);

//Establishing a connection using the constructors version 2
PipedInputStream in = new PipedInputStream();
PipedOutputStream out = new PipedOutputStream(in);

//Establishing a connection using the connect method
PipedInputStream in = new PipedInputStream();
PipedOutputStream out = new PipedOutputStream();
in.connect(out);

//Establishing a connection using the connect method version 2
PipedInputStream in = new PipedInputStream();
PipedOutputStream out = new PipedOutputStream();out.connect(in);
</PRE>

<H4><A NAME="ch09_ 9">
Communication Between the Streams
</A></H4>

<P>Because PipedOutputStream and PipedInputStream
subclass OutputStream and InputStream (respectively), all methods
made available to OutputStream and InputStream are made available
to PipedOutputStream and PipedInputStream. The processes
of sending and receiving data are managed by the same read and
write methods that were presented in the discussion of OutputStream
and InputStream. Listing 9.7 shows how you might use these methods
to communicate between streams. Note that to conserve space,
some code has been cut and is simply discussed in comments.<BR>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
It is essential that you understand that the purpose of
the PipedOutputStream and PipedInputStream classes is to
facilitate communication between threads. While one thread
is writing, the other is blocked from reading from that stream.
With the reverse true also, the means that it is
not possible for two classes to simultaneously read
and write to the same stream.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-287"><P>Page 287</P></A>





<P>Listing 9.7 Using PipedStreams to Communicate between Threads
</P>

<PRE>
class WriteData extends Thread {
     PipedOutputStream myPOS;
     public WriteData(PipedOutputStream POS) {
          myPOS = POS;
     }

     public void start() {
          //set up the Thread
     }

     pubic void run() {
          //write data to the PipedOutputStream
     }

public class UsePipeStreams {
     public static void main(String[] args) {
          try{
               PipedOutputStream out = new PipedOutputStream();
               PipedInputStream in = new PipedInputStream(out);
               WriteData myWriter = new WriteData(
out);
               myWriter.start();
               int theData;
               while((theData = in.read()) != 1) {
                    System.out.println((char)theData);
               }
          }
          catch(IOException ioe) { System.out.println(&quot;err: &quot;+ioe); }
     }
}
</PRE>

<H3><A NAME="ch09_ 10">
Using ByteArray Streams
</A></H3>

<P>The ByteArrayInputStream class and the ByteArrayOutputStream class enable arrays
of bytes to be used as the communication path between streams.
ByteArrayOutputStream writes a byte array to a stream, and ByteArrayInputStream reads it back. As with
other topics presented in the chapter, the methods present in the class are listed first, then
dis-     cussed in detail.
</P>

<A NAME="PAGENUM-288"><P>Page 288</P></A>



<H4><A NAME="ch09_ 11">
Using the ByteArrayOutputStream Class
</A></H4>

<P>Listing 9.8 contains the Java API listing for the class ByteArrayOutputStream.
</P>

<P>Listing 9.8 Java API's java.io.ByteArrayOutputStream
</P>

<PRE>
public class java.io.ByteArrayOutputStream extends java.io.OutputStream
 {
    //Fields
    protected byte buf[];
    protected int count;

    //Constructors
    public ByteArrayOutputStream();
    public ByteArrayOuputStream(int size);

    //Methods
    public void reset();
    public int size();
    public byte[] toByteArray();
    public String toString();
    public String toString(int hibyte);
    public void write(byte b[], int off, int len);
    public void write(int b);
    public void writeTo(OutputStream out);
}
</PRE>
<P>
<B>
Filling a ByteArrayOutputStream
</B>
</P>

<P>Inside a ByteArrayOutputStream object, data is stored in an array, which has the ability
to grow as new data is added. However, because it takes time to grow an array, it is
important that the space allocated originally for the array is close to what will be needed. Of
course in some situations, the amount of space needed is unknown, and in these cases a
best estimate will suffice. The initial storage capacity of a ByteArrayOutputStream object
is specified as a parameter to its constructor, and a default constructor is also provided.
</P>

<P>ByteArrayOutputStream() creates an array with room for 32 bytes; this array will grow
as needed. Again, because it takes time for the array to grow, situations that need more
than 32 bytes should use the second constructor, which enables you to specify the initial size
of the array. The following line, for example, creates a new ByteArrayOutputStream
with room for 42 bytes; of course, this array will resize if needed.
</P>

<PRE>
ByteArrayOutputStream  out = new ByteArrayOutputStream(42)
</PRE>

<A NAME="PAGENUM-289"><P>Page 289</P></A>



<P>After you have created an instance of ByteArrayOutputStream, you can fill it with
data. Not surprisingly, you can fill it with data using different versions of the
write() method. Because ByteArrayOutputStream subclasses OutputStream, its write() methods are
quite similar to those in OutputStream:
</P>

<UL>
<LI>          write(int b) writes b as a byte to the stream.
<LI>          write(byte b[], int off, int len) writes the data in the array b[] to the stream.
The parameter off specifies a start index, and the parameter len specifies the number
of entries in b[] which should be written. If out+len+1 is greater than the
total available bytes, only those from b[off] to b[(b.length - 1)] written out.
</UL>
<P>
<B>
Retrieving Data from a ByteArrayOutputStream
</B>
</P>
<P>You can retrieve information from a ByteArrayOutputStream with the
methods toByteArray(), toString(), and writeTo(). Listing 9.9 examines the usage of all the
methods discussed in the sections that follow and assumes there is a
ByteArrayOutputStream named &quot;out&quot; that is storing some data.
</P>

<P>Listing 9.9 Three Methods of Retrieving Data from a ByteArrayOutputStream
</P>
<PRE>
//Getting the information as a byte array
byte byteArray[] = new byte[ out.size() ];
byteArray = out.toByteArray();

//Getting the information as a String (two methods that
//produce identical results.
String myString = out.toString();
String myOtherString = out.toString(0);

//Passing the information to an output stream. Note that
//DataOutputStream will be covered later in this chapter, and
//is simply provided as an example.
DataOutputStream dos = new DataOutputStream();
out.writeTo(dos);
</PRE>
<P>
<B>
The toByteArray() Method
</B>
</P>

<P>The toByteArray() method returns a byte array containing the contents of the
current stream. The length of the array can be predetermined by referencing the size() method
of ByteArrayOutputStream. The following code is an example of this:
</P>

<P><CENTER>
<a href="0281-0284.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0290-0293.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



