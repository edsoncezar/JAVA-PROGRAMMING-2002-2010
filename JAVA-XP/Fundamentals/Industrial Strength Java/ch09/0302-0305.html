<HTML>

<HEAD>



<TITLE>Industrial Strength Java:Input/Output: Using Streams:EarthWeb Inc.-</TITLE>



















<P><CENTER>

<a href="0297-0301.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0306-0310.html">Next</A>

</CENTER></P>



<A NAME="PAGENUM-302"><P>Page 302</P></A>







<P>Listing 9.15 Continued

</P>




<PRE>

    //Methods

    public void close();

    public void flush();

    public void write(byte b[]);

    public void write(byte b[], int off, int len);

    public void write(int b);

}

</PRE>




<P>Moving on to listing 9.16 is the class FilterInputStream which will filter any child class

of InputStream.

</P>



<P>Listing 9.16 The Java API Listing for java.io.FilterInputStream

</P>


<PRE>

public class java.io.FilterInputStream extends java.io.InputStream {

    //Fields

    protected InputStream in;



    //Constructors

    protected FilterInputStream(InputStream in);



    //Methods

    public int available();

    public void close();

    public void mark(int readlimit);

    public boolean markSupported();

    public int read();

    public int read(byte b[]);

    public int read(byte b[], int off, int len);

    public void reset();

    public long skip(long n);

}

</PRE>




<P>After looking over listings 9.15 and 9.16, and by reading the introduction to filter

stream, you should have a tight grasp on this powerful concept. In your development you

will rarely use either FilterInputStream or FilterOutputStream by itself, due to the

few enhancements made at this level. Rather, you will use either one of its child classes,

or subclass it yourself to create a stream needed in an application you are building.

</P>



<P>Because the power of filter streams becomes obvious when studying child classes

of FilterInputStream and FilterOutputStream, detailed discussion is limited to these

child classes.

</P>



<A NAME="PAGENUM-303"><P>Page 303</P></A>







<H3><A NAME="ch09_ 19">

Using the DataOutputStream and <BR>DataInputStream Classes

</A></H3>



<P>Looking at the child classes of the filter streams reveals two very interesting

streams. Looking back through this chapter, you will note that all previously discussed

streams read and write data byte by byte. While it is functional to read and write data as a

byte, often your source or destination data will be in a different form. If you want to write

a series of long integers (long data type) to a stream, for example, you would have to do

this byte by byte, which is time consuming. The process would be much easier if there

were some way by which you could read and write those long integers directly as long integers.

</P>



<P>DataOutputStream and DataInputStream move away from the other stream classes

that can only read and write bytes to a stream, and add methods which read and write

all primitive types, along with String objects. Take a look at the listing for

DataOutputStream in listing 9.17 and listing 9.18 for DataInputStream. The listings are interesting as

the problem of reading and writing primitive types is solved.

</P>



<P>Listing 9.17 The Java API Listing for java.io.DataOutputStream

</P>




<PRE>

public class java.io.DataOutputStream extends java.io.FilterOutputStream

 &Acirc;implements java.io.DataOutput {

    //Fields

    protected int written;



    //Constructors

    public DataOutputStream(OutputStream out);



    //Methods

    public void flush();

    public final int size();

    public void write(byte b[], int off, int len);

    public void write(int b);

    public final void writeBoolean(boolean b);

    public final void writeByte(int v);

    public final void writeBytes(String s);

    public final void writeChar(int v);

    public final void writeChars(String s);

    public final void writeDouble(double v);

    public final void writeFloat(float f);

</PRE>


<PRE>
continues
</PRE>




<A NAME="PAGENUM-304"><P>Page 304</P></A>







<P>Listing 9.17 Continued

</P>




<PRE>

    public final void writeInt(int v);

    public final void writeLong(long l 0);

public final void writeShort(int v);

    public final void writeUTF(String s);

}

</PRE>




<P>Where the DataOutputStream class provides methods for writing primitive types,

the DataInputStream provides methods for reading primitive types. DataInputStream is

listed in listing 9.18.

</P>



<P>Listing 9.18 The Java API Listing for java.io.DataInputStream

</P>




<PRE>

public class java.io.DataInputStream extends java.io.FilterInputStream

 &Acirc;implements java.io.DataInput {

    //Constructors

    public DataInputStream(InputStream in);



    //Methods

    public final int read(byte b[]);

    public final int read(byte b[], int off, int len);

    public final boolean readBoolean();

    public final byte readByte();

    public final char readChar();

    public final double readDouble();

    public final float readFloat();

    public final void readFully(byte b[]);

    public final void readFully(byte b[], int off, int len);

    public final int readInt();

    public final String readLine();

    public final long readLong();

    public final short readShort();

    public final int readUnsignedByte();

    public final int readUnsignedShort();

    public final String readUTF();

    public final static String readUTF(DataInput in);

    public final int skipBytes(int n);

}

</PRE>




<P>Looking over listings 9.17 and 9.18, you should understand the potential that these

classes bring. In the following sections, you will learn how to use each method present in

Data-     InputStream and DataOutputStream.

</P>



<A NAME="PAGENUM-305"><P>Page 305</P></A>







<H4><A NAME="ch09_ 20">

Reading and Writing Bytes

</A></H4>



<P>As stated previously, the purpose of DataInputStream and DataOutputStream is to

read and write Java's primitive data types. In this section, you will learn about reading

and writing of bytes using DataOutputStream and DataInputStream. It should be noted

that even though most streams which will be &quot;filtered&quot; by either of these Data streams

provide support for reading or writing of bytes, this support was added to DataOutputStream

and DataInputStream as a matter of convenience. The methods used for writing bytes are

</P>



<UL>

<LI>          write(int b), which writes v as a byte to the stream

<LI>          write(byte b[], int off, int len), which writes from b[off] to b[len] to the stream

<LI>          writeByte(int v), which writes b as a byte to the stream

<LI>          writeBytes(String s), which writes the string s to the stream, discarding the

upper eight bits

</UL>



<P>The methods used from reading bytes back from the stream are

</P>



<UL>

<LI>          read(byte b[]), which fills b[] with data from the stream

<LI>          read(byte b[], int off, int len), which fills b[] from b[off] to b[len] with data

from the stream

<LI>          readByte(), which reads the next byte from the stream and uses that byte as

its return value

</UL>



<P>When studying the writeBytes() method, which writes a String object to the

underlying stream, it is important to note two additional methods used for reading that String

object back, as follows:

</P>



<UL>

<LI>          readLine(),

which reads in the first line and returns it as a String object. To

note here is that a line is defined as a series of characters terminated by a

carriage return, newline character, or a carriage return and a newline character. This

method was used to read in saved files in the text editor application developed earlier

in this chapter.

<LI>          readFully(byte b[], int off, int len),

which reads data into b[] from b[off] to b[off+len]

</UL>



<P><CENTER>

<a href="0297-0301.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0306-0310.html">Next</A>

</CENTER></P>











</BODY>
</HTML>







