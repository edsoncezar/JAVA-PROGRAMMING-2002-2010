<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Object-Oriented Programming:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0009-0012.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0017-0020.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-13"><P>Page 13</P></A>


<P><a href="images\ch02fg01.jpg"><img src="images\tn_ch02fg01.jpg"></a><BR>
Figure 2.1 The Contact object. Note the coverage and grouping of
all methods.
</P>

<P>streamEncoded(), is of particular interest because it provides a common method by
which other objects can get the entire contents of a Contact object.
</P>

<P>Before you try to comprehend the use of the streamEncoded() method, compare
this method to the manner in which web-based form submissions are managed.
</P>

<P>A user on a PC running Windows 3.11 hits a web page with the
AOL web browser, fills in a form, submits it, and has his results
processed in the same way that someone running Netscape Navigator under
SGI IRIX has her results processed. These identical results are a result
of the fact that although all browsers operate differently, they all
comply with certain standards. With form usage, these standards apply to
the manner in which the data is sent from browser to server. The user
does not need to have any knowledge of these inner workings; one
simply takes advantage of the fact that everything works correctly.
</P>

<P>The streamEncoded() method acts exactly the way that
form submissions do. Any object can ask a Contact object for its
entire contents, and the Contact object can stream its contents to the
object that requests the data.
</P>

<P>Additionally, there is a method in the Contact object called
register(). The underlying processes behind this method is detailed in
the next 
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Allowing for the existence of this method has
rather broad implications. If a standard method
for storing and retrieving contact data is formed, then not
only can the Contact object be used by this contact book, but
now they can also be used by other applications that need to manage
a contact file.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-14"><P>Page 14</P></A>


<P>section. For now simply understand that this method notifies
a global repository that a new Contact object has been instantiated
(or created).
</P>

<H4><A NAME="ch02_ 7">
Tracking Contact Objects
</A></H4>

<P>Although it is perfectly fine to have zillions of Contact objects existing in random
memory locations, they are practically useless if you can't track them. To track each Contact
object, you need to create a Registry object. The Registry object publishes a set of methods
by which various Contact objects can notify the Registry Object of their existence.
</P>

<P>The Registry object (see fig. 2.2) is notified by a Contact object
that the Contact object has been created. The Contact object
performs this notification (see the Note) by calling the
registerObject() method contained in the Registry object. This method accepts as
a parameter a reference to a Contact object. After this method
finishes executing, the Contact object passes a reference to itself so that
the Registry object can allow any object that it interacts with to
have access to a Contact object.
</P>

<P>You should pay special attention to the retrieve(), store(),
and delete() methods as described in the following list.
</P>

<UL>
<LI>     retrieve(). Enables the Registry object to search for
a specific object and return a reference to that object
to whomever has requested the object.
<LI>     store(). Enables the Contact references to be stored in
some manageable fashion.
<LI>     delete(). Enables the Registry object to remove a reference
to a specific Contact object.
</UL>

<H4><A NAME="ch02_ 8">
Building a Library of Contact Objects
</A></H4>

<P>Now that you can create and manage a large contact file, you need
to learn how to add and subtract from that file. Because addition
must come before subtraction, take a look at the AddContact object,
as shown in figure 2.3.
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The time when registration occurs is a topic that
merits discussion. Because a random object cannot find a Contact object
if it has not properly registered itself, it should be stated
that registration is the most important step taken during a
Contact object's existence. For this reason,
registration occurs during the execution of the Contact
object's constructor.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If you are confused by my descriptions don't worry. OOP can
be confusing, but a little time and practice are all that it takes to
gain a full understanding. This application should become
clear to you after the entire picture is complete.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-15"><P>Page 15</P></A>


<P><a href="images\ch02fg02.jpg"><img src="images\tn_ch02fg02.jpg"></a><BR>
Figure 2.3 The Registry object keeps track of all Contact objects.
</P>

<BR>

<P><a href="images\ch02fg03.jpg"><img src="images\tn_ch02fg03.jpg"></a><BR>
Figure 2.4 The AddContact object can accept use input and turn
this input into a Contact object.
</P>

<P>The AddContact object has a series of equally important
methods, which are discussed here in the order in which they are called.
First is the promptForInput() method, which draws a form to the
screen (see fig. 2.4) that prompts the user for information, such as
the
</P>


<A NAME="PAGENUM-16"><P>Page 16</P></A>


<P><a href="images\ch02fg04.jpg"><img src="images\tn_ch02fg04.jpg"></a><BR>
Figure 2.5 Using a form to collect data.
</P>

<P>contact's name, address, and phone and fax numbers.
</P>

<P>After the user has finished inputting the data and the
Add button has been clicked, the information contained in the form is submitted to the AddContact object. The
AddContact object in turn generates a Contact object.
</P>

<P>The form in figure 2.4 shows how the user can click the Add
button to transfer the information. In this application, the Add button
serves two purposes. First of all, it calls the checkForValidity() method 
to ensure that the user has entered valid information (for
example, did the user leave the name fields blank); next, it calls
the createNewContact() method. Without delving into too much
detail, the createNewContact() method grabs all information from
the current fields and uses it to create a new Contact object.
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You probably noticed that the AddContact object does
not interact with the Registry at all. This is an inherent aspect
of OOP. The AddContact object knows nothing of the Registry. In
this application, the registration process is the responsibility
of each individual Contact object.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>
<P>To recap, the classes that have been developed so far do the 
following:
</P>

<OL>
<LI>     Create new contacts.
<LI>     Act as the contacts themselves.
<LI>     Act as a global registry for all contacts.
<BR>          Having developed the above functionality, your contact
book is almost complete. However, three rather
important features still need to be implemented:

<UL>
<LI>      Deleting existing contacts
<LI>      Displaying a list of all contacts
</UL>
</OL>


<P><CENTER>
<a href="0009-0012.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0017-0020.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



