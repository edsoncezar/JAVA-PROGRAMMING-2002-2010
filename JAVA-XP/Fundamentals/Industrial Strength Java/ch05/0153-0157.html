<HTML>
<HEAD>


<TITLE>Industrial Strength Java:AWT Basics:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="0147-0152.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0158-0161.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-153"><P>Page 153</P></A>


<P>Listing 5.14Code to Scroll an Image Around a Frame
</P>

<PRE>
package industrial;
import java.awt.*;
import java.awt.image.*;
//Class ScrollingFrame. Will display an image and allow a user to scroll
//through it.
public class ScrollingFrame extends FileFrame implements ImageObserver {

       //GUI components
       private       Image               theImage;
       private       Scrollbar           hscroll;
       private       Scrollbar           vscroll;
       private       PictureCanvas       myCanvas;


       //constructor takes a String as a parameter which is used as the
       //title of the Frame
       public ScrollingFrame(String title) {
              setTitle(title);

              //get the Image
              theImage =
                             &Acirc;Toolkit.getDefaultToolkit().getImage(&quot;shaker.gif&quot;);

              //create the components
              myCanvas = new PictureCanvas(theImage);
              hscroll = new Scrollbar(Scrollbar.HORIZONTAL, 0, 0, 0, 100);
              vscroll = new Scrollbar(Scrollbar.VERTICAL, 0, 0, 0, 100);

              //place them on the screen
              setLayout(new BorderLayout());
              add(&quot;Center&quot;, myCanvas);
              add(&quot;South&quot;, hscroll);
              add(&quot;East&quot;, vscroll);
       }
</PRE>

<P>Listing 5.14b contains action()and handleEvent() methods. The handleEvent() method
is passed an Event object and based on the value of that object sets, tells the canvas
displaying the image to resize itself.
</P>


<A NAME="PAGENUM-154"><P>Page 154</P></A>


<P>Listing 5.14bUsing the action() and handleEvent() Methods
</P>

<PRE>
       //catch any events which would be passed to action
       public boolean action(Event evt, Object arg) {
              return super.action(evt, arg);
       }


       //catch scrollbar events. These would not be passed to action.
       public boolean handleEvent(Event evt) {
              if(evt.target == hscroll) {
                     myCanvas.setXOffset(((Integer)evt.arg).intValue());
                     repaint();
                     return true;
              }
              else if(evt.target == vscroll) {
                     myCanvas.setYOffset(((Integer)evt.arg).intValue());
                     repaint();
                     return true;
              }
              return super.handleEvent(evt);
       }

}
</PRE>

<P>The PictureCanvas class in listing 5.14c is the class that displays the image. It is passed
an Image object and first paints it to the screen at (0,0). When either of its offset variables
are changed (through a call to setYOffset() or setXOffset()), the picture will be redrawn at
the new coordinates. The code's result is shown in figure 5.9.
</P>

<P>Listing 5.14cUsing PictureCanvass to Display an Image
</P>

<PRE>
//a canvas which displays a picture. The point at which the picture is
//drawn can be altered.
class PictureCanvas extends Canvas {
       private       int         xOffset = 0;
       private       int         yOffset = 0;
       private       Image       myImage;

       //Constructor is passed an image to display
       public PictureCanvas(Image theImage) {
              myImage = theImage;
       }
</PRE>


<A NAME="PAGENUM-155"><P>Page 155</P></A>


<PRE>
       //alter the x position at which the image is drawn
       public void setXOffset(int x) {
              xOffset = x;
       }

       //alter the y position at which the image is drawn
       public void setYOffset(int y) {
              yOffset = y;
       }

       //paint the image, with regard to th offset variables. This gives us
       //the scrolling effect.
       public void paint(Graphics g) {
              g.drawImage(myImage, -xOffset, -yOffset, this);
       }
}
</PRE>

<P><a href="images\ch05fg09.jpg"><img src="images\tn_ch05fg09.jpg"></a><BR>
Figure 5.9 The ScrollingFrame class running under MacOS.
</P>

<H4><A NAME="ch05_ 15">
Open and Save Dialog Boxes
</A></H4>

<P>Stop for a second and take a breath. So far, this chapter has covered pretty much
every class in the AWT. Material was presented that demonstrated how to use components
by themselves, and other material was presented that demonstrated how to combine a
series of classes to form your own component. One other feature was previously presented
that was not covered in great detail&#151;opening and saving documents.
</P>

<P>Opening and saving documents is a rather tricky topic to discuss because each
application deals with the operations in unique ways. You have to make a lot of
application-specific decisions when you need to preserve the state of an the application.
</P>

<P>Listing 5.6, which introduced the FileFrame class, covered the code implementation
for creating an Open File dialog box and a Save File dialog box.
</P>

<A NAME="PAGENUM-156"><P>Page 156</P></A>


<P>Both types of dialog boxes are actually instances of the
FileDialog class where a parameter in the constructor indicates whether the dialog box should be for opening a new file
or for saving the current file. In addition to passing a mode to FileDialog when you create
a new instance, you also pass a dialog box title and a frame indicating the box's
owner. Listing 5.15 contains a snippet of code from listing 5.7 where the Open and Save
dialog boxes are actually created.
</P>

<P>Listing 5.15Code Used to Create Open and Save File Dialog Boxes
</P>

<PRE>
//create an open dialog
public void createOpenDialog() {
       FileDialog myDialog = new FileDialog(this, &quot;Open File&quot;,
              &Acirc;FileDialog.LOAD);
       myDialog.setDirectory(&quot;.&quot;);
       myDialog.setFile(&quot;openFile.txt&quot;);
       myDialog.show();
}

//create a save dialog
public void createSaveDialog() {
       FileDialog myDialog = new FileDialog(this, &quot;Save File As&quot;,
               &Acirc;FileDialog.SAVE);
       myDialog.setDirectory(&quot;.&quot;);
       myDialog.setFile(&quot;newFile.txt&quot;);
       myDialog.show();
}
</PRE>

<P>You will also note the additional methods in the
FileDialog class that enable you to set the default directory
(setDirectory()), and suggest a file name (setFile()). Of course,
because FileDialog extends Dialog, you must call its
show() method to actually get the dialog box to appear.
</P>

<H3><A NAME="ch05_ 16">
Layout Managers
</A></H3>

<P>As you probably noticed during the introduction of the code for the AWT demo
application, the setLayout() method was implemented. This method is passed an instance
of either GridLayout, GridBagLayout, CardLayout, BorderLayout, or FlowLayout. This
call tells the component in question which layout manager to use when building the
screen. The layout manager in turn tells the top-level component where to place components
on the screen.
</P>


<A NAME="PAGENUM-157"><P>Page 157</P></A>


<P>Those of you who are used to building screens in terms of pixels may be a bit
confused, but, as stated at the beginning of this chapter, a pixel-based layout system breaks
down when component size is unknown.
</P>

<P>The AWT presents five different layout managers that help you properly build
screens; unfortunately, they leave a lot to be desired. In fact, for most situations, you will find
that the GridBagLayout class is the only one that enables you to layout screens that meet
your specifications 100 percent of the time. Although powerful, GridBagLayout suffers
because it is often awkward and hard to learn.
</P>

<P>The following sections begin with basic coverage of each AWT layout managers, its
uses, and pros and cons. Then you will see a small application that demonstrates how
each layout manger deals with the same set of widgets.
</P>

<H4><A NAME="ch05_ 17">
FlowLayout
</A></H4>

<P>For most components, FlowLayout is the default layout manager; it is also the most
basic. It places components one right after another in a straight line. If it reaches the end of
the line, component layout simply continues on the next line down. The only time that
you will ever want to use this class is if you have a basic screen that only uses one or
two components. FlowLayout supports three constructors (see listing 5.16) that enable you
to specify where the components should be aligned
(CENTER, LEFT, and RIGHT), and also what the default space between each should be. As with all layout managers,
components are added using the add() method.
</P>

<P>Listing 5.16FlowLayout Constructors
</P>

<PRE>
//Default constructor, aligns components center, and uses
//a five pixel horizontal and vertical gap
public FlowLayout();

//Aligns components &quot;align&quot; (LEFT, RIGHT, or CENTER), and uses
//a five pixel horizontal and vertical gap
public FlowLayout(int align);

//Aligns components &quot;align&quot; (LEFT, RIGHT, or CENTER), and uses
//a five &quot;hgap&quot; horizontal gap and a &quot;vgap&quot; vertical gap
public FlowLayout(int align, int hgap, int vgap);
</PRE>


<P><CENTER>
<a href="0147-0152.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0158-0161.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



