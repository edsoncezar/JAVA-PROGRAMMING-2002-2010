<HTML>
<HEAD>


<TITLE>Industrial Strength Java:AWT Basics:EarthWeb Inc.-</TITLE>






<P><CENTER>
<a href="..\ch04\0116-0118.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0122-0125.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-119"><P>Page 119</P></A>


<H3><A NAME="ch05_ 1">
Chapter 5
</A></H3>

<H2>

AWT Basics

</H2>

<P>Gone are the days when all applications had a simple text interface. Most operating 
systems have graphical user interfaces (GUIs), and users demand that all
applications come equipped in the same fashion, which is great for the user because properly
designed GUIs make applications easier to use. To the developers, however, this new wave
of computing generates mixed feelings. Sure, the user base increases when applications
are easy to use; development time, however, increases if you have to build a pretty front end
to the application. Now developers not only have to spend time writing powerful
applications, but also developing an easy-to-use interface. Fortunately, it has become
increasingly easy to develop a GUI; powerful code generation tools are available, and most
operating systems provide a &quot;windowing toolkit&quot; consisting of pre-written code.
</P>

<P>Although it is relatively easy to make decisions regarding
the development of a platform-dependent toolkit, it is not as easy to
do the same in platform-independent terms because GUI widgets
vary from operating system to operating system&#151;a button in
MacOS looks very different from a button on IRIX.
</P>

<P>Because Java is a platform-independent language, the necessity for
a platform-independent toolkit obviously exists.
</P>

<P>Java's creators have provided the developer community with
the Abstract Window Toolkit (AWT). There has been mixed response
to the AWT because it is lacking many important features, but it
does serve its purpose. This chapter begins with the AWT as a topic
for
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Widget, woodget, willit? Confused? Like most terms in
computing, &quot;widget&quot; is a little confusing; not
to mention silly. The term applies to GUI components: buttons,
scroll-     bars, windows, title bars, and so on.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-120"><P>Page 120</P></A>


<P>discussion, including the pros, cons, and future design plans. The chapter then moves
on to some development with the AWT. In the development sections, you will build a
small application by using many standard AWT components, and some that you build yourself.
</P>

<H3><A NAME="ch05_ 2">
The Great Cross-Platform GUI
</A></H3>

<P>Like most of the Java language, the AWT exists at basically two levels. At one are
the components that most developers use in their applications. This level enables you to
build any screen or form that your application requests. There are classes for scrollbars,
menus, buttons, and so on. All these components are based on the next level of
AWT&#151;peer classes. These classes are primarily compromised of
native methods and actually provide the visual implementation of the components. Peer classes are native because
each operating system deals with widgets in a unique fashion. Because the actual visual feel
is created by native methods, you will find that the same piece of Java code generates
a screen with a &quot;Windows feel&quot; when run under Windows NT, and a screen with a
&quot;Mac feel&quot; when run under MacOS.
</P>

<P>In addition to providing a Java interface to the native windowing system, Java
provides screen layout tools called layout
managers. If you are accustomed to developing with native windowing toolkits, chances are you are familiar with laying out screens in terms
of pixels. If your code is going to offer the luxury of functionality across multiple
platforms, you cannot afford to layout screens in terms of pixels. After all, what would happen if
you created a screen that looked great on systems where buttons are oval, and then ran
that same screen on a system where buttons are square? Chances are that one screen
would have overlapping components.
</P>

<P>Instead of providing a standard of pixel-based screen layout,
Java provides a series of LayoutManager classes that enable you to
build screens in terms of relative positioning. In a nutshell, this means
that instead of telling the VM to place a button at (0, 0) and another at 
(0, 10), you tell the VM to place one button to the right of the
other. In addition, you can do things such as tell the VM to place
components at relative screen positions&#151;one button at the top of the
screen and one button on the left side. This topic is discussed later in
the section on the LayoutManager classes provided by the AWT.
</P>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A native method is defined as a platform- dependent piece
of code usually written in C.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>

<A NAME="PAGENUM-121"><P>Page 121</P></A>


<H3><A NAME="ch05_ 3">
Function versus Aesthetics <BR>
of the AWT
</A></H3>

<P>It is true that the AWT fulfills its promise of providing a cross-platform GUI
toolkit. Unfortunately, the manner in which it does this is clanky, and complex screens are hard
to build properly. As you work with the AWT more, you will likely become frustrated with
it as a whole. On the positive side, improvements are always being worked on; JavaSoft
does not claim to have provided a perfect implementation.
</P>

<P>One of the biggest drawbacks to the AWT is the level of difficulty required to
build screens that are visually appealing on all platforms. It is easy to build a functional
screen, but as stated earlier, an application's success often hinges on its GUI; an awkward
hard-to-use GUI rarely sells. Developers often struggle with screen building because only one
lay-     out manager gives you the control you need over your screens, and this layout
manager&#151;GridBagLayout&#151;is not the easiest thing to learn.
</P>

<H3><A NAME="ch05_ 4">
Event Management in Java
</A></H3>

<P>The manner in which events are managed in a Java application is a topic which
deserves much discussion. Up until the Java 1.1 release, a hierarchical event model was
used. However, Java 1.1 brings a delegation-based event model. The two are very different,
and some discussion on the topic is needed.
</P>

<P>In a hierarchical event model, events propagate from the component where the
event occurred up the inheritance hierarchy; stopping when a method processes the event. In
a delegation-based event model, events propagate from their source directly to
registered listeners.
</P>

<P>In covering the AWT, it is tricky to decide which event model to employ in ones code.
On one hand, it is important to cover the Java 1.0 hierarchical model because it is in place
on thousands of systems. Developers working on preexisting systems will most likely
be working with the Java 1.0 model. However, the Java 1.1 delegation-based model is
much more efficient and deserves discussion as well.
</P>


<P><CENTER>
<a href="..\ch04\0116-0118.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0122-0125.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



