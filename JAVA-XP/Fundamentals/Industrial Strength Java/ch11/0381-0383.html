<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Advanced Networking:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0377-0380.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0384-0388.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-381"><P>Page 381</P></A>





<P>In both of these cases, your server computes the elapsed time.
In the stateless approach, the client supplies all the information
the server needs to perform its task (that is, the start-time value).
If your network contains several elapsed time servers (with
synchronized clocks), your client can open the connection to a
different server each time and still obtain an accurate computation of
the elapsed time (again ignoring network delays). Any server
can compute the elapsed time because the client maintains the
complete state information and sends it with every request. (Note that
this stateless example uses TCP. If based on UDP, the
client/server protocol would be complicated by adding retransmission
and sequencing techniques to ensure reliable delivery.)
</P>

<H4><A NAME="ch11_ 4">
Picking Your Protocols
</A></H4>

<P>If necessary, you can use several different protocols to
accomplish the varied tasks required by the application. You can design a
new client/server protocol from scratch, but why bother? The
Internet protocol family has benefited from many hundreds of thousands
of hours of design work, as well as testing by several
thousand contributors. If a defined Internet client/server protocol suits
your task, use it. Select a protocol by scanning the list of Internet
RFCs for a match in function. The effort you spend looking for a
predefined protocol will more than compensate you by
avoiding protocol design problems that emerge later when the
client/server application is deployed. Among other issues, client/server
protocol design must consider race conditions, failure modes, and
the transmission characteristics of the Internet environment. Figure
11.2 lists the most commonly used Internet protocols.
</P>

<P>By using a standard protocol, you often can obtain the
client-side application commercially. Many application situations exist to
allow you to use standard client software and tailor the server to meet
your needs. For example, you will use a web browser client for
server status monitoring in a later example.
</P>

<P>The Simple Message Transport Protocol (SMTP) is the
Internet standard for carrying mail between mail servers. Although not explicitly mentioned in
the specification, the SMTP also can send e-mail from a client to a server. Post
Office Protocol version 3 (POP3) is one standard approach for a client to retrieve mail from
a server-based mail storage area, and many commercially available e-mail client
packages support the popular SMTP/POP protocol 
</P>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Internet protocols are documented in Requests For
Comment (RFCs). RFCs have been used since the beginning
of Internet development as a permanent record to document
information exchanges between researchers and implementers.
The first RFC was issued in 1969; now, over 2,000 exist. Not every
RFC specifies an Internet protocol standard, however. In the
last few years, the author classifies every new RFC  as
informational, experimental, preliminary standard, draft standard,
or Internet standard. Unlike many other standards, you
can easily download RFCs from <a href="http://ds./">
http://ds.</A><BR>
internet.net/ds. In addition, the file rfc-index.html contains
a list of all RFCs in reverse numerical order, beginning
with the most recent.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<A NAME="PAGENUM-382"><P>Page 382</P></A>



<P>combination. Although a variety of database access protocols exist, ranging in complexity from simple to full-featured query
languages, you decide on an HTTP/CGI query approach to access the name/address
database. These three protocols&#151;SMTP, POP, and HTTP&#151;form the foundation of your
e-mail server application.
</P>


<P><a href="images\ch11fg02.jpg"><img src="images\tn_ch11fg02.jpg"></a><BR>
Figure 11.2
Commonly used Internet protocols.
</P>

<H3><A NAME="ch11_ 5">
Server-Specific Issues
</A></H3>

<P>Servers are different from ordinary applications or applets in a variety of ways. For
applet developers or user-interface intensive applications, Java provides standard toolkits, such
as AWT, to simplify development. Java 1.0 provides more support than most systems
for client-side network communications, but the language still lacks many facilities for
server development. Next, you will develop classes tailored for constructing servers in the
same way that the core Java packages provide applet support.
</P>

<P>In designing these classes, consider how a typical network server application differs
from a regular Java application:
</P>

<UL>
<LI>          The Internet standard for date/time format differs from that used by standard Java.
<LI>          The end-of-line sequence for Java (\n) differs from the Internet standard (\r\n).
<LI>          Efficient use of network resources ranks as an important consideration.
<LI>          Client activity monitoring protects against disconnected clients.
</UL>

<A NAME="PAGENUM-383"><P>Page 383</P></A>





<P>Although these issues are often ignored in client development, you must develop a
server application framework to assist in coding servers. This should include classes for
Internet date, output stream, and command input.
</P>

<H3><A NAME="ch11_ 6">
InetDate Class
</A></H3>

<P>Unfortunately, the Java date/time class does not produce the exact Internet standard
date/time format. RFCs 822 and 1123 specify the preferred time format as a
three-letter abbreviated day of the week, followed by the date, a four-digit year, and the GMT
time. An example of the standard date/time format follows:
</P>

<BLOCKQUOTE>
Sun, 06 Nov 1994 08:49:37 GMT
</BLOCKQUOTE>


<P>The InetDate class is a subclass of the standard Java Date class
that provides the correct format. The extra constructors that deal with
the many ways to create a Date object have been removed from
the sample code, but you should define them in your package.
The InetDate class overrides the toString() method of Date to add the
day of the week abbreviation to the string and produce a fixed
two-character date field, as shown in the following code.
</P>

<PRE>
class InetDate extends Date {
    public InetDate () {
    super();
    }

    public InetDate (String date) {
    super(date);
    }

    private final static String dayOfWeek[] = {
    &quot;Sun, &quot;, &quot;Mon, &quot;, &quot;Tue, &quot;, &quot;Wed, &quot;, &quot;Thu, &quot;, &quot;Fri,
     &Acirc;&quot;, &quot;Sat, &quot;
    };

    public String toString() {
    if (this.getDate() &lt; 10)
      return (dayOfWeek[this.getDay()] + &quot;0&quot; +
     &Acirc;this.toGMTString());
    else
      return (dayOfWeek[this.getDay()] +
     &Acirc;this.toGMTString());
    }

  }

</PRE>

<BR>
<P>

<CENTER>
<TABLE BGCOLOR="#FFFF99">
<TR><TD><B>
NOTE
</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
JavaSoft is developing a server support package
called Jeeves, which provides support for writing
general-purpose servers, as well as special HTTP-based servlets.
The classes you develop in this chapter are similar to, but
different from, those in Jeeves. Because Jeeves exists only in
alpha release at the time of publication, detailed API comparisons
with JavaSoft's package are not possible. However, this
book notes significant design and philosophy similarities
when applicable.
</BLOCKQUOTE></TD></TR>
</TABLE></CENTER>
</P>


<P><CENTER>
<a href="0377-0380.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0384-0388.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



