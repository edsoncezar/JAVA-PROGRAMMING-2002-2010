<HTML>
<HEAD>


<TITLE>Industrial Strength Java:Planning Your Application:EarthWeb Inc.-</TITLE>





<P><CENTER>
<a href="0058-0061.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0067-0071.html">Next</A>
</CENTER></P>

<A NAME="PAGENUM-62"><P>Page 62</P></A>


<P>Listing 3.9 shows the ClassA1 class of package1. The class has a public method
called publicMethod(), which is visible to all classes in all packages. The method creates
an instance of ClassA2 and calls its defaultMethod().
</P>

<P>Listing 3.9The Class package1.ClassA1
</P>

<PRE>
/** ClassA1.java
*/
package package1;
// public class modifier
public class ClassA1{
    public void publicMethod(){
        System.out.println(&quot;package1.ClassA1: This is a public method&quot;);
        ClassB1 b1 = new ClassB1(); // class visible within package
        b1.defaultMethod(); // method visible within package
    }
    void defaultMethod(){
        System.out.println(&quot;package1.ClassA1: This is a default
                &Acirc;method&quot;);
    }
}
</PRE>

<P>Listing 3.10 shows the ClassB1 class of package1. The class has a public
method, publicMethod(), which is visible to all classes in all packages. The method creates
an instance of ClassB2 and calls its defaultMethod(). Like the default method in ClassA1,
the defaultMethod() in this class prints a string to the console acknowledging that it was called.
</P>

<P>Listing 3.10The Class package1.ClassB1
</P>

<PRE>
/** ClassB1.java
*/
package package1;
// default class modifier
class ClassB1{
    public void publicMethod(){
        System.out.println(&quot;package1.ClassB1: This is a public method&quot;);
        ClassA1 a1 = new ClassA1(); // class visible within package
        a1.defaultMethod(); // method visible within package
    }
    void defaultMethod(){
        System.out.println(&quot;package1.ClassB1: This is a default
method&quot;);
    }
}
</PRE>


<A NAME="PAGENUM-63"><P>Page 63</P></A>


<P>The classes in listings 3.11 and 3.12 are almost identical to those of 3.9 and 3.10. The
only differences are in the names of the classes and the fact that they only attempt to call
the defaultMethod() of classes within package2.
</P>

<P>Listing 3.11The Class package2.ClassA2
</P>

<PRE>
/** ClassA2
*/
package package2;
// public class modifier
public class ClassA2{
    public void publicMethod(){
        System.out.println(&quot;package2.ClassB2: This is a public method&quot;);
        ClassB2 b2 = new ClassB2(); // class visible within package
        b2.defaultMethod(); // method visible within package
    }
    void defaultMethod(){
        System.out.println(&quot;package2.ClassB2: This is a default
method&quot;);
    }
}
</PRE>

<P>Listing 3.12The Class package2.ClassB2
</P>

<PRE>
package package2;
/** ClassB2
*/
// default class modifier
class ClassB2{
    public void publicMethod(){
        System.out.println(&quot;package2.ClassB2: This is a public method&quot;);
        ClassA2 a2 = new ClassA2(); // class visible within package
        a2.defaultMethod(); // method visible within package
    }
    void defaultMethod(){
        System.out.println(&quot;package2.ClassB2: This is a default
method&quot;);
    }

}

</PRE>
<PRE>
                                                            continues
</PRE>

<A NAME="PAGENUM-64"><P>Page 64</P></A>


<P>Listing 3.13Continued
</P>

<P>In listing 3.13, the testing is done to prove that the visibility is correct, and the
proper information about the method call sequence is printed by each method called. When
this method was first compiled, the code line that attempted to call defaultMethod() of each
of the packaged classes failed. They were commented in order to compile the final
application.
</P>

<P>Listing 3.13The Class pkg_test: Tests Java Package Visibility
</P>

<PRE>
/** pkg_test.java
*/
import package1.*;
import package2.*;
import java.awt.*;
import java.io.IOException;

public class pkg_test {

    public static void main(String args[]) {
        System.out.println(&quot;package test&quot;);
        System.out.println(&quot;&quot;);

        ClassA1 pA1 = new ClassA1();
        //ClassB1 pB1 = new ClassB1(); - not visible to this class
        ClassA2 pA2 = new ClassA2();
        //ClassB2 pB2 = new ClassB2(); - not visible to this class
        pA1.publicMethod();
        //pA1.defaultMethod();- not visible to this class
        pA2.publicMethod();
        //pA2.defaultMethod();- not visible to this class

        System.out.println(&quot;&quot;);
        System.out.println(&quot;(press Enter to exit)&quot;);
        try {
            System.in.read();
        } catch (IOException e) {
            return;
        }
    }
}
</PRE>

<H4>
Directory Structure
</H4>

<P>Packages are stored in directories that have the same name and case as the
package. Packages are searched from the base of each class path directory. For example, the code
in
</P>


<A NAME="PAGENUM-65"><P>Page 65</P></A>


<P>listing 3.9 through 3.13 was stored as follows:
</P>

<P>Listing 3.14A Directory Listing Showing File Locations of Packages
</P>

<PRE>
d:\java\industrial\pkg_test\   &lt;- root directory of the application
d:\java\industrial\pkg_test\pkg_test.class
d:\java\industrial\pkg_test\package1\ClassA1.class
d:\java\industrial\pkg_test\package1\ClassB1.class
d:\java\industrial\pkg_test\package2\ClassA2.class
d:\java\industrial\pkg_test\package2\ClassB2.class
</PRE>

<P>From the application root directory, two additional directories make up each of the
two packages that were compiled. The class files of each of these packages were stored by
the compiler into their respective directories. Because the application was executed from
the pkg_test directory, the Java VM searched the tree for the package1 and package2
directories when imports of the packages were made inside of the pkg_test.class file. If
the package1 and package2 packages were used by an application in another directory,
the CLASSPATH environment variable would need to have the directory
d:\java\industrial\pkg_test\  appended to the existing path string.
</P>

<H3><A NAME="ch03_ 25">
Dynamic Class Loading
</A></H3>

<P>Dynamic class loading enables a new object of a class to be instantiated from object
code that was not specified when the program was first compiled. This becomes useful
for several software constructs, like object persistence or plug-and-play libraries. The
class creating the new object will still need to have a way of casting the new objects to a
class where the interface is understood. The minimum functionality is a class of Object.
This enables you to load any public class and perform the same functions that can be done
on any object class.
</P>

<P>Loading a class dynamically can be a powerful tool to create versatile programs. A
good example why a class would be loaded at runtime is a graphics editor that supports
differing image formats that can be purchased separately. The code to read and write
the formats would be supplied as class files. In this model, the editor would know about
the base class of these new classes and the interfaces that they support. When the
graphics editor requires a specific format, the class loader loads a copy of the class by name.
Once in memory, new instances can be created from the class.
</P>

<P>Normally, use this facility with a useful base class that a group of classes extends or
with
</P>

<A NAME="PAGENUM-66"><P>Page 66</P></A>


<P>classes that implement specific interfaces.
</P>

<P>There are a few restrictions to the types of classes that can be loaded:
</P>

<UL>
<LI>     The class must have at least one constructor that requires no arguments.
<LI>     The class must be accessible to the class that loads it.
</UL>

<P>The code in listing 3.15a dynamically loads two classes, creates an object of that
class, and prints Object and Class information.
</P>

<P>Listing 3.15aThe Class ClassLoad: Imports, Class Definition, and the
main() Method
</P>

<PRE>
import java.awt.*;
import java.io.IOException;

public class ClassLoad {

    public static void main(String args[]) {
        new ClassLoad();
    }
</PRE>

<P>Listing 3.15b defines the ClassLoad class contructor to run a test.
</P>

<P>Listing 3.15bThe Class ClassLoad
</P>

<PRE>
    ClassLoad(){
        try{
            System.out.println(&quot;demonstration of class load.&quot;);
            System.out.println();
            System.out.println(&quot;Creating an object of Foo&quot;);
            Object foo = getObjectOfClass(&quot;Foo&quot;);
            objectAnalyze(foo);
            System.out.println();
            System.out.println(&quot;Creating an object of Bar&quot;);
            Object bar = getObjectOfClass(&quot;Bar&quot;);
            objectAnalyze(bar);
            System.out.println();
            System.out.println(&quot;(press Enter to exit)&quot;);
        } catch(Exception ex){
            System.out.println(&quot;Class load failed.&quot;);
        }

        try {
</PRE>


<P><CENTER>
<a href="0058-0061.html">Previous</A> | <a href="..\ewtoc.html">Table of Contents</A> | <a href="0067-0071.html">Next</A>
</CENTER></P>






</BODY>
</HTML>



